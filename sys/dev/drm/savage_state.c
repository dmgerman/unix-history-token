begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* savage_state.c -- State and drawing support for Savage  *  * Copyright 2004  Felix Kuehling  * All Rights Reserved.  *  * Permission is hereby granted, free of charge, to any person obtaining a  * copy of this software and associated documentation files (the "Software"),  * to deal in the Software without restriction, including without limitation  * the rights to use, copy, modify, merge, publish, distribute, sub license,  * and/or sell copies of the Software, and to permit persons to whom the  * Software is furnished to do so, subject to the following conditions:  *  * The above copyright notice and this permission notice (including the  * next paragraph) shall be included in all copies or substantial portions  * of the Software.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  * NON-INFRINGEMENT. IN NO EVENT SHALL FELIX KUEHLING BE LIABLE FOR  * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF  * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|"drmP.h"
end_include

begin_include
include|#
directive|include
file|"savage_drm.h"
end_include

begin_include
include|#
directive|include
file|"savage_drv.h"
end_include

begin_function
name|void
name|savage_emit_clip_rect_s3d
parameter_list|(
name|drm_savage_private_t
modifier|*
name|dev_priv
parameter_list|,
name|drm_clip_rect_t
modifier|*
name|pbox
parameter_list|)
block|{
name|uint32_t
name|scstart
init|=
name|dev_priv
operator|->
name|state
operator|.
name|s3d
operator|.
name|new_scstart
decl_stmt|;
name|uint32_t
name|scend
init|=
name|dev_priv
operator|->
name|state
operator|.
name|s3d
operator|.
name|new_scend
decl_stmt|;
name|scstart
operator|=
operator|(
name|scstart
operator|&
operator|~
name|SAVAGE_SCISSOR_MASK_S3D
operator|)
operator||
operator|(
operator|(
name|uint32_t
operator|)
name|pbox
operator|->
name|x1
operator|&
literal|0x000007ff
operator|)
operator||
operator|(
operator|(
operator|(
name|uint32_t
operator|)
name|pbox
operator|->
name|y1
operator|<<
literal|16
operator|)
operator|&
literal|0x07ff0000
operator|)
expr_stmt|;
name|scend
operator|=
operator|(
name|scend
operator|&
operator|~
name|SAVAGE_SCISSOR_MASK_S3D
operator|)
operator||
operator|(
operator|(
operator|(
name|uint32_t
operator|)
name|pbox
operator|->
name|x2
operator|-
literal|1
operator|)
operator|&
literal|0x000007ff
operator|)
operator||
operator|(
operator|(
operator|(
operator|(
name|uint32_t
operator|)
name|pbox
operator|->
name|y2
operator|-
literal|1
operator|)
operator|<<
literal|16
operator|)
operator|&
literal|0x07ff0000
operator|)
expr_stmt|;
if|if
condition|(
name|scstart
operator|!=
name|dev_priv
operator|->
name|state
operator|.
name|s3d
operator|.
name|scstart
operator|||
name|scend
operator|!=
name|dev_priv
operator|->
name|state
operator|.
name|s3d
operator|.
name|scend
condition|)
block|{
name|DMA_LOCALS
expr_stmt|;
name|BEGIN_DMA
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|DMA_WRITE
argument_list|(
name|BCI_CMD_WAIT
operator||
name|BCI_CMD_WAIT_3D
argument_list|)
expr_stmt|;
name|DMA_SET_REGISTERS
argument_list|(
name|SAVAGE_SCSTART_S3D
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|DMA_WRITE
argument_list|(
name|scstart
argument_list|)
expr_stmt|;
name|DMA_WRITE
argument_list|(
name|scend
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|state
operator|.
name|s3d
operator|.
name|scstart
operator|=
name|scstart
expr_stmt|;
name|dev_priv
operator|->
name|state
operator|.
name|s3d
operator|.
name|scend
operator|=
name|scend
expr_stmt|;
name|dev_priv
operator|->
name|waiting
operator|=
literal|1
expr_stmt|;
name|DMA_COMMIT
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|savage_emit_clip_rect_s4
parameter_list|(
name|drm_savage_private_t
modifier|*
name|dev_priv
parameter_list|,
name|drm_clip_rect_t
modifier|*
name|pbox
parameter_list|)
block|{
name|uint32_t
name|drawctrl0
init|=
name|dev_priv
operator|->
name|state
operator|.
name|s4
operator|.
name|new_drawctrl0
decl_stmt|;
name|uint32_t
name|drawctrl1
init|=
name|dev_priv
operator|->
name|state
operator|.
name|s4
operator|.
name|new_drawctrl1
decl_stmt|;
name|drawctrl0
operator|=
operator|(
name|drawctrl0
operator|&
operator|~
name|SAVAGE_SCISSOR_MASK_S4
operator|)
operator||
operator|(
operator|(
name|uint32_t
operator|)
name|pbox
operator|->
name|x1
operator|&
literal|0x000007ff
operator|)
operator||
operator|(
operator|(
operator|(
name|uint32_t
operator|)
name|pbox
operator|->
name|y1
operator|<<
literal|12
operator|)
operator|&
literal|0x00fff000
operator|)
expr_stmt|;
name|drawctrl1
operator|=
operator|(
name|drawctrl1
operator|&
operator|~
name|SAVAGE_SCISSOR_MASK_S4
operator|)
operator||
operator|(
operator|(
operator|(
name|uint32_t
operator|)
name|pbox
operator|->
name|x2
operator|-
literal|1
operator|)
operator|&
literal|0x000007ff
operator|)
operator||
operator|(
operator|(
operator|(
operator|(
name|uint32_t
operator|)
name|pbox
operator|->
name|y2
operator|-
literal|1
operator|)
operator|<<
literal|12
operator|)
operator|&
literal|0x00fff000
operator|)
expr_stmt|;
if|if
condition|(
name|drawctrl0
operator|!=
name|dev_priv
operator|->
name|state
operator|.
name|s4
operator|.
name|drawctrl0
operator|||
name|drawctrl1
operator|!=
name|dev_priv
operator|->
name|state
operator|.
name|s4
operator|.
name|drawctrl1
condition|)
block|{
name|DMA_LOCALS
expr_stmt|;
name|BEGIN_DMA
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|DMA_WRITE
argument_list|(
name|BCI_CMD_WAIT
operator||
name|BCI_CMD_WAIT_3D
argument_list|)
expr_stmt|;
name|DMA_SET_REGISTERS
argument_list|(
name|SAVAGE_DRAWCTRL0_S4
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|DMA_WRITE
argument_list|(
name|drawctrl0
argument_list|)
expr_stmt|;
name|DMA_WRITE
argument_list|(
name|drawctrl1
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|state
operator|.
name|s4
operator|.
name|drawctrl0
operator|=
name|drawctrl0
expr_stmt|;
name|dev_priv
operator|->
name|state
operator|.
name|s4
operator|.
name|drawctrl1
operator|=
name|drawctrl1
expr_stmt|;
name|dev_priv
operator|->
name|waiting
operator|=
literal|1
expr_stmt|;
name|DMA_COMMIT
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|savage_verify_texaddr
parameter_list|(
name|drm_savage_private_t
modifier|*
name|dev_priv
parameter_list|,
name|int
name|unit
parameter_list|,
name|uint32_t
name|addr
parameter_list|)
block|{
if|if
condition|(
operator|(
name|addr
operator|&
literal|6
operator|)
operator|!=
literal|2
condition|)
block|{
comment|/* reserved bits */
name|DRM_ERROR
argument_list|(
literal|"bad texAddr%d %08x (reserved bits)\n"
argument_list|,
name|unit
argument_list|,
name|addr
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|addr
operator|&
literal|1
operator|)
condition|)
block|{
comment|/* local */
name|addr
operator|&=
operator|~
literal|7
expr_stmt|;
if|if
condition|(
name|addr
operator|<
name|dev_priv
operator|->
name|texture_offset
operator|||
name|addr
operator|>=
name|dev_priv
operator|->
name|texture_offset
operator|+
name|dev_priv
operator|->
name|texture_size
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"bad texAddr%d %08x (local addr out of range)\n"
argument_list|,
name|unit
argument_list|,
name|addr
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
block|}
else|else
block|{
comment|/* AGP */
if|if
condition|(
operator|!
name|dev_priv
operator|->
name|agp_textures
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"bad texAddr%d %08x (AGP not available)\n"
argument_list|,
name|unit
argument_list|,
name|addr
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
name|addr
operator|&=
operator|~
literal|7
expr_stmt|;
if|if
condition|(
name|addr
operator|<
name|dev_priv
operator|->
name|agp_textures
operator|->
name|offset
operator|||
name|addr
operator|>=
operator|(
name|dev_priv
operator|->
name|agp_textures
operator|->
name|offset
operator|+
name|dev_priv
operator|->
name|agp_textures
operator|->
name|size
operator|)
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"bad texAddr%d %08x (AGP addr out of range)\n"
argument_list|,
name|unit
argument_list|,
name|addr
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_define
define|#
directive|define
name|SAVE_STATE
parameter_list|(
name|reg
parameter_list|,
name|where
parameter_list|)
define|\
value|if(start<= reg&& start+count> reg)	\ 		DRM_GET_USER_UNCHECKED(dev_priv->state.where,&regs[reg-start])
end_define

begin_define
define|#
directive|define
name|SAVE_STATE_MASK
parameter_list|(
name|reg
parameter_list|,
name|where
parameter_list|,
name|mask
parameter_list|)
value|do {			\ 	if(start<= reg&& start+count> reg) {			\ 		uint32_t tmp;					\ 		DRM_GET_USER_UNCHECKED(tmp,&regs[reg-start]);	\ 		dev_priv->state.where = (tmp& (mask)) |	\ 			(dev_priv->state.where& ~(mask));	\ 	}							\ } while (0)
end_define

begin_function
specifier|static
name|int
name|savage_verify_state_s3d
parameter_list|(
name|drm_savage_private_t
modifier|*
name|dev_priv
parameter_list|,
name|unsigned
name|int
name|start
parameter_list|,
name|unsigned
name|int
name|count
parameter_list|,
specifier|const
name|uint32_t
name|__user
modifier|*
name|regs
parameter_list|)
block|{
if|if
condition|(
name|start
operator|<
name|SAVAGE_TEXPALADDR_S3D
operator|||
name|start
operator|+
name|count
operator|-
literal|1
operator|>
name|SAVAGE_DESTTEXRWWATERMARK_S3D
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"invalid register range (0x%04x-0x%04x)\n"
argument_list|,
name|start
argument_list|,
name|start
operator|+
name|count
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
name|SAVE_STATE_MASK
argument_list|(
name|SAVAGE_SCSTART_S3D
argument_list|,
name|s3d
operator|.
name|new_scstart
argument_list|,
operator|~
name|SAVAGE_SCISSOR_MASK_S3D
argument_list|)
expr_stmt|;
name|SAVE_STATE_MASK
argument_list|(
name|SAVAGE_SCEND_S3D
argument_list|,
name|s3d
operator|.
name|new_scend
argument_list|,
operator|~
name|SAVAGE_SCISSOR_MASK_S3D
argument_list|)
expr_stmt|;
comment|/* if any texture regs were changed ... */
if|if
condition|(
name|start
operator|<=
name|SAVAGE_TEXCTRL_S3D
operator|&&
name|start
operator|+
name|count
operator|>
name|SAVAGE_TEXPALADDR_S3D
condition|)
block|{
comment|/* ... check texture state */
name|SAVE_STATE
argument_list|(
name|SAVAGE_TEXCTRL_S3D
argument_list|,
name|s3d
operator|.
name|texctrl
argument_list|)
expr_stmt|;
name|SAVE_STATE
argument_list|(
name|SAVAGE_TEXADDR_S3D
argument_list|,
name|s3d
operator|.
name|texaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|state
operator|.
name|s3d
operator|.
name|texctrl
operator|&
name|SAVAGE_TEXCTRL_TEXEN_MASK
condition|)
return|return
name|savage_verify_texaddr
argument_list|(
name|dev_priv
argument_list|,
literal|0
argument_list|,
name|dev_priv
operator|->
name|state
operator|.
name|s3d
operator|.
name|texaddr
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|savage_verify_state_s4
parameter_list|(
name|drm_savage_private_t
modifier|*
name|dev_priv
parameter_list|,
name|unsigned
name|int
name|start
parameter_list|,
name|unsigned
name|int
name|count
parameter_list|,
specifier|const
name|uint32_t
name|__user
modifier|*
name|regs
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|start
operator|<
name|SAVAGE_DRAWLOCALCTRL_S4
operator|||
name|start
operator|+
name|count
operator|-
literal|1
operator|>
name|SAVAGE_TEXBLENDCOLOR_S4
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"invalid register range (0x%04x-0x%04x)\n"
argument_list|,
name|start
argument_list|,
name|start
operator|+
name|count
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
name|SAVE_STATE_MASK
argument_list|(
name|SAVAGE_DRAWCTRL0_S4
argument_list|,
name|s4
operator|.
name|new_drawctrl0
argument_list|,
operator|~
name|SAVAGE_SCISSOR_MASK_S4
argument_list|)
expr_stmt|;
name|SAVE_STATE_MASK
argument_list|(
name|SAVAGE_DRAWCTRL1_S4
argument_list|,
name|s4
operator|.
name|new_drawctrl1
argument_list|,
operator|~
name|SAVAGE_SCISSOR_MASK_S4
argument_list|)
expr_stmt|;
comment|/* if any texture regs were changed ... */
if|if
condition|(
name|start
operator|<=
name|SAVAGE_TEXDESCR_S4
operator|&&
name|start
operator|+
name|count
operator|>
name|SAVAGE_TEXPALADDR_S4
condition|)
block|{
comment|/* ... check texture state */
name|SAVE_STATE
argument_list|(
name|SAVAGE_TEXDESCR_S4
argument_list|,
name|s4
operator|.
name|texdescr
argument_list|)
expr_stmt|;
name|SAVE_STATE
argument_list|(
name|SAVAGE_TEXADDR0_S4
argument_list|,
name|s4
operator|.
name|texaddr0
argument_list|)
expr_stmt|;
name|SAVE_STATE
argument_list|(
name|SAVAGE_TEXADDR1_S4
argument_list|,
name|s4
operator|.
name|texaddr1
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|state
operator|.
name|s4
operator|.
name|texdescr
operator|&
name|SAVAGE_TEXDESCR_TEX0EN_MASK
condition|)
name|ret
operator||=
name|savage_verify_texaddr
argument_list|(
name|dev_priv
argument_list|,
literal|0
argument_list|,
name|dev_priv
operator|->
name|state
operator|.
name|s4
operator|.
name|texaddr0
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|state
operator|.
name|s4
operator|.
name|texdescr
operator|&
name|SAVAGE_TEXDESCR_TEX1EN_MASK
condition|)
name|ret
operator||=
name|savage_verify_texaddr
argument_list|(
name|dev_priv
argument_list|,
literal|1
argument_list|,
name|dev_priv
operator|->
name|state
operator|.
name|s4
operator|.
name|texaddr1
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|SAVE_STATE
end_undef

begin_undef
undef|#
directive|undef
name|SAVE_STATE_MASK
end_undef

begin_function
specifier|static
name|int
name|savage_dispatch_state
parameter_list|(
name|drm_savage_private_t
modifier|*
name|dev_priv
parameter_list|,
specifier|const
name|drm_savage_cmd_header_t
modifier|*
name|cmd_header
parameter_list|,
specifier|const
name|uint32_t
name|__user
modifier|*
name|regs
parameter_list|)
block|{
name|DMA_LOCALS
expr_stmt|;
name|unsigned
name|int
name|count
init|=
name|cmd_header
operator|->
name|state
operator|.
name|count
decl_stmt|;
name|unsigned
name|int
name|start
init|=
name|cmd_header
operator|->
name|state
operator|.
name|start
decl_stmt|;
name|unsigned
name|int
name|count2
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|bci_size
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
operator|!
name|count
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|DRM_VERIFYAREA_READ
argument_list|(
name|regs
argument_list|,
name|count
operator|*
literal|4
argument_list|)
condition|)
return|return
name|DRM_ERR
argument_list|(
name|EFAULT
argument_list|)
return|;
if|if
condition|(
name|S3_SAVAGE3D_SERIES
argument_list|(
name|dev_priv
operator|->
name|chipset
argument_list|)
condition|)
block|{
name|ret
operator|=
name|savage_verify_state_s3d
argument_list|(
name|dev_priv
argument_list|,
name|start
argument_list|,
name|count
argument_list|,
name|regs
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
return|return
name|ret
return|;
comment|/* scissor regs are emitted in savage_dispatch_draw */
if|if
condition|(
name|start
operator|<
name|SAVAGE_SCSTART_S3D
condition|)
block|{
if|if
condition|(
name|start
operator|+
name|count
operator|>
name|SAVAGE_SCEND_S3D
operator|+
literal|1
condition|)
name|count2
operator|=
name|count
operator|-
operator|(
name|SAVAGE_SCEND_S3D
operator|+
literal|1
operator|-
name|start
operator|)
expr_stmt|;
if|if
condition|(
name|start
operator|+
name|count
operator|>
name|SAVAGE_SCSTART_S3D
condition|)
name|count
operator|=
name|SAVAGE_SCSTART_S3D
operator|-
name|start
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|start
operator|<=
name|SAVAGE_SCEND_S3D
condition|)
block|{
if|if
condition|(
name|start
operator|+
name|count
operator|>
name|SAVAGE_SCEND_S3D
operator|+
literal|1
condition|)
block|{
name|count
operator|-=
name|SAVAGE_SCEND_S3D
operator|+
literal|1
operator|-
name|start
expr_stmt|;
name|start
operator|=
name|SAVAGE_SCEND_S3D
operator|+
literal|1
expr_stmt|;
block|}
else|else
return|return
literal|0
return|;
block|}
block|}
else|else
block|{
name|ret
operator|=
name|savage_verify_state_s4
argument_list|(
name|dev_priv
argument_list|,
name|start
argument_list|,
name|count
argument_list|,
name|regs
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
return|return
name|ret
return|;
comment|/* scissor regs are emitted in savage_dispatch_draw */
if|if
condition|(
name|start
operator|<
name|SAVAGE_DRAWCTRL0_S4
condition|)
block|{
if|if
condition|(
name|start
operator|+
name|count
operator|>
name|SAVAGE_DRAWCTRL1_S4
operator|+
literal|1
condition|)
name|count2
operator|=
name|count
operator|-
operator|(
name|SAVAGE_DRAWCTRL1_S4
operator|+
literal|1
operator|-
name|start
operator|)
expr_stmt|;
if|if
condition|(
name|start
operator|+
name|count
operator|>
name|SAVAGE_DRAWCTRL0_S4
condition|)
name|count
operator|=
name|SAVAGE_DRAWCTRL0_S4
operator|-
name|start
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|start
operator|<=
name|SAVAGE_DRAWCTRL1_S4
condition|)
block|{
if|if
condition|(
name|start
operator|+
name|count
operator|>
name|SAVAGE_DRAWCTRL1_S4
operator|+
literal|1
condition|)
block|{
name|count
operator|-=
name|SAVAGE_DRAWCTRL1_S4
operator|+
literal|1
operator|-
name|start
expr_stmt|;
name|start
operator|=
name|SAVAGE_DRAWCTRL1_S4
operator|+
literal|1
expr_stmt|;
block|}
else|else
return|return
literal|0
return|;
block|}
block|}
name|bci_size
operator|=
name|count
operator|+
operator|(
name|count
operator|+
literal|254
operator|)
operator|/
literal|255
operator|+
name|count2
operator|+
operator|(
name|count2
operator|+
literal|254
operator|)
operator|/
literal|255
expr_stmt|;
if|if
condition|(
name|cmd_header
operator|->
name|state
operator|.
name|global
condition|)
block|{
name|BEGIN_DMA
argument_list|(
name|bci_size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|DMA_WRITE
argument_list|(
name|BCI_CMD_WAIT
operator||
name|BCI_CMD_WAIT_3D
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|waiting
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|BEGIN_DMA
argument_list|(
name|bci_size
argument_list|)
expr_stmt|;
block|}
do|do
block|{
while|while
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|unsigned
name|int
name|n
init|=
name|count
operator|<
literal|255
condition|?
name|count
else|:
literal|255
decl_stmt|;
name|DMA_SET_REGISTERS
argument_list|(
name|start
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|DMA_COPY_FROM_USER
argument_list|(
name|regs
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|count
operator|-=
name|n
expr_stmt|;
name|start
operator|+=
name|n
expr_stmt|;
name|regs
operator|+=
name|n
expr_stmt|;
block|}
name|start
operator|+=
literal|2
expr_stmt|;
name|regs
operator|+=
literal|2
expr_stmt|;
name|count
operator|=
name|count2
expr_stmt|;
name|count2
operator|=
literal|0
expr_stmt|;
block|}
do|while
condition|(
name|count
condition|)
do|;
name|DMA_COMMIT
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|savage_dispatch_dma_prim
parameter_list|(
name|drm_savage_private_t
modifier|*
name|dev_priv
parameter_list|,
specifier|const
name|drm_savage_cmd_header_t
modifier|*
name|cmd_header
parameter_list|,
specifier|const
name|drm_buf_t
modifier|*
name|dmabuf
parameter_list|)
block|{
name|BCI_LOCALS
expr_stmt|;
name|unsigned
name|char
name|reorder
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|prim
init|=
name|cmd_header
operator|->
name|prim
operator|.
name|prim
decl_stmt|;
name|unsigned
name|int
name|skip
init|=
name|cmd_header
operator|->
name|prim
operator|.
name|skip
decl_stmt|;
name|unsigned
name|int
name|n
init|=
name|cmd_header
operator|->
name|prim
operator|.
name|count
decl_stmt|;
name|unsigned
name|int
name|start
init|=
name|cmd_header
operator|->
name|prim
operator|.
name|start
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|dmabuf
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"called without dma buffers!\n"
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|n
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|prim
condition|)
block|{
case|case
name|SAVAGE_PRIM_TRILIST_201
case|:
name|reorder
operator|=
literal|1
expr_stmt|;
name|prim
operator|=
name|SAVAGE_PRIM_TRILIST
expr_stmt|;
case|case
name|SAVAGE_PRIM_TRILIST
case|:
if|if
condition|(
name|n
operator|%
literal|3
operator|!=
literal|0
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"wrong number of vertices %u in TRILIST\n"
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
break|break;
case|case
name|SAVAGE_PRIM_TRISTRIP
case|:
case|case
name|SAVAGE_PRIM_TRIFAN
case|:
if|if
condition|(
name|n
operator|<
literal|3
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"wrong number of vertices %u in TRIFAN/STRIP\n"
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
break|break;
default|default:
name|DRM_ERROR
argument_list|(
literal|"invalid primitive type %u\n"
argument_list|,
name|prim
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
if|if
condition|(
name|S3_SAVAGE3D_SERIES
argument_list|(
name|dev_priv
operator|->
name|chipset
argument_list|)
condition|)
block|{
if|if
condition|(
name|skip
operator|!=
literal|0
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"invalid skip flags 0x%04x for DMA\n"
argument_list|,
name|skip
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
block|}
else|else
block|{
name|unsigned
name|int
name|size
init|=
literal|10
operator|-
operator|(
name|skip
operator|&
literal|1
operator|)
operator|-
operator|(
name|skip
operator|>>
literal|1
operator|&
literal|1
operator|)
operator|-
operator|(
name|skip
operator|>>
literal|2
operator|&
literal|1
operator|)
operator|-
operator|(
name|skip
operator|>>
literal|3
operator|&
literal|1
operator|)
operator|-
operator|(
name|skip
operator|>>
literal|4
operator|&
literal|1
operator|)
operator|-
operator|(
name|skip
operator|>>
literal|5
operator|&
literal|1
operator|)
operator|-
operator|(
name|skip
operator|>>
literal|6
operator|&
literal|1
operator|)
operator|-
operator|(
name|skip
operator|>>
literal|7
operator|&
literal|1
operator|)
decl_stmt|;
if|if
condition|(
name|skip
operator|>
name|SAVAGE_SKIP_ALL_S4
operator|||
name|size
operator|!=
literal|8
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"invalid skip flags 0x%04x for DMA\n"
argument_list|,
name|skip
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
if|if
condition|(
name|reorder
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"TRILIST_201 used on Savage4 hardware\n"
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|start
operator|+
name|n
operator|>
name|dmabuf
operator|->
name|total
operator|/
literal|32
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"vertex indices (%u-%u) out of range (0-%u)\n"
argument_list|,
name|start
argument_list|,
name|start
operator|+
name|n
operator|-
literal|1
argument_list|,
name|dmabuf
operator|->
name|total
operator|/
literal|32
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
comment|/* Vertex DMA doesn't work with command DMA at the same time, 	 * so we use BCI_... to submit commands here. Flush buffered 	 * faked DMA first. */
name|DMA_FLUSH
argument_list|()
expr_stmt|;
if|if
condition|(
name|dmabuf
operator|->
name|bus_address
operator|!=
name|dev_priv
operator|->
name|state
operator|.
name|common
operator|.
name|vbaddr
condition|)
block|{
name|BEGIN_BCI
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|BCI_SET_REGISTERS
argument_list|(
name|SAVAGE_VERTBUFADDR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|BCI_WRITE
argument_list|(
name|dmabuf
operator|->
name|bus_address
operator||
name|dev_priv
operator|->
name|dma_type
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|state
operator|.
name|common
operator|.
name|vbaddr
operator|=
name|dmabuf
operator|->
name|bus_address
expr_stmt|;
block|}
if|if
condition|(
name|S3_SAVAGE3D_SERIES
argument_list|(
name|dev_priv
operator|->
name|chipset
argument_list|)
operator|&&
name|dev_priv
operator|->
name|waiting
condition|)
block|{
comment|/* Workaround for what looks like a hardware bug. If a 		 * WAIT_3D_IDLE was emitted some time before the 		 * indexed drawing command then the engine will lock 		 * up. There are two known workarounds: 		 * WAIT_IDLE_EMPTY or emit at least 63 NOPs. */
name|BEGIN_BCI
argument_list|(
literal|63
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|63
condition|;
operator|++
name|i
control|)
name|BCI_WRITE
argument_list|(
name|BCI_CMD_WAIT
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|waiting
operator|=
literal|0
expr_stmt|;
block|}
name|prim
operator|<<=
literal|25
expr_stmt|;
while|while
condition|(
name|n
operator|!=
literal|0
condition|)
block|{
comment|/* Can emit up to 255 indices (85 triangles) at once. */
name|unsigned
name|int
name|count
init|=
name|n
operator|>
literal|255
condition|?
literal|255
else|:
name|n
decl_stmt|;
if|if
condition|(
name|reorder
condition|)
block|{
comment|/* Need to reorder indices for correct flat 			 * shading while preserving the clock sense 			 * for correct culling. Only on Savage3D. */
name|int
name|reorder
index|[
literal|3
index|]
init|=
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
decl_stmt|;
name|reorder
index|[
name|start
operator|%
literal|3
index|]
operator|=
literal|2
expr_stmt|;
name|BEGIN_BCI
argument_list|(
operator|(
name|count
operator|+
literal|1
operator|+
literal|1
operator|)
operator|/
literal|2
argument_list|)
expr_stmt|;
name|BCI_DRAW_INDICES_S3D
argument_list|(
name|count
argument_list|,
name|prim
argument_list|,
name|start
operator|+
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|start
operator|+
literal|1
init|;
name|i
operator|+
literal|1
operator|<
name|start
operator|+
name|count
condition|;
name|i
operator|+=
literal|2
control|)
name|BCI_WRITE
argument_list|(
operator|(
name|i
operator|+
name|reorder
index|[
name|i
operator|%
literal|3
index|]
operator|)
operator||
operator|(
operator|(
name|i
operator|+
literal|1
operator|+
name|reorder
index|[
operator|(
name|i
operator|+
literal|1
operator|)
operator|%
literal|3
index|]
operator|)
operator|<<
literal|16
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|start
operator|+
name|count
condition|)
name|BCI_WRITE
argument_list|(
name|i
operator|+
name|reorder
index|[
name|i
operator|%
literal|3
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|S3_SAVAGE3D_SERIES
argument_list|(
name|dev_priv
operator|->
name|chipset
argument_list|)
condition|)
block|{
name|BEGIN_BCI
argument_list|(
operator|(
name|count
operator|+
literal|1
operator|+
literal|1
operator|)
operator|/
literal|2
argument_list|)
expr_stmt|;
name|BCI_DRAW_INDICES_S3D
argument_list|(
name|count
argument_list|,
name|prim
argument_list|,
name|start
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|start
operator|+
literal|1
init|;
name|i
operator|+
literal|1
operator|<
name|start
operator|+
name|count
condition|;
name|i
operator|+=
literal|2
control|)
name|BCI_WRITE
argument_list|(
name|i
operator||
operator|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|<<
literal|16
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|start
operator|+
name|count
condition|)
name|BCI_WRITE
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|BEGIN_BCI
argument_list|(
operator|(
name|count
operator|+
literal|2
operator|+
literal|1
operator|)
operator|/
literal|2
argument_list|)
expr_stmt|;
name|BCI_DRAW_INDICES_S4
argument_list|(
name|count
argument_list|,
name|prim
argument_list|,
name|skip
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|start
init|;
name|i
operator|+
literal|1
operator|<
name|start
operator|+
name|count
condition|;
name|i
operator|+=
literal|2
control|)
name|BCI_WRITE
argument_list|(
name|i
operator||
operator|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|<<
literal|16
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|start
operator|+
name|count
condition|)
name|BCI_WRITE
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
name|start
operator|+=
name|count
expr_stmt|;
name|n
operator|-=
name|count
expr_stmt|;
name|prim
operator||=
name|BCI_CMD_DRAW_CONT
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|savage_dispatch_vb_prim
parameter_list|(
name|drm_savage_private_t
modifier|*
name|dev_priv
parameter_list|,
specifier|const
name|drm_savage_cmd_header_t
modifier|*
name|cmd_header
parameter_list|,
specifier|const
name|uint32_t
name|__user
modifier|*
name|vtxbuf
parameter_list|,
name|unsigned
name|int
name|vb_size
parameter_list|,
name|unsigned
name|int
name|vb_stride
parameter_list|)
block|{
name|DMA_LOCALS
expr_stmt|;
name|unsigned
name|char
name|reorder
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|prim
init|=
name|cmd_header
operator|->
name|prim
operator|.
name|prim
decl_stmt|;
name|unsigned
name|int
name|skip
init|=
name|cmd_header
operator|->
name|prim
operator|.
name|skip
decl_stmt|;
name|unsigned
name|int
name|n
init|=
name|cmd_header
operator|->
name|prim
operator|.
name|count
decl_stmt|;
name|unsigned
name|int
name|start
init|=
name|cmd_header
operator|->
name|prim
operator|.
name|start
decl_stmt|;
name|unsigned
name|int
name|vtx_size
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|prim
condition|)
block|{
case|case
name|SAVAGE_PRIM_TRILIST_201
case|:
name|reorder
operator|=
literal|1
expr_stmt|;
name|prim
operator|=
name|SAVAGE_PRIM_TRILIST
expr_stmt|;
case|case
name|SAVAGE_PRIM_TRILIST
case|:
if|if
condition|(
name|n
operator|%
literal|3
operator|!=
literal|0
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"wrong number of vertices %u in TRILIST\n"
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
break|break;
case|case
name|SAVAGE_PRIM_TRISTRIP
case|:
case|case
name|SAVAGE_PRIM_TRIFAN
case|:
if|if
condition|(
name|n
operator|<
literal|3
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"wrong number of vertices %u in TRIFAN/STRIP\n"
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
break|break;
default|default:
name|DRM_ERROR
argument_list|(
literal|"invalid primitive type %u\n"
argument_list|,
name|prim
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
if|if
condition|(
name|S3_SAVAGE3D_SERIES
argument_list|(
name|dev_priv
operator|->
name|chipset
argument_list|)
condition|)
block|{
if|if
condition|(
name|skip
operator|>
name|SAVAGE_SKIP_ALL_S3D
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"invalid skip flags 0x%04x\n"
argument_list|,
name|skip
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
name|vtx_size
operator|=
literal|8
expr_stmt|;
comment|/* full vertex */
block|}
else|else
block|{
if|if
condition|(
name|skip
operator|>
name|SAVAGE_SKIP_ALL_S4
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"invalid skip flags 0x%04x\n"
argument_list|,
name|skip
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
name|vtx_size
operator|=
literal|10
expr_stmt|;
comment|/* full vertex */
block|}
name|vtx_size
operator|-=
operator|(
name|skip
operator|&
literal|1
operator|)
operator|+
operator|(
name|skip
operator|>>
literal|1
operator|&
literal|1
operator|)
operator|+
operator|(
name|skip
operator|>>
literal|2
operator|&
literal|1
operator|)
operator|+
operator|(
name|skip
operator|>>
literal|3
operator|&
literal|1
operator|)
operator|+
operator|(
name|skip
operator|>>
literal|4
operator|&
literal|1
operator|)
operator|+
operator|(
name|skip
operator|>>
literal|5
operator|&
literal|1
operator|)
operator|+
operator|(
name|skip
operator|>>
literal|6
operator|&
literal|1
operator|)
operator|+
operator|(
name|skip
operator|>>
literal|7
operator|&
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|vtx_size
operator|>
name|vb_stride
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"vertex size greater than vb stride (%u> %u)\n"
argument_list|,
name|vtx_size
argument_list|,
name|vb_stride
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
if|if
condition|(
name|start
operator|+
name|n
operator|>
name|vb_size
operator|/
operator|(
name|vb_stride
operator|*
literal|4
operator|)
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"vertex indices (%u-%u) out of range (0-%u)\n"
argument_list|,
name|start
argument_list|,
name|start
operator|+
name|n
operator|-
literal|1
argument_list|,
name|vb_size
operator|/
operator|(
name|vb_stride
operator|*
literal|4
operator|)
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
name|prim
operator|<<=
literal|25
expr_stmt|;
while|while
condition|(
name|n
operator|!=
literal|0
condition|)
block|{
comment|/* Can emit up to 255 vertices (85 triangles) at once. */
name|unsigned
name|int
name|count
init|=
name|n
operator|>
literal|255
condition|?
literal|255
else|:
name|n
decl_stmt|;
if|if
condition|(
name|reorder
condition|)
block|{
comment|/* Need to reorder vertices for correct flat 			 * shading while preserving the clock sense 			 * for correct culling. Only on Savage3D. */
name|int
name|reorder
index|[
literal|3
index|]
init|=
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
decl_stmt|;
name|reorder
index|[
name|start
operator|%
literal|3
index|]
operator|=
literal|2
expr_stmt|;
name|BEGIN_DMA
argument_list|(
name|count
operator|*
name|vtx_size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|DMA_DRAW_PRIMITIVE
argument_list|(
name|count
argument_list|,
name|prim
argument_list|,
name|skip
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|start
init|;
name|i
operator|<
name|start
operator|+
name|count
condition|;
operator|++
name|i
control|)
block|{
name|unsigned
name|int
name|j
init|=
name|i
operator|+
name|reorder
index|[
name|i
operator|%
literal|3
index|]
decl_stmt|;
name|DMA_COPY_FROM_USER
argument_list|(
operator|&
name|vtxbuf
index|[
name|vb_stride
operator|*
name|j
index|]
argument_list|,
name|vtx_size
argument_list|)
expr_stmt|;
block|}
name|DMA_COMMIT
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|BEGIN_DMA
argument_list|(
name|count
operator|*
name|vtx_size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|DMA_DRAW_PRIMITIVE
argument_list|(
name|count
argument_list|,
name|prim
argument_list|,
name|skip
argument_list|)
expr_stmt|;
if|if
condition|(
name|vb_stride
operator|==
name|vtx_size
condition|)
block|{
name|DMA_COPY_FROM_USER
argument_list|(
operator|&
name|vtxbuf
index|[
name|vb_stride
operator|*
name|start
index|]
argument_list|,
name|vtx_size
operator|*
name|count
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
name|start
init|;
name|i
operator|<
name|start
operator|+
name|count
condition|;
operator|++
name|i
control|)
block|{
name|DMA_COPY_FROM_USER
argument_list|(
operator|&
name|vtxbuf
index|[
name|vb_stride
operator|*
name|i
index|]
argument_list|,
name|vtx_size
argument_list|)
expr_stmt|;
block|}
block|}
name|DMA_COMMIT
argument_list|()
expr_stmt|;
block|}
name|start
operator|+=
name|count
expr_stmt|;
name|n
operator|-=
name|count
expr_stmt|;
name|prim
operator||=
name|BCI_CMD_DRAW_CONT
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|savage_dispatch_dma_idx
parameter_list|(
name|drm_savage_private_t
modifier|*
name|dev_priv
parameter_list|,
specifier|const
name|drm_savage_cmd_header_t
modifier|*
name|cmd_header
parameter_list|,
specifier|const
name|uint16_t
name|__user
modifier|*
name|usr_idx
parameter_list|,
specifier|const
name|drm_buf_t
modifier|*
name|dmabuf
parameter_list|)
block|{
name|BCI_LOCALS
expr_stmt|;
name|unsigned
name|char
name|reorder
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|prim
init|=
name|cmd_header
operator|->
name|idx
operator|.
name|prim
decl_stmt|;
name|unsigned
name|int
name|skip
init|=
name|cmd_header
operator|->
name|idx
operator|.
name|skip
decl_stmt|;
name|unsigned
name|int
name|n
init|=
name|cmd_header
operator|->
name|idx
operator|.
name|count
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|dmabuf
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"called without dma buffers!\n"
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|n
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|prim
condition|)
block|{
case|case
name|SAVAGE_PRIM_TRILIST_201
case|:
name|reorder
operator|=
literal|1
expr_stmt|;
name|prim
operator|=
name|SAVAGE_PRIM_TRILIST
expr_stmt|;
case|case
name|SAVAGE_PRIM_TRILIST
case|:
if|if
condition|(
name|n
operator|%
literal|3
operator|!=
literal|0
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"wrong number of indices %u in TRILIST\n"
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
break|break;
case|case
name|SAVAGE_PRIM_TRISTRIP
case|:
case|case
name|SAVAGE_PRIM_TRIFAN
case|:
if|if
condition|(
name|n
operator|<
literal|3
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"wrong number of indices %u in TRIFAN/STRIP\n"
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
break|break;
default|default:
name|DRM_ERROR
argument_list|(
literal|"invalid primitive type %u\n"
argument_list|,
name|prim
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
if|if
condition|(
name|S3_SAVAGE3D_SERIES
argument_list|(
name|dev_priv
operator|->
name|chipset
argument_list|)
condition|)
block|{
if|if
condition|(
name|skip
operator|!=
literal|0
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"invalid skip flags 0x%04x for DMA\n"
argument_list|,
name|skip
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
block|}
else|else
block|{
name|unsigned
name|int
name|size
init|=
literal|10
operator|-
operator|(
name|skip
operator|&
literal|1
operator|)
operator|-
operator|(
name|skip
operator|>>
literal|1
operator|&
literal|1
operator|)
operator|-
operator|(
name|skip
operator|>>
literal|2
operator|&
literal|1
operator|)
operator|-
operator|(
name|skip
operator|>>
literal|3
operator|&
literal|1
operator|)
operator|-
operator|(
name|skip
operator|>>
literal|4
operator|&
literal|1
operator|)
operator|-
operator|(
name|skip
operator|>>
literal|5
operator|&
literal|1
operator|)
operator|-
operator|(
name|skip
operator|>>
literal|6
operator|&
literal|1
operator|)
operator|-
operator|(
name|skip
operator|>>
literal|7
operator|&
literal|1
operator|)
decl_stmt|;
if|if
condition|(
name|skip
operator|>
name|SAVAGE_SKIP_ALL_S4
operator|||
name|size
operator|!=
literal|8
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"invalid skip flags 0x%04x for DMA\n"
argument_list|,
name|skip
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
if|if
condition|(
name|reorder
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"TRILIST_201 used on Savage4 hardware\n"
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
block|}
comment|/* Vertex DMA doesn't work with command DMA at the same time, 	 * so we use BCI_... to submit commands here. Flush buffered 	 * faked DMA first. */
name|DMA_FLUSH
argument_list|()
expr_stmt|;
if|if
condition|(
name|dmabuf
operator|->
name|bus_address
operator|!=
name|dev_priv
operator|->
name|state
operator|.
name|common
operator|.
name|vbaddr
condition|)
block|{
name|BEGIN_BCI
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|BCI_SET_REGISTERS
argument_list|(
name|SAVAGE_VERTBUFADDR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|BCI_WRITE
argument_list|(
name|dmabuf
operator|->
name|bus_address
operator||
name|dev_priv
operator|->
name|dma_type
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|state
operator|.
name|common
operator|.
name|vbaddr
operator|=
name|dmabuf
operator|->
name|bus_address
expr_stmt|;
block|}
if|if
condition|(
name|S3_SAVAGE3D_SERIES
argument_list|(
name|dev_priv
operator|->
name|chipset
argument_list|)
operator|&&
name|dev_priv
operator|->
name|waiting
condition|)
block|{
comment|/* Workaround for what looks like a hardware bug. If a 		 * WAIT_3D_IDLE was emitted some time before the 		 * indexed drawing command then the engine will lock 		 * up. There are two known workarounds: 		 * WAIT_IDLE_EMPTY or emit at least 63 NOPs. */
name|BEGIN_BCI
argument_list|(
literal|63
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|63
condition|;
operator|++
name|i
control|)
name|BCI_WRITE
argument_list|(
name|BCI_CMD_WAIT
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|waiting
operator|=
literal|0
expr_stmt|;
block|}
name|prim
operator|<<=
literal|25
expr_stmt|;
while|while
condition|(
name|n
operator|!=
literal|0
condition|)
block|{
comment|/* Can emit up to 255 indices (85 triangles) at once. */
name|unsigned
name|int
name|count
init|=
name|n
operator|>
literal|255
condition|?
literal|255
else|:
name|n
decl_stmt|;
comment|/* Is it ok to allocate 510 bytes on the stack in an ioctl? */
name|uint16_t
name|idx
index|[
literal|255
index|]
decl_stmt|;
comment|/* Copy and check indices */
name|DRM_COPY_FROM_USER_UNCHECKED
argument_list|(
name|idx
argument_list|,
name|usr_idx
argument_list|,
name|count
operator|*
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|idx
index|[
name|i
index|]
operator|>
name|dmabuf
operator|->
name|total
operator|/
literal|32
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"idx[%u]=%u out of range (0-%u)\n"
argument_list|,
name|i
argument_list|,
name|idx
index|[
name|i
index|]
argument_list|,
name|dmabuf
operator|->
name|total
operator|/
literal|32
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|reorder
condition|)
block|{
comment|/* Need to reorder indices for correct flat 			 * shading while preserving the clock sense 			 * for correct culling. Only on Savage3D. */
name|int
name|reorder
index|[
literal|3
index|]
init|=
block|{
literal|2
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
decl_stmt|;
name|BEGIN_BCI
argument_list|(
operator|(
name|count
operator|+
literal|1
operator|+
literal|1
operator|)
operator|/
literal|2
argument_list|)
expr_stmt|;
name|BCI_DRAW_INDICES_S3D
argument_list|(
name|count
argument_list|,
name|prim
argument_list|,
name|idx
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|+
literal|1
operator|<
name|count
condition|;
name|i
operator|+=
literal|2
control|)
name|BCI_WRITE
argument_list|(
name|idx
index|[
name|i
operator|+
name|reorder
index|[
name|i
operator|%
literal|3
index|]
index|]
operator||
operator|(
name|idx
index|[
name|i
operator|+
literal|1
operator|+
name|reorder
index|[
operator|(
name|i
operator|+
literal|1
operator|)
operator|%
literal|3
index|]
index|]
operator|<<
literal|16
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|count
condition|)
name|BCI_WRITE
argument_list|(
name|idx
index|[
name|i
operator|+
name|reorder
index|[
name|i
operator|%
literal|3
index|]
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|S3_SAVAGE3D_SERIES
argument_list|(
name|dev_priv
operator|->
name|chipset
argument_list|)
condition|)
block|{
name|BEGIN_BCI
argument_list|(
operator|(
name|count
operator|+
literal|1
operator|+
literal|1
operator|)
operator|/
literal|2
argument_list|)
expr_stmt|;
name|BCI_DRAW_INDICES_S3D
argument_list|(
name|count
argument_list|,
name|prim
argument_list|,
name|idx
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|+
literal|1
operator|<
name|count
condition|;
name|i
operator|+=
literal|2
control|)
name|BCI_WRITE
argument_list|(
name|idx
index|[
name|i
index|]
operator||
operator|(
name|idx
index|[
name|i
operator|+
literal|1
index|]
operator|<<
literal|16
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|count
condition|)
name|BCI_WRITE
argument_list|(
name|idx
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|BEGIN_BCI
argument_list|(
operator|(
name|count
operator|+
literal|2
operator|+
literal|1
operator|)
operator|/
literal|2
argument_list|)
expr_stmt|;
name|BCI_DRAW_INDICES_S4
argument_list|(
name|count
argument_list|,
name|prim
argument_list|,
name|skip
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|+
literal|1
operator|<
name|count
condition|;
name|i
operator|+=
literal|2
control|)
name|BCI_WRITE
argument_list|(
name|idx
index|[
name|i
index|]
operator||
operator|(
name|idx
index|[
name|i
operator|+
literal|1
index|]
operator|<<
literal|16
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|count
condition|)
name|BCI_WRITE
argument_list|(
name|idx
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|usr_idx
operator|+=
name|count
expr_stmt|;
name|n
operator|-=
name|count
expr_stmt|;
name|prim
operator||=
name|BCI_CMD_DRAW_CONT
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|savage_dispatch_vb_idx
parameter_list|(
name|drm_savage_private_t
modifier|*
name|dev_priv
parameter_list|,
specifier|const
name|drm_savage_cmd_header_t
modifier|*
name|cmd_header
parameter_list|,
specifier|const
name|uint16_t
name|__user
modifier|*
name|usr_idx
parameter_list|,
specifier|const
name|uint32_t
name|__user
modifier|*
name|vtxbuf
parameter_list|,
name|unsigned
name|int
name|vb_size
parameter_list|,
name|unsigned
name|int
name|vb_stride
parameter_list|)
block|{
name|DMA_LOCALS
expr_stmt|;
name|unsigned
name|char
name|reorder
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|prim
init|=
name|cmd_header
operator|->
name|idx
operator|.
name|prim
decl_stmt|;
name|unsigned
name|int
name|skip
init|=
name|cmd_header
operator|->
name|idx
operator|.
name|skip
decl_stmt|;
name|unsigned
name|int
name|n
init|=
name|cmd_header
operator|->
name|idx
operator|.
name|count
decl_stmt|;
name|unsigned
name|int
name|vtx_size
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|prim
condition|)
block|{
case|case
name|SAVAGE_PRIM_TRILIST_201
case|:
name|reorder
operator|=
literal|1
expr_stmt|;
name|prim
operator|=
name|SAVAGE_PRIM_TRILIST
expr_stmt|;
case|case
name|SAVAGE_PRIM_TRILIST
case|:
if|if
condition|(
name|n
operator|%
literal|3
operator|!=
literal|0
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"wrong number of indices %u in TRILIST\n"
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
break|break;
case|case
name|SAVAGE_PRIM_TRISTRIP
case|:
case|case
name|SAVAGE_PRIM_TRIFAN
case|:
if|if
condition|(
name|n
operator|<
literal|3
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"wrong number of indices %u in TRIFAN/STRIP\n"
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
break|break;
default|default:
name|DRM_ERROR
argument_list|(
literal|"invalid primitive type %u\n"
argument_list|,
name|prim
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
if|if
condition|(
name|S3_SAVAGE3D_SERIES
argument_list|(
name|dev_priv
operator|->
name|chipset
argument_list|)
condition|)
block|{
if|if
condition|(
name|skip
operator|>
name|SAVAGE_SKIP_ALL_S3D
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"invalid skip flags 0x%04x\n"
argument_list|,
name|skip
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
name|vtx_size
operator|=
literal|8
expr_stmt|;
comment|/* full vertex */
block|}
else|else
block|{
if|if
condition|(
name|skip
operator|>
name|SAVAGE_SKIP_ALL_S4
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"invalid skip flags 0x%04x\n"
argument_list|,
name|skip
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
name|vtx_size
operator|=
literal|10
expr_stmt|;
comment|/* full vertex */
block|}
name|vtx_size
operator|-=
operator|(
name|skip
operator|&
literal|1
operator|)
operator|+
operator|(
name|skip
operator|>>
literal|1
operator|&
literal|1
operator|)
operator|+
operator|(
name|skip
operator|>>
literal|2
operator|&
literal|1
operator|)
operator|+
operator|(
name|skip
operator|>>
literal|3
operator|&
literal|1
operator|)
operator|+
operator|(
name|skip
operator|>>
literal|4
operator|&
literal|1
operator|)
operator|+
operator|(
name|skip
operator|>>
literal|5
operator|&
literal|1
operator|)
operator|+
operator|(
name|skip
operator|>>
literal|6
operator|&
literal|1
operator|)
operator|+
operator|(
name|skip
operator|>>
literal|7
operator|&
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|vtx_size
operator|>
name|vb_stride
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"vertex size greater than vb stride (%u> %u)\n"
argument_list|,
name|vtx_size
argument_list|,
name|vb_stride
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
name|prim
operator|<<=
literal|25
expr_stmt|;
while|while
condition|(
name|n
operator|!=
literal|0
condition|)
block|{
comment|/* Can emit up to 255 vertices (85 triangles) at once. */
name|unsigned
name|int
name|count
init|=
name|n
operator|>
literal|255
condition|?
literal|255
else|:
name|n
decl_stmt|;
comment|/* Is it ok to allocate 510 bytes on the stack in an ioctl? */
name|uint16_t
name|idx
index|[
literal|255
index|]
decl_stmt|;
comment|/* Copy and check indices */
name|DRM_COPY_FROM_USER_UNCHECKED
argument_list|(
name|idx
argument_list|,
name|usr_idx
argument_list|,
name|count
operator|*
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|idx
index|[
name|i
index|]
operator|>
name|vb_size
operator|/
operator|(
name|vb_stride
operator|*
literal|4
operator|)
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"idx[%u]=%u out of range (0-%u)\n"
argument_list|,
name|i
argument_list|,
name|idx
index|[
name|i
index|]
argument_list|,
name|vb_size
operator|/
operator|(
name|vb_stride
operator|*
literal|4
operator|)
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|reorder
condition|)
block|{
comment|/* Need to reorder vertices for correct flat 			 * shading while preserving the clock sense 			 * for correct culling. Only on Savage3D. */
name|int
name|reorder
index|[
literal|3
index|]
init|=
block|{
literal|2
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
decl_stmt|;
name|BEGIN_DMA
argument_list|(
name|count
operator|*
name|vtx_size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|DMA_DRAW_PRIMITIVE
argument_list|(
name|count
argument_list|,
name|prim
argument_list|,
name|skip
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
block|{
name|unsigned
name|int
name|j
init|=
name|idx
index|[
name|i
operator|+
name|reorder
index|[
name|i
operator|%
literal|3
index|]
index|]
decl_stmt|;
name|DMA_COPY_FROM_USER
argument_list|(
operator|&
name|vtxbuf
index|[
name|vb_stride
operator|*
name|j
index|]
argument_list|,
name|vtx_size
argument_list|)
expr_stmt|;
block|}
name|DMA_COMMIT
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|BEGIN_DMA
argument_list|(
name|count
operator|*
name|vtx_size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|DMA_DRAW_PRIMITIVE
argument_list|(
name|count
argument_list|,
name|prim
argument_list|,
name|skip
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
block|{
name|unsigned
name|int
name|j
init|=
name|idx
index|[
name|i
index|]
decl_stmt|;
name|DMA_COPY_FROM_USER
argument_list|(
operator|&
name|vtxbuf
index|[
name|vb_stride
operator|*
name|j
index|]
argument_list|,
name|vtx_size
argument_list|)
expr_stmt|;
block|}
name|DMA_COMMIT
argument_list|()
expr_stmt|;
block|}
name|usr_idx
operator|+=
name|count
expr_stmt|;
name|n
operator|-=
name|count
expr_stmt|;
name|prim
operator||=
name|BCI_CMD_DRAW_CONT
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|savage_dispatch_clear
parameter_list|(
name|drm_savage_private_t
modifier|*
name|dev_priv
parameter_list|,
specifier|const
name|drm_savage_cmd_header_t
modifier|*
name|cmd_header
parameter_list|,
specifier|const
name|drm_savage_cmd_header_t
name|__user
modifier|*
name|data
parameter_list|,
name|unsigned
name|int
name|nbox
parameter_list|,
specifier|const
name|drm_clip_rect_t
name|__user
modifier|*
name|usr_boxes
parameter_list|)
block|{
name|DMA_LOCALS
expr_stmt|;
name|unsigned
name|int
name|flags
init|=
name|cmd_header
operator|->
name|clear0
operator|.
name|flags
decl_stmt|,
name|mask
decl_stmt|,
name|value
decl_stmt|;
name|unsigned
name|int
name|clear_cmd
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|nbufs
decl_stmt|;
if|if
condition|(
name|nbox
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|DRM_GET_USER_UNCHECKED
argument_list|(
name|mask
argument_list|,
operator|&
operator|(
operator|(
name|drm_savage_cmd_header_t
operator|*
operator|)
name|data
operator|)
operator|->
name|clear1
operator|.
name|mask
argument_list|)
expr_stmt|;
name|DRM_GET_USER_UNCHECKED
argument_list|(
name|value
argument_list|,
operator|&
operator|(
operator|(
name|drm_savage_cmd_header_t
operator|*
operator|)
name|data
operator|)
operator|->
name|clear1
operator|.
name|value
argument_list|)
expr_stmt|;
name|clear_cmd
operator|=
name|BCI_CMD_RECT
operator||
name|BCI_CMD_RECT_XP
operator||
name|BCI_CMD_RECT_YP
operator||
name|BCI_CMD_SEND_COLOR
operator||
name|BCI_CMD_DEST_PBD_NEW
expr_stmt|;
name|BCI_CMD_SET_ROP
argument_list|(
name|clear_cmd
argument_list|,
literal|0xCC
argument_list|)
expr_stmt|;
name|nbufs
operator|=
operator|(
operator|(
name|flags
operator|&
name|SAVAGE_FRONT
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
operator|+
operator|(
operator|(
name|flags
operator|&
name|SAVAGE_BACK
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
operator|+
operator|(
operator|(
name|flags
operator|&
name|SAVAGE_DEPTH
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|nbufs
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|mask
operator|!=
literal|0xffffffff
condition|)
block|{
comment|/* set mask */
name|BEGIN_DMA
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|DMA_SET_REGISTERS
argument_list|(
name|SAVAGE_BITPLANEWTMASK
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|DMA_WRITE
argument_list|(
name|mask
argument_list|)
expr_stmt|;
name|DMA_COMMIT
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nbox
condition|;
operator|++
name|i
control|)
block|{
name|drm_clip_rect_t
name|box
decl_stmt|;
name|unsigned
name|int
name|x
decl_stmt|,
name|y
decl_stmt|,
name|w
decl_stmt|,
name|h
decl_stmt|;
name|unsigned
name|int
name|buf
decl_stmt|;
name|DRM_COPY_FROM_USER_UNCHECKED
argument_list|(
operator|&
name|box
argument_list|,
operator|&
name|usr_boxes
index|[
name|i
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|box
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|=
name|box
operator|.
name|x1
operator|,
name|y
operator|=
name|box
operator|.
name|y1
expr_stmt|;
name|w
operator|=
name|box
operator|.
name|x2
operator|-
name|box
operator|.
name|x1
expr_stmt|;
name|h
operator|=
name|box
operator|.
name|y2
operator|-
name|box
operator|.
name|y1
expr_stmt|;
name|BEGIN_DMA
argument_list|(
name|nbufs
operator|*
literal|6
argument_list|)
expr_stmt|;
for|for
control|(
name|buf
operator|=
name|SAVAGE_FRONT
init|;
name|buf
operator|<=
name|SAVAGE_DEPTH
condition|;
name|buf
operator|<<=
literal|1
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|buf
operator|)
condition|)
continue|continue;
name|DMA_WRITE
argument_list|(
name|clear_cmd
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|buf
condition|)
block|{
case|case
name|SAVAGE_FRONT
case|:
name|DMA_WRITE
argument_list|(
name|dev_priv
operator|->
name|front_offset
argument_list|)
expr_stmt|;
name|DMA_WRITE
argument_list|(
name|dev_priv
operator|->
name|front_bd
argument_list|)
expr_stmt|;
break|break;
case|case
name|SAVAGE_BACK
case|:
name|DMA_WRITE
argument_list|(
name|dev_priv
operator|->
name|back_offset
argument_list|)
expr_stmt|;
name|DMA_WRITE
argument_list|(
name|dev_priv
operator|->
name|back_bd
argument_list|)
expr_stmt|;
break|break;
case|case
name|SAVAGE_DEPTH
case|:
name|DMA_WRITE
argument_list|(
name|dev_priv
operator|->
name|depth_offset
argument_list|)
expr_stmt|;
name|DMA_WRITE
argument_list|(
name|dev_priv
operator|->
name|depth_bd
argument_list|)
expr_stmt|;
break|break;
block|}
name|DMA_WRITE
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|DMA_WRITE
argument_list|(
name|BCI_X_Y
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
argument_list|)
expr_stmt|;
name|DMA_WRITE
argument_list|(
name|BCI_W_H
argument_list|(
name|w
argument_list|,
name|h
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|DMA_COMMIT
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|mask
operator|!=
literal|0xffffffff
condition|)
block|{
comment|/* reset mask */
name|BEGIN_DMA
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|DMA_SET_REGISTERS
argument_list|(
name|SAVAGE_BITPLANEWTMASK
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|DMA_WRITE
argument_list|(
literal|0xffffffff
argument_list|)
expr_stmt|;
name|DMA_COMMIT
argument_list|()
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|savage_dispatch_swap
parameter_list|(
name|drm_savage_private_t
modifier|*
name|dev_priv
parameter_list|,
name|unsigned
name|int
name|nbox
parameter_list|,
specifier|const
name|drm_clip_rect_t
name|__user
modifier|*
name|usr_boxes
parameter_list|)
block|{
name|DMA_LOCALS
expr_stmt|;
name|unsigned
name|int
name|swap_cmd
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
if|if
condition|(
name|nbox
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|swap_cmd
operator|=
name|BCI_CMD_RECT
operator||
name|BCI_CMD_RECT_XP
operator||
name|BCI_CMD_RECT_YP
operator||
name|BCI_CMD_SRC_PBD_COLOR_NEW
operator||
name|BCI_CMD_DEST_GBD
expr_stmt|;
name|BCI_CMD_SET_ROP
argument_list|(
name|swap_cmd
argument_list|,
literal|0xCC
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nbox
condition|;
operator|++
name|i
control|)
block|{
name|drm_clip_rect_t
name|box
decl_stmt|;
name|DRM_COPY_FROM_USER_UNCHECKED
argument_list|(
operator|&
name|box
argument_list|,
operator|&
name|usr_boxes
index|[
name|i
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|box
argument_list|)
argument_list|)
expr_stmt|;
name|BEGIN_DMA
argument_list|(
literal|6
argument_list|)
expr_stmt|;
name|DMA_WRITE
argument_list|(
name|swap_cmd
argument_list|)
expr_stmt|;
name|DMA_WRITE
argument_list|(
name|dev_priv
operator|->
name|back_offset
argument_list|)
expr_stmt|;
name|DMA_WRITE
argument_list|(
name|dev_priv
operator|->
name|back_bd
argument_list|)
expr_stmt|;
name|DMA_WRITE
argument_list|(
name|BCI_X_Y
argument_list|(
name|box
operator|.
name|x1
argument_list|,
name|box
operator|.
name|y1
argument_list|)
argument_list|)
expr_stmt|;
name|DMA_WRITE
argument_list|(
name|BCI_X_Y
argument_list|(
name|box
operator|.
name|x1
argument_list|,
name|box
operator|.
name|y1
argument_list|)
argument_list|)
expr_stmt|;
name|DMA_WRITE
argument_list|(
name|BCI_W_H
argument_list|(
name|box
operator|.
name|x2
operator|-
name|box
operator|.
name|x1
argument_list|,
name|box
operator|.
name|y2
operator|-
name|box
operator|.
name|y1
argument_list|)
argument_list|)
expr_stmt|;
name|DMA_COMMIT
argument_list|()
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|savage_dispatch_draw
parameter_list|(
name|drm_savage_private_t
modifier|*
name|dev_priv
parameter_list|,
specifier|const
name|drm_savage_cmd_header_t
name|__user
modifier|*
name|start
parameter_list|,
specifier|const
name|drm_savage_cmd_header_t
name|__user
modifier|*
name|end
parameter_list|,
specifier|const
name|drm_buf_t
modifier|*
name|dmabuf
parameter_list|,
specifier|const
name|unsigned
name|int
name|__user
modifier|*
name|usr_vtxbuf
parameter_list|,
name|unsigned
name|int
name|vb_size
parameter_list|,
name|unsigned
name|int
name|vb_stride
parameter_list|,
name|unsigned
name|int
name|nbox
parameter_list|,
specifier|const
name|drm_clip_rect_t
name|__user
modifier|*
name|usr_boxes
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|ret
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nbox
condition|;
operator|++
name|i
control|)
block|{
name|drm_clip_rect_t
name|box
decl_stmt|;
specifier|const
name|drm_savage_cmd_header_t
name|__user
modifier|*
name|usr_cmdbuf
decl_stmt|;
name|DRM_COPY_FROM_USER_UNCHECKED
argument_list|(
operator|&
name|box
argument_list|,
operator|&
name|usr_boxes
index|[
name|i
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|box
argument_list|)
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|emit_clip_rect
argument_list|(
name|dev_priv
argument_list|,
operator|&
name|box
argument_list|)
expr_stmt|;
name|usr_cmdbuf
operator|=
name|start
expr_stmt|;
while|while
condition|(
name|usr_cmdbuf
operator|<
name|end
condition|)
block|{
name|drm_savage_cmd_header_t
name|cmd_header
decl_stmt|;
name|DRM_COPY_FROM_USER_UNCHECKED
argument_list|(
operator|&
name|cmd_header
argument_list|,
name|usr_cmdbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd_header
argument_list|)
argument_list|)
expr_stmt|;
name|usr_cmdbuf
operator|++
expr_stmt|;
switch|switch
condition|(
name|cmd_header
operator|.
name|cmd
operator|.
name|cmd
condition|)
block|{
case|case
name|SAVAGE_CMD_DMA_PRIM
case|:
name|ret
operator|=
name|savage_dispatch_dma_prim
argument_list|(
name|dev_priv
argument_list|,
operator|&
name|cmd_header
argument_list|,
name|dmabuf
argument_list|)
expr_stmt|;
break|break;
case|case
name|SAVAGE_CMD_VB_PRIM
case|:
name|ret
operator|=
name|savage_dispatch_vb_prim
argument_list|(
name|dev_priv
argument_list|,
operator|&
name|cmd_header
argument_list|,
operator|(
name|uint32_t
name|__user
operator|*
operator|)
name|usr_vtxbuf
argument_list|,
name|vb_size
argument_list|,
name|vb_stride
argument_list|)
expr_stmt|;
break|break;
case|case
name|SAVAGE_CMD_DMA_IDX
case|:
name|j
operator|=
operator|(
name|cmd_header
operator|.
name|idx
operator|.
name|count
operator|+
literal|3
operator|)
operator|/
literal|4
expr_stmt|;
comment|/* j was check in savage_bci_cmdbuf */
name|ret
operator|=
name|savage_dispatch_dma_idx
argument_list|(
name|dev_priv
argument_list|,
operator|&
name|cmd_header
argument_list|,
operator|(
name|uint16_t
name|__user
operator|*
operator|)
name|usr_cmdbuf
argument_list|,
name|dmabuf
argument_list|)
expr_stmt|;
name|usr_cmdbuf
operator|+=
name|j
expr_stmt|;
break|break;
case|case
name|SAVAGE_CMD_VB_IDX
case|:
name|j
operator|=
operator|(
name|cmd_header
operator|.
name|idx
operator|.
name|count
operator|+
literal|3
operator|)
operator|/
literal|4
expr_stmt|;
comment|/* j was check in savage_bci_cmdbuf */
name|ret
operator|=
name|savage_dispatch_vb_idx
argument_list|(
name|dev_priv
argument_list|,
operator|&
name|cmd_header
argument_list|,
operator|(
name|uint16_t
name|__user
operator|*
operator|)
name|usr_cmdbuf
argument_list|,
operator|(
name|uint32_t
name|__user
operator|*
operator|)
name|usr_vtxbuf
argument_list|,
name|vb_size
argument_list|,
name|vb_stride
argument_list|)
expr_stmt|;
name|usr_cmdbuf
operator|+=
name|j
expr_stmt|;
break|break;
default|default:
comment|/* What's the best return code? EFAULT? */
name|DRM_ERROR
argument_list|(
literal|"IMPLEMENTATION ERROR: "
literal|"non-drawing-command %d\n"
argument_list|,
name|cmd_header
operator|.
name|cmd
operator|.
name|cmd
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
return|return
name|ret
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|savage_bci_cmdbuf
parameter_list|(
name|DRM_IOCTL_ARGS
parameter_list|)
block|{
name|DRM_DEVICE
expr_stmt|;
name|drm_savage_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|drm_device_dma_t
modifier|*
name|dma
init|=
name|dev
operator|->
name|dma
decl_stmt|;
name|drm_buf_t
modifier|*
name|dmabuf
decl_stmt|;
name|drm_savage_cmdbuf_t
name|cmdbuf
decl_stmt|;
name|drm_savage_cmd_header_t
name|__user
modifier|*
name|usr_cmdbuf
decl_stmt|;
name|drm_savage_cmd_header_t
name|__user
modifier|*
name|first_draw_cmd
decl_stmt|;
name|unsigned
name|int
name|__user
modifier|*
name|usr_vtxbuf
decl_stmt|;
name|drm_clip_rect_t
name|__user
modifier|*
name|usr_boxes
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|LOCK_TEST_WITH_RETURN
argument_list|(
name|dev
argument_list|,
name|filp
argument_list|)
expr_stmt|;
name|DRM_COPY_FROM_USER_IOCTL
argument_list|(
name|cmdbuf
argument_list|,
operator|(
name|drm_savage_cmdbuf_t
name|__user
operator|*
operator|)
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|cmdbuf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dma
operator|&&
name|dma
operator|->
name|buflist
condition|)
block|{
if|if
condition|(
name|cmdbuf
operator|.
name|dma_idx
operator|>
name|dma
operator|->
name|buf_count
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"vertex buffer index %u out of range (0-%u)\n"
argument_list|,
name|cmdbuf
operator|.
name|dma_idx
argument_list|,
name|dma
operator|->
name|buf_count
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
name|dmabuf
operator|=
name|dma
operator|->
name|buflist
index|[
name|cmdbuf
operator|.
name|dma_idx
index|]
expr_stmt|;
block|}
else|else
block|{
name|dmabuf
operator|=
name|NULL
expr_stmt|;
block|}
name|usr_cmdbuf
operator|=
operator|(
name|drm_savage_cmd_header_t
name|__user
operator|*
operator|)
name|cmdbuf
operator|.
name|cmd_addr
expr_stmt|;
name|usr_vtxbuf
operator|=
operator|(
name|unsigned
name|int
name|__user
operator|*
operator|)
name|cmdbuf
operator|.
name|vb_addr
expr_stmt|;
name|usr_boxes
operator|=
operator|(
name|drm_clip_rect_t
name|__user
operator|*
operator|)
name|cmdbuf
operator|.
name|box_addr
expr_stmt|;
if|if
condition|(
operator|(
name|cmdbuf
operator|.
name|size
operator|&&
name|DRM_VERIFYAREA_READ
argument_list|(
name|usr_cmdbuf
argument_list|,
name|cmdbuf
operator|.
name|size
operator|*
literal|8
argument_list|)
operator|)
operator|||
operator|(
name|cmdbuf
operator|.
name|vb_size
operator|&&
name|DRM_VERIFYAREA_READ
argument_list|(
name|usr_vtxbuf
argument_list|,
name|cmdbuf
operator|.
name|vb_size
argument_list|)
operator|)
operator|||
operator|(
name|cmdbuf
operator|.
name|nbox
operator|&&
name|DRM_VERIFYAREA_READ
argument_list|(
name|usr_boxes
argument_list|,
name|cmdbuf
operator|.
name|nbox
operator|*
sizeof|sizeof
argument_list|(
name|drm_clip_rect_t
argument_list|)
argument_list|)
operator|)
condition|)
return|return
name|DRM_ERR
argument_list|(
name|EFAULT
argument_list|)
return|;
comment|/* Make sure writes to DMA buffers are finished before sending 	 * DMA commands to the graphics hardware. */
name|DRM_MEMORYBARRIER
argument_list|()
expr_stmt|;
comment|/* Coming from user space. Don't know if the Xserver has 	 * emitted wait commands. Assuming the worst. */
name|dev_priv
operator|->
name|waiting
operator|=
literal|1
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|first_draw_cmd
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|cmdbuf
operator|.
name|size
condition|)
block|{
name|drm_savage_cmd_header_t
name|cmd_header
decl_stmt|;
name|DRM_COPY_FROM_USER_UNCHECKED
argument_list|(
operator|&
name|cmd_header
argument_list|,
name|usr_cmdbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd_header
argument_list|)
argument_list|)
expr_stmt|;
name|usr_cmdbuf
operator|++
expr_stmt|;
name|i
operator|++
expr_stmt|;
comment|/* Group drawing commands with same state to minimize 		 * iterations over clip rects. */
name|j
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|cmd_header
operator|.
name|cmd
operator|.
name|cmd
condition|)
block|{
case|case
name|SAVAGE_CMD_DMA_IDX
case|:
case|case
name|SAVAGE_CMD_VB_IDX
case|:
name|j
operator|=
operator|(
name|cmd_header
operator|.
name|idx
operator|.
name|count
operator|+
literal|3
operator|)
operator|/
literal|4
expr_stmt|;
if|if
condition|(
name|i
operator|+
name|j
operator|>
name|cmdbuf
operator|.
name|size
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"indexed drawing command extends "
literal|"beyond end of command buffer\n"
argument_list|)
expr_stmt|;
name|DMA_FLUSH
argument_list|()
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
comment|/* fall through */
case|case
name|SAVAGE_CMD_DMA_PRIM
case|:
case|case
name|SAVAGE_CMD_VB_PRIM
case|:
if|if
condition|(
operator|!
name|first_draw_cmd
condition|)
name|first_draw_cmd
operator|=
name|usr_cmdbuf
operator|-
literal|1
expr_stmt|;
name|usr_cmdbuf
operator|+=
name|j
expr_stmt|;
name|i
operator|+=
name|j
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|first_draw_cmd
condition|)
block|{
name|ret
operator|=
name|savage_dispatch_draw
argument_list|(
name|dev_priv
argument_list|,
name|first_draw_cmd
argument_list|,
name|usr_cmdbuf
operator|-
literal|1
argument_list|,
name|dmabuf
argument_list|,
name|usr_vtxbuf
argument_list|,
name|cmdbuf
operator|.
name|vb_size
argument_list|,
name|cmdbuf
operator|.
name|vb_stride
argument_list|,
name|cmdbuf
operator|.
name|nbox
argument_list|,
name|usr_boxes
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
return|return
name|ret
return|;
name|first_draw_cmd
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|first_draw_cmd
condition|)
continue|continue;
switch|switch
condition|(
name|cmd_header
operator|.
name|cmd
operator|.
name|cmd
condition|)
block|{
case|case
name|SAVAGE_CMD_STATE
case|:
name|j
operator|=
operator|(
name|cmd_header
operator|.
name|state
operator|.
name|count
operator|+
literal|1
operator|)
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|i
operator|+
name|j
operator|>
name|cmdbuf
operator|.
name|size
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"command SAVAGE_CMD_STATE extends "
literal|"beyond end of command buffer\n"
argument_list|)
expr_stmt|;
name|DMA_FLUSH
argument_list|()
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
name|ret
operator|=
name|savage_dispatch_state
argument_list|(
name|dev_priv
argument_list|,
operator|&
name|cmd_header
argument_list|,
operator|(
name|uint32_t
name|__user
operator|*
operator|)
name|usr_cmdbuf
argument_list|)
expr_stmt|;
name|usr_cmdbuf
operator|+=
name|j
expr_stmt|;
name|i
operator|+=
name|j
expr_stmt|;
break|break;
case|case
name|SAVAGE_CMD_CLEAR
case|:
if|if
condition|(
name|i
operator|+
literal|1
operator|>
name|cmdbuf
operator|.
name|size
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"command SAVAGE_CMD_CLEAR extends "
literal|"beyond end of command buffer\n"
argument_list|)
expr_stmt|;
name|DMA_FLUSH
argument_list|()
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
name|ret
operator|=
name|savage_dispatch_clear
argument_list|(
name|dev_priv
argument_list|,
operator|&
name|cmd_header
argument_list|,
name|usr_cmdbuf
argument_list|,
name|cmdbuf
operator|.
name|nbox
argument_list|,
name|usr_boxes
argument_list|)
expr_stmt|;
name|usr_cmdbuf
operator|++
expr_stmt|;
name|i
operator|++
expr_stmt|;
break|break;
case|case
name|SAVAGE_CMD_SWAP
case|:
name|ret
operator|=
name|savage_dispatch_swap
argument_list|(
name|dev_priv
argument_list|,
name|cmdbuf
operator|.
name|nbox
argument_list|,
name|usr_boxes
argument_list|)
expr_stmt|;
break|break;
default|default:
name|DRM_ERROR
argument_list|(
literal|"invalid command 0x%x\n"
argument_list|,
name|cmd_header
operator|.
name|cmd
operator|.
name|cmd
argument_list|)
expr_stmt|;
name|DMA_FLUSH
argument_list|()
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|DMA_FLUSH
argument_list|()
expr_stmt|;
return|return
name|ret
return|;
block|}
block|}
if|if
condition|(
name|first_draw_cmd
condition|)
block|{
name|ret
operator|=
name|savage_dispatch_draw
argument_list|(
name|dev_priv
argument_list|,
name|first_draw_cmd
argument_list|,
name|usr_cmdbuf
argument_list|,
name|dmabuf
argument_list|,
name|usr_vtxbuf
argument_list|,
name|cmdbuf
operator|.
name|vb_size
argument_list|,
name|cmdbuf
operator|.
name|vb_stride
argument_list|,
name|cmdbuf
operator|.
name|nbox
argument_list|,
name|usr_boxes
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|DMA_FLUSH
argument_list|()
expr_stmt|;
return|return
name|ret
return|;
block|}
block|}
name|DMA_FLUSH
argument_list|()
expr_stmt|;
if|if
condition|(
name|dmabuf
operator|&&
name|cmdbuf
operator|.
name|discard
condition|)
block|{
name|drm_savage_buf_priv_t
modifier|*
name|buf_priv
init|=
name|dmabuf
operator|->
name|dev_private
decl_stmt|;
name|uint16_t
name|event
decl_stmt|;
name|event
operator|=
name|savage_bci_emit_event
argument_list|(
name|dev_priv
argument_list|,
name|SAVAGE_WAIT_3D
argument_list|)
expr_stmt|;
name|SET_AGE
argument_list|(
operator|&
name|buf_priv
operator|->
name|age
argument_list|,
name|event
argument_list|,
name|dev_priv
operator|->
name|event_wrap
argument_list|)
expr_stmt|;
name|savage_freelist_put
argument_list|(
name|dev
argument_list|,
name|dmabuf
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

end_unit

