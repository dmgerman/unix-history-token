begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* drm_bufs.h -- Generic buffer template -*- linux-c -*-  * Created: Thu Nov 23 03:10:50 2000 by gareth@valinux.com  *  * Copyright 1999, 2000 Precision Insight, Inc., Cedar Park, Texas.  * Copyright 2000 VA Linux Systems, Inc., Sunnyvale, California.  * All Rights Reserved.  *  * Permission is hereby granted, free of charge, to any person obtaining a  * copy of this software and associated documentation files (the "Software"),  * to deal in the Software without restriction, including without limitation  * the rights to use, copy, modify, merge, publish, distribute, sublicense,  * and/or sell copies of the Software, and to permit persons to whom the  * Software is furnished to do so, subject to the following conditions:  *  * The above copyright notice and this permission notice (including the next  * paragraph) shall be included in all copies or substantial portions of the  * Software.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL  * VA LINUX SYSTEMS AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR  * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,  * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR  * OTHER DEALINGS IN THE SOFTWARE.  *  * Authors:  *    Rickard E. (Rik) Faith<faith@valinux.com>  *    Gareth Hughes<gareth@valinux.com>  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|"dev/drm/drmP.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|__HAVE_PCI_DMA
end_ifndef

begin_define
define|#
directive|define
name|__HAVE_PCI_DMA
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|__HAVE_SG
end_ifndef

begin_define
define|#
directive|define
name|__HAVE_SG
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DRIVER_BUF_PRIV_T
end_ifndef

begin_define
define|#
directive|define
name|DRIVER_BUF_PRIV_T
value|u32
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DRIVER_AGP_BUFFERS_MAP
end_ifndef

begin_if
if|#
directive|if
name|__HAVE_AGP
operator|&&
name|__HAVE_DMA
end_if

begin_error
error|#
directive|error
literal|"You must define DRIVER_AGP_BUFFERS_MAP()"
end_error

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DRIVER_AGP_BUFFERS_MAP
parameter_list|(
name|dev
parameter_list|)
value|NULL
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Compute order.  Can be made faster.  */
end_comment

begin_function
name|int
name|DRM
function|(
name|order
function|)
parameter_list|(
name|unsigned
name|long
name|size
parameter_list|)
block|{
name|int
name|order
decl_stmt|;
name|unsigned
name|long
name|tmp
decl_stmt|;
for|for
control|(
name|order
operator|=
literal|0
operator|,
name|tmp
operator|=
name|size
init|;
name|tmp
operator|>>=
literal|1
condition|;
operator|++
name|order
control|)
empty_stmt|;
if|if
condition|(
name|size
operator|&
operator|~
operator|(
literal|1
operator|<<
name|order
operator|)
condition|)
operator|++
name|order
expr_stmt|;
return|return
name|order
return|;
block|}
end_function

begin_function
name|int
name|DRM
function|(
name|addmap
function|)
parameter_list|(
name|DRM_IOCTL_ARGS
parameter_list|)
block|{
name|DRM_DEVICE
expr_stmt|;
name|drm_map_t
name|request
decl_stmt|;
name|drm_local_map_t
modifier|*
name|map
decl_stmt|;
name|drm_map_list_entry_t
modifier|*
name|list
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|dev
operator|->
name|flags
operator|&
operator|(
name|FREAD
operator||
name|FWRITE
operator|)
operator|)
condition|)
return|return
name|DRM_ERR
argument_list|(
name|EACCES
argument_list|)
return|;
comment|/* Require read/write */
name|DRM_COPY_FROM_USER_IOCTL
argument_list|(
name|request
argument_list|,
operator|(
name|drm_map_t
operator|*
operator|)
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|drm_map_t
argument_list|)
argument_list|)
expr_stmt|;
name|map
operator|=
operator|(
name|drm_local_map_t
operator|*
operator|)
name|DRM
argument_list|(
name|alloc
argument_list|)
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|map
argument_list|)
argument_list|,
name|DRM_MEM_MAPS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|map
condition|)
return|return
name|DRM_ERR
argument_list|(
name|ENOMEM
argument_list|)
return|;
name|map
operator|->
name|offset
operator|=
name|request
operator|.
name|offset
expr_stmt|;
name|map
operator|->
name|size
operator|=
name|request
operator|.
name|size
expr_stmt|;
name|map
operator|->
name|type
operator|=
name|request
operator|.
name|type
expr_stmt|;
name|map
operator|->
name|flags
operator|=
name|request
operator|.
name|flags
expr_stmt|;
name|map
operator|->
name|mtrr
operator|=
operator|-
literal|1
expr_stmt|;
name|map
operator|->
name|handle
operator|=
literal|0
expr_stmt|;
comment|/* Only allow shared memory to be removable since we only keep enough 	 * book keeping information about shared memory to allow for removal 	 * when processes fork. 	 */
if|if
condition|(
operator|(
name|map
operator|->
name|flags
operator|&
name|_DRM_REMOVABLE
operator|)
operator|&&
name|map
operator|->
name|type
operator|!=
name|_DRM_SHM
condition|)
block|{
name|DRM
argument_list|(
name|free
argument_list|)
argument_list|(
name|map
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|map
argument_list|)
argument_list|,
name|DRM_MEM_MAPS
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
name|DRM_DEBUG
argument_list|(
literal|"offset = 0x%08lx, size = 0x%08lx, type = %d\n"
argument_list|,
name|map
operator|->
name|offset
argument_list|,
name|map
operator|->
name|size
argument_list|,
name|map
operator|->
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|map
operator|->
name|offset
operator|&
name|PAGE_MASK
operator|)
operator|||
operator|(
name|map
operator|->
name|size
operator|&
name|PAGE_MASK
operator|)
condition|)
block|{
name|DRM
argument_list|(
name|free
argument_list|)
argument_list|(
name|map
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|map
argument_list|)
argument_list|,
name|DRM_MEM_MAPS
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
switch|switch
condition|(
name|map
operator|->
name|type
condition|)
block|{
case|case
name|_DRM_REGISTERS
case|:
case|case
name|_DRM_FRAME_BUFFER
case|:
if|if
condition|(
name|map
operator|->
name|offset
operator|+
name|map
operator|->
name|size
operator|<
name|map
operator|->
name|offset
condition|)
block|{
name|DRM
argument_list|(
name|free
argument_list|)
argument_list|(
name|map
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|map
argument_list|)
argument_list|,
name|DRM_MEM_MAPS
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
if|#
directive|if
name|__REALLY_HAVE_MTRR
if|if
condition|(
name|map
operator|->
name|type
operator|==
name|_DRM_FRAME_BUFFER
operator|||
operator|(
name|map
operator|->
name|flags
operator|&
name|_DRM_WRITE_COMBINING
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|__FreeBSD__
name|int
name|retcode
init|=
literal|0
decl_stmt|,
name|act
decl_stmt|;
name|struct
name|mem_range_desc
name|mrdesc
decl_stmt|;
name|mrdesc
operator|.
name|mr_base
operator|=
name|map
operator|->
name|offset
expr_stmt|;
name|mrdesc
operator|.
name|mr_len
operator|=
name|map
operator|->
name|size
expr_stmt|;
name|mrdesc
operator|.
name|mr_flags
operator|=
name|MDF_WRITECOMBINE
expr_stmt|;
name|act
operator|=
name|MEMRANGE_SET_UPDATE
expr_stmt|;
name|bcopy
argument_list|(
name|DRIVER_NAME
argument_list|,
operator|&
name|mrdesc
operator|.
name|mr_owner
argument_list|,
name|strlen
argument_list|(
name|DRIVER_NAME
argument_list|)
argument_list|)
expr_stmt|;
name|retcode
operator|=
name|mem_range_attr_set
argument_list|(
operator|&
name|mrdesc
argument_list|,
operator|&
name|act
argument_list|)
expr_stmt|;
name|map
operator|->
name|mtrr
operator|=
literal|1
expr_stmt|;
elif|#
directive|elif
name|defined
name|__NetBSD__
name|struct
name|mtrr
name|mtrrmap
decl_stmt|;
name|int
name|one
init|=
literal|1
decl_stmt|;
name|mtrrmap
operator|.
name|base
operator|=
name|map
operator|->
name|offset
expr_stmt|;
name|mtrrmap
operator|.
name|len
operator|=
name|map
operator|->
name|size
expr_stmt|;
name|mtrrmap
operator|.
name|type
operator|=
name|MTRR_TYPE_WC
expr_stmt|;
name|mtrrmap
operator|.
name|flags
operator|=
name|MTRR_VALID
expr_stmt|;
name|map
operator|->
name|mtrr
operator|=
name|mtrr_set
argument_list|(
operator|&
name|mtrrmap
argument_list|,
operator|&
name|one
argument_list|,
name|p
argument_list|,
name|MTRR_GETSET_KERNEL
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
endif|#
directive|endif
comment|/* __REALLY_HAVE_MTRR */
name|DRM_IOREMAP
argument_list|(
name|map
argument_list|,
name|dev
argument_list|)
expr_stmt|;
break|break;
case|case
name|_DRM_SHM
case|:
name|map
operator|->
name|handle
operator|=
operator|(
name|void
operator|*
operator|)
name|DRM
argument_list|(
name|alloc
argument_list|)
argument_list|(
name|map
operator|->
name|size
argument_list|,
name|DRM_MEM_SAREA
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"%lu %d %p\n"
argument_list|,
name|map
operator|->
name|size
argument_list|,
name|DRM
argument_list|(
name|order
argument_list|)
argument_list|(
name|map
operator|->
name|size
argument_list|)
argument_list|,
name|map
operator|->
name|handle
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|map
operator|->
name|handle
condition|)
block|{
name|DRM
argument_list|(
name|free
argument_list|)
argument_list|(
name|map
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|map
argument_list|)
argument_list|,
name|DRM_MEM_MAPS
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|ENOMEM
argument_list|)
return|;
block|}
name|map
operator|->
name|offset
operator|=
operator|(
name|unsigned
name|long
operator|)
name|map
operator|->
name|handle
expr_stmt|;
if|if
condition|(
name|map
operator|->
name|flags
operator|&
name|_DRM_CONTAINS_LOCK
condition|)
block|{
name|dev
operator|->
name|lock
operator|.
name|hw_lock
operator|=
name|map
operator|->
name|handle
expr_stmt|;
comment|/* Pointer to lock */
block|}
break|break;
if|#
directive|if
name|__REALLY_HAVE_AGP
case|case
name|_DRM_AGP
case|:
name|map
operator|->
name|offset
operator|+=
name|dev
operator|->
name|agp
operator|->
name|base
expr_stmt|;
name|map
operator|->
name|mtrr
operator|=
name|dev
operator|->
name|agp
operator|->
name|agp_mtrr
expr_stmt|;
comment|/* for getmap */
break|break;
endif|#
directive|endif
case|case
name|_DRM_SCATTER_GATHER
case|:
if|if
condition|(
operator|!
name|dev
operator|->
name|sg
condition|)
block|{
name|DRM
argument_list|(
name|free
argument_list|)
argument_list|(
name|map
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|map
argument_list|)
argument_list|,
name|DRM_MEM_MAPS
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
name|map
operator|->
name|offset
operator|=
name|map
operator|->
name|offset
operator|+
name|dev
operator|->
name|sg
operator|->
name|handle
expr_stmt|;
break|break;
default|default:
name|DRM
argument_list|(
name|free
argument_list|)
argument_list|(
name|map
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|map
argument_list|)
argument_list|,
name|DRM_MEM_MAPS
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
name|list
operator|=
name|DRM
argument_list|(
name|alloc
argument_list|)
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|list
argument_list|)
argument_list|,
name|DRM_MEM_MAPS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|list
condition|)
block|{
name|DRM
argument_list|(
name|free
argument_list|)
argument_list|(
name|map
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|map
argument_list|)
argument_list|,
name|DRM_MEM_MAPS
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
name|memset
argument_list|(
name|list
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|list
argument_list|)
argument_list|)
expr_stmt|;
name|list
operator|->
name|map
operator|=
name|map
expr_stmt|;
name|DRM_LOCK
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
name|dev
operator|->
name|maplist
argument_list|,
name|list
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|DRM_UNLOCK
expr_stmt|;
name|request
operator|.
name|offset
operator|=
name|map
operator|->
name|offset
expr_stmt|;
name|request
operator|.
name|size
operator|=
name|map
operator|->
name|size
expr_stmt|;
name|request
operator|.
name|type
operator|=
name|map
operator|->
name|type
expr_stmt|;
name|request
operator|.
name|flags
operator|=
name|map
operator|->
name|flags
expr_stmt|;
name|request
operator|.
name|mtrr
operator|=
name|map
operator|->
name|mtrr
expr_stmt|;
name|request
operator|.
name|handle
operator|=
name|map
operator|->
name|handle
expr_stmt|;
if|if
condition|(
name|request
operator|.
name|type
operator|!=
name|_DRM_SHM
condition|)
block|{
name|request
operator|.
name|handle
operator|=
operator|(
name|void
operator|*
operator|)
name|request
operator|.
name|offset
expr_stmt|;
block|}
name|DRM_COPY_TO_USER_IOCTL
argument_list|(
operator|(
name|drm_map_t
operator|*
operator|)
name|data
argument_list|,
name|request
argument_list|,
sizeof|sizeof
argument_list|(
name|drm_map_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Remove a map private from list and deallocate resources if the mapping  * isn't in use.  */
end_comment

begin_function
name|int
name|DRM
function|(
name|rmmap
function|)
parameter_list|(
name|DRM_IOCTL_ARGS
parameter_list|)
block|{
name|DRM_DEVICE
expr_stmt|;
name|drm_map_list_entry_t
modifier|*
name|list
decl_stmt|;
name|drm_local_map_t
modifier|*
name|map
decl_stmt|;
name|drm_map_t
name|request
decl_stmt|;
name|int
name|found_maps
init|=
literal|0
decl_stmt|;
name|DRM_COPY_FROM_USER_IOCTL
argument_list|(
name|request
argument_list|,
operator|(
name|drm_map_t
operator|*
operator|)
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|request
argument_list|)
argument_list|)
expr_stmt|;
name|DRM_LOCK
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|list
argument_list|,
argument|dev->maplist
argument_list|,
argument|link
argument_list|)
block|{
name|map
operator|=
name|list
operator|->
name|map
expr_stmt|;
if|if
condition|(
name|map
operator|->
name|handle
operator|==
name|request
operator|.
name|handle
operator|&&
name|map
operator|->
name|flags
operator|&
name|_DRM_REMOVABLE
condition|)
break|break;
block|}
comment|/* List has wrapped around to the head pointer, or its empty we didn't 	 * find anything. 	 */
if|if
condition|(
name|list
operator|==
name|NULL
condition|)
block|{
name|DRM_UNLOCK
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
name|TAILQ_REMOVE
argument_list|(
name|dev
operator|->
name|maplist
argument_list|,
name|list
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|DRM
argument_list|(
name|free
argument_list|)
argument_list|(
name|list
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|list
argument_list|)
argument_list|,
name|DRM_MEM_MAPS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|found_maps
condition|)
block|{
switch|switch
condition|(
name|map
operator|->
name|type
condition|)
block|{
case|case
name|_DRM_REGISTERS
case|:
case|case
name|_DRM_FRAME_BUFFER
case|:
if|#
directive|if
name|__REALLY_HAVE_MTRR
if|if
condition|(
name|map
operator|->
name|mtrr
operator|>=
literal|0
condition|)
block|{
name|int
name|retcode
decl_stmt|;
ifdef|#
directive|ifdef
name|__FreeBSD__
name|int
name|act
decl_stmt|;
name|struct
name|mem_range_desc
name|mrdesc
decl_stmt|;
name|mrdesc
operator|.
name|mr_base
operator|=
name|map
operator|->
name|offset
expr_stmt|;
name|mrdesc
operator|.
name|mr_len
operator|=
name|map
operator|->
name|size
expr_stmt|;
name|mrdesc
operator|.
name|mr_flags
operator|=
name|MDF_WRITECOMBINE
expr_stmt|;
name|act
operator|=
name|MEMRANGE_SET_REMOVE
expr_stmt|;
name|bcopy
argument_list|(
name|DRIVER_NAME
argument_list|,
operator|&
name|mrdesc
operator|.
name|mr_owner
argument_list|,
name|strlen
argument_list|(
name|DRIVER_NAME
argument_list|)
argument_list|)
expr_stmt|;
name|retcode
operator|=
name|mem_range_attr_set
argument_list|(
operator|&
name|mrdesc
argument_list|,
operator|&
name|act
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
name|__NetBSD__
name|struct
name|mtrr
name|mtrrmap
decl_stmt|;
name|int
name|one
init|=
literal|1
decl_stmt|;
name|mtrrmap
operator|.
name|base
operator|=
name|map
operator|->
name|offset
expr_stmt|;
name|mtrrmap
operator|.
name|len
operator|=
name|map
operator|->
name|size
expr_stmt|;
name|mtrrmap
operator|.
name|type
operator|=
literal|0
expr_stmt|;
name|mtrrmap
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|mtrrmap
operator|.
name|owner
operator|=
name|p
operator|->
name|p_pid
expr_stmt|;
name|retcode
operator|=
name|mtrr_set
argument_list|(
operator|&
name|mtrrmap
argument_list|,
operator|&
name|one
argument_list|,
name|p
argument_list|,
name|MTRR_GETSET_KERNEL
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"mtrr_del = %d\n"
argument_list|,
name|retcode
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
endif|#
directive|endif
name|DRM
function_decl|(
name|ioremapfree
function_decl|)
parameter_list|(
name|map
parameter_list|)
function_decl|;
break|break;
case|case
name|_DRM_SHM
case|:
name|DRM
function_decl|(
name|free
function_decl|)
parameter_list|(
name|map
operator|->
name|handle
parameter_list|,
name|map
operator|->
name|size
parameter_list|,
name|DRM_MEM_SAREA
parameter_list|)
function_decl|;
break|break;
case|case
name|_DRM_AGP
case|:
case|case
name|_DRM_SCATTER_GATHER
case|:
break|break;
block|}
name|DRM
argument_list|(
name|free
argument_list|)
argument_list|(
name|map
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|map
argument_list|)
argument_list|,
name|DRM_MEM_MAPS
argument_list|)
expr_stmt|;
block|}
name|DRM_UNLOCK
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_if
if|#
directive|if
name|__HAVE_DMA
end_if

begin_function
specifier|static
name|void
name|DRM
function|(
name|cleanup_buf_error
function|)
parameter_list|(
name|drm_device_t
modifier|*
name|dev
parameter_list|,
name|drm_buf_entry_t
modifier|*
name|entry
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|#
directive|if
name|__HAVE_PCI_DMA
if|if
condition|(
name|entry
operator|->
name|seg_count
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|entry
operator|->
name|seg_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|entry
operator|->
name|seglist
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
name|DRM
argument_list|(
name|pci_free
argument_list|)
argument_list|(
name|dev
argument_list|,
name|entry
operator|->
name|buf_size
argument_list|,
operator|(
name|void
operator|*
operator|)
name|entry
operator|->
name|seglist
index|[
name|i
index|]
argument_list|,
name|entry
operator|->
name|seglist_bus
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|DRM
argument_list|(
name|free
argument_list|)
argument_list|(
name|entry
operator|->
name|seglist
argument_list|,
name|entry
operator|->
name|seg_count
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|entry
operator|->
name|seglist
argument_list|)
argument_list|,
name|DRM_MEM_SEGS
argument_list|)
expr_stmt|;
name|DRM
argument_list|(
name|free
argument_list|)
argument_list|(
name|entry
operator|->
name|seglist_bus
argument_list|,
name|entry
operator|->
name|seg_count
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|entry
operator|->
name|seglist_bus
argument_list|)
argument_list|,
name|DRM_MEM_SEGS
argument_list|)
expr_stmt|;
name|entry
operator|->
name|seg_count
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* __HAVE_PCI_DMA */
if|if
condition|(
name|entry
operator|->
name|buf_count
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|entry
operator|->
name|buf_count
condition|;
name|i
operator|++
control|)
block|{
name|DRM
argument_list|(
name|free
argument_list|)
argument_list|(
name|entry
operator|->
name|buflist
index|[
name|i
index|]
operator|.
name|dev_private
argument_list|,
name|entry
operator|->
name|buflist
index|[
name|i
index|]
operator|.
name|dev_priv_size
argument_list|,
name|DRM_MEM_BUFS
argument_list|)
expr_stmt|;
block|}
name|DRM
argument_list|(
name|free
argument_list|)
argument_list|(
name|entry
operator|->
name|buflist
argument_list|,
name|entry
operator|->
name|buf_count
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|entry
operator|->
name|buflist
argument_list|)
argument_list|,
name|DRM_MEM_BUFS
argument_list|)
expr_stmt|;
name|entry
operator|->
name|buf_count
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_if
if|#
directive|if
name|__REALLY_HAVE_AGP
end_if

begin_function
specifier|static
name|int
name|DRM
function|(
name|addbufs_agp
function|)
parameter_list|(
name|drm_device_t
modifier|*
name|dev
parameter_list|,
name|drm_buf_desc_t
modifier|*
name|request
parameter_list|)
block|{
name|drm_device_dma_t
modifier|*
name|dma
init|=
name|dev
operator|->
name|dma
decl_stmt|;
name|drm_buf_entry_t
modifier|*
name|entry
decl_stmt|;
name|drm_buf_t
modifier|*
name|buf
decl_stmt|;
name|unsigned
name|long
name|offset
decl_stmt|;
name|unsigned
name|long
name|agp_offset
decl_stmt|;
name|int
name|count
decl_stmt|;
name|int
name|order
decl_stmt|;
name|int
name|size
decl_stmt|;
name|int
name|alignment
decl_stmt|;
name|int
name|page_order
decl_stmt|;
name|int
name|total
decl_stmt|;
name|int
name|byte_count
decl_stmt|;
name|int
name|i
decl_stmt|;
name|drm_buf_t
modifier|*
modifier|*
name|temp_buflist
decl_stmt|;
name|count
operator|=
name|request
operator|->
name|count
expr_stmt|;
name|order
operator|=
name|DRM
argument_list|(
name|order
argument_list|)
argument_list|(
name|request
operator|->
name|size
argument_list|)
expr_stmt|;
name|size
operator|=
literal|1
operator|<<
name|order
expr_stmt|;
name|alignment
operator|=
operator|(
name|request
operator|->
name|flags
operator|&
name|_DRM_PAGE_ALIGN
operator|)
condition|?
name|round_page
argument_list|(
name|size
argument_list|)
else|:
name|size
expr_stmt|;
name|page_order
operator|=
name|order
operator|-
name|PAGE_SHIFT
operator|>
literal|0
condition|?
name|order
operator|-
name|PAGE_SHIFT
else|:
literal|0
expr_stmt|;
name|total
operator|=
name|PAGE_SIZE
operator|<<
name|page_order
expr_stmt|;
name|byte_count
operator|=
literal|0
expr_stmt|;
name|agp_offset
operator|=
name|dev
operator|->
name|agp
operator|->
name|base
operator|+
name|request
operator|->
name|agp_start
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"count:      %d\n"
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"order:      %d\n"
argument_list|,
name|order
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"size:       %d\n"
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"agp_offset: 0x%lx\n"
argument_list|,
name|agp_offset
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"alignment:  %d\n"
argument_list|,
name|alignment
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"page_order: %d\n"
argument_list|,
name|page_order
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"total:      %d\n"
argument_list|,
name|total
argument_list|)
expr_stmt|;
if|if
condition|(
name|order
operator|<
name|DRM_MIN_ORDER
operator|||
name|order
operator|>
name|DRM_MAX_ORDER
condition|)
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
name|DRM_LOCK
expr_stmt|;
name|entry
operator|=
operator|&
name|dma
operator|->
name|bufs
index|[
name|order
index|]
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|buf_count
condition|)
block|{
name|DRM_UNLOCK
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|ENOMEM
argument_list|)
return|;
comment|/* May only call once for each order */
block|}
name|entry
operator|->
name|buflist
operator|=
name|DRM
argument_list|(
name|alloc
argument_list|)
argument_list|(
name|count
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|entry
operator|->
name|buflist
argument_list|)
argument_list|,
name|DRM_MEM_BUFS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|entry
operator|->
name|buflist
condition|)
block|{
name|DRM_UNLOCK
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|ENOMEM
argument_list|)
return|;
block|}
name|memset
argument_list|(
name|entry
operator|->
name|buflist
argument_list|,
literal|0
argument_list|,
name|count
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|entry
operator|->
name|buflist
argument_list|)
argument_list|)
expr_stmt|;
name|entry
operator|->
name|buf_size
operator|=
name|size
expr_stmt|;
name|entry
operator|->
name|page_order
operator|=
name|page_order
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|entry
operator|->
name|buf_count
operator|<
name|count
condition|)
block|{
name|buf
operator|=
operator|&
name|entry
operator|->
name|buflist
index|[
name|entry
operator|->
name|buf_count
index|]
expr_stmt|;
name|buf
operator|->
name|idx
operator|=
name|dma
operator|->
name|buf_count
operator|+
name|entry
operator|->
name|buf_count
expr_stmt|;
name|buf
operator|->
name|total
operator|=
name|alignment
expr_stmt|;
name|buf
operator|->
name|order
operator|=
name|order
expr_stmt|;
name|buf
operator|->
name|used
operator|=
literal|0
expr_stmt|;
name|buf
operator|->
name|offset
operator|=
operator|(
name|dma
operator|->
name|byte_count
operator|+
name|offset
operator|)
expr_stmt|;
name|buf
operator|->
name|bus_address
operator|=
name|agp_offset
operator|+
name|offset
expr_stmt|;
name|buf
operator|->
name|address
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|agp_offset
operator|+
name|offset
operator|)
expr_stmt|;
name|buf
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|buf
operator|->
name|pending
operator|=
literal|0
expr_stmt|;
name|buf
operator|->
name|filp
operator|=
name|NULL
expr_stmt|;
name|buf
operator|->
name|dev_priv_size
operator|=
sizeof|sizeof
argument_list|(
name|DRIVER_BUF_PRIV_T
argument_list|)
expr_stmt|;
name|buf
operator|->
name|dev_private
operator|=
name|DRM
argument_list|(
name|alloc
argument_list|)
argument_list|(
sizeof|sizeof
argument_list|(
name|DRIVER_BUF_PRIV_T
argument_list|)
argument_list|,
name|DRM_MEM_BUFS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buf
operator|->
name|dev_private
condition|)
block|{
comment|/* Set count correctly so we free the proper amount. */
name|entry
operator|->
name|buf_count
operator|=
name|count
expr_stmt|;
name|DRM
function_decl|(
name|cleanup_buf_error
function_decl|)
parameter_list|(
name|dev
parameter_list|,
name|entry
parameter_list|)
function_decl|;
name|DRM_UNLOCK
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|ENOMEM
argument_list|)
return|;
block|}
name|memset
argument_list|(
name|buf
operator|->
name|dev_private
argument_list|,
literal|0
argument_list|,
name|buf
operator|->
name|dev_priv_size
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|alignment
expr_stmt|;
name|entry
operator|->
name|buf_count
operator|++
expr_stmt|;
name|byte_count
operator|+=
name|PAGE_SIZE
operator|<<
name|page_order
expr_stmt|;
block|}
name|DRM_DEBUG
argument_list|(
literal|"byte_count: %d\n"
argument_list|,
name|byte_count
argument_list|)
expr_stmt|;
name|temp_buflist
operator|=
name|DRM
argument_list|(
name|realloc
argument_list|)
argument_list|(
name|dma
operator|->
name|buflist
argument_list|,
name|dma
operator|->
name|buf_count
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|dma
operator|->
name|buflist
argument_list|)
argument_list|,
operator|(
name|dma
operator|->
name|buf_count
operator|+
name|entry
operator|->
name|buf_count
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|dma
operator|->
name|buflist
argument_list|)
argument_list|,
name|DRM_MEM_BUFS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|temp_buflist
condition|)
block|{
comment|/* Free the entry because it isn't valid */
name|DRM
function_decl|(
name|cleanup_buf_error
function_decl|)
parameter_list|(
name|dev
parameter_list|,
name|entry
parameter_list|)
function_decl|;
name|DRM_UNLOCK
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|ENOMEM
argument_list|)
return|;
block|}
name|dma
operator|->
name|buflist
operator|=
name|temp_buflist
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|entry
operator|->
name|buf_count
condition|;
name|i
operator|++
control|)
block|{
name|dma
operator|->
name|buflist
index|[
name|i
operator|+
name|dma
operator|->
name|buf_count
index|]
operator|=
operator|&
name|entry
operator|->
name|buflist
index|[
name|i
index|]
expr_stmt|;
block|}
name|dma
operator|->
name|buf_count
operator|+=
name|entry
operator|->
name|buf_count
expr_stmt|;
name|dma
operator|->
name|byte_count
operator|+=
name|byte_count
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"dma->buf_count : %d\n"
argument_list|,
name|dma
operator|->
name|buf_count
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"entry->buf_count : %d\n"
argument_list|,
name|entry
operator|->
name|buf_count
argument_list|)
expr_stmt|;
name|DRM_UNLOCK
expr_stmt|;
name|request
operator|->
name|count
operator|=
name|entry
operator|->
name|buf_count
expr_stmt|;
name|request
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|dma
operator|->
name|flags
operator|=
name|_DRM_DMA_USE_AGP
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __REALLY_HAVE_AGP */
end_comment

begin_if
if|#
directive|if
name|__HAVE_PCI_DMA
end_if

begin_function
specifier|static
name|int
name|DRM
function|(
name|addbufs_pci
function|)
parameter_list|(
name|drm_device_t
modifier|*
name|dev
parameter_list|,
name|drm_buf_desc_t
modifier|*
name|request
parameter_list|)
block|{
name|drm_device_dma_t
modifier|*
name|dma
init|=
name|dev
operator|->
name|dma
decl_stmt|;
name|int
name|count
decl_stmt|;
name|int
name|order
decl_stmt|;
name|int
name|size
decl_stmt|;
name|int
name|total
decl_stmt|;
name|int
name|page_order
decl_stmt|;
name|drm_buf_entry_t
modifier|*
name|entry
decl_stmt|;
name|vm_offset_t
name|vaddr
decl_stmt|;
name|drm_buf_t
modifier|*
name|buf
decl_stmt|;
name|int
name|alignment
decl_stmt|;
name|unsigned
name|long
name|offset
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|byte_count
decl_stmt|;
name|int
name|page_count
decl_stmt|;
name|unsigned
name|long
modifier|*
name|temp_pagelist
decl_stmt|;
name|drm_buf_t
modifier|*
modifier|*
name|temp_buflist
decl_stmt|;
name|dma_addr_t
name|bus_addr
decl_stmt|;
name|count
operator|=
name|request
operator|->
name|count
expr_stmt|;
name|order
operator|=
name|DRM
argument_list|(
name|order
argument_list|)
argument_list|(
name|request
operator|->
name|size
argument_list|)
expr_stmt|;
name|size
operator|=
literal|1
operator|<<
name|order
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"count=%d, size=%d (%d), order=%d\n"
argument_list|,
name|request
operator|->
name|count
argument_list|,
name|request
operator|->
name|size
argument_list|,
name|size
argument_list|,
name|order
argument_list|)
expr_stmt|;
if|if
condition|(
name|order
operator|<
name|DRM_MIN_ORDER
operator|||
name|order
operator|>
name|DRM_MAX_ORDER
condition|)
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
name|alignment
operator|=
operator|(
name|request
operator|->
name|flags
operator|&
name|_DRM_PAGE_ALIGN
operator|)
condition|?
name|round_page
argument_list|(
name|size
argument_list|)
else|:
name|size
expr_stmt|;
name|page_order
operator|=
name|order
operator|-
name|PAGE_SHIFT
operator|>
literal|0
condition|?
name|order
operator|-
name|PAGE_SHIFT
else|:
literal|0
expr_stmt|;
name|total
operator|=
name|PAGE_SIZE
operator|<<
name|page_order
expr_stmt|;
name|DRM_LOCK
expr_stmt|;
name|entry
operator|=
operator|&
name|dma
operator|->
name|bufs
index|[
name|order
index|]
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|buf_count
condition|)
block|{
name|DRM_UNLOCK
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|ENOMEM
argument_list|)
return|;
comment|/* May only call once for each order */
block|}
name|entry
operator|->
name|buflist
operator|=
name|DRM
argument_list|(
name|alloc
argument_list|)
argument_list|(
name|count
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|entry
operator|->
name|buflist
argument_list|)
argument_list|,
name|DRM_MEM_BUFS
argument_list|)
expr_stmt|;
name|entry
operator|->
name|seglist
operator|=
name|DRM
argument_list|(
name|alloc
argument_list|)
argument_list|(
name|count
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|entry
operator|->
name|seglist
argument_list|)
argument_list|,
name|DRM_MEM_SEGS
argument_list|)
expr_stmt|;
name|entry
operator|->
name|seglist_bus
operator|=
name|DRM
argument_list|(
name|alloc
argument_list|)
argument_list|(
name|count
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|entry
operator|->
name|seglist_bus
argument_list|)
argument_list|,
name|DRM_MEM_SEGS
argument_list|)
expr_stmt|;
comment|/* Keep the original pagelist until we know all the allocations 	 * have succeeded 	 */
name|temp_pagelist
operator|=
name|DRM
argument_list|(
name|alloc
argument_list|)
argument_list|(
operator|(
name|dma
operator|->
name|page_count
operator|+
operator|(
name|count
operator|<<
name|page_order
operator|)
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|dma
operator|->
name|pagelist
argument_list|)
argument_list|,
name|DRM_MEM_PAGES
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|buflist
operator|==
name|NULL
operator|||
name|entry
operator|->
name|seglist
operator|==
name|NULL
operator|||
name|temp_pagelist
operator|==
name|NULL
condition|)
block|{
name|DRM
argument_list|(
name|free
argument_list|)
argument_list|(
name|entry
operator|->
name|buflist
argument_list|,
name|count
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|entry
operator|->
name|buflist
argument_list|)
argument_list|,
name|DRM_MEM_BUFS
argument_list|)
expr_stmt|;
name|DRM
argument_list|(
name|free
argument_list|)
argument_list|(
name|entry
operator|->
name|seglist
argument_list|,
name|count
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|entry
operator|->
name|seglist
argument_list|)
argument_list|,
name|DRM_MEM_SEGS
argument_list|)
expr_stmt|;
name|DRM
argument_list|(
name|free
argument_list|)
argument_list|(
name|entry
operator|->
name|seglist_bus
argument_list|,
name|count
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|entry
operator|->
name|seglist_bus
argument_list|)
argument_list|,
name|DRM_MEM_SEGS
argument_list|)
expr_stmt|;
name|DRM_UNLOCK
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|ENOMEM
argument_list|)
return|;
block|}
name|bzero
argument_list|(
name|entry
operator|->
name|buflist
argument_list|,
name|count
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|entry
operator|->
name|buflist
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|entry
operator|->
name|seglist
argument_list|,
name|count
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|entry
operator|->
name|seglist
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|temp_pagelist
argument_list|,
name|dma
operator|->
name|pagelist
argument_list|,
name|dma
operator|->
name|page_count
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|dma
operator|->
name|pagelist
argument_list|)
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"pagelist: %d entries\n"
argument_list|,
name|dma
operator|->
name|page_count
operator|+
operator|(
name|count
operator|<<
name|page_order
operator|)
argument_list|)
expr_stmt|;
name|entry
operator|->
name|buf_size
operator|=
name|size
expr_stmt|;
name|entry
operator|->
name|page_order
operator|=
name|page_order
expr_stmt|;
name|byte_count
operator|=
literal|0
expr_stmt|;
name|page_count
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|entry
operator|->
name|buf_count
operator|<
name|count
condition|)
block|{
name|vaddr
operator|=
call|(
name|vm_offset_t
call|)
name|DRM
argument_list|(
argument|pci_alloc
argument_list|)
argument_list|(
name|dev
argument_list|,
name|size
argument_list|,
name|alignment
argument_list|,
literal|0xfffffffful
argument_list|,
operator|&
name|bus_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|vaddr
operator|==
name|NULL
condition|)
block|{
comment|/* Set count correctly so we free the proper amount. */
name|entry
operator|->
name|buf_count
operator|=
name|count
expr_stmt|;
name|entry
operator|->
name|seg_count
operator|=
name|count
expr_stmt|;
name|DRM
function_decl|(
name|cleanup_buf_error
function_decl|)
parameter_list|(
name|dev
parameter_list|,
name|entry
parameter_list|)
function_decl|;
name|DRM
argument_list|(
name|free
argument_list|)
argument_list|(
name|temp_pagelist
argument_list|,
operator|(
name|dma
operator|->
name|page_count
operator|+
operator|(
name|count
operator|<<
name|page_order
operator|)
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|dma
operator|->
name|pagelist
argument_list|)
argument_list|,
name|DRM_MEM_PAGES
argument_list|)
expr_stmt|;
name|DRM_UNLOCK
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|ENOMEM
argument_list|)
return|;
block|}
name|entry
operator|->
name|seglist_bus
index|[
name|entry
operator|->
name|seg_count
index|]
operator|=
name|bus_addr
expr_stmt|;
name|entry
operator|->
name|seglist
index|[
name|entry
operator|->
name|seg_count
operator|++
index|]
operator|=
name|vaddr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
literal|1
operator|<<
name|page_order
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"page %d @ 0x%08lx\n"
argument_list|,
name|dma
operator|->
name|page_count
operator|+
name|page_count
argument_list|,
operator|(
name|long
operator|)
name|vaddr
operator|+
name|PAGE_SIZE
operator|*
name|i
argument_list|)
expr_stmt|;
name|temp_pagelist
index|[
name|dma
operator|->
name|page_count
operator|+
name|page_count
operator|++
index|]
operator|=
name|vaddr
operator|+
name|PAGE_SIZE
operator|*
name|i
expr_stmt|;
block|}
for|for
control|(
name|offset
operator|=
literal|0
init|;
name|offset
operator|+
name|size
operator|<=
name|total
operator|&&
name|entry
operator|->
name|buf_count
operator|<
name|count
condition|;
name|offset
operator|+=
name|alignment
operator|,
operator|++
name|entry
operator|->
name|buf_count
control|)
block|{
name|buf
operator|=
operator|&
name|entry
operator|->
name|buflist
index|[
name|entry
operator|->
name|buf_count
index|]
expr_stmt|;
name|buf
operator|->
name|idx
operator|=
name|dma
operator|->
name|buf_count
operator|+
name|entry
operator|->
name|buf_count
expr_stmt|;
name|buf
operator|->
name|total
operator|=
name|alignment
expr_stmt|;
name|buf
operator|->
name|order
operator|=
name|order
expr_stmt|;
name|buf
operator|->
name|used
operator|=
literal|0
expr_stmt|;
name|buf
operator|->
name|offset
operator|=
operator|(
name|dma
operator|->
name|byte_count
operator|+
name|byte_count
operator|+
name|offset
operator|)
expr_stmt|;
name|buf
operator|->
name|address
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|vaddr
operator|+
name|offset
operator|)
expr_stmt|;
name|buf
operator|->
name|bus_address
operator|=
name|bus_addr
operator|+
name|offset
expr_stmt|;
name|buf
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|buf
operator|->
name|pending
operator|=
literal|0
expr_stmt|;
name|buf
operator|->
name|filp
operator|=
name|NULL
expr_stmt|;
name|buf
operator|->
name|dev_priv_size
operator|=
sizeof|sizeof
argument_list|(
name|DRIVER_BUF_PRIV_T
argument_list|)
expr_stmt|;
name|buf
operator|->
name|dev_private
operator|=
name|DRM
argument_list|(
name|alloc
argument_list|)
argument_list|(
sizeof|sizeof
argument_list|(
name|DRIVER_BUF_PRIV_T
argument_list|)
argument_list|,
name|DRM_MEM_BUFS
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|->
name|dev_private
operator|==
name|NULL
condition|)
block|{
comment|/* Set count correctly so we free the proper amount. */
name|entry
operator|->
name|buf_count
operator|=
name|count
expr_stmt|;
name|entry
operator|->
name|seg_count
operator|=
name|count
expr_stmt|;
name|DRM
function_decl|(
name|cleanup_buf_error
function_decl|)
parameter_list|(
name|dev
parameter_list|,
name|entry
parameter_list|)
function_decl|;
name|DRM
argument_list|(
name|free
argument_list|)
argument_list|(
name|temp_pagelist
argument_list|,
operator|(
name|dma
operator|->
name|page_count
operator|+
operator|(
name|count
operator|<<
name|page_order
operator|)
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|dma
operator|->
name|pagelist
argument_list|)
argument_list|,
name|DRM_MEM_PAGES
argument_list|)
expr_stmt|;
name|DRM_UNLOCK
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|ENOMEM
argument_list|)
return|;
block|}
name|bzero
argument_list|(
name|buf
operator|->
name|dev_private
argument_list|,
name|buf
operator|->
name|dev_priv_size
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"buffer %d @ %p\n"
argument_list|,
name|entry
operator|->
name|buf_count
argument_list|,
name|buf
operator|->
name|address
argument_list|)
expr_stmt|;
block|}
name|byte_count
operator|+=
name|PAGE_SIZE
operator|<<
name|page_order
expr_stmt|;
block|}
name|temp_buflist
operator|=
name|DRM
argument_list|(
name|realloc
argument_list|)
argument_list|(
name|dma
operator|->
name|buflist
argument_list|,
name|dma
operator|->
name|buf_count
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|dma
operator|->
name|buflist
argument_list|)
argument_list|,
operator|(
name|dma
operator|->
name|buf_count
operator|+
name|entry
operator|->
name|buf_count
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|dma
operator|->
name|buflist
argument_list|)
argument_list|,
name|DRM_MEM_BUFS
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp_buflist
operator|==
name|NULL
condition|)
block|{
comment|/* Free the entry because it isn't valid */
name|DRM
function_decl|(
name|cleanup_buf_error
function_decl|)
parameter_list|(
name|dev
parameter_list|,
name|entry
parameter_list|)
function_decl|;
name|DRM
argument_list|(
name|free
argument_list|)
argument_list|(
name|temp_pagelist
argument_list|,
operator|(
name|dma
operator|->
name|page_count
operator|+
operator|(
name|count
operator|<<
name|page_order
operator|)
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|dma
operator|->
name|pagelist
argument_list|)
argument_list|,
name|DRM_MEM_PAGES
argument_list|)
expr_stmt|;
name|DRM_UNLOCK
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|ENOMEM
argument_list|)
return|;
block|}
name|dma
operator|->
name|buflist
operator|=
name|temp_buflist
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|entry
operator|->
name|buf_count
condition|;
name|i
operator|++
control|)
block|{
name|dma
operator|->
name|buflist
index|[
name|i
operator|+
name|dma
operator|->
name|buf_count
index|]
operator|=
operator|&
name|entry
operator|->
name|buflist
index|[
name|i
index|]
expr_stmt|;
block|}
comment|/* No allocations failed, so now we can replace the orginal pagelist 	 * with the new one. 	 */
name|DRM
argument_list|(
name|free
argument_list|)
argument_list|(
name|dma
operator|->
name|pagelist
argument_list|,
name|dma
operator|->
name|page_count
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|dma
operator|->
name|pagelist
argument_list|)
argument_list|,
name|DRM_MEM_PAGES
argument_list|)
expr_stmt|;
name|dma
operator|->
name|pagelist
operator|=
name|temp_pagelist
expr_stmt|;
name|dma
operator|->
name|buf_count
operator|+=
name|entry
operator|->
name|buf_count
expr_stmt|;
name|dma
operator|->
name|seg_count
operator|+=
name|entry
operator|->
name|seg_count
expr_stmt|;
name|dma
operator|->
name|page_count
operator|+=
name|entry
operator|->
name|seg_count
operator|<<
name|page_order
expr_stmt|;
name|dma
operator|->
name|byte_count
operator|+=
name|PAGE_SIZE
operator|*
operator|(
name|entry
operator|->
name|seg_count
operator|<<
name|page_order
operator|)
expr_stmt|;
name|DRM_UNLOCK
expr_stmt|;
name|request
operator|->
name|count
operator|=
name|entry
operator|->
name|buf_count
expr_stmt|;
name|request
operator|->
name|size
operator|=
name|size
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __HAVE_PCI_DMA */
end_comment

begin_if
if|#
directive|if
name|__REALLY_HAVE_SG
end_if

begin_function
specifier|static
name|int
name|DRM
function|(
name|addbufs_sg
function|)
parameter_list|(
name|drm_device_t
modifier|*
name|dev
parameter_list|,
name|drm_buf_desc_t
modifier|*
name|request
parameter_list|)
block|{
name|drm_device_dma_t
modifier|*
name|dma
init|=
name|dev
operator|->
name|dma
decl_stmt|;
name|drm_buf_entry_t
modifier|*
name|entry
decl_stmt|;
name|drm_buf_t
modifier|*
name|buf
decl_stmt|;
name|unsigned
name|long
name|offset
decl_stmt|;
name|unsigned
name|long
name|agp_offset
decl_stmt|;
name|int
name|count
decl_stmt|;
name|int
name|order
decl_stmt|;
name|int
name|size
decl_stmt|;
name|int
name|alignment
decl_stmt|;
name|int
name|page_order
decl_stmt|;
name|int
name|total
decl_stmt|;
name|int
name|byte_count
decl_stmt|;
name|int
name|i
decl_stmt|;
name|drm_buf_t
modifier|*
modifier|*
name|temp_buflist
decl_stmt|;
name|count
operator|=
name|request
operator|->
name|count
expr_stmt|;
name|order
operator|=
name|DRM
argument_list|(
name|order
argument_list|)
argument_list|(
name|request
operator|->
name|size
argument_list|)
expr_stmt|;
name|size
operator|=
literal|1
operator|<<
name|order
expr_stmt|;
name|alignment
operator|=
operator|(
name|request
operator|->
name|flags
operator|&
name|_DRM_PAGE_ALIGN
operator|)
condition|?
name|round_page
argument_list|(
name|size
argument_list|)
else|:
name|size
expr_stmt|;
name|page_order
operator|=
name|order
operator|-
name|PAGE_SHIFT
operator|>
literal|0
condition|?
name|order
operator|-
name|PAGE_SHIFT
else|:
literal|0
expr_stmt|;
name|total
operator|=
name|PAGE_SIZE
operator|<<
name|page_order
expr_stmt|;
name|byte_count
operator|=
literal|0
expr_stmt|;
name|agp_offset
operator|=
name|request
operator|->
name|agp_start
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"count:      %d\n"
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"order:      %d\n"
argument_list|,
name|order
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"size:       %d\n"
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"agp_offset: %ld\n"
argument_list|,
name|agp_offset
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"alignment:  %d\n"
argument_list|,
name|alignment
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"page_order: %d\n"
argument_list|,
name|page_order
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"total:      %d\n"
argument_list|,
name|total
argument_list|)
expr_stmt|;
if|if
condition|(
name|order
operator|<
name|DRM_MIN_ORDER
operator|||
name|order
operator|>
name|DRM_MAX_ORDER
condition|)
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
name|DRM_LOCK
expr_stmt|;
name|entry
operator|=
operator|&
name|dma
operator|->
name|bufs
index|[
name|order
index|]
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|buf_count
condition|)
block|{
name|DRM_UNLOCK
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|ENOMEM
argument_list|)
return|;
comment|/* May only call once for each order */
block|}
name|entry
operator|->
name|buflist
operator|=
name|DRM
argument_list|(
name|alloc
argument_list|)
argument_list|(
name|count
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|entry
operator|->
name|buflist
argument_list|)
argument_list|,
name|DRM_MEM_BUFS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|entry
operator|->
name|buflist
condition|)
block|{
name|DRM_UNLOCK
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|ENOMEM
argument_list|)
return|;
block|}
name|memset
argument_list|(
name|entry
operator|->
name|buflist
argument_list|,
literal|0
argument_list|,
name|count
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|entry
operator|->
name|buflist
argument_list|)
argument_list|)
expr_stmt|;
name|entry
operator|->
name|buf_size
operator|=
name|size
expr_stmt|;
name|entry
operator|->
name|page_order
operator|=
name|page_order
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|entry
operator|->
name|buf_count
operator|<
name|count
condition|)
block|{
name|buf
operator|=
operator|&
name|entry
operator|->
name|buflist
index|[
name|entry
operator|->
name|buf_count
index|]
expr_stmt|;
name|buf
operator|->
name|idx
operator|=
name|dma
operator|->
name|buf_count
operator|+
name|entry
operator|->
name|buf_count
expr_stmt|;
name|buf
operator|->
name|total
operator|=
name|alignment
expr_stmt|;
name|buf
operator|->
name|order
operator|=
name|order
expr_stmt|;
name|buf
operator|->
name|used
operator|=
literal|0
expr_stmt|;
name|buf
operator|->
name|offset
operator|=
operator|(
name|dma
operator|->
name|byte_count
operator|+
name|offset
operator|)
expr_stmt|;
name|buf
operator|->
name|bus_address
operator|=
name|agp_offset
operator|+
name|offset
expr_stmt|;
name|buf
operator|->
name|address
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|agp_offset
operator|+
name|offset
operator|+
name|dev
operator|->
name|sg
operator|->
name|handle
operator|)
expr_stmt|;
name|buf
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|buf
operator|->
name|pending
operator|=
literal|0
expr_stmt|;
name|buf
operator|->
name|filp
operator|=
name|NULL
expr_stmt|;
name|buf
operator|->
name|dev_priv_size
operator|=
sizeof|sizeof
argument_list|(
name|DRIVER_BUF_PRIV_T
argument_list|)
expr_stmt|;
name|buf
operator|->
name|dev_private
operator|=
name|DRM
argument_list|(
name|alloc
argument_list|)
argument_list|(
sizeof|sizeof
argument_list|(
name|DRIVER_BUF_PRIV_T
argument_list|)
argument_list|,
name|DRM_MEM_BUFS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buf
operator|->
name|dev_private
condition|)
block|{
comment|/* Set count correctly so we free the proper amount. */
name|entry
operator|->
name|buf_count
operator|=
name|count
expr_stmt|;
name|DRM
function_decl|(
name|cleanup_buf_error
function_decl|)
parameter_list|(
name|dev
parameter_list|,
name|entry
parameter_list|)
function_decl|;
name|DRM_UNLOCK
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|ENOMEM
argument_list|)
return|;
block|}
name|memset
argument_list|(
name|buf
operator|->
name|dev_private
argument_list|,
literal|0
argument_list|,
name|buf
operator|->
name|dev_priv_size
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"buffer %d @ %p\n"
argument_list|,
name|entry
operator|->
name|buf_count
argument_list|,
name|buf
operator|->
name|address
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|alignment
expr_stmt|;
name|entry
operator|->
name|buf_count
operator|++
expr_stmt|;
name|byte_count
operator|+=
name|PAGE_SIZE
operator|<<
name|page_order
expr_stmt|;
block|}
name|DRM_DEBUG
argument_list|(
literal|"byte_count: %d\n"
argument_list|,
name|byte_count
argument_list|)
expr_stmt|;
name|temp_buflist
operator|=
name|DRM
argument_list|(
name|realloc
argument_list|)
argument_list|(
name|dma
operator|->
name|buflist
argument_list|,
name|dma
operator|->
name|buf_count
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|dma
operator|->
name|buflist
argument_list|)
argument_list|,
operator|(
name|dma
operator|->
name|buf_count
operator|+
name|entry
operator|->
name|buf_count
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|dma
operator|->
name|buflist
argument_list|)
argument_list|,
name|DRM_MEM_BUFS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|temp_buflist
condition|)
block|{
comment|/* Free the entry because it isn't valid */
name|DRM
function_decl|(
name|cleanup_buf_error
function_decl|)
parameter_list|(
name|dev
parameter_list|,
name|entry
parameter_list|)
function_decl|;
name|DRM_UNLOCK
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|ENOMEM
argument_list|)
return|;
block|}
name|dma
operator|->
name|buflist
operator|=
name|temp_buflist
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|entry
operator|->
name|buf_count
condition|;
name|i
operator|++
control|)
block|{
name|dma
operator|->
name|buflist
index|[
name|i
operator|+
name|dma
operator|->
name|buf_count
index|]
operator|=
operator|&
name|entry
operator|->
name|buflist
index|[
name|i
index|]
expr_stmt|;
block|}
name|dma
operator|->
name|buf_count
operator|+=
name|entry
operator|->
name|buf_count
expr_stmt|;
name|dma
operator|->
name|byte_count
operator|+=
name|byte_count
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"dma->buf_count : %d\n"
argument_list|,
name|dma
operator|->
name|buf_count
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"entry->buf_count : %d\n"
argument_list|,
name|entry
operator|->
name|buf_count
argument_list|)
expr_stmt|;
name|DRM_UNLOCK
expr_stmt|;
name|request
operator|->
name|count
operator|=
name|entry
operator|->
name|buf_count
expr_stmt|;
name|request
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|dma
operator|->
name|flags
operator|=
name|_DRM_DMA_USE_SG
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __REALLY_HAVE_SG */
end_comment

begin_function
name|int
name|DRM
function|(
name|addbufs
function|)
parameter_list|(
name|DRM_IOCTL_ARGS
parameter_list|)
block|{
name|DRM_DEVICE
expr_stmt|;
name|drm_buf_desc_t
name|request
decl_stmt|;
name|int
name|err
decl_stmt|;
name|DRM_COPY_FROM_USER_IOCTL
argument_list|(
name|request
argument_list|,
operator|(
name|drm_buf_desc_t
operator|*
operator|)
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|request
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|dma
operator|==
name|NULL
condition|)
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
if|if
condition|(
name|request
operator|.
name|count
operator|<
literal|0
operator|||
name|request
operator|.
name|count
operator|>
literal|4096
condition|)
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
name|DRM_SPINLOCK
argument_list|(
operator|&
name|dev
operator|->
name|count_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|buf_use
condition|)
block|{
name|DRM_SPINUNLOCK
argument_list|(
operator|&
name|dev
operator|->
name|count_lock
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EBUSY
argument_list|)
return|;
block|}
comment|/* dev->buf_alloc acts as a lock to prevent infobufs/mapbufs from 	 * trying to read from the dma->bufs while buffers are being allocated */
name|dev
operator|->
name|buf_alloc
operator|++
expr_stmt|;
name|DRM_SPINUNLOCK
argument_list|(
operator|&
name|dev
operator|->
name|count_lock
argument_list|)
expr_stmt|;
if|#
directive|if
name|__REALLY_HAVE_AGP
if|if
condition|(
name|request
operator|.
name|flags
operator|&
name|_DRM_AGP_BUFFER
condition|)
name|err
operator|=
name|DRM
argument_list|(
name|addbufs_agp
argument_list|)
argument_list|(
name|dev
argument_list|,
operator|&
name|request
argument_list|)
expr_stmt|;
elseif|else
endif|#
directive|endif
if|#
directive|if
name|__REALLY_HAVE_SG
if|if
condition|(
name|request
operator|.
name|flags
operator|&
name|_DRM_SG_BUFFER
condition|)
name|err
operator|=
name|DRM
argument_list|(
name|addbufs_sg
argument_list|)
argument_list|(
name|dev
argument_list|,
operator|&
name|request
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
if|#
directive|if
name|__HAVE_PCI_DMA
name|err
operator|=
name|DRM
argument_list|(
name|addbufs_pci
argument_list|)
argument_list|(
name|dev
argument_list|,
operator|&
name|request
argument_list|)
expr_stmt|;
else|#
directive|else
name|err
operator|=
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|DRM_COPY_TO_USER_IOCTL
argument_list|(
operator|(
name|drm_buf_desc_t
operator|*
operator|)
name|data
argument_list|,
name|request
argument_list|,
sizeof|sizeof
argument_list|(
name|request
argument_list|)
argument_list|)
expr_stmt|;
name|DRM_SPINLOCK
argument_list|(
operator|&
name|dev
operator|->
name|count_lock
argument_list|)
expr_stmt|;
name|dev
operator|->
name|buf_alloc
operator|--
expr_stmt|;
name|DRM_SPINUNLOCK
argument_list|(
operator|&
name|dev
operator|->
name|count_lock
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|int
name|DRM
function|(
name|infobufs
function|)
parameter_list|(
name|DRM_IOCTL_ARGS
parameter_list|)
block|{
name|DRM_DEVICE
expr_stmt|;
name|drm_device_dma_t
modifier|*
name|dma
init|=
name|dev
operator|->
name|dma
decl_stmt|;
name|drm_buf_info_t
name|request
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|count
decl_stmt|;
if|if
condition|(
operator|!
name|dma
condition|)
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
name|DRM_SPINLOCK
argument_list|(
operator|&
name|dev
operator|->
name|count_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|buf_alloc
operator|!=
literal|0
condition|)
block|{
name|DRM_SPINUNLOCK
argument_list|(
operator|&
name|dev
operator|->
name|count_lock
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EBUSY
argument_list|)
return|;
block|}
operator|++
name|dev
operator|->
name|buf_use
expr_stmt|;
comment|/* Can't allocate more after this call */
name|DRM_SPINUNLOCK
argument_list|(
operator|&
name|dev
operator|->
name|count_lock
argument_list|)
expr_stmt|;
name|DRM_COPY_FROM_USER_IOCTL
argument_list|(
name|request
argument_list|,
operator|(
name|drm_buf_info_t
operator|*
operator|)
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|request
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|count
operator|=
literal|0
init|;
name|i
operator|<
name|DRM_MAX_ORDER
operator|+
literal|1
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dma
operator|->
name|bufs
index|[
name|i
index|]
operator|.
name|buf_count
condition|)
operator|++
name|count
expr_stmt|;
block|}
name|DRM_DEBUG
argument_list|(
literal|"count = %d\n"
argument_list|,
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|request
operator|.
name|count
operator|>=
name|count
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|count
operator|=
literal|0
init|;
name|i
operator|<
name|DRM_MAX_ORDER
operator|+
literal|1
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dma
operator|->
name|bufs
index|[
name|i
index|]
operator|.
name|buf_count
condition|)
block|{
name|drm_buf_desc_t
name|from
decl_stmt|;
name|from
operator|.
name|count
operator|=
name|dma
operator|->
name|bufs
index|[
name|i
index|]
operator|.
name|buf_count
expr_stmt|;
name|from
operator|.
name|size
operator|=
name|dma
operator|->
name|bufs
index|[
name|i
index|]
operator|.
name|buf_size
expr_stmt|;
name|from
operator|.
name|low_mark
operator|=
name|dma
operator|->
name|bufs
index|[
name|i
index|]
operator|.
name|freelist
operator|.
name|low_mark
expr_stmt|;
name|from
operator|.
name|high_mark
operator|=
name|dma
operator|->
name|bufs
index|[
name|i
index|]
operator|.
name|freelist
operator|.
name|high_mark
expr_stmt|;
if|if
condition|(
name|DRM_COPY_TO_USER
argument_list|(
operator|&
name|request
operator|.
name|list
index|[
name|count
index|]
argument_list|,
operator|&
name|from
argument_list|,
sizeof|sizeof
argument_list|(
name|drm_buf_desc_t
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|DRM_ERR
argument_list|(
name|EFAULT
argument_list|)
return|;
name|DRM_DEBUG
argument_list|(
literal|"%d %d %d %d %d\n"
argument_list|,
name|i
argument_list|,
name|dma
operator|->
name|bufs
index|[
name|i
index|]
operator|.
name|buf_count
argument_list|,
name|dma
operator|->
name|bufs
index|[
name|i
index|]
operator|.
name|buf_size
argument_list|,
name|dma
operator|->
name|bufs
index|[
name|i
index|]
operator|.
name|freelist
operator|.
name|low_mark
argument_list|,
name|dma
operator|->
name|bufs
index|[
name|i
index|]
operator|.
name|freelist
operator|.
name|high_mark
argument_list|)
expr_stmt|;
operator|++
name|count
expr_stmt|;
block|}
block|}
block|}
name|request
operator|.
name|count
operator|=
name|count
expr_stmt|;
name|DRM_COPY_TO_USER_IOCTL
argument_list|(
operator|(
name|drm_buf_info_t
operator|*
operator|)
name|data
argument_list|,
name|request
argument_list|,
sizeof|sizeof
argument_list|(
name|request
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|DRM
function|(
name|markbufs
function|)
parameter_list|(
name|DRM_IOCTL_ARGS
parameter_list|)
block|{
name|DRM_DEVICE
expr_stmt|;
name|drm_device_dma_t
modifier|*
name|dma
init|=
name|dev
operator|->
name|dma
decl_stmt|;
name|drm_buf_desc_t
name|request
decl_stmt|;
name|int
name|order
decl_stmt|;
name|drm_buf_entry_t
modifier|*
name|entry
decl_stmt|;
if|if
condition|(
operator|!
name|dma
condition|)
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
name|DRM_COPY_FROM_USER_IOCTL
argument_list|(
name|request
argument_list|,
operator|(
name|drm_buf_desc_t
operator|*
operator|)
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|request
argument_list|)
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"%d, %d, %d\n"
argument_list|,
name|request
operator|.
name|size
argument_list|,
name|request
operator|.
name|low_mark
argument_list|,
name|request
operator|.
name|high_mark
argument_list|)
expr_stmt|;
name|order
operator|=
name|DRM
argument_list|(
name|order
argument_list|)
argument_list|(
name|request
operator|.
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|order
operator|<
name|DRM_MIN_ORDER
operator|||
name|order
operator|>
name|DRM_MAX_ORDER
condition|)
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
name|entry
operator|=
operator|&
name|dma
operator|->
name|bufs
index|[
name|order
index|]
expr_stmt|;
if|if
condition|(
name|request
operator|.
name|low_mark
operator|<
literal|0
operator|||
name|request
operator|.
name|low_mark
operator|>
name|entry
operator|->
name|buf_count
condition|)
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
if|if
condition|(
name|request
operator|.
name|high_mark
operator|<
literal|0
operator|||
name|request
operator|.
name|high_mark
operator|>
name|entry
operator|->
name|buf_count
condition|)
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
name|entry
operator|->
name|freelist
operator|.
name|low_mark
operator|=
name|request
operator|.
name|low_mark
expr_stmt|;
name|entry
operator|->
name|freelist
operator|.
name|high_mark
operator|=
name|request
operator|.
name|high_mark
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|DRM
function|(
name|freebufs
function|)
parameter_list|(
name|DRM_IOCTL_ARGS
parameter_list|)
block|{
name|DRM_DEVICE
expr_stmt|;
name|drm_device_dma_t
modifier|*
name|dma
init|=
name|dev
operator|->
name|dma
decl_stmt|;
name|drm_buf_free_t
name|request
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|idx
decl_stmt|;
name|drm_buf_t
modifier|*
name|buf
decl_stmt|;
if|if
condition|(
operator|!
name|dma
condition|)
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
name|DRM_COPY_FROM_USER_IOCTL
argument_list|(
name|request
argument_list|,
operator|(
name|drm_buf_free_t
operator|*
operator|)
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|request
argument_list|)
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"%d\n"
argument_list|,
name|request
operator|.
name|count
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|request
operator|.
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|DRM_COPY_FROM_USER
argument_list|(
operator|&
name|idx
argument_list|,
operator|&
name|request
operator|.
name|list
index|[
name|i
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|idx
argument_list|)
argument_list|)
condition|)
return|return
name|DRM_ERR
argument_list|(
name|EFAULT
argument_list|)
return|;
if|if
condition|(
name|idx
operator|<
literal|0
operator|||
name|idx
operator|>=
name|dma
operator|->
name|buf_count
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Index %d (of %d max)\n"
argument_list|,
name|idx
argument_list|,
name|dma
operator|->
name|buf_count
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
name|buf
operator|=
name|dma
operator|->
name|buflist
index|[
name|idx
index|]
expr_stmt|;
if|if
condition|(
name|buf
operator|->
name|filp
operator|!=
name|filp
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Process %d freeing buffer not owned\n"
argument_list|,
name|DRM_CURRENTPID
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
name|DRM
function_decl|(
name|free_buffer
function_decl|)
parameter_list|(
name|dev
parameter_list|,
name|buf
parameter_list|)
function_decl|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|DRM
function|(
name|mapbufs
function|)
parameter_list|(
name|DRM_IOCTL_ARGS
parameter_list|)
block|{
name|DRM_DEVICE
expr_stmt|;
name|drm_device_dma_t
modifier|*
name|dma
init|=
name|dev
operator|->
name|dma
decl_stmt|;
name|int
name|retcode
init|=
literal|0
decl_stmt|;
specifier|const
name|int
name|zero
init|=
literal|0
decl_stmt|;
name|vm_offset_t
name|virtual
decl_stmt|,
name|address
decl_stmt|;
ifdef|#
directive|ifdef
name|__FreeBSD__
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
name|struct
name|vmspace
modifier|*
name|vms
init|=
name|p
operator|->
name|td_proc
operator|->
name|p_vmspace
decl_stmt|;
else|#
directive|else
name|struct
name|vmspace
modifier|*
name|vms
init|=
name|p
operator|->
name|p_vmspace
decl_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* __FreeBSD__ */
ifdef|#
directive|ifdef
name|__NetBSD__
name|struct
name|vnode
modifier|*
name|vn
decl_stmt|;
name|struct
name|vmspace
modifier|*
name|vms
init|=
name|p
operator|->
name|p_vmspace
decl_stmt|;
endif|#
directive|endif
comment|/* __NetBSD__ */
name|drm_buf_map_t
name|request
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|dma
condition|)
return|return
name|DRM_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
name|DRM_SPINLOCK
argument_list|(
operator|&
name|dev
operator|->
name|count_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|buf_alloc
operator|!=
literal|0
condition|)
block|{
name|DRM_SPINUNLOCK
argument_list|(
operator|&
name|dev
operator|->
name|count_lock
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|EBUSY
argument_list|)
return|;
block|}
name|dev
operator|->
name|buf_use
operator|++
expr_stmt|;
comment|/* Can't allocate more after this call */
name|DRM_SPINUNLOCK
argument_list|(
operator|&
name|dev
operator|->
name|count_lock
argument_list|)
expr_stmt|;
name|DRM_COPY_FROM_USER_IOCTL
argument_list|(
name|request
argument_list|,
operator|(
name|drm_buf_map_t
operator|*
operator|)
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|request
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__NetBSD__
if|if
condition|(
operator|!
name|vfinddev
argument_list|(
name|kdev
argument_list|,
name|VCHR
argument_list|,
operator|&
name|vn
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* FIXME: Shouldn't this be EINVAL or something? */
endif|#
directive|endif
comment|/* __NetBSD__ */
if|if
condition|(
name|request
operator|.
name|count
operator|>=
name|dma
operator|->
name|buf_count
condition|)
block|{
if|if
condition|(
operator|(
name|__HAVE_AGP
operator|&&
operator|(
name|dma
operator|->
name|flags
operator|&
name|_DRM_DMA_USE_AGP
operator|)
operator|)
operator|||
operator|(
name|__HAVE_SG
operator|&&
operator|(
name|dma
operator|->
name|flags
operator|&
name|_DRM_DMA_USE_SG
operator|)
operator|)
condition|)
block|{
name|drm_local_map_t
modifier|*
name|map
init|=
name|DRIVER_AGP_BUFFERS_MAP
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|map
condition|)
block|{
name|retcode
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
ifdef|#
directive|ifdef
name|__FreeBSD__
name|virtual
operator|=
name|round_page
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|vms
operator|->
name|vm_daddr
operator|+
name|MAXDSIZ
argument_list|)
expr_stmt|;
name|retcode
operator|=
name|vm_mmap
argument_list|(
operator|&
name|vms
operator|->
name|vm_map
argument_list|,
operator|&
name|virtual
argument_list|,
name|round_page
argument_list|(
name|map
operator|->
name|size
argument_list|)
argument_list|,
name|PROT_READ
operator||
name|PROT_WRITE
argument_list|,
name|VM_PROT_ALL
argument_list|,
name|MAP_SHARED
argument_list|,
name|SLIST_FIRST
argument_list|(
operator|&
name|kdev
operator|->
name|si_hlist
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|map
operator|->
name|offset
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
name|virtual
operator|=
name|round_page
argument_list|(
operator|(
name|vaddr_t
operator|)
name|vms
operator|->
name|vm_daddr
operator|+
name|MAXDSIZ
argument_list|)
expr_stmt|;
name|retcode
operator|=
name|uvm_mmap
argument_list|(
operator|&
name|vms
operator|->
name|vm_map
argument_list|,
operator|(
name|vaddr_t
operator|*
operator|)
operator|&
name|virtual
argument_list|,
name|round_page
argument_list|(
name|map
operator|->
name|size
argument_list|)
argument_list|,
name|UVM_PROT_READ
operator||
name|UVM_PROT_WRITE
argument_list|,
name|UVM_PROT_ALL
argument_list|,
name|MAP_SHARED
argument_list|,
operator|&
name|vn
operator|->
name|v_uobj
argument_list|,
name|map
operator|->
name|offset
argument_list|,
name|p
operator|->
name|p_rlimit
index|[
name|RLIMIT_MEMLOCK
index|]
operator|.
name|rlim_cur
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* __NetBSD__ */
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|__FreeBSD__
name|virtual
operator|=
name|round_page
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|vms
operator|->
name|vm_daddr
operator|+
name|MAXDSIZ
argument_list|)
expr_stmt|;
name|retcode
operator|=
name|vm_mmap
argument_list|(
operator|&
name|vms
operator|->
name|vm_map
argument_list|,
operator|&
name|virtual
argument_list|,
name|round_page
argument_list|(
name|dma
operator|->
name|byte_count
argument_list|)
argument_list|,
name|PROT_READ
operator||
name|PROT_WRITE
argument_list|,
name|VM_PROT_ALL
argument_list|,
name|MAP_SHARED
argument_list|,
name|SLIST_FIRST
argument_list|(
operator|&
name|kdev
operator|->
name|si_hlist
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
name|virtual
operator|=
name|round_page
argument_list|(
operator|(
name|vaddr_t
operator|)
name|vms
operator|->
name|vm_daddr
operator|+
name|MAXDSIZ
argument_list|)
expr_stmt|;
name|retcode
operator|=
name|uvm_mmap
argument_list|(
operator|&
name|vms
operator|->
name|vm_map
argument_list|,
operator|(
name|vaddr_t
operator|*
operator|)
operator|&
name|virtual
argument_list|,
name|round_page
argument_list|(
name|dma
operator|->
name|byte_count
argument_list|)
argument_list|,
name|UVM_PROT_READ
operator||
name|UVM_PROT_WRITE
argument_list|,
name|UVM_PROT_ALL
argument_list|,
name|MAP_SHARED
argument_list|,
operator|&
name|vn
operator|->
name|v_uobj
argument_list|,
literal|0
argument_list|,
name|p
operator|->
name|p_rlimit
index|[
name|RLIMIT_MEMLOCK
index|]
operator|.
name|rlim_cur
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* __NetBSD__ */
block|}
if|if
condition|(
name|retcode
condition|)
goto|goto
name|done
goto|;
name|request
operator|.
name|virtual
operator|=
operator|(
name|void
operator|*
operator|)
name|virtual
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dma
operator|->
name|buf_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|DRM_COPY_TO_USER
argument_list|(
operator|&
name|request
operator|.
name|list
index|[
name|i
index|]
operator|.
name|idx
argument_list|,
operator|&
name|dma
operator|->
name|buflist
index|[
name|i
index|]
operator|->
name|idx
argument_list|,
sizeof|sizeof
argument_list|(
name|request
operator|.
name|list
index|[
literal|0
index|]
operator|.
name|idx
argument_list|)
argument_list|)
condition|)
block|{
name|retcode
operator|=
name|EFAULT
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|DRM_COPY_TO_USER
argument_list|(
operator|&
name|request
operator|.
name|list
index|[
name|i
index|]
operator|.
name|total
argument_list|,
operator|&
name|dma
operator|->
name|buflist
index|[
name|i
index|]
operator|->
name|total
argument_list|,
sizeof|sizeof
argument_list|(
name|request
operator|.
name|list
index|[
literal|0
index|]
operator|.
name|total
argument_list|)
argument_list|)
condition|)
block|{
name|retcode
operator|=
name|EFAULT
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|DRM_COPY_TO_USER
argument_list|(
operator|&
name|request
operator|.
name|list
index|[
name|i
index|]
operator|.
name|used
argument_list|,
operator|&
name|zero
argument_list|,
sizeof|sizeof
argument_list|(
name|zero
argument_list|)
argument_list|)
condition|)
block|{
name|retcode
operator|=
name|EFAULT
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|address
operator|=
name|virtual
operator|+
name|dma
operator|->
name|buflist
index|[
name|i
index|]
operator|->
name|offset
expr_stmt|;
comment|/* *** */
if|if
condition|(
name|DRM_COPY_TO_USER
argument_list|(
operator|&
name|request
operator|.
name|list
index|[
name|i
index|]
operator|.
name|address
argument_list|,
operator|&
name|address
argument_list|,
sizeof|sizeof
argument_list|(
name|address
argument_list|)
argument_list|)
condition|)
block|{
name|retcode
operator|=
name|EFAULT
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
block|}
name|done
label|:
name|request
operator|.
name|count
operator|=
name|dma
operator|->
name|buf_count
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"%d buffers, retcode = %d\n"
argument_list|,
name|request
operator|.
name|count
argument_list|,
name|retcode
argument_list|)
expr_stmt|;
name|DRM_COPY_TO_USER_IOCTL
argument_list|(
operator|(
name|drm_buf_map_t
operator|*
operator|)
name|data
argument_list|,
name|request
argument_list|,
sizeof|sizeof
argument_list|(
name|request
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|DRM_ERR
argument_list|(
name|retcode
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __HAVE_DMA */
end_comment

end_unit

