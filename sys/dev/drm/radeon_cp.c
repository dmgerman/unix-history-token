begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* radeon_cp.c -- CP support for Radeon -*- linux-c -*-  *  * Copyright 2000 Precision Insight, Inc., Cedar Park, Texas.  * Copyright 2000 VA Linux Systems, Inc., Fremont, California.  * All Rights Reserved.  *  * Permission is hereby granted, free of charge, to any person obtaining a  * copy of this software and associated documentation files (the "Software"),  * to deal in the Software without restriction, including without limitation  * the rights to use, copy, modify, merge, publish, distribute, sublicense,  * and/or sell copies of the Software, and to permit persons to whom the  * Software is furnished to do so, subject to the following conditions:  *  * The above copyright notice and this permission notice (including the next  * paragraph) shall be included in all copies or substantial portions of the  * Software.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL  * PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR  * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,  * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER  * DEALINGS IN THE SOFTWARE.  *  * Authors:  *    Kevin E. Martin<martin@valinux.com>  *    Gareth Hughes<gareth@valinux.com>  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|"dev/drm/radeon.h"
end_include

begin_include
include|#
directive|include
file|"dev/drm/drmP.h"
end_include

begin_include
include|#
directive|include
file|"dev/drm/radeon_drv.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__linux__
end_ifdef

begin_define
define|#
directive|define
name|__NO_VERSION__
end_define

begin_include
include|#
directive|include
file|<linux/interrupt.h>
end_include

begin_comment
comment|/* For task queue support */
end_comment

begin_include
include|#
directive|include
file|<linux/delay.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __linux__ */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __FreeBSD__ */
end_comment

begin_define
define|#
directive|define
name|RADEON_FIFO_DEBUG
value|0
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__alpha__
argument_list|)
end_if

begin_define
define|#
directive|define
name|PCIGART_ENABLED
end_define

begin_else
else|#
directive|else
end_else

begin_undef
undef|#
directive|undef
name|PCIGART_ENABLED
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CP microcode (from ATI) */
end_comment

begin_decl_stmt
specifier|static
name|u32
name|radeon_cp_microcode
index|[]
index|[
literal|2
index|]
init|=
block|{
block|{
literal|0x21007000
block|,
literal|0000000000
block|}
block|,
block|{
literal|0x20007000
block|,
literal|0000000000
block|}
block|,
block|{
literal|0x000000b4
block|,
literal|0x00000004
block|}
block|,
block|{
literal|0x000000b8
block|,
literal|0x00000004
block|}
block|,
block|{
literal|0x6f5b4d4c
block|,
literal|0000000000
block|}
block|,
block|{
literal|0x4c4c427f
block|,
literal|0000000000
block|}
block|,
block|{
literal|0x5b568a92
block|,
literal|0000000000
block|}
block|,
block|{
literal|0x4ca09c6d
block|,
literal|0000000000
block|}
block|,
block|{
literal|0xad4c4c4c
block|,
literal|0000000000
block|}
block|,
block|{
literal|0x4ce1af3d
block|,
literal|0000000000
block|}
block|,
block|{
literal|0xd8afafaf
block|,
literal|0000000000
block|}
block|,
block|{
literal|0xd64c4cdc
block|,
literal|0000000000
block|}
block|,
block|{
literal|0x4cd10d10
block|,
literal|0000000000
block|}
block|,
block|{
literal|0x000f0000
block|,
literal|0x00000016
block|}
block|,
block|{
literal|0x362f242d
block|,
literal|0000000000
block|}
block|,
block|{
literal|0x00000012
block|,
literal|0x00000004
block|}
block|,
block|{
literal|0x000f0000
block|,
literal|0x00000016
block|}
block|,
block|{
literal|0x362f282d
block|,
literal|0000000000
block|}
block|,
block|{
literal|0x000380e7
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x04002c97
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x000f0001
block|,
literal|0x00000016
block|}
block|,
block|{
literal|0x333a3730
block|,
literal|0000000000
block|}
block|,
block|{
literal|0x000077ef
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x00061000
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x00000021
block|,
literal|0x0000001a
block|}
block|,
block|{
literal|0x00004000
block|,
literal|0x0000001e
block|}
block|,
block|{
literal|0x00061000
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x00000021
block|,
literal|0x0000001a
block|}
block|,
block|{
literal|0x00004000
block|,
literal|0x0000001e
block|}
block|,
block|{
literal|0x00061000
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x00000021
block|,
literal|0x0000001a
block|}
block|,
block|{
literal|0x00004000
block|,
literal|0x0000001e
block|}
block|,
block|{
literal|0x00000017
block|,
literal|0x00000004
block|}
block|,
block|{
literal|0x0003802b
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x040067e0
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x00000017
block|,
literal|0x00000004
block|}
block|,
block|{
literal|0x000077e0
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x00065000
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x000037e1
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x040067e1
block|,
literal|0x00000006
block|}
block|,
block|{
literal|0x000077e0
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x000077e1
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x000077e1
block|,
literal|0x00000006
block|}
block|,
block|{
literal|0xffffffff
block|,
literal|0000000000
block|}
block|,
block|{
literal|0x10000000
block|,
literal|0000000000
block|}
block|,
block|{
literal|0x0003802b
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x040067e0
block|,
literal|0x00000006
block|}
block|,
block|{
literal|0x00007675
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x00007676
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x00007677
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x00007678
block|,
literal|0x00000006
block|}
block|,
block|{
literal|0x0003802c
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x04002676
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x00007677
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x00007678
block|,
literal|0x00000006
block|}
block|,
block|{
literal|0x0000002f
block|,
literal|0x00000018
block|}
block|,
block|{
literal|0x0000002f
block|,
literal|0x00000018
block|}
block|,
block|{
literal|0000000000
block|,
literal|0x00000006
block|}
block|,
block|{
literal|0x00000030
block|,
literal|0x00000018
block|}
block|,
block|{
literal|0x00000030
block|,
literal|0x00000018
block|}
block|,
block|{
literal|0000000000
block|,
literal|0x00000006
block|}
block|,
block|{
literal|0x01605000
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x00065000
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x00098000
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x00061000
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x64c0603e
block|,
literal|0x00000004
block|}
block|,
block|{
literal|0x000380e6
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x040025c5
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x00080000
block|,
literal|0x00000016
block|}
block|,
block|{
literal|0000000000
block|,
literal|0000000000
block|}
block|,
block|{
literal|0x0400251d
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x00007580
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x00067581
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x04002580
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x00067581
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x00000049
block|,
literal|0x00000004
block|}
block|,
block|{
literal|0x00005000
block|,
literal|0000000000
block|}
block|,
block|{
literal|0x000380e6
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x040025c5
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x00061000
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x0000750e
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x00019000
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x00011055
block|,
literal|0x00000014
block|}
block|,
block|{
literal|0x00000055
block|,
literal|0x00000012
block|}
block|,
block|{
literal|0x0400250f
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x0000504f
block|,
literal|0x00000004
block|}
block|,
block|{
literal|0x000380e6
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x040025c5
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x00007565
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x00007566
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x00000058
block|,
literal|0x00000004
block|}
block|,
block|{
literal|0x000380e6
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x040025c5
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x01e655b4
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x4401b0e4
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x01c110e4
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x26667066
block|,
literal|0x00000018
block|}
block|,
block|{
literal|0x040c2565
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x00000066
block|,
literal|0x00000018
block|}
block|,
block|{
literal|0x04002564
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x00007566
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x0000005d
block|,
literal|0x00000004
block|}
block|,
block|{
literal|0x00401069
block|,
literal|0x00000008
block|}
block|,
block|{
literal|0x00101000
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x000d80ff
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x0080006c
block|,
literal|0x00000008
block|}
block|,
block|{
literal|0x000f9000
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x000e00ff
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0000000000
block|,
literal|0x00000006
block|}
block|,
block|{
literal|0x0000008f
block|,
literal|0x00000018
block|}
block|,
block|{
literal|0x0000005b
block|,
literal|0x00000004
block|}
block|,
block|{
literal|0x000380e6
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x040025c5
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x00007576
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x00065000
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x00009000
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x00041000
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x0c00350e
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x00049000
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x00051000
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x01e785f8
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x00200000
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x0060007e
block|,
literal|0x0000000c
block|}
block|,
block|{
literal|0x00007563
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x006075f0
block|,
literal|0x00000021
block|}
block|,
block|{
literal|0x20007073
block|,
literal|0x00000004
block|}
block|,
block|{
literal|0x00005073
block|,
literal|0x00000004
block|}
block|,
block|{
literal|0x000380e6
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x040025c5
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x00007576
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x00007577
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x0000750e
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x0000750f
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x00a05000
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x00600083
block|,
literal|0x0000000c
block|}
block|,
block|{
literal|0x006075f0
block|,
literal|0x00000021
block|}
block|,
block|{
literal|0x000075f8
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x00000083
block|,
literal|0x00000004
block|}
block|,
block|{
literal|0x000a750e
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x000380e6
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x040025c5
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x0020750f
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x00600086
block|,
literal|0x00000004
block|}
block|,
block|{
literal|0x00007570
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x00007571
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x00007572
block|,
literal|0x00000006
block|}
block|,
block|{
literal|0x000380e6
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x040025c5
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x00005000
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x00a05000
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x00007568
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x00061000
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x00000095
block|,
literal|0x0000000c
block|}
block|,
block|{
literal|0x00058000
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x0c607562
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x00000097
block|,
literal|0x00000004
block|}
block|,
block|{
literal|0x000380e6
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x040025c5
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x00600096
block|,
literal|0x00000004
block|}
block|,
block|{
literal|0x400070e5
block|,
literal|0000000000
block|}
block|,
block|{
literal|0x000380e6
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x040025c5
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x000380e5
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x000000a8
block|,
literal|0x0000001c
block|}
block|,
block|{
literal|0x000650aa
block|,
literal|0x00000018
block|}
block|,
block|{
literal|0x040025bb
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x000610ab
block|,
literal|0x00000018
block|}
block|,
block|{
literal|0x040075bc
block|,
literal|0000000000
block|}
block|,
block|{
literal|0x000075bb
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x000075bc
block|,
literal|0000000000
block|}
block|,
block|{
literal|0x00090000
block|,
literal|0x00000006
block|}
block|,
block|{
literal|0x00090000
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x000d8002
block|,
literal|0x00000006
block|}
block|,
block|{
literal|0x00007832
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x00005000
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x000380e7
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x04002c97
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x00007820
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x00007821
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x00007800
block|,
literal|0000000000
block|}
block|,
block|{
literal|0x01200000
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x20077000
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x01200000
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x20007000
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x00061000
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x0120751b
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x8040750a
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x8040750b
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x00110000
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x000380e5
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x000000c6
block|,
literal|0x0000001c
block|}
block|,
block|{
literal|0x000610ab
block|,
literal|0x00000018
block|}
block|,
block|{
literal|0x844075bd
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x000610aa
block|,
literal|0x00000018
block|}
block|,
block|{
literal|0x840075bb
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x000610ab
block|,
literal|0x00000018
block|}
block|,
block|{
literal|0x844075bc
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x000000c9
block|,
literal|0x00000004
block|}
block|,
block|{
literal|0x804075bd
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x800075bb
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x804075bc
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x00108000
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x01400000
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x006000cd
block|,
literal|0x0000000c
block|}
block|,
block|{
literal|0x20c07000
block|,
literal|0x00000020
block|}
block|,
block|{
literal|0x000000cf
block|,
literal|0x00000012
block|}
block|,
block|{
literal|0x00800000
block|,
literal|0x00000006
block|}
block|,
block|{
literal|0x0080751d
block|,
literal|0x00000006
block|}
block|,
block|{
literal|0000000000
block|,
literal|0000000000
block|}
block|,
block|{
literal|0x0000775c
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x00a05000
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x00661000
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x0460275d
block|,
literal|0x00000020
block|}
block|,
block|{
literal|0x00004000
block|,
literal|0000000000
block|}
block|,
block|{
literal|0x01e00830
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x21007000
block|,
literal|0000000000
block|}
block|,
block|{
literal|0x6464614d
block|,
literal|0000000000
block|}
block|,
block|{
literal|0x69687420
block|,
literal|0000000000
block|}
block|,
block|{
literal|0x00000073
block|,
literal|0000000000
block|}
block|,
block|{
literal|0000000000
block|,
literal|0000000000
block|}
block|,
block|{
literal|0x00005000
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x000380d0
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x040025e0
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x000075e1
block|,
literal|0000000000
block|}
block|,
block|{
literal|0x00000001
block|,
literal|0000000000
block|}
block|,
block|{
literal|0x000380e0
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x04002394
block|,
literal|0x00000002
block|}
block|,
block|{
literal|0x00005000
block|,
literal|0000000000
block|}
block|,
block|{
literal|0000000000
block|,
literal|0000000000
block|}
block|,
block|{
literal|0000000000
block|,
literal|0000000000
block|}
block|,
block|{
literal|0x00000008
block|,
literal|0000000000
block|}
block|,
block|{
literal|0x00000004
block|,
literal|0000000000
block|}
block|,
block|{
literal|0000000000
block|,
literal|0000000000
block|}
block|,
block|{
literal|0000000000
block|,
literal|0000000000
block|}
block|,
block|{
literal|0000000000
block|,
literal|0000000000
block|}
block|,
block|{
literal|0000000000
block|,
literal|0000000000
block|}
block|,
block|{
literal|0000000000
block|,
literal|0000000000
block|}
block|,
block|{
literal|0000000000
block|,
literal|0000000000
block|}
block|,
block|{
literal|0000000000
block|,
literal|0000000000
block|}
block|,
block|{
literal|0000000000
block|,
literal|0000000000
block|}
block|,
block|{
literal|0000000000
block|,
literal|0000000000
block|}
block|,
block|{
literal|0000000000
block|,
literal|0000000000
block|}
block|,
block|{
literal|0000000000
block|,
literal|0000000000
block|}
block|,
block|{
literal|0000000000
block|,
literal|0000000000
block|}
block|,
block|{
literal|0000000000
block|,
literal|0000000000
block|}
block|,
block|{
literal|0000000000
block|,
literal|0000000000
block|}
block|,
block|{
literal|0000000000
block|,
literal|0000000000
block|}
block|,
block|{
literal|0000000000
block|,
literal|0000000000
block|}
block|,
block|{
literal|0000000000
block|,
literal|0000000000
block|}
block|,
block|{
literal|0000000000
block|,
literal|0000000000
block|}
block|,
block|{
literal|0000000000
block|,
literal|0000000000
block|}
block|,
block|{
literal|0000000000
block|,
literal|0000000000
block|}
block|,
block|{
literal|0000000000
block|,
literal|0000000000
block|}
block|,
block|{
literal|0000000000
block|,
literal|0000000000
block|}
block|,
block|{
literal|0000000000
block|,
literal|0000000000
block|}
block|,
block|{
literal|0000000000
block|,
literal|0000000000
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|RADEON_READ_PLL
parameter_list|(
name|drm_device_t
modifier|*
name|dev
parameter_list|,
name|int
name|addr
parameter_list|)
block|{
name|drm_radeon_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|RADEON_WRITE8
argument_list|(
name|RADEON_CLOCK_CNTL_INDEX
argument_list|,
name|addr
operator|&
literal|0x1f
argument_list|)
expr_stmt|;
return|return
name|RADEON_READ
argument_list|(
name|RADEON_CLOCK_CNTL_DATA
argument_list|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|RADEON_FIFO_DEBUG
end_if

begin_function
specifier|static
name|void
name|radeon_status
parameter_list|(
name|drm_radeon_private_t
modifier|*
name|dev_priv
parameter_list|)
block|{
name|printk
argument_list|(
literal|"%s:\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|printk
argument_list|(
literal|"RBBM_STATUS = 0x%08x\n"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|RADEON_READ
argument_list|(
name|RADEON_RBBM_STATUS
argument_list|)
argument_list|)
expr_stmt|;
name|printk
argument_list|(
literal|"CP_RB_RTPR = 0x%08x\n"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|RADEON_READ
argument_list|(
name|RADEON_CP_RB_RPTR
argument_list|)
argument_list|)
expr_stmt|;
name|printk
argument_list|(
literal|"CP_RB_WTPR = 0x%08x\n"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|RADEON_READ
argument_list|(
name|RADEON_CP_RB_WPTR
argument_list|)
argument_list|)
expr_stmt|;
name|printk
argument_list|(
literal|"AIC_CNTL = 0x%08x\n"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|RADEON_READ
argument_list|(
name|RADEON_AIC_CNTL
argument_list|)
argument_list|)
expr_stmt|;
name|printk
argument_list|(
literal|"AIC_STAT = 0x%08x\n"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|RADEON_READ
argument_list|(
name|RADEON_AIC_STAT
argument_list|)
argument_list|)
expr_stmt|;
name|printk
argument_list|(
literal|"AIC_PT_BASE = 0x%08x\n"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|RADEON_READ
argument_list|(
name|RADEON_AIC_PT_BASE
argument_list|)
argument_list|)
expr_stmt|;
name|printk
argument_list|(
literal|"TLB_ADDR = 0x%08x\n"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|RADEON_READ
argument_list|(
name|RADEON_AIC_TLB_ADDR
argument_list|)
argument_list|)
expr_stmt|;
name|printk
argument_list|(
literal|"TLB_DATA = 0x%08x\n"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|RADEON_READ
argument_list|(
name|RADEON_AIC_TLB_DATA
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ================================================================  * Engine, FIFO control  */
end_comment

begin_function
specifier|static
name|int
name|radeon_do_pixcache_flush
parameter_list|(
name|drm_radeon_private_t
modifier|*
name|dev_priv
parameter_list|)
block|{
name|u32
name|tmp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|tmp
operator|=
name|RADEON_READ
argument_list|(
name|RADEON_RB2D_DSTCACHE_CTLSTAT
argument_list|)
expr_stmt|;
name|tmp
operator||=
name|RADEON_RB2D_DC_FLUSH_ALL
expr_stmt|;
name|RADEON_WRITE
argument_list|(
name|RADEON_RB2D_DSTCACHE_CTLSTAT
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dev_priv
operator|->
name|usec_timeout
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|RADEON_READ
argument_list|(
name|RADEON_RB2D_DSTCACHE_CTLSTAT
argument_list|)
operator|&
name|RADEON_RB2D_DC_BUSY
operator|)
condition|)
block|{
return|return
literal|0
return|;
block|}
name|DRM_OS_DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|RADEON_FIFO_DEBUG
name|DRM_ERROR
argument_list|(
literal|"failed!\n"
argument_list|)
expr_stmt|;
name|radeon_status
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|DRM_OS_ERR
argument_list|(
name|EBUSY
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|radeon_do_wait_for_fifo
parameter_list|(
name|drm_radeon_private_t
modifier|*
name|dev_priv
parameter_list|,
name|int
name|entries
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dev_priv
operator|->
name|usec_timeout
condition|;
name|i
operator|++
control|)
block|{
name|int
name|slots
init|=
operator|(
name|RADEON_READ
argument_list|(
name|RADEON_RBBM_STATUS
argument_list|)
operator|&
name|RADEON_RBBM_FIFOCNT_MASK
operator|)
decl_stmt|;
if|if
condition|(
name|slots
operator|>=
name|entries
condition|)
return|return
literal|0
return|;
name|DRM_OS_DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|RADEON_FIFO_DEBUG
name|DRM_ERROR
argument_list|(
literal|"failed!\n"
argument_list|)
expr_stmt|;
name|radeon_status
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|DRM_OS_ERR
argument_list|(
name|EBUSY
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|radeon_do_wait_for_idle
parameter_list|(
name|drm_radeon_private_t
modifier|*
name|dev_priv
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|ret
decl_stmt|;
name|ret
operator|=
name|radeon_do_wait_for_fifo
argument_list|(
name|dev_priv
argument_list|,
literal|64
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__linux__
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
return|return
name|ret
return|;
endif|#
directive|endif
comment|/* __linux__ */
ifdef|#
directive|ifdef
name|__FreeBSD__
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
endif|#
directive|endif
comment|/* __FreeBSD__ */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dev_priv
operator|->
name|usec_timeout
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|RADEON_READ
argument_list|(
name|RADEON_RBBM_STATUS
argument_list|)
operator|&
name|RADEON_RBBM_ACTIVE
operator|)
condition|)
block|{
name|radeon_do_pixcache_flush
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|DRM_OS_DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|RADEON_FIFO_DEBUG
name|DRM_ERROR
argument_list|(
literal|"failed!\n"
argument_list|)
expr_stmt|;
name|radeon_status
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|DRM_OS_ERR
argument_list|(
name|EBUSY
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ================================================================  * CP control, initialization  */
end_comment

begin_comment
comment|/* Load the microcode for the CP */
end_comment

begin_function
specifier|static
name|void
name|radeon_cp_load_microcode
parameter_list|(
name|drm_radeon_private_t
modifier|*
name|dev_priv
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"%s\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|radeon_do_wait_for_idle
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
name|RADEON_WRITE
argument_list|(
name|RADEON_CP_ME_RAM_ADDR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
name|RADEON_WRITE
argument_list|(
name|RADEON_CP_ME_RAM_DATAH
argument_list|,
name|radeon_cp_microcode
index|[
name|i
index|]
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|RADEON_WRITE
argument_list|(
name|RADEON_CP_ME_RAM_DATAL
argument_list|,
name|radeon_cp_microcode
index|[
name|i
index|]
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Flush any pending commands to the CP.  This should only be used just  * prior to a wait for idle, as it informs the engine that the command  * stream is ending.  */
end_comment

begin_function
specifier|static
name|void
name|radeon_do_cp_flush
parameter_list|(
name|drm_radeon_private_t
modifier|*
name|dev_priv
parameter_list|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"%s\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|u32 tmp;  	tmp = RADEON_READ( RADEON_CP_RB_WPTR ) | (1<< 31); 	RADEON_WRITE( RADEON_CP_RB_WPTR, tmp );
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Wait for the CP to go idle.  */
end_comment

begin_function
name|int
name|radeon_do_cp_idle
parameter_list|(
name|drm_radeon_private_t
modifier|*
name|dev_priv
parameter_list|)
block|{
name|RING_LOCALS
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"%s\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|BEGIN_RING
argument_list|(
literal|6
argument_list|)
expr_stmt|;
name|RADEON_PURGE_CACHE
argument_list|()
expr_stmt|;
name|RADEON_PURGE_ZCACHE
argument_list|()
expr_stmt|;
name|RADEON_WAIT_UNTIL_IDLE
argument_list|()
expr_stmt|;
name|ADVANCE_RING
argument_list|()
expr_stmt|;
return|return
name|radeon_do_wait_for_idle
argument_list|(
name|dev_priv
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Start the Command Processor.  */
end_comment

begin_function
specifier|static
name|void
name|radeon_do_cp_start
parameter_list|(
name|drm_radeon_private_t
modifier|*
name|dev_priv
parameter_list|)
block|{
name|RING_LOCALS
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"%s\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|radeon_do_wait_for_idle
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
name|RADEON_WRITE
argument_list|(
name|RADEON_CP_CSQ_CNTL
argument_list|,
name|dev_priv
operator|->
name|cp_mode
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|cp_running
operator|=
literal|1
expr_stmt|;
name|BEGIN_RING
argument_list|(
literal|6
argument_list|)
expr_stmt|;
name|RADEON_PURGE_CACHE
argument_list|()
expr_stmt|;
name|RADEON_PURGE_ZCACHE
argument_list|()
expr_stmt|;
name|RADEON_WAIT_UNTIL_IDLE
argument_list|()
expr_stmt|;
name|ADVANCE_RING
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Reset the Command Processor.  This will not flush any pending  * commands, so you must wait for the CP command stream to complete  * before calling this routine.  */
end_comment

begin_function
specifier|static
name|void
name|radeon_do_cp_reset
parameter_list|(
name|drm_radeon_private_t
modifier|*
name|dev_priv
parameter_list|)
block|{
name|u32
name|cur_read_ptr
decl_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"%s\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|cur_read_ptr
operator|=
name|RADEON_READ
argument_list|(
name|RADEON_CP_RB_RPTR
argument_list|)
expr_stmt|;
name|RADEON_WRITE
argument_list|(
name|RADEON_CP_RB_WPTR
argument_list|,
name|cur_read_ptr
argument_list|)
expr_stmt|;
operator|*
name|dev_priv
operator|->
name|ring
operator|.
name|head
operator|=
name|cur_read_ptr
expr_stmt|;
name|dev_priv
operator|->
name|ring
operator|.
name|tail
operator|=
name|cur_read_ptr
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Stop the Command Processor.  This will not flush any pending  * commands, so you must flush the command stream and wait for the CP  * to go idle before calling this routine.  */
end_comment

begin_function
specifier|static
name|void
name|radeon_do_cp_stop
parameter_list|(
name|drm_radeon_private_t
modifier|*
name|dev_priv
parameter_list|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"%s\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|RADEON_WRITE
argument_list|(
name|RADEON_CP_CSQ_CNTL
argument_list|,
name|RADEON_CSQ_PRIDIS_INDDIS
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|cp_running
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Reset the engine.  This will stop the CP if it is running.  */
end_comment

begin_function
specifier|static
name|int
name|radeon_do_engine_reset
parameter_list|(
name|drm_device_t
modifier|*
name|dev
parameter_list|)
block|{
name|drm_radeon_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|u32
name|clock_cntl_index
decl_stmt|,
name|mclk_cntl
decl_stmt|,
name|rbbm_soft_reset
decl_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"%s\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|radeon_do_pixcache_flush
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
name|clock_cntl_index
operator|=
name|RADEON_READ
argument_list|(
name|RADEON_CLOCK_CNTL_INDEX
argument_list|)
expr_stmt|;
name|mclk_cntl
operator|=
name|RADEON_READ_PLL
argument_list|(
name|dev
argument_list|,
name|RADEON_MCLK_CNTL
argument_list|)
expr_stmt|;
name|RADEON_WRITE_PLL
argument_list|(
name|RADEON_MCLK_CNTL
argument_list|,
operator|(
name|mclk_cntl
operator||
name|RADEON_FORCEON_MCLKA
operator||
name|RADEON_FORCEON_MCLKB
operator||
name|RADEON_FORCEON_YCLKA
operator||
name|RADEON_FORCEON_YCLKB
operator||
name|RADEON_FORCEON_MC
operator||
name|RADEON_FORCEON_AIC
operator|)
argument_list|)
expr_stmt|;
name|rbbm_soft_reset
operator|=
name|RADEON_READ
argument_list|(
name|RADEON_RBBM_SOFT_RESET
argument_list|)
expr_stmt|;
name|RADEON_WRITE
argument_list|(
name|RADEON_RBBM_SOFT_RESET
argument_list|,
operator|(
name|rbbm_soft_reset
operator||
name|RADEON_SOFT_RESET_CP
operator||
name|RADEON_SOFT_RESET_HI
operator||
name|RADEON_SOFT_RESET_SE
operator||
name|RADEON_SOFT_RESET_RE
operator||
name|RADEON_SOFT_RESET_PP
operator||
name|RADEON_SOFT_RESET_E2
operator||
name|RADEON_SOFT_RESET_RB
operator|)
argument_list|)
expr_stmt|;
name|RADEON_READ
argument_list|(
name|RADEON_RBBM_SOFT_RESET
argument_list|)
expr_stmt|;
name|RADEON_WRITE
argument_list|(
name|RADEON_RBBM_SOFT_RESET
argument_list|,
operator|(
name|rbbm_soft_reset
operator|&
operator|~
operator|(
name|RADEON_SOFT_RESET_CP
operator||
name|RADEON_SOFT_RESET_HI
operator||
name|RADEON_SOFT_RESET_SE
operator||
name|RADEON_SOFT_RESET_RE
operator||
name|RADEON_SOFT_RESET_PP
operator||
name|RADEON_SOFT_RESET_E2
operator||
name|RADEON_SOFT_RESET_RB
operator|)
operator|)
argument_list|)
expr_stmt|;
name|RADEON_READ
argument_list|(
name|RADEON_RBBM_SOFT_RESET
argument_list|)
expr_stmt|;
name|RADEON_WRITE_PLL
argument_list|(
name|RADEON_MCLK_CNTL
argument_list|,
name|mclk_cntl
argument_list|)
expr_stmt|;
name|RADEON_WRITE
argument_list|(
name|RADEON_CLOCK_CNTL_INDEX
argument_list|,
name|clock_cntl_index
argument_list|)
expr_stmt|;
name|RADEON_WRITE
argument_list|(
name|RADEON_RBBM_SOFT_RESET
argument_list|,
name|rbbm_soft_reset
argument_list|)
expr_stmt|;
comment|/* Reset the CP ring */
name|radeon_do_cp_reset
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
comment|/* The CP is no longer running after an engine reset */
name|dev_priv
operator|->
name|cp_running
operator|=
literal|0
expr_stmt|;
comment|/* Reset any pending vertex, indirect buffers */
name|radeon_freelist_reset
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|radeon_cp_init_ring_buffer
parameter_list|(
name|drm_device_t
modifier|*
name|dev
parameter_list|,
name|drm_radeon_private_t
modifier|*
name|dev_priv
parameter_list|)
block|{
name|u32
name|ring_start
decl_stmt|,
name|cur_read_ptr
decl_stmt|;
name|u32
name|tmp
decl_stmt|;
comment|/* Initialize the memory controller */
name|RADEON_WRITE
argument_list|(
name|RADEON_MC_FB_LOCATION
argument_list|,
operator|(
name|dev_priv
operator|->
name|agp_vm_start
operator|-
literal|1
operator|)
operator|&
literal|0xffff0000
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dev_priv
operator|->
name|is_pci
condition|)
block|{
name|RADEON_WRITE
argument_list|(
name|RADEON_MC_AGP_LOCATION
argument_list|,
operator|(
operator|(
operator|(
name|dev_priv
operator|->
name|agp_vm_start
operator|-
literal|1
operator|+
name|dev_priv
operator|->
name|agp_size
operator|)
operator|&
literal|0xffff0000
operator|)
operator||
operator|(
name|dev_priv
operator|->
name|agp_vm_start
operator|>>
literal|16
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|__REALLY_HAVE_AGP
if|if
condition|(
operator|!
name|dev_priv
operator|->
name|is_pci
condition|)
name|ring_start
operator|=
operator|(
name|dev_priv
operator|->
name|cp_ring
operator|->
name|offset
operator|-
name|dev
operator|->
name|agp
operator|->
name|base
operator|+
name|dev_priv
operator|->
name|agp_vm_start
operator|)
expr_stmt|;
else|else
endif|#
directive|endif
name|ring_start
operator|=
operator|(
name|dev_priv
operator|->
name|cp_ring
operator|->
name|offset
operator|-
name|dev
operator|->
name|sg
operator|->
name|handle
operator|+
name|dev_priv
operator|->
name|agp_vm_start
operator|)
expr_stmt|;
name|RADEON_WRITE
argument_list|(
name|RADEON_CP_RB_BASE
argument_list|,
name|ring_start
argument_list|)
expr_stmt|;
comment|/* Set the write pointer delay */
name|RADEON_WRITE
argument_list|(
name|RADEON_CP_RB_WPTR_DELAY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Initialize the ring buffer's read and write pointers */
name|cur_read_ptr
operator|=
name|RADEON_READ
argument_list|(
name|RADEON_CP_RB_RPTR
argument_list|)
expr_stmt|;
name|RADEON_WRITE
argument_list|(
name|RADEON_CP_RB_WPTR
argument_list|,
name|cur_read_ptr
argument_list|)
expr_stmt|;
operator|*
name|dev_priv
operator|->
name|ring
operator|.
name|head
operator|=
name|cur_read_ptr
expr_stmt|;
name|dev_priv
operator|->
name|ring
operator|.
name|tail
operator|=
name|cur_read_ptr
expr_stmt|;
if|#
directive|if
name|__REALLY_HAVE_SG
if|if
condition|(
operator|!
name|dev_priv
operator|->
name|is_pci
condition|)
block|{
endif|#
directive|endif
name|RADEON_WRITE
argument_list|(
name|RADEON_CP_RB_RPTR_ADDR
argument_list|,
name|dev_priv
operator|->
name|ring_rptr
operator|->
name|offset
argument_list|)
expr_stmt|;
if|#
directive|if
name|__REALLY_HAVE_SG
block|}
else|else
block|{
name|drm_sg_mem_t
modifier|*
name|entry
init|=
name|dev
operator|->
name|sg
decl_stmt|;
name|unsigned
name|long
name|tmp_ofs
decl_stmt|,
name|page_ofs
decl_stmt|;
name|tmp_ofs
operator|=
name|dev_priv
operator|->
name|ring_rptr
operator|->
name|offset
operator|-
name|dev
operator|->
name|sg
operator|->
name|handle
expr_stmt|;
name|page_ofs
operator|=
name|tmp_ofs
operator|>>
name|PAGE_SHIFT
expr_stmt|;
name|RADEON_WRITE
argument_list|(
name|RADEON_CP_RB_RPTR_ADDR
argument_list|,
name|entry
operator|->
name|busaddr
index|[
name|page_ofs
index|]
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"ring rptr: offset=0x%08x handle=0x%08lx\n"
argument_list|,
name|entry
operator|->
name|busaddr
index|[
name|page_ofs
index|]
argument_list|,
name|entry
operator|->
name|handle
operator|+
name|tmp_ofs
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Set ring buffer size */
name|RADEON_WRITE
argument_list|(
name|RADEON_CP_RB_CNTL
argument_list|,
name|dev_priv
operator|->
name|ring
operator|.
name|size_l2qw
argument_list|)
expr_stmt|;
name|radeon_do_wait_for_idle
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
comment|/* Turn on bus mastering */
name|tmp
operator|=
name|RADEON_READ
argument_list|(
name|RADEON_BUS_CNTL
argument_list|)
operator|&
operator|~
name|RADEON_BUS_MASTER_DIS
expr_stmt|;
name|RADEON_WRITE
argument_list|(
name|RADEON_BUS_CNTL
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* Sync everything up */
name|RADEON_WRITE
argument_list|(
name|RADEON_ISYNC_CNTL
argument_list|,
operator|(
name|RADEON_ISYNC_ANY2D_IDLE3D
operator||
name|RADEON_ISYNC_ANY3D_IDLE2D
operator||
name|RADEON_ISYNC_WAIT_IDLEGUI
operator||
name|RADEON_ISYNC_CPSCRATCH_IDLEGUI
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|radeon_do_init_cp
parameter_list|(
name|drm_device_t
modifier|*
name|dev
parameter_list|,
name|drm_radeon_init_t
modifier|*
name|init
parameter_list|)
block|{
name|drm_radeon_private_t
modifier|*
name|dev_priv
decl_stmt|;
ifdef|#
directive|ifdef
name|__linux__
name|struct
name|list_head
modifier|*
name|list
decl_stmt|;
endif|#
directive|endif
comment|/* __linux__ */
ifdef|#
directive|ifdef
name|__FreeBSD__
name|drm_map_list_entry_t
modifier|*
name|listentry
decl_stmt|;
endif|#
directive|endif
comment|/* __FreeBSD__ */
name|u32
name|tmp
decl_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"%s\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|dev_priv
operator|=
name|DRM
argument_list|(
name|alloc
argument_list|)
argument_list|(
sizeof|sizeof
argument_list|(
name|drm_radeon_private_t
argument_list|)
argument_list|,
name|DRM_MEM_DRIVER
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev_priv
operator|==
name|NULL
condition|)
return|return
name|DRM_OS_ERR
argument_list|(
name|ENOMEM
argument_list|)
return|;
name|memset
argument_list|(
name|dev_priv
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|drm_radeon_private_t
argument_list|)
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|is_pci
operator|=
name|init
operator|->
name|is_pci
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|PCIGART_ENABLED
argument_list|)
comment|/* PCI support is not 100% working, so we disable it here. 	 */
if|if
condition|(
name|dev_priv
operator|->
name|is_pci
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"PCI GART not yet supported for Radeon!\n"
argument_list|)
expr_stmt|;
name|dev
operator|->
name|dev_private
operator|=
operator|(
name|void
operator|*
operator|)
name|dev_priv
expr_stmt|;
name|radeon_do_cleanup_cp
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|DRM_OS_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
endif|#
directive|endif
if|if
condition|(
name|dev_priv
operator|->
name|is_pci
operator|&&
operator|!
name|dev
operator|->
name|sg
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"PCI GART memory not allocated!\n"
argument_list|)
expr_stmt|;
name|dev
operator|->
name|dev_private
operator|=
operator|(
name|void
operator|*
operator|)
name|dev_priv
expr_stmt|;
name|radeon_do_cleanup_cp
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|DRM_OS_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
name|dev_priv
operator|->
name|usec_timeout
operator|=
name|init
operator|->
name|usec_timeout
expr_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|usec_timeout
operator|<
literal|1
operator|||
name|dev_priv
operator|->
name|usec_timeout
operator|>
name|RADEON_MAX_USEC_TIMEOUT
condition|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"TIMEOUT problem!\n"
argument_list|)
expr_stmt|;
name|dev
operator|->
name|dev_private
operator|=
operator|(
name|void
operator|*
operator|)
name|dev_priv
expr_stmt|;
name|radeon_do_cleanup_cp
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|DRM_OS_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
name|dev_priv
operator|->
name|cp_mode
operator|=
name|init
operator|->
name|cp_mode
expr_stmt|;
comment|/* Simple idle check. 	 */
name|atomic_set
argument_list|(
operator|&
name|dev_priv
operator|->
name|idle_count
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* We don't support anything other than bus-mastering ring mode, 	 * but the ring can be in either AGP or PCI space for the ring 	 * read pointer. 	 */
if|if
condition|(
operator|(
name|init
operator|->
name|cp_mode
operator|!=
name|RADEON_CSQ_PRIBM_INDDIS
operator|)
operator|&&
operator|(
name|init
operator|->
name|cp_mode
operator|!=
name|RADEON_CSQ_PRIBM_INDBM
operator|)
condition|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"BAD cp_mode (%x)!\n"
argument_list|,
name|init
operator|->
name|cp_mode
argument_list|)
expr_stmt|;
name|dev
operator|->
name|dev_private
operator|=
operator|(
name|void
operator|*
operator|)
name|dev_priv
expr_stmt|;
name|radeon_do_cleanup_cp
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|DRM_OS_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
switch|switch
condition|(
name|init
operator|->
name|fb_bpp
condition|)
block|{
case|case
literal|16
case|:
name|dev_priv
operator|->
name|color_fmt
operator|=
name|RADEON_COLOR_FORMAT_RGB565
expr_stmt|;
break|break;
case|case
literal|32
case|:
default|default:
name|dev_priv
operator|->
name|color_fmt
operator|=
name|RADEON_COLOR_FORMAT_ARGB8888
expr_stmt|;
break|break;
block|}
name|dev_priv
operator|->
name|front_offset
operator|=
name|init
operator|->
name|front_offset
expr_stmt|;
name|dev_priv
operator|->
name|front_pitch
operator|=
name|init
operator|->
name|front_pitch
expr_stmt|;
name|dev_priv
operator|->
name|back_offset
operator|=
name|init
operator|->
name|back_offset
expr_stmt|;
name|dev_priv
operator|->
name|back_pitch
operator|=
name|init
operator|->
name|back_pitch
expr_stmt|;
switch|switch
condition|(
name|init
operator|->
name|depth_bpp
condition|)
block|{
case|case
literal|16
case|:
name|dev_priv
operator|->
name|depth_fmt
operator|=
name|RADEON_DEPTH_FORMAT_16BIT_INT_Z
expr_stmt|;
break|break;
case|case
literal|32
case|:
default|default:
name|dev_priv
operator|->
name|depth_fmt
operator|=
name|RADEON_DEPTH_FORMAT_24BIT_INT_Z
expr_stmt|;
break|break;
block|}
name|dev_priv
operator|->
name|depth_offset
operator|=
name|init
operator|->
name|depth_offset
expr_stmt|;
name|dev_priv
operator|->
name|depth_pitch
operator|=
name|init
operator|->
name|depth_pitch
expr_stmt|;
name|dev_priv
operator|->
name|front_pitch_offset
operator|=
operator|(
operator|(
operator|(
name|dev_priv
operator|->
name|front_pitch
operator|/
literal|64
operator|)
operator|<<
literal|22
operator|)
operator||
operator|(
name|dev_priv
operator|->
name|front_offset
operator|>>
literal|10
operator|)
operator|)
expr_stmt|;
name|dev_priv
operator|->
name|back_pitch_offset
operator|=
operator|(
operator|(
operator|(
name|dev_priv
operator|->
name|back_pitch
operator|/
literal|64
operator|)
operator|<<
literal|22
operator|)
operator||
operator|(
name|dev_priv
operator|->
name|back_offset
operator|>>
literal|10
operator|)
operator|)
expr_stmt|;
name|dev_priv
operator|->
name|depth_pitch_offset
operator|=
operator|(
operator|(
operator|(
name|dev_priv
operator|->
name|depth_pitch
operator|/
literal|64
operator|)
operator|<<
literal|22
operator|)
operator||
operator|(
name|dev_priv
operator|->
name|depth_offset
operator|>>
literal|10
operator|)
operator|)
expr_stmt|;
comment|/* Hardware state for depth clears.  Remove this if/when we no 	 * longer clear the depth buffer with a 3D rectangle.  Hard-code 	 * all values to prevent unwanted 3D state from slipping through 	 * and screwing with the clear operation. 	 */
name|dev_priv
operator|->
name|depth_clear
operator|.
name|rb3d_cntl
operator|=
operator|(
name|RADEON_PLANE_MASK_ENABLE
operator||
name|RADEON_Z_ENABLE
operator||
operator|(
name|dev_priv
operator|->
name|color_fmt
operator|<<
literal|10
operator|)
operator||
name|RADEON_ZBLOCK16
operator|)
expr_stmt|;
name|dev_priv
operator|->
name|depth_clear
operator|.
name|rb3d_zstencilcntl
operator|=
operator|(
name|dev_priv
operator|->
name|depth_fmt
operator||
name|RADEON_Z_TEST_ALWAYS
operator||
name|RADEON_STENCIL_TEST_ALWAYS
operator||
name|RADEON_STENCIL_S_FAIL_KEEP
operator||
name|RADEON_STENCIL_ZPASS_KEEP
operator||
name|RADEON_STENCIL_ZFAIL_KEEP
operator||
name|RADEON_Z_WRITE_ENABLE
operator|)
expr_stmt|;
name|dev_priv
operator|->
name|depth_clear
operator|.
name|se_cntl
operator|=
operator|(
name|RADEON_FFACE_CULL_CW
operator||
name|RADEON_BFACE_SOLID
operator||
name|RADEON_FFACE_SOLID
operator||
name|RADEON_FLAT_SHADE_VTX_LAST
operator||
name|RADEON_DIFFUSE_SHADE_FLAT
operator||
name|RADEON_ALPHA_SHADE_FLAT
operator||
name|RADEON_SPECULAR_SHADE_FLAT
operator||
name|RADEON_FOG_SHADE_FLAT
operator||
name|RADEON_VTX_PIX_CENTER_OGL
operator||
name|RADEON_ROUND_MODE_TRUNC
operator||
name|RADEON_ROUND_PREC_8TH_PIX
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__linux__
name|list_for_each
argument_list|(
argument|list
argument_list|,
argument|&dev->maplist->head
argument_list|)
block|{
name|drm_map_list_t
modifier|*
name|r_list
init|=
operator|(
name|drm_map_list_t
operator|*
operator|)
name|list
decl_stmt|;
if|if
condition|(
name|r_list
operator|->
name|map
operator|&&
name|r_list
operator|->
name|map
operator|->
name|type
operator|==
name|_DRM_SHM
operator|&&
name|r_list
operator|->
name|map
operator|->
name|flags
operator|&
name|_DRM_CONTAINS_LOCK
condition|)
block|{
name|dev_priv
operator|->
name|sarea
operator|=
name|r_list
operator|->
name|map
expr_stmt|;
break|break;
block|}
block|}
endif|#
directive|endif
comment|/* __linux__ */
ifdef|#
directive|ifdef
name|__FreeBSD__
name|TAILQ_FOREACH
argument_list|(
argument|listentry
argument_list|,
argument|dev->maplist
argument_list|,
argument|link
argument_list|)
block|{
name|drm_map_t
modifier|*
name|map
init|=
name|listentry
operator|->
name|map
decl_stmt|;
if|if
condition|(
name|map
operator|->
name|type
operator|==
name|_DRM_SHM
operator|&&
name|map
operator|->
name|flags
operator|&
name|_DRM_CONTAINS_LOCK
condition|)
block|{
name|dev_priv
operator|->
name|sarea
operator|=
name|map
expr_stmt|;
break|break;
block|}
block|}
endif|#
directive|endif
comment|/* __FreeBSD__ */
if|if
condition|(
operator|!
name|dev_priv
operator|->
name|sarea
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"could not find sarea!\n"
argument_list|)
expr_stmt|;
name|dev
operator|->
name|dev_private
operator|=
operator|(
name|void
operator|*
operator|)
name|dev_priv
expr_stmt|;
name|radeon_do_cleanup_cp
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|DRM_OS_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
name|DRM_FIND_MAP
argument_list|(
name|dev_priv
operator|->
name|fb
argument_list|,
name|init
operator|->
name|fb_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dev_priv
operator|->
name|fb
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"could not find framebuffer!\n"
argument_list|)
expr_stmt|;
name|dev
operator|->
name|dev_private
operator|=
operator|(
name|void
operator|*
operator|)
name|dev_priv
expr_stmt|;
name|radeon_do_cleanup_cp
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|DRM_OS_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
name|DRM_FIND_MAP
argument_list|(
name|dev_priv
operator|->
name|mmio
argument_list|,
name|init
operator|->
name|mmio_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dev_priv
operator|->
name|mmio
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"could not find mmio region!\n"
argument_list|)
expr_stmt|;
name|dev
operator|->
name|dev_private
operator|=
operator|(
name|void
operator|*
operator|)
name|dev_priv
expr_stmt|;
name|radeon_do_cleanup_cp
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|DRM_OS_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
name|DRM_FIND_MAP
argument_list|(
name|dev_priv
operator|->
name|cp_ring
argument_list|,
name|init
operator|->
name|ring_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dev_priv
operator|->
name|cp_ring
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"could not find cp ring region!\n"
argument_list|)
expr_stmt|;
name|dev
operator|->
name|dev_private
operator|=
operator|(
name|void
operator|*
operator|)
name|dev_priv
expr_stmt|;
name|radeon_do_cleanup_cp
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|DRM_OS_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
name|DRM_FIND_MAP
argument_list|(
name|dev_priv
operator|->
name|ring_rptr
argument_list|,
name|init
operator|->
name|ring_rptr_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dev_priv
operator|->
name|ring_rptr
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"could not find ring read pointer!\n"
argument_list|)
expr_stmt|;
name|dev
operator|->
name|dev_private
operator|=
operator|(
name|void
operator|*
operator|)
name|dev_priv
expr_stmt|;
name|radeon_do_cleanup_cp
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|DRM_OS_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
name|DRM_FIND_MAP
argument_list|(
name|dev_priv
operator|->
name|buffers
argument_list|,
name|init
operator|->
name|buffers_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dev_priv
operator|->
name|buffers
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"could not find dma buffer region!\n"
argument_list|)
expr_stmt|;
name|dev
operator|->
name|dev_private
operator|=
operator|(
name|void
operator|*
operator|)
name|dev_priv
expr_stmt|;
name|radeon_do_cleanup_cp
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|DRM_OS_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|dev_priv
operator|->
name|is_pci
condition|)
block|{
name|DRM_FIND_MAP
argument_list|(
name|dev_priv
operator|->
name|agp_textures
argument_list|,
name|init
operator|->
name|agp_textures_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dev_priv
operator|->
name|agp_textures
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"could not find agp texture region!\n"
argument_list|)
expr_stmt|;
name|dev
operator|->
name|dev_private
operator|=
operator|(
name|void
operator|*
operator|)
name|dev_priv
expr_stmt|;
name|radeon_do_cleanup_cp
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|DRM_OS_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
block|}
name|dev_priv
operator|->
name|sarea_priv
operator|=
operator|(
name|drm_radeon_sarea_t
operator|*
operator|)
operator|(
operator|(
name|u8
operator|*
operator|)
name|dev_priv
operator|->
name|sarea
operator|->
name|handle
operator|+
name|init
operator|->
name|sarea_priv_offset
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|dev_priv
operator|->
name|is_pci
condition|)
block|{
name|DRM_IOREMAP
argument_list|(
name|dev_priv
operator|->
name|cp_ring
argument_list|)
expr_stmt|;
name|DRM_IOREMAP
argument_list|(
name|dev_priv
operator|->
name|ring_rptr
argument_list|)
expr_stmt|;
name|DRM_IOREMAP
argument_list|(
name|dev_priv
operator|->
name|buffers
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dev_priv
operator|->
name|cp_ring
operator|->
name|handle
operator|||
operator|!
name|dev_priv
operator|->
name|ring_rptr
operator|->
name|handle
operator|||
operator|!
name|dev_priv
operator|->
name|buffers
operator|->
name|handle
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"could not find ioremap agp regions!\n"
argument_list|)
expr_stmt|;
name|dev
operator|->
name|dev_private
operator|=
operator|(
name|void
operator|*
operator|)
name|dev_priv
expr_stmt|;
name|radeon_do_cleanup_cp
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|DRM_OS_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
block|}
else|else
block|{
name|dev_priv
operator|->
name|cp_ring
operator|->
name|handle
operator|=
operator|(
name|void
operator|*
operator|)
name|dev_priv
operator|->
name|cp_ring
operator|->
name|offset
expr_stmt|;
name|dev_priv
operator|->
name|ring_rptr
operator|->
name|handle
operator|=
operator|(
name|void
operator|*
operator|)
name|dev_priv
operator|->
name|ring_rptr
operator|->
name|offset
expr_stmt|;
name|dev_priv
operator|->
name|buffers
operator|->
name|handle
operator|=
operator|(
name|void
operator|*
operator|)
name|dev_priv
operator|->
name|buffers
operator|->
name|offset
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"dev_priv->cp_ring->handle %p\n"
argument_list|,
name|dev_priv
operator|->
name|cp_ring
operator|->
name|handle
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"dev_priv->ring_rptr->handle %p\n"
argument_list|,
name|dev_priv
operator|->
name|ring_rptr
operator|->
name|handle
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"dev_priv->buffers->handle %p\n"
argument_list|,
name|dev_priv
operator|->
name|buffers
operator|->
name|handle
argument_list|)
expr_stmt|;
block|}
name|dev_priv
operator|->
name|agp_size
operator|=
name|init
operator|->
name|agp_size
expr_stmt|;
name|dev_priv
operator|->
name|agp_vm_start
operator|=
name|RADEON_READ
argument_list|(
name|RADEON_CONFIG_APER_SIZE
argument_list|)
expr_stmt|;
if|#
directive|if
name|__REALLY_HAVE_AGP
if|if
condition|(
operator|!
name|dev_priv
operator|->
name|is_pci
condition|)
name|dev_priv
operator|->
name|agp_buffers_offset
operator|=
operator|(
name|dev_priv
operator|->
name|buffers
operator|->
name|offset
operator|-
name|dev
operator|->
name|agp
operator|->
name|base
operator|+
name|dev_priv
operator|->
name|agp_vm_start
operator|)
expr_stmt|;
else|else
endif|#
directive|endif
name|dev_priv
operator|->
name|agp_buffers_offset
operator|=
operator|(
name|dev_priv
operator|->
name|buffers
operator|->
name|offset
operator|-
name|dev
operator|->
name|sg
operator|->
name|handle
operator|+
name|dev_priv
operator|->
name|agp_vm_start
operator|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"dev_priv->agp_size %d\n"
argument_list|,
name|dev_priv
operator|->
name|agp_size
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"dev_priv->agp_vm_start 0x%x\n"
argument_list|,
name|dev_priv
operator|->
name|agp_vm_start
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"dev_priv->agp_buffers_offset 0x%lx\n"
argument_list|,
name|dev_priv
operator|->
name|agp_buffers_offset
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|ring
operator|.
name|head
operator|=
operator|(
operator|(
specifier|__volatile__
name|u32
operator|*
operator|)
name|dev_priv
operator|->
name|ring_rptr
operator|->
name|handle
operator|)
expr_stmt|;
name|dev_priv
operator|->
name|ring
operator|.
name|start
operator|=
operator|(
name|u32
operator|*
operator|)
name|dev_priv
operator|->
name|cp_ring
operator|->
name|handle
expr_stmt|;
name|dev_priv
operator|->
name|ring
operator|.
name|end
operator|=
operator|(
operator|(
name|u32
operator|*
operator|)
name|dev_priv
operator|->
name|cp_ring
operator|->
name|handle
operator|+
name|init
operator|->
name|ring_size
operator|/
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
operator|)
expr_stmt|;
name|dev_priv
operator|->
name|ring
operator|.
name|size
operator|=
name|init
operator|->
name|ring_size
expr_stmt|;
name|dev_priv
operator|->
name|ring
operator|.
name|size_l2qw
operator|=
name|DRM
argument_list|(
name|order
argument_list|)
argument_list|(
name|init
operator|->
name|ring_size
operator|/
literal|8
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|ring
operator|.
name|tail_mask
operator|=
operator|(
name|dev_priv
operator|->
name|ring
operator|.
name|size
operator|/
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
operator|)
operator|-
literal|1
expr_stmt|;
name|dev_priv
operator|->
name|ring
operator|.
name|high_mark
operator|=
name|RADEON_RING_HIGH_MARK
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Initialize the scratch register pointer.  This will cause 	 * the scratch register values to be written out to memory 	 * whenever they are updated. 	 * FIXME: This doesn't quite work yet, so we're disabling it 	 * for the release. 	 */
block|RADEON_WRITE( RADEON_SCRATCH_ADDR, (dev_priv->ring_rptr->offset + 					    RADEON_SCRATCH_REG_OFFSET) ); 	RADEON_WRITE( RADEON_SCRATCH_UMSK, 0x7 );
endif|#
directive|endif
name|dev_priv
operator|->
name|scratch
operator|=
operator|(
operator|(
specifier|__volatile__
name|u32
operator|*
operator|)
name|dev_priv
operator|->
name|ring_rptr
operator|->
name|handle
operator|+
operator|(
name|RADEON_SCRATCH_REG_OFFSET
operator|/
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
operator|)
operator|)
expr_stmt|;
name|dev_priv
operator|->
name|sarea_priv
operator|->
name|last_frame
operator|=
literal|0
expr_stmt|;
name|RADEON_WRITE
argument_list|(
name|RADEON_LAST_FRAME_REG
argument_list|,
name|dev_priv
operator|->
name|sarea_priv
operator|->
name|last_frame
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|sarea_priv
operator|->
name|last_dispatch
operator|=
literal|0
expr_stmt|;
name|RADEON_WRITE
argument_list|(
name|RADEON_LAST_DISPATCH_REG
argument_list|,
name|dev_priv
operator|->
name|sarea_priv
operator|->
name|last_dispatch
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|sarea_priv
operator|->
name|last_clear
operator|=
literal|0
expr_stmt|;
name|RADEON_WRITE
argument_list|(
name|RADEON_LAST_CLEAR_REG
argument_list|,
name|dev_priv
operator|->
name|sarea_priv
operator|->
name|last_clear
argument_list|)
expr_stmt|;
if|#
directive|if
name|__REALLY_HAVE_SG
if|if
condition|(
name|dev_priv
operator|->
name|is_pci
condition|)
block|{
if|if
condition|(
operator|!
name|DRM
argument_list|(
name|ati_pcigart_init
argument_list|)
argument_list|(
name|dev
argument_list|,
operator|&
name|dev_priv
operator|->
name|phys_pci_gart
argument_list|,
operator|&
name|dev_priv
operator|->
name|bus_pci_gart
argument_list|)
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"failed to init PCI GART!\n"
argument_list|)
expr_stmt|;
name|dev
operator|->
name|dev_private
operator|=
operator|(
name|void
operator|*
operator|)
name|dev_priv
expr_stmt|;
name|radeon_do_cleanup_cp
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|DRM_OS_ERR
argument_list|(
name|ENOMEM
argument_list|)
return|;
block|}
comment|/* Turn on PCI GART 		 */
name|tmp
operator|=
name|RADEON_READ
argument_list|(
name|RADEON_AIC_CNTL
argument_list|)
operator||
name|RADEON_PCIGART_TRANSLATE_EN
expr_stmt|;
name|RADEON_WRITE
argument_list|(
name|RADEON_AIC_CNTL
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* set PCI GART page-table base address 		 */
name|RADEON_WRITE
argument_list|(
name|RADEON_AIC_PT_BASE
argument_list|,
name|dev_priv
operator|->
name|bus_pci_gart
argument_list|)
expr_stmt|;
comment|/* set address range for PCI address translate 		 */
name|RADEON_WRITE
argument_list|(
name|RADEON_AIC_LO_ADDR
argument_list|,
name|dev_priv
operator|->
name|agp_vm_start
argument_list|)
expr_stmt|;
name|RADEON_WRITE
argument_list|(
name|RADEON_AIC_HI_ADDR
argument_list|,
name|dev_priv
operator|->
name|agp_vm_start
operator|+
name|dev_priv
operator|->
name|agp_size
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Turn off AGP aperture -- is this required for PCIGART? 		 */
name|RADEON_WRITE
argument_list|(
name|RADEON_MC_AGP_LOCATION
argument_list|,
literal|0xffffffc0
argument_list|)
expr_stmt|;
comment|/* ?? */
name|RADEON_WRITE
argument_list|(
name|RADEON_AGP_COMMAND
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* clear AGP_COMMAND */
block|}
else|else
block|{
endif|#
directive|endif
comment|/* Turn off PCI GART 		 */
name|tmp
operator|=
name|RADEON_READ
argument_list|(
name|RADEON_AIC_CNTL
argument_list|)
operator|&
operator|~
name|RADEON_PCIGART_TRANSLATE_EN
expr_stmt|;
name|RADEON_WRITE
argument_list|(
name|RADEON_AIC_CNTL
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
if|#
directive|if
name|__REALLY_HAVE_SG
block|}
endif|#
directive|endif
name|radeon_cp_load_microcode
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
name|radeon_cp_init_ring_buffer
argument_list|(
name|dev
argument_list|,
name|dev_priv
argument_list|)
expr_stmt|;
if|#
directive|if
name|ROTATE_BUFS
name|dev_priv
operator|->
name|last_buf
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|dev
operator|->
name|dev_private
operator|=
operator|(
name|void
operator|*
operator|)
name|dev_priv
expr_stmt|;
name|radeon_do_engine_reset
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|radeon_do_cleanup_cp
parameter_list|(
name|drm_device_t
modifier|*
name|dev
parameter_list|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"%s\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|dev_private
condition|)
block|{
name|drm_radeon_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
if|#
directive|if
name|__REALLY_HAVE_SG
if|if
condition|(
operator|!
name|dev_priv
operator|->
name|is_pci
condition|)
block|{
endif|#
directive|endif
name|DRM_IOREMAPFREE
argument_list|(
name|dev_priv
operator|->
name|cp_ring
argument_list|)
expr_stmt|;
name|DRM_IOREMAPFREE
argument_list|(
name|dev_priv
operator|->
name|ring_rptr
argument_list|)
expr_stmt|;
name|DRM_IOREMAPFREE
argument_list|(
name|dev_priv
operator|->
name|buffers
argument_list|)
expr_stmt|;
if|#
directive|if
name|__REALLY_HAVE_SG
block|}
else|else
block|{
if|if
condition|(
operator|!
name|DRM
argument_list|(
name|ati_pcigart_cleanup
argument_list|)
argument_list|(
name|dev
argument_list|,
name|dev_priv
operator|->
name|phys_pci_gart
argument_list|,
name|dev_priv
operator|->
name|bus_pci_gart
argument_list|)
condition|)
name|DRM_ERROR
argument_list|(
literal|"failed to cleanup PCI GART!\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|DRM
argument_list|(
name|free
argument_list|)
argument_list|(
name|dev
operator|->
name|dev_private
argument_list|,
sizeof|sizeof
argument_list|(
name|drm_radeon_private_t
argument_list|)
argument_list|,
name|DRM_MEM_DRIVER
argument_list|)
expr_stmt|;
name|dev
operator|->
name|dev_private
operator|=
name|NULL
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|radeon_cp_init
parameter_list|(
name|DRM_OS_IOCTL
parameter_list|)
block|{
name|DRM_OS_DEVICE
expr_stmt|;
name|drm_radeon_init_t
name|init
decl_stmt|;
name|DRM_OS_KRNFROMUSR
argument_list|(
name|init
argument_list|,
operator|(
name|drm_radeon_init_t
operator|*
operator|)
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|init
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|init
operator|.
name|func
condition|)
block|{
case|case
name|RADEON_INIT_CP
case|:
return|return
name|radeon_do_init_cp
argument_list|(
name|dev
argument_list|,
operator|&
name|init
argument_list|)
return|;
case|case
name|RADEON_CLEANUP_CP
case|:
return|return
name|radeon_do_cleanup_cp
argument_list|(
name|dev
argument_list|)
return|;
block|}
return|return
name|DRM_OS_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|radeon_cp_start
parameter_list|(
name|DRM_OS_IOCTL
parameter_list|)
block|{
name|DRM_OS_DEVICE
expr_stmt|;
name|drm_radeon_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"%s\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|LOCK_TEST_WITH_RETURN
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|cp_running
condition|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"%s while CP running\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|dev_priv
operator|->
name|cp_mode
operator|==
name|RADEON_CSQ_PRIDIS_INDDIS
condition|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"%s called with bogus CP mode (%d)\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|dev_priv
operator|->
name|cp_mode
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|radeon_do_cp_start
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Stop the CP.  The engine must have been idled before calling this  * routine.  */
end_comment

begin_function
name|int
name|radeon_cp_stop
parameter_list|(
name|DRM_OS_IOCTL
parameter_list|)
block|{
name|DRM_OS_DEVICE
expr_stmt|;
name|drm_radeon_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|drm_radeon_cp_stop_t
name|stop
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"%s\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|LOCK_TEST_WITH_RETURN
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|DRM_OS_KRNFROMUSR
argument_list|(
name|stop
argument_list|,
operator|(
name|drm_radeon_cp_stop_t
operator|*
operator|)
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|stop
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Flush any pending CP commands.  This ensures any outstanding 	 * commands are exectuted by the engine before we turn it off. 	 */
if|if
condition|(
name|stop
operator|.
name|flush
condition|)
block|{
name|radeon_do_cp_flush
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
block|}
comment|/* If we fail to make the engine go idle, we return an error 	 * code so that the DRM ioctl wrapper can try again. 	 */
if|if
condition|(
name|stop
operator|.
name|idle
condition|)
block|{
name|ret
operator|=
name|radeon_do_cp_idle
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__linux__
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
return|return
name|ret
return|;
endif|#
directive|endif
comment|/* __linux__ */
ifdef|#
directive|ifdef
name|__FreeBSD__
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
endif|#
directive|endif
comment|/* __FreeBSD__ */
block|}
comment|/* Finally, we can turn off the CP.  If the engine isn't idle, 	 * we will get some dropped triangles as they won't be fully 	 * rendered before the CP is shut down. 	 */
name|radeon_do_cp_stop
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
comment|/* Reset the engine */
name|radeon_do_engine_reset
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Just reset the CP ring.  Called as part of an X Server engine reset.  */
end_comment

begin_function
name|int
name|radeon_cp_reset
parameter_list|(
name|DRM_OS_IOCTL
parameter_list|)
block|{
name|DRM_OS_DEVICE
expr_stmt|;
name|drm_radeon_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"%s\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|LOCK_TEST_WITH_RETURN
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dev_priv
condition|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"%s called before init done\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
return|return
name|DRM_OS_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
name|radeon_do_cp_reset
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
comment|/* The CP is no longer running after an engine reset */
name|dev_priv
operator|->
name|cp_running
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|radeon_cp_idle
parameter_list|(
name|DRM_OS_IOCTL
parameter_list|)
block|{
name|DRM_OS_DEVICE
expr_stmt|;
name|drm_radeon_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"%s\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|LOCK_TEST_WITH_RETURN
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|radeon_do_cp_idle
argument_list|(
name|dev_priv
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|radeon_engine_reset
parameter_list|(
name|DRM_OS_IOCTL
parameter_list|)
block|{
name|DRM_OS_DEVICE
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"%s\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|LOCK_TEST_WITH_RETURN
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|radeon_do_engine_reset
argument_list|(
name|dev
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ================================================================  * Fullscreen mode  */
end_comment

begin_function
specifier|static
name|int
name|radeon_do_init_pageflip
parameter_list|(
name|drm_device_t
modifier|*
name|dev
parameter_list|)
block|{
name|drm_radeon_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"%s\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|crtc_offset
operator|=
name|RADEON_READ
argument_list|(
name|RADEON_CRTC_OFFSET
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|crtc_offset_cntl
operator|=
name|RADEON_READ
argument_list|(
name|RADEON_CRTC_OFFSET_CNTL
argument_list|)
expr_stmt|;
name|RADEON_WRITE
argument_list|(
name|RADEON_CRTC_OFFSET
argument_list|,
name|dev_priv
operator|->
name|front_offset
argument_list|)
expr_stmt|;
name|RADEON_WRITE
argument_list|(
name|RADEON_CRTC_OFFSET_CNTL
argument_list|,
name|dev_priv
operator|->
name|crtc_offset_cntl
operator||
name|RADEON_CRTC_OFFSET_FLIP_CNTL
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|page_flipping
operator|=
literal|1
expr_stmt|;
name|dev_priv
operator|->
name|current_page
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|radeon_do_cleanup_pageflip
parameter_list|(
name|drm_device_t
modifier|*
name|dev
parameter_list|)
block|{
name|drm_radeon_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"%s\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|RADEON_WRITE
argument_list|(
name|RADEON_CRTC_OFFSET
argument_list|,
name|dev_priv
operator|->
name|crtc_offset
argument_list|)
expr_stmt|;
name|RADEON_WRITE
argument_list|(
name|RADEON_CRTC_OFFSET_CNTL
argument_list|,
name|dev_priv
operator|->
name|crtc_offset_cntl
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|page_flipping
operator|=
literal|0
expr_stmt|;
name|dev_priv
operator|->
name|current_page
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|radeon_fullscreen
parameter_list|(
name|DRM_OS_IOCTL
parameter_list|)
block|{
name|DRM_OS_DEVICE
expr_stmt|;
name|drm_radeon_fullscreen_t
name|fs
decl_stmt|;
name|LOCK_TEST_WITH_RETURN
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|DRM_OS_KRNFROMUSR
argument_list|(
name|fs
argument_list|,
operator|(
name|drm_radeon_fullscreen_t
operator|*
operator|)
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|fs
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|fs
operator|.
name|func
condition|)
block|{
case|case
name|RADEON_INIT_FULLSCREEN
case|:
return|return
name|radeon_do_init_pageflip
argument_list|(
name|dev
argument_list|)
return|;
case|case
name|RADEON_CLEANUP_FULLSCREEN
case|:
return|return
name|radeon_do_cleanup_pageflip
argument_list|(
name|dev
argument_list|)
return|;
block|}
return|return
name|DRM_OS_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ================================================================  * Freelist management  */
end_comment

begin_define
define|#
directive|define
name|RADEON_BUFFER_USED
value|0xffffffff
end_define

begin_define
define|#
directive|define
name|RADEON_BUFFER_FREE
value|0
end_define

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static int radeon_freelist_init( drm_device_t *dev ) { 	drm_device_dma_t *dma = dev->dma; 	drm_radeon_private_t *dev_priv = dev->dev_private; 	drm_buf_t *buf; 	drm_radeon_buf_priv_t *buf_priv; 	drm_radeon_freelist_t *entry; 	int i;  	dev_priv->head = DRM(alloc)( sizeof(drm_radeon_freelist_t), 				     DRM_MEM_DRIVER ); 	if ( dev_priv->head == NULL ) 		return DRM_OS_ERR(ENOMEM);  	memset( dev_priv->head, 0, sizeof(drm_radeon_freelist_t) ); 	dev_priv->head->age = RADEON_BUFFER_USED;  	for ( i = 0 ; i< dma->buf_count ; i++ ) { 		buf = dma->buflist[i]; 		buf_priv = buf->dev_private;  		entry = DRM(alloc)( sizeof(drm_radeon_freelist_t), 				    DRM_MEM_DRIVER ); 		if ( !entry ) return DRM_OS_ERR(ENOMEM);  		entry->age = RADEON_BUFFER_FREE; 		entry->buf = buf; 		entry->prev = dev_priv->head; 		entry->next = dev_priv->head->next; 		if ( !entry->next ) 			dev_priv->tail = entry;  		buf_priv->discard = 0; 		buf_priv->dispatched = 0; 		buf_priv->list_entry = entry;  		dev_priv->head->next = entry;  		if ( dev_priv->head->next ) 			dev_priv->head->next->prev = entry; 	}  	return 0;  }
endif|#
directive|endif
end_endif

begin_function
name|drm_buf_t
modifier|*
name|radeon_freelist_get
parameter_list|(
name|drm_device_t
modifier|*
name|dev
parameter_list|)
block|{
name|drm_device_dma_t
modifier|*
name|dma
init|=
name|dev
operator|->
name|dma
decl_stmt|;
name|drm_radeon_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|drm_radeon_buf_priv_t
modifier|*
name|buf_priv
decl_stmt|;
name|drm_buf_t
modifier|*
name|buf
decl_stmt|;
name|int
name|i
decl_stmt|,
name|t
decl_stmt|;
if|#
directive|if
name|ROTATE_BUFS
name|int
name|start
decl_stmt|;
endif|#
directive|endif
comment|/* FIXME: Optimize -- use freelist code */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dma
operator|->
name|buf_count
condition|;
name|i
operator|++
control|)
block|{
name|buf
operator|=
name|dma
operator|->
name|buflist
index|[
name|i
index|]
expr_stmt|;
name|buf_priv
operator|=
name|buf
operator|->
name|dev_private
expr_stmt|;
if|if
condition|(
name|buf
operator|->
name|pid
operator|==
literal|0
condition|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"  ret buf=%d last=%d pid=0\n"
argument_list|,
name|buf
operator|->
name|idx
argument_list|,
name|dev_priv
operator|->
name|last_buf
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
name|DRM_DEBUG
argument_list|(
literal|"    skipping buf=%d pid=%d\n"
argument_list|,
name|buf
operator|->
name|idx
argument_list|,
name|buf
operator|->
name|pid
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|ROTATE_BUFS
if|if
condition|(
operator|++
name|dev_priv
operator|->
name|last_buf
operator|>=
name|dma
operator|->
name|buf_count
condition|)
name|dev_priv
operator|->
name|last_buf
operator|=
literal|0
expr_stmt|;
name|start
operator|=
name|dev_priv
operator|->
name|last_buf
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|t
operator|=
literal|0
init|;
name|t
operator|<
name|dev_priv
operator|->
name|usec_timeout
condition|;
name|t
operator|++
control|)
block|{
if|#
directive|if
literal|0
comment|/* FIXME: Disable this for now */
block|u32 done_age = dev_priv->scratch[RADEON_LAST_DISPATCH];
else|#
directive|else
name|u32
name|done_age
init|=
name|RADEON_READ
argument_list|(
name|RADEON_LAST_DISPATCH_REG
argument_list|)
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
name|ROTATE_BUFS
for|for
control|(
name|i
operator|=
name|start
init|;
name|i
operator|<
name|dma
operator|->
name|buf_count
condition|;
name|i
operator|++
control|)
block|{
else|#
directive|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dma
operator|->
name|buf_count
condition|;
name|i
operator|++
control|)
block|{
endif|#
directive|endif
name|buf
operator|=
name|dma
operator|->
name|buflist
index|[
name|i
index|]
expr_stmt|;
name|buf_priv
operator|=
name|buf
operator|->
name|dev_private
expr_stmt|;
if|if
condition|(
name|buf
operator|->
name|pending
operator|&&
name|buf_priv
operator|->
name|age
operator|<=
name|done_age
condition|)
block|{
comment|/* The buffer has been processed, so it 				 * can now be used. 				 */
name|buf
operator|->
name|pending
operator|=
literal|0
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"  ret buf=%d last=%d age=%d done=%d\n"
argument_list|,
name|buf
operator|->
name|idx
argument_list|,
name|dev_priv
operator|->
name|last_buf
argument_list|,
name|buf_priv
operator|->
name|age
argument_list|,
name|done_age
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
name|DRM_DEBUG
argument_list|(
literal|"    skipping buf=%d age=%d done=%d\n"
argument_list|,
name|buf
operator|->
name|idx
argument_list|,
name|buf_priv
operator|->
name|age
argument_list|,
name|done_age
argument_list|)
expr_stmt|;
if|#
directive|if
name|ROTATE_BUFS
name|start
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
name|DRM_OS_DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|DRM_ERROR
argument_list|(
literal|"returning NULL!\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|void
name|radeon_freelist_reset
parameter_list|(
name|drm_device_t
modifier|*
name|dev
parameter_list|)
block|{
name|drm_device_dma_t
modifier|*
name|dma
init|=
name|dev
operator|->
name|dma
decl_stmt|;
if|#
directive|if
name|ROTATE_BUFS
name|drm_radeon_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
endif|#
directive|endif
name|int
name|i
decl_stmt|;
if|#
directive|if
name|ROTATE_BUFS
name|dev_priv
operator|->
name|last_buf
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dma
operator|->
name|buf_count
condition|;
name|i
operator|++
control|)
block|{
name|drm_buf_t
modifier|*
name|buf
init|=
name|dma
operator|->
name|buflist
index|[
name|i
index|]
decl_stmt|;
name|drm_radeon_buf_priv_t
modifier|*
name|buf_priv
init|=
name|buf
operator|->
name|dev_private
decl_stmt|;
name|buf_priv
operator|->
name|age
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* ================================================================  * CP command submission  */
name|int
name|radeon_wait_ring
parameter_list|(
name|drm_radeon_private_t
modifier|*
name|dev_priv
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|drm_radeon_ring_buffer_t
modifier|*
name|ring
init|=
operator|&
name|dev_priv
operator|->
name|ring
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dev_priv
operator|->
name|usec_timeout
condition|;
name|i
operator|++
control|)
block|{
name|radeon_update_ring_snapshot
argument_list|(
name|ring
argument_list|)
expr_stmt|;
if|if
condition|(
name|ring
operator|->
name|space
operator|>
name|n
condition|)
return|return
literal|0
return|;
name|DRM_OS_DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* FIXME: This return value is ignored in the BEGIN_RING macro! */
if|#
directive|if
name|RADEON_FIFO_DEBUG
name|radeon_status
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
name|DRM_ERROR
argument_list|(
literal|"failed!\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|DRM_OS_ERR
argument_list|(
name|EBUSY
argument_list|)
return|;
block|}
specifier|static
name|int
name|radeon_cp_get_buffers
parameter_list|(
name|drm_device_t
modifier|*
name|dev
parameter_list|,
name|drm_dma_t
modifier|*
name|d
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|drm_buf_t
modifier|*
name|buf
decl_stmt|;
for|for
control|(
name|i
operator|=
name|d
operator|->
name|granted_count
init|;
name|i
operator|<
name|d
operator|->
name|request_count
condition|;
name|i
operator|++
control|)
block|{
name|buf
operator|=
name|radeon_freelist_get
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buf
condition|)
return|return
name|DRM_OS_ERR
argument_list|(
name|EAGAIN
argument_list|)
return|;
name|buf
operator|->
name|pid
operator|=
name|DRM_OS_CURRENTPID
expr_stmt|;
if|if
condition|(
name|DRM_OS_COPYTOUSR
argument_list|(
operator|&
name|d
operator|->
name|request_indices
index|[
name|i
index|]
argument_list|,
operator|&
name|buf
operator|->
name|idx
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
operator|->
name|idx
argument_list|)
argument_list|)
condition|)
return|return
name|DRM_OS_ERR
argument_list|(
name|EFAULT
argument_list|)
return|;
if|if
condition|(
name|DRM_OS_COPYTOUSR
argument_list|(
operator|&
name|d
operator|->
name|request_sizes
index|[
name|i
index|]
argument_list|,
operator|&
name|buf
operator|->
name|total
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
operator|->
name|total
argument_list|)
argument_list|)
condition|)
return|return
name|DRM_OS_ERR
argument_list|(
name|EFAULT
argument_list|)
return|;
name|d
operator|->
name|granted_count
operator|++
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
name|int
name|radeon_cp_buffers
parameter_list|(
name|DRM_OS_IOCTL
parameter_list|)
block|{
name|DRM_OS_DEVICE
expr_stmt|;
name|drm_device_dma_t
modifier|*
name|dma
init|=
name|dev
operator|->
name|dma
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|drm_dma_t
name|d
decl_stmt|;
name|LOCK_TEST_WITH_RETURN
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|DRM_OS_KRNFROMUSR
argument_list|(
name|d
argument_list|,
operator|(
name|drm_dma_t
operator|*
operator|)
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|d
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Please don't send us buffers. 	 */
if|if
condition|(
name|d
operator|.
name|send_count
operator|!=
literal|0
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Process %d trying to send %d buffers via drmDMA\n"
argument_list|,
name|DRM_OS_CURRENTPID
argument_list|,
name|d
operator|.
name|send_count
argument_list|)
expr_stmt|;
return|return
name|DRM_OS_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
comment|/* We'll send you buffers. 	 */
if|if
condition|(
name|d
operator|.
name|request_count
operator|<
literal|0
operator|||
name|d
operator|.
name|request_count
operator|>
name|dma
operator|->
name|buf_count
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Process %d trying to get %d buffers (of %d max)\n"
argument_list|,
name|DRM_OS_CURRENTPID
argument_list|,
name|d
operator|.
name|request_count
argument_list|,
name|dma
operator|->
name|buf_count
argument_list|)
expr_stmt|;
return|return
name|DRM_OS_ERR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
name|d
operator|.
name|granted_count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|d
operator|.
name|request_count
condition|)
block|{
name|ret
operator|=
name|radeon_cp_get_buffers
argument_list|(
name|dev
argument_list|,
operator|&
name|d
argument_list|)
expr_stmt|;
block|}
name|DRM_OS_KRNTOUSR
argument_list|(
operator|(
name|drm_dma_t
operator|*
operator|)
name|data
argument_list|,
name|d
argument_list|,
sizeof|sizeof
argument_list|(
name|d
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

end_unit

