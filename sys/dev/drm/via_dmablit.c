begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* via_dmablit.c -- PCI DMA BitBlt support for the VIA Unichrome/Pro  *  * Copyright (C) 2005 Thomas Hellstrom, All Rights Reserved.  *  * Permission is hereby granted, free of charge, to any person obtaining a  * copy of this software and associated documentation files (the "Software"),  * to deal in the Software without restriction, including without limitation  * the rights to use, copy, modify, merge, publish, distribute, sub license,  * and/or sell copies of the Software, and to permit persons to whom the  * Software is furnished to do so, subject to the following conditions:  *  * The above copyright notice and this permission notice (including the  * next paragraph) shall be included in all copies or substantial portions  * of the Software.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL  * THE COPYRIGHT HOLDERS, AUTHORS AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM,  * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR  * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE  * USE OR OTHER DEALINGS IN THE SOFTWARE.  *  * Authors:  *    Thomas Hellstrom.  *    Partially based on code obtained from Digeo Inc.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Unmaps the DMA mappings.  * FIXME: Is this a NoOp on x86? Also  * FIXME: What happens if this one is called and a pending blit has previously done  * the same DMA mappings?  */
end_comment

begin_include
include|#
directive|include
file|"dev/drm/drmP.h"
end_include

begin_include
include|#
directive|include
file|"dev/drm/via_drm.h"
end_include

begin_include
include|#
directive|include
file|"dev/drm/via_drv.h"
end_include

begin_include
include|#
directive|include
file|"dev/drm/via_dmablit.h"
end_include

begin_define
define|#
directive|define
name|VIA_PGDN
parameter_list|(
name|x
parameter_list|)
value|(((unsigned long)(x))& ~PAGE_MASK)
end_define

begin_define
define|#
directive|define
name|VIA_PGOFF
parameter_list|(
name|x
parameter_list|)
value|(((unsigned long)(x))& PAGE_MASK)
end_define

begin_define
define|#
directive|define
name|VIA_PFN
parameter_list|(
name|x
parameter_list|)
value|((unsigned long)(x)>> PAGE_SHIFT)
end_define

begin_typedef
typedef|typedef
struct|struct
name|_drm_via_descriptor
block|{
name|uint32_t
name|mem_addr
decl_stmt|;
name|uint32_t
name|dev_addr
decl_stmt|;
name|uint32_t
name|size
decl_stmt|;
name|uint32_t
name|next
decl_stmt|;
block|}
name|drm_via_descriptor_t
typedef|;
end_typedef

begin_function_decl
specifier|static
name|void
name|via_dmablit_timer
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Unmap a DMA mapping.  */
end_comment

begin_function
specifier|static
name|void
name|via_unmap_blit_from_device
parameter_list|(
name|drm_via_sg_info_t
modifier|*
name|vsg
parameter_list|)
block|{
name|int
name|num_desc
init|=
name|vsg
operator|->
name|num_desc
decl_stmt|;
name|unsigned
name|cur_descriptor_page
init|=
name|num_desc
operator|/
name|vsg
operator|->
name|descriptors_per_page
decl_stmt|;
name|unsigned
name|descriptor_this_page
init|=
name|num_desc
operator|%
name|vsg
operator|->
name|descriptors_per_page
decl_stmt|;
name|drm_via_descriptor_t
modifier|*
name|desc_ptr
init|=
name|vsg
operator|->
name|desc_pages
index|[
name|cur_descriptor_page
index|]
operator|+
name|descriptor_this_page
decl_stmt|;
name|dma_addr_t
name|next
init|=
name|vsg
operator|->
name|chain_start
decl_stmt|;
while|while
condition|(
name|num_desc
operator|--
condition|)
block|{
if|if
condition|(
name|descriptor_this_page
operator|--
operator|==
literal|0
condition|)
block|{
name|cur_descriptor_page
operator|--
expr_stmt|;
name|descriptor_this_page
operator|=
name|vsg
operator|->
name|descriptors_per_page
operator|-
literal|1
expr_stmt|;
name|desc_ptr
operator|=
name|vsg
operator|->
name|desc_pages
index|[
name|cur_descriptor_page
index|]
operator|+
name|descriptor_this_page
expr_stmt|;
block|}
name|next
operator|=
operator|(
name|dma_addr_t
operator|)
name|desc_ptr
operator|->
name|next
expr_stmt|;
name|desc_ptr
operator|--
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * If mode = 0, count how many descriptors are needed.  * If mode = 1, Map the DMA pages for the device, put together and map also the descriptors.  * Descriptors are run in reverse order by the hardware because we are not allowed to update the  * 'next' field without syncing calls when the descriptor is already mapped.  */
end_comment

begin_function
specifier|static
name|void
name|via_map_blit_for_device
parameter_list|(
specifier|const
name|drm_via_dmablit_t
modifier|*
name|xfer
parameter_list|,
name|drm_via_sg_info_t
modifier|*
name|vsg
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|unsigned
name|cur_descriptor_page
init|=
literal|0
decl_stmt|;
name|unsigned
name|num_descriptors_this_page
init|=
literal|0
decl_stmt|;
name|unsigned
name|char
modifier|*
name|mem_addr
init|=
name|xfer
operator|->
name|mem_addr
decl_stmt|;
name|unsigned
name|char
modifier|*
name|cur_mem
decl_stmt|;
name|unsigned
name|char
modifier|*
name|first_addr
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|VIA_PGDN
argument_list|(
name|mem_addr
argument_list|)
decl_stmt|;
name|uint32_t
name|fb_addr
init|=
name|xfer
operator|->
name|fb_addr
decl_stmt|;
name|uint32_t
name|cur_fb
decl_stmt|;
name|unsigned
name|long
name|line_len
decl_stmt|;
name|unsigned
name|remaining_len
decl_stmt|;
name|int
name|num_desc
init|=
literal|0
decl_stmt|;
name|int
name|cur_line
decl_stmt|;
name|dma_addr_t
name|next
init|=
literal|0
operator||
name|VIA_DMA_DPR_EC
decl_stmt|;
name|drm_via_descriptor_t
modifier|*
name|desc_ptr
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|mode
operator|==
literal|1
condition|)
name|desc_ptr
operator|=
name|vsg
operator|->
name|desc_pages
index|[
name|cur_descriptor_page
index|]
expr_stmt|;
for|for
control|(
name|cur_line
operator|=
literal|0
init|;
name|cur_line
operator|<
name|xfer
operator|->
name|num_lines
condition|;
operator|++
name|cur_line
control|)
block|{
name|line_len
operator|=
name|xfer
operator|->
name|line_length
expr_stmt|;
name|cur_fb
operator|=
name|fb_addr
expr_stmt|;
name|cur_mem
operator|=
name|mem_addr
expr_stmt|;
while|while
condition|(
name|line_len
operator|>
literal|0
condition|)
block|{
name|remaining_len
operator|=
name|min
argument_list|(
name|PAGE_SIZE
operator|-
name|VIA_PGOFF
argument_list|(
name|cur_mem
argument_list|)
argument_list|,
name|line_len
argument_list|)
expr_stmt|;
name|line_len
operator|-=
name|remaining_len
expr_stmt|;
if|if
condition|(
name|mode
operator|==
literal|1
condition|)
block|{
name|desc_ptr
operator|->
name|mem_addr
operator|=
name|VM_PAGE_TO_PHYS
argument_list|(
name|vsg
operator|->
name|pages
index|[
name|VIA_PFN
argument_list|(
name|cur_mem
argument_list|)
operator|-
name|VIA_PFN
argument_list|(
name|first_addr
argument_list|)
index|]
argument_list|)
operator|+
name|VIA_PGOFF
argument_list|(
name|cur_mem
argument_list|)
expr_stmt|;
name|desc_ptr
operator|->
name|dev_addr
operator|=
name|cur_fb
expr_stmt|;
name|desc_ptr
operator|->
name|size
operator|=
name|remaining_len
expr_stmt|;
name|desc_ptr
operator|->
name|next
operator|=
operator|(
name|uint32_t
operator|)
name|next
expr_stmt|;
name|next
operator|=
name|vtophys
argument_list|(
name|desc_ptr
argument_list|)
expr_stmt|;
name|desc_ptr
operator|++
expr_stmt|;
if|if
condition|(
operator|++
name|num_descriptors_this_page
operator|>=
name|vsg
operator|->
name|descriptors_per_page
condition|)
block|{
name|num_descriptors_this_page
operator|=
literal|0
expr_stmt|;
name|desc_ptr
operator|=
name|vsg
operator|->
name|desc_pages
index|[
operator|++
name|cur_descriptor_page
index|]
expr_stmt|;
block|}
block|}
name|num_desc
operator|++
expr_stmt|;
name|cur_mem
operator|+=
name|remaining_len
expr_stmt|;
name|cur_fb
operator|+=
name|remaining_len
expr_stmt|;
block|}
name|mem_addr
operator|+=
name|xfer
operator|->
name|mem_stride
expr_stmt|;
name|fb_addr
operator|+=
name|xfer
operator|->
name|fb_stride
expr_stmt|;
block|}
if|if
condition|(
name|mode
operator|==
literal|1
condition|)
block|{
name|vsg
operator|->
name|chain_start
operator|=
name|next
expr_stmt|;
name|vsg
operator|->
name|state
operator|=
name|dr_via_device_mapped
expr_stmt|;
block|}
name|vsg
operator|->
name|num_desc
operator|=
name|num_desc
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Function that frees up all resources for a blit. It is usable even if the  * blit info has only been partially built as long as the status enum is consistent  * with the actual status of the used resources.  */
end_comment

begin_function
specifier|static
name|void
name|via_free_sg_info
parameter_list|(
name|drm_via_sg_info_t
modifier|*
name|vsg
parameter_list|)
block|{
name|vm_page_t
name|page
decl_stmt|;
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|vsg
operator|->
name|state
condition|)
block|{
case|case
name|dr_via_device_mapped
case|:
name|via_unmap_blit_from_device
argument_list|(
name|vsg
argument_list|)
expr_stmt|;
case|case
name|dr_via_desc_pages_alloc
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vsg
operator|->
name|num_desc_pages
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|vsg
operator|->
name|desc_pages
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|vsg
operator|->
name|desc_pages
index|[
name|i
index|]
argument_list|,
name|DRM_MEM_PAGES
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|vsg
operator|->
name|desc_pages
argument_list|,
name|DRM_MEM_DRIVER
argument_list|)
expr_stmt|;
case|case
name|dr_via_pages_locked
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vsg
operator|->
name|num_pages
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|NULL
operator|!=
operator|(
name|page
operator|=
name|vsg
operator|->
name|pages
index|[
name|i
index|]
operator|)
condition|)
block|{
name|vm_page_lock
argument_list|(
name|page
argument_list|)
expr_stmt|;
name|vm_page_lock_queues
argument_list|()
expr_stmt|;
name|vm_page_unwire
argument_list|(
name|page
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vm_page_unlock_queues
argument_list|()
expr_stmt|;
name|vm_page_unlock
argument_list|(
name|page
argument_list|)
expr_stmt|;
block|}
block|}
case|case
name|dr_via_pages_alloc
case|:
name|free
argument_list|(
name|vsg
operator|->
name|pages
argument_list|,
name|DRM_MEM_DRIVER
argument_list|)
expr_stmt|;
default|default:
name|vsg
operator|->
name|state
operator|=
name|dr_via_sg_init
expr_stmt|;
block|}
name|free
argument_list|(
name|vsg
operator|->
name|bounce_buffer
argument_list|,
name|DRM_MEM_DRIVER
argument_list|)
expr_stmt|;
name|vsg
operator|->
name|bounce_buffer
operator|=
name|NULL
expr_stmt|;
name|vsg
operator|->
name|free_on_sequence
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Fire a blit engine.  */
end_comment

begin_function
specifier|static
name|void
name|via_fire_dmablit
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|drm_via_sg_info_t
modifier|*
name|vsg
parameter_list|,
name|int
name|engine
parameter_list|)
block|{
name|drm_via_private_t
modifier|*
name|dev_priv
init|=
operator|(
name|drm_via_private_t
operator|*
operator|)
name|dev
operator|->
name|dev_private
decl_stmt|;
name|VIA_WRITE
argument_list|(
name|VIA_PCI_DMA_MAR0
operator|+
name|engine
operator|*
literal|0x10
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|VIA_WRITE
argument_list|(
name|VIA_PCI_DMA_DAR0
operator|+
name|engine
operator|*
literal|0x10
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|VIA_WRITE
argument_list|(
name|VIA_PCI_DMA_CSR0
operator|+
name|engine
operator|*
literal|0x04
argument_list|,
name|VIA_DMA_CSR_DD
operator||
name|VIA_DMA_CSR_TD
operator||
name|VIA_DMA_CSR_DE
argument_list|)
expr_stmt|;
name|VIA_WRITE
argument_list|(
name|VIA_PCI_DMA_MR0
operator|+
name|engine
operator|*
literal|0x04
argument_list|,
name|VIA_DMA_MR_CM
operator||
name|VIA_DMA_MR_TDIE
argument_list|)
expr_stmt|;
name|VIA_WRITE
argument_list|(
name|VIA_PCI_DMA_BCR0
operator|+
name|engine
operator|*
literal|0x10
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|VIA_WRITE
argument_list|(
name|VIA_PCI_DMA_DPR0
operator|+
name|engine
operator|*
literal|0x10
argument_list|,
name|vsg
operator|->
name|chain_start
argument_list|)
expr_stmt|;
name|DRM_WRITEMEMORYBARRIER
argument_list|()
expr_stmt|;
name|VIA_WRITE
argument_list|(
name|VIA_PCI_DMA_CSR0
operator|+
name|engine
operator|*
literal|0x04
argument_list|,
name|VIA_DMA_CSR_DE
operator||
name|VIA_DMA_CSR_TS
argument_list|)
expr_stmt|;
name|VIA_READ
argument_list|(
name|VIA_PCI_DMA_CSR0
operator|+
name|engine
operator|*
literal|0x04
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Obtain a page pointer array and lock all pages into system memory. A segmentation violation will  * occur here if the calling user does not have access to the submitted address.  */
end_comment

begin_function
specifier|static
name|int
name|via_lock_all_dma_pages
parameter_list|(
name|drm_via_sg_info_t
modifier|*
name|vsg
parameter_list|,
name|drm_via_dmablit_t
modifier|*
name|xfer
parameter_list|)
block|{
name|unsigned
name|long
name|first_pfn
init|=
name|VIA_PFN
argument_list|(
name|xfer
operator|->
name|mem_addr
argument_list|)
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
name|vm_map_t
name|map
decl_stmt|;
name|int
name|i
decl_stmt|;
name|map
operator|=
operator|&
name|curproc
operator|->
name|p_vmspace
operator|->
name|vm_map
expr_stmt|;
name|vsg
operator|->
name|num_pages
operator|=
name|VIA_PFN
argument_list|(
name|xfer
operator|->
name|mem_addr
operator|+
operator|(
name|xfer
operator|->
name|num_lines
operator|*
name|xfer
operator|->
name|mem_stride
operator|-
literal|1
operator|)
argument_list|)
operator|-
name|first_pfn
operator|+
literal|1
expr_stmt|;
comment|/* Make sure that the user has access to these pages */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vsg
operator|->
name|num_pages
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|vm_fault_quick
argument_list|(
operator|(
name|caddr_t
operator|)
name|xfer
operator|->
name|mem_addr
operator|+
name|IDX_TO_OFF
argument_list|(
name|i
argument_list|)
argument_list|,
name|VM_PROT_RW
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
name|EACCES
operator|)
return|;
block|}
if|if
condition|(
name|NULL
operator|==
operator|(
name|vsg
operator|->
name|pages
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|vm_page_t
argument_list|)
operator|*
name|vsg
operator|->
name|num_pages
argument_list|,
name|DRM_MEM_DRIVER
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
operator|)
condition|)
return|return
operator|-
name|ENOMEM
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vsg
operator|->
name|num_pages
condition|;
name|i
operator|++
control|)
block|{
name|m
operator|=
name|pmap_extract_and_hold
argument_list|(
name|map
operator|->
name|pmap
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|xfer
operator|->
name|mem_addr
operator|+
name|IDX_TO_OFF
argument_list|(
name|i
argument_list|)
argument_list|,
name|VM_PROT_RW
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
break|break;
name|vm_page_lock
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|vm_page_lock_queues
argument_list|()
expr_stmt|;
name|vm_page_wire
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|vm_page_unhold
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|vm_page_unlock_queues
argument_list|()
expr_stmt|;
name|vm_page_unlock
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|vsg
operator|->
name|pages
index|[
name|i
index|]
operator|=
name|m
expr_stmt|;
block|}
name|vsg
operator|->
name|state
operator|=
name|dr_via_pages_locked
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|vsg
operator|->
name|num_pages
condition|)
return|return
operator|-
name|EINVAL
return|;
name|DRM_DEBUG
argument_list|(
literal|"DMA pages locked\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate DMA capable memory for the blit descriptor chain, and an array that keeps track of the  * pages we allocate. We don't want to use kmalloc for the descriptor chain because it may be  * quite large for some blits, and pages don't need to be contingous.  */
end_comment

begin_function
specifier|static
name|int
name|via_alloc_desc_pages
parameter_list|(
name|drm_via_sg_info_t
modifier|*
name|vsg
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|vsg
operator|->
name|descriptors_per_page
operator|=
name|PAGE_SIZE
operator|/
sizeof|sizeof
argument_list|(
name|drm_via_descriptor_t
argument_list|)
expr_stmt|;
name|vsg
operator|->
name|num_desc_pages
operator|=
operator|(
name|vsg
operator|->
name|num_desc
operator|+
name|vsg
operator|->
name|descriptors_per_page
operator|-
literal|1
operator|)
operator|/
name|vsg
operator|->
name|descriptors_per_page
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
operator|(
name|vsg
operator|->
name|desc_pages
operator|=
name|malloc
argument_list|(
name|vsg
operator|->
name|num_desc_pages
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|,
name|DRM_MEM_DRIVER
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
operator|)
condition|)
return|return
operator|-
name|ENOMEM
return|;
name|vsg
operator|->
name|state
operator|=
name|dr_via_desc_pages_alloc
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vsg
operator|->
name|num_desc_pages
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|NULL
operator|==
operator|(
name|vsg
operator|->
name|desc_pages
index|[
name|i
index|]
operator|=
operator|(
name|drm_via_descriptor_t
operator|*
operator|)
name|malloc
argument_list|(
name|PAGE_SIZE
argument_list|,
name|DRM_MEM_PAGES
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
operator|)
condition|)
return|return
operator|-
name|ENOMEM
return|;
block|}
name|DRM_DEBUG
argument_list|(
literal|"Allocated %d pages for %d descriptors.\n"
argument_list|,
name|vsg
operator|->
name|num_desc_pages
argument_list|,
name|vsg
operator|->
name|num_desc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|via_abort_dmablit
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|engine
parameter_list|)
block|{
name|drm_via_private_t
modifier|*
name|dev_priv
init|=
operator|(
name|drm_via_private_t
operator|*
operator|)
name|dev
operator|->
name|dev_private
decl_stmt|;
name|VIA_WRITE
argument_list|(
name|VIA_PCI_DMA_CSR0
operator|+
name|engine
operator|*
literal|0x04
argument_list|,
name|VIA_DMA_CSR_TA
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|via_dmablit_engine_off
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|engine
parameter_list|)
block|{
name|drm_via_private_t
modifier|*
name|dev_priv
init|=
operator|(
name|drm_via_private_t
operator|*
operator|)
name|dev
operator|->
name|dev_private
decl_stmt|;
name|VIA_WRITE
argument_list|(
name|VIA_PCI_DMA_CSR0
operator|+
name|engine
operator|*
literal|0x04
argument_list|,
name|VIA_DMA_CSR_TD
operator||
name|VIA_DMA_CSR_DD
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * The dmablit part of the IRQ handler. Trying to do only reasonably fast things here.  * The rest, like unmapping and freeing memory for done blits is done in a separate workqueue  * task. Basically the task of the interrupt handler is to submit a new blit to the engine, while  * the workqueue task takes care of processing associated with the old blit.  */
end_comment

begin_function
name|void
name|via_dmablit_handler
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|engine
parameter_list|,
name|int
name|from_irq
parameter_list|)
block|{
name|drm_via_private_t
modifier|*
name|dev_priv
init|=
operator|(
name|drm_via_private_t
operator|*
operator|)
name|dev
operator|->
name|dev_private
decl_stmt|;
name|drm_via_blitq_t
modifier|*
name|blitq
init|=
name|dev_priv
operator|->
name|blit_queues
operator|+
name|engine
decl_stmt|;
name|int
name|cur
decl_stmt|;
name|int
name|done_transfer
decl_stmt|;
name|uint32_t
name|status
init|=
literal|0
decl_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"DMA blit handler called. engine = %d, from_irq = %d, blitq = 0x%lx\n"
argument_list|,
name|engine
argument_list|,
name|from_irq
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|blitq
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|blitq
operator|->
name|blit_lock
argument_list|)
expr_stmt|;
name|done_transfer
operator|=
name|blitq
operator|->
name|is_active
operator|&&
operator|(
operator|(
name|status
operator|=
name|VIA_READ
argument_list|(
name|VIA_PCI_DMA_CSR0
operator|+
name|engine
operator|*
literal|0x04
argument_list|)
operator|)
operator|&
name|VIA_DMA_CSR_TD
operator|)
expr_stmt|;
name|done_transfer
operator|=
name|done_transfer
operator|||
operator|(
name|blitq
operator|->
name|aborting
operator|&&
operator|!
operator|(
name|status
operator|&
name|VIA_DMA_CSR_DE
operator|)
operator|)
expr_stmt|;
name|cur
operator|=
name|blitq
operator|->
name|cur
expr_stmt|;
if|if
condition|(
name|done_transfer
condition|)
block|{
name|blitq
operator|->
name|blits
index|[
name|cur
index|]
operator|->
name|aborted
operator|=
name|blitq
operator|->
name|aborting
expr_stmt|;
name|blitq
operator|->
name|done_blit_handle
operator|++
expr_stmt|;
name|DRM_WAKEUP
argument_list|(
operator|&
name|blitq
operator|->
name|blit_queue
index|[
name|cur
index|]
argument_list|)
expr_stmt|;
name|cur
operator|++
expr_stmt|;
if|if
condition|(
name|cur
operator|>=
name|VIA_NUM_BLIT_SLOTS
condition|)
name|cur
operator|=
literal|0
expr_stmt|;
name|blitq
operator|->
name|cur
operator|=
name|cur
expr_stmt|;
comment|/* 		 * Clear transfer done flag. 		 */
name|VIA_WRITE
argument_list|(
name|VIA_PCI_DMA_CSR0
operator|+
name|engine
operator|*
literal|0x04
argument_list|,
name|VIA_DMA_CSR_TD
argument_list|)
expr_stmt|;
name|blitq
operator|->
name|is_active
operator|=
literal|0
expr_stmt|;
name|blitq
operator|->
name|aborting
operator|=
literal|0
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|taskqueue_swi
argument_list|,
operator|&
name|blitq
operator|->
name|wq
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|blitq
operator|->
name|is_active
operator|&&
operator|(
name|ticks
operator|>=
name|blitq
operator|->
name|end
operator|)
condition|)
block|{
comment|/* 		 * Abort transfer after one second. 		 */
name|via_abort_dmablit
argument_list|(
name|dev
argument_list|,
name|engine
argument_list|)
expr_stmt|;
name|blitq
operator|->
name|aborting
operator|=
literal|1
expr_stmt|;
name|blitq
operator|->
name|end
operator|=
name|ticks
operator|+
name|DRM_HZ
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|blitq
operator|->
name|is_active
condition|)
block|{
if|if
condition|(
name|blitq
operator|->
name|num_outstanding
condition|)
block|{
name|via_fire_dmablit
argument_list|(
name|dev
argument_list|,
name|blitq
operator|->
name|blits
index|[
name|cur
index|]
argument_list|,
name|engine
argument_list|)
expr_stmt|;
name|blitq
operator|->
name|is_active
operator|=
literal|1
expr_stmt|;
name|blitq
operator|->
name|cur
operator|=
name|cur
expr_stmt|;
name|blitq
operator|->
name|num_outstanding
operator|--
expr_stmt|;
name|blitq
operator|->
name|end
operator|=
name|ticks
operator|+
name|DRM_HZ
expr_stmt|;
if|if
condition|(
operator|!
name|callout_pending
argument_list|(
operator|&
name|blitq
operator|->
name|poll_timer
argument_list|)
condition|)
name|callout_reset
argument_list|(
operator|&
name|blitq
operator|->
name|poll_timer
argument_list|,
literal|1
argument_list|,
operator|(
name|timeout_t
operator|*
operator|)
name|via_dmablit_timer
argument_list|,
operator|(
name|void
operator|*
operator|)
name|blitq
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|callout_pending
argument_list|(
operator|&
name|blitq
operator|->
name|poll_timer
argument_list|)
condition|)
block|{
name|callout_stop
argument_list|(
operator|&
name|blitq
operator|->
name|poll_timer
argument_list|)
expr_stmt|;
block|}
name|via_dmablit_engine_off
argument_list|(
name|dev
argument_list|,
name|engine
argument_list|)
expr_stmt|;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|blitq
operator|->
name|blit_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Check whether this blit is still active, performing necessary locking.  */
end_comment

begin_function
specifier|static
name|int
name|via_dmablit_active
parameter_list|(
name|drm_via_blitq_t
modifier|*
name|blitq
parameter_list|,
name|int
name|engine
parameter_list|,
name|uint32_t
name|handle
parameter_list|,
name|wait_queue_head_t
modifier|*
modifier|*
name|queue
parameter_list|)
block|{
name|uint32_t
name|slot
decl_stmt|;
name|int
name|active
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|blitq
operator|->
name|blit_lock
argument_list|)
expr_stmt|;
comment|/* 	 * Allow for handle wraparounds. 	 */
name|active
operator|=
operator|(
operator|(
name|blitq
operator|->
name|done_blit_handle
operator|-
name|handle
operator|)
operator|>
operator|(
literal|1
operator|<<
literal|23
operator|)
operator|)
operator|&&
operator|(
operator|(
name|blitq
operator|->
name|cur_blit_handle
operator|-
name|handle
operator|)
operator|<=
operator|(
literal|1
operator|<<
literal|23
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|queue
operator|&&
name|active
condition|)
block|{
name|slot
operator|=
name|handle
operator|-
name|blitq
operator|->
name|done_blit_handle
operator|+
name|blitq
operator|->
name|cur
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|slot
operator|>=
name|VIA_NUM_BLIT_SLOTS
condition|)
block|{
name|slot
operator|-=
name|VIA_NUM_BLIT_SLOTS
expr_stmt|;
block|}
operator|*
name|queue
operator|=
name|blitq
operator|->
name|blit_queue
operator|+
name|slot
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|blitq
operator|->
name|blit_lock
argument_list|)
expr_stmt|;
return|return
name|active
return|;
block|}
end_function

begin_comment
comment|/*  * Sync. Wait for at least three seconds for the blit to be performed.  */
end_comment

begin_function
specifier|static
name|int
name|via_dmablit_sync
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|uint32_t
name|handle
parameter_list|,
name|int
name|engine
parameter_list|)
block|{
name|drm_via_private_t
modifier|*
name|dev_priv
init|=
operator|(
name|drm_via_private_t
operator|*
operator|)
name|dev
operator|->
name|dev_private
decl_stmt|;
name|drm_via_blitq_t
modifier|*
name|blitq
init|=
name|dev_priv
operator|->
name|blit_queues
operator|+
name|engine
decl_stmt|;
name|wait_queue_head_t
modifier|*
name|queue
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|via_dmablit_active
argument_list|(
name|blitq
argument_list|,
name|engine
argument_list|,
name|handle
argument_list|,
operator|&
name|queue
argument_list|)
condition|)
block|{
name|DRM_WAIT_ON
argument_list|(
name|ret
argument_list|,
operator|*
name|queue
argument_list|,
literal|3
operator|*
name|DRM_HZ
argument_list|,
operator|!
name|via_dmablit_active
argument_list|(
name|blitq
argument_list|,
name|engine
argument_list|,
name|handle
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|DRM_DEBUG
argument_list|(
literal|"DMA blit sync handle 0x%x engine %d returned %d\n"
argument_list|,
name|handle
argument_list|,
name|engine
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * A timer that regularly polls the blit engine in cases where we don't have interrupts:  * a) Broken hardware (typically those that don't have any video capture facility).  * b) Blit abort. The hardware doesn't send an interrupt when a blit is aborted.  * The timer and hardware IRQ's can and do work in parallel. If the hardware has  * irqs, it will shorten the latency somewhat.  */
end_comment

begin_function
specifier|static
name|void
name|via_dmablit_timer
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|drm_via_blitq_t
modifier|*
name|blitq
init|=
operator|(
name|drm_via_blitq_t
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|blitq
operator|->
name|dev
decl_stmt|;
name|int
name|engine
init|=
call|(
name|int
call|)
argument_list|(
name|blitq
operator|-
operator|(
operator|(
name|drm_via_private_t
operator|*
operator|)
name|dev
operator|->
name|dev_private
operator|)
operator|->
name|blit_queues
argument_list|)
decl_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"Polling timer called for engine %d, jiffies %lu\n"
argument_list|,
name|engine
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|jiffies
argument_list|)
expr_stmt|;
name|via_dmablit_handler
argument_list|(
name|dev
argument_list|,
name|engine
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|callout_pending
argument_list|(
operator|&
name|blitq
operator|->
name|poll_timer
argument_list|)
condition|)
block|{
name|callout_schedule
argument_list|(
operator|&
name|blitq
operator|->
name|poll_timer
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 		* Rerun handler to delete timer if engines are off, and 		* to shorten abort latency. This is a little nasty. 		*/
name|via_dmablit_handler
argument_list|(
name|dev
argument_list|,
name|engine
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Workqueue task that frees data and mappings associated with a blit.  * Also wakes up waiting processes. Each of these tasks handles one  * blit engine only and may not be called on each interrupt.  */
end_comment

begin_function
specifier|static
name|void
name|via_dmablit_workqueue
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|drm_via_blitq_t
modifier|*
name|blitq
init|=
operator|(
name|drm_via_blitq_t
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|blitq
operator|->
name|dev
decl_stmt|;
name|drm_via_sg_info_t
modifier|*
name|cur_sg
decl_stmt|;
name|int
name|cur_released
decl_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"task called for blit engine %ld\n"
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|blitq
operator|-
operator|(
operator|(
name|drm_via_private_t
operator|*
operator|)
name|dev
operator|->
name|dev_private
operator|)
operator|->
name|blit_queues
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|blitq
operator|->
name|blit_lock
argument_list|)
expr_stmt|;
while|while
condition|(
name|blitq
operator|->
name|serviced
operator|!=
name|blitq
operator|->
name|cur
condition|)
block|{
name|cur_released
operator|=
name|blitq
operator|->
name|serviced
operator|++
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"Releasing blit slot %d\n"
argument_list|,
name|cur_released
argument_list|)
expr_stmt|;
if|if
condition|(
name|blitq
operator|->
name|serviced
operator|>=
name|VIA_NUM_BLIT_SLOTS
condition|)
name|blitq
operator|->
name|serviced
operator|=
literal|0
expr_stmt|;
name|cur_sg
operator|=
name|blitq
operator|->
name|blits
index|[
name|cur_released
index|]
expr_stmt|;
name|blitq
operator|->
name|num_free
operator|++
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|blitq
operator|->
name|blit_lock
argument_list|)
expr_stmt|;
name|DRM_WAKEUP
argument_list|(
operator|&
name|blitq
operator|->
name|busy_queue
argument_list|)
expr_stmt|;
name|via_free_sg_info
argument_list|(
name|cur_sg
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cur_sg
argument_list|,
name|DRM_MEM_DRIVER
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|blitq
operator|->
name|blit_lock
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|blitq
operator|->
name|blit_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Init all blit engines. Currently we use two, but some hardware have 4.  */
end_comment

begin_function
name|void
name|via_init_dmablit
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|drm_via_private_t
modifier|*
name|dev_priv
init|=
operator|(
name|drm_via_private_t
operator|*
operator|)
name|dev
operator|->
name|dev_private
decl_stmt|;
name|drm_via_blitq_t
modifier|*
name|blitq
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|VIA_NUM_BLIT_ENGINES
condition|;
operator|++
name|i
control|)
block|{
name|blitq
operator|=
name|dev_priv
operator|->
name|blit_queues
operator|+
name|i
expr_stmt|;
name|blitq
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|blitq
operator|->
name|cur_blit_handle
operator|=
literal|0
expr_stmt|;
name|blitq
operator|->
name|done_blit_handle
operator|=
literal|0
expr_stmt|;
name|blitq
operator|->
name|head
operator|=
literal|0
expr_stmt|;
name|blitq
operator|->
name|cur
operator|=
literal|0
expr_stmt|;
name|blitq
operator|->
name|serviced
operator|=
literal|0
expr_stmt|;
name|blitq
operator|->
name|num_free
operator|=
name|VIA_NUM_BLIT_SLOTS
operator|-
literal|1
expr_stmt|;
name|blitq
operator|->
name|num_outstanding
operator|=
literal|0
expr_stmt|;
name|blitq
operator|->
name|is_active
operator|=
literal|0
expr_stmt|;
name|blitq
operator|->
name|aborting
operator|=
literal|0
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|blitq
operator|->
name|blit_lock
argument_list|,
literal|"via_blit_lk"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|VIA_NUM_BLIT_SLOTS
condition|;
operator|++
name|j
control|)
block|{
name|DRM_INIT_WAITQUEUE
argument_list|(
name|blitq
operator|->
name|blit_queue
operator|+
name|j
argument_list|)
expr_stmt|;
block|}
name|DRM_INIT_WAITQUEUE
argument_list|(
operator|&
name|blitq
operator|->
name|busy_queue
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|blitq
operator|->
name|wq
argument_list|,
literal|0
argument_list|,
name|via_dmablit_workqueue
argument_list|,
name|blitq
argument_list|)
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|blitq
operator|->
name|poll_timer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Build all info and do all mappings required for a blit.  */
end_comment

begin_function
specifier|static
name|int
name|via_build_sg_info
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|drm_via_sg_info_t
modifier|*
name|vsg
parameter_list|,
name|drm_via_dmablit_t
modifier|*
name|xfer
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|vsg
operator|->
name|bounce_buffer
operator|=
name|NULL
expr_stmt|;
name|vsg
operator|->
name|state
operator|=
name|dr_via_sg_init
expr_stmt|;
if|if
condition|(
name|xfer
operator|->
name|num_lines
operator|<=
literal|0
operator|||
name|xfer
operator|->
name|line_length
operator|<=
literal|0
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Zero size bitblt.\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
comment|/* 	 * Below check is a driver limitation, not a hardware one. We 	 * don't want to lock unused pages, and don't want to incoporate the 	 * extra logic of avoiding them. Make sure there are no. 	 * (Not a big limitation anyway.) 	 */
if|if
condition|(
operator|(
name|xfer
operator|->
name|mem_stride
operator|-
name|xfer
operator|->
name|line_length
operator|)
operator|>
literal|2
operator|*
name|PAGE_SIZE
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Too large system memory stride. Stride: %d, "
literal|"Length: %d\n"
argument_list|,
name|xfer
operator|->
name|mem_stride
argument_list|,
name|xfer
operator|->
name|line_length
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
if|if
condition|(
operator|(
name|xfer
operator|->
name|mem_stride
operator|==
name|xfer
operator|->
name|line_length
operator|)
operator|&&
operator|(
name|xfer
operator|->
name|fb_stride
operator|==
name|xfer
operator|->
name|line_length
operator|)
condition|)
block|{
name|xfer
operator|->
name|mem_stride
operator|*=
name|xfer
operator|->
name|num_lines
expr_stmt|;
name|xfer
operator|->
name|line_length
operator|=
name|xfer
operator|->
name|mem_stride
expr_stmt|;
name|xfer
operator|->
name|fb_stride
operator|=
name|xfer
operator|->
name|mem_stride
expr_stmt|;
name|xfer
operator|->
name|num_lines
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 	 * Don't lock an arbitrary large number of pages, since that causes a 	 * DOS security hole. 	 */
if|if
condition|(
name|xfer
operator|->
name|num_lines
operator|>
literal|2048
operator|||
operator|(
name|xfer
operator|->
name|num_lines
operator|*
name|xfer
operator|->
name|mem_stride
operator|>
operator|(
literal|2048
operator|*
literal|2048
operator|*
literal|4
operator|)
operator|)
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Too large PCI DMA bitblt.\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
comment|/* 	 * we allow a negative fb stride to allow flipping of images in 	 * transfer. 	 */
if|if
condition|(
name|xfer
operator|->
name|mem_stride
operator|<
name|xfer
operator|->
name|line_length
operator|||
name|abs
argument_list|(
name|xfer
operator|->
name|fb_stride
argument_list|)
operator|<
name|xfer
operator|->
name|line_length
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Invalid frame-buffer / memory stride.\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
comment|/* 	 * A hardware bug seems to be worked around if system memory addresses 	 * start on 16 byte boundaries. This seems a bit restrictive however. 	 * VIA is contacted about this. Meanwhile, impose the following 	 * restrictions: 	 */
ifdef|#
directive|ifdef
name|VIA_BUGFREE
if|if
condition|(
operator|(
operator|(
operator|(
name|unsigned
name|long
operator|)
name|xfer
operator|->
name|mem_addr
operator|&
literal|3
operator|)
operator|!=
operator|(
operator|(
name|unsigned
name|long
operator|)
name|xfer
operator|->
name|fb_addr
operator|&
literal|3
operator|)
operator|)
operator|||
operator|(
operator|(
name|xfer
operator|->
name|num_lines
operator|>
literal|1
operator|)
operator|&&
operator|(
operator|(
name|xfer
operator|->
name|mem_stride
operator|&
literal|3
operator|)
operator|!=
operator|(
name|xfer
operator|->
name|fb_stride
operator|&
literal|3
operator|)
operator|)
operator|)
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Invalid DRM bitblt alignment.\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
else|#
directive|else
if|if
condition|(
operator|(
operator|(
operator|(
name|unsigned
name|long
operator|)
name|xfer
operator|->
name|mem_addr
operator|&
literal|15
operator|)
operator|||
operator|(
operator|(
name|unsigned
name|long
operator|)
name|xfer
operator|->
name|fb_addr
operator|&
literal|3
operator|)
operator|)
operator|||
operator|(
operator|(
name|xfer
operator|->
name|num_lines
operator|>
literal|1
operator|)
operator|&&
operator|(
operator|(
name|xfer
operator|->
name|mem_stride
operator|&
literal|15
operator|)
operator|||
operator|(
name|xfer
operator|->
name|fb_stride
operator|&
literal|3
operator|)
operator|)
operator|)
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Invalid DRM bitblt alignment.\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
endif|#
directive|endif
if|if
condition|(
literal|0
operator|!=
operator|(
name|ret
operator|=
name|via_lock_all_dma_pages
argument_list|(
name|vsg
argument_list|,
name|xfer
argument_list|)
operator|)
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Could not lock DMA pages.\n"
argument_list|)
expr_stmt|;
name|via_free_sg_info
argument_list|(
name|vsg
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|via_map_blit_for_device
argument_list|(
name|xfer
argument_list|,
name|vsg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|!=
operator|(
name|ret
operator|=
name|via_alloc_desc_pages
argument_list|(
name|vsg
argument_list|)
operator|)
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Could not allocate DMA descriptor pages.\n"
argument_list|)
expr_stmt|;
name|via_free_sg_info
argument_list|(
name|vsg
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|via_map_blit_for_device
argument_list|(
name|xfer
argument_list|,
name|vsg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Reserve one free slot in the blit queue. Will wait for one second for one  * to become available. Otherwise -EBUSY is returned.  */
end_comment

begin_function
specifier|static
name|int
name|via_dmablit_grab_slot
parameter_list|(
name|drm_via_blitq_t
modifier|*
name|blitq
parameter_list|,
name|int
name|engine
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|blitq
operator|->
name|dev
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"Num free is %d\n"
argument_list|,
name|blitq
operator|->
name|num_free
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|blitq
operator|->
name|blit_lock
argument_list|)
expr_stmt|;
while|while
condition|(
name|blitq
operator|->
name|num_free
operator|==
literal|0
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|blitq
operator|->
name|blit_lock
argument_list|)
expr_stmt|;
name|DRM_WAIT_ON
argument_list|(
name|ret
argument_list|,
name|blitq
operator|->
name|busy_queue
argument_list|,
name|DRM_HZ
argument_list|,
name|blitq
operator|->
name|num_free
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
return|return
operator|(
operator|-
name|EINTR
operator|==
name|ret
operator|)
condition|?
operator|-
name|EAGAIN
else|:
name|ret
return|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|blitq
operator|->
name|blit_lock
argument_list|)
expr_stmt|;
block|}
name|blitq
operator|->
name|num_free
operator|--
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|blitq
operator|->
name|blit_lock
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Hand back a free slot if we changed our mind.  */
end_comment

begin_function
specifier|static
name|void
name|via_dmablit_release_slot
parameter_list|(
name|drm_via_blitq_t
modifier|*
name|blitq
parameter_list|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|blitq
operator|->
name|blit_lock
argument_list|)
expr_stmt|;
name|blitq
operator|->
name|num_free
operator|++
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|blitq
operator|->
name|blit_lock
argument_list|)
expr_stmt|;
name|DRM_WAKEUP
argument_list|(
operator|&
name|blitq
operator|->
name|busy_queue
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Grab a free slot. Build blit info and queue a blit.  */
end_comment

begin_function
specifier|static
name|int
name|via_dmablit
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|drm_via_dmablit_t
modifier|*
name|xfer
parameter_list|)
block|{
name|drm_via_private_t
modifier|*
name|dev_priv
init|=
operator|(
name|drm_via_private_t
operator|*
operator|)
name|dev
operator|->
name|dev_private
decl_stmt|;
name|drm_via_sg_info_t
modifier|*
name|vsg
decl_stmt|;
name|drm_via_blitq_t
modifier|*
name|blitq
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|int
name|engine
decl_stmt|;
if|if
condition|(
name|dev_priv
operator|==
name|NULL
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Called without initialization.\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|engine
operator|=
operator|(
name|xfer
operator|->
name|to_fb
operator|)
condition|?
literal|0
else|:
literal|1
expr_stmt|;
name|blitq
operator|=
name|dev_priv
operator|->
name|blit_queues
operator|+
name|engine
expr_stmt|;
if|if
condition|(
literal|0
operator|!=
operator|(
name|ret
operator|=
name|via_dmablit_grab_slot
argument_list|(
name|blitq
argument_list|,
name|engine
argument_list|)
operator|)
condition|)
block|{
return|return
name|ret
return|;
block|}
if|if
condition|(
name|NULL
operator|==
operator|(
name|vsg
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|vsg
argument_list|)
argument_list|,
name|DRM_MEM_DRIVER
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
operator|)
condition|)
block|{
name|via_dmablit_release_slot
argument_list|(
name|blitq
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
block|}
if|if
condition|(
literal|0
operator|!=
operator|(
name|ret
operator|=
name|via_build_sg_info
argument_list|(
name|dev
argument_list|,
name|vsg
argument_list|,
name|xfer
argument_list|)
operator|)
condition|)
block|{
name|via_dmablit_release_slot
argument_list|(
name|blitq
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|vsg
argument_list|,
name|DRM_MEM_DRIVER
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|blitq
operator|->
name|blit_lock
argument_list|)
expr_stmt|;
name|blitq
operator|->
name|blits
index|[
name|blitq
operator|->
name|head
operator|++
index|]
operator|=
name|vsg
expr_stmt|;
if|if
condition|(
name|blitq
operator|->
name|head
operator|>=
name|VIA_NUM_BLIT_SLOTS
condition|)
name|blitq
operator|->
name|head
operator|=
literal|0
expr_stmt|;
name|blitq
operator|->
name|num_outstanding
operator|++
expr_stmt|;
name|xfer
operator|->
name|sync
operator|.
name|sync_handle
operator|=
operator|++
name|blitq
operator|->
name|cur_blit_handle
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|blitq
operator|->
name|blit_lock
argument_list|)
expr_stmt|;
name|xfer
operator|->
name|sync
operator|.
name|engine
operator|=
name|engine
expr_stmt|;
name|via_dmablit_handler
argument_list|(
name|dev
argument_list|,
name|engine
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Sync on a previously submitted blit. Note that the X server use signals  * extensively, and that there is a very big probability that this IOCTL will  * be interrupted by a signal. In that case it returns with -EAGAIN for the  * signal to be delivered. The caller should then reissue the IOCTL. This is  * similar to what is being done for drmGetLock().  */
end_comment

begin_function
name|int
name|via_dma_blit_sync
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
name|drm_via_blitsync_t
modifier|*
name|sync
init|=
name|data
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
name|sync
operator|->
name|engine
operator|>=
name|VIA_NUM_BLIT_ENGINES
condition|)
return|return
operator|-
name|EINVAL
return|;
name|err
operator|=
name|via_dmablit_sync
argument_list|(
name|dev
argument_list|,
name|sync
operator|->
name|sync_handle
argument_list|,
name|sync
operator|->
name|engine
argument_list|)
expr_stmt|;
if|if
condition|(
operator|-
name|EINTR
operator|==
name|err
condition|)
name|err
operator|=
operator|-
name|EAGAIN
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_comment
comment|/*  * Queue a blit and hand back a handle to be used for sync. This IOCTL may be  * interrupted by a signal while waiting for a free slot in the blit queue.  * In that case it returns with -EAGAIN and should be reissued. See the above  * IOCTL code.  */
end_comment

begin_function
name|int
name|via_dma_blit
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
name|drm_via_dmablit_t
modifier|*
name|xfer
init|=
name|data
decl_stmt|;
name|int
name|err
decl_stmt|;
name|err
operator|=
name|via_dmablit
argument_list|(
name|dev
argument_list|,
name|xfer
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

end_unit

