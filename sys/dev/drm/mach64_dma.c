begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* mach64_dma.c -- DMA support for mach64 (Rage Pro) driver -*- linux-c -*- */
end_comment

begin_comment
comment|/**  * \file mach64_dma.c  * DMA support for mach64 (Rage Pro) driver  *  * \author Gareth Hughes<gareth@valinux.com>  * \author Frank C. Earl<fearl@airmail.net>  * \author Leif Delgass<ldelgass@retinalburn.net>  * \author JosÃ© Fonseca<j_r_fonseca@yahoo.co.uk>  */
end_comment

begin_comment
comment|/*-  * Copyright 2000 Gareth Hughes  * Copyright 2002 Frank C. Earl  * Copyright 2002-2003 Leif Delgass  * All Rights Reserved.  *  * Permission is hereby granted, free of charge, to any person obtaining a  * copy of this software and associated documentation files (the "Software"),  * to deal in the Software without restriction, including without limitation  * the rights to use, copy, modify, merge, publish, distribute, sublicense,  * and/or sell copies of the Software, and to permit persons to whom the  * Software is furnished to do so, subject to the following conditions:  *  * The above copyright notice and this permission notice (including the next  * paragraph) shall be included in all copies or substantial portions of the  * Software.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL  * THE COPYRIGHT OWNER(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER  * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"dev/drm/drmP.h"
end_include

begin_include
include|#
directive|include
file|"dev/drm/drm.h"
end_include

begin_include
include|#
directive|include
file|"dev/drm/mach64_drm.h"
end_include

begin_include
include|#
directive|include
file|"dev/drm/mach64_drv.h"
end_include

begin_comment
comment|/*******************************************************************/
end_comment

begin_comment
comment|/** \name Engine, FIFO control */
end_comment

begin_comment
comment|/*@{*/
end_comment

begin_comment
comment|/**  * Waits for free entries in the FIFO.  *  * \note Most writes to Mach64 registers are automatically routed through  * command FIFO which is 16 entry deep. Prior to writing to any draw engine  * register one has to ensure that enough FIFO entries are available by calling  * this function.  Failure to do so may cause the engine to lock.  *  * \param dev_priv pointer to device private data structure.  * \param entries number of free entries in the FIFO to wait for.  *  * \returns zero on success, or -EBUSY if the timeout (specificed by  * drm_mach64_private::usec_timeout) occurs.  */
end_comment

begin_function
name|int
name|mach64_do_wait_for_fifo
parameter_list|(
name|drm_mach64_private_t
modifier|*
name|dev_priv
parameter_list|,
name|int
name|entries
parameter_list|)
block|{
name|int
name|slots
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dev_priv
operator|->
name|usec_timeout
condition|;
name|i
operator|++
control|)
block|{
name|slots
operator|=
operator|(
name|MACH64_READ
argument_list|(
name|MACH64_FIFO_STAT
argument_list|)
operator|&
name|MACH64_FIFO_SLOT_MASK
operator|)
expr_stmt|;
if|if
condition|(
name|slots
operator|<=
operator|(
literal|0x8000
operator|>>
name|entries
operator|)
condition|)
return|return
literal|0
return|;
name|DRM_UDELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|DRM_INFO
argument_list|(
literal|"failed! slots=%d entries=%d\n"
argument_list|,
name|slots
argument_list|,
name|entries
argument_list|)
expr_stmt|;
return|return
operator|-
name|EBUSY
return|;
block|}
end_function

begin_comment
comment|/**  * Wait for the draw engine to be idle.  */
end_comment

begin_function
name|int
name|mach64_do_wait_for_idle
parameter_list|(
name|drm_mach64_private_t
modifier|*
name|dev_priv
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|ret
decl_stmt|;
name|ret
operator|=
name|mach64_do_wait_for_fifo
argument_list|(
name|dev_priv
argument_list|,
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
return|return
name|ret
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dev_priv
operator|->
name|usec_timeout
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|MACH64_READ
argument_list|(
name|MACH64_GUI_STAT
argument_list|)
operator|&
name|MACH64_GUI_ACTIVE
operator|)
condition|)
return|return
literal|0
return|;
name|DRM_UDELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|DRM_INFO
argument_list|(
literal|"failed! GUI_STAT=0x%08x\n"
argument_list|,
name|MACH64_READ
argument_list|(
name|MACH64_GUI_STAT
argument_list|)
argument_list|)
expr_stmt|;
name|mach64_dump_ring_info
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
return|return
operator|-
name|EBUSY
return|;
block|}
end_function

begin_comment
comment|/**  * Wait for free entries in the ring buffer.  *  * The Mach64 bus master can be configured to act as a virtual FIFO, using a  * circular buffer (commonly referred as "ring buffer" in other drivers) with  * pointers to engine commands. This allows the CPU to do other things while  * the graphics engine is busy, i.e., DMA mode.  *  * This function should be called before writing new entries to the ring  * buffer.  *  * \param dev_priv pointer to device private data structure.  * \param n number of free entries in the ring buffer to wait for.  *  * \returns zero on success, or -EBUSY if the timeout (specificed by  * drm_mach64_private_t::usec_timeout) occurs.  *  * \sa mach64_dump_ring_info()  */
end_comment

begin_function
name|int
name|mach64_wait_ring
parameter_list|(
name|drm_mach64_private_t
modifier|*
name|dev_priv
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|drm_mach64_descriptor_ring_t
modifier|*
name|ring
init|=
operator|&
name|dev_priv
operator|->
name|ring
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dev_priv
operator|->
name|usec_timeout
condition|;
name|i
operator|++
control|)
block|{
name|mach64_update_ring_snapshot
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
if|if
condition|(
name|ring
operator|->
name|space
operator|>=
name|n
condition|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|DRM_DEBUG
argument_list|(
literal|"%d usecs\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|DRM_UDELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* FIXME: This is being ignored... */
name|DRM_ERROR
argument_list|(
literal|"failed!\n"
argument_list|)
expr_stmt|;
name|mach64_dump_ring_info
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
return|return
operator|-
name|EBUSY
return|;
block|}
end_function

begin_comment
comment|/**  * Wait until all DMA requests have been processed...  *  * \sa mach64_wait_ring()  */
end_comment

begin_function
specifier|static
name|int
name|mach64_ring_idle
parameter_list|(
name|drm_mach64_private_t
modifier|*
name|dev_priv
parameter_list|)
block|{
name|drm_mach64_descriptor_ring_t
modifier|*
name|ring
init|=
operator|&
name|dev_priv
operator|->
name|ring
decl_stmt|;
name|u32
name|head
decl_stmt|;
name|int
name|i
decl_stmt|;
name|head
operator|=
name|ring
operator|->
name|head
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|dev_priv
operator|->
name|usec_timeout
condition|)
block|{
name|mach64_update_ring_snapshot
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
if|if
condition|(
name|ring
operator|->
name|head
operator|==
name|ring
operator|->
name|tail
operator|&&
operator|!
operator|(
name|MACH64_READ
argument_list|(
name|MACH64_GUI_STAT
argument_list|)
operator|&
name|MACH64_GUI_ACTIVE
operator|)
condition|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|DRM_DEBUG
argument_list|(
literal|"%d usecs\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|ring
operator|->
name|head
operator|==
name|head
condition|)
block|{
operator|++
name|i
expr_stmt|;
block|}
else|else
block|{
name|head
operator|=
name|ring
operator|->
name|head
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
block|}
name|DRM_UDELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|DRM_INFO
argument_list|(
literal|"failed! GUI_STAT=0x%08x\n"
argument_list|,
name|MACH64_READ
argument_list|(
name|MACH64_GUI_STAT
argument_list|)
argument_list|)
expr_stmt|;
name|mach64_dump_ring_info
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
return|return
operator|-
name|EBUSY
return|;
block|}
end_function

begin_comment
comment|/**  * Reset the ring buffer descriptors.  *  * \sa mach64_do_engine_reset()  */
end_comment

begin_function
specifier|static
name|void
name|mach64_ring_reset
parameter_list|(
name|drm_mach64_private_t
modifier|*
name|dev_priv
parameter_list|)
block|{
name|drm_mach64_descriptor_ring_t
modifier|*
name|ring
init|=
operator|&
name|dev_priv
operator|->
name|ring
decl_stmt|;
name|mach64_do_release_used_buffers
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
name|ring
operator|->
name|head_addr
operator|=
name|ring
operator|->
name|start_addr
expr_stmt|;
name|ring
operator|->
name|head
operator|=
name|ring
operator|->
name|tail
operator|=
literal|0
expr_stmt|;
name|ring
operator|->
name|space
operator|=
name|ring
operator|->
name|size
expr_stmt|;
name|MACH64_WRITE
argument_list|(
name|MACH64_BM_GUI_TABLE_CMD
argument_list|,
name|ring
operator|->
name|head_addr
operator||
name|MACH64_CIRCULAR_BUF_SIZE_16KB
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|ring_running
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Ensure the all the queued commands will be processed.  */
end_comment

begin_function
name|int
name|mach64_do_dma_flush
parameter_list|(
name|drm_mach64_private_t
modifier|*
name|dev_priv
parameter_list|)
block|{
comment|/* FIXME: It's not necessary to wait for idle when flushing 	 * we just need to ensure the ring will be completely processed 	 * in finite time without another ioctl 	 */
return|return
name|mach64_ring_idle
argument_list|(
name|dev_priv
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * Stop all DMA activity.  */
end_comment

begin_function
name|int
name|mach64_do_dma_idle
parameter_list|(
name|drm_mach64_private_t
modifier|*
name|dev_priv
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
comment|/* wait for completion */
if|if
condition|(
operator|(
name|ret
operator|=
name|mach64_ring_idle
argument_list|(
name|dev_priv
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"failed BM_GUI_TABLE=0x%08x tail: %u\n"
argument_list|,
name|MACH64_READ
argument_list|(
name|MACH64_BM_GUI_TABLE
argument_list|)
argument_list|,
name|dev_priv
operator|->
name|ring
operator|.
name|tail
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|mach64_ring_stop
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
comment|/* clean up after pass */
name|mach64_do_release_used_buffers
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Reset the engine.  This will stop the DMA if it is running.  */
end_comment

begin_function
name|int
name|mach64_do_engine_reset
parameter_list|(
name|drm_mach64_private_t
modifier|*
name|dev_priv
parameter_list|)
block|{
name|u32
name|tmp
decl_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* Kill off any outstanding DMA transfers. 	 */
name|tmp
operator|=
name|MACH64_READ
argument_list|(
name|MACH64_BUS_CNTL
argument_list|)
expr_stmt|;
name|MACH64_WRITE
argument_list|(
name|MACH64_BUS_CNTL
argument_list|,
name|tmp
operator||
name|MACH64_BUS_MASTER_DIS
argument_list|)
expr_stmt|;
comment|/* Reset the GUI engine (high to low transition). 	 */
name|tmp
operator|=
name|MACH64_READ
argument_list|(
name|MACH64_GEN_TEST_CNTL
argument_list|)
expr_stmt|;
name|MACH64_WRITE
argument_list|(
name|MACH64_GEN_TEST_CNTL
argument_list|,
name|tmp
operator|&
operator|~
name|MACH64_GUI_ENGINE_ENABLE
argument_list|)
expr_stmt|;
comment|/* Enable the GUI engine 	 */
name|tmp
operator|=
name|MACH64_READ
argument_list|(
name|MACH64_GEN_TEST_CNTL
argument_list|)
expr_stmt|;
name|MACH64_WRITE
argument_list|(
name|MACH64_GEN_TEST_CNTL
argument_list|,
name|tmp
operator||
name|MACH64_GUI_ENGINE_ENABLE
argument_list|)
expr_stmt|;
comment|/* ensure engine is not locked up by clearing any FIFO or HOST errors 	 */
name|tmp
operator|=
name|MACH64_READ
argument_list|(
name|MACH64_BUS_CNTL
argument_list|)
expr_stmt|;
name|MACH64_WRITE
argument_list|(
name|MACH64_BUS_CNTL
argument_list|,
name|tmp
operator||
literal|0x00a00000
argument_list|)
expr_stmt|;
comment|/* Once GUI engine is restored, disable bus mastering */
name|MACH64_WRITE
argument_list|(
name|MACH64_SRC_CNTL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Reset descriptor ring */
name|mach64_ring_reset
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*@}*/
end_comment

begin_comment
comment|/*******************************************************************/
end_comment

begin_comment
comment|/** \name Debugging output */
end_comment

begin_comment
comment|/*@{*/
end_comment

begin_comment
comment|/**  * Dump engine registers values.  */
end_comment

begin_function
name|void
name|mach64_dump_engine_info
parameter_list|(
name|drm_mach64_private_t
modifier|*
name|dev_priv
parameter_list|)
block|{
name|DRM_INFO
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dev_priv
operator|->
name|is_pci
condition|)
block|{
name|DRM_INFO
argument_list|(
literal|"           AGP_BASE = 0x%08x\n"
argument_list|,
name|MACH64_READ
argument_list|(
name|MACH64_AGP_BASE
argument_list|)
argument_list|)
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|"           AGP_CNTL = 0x%08x\n"
argument_list|,
name|MACH64_READ
argument_list|(
name|MACH64_AGP_CNTL
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|DRM_INFO
argument_list|(
literal|"     ALPHA_TST_CNTL = 0x%08x\n"
argument_list|,
name|MACH64_READ
argument_list|(
name|MACH64_ALPHA_TST_CNTL
argument_list|)
argument_list|)
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|"         BM_COMMAND = 0x%08x\n"
argument_list|,
name|MACH64_READ
argument_list|(
name|MACH64_BM_COMMAND
argument_list|)
argument_list|)
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|"BM_FRAME_BUF_OFFSET = 0x%08x\n"
argument_list|,
name|MACH64_READ
argument_list|(
name|MACH64_BM_FRAME_BUF_OFFSET
argument_list|)
argument_list|)
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|"       BM_GUI_TABLE = 0x%08x\n"
argument_list|,
name|MACH64_READ
argument_list|(
name|MACH64_BM_GUI_TABLE
argument_list|)
argument_list|)
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|"          BM_STATUS = 0x%08x\n"
argument_list|,
name|MACH64_READ
argument_list|(
name|MACH64_BM_STATUS
argument_list|)
argument_list|)
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|" BM_SYSTEM_MEM_ADDR = 0x%08x\n"
argument_list|,
name|MACH64_READ
argument_list|(
name|MACH64_BM_SYSTEM_MEM_ADDR
argument_list|)
argument_list|)
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|"    BM_SYSTEM_TABLE = 0x%08x\n"
argument_list|,
name|MACH64_READ
argument_list|(
name|MACH64_BM_SYSTEM_TABLE
argument_list|)
argument_list|)
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|"           BUS_CNTL = 0x%08x\n"
argument_list|,
name|MACH64_READ
argument_list|(
name|MACH64_BUS_CNTL
argument_list|)
argument_list|)
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* DRM_INFO( "         CLOCK_CNTL = 0x%08x\n", MACH64_READ( MACH64_CLOCK_CNTL ) ); */
name|DRM_INFO
argument_list|(
literal|"        CLR_CMP_CLR = 0x%08x\n"
argument_list|,
name|MACH64_READ
argument_list|(
name|MACH64_CLR_CMP_CLR
argument_list|)
argument_list|)
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|"       CLR_CMP_CNTL = 0x%08x\n"
argument_list|,
name|MACH64_READ
argument_list|(
name|MACH64_CLR_CMP_CNTL
argument_list|)
argument_list|)
expr_stmt|;
comment|/* DRM_INFO( "        CLR_CMP_MSK = 0x%08x\n", MACH64_READ( MACH64_CLR_CMP_MSK ) ); */
name|DRM_INFO
argument_list|(
literal|"     CONFIG_CHIP_ID = 0x%08x\n"
argument_list|,
name|MACH64_READ
argument_list|(
name|MACH64_CONFIG_CHIP_ID
argument_list|)
argument_list|)
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|"        CONFIG_CNTL = 0x%08x\n"
argument_list|,
name|MACH64_READ
argument_list|(
name|MACH64_CONFIG_CNTL
argument_list|)
argument_list|)
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|"       CONFIG_STAT0 = 0x%08x\n"
argument_list|,
name|MACH64_READ
argument_list|(
name|MACH64_CONFIG_STAT0
argument_list|)
argument_list|)
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|"       CONFIG_STAT1 = 0x%08x\n"
argument_list|,
name|MACH64_READ
argument_list|(
name|MACH64_CONFIG_STAT1
argument_list|)
argument_list|)
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|"       CONFIG_STAT2 = 0x%08x\n"
argument_list|,
name|MACH64_READ
argument_list|(
name|MACH64_CONFIG_STAT2
argument_list|)
argument_list|)
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|"            CRC_SIG = 0x%08x\n"
argument_list|,
name|MACH64_READ
argument_list|(
name|MACH64_CRC_SIG
argument_list|)
argument_list|)
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|"  CUSTOM_MACRO_CNTL = 0x%08x\n"
argument_list|,
name|MACH64_READ
argument_list|(
name|MACH64_CUSTOM_MACRO_CNTL
argument_list|)
argument_list|)
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* DRM_INFO( "           DAC_CNTL = 0x%08x\n", MACH64_READ( MACH64_DAC_CNTL ) ); */
comment|/* DRM_INFO( "           DAC_REGS = 0x%08x\n", MACH64_READ( MACH64_DAC_REGS ) ); */
name|DRM_INFO
argument_list|(
literal|"        DP_BKGD_CLR = 0x%08x\n"
argument_list|,
name|MACH64_READ
argument_list|(
name|MACH64_DP_BKGD_CLR
argument_list|)
argument_list|)
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|"        DP_FRGD_CLR = 0x%08x\n"
argument_list|,
name|MACH64_READ
argument_list|(
name|MACH64_DP_FRGD_CLR
argument_list|)
argument_list|)
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|"             DP_MIX = 0x%08x\n"
argument_list|,
name|MACH64_READ
argument_list|(
name|MACH64_DP_MIX
argument_list|)
argument_list|)
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|"       DP_PIX_WIDTH = 0x%08x\n"
argument_list|,
name|MACH64_READ
argument_list|(
name|MACH64_DP_PIX_WIDTH
argument_list|)
argument_list|)
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|"             DP_SRC = 0x%08x\n"
argument_list|,
name|MACH64_READ
argument_list|(
name|MACH64_DP_SRC
argument_list|)
argument_list|)
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|"      DP_WRITE_MASK = 0x%08x\n"
argument_list|,
name|MACH64_READ
argument_list|(
name|MACH64_DP_WRITE_MASK
argument_list|)
argument_list|)
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|"         DSP_CONFIG = 0x%08x\n"
argument_list|,
name|MACH64_READ
argument_list|(
name|MACH64_DSP_CONFIG
argument_list|)
argument_list|)
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|"         DSP_ON_OFF = 0x%08x\n"
argument_list|,
name|MACH64_READ
argument_list|(
name|MACH64_DSP_ON_OFF
argument_list|)
argument_list|)
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|"           DST_CNTL = 0x%08x\n"
argument_list|,
name|MACH64_READ
argument_list|(
name|MACH64_DST_CNTL
argument_list|)
argument_list|)
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|"      DST_OFF_PITCH = 0x%08x\n"
argument_list|,
name|MACH64_READ
argument_list|(
name|MACH64_DST_OFF_PITCH
argument_list|)
argument_list|)
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* DRM_INFO( "       EXT_DAC_REGS = 0x%08x\n", MACH64_READ( MACH64_EXT_DAC_REGS ) ); */
name|DRM_INFO
argument_list|(
literal|"       EXT_MEM_CNTL = 0x%08x\n"
argument_list|,
name|MACH64_READ
argument_list|(
name|MACH64_EXT_MEM_CNTL
argument_list|)
argument_list|)
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|"          FIFO_STAT = 0x%08x\n"
argument_list|,
name|MACH64_READ
argument_list|(
name|MACH64_FIFO_STAT
argument_list|)
argument_list|)
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|"      GEN_TEST_CNTL = 0x%08x\n"
argument_list|,
name|MACH64_READ
argument_list|(
name|MACH64_GEN_TEST_CNTL
argument_list|)
argument_list|)
expr_stmt|;
comment|/* DRM_INFO( "              GP_IO = 0x%08x\n", MACH64_READ( MACH64_GP_IO ) ); */
name|DRM_INFO
argument_list|(
literal|"   GUI_CMDFIFO_DATA = 0x%08x\n"
argument_list|,
name|MACH64_READ
argument_list|(
name|MACH64_GUI_CMDFIFO_DATA
argument_list|)
argument_list|)
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|"  GUI_CMDFIFO_DEBUG = 0x%08x\n"
argument_list|,
name|MACH64_READ
argument_list|(
name|MACH64_GUI_CMDFIFO_DEBUG
argument_list|)
argument_list|)
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|"           GUI_CNTL = 0x%08x\n"
argument_list|,
name|MACH64_READ
argument_list|(
name|MACH64_GUI_CNTL
argument_list|)
argument_list|)
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|"           GUI_STAT = 0x%08x\n"
argument_list|,
name|MACH64_READ
argument_list|(
name|MACH64_GUI_STAT
argument_list|)
argument_list|)
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|"      GUI_TRAJ_CNTL = 0x%08x\n"
argument_list|,
name|MACH64_READ
argument_list|(
name|MACH64_GUI_TRAJ_CNTL
argument_list|)
argument_list|)
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|"          HOST_CNTL = 0x%08x\n"
argument_list|,
name|MACH64_READ
argument_list|(
name|MACH64_HOST_CNTL
argument_list|)
argument_list|)
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|"           HW_DEBUG = 0x%08x\n"
argument_list|,
name|MACH64_READ
argument_list|(
name|MACH64_HW_DEBUG
argument_list|)
argument_list|)
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|"    MEM_ADDR_CONFIG = 0x%08x\n"
argument_list|,
name|MACH64_READ
argument_list|(
name|MACH64_MEM_ADDR_CONFIG
argument_list|)
argument_list|)
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|"       MEM_BUF_CNTL = 0x%08x\n"
argument_list|,
name|MACH64_READ
argument_list|(
name|MACH64_MEM_BUF_CNTL
argument_list|)
argument_list|)
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|"           PAT_REG0 = 0x%08x\n"
argument_list|,
name|MACH64_READ
argument_list|(
name|MACH64_PAT_REG0
argument_list|)
argument_list|)
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|"           PAT_REG1 = 0x%08x\n"
argument_list|,
name|MACH64_READ
argument_list|(
name|MACH64_PAT_REG1
argument_list|)
argument_list|)
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|"            SC_LEFT = 0x%08x\n"
argument_list|,
name|MACH64_READ
argument_list|(
name|MACH64_SC_LEFT
argument_list|)
argument_list|)
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|"           SC_RIGHT = 0x%08x\n"
argument_list|,
name|MACH64_READ
argument_list|(
name|MACH64_SC_RIGHT
argument_list|)
argument_list|)
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|"             SC_TOP = 0x%08x\n"
argument_list|,
name|MACH64_READ
argument_list|(
name|MACH64_SC_TOP
argument_list|)
argument_list|)
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|"          SC_BOTTOM = 0x%08x\n"
argument_list|,
name|MACH64_READ
argument_list|(
name|MACH64_SC_BOTTOM
argument_list|)
argument_list|)
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|"      SCALE_3D_CNTL = 0x%08x\n"
argument_list|,
name|MACH64_READ
argument_list|(
name|MACH64_SCALE_3D_CNTL
argument_list|)
argument_list|)
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|"       SCRATCH_REG0 = 0x%08x\n"
argument_list|,
name|MACH64_READ
argument_list|(
name|MACH64_SCRATCH_REG0
argument_list|)
argument_list|)
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|"       SCRATCH_REG1 = 0x%08x\n"
argument_list|,
name|MACH64_READ
argument_list|(
name|MACH64_SCRATCH_REG1
argument_list|)
argument_list|)
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|"         SETUP_CNTL = 0x%08x\n"
argument_list|,
name|MACH64_READ
argument_list|(
name|MACH64_SETUP_CNTL
argument_list|)
argument_list|)
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|"           SRC_CNTL = 0x%08x\n"
argument_list|,
name|MACH64_READ
argument_list|(
name|MACH64_SRC_CNTL
argument_list|)
argument_list|)
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|"           TEX_CNTL = 0x%08x\n"
argument_list|,
name|MACH64_READ
argument_list|(
name|MACH64_TEX_CNTL
argument_list|)
argument_list|)
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|"     TEX_SIZE_PITCH = 0x%08x\n"
argument_list|,
name|MACH64_READ
argument_list|(
name|MACH64_TEX_SIZE_PITCH
argument_list|)
argument_list|)
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|"       TIMER_CONFIG = 0x%08x\n"
argument_list|,
name|MACH64_READ
argument_list|(
name|MACH64_TIMER_CONFIG
argument_list|)
argument_list|)
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|"             Z_CNTL = 0x%08x\n"
argument_list|,
name|MACH64_READ
argument_list|(
name|MACH64_Z_CNTL
argument_list|)
argument_list|)
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|"        Z_OFF_PITCH = 0x%08x\n"
argument_list|,
name|MACH64_READ
argument_list|(
name|MACH64_Z_OFF_PITCH
argument_list|)
argument_list|)
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|MACH64_DUMP_CONTEXT
value|3
end_define

begin_comment
comment|/**  * Used by mach64_dump_ring_info() to dump the contents of the current buffer  * pointed by the ring head.  */
end_comment

begin_function
specifier|static
name|void
name|mach64_dump_buf_info
parameter_list|(
name|drm_mach64_private_t
modifier|*
name|dev_priv
parameter_list|,
name|struct
name|drm_buf
modifier|*
name|buf
parameter_list|)
block|{
name|u32
name|addr
init|=
name|GETBUFADDR
argument_list|(
name|buf
argument_list|)
decl_stmt|;
name|u32
name|used
init|=
name|buf
operator|->
name|used
operator|>>
literal|2
decl_stmt|;
name|u32
name|sys_addr
init|=
name|MACH64_READ
argument_list|(
name|MACH64_BM_SYSTEM_MEM_ADDR
argument_list|)
decl_stmt|;
name|u32
modifier|*
name|p
init|=
name|GETBUFPTR
argument_list|(
name|buf
argument_list|)
decl_stmt|;
name|int
name|skipped
init|=
literal|0
decl_stmt|;
name|DRM_INFO
argument_list|(
literal|"buffer contents:\n"
argument_list|)
expr_stmt|;
while|while
condition|(
name|used
condition|)
block|{
name|u32
name|reg
decl_stmt|,
name|count
decl_stmt|;
name|reg
operator|=
name|le32_to_cpu
argument_list|(
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|<=
name|GETBUFADDR
argument_list|(
name|buf
argument_list|)
operator|+
name|MACH64_DUMP_CONTEXT
operator|*
literal|4
operator|||
operator|(
name|addr
operator|>=
name|sys_addr
operator|-
name|MACH64_DUMP_CONTEXT
operator|*
literal|4
operator|&&
name|addr
operator|<=
name|sys_addr
operator|+
name|MACH64_DUMP_CONTEXT
operator|*
literal|4
operator|)
operator|||
name|addr
operator|>=
name|GETBUFADDR
argument_list|(
name|buf
argument_list|)
operator|+
name|buf
operator|->
name|used
operator|-
name|MACH64_DUMP_CONTEXT
operator|*
literal|4
condition|)
block|{
name|DRM_INFO
argument_list|(
literal|"%08x:  0x%08x\n"
argument_list|,
name|addr
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
name|addr
operator|+=
literal|4
expr_stmt|;
name|used
operator|--
expr_stmt|;
name|count
operator|=
operator|(
name|reg
operator|>>
literal|16
operator|)
operator|+
literal|1
expr_stmt|;
name|reg
operator|=
name|reg
operator|&
literal|0xffff
expr_stmt|;
name|reg
operator|=
name|MMSELECT
argument_list|(
name|reg
argument_list|)
expr_stmt|;
while|while
condition|(
name|count
operator|&&
name|used
condition|)
block|{
if|if
condition|(
name|addr
operator|<=
name|GETBUFADDR
argument_list|(
name|buf
argument_list|)
operator|+
name|MACH64_DUMP_CONTEXT
operator|*
literal|4
operator|||
operator|(
name|addr
operator|>=
name|sys_addr
operator|-
name|MACH64_DUMP_CONTEXT
operator|*
literal|4
operator|&&
name|addr
operator|<=
name|sys_addr
operator|+
name|MACH64_DUMP_CONTEXT
operator|*
literal|4
operator|)
operator|||
name|addr
operator|>=
name|GETBUFADDR
argument_list|(
name|buf
argument_list|)
operator|+
name|buf
operator|->
name|used
operator|-
name|MACH64_DUMP_CONTEXT
operator|*
literal|4
condition|)
block|{
name|DRM_INFO
argument_list|(
literal|"%08x:    0x%04x = 0x%08x\n"
argument_list|,
name|addr
argument_list|,
name|reg
argument_list|,
name|le32_to_cpu
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|skipped
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|skipped
condition|)
block|{
name|DRM_INFO
argument_list|(
literal|"  ...\n"
argument_list|)
expr_stmt|;
name|skipped
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|p
operator|++
expr_stmt|;
name|addr
operator|+=
literal|4
expr_stmt|;
name|used
operator|--
expr_stmt|;
name|reg
operator|+=
literal|4
expr_stmt|;
name|count
operator|--
expr_stmt|;
block|}
block|}
name|DRM_INFO
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Dump the ring state and contents, including the contents of the buffer being  * processed by the graphics engine.  */
end_comment

begin_function
name|void
name|mach64_dump_ring_info
parameter_list|(
name|drm_mach64_private_t
modifier|*
name|dev_priv
parameter_list|)
block|{
name|drm_mach64_descriptor_ring_t
modifier|*
name|ring
init|=
operator|&
name|dev_priv
operator|->
name|ring
decl_stmt|;
name|int
name|i
decl_stmt|,
name|skipped
decl_stmt|;
name|DRM_INFO
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|"ring contents:\n"
argument_list|)
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|"  head_addr: 0x%08x head: %u tail: %u\n\n"
argument_list|,
name|ring
operator|->
name|head_addr
argument_list|,
name|ring
operator|->
name|head
argument_list|,
name|ring
operator|->
name|tail
argument_list|)
expr_stmt|;
name|skipped
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ring
operator|->
name|size
operator|/
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
condition|;
name|i
operator|+=
literal|4
control|)
block|{
if|if
condition|(
name|i
operator|<=
name|MACH64_DUMP_CONTEXT
operator|*
literal|4
operator|||
name|i
operator|>=
name|ring
operator|->
name|size
operator|/
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
operator|-
name|MACH64_DUMP_CONTEXT
operator|*
literal|4
operator|||
operator|(
name|i
operator|>=
name|ring
operator|->
name|tail
operator|-
name|MACH64_DUMP_CONTEXT
operator|*
literal|4
operator|&&
name|i
operator|<=
name|ring
operator|->
name|tail
operator|+
name|MACH64_DUMP_CONTEXT
operator|*
literal|4
operator|)
operator|||
operator|(
name|i
operator|>=
name|ring
operator|->
name|head
operator|-
name|MACH64_DUMP_CONTEXT
operator|*
literal|4
operator|&&
name|i
operator|<=
name|ring
operator|->
name|head
operator|+
name|MACH64_DUMP_CONTEXT
operator|*
literal|4
operator|)
condition|)
block|{
name|DRM_INFO
argument_list|(
literal|"  0x%08x:  0x%08x 0x%08x 0x%08x 0x%08x%s%s\n"
argument_list|,
call|(
name|u32
call|)
argument_list|(
name|ring
operator|->
name|start_addr
operator|+
name|i
operator|*
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
argument_list|)
argument_list|,
name|le32_to_cpu
argument_list|(
operator|(
operator|(
name|u32
operator|*
operator|)
name|ring
operator|->
name|start
operator|)
index|[
name|i
operator|+
literal|0
index|]
argument_list|)
argument_list|,
name|le32_to_cpu
argument_list|(
operator|(
operator|(
name|u32
operator|*
operator|)
name|ring
operator|->
name|start
operator|)
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
argument_list|,
name|le32_to_cpu
argument_list|(
operator|(
operator|(
name|u32
operator|*
operator|)
name|ring
operator|->
name|start
operator|)
index|[
name|i
operator|+
literal|2
index|]
argument_list|)
argument_list|,
name|le32_to_cpu
argument_list|(
operator|(
operator|(
name|u32
operator|*
operator|)
name|ring
operator|->
name|start
operator|)
index|[
name|i
operator|+
literal|3
index|]
argument_list|)
argument_list|,
name|i
operator|==
name|ring
operator|->
name|head
condition|?
literal|" (head)"
else|:
literal|""
argument_list|,
name|i
operator|==
name|ring
operator|->
name|tail
condition|?
literal|" (tail)"
else|:
literal|""
argument_list|)
expr_stmt|;
name|skipped
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|skipped
condition|)
block|{
name|DRM_INFO
argument_list|(
literal|"  ...\n"
argument_list|)
expr_stmt|;
name|skipped
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
name|DRM_INFO
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ring
operator|->
name|head
operator|<
name|ring
operator|->
name|size
operator|/
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
condition|)
block|{
name|struct
name|list_head
modifier|*
name|ptr
decl_stmt|;
name|u32
name|addr
init|=
name|le32_to_cpu
argument_list|(
operator|(
operator|(
name|u32
operator|*
operator|)
name|ring
operator|->
name|start
operator|)
index|[
name|ring
operator|->
name|head
operator|+
literal|1
index|]
argument_list|)
decl_stmt|;
name|list_for_each
argument_list|(
argument|ptr
argument_list|,
argument|&dev_priv->pending
argument_list|)
block|{
name|drm_mach64_freelist_t
modifier|*
name|entry
init|=
name|list_entry
argument_list|(
name|ptr
argument_list|,
name|drm_mach64_freelist_t
argument_list|,
name|list
argument_list|)
decl_stmt|;
name|struct
name|drm_buf
modifier|*
name|buf
init|=
name|entry
operator|->
name|buf
decl_stmt|;
name|u32
name|buf_addr
init|=
name|GETBUFADDR
argument_list|(
name|buf
argument_list|)
decl_stmt|;
if|if
condition|(
name|buf_addr
operator|<=
name|addr
operator|&&
name|addr
operator|<
name|buf_addr
operator|+
name|buf
operator|->
name|used
condition|)
name|mach64_dump_buf_info
argument_list|(
name|dev_priv
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
name|DRM_INFO
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|"       BM_GUI_TABLE = 0x%08x\n"
argument_list|,
name|MACH64_READ
argument_list|(
name|MACH64_BM_GUI_TABLE
argument_list|)
argument_list|)
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|"BM_FRAME_BUF_OFFSET = 0x%08x\n"
argument_list|,
name|MACH64_READ
argument_list|(
name|MACH64_BM_FRAME_BUF_OFFSET
argument_list|)
argument_list|)
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|" BM_SYSTEM_MEM_ADDR = 0x%08x\n"
argument_list|,
name|MACH64_READ
argument_list|(
name|MACH64_BM_SYSTEM_MEM_ADDR
argument_list|)
argument_list|)
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|"         BM_COMMAND = 0x%08x\n"
argument_list|,
name|MACH64_READ
argument_list|(
name|MACH64_BM_COMMAND
argument_list|)
argument_list|)
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|"          BM_STATUS = 0x%08x\n"
argument_list|,
name|MACH64_READ
argument_list|(
name|MACH64_BM_STATUS
argument_list|)
argument_list|)
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|"           BUS_CNTL = 0x%08x\n"
argument_list|,
name|MACH64_READ
argument_list|(
name|MACH64_BUS_CNTL
argument_list|)
argument_list|)
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|"          FIFO_STAT = 0x%08x\n"
argument_list|,
name|MACH64_READ
argument_list|(
name|MACH64_FIFO_STAT
argument_list|)
argument_list|)
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|"           GUI_STAT = 0x%08x\n"
argument_list|,
name|MACH64_READ
argument_list|(
name|MACH64_GUI_STAT
argument_list|)
argument_list|)
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|"           SRC_CNTL = 0x%08x\n"
argument_list|,
name|MACH64_READ
argument_list|(
name|MACH64_SRC_CNTL
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*@}*/
end_comment

begin_comment
comment|/*******************************************************************/
end_comment

begin_comment
comment|/** \name DMA descriptor ring macros */
end_comment

begin_comment
comment|/*@{*/
end_comment

begin_comment
comment|/**  * Add the end mark to the ring's new tail position.  *  * The bus master engine will keep processing the DMA buffers listed in the ring  * until it finds this mark, making it stop.  *  * \sa mach64_clear_dma_eol  */
end_comment

begin_function
specifier|static
name|__inline__
name|void
name|mach64_set_dma_eol
parameter_list|(
specifier|volatile
name|u32
modifier|*
name|addr
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|__i386__
argument_list|)
name|int
name|nr
init|=
literal|31
decl_stmt|;
comment|/* Taken from include/asm-i386/bitops.h linux header */
asm|__asm__
specifier|__volatile__
asm|("lock;" "btsl %1,%0":"=m"(*addr) 			     :"Ir"(nr));
elif|#
directive|elif
name|defined
argument_list|(
name|__powerpc__
argument_list|)
name|u32
name|old
decl_stmt|;
name|u32
name|mask
init|=
name|cpu_to_le32
argument_list|(
name|MACH64_DMA_EOL
argument_list|)
decl_stmt|;
comment|/* Taken from the include/asm-ppc/bitops.h linux header */
asm|__asm__
specifier|__volatile__
asm|("\n\ 1:	lwarx	%0,0,%3 \n\ 	or	%0,%0,%2 \n\ 	stwcx.	%0,0,%3 \n\ 	bne-	1b":"=&r"(old), "=m"(*addr) 			     :"r"(mask), "r"(addr), "m"(*addr) 			     :"cc");
elif|#
directive|elif
name|defined
argument_list|(
name|__alpha__
argument_list|)
name|u32
name|temp
decl_stmt|;
name|u32
name|mask
init|=
name|MACH64_DMA_EOL
decl_stmt|;
comment|/* Taken from the include/asm-alpha/bitops.h linux header */
asm|__asm__
specifier|__volatile__
asm|("1:	ldl_l %0,%3\n" 			     "	bis %0,%2,%0\n" 			     "	stl_c %0,%1\n" 			     "	beq %0,2f\n" 			     ".subsection 2\n" 			     "2:	br 1b\n" 			     ".previous":"=&r"(temp), "=m"(*addr) 			     :"Ir"(mask), "m"(*addr));
else|#
directive|else
name|u32
name|mask
init|=
name|cpu_to_le32
argument_list|(
name|MACH64_DMA_EOL
argument_list|)
decl_stmt|;
operator|*
name|addr
operator||=
name|mask
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/**  * Remove the end mark from the ring's old tail position.  *  * It should be called after calling mach64_set_dma_eol to mark the ring's new  * tail position.  *  * We update the end marks while the bus master engine is in operation. Since  * the bus master engine may potentially be reading from the same position  * that we write, we must change atomically to avoid having intermediary bad  * data.  */
end_comment

begin_function
specifier|static
name|__inline__
name|void
name|mach64_clear_dma_eol
parameter_list|(
specifier|volatile
name|u32
modifier|*
name|addr
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|__i386__
argument_list|)
name|int
name|nr
init|=
literal|31
decl_stmt|;
comment|/* Taken from include/asm-i386/bitops.h linux header */
asm|__asm__
specifier|__volatile__
asm|("lock;" "btrl %1,%0":"=m"(*addr) 			     :"Ir"(nr));
elif|#
directive|elif
name|defined
argument_list|(
name|__powerpc__
argument_list|)
name|u32
name|old
decl_stmt|;
name|u32
name|mask
init|=
name|cpu_to_le32
argument_list|(
name|MACH64_DMA_EOL
argument_list|)
decl_stmt|;
comment|/* Taken from the include/asm-ppc/bitops.h linux header */
asm|__asm__
specifier|__volatile__
asm|("\n\ 1:	lwarx	%0,0,%3 \n\ 	andc	%0,%0,%2 \n\ 	stwcx.	%0,0,%3 \n\ 	bne-	1b":"=&r"(old), "=m"(*addr) 			     :"r"(mask), "r"(addr), "m"(*addr) 			     :"cc");
elif|#
directive|elif
name|defined
argument_list|(
name|__alpha__
argument_list|)
name|u32
name|temp
decl_stmt|;
name|u32
name|mask
init|=
operator|~
name|MACH64_DMA_EOL
decl_stmt|;
comment|/* Taken from the include/asm-alpha/bitops.h linux header */
asm|__asm__
specifier|__volatile__
asm|("1:	ldl_l %0,%3\n" 			     "	and %0,%2,%0\n" 			     "	stl_c %0,%1\n" 			     "	beq %0,2f\n" 			     ".subsection 2\n" 			     "2:	br 1b\n" 			     ".previous":"=&r"(temp), "=m"(*addr) 			     :"Ir"(mask), "m"(*addr));
else|#
directive|else
name|u32
name|mask
init|=
name|cpu_to_le32
argument_list|(
operator|~
name|MACH64_DMA_EOL
argument_list|)
decl_stmt|;
operator|*
name|addr
operator|&=
name|mask
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_define
define|#
directive|define
name|RING_LOCALS
define|\
value|int _ring_tail, _ring_write; unsigned int _ring_mask; volatile u32 *_ring
end_define

begin_define
define|#
directive|define
name|RING_WRITE_OFS
value|_ring_write
end_define

begin_define
define|#
directive|define
name|BEGIN_RING
parameter_list|(
name|n
parameter_list|)
define|\
value|do {								\ 		if (MACH64_VERBOSE) {					\ 			DRM_INFO( "BEGIN_RING( %d ) \n",		\ 				  (n) );				\ 		}							\ 		if (dev_priv->ring.space<= (n) * sizeof(u32)) {	\ 			int ret;					\ 			if ((ret = mach64_wait_ring( dev_priv, (n) * sizeof(u32)))< 0 ) { \ 				DRM_ERROR( "wait_ring failed, resetting engine\n"); \ 				mach64_dump_engine_info( dev_priv );	\ 				mach64_do_engine_reset( dev_priv );	\ 				return ret;				\ 			}						\ 		}							\ 		dev_priv->ring.space -= (n) * sizeof(u32);		\ 		_ring = (u32 *) dev_priv->ring.start;			\ 		_ring_tail = _ring_write = dev_priv->ring.tail;		\ 		_ring_mask = dev_priv->ring.tail_mask;			\ 	} while (0)
end_define

begin_define
define|#
directive|define
name|OUT_RING
parameter_list|(
name|x
parameter_list|)
define|\
value|do {								\ 	if (MACH64_VERBOSE) {					\ 		DRM_INFO( "   OUT_RING( 0x%08x ) at 0x%x\n",	\ 			   (unsigned int)(x), _ring_write );	\ 	}							\ 	_ring[_ring_write++] = cpu_to_le32( x );		\ 	_ring_write&= _ring_mask;				\ } while (0)
end_define

begin_define
define|#
directive|define
name|ADVANCE_RING
parameter_list|()
define|\
value|do {									\ 	if (MACH64_VERBOSE) {						\ 		DRM_INFO( "ADVANCE_RING() wr=0x%06x tail=0x%06x\n",	\ 			  _ring_write, _ring_tail );			\ 	}								\ 	DRM_MEMORYBARRIER();						\ 	mach64_clear_dma_eol(&_ring[(_ring_tail - 2)& _ring_mask] );	\ 	DRM_MEMORYBARRIER();						\ 	dev_priv->ring.tail = _ring_write;				\ 	mach64_ring_tick( dev_priv,&(dev_priv)->ring );		\ } while (0)
end_define

begin_comment
comment|/**  * Queue a DMA buffer of registers writes into the ring buffer.  */
end_comment

begin_function
name|int
name|mach64_add_buf_to_ring
parameter_list|(
name|drm_mach64_private_t
modifier|*
name|dev_priv
parameter_list|,
name|drm_mach64_freelist_t
modifier|*
name|entry
parameter_list|)
block|{
name|int
name|bytes
decl_stmt|,
name|pages
decl_stmt|,
name|remainder
decl_stmt|;
name|u32
name|address
decl_stmt|,
name|page
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|drm_buf
modifier|*
name|buf
init|=
name|entry
operator|->
name|buf
decl_stmt|;
name|RING_LOCALS
expr_stmt|;
name|bytes
operator|=
name|buf
operator|->
name|used
expr_stmt|;
name|address
operator|=
name|GETBUFADDR
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|pages
operator|=
operator|(
name|bytes
operator|+
name|MACH64_DMA_CHUNKSIZE
operator|-
literal|1
operator|)
operator|/
name|MACH64_DMA_CHUNKSIZE
expr_stmt|;
name|BEGIN_RING
argument_list|(
name|pages
operator|*
literal|4
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pages
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|page
operator|=
name|address
operator|+
name|i
operator|*
name|MACH64_DMA_CHUNKSIZE
expr_stmt|;
name|OUT_RING
argument_list|(
name|MACH64_APERTURE_OFFSET
operator|+
name|MACH64_BM_ADDR
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|page
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|MACH64_DMA_CHUNKSIZE
operator||
name|MACH64_DMA_HOLD_OFFSET
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* generate the final descriptor for any remaining commands in this buffer */
name|page
operator|=
name|address
operator|+
name|i
operator|*
name|MACH64_DMA_CHUNKSIZE
expr_stmt|;
name|remainder
operator|=
name|bytes
operator|-
name|i
operator|*
name|MACH64_DMA_CHUNKSIZE
expr_stmt|;
comment|/* Save dword offset of last descriptor for this buffer. 	 * This is needed to check for completion of the buffer in freelist_get 	 */
name|entry
operator|->
name|ring_ofs
operator|=
name|RING_WRITE_OFS
expr_stmt|;
name|OUT_RING
argument_list|(
name|MACH64_APERTURE_OFFSET
operator|+
name|MACH64_BM_ADDR
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|page
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|remainder
operator||
name|MACH64_DMA_HOLD_OFFSET
operator||
name|MACH64_DMA_EOL
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|ADVANCE_RING
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Queue DMA buffer controlling host data tranfers (e.g., blit).  *   * Almost identical to mach64_add_buf_to_ring.  */
end_comment

begin_function
name|int
name|mach64_add_hostdata_buf_to_ring
parameter_list|(
name|drm_mach64_private_t
modifier|*
name|dev_priv
parameter_list|,
name|drm_mach64_freelist_t
modifier|*
name|entry
parameter_list|)
block|{
name|int
name|bytes
decl_stmt|,
name|pages
decl_stmt|,
name|remainder
decl_stmt|;
name|u32
name|address
decl_stmt|,
name|page
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|drm_buf
modifier|*
name|buf
init|=
name|entry
operator|->
name|buf
decl_stmt|;
name|RING_LOCALS
expr_stmt|;
name|bytes
operator|=
name|buf
operator|->
name|used
operator|-
name|MACH64_HOSTDATA_BLIT_OFFSET
expr_stmt|;
name|pages
operator|=
operator|(
name|bytes
operator|+
name|MACH64_DMA_CHUNKSIZE
operator|-
literal|1
operator|)
operator|/
name|MACH64_DMA_CHUNKSIZE
expr_stmt|;
name|address
operator|=
name|GETBUFADDR
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|BEGIN_RING
argument_list|(
literal|4
operator|+
name|pages
operator|*
literal|4
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|MACH64_APERTURE_OFFSET
operator|+
name|MACH64_BM_ADDR
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|address
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|MACH64_HOSTDATA_BLIT_OFFSET
operator||
name|MACH64_DMA_HOLD_OFFSET
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|address
operator|+=
name|MACH64_HOSTDATA_BLIT_OFFSET
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pages
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|page
operator|=
name|address
operator|+
name|i
operator|*
name|MACH64_DMA_CHUNKSIZE
expr_stmt|;
name|OUT_RING
argument_list|(
name|MACH64_APERTURE_OFFSET
operator|+
name|MACH64_BM_HOSTDATA
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|page
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|MACH64_DMA_CHUNKSIZE
operator||
name|MACH64_DMA_HOLD_OFFSET
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* generate the final descriptor for any remaining commands in this buffer */
name|page
operator|=
name|address
operator|+
name|i
operator|*
name|MACH64_DMA_CHUNKSIZE
expr_stmt|;
name|remainder
operator|=
name|bytes
operator|-
name|i
operator|*
name|MACH64_DMA_CHUNKSIZE
expr_stmt|;
comment|/* Save dword offset of last descriptor for this buffer. 	 * This is needed to check for completion of the buffer in freelist_get 	 */
name|entry
operator|->
name|ring_ofs
operator|=
name|RING_WRITE_OFS
expr_stmt|;
name|OUT_RING
argument_list|(
name|MACH64_APERTURE_OFFSET
operator|+
name|MACH64_BM_HOSTDATA
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|page
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|remainder
operator||
name|MACH64_DMA_HOLD_OFFSET
operator||
name|MACH64_DMA_EOL
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|ADVANCE_RING
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*@}*/
end_comment

begin_comment
comment|/*******************************************************************/
end_comment

begin_comment
comment|/** \name DMA test and initialization */
end_comment

begin_comment
comment|/*@{*/
end_comment

begin_comment
comment|/**  * Perform a simple DMA operation using the pattern registers to test whether  * DMA works.  *  * \return zero if successful.  *  * \note This function was the testbed for many experiences regarding Mach64  * DMA operation. It is left here since it so tricky to get DMA operating  * properly in some architectures and hardware.  */
end_comment

begin_function
specifier|static
name|int
name|mach64_bm_dma_test
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|drm_mach64_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|drm_dma_handle_t
modifier|*
name|cpu_addr_dmah
decl_stmt|;
name|u32
name|data_addr
decl_stmt|;
name|u32
modifier|*
name|table
decl_stmt|,
modifier|*
name|data
decl_stmt|;
name|u32
name|expected
index|[
literal|2
index|]
decl_stmt|;
name|u32
name|src_cntl
decl_stmt|,
name|pat_reg0
decl_stmt|,
name|pat_reg1
decl_stmt|;
name|int
name|i
decl_stmt|,
name|count
decl_stmt|,
name|failed
decl_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|table
operator|=
operator|(
name|u32
operator|*
operator|)
name|dev_priv
operator|->
name|ring
operator|.
name|start
expr_stmt|;
comment|/* FIXME: get a dma buffer from the freelist here */
name|DRM_DEBUG
argument_list|(
literal|"Allocating data memory ...\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__FreeBSD__
name|DRM_UNLOCK
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|cpu_addr_dmah
operator|=
name|drm_pci_alloc
argument_list|(
name|dev
argument_list|,
literal|0x1000
argument_list|,
literal|0x1000
argument_list|,
literal|0xfffffffful
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__FreeBSD__
name|DRM_LOCK
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|cpu_addr_dmah
condition|)
block|{
name|DRM_INFO
argument_list|(
literal|"data-memory allocation failed!\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
block|}
else|else
block|{
name|data
operator|=
operator|(
name|u32
operator|*
operator|)
name|cpu_addr_dmah
operator|->
name|vaddr
expr_stmt|;
name|data_addr
operator|=
operator|(
name|u32
operator|)
name|cpu_addr_dmah
operator|->
name|busaddr
expr_stmt|;
block|}
comment|/* Save the X server's value for SRC_CNTL and restore it 	 * in case our test fails.  This prevents the X server 	 * from disabling it's cache for this register 	 */
name|src_cntl
operator|=
name|MACH64_READ
argument_list|(
name|MACH64_SRC_CNTL
argument_list|)
expr_stmt|;
name|pat_reg0
operator|=
name|MACH64_READ
argument_list|(
name|MACH64_PAT_REG0
argument_list|)
expr_stmt|;
name|pat_reg1
operator|=
name|MACH64_READ
argument_list|(
name|MACH64_PAT_REG1
argument_list|)
expr_stmt|;
name|mach64_do_wait_for_fifo
argument_list|(
name|dev_priv
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|MACH64_WRITE
argument_list|(
name|MACH64_SRC_CNTL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|MACH64_WRITE
argument_list|(
name|MACH64_PAT_REG0
argument_list|,
literal|0x11111111
argument_list|)
expr_stmt|;
name|MACH64_WRITE
argument_list|(
name|MACH64_PAT_REG1
argument_list|,
literal|0x11111111
argument_list|)
expr_stmt|;
name|mach64_do_wait_for_idle
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|u32
name|reg
decl_stmt|;
name|reg
operator|=
name|MACH64_READ
argument_list|(
operator|(
name|MACH64_PAT_REG0
operator|+
name|i
operator|*
literal|4
operator|)
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"(Before DMA Transfer) reg %d = 0x%08x\n"
argument_list|,
name|i
argument_list|,
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|!=
literal|0x11111111
condition|)
block|{
name|DRM_INFO
argument_list|(
literal|"Error initializing test registers\n"
argument_list|)
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|"resetting engine ...\n"
argument_list|)
expr_stmt|;
name|mach64_do_engine_reset
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|"freeing data buffer memory.\n"
argument_list|)
expr_stmt|;
name|drm_pci_free
argument_list|(
name|dev
argument_list|,
name|cpu_addr_dmah
argument_list|)
expr_stmt|;
return|return
operator|-
name|EIO
return|;
block|}
block|}
comment|/* fill up a buffer with sets of 2 consecutive writes starting with PAT_REG0 */
name|count
operator|=
literal|0
expr_stmt|;
name|data
index|[
name|count
operator|++
index|]
operator|=
name|cpu_to_le32
argument_list|(
name|DMAREG
argument_list|(
name|MACH64_PAT_REG0
argument_list|)
operator||
operator|(
literal|1
operator|<<
literal|16
operator|)
argument_list|)
expr_stmt|;
name|data
index|[
name|count
operator|++
index|]
operator|=
name|expected
index|[
literal|0
index|]
operator|=
literal|0x22222222
expr_stmt|;
name|data
index|[
name|count
operator|++
index|]
operator|=
name|expected
index|[
literal|1
index|]
operator|=
literal|0xaaaaaaaa
expr_stmt|;
while|while
condition|(
name|count
operator|<
literal|1020
condition|)
block|{
name|data
index|[
name|count
operator|++
index|]
operator|=
name|cpu_to_le32
argument_list|(
name|DMAREG
argument_list|(
name|MACH64_PAT_REG0
argument_list|)
operator||
operator|(
literal|1
operator|<<
literal|16
operator|)
argument_list|)
expr_stmt|;
name|data
index|[
name|count
operator|++
index|]
operator|=
literal|0x22222222
expr_stmt|;
name|data
index|[
name|count
operator|++
index|]
operator|=
literal|0xaaaaaaaa
expr_stmt|;
block|}
name|data
index|[
name|count
operator|++
index|]
operator|=
name|cpu_to_le32
argument_list|(
name|DMAREG
argument_list|(
name|MACH64_SRC_CNTL
argument_list|)
operator||
operator|(
literal|0
operator|<<
literal|16
operator|)
argument_list|)
expr_stmt|;
name|data
index|[
name|count
operator|++
index|]
operator|=
literal|0
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"Preparing table ...\n"
argument_list|)
expr_stmt|;
name|table
index|[
name|MACH64_DMA_FRAME_BUF_OFFSET
index|]
operator|=
name|cpu_to_le32
argument_list|(
name|MACH64_BM_ADDR
operator|+
name|MACH64_APERTURE_OFFSET
argument_list|)
expr_stmt|;
name|table
index|[
name|MACH64_DMA_SYS_MEM_ADDR
index|]
operator|=
name|cpu_to_le32
argument_list|(
name|data_addr
argument_list|)
expr_stmt|;
name|table
index|[
name|MACH64_DMA_COMMAND
index|]
operator|=
name|cpu_to_le32
argument_list|(
name|count
operator|*
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
operator||
name|MACH64_DMA_HOLD_OFFSET
operator||
name|MACH64_DMA_EOL
argument_list|)
expr_stmt|;
name|table
index|[
name|MACH64_DMA_RESERVED
index|]
operator|=
literal|0
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"table[0] = 0x%08x\n"
argument_list|,
name|table
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"table[1] = 0x%08x\n"
argument_list|,
name|table
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"table[2] = 0x%08x\n"
argument_list|,
name|table
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"table[3] = 0x%08x\n"
argument_list|,
name|table
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
block|{
name|DRM_DEBUG
argument_list|(
literal|" data[%d] = 0x%08x\n"
argument_list|,
name|i
argument_list|,
name|data
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|DRM_DEBUG
argument_list|(
literal|" ...\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|count
operator|-
literal|5
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|DRM_DEBUG
argument_list|(
literal|" data[%d] = 0x%08x\n"
argument_list|,
name|i
argument_list|,
name|data
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|DRM_MEMORYBARRIER
argument_list|()
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"waiting for idle...\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|mach64_do_wait_for_idle
argument_list|(
name|dev_priv
argument_list|)
operator|)
condition|)
block|{
name|DRM_INFO
argument_list|(
literal|"mach64_do_wait_for_idle failed (result=%d)\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|"resetting engine ...\n"
argument_list|)
expr_stmt|;
name|mach64_do_engine_reset
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
name|mach64_do_wait_for_fifo
argument_list|(
name|dev_priv
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|MACH64_WRITE
argument_list|(
name|MACH64_SRC_CNTL
argument_list|,
name|src_cntl
argument_list|)
expr_stmt|;
name|MACH64_WRITE
argument_list|(
name|MACH64_PAT_REG0
argument_list|,
name|pat_reg0
argument_list|)
expr_stmt|;
name|MACH64_WRITE
argument_list|(
name|MACH64_PAT_REG1
argument_list|,
name|pat_reg1
argument_list|)
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|"freeing data buffer memory.\n"
argument_list|)
expr_stmt|;
name|drm_pci_free
argument_list|(
name|dev
argument_list|,
name|cpu_addr_dmah
argument_list|)
expr_stmt|;
return|return
name|i
return|;
block|}
name|DRM_DEBUG
argument_list|(
literal|"waiting for idle...done\n"
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"BUS_CNTL = 0x%08x\n"
argument_list|,
name|MACH64_READ
argument_list|(
name|MACH64_BUS_CNTL
argument_list|)
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"SRC_CNTL = 0x%08x\n"
argument_list|,
name|MACH64_READ
argument_list|(
name|MACH64_SRC_CNTL
argument_list|)
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"data bus addr = 0x%08x\n"
argument_list|,
name|data_addr
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"table bus addr = 0x%08x\n"
argument_list|,
name|dev_priv
operator|->
name|ring
operator|.
name|start_addr
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"starting DMA transfer...\n"
argument_list|)
expr_stmt|;
name|MACH64_WRITE
argument_list|(
name|MACH64_BM_GUI_TABLE_CMD
argument_list|,
name|dev_priv
operator|->
name|ring
operator|.
name|start_addr
operator||
name|MACH64_CIRCULAR_BUF_SIZE_16KB
argument_list|)
expr_stmt|;
name|MACH64_WRITE
argument_list|(
name|MACH64_SRC_CNTL
argument_list|,
name|MACH64_SRC_BM_ENABLE
operator||
name|MACH64_SRC_BM_SYNC
operator||
name|MACH64_SRC_BM_OP_SYSTEM_TO_REG
argument_list|)
expr_stmt|;
comment|/* Kick off the transfer */
name|DRM_DEBUG
argument_list|(
literal|"starting DMA transfer... done.\n"
argument_list|)
expr_stmt|;
name|MACH64_WRITE
argument_list|(
name|MACH64_DST_HEIGHT_WIDTH
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"waiting for idle...\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|mach64_do_wait_for_idle
argument_list|(
name|dev_priv
argument_list|)
operator|)
condition|)
block|{
comment|/* engine locked up, dump register state and reset */
name|DRM_INFO
argument_list|(
literal|"mach64_do_wait_for_idle failed (result=%d)\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|mach64_dump_engine_info
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|"resetting engine ...\n"
argument_list|)
expr_stmt|;
name|mach64_do_engine_reset
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
name|mach64_do_wait_for_fifo
argument_list|(
name|dev_priv
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|MACH64_WRITE
argument_list|(
name|MACH64_SRC_CNTL
argument_list|,
name|src_cntl
argument_list|)
expr_stmt|;
name|MACH64_WRITE
argument_list|(
name|MACH64_PAT_REG0
argument_list|,
name|pat_reg0
argument_list|)
expr_stmt|;
name|MACH64_WRITE
argument_list|(
name|MACH64_PAT_REG1
argument_list|,
name|pat_reg1
argument_list|)
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|"freeing data buffer memory.\n"
argument_list|)
expr_stmt|;
name|drm_pci_free
argument_list|(
name|dev
argument_list|,
name|cpu_addr_dmah
argument_list|)
expr_stmt|;
return|return
name|i
return|;
block|}
name|DRM_DEBUG
argument_list|(
literal|"waiting for idle...done\n"
argument_list|)
expr_stmt|;
comment|/* restore SRC_CNTL */
name|mach64_do_wait_for_fifo
argument_list|(
name|dev_priv
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|MACH64_WRITE
argument_list|(
name|MACH64_SRC_CNTL
argument_list|,
name|src_cntl
argument_list|)
expr_stmt|;
name|failed
operator|=
literal|0
expr_stmt|;
comment|/* Check register values to see if the GUI master operation succeeded */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|u32
name|reg
decl_stmt|;
name|reg
operator|=
name|MACH64_READ
argument_list|(
operator|(
name|MACH64_PAT_REG0
operator|+
name|i
operator|*
literal|4
operator|)
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"(After DMA Transfer) reg %d = 0x%08x\n"
argument_list|,
name|i
argument_list|,
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|!=
name|expected
index|[
name|i
index|]
condition|)
block|{
name|failed
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
comment|/* restore pattern registers */
name|mach64_do_wait_for_fifo
argument_list|(
name|dev_priv
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|MACH64_WRITE
argument_list|(
name|MACH64_PAT_REG0
argument_list|,
name|pat_reg0
argument_list|)
expr_stmt|;
name|MACH64_WRITE
argument_list|(
name|MACH64_PAT_REG1
argument_list|,
name|pat_reg1
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"freeing data buffer memory.\n"
argument_list|)
expr_stmt|;
name|drm_pci_free
argument_list|(
name|dev
argument_list|,
name|cpu_addr_dmah
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"returning ...\n"
argument_list|)
expr_stmt|;
return|return
name|failed
return|;
block|}
end_function

begin_comment
comment|/**  * Called during the DMA initialization ioctl to initialize all the necessary  * software and hardware state for DMA operation.  */
end_comment

begin_function
specifier|static
name|int
name|mach64_do_dma_init
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|drm_mach64_init_t
modifier|*
name|init
parameter_list|)
block|{
name|drm_mach64_private_t
modifier|*
name|dev_priv
decl_stmt|;
name|u32
name|tmp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ret
decl_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|dev_priv
operator|=
name|drm_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|drm_mach64_private_t
argument_list|)
argument_list|,
name|DRM_MEM_DRIVER
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev_priv
operator|==
name|NULL
condition|)
return|return
operator|-
name|ENOMEM
return|;
name|memset
argument_list|(
name|dev_priv
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|drm_mach64_private_t
argument_list|)
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|is_pci
operator|=
name|init
operator|->
name|is_pci
expr_stmt|;
name|dev_priv
operator|->
name|fb_bpp
operator|=
name|init
operator|->
name|fb_bpp
expr_stmt|;
name|dev_priv
operator|->
name|front_offset
operator|=
name|init
operator|->
name|front_offset
expr_stmt|;
name|dev_priv
operator|->
name|front_pitch
operator|=
name|init
operator|->
name|front_pitch
expr_stmt|;
name|dev_priv
operator|->
name|back_offset
operator|=
name|init
operator|->
name|back_offset
expr_stmt|;
name|dev_priv
operator|->
name|back_pitch
operator|=
name|init
operator|->
name|back_pitch
expr_stmt|;
name|dev_priv
operator|->
name|depth_bpp
operator|=
name|init
operator|->
name|depth_bpp
expr_stmt|;
name|dev_priv
operator|->
name|depth_offset
operator|=
name|init
operator|->
name|depth_offset
expr_stmt|;
name|dev_priv
operator|->
name|depth_pitch
operator|=
name|init
operator|->
name|depth_pitch
expr_stmt|;
name|dev_priv
operator|->
name|front_offset_pitch
operator|=
operator|(
operator|(
operator|(
name|dev_priv
operator|->
name|front_pitch
operator|/
literal|8
operator|)
operator|<<
literal|22
operator|)
operator||
operator|(
name|dev_priv
operator|->
name|front_offset
operator|>>
literal|3
operator|)
operator|)
expr_stmt|;
name|dev_priv
operator|->
name|back_offset_pitch
operator|=
operator|(
operator|(
operator|(
name|dev_priv
operator|->
name|back_pitch
operator|/
literal|8
operator|)
operator|<<
literal|22
operator|)
operator||
operator|(
name|dev_priv
operator|->
name|back_offset
operator|>>
literal|3
operator|)
operator|)
expr_stmt|;
name|dev_priv
operator|->
name|depth_offset_pitch
operator|=
operator|(
operator|(
operator|(
name|dev_priv
operator|->
name|depth_pitch
operator|/
literal|8
operator|)
operator|<<
literal|22
operator|)
operator||
operator|(
name|dev_priv
operator|->
name|depth_offset
operator|>>
literal|3
operator|)
operator|)
expr_stmt|;
name|dev_priv
operator|->
name|usec_timeout
operator|=
literal|1000000
expr_stmt|;
comment|/* Set up the freelist, placeholder list and pending list */
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|dev_priv
operator|->
name|free_list
argument_list|)
expr_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|dev_priv
operator|->
name|placeholders
argument_list|)
expr_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|dev_priv
operator|->
name|pending
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|sarea
operator|=
name|drm_getsarea
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dev_priv
operator|->
name|sarea
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"can not find sarea!\n"
argument_list|)
expr_stmt|;
name|dev
operator|->
name|dev_private
operator|=
operator|(
name|void
operator|*
operator|)
name|dev_priv
expr_stmt|;
name|mach64_do_cleanup_dma
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|dev_priv
operator|->
name|fb
operator|=
name|drm_core_findmap
argument_list|(
name|dev
argument_list|,
name|init
operator|->
name|fb_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dev_priv
operator|->
name|fb
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"can not find frame buffer map!\n"
argument_list|)
expr_stmt|;
name|dev
operator|->
name|dev_private
operator|=
operator|(
name|void
operator|*
operator|)
name|dev_priv
expr_stmt|;
name|mach64_do_cleanup_dma
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|dev_priv
operator|->
name|mmio
operator|=
name|drm_core_findmap
argument_list|(
name|dev
argument_list|,
name|init
operator|->
name|mmio_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dev_priv
operator|->
name|mmio
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"can not find mmio map!\n"
argument_list|)
expr_stmt|;
name|dev
operator|->
name|dev_private
operator|=
operator|(
name|void
operator|*
operator|)
name|dev_priv
expr_stmt|;
name|mach64_do_cleanup_dma
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|dev_priv
operator|->
name|ring_map
operator|=
name|drm_core_findmap
argument_list|(
name|dev
argument_list|,
name|init
operator|->
name|ring_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dev_priv
operator|->
name|ring_map
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"can not find ring map!\n"
argument_list|)
expr_stmt|;
name|dev
operator|->
name|dev_private
operator|=
operator|(
name|void
operator|*
operator|)
name|dev_priv
expr_stmt|;
name|mach64_do_cleanup_dma
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|dev_priv
operator|->
name|sarea_priv
operator|=
operator|(
name|drm_mach64_sarea_t
operator|*
operator|)
operator|(
operator|(
name|u8
operator|*
operator|)
name|dev_priv
operator|->
name|sarea
operator|->
name|virtual
operator|+
name|init
operator|->
name|sarea_priv_offset
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|dev_priv
operator|->
name|is_pci
condition|)
block|{
name|drm_core_ioremap
argument_list|(
name|dev_priv
operator|->
name|ring_map
argument_list|,
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dev_priv
operator|->
name|ring_map
operator|->
name|virtual
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"can not ioremap virtual address for"
literal|" descriptor ring\n"
argument_list|)
expr_stmt|;
name|dev
operator|->
name|dev_private
operator|=
operator|(
name|void
operator|*
operator|)
name|dev_priv
expr_stmt|;
name|mach64_do_cleanup_dma
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
block|}
name|dev
operator|->
name|agp_buffer_token
operator|=
name|init
operator|->
name|buffers_offset
expr_stmt|;
name|dev
operator|->
name|agp_buffer_map
operator|=
name|drm_core_findmap
argument_list|(
name|dev
argument_list|,
name|init
operator|->
name|buffers_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dev
operator|->
name|agp_buffer_map
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"can not find dma buffer map!\n"
argument_list|)
expr_stmt|;
name|dev
operator|->
name|dev_private
operator|=
operator|(
name|void
operator|*
operator|)
name|dev_priv
expr_stmt|;
name|mach64_do_cleanup_dma
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
comment|/* there might be a nicer way to do this - 		   dev isn't passed all the way though the mach64 - DA */
name|dev_priv
operator|->
name|dev_buffers
operator|=
name|dev
operator|->
name|agp_buffer_map
expr_stmt|;
name|drm_core_ioremap
argument_list|(
name|dev
operator|->
name|agp_buffer_map
argument_list|,
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dev
operator|->
name|agp_buffer_map
operator|->
name|virtual
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"can not ioremap virtual address for"
literal|" dma buffer\n"
argument_list|)
expr_stmt|;
name|dev
operator|->
name|dev_private
operator|=
operator|(
name|void
operator|*
operator|)
name|dev_priv
expr_stmt|;
name|mach64_do_cleanup_dma
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
block|}
name|dev_priv
operator|->
name|agp_textures
operator|=
name|drm_core_findmap
argument_list|(
name|dev
argument_list|,
name|init
operator|->
name|agp_textures_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dev_priv
operator|->
name|agp_textures
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"can not find agp texture region!\n"
argument_list|)
expr_stmt|;
name|dev
operator|->
name|dev_private
operator|=
operator|(
name|void
operator|*
operator|)
name|dev_priv
expr_stmt|;
name|mach64_do_cleanup_dma
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
block|}
name|dev
operator|->
name|dev_private
operator|=
operator|(
name|void
operator|*
operator|)
name|dev_priv
expr_stmt|;
name|dev_priv
operator|->
name|driver_mode
operator|=
name|init
operator|->
name|dma_mode
expr_stmt|;
comment|/* changing the FIFO size from the default causes problems with DMA */
name|tmp
operator|=
name|MACH64_READ
argument_list|(
name|MACH64_GUI_CNTL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tmp
operator|&
name|MACH64_CMDFIFO_SIZE_MASK
operator|)
operator|!=
name|MACH64_CMDFIFO_SIZE_128
condition|)
block|{
name|DRM_INFO
argument_list|(
literal|"Setting FIFO size to 128 entries\n"
argument_list|)
expr_stmt|;
comment|/* FIFO must be empty to change the FIFO depth */
if|if
condition|(
operator|(
name|ret
operator|=
name|mach64_do_wait_for_idle
argument_list|(
name|dev_priv
argument_list|)
operator|)
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"wait for idle failed before changing FIFO depth!\n"
argument_list|)
expr_stmt|;
name|mach64_do_cleanup_dma
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|MACH64_WRITE
argument_list|(
name|MACH64_GUI_CNTL
argument_list|,
operator|(
operator|(
name|tmp
operator|&
operator|~
name|MACH64_CMDFIFO_SIZE_MASK
operator|)
operator||
name|MACH64_CMDFIFO_SIZE_128
operator|)
argument_list|)
expr_stmt|;
comment|/* need to read GUI_STAT for proper sync according to docs */
if|if
condition|(
operator|(
name|ret
operator|=
name|mach64_do_wait_for_idle
argument_list|(
name|dev_priv
argument_list|)
operator|)
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"wait for idle failed when changing FIFO depth!\n"
argument_list|)
expr_stmt|;
name|mach64_do_cleanup_dma
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
block|}
name|dev_priv
operator|->
name|ring
operator|.
name|size
operator|=
literal|0x4000
expr_stmt|;
comment|/* 16KB */
name|dev_priv
operator|->
name|ring
operator|.
name|start
operator|=
name|dev_priv
operator|->
name|ring_map
operator|->
name|virtual
expr_stmt|;
name|dev_priv
operator|->
name|ring
operator|.
name|start_addr
operator|=
operator|(
name|u32
operator|)
name|dev_priv
operator|->
name|ring_map
operator|->
name|offset
expr_stmt|;
name|memset
argument_list|(
name|dev_priv
operator|->
name|ring
operator|.
name|start
argument_list|,
literal|0
argument_list|,
name|dev_priv
operator|->
name|ring
operator|.
name|size
argument_list|)
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|"descriptor ring: cpu addr %p, bus addr: 0x%08x\n"
argument_list|,
name|dev_priv
operator|->
name|ring
operator|.
name|start
argument_list|,
name|dev_priv
operator|->
name|ring
operator|.
name|start_addr
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|driver_mode
operator|!=
name|MACH64_MODE_MMIO
condition|)
block|{
comment|/* enable block 1 registers and bus mastering */
name|MACH64_WRITE
argument_list|(
name|MACH64_BUS_CNTL
argument_list|,
operator|(
operator|(
name|MACH64_READ
argument_list|(
name|MACH64_BUS_CNTL
argument_list|)
operator||
name|MACH64_BUS_EXT_REG_EN
operator|)
operator|&
operator|~
name|MACH64_BUS_MASTER_DIS
operator|)
argument_list|)
expr_stmt|;
comment|/* try a DMA GUI-mastering pass and fall back to MMIO if it fails */
name|DRM_DEBUG
argument_list|(
literal|"Starting DMA test...\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|mach64_bm_dma_test
argument_list|(
name|dev
argument_list|)
operator|)
condition|)
block|{
name|dev_priv
operator|->
name|driver_mode
operator|=
name|MACH64_MODE_MMIO
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|dev_priv
operator|->
name|driver_mode
condition|)
block|{
case|case
name|MACH64_MODE_MMIO
case|:
name|MACH64_WRITE
argument_list|(
name|MACH64_BUS_CNTL
argument_list|,
operator|(
name|MACH64_READ
argument_list|(
name|MACH64_BUS_CNTL
argument_list|)
operator||
name|MACH64_BUS_EXT_REG_EN
operator||
name|MACH64_BUS_MASTER_DIS
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|init
operator|->
name|dma_mode
operator|==
name|MACH64_MODE_MMIO
condition|)
name|DRM_INFO
argument_list|(
literal|"Forcing pseudo-DMA mode\n"
argument_list|)
expr_stmt|;
else|else
name|DRM_INFO
argument_list|(
literal|"DMA test failed (ret=%d), using pseudo-DMA mode\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
break|break;
case|case
name|MACH64_MODE_DMA_SYNC
case|:
name|DRM_INFO
argument_list|(
literal|"DMA test succeeded, using synchronous DMA mode\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MACH64_MODE_DMA_ASYNC
case|:
default|default:
name|DRM_INFO
argument_list|(
literal|"DMA test succeeded, using asynchronous DMA mode\n"
argument_list|)
expr_stmt|;
block|}
name|dev_priv
operator|->
name|ring_running
operator|=
literal|0
expr_stmt|;
comment|/* setup offsets for physical address of table start and end */
name|dev_priv
operator|->
name|ring
operator|.
name|head_addr
operator|=
name|dev_priv
operator|->
name|ring
operator|.
name|start_addr
expr_stmt|;
name|dev_priv
operator|->
name|ring
operator|.
name|head
operator|=
name|dev_priv
operator|->
name|ring
operator|.
name|tail
operator|=
literal|0
expr_stmt|;
name|dev_priv
operator|->
name|ring
operator|.
name|tail_mask
operator|=
operator|(
name|dev_priv
operator|->
name|ring
operator|.
name|size
operator|/
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
operator|)
operator|-
literal|1
expr_stmt|;
name|dev_priv
operator|->
name|ring
operator|.
name|space
operator|=
name|dev_priv
operator|->
name|ring
operator|.
name|size
expr_stmt|;
comment|/* setup physical address and size of descriptor table */
name|mach64_do_wait_for_fifo
argument_list|(
name|dev_priv
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|MACH64_WRITE
argument_list|(
name|MACH64_BM_GUI_TABLE_CMD
argument_list|,
operator|(
name|dev_priv
operator|->
name|ring
operator|.
name|head_addr
operator||
name|MACH64_CIRCULAR_BUF_SIZE_16KB
operator|)
argument_list|)
expr_stmt|;
comment|/* init frame counter */
name|dev_priv
operator|->
name|sarea_priv
operator|->
name|frames_queued
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MACH64_MAX_QUEUED_FRAMES
condition|;
name|i
operator|++
control|)
block|{
name|dev_priv
operator|->
name|frame_ofs
index|[
name|i
index|]
operator|=
operator|~
literal|0
expr_stmt|;
comment|/* All ones indicates placeholder */
block|}
comment|/* Allocate the DMA buffer freelist */
if|if
condition|(
operator|(
name|ret
operator|=
name|mach64_init_freelist
argument_list|(
name|dev
argument_list|)
operator|)
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Freelist allocation failed\n"
argument_list|)
expr_stmt|;
name|mach64_do_cleanup_dma
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************/
end_comment

begin_comment
comment|/** MMIO Pseudo-DMA (intended primarily for debugging, not performance)  */
end_comment

begin_function
name|int
name|mach64_do_dispatch_pseudo_dma
parameter_list|(
name|drm_mach64_private_t
modifier|*
name|dev_priv
parameter_list|)
block|{
name|drm_mach64_descriptor_ring_t
modifier|*
name|ring
init|=
operator|&
name|dev_priv
operator|->
name|ring
decl_stmt|;
specifier|volatile
name|u32
modifier|*
name|ring_read
decl_stmt|;
name|struct
name|list_head
modifier|*
name|ptr
decl_stmt|;
name|drm_mach64_freelist_t
modifier|*
name|entry
decl_stmt|;
name|struct
name|drm_buf
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
name|u32
modifier|*
name|buf_ptr
decl_stmt|;
name|u32
name|used
decl_stmt|,
name|reg
decl_stmt|,
name|target
decl_stmt|;
name|int
name|fifo
decl_stmt|,
name|count
decl_stmt|,
name|found
decl_stmt|,
name|ret
decl_stmt|,
name|no_idle_wait
decl_stmt|;
name|fifo
operator|=
name|count
operator|=
name|reg
operator|=
name|no_idle_wait
operator|=
literal|0
expr_stmt|;
name|target
operator|=
name|MACH64_BM_ADDR
expr_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|mach64_do_wait_for_idle
argument_list|(
name|dev_priv
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|DRM_INFO
argument_list|(
literal|"idle failed before pseudo-dma dispatch, resetting engine\n"
argument_list|)
expr_stmt|;
name|mach64_dump_engine_info
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
name|mach64_do_engine_reset
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|ring_read
operator|=
operator|(
name|u32
operator|*
operator|)
name|ring
operator|->
name|start
expr_stmt|;
while|while
condition|(
name|ring
operator|->
name|tail
operator|!=
name|ring
operator|->
name|head
condition|)
block|{
name|u32
name|buf_addr
decl_stmt|,
name|new_target
decl_stmt|,
name|offset
decl_stmt|;
name|u32
name|bytes
decl_stmt|,
name|remaining
decl_stmt|,
name|head
decl_stmt|,
name|eol
decl_stmt|;
name|head
operator|=
name|ring
operator|->
name|head
expr_stmt|;
name|new_target
operator|=
name|le32_to_cpu
argument_list|(
name|ring_read
index|[
name|head
operator|++
index|]
argument_list|)
operator|-
name|MACH64_APERTURE_OFFSET
expr_stmt|;
name|buf_addr
operator|=
name|le32_to_cpu
argument_list|(
name|ring_read
index|[
name|head
operator|++
index|]
argument_list|)
expr_stmt|;
name|eol
operator|=
name|le32_to_cpu
argument_list|(
name|ring_read
index|[
name|head
index|]
argument_list|)
operator|&
name|MACH64_DMA_EOL
expr_stmt|;
name|bytes
operator|=
name|le32_to_cpu
argument_list|(
name|ring_read
index|[
name|head
operator|++
index|]
argument_list|)
operator|&
operator|~
operator|(
name|MACH64_DMA_HOLD_OFFSET
operator||
name|MACH64_DMA_EOL
operator|)
expr_stmt|;
name|head
operator|++
expr_stmt|;
name|head
operator|&=
name|ring
operator|->
name|tail_mask
expr_stmt|;
comment|/* can't wait for idle between a blit setup descriptor 		 * and a HOSTDATA descriptor or the engine will lock 		 */
if|if
condition|(
name|new_target
operator|==
name|MACH64_BM_HOSTDATA
operator|&&
name|target
operator|==
name|MACH64_BM_ADDR
condition|)
name|no_idle_wait
operator|=
literal|1
expr_stmt|;
name|target
operator|=
name|new_target
expr_stmt|;
name|found
operator|=
literal|0
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
name|list_for_each
argument_list|(
argument|ptr
argument_list|,
argument|&dev_priv->pending
argument_list|)
block|{
name|entry
operator|=
name|list_entry
argument_list|(
name|ptr
argument_list|,
name|drm_mach64_freelist_t
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|buf
operator|=
name|entry
operator|->
name|buf
expr_stmt|;
name|offset
operator|=
name|buf_addr
operator|-
name|GETBUFADDR
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|<
name|MACH64_BUFFER_SIZE
condition|)
block|{
name|found
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|found
operator|||
name|buf
operator|==
name|NULL
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Couldn't find pending buffer: head: %u tail: %u buf_addr: 0x%08x %s\n"
argument_list|,
name|head
argument_list|,
name|ring
operator|->
name|tail
argument_list|,
name|buf_addr
argument_list|,
operator|(
name|eol
condition|?
literal|"eol"
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
name|mach64_dump_ring_info
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
name|mach64_do_engine_reset
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
comment|/* Hand feed the buffer to the card via MMIO, waiting for the fifo 		 * every 16 writes 		 */
name|DRM_DEBUG
argument_list|(
literal|"target: (0x%08x) %s\n"
argument_list|,
name|target
argument_list|,
operator|(
name|target
operator|==
name|MACH64_BM_HOSTDATA
condition|?
literal|"BM_HOSTDATA"
else|:
literal|"BM_ADDR"
operator|)
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"offset: %u bytes: %u used: %u\n"
argument_list|,
name|offset
argument_list|,
name|bytes
argument_list|,
name|buf
operator|->
name|used
argument_list|)
expr_stmt|;
name|remaining
operator|=
operator|(
name|buf
operator|->
name|used
operator|-
name|offset
operator|)
operator|>>
literal|2
expr_stmt|;
comment|/* dwords remaining in buffer */
name|used
operator|=
name|bytes
operator|>>
literal|2
expr_stmt|;
comment|/* dwords in buffer for this descriptor */
name|buf_ptr
operator|=
operator|(
name|u32
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|GETBUFPTR
argument_list|(
name|buf
argument_list|)
operator|+
name|offset
operator|)
expr_stmt|;
while|while
condition|(
name|used
condition|)
block|{
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|target
operator|==
name|MACH64_BM_HOSTDATA
condition|)
block|{
name|reg
operator|=
name|DMAREG
argument_list|(
name|MACH64_HOST_DATA0
argument_list|)
expr_stmt|;
name|count
operator|=
operator|(
name|remaining
operator|>
literal|16
operator|)
condition|?
literal|16
else|:
name|remaining
expr_stmt|;
name|fifo
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|reg
operator|=
name|le32_to_cpu
argument_list|(
operator|*
name|buf_ptr
operator|++
argument_list|)
expr_stmt|;
name|used
operator|--
expr_stmt|;
name|count
operator|=
operator|(
name|reg
operator|>>
literal|16
operator|)
operator|+
literal|1
expr_stmt|;
block|}
name|reg
operator|=
name|reg
operator|&
literal|0xffff
expr_stmt|;
name|reg
operator|=
name|MMSELECT
argument_list|(
name|reg
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|count
operator|&&
name|used
condition|)
block|{
if|if
condition|(
operator|!
name|fifo
condition|)
block|{
if|if
condition|(
name|no_idle_wait
condition|)
block|{
if|if
condition|(
operator|(
name|ret
operator|=
name|mach64_do_wait_for_fifo
argument_list|(
name|dev_priv
argument_list|,
literal|16
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|no_idle_wait
operator|=
literal|0
expr_stmt|;
return|return
name|ret
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|ret
operator|=
name|mach64_do_wait_for_idle
argument_list|(
name|dev_priv
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
return|return
name|ret
return|;
block|}
block|}
name|fifo
operator|=
literal|16
expr_stmt|;
block|}
operator|--
name|fifo
expr_stmt|;
name|MACH64_WRITE
argument_list|(
name|reg
argument_list|,
name|le32_to_cpu
argument_list|(
operator|*
name|buf_ptr
operator|++
argument_list|)
argument_list|)
expr_stmt|;
name|used
operator|--
expr_stmt|;
name|remaining
operator|--
expr_stmt|;
name|reg
operator|+=
literal|4
expr_stmt|;
name|count
operator|--
expr_stmt|;
block|}
block|}
name|ring
operator|->
name|head
operator|=
name|head
expr_stmt|;
name|ring
operator|->
name|head_addr
operator|=
name|ring
operator|->
name|start_addr
operator|+
operator|(
name|ring
operator|->
name|head
operator|*
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
operator|)
expr_stmt|;
name|ring
operator|->
name|space
operator|+=
operator|(
literal|4
operator|*
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ret
operator|=
name|mach64_do_wait_for_idle
argument_list|(
name|dev_priv
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
return|return
name|ret
return|;
block|}
name|MACH64_WRITE
argument_list|(
name|MACH64_BM_GUI_TABLE_CMD
argument_list|,
name|ring
operator|->
name|head_addr
operator||
name|MACH64_CIRCULAR_BUF_SIZE_16KB
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"completed\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*@}*/
end_comment

begin_comment
comment|/*******************************************************************/
end_comment

begin_comment
comment|/** \name DMA cleanup */
end_comment

begin_comment
comment|/*@{*/
end_comment

begin_function
name|int
name|mach64_do_cleanup_dma
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* Make sure interrupts are disabled here because the uninstall ioctl 	 * may not have been called from userspace and after dev_private 	 * is freed, it's too late. 	 */
if|if
condition|(
name|dev
operator|->
name|irq
condition|)
name|drm_irq_uninstall
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|dev_private
condition|)
block|{
name|drm_mach64_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
if|if
condition|(
operator|!
name|dev_priv
operator|->
name|is_pci
condition|)
block|{
if|if
condition|(
name|dev_priv
operator|->
name|ring_map
condition|)
name|drm_core_ioremapfree
argument_list|(
name|dev_priv
operator|->
name|ring_map
argument_list|,
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|agp_buffer_map
condition|)
block|{
name|drm_core_ioremapfree
argument_list|(
name|dev
operator|->
name|agp_buffer_map
argument_list|,
name|dev
argument_list|)
expr_stmt|;
name|dev
operator|->
name|agp_buffer_map
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|mach64_destroy_freelist
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|drm_free
argument_list|(
name|dev_priv
argument_list|,
sizeof|sizeof
argument_list|(
name|drm_mach64_private_t
argument_list|)
argument_list|,
name|DRM_MEM_DRIVER
argument_list|)
expr_stmt|;
name|dev
operator|->
name|dev_private
operator|=
name|NULL
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*@}*/
end_comment

begin_comment
comment|/*******************************************************************/
end_comment

begin_comment
comment|/** \name IOCTL handlers */
end_comment

begin_comment
comment|/*@{*/
end_comment

begin_function
name|int
name|mach64_dma_init
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
name|drm_mach64_init_t
modifier|*
name|init
init|=
name|data
decl_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|LOCK_TEST_WITH_RETURN
argument_list|(
name|dev
argument_list|,
name|file_priv
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|init
operator|->
name|func
condition|)
block|{
case|case
name|DRM_MACH64_INIT_DMA
case|:
return|return
name|mach64_do_dma_init
argument_list|(
name|dev
argument_list|,
name|init
argument_list|)
return|;
case|case
name|DRM_MACH64_CLEANUP_DMA
case|:
return|return
name|mach64_do_cleanup_dma
argument_list|(
name|dev
argument_list|)
return|;
block|}
return|return
operator|-
name|EINVAL
return|;
block|}
end_function

begin_function
name|int
name|mach64_dma_idle
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
name|drm_mach64_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|LOCK_TEST_WITH_RETURN
argument_list|(
name|dev
argument_list|,
name|file_priv
argument_list|)
expr_stmt|;
return|return
name|mach64_do_dma_idle
argument_list|(
name|dev_priv
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|mach64_dma_flush
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
name|drm_mach64_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|LOCK_TEST_WITH_RETURN
argument_list|(
name|dev
argument_list|,
name|file_priv
argument_list|)
expr_stmt|;
return|return
name|mach64_do_dma_flush
argument_list|(
name|dev_priv
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|mach64_engine_reset
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
name|drm_mach64_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|LOCK_TEST_WITH_RETURN
argument_list|(
name|dev
argument_list|,
name|file_priv
argument_list|)
expr_stmt|;
return|return
name|mach64_do_engine_reset
argument_list|(
name|dev_priv
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*@}*/
end_comment

begin_comment
comment|/*******************************************************************/
end_comment

begin_comment
comment|/** \name Freelist management */
end_comment

begin_comment
comment|/*@{*/
end_comment

begin_function
name|int
name|mach64_init_freelist
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_device_dma
modifier|*
name|dma
init|=
name|dev
operator|->
name|dma
decl_stmt|;
name|drm_mach64_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|drm_mach64_freelist_t
modifier|*
name|entry
decl_stmt|;
name|struct
name|list_head
modifier|*
name|ptr
decl_stmt|;
name|int
name|i
decl_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"adding %d buffers to freelist\n"
argument_list|,
name|dma
operator|->
name|buf_count
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dma
operator|->
name|buf_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|entry
operator|=
operator|(
name|drm_mach64_freelist_t
operator|*
operator|)
name|drm_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|drm_mach64_freelist_t
argument_list|)
argument_list|,
name|DRM_MEM_BUFLISTS
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|-
name|ENOMEM
return|;
name|memset
argument_list|(
name|entry
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|drm_mach64_freelist_t
argument_list|)
argument_list|)
expr_stmt|;
name|entry
operator|->
name|buf
operator|=
name|dma
operator|->
name|buflist
index|[
name|i
index|]
expr_stmt|;
name|ptr
operator|=
operator|&
name|entry
operator|->
name|list
expr_stmt|;
name|list_add_tail
argument_list|(
name|ptr
argument_list|,
operator|&
name|dev_priv
operator|->
name|free_list
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|mach64_destroy_freelist
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|drm_mach64_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|drm_mach64_freelist_t
modifier|*
name|entry
decl_stmt|;
name|struct
name|list_head
modifier|*
name|ptr
decl_stmt|;
name|struct
name|list_head
modifier|*
name|tmp
decl_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|list_for_each_safe
argument_list|(
argument|ptr
argument_list|,
argument|tmp
argument_list|,
argument|&dev_priv->pending
argument_list|)
block|{
name|list_del
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|entry
operator|=
name|list_entry
argument_list|(
name|ptr
argument_list|,
name|drm_mach64_freelist_t
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|drm_free
argument_list|(
name|entry
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|entry
argument_list|)
argument_list|,
name|DRM_MEM_BUFLISTS
argument_list|)
expr_stmt|;
block|}
name|list_for_each_safe
argument_list|(
argument|ptr
argument_list|,
argument|tmp
argument_list|,
argument|&dev_priv->placeholders
argument_list|)
block|{
name|list_del
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|entry
operator|=
name|list_entry
argument_list|(
name|ptr
argument_list|,
name|drm_mach64_freelist_t
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|drm_free
argument_list|(
name|entry
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|entry
argument_list|)
argument_list|,
name|DRM_MEM_BUFLISTS
argument_list|)
expr_stmt|;
block|}
name|list_for_each_safe
argument_list|(
argument|ptr
argument_list|,
argument|tmp
argument_list|,
argument|&dev_priv->free_list
argument_list|)
block|{
name|list_del
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|entry
operator|=
name|list_entry
argument_list|(
name|ptr
argument_list|,
name|drm_mach64_freelist_t
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|drm_free
argument_list|(
name|entry
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|entry
argument_list|)
argument_list|,
name|DRM_MEM_BUFLISTS
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* IMPORTANT: This function should only be called when the engine is idle or locked up,  * as it assumes all buffers in the pending list have been completed by the hardware.  */
end_comment

begin_function
name|int
name|mach64_do_release_used_buffers
parameter_list|(
name|drm_mach64_private_t
modifier|*
name|dev_priv
parameter_list|)
block|{
name|struct
name|list_head
modifier|*
name|ptr
decl_stmt|;
name|struct
name|list_head
modifier|*
name|tmp
decl_stmt|;
name|drm_mach64_freelist_t
modifier|*
name|entry
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|list_empty
argument_list|(
operator|&
name|dev_priv
operator|->
name|pending
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Iterate the pending list and move all buffers into the freelist... */
name|i
operator|=
literal|0
expr_stmt|;
name|list_for_each_safe
argument_list|(
argument|ptr
argument_list|,
argument|tmp
argument_list|,
argument|&dev_priv->pending
argument_list|)
block|{
name|entry
operator|=
name|list_entry
argument_list|(
name|ptr
argument_list|,
name|drm_mach64_freelist_t
argument_list|,
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|discard
condition|)
block|{
name|entry
operator|->
name|buf
operator|->
name|pending
operator|=
literal|0
expr_stmt|;
name|list_del
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|list_add_tail
argument_list|(
name|ptr
argument_list|,
operator|&
name|dev_priv
operator|->
name|free_list
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
block|}
name|DRM_DEBUG
argument_list|(
literal|"released %d buffers from pending list\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mach64_do_reclaim_completed
parameter_list|(
name|drm_mach64_private_t
modifier|*
name|dev_priv
parameter_list|)
block|{
name|drm_mach64_descriptor_ring_t
modifier|*
name|ring
init|=
operator|&
name|dev_priv
operator|->
name|ring
decl_stmt|;
name|struct
name|list_head
modifier|*
name|ptr
decl_stmt|;
name|struct
name|list_head
modifier|*
name|tmp
decl_stmt|;
name|drm_mach64_freelist_t
modifier|*
name|entry
decl_stmt|;
name|u32
name|head
decl_stmt|,
name|tail
decl_stmt|,
name|ofs
decl_stmt|;
name|mach64_ring_tick
argument_list|(
name|dev_priv
argument_list|,
name|ring
argument_list|)
expr_stmt|;
name|head
operator|=
name|ring
operator|->
name|head
expr_stmt|;
name|tail
operator|=
name|ring
operator|->
name|tail
expr_stmt|;
if|if
condition|(
name|head
operator|==
name|tail
condition|)
block|{
if|#
directive|if
name|MACH64_EXTRA_CHECKING
if|if
condition|(
name|MACH64_READ
argument_list|(
name|MACH64_GUI_STAT
argument_list|)
operator|&
name|MACH64_GUI_ACTIVE
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Empty ring with non-idle engine!\n"
argument_list|)
expr_stmt|;
name|mach64_dump_ring_info
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
endif|#
directive|endif
comment|/* last pass is complete, so release everything */
name|mach64_do_release_used_buffers
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"idle engine, freed all buffers.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|list_empty
argument_list|(
operator|&
name|dev_priv
operator|->
name|free_list
argument_list|)
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Freelist empty with idle engine\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
comment|/* Look for a completed buffer and bail out of the loop 	 * as soon as we find one -- don't waste time trying 	 * to free extra bufs here, leave that to do_release_used_buffers 	 */
name|list_for_each_safe
argument_list|(
argument|ptr
argument_list|,
argument|tmp
argument_list|,
argument|&dev_priv->pending
argument_list|)
block|{
name|entry
operator|=
name|list_entry
argument_list|(
name|ptr
argument_list|,
name|drm_mach64_freelist_t
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|ofs
operator|=
name|entry
operator|->
name|ring_ofs
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|discard
operator|&&
operator|(
operator|(
name|head
operator|<
name|tail
operator|&&
operator|(
name|ofs
operator|<
name|head
operator|||
name|ofs
operator|>=
name|tail
operator|)
operator|)
operator|||
operator|(
name|head
operator|>
name|tail
operator|&&
operator|(
name|ofs
operator|<
name|head
operator|&&
name|ofs
operator|>=
name|tail
operator|)
operator|)
operator|)
condition|)
block|{
if|#
directive|if
name|MACH64_EXTRA_CHECKING
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|head
init|;
name|i
operator|!=
name|tail
condition|;
name|i
operator|=
operator|(
name|i
operator|+
literal|4
operator|)
operator|&
name|ring
operator|->
name|tail_mask
control|)
block|{
name|u32
name|o1
init|=
name|le32_to_cpu
argument_list|(
operator|(
operator|(
name|u32
operator|*
operator|)
name|ring
operator|->
name|start
operator|)
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
decl_stmt|;
name|u32
name|o2
init|=
name|GETBUFADDR
argument_list|(
name|entry
operator|->
name|buf
argument_list|)
decl_stmt|;
if|if
condition|(
name|o1
operator|==
name|o2
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Attempting to free used buffer: "
literal|"i=%d  buf=0x%08x\n"
argument_list|,
name|i
argument_list|,
name|o1
argument_list|)
expr_stmt|;
name|mach64_dump_ring_info
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
endif|#
directive|endif
comment|/* found a processed buffer */
name|entry
operator|->
name|buf
operator|->
name|pending
operator|=
literal|0
expr_stmt|;
name|list_del
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|list_add_tail
argument_list|(
name|ptr
argument_list|,
operator|&
name|dev_priv
operator|->
name|free_list
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"freed processed buffer (head=%d tail=%d "
literal|"buf ring ofs=%d).\n"
argument_list|,
name|head
argument_list|,
name|tail
argument_list|,
name|ofs
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|struct
name|drm_buf
modifier|*
name|mach64_freelist_get
parameter_list|(
name|drm_mach64_private_t
modifier|*
name|dev_priv
parameter_list|)
block|{
name|drm_mach64_descriptor_ring_t
modifier|*
name|ring
init|=
operator|&
name|dev_priv
operator|->
name|ring
decl_stmt|;
name|drm_mach64_freelist_t
modifier|*
name|entry
decl_stmt|;
name|struct
name|list_head
modifier|*
name|ptr
decl_stmt|;
name|int
name|t
decl_stmt|;
if|if
condition|(
name|list_empty
argument_list|(
operator|&
name|dev_priv
operator|->
name|free_list
argument_list|)
condition|)
block|{
if|if
condition|(
name|list_empty
argument_list|(
operator|&
name|dev_priv
operator|->
name|pending
argument_list|)
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Couldn't get buffer - pending and free lists empty\n"
argument_list|)
expr_stmt|;
name|t
operator|=
literal|0
expr_stmt|;
name|list_for_each
argument_list|(
argument|ptr
argument_list|,
argument|&dev_priv->placeholders
argument_list|)
block|{
name|t
operator|++
expr_stmt|;
block|}
name|DRM_INFO
argument_list|(
literal|"Placeholders: %d\n"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
for|for
control|(
name|t
operator|=
literal|0
init|;
name|t
operator|<
name|dev_priv
operator|->
name|usec_timeout
condition|;
name|t
operator|++
control|)
block|{
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|mach64_do_reclaim_completed
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
goto|goto
name|_freelist_entry_found
goto|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
return|return
name|NULL
return|;
name|DRM_UDELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|mach64_dump_ring_info
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
name|DRM_ERROR
argument_list|(
literal|"timeout waiting for buffers: ring head_addr: 0x%08x head: %d tail: %d\n"
argument_list|,
name|ring
operator|->
name|head_addr
argument_list|,
name|ring
operator|->
name|head
argument_list|,
name|ring
operator|->
name|tail
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|_freelist_entry_found
label|:
name|ptr
operator|=
name|dev_priv
operator|->
name|free_list
operator|.
name|next
expr_stmt|;
name|list_del
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|entry
operator|=
name|list_entry
argument_list|(
name|ptr
argument_list|,
name|drm_mach64_freelist_t
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|entry
operator|->
name|buf
operator|->
name|used
operator|=
literal|0
expr_stmt|;
name|list_add_tail
argument_list|(
name|ptr
argument_list|,
operator|&
name|dev_priv
operator|->
name|placeholders
argument_list|)
expr_stmt|;
return|return
name|entry
operator|->
name|buf
return|;
block|}
end_function

begin_function
name|int
name|mach64_freelist_put
parameter_list|(
name|drm_mach64_private_t
modifier|*
name|dev_priv
parameter_list|,
name|struct
name|drm_buf
modifier|*
name|copy_buf
parameter_list|)
block|{
name|struct
name|list_head
modifier|*
name|ptr
decl_stmt|;
name|drm_mach64_freelist_t
modifier|*
name|entry
decl_stmt|;
if|#
directive|if
name|MACH64_EXTRA_CHECKING
name|list_for_each
argument_list|(
argument|ptr
argument_list|,
argument|&dev_priv->pending
argument_list|)
block|{
name|entry
operator|=
name|list_entry
argument_list|(
name|ptr
argument_list|,
name|drm_mach64_freelist_t
argument_list|,
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
name|copy_buf
operator|==
name|entry
operator|->
name|buf
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Trying to release a pending buf\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EFAULT
return|;
block|}
block|}
endif|#
directive|endif
name|ptr
operator|=
name|dev_priv
operator|->
name|placeholders
operator|.
name|next
expr_stmt|;
name|entry
operator|=
name|list_entry
argument_list|(
name|ptr
argument_list|,
name|drm_mach64_freelist_t
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|copy_buf
operator|->
name|pending
operator|=
literal|0
expr_stmt|;
name|copy_buf
operator|->
name|used
operator|=
literal|0
expr_stmt|;
name|entry
operator|->
name|buf
operator|=
name|copy_buf
expr_stmt|;
name|entry
operator|->
name|discard
operator|=
literal|1
expr_stmt|;
name|list_del
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|list_add_tail
argument_list|(
name|ptr
argument_list|,
operator|&
name|dev_priv
operator|->
name|free_list
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*@}*/
end_comment

begin_comment
comment|/*******************************************************************/
end_comment

begin_comment
comment|/** \name DMA buffer request and submission IOCTL handler */
end_comment

begin_comment
comment|/*@{*/
end_comment

begin_function
specifier|static
name|int
name|mach64_dma_get_buffers
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|,
name|struct
name|drm_dma
modifier|*
name|d
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|drm_buf
modifier|*
name|buf
decl_stmt|;
name|drm_mach64_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
for|for
control|(
name|i
operator|=
name|d
operator|->
name|granted_count
init|;
name|i
operator|<
name|d
operator|->
name|request_count
condition|;
name|i
operator|++
control|)
block|{
name|buf
operator|=
name|mach64_freelist_get
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
if|#
directive|if
name|MACH64_EXTRA_CHECKING
if|if
condition|(
operator|!
name|buf
condition|)
return|return
operator|-
name|EFAULT
return|;
else|#
directive|else
if|if
condition|(
operator|!
name|buf
condition|)
return|return
operator|-
name|EAGAIN
return|;
endif|#
directive|endif
name|buf
operator|->
name|file_priv
operator|=
name|file_priv
expr_stmt|;
if|if
condition|(
name|DRM_COPY_TO_USER
argument_list|(
operator|&
name|d
operator|->
name|request_indices
index|[
name|i
index|]
argument_list|,
operator|&
name|buf
operator|->
name|idx
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
operator|->
name|idx
argument_list|)
argument_list|)
condition|)
return|return
operator|-
name|EFAULT
return|;
if|if
condition|(
name|DRM_COPY_TO_USER
argument_list|(
operator|&
name|d
operator|->
name|request_sizes
index|[
name|i
index|]
argument_list|,
operator|&
name|buf
operator|->
name|total
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
operator|->
name|total
argument_list|)
argument_list|)
condition|)
return|return
operator|-
name|EFAULT
return|;
name|d
operator|->
name|granted_count
operator|++
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|mach64_dma_buffers
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
name|struct
name|drm_device_dma
modifier|*
name|dma
init|=
name|dev
operator|->
name|dma
decl_stmt|;
name|struct
name|drm_dma
modifier|*
name|d
init|=
name|data
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|LOCK_TEST_WITH_RETURN
argument_list|(
name|dev
argument_list|,
name|file_priv
argument_list|)
expr_stmt|;
comment|/* Please don't send us buffers. 	 */
if|if
condition|(
name|d
operator|->
name|send_count
operator|!=
literal|0
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Process %d trying to send %d buffers via drmDMA\n"
argument_list|,
name|DRM_CURRENTPID
argument_list|,
name|d
operator|->
name|send_count
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
comment|/* We'll send you buffers. 	 */
if|if
condition|(
name|d
operator|->
name|request_count
operator|<
literal|0
operator|||
name|d
operator|->
name|request_count
operator|>
name|dma
operator|->
name|buf_count
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Process %d trying to get %d buffers (of %d max)\n"
argument_list|,
name|DRM_CURRENTPID
argument_list|,
name|d
operator|->
name|request_count
argument_list|,
name|dma
operator|->
name|buf_count
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
name|EINVAL
expr_stmt|;
block|}
name|d
operator|->
name|granted_count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|request_count
condition|)
block|{
name|ret
operator|=
name|mach64_dma_get_buffers
argument_list|(
name|dev
argument_list|,
name|file_priv
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
name|void
name|mach64_driver_lastclose
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|mach64_do_cleanup_dma
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*@}*/
end_comment

end_unit

