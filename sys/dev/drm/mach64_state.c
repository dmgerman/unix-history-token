begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* mach64_state.c -- State support for mach64 (Rage Pro) driver -*- linux-c -*-  * Created: Sun Dec 03 19:20:26 2000 by gareth@valinux.com  */
end_comment

begin_comment
comment|/*-  * Copyright 2000 Gareth Hughes  * Copyright 2002-2003 Leif Delgass  * All Rights Reserved.  *  * Permission is hereby granted, free of charge, to any person obtaining a  * copy of this software and associated documentation files (the "Software"),  * to deal in the Software without restriction, including without limitation  * the rights to use, copy, modify, merge, publish, distribute, sublicense,  * and/or sell copies of the Software, and to permit persons to whom the  * Software is furnished to do so, subject to the following conditions:  *  * The above copyright notice and this permission notice (including the next  * paragraph) shall be included in all copies or substantial portions of the  * Software.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL  * THE COPYRIGHT OWNER(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER  * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  *  * Authors:  *    Gareth Hughes<gareth@valinux.com>  *    Leif Delgass<ldelgass@retinalburn.net>  *    JosÃ© Fonseca<j_r_fonseca@yahoo.co.uk>  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"dev/drm/drmP.h"
end_include

begin_include
include|#
directive|include
file|"dev/drm/drm.h"
end_include

begin_include
include|#
directive|include
file|"dev/drm/mach64_drm.h"
end_include

begin_include
include|#
directive|include
file|"dev/drm/mach64_drv.h"
end_include

begin_comment
comment|/* Interface history:  *  * 1.0 - Initial mach64 DRM  *  */
end_comment

begin_decl_stmt
name|struct
name|drm_ioctl_desc
name|mach64_ioctls
index|[]
init|=
block|{
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_MACH64_INIT
argument_list|,
name|mach64_dma_init
argument_list|,
name|DRM_AUTH
operator||
name|DRM_MASTER
operator||
name|DRM_ROOT_ONLY
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_MACH64_CLEAR
argument_list|,
name|mach64_dma_clear
argument_list|,
name|DRM_AUTH
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_MACH64_SWAP
argument_list|,
name|mach64_dma_swap
argument_list|,
name|DRM_AUTH
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_MACH64_IDLE
argument_list|,
name|mach64_dma_idle
argument_list|,
name|DRM_AUTH
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_MACH64_RESET
argument_list|,
name|mach64_engine_reset
argument_list|,
name|DRM_AUTH
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_MACH64_VERTEX
argument_list|,
name|mach64_dma_vertex
argument_list|,
name|DRM_AUTH
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_MACH64_BLIT
argument_list|,
name|mach64_dma_blit
argument_list|,
name|DRM_AUTH
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_MACH64_FLUSH
argument_list|,
name|mach64_dma_flush
argument_list|,
name|DRM_AUTH
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_MACH64_GETPARAM
argument_list|,
name|mach64_get_param
argument_list|,
name|DRM_AUTH
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|mach64_max_ioctl
init|=
name|DRM_ARRAY_SIZE
argument_list|(
name|mach64_ioctls
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ================================================================  * DMA hardware state programming functions  */
end_comment

begin_function
specifier|static
name|void
name|mach64_print_dirty
parameter_list|(
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
name|unsigned
name|int
name|flags
parameter_list|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"%s: (0x%x) %s%s%s%s%s%s%s%s%s%s%s%s\n"
argument_list|,
name|msg
argument_list|,
name|flags
argument_list|,
operator|(
name|flags
operator|&
name|MACH64_UPLOAD_DST_OFF_PITCH
operator|)
condition|?
literal|"dst_off_pitch, "
else|:
literal|""
argument_list|,
operator|(
name|flags
operator|&
name|MACH64_UPLOAD_Z_ALPHA_CNTL
operator|)
condition|?
literal|"z_alpha_cntl, "
else|:
literal|""
argument_list|,
operator|(
name|flags
operator|&
name|MACH64_UPLOAD_SCALE_3D_CNTL
operator|)
condition|?
literal|"scale_3d_cntl, "
else|:
literal|""
argument_list|,
operator|(
name|flags
operator|&
name|MACH64_UPLOAD_DP_FOG_CLR
operator|)
condition|?
literal|"dp_fog_clr, "
else|:
literal|""
argument_list|,
operator|(
name|flags
operator|&
name|MACH64_UPLOAD_DP_WRITE_MASK
operator|)
condition|?
literal|"dp_write_mask, "
else|:
literal|""
argument_list|,
operator|(
name|flags
operator|&
name|MACH64_UPLOAD_DP_PIX_WIDTH
operator|)
condition|?
literal|"dp_pix_width, "
else|:
literal|""
argument_list|,
operator|(
name|flags
operator|&
name|MACH64_UPLOAD_SETUP_CNTL
operator|)
condition|?
literal|"setup_cntl, "
else|:
literal|""
argument_list|,
operator|(
name|flags
operator|&
name|MACH64_UPLOAD_MISC
operator|)
condition|?
literal|"misc, "
else|:
literal|""
argument_list|,
operator|(
name|flags
operator|&
name|MACH64_UPLOAD_TEXTURE
operator|)
condition|?
literal|"texture, "
else|:
literal|""
argument_list|,
operator|(
name|flags
operator|&
name|MACH64_UPLOAD_TEX0IMAGE
operator|)
condition|?
literal|"tex0 image, "
else|:
literal|""
argument_list|,
operator|(
name|flags
operator|&
name|MACH64_UPLOAD_TEX1IMAGE
operator|)
condition|?
literal|"tex1 image, "
else|:
literal|""
argument_list|,
operator|(
name|flags
operator|&
name|MACH64_UPLOAD_CLIPRECTS
operator|)
condition|?
literal|"cliprects, "
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Mach64 doesn't have hardware cliprects, just one hardware scissor,  * so the GL scissor is intersected with each cliprect here  */
end_comment

begin_comment
comment|/* This function returns 0 on success, 1 for no intersection, and  * negative for an error  */
end_comment

begin_function
specifier|static
name|int
name|mach64_emit_cliprect
parameter_list|(
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|,
name|drm_mach64_private_t
modifier|*
name|dev_priv
parameter_list|,
name|struct
name|drm_clip_rect
modifier|*
name|box
parameter_list|)
block|{
name|u32
name|sc_left_right
decl_stmt|,
name|sc_top_bottom
decl_stmt|;
name|struct
name|drm_clip_rect
name|scissor
decl_stmt|;
name|drm_mach64_sarea_t
modifier|*
name|sarea_priv
init|=
name|dev_priv
operator|->
name|sarea_priv
decl_stmt|;
name|drm_mach64_context_regs_t
modifier|*
name|regs
init|=
operator|&
name|sarea_priv
operator|->
name|context_state
decl_stmt|;
name|DMALOCALS
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"box=%p\n"
argument_list|,
name|box
argument_list|)
expr_stmt|;
comment|/* Get GL scissor */
comment|/* FIXME: store scissor in SAREA as a cliprect instead of in 	 * hardware format, or do intersection client-side 	 */
name|scissor
operator|.
name|x1
operator|=
name|regs
operator|->
name|sc_left_right
operator|&
literal|0xffff
expr_stmt|;
name|scissor
operator|.
name|x2
operator|=
operator|(
name|regs
operator|->
name|sc_left_right
operator|&
literal|0xffff0000
operator|)
operator|>>
literal|16
expr_stmt|;
name|scissor
operator|.
name|y1
operator|=
name|regs
operator|->
name|sc_top_bottom
operator|&
literal|0xffff
expr_stmt|;
name|scissor
operator|.
name|y2
operator|=
operator|(
name|regs
operator|->
name|sc_top_bottom
operator|&
literal|0xffff0000
operator|)
operator|>>
literal|16
expr_stmt|;
comment|/* Intersect GL scissor with cliprect */
if|if
condition|(
name|box
operator|->
name|x1
operator|>
name|scissor
operator|.
name|x1
condition|)
name|scissor
operator|.
name|x1
operator|=
name|box
operator|->
name|x1
expr_stmt|;
if|if
condition|(
name|box
operator|->
name|y1
operator|>
name|scissor
operator|.
name|y1
condition|)
name|scissor
operator|.
name|y1
operator|=
name|box
operator|->
name|y1
expr_stmt|;
if|if
condition|(
name|box
operator|->
name|x2
operator|<
name|scissor
operator|.
name|x2
condition|)
name|scissor
operator|.
name|x2
operator|=
name|box
operator|->
name|x2
expr_stmt|;
if|if
condition|(
name|box
operator|->
name|y2
operator|<
name|scissor
operator|.
name|y2
condition|)
name|scissor
operator|.
name|y2
operator|=
name|box
operator|->
name|y2
expr_stmt|;
comment|/* positive return means skip */
if|if
condition|(
name|scissor
operator|.
name|x1
operator|>=
name|scissor
operator|.
name|x2
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|scissor
operator|.
name|y1
operator|>=
name|scissor
operator|.
name|y2
condition|)
return|return
literal|1
return|;
name|DMAGETPTR
argument_list|(
name|file_priv
argument_list|,
name|dev_priv
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* returns on failure to get buffer */
name|sc_left_right
operator|=
operator|(
operator|(
name|scissor
operator|.
name|x1
operator|<<
literal|0
operator|)
operator||
operator|(
name|scissor
operator|.
name|x2
operator|<<
literal|16
operator|)
operator|)
expr_stmt|;
name|sc_top_bottom
operator|=
operator|(
operator|(
name|scissor
operator|.
name|y1
operator|<<
literal|0
operator|)
operator||
operator|(
name|scissor
operator|.
name|y2
operator|<<
literal|16
operator|)
operator|)
expr_stmt|;
name|DMAOUTREG
argument_list|(
name|MACH64_SC_LEFT_RIGHT
argument_list|,
name|sc_left_right
argument_list|)
expr_stmt|;
name|DMAOUTREG
argument_list|(
name|MACH64_SC_TOP_BOTTOM
argument_list|,
name|sc_top_bottom
argument_list|)
expr_stmt|;
name|DMAADVANCE
argument_list|(
name|dev_priv
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|__inline__
name|int
name|mach64_emit_state
parameter_list|(
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|,
name|drm_mach64_private_t
modifier|*
name|dev_priv
parameter_list|)
block|{
name|drm_mach64_sarea_t
modifier|*
name|sarea_priv
init|=
name|dev_priv
operator|->
name|sarea_priv
decl_stmt|;
name|drm_mach64_context_regs_t
modifier|*
name|regs
init|=
operator|&
name|sarea_priv
operator|->
name|context_state
decl_stmt|;
name|unsigned
name|int
name|dirty
init|=
name|sarea_priv
operator|->
name|dirty
decl_stmt|;
name|u32
name|offset
init|=
operator|(
operator|(
name|regs
operator|->
name|tex_size_pitch
operator|&
literal|0xf0
operator|)
operator|>>
literal|2
operator|)
decl_stmt|;
name|DMALOCALS
expr_stmt|;
if|if
condition|(
name|MACH64_VERBOSE
condition|)
block|{
name|mach64_print_dirty
argument_list|(
name|__FUNCTION__
argument_list|,
name|dirty
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DRM_DEBUG
argument_list|(
literal|"dirty=0x%08x\n"
argument_list|,
name|dirty
argument_list|)
expr_stmt|;
block|}
name|DMAGETPTR
argument_list|(
name|file_priv
argument_list|,
name|dev_priv
argument_list|,
literal|17
argument_list|)
expr_stmt|;
comment|/* returns on failure to get buffer */
if|if
condition|(
name|dirty
operator|&
name|MACH64_UPLOAD_MISC
condition|)
block|{
name|DMAOUTREG
argument_list|(
name|MACH64_DP_MIX
argument_list|,
name|regs
operator|->
name|dp_mix
argument_list|)
expr_stmt|;
name|DMAOUTREG
argument_list|(
name|MACH64_DP_SRC
argument_list|,
name|regs
operator|->
name|dp_src
argument_list|)
expr_stmt|;
name|DMAOUTREG
argument_list|(
name|MACH64_CLR_CMP_CNTL
argument_list|,
name|regs
operator|->
name|clr_cmp_cntl
argument_list|)
expr_stmt|;
name|DMAOUTREG
argument_list|(
name|MACH64_GUI_TRAJ_CNTL
argument_list|,
name|regs
operator|->
name|gui_traj_cntl
argument_list|)
expr_stmt|;
name|sarea_priv
operator|->
name|dirty
operator|&=
operator|~
name|MACH64_UPLOAD_MISC
expr_stmt|;
block|}
if|if
condition|(
name|dirty
operator|&
name|MACH64_UPLOAD_DST_OFF_PITCH
condition|)
block|{
name|DMAOUTREG
argument_list|(
name|MACH64_DST_OFF_PITCH
argument_list|,
name|regs
operator|->
name|dst_off_pitch
argument_list|)
expr_stmt|;
name|sarea_priv
operator|->
name|dirty
operator|&=
operator|~
name|MACH64_UPLOAD_DST_OFF_PITCH
expr_stmt|;
block|}
if|if
condition|(
name|dirty
operator|&
name|MACH64_UPLOAD_Z_OFF_PITCH
condition|)
block|{
name|DMAOUTREG
argument_list|(
name|MACH64_Z_OFF_PITCH
argument_list|,
name|regs
operator|->
name|z_off_pitch
argument_list|)
expr_stmt|;
name|sarea_priv
operator|->
name|dirty
operator|&=
operator|~
name|MACH64_UPLOAD_Z_OFF_PITCH
expr_stmt|;
block|}
if|if
condition|(
name|dirty
operator|&
name|MACH64_UPLOAD_Z_ALPHA_CNTL
condition|)
block|{
name|DMAOUTREG
argument_list|(
name|MACH64_Z_CNTL
argument_list|,
name|regs
operator|->
name|z_cntl
argument_list|)
expr_stmt|;
name|DMAOUTREG
argument_list|(
name|MACH64_ALPHA_TST_CNTL
argument_list|,
name|regs
operator|->
name|alpha_tst_cntl
argument_list|)
expr_stmt|;
name|sarea_priv
operator|->
name|dirty
operator|&=
operator|~
name|MACH64_UPLOAD_Z_ALPHA_CNTL
expr_stmt|;
block|}
if|if
condition|(
name|dirty
operator|&
name|MACH64_UPLOAD_SCALE_3D_CNTL
condition|)
block|{
name|DMAOUTREG
argument_list|(
name|MACH64_SCALE_3D_CNTL
argument_list|,
name|regs
operator|->
name|scale_3d_cntl
argument_list|)
expr_stmt|;
name|sarea_priv
operator|->
name|dirty
operator|&=
operator|~
name|MACH64_UPLOAD_SCALE_3D_CNTL
expr_stmt|;
block|}
if|if
condition|(
name|dirty
operator|&
name|MACH64_UPLOAD_DP_FOG_CLR
condition|)
block|{
name|DMAOUTREG
argument_list|(
name|MACH64_DP_FOG_CLR
argument_list|,
name|regs
operator|->
name|dp_fog_clr
argument_list|)
expr_stmt|;
name|sarea_priv
operator|->
name|dirty
operator|&=
operator|~
name|MACH64_UPLOAD_DP_FOG_CLR
expr_stmt|;
block|}
if|if
condition|(
name|dirty
operator|&
name|MACH64_UPLOAD_DP_WRITE_MASK
condition|)
block|{
name|DMAOUTREG
argument_list|(
name|MACH64_DP_WRITE_MASK
argument_list|,
name|regs
operator|->
name|dp_write_mask
argument_list|)
expr_stmt|;
name|sarea_priv
operator|->
name|dirty
operator|&=
operator|~
name|MACH64_UPLOAD_DP_WRITE_MASK
expr_stmt|;
block|}
if|if
condition|(
name|dirty
operator|&
name|MACH64_UPLOAD_DP_PIX_WIDTH
condition|)
block|{
name|DMAOUTREG
argument_list|(
name|MACH64_DP_PIX_WIDTH
argument_list|,
name|regs
operator|->
name|dp_pix_width
argument_list|)
expr_stmt|;
name|sarea_priv
operator|->
name|dirty
operator|&=
operator|~
name|MACH64_UPLOAD_DP_PIX_WIDTH
expr_stmt|;
block|}
if|if
condition|(
name|dirty
operator|&
name|MACH64_UPLOAD_SETUP_CNTL
condition|)
block|{
name|DMAOUTREG
argument_list|(
name|MACH64_SETUP_CNTL
argument_list|,
name|regs
operator|->
name|setup_cntl
argument_list|)
expr_stmt|;
name|sarea_priv
operator|->
name|dirty
operator|&=
operator|~
name|MACH64_UPLOAD_SETUP_CNTL
expr_stmt|;
block|}
if|if
condition|(
name|dirty
operator|&
name|MACH64_UPLOAD_TEXTURE
condition|)
block|{
name|DMAOUTREG
argument_list|(
name|MACH64_TEX_SIZE_PITCH
argument_list|,
name|regs
operator|->
name|tex_size_pitch
argument_list|)
expr_stmt|;
name|DMAOUTREG
argument_list|(
name|MACH64_TEX_CNTL
argument_list|,
name|regs
operator|->
name|tex_cntl
argument_list|)
expr_stmt|;
name|DMAOUTREG
argument_list|(
name|MACH64_SECONDARY_TEX_OFF
argument_list|,
name|regs
operator|->
name|secondary_tex_off
argument_list|)
expr_stmt|;
name|DMAOUTREG
argument_list|(
name|MACH64_TEX_0_OFF
operator|+
name|offset
argument_list|,
name|regs
operator|->
name|tex_offset
argument_list|)
expr_stmt|;
name|sarea_priv
operator|->
name|dirty
operator|&=
operator|~
name|MACH64_UPLOAD_TEXTURE
expr_stmt|;
block|}
name|DMAADVANCE
argument_list|(
name|dev_priv
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sarea_priv
operator|->
name|dirty
operator|&=
name|MACH64_UPLOAD_CLIPRECTS
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ================================================================  * DMA command dispatch functions  */
end_comment

begin_function
specifier|static
name|int
name|mach64_dma_dispatch_clear
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|,
name|unsigned
name|int
name|flags
parameter_list|,
name|int
name|cx
parameter_list|,
name|int
name|cy
parameter_list|,
name|int
name|cw
parameter_list|,
name|int
name|ch
parameter_list|,
name|unsigned
name|int
name|clear_color
parameter_list|,
name|unsigned
name|int
name|clear_depth
parameter_list|)
block|{
name|drm_mach64_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|drm_mach64_sarea_t
modifier|*
name|sarea_priv
init|=
name|dev_priv
operator|->
name|sarea_priv
decl_stmt|;
name|drm_mach64_context_regs_t
modifier|*
name|ctx
init|=
operator|&
name|sarea_priv
operator|->
name|context_state
decl_stmt|;
name|int
name|nbox
init|=
name|sarea_priv
operator|->
name|nbox
decl_stmt|;
name|struct
name|drm_clip_rect
modifier|*
name|pbox
init|=
name|sarea_priv
operator|->
name|boxes
decl_stmt|;
name|u32
name|fb_bpp
decl_stmt|,
name|depth_bpp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|DMALOCALS
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|dev_priv
operator|->
name|fb_bpp
condition|)
block|{
case|case
literal|16
case|:
name|fb_bpp
operator|=
name|MACH64_DATATYPE_RGB565
expr_stmt|;
break|break;
case|case
literal|32
case|:
name|fb_bpp
operator|=
name|MACH64_DATATYPE_ARGB8888
expr_stmt|;
break|break;
default|default:
return|return
operator|-
name|EINVAL
return|;
block|}
switch|switch
condition|(
name|dev_priv
operator|->
name|depth_bpp
condition|)
block|{
case|case
literal|16
case|:
name|depth_bpp
operator|=
name|MACH64_DATATYPE_RGB565
expr_stmt|;
break|break;
case|case
literal|24
case|:
case|case
literal|32
case|:
name|depth_bpp
operator|=
name|MACH64_DATATYPE_ARGB8888
expr_stmt|;
break|break;
default|default:
return|return
operator|-
name|EINVAL
return|;
block|}
if|if
condition|(
operator|!
name|nbox
condition|)
return|return
literal|0
return|;
name|DMAGETPTR
argument_list|(
name|file_priv
argument_list|,
name|dev_priv
argument_list|,
name|nbox
operator|*
literal|31
argument_list|)
expr_stmt|;
comment|/* returns on failure to get buffer */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nbox
condition|;
name|i
operator|++
control|)
block|{
name|int
name|x
init|=
name|pbox
index|[
name|i
index|]
operator|.
name|x1
decl_stmt|;
name|int
name|y
init|=
name|pbox
index|[
name|i
index|]
operator|.
name|y1
decl_stmt|;
name|int
name|w
init|=
name|pbox
index|[
name|i
index|]
operator|.
name|x2
operator|-
name|x
decl_stmt|;
name|int
name|h
init|=
name|pbox
index|[
name|i
index|]
operator|.
name|y2
operator|-
name|y
decl_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"dispatch clear %d,%d-%d,%d flags 0x%x\n"
argument_list|,
name|pbox
index|[
name|i
index|]
operator|.
name|x1
argument_list|,
name|pbox
index|[
name|i
index|]
operator|.
name|y1
argument_list|,
name|pbox
index|[
name|i
index|]
operator|.
name|x2
argument_list|,
name|pbox
index|[
name|i
index|]
operator|.
name|y2
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
operator|(
name|MACH64_FRONT
operator||
name|MACH64_BACK
operator|)
condition|)
block|{
comment|/* Setup for color buffer clears 			 */
name|DMAOUTREG
argument_list|(
name|MACH64_Z_CNTL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DMAOUTREG
argument_list|(
name|MACH64_SCALE_3D_CNTL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DMAOUTREG
argument_list|(
name|MACH64_SC_LEFT_RIGHT
argument_list|,
name|ctx
operator|->
name|sc_left_right
argument_list|)
expr_stmt|;
name|DMAOUTREG
argument_list|(
name|MACH64_SC_TOP_BOTTOM
argument_list|,
name|ctx
operator|->
name|sc_top_bottom
argument_list|)
expr_stmt|;
name|DMAOUTREG
argument_list|(
name|MACH64_CLR_CMP_CNTL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DMAOUTREG
argument_list|(
name|MACH64_GUI_TRAJ_CNTL
argument_list|,
operator|(
name|MACH64_DST_X_LEFT_TO_RIGHT
operator||
name|MACH64_DST_Y_TOP_TO_BOTTOM
operator|)
argument_list|)
expr_stmt|;
name|DMAOUTREG
argument_list|(
name|MACH64_DP_PIX_WIDTH
argument_list|,
operator|(
operator|(
name|fb_bpp
operator|<<
literal|0
operator|)
operator||
operator|(
name|fb_bpp
operator|<<
literal|4
operator|)
operator||
operator|(
name|fb_bpp
operator|<<
literal|8
operator|)
operator||
operator|(
name|fb_bpp
operator|<<
literal|16
operator|)
operator||
operator|(
name|fb_bpp
operator|<<
literal|28
operator|)
operator|)
argument_list|)
expr_stmt|;
name|DMAOUTREG
argument_list|(
name|MACH64_DP_FRGD_CLR
argument_list|,
name|clear_color
argument_list|)
expr_stmt|;
name|DMAOUTREG
argument_list|(
name|MACH64_DP_WRITE_MASK
argument_list|,
name|ctx
operator|->
name|dp_write_mask
argument_list|)
expr_stmt|;
name|DMAOUTREG
argument_list|(
name|MACH64_DP_MIX
argument_list|,
operator|(
name|MACH64_BKGD_MIX_D
operator||
name|MACH64_FRGD_MIX_S
operator|)
argument_list|)
expr_stmt|;
name|DMAOUTREG
argument_list|(
name|MACH64_DP_SRC
argument_list|,
operator|(
name|MACH64_BKGD_SRC_FRGD_CLR
operator||
name|MACH64_FRGD_SRC_FRGD_CLR
operator||
name|MACH64_MONO_SRC_ONE
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|MACH64_FRONT
condition|)
block|{
name|DMAOUTREG
argument_list|(
name|MACH64_DST_OFF_PITCH
argument_list|,
name|dev_priv
operator|->
name|front_offset_pitch
argument_list|)
expr_stmt|;
name|DMAOUTREG
argument_list|(
name|MACH64_DST_X_Y
argument_list|,
operator|(
name|y
operator|<<
literal|16
operator|)
operator||
name|x
argument_list|)
expr_stmt|;
name|DMAOUTREG
argument_list|(
name|MACH64_DST_WIDTH_HEIGHT
argument_list|,
operator|(
name|h
operator|<<
literal|16
operator|)
operator||
name|w
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|MACH64_BACK
condition|)
block|{
name|DMAOUTREG
argument_list|(
name|MACH64_DST_OFF_PITCH
argument_list|,
name|dev_priv
operator|->
name|back_offset_pitch
argument_list|)
expr_stmt|;
name|DMAOUTREG
argument_list|(
name|MACH64_DST_X_Y
argument_list|,
operator|(
name|y
operator|<<
literal|16
operator|)
operator||
name|x
argument_list|)
expr_stmt|;
name|DMAOUTREG
argument_list|(
name|MACH64_DST_WIDTH_HEIGHT
argument_list|,
operator|(
name|h
operator|<<
literal|16
operator|)
operator||
name|w
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|MACH64_DEPTH
condition|)
block|{
comment|/* Setup for depth buffer clear 			 */
name|DMAOUTREG
argument_list|(
name|MACH64_Z_CNTL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DMAOUTREG
argument_list|(
name|MACH64_SCALE_3D_CNTL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DMAOUTREG
argument_list|(
name|MACH64_SC_LEFT_RIGHT
argument_list|,
name|ctx
operator|->
name|sc_left_right
argument_list|)
expr_stmt|;
name|DMAOUTREG
argument_list|(
name|MACH64_SC_TOP_BOTTOM
argument_list|,
name|ctx
operator|->
name|sc_top_bottom
argument_list|)
expr_stmt|;
name|DMAOUTREG
argument_list|(
name|MACH64_CLR_CMP_CNTL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DMAOUTREG
argument_list|(
name|MACH64_GUI_TRAJ_CNTL
argument_list|,
operator|(
name|MACH64_DST_X_LEFT_TO_RIGHT
operator||
name|MACH64_DST_Y_TOP_TO_BOTTOM
operator|)
argument_list|)
expr_stmt|;
name|DMAOUTREG
argument_list|(
name|MACH64_DP_PIX_WIDTH
argument_list|,
operator|(
operator|(
name|depth_bpp
operator|<<
literal|0
operator|)
operator||
operator|(
name|depth_bpp
operator|<<
literal|4
operator|)
operator||
operator|(
name|depth_bpp
operator|<<
literal|8
operator|)
operator||
operator|(
name|depth_bpp
operator|<<
literal|16
operator|)
operator||
operator|(
name|depth_bpp
operator|<<
literal|28
operator|)
operator|)
argument_list|)
expr_stmt|;
name|DMAOUTREG
argument_list|(
name|MACH64_DP_FRGD_CLR
argument_list|,
name|clear_depth
argument_list|)
expr_stmt|;
name|DMAOUTREG
argument_list|(
name|MACH64_DP_WRITE_MASK
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|DMAOUTREG
argument_list|(
name|MACH64_DP_MIX
argument_list|,
operator|(
name|MACH64_BKGD_MIX_D
operator||
name|MACH64_FRGD_MIX_S
operator|)
argument_list|)
expr_stmt|;
name|DMAOUTREG
argument_list|(
name|MACH64_DP_SRC
argument_list|,
operator|(
name|MACH64_BKGD_SRC_FRGD_CLR
operator||
name|MACH64_FRGD_SRC_FRGD_CLR
operator||
name|MACH64_MONO_SRC_ONE
operator|)
argument_list|)
expr_stmt|;
name|DMAOUTREG
argument_list|(
name|MACH64_DST_OFF_PITCH
argument_list|,
name|dev_priv
operator|->
name|depth_offset_pitch
argument_list|)
expr_stmt|;
name|DMAOUTREG
argument_list|(
name|MACH64_DST_X_Y
argument_list|,
operator|(
name|y
operator|<<
literal|16
operator|)
operator||
name|x
argument_list|)
expr_stmt|;
name|DMAOUTREG
argument_list|(
name|MACH64_DST_WIDTH_HEIGHT
argument_list|,
operator|(
name|h
operator|<<
literal|16
operator|)
operator||
name|w
argument_list|)
expr_stmt|;
block|}
block|}
name|DMAADVANCE
argument_list|(
name|dev_priv
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mach64_dma_dispatch_swap
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
name|drm_mach64_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|drm_mach64_sarea_t
modifier|*
name|sarea_priv
init|=
name|dev_priv
operator|->
name|sarea_priv
decl_stmt|;
name|int
name|nbox
init|=
name|sarea_priv
operator|->
name|nbox
decl_stmt|;
name|struct
name|drm_clip_rect
modifier|*
name|pbox
init|=
name|sarea_priv
operator|->
name|boxes
decl_stmt|;
name|u32
name|fb_bpp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|DMALOCALS
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|dev_priv
operator|->
name|fb_bpp
condition|)
block|{
case|case
literal|16
case|:
name|fb_bpp
operator|=
name|MACH64_DATATYPE_RGB565
expr_stmt|;
break|break;
case|case
literal|32
case|:
default|default:
name|fb_bpp
operator|=
name|MACH64_DATATYPE_ARGB8888
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|nbox
condition|)
return|return
literal|0
return|;
name|DMAGETPTR
argument_list|(
name|file_priv
argument_list|,
name|dev_priv
argument_list|,
literal|13
operator|+
name|nbox
operator|*
literal|4
argument_list|)
expr_stmt|;
comment|/* returns on failure to get buffer */
name|DMAOUTREG
argument_list|(
name|MACH64_Z_CNTL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DMAOUTREG
argument_list|(
name|MACH64_SCALE_3D_CNTL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DMAOUTREG
argument_list|(
name|MACH64_SC_LEFT_RIGHT
argument_list|,
literal|0
operator||
operator|(
literal|8191
operator|<<
literal|16
operator|)
argument_list|)
expr_stmt|;
comment|/* no scissor */
name|DMAOUTREG
argument_list|(
name|MACH64_SC_TOP_BOTTOM
argument_list|,
literal|0
operator||
operator|(
literal|16383
operator|<<
literal|16
operator|)
argument_list|)
expr_stmt|;
name|DMAOUTREG
argument_list|(
name|MACH64_CLR_CMP_CNTL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DMAOUTREG
argument_list|(
name|MACH64_GUI_TRAJ_CNTL
argument_list|,
operator|(
name|MACH64_DST_X_LEFT_TO_RIGHT
operator||
name|MACH64_DST_Y_TOP_TO_BOTTOM
operator|)
argument_list|)
expr_stmt|;
name|DMAOUTREG
argument_list|(
name|MACH64_DP_PIX_WIDTH
argument_list|,
operator|(
operator|(
name|fb_bpp
operator|<<
literal|0
operator|)
operator||
operator|(
name|fb_bpp
operator|<<
literal|4
operator|)
operator||
operator|(
name|fb_bpp
operator|<<
literal|8
operator|)
operator||
operator|(
name|fb_bpp
operator|<<
literal|16
operator|)
operator||
operator|(
name|fb_bpp
operator|<<
literal|28
operator|)
operator|)
argument_list|)
expr_stmt|;
name|DMAOUTREG
argument_list|(
name|MACH64_DP_WRITE_MASK
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|DMAOUTREG
argument_list|(
name|MACH64_DP_MIX
argument_list|,
operator|(
name|MACH64_BKGD_MIX_D
operator||
name|MACH64_FRGD_MIX_S
operator|)
argument_list|)
expr_stmt|;
name|DMAOUTREG
argument_list|(
name|MACH64_DP_SRC
argument_list|,
operator|(
name|MACH64_BKGD_SRC_BKGD_CLR
operator||
name|MACH64_FRGD_SRC_BLIT
operator||
name|MACH64_MONO_SRC_ONE
operator|)
argument_list|)
expr_stmt|;
name|DMAOUTREG
argument_list|(
name|MACH64_SRC_OFF_PITCH
argument_list|,
name|dev_priv
operator|->
name|back_offset_pitch
argument_list|)
expr_stmt|;
name|DMAOUTREG
argument_list|(
name|MACH64_DST_OFF_PITCH
argument_list|,
name|dev_priv
operator|->
name|front_offset_pitch
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nbox
condition|;
name|i
operator|++
control|)
block|{
name|int
name|x
init|=
name|pbox
index|[
name|i
index|]
operator|.
name|x1
decl_stmt|;
name|int
name|y
init|=
name|pbox
index|[
name|i
index|]
operator|.
name|y1
decl_stmt|;
name|int
name|w
init|=
name|pbox
index|[
name|i
index|]
operator|.
name|x2
operator|-
name|x
decl_stmt|;
name|int
name|h
init|=
name|pbox
index|[
name|i
index|]
operator|.
name|y2
operator|-
name|y
decl_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"dispatch swap %d,%d-%d,%d\n"
argument_list|,
name|pbox
index|[
name|i
index|]
operator|.
name|x1
argument_list|,
name|pbox
index|[
name|i
index|]
operator|.
name|y1
argument_list|,
name|pbox
index|[
name|i
index|]
operator|.
name|x2
argument_list|,
name|pbox
index|[
name|i
index|]
operator|.
name|y2
argument_list|)
expr_stmt|;
name|DMAOUTREG
argument_list|(
name|MACH64_SRC_WIDTH1
argument_list|,
name|w
argument_list|)
expr_stmt|;
name|DMAOUTREG
argument_list|(
name|MACH64_SRC_Y_X
argument_list|,
operator|(
name|x
operator|<<
literal|16
operator|)
operator||
name|y
argument_list|)
expr_stmt|;
name|DMAOUTREG
argument_list|(
name|MACH64_DST_Y_X
argument_list|,
operator|(
name|x
operator|<<
literal|16
operator|)
operator||
name|y
argument_list|)
expr_stmt|;
name|DMAOUTREG
argument_list|(
name|MACH64_DST_WIDTH_HEIGHT
argument_list|,
operator|(
name|h
operator|<<
literal|16
operator|)
operator||
name|w
argument_list|)
expr_stmt|;
block|}
name|DMAADVANCE
argument_list|(
name|dev_priv
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|driver_mode
operator|==
name|MACH64_MODE_DMA_ASYNC
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MACH64_MAX_QUEUED_FRAMES
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|dev_priv
operator|->
name|frame_ofs
index|[
name|i
index|]
operator|=
name|dev_priv
operator|->
name|frame_ofs
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
block|}
name|dev_priv
operator|->
name|frame_ofs
index|[
name|i
index|]
operator|=
name|GETRINGOFFSET
argument_list|()
expr_stmt|;
name|dev_priv
operator|->
name|sarea_priv
operator|->
name|frames_queued
operator|++
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mach64_do_get_frames_queued
parameter_list|(
name|drm_mach64_private_t
modifier|*
name|dev_priv
parameter_list|)
block|{
name|drm_mach64_descriptor_ring_t
modifier|*
name|ring
init|=
operator|&
name|dev_priv
operator|->
name|ring
decl_stmt|;
name|drm_mach64_sarea_t
modifier|*
name|sarea_priv
init|=
name|dev_priv
operator|->
name|sarea_priv
decl_stmt|;
name|int
name|i
decl_stmt|,
name|start
decl_stmt|;
name|u32
name|head
decl_stmt|,
name|tail
decl_stmt|,
name|ofs
decl_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sarea_priv
operator|->
name|frames_queued
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|tail
operator|=
name|ring
operator|->
name|tail
expr_stmt|;
name|mach64_ring_tick
argument_list|(
name|dev_priv
argument_list|,
name|ring
argument_list|)
expr_stmt|;
name|head
operator|=
name|ring
operator|->
name|head
expr_stmt|;
name|start
operator|=
operator|(
name|MACH64_MAX_QUEUED_FRAMES
operator|-
name|DRM_MIN
argument_list|(
name|MACH64_MAX_QUEUED_FRAMES
argument_list|,
name|sarea_priv
operator|->
name|frames_queued
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|head
operator|==
name|tail
condition|)
block|{
name|sarea_priv
operator|->
name|frames_queued
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|start
init|;
name|i
operator|<
name|MACH64_MAX_QUEUED_FRAMES
condition|;
name|i
operator|++
control|)
block|{
name|dev_priv
operator|->
name|frame_ofs
index|[
name|i
index|]
operator|=
operator|~
literal|0
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
for|for
control|(
name|i
operator|=
name|start
init|;
name|i
operator|<
name|MACH64_MAX_QUEUED_FRAMES
condition|;
name|i
operator|++
control|)
block|{
name|ofs
operator|=
name|dev_priv
operator|->
name|frame_ofs
index|[
name|i
index|]
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"frame_ofs[%d] ofs: %d\n"
argument_list|,
name|i
argument_list|,
name|ofs
argument_list|)
expr_stmt|;
if|if
condition|(
name|ofs
operator|==
operator|~
literal|0
operator|||
operator|(
name|head
operator|<
name|tail
operator|&&
operator|(
name|ofs
operator|<
name|head
operator|||
name|ofs
operator|>=
name|tail
operator|)
operator|)
operator|||
operator|(
name|head
operator|>
name|tail
operator|&&
operator|(
name|ofs
operator|<
name|head
operator|&&
name|ofs
operator|>=
name|tail
operator|)
operator|)
condition|)
block|{
name|sarea_priv
operator|->
name|frames_queued
operator|=
operator|(
name|MACH64_MAX_QUEUED_FRAMES
operator|-
literal|1
operator|)
operator|-
name|i
expr_stmt|;
name|dev_priv
operator|->
name|frame_ofs
index|[
name|i
index|]
operator|=
operator|~
literal|0
expr_stmt|;
block|}
block|}
return|return
name|sarea_priv
operator|->
name|frames_queued
return|;
block|}
end_function

begin_comment
comment|/* Copy and verify a client submited buffer.  * FIXME: Make an assembly optimized version  */
end_comment

begin_function
specifier|static
name|__inline__
name|int
name|copy_from_user_vertex
parameter_list|(
name|u32
modifier|*
name|to
parameter_list|,
specifier|const
name|u32
name|__user
modifier|*
name|ufrom
parameter_list|,
name|unsigned
name|long
name|bytes
parameter_list|)
block|{
name|unsigned
name|long
name|n
init|=
name|bytes
decl_stmt|;
comment|/* dwords remaining in buffer */
name|u32
modifier|*
name|from
decl_stmt|,
modifier|*
name|orig_from
decl_stmt|;
name|from
operator|=
name|drm_alloc
argument_list|(
name|bytes
argument_list|,
name|DRM_MEM_DRIVER
argument_list|)
expr_stmt|;
if|if
condition|(
name|from
operator|==
name|NULL
condition|)
return|return
operator|-
name|ENOMEM
return|;
if|if
condition|(
name|DRM_COPY_FROM_USER
argument_list|(
name|from
argument_list|,
name|ufrom
argument_list|,
name|bytes
argument_list|)
condition|)
block|{
name|drm_free
argument_list|(
name|from
argument_list|,
name|bytes
argument_list|,
name|DRM_MEM_DRIVER
argument_list|)
expr_stmt|;
return|return
operator|-
name|EFAULT
return|;
block|}
name|orig_from
operator|=
name|from
expr_stmt|;
comment|/* we'll be modifying the "from" ptr, so save it */
name|n
operator|>>=
literal|2
expr_stmt|;
while|while
condition|(
name|n
operator|>
literal|1
condition|)
block|{
name|u32
name|data
decl_stmt|,
name|reg
decl_stmt|,
name|count
decl_stmt|;
name|data
operator|=
operator|*
name|from
operator|++
expr_stmt|;
name|n
operator|--
expr_stmt|;
name|reg
operator|=
name|le32_to_cpu
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|count
operator|=
operator|(
name|reg
operator|>>
literal|16
operator|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|count
operator|<=
name|n
condition|)
block|{
name|n
operator|-=
name|count
expr_stmt|;
name|reg
operator|&=
literal|0xffff
expr_stmt|;
comment|/* This is an exact match of Mach64's Setup Engine registers, 			 * excluding SETUP_CNTL (1_C1). 			 */
if|if
condition|(
operator|(
name|reg
operator|>=
literal|0x0190
operator|&&
name|reg
operator|<
literal|0x01c1
operator|)
operator|||
operator|(
name|reg
operator|>=
literal|0x01ca
operator|&&
name|reg
operator|<=
literal|0x01cf
operator|)
condition|)
block|{
operator|*
name|to
operator|++
operator|=
name|data
expr_stmt|;
name|memcpy
argument_list|(
name|to
argument_list|,
name|from
argument_list|,
name|count
operator|<<
literal|2
argument_list|)
expr_stmt|;
name|from
operator|+=
name|count
expr_stmt|;
name|to
operator|+=
name|count
expr_stmt|;
block|}
else|else
block|{
name|DRM_ERROR
argument_list|(
literal|"Got bad command: 0x%04x\n"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|drm_free
argument_list|(
name|orig_from
argument_list|,
name|bytes
argument_list|,
name|DRM_MEM_DRIVER
argument_list|)
expr_stmt|;
return|return
operator|-
name|EACCES
return|;
block|}
block|}
else|else
block|{
name|DRM_ERROR
argument_list|(
literal|"Got bad command count(=%u) dwords remaining=%lu\n"
argument_list|,
name|count
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|drm_free
argument_list|(
name|orig_from
argument_list|,
name|bytes
argument_list|,
name|DRM_MEM_DRIVER
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
block|}
name|drm_free
argument_list|(
name|orig_from
argument_list|,
name|bytes
argument_list|,
name|DRM_MEM_DRIVER
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
return|return
literal|0
return|;
else|else
block|{
name|DRM_ERROR
argument_list|(
literal|"Bad buf->used(=%lu)\n"
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|mach64_dma_dispatch_vertex
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|,
name|drm_mach64_vertex_t
modifier|*
name|vertex
parameter_list|)
block|{
name|drm_mach64_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|drm_mach64_sarea_t
modifier|*
name|sarea_priv
init|=
name|dev_priv
operator|->
name|sarea_priv
decl_stmt|;
name|struct
name|drm_buf
modifier|*
name|copy_buf
decl_stmt|;
name|void
modifier|*
name|buf
init|=
name|vertex
operator|->
name|buf
decl_stmt|;
name|unsigned
name|long
name|used
init|=
name|vertex
operator|->
name|used
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|int
name|done
init|=
literal|0
decl_stmt|;
name|int
name|verify_ret
init|=
literal|0
decl_stmt|;
name|DMALOCALS
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"buf=%p used=%lu nbox=%d\n"
argument_list|,
name|buf
argument_list|,
name|used
argument_list|,
name|sarea_priv
operator|->
name|nbox
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|used
condition|)
goto|goto
name|_vertex_done
goto|;
name|copy_buf
operator|=
name|mach64_freelist_get
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
if|if
condition|(
name|copy_buf
operator|==
name|NULL
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"couldn't get buffer\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EAGAIN
return|;
block|}
comment|/* Mach64's vertex data is actually register writes. To avoid security 	 * compromises these register writes have to be verified and copied from 	 * user space into a private DMA buffer. 	 */
name|verify_ret
operator|=
name|copy_from_user_vertex
argument_list|(
name|GETBUFPTR
argument_list|(
name|copy_buf
argument_list|)
argument_list|,
name|buf
argument_list|,
name|used
argument_list|)
expr_stmt|;
if|if
condition|(
name|verify_ret
operator|!=
literal|0
condition|)
block|{
name|mach64_freelist_put
argument_list|(
name|dev_priv
argument_list|,
name|copy_buf
argument_list|)
expr_stmt|;
goto|goto
name|_vertex_done
goto|;
block|}
name|copy_buf
operator|->
name|used
operator|=
name|used
expr_stmt|;
name|DMASETPTR
argument_list|(
name|copy_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|sarea_priv
operator|->
name|dirty
operator|&
operator|~
name|MACH64_UPLOAD_CLIPRECTS
condition|)
block|{
name|ret
operator|=
name|mach64_emit_state
argument_list|(
name|file_priv
argument_list|,
name|dev_priv
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
return|return
name|ret
return|;
block|}
do|do
block|{
comment|/* Emit the next cliprect */
if|if
condition|(
name|i
operator|<
name|sarea_priv
operator|->
name|nbox
condition|)
block|{
name|ret
operator|=
name|mach64_emit_cliprect
argument_list|(
name|file_priv
argument_list|,
name|dev_priv
argument_list|,
operator|&
name|sarea_priv
operator|->
name|boxes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
comment|/* failed to get buffer */
return|return
name|ret
return|;
block|}
elseif|else
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
comment|/* null intersection with scissor */
continue|continue;
block|}
block|}
if|if
condition|(
operator|(
name|i
operator|>=
name|sarea_priv
operator|->
name|nbox
operator|-
literal|1
operator|)
condition|)
name|done
operator|=
literal|1
expr_stmt|;
comment|/* Add the buffer to the DMA queue */
name|DMAADVANCE
argument_list|(
name|dev_priv
argument_list|,
name|done
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|++
name|i
operator|<
name|sarea_priv
operator|->
name|nbox
condition|)
do|;
if|if
condition|(
operator|!
name|done
condition|)
block|{
if|if
condition|(
name|copy_buf
operator|->
name|pending
condition|)
block|{
name|DMADISCARDBUF
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/* This buffer wasn't used (no cliprects), so place it 			 * back on the free list 			 */
name|mach64_freelist_put
argument_list|(
name|dev_priv
argument_list|,
name|copy_buf
argument_list|)
expr_stmt|;
block|}
block|}
name|_vertex_done
label|:
name|sarea_priv
operator|->
name|dirty
operator|&=
operator|~
name|MACH64_UPLOAD_CLIPRECTS
expr_stmt|;
name|sarea_priv
operator|->
name|nbox
operator|=
literal|0
expr_stmt|;
return|return
name|verify_ret
return|;
block|}
end_function

begin_function
specifier|static
name|__inline__
name|int
name|copy_from_user_blit
parameter_list|(
name|u32
modifier|*
name|to
parameter_list|,
specifier|const
name|u32
name|__user
modifier|*
name|ufrom
parameter_list|,
name|unsigned
name|long
name|bytes
parameter_list|)
block|{
name|to
operator|=
operator|(
name|u32
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|to
operator|+
name|MACH64_HOSTDATA_BLIT_OFFSET
operator|)
expr_stmt|;
if|if
condition|(
name|DRM_COPY_FROM_USER
argument_list|(
name|to
argument_list|,
name|ufrom
argument_list|,
name|bytes
argument_list|)
condition|)
block|{
return|return
operator|-
name|EFAULT
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mach64_dma_dispatch_blit
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|,
name|drm_mach64_blit_t
modifier|*
name|blit
parameter_list|)
block|{
name|drm_mach64_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|int
name|dword_shift
decl_stmt|,
name|dwords
decl_stmt|;
name|unsigned
name|long
name|used
decl_stmt|;
name|struct
name|drm_buf
modifier|*
name|copy_buf
decl_stmt|;
name|int
name|verify_ret
init|=
literal|0
decl_stmt|;
name|DMALOCALS
expr_stmt|;
comment|/* The compiler won't optimize away a division by a variable, 	 * even if the only legal values are powers of two.  Thus, we'll 	 * use a shift instead. 	 */
switch|switch
condition|(
name|blit
operator|->
name|format
condition|)
block|{
case|case
name|MACH64_DATATYPE_ARGB8888
case|:
name|dword_shift
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|MACH64_DATATYPE_ARGB1555
case|:
case|case
name|MACH64_DATATYPE_RGB565
case|:
case|case
name|MACH64_DATATYPE_VYUY422
case|:
case|case
name|MACH64_DATATYPE_YVYU422
case|:
case|case
name|MACH64_DATATYPE_ARGB4444
case|:
name|dword_shift
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|MACH64_DATATYPE_CI8
case|:
case|case
name|MACH64_DATATYPE_RGB8
case|:
name|dword_shift
operator|=
literal|2
expr_stmt|;
break|break;
default|default:
name|DRM_ERROR
argument_list|(
literal|"invalid blit format %d\n"
argument_list|,
name|blit
operator|->
name|format
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
comment|/* Set buf->used to the bytes of blit data based on the blit dimensions 	 * and verify the size.  When the setup is emitted to the buffer with 	 * the DMA* macros below, buf->used is incremented to include the bytes 	 * used for setup as well as the blit data. 	 */
name|dwords
operator|=
operator|(
name|blit
operator|->
name|width
operator|*
name|blit
operator|->
name|height
operator|)
operator|>>
name|dword_shift
expr_stmt|;
name|used
operator|=
name|dwords
operator|<<
literal|2
expr_stmt|;
if|if
condition|(
name|used
operator|<=
literal|0
operator|||
name|used
operator|>
name|MACH64_BUFFER_SIZE
operator|-
name|MACH64_HOSTDATA_BLIT_OFFSET
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Invalid blit size: %lu bytes\n"
argument_list|,
name|used
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|copy_buf
operator|=
name|mach64_freelist_get
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
if|if
condition|(
name|copy_buf
operator|==
name|NULL
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"couldn't get buffer\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EAGAIN
return|;
block|}
comment|/* Copy the blit data from userspace. 	 *  	 * XXX: This is overkill. The most efficient solution would be having  	 * two sets of buffers (one set private for vertex data, the other set  	 * client-writable for blits). However that would bring more complexity  	 * and would break backward compatability. The solution currently  	 * implemented is keeping all buffers private, allowing to secure the 	 * driver, without increasing complexity at the expense of some speed  	 * transfering data. 	 */
name|verify_ret
operator|=
name|copy_from_user_blit
argument_list|(
name|GETBUFPTR
argument_list|(
name|copy_buf
argument_list|)
argument_list|,
name|blit
operator|->
name|buf
argument_list|,
name|used
argument_list|)
expr_stmt|;
if|if
condition|(
name|verify_ret
operator|!=
literal|0
condition|)
block|{
name|mach64_freelist_put
argument_list|(
name|dev_priv
argument_list|,
name|copy_buf
argument_list|)
expr_stmt|;
goto|goto
name|_blit_done
goto|;
block|}
name|copy_buf
operator|->
name|used
operator|=
name|used
expr_stmt|;
comment|/* FIXME: Use a last buffer flag and reduce the state emitted for subsequent, 	 * continuation buffers? 	 */
comment|/* Blit via BM_HOSTDATA (gui-master) - like HOST_DATA[0-15], but doesn't require 	 * a register command every 16 dwords.  State setup is added at the start of the 	 * buffer -- the client leaves space for this based on MACH64_HOSTDATA_BLIT_OFFSET 	 */
name|DMASETPTR
argument_list|(
name|copy_buf
argument_list|)
expr_stmt|;
name|DMAOUTREG
argument_list|(
name|MACH64_Z_CNTL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DMAOUTREG
argument_list|(
name|MACH64_SCALE_3D_CNTL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DMAOUTREG
argument_list|(
name|MACH64_SC_LEFT_RIGHT
argument_list|,
literal|0
operator||
operator|(
literal|8191
operator|<<
literal|16
operator|)
argument_list|)
expr_stmt|;
comment|/* no scissor */
name|DMAOUTREG
argument_list|(
name|MACH64_SC_TOP_BOTTOM
argument_list|,
literal|0
operator||
operator|(
literal|16383
operator|<<
literal|16
operator|)
argument_list|)
expr_stmt|;
name|DMAOUTREG
argument_list|(
name|MACH64_CLR_CMP_CNTL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* disable */
name|DMAOUTREG
argument_list|(
name|MACH64_GUI_TRAJ_CNTL
argument_list|,
name|MACH64_DST_X_LEFT_TO_RIGHT
operator||
name|MACH64_DST_Y_TOP_TO_BOTTOM
argument_list|)
expr_stmt|;
name|DMAOUTREG
argument_list|(
name|MACH64_DP_PIX_WIDTH
argument_list|,
operator|(
name|blit
operator|->
name|format
operator|<<
literal|0
operator|)
comment|/* dst pix width */
operator||
operator|(
name|blit
operator|->
name|format
operator|<<
literal|4
operator|)
comment|/* composite pix width */
operator||
operator|(
name|blit
operator|->
name|format
operator|<<
literal|8
operator|)
comment|/* src pix width */
operator||
operator|(
name|blit
operator|->
name|format
operator|<<
literal|16
operator|)
comment|/* host data pix width */
operator||
operator|(
name|blit
operator|->
name|format
operator|<<
literal|28
operator|)
comment|/* scaler/3D pix width */
argument_list|)
expr_stmt|;
name|DMAOUTREG
argument_list|(
name|MACH64_DP_WRITE_MASK
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
comment|/* enable all planes */
name|DMAOUTREG
argument_list|(
name|MACH64_DP_MIX
argument_list|,
name|MACH64_BKGD_MIX_D
operator||
name|MACH64_FRGD_MIX_S
argument_list|)
expr_stmt|;
name|DMAOUTREG
argument_list|(
name|MACH64_DP_SRC
argument_list|,
name|MACH64_BKGD_SRC_BKGD_CLR
operator||
name|MACH64_FRGD_SRC_HOST
operator||
name|MACH64_MONO_SRC_ONE
argument_list|)
expr_stmt|;
name|DMAOUTREG
argument_list|(
name|MACH64_DST_OFF_PITCH
argument_list|,
operator|(
name|blit
operator|->
name|pitch
operator|<<
literal|22
operator|)
operator||
operator|(
name|blit
operator|->
name|offset
operator|>>
literal|3
operator|)
argument_list|)
expr_stmt|;
name|DMAOUTREG
argument_list|(
name|MACH64_DST_X_Y
argument_list|,
operator|(
name|blit
operator|->
name|y
operator|<<
literal|16
operator|)
operator||
name|blit
operator|->
name|x
argument_list|)
expr_stmt|;
name|DMAOUTREG
argument_list|(
name|MACH64_DST_WIDTH_HEIGHT
argument_list|,
operator|(
name|blit
operator|->
name|height
operator|<<
literal|16
operator|)
operator||
name|blit
operator|->
name|width
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"%lu bytes\n"
argument_list|,
name|used
argument_list|)
expr_stmt|;
comment|/* Add the buffer to the queue */
name|DMAADVANCEHOSTDATA
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
name|_blit_done
label|:
return|return
name|verify_ret
return|;
block|}
end_function

begin_comment
comment|/* ================================================================  * IOCTL functions  */
end_comment

begin_function
name|int
name|mach64_dma_clear
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
name|drm_mach64_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|drm_mach64_sarea_t
modifier|*
name|sarea_priv
init|=
name|dev_priv
operator|->
name|sarea_priv
decl_stmt|;
name|drm_mach64_clear_t
modifier|*
name|clear
init|=
name|data
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"pid=%d\n"
argument_list|,
name|DRM_CURRENTPID
argument_list|)
expr_stmt|;
name|LOCK_TEST_WITH_RETURN
argument_list|(
name|dev
argument_list|,
name|file_priv
argument_list|)
expr_stmt|;
if|if
condition|(
name|sarea_priv
operator|->
name|nbox
operator|>
name|MACH64_NR_SAREA_CLIPRECTS
condition|)
name|sarea_priv
operator|->
name|nbox
operator|=
name|MACH64_NR_SAREA_CLIPRECTS
expr_stmt|;
name|ret
operator|=
name|mach64_dma_dispatch_clear
argument_list|(
name|dev
argument_list|,
name|file_priv
argument_list|,
name|clear
operator|->
name|flags
argument_list|,
name|clear
operator|->
name|x
argument_list|,
name|clear
operator|->
name|y
argument_list|,
name|clear
operator|->
name|w
argument_list|,
name|clear
operator|->
name|h
argument_list|,
name|clear
operator|->
name|clear_color
argument_list|,
name|clear
operator|->
name|clear_depth
argument_list|)
expr_stmt|;
comment|/* Make sure we restore the 3D state next time. 	 */
name|sarea_priv
operator|->
name|dirty
operator||=
operator|(
name|MACH64_UPLOAD_CONTEXT
operator||
name|MACH64_UPLOAD_MISC
operator|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|mach64_dma_swap
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
name|drm_mach64_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|drm_mach64_sarea_t
modifier|*
name|sarea_priv
init|=
name|dev_priv
operator|->
name|sarea_priv
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"pid=%d\n"
argument_list|,
name|DRM_CURRENTPID
argument_list|)
expr_stmt|;
name|LOCK_TEST_WITH_RETURN
argument_list|(
name|dev
argument_list|,
name|file_priv
argument_list|)
expr_stmt|;
if|if
condition|(
name|sarea_priv
operator|->
name|nbox
operator|>
name|MACH64_NR_SAREA_CLIPRECTS
condition|)
name|sarea_priv
operator|->
name|nbox
operator|=
name|MACH64_NR_SAREA_CLIPRECTS
expr_stmt|;
name|ret
operator|=
name|mach64_dma_dispatch_swap
argument_list|(
name|dev
argument_list|,
name|file_priv
argument_list|)
expr_stmt|;
comment|/* Make sure we restore the 3D state next time. 	 */
name|sarea_priv
operator|->
name|dirty
operator||=
operator|(
name|MACH64_UPLOAD_CONTEXT
operator||
name|MACH64_UPLOAD_MISC
operator|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|mach64_dma_vertex
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
name|drm_mach64_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|drm_mach64_sarea_t
modifier|*
name|sarea_priv
decl_stmt|;
name|drm_mach64_vertex_t
modifier|*
name|vertex
init|=
name|data
decl_stmt|;
name|LOCK_TEST_WITH_RETURN
argument_list|(
name|dev
argument_list|,
name|file_priv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dev_priv
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"called with no initialization\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|sarea_priv
operator|=
name|dev_priv
operator|->
name|sarea_priv
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"pid=%d buf=%p used=%lu discard=%d\n"
argument_list|,
name|DRM_CURRENTPID
argument_list|,
name|vertex
operator|->
name|buf
argument_list|,
name|vertex
operator|->
name|used
argument_list|,
name|vertex
operator|->
name|discard
argument_list|)
expr_stmt|;
if|if
condition|(
name|vertex
operator|->
name|prim
operator|<
literal|0
operator|||
name|vertex
operator|->
name|prim
operator|>
name|MACH64_PRIM_POLYGON
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"buffer prim %d\n"
argument_list|,
name|vertex
operator|->
name|prim
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
if|if
condition|(
name|vertex
operator|->
name|used
operator|>
name|MACH64_BUFFER_SIZE
operator|||
operator|(
name|vertex
operator|->
name|used
operator|&
literal|3
operator|)
operator|!=
literal|0
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Invalid vertex buffer size: %lu bytes\n"
argument_list|,
name|vertex
operator|->
name|used
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
if|if
condition|(
name|sarea_priv
operator|->
name|nbox
operator|>
name|MACH64_NR_SAREA_CLIPRECTS
condition|)
name|sarea_priv
operator|->
name|nbox
operator|=
name|MACH64_NR_SAREA_CLIPRECTS
expr_stmt|;
return|return
name|mach64_dma_dispatch_vertex
argument_list|(
name|dev
argument_list|,
name|file_priv
argument_list|,
name|vertex
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|mach64_dma_blit
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
name|drm_mach64_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|drm_mach64_sarea_t
modifier|*
name|sarea_priv
init|=
name|dev_priv
operator|->
name|sarea_priv
decl_stmt|;
name|drm_mach64_blit_t
modifier|*
name|blit
init|=
name|data
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|LOCK_TEST_WITH_RETURN
argument_list|(
name|dev
argument_list|,
name|file_priv
argument_list|)
expr_stmt|;
name|ret
operator|=
name|mach64_dma_dispatch_blit
argument_list|(
name|dev
argument_list|,
name|file_priv
argument_list|,
name|blit
argument_list|)
expr_stmt|;
comment|/* Make sure we restore the 3D state next time. 	 */
name|sarea_priv
operator|->
name|dirty
operator||=
operator|(
name|MACH64_UPLOAD_CONTEXT
operator||
name|MACH64_UPLOAD_MISC
operator||
name|MACH64_UPLOAD_CLIPRECTS
operator|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|mach64_get_param
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
name|drm_mach64_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|drm_mach64_getparam_t
modifier|*
name|param
init|=
name|data
decl_stmt|;
name|int
name|value
decl_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dev_priv
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"called with no initialization\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
switch|switch
condition|(
name|param
operator|->
name|param
condition|)
block|{
case|case
name|MACH64_PARAM_FRAMES_QUEUED
case|:
comment|/* Needs lock since it calls mach64_ring_tick() */
name|LOCK_TEST_WITH_RETURN
argument_list|(
name|dev
argument_list|,
name|file_priv
argument_list|)
expr_stmt|;
name|value
operator|=
name|mach64_do_get_frames_queued
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
break|break;
case|case
name|MACH64_PARAM_IRQ_NR
case|:
name|value
operator|=
name|dev
operator|->
name|irq
expr_stmt|;
break|break;
default|default:
return|return
operator|-
name|EINVAL
return|;
block|}
if|if
condition|(
name|DRM_COPY_TO_USER
argument_list|(
name|param
operator|->
name|value
argument_list|,
operator|&
name|value
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"copy_to_user\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EFAULT
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

end_unit

