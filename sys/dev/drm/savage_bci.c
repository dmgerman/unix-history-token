begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* savage_bci.c -- BCI support for Savage  *  * Copyright 2004  Felix Kuehling  * All Rights Reserved.  *  * Permission is hereby granted, free of charge, to any person obtaining a  * copy of this software and associated documentation files (the "Software"),  * to deal in the Software without restriction, including without limitation  * the rights to use, copy, modify, merge, publish, distribute, sub license,  * and/or sell copies of the Software, and to permit persons to whom the  * Software is furnished to do so, subject to the following conditions:  *  * The above copyright notice and this permission notice (including the  * next paragraph) shall be included in all copies or substantial portions  * of the Software.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  * NON-INFRINGEMENT. IN NO EVENT SHALL FELIX KUEHLING BE LIABLE FOR  * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF  * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"dev/drm/drmP.h"
end_include

begin_include
include|#
directive|include
file|"dev/drm/savage_drm.h"
end_include

begin_include
include|#
directive|include
file|"dev/drm/savage_drv.h"
end_include

begin_comment
comment|/* Need a long timeout for shadow status updates can take a while  * and so can waiting for events when the queue is full. */
end_comment

begin_define
define|#
directive|define
name|SAVAGE_DEFAULT_USEC_TIMEOUT
value|1000000
end_define

begin_comment
comment|/* 1s */
end_comment

begin_define
define|#
directive|define
name|SAVAGE_EVENT_USEC_TIMEOUT
value|5000000
end_define

begin_comment
comment|/* 5s */
end_comment

begin_define
define|#
directive|define
name|SAVAGE_FREELIST_DEBUG
value|0
end_define

begin_function_decl
specifier|static
name|int
name|savage_do_cleanup_bci
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|savage_bci_wait_fifo_shadow
parameter_list|(
name|drm_savage_private_t
modifier|*
name|dev_priv
parameter_list|,
name|unsigned
name|int
name|n
parameter_list|)
block|{
name|uint32_t
name|mask
init|=
name|dev_priv
operator|->
name|status_used_mask
decl_stmt|;
name|uint32_t
name|threshold
init|=
name|dev_priv
operator|->
name|bci_threshold_hi
decl_stmt|;
name|uint32_t
name|status
decl_stmt|;
name|int
name|i
decl_stmt|;
if|#
directive|if
name|SAVAGE_BCI_DEBUG
if|if
condition|(
name|n
operator|>
name|dev_priv
operator|->
name|cob_size
operator|+
name|SAVAGE_BCI_FIFO_SIZE
operator|-
name|threshold
condition|)
name|DRM_ERROR
argument_list|(
literal|"Trying to emit %d words "
literal|"(more than guaranteed space in COB)\n"
argument_list|,
name|n
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SAVAGE_DEFAULT_USEC_TIMEOUT
condition|;
name|i
operator|++
control|)
block|{
name|DRM_MEMORYBARRIER
argument_list|()
expr_stmt|;
name|status
operator|=
name|dev_priv
operator|->
name|status_ptr
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|mask
operator|)
operator|<
name|threshold
condition|)
return|return
literal|0
return|;
name|DRM_UDELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|SAVAGE_BCI_DEBUG
name|DRM_ERROR
argument_list|(
literal|"failed!\n"
argument_list|)
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|"   status=0x%08x, threshold=0x%08x\n"
argument_list|,
name|status
argument_list|,
name|threshold
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|-
name|EBUSY
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|savage_bci_wait_fifo_s3d
parameter_list|(
name|drm_savage_private_t
modifier|*
name|dev_priv
parameter_list|,
name|unsigned
name|int
name|n
parameter_list|)
block|{
name|uint32_t
name|maxUsed
init|=
name|dev_priv
operator|->
name|cob_size
operator|+
name|SAVAGE_BCI_FIFO_SIZE
operator|-
name|n
decl_stmt|;
name|uint32_t
name|status
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SAVAGE_DEFAULT_USEC_TIMEOUT
condition|;
name|i
operator|++
control|)
block|{
name|status
operator|=
name|SAVAGE_READ
argument_list|(
name|SAVAGE_STATUS_WORD0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|SAVAGE_FIFO_USED_MASK_S3D
operator|)
operator|<=
name|maxUsed
condition|)
return|return
literal|0
return|;
name|DRM_UDELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|SAVAGE_BCI_DEBUG
name|DRM_ERROR
argument_list|(
literal|"failed!\n"
argument_list|)
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|"   status=0x%08x\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|-
name|EBUSY
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|savage_bci_wait_fifo_s4
parameter_list|(
name|drm_savage_private_t
modifier|*
name|dev_priv
parameter_list|,
name|unsigned
name|int
name|n
parameter_list|)
block|{
name|uint32_t
name|maxUsed
init|=
name|dev_priv
operator|->
name|cob_size
operator|+
name|SAVAGE_BCI_FIFO_SIZE
operator|-
name|n
decl_stmt|;
name|uint32_t
name|status
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SAVAGE_DEFAULT_USEC_TIMEOUT
condition|;
name|i
operator|++
control|)
block|{
name|status
operator|=
name|SAVAGE_READ
argument_list|(
name|SAVAGE_ALT_STATUS_WORD0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|SAVAGE_FIFO_USED_MASK_S4
operator|)
operator|<=
name|maxUsed
condition|)
return|return
literal|0
return|;
name|DRM_UDELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|SAVAGE_BCI_DEBUG
name|DRM_ERROR
argument_list|(
literal|"failed!\n"
argument_list|)
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|"   status=0x%08x\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|-
name|EBUSY
return|;
block|}
end_function

begin_comment
comment|/*  * Waiting for events.  *  * The BIOSresets the event tag to 0 on mode changes. Therefore we  * never emit 0 to the event tag. If we find a 0 event tag we know the  * BIOS stomped on it and return success assuming that the BIOS waited  * for engine idle.  *  * Note: if the Xserver uses the event tag it has to follow the same  * rule. Otherwise there may be glitches every 2^16 events.  */
end_comment

begin_function
specifier|static
name|int
name|savage_bci_wait_event_shadow
parameter_list|(
name|drm_savage_private_t
modifier|*
name|dev_priv
parameter_list|,
name|uint16_t
name|e
parameter_list|)
block|{
name|uint32_t
name|status
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SAVAGE_EVENT_USEC_TIMEOUT
condition|;
name|i
operator|++
control|)
block|{
name|DRM_MEMORYBARRIER
argument_list|()
expr_stmt|;
name|status
operator|=
name|dev_priv
operator|->
name|status_ptr
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|(
operator|(
operator|(
name|status
operator|&
literal|0xffff
operator|)
operator|-
name|e
operator|)
operator|&
literal|0xffff
operator|)
operator|<=
literal|0x7fff
operator|||
operator|(
name|status
operator|&
literal|0xffff
operator|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|DRM_UDELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|SAVAGE_BCI_DEBUG
name|DRM_ERROR
argument_list|(
literal|"failed!\n"
argument_list|)
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|"   status=0x%08x, e=0x%04x\n"
argument_list|,
name|status
argument_list|,
name|e
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|-
name|EBUSY
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|savage_bci_wait_event_reg
parameter_list|(
name|drm_savage_private_t
modifier|*
name|dev_priv
parameter_list|,
name|uint16_t
name|e
parameter_list|)
block|{
name|uint32_t
name|status
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SAVAGE_EVENT_USEC_TIMEOUT
condition|;
name|i
operator|++
control|)
block|{
name|status
operator|=
name|SAVAGE_READ
argument_list|(
name|SAVAGE_STATUS_WORD1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
operator|(
name|status
operator|&
literal|0xffff
operator|)
operator|-
name|e
operator|)
operator|&
literal|0xffff
operator|)
operator|<=
literal|0x7fff
operator|||
operator|(
name|status
operator|&
literal|0xffff
operator|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|DRM_UDELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|SAVAGE_BCI_DEBUG
name|DRM_ERROR
argument_list|(
literal|"failed!\n"
argument_list|)
expr_stmt|;
name|DRM_INFO
argument_list|(
literal|"   status=0x%08x, e=0x%04x\n"
argument_list|,
name|status
argument_list|,
name|e
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|-
name|EBUSY
return|;
block|}
end_function

begin_function
name|uint16_t
name|savage_bci_emit_event
parameter_list|(
name|drm_savage_private_t
modifier|*
name|dev_priv
parameter_list|,
name|unsigned
name|int
name|flags
parameter_list|)
block|{
name|uint16_t
name|count
decl_stmt|;
name|BCI_LOCALS
expr_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|status_ptr
condition|)
block|{
comment|/* coordinate with Xserver */
name|count
operator|=
name|dev_priv
operator|->
name|status_ptr
index|[
literal|1023
index|]
expr_stmt|;
if|if
condition|(
name|count
operator|<
name|dev_priv
operator|->
name|event_counter
condition|)
name|dev_priv
operator|->
name|event_wrap
operator|++
expr_stmt|;
block|}
else|else
block|{
name|count
operator|=
name|dev_priv
operator|->
name|event_counter
expr_stmt|;
block|}
name|count
operator|=
operator|(
name|count
operator|+
literal|1
operator|)
operator|&
literal|0xffff
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
name|count
operator|++
expr_stmt|;
comment|/* See the comment above savage_wait_event_*. */
name|dev_priv
operator|->
name|event_wrap
operator|++
expr_stmt|;
block|}
name|dev_priv
operator|->
name|event_counter
operator|=
name|count
expr_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|status_ptr
condition|)
name|dev_priv
operator|->
name|status_ptr
index|[
literal|1023
index|]
operator|=
operator|(
name|uint32_t
operator|)
name|count
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
operator|(
name|SAVAGE_WAIT_2D
operator||
name|SAVAGE_WAIT_3D
operator|)
operator|)
condition|)
block|{
name|unsigned
name|int
name|wait_cmd
init|=
name|BCI_CMD_WAIT
decl_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|SAVAGE_WAIT_2D
operator|)
condition|)
name|wait_cmd
operator||=
name|BCI_CMD_WAIT_2D
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|SAVAGE_WAIT_3D
operator|)
condition|)
name|wait_cmd
operator||=
name|BCI_CMD_WAIT_3D
expr_stmt|;
name|BEGIN_BCI
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|BCI_WRITE
argument_list|(
name|wait_cmd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|BEGIN_BCI
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|BCI_WRITE
argument_list|(
name|BCI_CMD_UPDATE_EVENT_TAG
operator||
operator|(
name|uint32_t
operator|)
name|count
argument_list|)
expr_stmt|;
return|return
name|count
return|;
block|}
end_function

begin_comment
comment|/*  * Freelist management  */
end_comment

begin_function
specifier|static
name|int
name|savage_freelist_init
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|drm_savage_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|drm_device_dma
modifier|*
name|dma
init|=
name|dev
operator|->
name|dma
decl_stmt|;
name|struct
name|drm_buf
modifier|*
name|buf
decl_stmt|;
name|drm_savage_buf_priv_t
modifier|*
name|entry
decl_stmt|;
name|int
name|i
decl_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"count=%d\n"
argument_list|,
name|dma
operator|->
name|buf_count
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|head
operator|.
name|next
operator|=
operator|&
name|dev_priv
operator|->
name|tail
expr_stmt|;
name|dev_priv
operator|->
name|head
operator|.
name|prev
operator|=
name|NULL
expr_stmt|;
name|dev_priv
operator|->
name|head
operator|.
name|buf
operator|=
name|NULL
expr_stmt|;
name|dev_priv
operator|->
name|tail
operator|.
name|next
operator|=
name|NULL
expr_stmt|;
name|dev_priv
operator|->
name|tail
operator|.
name|prev
operator|=
operator|&
name|dev_priv
operator|->
name|head
expr_stmt|;
name|dev_priv
operator|->
name|tail
operator|.
name|buf
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dma
operator|->
name|buf_count
condition|;
name|i
operator|++
control|)
block|{
name|buf
operator|=
name|dma
operator|->
name|buflist
index|[
name|i
index|]
expr_stmt|;
name|entry
operator|=
name|buf
operator|->
name|dev_private
expr_stmt|;
name|SET_AGE
argument_list|(
operator|&
name|entry
operator|->
name|age
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|entry
operator|->
name|buf
operator|=
name|buf
expr_stmt|;
name|entry
operator|->
name|next
operator|=
name|dev_priv
operator|->
name|head
operator|.
name|next
expr_stmt|;
name|entry
operator|->
name|prev
operator|=
operator|&
name|dev_priv
operator|->
name|head
expr_stmt|;
name|dev_priv
operator|->
name|head
operator|.
name|next
operator|->
name|prev
operator|=
name|entry
expr_stmt|;
name|dev_priv
operator|->
name|head
operator|.
name|next
operator|=
name|entry
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|drm_buf
modifier|*
name|savage_freelist_get
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|drm_savage_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|drm_savage_buf_priv_t
modifier|*
name|tail
init|=
name|dev_priv
operator|->
name|tail
operator|.
name|prev
decl_stmt|;
name|uint16_t
name|event
decl_stmt|;
name|unsigned
name|int
name|wrap
decl_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|UPDATE_EVENT_COUNTER
argument_list|()
expr_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|status_ptr
condition|)
name|event
operator|=
name|dev_priv
operator|->
name|status_ptr
index|[
literal|1
index|]
operator|&
literal|0xffff
expr_stmt|;
else|else
name|event
operator|=
name|SAVAGE_READ
argument_list|(
name|SAVAGE_STATUS_WORD1
argument_list|)
operator|&
literal|0xffff
expr_stmt|;
name|wrap
operator|=
name|dev_priv
operator|->
name|event_wrap
expr_stmt|;
if|if
condition|(
name|event
operator|>
name|dev_priv
operator|->
name|event_counter
condition|)
name|wrap
operator|--
expr_stmt|;
comment|/* hardware hasn't passed the last wrap yet */
name|DRM_DEBUG
argument_list|(
literal|"   tail=0x%04x %d\n"
argument_list|,
name|tail
operator|->
name|age
operator|.
name|event
argument_list|,
name|tail
operator|->
name|age
operator|.
name|wrap
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"   head=0x%04x %d\n"
argument_list|,
name|event
argument_list|,
name|wrap
argument_list|)
expr_stmt|;
if|if
condition|(
name|tail
operator|->
name|buf
operator|&&
operator|(
name|TEST_AGE
argument_list|(
operator|&
name|tail
operator|->
name|age
argument_list|,
name|event
argument_list|,
name|wrap
argument_list|)
operator|||
name|event
operator|==
literal|0
operator|)
condition|)
block|{
name|drm_savage_buf_priv_t
modifier|*
name|next
init|=
name|tail
operator|->
name|next
decl_stmt|;
name|drm_savage_buf_priv_t
modifier|*
name|prev
init|=
name|tail
operator|->
name|prev
decl_stmt|;
name|prev
operator|->
name|next
operator|=
name|next
expr_stmt|;
name|next
operator|->
name|prev
operator|=
name|prev
expr_stmt|;
name|tail
operator|->
name|next
operator|=
name|tail
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
return|return
name|tail
operator|->
name|buf
return|;
block|}
name|DRM_DEBUG
argument_list|(
literal|"returning NULL, tail->buf=%p!\n"
argument_list|,
name|tail
operator|->
name|buf
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|void
name|savage_freelist_put
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_buf
modifier|*
name|buf
parameter_list|)
block|{
name|drm_savage_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|drm_savage_buf_priv_t
modifier|*
name|entry
init|=
name|buf
operator|->
name|dev_private
decl_stmt|,
modifier|*
name|prev
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"age=0x%04x wrap=%d\n"
argument_list|,
name|entry
operator|->
name|age
operator|.
name|event
argument_list|,
name|entry
operator|->
name|age
operator|.
name|wrap
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|next
operator|!=
name|NULL
operator|||
name|entry
operator|->
name|prev
operator|!=
name|NULL
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"entry already on freelist.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|prev
operator|=
operator|&
name|dev_priv
operator|->
name|head
expr_stmt|;
name|next
operator|=
name|prev
operator|->
name|next
expr_stmt|;
name|prev
operator|->
name|next
operator|=
name|entry
expr_stmt|;
name|next
operator|->
name|prev
operator|=
name|entry
expr_stmt|;
name|entry
operator|->
name|prev
operator|=
name|prev
expr_stmt|;
name|entry
operator|->
name|next
operator|=
name|next
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Command DMA  */
end_comment

begin_function
specifier|static
name|int
name|savage_dma_init
parameter_list|(
name|drm_savage_private_t
modifier|*
name|dev_priv
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|dev_priv
operator|->
name|nr_dma_pages
operator|=
name|dev_priv
operator|->
name|cmd_dma
operator|->
name|size
operator|/
operator|(
name|SAVAGE_DMA_PAGE_SIZE
operator|*
literal|4
operator|)
expr_stmt|;
name|dev_priv
operator|->
name|dma_pages
operator|=
name|drm_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|drm_savage_dma_page_t
argument_list|)
operator|*
name|dev_priv
operator|->
name|nr_dma_pages
argument_list|,
name|DRM_MEM_DRIVER
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|dma_pages
operator|==
name|NULL
condition|)
return|return
operator|-
name|ENOMEM
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dev_priv
operator|->
name|nr_dma_pages
condition|;
operator|++
name|i
control|)
block|{
name|SET_AGE
argument_list|(
operator|&
name|dev_priv
operator|->
name|dma_pages
index|[
name|i
index|]
operator|.
name|age
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|dma_pages
index|[
name|i
index|]
operator|.
name|used
operator|=
literal|0
expr_stmt|;
name|dev_priv
operator|->
name|dma_pages
index|[
name|i
index|]
operator|.
name|flushed
operator|=
literal|0
expr_stmt|;
block|}
name|SET_AGE
argument_list|(
operator|&
name|dev_priv
operator|->
name|last_dma_age
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|first_dma_page
operator|=
literal|0
expr_stmt|;
name|dev_priv
operator|->
name|current_dma_page
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|savage_dma_reset
parameter_list|(
name|drm_savage_private_t
modifier|*
name|dev_priv
parameter_list|)
block|{
name|uint16_t
name|event
decl_stmt|;
name|unsigned
name|int
name|wrap
decl_stmt|,
name|i
decl_stmt|;
name|event
operator|=
name|savage_bci_emit_event
argument_list|(
name|dev_priv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wrap
operator|=
name|dev_priv
operator|->
name|event_wrap
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dev_priv
operator|->
name|nr_dma_pages
condition|;
operator|++
name|i
control|)
block|{
name|SET_AGE
argument_list|(
operator|&
name|dev_priv
operator|->
name|dma_pages
index|[
name|i
index|]
operator|.
name|age
argument_list|,
name|event
argument_list|,
name|wrap
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|dma_pages
index|[
name|i
index|]
operator|.
name|used
operator|=
literal|0
expr_stmt|;
name|dev_priv
operator|->
name|dma_pages
index|[
name|i
index|]
operator|.
name|flushed
operator|=
literal|0
expr_stmt|;
block|}
name|SET_AGE
argument_list|(
operator|&
name|dev_priv
operator|->
name|last_dma_age
argument_list|,
name|event
argument_list|,
name|wrap
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|first_dma_page
operator|=
name|dev_priv
operator|->
name|current_dma_page
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|savage_dma_wait
parameter_list|(
name|drm_savage_private_t
modifier|*
name|dev_priv
parameter_list|,
name|unsigned
name|int
name|page
parameter_list|)
block|{
name|uint16_t
name|event
decl_stmt|;
name|unsigned
name|int
name|wrap
decl_stmt|;
comment|/* Faked DMA buffer pages don't age. */
if|if
condition|(
name|dev_priv
operator|->
name|cmd_dma
operator|==
operator|&
name|dev_priv
operator|->
name|fake_dma
condition|)
return|return;
name|UPDATE_EVENT_COUNTER
argument_list|()
expr_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|status_ptr
condition|)
name|event
operator|=
name|dev_priv
operator|->
name|status_ptr
index|[
literal|1
index|]
operator|&
literal|0xffff
expr_stmt|;
else|else
name|event
operator|=
name|SAVAGE_READ
argument_list|(
name|SAVAGE_STATUS_WORD1
argument_list|)
operator|&
literal|0xffff
expr_stmt|;
name|wrap
operator|=
name|dev_priv
operator|->
name|event_wrap
expr_stmt|;
if|if
condition|(
name|event
operator|>
name|dev_priv
operator|->
name|event_counter
condition|)
name|wrap
operator|--
expr_stmt|;
comment|/* hardware hasn't passed the last wrap yet */
if|if
condition|(
name|dev_priv
operator|->
name|dma_pages
index|[
name|page
index|]
operator|.
name|age
operator|.
name|wrap
operator|>
name|wrap
operator|||
operator|(
name|dev_priv
operator|->
name|dma_pages
index|[
name|page
index|]
operator|.
name|age
operator|.
name|wrap
operator|==
name|wrap
operator|&&
name|dev_priv
operator|->
name|dma_pages
index|[
name|page
index|]
operator|.
name|age
operator|.
name|event
operator|>
name|event
operator|)
condition|)
block|{
if|if
condition|(
name|dev_priv
operator|->
name|wait_evnt
argument_list|(
name|dev_priv
argument_list|,
name|dev_priv
operator|->
name|dma_pages
index|[
name|page
index|]
operator|.
name|age
operator|.
name|event
argument_list|)
operator|<
literal|0
condition|)
name|DRM_ERROR
argument_list|(
literal|"wait_evnt failed!\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|uint32_t
modifier|*
name|savage_dma_alloc
parameter_list|(
name|drm_savage_private_t
modifier|*
name|dev_priv
parameter_list|,
name|unsigned
name|int
name|n
parameter_list|)
block|{
name|unsigned
name|int
name|cur
init|=
name|dev_priv
operator|->
name|current_dma_page
decl_stmt|;
name|unsigned
name|int
name|rest
init|=
name|SAVAGE_DMA_PAGE_SIZE
operator|-
name|dev_priv
operator|->
name|dma_pages
index|[
name|cur
index|]
operator|.
name|used
decl_stmt|;
name|unsigned
name|int
name|nr_pages
init|=
operator|(
name|n
operator|-
name|rest
operator|+
name|SAVAGE_DMA_PAGE_SIZE
operator|-
literal|1
operator|)
operator|/
name|SAVAGE_DMA_PAGE_SIZE
decl_stmt|;
name|uint32_t
modifier|*
name|dma_ptr
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"cur=%u, cur->used=%u, n=%u, rest=%u, nr_pages=%u\n"
argument_list|,
name|cur
argument_list|,
name|dev_priv
operator|->
name|dma_pages
index|[
name|cur
index|]
operator|.
name|used
argument_list|,
name|n
argument_list|,
name|rest
argument_list|,
name|nr_pages
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur
operator|+
name|nr_pages
operator|<
name|dev_priv
operator|->
name|nr_dma_pages
condition|)
block|{
name|dma_ptr
operator|=
operator|(
name|uint32_t
operator|*
operator|)
name|dev_priv
operator|->
name|cmd_dma
operator|->
name|virtual
operator|+
name|cur
operator|*
name|SAVAGE_DMA_PAGE_SIZE
operator|+
name|dev_priv
operator|->
name|dma_pages
index|[
name|cur
index|]
operator|.
name|used
expr_stmt|;
if|if
condition|(
name|n
operator|<
name|rest
condition|)
name|rest
operator|=
name|n
expr_stmt|;
name|dev_priv
operator|->
name|dma_pages
index|[
name|cur
index|]
operator|.
name|used
operator|+=
name|rest
expr_stmt|;
name|n
operator|-=
name|rest
expr_stmt|;
name|cur
operator|++
expr_stmt|;
block|}
else|else
block|{
name|dev_priv
operator|->
name|dma_flush
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
name|nr_pages
operator|=
operator|(
name|n
operator|+
name|SAVAGE_DMA_PAGE_SIZE
operator|-
literal|1
operator|)
operator|/
name|SAVAGE_DMA_PAGE_SIZE
expr_stmt|;
for|for
control|(
name|i
operator|=
name|cur
init|;
name|i
operator|<
name|dev_priv
operator|->
name|nr_dma_pages
condition|;
operator|++
name|i
control|)
block|{
name|dev_priv
operator|->
name|dma_pages
index|[
name|i
index|]
operator|.
name|age
operator|=
name|dev_priv
operator|->
name|last_dma_age
expr_stmt|;
name|dev_priv
operator|->
name|dma_pages
index|[
name|i
index|]
operator|.
name|used
operator|=
literal|0
expr_stmt|;
name|dev_priv
operator|->
name|dma_pages
index|[
name|i
index|]
operator|.
name|flushed
operator|=
literal|0
expr_stmt|;
block|}
name|dma_ptr
operator|=
operator|(
name|uint32_t
operator|*
operator|)
name|dev_priv
operator|->
name|cmd_dma
operator|->
name|virtual
expr_stmt|;
name|dev_priv
operator|->
name|first_dma_page
operator|=
name|cur
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|cur
init|;
name|nr_pages
operator|>
literal|0
condition|;
operator|++
name|i
operator|,
operator|--
name|nr_pages
control|)
block|{
if|#
directive|if
name|SAVAGE_DMA_DEBUG
if|if
condition|(
name|dev_priv
operator|->
name|dma_pages
index|[
name|i
index|]
operator|.
name|used
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"unflushed page %u: used=%u\n"
argument_list|,
name|i
argument_list|,
name|dev_priv
operator|->
name|dma_pages
index|[
name|i
index|]
operator|.
name|used
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|n
operator|>
name|SAVAGE_DMA_PAGE_SIZE
condition|)
name|dev_priv
operator|->
name|dma_pages
index|[
name|i
index|]
operator|.
name|used
operator|=
name|SAVAGE_DMA_PAGE_SIZE
expr_stmt|;
else|else
name|dev_priv
operator|->
name|dma_pages
index|[
name|i
index|]
operator|.
name|used
operator|=
name|n
expr_stmt|;
name|n
operator|-=
name|SAVAGE_DMA_PAGE_SIZE
expr_stmt|;
block|}
name|dev_priv
operator|->
name|current_dma_page
operator|=
operator|--
name|i
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"cur=%u, cur->used=%u, n=%u\n"
argument_list|,
name|i
argument_list|,
name|dev_priv
operator|->
name|dma_pages
index|[
name|i
index|]
operator|.
name|used
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|savage_dma_wait
argument_list|(
name|dev_priv
argument_list|,
name|dev_priv
operator|->
name|current_dma_page
argument_list|)
expr_stmt|;
return|return
name|dma_ptr
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|savage_dma_flush
parameter_list|(
name|drm_savage_private_t
modifier|*
name|dev_priv
parameter_list|)
block|{
name|unsigned
name|int
name|first
init|=
name|dev_priv
operator|->
name|first_dma_page
decl_stmt|;
name|unsigned
name|int
name|cur
init|=
name|dev_priv
operator|->
name|current_dma_page
decl_stmt|;
name|uint16_t
name|event
decl_stmt|;
name|unsigned
name|int
name|wrap
decl_stmt|,
name|pad
decl_stmt|,
name|align
decl_stmt|,
name|len
decl_stmt|,
name|i
decl_stmt|;
name|unsigned
name|long
name|phys_addr
decl_stmt|;
name|BCI_LOCALS
expr_stmt|;
if|if
condition|(
name|first
operator|==
name|cur
operator|&&
name|dev_priv
operator|->
name|dma_pages
index|[
name|cur
index|]
operator|.
name|used
operator|==
name|dev_priv
operator|->
name|dma_pages
index|[
name|cur
index|]
operator|.
name|flushed
condition|)
return|return;
comment|/* pad length to multiples of 2 entries 	 * align start of next DMA block to multiles of 8 entries */
name|pad
operator|=
operator|-
name|dev_priv
operator|->
name|dma_pages
index|[
name|cur
index|]
operator|.
name|used
operator|&
literal|1
expr_stmt|;
name|align
operator|=
operator|-
operator|(
name|dev_priv
operator|->
name|dma_pages
index|[
name|cur
index|]
operator|.
name|used
operator|+
name|pad
operator|)
operator|&
literal|7
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"first=%u, cur=%u, first->flushed=%u, cur->used=%u, "
literal|"pad=%u, align=%u\n"
argument_list|,
name|first
argument_list|,
name|cur
argument_list|,
name|dev_priv
operator|->
name|dma_pages
index|[
name|first
index|]
operator|.
name|flushed
argument_list|,
name|dev_priv
operator|->
name|dma_pages
index|[
name|cur
index|]
operator|.
name|used
argument_list|,
name|pad
argument_list|,
name|align
argument_list|)
expr_stmt|;
comment|/* pad with noops */
if|if
condition|(
name|pad
condition|)
block|{
name|uint32_t
modifier|*
name|dma_ptr
init|=
operator|(
name|uint32_t
operator|*
operator|)
name|dev_priv
operator|->
name|cmd_dma
operator|->
name|virtual
operator|+
name|cur
operator|*
name|SAVAGE_DMA_PAGE_SIZE
operator|+
name|dev_priv
operator|->
name|dma_pages
index|[
name|cur
index|]
operator|.
name|used
decl_stmt|;
name|dev_priv
operator|->
name|dma_pages
index|[
name|cur
index|]
operator|.
name|used
operator|+=
name|pad
expr_stmt|;
while|while
condition|(
name|pad
operator|!=
literal|0
condition|)
block|{
operator|*
name|dma_ptr
operator|++
operator|=
name|BCI_CMD_WAIT
expr_stmt|;
name|pad
operator|--
expr_stmt|;
block|}
block|}
name|DRM_MEMORYBARRIER
argument_list|()
expr_stmt|;
comment|/* do flush ... */
name|phys_addr
operator|=
name|dev_priv
operator|->
name|cmd_dma
operator|->
name|offset
operator|+
operator|(
name|first
operator|*
name|SAVAGE_DMA_PAGE_SIZE
operator|+
name|dev_priv
operator|->
name|dma_pages
index|[
name|first
index|]
operator|.
name|flushed
operator|)
operator|*
literal|4
expr_stmt|;
name|len
operator|=
operator|(
name|cur
operator|-
name|first
operator|)
operator|*
name|SAVAGE_DMA_PAGE_SIZE
operator|+
name|dev_priv
operator|->
name|dma_pages
index|[
name|cur
index|]
operator|.
name|used
operator|-
name|dev_priv
operator|->
name|dma_pages
index|[
name|first
index|]
operator|.
name|flushed
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"phys_addr=%lx, len=%u\n"
argument_list|,
name|phys_addr
operator||
name|dev_priv
operator|->
name|dma_type
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|BEGIN_BCI
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|BCI_SET_REGISTERS
argument_list|(
name|SAVAGE_DMABUFADDR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|BCI_WRITE
argument_list|(
name|phys_addr
operator||
name|dev_priv
operator|->
name|dma_type
argument_list|)
expr_stmt|;
name|BCI_DMA
argument_list|(
name|len
argument_list|)
expr_stmt|;
comment|/* fix alignment of the start of the next block */
name|dev_priv
operator|->
name|dma_pages
index|[
name|cur
index|]
operator|.
name|used
operator|+=
name|align
expr_stmt|;
comment|/* age DMA pages */
name|event
operator|=
name|savage_bci_emit_event
argument_list|(
name|dev_priv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wrap
operator|=
name|dev_priv
operator|->
name|event_wrap
expr_stmt|;
for|for
control|(
name|i
operator|=
name|first
init|;
name|i
operator|<
name|cur
condition|;
operator|++
name|i
control|)
block|{
name|SET_AGE
argument_list|(
operator|&
name|dev_priv
operator|->
name|dma_pages
index|[
name|i
index|]
operator|.
name|age
argument_list|,
name|event
argument_list|,
name|wrap
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|dma_pages
index|[
name|i
index|]
operator|.
name|used
operator|=
literal|0
expr_stmt|;
name|dev_priv
operator|->
name|dma_pages
index|[
name|i
index|]
operator|.
name|flushed
operator|=
literal|0
expr_stmt|;
block|}
comment|/* age the current page only when it's full */
if|if
condition|(
name|dev_priv
operator|->
name|dma_pages
index|[
name|cur
index|]
operator|.
name|used
operator|==
name|SAVAGE_DMA_PAGE_SIZE
condition|)
block|{
name|SET_AGE
argument_list|(
operator|&
name|dev_priv
operator|->
name|dma_pages
index|[
name|cur
index|]
operator|.
name|age
argument_list|,
name|event
argument_list|,
name|wrap
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|dma_pages
index|[
name|cur
index|]
operator|.
name|used
operator|=
literal|0
expr_stmt|;
name|dev_priv
operator|->
name|dma_pages
index|[
name|cur
index|]
operator|.
name|flushed
operator|=
literal|0
expr_stmt|;
comment|/* advance to next page */
name|cur
operator|++
expr_stmt|;
if|if
condition|(
name|cur
operator|==
name|dev_priv
operator|->
name|nr_dma_pages
condition|)
name|cur
operator|=
literal|0
expr_stmt|;
name|dev_priv
operator|->
name|first_dma_page
operator|=
name|dev_priv
operator|->
name|current_dma_page
operator|=
name|cur
expr_stmt|;
block|}
else|else
block|{
name|dev_priv
operator|->
name|first_dma_page
operator|=
name|cur
expr_stmt|;
name|dev_priv
operator|->
name|dma_pages
index|[
name|cur
index|]
operator|.
name|flushed
operator|=
name|dev_priv
operator|->
name|dma_pages
index|[
name|i
index|]
operator|.
name|used
expr_stmt|;
block|}
name|SET_AGE
argument_list|(
operator|&
name|dev_priv
operator|->
name|last_dma_age
argument_list|,
name|event
argument_list|,
name|wrap
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"first=cur=%u, cur->used=%u, cur->flushed=%u\n"
argument_list|,
name|cur
argument_list|,
name|dev_priv
operator|->
name|dma_pages
index|[
name|cur
index|]
operator|.
name|used
argument_list|,
name|dev_priv
operator|->
name|dma_pages
index|[
name|cur
index|]
operator|.
name|flushed
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|savage_fake_dma_flush
parameter_list|(
name|drm_savage_private_t
modifier|*
name|dev_priv
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|BCI_LOCALS
expr_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|first_dma_page
operator|==
name|dev_priv
operator|->
name|current_dma_page
operator|&&
name|dev_priv
operator|->
name|dma_pages
index|[
name|dev_priv
operator|->
name|current_dma_page
index|]
operator|.
name|used
operator|==
literal|0
condition|)
return|return;
name|DRM_DEBUG
argument_list|(
literal|"first=%u, cur=%u, cur->used=%u\n"
argument_list|,
name|dev_priv
operator|->
name|first_dma_page
argument_list|,
name|dev_priv
operator|->
name|current_dma_page
argument_list|,
name|dev_priv
operator|->
name|dma_pages
index|[
name|dev_priv
operator|->
name|current_dma_page
index|]
operator|.
name|used
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|dev_priv
operator|->
name|first_dma_page
init|;
name|i
operator|<=
name|dev_priv
operator|->
name|current_dma_page
operator|&&
name|dev_priv
operator|->
name|dma_pages
index|[
name|i
index|]
operator|.
name|used
condition|;
operator|++
name|i
control|)
block|{
name|uint32_t
modifier|*
name|dma_ptr
init|=
operator|(
name|uint32_t
operator|*
operator|)
name|dev_priv
operator|->
name|cmd_dma
operator|->
name|virtual
operator|+
name|i
operator|*
name|SAVAGE_DMA_PAGE_SIZE
decl_stmt|;
if|#
directive|if
name|SAVAGE_DMA_DEBUG
comment|/* Sanity check: all pages except the last one must be full. */
if|if
condition|(
name|i
operator|<
name|dev_priv
operator|->
name|current_dma_page
operator|&&
name|dev_priv
operator|->
name|dma_pages
index|[
name|i
index|]
operator|.
name|used
operator|!=
name|SAVAGE_DMA_PAGE_SIZE
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"partial DMA page %u: used=%u"
argument_list|,
name|i
argument_list|,
name|dev_priv
operator|->
name|dma_pages
index|[
name|i
index|]
operator|.
name|used
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|BEGIN_BCI
argument_list|(
name|dev_priv
operator|->
name|dma_pages
index|[
name|i
index|]
operator|.
name|used
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|dev_priv
operator|->
name|dma_pages
index|[
name|i
index|]
operator|.
name|used
condition|;
operator|++
name|j
control|)
block|{
name|BCI_WRITE
argument_list|(
name|dma_ptr
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
name|dev_priv
operator|->
name|dma_pages
index|[
name|i
index|]
operator|.
name|used
operator|=
literal|0
expr_stmt|;
block|}
comment|/* reset to first page */
name|dev_priv
operator|->
name|first_dma_page
operator|=
name|dev_priv
operator|->
name|current_dma_page
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|int
name|savage_driver_load
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|unsigned
name|long
name|chipset
parameter_list|)
block|{
name|drm_savage_private_t
modifier|*
name|dev_priv
decl_stmt|;
name|dev_priv
operator|=
name|drm_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|drm_savage_private_t
argument_list|)
argument_list|,
name|DRM_MEM_DRIVER
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev_priv
operator|==
name|NULL
condition|)
return|return
operator|-
name|ENOMEM
return|;
name|memset
argument_list|(
name|dev_priv
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|drm_savage_private_t
argument_list|)
argument_list|)
expr_stmt|;
name|dev
operator|->
name|dev_private
operator|=
operator|(
name|void
operator|*
operator|)
name|dev_priv
expr_stmt|;
name|dev_priv
operator|->
name|chipset
operator|=
operator|(
expr|enum
name|savage_family
operator|)
name|chipset
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Initialize mappings. On Savage4 and SavageIX the alignment  * and size of the aperture is not suitable for automatic MTRR setup  * in drm_addmap. Therefore we add them manually before the maps are  * initialized, and tear them down on last close.  */
end_comment

begin_function
name|int
name|savage_driver_firstopen
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|drm_savage_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|unsigned
name|long
name|mmio_base
decl_stmt|,
name|fb_base
decl_stmt|,
name|fb_size
decl_stmt|,
name|aperture_base
decl_stmt|;
comment|/* fb_rsrc and aper_rsrc aren't really used currently, but still exist 	 * in case we decide we need information on the BAR for BSD in the 	 * future. 	 */
name|unsigned
name|int
name|fb_rsrc
decl_stmt|,
name|aper_rsrc
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|dev_priv
operator|->
name|mtrr
index|[
literal|0
index|]
operator|.
name|handle
operator|=
operator|-
literal|1
expr_stmt|;
name|dev_priv
operator|->
name|mtrr
index|[
literal|1
index|]
operator|.
name|handle
operator|=
operator|-
literal|1
expr_stmt|;
name|dev_priv
operator|->
name|mtrr
index|[
literal|2
index|]
operator|.
name|handle
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|S3_SAVAGE3D_SERIES
argument_list|(
name|dev_priv
operator|->
name|chipset
argument_list|)
condition|)
block|{
name|fb_rsrc
operator|=
literal|0
expr_stmt|;
name|fb_base
operator|=
name|drm_get_resource_start
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fb_size
operator|=
name|SAVAGE_FB_SIZE_S3
expr_stmt|;
name|mmio_base
operator|=
name|fb_base
operator|+
name|SAVAGE_FB_SIZE_S3
expr_stmt|;
name|aper_rsrc
operator|=
literal|0
expr_stmt|;
name|aperture_base
operator|=
name|fb_base
operator|+
name|SAVAGE_APERTURE_OFFSET
expr_stmt|;
comment|/* this should always be true */
if|if
condition|(
name|drm_get_resource_len
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|)
operator|==
literal|0x08000000
condition|)
block|{
comment|/* Don't make MMIO write-cobining! We need 3 			 * MTRRs. */
name|dev_priv
operator|->
name|mtrr
index|[
literal|0
index|]
operator|.
name|base
operator|=
name|fb_base
expr_stmt|;
name|dev_priv
operator|->
name|mtrr
index|[
literal|0
index|]
operator|.
name|size
operator|=
literal|0x01000000
expr_stmt|;
name|dev_priv
operator|->
name|mtrr
index|[
literal|0
index|]
operator|.
name|handle
operator|=
name|drm_mtrr_add
argument_list|(
name|dev_priv
operator|->
name|mtrr
index|[
literal|0
index|]
operator|.
name|base
argument_list|,
name|dev_priv
operator|->
name|mtrr
index|[
literal|0
index|]
operator|.
name|size
argument_list|,
name|DRM_MTRR_WC
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|mtrr
index|[
literal|1
index|]
operator|.
name|base
operator|=
name|fb_base
operator|+
literal|0x02000000
expr_stmt|;
name|dev_priv
operator|->
name|mtrr
index|[
literal|1
index|]
operator|.
name|size
operator|=
literal|0x02000000
expr_stmt|;
name|dev_priv
operator|->
name|mtrr
index|[
literal|1
index|]
operator|.
name|handle
operator|=
name|drm_mtrr_add
argument_list|(
name|dev_priv
operator|->
name|mtrr
index|[
literal|1
index|]
operator|.
name|base
argument_list|,
name|dev_priv
operator|->
name|mtrr
index|[
literal|1
index|]
operator|.
name|size
argument_list|,
name|DRM_MTRR_WC
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|mtrr
index|[
literal|2
index|]
operator|.
name|base
operator|=
name|fb_base
operator|+
literal|0x04000000
expr_stmt|;
name|dev_priv
operator|->
name|mtrr
index|[
literal|2
index|]
operator|.
name|size
operator|=
literal|0x04000000
expr_stmt|;
name|dev_priv
operator|->
name|mtrr
index|[
literal|2
index|]
operator|.
name|handle
operator|=
name|drm_mtrr_add
argument_list|(
name|dev_priv
operator|->
name|mtrr
index|[
literal|2
index|]
operator|.
name|base
argument_list|,
name|dev_priv
operator|->
name|mtrr
index|[
literal|2
index|]
operator|.
name|size
argument_list|,
name|DRM_MTRR_WC
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DRM_ERROR
argument_list|(
literal|"strange pci_resource_len %08lx\n"
argument_list|,
name|drm_get_resource_len
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|dev_priv
operator|->
name|chipset
operator|!=
name|S3_SUPERSAVAGE
operator|&&
name|dev_priv
operator|->
name|chipset
operator|!=
name|S3_SAVAGE2000
condition|)
block|{
name|mmio_base
operator|=
name|drm_get_resource_start
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fb_rsrc
operator|=
literal|1
expr_stmt|;
name|fb_base
operator|=
name|drm_get_resource_start
argument_list|(
name|dev
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fb_size
operator|=
name|SAVAGE_FB_SIZE_S4
expr_stmt|;
name|aper_rsrc
operator|=
literal|1
expr_stmt|;
name|aperture_base
operator|=
name|fb_base
operator|+
name|SAVAGE_APERTURE_OFFSET
expr_stmt|;
comment|/* this should always be true */
if|if
condition|(
name|drm_get_resource_len
argument_list|(
name|dev
argument_list|,
literal|1
argument_list|)
operator|==
literal|0x08000000
condition|)
block|{
comment|/* Can use one MTRR to cover both fb and 			 * aperture. */
name|dev_priv
operator|->
name|mtrr
index|[
literal|0
index|]
operator|.
name|base
operator|=
name|fb_base
expr_stmt|;
name|dev_priv
operator|->
name|mtrr
index|[
literal|0
index|]
operator|.
name|size
operator|=
literal|0x08000000
expr_stmt|;
name|dev_priv
operator|->
name|mtrr
index|[
literal|0
index|]
operator|.
name|handle
operator|=
name|drm_mtrr_add
argument_list|(
name|dev_priv
operator|->
name|mtrr
index|[
literal|0
index|]
operator|.
name|base
argument_list|,
name|dev_priv
operator|->
name|mtrr
index|[
literal|0
index|]
operator|.
name|size
argument_list|,
name|DRM_MTRR_WC
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DRM_ERROR
argument_list|(
literal|"strange pci_resource_len %08lx\n"
argument_list|,
name|drm_get_resource_len
argument_list|(
name|dev
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|mmio_base
operator|=
name|drm_get_resource_start
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fb_rsrc
operator|=
literal|1
expr_stmt|;
name|fb_base
operator|=
name|drm_get_resource_start
argument_list|(
name|dev
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fb_size
operator|=
name|drm_get_resource_len
argument_list|(
name|dev
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|aper_rsrc
operator|=
literal|2
expr_stmt|;
name|aperture_base
operator|=
name|drm_get_resource_start
argument_list|(
name|dev
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Automatic MTRR setup will do the right thing. */
block|}
name|ret
operator|=
name|drm_addmap
argument_list|(
name|dev
argument_list|,
name|mmio_base
argument_list|,
name|SAVAGE_MMIO_SIZE
argument_list|,
name|_DRM_REGISTERS
argument_list|,
name|_DRM_READ_ONLY
argument_list|,
operator|&
name|dev_priv
operator|->
name|mmio
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|ret
operator|=
name|drm_addmap
argument_list|(
name|dev
argument_list|,
name|fb_base
argument_list|,
name|fb_size
argument_list|,
name|_DRM_FRAME_BUFFER
argument_list|,
name|_DRM_WRITE_COMBINING
argument_list|,
operator|&
name|dev_priv
operator|->
name|fb
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|ret
operator|=
name|drm_addmap
argument_list|(
name|dev
argument_list|,
name|aperture_base
argument_list|,
name|SAVAGE_APERTURE_SIZE
argument_list|,
name|_DRM_FRAME_BUFFER
argument_list|,
name|_DRM_WRITE_COMBINING
argument_list|,
operator|&
name|dev_priv
operator|->
name|aperture
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * Delete MTRRs and free device-private data.  */
end_comment

begin_function
name|void
name|savage_driver_lastclose
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|drm_savage_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|dev_priv
operator|->
name|mtrr
index|[
name|i
index|]
operator|.
name|handle
operator|>=
literal|0
condition|)
name|drm_mtrr_del
argument_list|(
name|dev_priv
operator|->
name|mtrr
index|[
name|i
index|]
operator|.
name|handle
argument_list|,
name|dev_priv
operator|->
name|mtrr
index|[
name|i
index|]
operator|.
name|base
argument_list|,
name|dev_priv
operator|->
name|mtrr
index|[
name|i
index|]
operator|.
name|size
argument_list|,
name|DRM_MTRR_WC
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|savage_driver_unload
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|drm_savage_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|drm_free
argument_list|(
name|dev_priv
argument_list|,
sizeof|sizeof
argument_list|(
name|drm_savage_private_t
argument_list|)
argument_list|,
name|DRM_MEM_DRIVER
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|savage_do_init_bci
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|drm_savage_init_t
modifier|*
name|init
parameter_list|)
block|{
name|drm_savage_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
if|if
condition|(
name|init
operator|->
name|fb_bpp
operator|!=
literal|16
operator|&&
name|init
operator|->
name|fb_bpp
operator|!=
literal|32
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"invalid frame buffer bpp %d!\n"
argument_list|,
name|init
operator|->
name|fb_bpp
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
if|if
condition|(
name|init
operator|->
name|depth_bpp
operator|!=
literal|16
operator|&&
name|init
operator|->
name|depth_bpp
operator|!=
literal|32
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"invalid depth buffer bpp %d!\n"
argument_list|,
name|init
operator|->
name|fb_bpp
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
if|if
condition|(
name|init
operator|->
name|dma_type
operator|!=
name|SAVAGE_DMA_AGP
operator|&&
name|init
operator|->
name|dma_type
operator|!=
name|SAVAGE_DMA_PCI
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"invalid dma memory type %d!\n"
argument_list|,
name|init
operator|->
name|dma_type
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|dev_priv
operator|->
name|cob_size
operator|=
name|init
operator|->
name|cob_size
expr_stmt|;
name|dev_priv
operator|->
name|bci_threshold_lo
operator|=
name|init
operator|->
name|bci_threshold_lo
expr_stmt|;
name|dev_priv
operator|->
name|bci_threshold_hi
operator|=
name|init
operator|->
name|bci_threshold_hi
expr_stmt|;
name|dev_priv
operator|->
name|dma_type
operator|=
name|init
operator|->
name|dma_type
expr_stmt|;
name|dev_priv
operator|->
name|fb_bpp
operator|=
name|init
operator|->
name|fb_bpp
expr_stmt|;
name|dev_priv
operator|->
name|front_offset
operator|=
name|init
operator|->
name|front_offset
expr_stmt|;
name|dev_priv
operator|->
name|front_pitch
operator|=
name|init
operator|->
name|front_pitch
expr_stmt|;
name|dev_priv
operator|->
name|back_offset
operator|=
name|init
operator|->
name|back_offset
expr_stmt|;
name|dev_priv
operator|->
name|back_pitch
operator|=
name|init
operator|->
name|back_pitch
expr_stmt|;
name|dev_priv
operator|->
name|depth_bpp
operator|=
name|init
operator|->
name|depth_bpp
expr_stmt|;
name|dev_priv
operator|->
name|depth_offset
operator|=
name|init
operator|->
name|depth_offset
expr_stmt|;
name|dev_priv
operator|->
name|depth_pitch
operator|=
name|init
operator|->
name|depth_pitch
expr_stmt|;
name|dev_priv
operator|->
name|texture_offset
operator|=
name|init
operator|->
name|texture_offset
expr_stmt|;
name|dev_priv
operator|->
name|texture_size
operator|=
name|init
operator|->
name|texture_size
expr_stmt|;
name|dev_priv
operator|->
name|sarea
operator|=
name|drm_getsarea
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dev_priv
operator|->
name|sarea
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"could not find sarea!\n"
argument_list|)
expr_stmt|;
name|savage_do_cleanup_bci
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
if|if
condition|(
name|init
operator|->
name|status_offset
operator|!=
literal|0
condition|)
block|{
name|dev_priv
operator|->
name|status
operator|=
name|drm_core_findmap
argument_list|(
name|dev
argument_list|,
name|init
operator|->
name|status_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dev_priv
operator|->
name|status
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"could not find shadow status region!\n"
argument_list|)
expr_stmt|;
name|savage_do_cleanup_bci
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
block|}
else|else
block|{
name|dev_priv
operator|->
name|status
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|dev_priv
operator|->
name|dma_type
operator|==
name|SAVAGE_DMA_AGP
operator|&&
name|init
operator|->
name|buffers_offset
condition|)
block|{
name|dev
operator|->
name|agp_buffer_token
operator|=
name|init
operator|->
name|buffers_offset
expr_stmt|;
name|dev
operator|->
name|agp_buffer_map
operator|=
name|drm_core_findmap
argument_list|(
name|dev
argument_list|,
name|init
operator|->
name|buffers_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dev
operator|->
name|agp_buffer_map
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"could not find DMA buffer region!\n"
argument_list|)
expr_stmt|;
name|savage_do_cleanup_bci
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|drm_core_ioremap
argument_list|(
name|dev
operator|->
name|agp_buffer_map
argument_list|,
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dev
operator|->
name|agp_buffer_map
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"failed to ioremap DMA buffer region!\n"
argument_list|)
expr_stmt|;
name|savage_do_cleanup_bci
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
block|}
block|}
if|if
condition|(
name|init
operator|->
name|agp_textures_offset
condition|)
block|{
name|dev_priv
operator|->
name|agp_textures
operator|=
name|drm_core_findmap
argument_list|(
name|dev
argument_list|,
name|init
operator|->
name|agp_textures_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dev_priv
operator|->
name|agp_textures
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"could not find agp texture region!\n"
argument_list|)
expr_stmt|;
name|savage_do_cleanup_bci
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
block|}
else|else
block|{
name|dev_priv
operator|->
name|agp_textures
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|init
operator|->
name|cmd_dma_offset
condition|)
block|{
if|if
condition|(
name|S3_SAVAGE3D_SERIES
argument_list|(
name|dev_priv
operator|->
name|chipset
argument_list|)
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"command DMA not supported on "
literal|"Savage3D/MX/IX.\n"
argument_list|)
expr_stmt|;
name|savage_do_cleanup_bci
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
if|if
condition|(
name|dev
operator|->
name|dma
operator|&&
name|dev
operator|->
name|dma
operator|->
name|buflist
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"command and vertex DMA not supported "
literal|"at the same time.\n"
argument_list|)
expr_stmt|;
name|savage_do_cleanup_bci
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|dev_priv
operator|->
name|cmd_dma
operator|=
name|drm_core_findmap
argument_list|(
name|dev
argument_list|,
name|init
operator|->
name|cmd_dma_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dev_priv
operator|->
name|cmd_dma
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"could not find command DMA region!\n"
argument_list|)
expr_stmt|;
name|savage_do_cleanup_bci
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
if|if
condition|(
name|dev_priv
operator|->
name|dma_type
operator|==
name|SAVAGE_DMA_AGP
condition|)
block|{
if|if
condition|(
name|dev_priv
operator|->
name|cmd_dma
operator|->
name|type
operator|!=
name|_DRM_AGP
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"AGP command DMA region is not a "
literal|"_DRM_AGP map!\n"
argument_list|)
expr_stmt|;
name|savage_do_cleanup_bci
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|drm_core_ioremap
argument_list|(
name|dev_priv
operator|->
name|cmd_dma
argument_list|,
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dev_priv
operator|->
name|cmd_dma
operator|->
name|virtual
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"failed to ioremap command "
literal|"DMA region!\n"
argument_list|)
expr_stmt|;
name|savage_do_cleanup_bci
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|dev_priv
operator|->
name|cmd_dma
operator|->
name|type
operator|!=
name|_DRM_CONSISTENT
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"PCI command DMA region is not a "
literal|"_DRM_CONSISTENT map!\n"
argument_list|)
expr_stmt|;
name|savage_do_cleanup_bci
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
block|}
else|else
block|{
name|dev_priv
operator|->
name|cmd_dma
operator|=
name|NULL
expr_stmt|;
block|}
name|dev_priv
operator|->
name|dma_flush
operator|=
name|savage_dma_flush
expr_stmt|;
if|if
condition|(
operator|!
name|dev_priv
operator|->
name|cmd_dma
condition|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"falling back to faked command DMA.\n"
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|fake_dma
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|dev_priv
operator|->
name|fake_dma
operator|.
name|size
operator|=
name|SAVAGE_FAKE_DMA_SIZE
expr_stmt|;
name|dev_priv
operator|->
name|fake_dma
operator|.
name|type
operator|=
name|_DRM_SHM
expr_stmt|;
name|dev_priv
operator|->
name|fake_dma
operator|.
name|virtual
operator|=
name|drm_alloc
argument_list|(
name|SAVAGE_FAKE_DMA_SIZE
argument_list|,
name|DRM_MEM_DRIVER
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dev_priv
operator|->
name|fake_dma
operator|.
name|virtual
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"could not allocate faked DMA buffer!\n"
argument_list|)
expr_stmt|;
name|savage_do_cleanup_bci
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
block|}
name|dev_priv
operator|->
name|cmd_dma
operator|=
operator|&
name|dev_priv
operator|->
name|fake_dma
expr_stmt|;
name|dev_priv
operator|->
name|dma_flush
operator|=
name|savage_fake_dma_flush
expr_stmt|;
block|}
name|dev_priv
operator|->
name|sarea_priv
operator|=
operator|(
name|drm_savage_sarea_t
operator|*
operator|)
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|dev_priv
operator|->
name|sarea
operator|->
name|virtual
operator|+
name|init
operator|->
name|sarea_priv_offset
operator|)
expr_stmt|;
comment|/* setup bitmap descriptors */
block|{
name|unsigned
name|int
name|color_tile_format
decl_stmt|;
name|unsigned
name|int
name|depth_tile_format
decl_stmt|;
name|unsigned
name|int
name|front_stride
decl_stmt|,
name|back_stride
decl_stmt|,
name|depth_stride
decl_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|chipset
operator|<=
name|S3_SAVAGE4
condition|)
block|{
name|color_tile_format
operator|=
name|dev_priv
operator|->
name|fb_bpp
operator|==
literal|16
condition|?
name|SAVAGE_BD_TILE_16BPP
else|:
name|SAVAGE_BD_TILE_32BPP
expr_stmt|;
name|depth_tile_format
operator|=
name|dev_priv
operator|->
name|depth_bpp
operator|==
literal|16
condition|?
name|SAVAGE_BD_TILE_16BPP
else|:
name|SAVAGE_BD_TILE_32BPP
expr_stmt|;
block|}
else|else
block|{
name|color_tile_format
operator|=
name|SAVAGE_BD_TILE_DEST
expr_stmt|;
name|depth_tile_format
operator|=
name|SAVAGE_BD_TILE_DEST
expr_stmt|;
block|}
name|front_stride
operator|=
name|dev_priv
operator|->
name|front_pitch
operator|/
operator|(
name|dev_priv
operator|->
name|fb_bpp
operator|/
literal|8
operator|)
expr_stmt|;
name|back_stride
operator|=
name|dev_priv
operator|->
name|back_pitch
operator|/
operator|(
name|dev_priv
operator|->
name|fb_bpp
operator|/
literal|8
operator|)
expr_stmt|;
name|depth_stride
operator|=
name|dev_priv
operator|->
name|depth_pitch
operator|/
operator|(
name|dev_priv
operator|->
name|depth_bpp
operator|/
literal|8
operator|)
expr_stmt|;
name|dev_priv
operator|->
name|front_bd
operator|=
name|front_stride
operator||
name|SAVAGE_BD_BW_DISABLE
operator||
operator|(
name|dev_priv
operator|->
name|fb_bpp
operator|<<
name|SAVAGE_BD_BPP_SHIFT
operator|)
operator||
operator|(
name|color_tile_format
operator|<<
name|SAVAGE_BD_TILE_SHIFT
operator|)
expr_stmt|;
name|dev_priv
operator|->
name|back_bd
operator|=
name|back_stride
operator||
name|SAVAGE_BD_BW_DISABLE
operator||
operator|(
name|dev_priv
operator|->
name|fb_bpp
operator|<<
name|SAVAGE_BD_BPP_SHIFT
operator|)
operator||
operator|(
name|color_tile_format
operator|<<
name|SAVAGE_BD_TILE_SHIFT
operator|)
expr_stmt|;
name|dev_priv
operator|->
name|depth_bd
operator|=
name|depth_stride
operator||
name|SAVAGE_BD_BW_DISABLE
operator||
operator|(
name|dev_priv
operator|->
name|depth_bpp
operator|<<
name|SAVAGE_BD_BPP_SHIFT
operator|)
operator||
operator|(
name|depth_tile_format
operator|<<
name|SAVAGE_BD_TILE_SHIFT
operator|)
expr_stmt|;
block|}
comment|/* setup status and bci ptr */
name|dev_priv
operator|->
name|event_counter
operator|=
literal|0
expr_stmt|;
name|dev_priv
operator|->
name|event_wrap
operator|=
literal|0
expr_stmt|;
name|dev_priv
operator|->
name|bci_ptr
operator|=
operator|(
specifier|volatile
name|uint32_t
operator|*
operator|)
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|dev_priv
operator|->
name|mmio
operator|->
name|virtual
operator|+
name|SAVAGE_BCI_OFFSET
operator|)
expr_stmt|;
if|if
condition|(
name|S3_SAVAGE3D_SERIES
argument_list|(
name|dev_priv
operator|->
name|chipset
argument_list|)
condition|)
block|{
name|dev_priv
operator|->
name|status_used_mask
operator|=
name|SAVAGE_FIFO_USED_MASK_S3D
expr_stmt|;
block|}
else|else
block|{
name|dev_priv
operator|->
name|status_used_mask
operator|=
name|SAVAGE_FIFO_USED_MASK_S4
expr_stmt|;
block|}
if|if
condition|(
name|dev_priv
operator|->
name|status
operator|!=
name|NULL
condition|)
block|{
name|dev_priv
operator|->
name|status_ptr
operator|=
operator|(
specifier|volatile
name|uint32_t
operator|*
operator|)
name|dev_priv
operator|->
name|status
operator|->
name|virtual
expr_stmt|;
name|dev_priv
operator|->
name|wait_fifo
operator|=
name|savage_bci_wait_fifo_shadow
expr_stmt|;
name|dev_priv
operator|->
name|wait_evnt
operator|=
name|savage_bci_wait_event_shadow
expr_stmt|;
name|dev_priv
operator|->
name|status_ptr
index|[
literal|1023
index|]
operator|=
name|dev_priv
operator|->
name|event_counter
expr_stmt|;
block|}
else|else
block|{
name|dev_priv
operator|->
name|status_ptr
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|S3_SAVAGE3D_SERIES
argument_list|(
name|dev_priv
operator|->
name|chipset
argument_list|)
condition|)
block|{
name|dev_priv
operator|->
name|wait_fifo
operator|=
name|savage_bci_wait_fifo_s3d
expr_stmt|;
block|}
else|else
block|{
name|dev_priv
operator|->
name|wait_fifo
operator|=
name|savage_bci_wait_fifo_s4
expr_stmt|;
block|}
name|dev_priv
operator|->
name|wait_evnt
operator|=
name|savage_bci_wait_event_reg
expr_stmt|;
block|}
comment|/* cliprect functions */
if|if
condition|(
name|S3_SAVAGE3D_SERIES
argument_list|(
name|dev_priv
operator|->
name|chipset
argument_list|)
condition|)
name|dev_priv
operator|->
name|emit_clip_rect
operator|=
name|savage_emit_clip_rect_s3d
expr_stmt|;
else|else
name|dev_priv
operator|->
name|emit_clip_rect
operator|=
name|savage_emit_clip_rect_s4
expr_stmt|;
if|if
condition|(
name|savage_freelist_init
argument_list|(
name|dev
argument_list|)
operator|<
literal|0
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"could not initialize freelist\n"
argument_list|)
expr_stmt|;
name|savage_do_cleanup_bci
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
block|}
if|if
condition|(
name|savage_dma_init
argument_list|(
name|dev_priv
argument_list|)
operator|<
literal|0
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"could not initialize command DMA\n"
argument_list|)
expr_stmt|;
name|savage_do_cleanup_bci
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|savage_do_cleanup_bci
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|drm_savage_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|cmd_dma
operator|==
operator|&
name|dev_priv
operator|->
name|fake_dma
condition|)
block|{
if|if
condition|(
name|dev_priv
operator|->
name|fake_dma
operator|.
name|virtual
condition|)
name|drm_free
argument_list|(
name|dev_priv
operator|->
name|fake_dma
operator|.
name|virtual
argument_list|,
name|SAVAGE_FAKE_DMA_SIZE
argument_list|,
name|DRM_MEM_DRIVER
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dev_priv
operator|->
name|cmd_dma
operator|&&
name|dev_priv
operator|->
name|cmd_dma
operator|->
name|virtual
operator|&&
name|dev_priv
operator|->
name|cmd_dma
operator|->
name|type
operator|==
name|_DRM_AGP
operator|&&
name|dev_priv
operator|->
name|dma_type
operator|==
name|SAVAGE_DMA_AGP
condition|)
name|drm_core_ioremapfree
argument_list|(
name|dev_priv
operator|->
name|cmd_dma
argument_list|,
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|dma_type
operator|==
name|SAVAGE_DMA_AGP
operator|&&
name|dev
operator|->
name|agp_buffer_map
operator|&&
name|dev
operator|->
name|agp_buffer_map
operator|->
name|virtual
condition|)
block|{
name|drm_core_ioremapfree
argument_list|(
name|dev
operator|->
name|agp_buffer_map
argument_list|,
name|dev
argument_list|)
expr_stmt|;
comment|/* make sure the next instance (which may be running 		 * in PCI mode) doesn't try to use an old 		 * agp_buffer_map. */
name|dev
operator|->
name|agp_buffer_map
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|dev_priv
operator|->
name|dma_pages
condition|)
name|drm_free
argument_list|(
name|dev_priv
operator|->
name|dma_pages
argument_list|,
sizeof|sizeof
argument_list|(
name|drm_savage_dma_page_t
argument_list|)
operator|*
name|dev_priv
operator|->
name|nr_dma_pages
argument_list|,
name|DRM_MEM_DRIVER
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|savage_bci_init
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
name|drm_savage_init_t
modifier|*
name|init
init|=
name|data
decl_stmt|;
name|LOCK_TEST_WITH_RETURN
argument_list|(
name|dev
argument_list|,
name|file_priv
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|init
operator|->
name|func
condition|)
block|{
case|case
name|SAVAGE_INIT_BCI
case|:
return|return
name|savage_do_init_bci
argument_list|(
name|dev
argument_list|,
name|init
argument_list|)
return|;
case|case
name|SAVAGE_CLEANUP_BCI
case|:
return|return
name|savage_do_cleanup_bci
argument_list|(
name|dev
argument_list|)
return|;
block|}
return|return
operator|-
name|EINVAL
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|savage_bci_event_emit
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
name|drm_savage_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|drm_savage_event_emit_t
modifier|*
name|event
init|=
name|data
decl_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|LOCK_TEST_WITH_RETURN
argument_list|(
name|dev
argument_list|,
name|file_priv
argument_list|)
expr_stmt|;
name|event
operator|->
name|count
operator|=
name|savage_bci_emit_event
argument_list|(
name|dev_priv
argument_list|,
name|event
operator|->
name|flags
argument_list|)
expr_stmt|;
name|event
operator|->
name|count
operator||=
name|dev_priv
operator|->
name|event_wrap
operator|<<
literal|16
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|savage_bci_event_wait
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
name|drm_savage_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|drm_savage_event_wait_t
modifier|*
name|event
init|=
name|data
decl_stmt|;
name|unsigned
name|int
name|event_e
decl_stmt|,
name|hw_e
decl_stmt|;
name|unsigned
name|int
name|event_w
decl_stmt|,
name|hw_w
decl_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|UPDATE_EVENT_COUNTER
argument_list|()
expr_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|status_ptr
condition|)
name|hw_e
operator|=
name|dev_priv
operator|->
name|status_ptr
index|[
literal|1
index|]
operator|&
literal|0xffff
expr_stmt|;
else|else
name|hw_e
operator|=
name|SAVAGE_READ
argument_list|(
name|SAVAGE_STATUS_WORD1
argument_list|)
operator|&
literal|0xffff
expr_stmt|;
name|hw_w
operator|=
name|dev_priv
operator|->
name|event_wrap
expr_stmt|;
if|if
condition|(
name|hw_e
operator|>
name|dev_priv
operator|->
name|event_counter
condition|)
name|hw_w
operator|--
expr_stmt|;
comment|/* hardware hasn't passed the last wrap yet */
name|event_e
operator|=
name|event
operator|->
name|count
operator|&
literal|0xffff
expr_stmt|;
name|event_w
operator|=
name|event
operator|->
name|count
operator|>>
literal|16
expr_stmt|;
comment|/* Don't need to wait if 	 * - event counter wrapped since the event was emitted or 	 * - the hardware has advanced up to or over the event to wait for. 	 */
if|if
condition|(
name|event_w
operator|<
name|hw_w
operator|||
operator|(
name|event_w
operator|==
name|hw_w
operator|&&
name|event_e
operator|<=
name|hw_e
operator|)
condition|)
return|return
literal|0
return|;
else|else
return|return
name|dev_priv
operator|->
name|wait_evnt
argument_list|(
name|dev_priv
argument_list|,
name|event_e
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * DMA buffer management  */
end_comment

begin_function
specifier|static
name|int
name|savage_bci_get_buffers
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|,
name|struct
name|drm_dma
modifier|*
name|d
parameter_list|)
block|{
name|struct
name|drm_buf
modifier|*
name|buf
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|d
operator|->
name|granted_count
init|;
name|i
operator|<
name|d
operator|->
name|request_count
condition|;
name|i
operator|++
control|)
block|{
name|buf
operator|=
name|savage_freelist_get
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buf
condition|)
return|return
operator|-
name|EAGAIN
return|;
name|buf
operator|->
name|file_priv
operator|=
name|file_priv
expr_stmt|;
if|if
condition|(
name|DRM_COPY_TO_USER
argument_list|(
operator|&
name|d
operator|->
name|request_indices
index|[
name|i
index|]
argument_list|,
operator|&
name|buf
operator|->
name|idx
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
operator|->
name|idx
argument_list|)
argument_list|)
condition|)
return|return
operator|-
name|EFAULT
return|;
if|if
condition|(
name|DRM_COPY_TO_USER
argument_list|(
operator|&
name|d
operator|->
name|request_sizes
index|[
name|i
index|]
argument_list|,
operator|&
name|buf
operator|->
name|total
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
operator|->
name|total
argument_list|)
argument_list|)
condition|)
return|return
operator|-
name|EFAULT
return|;
name|d
operator|->
name|granted_count
operator|++
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|savage_bci_buffers
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
name|struct
name|drm_device_dma
modifier|*
name|dma
init|=
name|dev
operator|->
name|dma
decl_stmt|;
name|struct
name|drm_dma
modifier|*
name|d
init|=
name|data
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|LOCK_TEST_WITH_RETURN
argument_list|(
name|dev
argument_list|,
name|file_priv
argument_list|)
expr_stmt|;
comment|/* Please don't send us buffers. 	 */
if|if
condition|(
name|d
operator|->
name|send_count
operator|!=
literal|0
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Process %d trying to send %d buffers via drmDMA\n"
argument_list|,
name|DRM_CURRENTPID
argument_list|,
name|d
operator|->
name|send_count
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
comment|/* We'll send you buffers. 	 */
if|if
condition|(
name|d
operator|->
name|request_count
operator|<
literal|0
operator|||
name|d
operator|->
name|request_count
operator|>
name|dma
operator|->
name|buf_count
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Process %d trying to get %d buffers (of %d max)\n"
argument_list|,
name|DRM_CURRENTPID
argument_list|,
name|d
operator|->
name|request_count
argument_list|,
name|dma
operator|->
name|buf_count
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|d
operator|->
name|granted_count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|request_count
condition|)
block|{
name|ret
operator|=
name|savage_bci_get_buffers
argument_list|(
name|dev
argument_list|,
name|file_priv
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
name|void
name|savage_reclaim_buffers
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
name|struct
name|drm_device_dma
modifier|*
name|dma
init|=
name|dev
operator|->
name|dma
decl_stmt|;
name|drm_savage_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|dma
condition|)
return|return;
if|if
condition|(
operator|!
name|dev_priv
condition|)
return|return;
if|if
condition|(
operator|!
name|dma
operator|->
name|buflist
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dma
operator|->
name|buf_count
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|drm_buf
modifier|*
name|buf
init|=
name|dma
operator|->
name|buflist
index|[
name|i
index|]
decl_stmt|;
name|drm_savage_buf_priv_t
modifier|*
name|buf_priv
init|=
name|buf
operator|->
name|dev_private
decl_stmt|;
if|if
condition|(
name|buf
operator|->
name|file_priv
operator|==
name|file_priv
operator|&&
name|buf_priv
operator|&&
name|buf_priv
operator|->
name|next
operator|==
name|NULL
operator|&&
name|buf_priv
operator|->
name|prev
operator|==
name|NULL
condition|)
block|{
name|uint16_t
name|event
decl_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"reclaimed from client\n"
argument_list|)
expr_stmt|;
name|event
operator|=
name|savage_bci_emit_event
argument_list|(
name|dev_priv
argument_list|,
name|SAVAGE_WAIT_3D
argument_list|)
expr_stmt|;
name|SET_AGE
argument_list|(
operator|&
name|buf_priv
operator|->
name|age
argument_list|,
name|event
argument_list|,
name|dev_priv
operator|->
name|event_wrap
argument_list|)
expr_stmt|;
name|savage_freelist_put
argument_list|(
name|dev
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
name|drm_core_reclaim_buffers
argument_list|(
name|dev
argument_list|,
name|file_priv
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|struct
name|drm_ioctl_desc
name|savage_ioctls
index|[]
init|=
block|{
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_SAVAGE_BCI_INIT
argument_list|,
name|savage_bci_init
argument_list|,
name|DRM_AUTH
operator||
name|DRM_MASTER
operator||
name|DRM_ROOT_ONLY
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_SAVAGE_BCI_CMDBUF
argument_list|,
name|savage_bci_cmdbuf
argument_list|,
name|DRM_AUTH
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_SAVAGE_BCI_EVENT_EMIT
argument_list|,
name|savage_bci_event_emit
argument_list|,
name|DRM_AUTH
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_SAVAGE_BCI_EVENT_WAIT
argument_list|,
name|savage_bci_event_wait
argument_list|,
name|DRM_AUTH
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|savage_max_ioctl
init|=
name|DRM_ARRAY_SIZE
argument_list|(
name|savage_ioctls
argument_list|)
decl_stmt|;
end_decl_stmt

end_unit

