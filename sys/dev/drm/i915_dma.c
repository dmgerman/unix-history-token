begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* i915_dma.c -- DMA support for the I915 -*- linux-c -*-  */
end_comment

begin_comment
comment|/*-  * Copyright 2003 Tungsten Graphics, Inc., Cedar Park, Texas.  * All Rights Reserved.  *  * Permission is hereby granted, free of charge, to any person obtaining a  * copy of this software and associated documentation files (the  * "Software"), to deal in the Software without restriction, including  * without limitation the rights to use, copy, modify, merge, publish,  * distribute, sub license, and/or sell copies of the Software, and to  * permit persons to whom the Software is furnished to do so, subject to  * the following conditions:  *  * The above copyright notice and this permission notice (including the  * next paragraph) shall be included in all copies or substantial portions  * of the Software.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.  * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR  * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,  * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE  * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"dev/drm/drmP.h"
end_include

begin_include
include|#
directive|include
file|"dev/drm/drm.h"
end_include

begin_include
include|#
directive|include
file|"dev/drm/i915_drm.h"
end_include

begin_include
include|#
directive|include
file|"dev/drm/i915_drv.h"
end_include

begin_comment
comment|/* Really want an OS-independent resettable timer.  Would like to have  * this loop run for (eg) 3 sec, but have the timer reset every time  * the head pointer changes, so that EBUSY only happens if the ring  * actually stalls for (eg) 3 seconds.  */
end_comment

begin_function
name|int
name|i915_wait_ring
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|n
parameter_list|,
specifier|const
name|char
modifier|*
name|caller
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|drm_i915_ring_buffer_t
modifier|*
name|ring
init|=
operator|&
operator|(
name|dev_priv
operator|->
name|ring
operator|)
decl_stmt|;
name|u32
name|last_head
init|=
name|I915_READ
argument_list|(
name|PRB0_HEAD
argument_list|)
operator|&
name|HEAD_ADDR
decl_stmt|;
name|u32
name|acthd_reg
init|=
name|IS_I965G
argument_list|(
name|dev
argument_list|)
condition|?
name|ACTHD_I965
else|:
name|ACTHD
decl_stmt|;
name|u32
name|last_acthd
init|=
name|I915_READ
argument_list|(
name|acthd_reg
argument_list|)
decl_stmt|;
name|u32
name|acthd
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|100000
condition|;
name|i
operator|++
control|)
block|{
name|ring
operator|->
name|head
operator|=
name|I915_READ
argument_list|(
name|PRB0_HEAD
argument_list|)
operator|&
name|HEAD_ADDR
expr_stmt|;
name|acthd
operator|=
name|I915_READ
argument_list|(
name|acthd_reg
argument_list|)
expr_stmt|;
name|ring
operator|->
name|space
operator|=
name|ring
operator|->
name|head
operator|-
operator|(
name|ring
operator|->
name|tail
operator|+
literal|8
operator|)
expr_stmt|;
if|if
condition|(
name|ring
operator|->
name|space
operator|<
literal|0
condition|)
name|ring
operator|->
name|space
operator|+=
name|ring
operator|->
name|Size
expr_stmt|;
if|if
condition|(
name|ring
operator|->
name|space
operator|>=
name|n
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|ring
operator|->
name|head
operator|!=
name|last_head
condition|)
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|acthd
operator|!=
name|last_acthd
condition|)
name|i
operator|=
literal|0
expr_stmt|;
name|last_head
operator|=
name|ring
operator|->
name|head
expr_stmt|;
name|last_acthd
operator|=
name|acthd
expr_stmt|;
name|DRM_UDELAY
argument_list|(
literal|10
operator|*
literal|1000
argument_list|)
expr_stmt|;
block|}
return|return
operator|-
name|EBUSY
return|;
block|}
end_function

begin_function
name|int
name|i915_init_hardware_status
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|drm_dma_handle_t
modifier|*
name|dmah
decl_stmt|;
comment|/* Program Hardware Status Page */
ifdef|#
directive|ifdef
name|__FreeBSD__
name|DRM_UNLOCK
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|dmah
operator|=
name|drm_pci_alloc
argument_list|(
name|dev
argument_list|,
name|PAGE_SIZE
argument_list|,
name|PAGE_SIZE
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__FreeBSD__
name|DRM_LOCK
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|dmah
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Can not allocate hardware status page\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
block|}
name|dev_priv
operator|->
name|status_page_dmah
operator|=
name|dmah
expr_stmt|;
name|dev_priv
operator|->
name|hw_status_page
operator|=
name|dmah
operator|->
name|vaddr
expr_stmt|;
name|dev_priv
operator|->
name|dma_status_page
operator|=
name|dmah
operator|->
name|busaddr
expr_stmt|;
name|memset
argument_list|(
name|dev_priv
operator|->
name|hw_status_page
argument_list|,
literal|0
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
literal|0x02080
argument_list|,
name|dev_priv
operator|->
name|dma_status_page
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"Enabled hardware status page\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|i915_free_hardware_status
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|status_page_dmah
condition|)
block|{
name|drm_pci_free
argument_list|(
name|dev
argument_list|,
name|dev_priv
operator|->
name|status_page_dmah
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|status_page_dmah
operator|=
name|NULL
expr_stmt|;
comment|/* Need to rewrite hardware status page */
name|I915_WRITE
argument_list|(
literal|0x02080
argument_list|,
literal|0x1ffff000
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dev_priv
operator|->
name|status_gfx_addr
condition|)
block|{
name|dev_priv
operator|->
name|status_gfx_addr
operator|=
literal|0
expr_stmt|;
name|drm_core_ioremapfree
argument_list|(
operator|&
name|dev_priv
operator|->
name|hws_map
argument_list|,
name|dev
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
literal|0x02080
argument_list|,
literal|0x1ffff000
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_if
if|#
directive|if
name|I915_RING_VALIDATE
end_if

begin_comment
comment|/**  * Validate the cached ring tail value  *  * If the X server writes to the ring and DRM doesn't  * reload the head and tail pointers, it will end up writing  * data to the wrong place in the ring, causing havoc.  */
end_comment

begin_function
name|void
name|i915_ring_validate
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
specifier|const
name|char
modifier|*
name|func
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|drm_i915_ring_buffer_t
modifier|*
name|ring
init|=
operator|&
operator|(
name|dev_priv
operator|->
name|ring
operator|)
decl_stmt|;
name|u32
name|tail
init|=
name|I915_READ
argument_list|(
name|PRB0_TAIL
argument_list|)
operator|&
name|HEAD_ADDR
decl_stmt|;
name|u32
name|head
init|=
name|I915_READ
argument_list|(
name|PRB0_HEAD
argument_list|)
operator|&
name|HEAD_ADDR
decl_stmt|;
if|if
condition|(
name|tail
operator|!=
name|ring
operator|->
name|tail
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"%s:%d head sw %x, hw %x. tail sw %x hw %x\n"
argument_list|,
name|func
argument_list|,
name|line
argument_list|,
name|ring
operator|->
name|head
argument_list|,
name|head
argument_list|,
name|ring
operator|->
name|tail
argument_list|,
name|tail
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__linux__
name|BUG_ON
argument_list|(
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|i915_kernel_lost_context
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|drm_i915_ring_buffer_t
modifier|*
name|ring
init|=
operator|&
operator|(
name|dev_priv
operator|->
name|ring
operator|)
decl_stmt|;
name|ring
operator|->
name|head
operator|=
name|I915_READ
argument_list|(
name|PRB0_HEAD
argument_list|)
operator|&
name|HEAD_ADDR
expr_stmt|;
name|ring
operator|->
name|tail
operator|=
name|I915_READ
argument_list|(
name|PRB0_TAIL
argument_list|)
operator|&
name|TAIL_ADDR
expr_stmt|;
name|ring
operator|->
name|space
operator|=
name|ring
operator|->
name|head
operator|-
operator|(
name|ring
operator|->
name|tail
operator|+
literal|8
operator|)
expr_stmt|;
if|if
condition|(
name|ring
operator|->
name|space
operator|<
literal|0
condition|)
name|ring
operator|->
name|space
operator|+=
name|ring
operator|->
name|Size
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|i915_dma_cleanup
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
comment|/* Make sure interrupts are disabled here because the uninstall ioctl 	 * may not have been called from userspace and after dev_private 	 * is freed, it's too late. 	 */
if|if
condition|(
name|dev
operator|->
name|irq_enabled
condition|)
name|drm_irq_uninstall
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|ring
operator|.
name|virtual_start
condition|)
block|{
name|drm_core_ioremapfree
argument_list|(
operator|&
name|dev_priv
operator|->
name|ring
operator|.
name|map
argument_list|,
name|dev
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|ring
operator|.
name|virtual_start
operator|=
literal|0
expr_stmt|;
name|dev_priv
operator|->
name|ring
operator|.
name|map
operator|.
name|handle
operator|=
literal|0
expr_stmt|;
name|dev_priv
operator|->
name|ring
operator|.
name|map
operator|.
name|size
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|I915_NEED_GFX_HWS
argument_list|(
name|dev
argument_list|)
condition|)
name|i915_free_hardware_status
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|I915_HAVE_BUFFER
argument_list|)
end_if

begin_define
define|#
directive|define
name|DRI2_SAREA_BLOCK_TYPE
parameter_list|(
name|b
parameter_list|)
value|((b)>> 16)
end_define

begin_define
define|#
directive|define
name|DRI2_SAREA_BLOCK_SIZE
parameter_list|(
name|b
parameter_list|)
value|((b)& 0xffff)
end_define

begin_define
define|#
directive|define
name|DRI2_SAREA_BLOCK_NEXT
parameter_list|(
name|p
parameter_list|)
define|\
value|((void *) ((unsigned char *) (p) +			\ 		   DRI2_SAREA_BLOCK_SIZE(*(unsigned int *) p)))
end_define

begin_define
define|#
directive|define
name|DRI2_SAREA_BLOCK_END
value|0x0000
end_define

begin_define
define|#
directive|define
name|DRI2_SAREA_BLOCK_LOCK
value|0x0001
end_define

begin_define
define|#
directive|define
name|DRI2_SAREA_BLOCK_EVENT_BUFFER
value|0x0002
end_define

begin_function
specifier|static
name|int
name|setup_dri2_sarea
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|,
name|drm_i915_init_t
modifier|*
name|init
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|unsigned
name|int
modifier|*
name|p
decl_stmt|,
modifier|*
name|end
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|mutex_lock
argument_list|(
operator|&
name|dev
operator|->
name|struct_mutex
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|sarea_bo
operator|=
name|drm_lookup_buffer_object
argument_list|(
name|file_priv
argument_list|,
name|init
operator|->
name|sarea_handle
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|mutex_unlock
argument_list|(
operator|&
name|dev
operator|->
name|struct_mutex
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dev_priv
operator|->
name|sarea_bo
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"did not find sarea bo\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|ret
operator|=
name|drm_bo_kmap
argument_list|(
name|dev_priv
operator|->
name|sarea_bo
argument_list|,
literal|0
argument_list|,
name|dev_priv
operator|->
name|sarea_bo
operator|->
name|num_pages
argument_list|,
operator|&
name|dev_priv
operator|->
name|sarea_kmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"could not map sarea bo\n"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|p
operator|=
name|dev_priv
operator|->
name|sarea_kmap
operator|.
name|virtual
expr_stmt|;
name|end
operator|=
operator|(
name|void
operator|*
operator|)
name|p
operator|+
operator|(
name|dev_priv
operator|->
name|sarea_bo
operator|->
name|num_pages
operator|<<
name|PAGE_SHIFT
operator|)
expr_stmt|;
while|while
condition|(
name|p
operator|<
name|end
operator|&&
name|DRI2_SAREA_BLOCK_TYPE
argument_list|(
operator|*
name|p
argument_list|)
operator|!=
name|DRI2_SAREA_BLOCK_END
condition|)
block|{
switch|switch
condition|(
name|DRI2_SAREA_BLOCK_TYPE
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
case|case
name|DRI2_SAREA_BLOCK_LOCK
case|:
name|dev
operator|->
name|lock
operator|.
name|hw_lock
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|p
operator|+
literal|1
operator|)
expr_stmt|;
name|dev
operator|->
name|sigdata
operator|.
name|lock
operator|=
name|dev
operator|->
name|lock
operator|.
name|hw_lock
expr_stmt|;
break|break;
block|}
name|next
operator|=
name|DRI2_SAREA_BLOCK_NEXT
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|<=
name|p
operator|||
name|end
operator|<
name|next
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"malformed dri2 sarea: next is %p should be within %p-%p\n"
argument_list|,
name|next
argument_list|,
name|p
argument_list|,
name|end
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|p
operator|=
name|next
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|i915_initialize
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|,
name|drm_i915_init_t
modifier|*
name|init
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|I915_HAVE_BUFFER
argument_list|)
name|int
name|ret
decl_stmt|;
endif|#
directive|endif
name|dev_priv
operator|->
name|sarea
operator|=
name|drm_getsarea
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dev_priv
operator|->
name|sarea
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"can not find sarea!\n"
argument_list|)
expr_stmt|;
name|i915_dma_cleanup
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
ifdef|#
directive|ifdef
name|I915_HAVE_BUFFER
name|dev_priv
operator|->
name|max_validate_buffers
operator|=
name|I915_MAX_VALIDATE_BUFFERS
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|init
operator|->
name|sarea_priv_offset
condition|)
name|dev_priv
operator|->
name|sarea_priv
operator|=
operator|(
name|drm_i915_sarea_t
operator|*
operator|)
operator|(
operator|(
name|u8
operator|*
operator|)
name|dev_priv
operator|->
name|sarea
operator|->
name|handle
operator|+
name|init
operator|->
name|sarea_priv_offset
operator|)
expr_stmt|;
else|else
block|{
comment|/* No sarea_priv for you! */
name|dev_priv
operator|->
name|sarea_priv
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|init
operator|->
name|ring_size
operator|!=
literal|0
condition|)
block|{
name|dev_priv
operator|->
name|ring
operator|.
name|Size
operator|=
name|init
operator|->
name|ring_size
expr_stmt|;
name|dev_priv
operator|->
name|ring
operator|.
name|tail_mask
operator|=
name|dev_priv
operator|->
name|ring
operator|.
name|Size
operator|-
literal|1
expr_stmt|;
name|dev_priv
operator|->
name|ring
operator|.
name|map
operator|.
name|offset
operator|=
name|init
operator|->
name|ring_start
expr_stmt|;
name|dev_priv
operator|->
name|ring
operator|.
name|map
operator|.
name|size
operator|=
name|init
operator|->
name|ring_size
expr_stmt|;
name|dev_priv
operator|->
name|ring
operator|.
name|map
operator|.
name|type
operator|=
literal|0
expr_stmt|;
name|dev_priv
operator|->
name|ring
operator|.
name|map
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|dev_priv
operator|->
name|ring
operator|.
name|map
operator|.
name|mtrr
operator|=
literal|0
expr_stmt|;
name|drm_core_ioremap
argument_list|(
operator|&
name|dev_priv
operator|->
name|ring
operator|.
name|map
argument_list|,
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|ring
operator|.
name|map
operator|.
name|handle
operator|==
name|NULL
condition|)
block|{
name|i915_dma_cleanup
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|DRM_ERROR
argument_list|(
literal|"can not ioremap virtual address for"
literal|" ring buffer\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
block|}
name|dev_priv
operator|->
name|ring
operator|.
name|virtual_start
operator|=
name|dev_priv
operator|->
name|ring
operator|.
name|map
operator|.
name|handle
expr_stmt|;
block|}
name|dev_priv
operator|->
name|cpp
operator|=
name|init
operator|->
name|cpp
expr_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|sarea_priv
condition|)
name|dev_priv
operator|->
name|sarea_priv
operator|->
name|pf_current_page
operator|=
literal|0
expr_stmt|;
comment|/* We are using separate values as placeholders for mechanisms for 	 * private backbuffer/depthbuffer usage. 	 */
comment|/* Allow hardware batchbuffers unless told otherwise. 	 */
name|dev_priv
operator|->
name|allow_batchbuffer
operator|=
literal|1
expr_stmt|;
comment|/* Enable vblank on pipe A for older X servers 	 */
name|dev_priv
operator|->
name|vblank_pipe
operator|=
name|DRM_I915_VBLANK_PIPE_A
expr_stmt|;
ifdef|#
directive|ifdef
name|I915_HAVE_BUFFER
name|mutex_init
argument_list|(
operator|&
name|dev_priv
operator|->
name|cmdbuf_mutex
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|I915_HAVE_BUFFER
argument_list|)
if|if
condition|(
name|init
operator|->
name|func
operator|==
name|I915_INIT_DMA2
condition|)
block|{
name|ret
operator|=
name|setup_dri2_sarea
argument_list|(
name|dev
argument_list|,
name|file_priv
argument_list|,
name|init
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|i915_dma_cleanup
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|DRM_ERROR
argument_list|(
literal|"could not set up dri2 sarea\n"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
block|}
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|i915_dma_resume
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
operator|(
name|drm_i915_private_t
operator|*
operator|)
name|dev
operator|->
name|dev_private
decl_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dev_priv
operator|->
name|sarea
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"can not find sarea!\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
if|if
condition|(
name|dev_priv
operator|->
name|ring
operator|.
name|map
operator|.
name|handle
operator|==
name|NULL
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"can not ioremap virtual address for"
literal|" ring buffer\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
block|}
comment|/* Program Hardware Status Page */
if|if
condition|(
operator|!
name|dev_priv
operator|->
name|hw_status_page
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Can not find hardware status page\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|DRM_DEBUG
argument_list|(
literal|"hw status page @ %p\n"
argument_list|,
name|dev_priv
operator|->
name|hw_status_page
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|status_gfx_addr
operator|!=
literal|0
condition|)
name|I915_WRITE
argument_list|(
literal|0x02080
argument_list|,
name|dev_priv
operator|->
name|status_gfx_addr
argument_list|)
expr_stmt|;
else|else
name|I915_WRITE
argument_list|(
literal|0x02080
argument_list|,
name|dev_priv
operator|->
name|dma_status_page
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"Enabled hardware status page\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|i915_dma_init
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
name|drm_i915_init_t
modifier|*
name|init
init|=
name|data
decl_stmt|;
name|int
name|retcode
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|init
operator|->
name|func
condition|)
block|{
case|case
name|I915_INIT_DMA
case|:
case|case
name|I915_INIT_DMA2
case|:
name|retcode
operator|=
name|i915_initialize
argument_list|(
name|dev
argument_list|,
name|file_priv
argument_list|,
name|init
argument_list|)
expr_stmt|;
break|break;
case|case
name|I915_CLEANUP_DMA
case|:
name|retcode
operator|=
name|i915_dma_cleanup
argument_list|(
name|dev
argument_list|)
expr_stmt|;
break|break;
case|case
name|I915_RESUME_DMA
case|:
name|retcode
operator|=
name|i915_dma_resume
argument_list|(
name|dev
argument_list|)
expr_stmt|;
break|break;
default|default:
name|retcode
operator|=
operator|-
name|EINVAL
expr_stmt|;
break|break;
block|}
return|return
name|retcode
return|;
block|}
end_function

begin_comment
comment|/* Implement basically the same security restrictions as hardware does  * for MI_BATCH_NON_SECURE.  These can be made stricter at any time.  *  * Most of the calculations below involve calculating the size of a  * particular instruction.  It's important to get the size right as  * that tells us where the next instruction to check is.  Any illegal  * instruction detected will be given a size of zero, which is a  * signal to abort the rest of the buffer.  */
end_comment

begin_function
specifier|static
name|int
name|do_validate_cmd
parameter_list|(
name|int
name|cmd
parameter_list|)
block|{
switch|switch
condition|(
operator|(
operator|(
name|cmd
operator|>>
literal|29
operator|)
operator|&
literal|0x7
operator|)
condition|)
block|{
case|case
literal|0x0
case|:
switch|switch
condition|(
operator|(
name|cmd
operator|>>
literal|23
operator|)
operator|&
literal|0x3f
condition|)
block|{
case|case
literal|0x0
case|:
return|return
literal|1
return|;
comment|/* MI_NOOP */
case|case
literal|0x4
case|:
return|return
literal|1
return|;
comment|/* MI_FLUSH */
default|default:
return|return
literal|0
return|;
comment|/* disallow everything else */
block|}
break|break;
case|case
literal|0x1
case|:
return|return
literal|0
return|;
comment|/* reserved */
case|case
literal|0x2
case|:
return|return
operator|(
name|cmd
operator|&
literal|0xff
operator|)
operator|+
literal|2
return|;
comment|/* 2d commands */
case|case
literal|0x3
case|:
if|if
condition|(
operator|(
operator|(
name|cmd
operator|>>
literal|24
operator|)
operator|&
literal|0x1f
operator|)
operator|<=
literal|0x18
condition|)
return|return
literal|1
return|;
switch|switch
condition|(
operator|(
name|cmd
operator|>>
literal|24
operator|)
operator|&
literal|0x1f
condition|)
block|{
case|case
literal|0x1c
case|:
return|return
literal|1
return|;
case|case
literal|0x1d
case|:
switch|switch
condition|(
operator|(
name|cmd
operator|>>
literal|16
operator|)
operator|&
literal|0xff
condition|)
block|{
case|case
literal|0x3
case|:
return|return
operator|(
name|cmd
operator|&
literal|0x1f
operator|)
operator|+
literal|2
return|;
case|case
literal|0x4
case|:
return|return
operator|(
name|cmd
operator|&
literal|0xf
operator|)
operator|+
literal|2
return|;
default|default:
return|return
operator|(
name|cmd
operator|&
literal|0xffff
operator|)
operator|+
literal|2
return|;
block|}
case|case
literal|0x1e
case|:
if|if
condition|(
name|cmd
operator|&
operator|(
literal|1
operator|<<
literal|23
operator|)
condition|)
return|return
operator|(
name|cmd
operator|&
literal|0xffff
operator|)
operator|+
literal|1
return|;
else|else
return|return
literal|1
return|;
case|case
literal|0x1f
case|:
if|if
condition|(
operator|(
name|cmd
operator|&
operator|(
literal|1
operator|<<
literal|23
operator|)
operator|)
operator|==
literal|0
condition|)
comment|/* inline vertices */
return|return
operator|(
name|cmd
operator|&
literal|0x1ffff
operator|)
operator|+
literal|2
return|;
elseif|else
if|if
condition|(
name|cmd
operator|&
operator|(
literal|1
operator|<<
literal|17
operator|)
condition|)
comment|/* indirect random */
if|if
condition|(
operator|(
name|cmd
operator|&
literal|0xffff
operator|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* unknown length, too hard */
else|else
return|return
operator|(
operator|(
operator|(
name|cmd
operator|&
literal|0xffff
operator|)
operator|+
literal|1
operator|)
operator|/
literal|2
operator|)
operator|+
literal|1
return|;
else|else
return|return
literal|2
return|;
comment|/* indirect sequential */
default|default:
return|return
literal|0
return|;
block|}
default|default:
return|return
literal|0
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|validate_cmd
parameter_list|(
name|int
name|cmd
parameter_list|)
block|{
name|int
name|ret
init|=
name|do_validate_cmd
argument_list|(
name|cmd
argument_list|)
decl_stmt|;
comment|/*	printk("validate_cmd( %x ): %d\n", cmd, ret); */
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|i915_emit_cmds
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|__user
modifier|*
name|buffer
parameter_list|,
name|int
name|dwords
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|int
name|i
decl_stmt|;
name|RING_LOCALS
expr_stmt|;
if|if
condition|(
operator|(
name|dwords
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|>=
name|dev_priv
operator|->
name|ring
operator|.
name|Size
operator|-
literal|8
condition|)
return|return
operator|-
name|EINVAL
return|;
name|BEGIN_LP_RING
argument_list|(
operator|(
name|dwords
operator|+
literal|1
operator|)
operator|&
operator|~
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dwords
condition|;
control|)
block|{
name|int
name|cmd
decl_stmt|,
name|sz
decl_stmt|;
if|if
condition|(
name|DRM_COPY_FROM_USER_UNCHECKED
argument_list|(
operator|&
name|cmd
argument_list|,
operator|&
name|buffer
index|[
name|i
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|)
condition|)
return|return
operator|-
name|EINVAL
return|;
if|if
condition|(
operator|(
name|sz
operator|=
name|validate_cmd
argument_list|(
name|cmd
argument_list|)
operator|)
operator|==
literal|0
operator|||
name|i
operator|+
name|sz
operator|>
name|dwords
condition|)
return|return
operator|-
name|EINVAL
return|;
name|OUT_RING
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
while|while
condition|(
operator|++
name|i
operator|,
operator|--
name|sz
condition|)
block|{
if|if
condition|(
name|DRM_COPY_FROM_USER_UNCHECKED
argument_list|(
operator|&
name|cmd
argument_list|,
operator|&
name|buffer
index|[
name|i
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|)
condition|)
block|{
return|return
operator|-
name|EINVAL
return|;
block|}
name|OUT_RING
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dwords
operator|&
literal|1
condition|)
name|OUT_RING
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|ADVANCE_LP_RING
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|i915_emit_box
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_clip_rect
name|__user
modifier|*
name|boxes
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|DR1
parameter_list|,
name|int
name|DR4
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|drm_clip_rect
name|box
decl_stmt|;
name|RING_LOCALS
expr_stmt|;
if|if
condition|(
name|DRM_COPY_FROM_USER_UNCHECKED
argument_list|(
operator|&
name|box
argument_list|,
operator|&
name|boxes
index|[
name|i
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|box
argument_list|)
argument_list|)
condition|)
block|{
return|return
operator|-
name|EFAULT
return|;
block|}
if|if
condition|(
name|box
operator|.
name|y2
operator|<=
name|box
operator|.
name|y1
operator|||
name|box
operator|.
name|x2
operator|<=
name|box
operator|.
name|x1
operator|||
name|box
operator|.
name|y2
operator|<=
literal|0
operator|||
name|box
operator|.
name|x2
operator|<=
literal|0
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Bad box %d,%d..%d,%d\n"
argument_list|,
name|box
operator|.
name|x1
argument_list|,
name|box
operator|.
name|y1
argument_list|,
name|box
operator|.
name|x2
argument_list|,
name|box
operator|.
name|y2
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
if|if
condition|(
name|IS_I965G
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|BEGIN_LP_RING
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|GFX_OP_DRAWRECT_INFO_I965
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
operator|(
name|box
operator|.
name|x1
operator|&
literal|0xffff
operator|)
operator||
operator|(
name|box
operator|.
name|y1
operator|<<
literal|16
operator|)
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
operator|(
operator|(
name|box
operator|.
name|x2
operator|-
literal|1
operator|)
operator|&
literal|0xffff
operator|)
operator||
operator|(
operator|(
name|box
operator|.
name|y2
operator|-
literal|1
operator|)
operator|<<
literal|16
operator|)
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|DR4
argument_list|)
expr_stmt|;
name|ADVANCE_LP_RING
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|BEGIN_LP_RING
argument_list|(
literal|6
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|GFX_OP_DRAWRECT_INFO
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|DR1
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
operator|(
name|box
operator|.
name|x1
operator|&
literal|0xffff
operator|)
operator||
operator|(
name|box
operator|.
name|y1
operator|<<
literal|16
operator|)
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
operator|(
operator|(
name|box
operator|.
name|x2
operator|-
literal|1
operator|)
operator|&
literal|0xffff
operator|)
operator||
operator|(
operator|(
name|box
operator|.
name|y2
operator|-
literal|1
operator|)
operator|<<
literal|16
operator|)
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|DR4
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|ADVANCE_LP_RING
argument_list|()
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* XXX: Emitting the counter should really be moved to part of the IRQ  * emit. For now, do it in both places:  */
end_comment

begin_function
name|void
name|i915_emit_breadcrumb
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|RING_LOCALS
expr_stmt|;
if|if
condition|(
operator|++
name|dev_priv
operator|->
name|counter
operator|>
name|BREADCRUMB_MASK
condition|)
block|{
name|dev_priv
operator|->
name|counter
operator|=
literal|1
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"Breadcrumb counter wrapped around\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dev_priv
operator|->
name|sarea_priv
condition|)
name|dev_priv
operator|->
name|sarea_priv
operator|->
name|last_enqueue
operator|=
name|dev_priv
operator|->
name|counter
expr_stmt|;
name|BEGIN_LP_RING
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|MI_STORE_DWORD_INDEX
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
literal|5
operator|<<
name|MI_STORE_DWORD_INDEX_SHIFT
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|dev_priv
operator|->
name|counter
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|ADVANCE_LP_RING
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|int
name|i915_emit_mi_flush
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|uint32_t
name|flush
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|uint32_t
name|flush_cmd
init|=
name|MI_FLUSH
decl_stmt|;
name|RING_LOCALS
expr_stmt|;
name|flush_cmd
operator||=
name|flush
expr_stmt|;
name|i915_kernel_lost_context
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|BEGIN_LP_RING
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|flush_cmd
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|ADVANCE_LP_RING
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|i915_dispatch_cmdbuffer
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|drm_i915_cmdbuffer_t
modifier|*
name|cmd
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|I915_HAVE_FENCE
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
endif|#
directive|endif
name|int
name|nbox
init|=
name|cmd
operator|->
name|num_cliprects
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|,
name|count
decl_stmt|,
name|ret
decl_stmt|;
if|if
condition|(
name|cmd
operator|->
name|sz
operator|&
literal|0x3
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"alignment\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|i915_kernel_lost_context
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|count
operator|=
name|nbox
condition|?
name|nbox
else|:
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|<
name|nbox
condition|)
block|{
name|ret
operator|=
name|i915_emit_box
argument_list|(
name|dev
argument_list|,
name|cmd
operator|->
name|cliprects
argument_list|,
name|i
argument_list|,
name|cmd
operator|->
name|DR1
argument_list|,
name|cmd
operator|->
name|DR4
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
block|}
name|ret
operator|=
name|i915_emit_cmds
argument_list|(
name|dev
argument_list|,
operator|(
name|int
name|__user
operator|*
operator|)
name|cmd
operator|->
name|buf
argument_list|,
name|cmd
operator|->
name|sz
operator|/
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
block|}
name|i915_emit_breadcrumb
argument_list|(
name|dev
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|I915_HAVE_FENCE
if|if
condition|(
name|unlikely
argument_list|(
operator|(
name|dev_priv
operator|->
name|counter
operator|&
literal|0xFF
operator|)
operator|==
literal|0
argument_list|)
condition|)
name|drm_fence_flush_old
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
name|dev_priv
operator|->
name|counter
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|i915_dispatch_batchbuffer
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|drm_i915_batchbuffer_t
modifier|*
name|batch
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|drm_clip_rect
name|__user
modifier|*
name|boxes
init|=
name|batch
operator|->
name|cliprects
decl_stmt|;
name|int
name|nbox
init|=
name|batch
operator|->
name|num_cliprects
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|,
name|count
decl_stmt|;
name|RING_LOCALS
expr_stmt|;
if|if
condition|(
operator|(
name|batch
operator|->
name|start
operator||
name|batch
operator|->
name|used
operator|)
operator|&
literal|0x7
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"alignment\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|i915_kernel_lost_context
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|count
operator|=
name|nbox
condition|?
name|nbox
else|:
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|<
name|nbox
condition|)
block|{
name|int
name|ret
init|=
name|i915_emit_box
argument_list|(
name|dev
argument_list|,
name|boxes
argument_list|,
name|i
argument_list|,
name|batch
operator|->
name|DR1
argument_list|,
name|batch
operator|->
name|DR4
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
block|}
if|if
condition|(
name|IS_I830
argument_list|(
name|dev
argument_list|)
operator|||
name|IS_845G
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|BEGIN_LP_RING
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|MI_BATCH_BUFFER
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|batch
operator|->
name|start
operator||
name|MI_BATCH_NON_SECURE
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|batch
operator|->
name|start
operator|+
name|batch
operator|->
name|used
operator|-
literal|4
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|ADVANCE_LP_RING
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|BEGIN_LP_RING
argument_list|(
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_I965G
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|OUT_RING
argument_list|(
name|MI_BATCH_BUFFER_START
operator||
operator|(
literal|2
operator|<<
literal|6
operator|)
operator||
name|MI_BATCH_NON_SECURE_I965
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|batch
operator|->
name|start
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|OUT_RING
argument_list|(
name|MI_BATCH_BUFFER_START
operator||
operator|(
literal|2
operator|<<
literal|6
operator|)
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|batch
operator|->
name|start
operator||
name|MI_BATCH_NON_SECURE
argument_list|)
expr_stmt|;
block|}
name|ADVANCE_LP_RING
argument_list|()
expr_stmt|;
block|}
block|}
name|i915_emit_breadcrumb
argument_list|(
name|dev
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|I915_HAVE_FENCE
if|if
condition|(
name|unlikely
argument_list|(
operator|(
name|dev_priv
operator|->
name|counter
operator|&
literal|0xFF
operator|)
operator|==
literal|0
argument_list|)
condition|)
name|drm_fence_flush_old
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
name|dev_priv
operator|->
name|counter
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|i915_do_dispatch_flip
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|plane
parameter_list|,
name|int
name|sync
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|u32
name|num_pages
decl_stmt|,
name|current_page
decl_stmt|,
name|next_page
decl_stmt|,
name|dspbase
decl_stmt|;
name|int
name|shift
init|=
literal|2
operator|*
name|plane
decl_stmt|,
name|x
decl_stmt|,
name|y
decl_stmt|;
name|RING_LOCALS
expr_stmt|;
comment|/* Calculate display base offset */
name|num_pages
operator|=
name|dev_priv
operator|->
name|sarea_priv
operator|->
name|third_handle
condition|?
literal|3
else|:
literal|2
expr_stmt|;
name|current_page
operator|=
operator|(
name|dev_priv
operator|->
name|sarea_priv
operator|->
name|pf_current_page
operator|>>
name|shift
operator|)
operator|&
literal|0x3
expr_stmt|;
name|next_page
operator|=
operator|(
name|current_page
operator|+
literal|1
operator|)
operator|%
name|num_pages
expr_stmt|;
switch|switch
condition|(
name|next_page
condition|)
block|{
default|default:
case|case
literal|0
case|:
name|dspbase
operator|=
name|dev_priv
operator|->
name|sarea_priv
operator|->
name|front_offset
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|dspbase
operator|=
name|dev_priv
operator|->
name|sarea_priv
operator|->
name|back_offset
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|dspbase
operator|=
name|dev_priv
operator|->
name|sarea_priv
operator|->
name|third_offset
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|plane
operator|==
literal|0
condition|)
block|{
name|x
operator|=
name|dev_priv
operator|->
name|sarea_priv
operator|->
name|planeA_x
expr_stmt|;
name|y
operator|=
name|dev_priv
operator|->
name|sarea_priv
operator|->
name|planeA_y
expr_stmt|;
block|}
else|else
block|{
name|x
operator|=
name|dev_priv
operator|->
name|sarea_priv
operator|->
name|planeB_x
expr_stmt|;
name|y
operator|=
name|dev_priv
operator|->
name|sarea_priv
operator|->
name|planeB_y
expr_stmt|;
block|}
name|dspbase
operator|+=
operator|(
name|y
operator|*
name|dev_priv
operator|->
name|sarea_priv
operator|->
name|pitch
operator|+
name|x
operator|)
operator|*
name|dev_priv
operator|->
name|cpp
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"plane=%d current_page=%d dspbase=0x%x\n"
argument_list|,
name|plane
argument_list|,
name|current_page
argument_list|,
name|dspbase
argument_list|)
expr_stmt|;
name|BEGIN_LP_RING
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|sync
condition|?
literal|0
else|:
operator|(
name|MI_WAIT_FOR_EVENT
operator||
operator|(
name|plane
condition|?
name|MI_WAIT_FOR_PLANE_B_FLIP
else|:
name|MI_WAIT_FOR_PLANE_A_FLIP
operator|)
operator|)
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|CMD_OP_DISPLAYBUFFER_INFO
operator||
operator|(
name|sync
condition|?
literal|0
else|:
name|ASYNC_FLIP
operator|)
operator||
operator|(
name|plane
condition|?
name|DISPLAY_PLANE_B
else|:
name|DISPLAY_PLANE_A
operator|)
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|dev_priv
operator|->
name|sarea_priv
operator|->
name|pitch
operator|*
name|dev_priv
operator|->
name|cpp
argument_list|)
expr_stmt|;
name|OUT_RING
argument_list|(
name|dspbase
argument_list|)
expr_stmt|;
name|ADVANCE_LP_RING
argument_list|()
expr_stmt|;
name|dev_priv
operator|->
name|sarea_priv
operator|->
name|pf_current_page
operator|&=
operator|~
operator|(
literal|0x3
operator|<<
name|shift
operator|)
expr_stmt|;
name|dev_priv
operator|->
name|sarea_priv
operator|->
name|pf_current_page
operator||=
name|next_page
operator|<<
name|shift
expr_stmt|;
block|}
end_function

begin_function
name|void
name|i915_dispatch_flip
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|planes
parameter_list|,
name|int
name|sync
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|int
name|i
decl_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"planes=0x%x pfCurrentPage=%d\n"
argument_list|,
name|planes
argument_list|,
name|dev_priv
operator|->
name|sarea_priv
operator|->
name|pf_current_page
argument_list|)
expr_stmt|;
name|i915_emit_mi_flush
argument_list|(
name|dev
argument_list|,
name|MI_READ_FLUSH
operator||
name|MI_EXE_FLUSH
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|planes
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
name|i915_do_dispatch_flip
argument_list|(
name|dev
argument_list|,
name|i
argument_list|,
name|sync
argument_list|)
expr_stmt|;
name|i915_emit_breadcrumb
argument_list|(
name|dev
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|I915_HAVE_FENCE
if|if
condition|(
name|unlikely
argument_list|(
operator|!
name|sync
operator|&&
operator|(
operator|(
name|dev_priv
operator|->
name|counter
operator|&
literal|0xFF
operator|)
operator|==
literal|0
operator|)
argument_list|)
condition|)
name|drm_fence_flush_old
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
name|dev_priv
operator|->
name|counter
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|int
name|i915_quiescent
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|i915_kernel_lost_context
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ret
operator|=
name|i915_wait_ring
argument_list|(
name|dev
argument_list|,
name|dev_priv
operator|->
name|ring
operator|.
name|Size
operator|-
literal|8
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|i915_kernel_lost_context
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|DRM_ERROR
argument_list|(
literal|"not quiescent head %08x tail %08x space %08x\n"
argument_list|,
name|dev_priv
operator|->
name|ring
operator|.
name|head
argument_list|,
name|dev_priv
operator|->
name|ring
operator|.
name|tail
argument_list|,
name|dev_priv
operator|->
name|ring
operator|.
name|space
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|i915_flush_ioctl
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
name|LOCK_TEST_WITH_RETURN
argument_list|(
name|dev
argument_list|,
name|file_priv
argument_list|)
expr_stmt|;
return|return
name|i915_quiescent
argument_list|(
name|dev
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|i915_batchbuffer
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
operator|(
name|drm_i915_private_t
operator|*
operator|)
name|dev
operator|->
name|dev_private
decl_stmt|;
name|drm_i915_sarea_t
modifier|*
name|sarea_priv
init|=
operator|(
name|drm_i915_sarea_t
operator|*
operator|)
name|dev_priv
operator|->
name|sarea_priv
decl_stmt|;
name|drm_i915_batchbuffer_t
modifier|*
name|batch
init|=
name|data
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
operator|!
name|dev_priv
operator|->
name|allow_batchbuffer
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Batchbuffer ioctl disabled\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|DRM_DEBUG
argument_list|(
literal|"i915 batchbuffer, start %x used %d cliprects %d\n"
argument_list|,
name|batch
operator|->
name|start
argument_list|,
name|batch
operator|->
name|used
argument_list|,
name|batch
operator|->
name|num_cliprects
argument_list|)
expr_stmt|;
name|LOCK_TEST_WITH_RETURN
argument_list|(
name|dev
argument_list|,
name|file_priv
argument_list|)
expr_stmt|;
if|if
condition|(
name|batch
operator|->
name|num_cliprects
operator|&&
name|DRM_VERIFYAREA_READ
argument_list|(
name|batch
operator|->
name|cliprects
argument_list|,
name|batch
operator|->
name|num_cliprects
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|drm_clip_rect
argument_list|)
argument_list|)
condition|)
return|return
operator|-
name|EFAULT
return|;
name|ret
operator|=
name|i915_dispatch_batchbuffer
argument_list|(
name|dev
argument_list|,
name|batch
argument_list|)
expr_stmt|;
name|sarea_priv
operator|->
name|last_dispatch
operator|=
name|READ_BREADCRUMB
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|i915_cmdbuffer
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
operator|(
name|drm_i915_private_t
operator|*
operator|)
name|dev
operator|->
name|dev_private
decl_stmt|;
name|drm_i915_sarea_t
modifier|*
name|sarea_priv
init|=
operator|(
name|drm_i915_sarea_t
operator|*
operator|)
name|dev_priv
operator|->
name|sarea_priv
decl_stmt|;
name|drm_i915_cmdbuffer_t
modifier|*
name|cmdbuf
init|=
name|data
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"i915 cmdbuffer, buf %p sz %d cliprects %d\n"
argument_list|,
name|cmdbuf
operator|->
name|buf
argument_list|,
name|cmdbuf
operator|->
name|sz
argument_list|,
name|cmdbuf
operator|->
name|num_cliprects
argument_list|)
expr_stmt|;
name|LOCK_TEST_WITH_RETURN
argument_list|(
name|dev
argument_list|,
name|file_priv
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmdbuf
operator|->
name|num_cliprects
operator|&&
name|DRM_VERIFYAREA_READ
argument_list|(
name|cmdbuf
operator|->
name|cliprects
argument_list|,
name|cmdbuf
operator|->
name|num_cliprects
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|drm_clip_rect
argument_list|)
argument_list|)
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Fault accessing cliprects\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EFAULT
return|;
block|}
name|ret
operator|=
name|i915_dispatch_cmdbuffer
argument_list|(
name|dev
argument_list|,
name|cmdbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"i915_dispatch_cmdbuffer failed\n"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|sarea_priv
operator|->
name|last_dispatch
operator|=
name|READ_BREADCRUMB
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DRM_DEBUG_CODE
argument_list|)
end_if

begin_define
define|#
directive|define
name|DRM_DEBUG_RELOCATION
value|(drm_debug != 0)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DRM_DEBUG_RELOCATION
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|i915_do_cleanup_pageflip
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|int
name|i
decl_stmt|,
name|planes
decl_stmt|,
name|num_pages
init|=
name|dev_priv
operator|->
name|sarea_priv
operator|->
name|third_handle
condition|?
literal|3
else|:
literal|2
decl_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|planes
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|dev_priv
operator|->
name|sarea_priv
operator|->
name|pf_current_page
operator|&
operator|(
literal|0x3
operator|<<
operator|(
literal|2
operator|*
name|i
operator|)
operator|)
condition|)
block|{
name|dev_priv
operator|->
name|sarea_priv
operator|->
name|pf_current_page
operator|=
operator|(
name|dev_priv
operator|->
name|sarea_priv
operator|->
name|pf_current_page
operator|&
operator|~
operator|(
literal|0x3
operator|<<
operator|(
literal|2
operator|*
name|i
operator|)
operator|)
operator|)
operator||
operator|(
operator|(
name|num_pages
operator|-
literal|1
operator|)
operator|<<
operator|(
literal|2
operator|*
name|i
operator|)
operator|)
expr_stmt|;
name|planes
operator||=
literal|1
operator|<<
name|i
expr_stmt|;
block|}
if|if
condition|(
name|planes
condition|)
name|i915_dispatch_flip
argument_list|(
name|dev
argument_list|,
name|planes
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|i915_flip_bufs
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
name|drm_i915_flip_t
modifier|*
name|param
init|=
name|data
decl_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|LOCK_TEST_WITH_RETURN
argument_list|(
name|dev
argument_list|,
name|file_priv
argument_list|)
expr_stmt|;
comment|/* This is really planes */
if|if
condition|(
name|param
operator|->
name|pipes
operator|&
operator|~
literal|0x3
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Invalid planes 0x%x, only<= 0x3 is valid\n"
argument_list|,
name|param
operator|->
name|pipes
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|i915_dispatch_flip
argument_list|(
name|dev
argument_list|,
name|param
operator|->
name|pipes
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|i915_getparam
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|drm_i915_getparam_t
modifier|*
name|param
init|=
name|data
decl_stmt|;
name|int
name|value
decl_stmt|;
if|if
condition|(
operator|!
name|dev_priv
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"called with no initialization\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
switch|switch
condition|(
name|param
operator|->
name|param
condition|)
block|{
case|case
name|I915_PARAM_IRQ_ACTIVE
case|:
name|value
operator|=
name|dev
operator|->
name|irq_enabled
condition|?
literal|1
else|:
literal|0
expr_stmt|;
break|break;
case|case
name|I915_PARAM_ALLOW_BATCHBUFFER
case|:
name|value
operator|=
name|dev_priv
operator|->
name|allow_batchbuffer
condition|?
literal|1
else|:
literal|0
expr_stmt|;
break|break;
case|case
name|I915_PARAM_LAST_DISPATCH
case|:
name|value
operator|=
name|READ_BREADCRUMB
argument_list|(
name|dev_priv
argument_list|)
expr_stmt|;
break|break;
case|case
name|I915_PARAM_CHIPSET_ID
case|:
name|value
operator|=
name|dev
operator|->
name|pci_device
expr_stmt|;
break|break;
case|case
name|I915_PARAM_HAS_GEM
case|:
comment|/* We need to reset this to 1 once we have GEM */
name|value
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|DRM_ERROR
argument_list|(
literal|"Unknown parameter %d\n"
argument_list|,
name|param
operator|->
name|param
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
if|if
condition|(
name|DRM_COPY_TO_USER
argument_list|(
name|param
operator|->
name|value
argument_list|,
operator|&
name|value
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"DRM_COPY_TO_USER failed\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EFAULT
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|i915_setparam
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|drm_i915_setparam_t
modifier|*
name|param
init|=
name|data
decl_stmt|;
if|if
condition|(
operator|!
name|dev_priv
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"called with no initialization\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
switch|switch
condition|(
name|param
operator|->
name|param
condition|)
block|{
case|case
name|I915_SETPARAM_USE_MI_BATCHBUFFER_START
case|:
break|break;
case|case
name|I915_SETPARAM_TEX_LRU_LOG_GRANULARITY
case|:
name|dev_priv
operator|->
name|tex_lru_log_granularity
operator|=
name|param
operator|->
name|value
expr_stmt|;
break|break;
case|case
name|I915_SETPARAM_ALLOW_BATCHBUFFER
case|:
name|dev_priv
operator|->
name|allow_batchbuffer
operator|=
name|param
operator|->
name|value
expr_stmt|;
break|break;
default|default:
name|DRM_ERROR
argument_list|(
literal|"unknown parameter %d\n"
argument_list|,
name|param
operator|->
name|param
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
name|drm_i915_mmio_entry_t
name|mmio_table
index|[]
init|=
block|{
index|[
name|MMIO_REGS_PS_DEPTH_COUNT
index|]
operator|=
block|{
name|I915_MMIO_MAY_READ
operator||
name|I915_MMIO_MAY_WRITE
block|,
literal|0x2350
block|,
literal|8
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mmio_table_size
init|=
sizeof|sizeof
argument_list|(
name|mmio_table
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|drm_i915_mmio_entry_t
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|i915_mmio
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
name|uint32_t
name|buf
index|[
literal|8
index|]
decl_stmt|;
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|drm_i915_mmio_entry_t
modifier|*
name|e
decl_stmt|;
name|drm_i915_mmio_t
modifier|*
name|mmio
init|=
name|data
decl_stmt|;
name|void
name|__iomem
modifier|*
name|base
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|dev_priv
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"called with no initialization\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
if|if
condition|(
name|mmio
operator|->
name|reg
operator|>=
name|mmio_table_size
condition|)
return|return
operator|-
name|EINVAL
return|;
name|e
operator|=
operator|&
name|mmio_table
index|[
name|mmio
operator|->
name|reg
index|]
expr_stmt|;
name|base
operator|=
operator|(
name|u8
operator|*
operator|)
name|dev_priv
operator|->
name|mmio_map
operator|->
name|handle
operator|+
name|e
operator|->
name|offset
expr_stmt|;
switch|switch
condition|(
name|mmio
operator|->
name|read_write
condition|)
block|{
case|case
name|I915_MMIO_READ
case|:
if|if
condition|(
operator|!
operator|(
name|e
operator|->
name|flag
operator|&
name|I915_MMIO_MAY_READ
operator|)
condition|)
return|return
operator|-
name|EINVAL
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|e
operator|->
name|size
operator|/
literal|4
condition|;
name|i
operator|++
control|)
name|buf
index|[
name|i
index|]
operator|=
name|I915_READ
argument_list|(
name|e
operator|->
name|offset
operator|+
name|i
operator|*
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|DRM_COPY_TO_USER
argument_list|(
name|mmio
operator|->
name|data
argument_list|,
name|buf
argument_list|,
name|e
operator|->
name|size
argument_list|)
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"DRM_COPY_TO_USER failed\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EFAULT
return|;
block|}
break|break;
case|case
name|I915_MMIO_WRITE
case|:
if|if
condition|(
operator|!
operator|(
name|e
operator|->
name|flag
operator|&
name|I915_MMIO_MAY_WRITE
operator|)
condition|)
return|return
operator|-
name|EINVAL
return|;
if|if
condition|(
name|DRM_COPY_FROM_USER
argument_list|(
name|buf
argument_list|,
name|mmio
operator|->
name|data
argument_list|,
name|e
operator|->
name|size
argument_list|)
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"DRM_COPY_TO_USER failed\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EFAULT
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|e
operator|->
name|size
operator|/
literal|4
condition|;
name|i
operator|++
control|)
name|I915_WRITE
argument_list|(
name|e
operator|->
name|offset
operator|+
name|i
operator|*
literal|4
argument_list|,
name|buf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|i915_set_status_page
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|drm_i915_hws_addr_t
modifier|*
name|hws
init|=
name|data
decl_stmt|;
if|if
condition|(
operator|!
name|I915_NEED_GFX_HWS
argument_list|(
name|dev
argument_list|)
condition|)
return|return
operator|-
name|EINVAL
return|;
if|if
condition|(
operator|!
name|dev_priv
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"called with no initialization\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|DRM_DEBUG
argument_list|(
literal|"set status page addr 0x%08x\n"
argument_list|,
operator|(
name|u32
operator|)
name|hws
operator|->
name|addr
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|status_gfx_addr
operator|=
name|hws
operator|->
name|addr
operator|&
operator|(
literal|0x1ffff
operator|<<
literal|12
operator|)
expr_stmt|;
name|dev_priv
operator|->
name|hws_map
operator|.
name|offset
operator|=
name|dev
operator|->
name|agp
operator|->
name|base
operator|+
name|hws
operator|->
name|addr
expr_stmt|;
name|dev_priv
operator|->
name|hws_map
operator|.
name|size
operator|=
literal|4
operator|*
literal|1024
expr_stmt|;
name|dev_priv
operator|->
name|hws_map
operator|.
name|type
operator|=
literal|0
expr_stmt|;
name|dev_priv
operator|->
name|hws_map
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|dev_priv
operator|->
name|hws_map
operator|.
name|mtrr
operator|=
literal|0
expr_stmt|;
name|drm_core_ioremap
argument_list|(
operator|&
name|dev_priv
operator|->
name|hws_map
argument_list|,
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|hws_map
operator|.
name|handle
operator|==
name|NULL
condition|)
block|{
name|i915_dma_cleanup
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|status_gfx_addr
operator|=
literal|0
expr_stmt|;
name|DRM_ERROR
argument_list|(
literal|"can not ioremap virtual address for"
literal|" G33 hw status page\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
block|}
name|dev_priv
operator|->
name|hw_status_page
operator|=
name|dev_priv
operator|->
name|hws_map
operator|.
name|handle
expr_stmt|;
name|memset
argument_list|(
name|dev_priv
operator|->
name|hw_status_page
argument_list|,
literal|0
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|I915_WRITE
argument_list|(
name|HWS_PGA
argument_list|,
name|dev_priv
operator|->
name|status_gfx_addr
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"load hws 0x2080 with gfx mem 0x%x\n"
argument_list|,
name|dev_priv
operator|->
name|status_gfx_addr
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"load hws at %p\n"
argument_list|,
name|dev_priv
operator|->
name|hw_status_page
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|i915_driver_load
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|unsigned
name|long
name|flags
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
decl_stmt|;
name|unsigned
name|long
name|base
decl_stmt|,
name|size
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|,
name|mmio_bar
init|=
name|IS_I9XX
argument_list|(
name|dev
argument_list|)
condition|?
literal|0
else|:
literal|1
decl_stmt|;
comment|/* i915 has 4 more counters */
name|dev
operator|->
name|counters
operator|+=
literal|4
expr_stmt|;
name|dev
operator|->
name|types
index|[
literal|6
index|]
operator|=
name|_DRM_STAT_IRQ
expr_stmt|;
name|dev
operator|->
name|types
index|[
literal|7
index|]
operator|=
name|_DRM_STAT_PRIMARY
expr_stmt|;
name|dev
operator|->
name|types
index|[
literal|8
index|]
operator|=
name|_DRM_STAT_SECONDARY
expr_stmt|;
name|dev
operator|->
name|types
index|[
literal|9
index|]
operator|=
name|_DRM_STAT_DMA
expr_stmt|;
name|dev_priv
operator|=
name|drm_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|drm_i915_private_t
argument_list|)
argument_list|,
name|DRM_MEM_DRIVER
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev_priv
operator|==
name|NULL
condition|)
return|return
operator|-
name|ENOMEM
return|;
name|memset
argument_list|(
name|dev_priv
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|drm_i915_private_t
argument_list|)
argument_list|)
expr_stmt|;
name|dev
operator|->
name|dev_private
operator|=
operator|(
name|void
operator|*
operator|)
name|dev_priv
expr_stmt|;
name|dev_priv
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
comment|/* Add register map (needed for suspend/resume) */
name|base
operator|=
name|drm_get_resource_start
argument_list|(
name|dev
argument_list|,
name|mmio_bar
argument_list|)
expr_stmt|;
name|size
operator|=
name|drm_get_resource_len
argument_list|(
name|dev
argument_list|,
name|mmio_bar
argument_list|)
expr_stmt|;
name|ret
operator|=
name|drm_addmap
argument_list|(
name|dev
argument_list|,
name|base
argument_list|,
name|size
argument_list|,
name|_DRM_REGISTERS
argument_list|,
name|_DRM_KERNEL
operator||
name|_DRM_DRIVER
argument_list|,
operator|&
name|dev_priv
operator|->
name|mmio_map
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|I915_HAVE_GEM
name|i915_gem_load
argument_list|(
name|dev
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|DRM_SPININIT
argument_list|(
operator|&
name|dev_priv
operator|->
name|user_irq_lock
argument_list|,
literal|"userirq"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__linux__
if|#
directive|if
name|LINUX_VERSION_CODE
operator|<
name|KERNEL_VERSION
argument_list|(
literal|2
operator|,
literal|6
operator|,
literal|25
argument_list|)
name|intel_init_chipset_flush_compat
argument_list|(
name|dev
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|LINUX_VERSION_CODE
operator|>
name|KERNEL_VERSION
argument_list|(
literal|2
operator|,
literal|6
operator|,
literal|25
argument_list|)
name|intel_opregion_init
argument_list|(
name|dev
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* Init HWS */
if|if
condition|(
operator|!
name|I915_NEED_GFX_HWS
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|ret
operator|=
name|i915_init_hardware_status
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|i915_driver_unload
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|drm_i915_private
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|i915_free_hardware_status
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|drm_rmmap
argument_list|(
name|dev
argument_list|,
name|dev_priv
operator|->
name|mmio_map
argument_list|)
expr_stmt|;
name|DRM_SPINUNINIT
argument_list|(
operator|&
name|dev_priv
operator|->
name|user_irq_lock
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__linux__
if|#
directive|if
name|LINUX_VERSION_CODE
operator|>
name|KERNEL_VERSION
argument_list|(
literal|2
operator|,
literal|6
operator|,
literal|25
argument_list|)
name|intel_opregion_free
argument_list|(
name|dev
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|drm_free
argument_list|(
name|dev
operator|->
name|dev_private
argument_list|,
sizeof|sizeof
argument_list|(
name|drm_i915_private_t
argument_list|)
argument_list|,
name|DRM_MEM_DRIVER
argument_list|)
expr_stmt|;
name|dev
operator|->
name|dev_private
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|__linux__
if|#
directive|if
name|LINUX_VERSION_CODE
operator|<
name|KERNEL_VERSION
argument_list|(
literal|2
operator|,
literal|6
operator|,
literal|25
argument_list|)
name|intel_fini_chipset_flush_compat
argument_list|(
name|dev
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|i915_driver_lastclose
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
comment|/* agp off can use this to get called before dev_priv */
if|if
condition|(
operator|!
name|dev_priv
condition|)
return|return;
ifdef|#
directive|ifdef
name|I915_HAVE_BUFFER
if|if
condition|(
name|dev_priv
operator|->
name|val_bufs
condition|)
block|{
name|vfree
argument_list|(
name|dev_priv
operator|->
name|val_bufs
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|val_bufs
operator|=
name|NULL
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|I915_HAVE_GEM
name|i915_gem_lastclose
argument_list|(
name|dev
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|drm_getsarea
argument_list|(
name|dev
argument_list|)
operator|&&
name|dev_priv
operator|->
name|sarea_priv
condition|)
name|i915_do_cleanup_pageflip
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|sarea_priv
condition|)
name|dev_priv
operator|->
name|sarea_priv
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|dev_priv
operator|->
name|agp_heap
condition|)
name|i915_mem_takedown
argument_list|(
operator|&
operator|(
name|dev_priv
operator|->
name|agp_heap
operator|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|I915_HAVE_BUFFER
argument_list|)
if|if
condition|(
name|dev_priv
operator|->
name|sarea_kmap
operator|.
name|virtual
condition|)
block|{
name|drm_bo_kunmap
argument_list|(
operator|&
name|dev_priv
operator|->
name|sarea_kmap
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|sarea_kmap
operator|.
name|virtual
operator|=
name|NULL
expr_stmt|;
name|dev
operator|->
name|lock
operator|.
name|hw_lock
operator|=
name|NULL
expr_stmt|;
name|dev
operator|->
name|sigdata
operator|.
name|lock
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|dev_priv
operator|->
name|sarea_bo
condition|)
block|{
name|mutex_lock
argument_list|(
operator|&
name|dev
operator|->
name|struct_mutex
argument_list|)
expr_stmt|;
name|drm_bo_usage_deref_locked
argument_list|(
operator|&
name|dev_priv
operator|->
name|sarea_bo
argument_list|)
expr_stmt|;
name|mutex_unlock
argument_list|(
operator|&
name|dev
operator|->
name|struct_mutex
argument_list|)
expr_stmt|;
name|dev_priv
operator|->
name|sarea_bo
operator|=
name|NULL
expr_stmt|;
block|}
endif|#
directive|endif
name|i915_dma_cleanup
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|i915_driver_open
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
name|struct
name|drm_i915_file_private
modifier|*
name|i915_file_priv
decl_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|i915_file_priv
operator|=
operator|(
expr|struct
name|drm_i915_file_private
operator|*
operator|)
name|drm_alloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|i915_file_priv
argument_list|)
argument_list|,
name|DRM_MEM_FILES
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|i915_file_priv
condition|)
return|return
operator|-
name|ENOMEM
return|;
name|file_priv
operator|->
name|driver_priv
operator|=
name|i915_file_priv
expr_stmt|;
name|i915_file_priv
operator|->
name|mm
operator|.
name|last_gem_seqno
operator|=
literal|0
expr_stmt|;
name|i915_file_priv
operator|->
name|mm
operator|.
name|last_gem_throttle_seqno
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|i915_driver_preclose
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
name|drm_i915_private_t
modifier|*
name|dev_priv
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|i915_mem_release
argument_list|(
name|dev
argument_list|,
name|file_priv
argument_list|,
name|dev_priv
operator|->
name|agp_heap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|i915_driver_postclose
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
name|struct
name|drm_i915_file_private
modifier|*
name|i915_file_priv
init|=
name|file_priv
operator|->
name|driver_priv
decl_stmt|;
name|drm_free
argument_list|(
name|i915_file_priv
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|i915_file_priv
argument_list|)
argument_list|,
name|DRM_MEM_FILES
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|struct
name|drm_ioctl_desc
name|i915_ioctls
index|[]
init|=
block|{
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_I915_INIT
argument_list|,
name|i915_dma_init
argument_list|,
name|DRM_AUTH
operator||
name|DRM_MASTER
operator||
name|DRM_ROOT_ONLY
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_I915_FLUSH
argument_list|,
name|i915_flush_ioctl
argument_list|,
name|DRM_AUTH
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_I915_FLIP
argument_list|,
name|i915_flip_bufs
argument_list|,
name|DRM_AUTH
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_I915_BATCHBUFFER
argument_list|,
name|i915_batchbuffer
argument_list|,
name|DRM_AUTH
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_I915_IRQ_EMIT
argument_list|,
name|i915_irq_emit
argument_list|,
name|DRM_AUTH
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_I915_IRQ_WAIT
argument_list|,
name|i915_irq_wait
argument_list|,
name|DRM_AUTH
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_I915_GETPARAM
argument_list|,
name|i915_getparam
argument_list|,
name|DRM_AUTH
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_I915_SETPARAM
argument_list|,
name|i915_setparam
argument_list|,
name|DRM_AUTH
operator||
name|DRM_MASTER
operator||
name|DRM_ROOT_ONLY
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_I915_ALLOC
argument_list|,
name|i915_mem_alloc
argument_list|,
name|DRM_AUTH
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_I915_FREE
argument_list|,
name|i915_mem_free
argument_list|,
name|DRM_AUTH
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_I915_INIT_HEAP
argument_list|,
name|i915_mem_init_heap
argument_list|,
name|DRM_AUTH
operator||
name|DRM_MASTER
operator||
name|DRM_ROOT_ONLY
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_I915_CMDBUFFER
argument_list|,
name|i915_cmdbuffer
argument_list|,
name|DRM_AUTH
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_I915_DESTROY_HEAP
argument_list|,
name|i915_mem_destroy_heap
argument_list|,
name|DRM_AUTH
operator||
name|DRM_MASTER
operator||
name|DRM_ROOT_ONLY
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_I915_SET_VBLANK_PIPE
argument_list|,
name|i915_vblank_pipe_set
argument_list|,
name|DRM_AUTH
operator||
name|DRM_MASTER
operator||
name|DRM_ROOT_ONLY
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_I915_GET_VBLANK_PIPE
argument_list|,
name|i915_vblank_pipe_get
argument_list|,
name|DRM_AUTH
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_I915_VBLANK_SWAP
argument_list|,
name|i915_vblank_swap
argument_list|,
name|DRM_AUTH
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_I915_MMIO
argument_list|,
name|i915_mmio
argument_list|,
name|DRM_AUTH
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_I915_HWS_ADDR
argument_list|,
name|i915_set_status_page
argument_list|,
name|DRM_AUTH
operator||
name|DRM_MASTER
operator||
name|DRM_ROOT_ONLY
argument_list|)
block|,
ifdef|#
directive|ifdef
name|I915_HAVE_BUFFER
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_I915_EXECBUFFER
argument_list|,
name|i915_execbuffer
argument_list|,
name|DRM_AUTH
argument_list|)
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|I915_HAVE_GEM
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_I915_GEM_INIT
argument_list|,
name|i915_gem_init_ioctl
argument_list|,
name|DRM_AUTH
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_I915_GEM_EXECBUFFER
argument_list|,
name|i915_gem_execbuffer
argument_list|,
name|DRM_AUTH
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_I915_GEM_PIN
argument_list|,
name|i915_gem_pin_ioctl
argument_list|,
name|DRM_AUTH
operator||
name|DRM_ROOT_ONLY
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_I915_GEM_UNPIN
argument_list|,
name|i915_gem_unpin_ioctl
argument_list|,
name|DRM_AUTH
operator||
name|DRM_ROOT_ONLY
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_I915_GEM_BUSY
argument_list|,
name|i915_gem_busy_ioctl
argument_list|,
name|DRM_AUTH
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_I915_GEM_THROTTLE
argument_list|,
name|i915_gem_throttle_ioctl
argument_list|,
name|DRM_AUTH
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_I915_GEM_ENTERVT
argument_list|,
name|i915_gem_entervt_ioctl
argument_list|,
name|DRM_AUTH
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_I915_GEM_LEAVEVT
argument_list|,
name|i915_gem_leavevt_ioctl
argument_list|,
name|DRM_AUTH
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_I915_GEM_CREATE
argument_list|,
name|i915_gem_create_ioctl
argument_list|,
literal|0
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_I915_GEM_PREAD
argument_list|,
name|i915_gem_pread_ioctl
argument_list|,
literal|0
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_I915_GEM_PWRITE
argument_list|,
name|i915_gem_pwrite_ioctl
argument_list|,
literal|0
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_I915_GEM_MMAP
argument_list|,
name|i915_gem_mmap_ioctl
argument_list|,
literal|0
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_I915_GEM_SET_DOMAIN
argument_list|,
name|i915_gem_set_domain_ioctl
argument_list|,
literal|0
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_I915_GEM_SW_FINISH
argument_list|,
name|i915_gem_sw_finish_ioctl
argument_list|,
literal|0
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_I915_GEM_SET_TILING
argument_list|,
name|i915_gem_set_tiling
argument_list|,
literal|0
argument_list|)
block|,
name|DRM_IOCTL_DEF
argument_list|(
name|DRM_I915_GEM_GET_TILING
argument_list|,
name|i915_gem_get_tiling
argument_list|,
literal|0
argument_list|)
block|,
endif|#
directive|endif
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|i915_max_ioctl
init|=
name|DRM_ARRAY_SIZE
argument_list|(
name|i915_ioctls
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**  * Determine if the device really is AGP or not.  *  * All Intel graphics chipsets are treated as AGP, even if they are really  * PCI-e.  *  * \param dev   The device to be tested.  *  * \returns  * A value of 1 is always retured to indictate every i9x5 is AGP.  */
end_comment

begin_function
name|int
name|i915_driver_device_is_agp
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|i915_driver_firstopen
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|I915_HAVE_BUFFER
name|drm_bo_driver_init
argument_list|(
name|dev
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

end_unit

