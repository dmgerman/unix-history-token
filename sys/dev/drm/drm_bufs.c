begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright 1999, 2000 Precision Insight, Inc., Cedar Park, Texas.  * Copyright 2000 VA Linux Systems, Inc., Sunnyvale, California.  * All Rights Reserved.  *  * Permission is hereby granted, free of charge, to any person obtaining a  * copy of this software and associated documentation files (the "Software"),  * to deal in the Software without restriction, including without limitation  * the rights to use, copy, modify, merge, publish, distribute, sublicense,  * and/or sell copies of the Software, and to permit persons to whom the  * Software is furnished to do so, subject to the following conditions:  *  * The above copyright notice and this permission notice (including the next  * paragraph) shall be included in all copies or substantial portions of the  * Software.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL  * VA LINUX SYSTEMS AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR  * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,  * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR  * OTHER DEALINGS IN THE SOFTWARE.  *  * Authors:  *    Rickard E. (Rik) Faith<faith@valinux.com>  *    Gareth Hughes<gareth@valinux.com>  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/** @file drm_bufs.c  * Implementation of the ioctls for setup of DRM mappings and DMA buffers.  */
end_comment

begin_include
include|#
directive|include
file|"dev/pci/pcireg.h"
end_include

begin_include
include|#
directive|include
file|"dev/drm/drmP.h"
end_include

begin_comment
comment|/* Allocation of PCI memory resources (framebuffer, registers, etc.) for  * drm_get_resource_*.  Note that they are not RF_ACTIVE, so there's no virtual  * address for accessing them.  Cleaned up at unload.  */
end_comment

begin_function
specifier|static
name|int
name|drm_alloc_resource
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|resource
parameter_list|)
block|{
name|struct
name|resource
modifier|*
name|res
decl_stmt|;
name|int
name|rid
decl_stmt|;
name|DRM_SPINLOCK_ASSERT
argument_list|(
operator|&
name|dev
operator|->
name|dev_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|resource
operator|>=
name|DRM_MAX_PCI_RESOURCE
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Resource %d too large\n"
argument_list|,
name|resource
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|dev
operator|->
name|pcir
index|[
name|resource
index|]
operator|!=
name|NULL
condition|)
block|{
return|return
literal|0
return|;
block|}
name|DRM_UNLOCK
argument_list|()
expr_stmt|;
name|rid
operator|=
name|PCIR_BAR
argument_list|(
name|resource
argument_list|)
expr_stmt|;
name|res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
operator|->
name|device
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_SHAREABLE
argument_list|)
expr_stmt|;
name|DRM_LOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|NULL
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Couldn't find resource 0x%x\n"
argument_list|,
name|resource
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|dev
operator|->
name|pcir
index|[
name|resource
index|]
operator|==
name|NULL
condition|)
block|{
name|dev
operator|->
name|pcirid
index|[
name|resource
index|]
operator|=
name|rid
expr_stmt|;
name|dev
operator|->
name|pcir
index|[
name|resource
index|]
operator|=
name|res
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|unsigned
name|long
name|drm_get_resource_start
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|unsigned
name|int
name|resource
parameter_list|)
block|{
if|if
condition|(
name|drm_alloc_resource
argument_list|(
name|dev
argument_list|,
name|resource
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
return|return
name|rman_get_start
argument_list|(
name|dev
operator|->
name|pcir
index|[
name|resource
index|]
argument_list|)
return|;
block|}
end_function

begin_function
name|unsigned
name|long
name|drm_get_resource_len
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|unsigned
name|int
name|resource
parameter_list|)
block|{
if|if
condition|(
name|drm_alloc_resource
argument_list|(
name|dev
argument_list|,
name|resource
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
return|return
name|rman_get_size
argument_list|(
name|dev
operator|->
name|pcir
index|[
name|resource
index|]
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|drm_addmap
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|size
parameter_list|,
name|enum
name|drm_map_type
name|type
parameter_list|,
name|enum
name|drm_map_flags
name|flags
parameter_list|,
name|drm_local_map_t
modifier|*
modifier|*
name|map_ptr
parameter_list|)
block|{
name|drm_local_map_t
modifier|*
name|map
decl_stmt|;
name|int
name|align
decl_stmt|;
comment|/*drm_agp_mem_t *entry; 	int valid;*/
comment|/* Only allow shared memory to be removable since we only keep enough 	 * book keeping information about shared memory to allow for removal 	 * when processes fork. 	 */
if|if
condition|(
operator|(
name|flags
operator|&
name|_DRM_REMOVABLE
operator|)
operator|&&
name|type
operator|!=
name|_DRM_SHM
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Requested removable map for non-DRM_SHM\n"
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
if|if
condition|(
operator|(
name|offset
operator|&
name|PAGE_MASK
operator|)
operator|||
operator|(
name|size
operator|&
name|PAGE_MASK
operator|)
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"offset/size not page aligned: 0x%lx/0x%lx\n"
argument_list|,
name|offset
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
if|if
condition|(
name|offset
operator|+
name|size
operator|<
name|offset
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"offset and size wrap around: 0x%lx/0x%lx\n"
argument_list|,
name|offset
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|DRM_DEBUG
argument_list|(
literal|"offset = 0x%08lx, size = 0x%08lx, type = %d\n"
argument_list|,
name|offset
argument_list|,
name|size
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* Check if this is just another version of a kernel-allocated map, and 	 * just hand that back if so. 	 */
if|if
condition|(
name|type
operator|==
name|_DRM_REGISTERS
operator|||
name|type
operator|==
name|_DRM_FRAME_BUFFER
operator|||
name|type
operator|==
name|_DRM_SHM
condition|)
block|{
name|TAILQ_FOREACH
argument_list|(
argument|map
argument_list|,
argument|&dev->maplist
argument_list|,
argument|link
argument_list|)
block|{
if|if
condition|(
name|map
operator|->
name|type
operator|==
name|type
operator|&&
operator|(
name|map
operator|->
name|offset
operator|==
name|offset
operator|||
operator|(
name|map
operator|->
name|type
operator|==
name|_DRM_SHM
operator|&&
name|map
operator|->
name|flags
operator|==
name|_DRM_CONTAINS_LOCK
operator|)
operator|)
condition|)
block|{
name|map
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"Found kernel map %d\n"
argument_list|,
name|type
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
block|}
name|DRM_UNLOCK
argument_list|()
expr_stmt|;
comment|/* Allocate a new map structure, fill it in, and do any type-specific 	 * initialization necessary. 	 */
name|map
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|map
argument_list|)
argument_list|,
name|DRM_MEM_MAPS
argument_list|,
name|M_ZERO
operator||
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|map
condition|)
block|{
name|DRM_LOCK
argument_list|()
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|map
operator|->
name|offset
operator|=
name|offset
expr_stmt|;
name|map
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|map
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|map
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
switch|switch
condition|(
name|map
operator|->
name|type
condition|)
block|{
case|case
name|_DRM_REGISTERS
case|:
name|map
operator|->
name|handle
operator|=
name|drm_ioremap
argument_list|(
name|dev
argument_list|,
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|map
operator|->
name|flags
operator|&
name|_DRM_WRITE_COMBINING
operator|)
condition|)
break|break;
comment|/* FALLTHROUGH */
case|case
name|_DRM_FRAME_BUFFER
case|:
if|if
condition|(
name|drm_mtrr_add
argument_list|(
name|map
operator|->
name|offset
argument_list|,
name|map
operator|->
name|size
argument_list|,
name|DRM_MTRR_WC
argument_list|)
operator|==
literal|0
condition|)
name|map
operator|->
name|mtrr
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|_DRM_SHM
case|:
name|map
operator|->
name|handle
operator|=
name|malloc
argument_list|(
name|map
operator|->
name|size
argument_list|,
name|DRM_MEM_MAPS
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"%lu %d %p\n"
argument_list|,
name|map
operator|->
name|size
argument_list|,
name|drm_order
argument_list|(
name|map
operator|->
name|size
argument_list|)
argument_list|,
name|map
operator|->
name|handle
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|map
operator|->
name|handle
condition|)
block|{
name|free
argument_list|(
name|map
argument_list|,
name|DRM_MEM_MAPS
argument_list|)
expr_stmt|;
name|DRM_LOCK
argument_list|()
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|map
operator|->
name|offset
operator|=
operator|(
name|unsigned
name|long
operator|)
name|map
operator|->
name|handle
expr_stmt|;
if|if
condition|(
name|map
operator|->
name|flags
operator|&
name|_DRM_CONTAINS_LOCK
condition|)
block|{
comment|/* Prevent a 2nd X Server from creating a 2nd lock */
name|DRM_LOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|lock
operator|.
name|hw_lock
operator|!=
name|NULL
condition|)
block|{
name|DRM_UNLOCK
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|map
operator|->
name|handle
argument_list|,
name|DRM_MEM_MAPS
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|map
argument_list|,
name|DRM_MEM_MAPS
argument_list|)
expr_stmt|;
return|return
name|EBUSY
return|;
block|}
name|dev
operator|->
name|lock
operator|.
name|hw_lock
operator|=
name|map
operator|->
name|handle
expr_stmt|;
comment|/* Pointer to lock */
name|DRM_UNLOCK
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|_DRM_AGP
case|:
comment|/*valid = 0;*/
comment|/* In some cases (i810 driver), user space may have already 		 * added the AGP base itself, because dev->agp->base previously 		 * only got set during AGP enable.  So, only add the base 		 * address if the map's offset isn't already within the 		 * aperture. 		 */
if|if
condition|(
name|map
operator|->
name|offset
operator|<
name|dev
operator|->
name|agp
operator|->
name|base
operator|||
name|map
operator|->
name|offset
operator|>
name|dev
operator|->
name|agp
operator|->
name|base
operator|+
name|dev
operator|->
name|agp
operator|->
name|info
operator|.
name|ai_aperture_size
operator|-
literal|1
condition|)
block|{
name|map
operator|->
name|offset
operator|+=
name|dev
operator|->
name|agp
operator|->
name|base
expr_stmt|;
block|}
name|map
operator|->
name|mtrr
operator|=
name|dev
operator|->
name|agp
operator|->
name|mtrr
expr_stmt|;
comment|/* for getmap */
comment|/*for (entry = dev->agp->memory; entry; entry = entry->next) { 			if ((map->offset>= entry->bound)&& 			    (map->offset + map->size<= 			    entry->bound + entry->pages * PAGE_SIZE)) { 				valid = 1; 				break; 			} 		} 		if (!valid) { 			free(map, DRM_MEM_MAPS); 			DRM_LOCK(); 			return EACCES; 		}*/
break|break;
case|case
name|_DRM_SCATTER_GATHER
case|:
if|if
condition|(
operator|!
name|dev
operator|->
name|sg
condition|)
block|{
name|free
argument_list|(
name|map
argument_list|,
name|DRM_MEM_MAPS
argument_list|)
expr_stmt|;
name|DRM_LOCK
argument_list|()
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|map
operator|->
name|offset
operator|+=
name|dev
operator|->
name|sg
operator|->
name|handle
expr_stmt|;
break|break;
case|case
name|_DRM_CONSISTENT
case|:
comment|/* Unfortunately, we don't get any alignment specification from 		 * the caller, so we have to guess.  drm_pci_alloc requires 		 * a power-of-two alignment, so try to align the bus address of 		 * the map to it size if possible, otherwise just assume 		 * PAGE_SIZE alignment. 		 */
name|align
operator|=
name|map
operator|->
name|size
expr_stmt|;
if|if
condition|(
operator|(
name|align
operator|&
operator|(
name|align
operator|-
literal|1
operator|)
operator|)
operator|!=
literal|0
condition|)
name|align
operator|=
name|PAGE_SIZE
expr_stmt|;
name|map
operator|->
name|dmah
operator|=
name|drm_pci_alloc
argument_list|(
name|dev
argument_list|,
name|map
operator|->
name|size
argument_list|,
name|align
argument_list|,
literal|0xfffffffful
argument_list|)
expr_stmt|;
if|if
condition|(
name|map
operator|->
name|dmah
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|map
argument_list|,
name|DRM_MEM_MAPS
argument_list|)
expr_stmt|;
name|DRM_LOCK
argument_list|()
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|map
operator|->
name|handle
operator|=
name|map
operator|->
name|dmah
operator|->
name|vaddr
expr_stmt|;
name|map
operator|->
name|offset
operator|=
name|map
operator|->
name|dmah
operator|->
name|busaddr
expr_stmt|;
break|break;
default|default:
name|DRM_ERROR
argument_list|(
literal|"Bad map type %d\n"
argument_list|,
name|map
operator|->
name|type
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|map
argument_list|,
name|DRM_MEM_MAPS
argument_list|)
expr_stmt|;
name|DRM_LOCK
argument_list|()
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|DRM_LOCK
argument_list|()
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|dev
operator|->
name|maplist
argument_list|,
name|map
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|done
label|:
comment|/* Jumped to, with lock held, when a kernel map is found. */
name|DRM_DEBUG
argument_list|(
literal|"Added map %d 0x%lx/0x%lx\n"
argument_list|,
name|map
operator|->
name|type
argument_list|,
name|map
operator|->
name|offset
argument_list|,
name|map
operator|->
name|size
argument_list|)
expr_stmt|;
operator|*
name|map_ptr
operator|=
name|map
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|drm_addmap_ioctl
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
name|struct
name|drm_map
modifier|*
name|request
init|=
name|data
decl_stmt|;
name|drm_local_map_t
modifier|*
name|map
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|dev
operator|->
name|flags
operator|&
operator|(
name|FREAD
operator||
name|FWRITE
operator|)
operator|)
condition|)
return|return
name|EACCES
return|;
comment|/* Require read/write */
if|if
condition|(
operator|!
name|DRM_SUSER
argument_list|(
name|DRM_CURPROC
argument_list|)
operator|&&
name|request
operator|->
name|type
operator|!=
name|_DRM_AGP
condition|)
return|return
name|EACCES
return|;
name|DRM_LOCK
argument_list|()
expr_stmt|;
name|err
operator|=
name|drm_addmap
argument_list|(
name|dev
argument_list|,
name|request
operator|->
name|offset
argument_list|,
name|request
operator|->
name|size
argument_list|,
name|request
operator|->
name|type
argument_list|,
name|request
operator|->
name|flags
argument_list|,
operator|&
name|map
argument_list|)
expr_stmt|;
name|DRM_UNLOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
return|return
name|err
return|;
name|request
operator|->
name|offset
operator|=
name|map
operator|->
name|offset
expr_stmt|;
name|request
operator|->
name|size
operator|=
name|map
operator|->
name|size
expr_stmt|;
name|request
operator|->
name|type
operator|=
name|map
operator|->
name|type
expr_stmt|;
name|request
operator|->
name|flags
operator|=
name|map
operator|->
name|flags
expr_stmt|;
name|request
operator|->
name|mtrr
operator|=
name|map
operator|->
name|mtrr
expr_stmt|;
name|request
operator|->
name|handle
operator|=
name|map
operator|->
name|handle
expr_stmt|;
if|if
condition|(
name|request
operator|->
name|type
operator|!=
name|_DRM_SHM
condition|)
block|{
name|request
operator|->
name|handle
operator|=
operator|(
name|void
operator|*
operator|)
name|request
operator|->
name|offset
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|drm_rmmap
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|drm_local_map_t
modifier|*
name|map
parameter_list|)
block|{
name|DRM_SPINLOCK_ASSERT
argument_list|(
operator|&
name|dev
operator|->
name|dev_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|map
operator|==
name|NULL
condition|)
return|return;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|dev
operator|->
name|maplist
argument_list|,
name|map
argument_list|,
name|link
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|map
operator|->
name|type
condition|)
block|{
case|case
name|_DRM_REGISTERS
case|:
if|if
condition|(
name|map
operator|->
name|bsr
operator|==
name|NULL
condition|)
name|drm_ioremapfree
argument_list|(
name|map
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|_DRM_FRAME_BUFFER
case|:
if|if
condition|(
name|map
operator|->
name|mtrr
condition|)
block|{
name|int
name|__unused
name|retcode
decl_stmt|;
name|retcode
operator|=
name|drm_mtrr_del
argument_list|(
literal|0
argument_list|,
name|map
operator|->
name|offset
argument_list|,
name|map
operator|->
name|size
argument_list|,
name|DRM_MTRR_WC
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"mtrr_del = %d\n"
argument_list|,
name|retcode
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|_DRM_SHM
case|:
name|free
argument_list|(
name|map
operator|->
name|handle
argument_list|,
name|DRM_MEM_MAPS
argument_list|)
expr_stmt|;
break|break;
case|case
name|_DRM_AGP
case|:
case|case
name|_DRM_SCATTER_GATHER
case|:
break|break;
case|case
name|_DRM_CONSISTENT
case|:
name|drm_pci_free
argument_list|(
name|dev
argument_list|,
name|map
operator|->
name|dmah
argument_list|)
expr_stmt|;
break|break;
default|default:
name|DRM_ERROR
argument_list|(
literal|"Bad map type %d\n"
argument_list|,
name|map
operator|->
name|type
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|map
operator|->
name|bsr
operator|!=
name|NULL
condition|)
block|{
name|bus_release_resource
argument_list|(
name|dev
operator|->
name|device
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|map
operator|->
name|rid
argument_list|,
name|map
operator|->
name|bsr
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|map
argument_list|,
name|DRM_MEM_MAPS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remove a map private from list and deallocate resources if the mapping  * isn't in use.  */
end_comment

begin_function
name|int
name|drm_rmmap_ioctl
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
name|drm_local_map_t
modifier|*
name|map
decl_stmt|;
name|struct
name|drm_map
modifier|*
name|request
init|=
name|data
decl_stmt|;
name|DRM_LOCK
argument_list|()
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|map
argument_list|,
argument|&dev->maplist
argument_list|,
argument|link
argument_list|)
block|{
if|if
condition|(
name|map
operator|->
name|handle
operator|==
name|request
operator|->
name|handle
operator|&&
name|map
operator|->
name|flags
operator|&
name|_DRM_REMOVABLE
condition|)
break|break;
block|}
comment|/* No match found. */
if|if
condition|(
name|map
operator|==
name|NULL
condition|)
block|{
name|DRM_UNLOCK
argument_list|()
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|drm_rmmap
argument_list|(
name|dev
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|DRM_UNLOCK
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|drm_cleanup_buf_error
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|drm_buf_entry_t
modifier|*
name|entry
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|entry
operator|->
name|seg_count
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|entry
operator|->
name|seg_count
condition|;
name|i
operator|++
control|)
block|{
name|drm_pci_free
argument_list|(
name|dev
argument_list|,
name|entry
operator|->
name|seglist
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|entry
operator|->
name|seglist
argument_list|,
name|DRM_MEM_SEGS
argument_list|)
expr_stmt|;
name|entry
operator|->
name|seg_count
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|entry
operator|->
name|buf_count
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|entry
operator|->
name|buf_count
condition|;
name|i
operator|++
control|)
block|{
name|free
argument_list|(
name|entry
operator|->
name|buflist
index|[
name|i
index|]
operator|.
name|dev_private
argument_list|,
name|DRM_MEM_BUFS
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|entry
operator|->
name|buflist
argument_list|,
name|DRM_MEM_BUFS
argument_list|)
expr_stmt|;
name|entry
operator|->
name|buf_count
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|drm_do_addbufs_agp
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_buf_desc
modifier|*
name|request
parameter_list|)
block|{
name|drm_device_dma_t
modifier|*
name|dma
init|=
name|dev
operator|->
name|dma
decl_stmt|;
name|drm_buf_entry_t
modifier|*
name|entry
decl_stmt|;
comment|/*drm_agp_mem_t *agp_entry; 	int valid*/
name|drm_buf_t
modifier|*
name|buf
decl_stmt|;
name|unsigned
name|long
name|offset
decl_stmt|;
name|unsigned
name|long
name|agp_offset
decl_stmt|;
name|int
name|count
decl_stmt|;
name|int
name|order
decl_stmt|;
name|int
name|size
decl_stmt|;
name|int
name|alignment
decl_stmt|;
name|int
name|page_order
decl_stmt|;
name|int
name|total
decl_stmt|;
name|int
name|byte_count
decl_stmt|;
name|int
name|i
decl_stmt|;
name|drm_buf_t
modifier|*
modifier|*
name|temp_buflist
decl_stmt|;
name|count
operator|=
name|request
operator|->
name|count
expr_stmt|;
name|order
operator|=
name|drm_order
argument_list|(
name|request
operator|->
name|size
argument_list|)
expr_stmt|;
name|size
operator|=
literal|1
operator|<<
name|order
expr_stmt|;
name|alignment
operator|=
operator|(
name|request
operator|->
name|flags
operator|&
name|_DRM_PAGE_ALIGN
operator|)
condition|?
name|round_page
argument_list|(
name|size
argument_list|)
else|:
name|size
expr_stmt|;
name|page_order
operator|=
name|order
operator|-
name|PAGE_SHIFT
operator|>
literal|0
condition|?
name|order
operator|-
name|PAGE_SHIFT
else|:
literal|0
expr_stmt|;
name|total
operator|=
name|PAGE_SIZE
operator|<<
name|page_order
expr_stmt|;
name|byte_count
operator|=
literal|0
expr_stmt|;
name|agp_offset
operator|=
name|dev
operator|->
name|agp
operator|->
name|base
operator|+
name|request
operator|->
name|agp_start
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"count:      %d\n"
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"order:      %d\n"
argument_list|,
name|order
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"size:       %d\n"
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"agp_offset: 0x%lx\n"
argument_list|,
name|agp_offset
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"alignment:  %d\n"
argument_list|,
name|alignment
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"page_order: %d\n"
argument_list|,
name|page_order
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"total:      %d\n"
argument_list|,
name|total
argument_list|)
expr_stmt|;
comment|/* Make sure buffers are located in AGP memory that we own */
comment|/* Breaks MGA due to drm_alloc_agp not setting up entries for the 	 * memory.  Safe to ignore for now because these ioctls are still 	 * root-only. 	 */
comment|/*valid = 0; 	for (agp_entry = dev->agp->memory; agp_entry; 	    agp_entry = agp_entry->next) { 		if ((agp_offset>= agp_entry->bound)&& 		    (agp_offset + total * count<= 		    agp_entry->bound + agp_entry->pages * PAGE_SIZE)) { 			valid = 1; 			break; 		} 	} 	if (!valid) { 		DRM_DEBUG("zone invalid\n"); 		return EINVAL; 	}*/
name|entry
operator|=
operator|&
name|dma
operator|->
name|bufs
index|[
name|order
index|]
expr_stmt|;
name|entry
operator|->
name|buflist
operator|=
name|malloc
argument_list|(
name|count
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|entry
operator|->
name|buflist
argument_list|)
argument_list|,
name|DRM_MEM_BUFS
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|entry
operator|->
name|buflist
condition|)
block|{
return|return
name|ENOMEM
return|;
block|}
name|entry
operator|->
name|buf_size
operator|=
name|size
expr_stmt|;
name|entry
operator|->
name|page_order
operator|=
name|page_order
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|entry
operator|->
name|buf_count
operator|<
name|count
condition|)
block|{
name|buf
operator|=
operator|&
name|entry
operator|->
name|buflist
index|[
name|entry
operator|->
name|buf_count
index|]
expr_stmt|;
name|buf
operator|->
name|idx
operator|=
name|dma
operator|->
name|buf_count
operator|+
name|entry
operator|->
name|buf_count
expr_stmt|;
name|buf
operator|->
name|total
operator|=
name|alignment
expr_stmt|;
name|buf
operator|->
name|order
operator|=
name|order
expr_stmt|;
name|buf
operator|->
name|used
operator|=
literal|0
expr_stmt|;
name|buf
operator|->
name|offset
operator|=
operator|(
name|dma
operator|->
name|byte_count
operator|+
name|offset
operator|)
expr_stmt|;
name|buf
operator|->
name|bus_address
operator|=
name|agp_offset
operator|+
name|offset
expr_stmt|;
name|buf
operator|->
name|address
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|agp_offset
operator|+
name|offset
operator|)
expr_stmt|;
name|buf
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|buf
operator|->
name|pending
operator|=
literal|0
expr_stmt|;
name|buf
operator|->
name|file_priv
operator|=
name|NULL
expr_stmt|;
name|buf
operator|->
name|dev_priv_size
operator|=
name|dev
operator|->
name|driver
operator|->
name|buf_priv_size
expr_stmt|;
name|buf
operator|->
name|dev_private
operator|=
name|malloc
argument_list|(
name|buf
operator|->
name|dev_priv_size
argument_list|,
name|DRM_MEM_BUFS
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|->
name|dev_private
operator|==
name|NULL
condition|)
block|{
comment|/* Set count correctly so we free the proper amount. */
name|entry
operator|->
name|buf_count
operator|=
name|count
expr_stmt|;
name|drm_cleanup_buf_error
argument_list|(
name|dev
argument_list|,
name|entry
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|offset
operator|+=
name|alignment
expr_stmt|;
name|entry
operator|->
name|buf_count
operator|++
expr_stmt|;
name|byte_count
operator|+=
name|PAGE_SIZE
operator|<<
name|page_order
expr_stmt|;
block|}
name|DRM_DEBUG
argument_list|(
literal|"byte_count: %d\n"
argument_list|,
name|byte_count
argument_list|)
expr_stmt|;
name|temp_buflist
operator|=
name|realloc
argument_list|(
name|dma
operator|->
name|buflist
argument_list|,
operator|(
name|dma
operator|->
name|buf_count
operator|+
name|entry
operator|->
name|buf_count
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|dma
operator|->
name|buflist
argument_list|)
argument_list|,
name|DRM_MEM_BUFS
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp_buflist
operator|==
name|NULL
condition|)
block|{
comment|/* Free the entry because it isn't valid */
name|drm_cleanup_buf_error
argument_list|(
name|dev
argument_list|,
name|entry
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|dma
operator|->
name|buflist
operator|=
name|temp_buflist
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|entry
operator|->
name|buf_count
condition|;
name|i
operator|++
control|)
block|{
name|dma
operator|->
name|buflist
index|[
name|i
operator|+
name|dma
operator|->
name|buf_count
index|]
operator|=
operator|&
name|entry
operator|->
name|buflist
index|[
name|i
index|]
expr_stmt|;
block|}
name|dma
operator|->
name|buf_count
operator|+=
name|entry
operator|->
name|buf_count
expr_stmt|;
name|dma
operator|->
name|byte_count
operator|+=
name|byte_count
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"dma->buf_count : %d\n"
argument_list|,
name|dma
operator|->
name|buf_count
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"entry->buf_count : %d\n"
argument_list|,
name|entry
operator|->
name|buf_count
argument_list|)
expr_stmt|;
name|request
operator|->
name|count
operator|=
name|entry
operator|->
name|buf_count
expr_stmt|;
name|request
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|dma
operator|->
name|flags
operator|=
name|_DRM_DMA_USE_AGP
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|drm_do_addbufs_pci
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_buf_desc
modifier|*
name|request
parameter_list|)
block|{
name|drm_device_dma_t
modifier|*
name|dma
init|=
name|dev
operator|->
name|dma
decl_stmt|;
name|int
name|count
decl_stmt|;
name|int
name|order
decl_stmt|;
name|int
name|size
decl_stmt|;
name|int
name|total
decl_stmt|;
name|int
name|page_order
decl_stmt|;
name|drm_buf_entry_t
modifier|*
name|entry
decl_stmt|;
name|drm_buf_t
modifier|*
name|buf
decl_stmt|;
name|int
name|alignment
decl_stmt|;
name|unsigned
name|long
name|offset
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|byte_count
decl_stmt|;
name|int
name|page_count
decl_stmt|;
name|unsigned
name|long
modifier|*
name|temp_pagelist
decl_stmt|;
name|drm_buf_t
modifier|*
modifier|*
name|temp_buflist
decl_stmt|;
name|count
operator|=
name|request
operator|->
name|count
expr_stmt|;
name|order
operator|=
name|drm_order
argument_list|(
name|request
operator|->
name|size
argument_list|)
expr_stmt|;
name|size
operator|=
literal|1
operator|<<
name|order
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"count=%d, size=%d (%d), order=%d\n"
argument_list|,
name|request
operator|->
name|count
argument_list|,
name|request
operator|->
name|size
argument_list|,
name|size
argument_list|,
name|order
argument_list|)
expr_stmt|;
name|alignment
operator|=
operator|(
name|request
operator|->
name|flags
operator|&
name|_DRM_PAGE_ALIGN
operator|)
condition|?
name|round_page
argument_list|(
name|size
argument_list|)
else|:
name|size
expr_stmt|;
name|page_order
operator|=
name|order
operator|-
name|PAGE_SHIFT
operator|>
literal|0
condition|?
name|order
operator|-
name|PAGE_SHIFT
else|:
literal|0
expr_stmt|;
name|total
operator|=
name|PAGE_SIZE
operator|<<
name|page_order
expr_stmt|;
name|entry
operator|=
operator|&
name|dma
operator|->
name|bufs
index|[
name|order
index|]
expr_stmt|;
name|entry
operator|->
name|buflist
operator|=
name|malloc
argument_list|(
name|count
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|entry
operator|->
name|buflist
argument_list|)
argument_list|,
name|DRM_MEM_BUFS
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|entry
operator|->
name|seglist
operator|=
name|malloc
argument_list|(
name|count
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|entry
operator|->
name|seglist
argument_list|)
argument_list|,
name|DRM_MEM_SEGS
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
comment|/* Keep the original pagelist until we know all the allocations 	 * have succeeded 	 */
name|temp_pagelist
operator|=
name|malloc
argument_list|(
operator|(
name|dma
operator|->
name|page_count
operator|+
operator|(
name|count
operator|<<
name|page_order
operator|)
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|dma
operator|->
name|pagelist
argument_list|)
argument_list|,
name|DRM_MEM_PAGES
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|buflist
operator|==
name|NULL
operator|||
name|entry
operator|->
name|seglist
operator|==
name|NULL
operator|||
name|temp_pagelist
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|temp_pagelist
argument_list|,
name|DRM_MEM_PAGES
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|entry
operator|->
name|seglist
argument_list|,
name|DRM_MEM_SEGS
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|entry
operator|->
name|buflist
argument_list|,
name|DRM_MEM_BUFS
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|memcpy
argument_list|(
name|temp_pagelist
argument_list|,
name|dma
operator|->
name|pagelist
argument_list|,
name|dma
operator|->
name|page_count
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|dma
operator|->
name|pagelist
argument_list|)
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"pagelist: %d entries\n"
argument_list|,
name|dma
operator|->
name|page_count
operator|+
operator|(
name|count
operator|<<
name|page_order
operator|)
argument_list|)
expr_stmt|;
name|entry
operator|->
name|buf_size
operator|=
name|size
expr_stmt|;
name|entry
operator|->
name|page_order
operator|=
name|page_order
expr_stmt|;
name|byte_count
operator|=
literal|0
expr_stmt|;
name|page_count
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|entry
operator|->
name|buf_count
operator|<
name|count
condition|)
block|{
name|DRM_SPINUNLOCK
argument_list|(
operator|&
name|dev
operator|->
name|dma_lock
argument_list|)
expr_stmt|;
name|drm_dma_handle_t
modifier|*
name|dmah
init|=
name|drm_pci_alloc
argument_list|(
name|dev
argument_list|,
name|size
argument_list|,
name|alignment
argument_list|,
literal|0xfffffffful
argument_list|)
decl_stmt|;
name|DRM_SPINLOCK
argument_list|(
operator|&
name|dev
operator|->
name|dma_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|dmah
operator|==
name|NULL
condition|)
block|{
comment|/* Set count correctly so we free the proper amount. */
name|entry
operator|->
name|buf_count
operator|=
name|count
expr_stmt|;
name|entry
operator|->
name|seg_count
operator|=
name|count
expr_stmt|;
name|drm_cleanup_buf_error
argument_list|(
name|dev
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp_pagelist
argument_list|,
name|DRM_MEM_PAGES
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|entry
operator|->
name|seglist
index|[
name|entry
operator|->
name|seg_count
operator|++
index|]
operator|=
name|dmah
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
literal|1
operator|<<
name|page_order
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|DRM_DEBUG
argument_list|(
literal|"page %d @ %p\n"
argument_list|,
name|dma
operator|->
name|page_count
operator|+
name|page_count
argument_list|,
operator|(
name|char
operator|*
operator|)
name|dmah
operator|->
name|vaddr
operator|+
name|PAGE_SIZE
operator|*
name|i
argument_list|)
expr_stmt|;
name|temp_pagelist
index|[
name|dma
operator|->
name|page_count
operator|+
name|page_count
operator|++
index|]
operator|=
operator|(
name|long
operator|)
name|dmah
operator|->
name|vaddr
operator|+
name|PAGE_SIZE
operator|*
name|i
expr_stmt|;
block|}
for|for
control|(
name|offset
operator|=
literal|0
init|;
name|offset
operator|+
name|size
operator|<=
name|total
operator|&&
name|entry
operator|->
name|buf_count
operator|<
name|count
condition|;
name|offset
operator|+=
name|alignment
operator|,
operator|++
name|entry
operator|->
name|buf_count
control|)
block|{
name|buf
operator|=
operator|&
name|entry
operator|->
name|buflist
index|[
name|entry
operator|->
name|buf_count
index|]
expr_stmt|;
name|buf
operator|->
name|idx
operator|=
name|dma
operator|->
name|buf_count
operator|+
name|entry
operator|->
name|buf_count
expr_stmt|;
name|buf
operator|->
name|total
operator|=
name|alignment
expr_stmt|;
name|buf
operator|->
name|order
operator|=
name|order
expr_stmt|;
name|buf
operator|->
name|used
operator|=
literal|0
expr_stmt|;
name|buf
operator|->
name|offset
operator|=
operator|(
name|dma
operator|->
name|byte_count
operator|+
name|byte_count
operator|+
name|offset
operator|)
expr_stmt|;
name|buf
operator|->
name|address
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|dmah
operator|->
name|vaddr
operator|+
name|offset
operator|)
expr_stmt|;
name|buf
operator|->
name|bus_address
operator|=
name|dmah
operator|->
name|busaddr
operator|+
name|offset
expr_stmt|;
name|buf
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|buf
operator|->
name|pending
operator|=
literal|0
expr_stmt|;
name|buf
operator|->
name|file_priv
operator|=
name|NULL
expr_stmt|;
name|buf
operator|->
name|dev_priv_size
operator|=
name|dev
operator|->
name|driver
operator|->
name|buf_priv_size
expr_stmt|;
name|buf
operator|->
name|dev_private
operator|=
name|malloc
argument_list|(
name|buf
operator|->
name|dev_priv_size
argument_list|,
name|DRM_MEM_BUFS
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|->
name|dev_private
operator|==
name|NULL
condition|)
block|{
comment|/* Set count correctly so we free the proper amount. */
name|entry
operator|->
name|buf_count
operator|=
name|count
expr_stmt|;
name|entry
operator|->
name|seg_count
operator|=
name|count
expr_stmt|;
name|drm_cleanup_buf_error
argument_list|(
name|dev
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp_pagelist
argument_list|,
name|DRM_MEM_PAGES
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|DRM_DEBUG
argument_list|(
literal|"buffer %d @ %p\n"
argument_list|,
name|entry
operator|->
name|buf_count
argument_list|,
name|buf
operator|->
name|address
argument_list|)
expr_stmt|;
block|}
name|byte_count
operator|+=
name|PAGE_SIZE
operator|<<
name|page_order
expr_stmt|;
block|}
name|temp_buflist
operator|=
name|realloc
argument_list|(
name|dma
operator|->
name|buflist
argument_list|,
operator|(
name|dma
operator|->
name|buf_count
operator|+
name|entry
operator|->
name|buf_count
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|dma
operator|->
name|buflist
argument_list|)
argument_list|,
name|DRM_MEM_BUFS
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp_buflist
operator|==
name|NULL
condition|)
block|{
comment|/* Free the entry because it isn't valid */
name|drm_cleanup_buf_error
argument_list|(
name|dev
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp_pagelist
argument_list|,
name|DRM_MEM_PAGES
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|dma
operator|->
name|buflist
operator|=
name|temp_buflist
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|entry
operator|->
name|buf_count
condition|;
name|i
operator|++
control|)
block|{
name|dma
operator|->
name|buflist
index|[
name|i
operator|+
name|dma
operator|->
name|buf_count
index|]
operator|=
operator|&
name|entry
operator|->
name|buflist
index|[
name|i
index|]
expr_stmt|;
block|}
comment|/* No allocations failed, so now we can replace the orginal pagelist 	 * with the new one. 	 */
name|free
argument_list|(
name|dma
operator|->
name|pagelist
argument_list|,
name|DRM_MEM_PAGES
argument_list|)
expr_stmt|;
name|dma
operator|->
name|pagelist
operator|=
name|temp_pagelist
expr_stmt|;
name|dma
operator|->
name|buf_count
operator|+=
name|entry
operator|->
name|buf_count
expr_stmt|;
name|dma
operator|->
name|seg_count
operator|+=
name|entry
operator|->
name|seg_count
expr_stmt|;
name|dma
operator|->
name|page_count
operator|+=
name|entry
operator|->
name|seg_count
operator|<<
name|page_order
expr_stmt|;
name|dma
operator|->
name|byte_count
operator|+=
name|PAGE_SIZE
operator|*
operator|(
name|entry
operator|->
name|seg_count
operator|<<
name|page_order
operator|)
expr_stmt|;
name|request
operator|->
name|count
operator|=
name|entry
operator|->
name|buf_count
expr_stmt|;
name|request
operator|->
name|size
operator|=
name|size
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|drm_do_addbufs_sg
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_buf_desc
modifier|*
name|request
parameter_list|)
block|{
name|drm_device_dma_t
modifier|*
name|dma
init|=
name|dev
operator|->
name|dma
decl_stmt|;
name|drm_buf_entry_t
modifier|*
name|entry
decl_stmt|;
name|drm_buf_t
modifier|*
name|buf
decl_stmt|;
name|unsigned
name|long
name|offset
decl_stmt|;
name|unsigned
name|long
name|agp_offset
decl_stmt|;
name|int
name|count
decl_stmt|;
name|int
name|order
decl_stmt|;
name|int
name|size
decl_stmt|;
name|int
name|alignment
decl_stmt|;
name|int
name|page_order
decl_stmt|;
name|int
name|total
decl_stmt|;
name|int
name|byte_count
decl_stmt|;
name|int
name|i
decl_stmt|;
name|drm_buf_t
modifier|*
modifier|*
name|temp_buflist
decl_stmt|;
name|count
operator|=
name|request
operator|->
name|count
expr_stmt|;
name|order
operator|=
name|drm_order
argument_list|(
name|request
operator|->
name|size
argument_list|)
expr_stmt|;
name|size
operator|=
literal|1
operator|<<
name|order
expr_stmt|;
name|alignment
operator|=
operator|(
name|request
operator|->
name|flags
operator|&
name|_DRM_PAGE_ALIGN
operator|)
condition|?
name|round_page
argument_list|(
name|size
argument_list|)
else|:
name|size
expr_stmt|;
name|page_order
operator|=
name|order
operator|-
name|PAGE_SHIFT
operator|>
literal|0
condition|?
name|order
operator|-
name|PAGE_SHIFT
else|:
literal|0
expr_stmt|;
name|total
operator|=
name|PAGE_SIZE
operator|<<
name|page_order
expr_stmt|;
name|byte_count
operator|=
literal|0
expr_stmt|;
name|agp_offset
operator|=
name|request
operator|->
name|agp_start
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"count:      %d\n"
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"order:      %d\n"
argument_list|,
name|order
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"size:       %d\n"
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"agp_offset: %ld\n"
argument_list|,
name|agp_offset
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"alignment:  %d\n"
argument_list|,
name|alignment
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"page_order: %d\n"
argument_list|,
name|page_order
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"total:      %d\n"
argument_list|,
name|total
argument_list|)
expr_stmt|;
name|entry
operator|=
operator|&
name|dma
operator|->
name|bufs
index|[
name|order
index|]
expr_stmt|;
name|entry
operator|->
name|buflist
operator|=
name|malloc
argument_list|(
name|count
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|entry
operator|->
name|buflist
argument_list|)
argument_list|,
name|DRM_MEM_BUFS
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|buflist
operator|==
name|NULL
condition|)
return|return
name|ENOMEM
return|;
name|entry
operator|->
name|buf_size
operator|=
name|size
expr_stmt|;
name|entry
operator|->
name|page_order
operator|=
name|page_order
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|entry
operator|->
name|buf_count
operator|<
name|count
condition|)
block|{
name|buf
operator|=
operator|&
name|entry
operator|->
name|buflist
index|[
name|entry
operator|->
name|buf_count
index|]
expr_stmt|;
name|buf
operator|->
name|idx
operator|=
name|dma
operator|->
name|buf_count
operator|+
name|entry
operator|->
name|buf_count
expr_stmt|;
name|buf
operator|->
name|total
operator|=
name|alignment
expr_stmt|;
name|buf
operator|->
name|order
operator|=
name|order
expr_stmt|;
name|buf
operator|->
name|used
operator|=
literal|0
expr_stmt|;
name|buf
operator|->
name|offset
operator|=
operator|(
name|dma
operator|->
name|byte_count
operator|+
name|offset
operator|)
expr_stmt|;
name|buf
operator|->
name|bus_address
operator|=
name|agp_offset
operator|+
name|offset
expr_stmt|;
name|buf
operator|->
name|address
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|agp_offset
operator|+
name|offset
operator|+
name|dev
operator|->
name|sg
operator|->
name|handle
operator|)
expr_stmt|;
name|buf
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|buf
operator|->
name|pending
operator|=
literal|0
expr_stmt|;
name|buf
operator|->
name|file_priv
operator|=
name|NULL
expr_stmt|;
name|buf
operator|->
name|dev_priv_size
operator|=
name|dev
operator|->
name|driver
operator|->
name|buf_priv_size
expr_stmt|;
name|buf
operator|->
name|dev_private
operator|=
name|malloc
argument_list|(
name|buf
operator|->
name|dev_priv_size
argument_list|,
name|DRM_MEM_BUFS
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|->
name|dev_private
operator|==
name|NULL
condition|)
block|{
comment|/* Set count correctly so we free the proper amount. */
name|entry
operator|->
name|buf_count
operator|=
name|count
expr_stmt|;
name|drm_cleanup_buf_error
argument_list|(
name|dev
argument_list|,
name|entry
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|DRM_DEBUG
argument_list|(
literal|"buffer %d @ %p\n"
argument_list|,
name|entry
operator|->
name|buf_count
argument_list|,
name|buf
operator|->
name|address
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|alignment
expr_stmt|;
name|entry
operator|->
name|buf_count
operator|++
expr_stmt|;
name|byte_count
operator|+=
name|PAGE_SIZE
operator|<<
name|page_order
expr_stmt|;
block|}
name|DRM_DEBUG
argument_list|(
literal|"byte_count: %d\n"
argument_list|,
name|byte_count
argument_list|)
expr_stmt|;
name|temp_buflist
operator|=
name|realloc
argument_list|(
name|dma
operator|->
name|buflist
argument_list|,
operator|(
name|dma
operator|->
name|buf_count
operator|+
name|entry
operator|->
name|buf_count
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|dma
operator|->
name|buflist
argument_list|)
argument_list|,
name|DRM_MEM_BUFS
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp_buflist
operator|==
name|NULL
condition|)
block|{
comment|/* Free the entry because it isn't valid */
name|drm_cleanup_buf_error
argument_list|(
name|dev
argument_list|,
name|entry
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|dma
operator|->
name|buflist
operator|=
name|temp_buflist
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|entry
operator|->
name|buf_count
condition|;
name|i
operator|++
control|)
block|{
name|dma
operator|->
name|buflist
index|[
name|i
operator|+
name|dma
operator|->
name|buf_count
index|]
operator|=
operator|&
name|entry
operator|->
name|buflist
index|[
name|i
index|]
expr_stmt|;
block|}
name|dma
operator|->
name|buf_count
operator|+=
name|entry
operator|->
name|buf_count
expr_stmt|;
name|dma
operator|->
name|byte_count
operator|+=
name|byte_count
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"dma->buf_count : %d\n"
argument_list|,
name|dma
operator|->
name|buf_count
argument_list|)
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"entry->buf_count : %d\n"
argument_list|,
name|entry
operator|->
name|buf_count
argument_list|)
expr_stmt|;
name|request
operator|->
name|count
operator|=
name|entry
operator|->
name|buf_count
expr_stmt|;
name|request
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|dma
operator|->
name|flags
operator|=
name|_DRM_DMA_USE_SG
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|drm_addbufs_agp
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_buf_desc
modifier|*
name|request
parameter_list|)
block|{
name|int
name|order
decl_stmt|,
name|ret
decl_stmt|;
if|if
condition|(
name|request
operator|->
name|count
operator|<
literal|0
operator|||
name|request
operator|->
name|count
operator|>
literal|4096
condition|)
return|return
name|EINVAL
return|;
name|order
operator|=
name|drm_order
argument_list|(
name|request
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|order
operator|<
name|DRM_MIN_ORDER
operator|||
name|order
operator|>
name|DRM_MAX_ORDER
condition|)
return|return
name|EINVAL
return|;
name|DRM_SPINLOCK
argument_list|(
operator|&
name|dev
operator|->
name|dma_lock
argument_list|)
expr_stmt|;
comment|/* No more allocations after first buffer-using ioctl. */
if|if
condition|(
name|dev
operator|->
name|buf_use
operator|!=
literal|0
condition|)
block|{
name|DRM_SPINUNLOCK
argument_list|(
operator|&
name|dev
operator|->
name|dma_lock
argument_list|)
expr_stmt|;
return|return
name|EBUSY
return|;
block|}
comment|/* No more than one allocation per order */
if|if
condition|(
name|dev
operator|->
name|dma
operator|->
name|bufs
index|[
name|order
index|]
operator|.
name|buf_count
operator|!=
literal|0
condition|)
block|{
name|DRM_SPINUNLOCK
argument_list|(
operator|&
name|dev
operator|->
name|dma_lock
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|ret
operator|=
name|drm_do_addbufs_agp
argument_list|(
name|dev
argument_list|,
name|request
argument_list|)
expr_stmt|;
name|DRM_SPINUNLOCK
argument_list|(
operator|&
name|dev
operator|->
name|dma_lock
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|drm_addbufs_sg
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_buf_desc
modifier|*
name|request
parameter_list|)
block|{
name|int
name|order
decl_stmt|,
name|ret
decl_stmt|;
if|if
condition|(
operator|!
name|DRM_SUSER
argument_list|(
name|DRM_CURPROC
argument_list|)
condition|)
return|return
name|EACCES
return|;
if|if
condition|(
name|request
operator|->
name|count
operator|<
literal|0
operator|||
name|request
operator|->
name|count
operator|>
literal|4096
condition|)
return|return
name|EINVAL
return|;
name|order
operator|=
name|drm_order
argument_list|(
name|request
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|order
operator|<
name|DRM_MIN_ORDER
operator|||
name|order
operator|>
name|DRM_MAX_ORDER
condition|)
return|return
name|EINVAL
return|;
name|DRM_SPINLOCK
argument_list|(
operator|&
name|dev
operator|->
name|dma_lock
argument_list|)
expr_stmt|;
comment|/* No more allocations after first buffer-using ioctl. */
if|if
condition|(
name|dev
operator|->
name|buf_use
operator|!=
literal|0
condition|)
block|{
name|DRM_SPINUNLOCK
argument_list|(
operator|&
name|dev
operator|->
name|dma_lock
argument_list|)
expr_stmt|;
return|return
name|EBUSY
return|;
block|}
comment|/* No more than one allocation per order */
if|if
condition|(
name|dev
operator|->
name|dma
operator|->
name|bufs
index|[
name|order
index|]
operator|.
name|buf_count
operator|!=
literal|0
condition|)
block|{
name|DRM_SPINUNLOCK
argument_list|(
operator|&
name|dev
operator|->
name|dma_lock
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|ret
operator|=
name|drm_do_addbufs_sg
argument_list|(
name|dev
argument_list|,
name|request
argument_list|)
expr_stmt|;
name|DRM_SPINUNLOCK
argument_list|(
operator|&
name|dev
operator|->
name|dma_lock
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|drm_addbufs_pci
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_buf_desc
modifier|*
name|request
parameter_list|)
block|{
name|int
name|order
decl_stmt|,
name|ret
decl_stmt|;
if|if
condition|(
operator|!
name|DRM_SUSER
argument_list|(
name|DRM_CURPROC
argument_list|)
condition|)
return|return
name|EACCES
return|;
if|if
condition|(
name|request
operator|->
name|count
operator|<
literal|0
operator|||
name|request
operator|->
name|count
operator|>
literal|4096
condition|)
return|return
name|EINVAL
return|;
name|order
operator|=
name|drm_order
argument_list|(
name|request
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|order
operator|<
name|DRM_MIN_ORDER
operator|||
name|order
operator|>
name|DRM_MAX_ORDER
condition|)
return|return
name|EINVAL
return|;
name|DRM_SPINLOCK
argument_list|(
operator|&
name|dev
operator|->
name|dma_lock
argument_list|)
expr_stmt|;
comment|/* No more allocations after first buffer-using ioctl. */
if|if
condition|(
name|dev
operator|->
name|buf_use
operator|!=
literal|0
condition|)
block|{
name|DRM_SPINUNLOCK
argument_list|(
operator|&
name|dev
operator|->
name|dma_lock
argument_list|)
expr_stmt|;
return|return
name|EBUSY
return|;
block|}
comment|/* No more than one allocation per order */
if|if
condition|(
name|dev
operator|->
name|dma
operator|->
name|bufs
index|[
name|order
index|]
operator|.
name|buf_count
operator|!=
literal|0
condition|)
block|{
name|DRM_SPINUNLOCK
argument_list|(
operator|&
name|dev
operator|->
name|dma_lock
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|ret
operator|=
name|drm_do_addbufs_pci
argument_list|(
name|dev
argument_list|,
name|request
argument_list|)
expr_stmt|;
name|DRM_SPINUNLOCK
argument_list|(
operator|&
name|dev
operator|->
name|dma_lock
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|drm_addbufs
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
name|struct
name|drm_buf_desc
modifier|*
name|request
init|=
name|data
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
name|request
operator|->
name|flags
operator|&
name|_DRM_AGP_BUFFER
condition|)
name|err
operator|=
name|drm_addbufs_agp
argument_list|(
name|dev
argument_list|,
name|request
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|request
operator|->
name|flags
operator|&
name|_DRM_SG_BUFFER
condition|)
name|err
operator|=
name|drm_addbufs_sg
argument_list|(
name|dev
argument_list|,
name|request
argument_list|)
expr_stmt|;
else|else
name|err
operator|=
name|drm_addbufs_pci
argument_list|(
name|dev
argument_list|,
name|request
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|int
name|drm_infobufs
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
name|drm_device_dma_t
modifier|*
name|dma
init|=
name|dev
operator|->
name|dma
decl_stmt|;
name|struct
name|drm_buf_info
modifier|*
name|request
init|=
name|data
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|count
decl_stmt|;
name|int
name|retcode
init|=
literal|0
decl_stmt|;
name|DRM_SPINLOCK
argument_list|(
operator|&
name|dev
operator|->
name|dma_lock
argument_list|)
expr_stmt|;
operator|++
name|dev
operator|->
name|buf_use
expr_stmt|;
comment|/* Can't allocate more after this call */
name|DRM_SPINUNLOCK
argument_list|(
operator|&
name|dev
operator|->
name|dma_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|count
operator|=
literal|0
init|;
name|i
operator|<
name|DRM_MAX_ORDER
operator|+
literal|1
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dma
operator|->
name|bufs
index|[
name|i
index|]
operator|.
name|buf_count
condition|)
operator|++
name|count
expr_stmt|;
block|}
name|DRM_DEBUG
argument_list|(
literal|"count = %d\n"
argument_list|,
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|request
operator|->
name|count
operator|>=
name|count
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|count
operator|=
literal|0
init|;
name|i
operator|<
name|DRM_MAX_ORDER
operator|+
literal|1
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dma
operator|->
name|bufs
index|[
name|i
index|]
operator|.
name|buf_count
condition|)
block|{
name|struct
name|drm_buf_desc
name|from
decl_stmt|;
name|from
operator|.
name|count
operator|=
name|dma
operator|->
name|bufs
index|[
name|i
index|]
operator|.
name|buf_count
expr_stmt|;
name|from
operator|.
name|size
operator|=
name|dma
operator|->
name|bufs
index|[
name|i
index|]
operator|.
name|buf_size
expr_stmt|;
name|from
operator|.
name|low_mark
operator|=
name|dma
operator|->
name|bufs
index|[
name|i
index|]
operator|.
name|freelist
operator|.
name|low_mark
expr_stmt|;
name|from
operator|.
name|high_mark
operator|=
name|dma
operator|->
name|bufs
index|[
name|i
index|]
operator|.
name|freelist
operator|.
name|high_mark
expr_stmt|;
if|if
condition|(
name|DRM_COPY_TO_USER
argument_list|(
operator|&
name|request
operator|->
name|list
index|[
name|count
index|]
argument_list|,
operator|&
name|from
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|drm_buf_desc
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|retcode
operator|=
name|EFAULT
expr_stmt|;
break|break;
block|}
name|DRM_DEBUG
argument_list|(
literal|"%d %d %d %d %d\n"
argument_list|,
name|i
argument_list|,
name|dma
operator|->
name|bufs
index|[
name|i
index|]
operator|.
name|buf_count
argument_list|,
name|dma
operator|->
name|bufs
index|[
name|i
index|]
operator|.
name|buf_size
argument_list|,
name|dma
operator|->
name|bufs
index|[
name|i
index|]
operator|.
name|freelist
operator|.
name|low_mark
argument_list|,
name|dma
operator|->
name|bufs
index|[
name|i
index|]
operator|.
name|freelist
operator|.
name|high_mark
argument_list|)
expr_stmt|;
operator|++
name|count
expr_stmt|;
block|}
block|}
block|}
name|request
operator|->
name|count
operator|=
name|count
expr_stmt|;
return|return
name|retcode
return|;
block|}
end_function

begin_function
name|int
name|drm_markbufs
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
name|drm_device_dma_t
modifier|*
name|dma
init|=
name|dev
operator|->
name|dma
decl_stmt|;
name|struct
name|drm_buf_desc
modifier|*
name|request
init|=
name|data
decl_stmt|;
name|int
name|order
decl_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"%d, %d, %d\n"
argument_list|,
name|request
operator|->
name|size
argument_list|,
name|request
operator|->
name|low_mark
argument_list|,
name|request
operator|->
name|high_mark
argument_list|)
expr_stmt|;
name|order
operator|=
name|drm_order
argument_list|(
name|request
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|order
operator|<
name|DRM_MIN_ORDER
operator|||
name|order
operator|>
name|DRM_MAX_ORDER
operator|||
name|request
operator|->
name|low_mark
operator|<
literal|0
operator|||
name|request
operator|->
name|high_mark
operator|<
literal|0
condition|)
block|{
return|return
name|EINVAL
return|;
block|}
name|DRM_SPINLOCK
argument_list|(
operator|&
name|dev
operator|->
name|dma_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|request
operator|->
name|low_mark
operator|>
name|dma
operator|->
name|bufs
index|[
name|order
index|]
operator|.
name|buf_count
operator|||
name|request
operator|->
name|high_mark
operator|>
name|dma
operator|->
name|bufs
index|[
name|order
index|]
operator|.
name|buf_count
condition|)
block|{
name|DRM_SPINUNLOCK
argument_list|(
operator|&
name|dev
operator|->
name|dma_lock
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|dma
operator|->
name|bufs
index|[
name|order
index|]
operator|.
name|freelist
operator|.
name|low_mark
operator|=
name|request
operator|->
name|low_mark
expr_stmt|;
name|dma
operator|->
name|bufs
index|[
name|order
index|]
operator|.
name|freelist
operator|.
name|high_mark
operator|=
name|request
operator|->
name|high_mark
expr_stmt|;
name|DRM_SPINUNLOCK
argument_list|(
operator|&
name|dev
operator|->
name|dma_lock
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|drm_freebufs
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
name|drm_device_dma_t
modifier|*
name|dma
init|=
name|dev
operator|->
name|dma
decl_stmt|;
name|struct
name|drm_buf_free
modifier|*
name|request
init|=
name|data
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|idx
decl_stmt|;
name|drm_buf_t
modifier|*
name|buf
decl_stmt|;
name|int
name|retcode
init|=
literal|0
decl_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"%d\n"
argument_list|,
name|request
operator|->
name|count
argument_list|)
expr_stmt|;
name|DRM_SPINLOCK
argument_list|(
operator|&
name|dev
operator|->
name|dma_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|request
operator|->
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|DRM_COPY_FROM_USER
argument_list|(
operator|&
name|idx
argument_list|,
operator|&
name|request
operator|->
name|list
index|[
name|i
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|idx
argument_list|)
argument_list|)
condition|)
block|{
name|retcode
operator|=
name|EFAULT
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|idx
operator|<
literal|0
operator|||
name|idx
operator|>=
name|dma
operator|->
name|buf_count
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Index %d (of %d max)\n"
argument_list|,
name|idx
argument_list|,
name|dma
operator|->
name|buf_count
operator|-
literal|1
argument_list|)
expr_stmt|;
name|retcode
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|buf
operator|=
name|dma
operator|->
name|buflist
index|[
name|idx
index|]
expr_stmt|;
if|if
condition|(
name|buf
operator|->
name|file_priv
operator|!=
name|file_priv
condition|)
block|{
name|DRM_ERROR
argument_list|(
literal|"Process %d freeing buffer not owned\n"
argument_list|,
name|DRM_CURRENTPID
argument_list|)
expr_stmt|;
name|retcode
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|drm_free_buffer
argument_list|(
name|dev
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
name|DRM_SPINUNLOCK
argument_list|(
operator|&
name|dev
operator|->
name|dma_lock
argument_list|)
expr_stmt|;
return|return
name|retcode
return|;
block|}
end_function

begin_function
name|int
name|drm_mapbufs
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|drm_file
modifier|*
name|file_priv
parameter_list|)
block|{
name|drm_device_dma_t
modifier|*
name|dma
init|=
name|dev
operator|->
name|dma
decl_stmt|;
name|int
name|retcode
init|=
literal|0
decl_stmt|;
specifier|const
name|int
name|zero
init|=
literal|0
decl_stmt|;
name|vm_offset_t
name|address
decl_stmt|;
name|struct
name|vmspace
modifier|*
name|vms
decl_stmt|;
name|vm_ooffset_t
name|foff
decl_stmt|;
name|vm_size_t
name|size
decl_stmt|;
name|vm_offset_t
name|vaddr
decl_stmt|;
name|struct
name|drm_buf_map
modifier|*
name|request
init|=
name|data
decl_stmt|;
name|int
name|i
decl_stmt|;
name|vms
operator|=
name|DRM_CURPROC
operator|->
name|td_proc
operator|->
name|p_vmspace
expr_stmt|;
name|DRM_SPINLOCK
argument_list|(
operator|&
name|dev
operator|->
name|dma_lock
argument_list|)
expr_stmt|;
name|dev
operator|->
name|buf_use
operator|++
expr_stmt|;
comment|/* Can't allocate more after this call */
name|DRM_SPINUNLOCK
argument_list|(
operator|&
name|dev
operator|->
name|dma_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|request
operator|->
name|count
operator|<
name|dma
operator|->
name|buf_count
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
operator|(
name|drm_core_has_AGP
argument_list|(
name|dev
argument_list|)
operator|&&
operator|(
name|dma
operator|->
name|flags
operator|&
name|_DRM_DMA_USE_AGP
operator|)
operator|)
operator|||
operator|(
name|drm_core_check_feature
argument_list|(
name|dev
argument_list|,
name|DRIVER_SG
argument_list|)
operator|&&
operator|(
name|dma
operator|->
name|flags
operator|&
name|_DRM_DMA_USE_SG
operator|)
operator|)
condition|)
block|{
name|drm_local_map_t
modifier|*
name|map
init|=
name|dev
operator|->
name|agp_buffer_map
decl_stmt|;
if|if
condition|(
name|map
operator|==
name|NULL
condition|)
block|{
name|retcode
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|size
operator|=
name|round_page
argument_list|(
name|map
operator|->
name|size
argument_list|)
expr_stmt|;
name|foff
operator|=
name|map
operator|->
name|offset
expr_stmt|;
block|}
else|else
block|{
name|size
operator|=
name|round_page
argument_list|(
name|dma
operator|->
name|byte_count
argument_list|)
operator|,
name|foff
operator|=
literal|0
expr_stmt|;
block|}
name|vaddr
operator|=
name|round_page
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|vms
operator|->
name|vm_daddr
operator|+
name|MAXDSIZ
argument_list|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|600023
name|retcode
operator|=
name|vm_mmap
argument_list|(
operator|&
name|vms
operator|->
name|vm_map
argument_list|,
operator|&
name|vaddr
argument_list|,
name|size
argument_list|,
name|PROT_READ
operator||
name|PROT_WRITE
argument_list|,
name|VM_PROT_ALL
argument_list|,
name|MAP_SHARED
operator||
name|MAP_NOSYNC
argument_list|,
name|OBJT_DEVICE
argument_list|,
name|dev
operator|->
name|devnode
argument_list|,
name|foff
argument_list|)
expr_stmt|;
else|#
directive|else
name|retcode
operator|=
name|vm_mmap
argument_list|(
operator|&
name|vms
operator|->
name|vm_map
argument_list|,
operator|&
name|vaddr
argument_list|,
name|size
argument_list|,
name|PROT_READ
operator||
name|PROT_WRITE
argument_list|,
name|VM_PROT_ALL
argument_list|,
name|MAP_SHARED
operator||
name|MAP_NOSYNC
argument_list|,
name|SLIST_FIRST
argument_list|(
operator|&
name|dev
operator|->
name|devnode
operator|->
name|si_hlist
argument_list|)
argument_list|,
name|foff
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|retcode
condition|)
goto|goto
name|done
goto|;
name|request
operator|->
name|virtual
operator|=
operator|(
name|void
operator|*
operator|)
name|vaddr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dma
operator|->
name|buf_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|DRM_COPY_TO_USER
argument_list|(
operator|&
name|request
operator|->
name|list
index|[
name|i
index|]
operator|.
name|idx
argument_list|,
operator|&
name|dma
operator|->
name|buflist
index|[
name|i
index|]
operator|->
name|idx
argument_list|,
sizeof|sizeof
argument_list|(
name|request
operator|->
name|list
index|[
literal|0
index|]
operator|.
name|idx
argument_list|)
argument_list|)
condition|)
block|{
name|retcode
operator|=
name|EFAULT
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|DRM_COPY_TO_USER
argument_list|(
operator|&
name|request
operator|->
name|list
index|[
name|i
index|]
operator|.
name|total
argument_list|,
operator|&
name|dma
operator|->
name|buflist
index|[
name|i
index|]
operator|->
name|total
argument_list|,
sizeof|sizeof
argument_list|(
name|request
operator|->
name|list
index|[
literal|0
index|]
operator|.
name|total
argument_list|)
argument_list|)
condition|)
block|{
name|retcode
operator|=
name|EFAULT
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|DRM_COPY_TO_USER
argument_list|(
operator|&
name|request
operator|->
name|list
index|[
name|i
index|]
operator|.
name|used
argument_list|,
operator|&
name|zero
argument_list|,
sizeof|sizeof
argument_list|(
name|zero
argument_list|)
argument_list|)
condition|)
block|{
name|retcode
operator|=
name|EFAULT
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|address
operator|=
name|vaddr
operator|+
name|dma
operator|->
name|buflist
index|[
name|i
index|]
operator|->
name|offset
expr_stmt|;
comment|/* *** */
if|if
condition|(
name|DRM_COPY_TO_USER
argument_list|(
operator|&
name|request
operator|->
name|list
index|[
name|i
index|]
operator|.
name|address
argument_list|,
operator|&
name|address
argument_list|,
sizeof|sizeof
argument_list|(
name|address
argument_list|)
argument_list|)
condition|)
block|{
name|retcode
operator|=
name|EFAULT
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
name|done
label|:
name|request
operator|->
name|count
operator|=
name|dma
operator|->
name|buf_count
expr_stmt|;
name|DRM_DEBUG
argument_list|(
literal|"%d buffers, retcode = %d\n"
argument_list|,
name|request
operator|->
name|count
argument_list|,
name|retcode
argument_list|)
expr_stmt|;
return|return
name|retcode
return|;
block|}
end_function

begin_comment
comment|/*  * Compute order.  Can be made faster.  */
end_comment

begin_function
name|int
name|drm_order
parameter_list|(
name|unsigned
name|long
name|size
parameter_list|)
block|{
name|int
name|order
decl_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|order
operator|=
name|flsl
argument_list|(
name|size
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|size
operator|&
operator|~
operator|(
literal|1ul
operator|<<
name|order
operator|)
condition|)
operator|++
name|order
expr_stmt|;
return|return
name|order
return|;
block|}
end_function

end_unit

