begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2002, 2003 Christian Bucari, Prosum   * Copyright (c) 2002, 2003 Xavier Heiny, Vincent Jardin, 6WIND  * Copyright (c) 2000, 2001 Richard Hodges and Matriplex, inc.  * Copyright (c) 1996, 1997, 1998, 1999 Mark Tinguely  *  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *	notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *	notice, this list of conditions and the following disclaimer in the  *	documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *	must display the following acknowledgement:  *	This product includes software developed by Prosum, 6wind and   *  Matriplex, inc  * 4. The name of the authors may not be used to endorse or promote products   *	derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,  * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  *  ******************************************************************************  *  *  This driver supports the PROATM-155 and PROATM-25 cards based on the IDT77252.  *  *  UBR, CBR and VBR connections are supported    *  *  You must have FreeBSD 3.5, 4.1 or later.  *  * in sys/i386/conf/YOUR_NAME add:  *	options		ATM_CORE	#core ATM protocol family  *	options		ATM_IP		#IP over ATM support  *  at least one (and usually one of the following:  *	options		ATM_SIGPVC	#SIGPVC signalling manager  *	options		ATM_SPANS	#SPANS signalling manager  *	options		ATM_UNI		#UNI signalling manager  *  and the device driver:  *	device		proatm      #PROATM device driver (this file)  *  * Add the following line to /usr/src/sys/conf/files:  *   pci/proatm.c  optional proatm pci  *  ******************************************************************************  *  *  The following sysctl variables are used:  *  * hw.proatm.log_bufstat  (0)   Log free buffers (every few minutes)  * hw.proatm.log_vcs      (0)   Log VC opens, closes, and other events  * hw.proatm.bufs_large  (500)  Max/target number of free 2k buffers  * hw.proatm.bufs_small  (500)  Max/target number of free mbufs  * hw.proatm.cur_large   (R/O)  Current number of free 2k buffers  * hw.proatm.cur_small   (R/O)  Current number of free mbufs  * hw.proatm.qptr_hold    (1)   Optimize TX queue buffer for lowest overhead  *  * Note that the read-only buffer counts will not work with multiple cards.  *  ******************************************************************************  *  *  Assumption: All mbuf clusters are 2048 bytes.  *  ******************************************************************************  *  *  Date: 25-06-2003  *  Version: 1.06  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* replace with #define XDEBUG 1 or #define XDEBUG 2 for extra debug printing */
end_comment

begin_define
define|#
directive|define
name|XDEBUG
value|0
end_define

begin_define
define|#
directive|define
name|PROATM_VERSION
value|"PROATM 1.0061"
end_define

begin_comment
comment|/* Don't touch these **********************************************************/
end_comment

begin_if
if|#
directive|if
name|XDEBUG
operator|==
literal|1
end_if

begin_define
define|#
directive|define
name|XPRINT
parameter_list|(
name|arg
modifier|...
parameter_list|)
value|printf(arg)
end_define

begin_elif
elif|#
directive|elif
name|XDEBUG
operator|==
literal|2
end_elif

begin_define
define|#
directive|define
name|XPRINT
parameter_list|(
name|arg
modifier|...
parameter_list|)
value|bprintf(arg);
end_define

begin_define
define|#
directive|define
name|PROATM_LOG_SIZE
value|0x4000
end_define

begin_decl_stmt
specifier|static
name|char
name|proatm_log
index|[
name|PROATM_LOG_SIZE
operator|+
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|proatm_logptr
init|=
name|proatm_log
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|XPRINT
parameter_list|(
name|arg
modifier|...
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/******************************************************************************/
end_comment

begin_include
include|#
directive|include
file|<dev/proatm/proatm.h>
end_include

begin_include
include|#
directive|include
file|<dev/proatm/proatm_rtbl.c>
end_include

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|==
literal|350000
operator|||
name|__FreeBSD_version
operator|==
literal|350001
end_if

begin_define
define|#
directive|define
name|FBSD35
end_define

begin_elif
elif|#
directive|elif
name|__FreeBSD_version
operator|>=
literal|410000
end_elif

begin_define
define|#
directive|define
name|FBSD41
end_define

begin_else
else|#
directive|else
end_else

begin_error
error|#
directive|error
literal|"This driver is for FreeBSD 3.5, 3.51 or 4.1 and later"
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|u_int32_t
name|proatm_found
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int32_t
name|proatm_phys_init
name|__P
argument_list|(
operator|(
name|proatm_reg_t
operator|*
specifier|const
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int32_t
name|proatm_init
name|__P
argument_list|(
operator|(
name|proatm_reg_t
operator|*
specifier|const
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int32_t
name|proatm_sram_wr
name|__P
argument_list|(
operator|(
name|proatm_reg_t
operator|*
specifier|const
operator|,
name|u_int32_t
operator|,
name|int32_t
operator|,
name|u_int32_t
operator|,
name|u_int32_t
operator|,
name|u_int32_t
operator|,
name|u_int32_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int32_t
name|proatm_sram_rd
name|__P
argument_list|(
operator|(
name|proatm_reg_t
operator|*
specifier|const
operator|,
name|u_int32_t
operator|,
name|u_int32_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int32_t
name|proatm_add_buf
name|__P
argument_list|(
operator|(
name|proatm_reg_t
operator|*
specifier|const
operator|,
expr|struct
name|mbuf
operator|*
operator|,
expr|struct
name|mbuf
operator|*
operator|,
name|u_int32_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int32_t
name|proatm_util_rd
name|__P
argument_list|(
operator|(
name|proatm_reg_t
operator|*
specifier|const
operator|,
name|u_int32_t
operator|,
name|u_int32_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int32_t
name|proatm_util_wr
name|__P
argument_list|(
operator|(
name|proatm_reg_t
operator|*
specifier|const
operator|,
name|u_int32_t
operator|,
name|u_int32_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|proatm_ld_rcv_buf
name|__P
argument_list|(
operator|(
name|proatm_reg_t
operator|*
specifier|const
operator|,
name|int32_t
operator|,
name|int32_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|proatm_itrx
name|__P
argument_list|(
operator|(
name|proatm_reg_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|proatm_rawc
name|__P
argument_list|(
operator|(
name|proatm_reg_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|proatm_recv
name|__P
argument_list|(
operator|(
name|proatm_reg_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|proatm_phys
name|__P
argument_list|(
operator|(
name|proatm_reg_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|proatm_intr
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int32_t
name|proatm_atm_bearerclass
parameter_list|(
name|struct
name|attr_bearer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|CONNECTION
modifier|*
name|proatm_atm_harpconn
parameter_list|(
name|Cmn_unit
modifier|*
parameter_list|,
name|Cmn_vcc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|int32_t
name|proatm_atm_ioctl
name|__P
argument_list|(
operator|(
name|int32_t
operator|,
name|caddr_t
operator|,
name|caddr_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|proatm_harp_init
name|__P
argument_list|(
operator|(
name|proatm_reg_t
operator|*
specifier|const
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|proatm_output
name|__P
argument_list|(
operator|(
name|Cmn_unit
operator|*
operator|,
name|Cmn_vcc
operator|*
operator|,
name|KBuffer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int32_t
name|proatm_openvcc
name|__P
argument_list|(
operator|(
name|Cmn_unit
operator|*
operator|,
name|Cmn_vcc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int32_t
name|proatm_closevcc
name|__P
argument_list|(
operator|(
name|Cmn_unit
operator|*
operator|,
name|Cmn_vcc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int32_t
name|proatm_instvcc
name|__P
argument_list|(
operator|(
name|Cmn_unit
operator|*
operator|,
name|Cmn_vcc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|proatm_recv_stack
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|,
name|KBuffer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|struct
name|mbuf
modifier|*
name|proatm_mbufcl_get
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|CONNECTION
modifier|*
name|proatm_connect_find
parameter_list|(
name|PROATM
modifier|*
parameter_list|,
name|int32_t
parameter_list|,
name|int32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|proatm_connect_init
parameter_list|(
name|PROATM
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|proatm_dtst_init
parameter_list|(
name|PROATM
modifier|*
name|proatm
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|proatm_tst_init
parameter_list|(
name|PROATM
modifier|*
name|proatm
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|proatm_rate_init
parameter_list|(
name|PROATM
modifier|*
name|proatm
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|proatm_connect_rxopen
parameter_list|(
name|PROATM
modifier|*
parameter_list|,
name|CONNECTION
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|proatm_connect_rxclose
parameter_list|(
name|PROATM
modifier|*
parameter_list|,
name|CONNECTION
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|proatm_connect_txclose
parameter_list|(
name|PROATM
modifier|*
parameter_list|,
name|CONNECTION
modifier|*
parameter_list|,
name|int32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|proatm_connect_txopen
parameter_list|(
name|PROATM
modifier|*
parameter_list|,
name|CONNECTION
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|proatm_device_stop
parameter_list|(
name|PROATM
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|proatm_intr_tsq
parameter_list|(
name|PROATM
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|proatm_malloc_contig
parameter_list|(
name|int32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|caddr_t
name|proatm_mbuf_base
parameter_list|(
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|proatm_mcheck_add
parameter_list|(
name|PROATM
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|proatm_mcheck_rem
parameter_list|(
name|PROATM
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|proatm_mcheck_init
parameter_list|(
name|PROATM
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|proatm_queue_flush
parameter_list|(
name|CONNECTION
modifier|*
parameter_list|,
name|int32_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|mbuf
modifier|*
name|proatm_queue_get
parameter_list|(
name|TX_QUEUE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|proatm_queue_init
parameter_list|(
name|PROATM
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|proatm_queue_put
parameter_list|(
name|CONNECTION
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|proatm_receive
parameter_list|(
name|PROATM
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|int32_t
parameter_list|,
name|int32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|proatm_receive_aal5
parameter_list|(
name|PROATM
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|proatm_release_mem
parameter_list|(
name|PROATM
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|proatm_transmit
parameter_list|(
name|PROATM
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|int32_t
parameter_list|,
name|int32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|proatm_transmit_drop
parameter_list|(
name|PROATM
modifier|*
parameter_list|,
name|CONNECTION
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|proatm_transmit_top
parameter_list|(
name|PROATM
modifier|*
parameter_list|,
name|TX_QUEUE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|proatm_slots_add
parameter_list|(
name|PROATM
modifier|*
parameter_list|,
name|TX_QUEUE
modifier|*
parameter_list|,
name|int32_t
parameter_list|,
name|int32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|proatm_slots_cbr
parameter_list|(
name|PROATM
modifier|*
parameter_list|,
name|int32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|proatm_slots_rem
parameter_list|(
name|PROATM
modifier|*
parameter_list|,
name|TX_QUEUE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|proatm_phys_detect
parameter_list|(
name|PROATM
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|proatm_status_bufs
parameter_list|(
name|PROATM
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|proatm_status_wait
parameter_list|(
name|PROATM
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int32_t
name|proatm_reg_rd
parameter_list|(
name|proatm_reg_t
modifier|*
specifier|const
parameter_list|,
name|vm_offset_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|proatm_reg_wr
parameter_list|(
name|proatm_reg_t
modifier|*
specifier|const
parameter_list|,
name|u_int32_t
parameter_list|,
name|vm_offset_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|proatm_tct_wr
parameter_list|(
name|PROATM
modifier|*
parameter_list|,
name|int32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|u_int32_t
name|nicsr
parameter_list|(
name|proatm_reg_t
modifier|*
specifier|const
parameter_list|,
name|u_int32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|proatm_connect_txstop
parameter_list|(
name|PROATM
modifier|*
parameter_list|,
name|int32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|proatm_process_tsr
parameter_list|(
name|PROATM
modifier|*
parameter_list|,
name|u_int32_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|proatm_connect_txclose_cb
parameter_list|(
name|PROATM
modifier|*
parameter_list|,
name|CONNECTION
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|proatm_process_rcqe
parameter_list|(
name|proatm_reg_t
modifier|*
parameter_list|,
name|rcqe
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|proatm_check_vc
parameter_list|(
name|PROATM
modifier|*
parameter_list|,
name|u_int8_t
parameter_list|,
name|ushort
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|proatm_get_stats
parameter_list|(
name|proatm_reg_t
modifier|*
name|proatm
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Our own proatm malloc type */
end_comment

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_PROATM
argument_list|,
literal|"proatm"
argument_list|,
literal|"Prosum's ATM buffers"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|#
directive|if
name|XDEBUG
operator|==
literal|2
end_if

begin_function_decl
name|void
name|print_proatm_log
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|bprintf
parameter_list|(
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|FBSD35
end_ifdef

begin_comment
comment|/*****************************************************************************  *   * FreeBSD 3.5 specific section   *  *****************************************************************************/
end_comment

begin_comment
comment|/*  FreeBSD glue */
end_comment

begin_decl_stmt
specifier|static
name|u_int32_t
name|proatm_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|proatm_probe
name|__P
argument_list|(
operator|(
name|pcici_t
operator|,
name|pcidi_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|proatm_attach
name|__P
argument_list|(
operator|(
name|pcici_t
operator|,
name|int32_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|proatm_shutdown
name|__P
argument_list|(
operator|(
name|int32_t
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|pci_device
name|proatm_device
init|=
block|{
literal|"proatm"
block|,
name|proatm_probe
block|,
name|proatm_attach
block|,
operator|&
name|proatm_count
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DATA_SET
argument_list|(
name|pcidevice_set
argument_list|,
name|proatm_device
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/******************************************************************************  *  *  PROATM Nicstar probe   (3.5)  *  *  Return identification string if this is device is IDT77252.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|proatm_probe
parameter_list|(
name|pcici_t
name|config_id
parameter_list|,
name|pcidi_t
name|device_id
parameter_list|)
block|{
if|if
condition|(
operator|(
operator|(
name|device_id
operator|&
literal|0xffff
operator|)
operator|==
literal|0x111d
operator|)
operator|&&
operator|(
operator|(
name|device_id
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
operator|)
operator|==
literal|3
condition|)
comment|/* IDT77252 device ID */
return|return
operator|(
literal|"PROSUM PROATM adapter"
operator|)
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  *  *  Attach device    (3.5)  *  */
end_comment

begin_function
specifier|static
name|void
name|proatm_attach
parameter_list|(
name|pcici_t
name|config_id
parameter_list|,
name|int32_t
name|unit
parameter_list|)
block|{
name|PROATM
modifier|*
name|proatm
decl_stmt|;
name|u_int32_t
name|val
decl_stmt|;
name|vm_offset_t
name|pbase
decl_stmt|,
name|vbase
decl_stmt|;
name|int32_t
name|latency
decl_stmt|;
name|int32_t
name|retval
decl_stmt|;
name|int32_t
name|s
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|proatm
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|PROATM
argument_list|)
argument_list|,
name|M_PROATM
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|proatm
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"proatm%d: no memory for PROATM struct!\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
name|bzero
argument_list|(
name|proatm
argument_list|,
sizeof|sizeof
argument_list|(
name|PROATM
argument_list|)
argument_list|)
expr_stmt|;
name|val
operator|=
name|pci_conf_read
argument_list|(
name|config_id
argument_list|,
name|PCIR_COMMAND
argument_list|)
expr_stmt|;
comment|/* enable bus mastering */
name|val
operator||=
name|PCIM_CMD_MEMEN
operator||
name|PCIM_CMD_BUSMASTEREN
expr_stmt|;
name|pci_conf_write
argument_list|(
name|config_id
argument_list|,
name|PCIR_COMMAND
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
name|pci_conf_read
argument_list|(
name|config_id
argument_list|,
name|PCIR_COMMAND
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|val
operator|&
name|PCIM_CMD_MEMEN
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"proatm%d: failed to enable memory mapping!\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/*  Map IDT registers */
if|if
condition|(
operator|!
name|pci_map_mem
argument_list|(
name|config_id
argument_list|,
literal|0x14
argument_list|,
operator|&
name|vbase
argument_list|,
operator|&
name|pbase
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"proatm%d: couldn't map registers\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|proatm
operator|->
name|bustag
operator|=
name|I386_BUS_SPACE_MEM
expr_stmt|;
name|proatm
operator|->
name|bushandle
operator|=
name|vbase
expr_stmt|;
name|proatm
operator|->
name|virt_baseaddr
operator|=
operator|(
name|vm_offset_t
operator|)
name|vbase
expr_stmt|;
comment|/* Map interrupt */
if|if
condition|(
operator|!
name|pci_map_int
argument_list|(
name|config_id
argument_list|,
name|proatm_intr
argument_list|,
name|proatm
argument_list|,
operator|&
name|net_imask
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"proatm%d: couldn't map interrupt\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|val
operator|=
name|pci_conf_read
argument_list|(
name|config_id
argument_list|,
name|PCIR_REVID
argument_list|)
expr_stmt|;
comment|/* device class code register */
name|proatm
operator|->
name|pci_rev
operator|=
name|val
operator|&
literal|255
expr_stmt|;
name|latency
operator|=
name|pci_conf_read
argument_list|(
name|config_id
argument_list|,
name|PCIR_CACHELNSZ
argument_list|)
expr_stmt|;
name|latency
operator|&=
literal|0xffff00ff
expr_stmt|;
name|latency
operator||=
literal|0x2000
expr_stmt|;
comment|/* count = 2 (times 32 PCI clocks) */
name|pci_conf_write
argument_list|(
name|config_id
argument_list|,
name|PCIR_CACHELNSZ
argument_list|,
name|latency
argument_list|)
expr_stmt|;
name|proatm
operator|->
name|timer_wrap
operator|=
literal|0
expr_stmt|;
name|proatm
operator|->
name|unit
operator|=
name|unit
expr_stmt|;
name|nicstar
index|[
name|proatm
operator|->
name|unit
index|]
operator|=
name|proatm
expr_stmt|;
name|retval
operator|=
name|proatm_phys_init
argument_list|(
name|proatm
argument_list|)
expr_stmt|;
comment|/* initialize the hardware */
if|if
condition|(
name|retval
condition|)
goto|goto
name|fail
goto|;
name|retval
operator|=
name|proatm_init
argument_list|(
name|proatm
argument_list|)
expr_stmt|;
comment|/* allocate and initialize */
if|if
condition|(
name|retval
condition|)
goto|goto
name|fail
goto|;
name|proatm_harp_init
argument_list|(
name|proatm
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|at_shutdown
argument_list|(
name|proatm_shutdown
argument_list|,
name|proatm
argument_list|,
name|SHUTDOWN_POST_SYNC
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
name|fail
label|:
name|free
argument_list|(
name|proatm
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/******************************************************************************  *  *  Shutdown device    (3.5)  *  */
end_comment

begin_function
specifier|static
name|void
name|proatm_shutdown
parameter_list|(
name|int32_t
name|howto
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|PROATM
modifier|*
name|proatm
init|=
operator|(
name|PROATM
operator|*
operator|)
name|arg
decl_stmt|;
name|proatm_device_stop
argument_list|(
name|proatm
argument_list|)
expr_stmt|;
comment|/*  Stop the device */
return|return;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/*****************************************************************************  *   * FreeBSD 4.1 and above specific section   *  *****************************************************************************/
end_comment

begin_comment
comment|/*  FreeBSD glue */
end_comment

begin_function_decl
specifier|static
name|int32_t
name|proatm_probe
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|proatm_attach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|proatm_detach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|proatm_shutdown
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|device_method_t
name|proatm_methods
index|[]
init|=
block|{
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|proatm_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|proatm_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|proatm_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|proatm_shutdown
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|proatm_driver
init|=
block|{
literal|"proatm"
block|,
name|proatm_methods
block|,
expr|sizeof
operator|(
name|PROATM
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|proatm_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|proatm
argument_list|,
name|pci
argument_list|,
name|proatm_driver
argument_list|,
name|proatm_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/******************************************************************************  *  *  PROATM Nicstar probe (4.xx)  *  */
end_comment

begin_function
specifier|static
name|int32_t
name|proatm_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
if|if
condition|(
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
operator|!=
literal|0x111d
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|pci_get_device
argument_list|(
name|dev
argument_list|)
operator|!=
literal|3
condition|)
comment|/* IDT77252 device ID */
return|return
operator|(
name|ENXIO
operator|)
return|;
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"PROSUM PROATM adapter"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  *  *  Attach device (4.xx)  *  */
end_comment

begin_function
specifier|static
name|int32_t
name|proatm_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|PROATM
modifier|*
name|proatm
decl_stmt|;
name|int32_t
name|val
decl_stmt|;
name|int32_t
name|rid
decl_stmt|;
comment|/* resource ID */
name|int32_t
name|latency
decl_stmt|;
name|int32_t
name|retval
decl_stmt|;
name|int32_t
name|s
decl_stmt|;
name|proatm
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|proatm
argument_list|,
sizeof|sizeof
argument_list|(
name|PROATM
argument_list|)
argument_list|)
expr_stmt|;
name|callout_handle_init
argument_list|(
operator|&
name|proatm
operator|->
name|stat_ch
argument_list|)
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|val
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* enable bus mastering */
name|val
operator||=
name|PCIM_CMD_MEMEN
operator||
name|PCIM_CMD_BUSMASTEREN
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
name|val
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/*  Map IDT registers */
name|rid
operator|=
literal|0x14
expr_stmt|;
name|proatm
operator|->
name|mem
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
literal|1
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|proatm
operator|->
name|mem
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not map registers.\n"
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|proatm
operator|->
name|bustag
operator|=
name|rman_get_bustag
argument_list|(
name|proatm
operator|->
name|mem
argument_list|)
expr_stmt|;
name|proatm
operator|->
name|bushandle
operator|=
name|rman_get_bushandle
argument_list|(
name|proatm
operator|->
name|mem
argument_list|)
expr_stmt|;
comment|/* Map interrupt */
name|rid
operator|=
literal|0
expr_stmt|;
name|proatm
operator|->
name|irq
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
literal|1
argument_list|,
name|RF_ACTIVE
operator||
name|RF_SHAREABLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|proatm
operator|->
name|irq
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not map interrupt.\n"
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|retval
operator|=
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|proatm
operator|->
name|irq
argument_list|,
name|INTR_TYPE_NET
argument_list|,
name|proatm_intr
argument_list|,
name|proatm
argument_list|,
operator|&
name|proatm
operator|->
name|irqcookie
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not setup irq.\n"
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
name|proatm
operator|->
name|virt_baseaddr
operator|=
operator|(
name|vm_offset_t
operator|)
name|rman_get_virtual
argument_list|(
name|proatm
operator|->
name|mem
argument_list|)
expr_stmt|;
name|val
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
literal|8
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* device class code register */
name|proatm
operator|->
name|pci_rev
operator|=
name|val
operator|&
literal|255
expr_stmt|;
name|latency
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
literal|12
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|latency
operator|&=
literal|0xffff00ff
expr_stmt|;
name|latency
operator||=
literal|0x2000
expr_stmt|;
comment|/* count = 2 (times 32 PCI clocks) */
name|pci_write_config
argument_list|(
name|dev
argument_list|,
literal|12
argument_list|,
name|latency
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|proatm
operator|->
name|timer_wrap
operator|=
literal|0
expr_stmt|;
name|proatm
operator|->
name|unit
operator|=
name|device_get_unit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|nicstar
index|[
name|proatm
operator|->
name|unit
index|]
operator|=
name|proatm
expr_stmt|;
name|retval
operator|=
name|proatm_phys_init
argument_list|(
name|proatm
argument_list|)
expr_stmt|;
comment|/* initialize the hardware */
if|if
condition|(
name|retval
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
name|retval
operator|=
name|proatm_init
argument_list|(
name|proatm
argument_list|)
expr_stmt|;
comment|/* allocate and initialize */
if|if
condition|(
name|retval
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
name|proatm_harp_init
argument_list|(
name|proatm
argument_list|,
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  *  *  Detach device (4.xx)  *  */
end_comment

begin_function
specifier|static
name|int32_t
name|proatm_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|PROATM
modifier|*
name|proatm
decl_stmt|;
name|int32_t
name|s
decl_stmt|,
name|i
decl_stmt|;
name|CONNECTION
modifier|*
name|connection
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|proatm
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|proatm_device_stop
argument_list|(
name|proatm
argument_list|)
expr_stmt|;
comment|/*  Stop the device */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|proatm
operator|->
name|max_connection
condition|;
name|i
operator|++
control|)
block|{
name|connection
operator|=
operator|&
name|proatm
operator|->
name|connection
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|connection
operator|->
name|flg_open
condition|)
block|{
name|proatm_connect_rxclose
argument_list|(
name|proatm
argument_list|,
name|connection
argument_list|)
expr_stmt|;
if|if
condition|(
name|connection
operator|->
name|recv
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|connection
operator|->
name|recv
argument_list|)
expr_stmt|;
comment|/* Enforce close when it is a VBR or UBR connection for which a 	     * PROATM_CLOSE_TAG message has to be sent to the SAR. 	     * It means that no message will be posted. 	     * Only the CBR and UBR0 connections are synchronously closed. 	     */
name|proatm_connect_txclose
argument_list|(
name|proatm
argument_list|,
name|connection
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|1024
condition|;
name|i
operator|++
control|)
block|{
name|m
operator|=
name|proatm
operator|->
name|mcheck
index|[
name|i
index|]
expr_stmt|;
while|while
condition|(
name|m
condition|)
name|m
operator|=
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|proatm
operator|->
name|irq
argument_list|,
name|proatm
operator|->
name|irqcookie
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
name|proatm
operator|->
name|irq
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
literal|0x14
argument_list|,
name|proatm
operator|->
name|mem
argument_list|)
expr_stmt|;
name|proatm_release_mem
argument_list|(
name|proatm
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  *  *  Shutdown device (4.xx)  *  */
end_comment

begin_function
specifier|static
name|int32_t
name|proatm_shutdown
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|PROATM
modifier|*
name|proatm
decl_stmt|;
name|proatm
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|proatm_device_stop
argument_list|(
name|proatm
argument_list|)
expr_stmt|;
comment|/*  Stop the device */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*****************************************************************************  *   * common section  *  *****************************************************************************/
end_comment

begin_comment
comment|/******************************************************************************  *  *  Stop device (shutdown)  *  *  in:  PROATM device  *  */
end_comment

begin_function
specifier|static
name|void
name|proatm_device_stop
parameter_list|(
name|PROATM
modifier|*
name|proatm
parameter_list|)
block|{
name|int32_t
name|s
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|proatm_reg_wr
argument_list|(
name|proatm
argument_list|,
name|IDT_CFG_SWRST
argument_list|,
name|REGCFG
argument_list|)
expr_stmt|;
comment|/* put chip into reset */
name|DELAY
argument_list|(
literal|50
argument_list|)
expr_stmt|;
name|proatm_reg_wr
argument_list|(
name|proatm
argument_list|,
literal|0
argument_list|,
name|REGCFG
argument_list|)
expr_stmt|;
comment|/* out of reset */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************************  *  *  Initialize hardware  */
end_comment

begin_function
specifier|static
name|int32_t
name|proatm_phys_init
parameter_list|(
name|proatm_reg_t
modifier|*
specifier|const
name|proatm
parameter_list|)
block|{
name|int32_t
name|i
decl_stmt|;
name|u_int32_t
name|t
decl_stmt|;
name|u_int32_t
name|x
decl_stmt|,
name|s1
decl_stmt|,
name|s2
decl_stmt|,
name|z
decl_stmt|;
specifier|volatile
name|u_int32_t
name|stat_val
decl_stmt|;
comment|/* clean status bits */
name|stat_val
operator|=
name|proatm_reg_rd
argument_list|(
name|proatm
argument_list|,
name|REGSTAT
argument_list|)
expr_stmt|;
name|proatm_reg_wr
argument_list|(
name|proatm
argument_list|,
name|stat_val
operator||
name|CLEAR_FLAGS
argument_list|,
name|REGSTAT
argument_list|)
expr_stmt|;
comment|/* clear ints */
name|proatm
operator|->
name|flg_25
operator|=
literal|0
expr_stmt|;
comment|/* is this PROATM-25 with 77105 PHY? */
name|proatm
operator|->
name|flg_igcrc
operator|=
literal|0
expr_stmt|;
comment|/* ignore receive CRC errors? */
name|strcpy
argument_list|(
name|proatm
operator|->
name|hardware
argument_list|,
literal|"?"
argument_list|)
expr_stmt|;
comment|/* start signalling SAR reset*/
name|proatm_reg_wr
argument_list|(
name|proatm
argument_list|,
name|IDT_CFG_SWRST
argument_list|,
name|REGCFG
argument_list|)
expr_stmt|;
comment|/* SAR reset--clear occurs at lease 2 PCI cycles after setting */
name|DELAY
argument_list|(
literal|50
argument_list|)
expr_stmt|;
comment|/* wait */
name|proatm_reg_wr
argument_list|(
name|proatm
argument_list|,
literal|0
argument_list|,
name|REGCFG
argument_list|)
expr_stmt|;
comment|/* clear reset */
name|proatm_reg_wr
argument_list|(
name|proatm
argument_list|,
literal|0
argument_list|,
name|REGGP
argument_list|)
expr_stmt|;
comment|/* clear PHYS reset */
name|proatm_reg_wr
argument_list|(
name|proatm
argument_list|,
literal|8
argument_list|,
name|REGGP
argument_list|)
expr_stmt|;
comment|/* set PHYS reset */
name|DELAY
argument_list|(
literal|50
argument_list|)
expr_stmt|;
comment|/* wait */
name|proatm_reg_wr
argument_list|(
name|proatm
argument_list|,
literal|3
argument_list|,
name|REGGP
argument_list|)
expr_stmt|;
comment|/* clear PHYS reset and set EECS and EED0*/
name|DELAY
argument_list|(
literal|50
argument_list|)
expr_stmt|;
comment|/* wait */
name|proatm
operator|->
name|flg_25
operator|=
name|proatm_phys_detect
argument_list|(
name|proatm
argument_list|)
expr_stmt|;
if|if
condition|(
name|proatm
operator|->
name|flg_25
condition|)
block|{
name|proatm
operator|->
name|max_pcr
operator|=
name|ATM_PCR_25
expr_stmt|;
name|proatm
operator|->
name|txslots_cur
operator|=
literal|0
expr_stmt|;
comment|/* initialize the 25.6 Mbps IDT77105 */
name|proatm_util_wr
argument_list|(
name|proatm
argument_list|,
name|IDT77105_MCR_REG
argument_list|,
literal|0x09
argument_list|)
expr_stmt|;
comment|/* enable interrupts 		                                                  * and Discard Received Idle Cells */
name|proatm_util_wr
argument_list|(
name|proatm
argument_list|,
name|IDT77105_DIAG_REG
argument_list|,
literal|0x10
argument_list|)
expr_stmt|;
comment|/* 77105 RFLUSH, clear receive FIFO */
name|proatm_util_rd
argument_list|(
name|proatm
argument_list|,
name|IDT77105_ISTAT_REG
argument_list|,
operator|&
name|t
argument_list|)
expr_stmt|;
comment|/* read/clear interrupt flag */
block|}
else|else
block|{
name|proatm
operator|->
name|max_pcr
operator|=
name|ATM_PCR_OC3C
expr_stmt|;
name|proatm
operator|->
name|txslots_cur
operator|=
literal|0
expr_stmt|;
comment|/* initialize the 155Mb SUNI */
name|proatm_util_wr
argument_list|(
name|proatm
argument_list|,
name|SUNI_MASTER_REG
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* clear SW reset */
ifdef|#
directive|ifdef
name|PROATM_LOOPT
name|proatm_util_rd
argument_list|(
name|proatm
argument_list|,
name|SUNI_MSTR_CTRL_REG
argument_list|,
operator|&
name|t
argument_list|)
expr_stmt|;
name|proatm_util_wr
argument_list|(
name|proatm
argument_list|,
name|SUNI_MSTR_CTRL_REG
argument_list|,
name|t
operator||
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PROATM_FULL_SDH
name|proatm_util_rd
argument_list|(
name|proatm
argument_list|,
name|SUNI_TPOP_MSB_REG
argument_list|,
operator|&
name|t
argument_list|)
expr_stmt|;
name|proatm_util_rd
argument_list|(
name|proatm
argument_list|,
name|SUNI_TPOP_MSB_REG
argument_list|,
name|t
operator||
literal|0x8
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* this will work with 32K and 128K word RAM  because              * the pattern repeats every 4 words */
name|proatm
operator|->
name|sram_size
operator|=
literal|0x20000
expr_stmt|;
comment|/* to allow SRAM write */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|0x20000
condition|;
name|i
operator|+=
literal|4
control|)
operator|(
name|void
operator|)
name|proatm_sram_wr
argument_list|(
name|proatm
argument_list|,
name|i
argument_list|,
literal|4
argument_list|,
literal|0xa5a5a5a5
argument_list|,
literal|0x5a5a5a5a
argument_list|,
literal|0xa5a5a5a5
argument_list|,
literal|0x5a5a5a5a
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|0x20000
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|s1
operator|=
name|proatm_sram_rd
argument_list|(
name|proatm
argument_list|,
name|i
argument_list|,
operator|&
name|x
argument_list|)
expr_stmt|;
name|s2
operator|=
name|proatm_sram_rd
argument_list|(
name|proatm
argument_list|,
name|i
operator|+
literal|1
argument_list|,
operator|&
name|z
argument_list|)
expr_stmt|;
if|if
condition|(
name|s1
operator|||
name|s2
operator|||
name|x
operator|!=
literal|0xa5a5a5a5
operator|||
name|z
operator|!=
literal|0x5a5a5a5a
condition|)
block|{
name|printf
argument_list|(
literal|"proatm%d: sram fail1 %d 0x%08x 0x%08x\n"
argument_list|,
name|proatm
operator|->
name|unit
argument_list|,
name|i
argument_list|,
operator|(
name|u_int32_t
operator|)
name|x
argument_list|,
operator|(
name|u_int32_t
operator|)
name|z
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|0x20000
condition|;
name|i
operator|+=
literal|4
control|)
operator|(
name|void
operator|)
name|proatm_sram_wr
argument_list|(
name|proatm
argument_list|,
name|i
argument_list|,
literal|4
argument_list|,
literal|0x5a5a5a5a
argument_list|,
literal|0xa5a5a5a5
argument_list|,
literal|0x5a5a5a5a
argument_list|,
literal|0xa5a5a5a5
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|0x20000
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|s1
operator|=
name|proatm_sram_rd
argument_list|(
name|proatm
argument_list|,
name|i
argument_list|,
operator|&
name|z
argument_list|)
expr_stmt|;
name|s2
operator|=
name|proatm_sram_rd
argument_list|(
name|proatm
argument_list|,
name|i
operator|+
literal|1
argument_list|,
operator|&
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|s1
operator|||
name|s2
operator|||
name|x
operator|!=
literal|0xa5a5a5a5
operator|||
name|z
operator|!=
literal|0x5a5a5a5a
condition|)
block|{
name|printf
argument_list|(
literal|"proatm%d: sram fail2 %d 0x%08x 0x%08x\n"
argument_list|,
name|proatm
operator|->
name|unit
argument_list|,
name|i
argument_list|,
operator|(
name|u_int32_t
operator|)
name|x
argument_list|,
operator|(
name|u_int32_t
operator|)
name|z
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
block|}
comment|/* flush SRAM */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|0x20000
condition|;
name|i
operator|+=
literal|4
control|)
operator|(
name|void
operator|)
name|proatm_sram_wr
argument_list|(
name|proatm
argument_list|,
name|i
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* write in the 0 word, see if we read it at 0x10000 */
operator|(
name|void
operator|)
name|proatm_sram_wr
argument_list|(
name|proatm
argument_list|,
literal|0x0
argument_list|,
literal|1
argument_list|,
literal|0xa5a5a5a5
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|s1
operator|=
name|proatm_sram_rd
argument_list|(
name|proatm
argument_list|,
literal|0x10000
argument_list|,
operator|&
name|x
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|proatm_sram_wr
argument_list|(
name|proatm
argument_list|,
literal|0x0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s1
operator|&&
name|x
operator|==
literal|0xa5a5a5a5
condition|)
block|{
name|printf
argument_list|(
literal|"proatm%d: 32K words of RAM "
argument_list|,
name|proatm
operator|->
name|unit
argument_list|)
expr_stmt|;
name|proatm
operator|->
name|sram_size
operator|=
literal|0x8000
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"proatm%d: 128K words of RAM "
argument_list|,
name|proatm
operator|->
name|unit
argument_list|)
expr_stmt|;
name|proatm
operator|->
name|sram_size
operator|=
literal|0x20000
expr_stmt|;
block|}
comment|/* else TODO: 512K support */
ifdef|#
directive|ifdef
name|NICSTAR_FORCE32K
name|proatm
operator|->
name|sram_size
operator|=
literal|0x8000
expr_stmt|;
name|printf
argument_list|(
literal|"forced to 32K "
argument_list|,
name|proatm
operator|->
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|proatm
operator|->
name|sram_size
operator|==
literal|0x8000
condition|)
block|{
name|proatm
operator|->
name|max_connection
operator|=
literal|1024
expr_stmt|;
name|proatm
operator|->
name|tst_num
operator|=
literal|2047
expr_stmt|;
block|}
else|else
block|{
name|proatm
operator|->
name|max_connection
operator|=
literal|4096
expr_stmt|;
name|proatm
operator|->
name|tst_num
operator|=
literal|4095
expr_stmt|;
block|}
comment|/* else TODO: 512K support */
name|printf
argument_list|(
literal|"up to %d PVC\n"
argument_list|,
name|proatm
operator|->
name|max_connection
argument_list|)
expr_stmt|;
comment|/* dynamic SRAM map */
name|proatm
operator|->
name|rct
operator|=
name|IDT_TCT_ENTRY_SIZE
operator|*
name|proatm
operator|->
name|max_connection
expr_stmt|;
name|proatm
operator|->
name|rate
operator|=
name|proatm
operator|->
name|rct
operator|+
name|IDT_RCT_ENTRY_SIZE
operator|*
name|proatm
operator|->
name|max_connection
operator|+
literal|2
operator|*
name|PROATM_RFBQ_SIZE
expr_stmt|;
name|proatm
operator|->
name|tst
operator|=
name|proatm
operator|->
name|rate
operator|+
name|abr_vbr_rate_tables_len
expr_stmt|;
name|proatm
operator|->
name|dtst
operator|=
name|proatm
operator|->
name|tst
operator|+
name|proatm
operator|->
name|tst_num
operator|+
literal|1
expr_stmt|;
name|proatm
operator|->
name|scd
operator|=
name|proatm
operator|->
name|dtst
operator|+
name|PROATM_DTST_SIZE
expr_stmt|;
name|proatm
operator|->
name|rxfifo
operator|=
name|proatm
operator|->
name|sram_size
operator|-
name|PROATM_RXFIFO_SIZE
expr_stmt|;
name|proatm
operator|->
name|scd_size
operator|=
operator|(
operator|(
name|proatm
operator|->
name|rxfifo
operator|-
name|proatm
operator|->
name|scd
operator|)
operator|/
name|IDT_STRUCT_SCD_SIZE
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|proatm
operator|->
name|scd_size
operator|>=
operator|(
name|PROATM_MAX_QUEUE
operator|-
literal|1
operator|)
condition|)
name|proatm
operator|->
name|scd_size
operator|=
name|PROATM_MAX_QUEUE
operator|-
literal|1
expr_stmt|;
name|proatm
operator|->
name|scd_ubr0
operator|=
name|proatm
operator|->
name|scd
operator|+
name|proatm
operator|->
name|scd_size
operator|*
name|IDT_STRUCT_SCD_SIZE
expr_stmt|;
name|XPRINT
argument_list|(
literal|"proatm: SRAM Map for %d connections:\n"
argument_list|,
name|proatm
operator|->
name|max_connection
argument_list|)
expr_stmt|;
name|XPRINT
argument_list|(
literal|"TCT =      0x0\n"
argument_list|)
expr_stmt|;
name|XPRINT
argument_list|(
literal|"RCT =      0x%x\n"
argument_list|,
name|proatm
operator|->
name|rct
argument_list|)
expr_stmt|;
name|XPRINT
argument_list|(
literal|"RATE_TBL = 0x%x\n"
argument_list|,
name|proatm
operator|->
name|rate
argument_list|)
expr_stmt|;
name|XPRINT
argument_list|(
literal|"TST =      0x%x\n"
argument_list|,
name|proatm
operator|->
name|tst
argument_list|)
expr_stmt|;
name|XPRINT
argument_list|(
literal|"DTST =     0x%x\n"
argument_list|,
name|proatm
operator|->
name|dtst
argument_list|)
expr_stmt|;
name|XPRINT
argument_list|(
literal|"SCD =      0x%x\n"
argument_list|,
name|proatm
operator|->
name|scd
argument_list|)
expr_stmt|;
name|XPRINT
argument_list|(
literal|"SCD_UBR0 = 0x%x\n"
argument_list|,
name|proatm
operator|->
name|scd_ubr0
argument_list|)
expr_stmt|;
name|XPRINT
argument_list|(
literal|"RXFIFO =   0x%x\n"
argument_list|,
name|proatm
operator|->
name|rxfifo
argument_list|)
expr_stmt|;
name|XPRINT
argument_list|(
literal|"proatm_phys_init: SCD number = %d\n"
argument_list|,
name|proatm
operator|->
name|scd_size
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  *  *  Physical layer detect  *  *  in:  PROATM device  * out:  zero = PROATM-155, NZ = PROATM-25  *  */
end_comment

begin_function
specifier|static
name|int32_t
name|proatm_phys_detect
parameter_list|(
name|PROATM
modifier|*
name|proatm
parameter_list|)
block|{
name|u_int32_t
name|t
decl_stmt|;
name|proatm_reg_wr
argument_list|(
name|proatm
argument_list|,
literal|0xa
argument_list|,
name|REGGP
argument_list|)
expr_stmt|;
comment|/* PHY reset */
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|proatm_reg_wr
argument_list|(
name|proatm
argument_list|,
literal|0x2
argument_list|,
name|REGGP
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|proatm_status_wait
argument_list|(
name|proatm
argument_list|)
expr_stmt|;
name|proatm_util_rd
argument_list|(
name|proatm
argument_list|,
name|SUNI_MASTER_REG
argument_list|,
operator|&
name|t
argument_list|)
expr_stmt|;
comment|/* get Master Control Register */
comment|/*  *  Both MCR are 0x00  *  proatm_util_rd(proatm, IDT77105_MCR_REG,&t);  */
comment|/*  Register 0 values:      *       IDT77105  = 0x09      *       PM5346 = 0x30      *       PM5250 = 0x31  (actually observed)      *       IDT77155 = 0x70      *       PM5350 or idt77155 = 0x70 or 0x78 (according to docs)      */
if|if
condition|(
name|t
operator|==
literal|0x09
condition|)
block|{
name|printf
argument_list|(
literal|"proatm%d: ATM card is PROATM-25, PHY=IDT77105\n"
argument_list|,
name|proatm
operator|->
name|unit
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|proatm
operator|->
name|hardware
argument_list|,
literal|"PROATM-25"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|t
operator|==
literal|0x70
operator|||
name|t
operator|==
literal|0x30
operator|||
name|t
operator|==
literal|0x31
condition|)
block|{
name|printf
argument_list|(
literal|"proatm%d: ATM card is PROATM-155 or IDT, PHY=PM5346 or IDT77155\n"
argument_list|,
name|proatm
operator|->
name|unit
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|proatm
operator|->
name|hardware
argument_list|,
literal|"PROATM-155"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|printf
argument_list|(
literal|"proatm%d: unknown card, assuming PROATM-155 compatible model (reg0= 0x%x).\n"
argument_list|,
name|proatm
operator|->
name|unit
argument_list|,
operator|(
name|int32_t
operator|)
name|t
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|proatm
operator|->
name|hardware
argument_list|,
literal|"unknown"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  *  *  Initialize the data structures  */
end_comment

begin_function
specifier|static
name|int32_t
name|proatm_init
parameter_list|(
name|proatm_reg_t
modifier|*
specifier|const
name|proatm
parameter_list|)
block|{
name|int32_t
name|i
decl_stmt|;
name|vm_offset_t
name|buf
decl_stmt|;
name|u_int32_t
modifier|*
name|p
decl_stmt|;
name|u_int32_t
name|cfg
decl_stmt|;
name|proatm
operator|->
name|vpibits
operator|=
name|PROATM_VPIBITS
expr_stmt|;
comment|/* compilation constant */
if|if
condition|(
name|proatm
operator|->
name|max_connection
operator|==
literal|1024
condition|)
block|{
name|cfg
operator|=
name|IDT_CFG_RCTSIZE_1024_ENTRIES
expr_stmt|;
name|proatm
operator|->
name|vcibits
operator|=
literal|10
operator|-
name|proatm
operator|->
name|vpibits
expr_stmt|;
block|}
else|else
block|{
name|proatm
operator|->
name|vcibits
operator|=
literal|12
operator|-
name|proatm
operator|->
name|vpibits
expr_stmt|;
name|cfg
operator|=
name|IDT_CFG_RCTSIZE_4096_ENTRIES
expr_stmt|;
block|}
comment|/* compute the vpm register value */
name|proatm
operator|->
name|vpm
operator|=
operator|(
name|VCI_BASE
operator|>>
name|proatm
operator|->
name|vcibits
operator|)
operator||
operator|(
operator|(
name|VPI_BASE
operator|>>
name|proatm
operator|->
name|vpibits
operator|)
operator|<<
operator|(
literal|16
operator|-
name|proatm
operator|->
name|vcibits
operator|)
operator|)
expr_stmt|;
name|proatm
operator|->
name|vpm
operator|&=
literal|0x7fff
expr_stmt|;
name|XPRINT
argument_list|(
literal|"proatm_init: VPM = 0x%x\n"
argument_list|,
name|proatm
operator|->
name|vpm
argument_list|)
expr_stmt|;
name|proatm_reg_wr
argument_list|(
name|proatm
argument_list|,
name|cfg
argument_list|,
name|REGCFG
argument_list|)
expr_stmt|;
comment|/* initialize RCT and TCT sizes */
if|if
condition|(
name|proatm_connect_init
argument_list|(
name|proatm
argument_list|)
condition|)
block|{
comment|/* initialize for 0, 1, 2 or 8 VPI bits */
name|printf
argument_list|(
literal|"proatm%d: Cannot allocate connection table memory\n"
argument_list|,
name|proatm
operator|->
name|unit
argument_list|)
expr_stmt|;
goto|goto
name|freemem
goto|;
block|}
comment|/* allocate space for TSQ, RSQ */
name|proatm
operator|->
name|fixbuf
operator|=
operator|(
name|vm_offset_t
operator|)
name|proatm_malloc_contig
argument_list|(
name|PROATM_FIXPAGES
operator|*
name|PAGE_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|proatm
operator|->
name|fixbuf
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"proatm%d: Cannot allocate buffer memory\n"
argument_list|,
name|proatm
operator|->
name|unit
argument_list|)
expr_stmt|;
goto|goto
name|freemem
goto|;
block|}
name|proatm
operator|->
name|raw_headm
operator|=
name|NULL
expr_stmt|;
comment|/* proatm_add_buf() will initialize */
name|proatm
operator|->
name|raw_headp
operator|=
literal|0
expr_stmt|;
name|proatm
operator|->
name|raw_ch
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|proatm_mcheck_init
argument_list|(
name|proatm
argument_list|)
condition|)
goto|goto
name|freemem
goto|;
name|proatm_found
operator|++
expr_stmt|;
comment|/* number of cards found on machine */
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"proatm%d: buffer size %d\n"
argument_list|,
name|proatm
operator|->
name|unit
argument_list|,
name|PROATM_FIXPAGES
operator|*
name|PAGE_SIZE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|proatm_queue_init
argument_list|(
name|proatm
argument_list|)
condition|)
comment|/* initialize all TX_QUEUE structures */
goto|goto
name|freemem
goto|;
name|proatm_reg_wr
argument_list|(
name|proatm
argument_list|,
literal|0
argument_list|,
name|REGNOW
argument_list|)
expr_stmt|;
name|proatm_dtst_init
argument_list|(
name|proatm
argument_list|)
expr_stmt|;
comment|/* initialize the ABR/VBR  dynamic TST*/
name|proatm_tst_init
argument_list|(
name|proatm
argument_list|)
expr_stmt|;
comment|/* initialize TST tables */
name|proatm_rate_init
argument_list|(
name|proatm
argument_list|)
expr_stmt|;
comment|/* initialize  the rate table */
name|proatm_reg_wr
argument_list|(
name|proatm
argument_list|,
literal|0
argument_list|,
name|REGABRRQ
argument_list|)
expr_stmt|;
name|proatm_reg_wr
argument_list|(
name|proatm
argument_list|,
literal|0
argument_list|,
name|REGVBRRQ
argument_list|)
expr_stmt|;
comment|/* clear mbuf queues */
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|proatm
operator|->
name|fixbuf
argument_list|,
name|PROATM_FIXPAGES
operator|*
name|PAGE_SIZE
argument_list|)
expr_stmt|;
comment|/* Clear the TCT (must be located at SRAM address 0x00000 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|proatm
operator|->
name|max_connection
condition|;
name|i
operator|++
control|)
block|{
name|proatm_sram_wr
argument_list|(
name|proatm
argument_list|,
name|i
operator|*
literal|8
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|proatm_sram_wr
argument_list|(
name|proatm
argument_list|,
name|i
operator|*
literal|8
operator|+
literal|4
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Initialize the  RCT */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|proatm
operator|->
name|max_connection
condition|;
name|i
operator|++
control|)
block|{
ifdef|#
directive|ifdef
name|RCQ_SUPPORT
name|proatm_sram_wr
argument_list|(
name|proatm
argument_list|,
name|proatm
operator|->
name|rct
operator|+
name|i
operator|*
literal|4
argument_list|,
literal|4
argument_list|,
name|IDT_RCTE_RAWCELLINTEN
argument_list|,
literal|0x0
argument_list|,
literal|0x0
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
else|#
directive|else
name|proatm_sram_wr
argument_list|(
name|proatm
argument_list|,
name|proatm
operator|->
name|rct
operator|+
name|i
operator|*
literal|4
argument_list|,
literal|4
argument_list|,
literal|0x0
argument_list|,
literal|0x0
argument_list|,
literal|0x0
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Initialize RAWHND */
name|proatm
operator|->
name|raw_hnd
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|proatm_reg_wr
argument_list|(
name|proatm
argument_list|,
name|vtophys
argument_list|(
name|proatm
operator|->
name|raw_hnd
argument_list|)
argument_list|,
name|REGRAWHND
argument_list|)
expr_stmt|;
comment|/* Initialize the TSQs */
for|for
control|(
name|p
operator|=
operator|(
name|u_int32_t
operator|*
operator|)
name|proatm
operator|->
name|fixbuf
operator|+
name|PROATM_TSQ_OFFSET
init|;
name|p
operator|<
operator|(
name|u_int32_t
operator|*
operator|)
operator|(
name|proatm
operator|->
name|fixbuf
operator|+
name|PROATM_TSQ_OFFSET
operator|+
name|PROATM_TSQ_SIZE
operator|)
condition|;
control|)
block|{
operator|*
name|p
operator|++
operator|=
literal|0x00000000
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|IDT_TSI_EMPTY
expr_stmt|;
comment|/* set empty bit */
block|}
name|buf
operator|=
name|vtophys
argument_list|(
name|proatm
operator|->
name|fixbuf
operator|+
name|PROATM_TSQ_OFFSET
argument_list|)
expr_stmt|;
name|proatm_reg_wr
argument_list|(
name|proatm
argument_list|,
name|buf
argument_list|,
name|REGTSQB
argument_list|)
expr_stmt|;
comment|/* TSQ Base */
name|proatm
operator|->
name|tsq_base
operator|=
operator|(
name|u_int32_t
operator|*
operator|)
name|proatm
operator|->
name|fixbuf
expr_stmt|;
name|proatm
operator|->
name|tsq_head
operator|=
operator|(
name|u_int32_t
operator|*
operator|)
name|proatm
operator|->
name|fixbuf
expr_stmt|;
comment|/* TSQ Head */
name|proatm_reg_wr
argument_list|(
name|proatm
argument_list|,
literal|0
argument_list|,
name|REGTSQH
argument_list|)
expr_stmt|;
name|proatm
operator|->
name|tsq_size
operator|=
name|PROATM_TSQ_SIZE
operator|/
literal|8
expr_stmt|;
comment|/* TSQ entries */
comment|/* Initialize the receive FIFO */
name|proatm_reg_wr
argument_list|(
name|proatm
argument_list|,
operator|(
name|proatm
operator|->
name|rxfifo
operator|<<
literal|2
operator|)
operator||
name|PROATM_RXFD_SIZE
argument_list|,
name|REGRXFD
argument_list|)
expr_stmt|;
name|proatm_reg_wr
argument_list|(
name|proatm
argument_list|,
literal|0
argument_list|,
name|REGRXFT
argument_list|)
expr_stmt|;
name|proatm_reg_wr
argument_list|(
name|proatm
argument_list|,
literal|0
argument_list|,
name|REGRXFH
argument_list|)
expr_stmt|;
comment|/* RSQ initialization */
name|buf
operator|=
name|vtophys
argument_list|(
name|proatm
operator|->
name|fixbuf
operator|+
name|PROATM_RSQ_OFFSET
argument_list|)
expr_stmt|;
name|proatm_reg_wr
argument_list|(
name|proatm
argument_list|,
name|buf
argument_list|,
name|REGRSQB
argument_list|)
expr_stmt|;
comment|/* RSQ Base */
name|proatm_reg_wr
argument_list|(
name|proatm
argument_list|,
literal|0
argument_list|,
name|REGRSQH
argument_list|)
expr_stmt|;
comment|/* RSQ Head, 8k aligned*/
name|proatm
operator|->
name|rsqh
operator|=
literal|0
expr_stmt|;
comment|/* reflect the register */
comment|/* Initialize RFBQ pointers */
name|proatm_reg_wr
argument_list|(
name|proatm
argument_list|,
literal|0
argument_list|,
name|REGFBQP0
argument_list|)
expr_stmt|;
name|proatm_reg_wr
argument_list|(
name|proatm
argument_list|,
literal|0
argument_list|,
name|REGFBQP1
argument_list|)
expr_stmt|;
name|proatm_reg_wr
argument_list|(
name|proatm
argument_list|,
literal|0
argument_list|,
name|REGFBQP2
argument_list|)
expr_stmt|;
name|proatm_reg_wr
argument_list|(
name|proatm
argument_list|,
literal|0
argument_list|,
name|REGFBQP3
argument_list|)
expr_stmt|;
comment|/* Initialize RFBQ thresholds */
ifdef|#
directive|ifdef
name|FBSD35
name|proatm_reg_wr
argument_list|(
name|proatm
argument_list|,
name|IDT_B0THLD
operator||
name|IDT_B1SIZE
argument_list|,
name|REGFBQS0
argument_list|)
expr_stmt|;
else|#
directive|else
name|proatm_reg_wr
argument_list|(
name|proatm
argument_list|,
name|IDT_B0THLD
operator||
name|IDT_B0SIZE
argument_list|,
name|REGFBQS0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|proatm_reg_wr
argument_list|(
name|proatm
argument_list|,
name|IDT_B1THLD
operator||
name|IDT_B1SIZE
argument_list|,
name|REGFBQS1
argument_list|)
expr_stmt|;
name|proatm_reg_wr
argument_list|(
name|proatm
argument_list|,
literal|0
argument_list|,
name|REGFBQS2
argument_list|)
expr_stmt|;
comment|/* unused */
name|proatm_reg_wr
argument_list|(
name|proatm
argument_list|,
literal|0
argument_list|,
name|REGFBQS3
argument_list|)
expr_stmt|;
comment|/* unused */
comment|/* Allocate RFBQ buffers */
name|proatm_ld_rcv_buf
argument_list|(
name|proatm
argument_list|,
name|proatm_sysctl_bufsmall
argument_list|,
name|proatm_sysctl_buflarge
argument_list|)
expr_stmt|;
comment|/* Check that buffer allocation worked well */
name|i
operator|=
name|idt_fbqc_get
argument_list|(
name|proatm_reg_rd
argument_list|(
name|proatm
argument_list|,
name|REGFBQP0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|proatm_sysctl_bufsmall
condition|)
block|{
name|printf
argument_list|(
literal|"proatm%d: Wanted %d small buffers but got %d only.\n"
argument_list|,
name|proatm
operator|->
name|unit
argument_list|,
name|proatm_sysctl_bufsmall
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
name|idt_fbqc_get
argument_list|(
name|proatm_reg_rd
argument_list|(
name|proatm
argument_list|,
name|REGFBQP1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|proatm_sysctl_buflarge
condition|)
block|{
name|printf
argument_list|(
literal|"proatm%d: Wanted %d large buffers but got %d only.\n"
argument_list|,
name|proatm
operator|->
name|unit
argument_list|,
name|proatm_sysctl_buflarge
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* VPI/VCI mask VMSK */
name|proatm_reg_wr
argument_list|(
name|proatm
argument_list|,
name|proatm
operator|->
name|vpm
argument_list|,
name|REGVMSK
argument_list|)
expr_stmt|;
comment|/* Configuration Register */
name|proatm_reg_wr
argument_list|(
name|proatm
argument_list|,
name|cfg
operator||
name|IDT_DEFAULT_CFG
argument_list|,
name|REGCFG
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|freemem
label|:
comment|/* free memory and return */
name|proatm_release_mem
argument_list|(
name|proatm
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"proatm%d: Cannot allocate memory\n"
argument_list|,
name|proatm
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
comment|/* no space card disabled */
block|}
end_function

begin_comment
comment|/******************************************************************************  *  *  Release all allocated memory  *  *  in:  PROATM device  *  */
end_comment

begin_function
specifier|static
name|void
name|proatm_release_mem
parameter_list|(
name|PROATM
modifier|*
name|proatm
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|FBSD35
define|#
directive|define
name|contigfree
parameter_list|(
name|addr
parameter_list|,
name|size
parameter_list|,
name|type
parameter_list|)
define|\
value|kmem_free(kernel_map, (vm_offset_t)addr, size);
endif|#
directive|endif
if|if
condition|(
name|proatm
operator|->
name|mcheck
operator|!=
name|NULL
condition|)
block|{
name|vm_size_t
name|size
decl_stmt|;
name|size
operator|=
name|round_page
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|mbuf
operator|*
argument_list|)
operator|*
name|PROATM_MCHECK_COUNT
argument_list|)
expr_stmt|;
name|contigfree
argument_list|(
name|proatm
operator|->
name|mcheck
argument_list|,
name|size
argument_list|,
name|M_PROATM
argument_list|)
expr_stmt|;
name|proatm
operator|->
name|mcheck
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|proatm
operator|->
name|connection
operator|!=
name|NULL
condition|)
block|{
name|vm_size_t
name|pages
decl_stmt|;
name|pages
operator|=
operator|(
sizeof|sizeof
argument_list|(
name|CONNECTION
argument_list|)
operator|*
name|proatm
operator|->
name|max_connection
operator|)
operator|+
name|PAGE_SIZE
operator|-
literal|1
expr_stmt|;
name|pages
operator|/=
name|PAGE_SIZE
expr_stmt|;
name|contigfree
argument_list|(
name|proatm
operator|->
name|connection
argument_list|,
name|pages
operator|*
name|PAGE_SIZE
argument_list|,
name|M_PROATM
argument_list|)
expr_stmt|;
name|proatm
operator|->
name|connection
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|proatm
operator|->
name|fixbuf
operator|!=
name|NULL
condition|)
name|contigfree
argument_list|(
operator|(
name|void
operator|*
operator|)
name|proatm
operator|->
name|fixbuf
argument_list|,
operator|(
name|PROATM_FIXPAGES
operator|*
name|PAGE_SIZE
operator|)
argument_list|,
name|M_PROATM
argument_list|)
expr_stmt|;
name|proatm
operator|->
name|fixbuf
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|proatm
operator|->
name|scq_cluster_size
operator|!=
name|NULL
condition|)
name|contigfree
argument_list|(
operator|(
name|void
operator|*
operator|)
name|proatm
operator|->
name|scq_cluster_base
argument_list|,
name|proatm
operator|->
name|scq_cluster_size
argument_list|,
name|M_PROATM
argument_list|)
expr_stmt|;
name|proatm
operator|->
name|scq_cluster_base
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************************  *  *  Write to Nicstar Register  *  */
end_comment

begin_function
specifier|static
name|void
name|proatm_reg_wr
parameter_list|(
name|proatm_reg_t
modifier|*
specifier|const
name|proatm
parameter_list|,
name|u_int32_t
name|data
parameter_list|,
name|vm_offset_t
name|reg
parameter_list|)
block|{
operator|*
operator|(
specifier|volatile
name|u_int32_t
operator|*
operator|)
operator|(
name|proatm
operator|->
name|virt_baseaddr
operator|+
name|reg
operator|)
operator|=
name|data
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************************  *  *  Read from Nicstar Register  *  */
end_comment

begin_function
specifier|static
name|u_int32_t
name|proatm_reg_rd
parameter_list|(
name|proatm_reg_t
modifier|*
specifier|const
name|proatm
parameter_list|,
name|vm_offset_t
name|reg
parameter_list|)
block|{
return|return
operator|*
operator|(
specifier|volatile
name|u_int32_t
operator|*
operator|)
operator|(
name|proatm
operator|->
name|virt_baseaddr
operator|+
name|reg
operator|)
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  *  *  Write one to four words to SRAM  *  *    writes one to four words into sram starting at "sram_location"  *    the SRAM address is a word (4-byte) address   *  *    returns -1 if sram location is out of range.  *    returns count, if count is not in the range from 1-4.  *    returns 0 if parameters were acceptable  */
end_comment

begin_function
specifier|static
name|int32_t
name|proatm_sram_wr
parameter_list|(
name|proatm_reg_t
modifier|*
specifier|const
name|proatm
parameter_list|,
name|u_int32_t
name|address
parameter_list|,
name|int
name|count
parameter_list|,
name|u_int32_t
name|data0
parameter_list|,
name|u_int32_t
name|data1
parameter_list|,
name|u_int32_t
name|data2
parameter_list|,
name|u_int32_t
name|data3
parameter_list|)
block|{
if|if
condition|(
name|address
operator|>=
name|proatm
operator|->
name|sram_size
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* bad address */
if|if
condition|(
name|proatm_status_wait
argument_list|(
name|proatm
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
switch|switch
condition|(
operator|--
name|count
condition|)
block|{
case|case
literal|3
case|:
name|proatm_reg_wr
argument_list|(
name|proatm
argument_list|,
name|data3
argument_list|,
name|REGDR3
argument_list|)
expr_stmt|;
comment|/* drop down to do others */
case|case
literal|2
case|:
name|proatm_reg_wr
argument_list|(
name|proatm
argument_list|,
name|data2
argument_list|,
name|REGDR2
argument_list|)
expr_stmt|;
comment|/* drop down to do others */
case|case
literal|1
case|:
name|proatm_reg_wr
argument_list|(
name|proatm
argument_list|,
name|data1
argument_list|,
name|REGDR1
argument_list|)
expr_stmt|;
comment|/* drop down to do others */
case|case
literal|0
case|:
name|proatm_reg_wr
argument_list|(
name|proatm
argument_list|,
name|data0
argument_list|,
name|REGDR0
argument_list|)
expr_stmt|;
comment|/* load last data item */
break|break;
comment|/* done loading values */
default|default:
return|return
operator|(
name|count
operator|)
return|;
comment|/* nothing to do */
block|}
name|proatm_reg_wr
argument_list|(
name|proatm
argument_list|,
name|IDT_CMD_WRITE_SRAM
operator||
operator|(
name|address
operator|<<
literal|2
operator|)
operator||
name|count
argument_list|,
name|REGCMD
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  *  Read one word from SRAM  *  *    reads one word of sram at "sram_location" and places the value  *    in "answer_pointer"  *  *    returns -1 if sram location is out of range.  *    returns 0 if parameters were acceptable  */
end_comment

begin_function
specifier|static
name|int32_t
name|proatm_sram_rd
parameter_list|(
name|proatm_reg_t
modifier|*
specifier|const
name|proatm
parameter_list|,
name|u_int32_t
name|address
parameter_list|,
name|u_int32_t
modifier|*
name|data0
parameter_list|)
block|{
if|if
condition|(
name|address
operator|>=
name|proatm
operator|->
name|sram_size
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* bad address */
if|if
condition|(
name|proatm_status_wait
argument_list|(
name|proatm
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|proatm_reg_wr
argument_list|(
name|proatm
argument_list|,
name|IDT_CMD_READ_SRAM
operator||
operator|(
name|address
operator|<<
literal|2
operator|)
argument_list|,
name|REGCMD
argument_list|)
expr_stmt|;
if|if
condition|(
name|proatm_status_wait
argument_list|(
name|proatm
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
operator|*
name|data0
operator|=
name|proatm_reg_rd
argument_list|(
name|proatm
argument_list|,
name|REGDR0
argument_list|)
expr_stmt|;
comment|/* save word */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* for debug purpose */
end_comment

begin_function
name|u_int32_t
name|nicsr
parameter_list|(
name|proatm_reg_t
modifier|*
specifier|const
name|proatm
parameter_list|,
name|u_int32_t
name|address
parameter_list|)
block|{
name|proatm_reg_wr
argument_list|(
name|proatm
argument_list|,
name|IDT_CMD_READ_SRAM
operator||
operator|(
name|address
operator|<<
literal|2
operator|)
argument_list|,
name|REGCMD
argument_list|)
expr_stmt|;
if|if
condition|(
name|proatm_status_wait
argument_list|(
name|proatm
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|proatm_reg_rd
argument_list|(
name|proatm
argument_list|,
name|REGDR0
argument_list|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|XDEBUG
operator|==
literal|2
end_if

begin_function
name|void
name|bprintf
parameter_list|(
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|char
name|buf
index|[
literal|0x400
index|]
decl_stmt|;
name|int32_t
name|len
init|=
literal|0
decl_stmt|;
name|buf
index|[
literal|0x3ff
index|]
operator|=
literal|'\0'
expr_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|vsprintf
argument_list|(
name|buf
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|proatm_logptr
operator|+
name|len
operator|+
literal|1
operator|<
name|proatm_log
operator|+
name|PROATM_LOG_SIZE
condition|)
block|{
name|memcpy
argument_list|(
name|proatm_logptr
argument_list|,
name|buf
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|proatm_logptr
operator|+=
name|len
expr_stmt|;
block|}
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|print_proatm_log
parameter_list|(
name|void
parameter_list|)
block|{
name|printf
argument_list|(
literal|"\n************ PROATM LOG ************\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|proatm_log
argument_list|)
expr_stmt|;
name|proatm_logptr
operator|=
name|proatm_log
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*******************************************************************************  *  *  Open connection in PROATM Receive Connection Table  *  *  in:  PROATM device, VPI, VCI, opflag  * out:  zero = success  *  */
end_comment

begin_function
specifier|static
name|int32_t
name|proatm_connect_rxopen
parameter_list|(
name|PROATM
modifier|*
name|proatm
parameter_list|,
name|CONNECTION
modifier|*
name|connection
parameter_list|)
block|{
name|int32_t
name|addr
decl_stmt|;
name|int32_t
name|word1
decl_stmt|;
if|if
condition|(
name|proatm_check_vc
argument_list|(
name|proatm
argument_list|,
name|connection
operator|->
name|vpi
argument_list|,
name|connection
operator|->
name|vci
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|addr
operator|=
name|proatm
operator|->
name|rct
operator|+
name|connection
operator|->
name|number
operator|*
name|IDT_RCT_ENTRY_SIZE
expr_stmt|;
comment|/*      switch (connection->aal) {     case IDTAAL0:         word1 = IDT_RCTE_CONNECTOPEN | IDT_RCTE_AAL0;         break;     case IDTAAL1:         word1 = IDT_RCTE_CONNECTOPEN | IDT_RCTE_AAL0;         break;     case IDTAAL3_4:         word1 = IDT_RCTE_CONNECTOPEN | IDT_RCTE_AAL34;         break;     case IDTAAL5:         word1 = IDT_RCTE_CONNECTOPEN | IDT_RCTE_AAL5;         break;     default:         return (1);     } */
name|word1
operator|=
name|IDT_RCTE_CONNECTOPEN
operator||
name|IDT_RCTE_AAL5
expr_stmt|;
comment|/* no other AAL supported at this time */
ifdef|#
directive|ifdef
name|RCQ_SUPPORT
name|word1
operator||=
name|IDT_RCTE_RAWCELLINTEN
expr_stmt|;
endif|#
directive|endif
name|proatm_sram_wr
argument_list|(
name|proatm
argument_list|,
name|addr
argument_list|,
literal|4
argument_list|,
name|word1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  *  Close connection in PROATM Receive Connection Table  *  *  in:  PROATM device, VPI, VCI  * out:  zero = success  *  */
end_comment

begin_function
specifier|static
name|int32_t
name|proatm_connect_rxclose
parameter_list|(
name|PROATM
modifier|*
name|proatm
parameter_list|,
name|CONNECTION
modifier|*
name|connection
parameter_list|)
block|{
name|int32_t
name|addr
decl_stmt|;
if|if
condition|(
name|proatm_check_vc
argument_list|(
name|proatm
argument_list|,
name|connection
operator|->
name|vpi
argument_list|,
name|connection
operator|->
name|vci
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|addr
operator|=
name|proatm
operator|->
name|rct
operator|+
name|connection
operator|->
name|number
operator|*
name|IDT_RCT_ENTRY_SIZE
expr_stmt|;
if|if
condition|(
name|proatm_status_wait
argument_list|(
name|proatm
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|proatm_reg_wr
argument_list|(
name|proatm
argument_list|,
name|IDT_CMD_CLOSE_CONNECTION
operator||
name|addr
operator|<<
literal|2
argument_list|,
name|REGCMD
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  *    proatm_add_buf    ( card, mbuf1, mbuf2, which_queue)  *   *    This adds two buffers to the specified queue. This uses the  *    mbuf address as handle and the buffer physical address must be  *    the DMA address.  *  *    returns -1 if queue is full, the address is not word aligned, or  *    a invalid queue is specified  *    returns 0 if parameters were acceptable  */
end_comment

begin_function
specifier|static
name|int32_t
name|proatm_add_buf
parameter_list|(
name|proatm_reg_t
modifier|*
specifier|const
name|proatm
parameter_list|,
name|struct
name|mbuf
modifier|*
name|buf0
parameter_list|,
name|struct
name|mbuf
modifier|*
name|buf1
parameter_list|,
name|u_int32_t
name|rfbq
parameter_list|)
block|{
name|u_int32_t
name|stat_val
decl_stmt|;
name|u_int32_t
name|val0
decl_stmt|,
name|val1
decl_stmt|,
name|val2
decl_stmt|,
name|val3
decl_stmt|;
name|stat_val
operator|=
name|proatm_reg_rd
argument_list|(
name|proatm
argument_list|,
name|REGSTAT
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|rfbq
condition|)
block|{
case|case
literal|0
case|:
if|if
condition|(
operator|(
name|stat_val
operator|&
name|IDT_STAT_FRAC0_MASK
operator|)
operator|==
name|IDT_STAT_FRAC0_MASK
condition|)
return|return
operator|-
literal|1
return|;
comment|/*small-buffer queue is full */
break|break;
case|case
literal|1
case|:
if|if
condition|(
operator|(
name|stat_val
operator|&
name|IDT_STAT_FRAC1_MASK
operator|)
operator|==
name|IDT_STAT_FRAC1_MASK
condition|)
return|return
operator|-
literal|1
return|;
comment|/*large-buffer queue is full */
break|break;
default|default:
return|return
operator|-
literal|1
return|;
comment|/* we manage RFBQ0 and RFBQ1 only */
block|}
if|if
condition|(
operator|!
name|buf0
operator|||
operator|!
name|buf1
operator|||
operator|(
call|(
name|u_int32_t
call|)
argument_list|(
name|buf0
operator|->
name|m_data
argument_list|)
operator|&
literal|0x3
operator|)
operator|||
operator|(
call|(
name|u_int32_t
call|)
argument_list|(
name|buf1
operator|->
name|m_data
argument_list|)
operator|&
literal|0x3
operator|)
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* buffers must be word aligned */
block|}
if|if
condition|(
name|proatm
operator|->
name|raw_headm
operator|==
name|NULL
condition|)
comment|/* raw cell buffer pointer not initialized */
if|if
condition|(
name|rfbq
operator|==
literal|1
condition|)
block|{
name|proatm
operator|->
name|raw_headm
operator|=
name|buf0
expr_stmt|;
name|proatm
operator|->
name|raw_ch
operator|=
operator|(
name|rcqe
operator|*
operator|)
name|buf0
operator|->
name|m_data
expr_stmt|;
name|proatm
operator|->
name|raw_headp
operator|=
name|vtophys
argument_list|(
name|buf0
operator|->
name|m_data
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|proatm_status_wait
argument_list|(
name|proatm
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|val0
operator|=
operator|(
name|u_int32_t
operator|)
name|buf0
expr_stmt|;
comment|/* mbuf address is handle */
name|val1
operator|=
name|vtophys
argument_list|(
name|buf0
operator|->
name|m_data
argument_list|)
expr_stmt|;
comment|/* DMA addr of buff1 */
name|val2
operator|=
operator|(
name|u_int32_t
operator|)
name|buf1
expr_stmt|;
comment|/* mbuf address is handle */
name|val3
operator|=
name|vtophys
argument_list|(
name|buf1
operator|->
name|m_data
argument_list|)
expr_stmt|;
comment|/* DMA addr of buff2 */
name|proatm_reg_wr
argument_list|(
name|proatm
argument_list|,
name|val0
argument_list|,
name|REGDR0
argument_list|)
expr_stmt|;
name|proatm_reg_wr
argument_list|(
name|proatm
argument_list|,
name|val1
argument_list|,
name|REGDR1
argument_list|)
expr_stmt|;
name|proatm_reg_wr
argument_list|(
name|proatm
argument_list|,
name|val2
argument_list|,
name|REGDR2
argument_list|)
expr_stmt|;
name|proatm_reg_wr
argument_list|(
name|proatm
argument_list|,
name|val3
argument_list|,
name|REGDR3
argument_list|)
expr_stmt|;
name|proatm_reg_wr
argument_list|(
name|proatm
argument_list|,
name|IDT_CMD_WRITE_FREEBUFQ
operator||
name|rfbq
argument_list|,
name|REGCMD
argument_list|)
expr_stmt|;
name|proatm_mcheck_add
argument_list|(
name|proatm
argument_list|,
name|buf0
argument_list|)
expr_stmt|;
name|proatm_mcheck_add
argument_list|(
name|proatm
argument_list|,
name|buf1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  *  *    proatm_util_rd    ( card, util_location, answer_pointer )  *  *    reads one byte from the utility bus at "util_location" and places the  *    value in "answer_pointer"  *  *    returns -1 if util location is out of range.  *    returns 0 if parameters were acceptable  */
end_comment

begin_function
specifier|static
name|int32_t
name|proatm_util_rd
parameter_list|(
name|proatm_reg_t
modifier|*
specifier|const
name|proatm
parameter_list|,
name|u_int32_t
name|address
parameter_list|,
name|u_int32_t
modifier|*
name|data
parameter_list|)
block|{
if|if
condition|(
name|address
operator|>=
literal|0x81
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* bad address */
if|if
condition|(
name|proatm_status_wait
argument_list|(
name|proatm
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|proatm_reg_wr
argument_list|(
name|proatm
argument_list|,
name|IDT_CMD_READ_UTILITY_CS0
operator||
name|address
argument_list|,
name|REGCMD
argument_list|)
expr_stmt|;
if|if
condition|(
name|proatm_status_wait
argument_list|(
name|proatm
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
operator|*
name|data
operator|=
name|proatm_reg_rd
argument_list|(
name|proatm
argument_list|,
name|REGDR0
argument_list|)
operator|&
literal|0xff
expr_stmt|;
comment|/* return word */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  *  *    proatm_util_wr    ( card, util location, data )  *  *    writes one byte to the utility bus at "util_location"   *  *    returns -1 if util location is out of range.  *    returns 0 if parameters were acceptable  */
end_comment

begin_function
specifier|static
name|int32_t
name|proatm_util_wr
parameter_list|(
name|proatm_reg_t
modifier|*
specifier|const
name|proatm
parameter_list|,
name|u_int32_t
name|address
parameter_list|,
name|u_int32_t
name|data
parameter_list|)
block|{
if|if
condition|(
name|address
operator|>=
literal|0x81
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* bad address */
if|if
condition|(
name|proatm_status_wait
argument_list|(
name|proatm
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|proatm_reg_wr
argument_list|(
name|proatm
argument_list|,
name|data
operator|&
literal|0xff
argument_list|,
name|REGDR0
argument_list|)
expr_stmt|;
name|proatm_reg_wr
argument_list|(
name|proatm
argument_list|,
name|IDT_CMD_WRITE_UTILITY_CS0
operator||
name|address
argument_list|,
name|REGCMD
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  *  *    proatm_eeprom_byte_rd ( card , byte_location, len )  *  *    reads one byte from the utility bus at "byte_location" and return the  *    value as an integer.   */
end_comment

begin_function
specifier|static
name|u_int8_t
name|proatm_eeprom_byte_rd
parameter_list|(
name|proatm_reg_t
modifier|*
specifier|const
name|proatm
parameter_list|,
name|u_int32_t
name|address
parameter_list|)
block|{
specifier|volatile
name|u_int32_t
name|gp
init|=
name|proatm_reg_rd
argument_list|(
name|proatm
argument_list|,
name|REGGP
argument_list|)
operator|&
literal|0xfffffff8
decl_stmt|;
name|int32_t
name|i
decl_stmt|,
name|value
init|=
literal|0
decl_stmt|,
name|command
init|=
literal|3
decl_stmt|;
name|DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
comment|/* make sure idle */
name|proatm_reg_wr
argument_list|(
name|proatm
argument_list|,
name|gp
operator||
name|IDT_GP_EECLK
operator||
name|IDT_GP_EECS
argument_list|,
name|REGGP
argument_list|)
expr_stmt|;
comment|/* CS and Clock high */
name|DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
comment|/* toggle in  READ CMD (00000011) */
for|for
control|(
name|i
operator|=
literal|7
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|proatm_reg_wr
argument_list|(
name|proatm
argument_list|,
name|gp
operator||
operator|(
operator|(
name|command
operator|>>
name|i
operator|)
operator|&
literal|1
operator|)
argument_list|,
name|REGGP
argument_list|)
expr_stmt|;
comment|/* Clock low */
name|DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|proatm_reg_wr
argument_list|(
name|proatm
argument_list|,
name|gp
operator||
name|IDT_GP_EECLK
operator||
operator|(
operator|(
name|command
operator|>>
name|i
operator|)
operator|&
literal|1
operator|)
argument_list|,
name|REGGP
argument_list|)
expr_stmt|;
comment|/* Clock high */
name|DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
block|}
comment|/* toggle in address */
for|for
control|(
name|i
operator|=
literal|7
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|proatm_reg_wr
argument_list|(
name|proatm
argument_list|,
name|gp
operator||
operator|(
operator|(
name|address
operator|>>
name|i
operator|)
operator|&
literal|1
operator|)
argument_list|,
name|REGGP
argument_list|)
expr_stmt|;
comment|/* Clock low */
name|DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|proatm_reg_wr
argument_list|(
name|proatm
argument_list|,
name|gp
operator||
name|IDT_GP_EECLK
operator||
operator|(
operator|(
name|address
operator|>>
name|i
operator|)
operator|&
literal|1
operator|)
argument_list|,
name|REGGP
argument_list|)
expr_stmt|;
comment|/* Clock high */
name|DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
block|}
comment|/* read EEPROM data */
for|for
control|(
name|i
operator|=
literal|7
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|proatm_reg_wr
argument_list|(
name|proatm
argument_list|,
name|gp
argument_list|,
name|REGGP
argument_list|)
expr_stmt|;
comment|/* Clock low */
name|DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|value
operator||=
operator|(
name|proatm_reg_rd
argument_list|(
name|proatm
argument_list|,
name|REGGP
argument_list|)
operator|&
name|IDT_GP_EEDI
operator|)
operator|>>
operator|(
literal|16
operator|-
name|i
operator|)
expr_stmt|;
name|proatm_reg_wr
argument_list|(
name|proatm
argument_list|,
name|gp
operator||
name|IDT_GP_EECLK
argument_list|,
name|REGGP
argument_list|)
expr_stmt|;
comment|/* Clock high */
name|DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
block|}
name|proatm_reg_wr
argument_list|(
name|proatm
argument_list|,
name|gp
argument_list|,
name|REGGP
argument_list|)
expr_stmt|;
comment|/* CS and Clock low */
return|return
operator|(
operator|(
name|u_int8_t
operator|)
name|value
operator|)
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  *  *    proatm_eeprom_rd  ( card , eeprom location, memory location, len )  *  *    reads len bytes from the utility bus at "eeprom location" and write them  *    at memory location. this routine is only used to read the MAC address  *    from the EEPROM at boot time.  */
end_comment

begin_function
specifier|static
name|void
name|proatm_eeprom_rd
parameter_list|(
name|proatm_reg_t
modifier|*
specifier|const
name|proatm
parameter_list|,
name|u_int32_t
name|ee_add
parameter_list|,
name|u_int8_t
modifier|*
name|memptr
parameter_list|,
name|u_int32_t
name|len
parameter_list|)
block|{
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
operator|*
name|memptr
operator|++
operator|=
name|proatm_eeprom_byte_rd
argument_list|(
name|proatm
argument_list|,
name|ee_add
operator|++
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  *  Load the card receive buffers  *  *  in:  PROATM device  *  */
end_comment

begin_function
name|void
name|proatm_ld_rcv_buf
parameter_list|(
name|PROATM
modifier|*
name|proatm
parameter_list|,
name|int32_t
name|want_small
parameter_list|,
name|int32_t
name|want_large
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m1
decl_stmt|,
modifier|*
name|m2
decl_stmt|;
name|u_int32_t
name|reg_stat
decl_stmt|;
name|int32_t
name|card_small
decl_stmt|;
name|int32_t
name|card_large
decl_stmt|;
name|int32_t
name|s
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
comment|/* read card current amount of free buffer available */
name|reg_stat
operator|=
name|proatm_reg_rd
argument_list|(
name|proatm
argument_list|,
name|REGSTAT
argument_list|)
expr_stmt|;
name|card_small
operator|=
operator|(
name|reg_stat
operator|&
name|IDT_STAT_FRAC0_MASK
operator|)
operator|>>
literal|11
expr_stmt|;
name|card_large
operator|=
operator|(
name|reg_stat
operator|&
name|IDT_STAT_FRAC1_MASK
operator|)
operator|>>
literal|15
expr_stmt|;
ifdef|#
directive|ifdef
name|FBSD35
comment|/*       * With FreeBSD versions 3.5 and 351, we allocate 2K clusters since      * mbufs are too small (128 Bytes only)       */
while|while
condition|(
name|card_small
operator|<
name|want_small
condition|)
block|{
name|m1
operator|=
name|proatm_mbufcl_get
argument_list|()
expr_stmt|;
if|if
condition|(
name|m1
operator|==
name|NULL
condition|)
break|break;
comment|/* Prepend 32-byte space */
name|m1
operator|->
name|m_data
operator|+=
operator|(
name|MCLBYTES
operator|-
operator|(
name|IDT_B1SIZE
operator|*
literal|48
operator|)
operator|)
expr_stmt|;
name|m1
operator|->
name|m_len
operator|-=
operator|(
name|MCLBYTES
operator|-
operator|(
name|IDT_B1SIZE
operator|*
literal|48
operator|)
operator|)
expr_stmt|;
name|m2
operator|=
name|proatm_mbufcl_get
argument_list|()
expr_stmt|;
if|if
condition|(
name|m2
operator|==
name|NULL
condition|)
block|{
name|m_free
argument_list|(
name|m1
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Prepend 32-byte space */
name|m2
operator|->
name|m_data
operator|+=
operator|(
name|MCLBYTES
operator|-
operator|(
name|IDT_B1SIZE
operator|*
literal|48
operator|)
operator|)
expr_stmt|;
name|m2
operator|->
name|m_len
operator|-=
operator|(
name|MCLBYTES
operator|-
operator|(
name|IDT_B1SIZE
operator|*
literal|48
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|proatm_add_buf
argument_list|(
name|proatm
argument_list|,
name|m1
argument_list|,
name|m2
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"proatm%d: Cannot add buffers to FBQ0, size=%d.\n"
argument_list|,
name|proatm
operator|->
name|unit
argument_list|,
name|card_small
argument_list|)
expr_stmt|;
name|m_free
argument_list|(
name|m1
argument_list|)
expr_stmt|;
name|m_free
argument_list|(
name|m2
argument_list|)
expr_stmt|;
break|break;
block|}
name|card_small
operator|+=
literal|2
expr_stmt|;
block|}
else|#
directive|else
comment|/* get 2-cell buffers if current level of small buffers is below desired level */
while|while
condition|(
name|card_small
operator|<
name|want_small
condition|)
block|{
name|MGETHDR
argument_list|(
name|m1
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m1
operator|==
name|NULL
condition|)
break|break;
name|MGETHDR
argument_list|(
name|m2
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m2
operator|==
name|NULL
condition|)
block|{
name|m_free
argument_list|(
name|m1
argument_list|)
expr_stmt|;
break|break;
block|}
name|MH_ALIGN
argument_list|(
name|m1
argument_list|,
literal|96
argument_list|)
expr_stmt|;
comment|/* word align& allow lots of prepending */
name|MH_ALIGN
argument_list|(
name|m2
argument_list|,
literal|96
argument_list|)
expr_stmt|;
if|if
condition|(
name|proatm_add_buf
argument_list|(
name|proatm
argument_list|,
name|m1
argument_list|,
name|m2
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"proatm%d: Cannot add small buffers, size=%d.\n"
argument_list|,
name|proatm
operator|->
name|unit
argument_list|,
name|card_small
argument_list|)
expr_stmt|;
name|m_free
argument_list|(
name|m1
argument_list|)
expr_stmt|;
name|m_free
argument_list|(
name|m2
argument_list|)
expr_stmt|;
break|break;
block|}
name|card_small
operator|+=
literal|2
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* get 2K clusters if current level of small buffers is below desired level */
while|while
condition|(
name|card_large
operator|<
name|want_large
condition|)
block|{
name|m1
operator|=
name|proatm_mbufcl_get
argument_list|()
expr_stmt|;
if|if
condition|(
name|m1
operator|==
name|NULL
condition|)
break|break;
name|m2
operator|=
name|proatm_mbufcl_get
argument_list|()
expr_stmt|;
if|if
condition|(
name|m2
operator|==
name|NULL
condition|)
block|{
name|m_free
argument_list|(
name|m1
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|proatm_add_buf
argument_list|(
name|proatm
argument_list|,
name|m1
argument_list|,
name|m2
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"proatm%d: Cannot add large buffers, size=%d.\n"
argument_list|,
name|proatm
operator|->
name|unit
argument_list|,
name|card_large
argument_list|)
expr_stmt|;
name|m_free
argument_list|(
name|m1
argument_list|)
expr_stmt|;
name|m_free
argument_list|(
name|m2
argument_list|)
expr_stmt|;
break|break;
block|}
name|card_large
operator|+=
literal|2
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  *  Wait for command to finish  *  *  in:  PROATM device  * out:  zero = success  *  */
end_comment

begin_function
specifier|static
name|int32_t
name|proatm_status_wait
parameter_list|(
name|PROATM
modifier|*
name|proatm
parameter_list|)
block|{
name|int32_t
name|timeout
decl_stmt|;
name|timeout
operator|=
literal|33
operator|*
literal|100
expr_stmt|;
comment|/* allow 100 microseconds timeout */
while|while
condition|(
name|proatm_reg_rd
argument_list|(
name|proatm
argument_list|,
name|REGSTAT
argument_list|)
operator|&
literal|0x200
condition|)
if|if
condition|(
operator|--
name|timeout
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"proatm%d: timeout waiting for device status.\n"
argument_list|,
name|proatm
operator|->
name|unit
argument_list|)
expr_stmt|;
name|proatm
operator|->
name|stats_cmderrors
operator|++
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  *  Log status of system buffers  *  *  in:  PROATM device  *  */
end_comment

begin_function
specifier|static
name|void
name|proatm_status_bufs
parameter_list|(
name|PROATM
modifier|*
name|proatm
parameter_list|)
block|{
name|int32_t
name|card_small
decl_stmt|;
name|int32_t
name|card_large
decl_stmt|;
name|int32_t
name|s
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|card_small
operator|=
name|idt_fbqc_get
argument_list|(
name|proatm_reg_rd
argument_list|(
name|proatm
argument_list|,
name|REGFBQP0
argument_list|)
argument_list|)
expr_stmt|;
name|card_large
operator|=
name|idt_fbqc_get
argument_list|(
name|proatm_reg_rd
argument_list|(
name|proatm
argument_list|,
name|REGFBQP1
argument_list|)
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"proatm%d BUFFER STATUS: small=%d/%d, large=%d/%d.\n"
argument_list|,
name|proatm
operator|->
name|unit
argument_list|,
name|card_small
argument_list|,
name|proatm_sysctl_bufsmall
argument_list|,
name|card_large
argument_list|,
name|proatm_sysctl_buflarge
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  *  Add mbuf into "owned" list  *  *  in:  PROATM device, mbuf  * out:  zero = success  *  */
end_comment

begin_function
specifier|static
name|int32_t
name|proatm_mcheck_add
parameter_list|(
name|PROATM
modifier|*
name|proatm
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|int32_t
name|hpos
decl_stmt|;
name|int32_t
name|s
decl_stmt|;
name|hpos
operator|=
operator|(
operator|(
operator|(
name|int32_t
operator|)
name|m
operator|)
operator|>>
literal|8
operator|)
operator|&
literal|1023
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|m
operator|->
name|m_next
operator|=
name|proatm
operator|->
name|mcheck
index|[
name|hpos
index|]
expr_stmt|;
name|proatm
operator|->
name|mcheck
index|[
name|hpos
index|]
operator|=
name|m
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  *  *  Remove mbuf from "owned" list  *  *  in:  PROATM device, mbuf  * out:  zero = success  *  */
end_comment

begin_function
specifier|static
name|int32_t
name|proatm_mcheck_rem
parameter_list|(
name|PROATM
modifier|*
name|proatm
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|nbuf
decl_stmt|;
name|int32_t
name|hpos
decl_stmt|;
name|int32_t
name|s
decl_stmt|;
name|hpos
operator|=
operator|(
operator|(
operator|(
name|int32_t
operator|)
name|m
operator|)
operator|>>
literal|8
operator|)
operator|&
literal|1023
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|nbuf
operator|=
name|proatm
operator|->
name|mcheck
index|[
name|hpos
index|]
expr_stmt|;
if|if
condition|(
name|nbuf
operator|==
name|m
condition|)
block|{
name|proatm
operator|->
name|mcheck
index|[
name|hpos
index|]
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
while|while
condition|(
name|nbuf
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|nbuf
operator|->
name|m_next
operator|!=
name|m
condition|)
block|{
name|nbuf
operator|=
name|nbuf
operator|->
name|m_next
expr_stmt|;
continue|continue;
block|}
name|nbuf
operator|->
name|m_next
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"proatm%d: Card should not have this mbuf! %x\n"
argument_list|,
name|proatm
operator|->
name|unit
argument_list|,
operator|(
name|int
operator|)
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  *  *  Initialize mbuf "owned" list  *  *  in:  PROATM device  * out:  zero = success  *  */
end_comment

begin_function
specifier|static
name|int32_t
name|proatm_mcheck_init
parameter_list|(
name|PROATM
modifier|*
name|proatm
parameter_list|)
block|{
name|int32_t
name|size
decl_stmt|;
name|int32_t
name|x
decl_stmt|;
name|size
operator|=
name|round_page
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|mbuf
operator|*
argument_list|)
operator|*
name|PROATM_MCHECK_COUNT
argument_list|)
expr_stmt|;
name|proatm
operator|->
name|mcheck
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|*
operator|)
name|proatm_malloc_contig
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|proatm
operator|->
name|mcheck
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
literal|1024
condition|;
name|x
operator|++
control|)
name|proatm
operator|->
name|mcheck
index|[
name|x
index|]
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  *  *  Allocate contiguous, fixed memory  *  *  in:  size in bytes  * out:  pointer, NULL = failure  *  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|proatm_malloc_contig
parameter_list|(
name|int32_t
name|size
parameter_list|)
block|{
name|void
modifier|*
name|retval
decl_stmt|;
name|retval
operator|=
name|contigmalloc
argument_list|(
name|size
argument_list|,
name|M_PROATM
argument_list|,
name|M_NOWAIT
argument_list|,
literal|0x100000
argument_list|,
literal|0xffffffff
argument_list|,
literal|0x2000
argument_list|,
literal|0ul
argument_list|)
expr_stmt|;
name|XPRINT
argument_list|(
literal|"proatm: contig memory allocated %d bytes at %0x\n"
argument_list|,
name|size
argument_list|,
name|retval
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  *  Initialize all TX_QUEUE structures   *  *  in:  PROATM device  * out:  zero = succes  *  */
end_comment

begin_function
specifier|static
name|int32_t
name|proatm_queue_init
parameter_list|(
name|PROATM
modifier|*
name|proatm
parameter_list|)
block|{
name|TX_QUEUE
modifier|*
name|txqueue
decl_stmt|;
name|vm_offset_t
name|scq_base
decl_stmt|;
name|int32_t
name|x
decl_stmt|;
name|proatm
operator|->
name|scq_cluster_size
operator|=
name|proatm
operator|->
name|scd_size
operator|*
name|IDT_SCQ_SIZE
expr_stmt|;
name|proatm
operator|->
name|scq_cluster_base
operator|=
operator|(
name|vm_offset_t
operator|)
name|proatm_malloc_contig
argument_list|(
name|proatm
operator|->
name|scq_cluster_size
argument_list|)
expr_stmt|;
name|scq_base
operator|=
name|proatm
operator|->
name|scq_cluster_base
expr_stmt|;
if|if
condition|(
name|scq_base
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|proatm
operator|->
name|txqueue_free_count
operator|=
name|proatm
operator|->
name|scd_size
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|proatm
operator|->
name|txqueue_free_count
condition|;
name|x
operator|++
control|)
block|{
name|txqueue
operator|=
operator|&
name|proatm
operator|->
name|txqueue
index|[
name|x
index|]
expr_stmt|;
name|txqueue
operator|->
name|mget
operator|=
name|NULL
expr_stmt|;
name|txqueue
operator|->
name|mput
operator|=
name|NULL
expr_stmt|;
name|txqueue
operator|->
name|scd
operator|=
name|proatm
operator|->
name|scd
operator|+
name|x
operator|*
name|IDT_STRUCT_SCD_SIZE
expr_stmt|;
comment|/*word address */
name|txqueue
operator|->
name|scq_base
operator|=
operator|(
name|u_int32_t
operator|*
operator|)
name|scq_base
expr_stmt|;
name|txqueue
operator|->
name|scq_next
operator|=
name|txqueue
operator|->
name|scq_base
expr_stmt|;
name|txqueue
operator|->
name|scq_last
operator|=
name|txqueue
operator|->
name|scq_next
expr_stmt|;
name|txqueue
operator|->
name|scq_cur
operator|=
literal|0
expr_stmt|;
name|txqueue
operator|->
name|rate
operator|=
literal|0
expr_stmt|;
name|proatm
operator|->
name|txqueue_free
index|[
name|x
index|]
operator|=
name|txqueue
expr_stmt|;
comment|/* initialize SCD */
name|proatm_sram_wr
argument_list|(
name|proatm
argument_list|,
name|txqueue
operator|->
name|scd
argument_list|,
literal|4
argument_list|,
name|vtophys
argument_list|(
name|txqueue
operator|->
name|scq_base
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0xffffffff
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|proatm_sram_wr
argument_list|(
name|proatm
argument_list|,
name|txqueue
operator|->
name|scd
operator|+
literal|4
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|proatm_sram_wr
argument_list|(
name|proatm
argument_list|,
name|txqueue
operator|->
name|scd
operator|+
literal|8
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|scq_base
operator|+=
name|IDT_SCQ_SIZE
expr_stmt|;
block|}
comment|/* UBR0 queue */
name|txqueue
operator|=
operator|&
name|proatm
operator|->
name|txqueue_ubr0
expr_stmt|;
name|txqueue
operator|->
name|mget
operator|=
name|NULL
expr_stmt|;
name|txqueue
operator|->
name|mput
operator|=
name|NULL
expr_stmt|;
name|txqueue
operator|->
name|scd
operator|=
name|proatm
operator|->
name|scd_ubr0
expr_stmt|;
name|txqueue
operator|->
name|scq_base
operator|=
operator|(
name|u_int32_t
operator|*
operator|)
name|ALIGN_ADDR
argument_list|(
name|proatm
operator|->
name|scq_ubr0_cluster
argument_list|,
name|IDT_SCQ_SIZE
argument_list|)
expr_stmt|;
name|txqueue
operator|->
name|scq_next
operator|=
name|txqueue
operator|->
name|scq_base
expr_stmt|;
name|txqueue
operator|->
name|scq_last
operator|=
name|txqueue
operator|->
name|scq_next
expr_stmt|;
name|txqueue
operator|->
name|scq_cur
operator|=
literal|0
expr_stmt|;
name|txqueue
operator|->
name|rate
operator|=
literal|0
expr_stmt|;
name|proatm_sram_wr
argument_list|(
name|proatm
argument_list|,
name|proatm
operator|->
name|scd_ubr0
argument_list|,
literal|4
argument_list|,
name|vtophys
argument_list|(
name|proatm
operator|->
name|txqueue_ubr0
operator|.
name|scq_base
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0xffffffff
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|proatm_sram_wr
argument_list|(
name|proatm
argument_list|,
name|proatm
operator|->
name|scd_ubr0
operator|+
literal|4
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|proatm_sram_wr
argument_list|(
name|proatm
argument_list|,
name|proatm
operator|->
name|scd_ubr0
operator|+
literal|8
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|proatm_tct_wr
argument_list|(
name|proatm
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  *  Get mbuf chain from TX_QUEUE  *  *  called by proatm_transmit_top at splimp()  *  *  in:  CONNECTION  * out:  mbuf, NULL = empty  *  */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|proatm_queue_get
parameter_list|(
name|TX_QUEUE
modifier|*
name|txqueue
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
if|if
condition|(
name|txqueue
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* s = splimp(); */
name|m
operator|=
name|txqueue
operator|->
name|mget
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
name|txqueue
operator|->
name|mget
operator|=
name|m
operator|->
name|m_nextpkt
expr_stmt|;
if|if
condition|(
name|txqueue
operator|->
name|mget
operator|==
name|NULL
condition|)
comment|/* is queue empty now? */
name|txqueue
operator|->
name|mput
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* splx(s); */
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  *  Add mbuf chain to connection TX_QUEUE  *  *  in:  CONNECTION, mbuf chain  * out:  zero = succes  *  */
end_comment

begin_function
specifier|static
name|int32_t
name|proatm_queue_put
parameter_list|(
name|CONNECTION
modifier|*
name|connection
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|TX_QUEUE
modifier|*
name|txqueue
decl_stmt|;
name|int32_t
name|s
decl_stmt|;
if|if
condition|(
name|connection
operator|==
name|NULL
condition|)
block|{
comment|/*          * it has already been checked by proatm_transmit,          * that has updated the AAL's counters.          */
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|txqueue
operator|=
name|connection
operator|->
name|queue
expr_stmt|;
if|if
condition|(
name|txqueue
operator|==
name|NULL
condition|)
block|{
comment|/*          * it has already been checked by proatm_transmit,          * that has updated the AAL's counters.          */
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|m
operator|->
name|m_nextpkt
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|KB_ISPKT
argument_list|(
name|m
argument_list|)
condition|)
name|panic
argument_list|(
name|__FUNCTION__
literal|" missing M_PKTHDR"
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
operator|(
expr|struct
name|ifnet
operator|*
operator|)
name|connection
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|header
operator|=
name|NULL
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
if|if
condition|(
name|txqueue
operator|->
name|mput
operator|!=
name|NULL
condition|)
block|{
name|txqueue
operator|->
name|mput
operator|->
name|m_nextpkt
operator|=
name|m
expr_stmt|;
name|txqueue
operator|->
name|mput
operator|=
name|m
expr_stmt|;
block|}
else|else
block|{
comment|/* queue is empty */
name|txqueue
operator|->
name|mget
operator|=
name|m
expr_stmt|;
name|txqueue
operator|->
name|mput
operator|=
name|m
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  *  Flush all connection mbufs from TX_QUEUE  *  *  in:  CONNECTION  * out:  zero = succes  *  */
end_comment

begin_function
specifier|static
name|int32_t
name|proatm_queue_flush
parameter_list|(
name|CONNECTION
modifier|*
name|connection
parameter_list|,
name|int32_t
modifier|*
name|count
parameter_list|)
block|{
name|TX_QUEUE
modifier|*
name|txqueue
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
modifier|*
name|mp
decl_stmt|,
modifier|*
name|mprev
decl_stmt|;
name|int32_t
name|s
decl_stmt|,
name|cnt
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|connection
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|txqueue
operator|=
name|connection
operator|->
name|queue
expr_stmt|;
if|if
condition|(
name|txqueue
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|mprev
operator|=
name|NULL
expr_stmt|;
name|mp
operator|=
operator|&
name|txqueue
operator|->
name|mget
expr_stmt|;
name|m
operator|=
name|txqueue
operator|->
name|mget
expr_stmt|;
while|while
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|KB_ISPKT
argument_list|(
name|m
argument_list|)
operator|&&
operator|(
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|==
operator|(
expr|struct
name|ifnet
operator|*
operator|)
name|connection
operator|)
condition|)
block|{
operator|*
name|mp
operator|=
name|m
operator|->
name|m_nextpkt
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
operator|*
name|mp
expr_stmt|;
name|cnt
operator|++
expr_stmt|;
continue|continue;
block|}
name|mprev
operator|=
name|m
expr_stmt|;
name|mp
operator|=
operator|&
name|mprev
operator|->
name|m_nextpkt
expr_stmt|;
name|m
operator|=
name|mprev
operator|->
name|m_nextpkt
expr_stmt|;
block|}
name|txqueue
operator|->
name|mput
operator|=
name|mprev
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
operator|*
name|count
operator|=
name|cnt
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  *  Calculate number of table positions for CBR connection  *  *  in:  PROATM device, PCR (cells/second)  * out:  table positions needed (minimum = 1)  *  */
end_comment

begin_function
specifier|static
name|int32_t
name|proatm_slots_cbr
parameter_list|(
name|PROATM
modifier|*
name|proatm
parameter_list|,
name|int32_t
name|pcr
parameter_list|)
block|{
name|u_int32_t
name|slots
decl_stmt|;
if|if
condition|(
name|pcr
operator|<=
name|proatm
operator|->
name|max_pcr
operator|/
name|proatm
operator|->
name|tst_num
condition|)
block|{
if|if
condition|(
name|proatm_sysctl_logvcs
condition|)
name|printf
argument_list|(
literal|"proatm_slots_cbr:  CBR pcr %d rounded up to 1 slot\n"
argument_list|,
name|pcr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|slots
operator|=
operator|(
name|pcr
operator|*
name|proatm
operator|->
name|tst_num
operator|)
operator|/
name|proatm
operator|->
name|max_pcr
expr_stmt|;
if|if
condition|(
name|proatm_sysctl_logvcs
condition|)
name|printf
argument_list|(
literal|"proatm_slots_cbr: CBR cell rate rounded down to %d from %d\n"
argument_list|,
call|(
name|int32_t
call|)
argument_list|(
operator|(
name|slots
operator|*
name|proatm
operator|->
name|max_pcr
operator|)
operator|/
name|proatm
operator|->
name|tst_num
argument_list|)
argument_list|,
name|pcr
argument_list|)
expr_stmt|;
return|return
operator|(
name|slots
operator|)
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  *  Add TX QUEUE pointer to slots in CBR table  *  *  in:  PROATM device, TX_QUEUE, number slots  * out:  zero = success  *  */
end_comment

begin_function
specifier|static
name|int32_t
name|proatm_slots_add
parameter_list|(
name|PROATM
modifier|*
name|proatm
parameter_list|,
name|TX_QUEUE
modifier|*
name|queue
parameter_list|,
name|int32_t
name|slots
parameter_list|,
name|int32_t
name|conn
parameter_list|)
block|{
name|TX_QUEUE
modifier|*
name|curval
decl_stmt|;
name|int32_t
name|p_max
decl_stmt|;
comment|/* extra precision slots maximum */
name|int32_t
name|p_spc
decl_stmt|;
comment|/* extra precision spacing value */
name|int32_t
name|p_ptr
decl_stmt|;
comment|/* extra precision pointer */
name|int32_t
name|qptr
decl_stmt|,
name|qmax
decl_stmt|;
name|int32_t
name|qlast
decl_stmt|;
if|if
condition|(
name|slots
operator|<
literal|1
condition|)
return|return
operator|-
literal|1
return|;
name|qmax
operator|=
name|proatm
operator|->
name|tst_num
expr_stmt|;
name|p_max
operator|=
name|qmax
operator|<<
literal|8
expr_stmt|;
name|p_spc
operator|=
name|p_max
operator|/
name|slots
expr_stmt|;
name|p_ptr
operator|=
name|p_spc
operator|>>
literal|1
expr_stmt|;
comment|/* use half spacing for start point */
name|qptr
operator|=
name|p_ptr
operator|>>
literal|8
expr_stmt|;
name|qlast
operator|=
name|qptr
expr_stmt|;
name|XPRINT
argument_list|(
literal|"proatm_slots_add: p_max = %d\n"
argument_list|,
name|p_max
argument_list|)
expr_stmt|;
name|XPRINT
argument_list|(
literal|"proatm_slots_add: p_spc = %d\n"
argument_list|,
name|p_spc
argument_list|)
expr_stmt|;
name|XPRINT
argument_list|(
literal|"proatm_slots_add: p_ptr = %d\n"
argument_list|,
name|p_ptr
argument_list|)
expr_stmt|;
name|XPRINT
argument_list|(
literal|"proatm_slots_add: qptr  = %d\n"
argument_list|,
name|qptr
argument_list|)
expr_stmt|;
while|while
condition|(
name|slots
condition|)
block|{
if|if
condition|(
name|qptr
operator|>=
name|qmax
condition|)
name|qptr
operator|-=
name|qmax
expr_stmt|;
comment|/* handle wrap for empty slot choosing */
name|curval
operator|=
name|proatm
operator|->
name|tst_slot
index|[
name|qptr
index|]
expr_stmt|;
if|if
condition|(
name|curval
operator|!=
name|NULL
condition|)
block|{
comment|/* this slot has CBR, so try next */
name|qptr
operator|++
expr_stmt|;
comment|/* next slot */
continue|continue;
block|}
name|XPRINT
argument_list|(
literal|"proatm_slots_add: using qptr %d (%d)\n"
argument_list|,
name|qptr
argument_list|,
name|qptr
operator|-
name|qlast
argument_list|)
expr_stmt|;
name|qlast
operator|=
name|qptr
expr_stmt|;
name|proatm
operator|->
name|tst_slot
index|[
name|qptr
index|]
operator|=
name|queue
expr_stmt|;
name|proatm_sram_wr
argument_list|(
name|proatm
argument_list|,
name|proatm
operator|->
name|tst
operator|+
name|qptr
argument_list|,
literal|1
argument_list|,
name|IDT_TST_OPCODE_FIXED
operator||
name|conn
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|slots
operator|--
expr_stmt|;
name|p_ptr
operator|+=
name|p_spc
expr_stmt|;
if|if
condition|(
name|p_ptr
operator|>=
name|p_max
condition|)
name|p_ptr
operator|-=
name|p_max
expr_stmt|;
comment|/* main pointer wrap */
name|qptr
operator|=
name|p_ptr
operator|>>
literal|8
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*       Extra precision pointer is used in order to handle cases where  *       fractional slot spacing causes a large area of slots to be filled.  *       This can cause further CBR circuits to get slots that have very  *       poor spacing.  *  */
end_comment

begin_comment
comment|/*******************************************************************************  *  *  Remove TX QUEUE pointer from slots in CBR table  *  *  in:  PROATM device, TX_QUEUE  * out:  number of CBR slots released  *  */
end_comment

begin_function
specifier|static
name|int32_t
name|proatm_slots_rem
parameter_list|(
name|PROATM
modifier|*
name|proatm
parameter_list|,
name|TX_QUEUE
modifier|*
name|queue
parameter_list|)
block|{
name|int32_t
name|qptr
decl_stmt|,
name|qmax
decl_stmt|;
name|int32_t
name|slots
decl_stmt|;
name|qmax
operator|=
name|proatm
operator|->
name|tst_num
expr_stmt|;
name|slots
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|qptr
operator|=
literal|0
init|;
name|qptr
operator|<
name|qmax
condition|;
name|qptr
operator|++
control|)
block|{
if|if
condition|(
name|proatm
operator|->
name|tst_slot
index|[
name|qptr
index|]
operator|!=
name|queue
condition|)
continue|continue;
name|proatm
operator|->
name|tst_slot
index|[
name|qptr
index|]
operator|=
name|NULL
expr_stmt|;
name|proatm_sram_wr
argument_list|(
name|proatm
argument_list|,
name|proatm
operator|->
name|tst
operator|+
name|qptr
argument_list|,
literal|1
argument_list|,
name|IDT_TST_OPCODE_VARIABLE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|slots
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|slots
operator|)
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  *  Initialize the ABRVBR DTST tables  *  *  in:  PROATM device  */
end_comment

begin_function
specifier|static
name|void
name|proatm_dtst_init
parameter_list|(
name|PROATM
modifier|*
name|proatm
parameter_list|)
block|{
name|u_int32_t
name|j
decl_stmt|;
name|proatm_reg_wr
argument_list|(
name|proatm
argument_list|,
name|PROATM_ABRSTD_SIZE
operator||
operator|(
name|proatm
operator|->
name|dtst
operator|<<
literal|2
operator|)
argument_list|,
name|REGABRSTD
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|PROATM_DTST_SIZE
condition|;
name|j
operator|++
control|)
block|{
name|proatm_sram_wr
argument_list|(
name|proatm
argument_list|,
name|proatm
operator|->
name|dtst
operator|+
name|j
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  *  Initialize the TST table  *  *  in:  PROATM device  *  out:  zero = success  */
end_comment

begin_function
specifier|static
name|int32_t
name|proatm_tst_init
parameter_list|(
name|PROATM
modifier|*
name|proatm
parameter_list|)
block|{
name|int32_t
name|j
decl_stmt|;
name|u_int32_t
name|data
decl_stmt|;
name|proatm
operator|->
name|tst_free_entries
operator|=
name|proatm
operator|->
name|tst_num
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|proatm
operator|->
name|tst_num
condition|;
name|j
operator|++
control|)
name|proatm_sram_wr
argument_list|(
name|proatm
argument_list|,
name|proatm
operator|->
name|tst
operator|+
name|j
argument_list|,
literal|1
argument_list|,
name|IDT_TST_OPCODE_VARIABLE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|data
operator|=
name|IDT_TST_OPCODE_END
operator||
operator|(
name|proatm
operator|->
name|tst
operator|<<
literal|2
operator|)
expr_stmt|;
name|proatm_sram_wr
argument_list|(
name|proatm
argument_list|,
name|proatm
operator|->
name|tst
operator|+
name|proatm
operator|->
name|tst_num
argument_list|,
literal|1
argument_list|,
name|data
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|proatm
operator|->
name|tst_num
condition|;
name|j
operator|++
control|)
name|proatm
operator|->
name|tst_slot
index|[
name|j
index|]
operator|=
name|NULL
expr_stmt|;
name|proatm_reg_wr
argument_list|(
name|proatm
argument_list|,
operator|(
name|proatm
operator|->
name|tst
operator|<<
literal|2
operator|)
argument_list|,
name|REGTSTB
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  *  Initialize the Rate Tables  *  *  in:  PROATM device  *  out:  zero = success  */
end_comment

begin_function
specifier|static
name|void
name|proatm_rate_init
parameter_list|(
name|PROATM
modifier|*
name|proatm
parameter_list|)
block|{
name|u_int32_t
modifier|*
name|abr_vbr_rate_tables
decl_stmt|;
name|int32_t
name|j
decl_stmt|;
if|if
condition|(
name|proatm
operator|->
name|flg_25
condition|)
name|abr_vbr_rate_tables
operator|=
name|abr_vbr_rate_tables_25Mb
expr_stmt|;
else|else
name|abr_vbr_rate_tables
operator|=
name|abr_vbr_rate_tables_155Mb
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|abr_vbr_rate_tables_len
condition|;
name|j
operator|++
control|)
block|{
name|proatm_sram_wr
argument_list|(
name|proatm
argument_list|,
operator|(
name|proatm
operator|->
name|rate
operator|+
name|j
operator|)
argument_list|,
literal|1
argument_list|,
name|abr_vbr_rate_tables
index|[
name|j
index|]
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|proatm_reg_wr
argument_list|(
name|proatm
argument_list|,
name|proatm
operator|->
name|rate
operator|<<
literal|2
argument_list|,
name|REGRTBL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compute (scr<<16)/pcr */
end_comment

begin_function
specifier|static
name|u_int16_t
name|scr_on_pcr
parameter_list|(
name|u_int32_t
name|scr
parameter_list|,
name|u_int32_t
name|pcr
parameter_list|)
block|{
name|u_int32_t
name|q
init|=
literal|0
decl_stmt|;
name|scr
operator|<<=
literal|8
expr_stmt|;
name|q
operator|=
name|scr
operator|/
name|pcr
expr_stmt|;
name|scr
operator|=
operator|(
name|scr
operator|%
name|pcr
operator|)
operator|<<
literal|8
expr_stmt|;
return|return
operator|(
name|q
operator|<<
literal|8
operator|)
operator||
operator|(
name|scr
operator|/
name|pcr
operator|)
return|;
block|}
end_function

begin_comment
comment|/* translate rate to ATM Forum rate   * 2^e (1+m/512) = rate   => m = rate * 2^(9-e) - 512  */
end_comment

begin_function
specifier|static
name|u_int16_t
name|u32_to_afr
parameter_list|(
name|u_int32_t
name|rate
parameter_list|)
block|{
name|u_int16_t
name|m
decl_stmt|,
name|e
decl_stmt|;
name|u_int32_t
name|mask
decl_stmt|;
if|if
condition|(
name|rate
operator|==
literal|0
condition|)
return|return
literal|0
return|;
for|for
control|(
name|mask
operator|=
literal|0x80000000
operator|,
name|e
operator|=
literal|31
init|;
name|mask
condition|;
name|mask
operator|>>=
literal|1
operator|,
name|e
operator|--
control|)
if|if
condition|(
name|rate
operator|&
name|mask
condition|)
break|break;
name|m
operator|=
name|e
operator|>=
literal|9
condition|?
name|rate
operator|>>
operator|(
name|e
operator|-
literal|9
operator|)
else|:
name|rate
operator|<<
operator|(
literal|9
operator|-
name|e
operator|)
expr_stmt|;
name|m
operator|-=
literal|512
expr_stmt|;
return|return
operator|(
literal|1
operator|<<
literal|14
operator||
name|e
operator|<<
literal|9
operator||
name|m
operator|)
return|;
block|}
end_function

begin_comment
comment|/*   * First transform rate to ATM fixed point format (afr)  * Then find the index corresponding to afr into log_to_conv table  */
end_comment

begin_function
specifier|static
name|u_int8_t
name|ns_rate2log
parameter_list|(
name|PROATM
modifier|*
name|proatm
parameter_list|,
name|u_int32_t
name|rate
parameter_list|)
block|{
name|u_int16_t
name|afr_rate
init|=
name|u32_to_afr
argument_list|(
name|rate
argument_list|)
decl_stmt|,
name|afr_value
decl_stmt|;
name|u_int32_t
name|data
decl_stmt|;
name|u_int8_t
name|lower
init|=
literal|0
decl_stmt|,
name|upper
init|=
literal|255
decl_stmt|,
name|mid
decl_stmt|;
name|u_int32_t
modifier|*
name|rate_table
decl_stmt|;
if|if
condition|(
name|proatm
operator|->
name|flg_25
condition|)
name|rate_table
operator|=
name|abr_vbr_rate_tables_25Mb
expr_stmt|;
else|else
name|rate_table
operator|=
name|abr_vbr_rate_tables_155Mb
expr_stmt|;
comment|/* We could use the rate2log table but this content research gives better precision */
while|while
condition|(
literal|1
condition|)
block|{
name|mid
operator|=
call|(
name|u_int8_t
call|)
argument_list|(
operator|(
name|lower
operator|+
name|upper
operator|)
operator|>>
literal|1
argument_list|)
expr_stmt|;
name|data
operator|=
name|rate_table
index|[
name|mid
index|]
expr_stmt|;
name|afr_value
operator|=
call|(
name|u_int16_t
call|)
argument_list|(
name|data
operator|>>
literal|17
argument_list|)
expr_stmt|;
comment|/* extract cps from table */
if|if
condition|(
operator|(
name|afr_rate
operator|==
name|afr_value
operator|)
operator|||
operator|(
name|upper
operator|<=
name|lower
operator|)
condition|)
break|break;
elseif|else
if|if
condition|(
name|afr_rate
operator|>
name|afr_value
condition|)
name|lower
operator|=
name|mid
operator|+
literal|1
expr_stmt|;
else|else
name|upper
operator|=
name|mid
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|afr_value
operator|>
name|afr_rate
condition|)
name|mid
operator|--
expr_stmt|;
return|return
operator|(
name|mid
operator|)
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  *  Write TCT entry  *  *  in:  PROATM device, connection descriptor, connection number  *  out:  zero = success  *  */
end_comment

begin_function
specifier|static
name|int32_t
name|proatm_tct_wr
parameter_list|(
name|PROATM
modifier|*
name|proatm
parameter_list|,
name|int32_t
name|conn
parameter_list|)
block|{
name|CONNECTION
modifier|*
name|connection
init|=
operator|&
name|proatm
operator|->
name|connection
index|[
name|conn
index|]
decl_stmt|;
name|u_int32_t
name|w0
decl_stmt|,
name|w1
decl_stmt|,
name|w2
decl_stmt|,
name|w3
decl_stmt|,
name|w4
decl_stmt|,
name|w5
decl_stmt|,
name|w6
decl_stmt|,
name|w7
decl_stmt|;
comment|/*    u_int32_t             air_tbl, rdf_tbl, cdf_tbl;*/
name|u_int16_t
name|pcr_token
decl_stmt|;
switch|switch
condition|(
name|connection
operator|->
name|class
condition|)
block|{
case|case
name|NICUBR0
case|:
name|w0
operator|=
name|IDT_TCTE_TYPE_UBR
operator||
name|proatm
operator|->
name|scd_ubr0
expr_stmt|;
name|w1
operator|=
literal|0x00000000
expr_stmt|;
name|w2
operator|=
literal|0x00000000
expr_stmt|;
name|w3
operator|=
operator|(
name|IDT_TCTE_HALT
operator||
name|IDT_TCTE_IDLE
operator|)
expr_stmt|;
name|w4
operator|=
literal|0x00000000
expr_stmt|;
name|w5
operator|=
literal|0x00000000
expr_stmt|;
name|w6
operator|=
literal|0x00000000
expr_stmt|;
name|w7
operator|=
literal|0x80000000
expr_stmt|;
break|break;
case|case
name|NICUBR
case|:
if|if
condition|(
name|connection
operator|->
name|traf_pcr
operator|==
literal|0
condition|)
block|{
name|connection
operator|->
name|init_er
operator|=
literal|0xff
expr_stmt|;
comment|/* max values if nothing specified */
name|connection
operator|->
name|lacr
operator|=
literal|0xff
expr_stmt|;
block|}
else|else
block|{
name|connection
operator|->
name|init_er
operator|=
name|ns_rate2log
argument_list|(
name|proatm
argument_list|,
name|connection
operator|->
name|traf_pcr
argument_list|)
expr_stmt|;
name|connection
operator|->
name|lacr
operator|=
name|ns_rate2log
argument_list|(
name|proatm
argument_list|,
name|connection
operator|->
name|traf_scr
argument_list|)
expr_stmt|;
block|}
name|w0
operator|=
operator|(
name|IDT_TCTE_TYPE_UBR
operator||
name|connection
operator|->
name|queue
operator|->
name|scd
operator|)
expr_stmt|;
name|w1
operator|=
literal|0x00000000
expr_stmt|;
name|w2
operator|=
literal|0x00000000
expr_stmt|;
name|w3
operator|=
operator|(
name|IDT_TCTE_HALT
operator||
name|IDT_TCTE_IDLE
operator|)
expr_stmt|;
name|w4
operator|=
literal|0x00000000
expr_stmt|;
name|w5
operator|=
literal|0x00000000
expr_stmt|;
name|w6
operator|=
literal|0x00000000
expr_stmt|;
name|w7
operator|=
literal|0x80000000
expr_stmt|;
break|break;
case|case
name|NICCBR
case|:
name|w0
operator|=
name|IDT_TCTE_TYPE_CBR
operator||
name|connection
operator|->
name|queue
operator|->
name|scd
expr_stmt|;
name|w1
operator|=
literal|0x00000000
expr_stmt|;
name|w2
operator|=
literal|0x00000000
expr_stmt|;
name|w3
operator|=
literal|0x00000000
expr_stmt|;
name|w4
operator|=
literal|0x00000000
expr_stmt|;
name|w5
operator|=
literal|0x00000000
expr_stmt|;
name|w6
operator|=
literal|0x00000000
expr_stmt|;
name|w7
operator|=
literal|0x00000000
expr_stmt|;
break|break;
case|case
name|NICVBR
case|:
name|pcr_token
operator|=
name|scr_on_pcr
argument_list|(
name|connection
operator|->
name|traf_scr
argument_list|,
name|connection
operator|->
name|traf_pcr
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcr_token
operator|==
literal|0
condition|)
name|pcr_token
operator|++
expr_stmt|;
name|connection
operator|->
name|init_er
operator|=
name|ns_rate2log
argument_list|(
name|proatm
argument_list|,
name|connection
operator|->
name|traf_pcr
argument_list|)
expr_stmt|;
name|connection
operator|->
name|lacr
operator|=
name|ns_rate2log
argument_list|(
name|proatm
argument_list|,
name|connection
operator|->
name|traf_scr
argument_list|)
expr_stmt|;
name|w0
operator|=
name|IDT_TCTE_TYPE_VBR
operator||
name|connection
operator|->
name|queue
operator|->
name|scd
expr_stmt|;
name|w1
operator|=
literal|0x00000000
expr_stmt|;
name|w2
operator|=
name|IDT_TCTE_TSIF
expr_stmt|;
comment|/* interrupt when connection become idle*/
name|w3
operator|=
name|IDT_TCTE_HALT
operator||
name|IDT_TCTE_IDLE
expr_stmt|;
name|w4
operator|=
literal|0x7F
operator|<<
literal|24
expr_stmt|;
name|w5
operator|=
literal|0x01
operator|<<
literal|24
expr_stmt|;
name|w6
operator|=
operator|(
name|connection
operator|->
name|traf_mbs
operator|<<
literal|16
operator|)
operator||
name|pcr_token
expr_stmt|;
name|w7
operator|=
literal|0x00000000
expr_stmt|;
break|break;
case|case
name|NICABR
case|:
comment|/*           * We will add ABR as soon as FreeBSD provides support for it           */
default|default:
return|return
operator|-
literal|1
return|;
block|}
name|proatm_sram_wr
argument_list|(
name|proatm
argument_list|,
name|conn
operator|*
literal|8
argument_list|,
literal|4
argument_list|,
name|w0
argument_list|,
name|w1
argument_list|,
name|w2
argument_list|,
name|w3
argument_list|)
expr_stmt|;
name|proatm_sram_wr
argument_list|(
name|proatm
argument_list|,
name|conn
operator|*
literal|8
operator|+
literal|4
argument_list|,
literal|4
argument_list|,
name|w4
argument_list|,
name|w5
argument_list|,
name|w6
argument_list|,
name|w7
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  *  Open output queue for connection  *  *  in:  PROATM device, connection (class, traf_pcr,& traf_scr fields valid)  * out:  zero = success  *  */
end_comment

begin_function
specifier|static
name|int32_t
name|proatm_connect_txopen
parameter_list|(
name|PROATM
modifier|*
name|proatm
parameter_list|,
name|CONNECTION
modifier|*
name|connection
parameter_list|)
block|{
name|TX_QUEUE
modifier|*
name|txqueue
decl_stmt|;
name|int32_t
name|cellrate
init|=
name|connection
operator|->
name|traf_scr
decl_stmt|;
comment|/* use SCR instead of PCR */
name|int32_t
name|cbr_slots
decl_stmt|;
name|int32_t
name|s
init|=
literal|0
decl_stmt|;
name|int32_t
name|conn
init|=
name|connection
operator|->
name|number
decl_stmt|;
name|u_int8_t
name|class
init|=
name|connection
operator|->
name|class
decl_stmt|;
switch|switch
condition|(
name|class
condition|)
block|{
case|case
name|NICCBR
case|:
name|cbr_slots
operator|=
name|proatm_slots_cbr
argument_list|(
name|proatm
argument_list|,
name|cellrate
argument_list|)
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|cbr_slots
operator|+
name|proatm
operator|->
name|txslots_cur
operator|)
operator|>
operator|(
name|proatm
operator|->
name|tst_num
operator|-
name|PROATM_TST_RESERVED
operator|)
operator|||
operator|(
name|proatm
operator|->
name|txqueue_free_count
operator|<
literal|1
operator|)
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
comment|/* requested rate not available */
block|}
name|proatm
operator|->
name|txslots_cur
operator|+=
name|cbr_slots
expr_stmt|;
name|proatm
operator|->
name|cellrate_tcur
operator|+=
name|cellrate
expr_stmt|;
name|proatm
operator|->
name|txqueue_free_count
operator|--
expr_stmt|;
name|txqueue
operator|=
name|proatm
operator|->
name|txqueue_free
index|[
name|proatm
operator|->
name|txqueue_free_count
index|]
expr_stmt|;
name|txqueue
operator|->
name|rate
operator|=
name|cellrate
expr_stmt|;
name|connection
operator|->
name|queue
operator|=
name|txqueue
expr_stmt|;
name|proatm_tct_wr
argument_list|(
name|proatm
argument_list|,
name|conn
argument_list|)
expr_stmt|;
comment|/* write TCT connection info */
if|if
condition|(
name|proatm_slots_add
argument_list|(
name|proatm
argument_list|,
name|txqueue
argument_list|,
name|cbr_slots
argument_list|,
name|conn
argument_list|)
condition|)
block|{
name|proatm
operator|->
name|txslots_cur
operator|-=
name|cbr_slots
expr_stmt|;
comment|/* cannot add CBR slots */
name|proatm
operator|->
name|cellrate_tcur
operator|-=
name|cellrate
expr_stmt|;
name|proatm
operator|->
name|txqueue_free
index|[
name|proatm
operator|->
name|txqueue_free_count
index|]
operator|=
name|txqueue
expr_stmt|;
name|proatm
operator|->
name|txqueue_free_count
operator|++
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|proatm_sysctl_logvcs
condition|)
name|printf
argument_list|(
literal|"proatm_connect_txopen: CBR connection for %d/%d\n"
argument_list|,
name|connection
operator|->
name|vpi
argument_list|,
name|connection
operator|->
name|vci
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|NICUBR0
case|:
comment|/* UBR0 takes whatever is left over or setup for full speed */
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
if|if
condition|(
name|proatm
operator|->
name|txslots_cur
operator|==
name|proatm
operator|->
name|tst_num
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
comment|/* no more possibility for this rate */
block|}
name|proatm
operator|->
name|txslots_cur
operator|++
expr_stmt|;
name|connection
operator|->
name|queue
operator|=
operator|&
name|proatm
operator|->
name|txqueue_ubr0
expr_stmt|;
comment|/* single tx queue for all UBR0 connections */
name|proatm_tct_wr
argument_list|(
name|proatm
argument_list|,
name|conn
argument_list|)
expr_stmt|;
comment|/* write TCT connection info */
name|proatm_reg_wr
argument_list|(
name|proatm
argument_list|,
name|IDT_TCMDQ_UPD_INITER
operator||
literal|0xff
operator|<<
literal|16
operator||
name|conn
argument_list|,
name|REGTCMDQ
argument_list|)
expr_stmt|;
name|proatm_reg_wr
argument_list|(
name|proatm
argument_list|,
name|IDT_TCMDQ_START_ULACR
operator||
literal|0xff
operator|<<
literal|16
operator||
name|conn
argument_list|,
name|REGTCMDQ
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|proatm_sysctl_logvcs
condition|)
name|printf
argument_list|(
literal|"proatm_connect_txopen: UBR with unspecified rate connection for %d/%d\n"
argument_list|,
name|connection
operator|->
name|vpi
argument_list|,
name|connection
operator|->
name|vci
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|NICVBR
case|:
case|case
name|NICABR
case|:
case|case
name|NICUBR
case|:
if|if
condition|(
name|connection
operator|->
name|flg_closing
condition|)
block|{
name|printf
argument_list|(
literal|"proatm%d: connection is still closing\n"
argument_list|,
name|proatm
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
comment|/* make sure connection is idle */
if|if
condition|(
name|proatm_connect_txstop
argument_list|(
name|proatm
argument_list|,
name|conn
argument_list|)
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|(
name|proatm
operator|->
name|txslots_cur
operator|==
name|proatm
operator|->
name|tst_num
operator|)
operator|||
name|proatm
operator|->
name|txqueue_free_count
operator|<
literal|1
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
comment|/* no more possibility for this rate */
block|}
name|proatm
operator|->
name|txslots_cur
operator|++
expr_stmt|;
name|proatm
operator|->
name|txqueue_free_count
operator|--
expr_stmt|;
name|txqueue
operator|=
name|proatm
operator|->
name|txqueue_free
index|[
name|proatm
operator|->
name|txqueue_free_count
index|]
expr_stmt|;
name|connection
operator|->
name|queue
operator|=
name|txqueue
expr_stmt|;
name|txqueue
operator|->
name|mget
operator|=
name|NULL
expr_stmt|;
name|txqueue
operator|->
name|mput
operator|=
name|NULL
expr_stmt|;
name|txqueue
operator|->
name|scq_next
operator|=
name|txqueue
operator|->
name|scq_base
expr_stmt|;
name|txqueue
operator|->
name|scq_last
operator|=
name|txqueue
operator|->
name|scq_next
expr_stmt|;
name|txqueue
operator|->
name|scq_cur
operator|=
literal|0
expr_stmt|;
name|txqueue
operator|->
name|rate
operator|=
name|cellrate
expr_stmt|;
comment|/* init SCD */
name|proatm_sram_wr
argument_list|(
name|proatm
argument_list|,
name|txqueue
operator|->
name|scd
argument_list|,
literal|4
argument_list|,
name|vtophys
argument_list|(
name|txqueue
operator|->
name|scq_base
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0xffffffff
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|proatm_sram_wr
argument_list|(
name|proatm
argument_list|,
name|txqueue
operator|->
name|scd
operator|+
literal|4
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|proatm_sram_wr
argument_list|(
name|proatm
argument_list|,
name|txqueue
operator|->
name|scd
operator|+
literal|8
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* write TCT connection info */
name|proatm_tct_wr
argument_list|(
name|proatm
argument_list|,
name|conn
argument_list|)
expr_stmt|;
comment|/* start scheduling */
name|proatm_reg_wr
argument_list|(
name|proatm
argument_list|,
name|IDT_TCMDQ_UPD_INITER
operator||
name|connection
operator|->
name|init_er
operator|<<
literal|16
operator||
name|conn
argument_list|,
name|REGTCMDQ
argument_list|)
expr_stmt|;
name|proatm_reg_wr
argument_list|(
name|proatm
argument_list|,
name|IDT_TCMDQ_START_ULACR
operator||
name|connection
operator|->
name|lacr
operator|<<
literal|16
operator||
name|conn
argument_list|,
name|REGTCMDQ
argument_list|)
expr_stmt|;
name|connection
operator|->
name|flg_active
operator|=
literal|1
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|proatm_sysctl_logvcs
condition|)
name|printf
argument_list|(
literal|"proatm%d: txopen %s connection for %d/%d\n"
argument_list|,
name|proatm
operator|->
name|unit
argument_list|,
name|class
operator|==
name|NICUBR
condition|?
literal|"UBR"
else|:
name|class
operator|==
name|NICVBR
condition|?
literal|"VBR"
else|:
literal|"ABR"
argument_list|,
name|connection
operator|->
name|vpi
argument_list|,
name|connection
operator|->
name|vci
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
comment|/* unknown class */
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  *  Halt hardware connection  *  *  Called at splimp  *  *  in:  connection number  * out:  zero = success  *  */
end_comment

begin_function
specifier|static
name|int32_t
name|proatm_connect_txstop
parameter_list|(
name|PROATM
modifier|*
name|proatm
parameter_list|,
name|int32_t
name|conn
parameter_list|)
block|{
name|int32_t
name|i
decl_stmt|;
name|u_int32_t
name|addr
decl_stmt|,
name|w
decl_stmt|;
name|addr
operator|=
name|conn
operator|*
name|IDT_TCT_ENTRY_SIZE
expr_stmt|;
name|proatm_sram_rd
argument_list|(
name|proatm
argument_list|,
name|addr
operator|+
literal|3
argument_list|,
operator|&
name|w
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|w
operator|&
operator|(
name|IDT_TCTE_IDLE
operator||
name|IDT_TCTE_HALT
operator|)
operator|)
condition|)
block|{
name|proatm_reg_wr
argument_list|(
name|proatm
argument_list|,
name|IDT_TCMDQ_HALT
operator||
name|conn
argument_list|,
name|REGTCMDQ
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|1000
condition|;
name|i
operator|++
control|)
block|{
name|DELAY
argument_list|(
literal|50
argument_list|)
expr_stmt|;
name|proatm_sram_rd
argument_list|(
name|proatm
argument_list|,
name|addr
operator|+
literal|3
argument_list|,
operator|&
name|w
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|&
operator|(
name|IDT_TCTE_IDLE
operator||
name|IDT_TCTE_HALT
operator|)
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
name|i
operator|==
literal|1000
condition|)
block|{
name|printf
argument_list|(
literal|"proatm%d: timeout when halting transmission on connection %d\n"
argument_list|,
name|proatm
operator|->
name|unit
argument_list|,
name|conn
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  *  Close connection output queue when empty.  *  *  Called at splimp by proatm_intr_tsq()  *  *  in:  PROATM device  *  */
end_comment

begin_function
specifier|static
name|void
name|proatm_connect_txclose_cb
parameter_list|(
name|PROATM
modifier|*
name|proatm
parameter_list|,
name|CONNECTION
modifier|*
name|connection
parameter_list|)
block|{
name|TX_QUEUE
modifier|*
name|txqueue
init|=
name|connection
operator|->
name|queue
decl_stmt|;
name|int32_t
name|s
decl_stmt|,
name|count
init|=
literal|0
decl_stmt|;
name|u_int32_t
name|conn
init|=
name|connection
operator|->
name|number
decl_stmt|;
if|if
condition|(
name|proatm_sysctl_logvcs
condition|)
name|printf
argument_list|(
literal|"proatm%d: %d/%d closed\n"
argument_list|,
name|proatm
operator|->
name|unit
argument_list|,
name|connection
operator|->
name|vpi
argument_list|,
name|connection
operator|->
name|vci
argument_list|)
expr_stmt|;
comment|/*      * All the UBR0 shares the same queue txqueue_ubr0. It means that txqueue_ubr0      * cannot be set back to txqueue_free.      */
if|if
condition|(
name|connection
operator|->
name|class
operator|==
name|NICUBR0
condition|)
block|{
name|printf
argument_list|(
literal|"proatm%d: "
name|__FUNCTION__
literal|" called while VPI/VCI=%d/%d is UBR0\n"
argument_list|,
name|proatm
operator|->
name|unit
argument_list|,
name|connection
operator|->
name|vpi
argument_list|,
name|connection
operator|->
name|vci
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|connection
operator|->
name|flg_closing
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|proatm_check_vc
argument_list|(
name|proatm
argument_list|,
name|connection
operator|->
name|vpi
argument_list|,
name|connection
operator|->
name|vci
argument_list|)
condition|)
return|return;
name|proatm
operator|->
name|pu_stats
operator|.
name|proatm_st_drv
operator|.
name|drv_xm_closing
operator|--
expr_stmt|;
name|proatm_queue_flush
argument_list|(
name|connection
argument_list|,
operator|&
name|count
argument_list|)
expr_stmt|;
comment|/* free mbufs remaining in transmit queue*/
if|if
condition|(
name|count
condition|)
name|printf
argument_list|(
literal|"proatm%d: %d PDUs have been trashed on UBR/VBR close\n"
argument_list|,
name|proatm
operator|->
name|unit
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
if|if
condition|(
name|txqueue
operator|!=
name|NULL
condition|)
block|{
name|proatm
operator|->
name|txqueue_free
index|[
name|proatm
operator|->
name|txqueue_free_count
index|]
operator|=
name|txqueue
expr_stmt|;
name|proatm
operator|->
name|txqueue_free_count
operator|++
expr_stmt|;
block|}
name|proatm
operator|->
name|txslots_cur
operator|--
expr_stmt|;
name|connection
operator|->
name|queue
operator|=
name|NULL
expr_stmt|;
name|connection
operator|->
name|recv
operator|=
name|NULL
expr_stmt|;
name|connection
operator|->
name|rlen
operator|=
literal|0
expr_stmt|;
name|connection
operator|->
name|maxpdu
operator|=
literal|0
expr_stmt|;
name|connection
operator|->
name|aal
operator|=
literal|0
expr_stmt|;
name|connection
operator|->
name|traf_pcr
operator|=
literal|0
expr_stmt|;
name|connection
operator|->
name|traf_scr
operator|=
literal|0
expr_stmt|;
name|connection
operator|->
name|traf_mbs
operator|=
literal|0
expr_stmt|;
name|connection
operator|->
name|flg_closing
operator|=
literal|0
expr_stmt|;
name|connection
operator|->
name|flg_open
operator|=
literal|0
expr_stmt|;
name|connection
operator|->
name|flg_clp
operator|=
literal|0
expr_stmt|;
name|proatm_connect_txstop
argument_list|(
name|proatm
argument_list|,
name|conn
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  *  Close connection output queue  *  *  in:  PROATM device, connection (class, traf_pcr,& traf_scr fields valid)  * out:  zero = success  *  */
end_comment

begin_function
specifier|static
name|int32_t
name|proatm_connect_txclose
parameter_list|(
name|PROATM
modifier|*
name|proatm
parameter_list|,
name|CONNECTION
modifier|*
name|connection
parameter_list|,
name|int32_t
name|force
parameter_list|)
block|{
name|TX_QUEUE
modifier|*
name|txqueue
decl_stmt|;
name|int32_t
name|slots
decl_stmt|;
name|int32_t
name|s
decl_stmt|,
name|count
init|=
literal|0
decl_stmt|;
name|u_int32_t
name|conn
init|=
name|connection
operator|->
name|number
decl_stmt|;
name|u_int32_t
name|addr
init|=
name|conn
operator|*
name|IDT_TCT_ENTRY_SIZE
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
if|if
condition|(
name|proatm_check_vc
argument_list|(
name|proatm
argument_list|,
name|connection
operator|->
name|vpi
argument_list|,
name|connection
operator|->
name|vci
argument_list|)
condition|)
return|return
literal|1
return|;
name|txqueue
operator|=
name|connection
operator|->
name|queue
expr_stmt|;
if|if
condition|(
name|proatm_sysctl_logvcs
condition|)
name|printf
argument_list|(
literal|"proatm%d: closing %d/%d\n"
argument_list|,
name|proatm
operator|->
name|unit
argument_list|,
name|connection
operator|->
name|vpi
argument_list|,
name|connection
operator|->
name|vci
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|connection
operator|->
name|class
condition|)
block|{
case|case
name|NICCBR
case|:
name|slots
operator|=
name|proatm_slots_rem
argument_list|(
name|proatm
argument_list|,
name|txqueue
argument_list|)
expr_stmt|;
comment|/* remove this queue from CBR slots */
name|proatm_queue_flush
argument_list|(
name|connection
argument_list|,
operator|&
name|count
argument_list|)
expr_stmt|;
comment|/* free mbufs remaining in transmit queue*/
if|if
condition|(
name|count
condition|)
name|printf
argument_list|(
literal|"proatm%d: %d PDUs have been trashed on CBR close on VPI/VCI=%d/%d\n"
argument_list|,
name|proatm
operator|->
name|unit
argument_list|,
name|count
argument_list|,
name|connection
operator|->
name|vpi
argument_list|,
name|connection
operator|->
name|vci
argument_list|)
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|proatm
operator|->
name|txslots_cur
operator|-=
name|slots
expr_stmt|;
name|proatm
operator|->
name|cellrate_tcur
operator|-=
name|connection
operator|->
name|traf_scr
expr_stmt|;
if|if
condition|(
name|txqueue
operator|!=
name|NULL
condition|)
block|{
name|proatm
operator|->
name|txqueue_free
index|[
name|proatm
operator|->
name|txqueue_free_count
index|]
operator|=
name|txqueue
expr_stmt|;
name|proatm
operator|->
name|txqueue_free_count
operator|++
expr_stmt|;
block|}
name|connection
operator|->
name|queue
operator|=
name|NULL
expr_stmt|;
name|connection
operator|->
name|flg_open
operator|=
literal|0
expr_stmt|;
name|connection
operator|->
name|recv
operator|=
name|NULL
expr_stmt|;
name|connection
operator|->
name|rlen
operator|=
literal|0
expr_stmt|;
name|connection
operator|->
name|maxpdu
operator|=
literal|0
expr_stmt|;
name|connection
operator|->
name|aal
operator|=
literal|0
expr_stmt|;
name|connection
operator|->
name|traf_pcr
operator|=
literal|0
expr_stmt|;
name|connection
operator|->
name|traf_scr
operator|=
literal|0
expr_stmt|;
name|connection
operator|->
name|traf_mbs
operator|=
literal|0
expr_stmt|;
comment|/* XXX: Is proatm_connect_txstop (proatm, conn) missing ?? */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|NICUBR
case|:
case|case
name|NICVBR
case|:
if|if
condition|(
operator|!
name|force
condition|)
block|{
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|connection
operator|->
name|flg_closing
operator|=
literal|1
expr_stmt|;
comment|/* blocks open() while closing */
comment|/*               * Do nothing here. Just post a special end of transmission mbuf               */
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_WAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* thanks to Vincent Jardin */
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/*               * Delay the call to proatm_connect_txstop (proatm, conn).              * proatm_connect_txclose_cb will do the job.              */
name|proatm
operator|->
name|pu_stats
operator|.
name|proatm_st_drv
operator|.
name|drv_xm_closing
operator|++
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|header
operator|=
name|PROATM_CLOSE_CONNECTION
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
literal|4
expr_stmt|;
comment|/* fake length for proatm_transmit_top */
name|proatm_queue_put
argument_list|(
name|connection
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|proatm_transmit_top
argument_list|(
name|proatm
argument_list|,
name|txqueue
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*              * Flush everything in case of detach. Don't care if packets may be lost.              */
name|connection
operator|->
name|flg_closing
operator|=
literal|0
expr_stmt|;
name|proatm_connect_txclose_cb
argument_list|(
name|proatm
argument_list|,
name|connection
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
case|case
name|NICUBR0
case|:
name|proatm_queue_flush
argument_list|(
name|connection
argument_list|,
operator|&
name|count
argument_list|)
expr_stmt|;
comment|/* free mbufs remaining in transmit queue*/
if|if
condition|(
name|count
condition|)
name|printf
argument_list|(
literal|"proatm%d: %d PDUs have been trashed on UBR0 close on VPI/VCI=%d/%d\n"
argument_list|,
name|proatm
operator|->
name|unit
argument_list|,
name|count
argument_list|,
name|connection
operator|->
name|vpi
argument_list|,
name|connection
operator|->
name|vci
argument_list|)
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|proatm
operator|->
name|txslots_cur
operator|--
expr_stmt|;
name|connection
operator|->
name|queue
operator|=
name|NULL
expr_stmt|;
name|connection
operator|->
name|flg_open
operator|=
literal|0
expr_stmt|;
name|connection
operator|->
name|recv
operator|=
name|NULL
expr_stmt|;
name|connection
operator|->
name|rlen
operator|=
literal|0
expr_stmt|;
name|connection
operator|->
name|maxpdu
operator|=
literal|0
expr_stmt|;
name|connection
operator|->
name|aal
operator|=
literal|0
expr_stmt|;
name|connection
operator|->
name|traf_pcr
operator|=
literal|0
expr_stmt|;
name|connection
operator|->
name|traf_scr
operator|=
literal|0
expr_stmt|;
name|connection
operator|->
name|traf_mbs
operator|=
literal|0
expr_stmt|;
comment|/* halt hardware connection*/
name|proatm_connect_txstop
argument_list|(
name|proatm
argument_list|,
name|conn
argument_list|)
expr_stmt|;
comment|/* Clear TCT entry */
name|proatm_sram_wr
argument_list|(
name|proatm
argument_list|,
name|addr
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|proatm_sram_wr
argument_list|(
name|proatm
argument_list|,
name|addr
operator|+
literal|4
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
default|default:
return|return
literal|1
return|;
comment|/* unsupported class */
block|}
comment|/*  print_proatm_log (); */
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  *  Get large buffer from kernel pool  *  * out:  mbuf, NULL = error  *  */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|proatm_mbufcl_get
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|MCLGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
condition|)
return|return
operator|(
name|m
operator|)
return|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  *  Initialize connection table  *  *  in:  PROATM, number of VPI bits (0, 1, or 2)  *  out:  zero = success  *  */
end_comment

begin_function
specifier|static
name|int32_t
name|proatm_connect_init
parameter_list|(
name|PROATM
modifier|*
name|proatm
parameter_list|)
block|{
name|CONNECTION
modifier|*
name|connection
decl_stmt|;
name|int32_t
name|pages
decl_stmt|;
name|int32_t
name|vpi
decl_stmt|;
name|int32_t
name|vci
decl_stmt|;
name|proatm
operator|->
name|conn_maxvpi
operator|=
literal|1
operator|<<
name|proatm
operator|->
name|vpibits
expr_stmt|;
name|proatm
operator|->
name|conn_maxvci
operator|=
name|proatm
operator|->
name|max_connection
operator|/
name|proatm
operator|->
name|conn_maxvpi
expr_stmt|;
name|pages
operator|=
operator|(
sizeof|sizeof
argument_list|(
name|CONNECTION
argument_list|)
operator|*
name|proatm
operator|->
name|max_connection
operator|)
operator|+
name|PAGE_SIZE
operator|-
literal|1
expr_stmt|;
name|pages
operator|/=
name|PAGE_SIZE
expr_stmt|;
name|proatm
operator|->
name|connection
operator|=
operator|(
name|CONNECTION
operator|*
operator|)
name|proatm_malloc_contig
argument_list|(
name|pages
operator|*
name|PAGE_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|proatm
operator|->
name|connection
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
for|for
control|(
name|vpi
operator|=
literal|0
init|;
name|vpi
operator|<
name|proatm
operator|->
name|conn_maxvpi
condition|;
name|vpi
operator|++
control|)
for|for
control|(
name|vci
operator|=
literal|0
init|;
name|vci
operator|<
name|proatm
operator|->
name|conn_maxvci
condition|;
name|vci
operator|++
control|)
block|{
name|connection
operator|=
operator|&
name|proatm
operator|->
name|connection
index|[
name|vpi
operator|*
name|proatm
operator|->
name|conn_maxvci
operator|+
name|vci
index|]
expr_stmt|;
name|connection
operator|->
name|vccinf
operator|=
name|NULL
expr_stmt|;
comment|/* may want to change to "unclaimed" */
name|connection
operator|->
name|flg_open
operator|=
literal|0
expr_stmt|;
comment|/* closed */
name|connection
operator|->
name|vpi
operator|=
name|vpi
expr_stmt|;
name|connection
operator|->
name|vci
operator|=
name|vci
expr_stmt|;
name|connection
operator|->
name|queue
operator|=
name|NULL
expr_stmt|;
comment|/* no current TX queue */
name|connection
operator|->
name|recv
operator|=
name|NULL
expr_stmt|;
comment|/* no current receive mbuf */
name|connection
operator|->
name|rlen
operator|=
literal|0
expr_stmt|;
name|connection
operator|->
name|maxpdu
operator|=
literal|0
expr_stmt|;
name|connection
operator|->
name|traf_pcr
operator|=
literal|0
expr_stmt|;
name|connection
operator|->
name|traf_scr
operator|=
literal|0
expr_stmt|;
name|connection
operator|->
name|aal
operator|=
literal|0
expr_stmt|;
name|connection
operator|->
name|class
operator|=
literal|0
expr_stmt|;
name|connection
operator|->
name|number
operator|=
operator|(
name|vpi
operator|<<
name|proatm
operator|->
name|vcibits
operator|)
operator||
name|vci
expr_stmt|;
name|connection
operator|->
name|flg_clp
operator|=
literal|0
expr_stmt|;
name|connection
operator|->
name|flg_active
operator|=
literal|0
expr_stmt|;
name|connection
operator|->
name|flg_closing
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  *  Look up a connection  *  *  in:  PROATM, vpi, vci  * out:  connection number, 0=invalid vpi/vci  *  */
end_comment

begin_function
specifier|static
name|CONNECTION
modifier|*
name|proatm_connect_find
parameter_list|(
name|PROATM
modifier|*
name|proatm
parameter_list|,
name|int32_t
name|vpi
parameter_list|,
name|int32_t
name|vci
parameter_list|)
block|{
name|int32_t
name|conn
decl_stmt|;
name|vpi
operator|&=
name|proatm
operator|->
name|conn_maxvpi
operator|-
literal|1
expr_stmt|;
name|vci
operator|&=
name|proatm
operator|->
name|conn_maxvci
operator|-
literal|1
expr_stmt|;
name|conn
operator|=
name|vpi
operator|<<
name|proatm
operator|->
name|vcibits
operator||
name|vci
expr_stmt|;
return|return
operator|&
operator|(
name|proatm
operator|->
name|connection
index|[
name|conn
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  *  Check VPI and VCI  *  *  in:  PROATM, vpi, vci  * out:  0= OK, 1=invalid vpi/vci  *  */
end_comment

begin_function
specifier|static
name|int32_t
name|proatm_check_vc
parameter_list|(
name|PROATM
modifier|*
name|proatm
parameter_list|,
name|u_int8_t
name|vpi
parameter_list|,
name|ushort
name|vci
parameter_list|)
block|{
name|u_int32_t
name|mask
decl_stmt|;
name|u_int8_t
name|vp
init|=
name|vpi
decl_stmt|;
name|u_int16_t
name|vc
init|=
name|vci
decl_stmt|;
name|mask
operator|=
literal|0xffff
operator|>>
name|proatm
operator|->
name|vcibits
expr_stmt|;
comment|/* vci check */
if|if
condition|(
operator|(
name|vc
operator|>>
name|proatm
operator|->
name|vcibits
operator|)
operator|!=
operator|(
name|proatm
operator|->
name|vpm
operator|&
name|mask
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"proatm%d: vci %d out of bounds (max vpi= %d, max vci= %d, mask = 0x%x)\n"
argument_list|,
name|proatm
operator|->
name|unit
argument_list|,
operator|(
name|int32_t
operator|)
name|vci
argument_list|,
operator|(
name|int32_t
operator|)
name|proatm
operator|->
name|conn_maxvpi
argument_list|,
operator|(
name|int32_t
operator|)
name|proatm
operator|->
name|conn_maxvci
argument_list|,
operator|(
name|int32_t
operator|)
name|proatm
operator|->
name|vpm
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* vpi check */
if|if
condition|(
operator|(
name|vp
operator|>>
name|proatm
operator|->
name|vpibits
operator|)
operator|!=
operator|(
name|proatm
operator|->
name|vpm
operator|>>
operator|(
literal|16
operator|-
name|proatm
operator|->
name|vcibits
operator|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"proatm%d: vpi %d out of bounds (max vpi= %d, max vci= %d, mask = 0x%x)\n"
argument_list|,
name|proatm
operator|->
name|unit
argument_list|,
operator|(
name|int32_t
operator|)
name|vpi
argument_list|,
operator|(
name|int32_t
operator|)
name|proatm
operator|->
name|conn_maxvpi
argument_list|,
operator|(
name|int32_t
operator|)
name|proatm
operator|->
name|conn_maxvci
argument_list|,
operator|(
name|int32_t
operator|)
name|proatm
operator|->
name|vpm
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  *  Get current base of data storage  *  *  in:  mbuf  * out:  base  *  */
end_comment

begin_function
specifier|static
name|caddr_t
name|proatm_mbuf_base
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
condition|)
return|return
operator|(
name|m
operator|->
name|m_ext
operator|.
name|ext_buf
operator|)
return|;
comment|/* external storage */
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_PKTHDR
condition|)
return|return
operator|(
name|m
operator|->
name|m_pktdat
operator|)
return|;
comment|/* internal storage, packet header */
return|return
operator|(
name|m
operator|->
name|m_dat
operator|)
return|;
comment|/* internal storage, no packet header */
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  *  Put mbuf chain on transmit queue  *  *  Note on mbuf usage in the transmit queue:  *  *  m_pkthdr.rcvif       Connection pointer (set by proatm_queue_put)  *  m_pkthdr.len         Length of PDU  *  m_pkthdr.header      NULL for normal packet, 1 if end of transmission packet  *  m_pkthdr.csum_flags  Unused, keep zero	(does not apply to 3.5 version)  *  m_pkthdr.csum_data   unused, keep zero  (does not apply to 3.5 version)  *  m_pkthdr.aux         Unused, keep NULL  *  *  This mbuf is m_freem(ed) when a TSQ interrupt is catched  *  and processed by proatm_process_tsr()  *  *  in:  PROATM device, mbuf chain, vpi, vci, flags (2 MPEG2 TS == 8 AAL5 cells)  *  out:  (nothing)  *  */
end_comment

begin_function
specifier|static
name|void
name|proatm_transmit
parameter_list|(
name|PROATM
modifier|*
name|proatm
parameter_list|,
name|struct
name|mbuf
modifier|*
name|mfirst
parameter_list|,
name|int32_t
name|vpi
parameter_list|,
name|int32_t
name|vci
parameter_list|)
block|{
name|CONNECTION
modifier|*
name|connection
init|=
name|proatm_connect_find
argument_list|(
name|proatm
argument_list|,
name|vpi
argument_list|,
name|vci
argument_list|)
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|top
init|=
name|mfirst
decl_stmt|;
name|struct
name|mbuf
modifier|*
modifier|*
name|pnext
init|=
operator|&
name|top
decl_stmt|;
name|int32_t
name|ntbd
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|connection
operator|==
name|NULL
condition|)
block|{
name|XPRINT
argument_list|(
literal|"proatm_transmit: this VPI/VCI is not open\n"
argument_list|)
expr_stmt|;
name|proatm_transmit_drop
argument_list|(
name|proatm
argument_list|,
name|connection
argument_list|,
name|mfirst
argument_list|)
expr_stmt|;
comment|/* this VPI/VCI is not open */
return|return;
block|}
if|if
condition|(
name|connection
operator|->
name|queue
operator|==
name|NULL
condition|)
block|{
name|XPRINT
argument_list|(
literal|"proatm_transmit: queue = NULL\n"
argument_list|)
expr_stmt|;
name|proatm_transmit_drop
argument_list|(
name|proatm
argument_list|,
name|connection
argument_list|,
name|mfirst
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Sanity check to suppress null-length buffers */
do|do
block|{
name|m
operator|=
operator|*
name|pnext
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|==
literal|0
condition|)
block|{
operator|*
name|pnext
operator|=
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pnext
operator|=
operator|&
name|m
operator|->
name|m_next
expr_stmt|;
name|ntbd
operator|++
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|*
name|pnext
condition|)
do|;
if|if
condition|(
name|ntbd
operator|==
literal|0
condition|)
return|return;
comment|/* empty packet */
if|if
condition|(
name|proatm_queue_put
argument_list|(
name|connection
argument_list|,
name|top
argument_list|)
condition|)
comment|/* put packet on TX queue */
name|printf
argument_list|(
literal|"proatm%d: Cannot queue packet for %d/%d.\n"
argument_list|,
name|proatm
operator|->
name|unit
argument_list|,
name|vpi
argument_list|,
name|vci
argument_list|)
expr_stmt|;
comment|/* Put on SCQ if the TX queue was empty */
if|if
condition|(
name|connection
operator|->
name|queue
operator|->
name|mget
operator|==
name|top
condition|)
name|proatm_transmit_top
argument_list|(
name|proatm
argument_list|,
name|connection
operator|->
name|queue
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  *  Drop transmit mbuf chain and update counters  *  *  in:  PROATM device, CONNECTION if any, mbuf chain  * out:  (nothing)  *  */
end_comment

begin_function
specifier|static
name|void
name|proatm_transmit_drop
parameter_list|(
name|PROATM
modifier|*
name|proatm
parameter_list|,
name|CONNECTION
modifier|*
name|connection
parameter_list|,
name|struct
name|mbuf
modifier|*
name|mfirst
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|next
decl_stmt|;
name|int32_t
name|mesglen
decl_stmt|;
name|mesglen
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|mfirst
operator|!=
name|NULL
condition|)
block|{
name|mesglen
operator|+=
name|mfirst
operator|->
name|m_len
expr_stmt|;
name|next
operator|=
name|m_free
argument_list|(
name|mfirst
argument_list|)
expr_stmt|;
name|mfirst
operator|=
name|next
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"proatm%d: dropping transmit packet, size=%d\n"
argument_list|,
name|proatm
operator|->
name|unit
argument_list|,
name|mesglen
argument_list|)
expr_stmt|;
name|proatm
operator|->
name|stats_oerrors
operator|++
expr_stmt|;
if|if
condition|(
name|connection
condition|)
block|{
name|connection
operator|->
name|vccinf
operator|->
name|vc_oerrors
operator|++
expr_stmt|;
switch|switch
condition|(
name|connection
operator|->
name|aal
condition|)
block|{
case|case
name|IDTAAL5
case|:
name|proatm
operator|->
name|pu_stats
operator|.
name|proatm_st_aal5
operator|.
name|aal5_pdu_drops
operator|++
expr_stmt|;
name|proatm
operator|->
name|pu_stats
operator|.
name|proatm_st_aal5
operator|.
name|aal5_drops
operator|+=
operator|(
name|mesglen
operator|+
literal|47
operator|)
operator|/
name|BYTES_PER_CELL
expr_stmt|;
break|break;
case|case
name|IDTAAL3_4
case|:
name|proatm
operator|->
name|pu_stats
operator|.
name|proatm_st_aal4
operator|.
name|aal4_pdu_drops
operator|++
expr_stmt|;
name|proatm
operator|->
name|pu_stats
operator|.
name|proatm_st_aal4
operator|.
name|aal4_drops
operator|+=
operator|(
name|mesglen
operator|+
literal|47
operator|)
operator|/
name|BYTES_PER_CELL
expr_stmt|;
break|break;
case|case
name|IDTAAL0
case|:
name|proatm
operator|->
name|pu_stats
operator|.
name|proatm_st_aal0
operator|.
name|aal0_drops
operator|++
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"proatm%d: bad AAL for %d/%d\n"
argument_list|,
name|proatm
operator|->
name|unit
argument_list|,
name|connection
operator|->
name|vpi
argument_list|,
name|connection
operator|->
name|vci
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  *  Put mbuf chain on SCQ  *  *  in:  PROATM device, TX_QUEUE  * out:  (nothing)  *  */
end_comment

begin_function
specifier|static
name|void
name|proatm_transmit_top
parameter_list|(
name|PROATM
modifier|*
name|proatm
parameter_list|,
name|TX_QUEUE
modifier|*
name|txqueue
parameter_list|)
block|{
name|CONNECTION
modifier|*
name|connection
init|=
name|NULL
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|top
decl_stmt|,
modifier|*
name|m
decl_stmt|;
name|int32_t
name|val1
decl_stmt|,
name|val4
decl_stmt|;
name|int32_t
name|tlen
decl_stmt|;
name|int32_t
name|vci
decl_stmt|,
name|vpi
decl_stmt|;
name|int32_t
name|scq_space
decl_stmt|,
name|scq_pending
decl_stmt|;
name|int32_t
name|count
decl_stmt|,
name|s
decl_stmt|,
name|ntbd
decl_stmt|,
name|i
decl_stmt|,
name|conn
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|txqueue
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"proatm%d: error: txqueue = NULL\n"
argument_list|,
name|proatm
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
comment|/*        * Now we can add the queue entries for the PDUs       */
name|scq_space
operator|=
name|IDT_SCQ_ENTRIES
operator|-
name|txqueue
operator|->
name|scq_cur
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|top
operator|=
name|txqueue
operator|->
name|mget
expr_stmt|;
comment|/* read the PDU pointer */
if|if
condition|(
name|top
operator|==
name|NULL
condition|)
break|break;
comment|/* no more PDU in the TX queue */
comment|/*           * First pass to calculate the total PDU length and TBD number.          * Empty packets have been filtered by proatm_transmit ()          */
for|for
control|(
name|m
operator|=
name|top
operator|,
name|ntbd
operator|=
literal|0
operator|,
name|tlen
operator|=
literal|0
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
block|{
name|tlen
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
name|ntbd
operator|++
expr_stmt|;
block|}
comment|/*           * Exit if no more room for the PDU. It will be processed later           */
if|if
condition|(
name|scq_space
operator|<
name|ntbd
operator|+
literal|1
condition|)
break|break;
comment|/*           * Now extract this PDU from txqueue           */
name|top
operator|=
name|proatm_queue_get
argument_list|(
name|txqueue
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|KB_ISPKT
argument_list|(
name|top
argument_list|)
condition|)
name|panic
argument_list|(
name|__FUNCTION__
literal|" missing M_PKTHDR"
argument_list|)
expr_stmt|;
name|connection
operator|=
operator|(
name|CONNECTION
operator|*
operator|)
name|top
operator|->
name|m_pkthdr
operator|.
name|rcvif
expr_stmt|;
if|if
condition|(
name|top
operator|->
name|m_pkthdr
operator|.
name|header
operator|==
name|PROATM_CLOSE_CONNECTION
condition|)
block|{
comment|/*               * Insert a Transmit Status Request with interruption              * this is a special end-of-connection mbuf              * we must insert a special end-of-connection TSR              */
operator|*
name|txqueue
operator|->
name|scq_next
operator|++
operator|=
name|IDT_TSR
operator||
name|IDT_TBD_TSIF
operator||
operator|(
name|PROATM_CLOSE_TAG
operator|<<
literal|20
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|top
operator|->
name|m_len
operator|!=
literal|4
operator|)
operator|||
operator|(
name|top
operator|->
name|m_pkthdr
operator|.
name|len
operator|!=
literal|0
operator|)
condition|)
name|printf
argument_list|(
literal|"proatm%d: trying close (PROATM_CLOSE_TAG) with m_len"
literal|" %d and m_pkthdr.len %d\n"
argument_list|,
name|proatm
operator|->
name|unit
argument_list|,
name|top
operator|->
name|m_len
argument_list|,
name|top
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
operator|*
name|txqueue
operator|->
name|scq_next
operator|++
operator|=
operator|(
name|u_int32_t
operator|)
name|connection
expr_stmt|;
operator|*
name|txqueue
operator|->
name|scq_next
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|txqueue
operator|->
name|scq_next
operator|++
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|txqueue
operator|->
name|scq_next
operator|>=
name|txqueue
operator|->
name|scq_base
operator|+
operator|(
name|IDT_SCQ_ENTRIES
operator|*
literal|4
operator|)
condition|)
name|txqueue
operator|->
name|scq_next
operator|=
name|txqueue
operator|->
name|scq_base
expr_stmt|;
name|top
operator|->
name|m_pkthdr
operator|.
name|header
operator|=
name|NULL
expr_stmt|;
name|top
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
literal|0
expr_stmt|;
name|m_free
argument_list|(
name|top
argument_list|)
expr_stmt|;
name|txqueue
operator|->
name|scq_cur
operator|++
expr_stmt|;
name|count
operator|++
expr_stmt|;
break|break;
block|}
name|vpi
operator|=
name|connection
operator|->
name|vpi
expr_stmt|;
name|vci
operator|=
name|connection
operator|->
name|vci
expr_stmt|;
name|conn
operator|=
name|connection
operator|->
name|number
expr_stmt|;
switch|switch
condition|(
name|connection
operator|->
name|aal
condition|)
block|{
case|case
name|IDTAAL5
case|:
name|val1
operator|=
name|IDT_TBD_AAL5
expr_stmt|;
break|break;
case|case
name|IDTAAL3_4
case|:
name|printf
argument_list|(
literal|"proatm%d: AAL3/4 is not supported\n"
argument_list|,
name|proatm
operator|->
name|unit
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|top
argument_list|)
expr_stmt|;
name|proatm
operator|->
name|pu_stats
operator|.
name|proatm_st_aal4
operator|.
name|aal4_pdu_drops
operator|++
expr_stmt|;
name|proatm
operator|->
name|pu_stats
operator|.
name|proatm_st_aal4
operator|.
name|aal4_drops
operator|+=
operator|(
name|tlen
operator|+
literal|47
operator|)
operator|/
name|BYTES_PER_CELL
expr_stmt|;
name|connection
operator|->
name|vccinf
operator|->
name|vc_oerrors
operator|++
expr_stmt|;
continue|continue;
comment|/* process the next PDU */
case|case
name|IDTAAL0
case|:
name|printf
argument_list|(
literal|"proatm%d: AAL0 is not supported\n"
argument_list|,
name|proatm
operator|->
name|unit
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|top
argument_list|)
expr_stmt|;
name|proatm
operator|->
name|pu_stats
operator|.
name|proatm_st_aal0
operator|.
name|aal0_drops
operator|+=
operator|(
name|tlen
operator|+
literal|47
operator|)
operator|/
name|BYTES_PER_CELL
expr_stmt|;
name|connection
operator|->
name|vccinf
operator|->
name|vc_oerrors
operator|++
expr_stmt|;
continue|continue;
comment|/* process the next PDU */
default|default:
name|printf
argument_list|(
literal|"proatm%d: bad AAL for %d/%d\n"
argument_list|,
name|proatm
operator|->
name|unit
argument_list|,
name|vpi
argument_list|,
name|vci
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|top
argument_list|)
expr_stmt|;
name|connection
operator|->
name|vccinf
operator|->
name|vc_oerrors
operator|++
expr_stmt|;
continue|continue;
comment|/* process the next PDU */
block|}
name|val4
operator|=
operator|(
operator|(
name|vpi
operator|<<
literal|20
operator|)
operator|&
name|IDT_TBD_VPI_MASK
operator|)
operator||
operator|(
operator|(
name|vci
operator|<<
literal|4
operator|)
operator|&
name|IDT_TBD_VCI_MASK
operator|)
expr_stmt|;
if|if
condition|(
name|connection
operator|->
name|flg_clp
condition|)
name|val4
operator||=
name|IDT_TBD_LOW_PRIORITY
expr_stmt|;
for|for
control|(
name|i
operator|=
name|ntbd
operator|,
name|m
operator|=
name|top
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
operator|,
name|m
operator|=
name|m
operator|->
name|m_next
control|)
block|{
if|if
condition|(
name|i
operator|==
literal|1
condition|)
operator|*
name|txqueue
operator|->
name|scq_next
operator|++
operator|=
name|IDT_TBD_EOPDU
operator||
name|val1
operator||
name|m
operator|->
name|m_len
expr_stmt|;
else|else
operator|*
name|txqueue
operator|->
name|scq_next
operator|++
operator|=
name|val1
operator||
name|m
operator|->
name|m_len
expr_stmt|;
operator|*
name|txqueue
operator|->
name|scq_next
operator|++
operator|=
name|vtophys
argument_list|(
name|m
operator|->
name|m_data
argument_list|)
expr_stmt|;
operator|*
name|txqueue
operator|->
name|scq_next
operator|++
operator|=
name|tlen
expr_stmt|;
operator|*
name|txqueue
operator|->
name|scq_next
operator|++
operator|=
name|val4
expr_stmt|;
if|if
condition|(
name|txqueue
operator|->
name|scq_next
operator|>=
name|txqueue
operator|->
name|scq_base
operator|+
operator|(
name|IDT_SCQ_ENTRIES
operator|*
literal|4
operator|)
condition|)
name|txqueue
operator|->
name|scq_next
operator|=
name|txqueue
operator|->
name|scq_base
expr_stmt|;
block|}
comment|/*         * Increment ATM stats         */
name|proatm
operator|->
name|pu_stats
operator|.
name|proatm_st_atm
operator|.
name|atm_xmit
operator|+=
operator|(
name|tlen
operator|+
literal|47
operator|)
operator|/
name|BYTES_PER_CELL
expr_stmt|;
comment|/*         * Increment AAL stats         */
switch|switch
condition|(
name|connection
operator|->
name|aal
condition|)
block|{
case|case
name|IDTAAL5
case|:
name|proatm
operator|->
name|pu_stats
operator|.
name|proatm_st_aal5
operator|.
name|aal5_pdu_xmit
operator|++
expr_stmt|;
name|proatm
operator|->
name|pu_stats
operator|.
name|proatm_st_aal5
operator|.
name|aal5_xmit
operator|+=
operator|(
name|tlen
operator|+
literal|47
operator|)
operator|/
name|BYTES_PER_CELL
expr_stmt|;
break|break;
case|case
name|IDTAAL3_4
case|:
name|proatm
operator|->
name|pu_stats
operator|.
name|proatm_st_aal4
operator|.
name|aal4_pdu_xmit
operator|++
expr_stmt|;
name|proatm
operator|->
name|pu_stats
operator|.
name|proatm_st_aal4
operator|.
name|aal4_xmit
operator|+=
operator|(
name|tlen
operator|+
literal|47
operator|)
operator|/
name|BYTES_PER_CELL
expr_stmt|;
break|break;
case|case
name|IDTAAL0
case|:
name|proatm
operator|->
name|pu_stats
operator|.
name|proatm_st_aal0
operator|.
name|aal0_xmit
operator|+=
operator|(
name|tlen
operator|+
literal|47
operator|)
operator|/
name|BYTES_PER_CELL
expr_stmt|;
break|break;
block|}
comment|/*         * Count the PDU stats for this interface.         */
name|proatm
operator|->
name|stats_opdus
operator|++
expr_stmt|;
name|proatm
operator|->
name|stats_obytes
operator|+=
name|tlen
expr_stmt|;
comment|/*         * Counts the stats for this VC.         */
name|connection
operator|->
name|vccinf
operator|->
name|vc_opdus
operator|++
expr_stmt|;
name|connection
operator|->
name|vccinf
operator|->
name|vc_obytes
operator|+=
name|tlen
expr_stmt|;
comment|/*            * Insert a Transmit Status Request with interrupt          */
operator|*
name|txqueue
operator|->
name|scq_next
operator|++
operator|=
name|IDT_TSR
operator||
name|IDT_TBD_TSIF
operator||
operator|(
name|PROATM_PDU_TAG
operator|<<
literal|20
operator|)
expr_stmt|;
operator|*
name|txqueue
operator|->
name|scq_next
operator|++
operator|=
operator|(
name|u_int32_t
operator|)
name|top
expr_stmt|;
operator|*
name|txqueue
operator|->
name|scq_next
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|txqueue
operator|->
name|scq_next
operator|++
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|txqueue
operator|->
name|scq_next
operator|>=
name|txqueue
operator|->
name|scq_base
operator|+
operator|(
name|IDT_SCQ_ENTRIES
operator|*
literal|4
operator|)
condition|)
name|txqueue
operator|->
name|scq_next
operator|=
name|txqueue
operator|->
name|scq_base
expr_stmt|;
name|ntbd
operator|++
expr_stmt|;
name|top
operator|->
name|m_pkthdr
operator|.
name|header
operator|=
name|NULL
expr_stmt|;
name|top
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|tlen
expr_stmt|;
name|scq_space
operator|-=
name|ntbd
expr_stmt|;
name|txqueue
operator|->
name|scq_cur
operator|+=
name|ntbd
expr_stmt|;
name|count
operator|+=
name|ntbd
expr_stmt|;
block|}
comment|/*      * Stats about the number of TBDs that have been added      * to TX_QUEUE->scq_next      */
name|proatm
operator|->
name|pu_stats
operator|.
name|proatm_st_drv
operator|.
name|drv_xm_ntbd
operator|+=
name|count
expr_stmt|;
comment|/*      * Calculate the number of pending TBDs      */
name|scq_pending
operator|=
operator|(
name|txqueue
operator|->
name|scq_next
operator|-
name|txqueue
operator|->
name|scq_last
operator|)
operator|/
literal|4
expr_stmt|;
if|if
condition|(
name|scq_pending
operator|<
literal|0
condition|)
name|scq_pending
operator|+=
name|IDT_SCQ_ENTRIES
expr_stmt|;
comment|/*      * We don't update the SCD if less than half pending and queue is active      */
if|if
condition|(
name|scq_pending
operator|<
name|IDT_SCQ_ENTRIES
operator|/
literal|2
operator|&&
operator|(
name|txqueue
operator|->
name|scq_cur
operator|-
name|scq_pending
operator|)
operator|>
literal|6
condition|)
block|{
name|XPRINT
argument_list|(
literal|"block:    txqueue->scq_cur= %d, scq_pending= %d\n"
argument_list|,
name|txqueue
operator|->
name|scq_cur
argument_list|,
name|scq_pending
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|XPRINT
argument_list|(
literal|"transmit: txqueue->scq_cur= %d, scq_pending= %d\n"
argument_list|,
name|txqueue
operator|->
name|scq_cur
argument_list|,
name|scq_pending
argument_list|)
expr_stmt|;
comment|/*          * If PDUs have been added to the SCQ, give information to the SAR and          * restart the connection if needed.          */
if|#
directive|if
name|XDEBUG
if|if
condition|(
name|count
condition|)
block|{
name|u_int32_t
modifier|*
name|wp
decl_stmt|;
comment|/*              * Dump the SCQ entries.              */
name|XPRINT
argument_list|(
literal|"Add %d SCQEs from 0x%x,\n"
argument_list|,
name|count
argument_list|,
operator|(
name|unsigned
name|int32_t
operator|)
name|txqueue
operator|->
name|scq_last
argument_list|)
expr_stmt|;
name|wp
operator|=
name|txqueue
operator|->
name|scq_last
expr_stmt|;
while|while
condition|(
name|wp
operator|!=
name|txqueue
operator|->
name|scq_next
condition|)
block|{
name|XPRINT
argument_list|(
literal|"0x%x  0x%x  0x%x  0x%x \n"
argument_list|,
operator|*
name|wp
argument_list|,
operator|*
operator|(
name|wp
operator|+
literal|1
operator|)
argument_list|,
operator|*
operator|(
name|wp
operator|+
literal|2
operator|)
argument_list|,
operator|*
operator|(
name|wp
operator|+
literal|3
operator|)
argument_list|)
expr_stmt|;
name|wp
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|wp
operator|>=
name|txqueue
operator|->
name|scq_base
operator|+
operator|(
name|IDT_SCQ_ENTRIES
operator|*
literal|4
operator|)
condition|)
name|wp
operator|=
name|txqueue
operator|->
name|scq_base
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|XPRINT
argument_list|(
literal|"Write 0x%x to SCD 0x%x\n"
argument_list|,
name|vtophys
argument_list|(
name|txqueue
operator|->
name|scq_next
argument_list|)
argument_list|,
name|txqueue
operator|->
name|scd
argument_list|)
expr_stmt|;
comment|/*           * we need to update the SCD queue pointer          */
name|proatm_sram_wr
argument_list|(
name|proatm
argument_list|,
name|txqueue
operator|->
name|scd
argument_list|,
literal|1
argument_list|,
name|vtophys
argument_list|(
name|txqueue
operator|->
name|scq_next
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*          * restart VBR connection if idle          * we don't need to do that in the loop because in VBR there can be only          * one connection per queue          */
if|if
condition|(
name|connection
condition|)
block|{
if|if
condition|(
operator|(
name|connection
operator|->
name|class
operator|==
name|NICVBR
operator|)
operator|&&
operator|!
name|connection
operator|->
name|flg_active
condition|)
block|{
name|proatm_reg_wr
argument_list|(
name|proatm
argument_list|,
name|IDT_TCMDQ_START
operator||
literal|0xff
operator|<<
literal|16
operator||
name|conn
argument_list|,
name|REGTCMDQ
argument_list|)
expr_stmt|;
name|connection
operator|->
name|flg_active
operator|=
literal|1
expr_stmt|;
name|proatm
operator|->
name|pu_stats
operator|.
name|proatm_st_drv
operator|.
name|drv_xm_idlevbr
operator|--
expr_stmt|;
block|}
block|}
if|if
condition|(
name|conn
condition|)
block|{
name|XPRINT
argument_list|(
literal|"SCD 0x%x\n"
argument_list|,
name|txqueue
operator|->
name|scd
argument_list|)
expr_stmt|;
name|XPRINT
argument_list|(
literal|"0x%x 0x%x 0x%x 0x%x\n"
argument_list|,
name|nicsr
argument_list|(
name|proatm
argument_list|,
name|txqueue
operator|->
name|scd
argument_list|)
argument_list|,
name|nicsr
argument_list|(
name|proatm
argument_list|,
name|txqueue
operator|->
name|scd
operator|+
literal|1
argument_list|)
argument_list|,
name|nicsr
argument_list|(
name|proatm
argument_list|,
name|txqueue
operator|->
name|scd
operator|+
literal|2
argument_list|)
argument_list|,
name|nicsr
argument_list|(
name|proatm
argument_list|,
name|txqueue
operator|->
name|scd
operator|+
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|XPRINT
argument_list|(
literal|"0x%x 0x%x 0x%x 0x%x\n"
argument_list|,
name|nicsr
argument_list|(
name|proatm
argument_list|,
name|txqueue
operator|->
name|scd
operator|+
literal|4
argument_list|)
argument_list|,
name|nicsr
argument_list|(
name|proatm
argument_list|,
name|txqueue
operator|->
name|scd
operator|+
literal|5
argument_list|)
argument_list|,
name|nicsr
argument_list|(
name|proatm
argument_list|,
name|txqueue
operator|->
name|scd
operator|+
literal|6
argument_list|)
argument_list|,
name|nicsr
argument_list|(
name|proatm
argument_list|,
name|txqueue
operator|->
name|scd
operator|+
literal|7
argument_list|)
argument_list|)
expr_stmt|;
name|XPRINT
argument_list|(
literal|"0x%x 0x%x 0x%x 0x%x\n"
argument_list|,
name|nicsr
argument_list|(
name|proatm
argument_list|,
name|txqueue
operator|->
name|scd
operator|+
literal|8
argument_list|)
argument_list|,
name|nicsr
argument_list|(
name|proatm
argument_list|,
name|txqueue
operator|->
name|scd
operator|+
literal|9
argument_list|)
argument_list|,
name|nicsr
argument_list|(
name|proatm
argument_list|,
name|txqueue
operator|->
name|scd
operator|+
literal|10
argument_list|)
argument_list|,
name|nicsr
argument_list|(
name|proatm
argument_list|,
name|txqueue
operator|->
name|scd
operator|+
literal|11
argument_list|)
argument_list|)
expr_stmt|;
name|XPRINT
argument_list|(
literal|"TCT, connection = %d:\n"
argument_list|,
name|conn
argument_list|)
expr_stmt|;
name|XPRINT
argument_list|(
literal|"0x%x 0x%x 0x%x 0x%x\n"
argument_list|,
name|nicsr
argument_list|(
name|proatm
argument_list|,
name|conn
operator|*
literal|8
argument_list|)
argument_list|,
name|nicsr
argument_list|(
name|proatm
argument_list|,
name|conn
operator|*
literal|8
operator|+
literal|1
argument_list|)
argument_list|,
name|nicsr
argument_list|(
name|proatm
argument_list|,
name|conn
operator|*
literal|8
operator|+
literal|2
argument_list|)
argument_list|,
name|nicsr
argument_list|(
name|proatm
argument_list|,
name|conn
operator|*
literal|8
operator|+
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|XPRINT
argument_list|(
literal|"0x%x 0x%x 0x%x 0x%x\n"
argument_list|,
name|nicsr
argument_list|(
name|proatm
argument_list|,
name|conn
operator|*
literal|8
operator|+
literal|4
argument_list|)
argument_list|,
name|nicsr
argument_list|(
name|proatm
argument_list|,
name|conn
operator|*
literal|8
operator|+
literal|5
argument_list|)
argument_list|,
name|nicsr
argument_list|(
name|proatm
argument_list|,
name|conn
operator|*
literal|8
operator|+
literal|6
argument_list|)
argument_list|,
name|nicsr
argument_list|(
name|proatm
argument_list|,
name|conn
operator|*
literal|8
operator|+
literal|7
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|txqueue
operator|->
name|scq_last
operator|=
name|txqueue
operator|->
name|scq_next
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/******************************************************************************  *  *  Handle a TSR.  *  m_freem the mbuf that had been sent by proatm_transmit.  *  *  Called at splimp() by proatm_intr_tsq()  *  *  in:  PROATM device, TSR pointer  *  */
end_comment

begin_function
specifier|static
name|void
name|proatm_process_tsr
parameter_list|(
name|PROATM
modifier|*
name|proatm
parameter_list|,
name|u_int32_t
modifier|*
name|tsr_ptr
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|mw
decl_stmt|;
name|int32_t
name|ntbd
decl_stmt|;
name|TX_QUEUE
modifier|*
name|txqueue
decl_stmt|;
name|CONNECTION
modifier|*
name|connection
decl_stmt|;
name|m
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
name|tsr_ptr
index|[
literal|0
index|]
expr_stmt|;
comment|/* top of chain */
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
comment|/*         * look for TBD number since we cannot store it inside         * m_pkthdr.csum_data to be compatible with kernel version 3.5         */
for|for
control|(
name|mw
operator|=
name|m
operator|,
name|ntbd
operator|=
literal|1
init|;
name|mw
operator|!=
name|NULL
condition|;
name|mw
operator|=
name|mw
operator|->
name|m_next
control|)
name|ntbd
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|KB_ISPKT
argument_list|(
name|m
argument_list|)
condition|)
name|panic
argument_list|(
name|__FUNCTION__
literal|" missing M_PKTHDR"
argument_list|)
expr_stmt|;
name|connection
operator|=
operator|(
name|CONNECTION
operator|*
operator|)
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
expr_stmt|;
if|if
condition|(
name|connection
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"proatm%d: Error, NULL connection\n"
argument_list|,
name|proatm
operator|->
name|unit
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|txqueue
operator|=
name|connection
operator|->
name|queue
expr_stmt|;
if|if
condition|(
name|txqueue
operator|==
name|NULL
condition|)
name|printf
argument_list|(
literal|"proatm%d: Error, NULL txqueue\n"
argument_list|,
name|proatm
operator|->
name|unit
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* s = splimp() set by the caller */
name|txqueue
operator|->
name|scq_cur
operator|-=
name|ntbd
expr_stmt|;
if|if
condition|(
name|txqueue
operator|->
name|scq_cur
operator|<
literal|0
operator|||
name|txqueue
operator|->
name|scq_cur
operator|>
name|IDT_SCQ_ENTRIES
condition|)
name|printf
argument_list|(
literal|"proatm%d: DANGER! scq_cur is %d\n"
argument_list|,
name|proatm
operator|->
name|unit
argument_list|,
name|IDT_SCQ_ENTRIES
argument_list|)
expr_stmt|;
name|proatm_transmit_top
argument_list|(
name|proatm
argument_list|,
name|txqueue
argument_list|)
expr_stmt|;
comment|/* move more into SCQ */
comment|/* splx(x) */
block|}
block|}
name|m
operator|->
name|m_pkthdr
operator|.
name|header
operator|=
name|NULL
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* the one provided to proatm_transmit() */
block|}
else|else
name|printf
argument_list|(
literal|"proatm%d: Error, NULL pointer in TSQE\n"
argument_list|,
name|proatm
operator|->
name|unit
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************************  *  *  Handle entries in Transmit Status Queue (end of PDU interrupt or TSQ full)  *  *  in:  PROATM device  *  */
end_comment

begin_function
specifier|static
name|void
name|proatm_intr_tsq
parameter_list|(
name|PROATM
modifier|*
name|proatm
parameter_list|)
block|{
name|CONNECTION
modifier|*
name|connection
decl_stmt|;
name|u_int32_t
modifier|*
name|tsq_ptr
decl_stmt|;
name|u_int32_t
name|val
decl_stmt|;
name|int32_t
name|count
decl_stmt|,
name|s
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|tsq_ptr
operator|=
name|proatm
operator|->
name|tsq_head
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|tsq_ptr
index|[
literal|1
index|]
operator|&
name|IDT_TSI_EMPTY
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* This should never occur */
if|if
condition|(
name|count
operator|>
operator|(
name|PROATM_TSQ_SIZE
operator|/
literal|8
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"proatm%d: TSQ Buffer Overflow (count=%d)\n"
argument_list|,
name|proatm
operator|->
name|unit
argument_list|,
name|count
argument_list|)
expr_stmt|;
break|break;
block|}
name|XPRINT
argument_list|(
literal|"Processed TSQE= 0x%x 0x%x\n"
argument_list|,
name|tsq_ptr
index|[
literal|0
index|]
argument_list|,
name|tsq_ptr
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|tsq_ptr
index|[
literal|1
index|]
operator|&
name|IDT_TSI_TYPE_MASK
condition|)
block|{
case|case
name|IDT_TSI_TYPE_TSR
case|:
block|{
if|if
condition|(
operator|(
name|tsq_ptr
index|[
literal|1
index|]
operator|&
name|IDT_TSI_TAG_MASK
operator|)
operator|==
literal|0
condition|)
block|{
name|int32_t
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|tsq_ptr
index|[
literal|1
index|]
operator|&
name|IDT_TSI_TAG_MASK
operator|)
operator|==
literal|0
operator|&&
name|i
operator|<
literal|1000
condition|)
block|{
name|DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
comment|/* race condition */
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
literal|1000
condition|)
name|printf
argument_list|(
literal|"proatm%d, TSI update error\n"
argument_list|,
name|proatm
operator|->
name|unit
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|tsq_ptr
index|[
literal|1
index|]
operator|&
name|IDT_TSI_TAG_MASK
operator|)
operator|==
operator|(
name|PROATM_CLOSE_TAG
operator|<<
literal|24
operator|)
condition|)
block|{
comment|/* we must close this connection */
name|proatm_connect_txclose_cb
argument_list|(
name|proatm
argument_list|,
operator|(
name|CONNECTION
operator|*
operator|)
name|tsq_ptr
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|tsq_ptr
index|[
literal|1
index|]
operator|&
name|IDT_TSI_TAG_MASK
operator|)
operator|==
operator|(
name|PROATM_PDU_TAG
operator|<<
literal|24
operator|)
condition|)
block|{
comment|/* we must free the TBDs and the mbuf chain related to this TSR*/
name|proatm_process_tsr
argument_list|(
name|proatm
argument_list|,
name|tsq_ptr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"proatm%d: Unknown TSR: 0x%x 0x%x\n"
argument_list|,
name|proatm
operator|->
name|unit
argument_list|,
operator|(
name|u_int32_t
operator|)
name|tsq_ptr
index|[
literal|0
index|]
argument_list|,
operator|(
name|u_int32_t
operator|)
name|tsq_ptr
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|IDT_TSI_TYPE_IDLE
case|:
block|{
name|int32_t
name|conn
init|=
name|tsq_ptr
index|[
literal|0
index|]
operator|&
literal|0x3fff
decl_stmt|;
if|if
condition|(
name|conn
operator|<
name|proatm
operator|->
name|max_connection
condition|)
block|{
name|connection
operator|=
operator|&
name|proatm
operator|->
name|connection
index|[
name|conn
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|connection
operator|->
name|flg_active
condition|)
name|printf
argument_list|(
literal|"proatm%d: Double idle of VPI=%d/VCI=%d\n"
argument_list|,
name|proatm
operator|->
name|unit
argument_list|,
name|connection
operator|->
name|vpi
argument_list|,
name|connection
operator|->
name|vci
argument_list|)
expr_stmt|;
name|connection
operator|->
name|flg_active
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|connection
operator|->
name|class
operator|==
name|NICVBR
condition|)
name|proatm
operator|->
name|pu_stats
operator|.
name|proatm_st_drv
operator|.
name|drv_xm_idlevbr
operator|++
expr_stmt|;
comment|/* XXX: What's about UBR, UBR0 and may be ABR ?? */
block|}
block|}
break|break;
case|case
name|IDT_TSI_TYPE_TMROF
case|:
name|XPRINT
argument_list|(
literal|"proatm%d: TSI Timer Overflow\n"
argument_list|,
name|proatm
operator|->
name|unit
argument_list|)
expr_stmt|;
break|break;
case|case
name|IDT_TSI_TYPE_TBD
case|:
name|printf
argument_list|(
literal|"proatm%d: TSI TBD\n"
argument_list|,
name|proatm
operator|->
name|unit
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"proatm%d: Unknown TSI type\n"
argument_list|,
name|proatm
operator|->
name|unit
argument_list|)
expr_stmt|;
break|break;
block|}
name|tsq_ptr
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|tsq_ptr
index|[
literal|1
index|]
operator|=
name|IDT_TSI_EMPTY
expr_stmt|;
comment|/* reset TSQ entry */
name|tsq_ptr
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|tsq_ptr
operator|>=
name|proatm
operator|->
name|tsq_base
operator|+
name|proatm
operator|->
name|tsq_size
operator|*
literal|2
condition|)
name|tsq_ptr
operator|=
name|proatm
operator|->
name|tsq_base
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
name|proatm
operator|->
name|tsq_head
operator|=
name|tsq_ptr
expr_stmt|;
if|if
condition|(
name|count
condition|)
block|{
name|val
operator|=
operator|(
name|int32_t
operator|)
name|tsq_ptr
operator|-
operator|(
name|int32_t
operator|)
name|proatm
operator|->
name|tsq_base
expr_stmt|;
name|val
operator|-=
literal|8
expr_stmt|;
comment|/* always stay one behind */
name|val
operator|&=
literal|0x001ffc
expr_stmt|;
name|proatm_reg_wr
argument_list|(
name|proatm
argument_list|,
name|val
argument_list|,
name|REGTSQH
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************************  *  *    proatm_itrx ( card )  *  *    service error in transmitting PDU interrupt.  * */
end_comment

begin_function
specifier|static
name|void
name|proatm_itrx
parameter_list|(
name|proatm_reg_t
modifier|*
name|proatm
parameter_list|)
block|{
comment|/* trace mbuf and release */
name|proatm
operator|->
name|pu_stats
operator|.
name|proatm_st_drv
operator|.
name|drv_xm_txicp
operator|++
expr_stmt|;
name|proatm
operator|->
name|stats_oerrors
operator|++
expr_stmt|;
comment|/* XXX: How should the mbuf be released ?? */
block|}
end_function

begin_comment
comment|/******************************************************************************  *  *  Raw cell process  *  *    Do something with raw cell   *  */
end_comment

begin_function
name|void
name|proatm_process_rcqe
parameter_list|(
name|proatm_reg_t
modifier|*
name|proatm
parameter_list|,
name|rcqe
modifier|*
name|rawcell
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
block|{
comment|/* out of mbuf */
name|proatm
operator|->
name|pu_stats
operator|.
name|proatm_st_drv
operator|.
name|drv_rv_rnobufs
operator|++
expr_stmt|;
name|proatm
operator|->
name|stats_ierrors
operator|++
expr_stmt|;
return|return;
block|}
name|m
operator|->
name|m_len
operator|=
name|BYTES_PER_CELL
operator|+
literal|5
expr_stmt|;
comment|/* 53 */
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|BYTES_PER_CELL
operator|+
literal|5
expr_stmt|;
comment|/* 53 */
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|NULL
expr_stmt|;
name|m
operator|->
name|m_data
operator|=
operator|(
name|caddr_t
operator|)
name|rawcell
expr_stmt|;
comment|/* XXX */
comment|/* XXX: m_data must not be freeed */
name|proatm
operator|->
name|pu_stats
operator|.
name|proatm_st_atm
operator|.
name|atm_rcvd
operator|++
expr_stmt|;
comment|/* consume */
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* else process it */
name|XPRINT
argument_list|(
literal|"proatm_process_rcqe: nothing to do with raw cells for now\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************************  *  *  Raw cell receive interrupt  *  *    service raw cell reception interrupt.  *  */
end_comment

begin_function
specifier|static
name|void
name|proatm_rawc
parameter_list|(
name|proatm_reg_t
modifier|*
name|proatm
parameter_list|)
block|{
name|rcqe
modifier|*
name|rawcell
decl_stmt|;
name|u_int32_t
name|tail
decl_stmt|;
if|if
condition|(
name|proatm
operator|->
name|raw_headm
operator|==
name|NULL
operator|||
name|proatm
operator|->
name|raw_headp
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"proatm%d: RAW cell received, buffers not ready (%x/%x.\n"
argument_list|,
name|proatm
operator|->
name|unit
argument_list|,
operator|(
name|int32_t
operator|)
name|proatm
operator|->
name|raw_headm
argument_list|,
operator|(
name|int32_t
operator|)
name|proatm
operator|->
name|raw_headp
argument_list|)
expr_stmt|;
name|proatm
operator|->
name|pu_stats
operator|.
name|proatm_st_drv
operator|.
name|drv_rv_rnotrdy
operator|++
expr_stmt|;
name|proatm
operator|->
name|stats_ierrors
operator|++
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|proatm
operator|->
name|raw_hnd
index|[
literal|0
index|]
operator|==
literal|0
condition|)
return|return;
name|tail
operator|=
name|proatm
operator|->
name|raw_hnd
index|[
literal|0
index|]
operator|+
name|IDT_RCQE_SIZE
expr_stmt|;
while|while
condition|(
name|vtophys
argument_list|(
name|proatm
operator|->
name|raw_ch
argument_list|)
operator|!=
name|tail
condition|)
block|{
name|rawcell
operator|=
name|proatm
operator|->
name|raw_ch
expr_stmt|;
if|if
condition|(
name|rawcell
operator|->
name|word_2
operator|!=
literal|0
condition|)
block|{
comment|/* last cell */
name|struct
name|mbuf
modifier|*
name|oldbuf
init|=
name|proatm
operator|->
name|raw_headm
decl_stmt|;
name|proatm
operator|->
name|raw_headm
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
name|rawcell
operator|->
name|word_2
expr_stmt|;
name|proatm
operator|->
name|raw_ch
operator|=
operator|(
name|rcqe
operator|*
operator|)
operator|(
name|proatm
operator|->
name|raw_headm
operator|->
name|m_data
operator|)
expr_stmt|;
name|proatm
operator|->
name|raw_headp
operator|=
name|rawcell
operator|->
name|word_1
expr_stmt|;
name|proatm_mcheck_rem
argument_list|(
name|proatm
argument_list|,
name|oldbuf
argument_list|)
expr_stmt|;
name|m_free
argument_list|(
name|oldbuf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* this is not the last buffer cell, so it is not empty */
name|proatm_process_rcqe
argument_list|(
name|proatm
argument_list|,
name|rawcell
argument_list|)
expr_stmt|;
name|proatm
operator|->
name|raw_ch
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*****************************************************************************  *  *  Handle AAL5 PDU length  *  *  in:  PROATM device, first mbuf in chain, last mbuf  * out:  zero = success, nz = failure (mbuf chain freed)  *  */
end_comment

begin_function
specifier|static
name|int32_t
name|proatm_receive_aal5
parameter_list|(
name|PROATM
modifier|*
name|proatm
parameter_list|,
name|struct
name|mbuf
modifier|*
name|mfirst
parameter_list|,
name|struct
name|mbuf
modifier|*
name|mdata
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m2
decl_stmt|;
name|unsigned
name|char
modifier|*
name|aal5len
decl_stmt|;
name|int32_t
name|plen
decl_stmt|;
name|int32_t
name|diff
decl_stmt|;
name|aal5len
operator|=
name|mdata
operator|->
name|m_data
operator|+
name|mdata
operator|->
name|m_len
operator|-
literal|6
expr_stmt|;
comment|/* aal5 length = 16 bits */
name|plen
operator|=
name|aal5len
index|[
literal|0
index|]
operator|*
literal|256
operator|+
name|aal5len
index|[
literal|1
index|]
expr_stmt|;
name|diff
operator|=
name|mfirst
operator|->
name|m_pkthdr
operator|.
name|len
operator|-
name|plen
expr_stmt|;
comment|/* number of bytes to trim */
if|if
condition|(
name|diff
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|diff
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"proatm%d: AAL5 PDU length (%d) greater than cells (%d), discarding\n"
argument_list|,
name|proatm
operator|->
name|unit
argument_list|,
name|plen
argument_list|,
name|mfirst
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|mfirst
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
while|while
condition|(
name|mdata
operator|->
name|m_len
operator|<
name|diff
condition|)
block|{
comment|/* last mbuf not big enough */
name|diff
operator|-=
name|mdata
operator|->
name|m_len
expr_stmt|;
name|m2
operator|=
name|mdata
expr_stmt|;
name|m_free
argument_list|(
name|mdata
argument_list|)
expr_stmt|;
if|if
condition|(
name|mdata
operator|==
name|mfirst
condition|)
block|{
comment|/* we just tossed the whole PDU */
name|printf
argument_list|(
literal|"proatm%d: AAL5 PDU length failed, discarding.\n"
argument_list|,
name|proatm
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
comment|/* the packetheadr length was bad! */
block|}
for|for
control|(
name|mdata
operator|=
name|mfirst
init|;
name|mdata
operator|->
name|m_next
operator|!=
name|m2
condition|;
name|mdata
operator|=
name|mdata
operator|->
name|m_next
control|)
empty_stmt|;
name|mdata
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
comment|/* remove old link to free'd mbuf */
block|}
name|mdata
operator|->
name|m_len
operator|-=
name|diff
expr_stmt|;
comment|/* trim last mbuf */
name|mfirst
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|plen
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************  *  *    proatm_recv ( card )  *  *    rebuilds PDUs from entries in the Receive Status Queue.  *  */
end_comment

begin_struct
struct|struct
name|rsq_entry
block|{
name|u_int32_t
name|vpivci
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mdata
decl_stmt|;
name|u_int32_t
name|crc
decl_stmt|;
name|u_int32_t
name|flags
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|proatm_recv
parameter_list|(
name|proatm_reg_t
modifier|*
name|proatm
parameter_list|)
block|{
name|CONNECTION
modifier|*
name|connection
init|=
name|NULL
decl_stmt|;
name|struct
name|rsq_entry
modifier|*
name|rsq
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mdata
decl_stmt|,
modifier|*
name|mptr
decl_stmt|;
name|u_int32_t
name|flags
decl_stmt|;
name|u_int32_t
name|crc
decl_stmt|;
name|int32_t
name|vpi
decl_stmt|;
name|int32_t
name|vci
decl_stmt|;
name|int32_t
name|clen
decl_stmt|;
name|int32_t
name|x
decl_stmt|,
name|s
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|rsq
operator|=
operator|(
expr|struct
name|rsq_entry
operator|*
operator|)
operator|(
name|proatm
operator|->
name|fixbuf
operator|+
name|PROATM_RSQ_OFFSET
operator|+
operator|(
name|proatm
operator|->
name|rsqh
operator|&
literal|0x1ffc
operator|)
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|rsq
operator|->
name|flags
operator|&
name|IDT_RSQE_VALID
operator|)
operator|==
literal|0
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|rsq
operator|->
name|flags
operator|&
name|IDT_RSQE_VALID
condition|)
block|{
name|vpi
operator|=
name|rsq
operator|->
name|vpivci
operator|>>
literal|16
expr_stmt|;
comment|/* first, grab the RSQ data */
name|vci
operator|=
name|rsq
operator|->
name|vpivci
operator|&
literal|0xffff
expr_stmt|;
name|mdata
operator|=
name|rsq
operator|->
name|mdata
expr_stmt|;
name|crc
operator|=
name|rsq
operator|->
name|crc
expr_stmt|;
name|flags
operator|=
name|rsq
operator|->
name|flags
expr_stmt|;
name|clen
operator|=
operator|(
name|flags
operator|&
literal|0x1ff
operator|)
operator|*
literal|48
expr_stmt|;
name|rsq
operator|->
name|vpivci
operator|=
literal|0
expr_stmt|;
comment|/* now recycle the RSQ entry */
name|rsq
operator|->
name|mdata
operator|=
name|NULL
expr_stmt|;
name|rsq
operator|->
name|crc
operator|=
literal|0
expr_stmt|;
name|rsq
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
comment|/* turn off valid bit */
name|rsq
operator|++
expr_stmt|;
if|if
condition|(
name|rsq
operator|==
operator|(
expr|struct
name|rsq_entry
operator|*
operator|)
operator|(
name|proatm
operator|->
name|fixbuf
operator|+
name|PROATM_RSQ_OFFSET
operator|+
name|PROATM_RSQ_SIZE
operator|)
condition|)
name|rsq
operator|=
operator|(
expr|struct
name|rsq_entry
operator|*
operator|)
operator|(
name|proatm
operator|->
name|fixbuf
operator|+
name|PROATM_RSQ_OFFSET
operator|)
expr_stmt|;
name|proatm_mcheck_rem
argument_list|(
name|proatm
argument_list|,
name|mdata
argument_list|)
expr_stmt|;
name|connection
operator|=
name|proatm_connect_find
argument_list|(
name|proatm
argument_list|,
name|vpi
argument_list|,
name|vci
argument_list|)
expr_stmt|;
if|if
condition|(
name|connection
operator|==
name|NULL
condition|)
block|{
comment|/* we don't want this PDU */
name|printf
argument_list|(
literal|"proatm%d: no connection %d/%d - discarding packet.\n"
argument_list|,
name|proatm
operator|->
name|unit
argument_list|,
name|vpi
argument_list|,
name|vci
argument_list|)
expr_stmt|;
name|proatm
operator|->
name|pu_stats
operator|.
name|proatm_st_drv
operator|.
name|drv_rv_nocx
operator|++
expr_stmt|;
name|proatm
operator|->
name|stats_ierrors
operator|++
expr_stmt|;
name|m_free
argument_list|(
name|mdata
argument_list|)
expr_stmt|;
comment|/* throw mbuf away */
continue|continue;
block|}
name|mdata
operator|->
name|m_len
operator|=
name|clen
expr_stmt|;
name|mptr
operator|=
name|connection
operator|->
name|recv
expr_stmt|;
if|if
condition|(
name|mptr
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|mdata
operator|->
name|m_flags
operator|&
name|M_PKTHDR
condition|)
name|connection
operator|->
name|recv
operator|=
name|mdata
expr_stmt|;
else|else
block|{
name|proatm
operator|->
name|pu_stats
operator|.
name|proatm_st_drv
operator|.
name|drv_rv_nopkthdr
operator|++
expr_stmt|;
name|proatm
operator|->
name|stats_ierrors
operator|++
expr_stmt|;
name|connection
operator|->
name|vccinf
operator|->
name|vc_ierrors
operator|++
expr_stmt|;
name|m_free
argument_list|(
name|mdata
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
else|else
block|{
name|x
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|mptr
operator|->
name|m_next
operator|!=
name|NULL
condition|)
block|{
comment|/* find last mbuf in chain */
name|mptr
operator|=
name|mptr
operator|->
name|m_next
expr_stmt|;
name|x
operator|++
expr_stmt|;
if|if
condition|(
name|x
operator|>
literal|25
condition|)
break|break;
block|}
if|if
condition|(
name|x
operator|>
literal|25
condition|)
block|{
name|mptr
operator|=
name|connection
operator|->
name|recv
expr_stmt|;
name|printf
argument_list|(
literal|"proatm%d: invalid mbuf chain - probable corruption!\n"
argument_list|,
name|proatm
operator|->
name|unit
argument_list|)
expr_stmt|;
name|m_free
argument_list|(
name|mdata
argument_list|)
expr_stmt|;
name|proatm
operator|->
name|pu_stats
operator|.
name|proatm_st_drv
operator|.
name|drv_rv_invchain
operator|++
expr_stmt|;
name|proatm
operator|->
name|stats_ierrors
operator|++
expr_stmt|;
name|connection
operator|->
name|vccinf
operator|->
name|vc_ierrors
operator|++
expr_stmt|;
name|connection
operator|->
name|recv
operator|=
name|NULL
expr_stmt|;
name|connection
operator|->
name|rlen
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
name|mptr
operator|->
name|m_next
operator|=
name|mdata
expr_stmt|;
block|}
name|connection
operator|->
name|rlen
operator|+=
name|clen
expr_stmt|;
if|if
condition|(
name|flags
operator|&
literal|0x2000
condition|)
block|{
comment|/* end of PDU */
name|mptr
operator|=
name|connection
operator|->
name|recv
expr_stmt|;
comment|/* one or more mbufs will be here */
name|clen
operator|=
name|connection
operator|->
name|rlen
expr_stmt|;
comment|/* length based on cell count */
name|connection
operator|->
name|recv
operator|=
name|NULL
expr_stmt|;
name|connection
operator|->
name|rlen
operator|=
literal|0
expr_stmt|;
name|mptr
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|clen
expr_stmt|;
comment|/* M_PKTHDR has already been tested */
name|mptr
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|NULL
expr_stmt|;
name|mptr
operator|->
name|m_nextpkt
operator|=
name|NULL
expr_stmt|;
ifndef|#
directive|ifndef
name|FBSD35
if|if
condition|(
name|mptr
operator|->
name|m_pkthdr
operator|.
name|csum_flags
condition|)
block|{
name|printf
argument_list|(
literal|"proatm%d: received pkthdr.csum_flags=%x\n"
argument_list|,
name|proatm
operator|->
name|unit
argument_list|,
name|mptr
operator|->
name|m_pkthdr
operator|.
name|csum_flags
argument_list|)
expr_stmt|;
name|mptr
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|flags
operator|&
literal|0x200
operator|&&
comment|/* bad CRC */
name|proatm
operator|->
name|flg_igcrc
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"proatm%d: bad CRC - discarding PDU: %d/%d\n"
argument_list|,
name|proatm
operator|->
name|unit
argument_list|,
name|vpi
argument_list|,
name|vci
argument_list|)
expr_stmt|;
comment|/*                  * Update interface stats                  */
name|proatm
operator|->
name|stats_ierrors
operator|++
expr_stmt|;
comment|/*                  * Update VC stats                  */
name|connection
operator|->
name|vccinf
operator|->
name|vc_ierrors
operator|++
expr_stmt|;
if|if
condition|(
name|connection
operator|->
name|aal
operator|==
name|IDTAAL5
condition|)
block|{
comment|/*                      * Update AAL5 stats                      */
name|proatm
operator|->
name|pu_stats
operator|.
name|proatm_st_aal5
operator|.
name|aal5_pdu_crc
operator|++
expr_stmt|;
name|proatm
operator|->
name|pu_stats
operator|.
name|proatm_st_aal5
operator|.
name|aal5_pdu_drops
operator|++
expr_stmt|;
name|proatm
operator|->
name|pu_stats
operator|.
name|proatm_st_aal5
operator|.
name|aal5_drops
operator|+=
name|mptr
operator|->
name|m_pkthdr
operator|.
name|len
operator|/
name|BYTES_PER_CELL
expr_stmt|;
name|proatm
operator|->
name|pu_stats
operator|.
name|proatm_st_aal5
operator|.
name|aal5_crc_len
operator|+=
name|mptr
operator|->
name|m_pkthdr
operator|.
name|len
operator|/
name|BYTES_PER_CELL
expr_stmt|;
block|}
comment|/* else                  * what's about IDTAAL3_4 ?                  *  proatm->pu_stats.proatm_st_aal4.aal4_pdu_crc++;                  *  proatm->pu_stats.proatm_st_aal4.aal4_pdu_errs++;                  *  proatm->pu_stats.proatm_st_aal4.aal4_pdu_drops++;                  *  proatm->pu_stats.proatm_st_aal4.aal4_drops +=                  *      mptr->m_pkthdr.len / BYTES_PER_CELL;                  *  proatm->pu_stats.proatm_st_aal4.aal4_crc +=                  *       mptr->m_pkthdr.len / BYTES_PER_CELL;                  */
name|m_freem
argument_list|(
name|mptr
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/*              * OK, it is a nice looking PDU. Forward to the              * upper layers.              */
comment|/*              * Increment cells/pdu received stats.              */
name|proatm
operator|->
name|pu_stats
operator|.
name|proatm_st_atm
operator|.
name|atm_rcvd
operator|+=
name|mptr
operator|->
name|m_pkthdr
operator|.
name|len
operator|/
name|BYTES_PER_CELL
expr_stmt|;
switch|switch
condition|(
name|connection
operator|->
name|aal
condition|)
block|{
case|case
name|IDTAAL5
case|:
if|if
condition|(
name|proatm_receive_aal5
argument_list|(
name|proatm
argument_list|,
name|mptr
argument_list|,
name|mdata
argument_list|)
condition|)
comment|/* adjust for AAL5 length */
continue|continue;
name|proatm
operator|->
name|pu_stats
operator|.
name|proatm_st_aal5
operator|.
name|aal5_pdu_rcvd
operator|++
expr_stmt|;
name|proatm
operator|->
name|pu_stats
operator|.
name|proatm_st_aal5
operator|.
name|aal5_rcvd
operator|+=
name|mptr
operator|->
name|m_pkthdr
operator|.
name|len
operator|/
name|BYTES_PER_CELL
expr_stmt|;
break|break;
case|case
name|IDTAAL3_4
case|:
name|proatm
operator|->
name|pu_stats
operator|.
name|proatm_st_aal4
operator|.
name|aal4_pdu_rcvd
operator|++
expr_stmt|;
name|proatm
operator|->
name|pu_stats
operator|.
name|proatm_st_aal4
operator|.
name|aal4_rcvd
operator|+=
name|mptr
operator|->
name|m_pkthdr
operator|.
name|len
operator|/
name|BYTES_PER_CELL
expr_stmt|;
break|break;
case|case
name|IDTAAL0
case|:
name|proatm
operator|->
name|pu_stats
operator|.
name|proatm_st_aal0
operator|.
name|aal0_rcvd
operator|+=
name|mptr
operator|->
name|m_pkthdr
operator|.
name|len
operator|/
name|BYTES_PER_CELL
expr_stmt|;
break|break;
case|case
name|IDTAAL1
case|:
default|default:
break|break;
block|}
comment|/*              * Count the PDU stats for this interface.              */
name|proatm
operator|->
name|stats_ipdus
operator|++
expr_stmt|;
name|proatm
operator|->
name|stats_ibytes
operator|+=
name|mptr
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
comment|/*              * Counts the stats for this VC.              */
name|connection
operator|->
name|vccinf
operator|->
name|vc_ipdus
operator|++
expr_stmt|;
name|connection
operator|->
name|vccinf
operator|->
name|vc_ibytes
operator|+=
name|mptr
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|proatm_receive
argument_list|(
name|proatm
argument_list|,
name|mptr
argument_list|,
name|vpi
argument_list|,
name|vci
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|connection
operator|->
name|rlen
operator|>
name|connection
operator|->
name|maxpdu
condition|)
block|{
comment|/* this packet is insane */
name|printf
argument_list|(
literal|"proatm%d: bad packet, len=%d - discarding.\n"
argument_list|,
name|proatm
operator|->
name|unit
argument_list|,
name|connection
operator|->
name|rlen
argument_list|)
expr_stmt|;
name|connection
operator|->
name|recv
operator|=
name|NULL
expr_stmt|;
name|connection
operator|->
name|rlen
operator|=
literal|0
expr_stmt|;
name|proatm
operator|->
name|pu_stats
operator|.
name|proatm_st_drv
operator|.
name|drv_rv_toobigpdu
operator|++
expr_stmt|;
name|proatm
operator|->
name|stats_ierrors
operator|++
expr_stmt|;
name|connection
operator|->
name|vccinf
operator|->
name|vc_ierrors
operator|++
expr_stmt|;
if|if
condition|(
name|connection
operator|->
name|aal
operator|==
name|IDTAAL5
condition|)
block|{
comment|/*                  * Update AAL5 stats                  */
name|proatm
operator|->
name|pu_stats
operator|.
name|proatm_st_aal5
operator|.
name|aal5_pdu_drops
operator|++
expr_stmt|;
name|proatm
operator|->
name|pu_stats
operator|.
name|proatm_st_aal5
operator|.
name|aal5_drops
operator|+=
name|connection
operator|->
name|rlen
operator|/
name|BYTES_PER_CELL
expr_stmt|;
block|}
comment|/* else              * what's about IDTAAL3_4 ?              *  proatm->pu_stats.proatm_st_aal4.aal4_pdu_drops++;              *  proatm->pu_stats.proatm_st_aal4.aal4_pdu_errs++;              *  proatm->pu_stats.proatm_st_aal4.aal4_drops +=              *      connection->rlen / BYTES_PER_CELL;              */
name|m_freem
argument_list|(
name|mptr
argument_list|)
expr_stmt|;
block|}
comment|/* end of PDU */
block|}
name|proatm
operator|->
name|rsqh
operator|=
name|vtophys
argument_list|(
operator|(
name|u_int32_t
operator|)
name|rsq
argument_list|)
operator|&
literal|0x1ffc
expr_stmt|;
name|proatm_reg_wr
argument_list|(
name|proatm
argument_list|,
operator|(
name|proatm
operator|->
name|rsqh
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|rsq_entry
argument_list|)
operator|)
operator|&
literal|0x1ff0
argument_list|,
name|REGRSQH
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************************  *  *  Physical Interrupt handler  *  *  service physical interrupt.  *  */
end_comment

begin_function
specifier|static
name|void
name|proatm_phys
parameter_list|(
name|proatm_reg_t
modifier|*
name|proatm
parameter_list|)
block|{
name|u_int32_t
name|t
decl_stmt|;
if|if
condition|(
name|proatm
operator|->
name|flg_25
condition|)
block|{
name|proatm_util_rd
argument_list|(
name|proatm
argument_list|,
name|IDT77105_ISTAT_REG
argument_list|,
operator|&
name|t
argument_list|)
expr_stmt|;
comment|/* get interrupt cause */
if|if
condition|(
name|t
operator|&
literal|0x01
condition|)
block|{
comment|/* Is it due to Rx FIFO Overrun  ? */
name|proatm_util_wr
argument_list|(
name|proatm
argument_list|,
name|IDT77105_DIAG_REG
argument_list|,
literal|0x10
argument_list|)
expr_stmt|;
comment|/* reset rx fifo, RFLUSH 			                                                     * clear receive FIFO */
name|printf
argument_list|(
literal|"proatm%d: PHY cleared.\n"
argument_list|,
name|proatm
operator|->
name|unit
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|proatm_util_rd
argument_list|(
name|proatm
argument_list|,
name|SUNI_RSOP_SIS_REG
argument_list|,
operator|&
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|&
literal|0x01
condition|)
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"proatm%d: PHYS out of frame"
argument_list|,
name|proatm
operator|->
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|&
literal|0x02
condition|)
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"proatm%d: PHYS loss of frame"
argument_list|,
name|proatm
operator|->
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|&
literal|0x04
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"proatm%d: PHYS loss of signal"
argument_list|,
name|proatm
operator|->
name|unit
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__not_yet__
name|proatm
operator|->
name|XXX
operator|->
name|phys
operator|=
name|ATM_PHY_SIG_DOWN
expr_stmt|;
endif|#
directive|endif
block|}
block|}
block|}
end_function

begin_comment
comment|/******************************************************************************  *  *  Interrupt handler  *  *    service card interrupt.  *  *    proatm_intr ( card )  */
end_comment

begin_function
specifier|static
name|void
name|proatm_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|PROATM
modifier|*
name|proatm
init|=
operator|(
name|PROATM
operator|*
operator|)
name|arg
decl_stmt|;
specifier|volatile
name|u_int32_t
name|stat_val
decl_stmt|,
name|config_val
decl_stmt|;
specifier|volatile
name|int32_t
name|i
init|=
literal|0
decl_stmt|;
name|config_val
operator|=
name|proatm_reg_rd
argument_list|(
name|proatm
argument_list|,
name|REGCFG
argument_list|)
expr_stmt|;
name|stat_val
operator|=
name|proatm_reg_rd
argument_list|(
name|proatm
argument_list|,
name|REGSTAT
argument_list|)
expr_stmt|;
comment|/* loop until no more interrupts to service */
while|while
condition|(
name|stat_val
operator|&
name|INT_FLAGS
condition|)
block|{
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
operator|||
name|i
operator|>
literal|100
condition|)
break|break;
comment|/* clear status bits that must be cleared by writing 1 */
name|proatm_reg_wr
argument_list|(
name|proatm
argument_list|,
name|stat_val
operator|&
name|CLEAR_FLAGS
argument_list|,
name|REGSTAT
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat_val
operator|&
name|IDT_STAT_EOPDU
condition|)
block|{
name|int32_t
name|nsmall
decl_stmt|,
name|nlarge
decl_stmt|;
comment|/* receive PDU */
name|XPRINT
argument_list|(
literal|"proatm_intr: receive PDU \n"
argument_list|)
expr_stmt|;
name|proatm_recv
argument_list|(
name|proatm
argument_list|)
expr_stmt|;
comment|/* replace buffers */
name|nsmall
operator|=
name|proatm_sysctl_bufsmall
operator|-
operator|(
operator|(
name|stat_val
operator|&
name|IDT_STAT_FRAC0_MASK
operator|)
operator|>>
literal|11
operator|)
expr_stmt|;
if|if
condition|(
name|nsmall
operator|<
literal|0
condition|)
name|nsmall
operator|=
literal|0
expr_stmt|;
name|nlarge
operator|=
name|proatm_sysctl_buflarge
operator|-
operator|(
operator|(
name|stat_val
operator|&
name|IDT_STAT_FRAC1_MASK
operator|)
operator|>>
literal|15
operator|)
expr_stmt|;
if|if
condition|(
name|nlarge
operator|<
literal|0
condition|)
name|nlarge
operator|=
literal|0
expr_stmt|;
name|proatm_ld_rcv_buf
argument_list|(
name|proatm
argument_list|,
name|nsmall
argument_list|,
name|nlarge
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stat_val
operator|&
name|IDT_STAT_RAWCF
condition|)
block|{
name|XPRINT
argument_list|(
literal|"proatm_intr: receive raw cell\n"
argument_list|)
expr_stmt|;
name|proatm_rawc
argument_list|(
name|proatm
argument_list|)
expr_stmt|;
comment|/* raw cell */
block|}
if|if
condition|(
name|stat_val
operator|&
name|IDT_STAT_TSIF
condition|)
block|{
comment|/* transmit complete */
name|XPRINT
argument_list|(
literal|"proatm_intr: transmit complete \n"
argument_list|)
expr_stmt|;
name|proatm_intr_tsq
argument_list|(
name|proatm
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stat_val
operator|&
name|IDT_STAT_TXICP
condition|)
block|{
comment|/* bad transmit */
name|proatm_itrx
argument_list|(
name|proatm
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"proatm%d: Bad transmit.\n"
argument_list|,
name|proatm
operator|->
name|unit
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stat_val
operator|&
operator|(
name|IDT_STAT_FBQ0A
operator||
name|IDT_STAT_FBQ1A
operator|)
condition|)
block|{
comment|/* low level of FBQ0 */
if|if
condition|(
name|stat_val
operator|&
name|IDT_STAT_FBQ0A
condition|)
block|{
name|printf
argument_list|(
literal|"proatm%d: not enough small buffers.\n"
argument_list|,
name|proatm
operator|->
name|unit
argument_list|)
expr_stmt|;
name|proatm_ld_rcv_buf
argument_list|(
name|proatm
argument_list|,
literal|64
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* low level of FBQ1 */
if|if
condition|(
name|stat_val
operator|&
name|IDT_STAT_FBQ1A
condition|)
block|{
name|printf
argument_list|(
literal|"proatm%d: not enough large buffers.\n"
argument_list|,
name|proatm
operator|->
name|unit
argument_list|)
expr_stmt|;
name|proatm_ld_rcv_buf
argument_list|(
name|proatm
argument_list|,
literal|0
argument_list|,
literal|64
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|proatm_reg_rd
argument_list|(
name|proatm
argument_list|,
name|REGSTAT
argument_list|)
operator|&
operator|(
name|IDT_STAT_FBQ0A
operator||
name|IDT_STAT_FBQ1A
operator|)
condition|)
block|{
comment|/* still missing, so disable IRQ */
name|config_val
operator|&=
operator|~
name|IDT_CFG_FBIE
expr_stmt|;
name|proatm_reg_wr
argument_list|(
name|proatm
argument_list|,
name|config_val
argument_list|,
name|REGCFG
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|stat_val
operator|&
name|IDT_STAT_TMROF
condition|)
block|{
comment|/* timer wrap */
name|XPRINT
argument_list|(
literal|"proatm_intr: timer wrap \n"
argument_list|)
expr_stmt|;
name|proatm
operator|->
name|timer_wrap
operator|++
expr_stmt|;
name|proatm_intr_tsq
argument_list|(
name|proatm
argument_list|)
expr_stmt|;
comment|/* check the TSQ */
name|proatm_recv
argument_list|(
name|proatm
argument_list|)
expr_stmt|;
comment|/* check the receive queue */
if|if
condition|(
name|vtophys
argument_list|(
name|proatm
operator|->
name|raw_ch
argument_list|)
operator|!=
name|proatm
operator|->
name|raw_hnd
index|[
literal|0
index|]
condition|)
name|proatm_rawc
argument_list|(
name|proatm
argument_list|)
expr_stmt|;
comment|/* check the raw cell queue */
if|if
condition|(
name|proatm_sysctl_logbufs
condition|)
name|proatm_status_bufs
argument_list|(
name|proatm
argument_list|)
expr_stmt|;
comment|/* show the buffer status */
block|}
if|if
condition|(
name|stat_val
operator|&
name|IDT_STAT_PHYI
condition|)
block|{
comment|/* physical interface interrupt */
name|XPRINT
argument_list|(
literal|"proatm_intr: phy interrupt \n"
argument_list|)
expr_stmt|;
name|proatm_phys
argument_list|(
name|proatm
argument_list|)
expr_stmt|;
name|proatm_reg_wr
argument_list|(
name|proatm
argument_list|,
name|IDT_STAT_PHYI
argument_list|,
name|REGSTAT
argument_list|)
expr_stmt|;
comment|/* clear again the int32_t flag */
block|}
if|if
condition|(
name|stat_val
operator|&
name|IDT_STAT_RSQAF
condition|)
block|{
comment|/* RSQ almost full */
name|proatm_recv
argument_list|(
name|proatm
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"proatm%d: warning, RSQ almost full.\n"
argument_list|,
name|proatm
operator|->
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|proatm_reg_rd
argument_list|(
name|proatm
argument_list|,
name|REGSTAT
argument_list|)
operator|&
name|IDT_STAT_RSQAF
condition|)
block|{
comment|/* RSQ full */
name|printf
argument_list|(
literal|"      RSQ is full, disabling interrupt.\n"
argument_list|)
expr_stmt|;
name|config_val
operator|&=
operator|~
name|IDT_CFG_RSQAFIE
expr_stmt|;
name|proatm_reg_wr
argument_list|(
name|proatm
argument_list|,
name|config_val
argument_list|,
name|REGCFG
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|stat_val
operator|&
name|IDT_STAT_TSQF
condition|)
block|{
comment|/* TSQ almost full */
name|proatm_intr_tsq
argument_list|(
name|proatm
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"proatm%d: warning, TSQ almost full.\n"
argument_list|,
name|proatm
operator|->
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|proatm_reg_rd
argument_list|(
name|proatm
argument_list|,
name|IDT_STAT_TSQF
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"      TSQ is full, disabling interrupt.\n"
argument_list|)
expr_stmt|;
name|config_val
operator|&=
operator|~
name|IDT_CFG_TSQFIE
expr_stmt|;
name|proatm_reg_wr
argument_list|(
name|proatm
argument_list|,
name|config_val
argument_list|,
name|REGCFG
argument_list|)
expr_stmt|;
block|}
block|}
name|stat_val
operator|=
name|proatm_reg_rd
argument_list|(
name|proatm
argument_list|,
name|REGSTAT
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* detect spurious interrupts if the interrupt is not shared */
comment|/* do not use when the PCI interrupt is shared */
block|if (i< 1 )                             printf("proatm%d: i=%3d, unknown interrupt, status=%08x\n",                                  proatm->unit, i, (int) stat_val);
endif|#
directive|endif
if|if
condition|(
name|i
operator|>
literal|50
condition|)
name|printf
argument_list|(
literal|"proatm%d: i=%3d, status=%08x\n"
argument_list|,
name|proatm
operator|->
name|unit
argument_list|,
name|i
argument_list|,
operator|(
name|int
operator|)
name|stat_val
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Retrieve the value of one of the IDT77105's counters.  * `counter' is one of   *   - SEC: symbol errors,  0x08  *   - TCC: TX cells,       0x04  *   - RCC: RX cells,       0x02  *   - RHEC: RX HEC errors, 0x01  */
end_comment

begin_function
specifier|static
name|uint16_t
name|idt77105_get_counter
parameter_list|(
name|proatm_reg_t
modifier|*
name|proatm
parameter_list|,
name|u_int32_t
name|counter
parameter_list|)
block|{
name|uint16_t
name|val_low
decl_stmt|,
name|val_high
decl_stmt|;
name|u_int32_t
name|t
decl_stmt|;
switch|switch
condition|(
name|counter
condition|)
block|{
case|case
literal|0x08
case|:
case|case
literal|0x04
case|:
case|case
literal|0x02
case|:
case|case
literal|0x01
case|:
break|break;
default|default:
return|return
literal|0
return|;
break|break;
block|}
comment|/* Select counter register */
name|proatm_util_wr
argument_list|(
name|proatm
argument_list|,
name|IDT77105_CTRSEL_REG
argument_list|,
name|counter
argument_list|)
expr_stmt|;
comment|/* XXX: Should we delay ? */
comment|/* Read the counter */
comment|/*   read the low 8 bits */
name|proatm_util_rd
argument_list|(
name|proatm
argument_list|,
name|IDT77105_CTRLO_REG
argument_list|,
operator|&
name|t
argument_list|)
expr_stmt|;
name|val_low
operator|=
name|t
operator|&
literal|0xff
expr_stmt|;
comment|/*   read the high 8 bits */
name|proatm_util_rd
argument_list|(
name|proatm
argument_list|,
name|IDT77105_CTRHI_REG
argument_list|,
operator|&
name|t
argument_list|)
expr_stmt|;
name|val_high
operator|=
name|t
operator|&
literal|0xff
expr_stmt|;
return|return
operator|(
name|val_low
operator||
operator|(
name|val_high
operator|<<
literal|8
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Retrieve SUNI stats  *  */
end_comment

begin_function
specifier|static
name|void
name|proatm_get_stats
parameter_list|(
name|proatm_reg_t
modifier|*
name|proatm
parameter_list|)
block|{
if|if
condition|(
name|proatm
operator|->
name|flg_25
condition|)
block|{
comment|/*           * IDT77105 stats           * The counters overflow when not fetched about every           * (65535 / ATM_PCR_UTP25) ~ 1 second.          */
name|proatm
operator|->
name|pu_stats
operator|.
name|proatm_st_utp25
operator|.
name|utp25_symbol_errors
operator|+=
name|idt77105_get_counter
argument_list|(
name|proatm
argument_list|,
literal|0x08
argument_list|)
expr_stmt|;
name|proatm
operator|->
name|pu_stats
operator|.
name|proatm_st_utp25
operator|.
name|utp25_tx_cells
operator|+=
name|idt77105_get_counter
argument_list|(
name|proatm
argument_list|,
literal|0x04
argument_list|)
expr_stmt|;
name|proatm
operator|->
name|pu_stats
operator|.
name|proatm_st_utp25
operator|.
name|utp25_rx_cells
operator|+=
name|idt77105_get_counter
argument_list|(
name|proatm
argument_list|,
literal|0x02
argument_list|)
expr_stmt|;
name|proatm
operator|->
name|pu_stats
operator|.
name|proatm_st_utp25
operator|.
name|utp25_rx_hec_errors
operator|+=
name|idt77105_get_counter
argument_list|(
name|proatm
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* SUNI stats */
name|u_int32_t
name|t
decl_stmt|,
name|val
decl_stmt|;
comment|/*          * Write the SUNI master control register which          * will cause all the statistics counters to be          * loaded.          */
name|proatm_util_rd
argument_list|(
name|proatm
argument_list|,
name|SUNI_MASTER_REG
argument_list|,
operator|&
name|t
argument_list|)
expr_stmt|;
name|proatm_util_wr
argument_list|(
name|proatm
argument_list|,
name|SUNI_MASTER_REG
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|/*          * Delay to allow for counter load time...          */
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
comment|/* SUNI_DELAY */
comment|/*          * Statistics counters contain the number of events          * since the last time the counter was read.          */
name|READ_TWO
argument_list|(
name|val
argument_list|,
name|SUNI_SECT_BIP_REG
argument_list|)
expr_stmt|;
comment|/* oc3_sect_bip8 */
name|proatm
operator|->
name|pu_stats
operator|.
name|proatm_st_oc3
operator|.
name|oc3_sect_bip8
operator|+=
name|val
expr_stmt|;
name|READ_TWO
argument_list|(
name|val
argument_list|,
name|SUNI_PATH_BIP_REG
argument_list|)
expr_stmt|;
comment|/* oc3_path_bip8 */
name|proatm
operator|->
name|pu_stats
operator|.
name|proatm_st_oc3
operator|.
name|oc3_path_bip8
operator|+=
name|val
expr_stmt|;
name|READ_THREE
argument_list|(
name|val
argument_list|,
name|SUNI_LINE_BIP_REG
argument_list|)
expr_stmt|;
comment|/* oc3_line_bip24 */
name|proatm
operator|->
name|pu_stats
operator|.
name|proatm_st_oc3
operator|.
name|oc3_line_bip24
operator|+=
name|val
expr_stmt|;
name|READ_THREE
argument_list|(
name|val
argument_list|,
name|SUNI_LINE_FEBE_REG
argument_list|)
expr_stmt|;
comment|/* oc3_line_febe */
name|proatm
operator|->
name|pu_stats
operator|.
name|proatm_st_oc3
operator|.
name|oc3_line_febe
operator|+=
name|val
expr_stmt|;
name|READ_TWO
argument_list|(
name|val
argument_list|,
name|SUNI_PATH_FEBE_REG
argument_list|)
expr_stmt|;
comment|/* oc3_path_febe */
name|proatm
operator|->
name|pu_stats
operator|.
name|proatm_st_oc3
operator|.
name|oc3_path_febe
operator|+=
name|val
expr_stmt|;
name|READ_ONE
argument_list|(
name|val
argument_list|,
name|SUNI_HECS_REG
argument_list|)
expr_stmt|;
comment|/* oc3_hec_corr */
name|proatm
operator|->
name|pu_stats
operator|.
name|proatm_st_oc3
operator|.
name|oc3_hec_corr
operator|+=
name|val
expr_stmt|;
name|READ_ONE
argument_list|(
name|val
argument_list|,
name|SUNI_UHECS_REG
argument_list|)
expr_stmt|;
comment|/* oc3_hec_uncorr */
name|proatm
operator|->
name|pu_stats
operator|.
name|proatm_st_oc3
operator|.
name|oc3_hec_uncorr
operator|+=
name|val
expr_stmt|;
comment|/* The counters overflow when not fetched about every           * (2^24 - 1) / ATM_PCR_OC3C ~ 47 seconds.          */
name|READ_THREE
argument_list|(
name|val
argument_list|,
name|SUNI_RACP_RX_REG
argument_list|)
expr_stmt|;
comment|/* oc3_rx_cells */
name|proatm
operator|->
name|pu_stats
operator|.
name|proatm_st_oc3
operator|.
name|oc3_rx_cells
operator|+=
name|val
expr_stmt|;
name|READ_THREE
argument_list|(
name|val
argument_list|,
name|SUNI_TACP_TX_REG
argument_list|)
expr_stmt|;
comment|/* oc3_tx_cells */
name|proatm
operator|->
name|pu_stats
operator|.
name|proatm_st_oc3
operator|.
name|oc3_tx_cells
operator|+=
name|val
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/******************************************************************************  *  *                       HARP GLUE SECTION  *  ******************************************************************************  *  * Handle netatm core service interface ioctl requests  *  * Called at splnet.  *  * Arguments:  *    code       ioctl function (sub)code  *    data       data to/from ioctl  *    arg        optional code-specific argument  *  * Returns:  *    0          request processed successfully  *    error      request failed - UNIX reason code  *  */
end_comment

begin_function
name|int32_t
name|proatm_atm_ioctl
parameter_list|(
name|int32_t
name|code
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|caddr_t
name|arg
parameter_list|)
block|{
name|PROATM
modifier|*
name|proatm
init|=
operator|(
name|PROATM
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|atm_pif
modifier|*
name|pip
init|=
operator|(
expr|struct
name|atm_pif
operator|*
operator|)
name|proatm
decl_stmt|;
name|struct
name|atminfreq
modifier|*
name|aip
init|=
operator|(
expr|struct
name|atminfreq
operator|*
operator|)
name|data
decl_stmt|;
name|caddr_t
name|buf
init|=
name|aip
operator|->
name|air_buf_addr
decl_stmt|;
name|struct
name|air_vinfo_rsp
modifier|*
name|avr
decl_stmt|;
comment|/*rsp*/
name|int32_t
name|count
decl_stmt|,
name|len
decl_stmt|,
name|buf_len
init|=
name|aip
operator|->
name|air_buf_len
decl_stmt|;
name|int32_t
name|err
init|=
literal|0
decl_stmt|;
name|char
name|ifname
index|[
literal|2
operator|*
name|IFNAMSIZ
index|]
decl_stmt|;
name|XPRINT
argument_list|(
literal|"proatm_atm_ioctl: code=%d, opcode=%d\n"
argument_list|,
name|code
argument_list|,
name|aip
operator|->
name|air_opcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|proatm
operator|==
name|NULL
condition|)
return|return
name|ENXIO
return|;
switch|switch
condition|(
name|aip
operator|->
name|air_opcode
condition|)
block|{
case|case
name|AIOCS_INF_VST
case|:
comment|/*          * Get vendor statistics          */
if|if
condition|(
name|proatm
operator|==
name|NULL
condition|)
return|return
name|ENXIO
return|;
name|snprintf
argument_list|(
name|ifname
argument_list|,
sizeof|sizeof
argument_list|(
name|ifname
argument_list|)
argument_list|,
literal|"%s%d"
argument_list|,
name|pip
operator|->
name|pif_name
argument_list|,
name|pip
operator|->
name|pif_unit
argument_list|)
expr_stmt|;
comment|/*          * Cast response structure onto user's buffer          */
name|avr
operator|=
operator|(
expr|struct
name|air_vinfo_rsp
operator|*
operator|)
name|buf
expr_stmt|;
comment|/*          * How large is the response structure          */
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|air_vinfo_rsp
argument_list|)
expr_stmt|;
comment|/*          * Sanity check - enough room for response structure?          */
if|if
condition|(
name|buf_len
operator|<
name|len
condition|)
return|return
name|ENOSPC
return|;
comment|/*          * Copy interface name into response structure          */
if|if
condition|(
operator|(
name|err
operator|=
name|copyout
argument_list|(
name|ifname
argument_list|,
name|avr
operator|->
name|avsp_intf
argument_list|,
name|IFNAMSIZ
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
comment|/*          * Advance the buffer address and decrement the size          */
name|buf
operator|+=
name|len
expr_stmt|;
name|buf_len
operator|-=
name|len
expr_stmt|;
comment|/* retrieve the SUNI stats */
name|proatm_get_stats
argument_list|(
name|proatm
argument_list|)
expr_stmt|;
comment|/* Get misc stats */
comment|/* current CBR TX cellrate */
name|proatm
operator|->
name|pu_stats
operator|.
name|proatm_st_drv
operator|.
name|drv_xm_cbrbw
operator|=
name|proatm
operator|->
name|cellrate_tcur
expr_stmt|;
comment|/* Unused TX QUEUE  */
name|proatm
operator|->
name|pu_stats
operator|.
name|proatm_st_drv
operator|.
name|drv_xm_qufree
operator|=
name|proatm
operator|->
name|txqueue_free_count
expr_stmt|;
comment|/* Free slots within the UBR0 queue */
name|proatm
operator|->
name|pu_stats
operator|.
name|proatm_st_drv
operator|.
name|drv_xm_ubr0free
operator|=
name|IDT_SCQ_ENTRIES
operator|-
name|proatm
operator|->
name|txqueue_ubr0
operator|.
name|scq_cur
expr_stmt|;
comment|/*          * Stick as much of it as we have room for          * into the response          */
name|count
operator|=
name|MIN
argument_list|(
sizeof|sizeof
argument_list|(
name|Proatm_stats
argument_list|)
argument_list|,
name|buf_len
argument_list|)
expr_stmt|;
comment|/*          * Copy stats into user's buffer. Return value is          * amount of data copied.          */
if|if
condition|(
operator|(
name|err
operator|=
name|copyout
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|proatm
operator|->
name|pu_stats
argument_list|,
name|buf
argument_list|,
name|count
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
name|buf
operator|+=
name|count
expr_stmt|;
name|buf_len
operator|-=
name|count
expr_stmt|;
if|if
condition|(
name|count
operator|<
sizeof|sizeof
argument_list|(
name|Proatm_stats
argument_list|)
condition|)
name|err
operator|=
name|ENOSPC
expr_stmt|;
comment|/*          * Record amount we're returning as vendor info...          * ie : arv->avsp_len = sizeof (Proatm_stats);          */
if|if
condition|(
operator|(
name|err
operator|=
name|copyout
argument_list|(
operator|&
name|count
argument_list|,
operator|&
name|avr
operator|->
name|avsp_len
argument_list|,
sizeof|sizeof
argument_list|(
name|int32_t
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
comment|/* Update the reply length and pointer*/
name|aip
operator|->
name|air_buf_addr
operator|=
name|buf
expr_stmt|;
name|aip
operator|->
name|air_buf_len
operator|=
name|buf_len
expr_stmt|;
break|break;
default|default:
name|err
operator|=
name|ENOSYS
expr_stmt|;
comment|/* Operation not supported */
break|break;
block|}
return|return
name|err
return|;
block|}
end_function

begin_comment
comment|/*  * ATM Interface services  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|stack_defn
name|proatm_svaal5
init|=
block|{
name|NULL
block|,
name|SAP_CPCS_AAL5
block|,
name|SDF_TERM
block|,
name|atm_dev_inst
block|,
name|atm_dev_lower
block|,
name|NULL
block|,
literal|0
block|,  }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|stack_defn
name|proatm_svaal4
init|=
block|{
operator|&
name|proatm_svaal5
block|,
name|SAP_CPCS_AAL3_4
block|,
name|SDF_TERM
block|,
name|atm_dev_inst
block|,
name|atm_dev_lower
block|,
name|NULL
block|,
literal|0
block|,  }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|stack_defn
name|proatm_svaal0
init|=
block|{
operator|&
name|proatm_svaal4
block|,
name|SAP_ATM
block|,
name|SDF_TERM
block|,
name|atm_dev_inst
block|,
name|atm_dev_lower
block|,
name|NULL
block|,
literal|0
block|,  }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|stack_defn
modifier|*
name|proatm_services
init|=
operator|&
name|proatm_svaal0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Storage pools  */
end_comment

begin_decl_stmt
name|struct
name|sp_info
name|proatm_nif_pool
init|=
block|{
literal|"proatm nif pool"
block|,
comment|/* si_name */
sizeof|sizeof
argument_list|(
expr|struct
name|atm_nif
argument_list|)
block|,
comment|/* si_blksiz */
literal|5
block|,
comment|/* si_blkcnt */
literal|20
comment|/* si_maxallow */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|sp_info
name|proatm_vcc_pool
init|=
block|{
literal|"proatm vcc pool"
block|,
comment|/* si_name */
sizeof|sizeof
argument_list|(
name|Idt_vcc
argument_list|)
block|,
comment|/* si_blksiz */
literal|10
block|,
comment|/* si_blkcnt */
literal|500
comment|/* si_maxallow */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*******************************************************************************  *  *  Get connection pointer from Cmn_unit and Cmn_vcc  *  *  in:  Cmn_unit and Cmn_vcc  * out:  connection (NULL=error)  *  */
end_comment

begin_function
name|CONNECTION
modifier|*
name|proatm_atm_harpconn
parameter_list|(
name|Cmn_unit
modifier|*
name|cup
parameter_list|,
name|Cmn_vcc
modifier|*
name|cvp
parameter_list|)
block|{
name|struct
name|vccb
modifier|*
name|vccinf
decl_stmt|;
comment|/* from HARP struct */
name|PROATM
modifier|*
name|proatm
decl_stmt|;
name|int32_t
name|vpi
decl_stmt|;
name|int32_t
name|vci
decl_stmt|;
name|proatm
operator|=
operator|(
name|PROATM
operator|*
operator|)
name|cup
expr_stmt|;
if|if
condition|(
name|proatm
operator|==
name|NULL
operator|||
name|cvp
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|cvp
operator|->
name|cv_connvc
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|vccinf
operator|=
name|cvp
operator|->
name|cv_connvc
operator|->
name|cvc_vcc
expr_stmt|;
if|if
condition|(
name|vccinf
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|vpi
operator|=
name|vccinf
operator|->
name|vc_vpi
expr_stmt|;
name|vci
operator|=
name|vccinf
operator|->
name|vc_vci
expr_stmt|;
return|return
name|proatm_connect_find
argument_list|(
name|proatm
argument_list|,
name|vpi
argument_list|,
name|vci
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  *  Get CBR/VBR/UBR class from bearer attribute  *  *  in:    * out:  NICCBR/NICVBR/NICABR/NICUBR  *  */
end_comment

begin_comment
comment|/*    *  Note that CLASS_X is typically UBR, but the traffic type information  *  element may still specify CBR or VBR.  *  the default class is UBR0  *  At this time it is not possible to specify ABR   */
end_comment

begin_function
specifier|static
name|int32_t
name|proatm_atm_bearerclass
parameter_list|(
name|struct
name|attr_bearer
modifier|*
name|bearer
parameter_list|)
block|{
switch|switch
condition|(
name|bearer
operator|->
name|v
operator|.
name|bearer_class
condition|)
block|{
case|case
name|T_ATM_CLASS_A
case|:
return|return
operator|(
name|NICCBR
operator|)
return|;
case|case
name|T_ATM_CLASS_C
case|:
return|return
operator|(
name|NICVBR
operator|)
return|;
case|case
name|T_ATM_CLASS_X
case|:
switch|switch
condition|(
name|bearer
operator|->
name|v
operator|.
name|traffic_type
condition|)
block|{
case|case
name|T_ATM_CBR
case|:
return|return
operator|(
name|NICCBR
operator|)
return|;
case|case
name|T_ATM_VBR
case|:
return|return
operator|(
name|NICVBR
operator|)
return|;
block|}
break|break;
block|}
return|return
operator|(
name|NICUBR
operator|)
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  *  Initialize HARP service  *  called from device attach  */
end_comment

begin_function
specifier|static
name|void
name|proatm_harp_init
parameter_list|(
name|proatm_reg_t
modifier|*
specifier|const
name|proatm
parameter_list|,
name|void
modifier|*
name|arg2
parameter_list|)
block|{
name|long
name|long
name|tsc_val
decl_stmt|;
name|u_int8_t
name|mac
index|[
literal|6
index|]
decl_stmt|;
comment|/*     * Start initializing it     */
name|proatm
operator|->
name|iu_unit
operator|=
name|proatm
operator|->
name|unit
expr_stmt|;
name|proatm
operator|->
name|iu_mtu
operator|=
name|PROATM_IFF_MTU
expr_stmt|;
name|proatm
operator|->
name|iu_ioctl
operator|=
name|proatm_atm_ioctl
expr_stmt|;
name|proatm
operator|->
name|iu_openvcc
operator|=
name|proatm_openvcc
expr_stmt|;
name|proatm
operator|->
name|iu_instvcc
operator|=
name|proatm_instvcc
expr_stmt|;
name|proatm
operator|->
name|iu_closevcc
operator|=
name|proatm_closevcc
expr_stmt|;
name|proatm
operator|->
name|iu_output
operator|=
name|proatm_output
expr_stmt|;
name|proatm
operator|->
name|iu_vcc_pool
operator|=
operator|&
name|proatm_vcc_pool
expr_stmt|;
name|proatm
operator|->
name|iu_nif_pool
operator|=
operator|&
name|proatm_nif_pool
expr_stmt|;
comment|/*     * Copy serial number into config space     */
name|proatm
operator|->
name|iu_config
operator|.
name|ac_serial
operator|=
literal|0
expr_stmt|;
name|proatm
operator|->
name|iu_config
operator|.
name|ac_vendor
operator|=
name|VENDOR_PROSUM
expr_stmt|;
name|proatm
operator|->
name|iu_config
operator|.
name|ac_vendapi
operator|=
name|VENDAPI_IDT_2
expr_stmt|;
name|proatm
operator|->
name|iu_config
operator|.
name|ac_device
operator|=
name|proatm
operator|->
name|flg_25
condition|?
name|DEV_PROATM_25
else|:
name|DEV_PROATM_155
expr_stmt|;
name|proatm
operator|->
name|iu_config
operator|.
name|ac_media
operator|=
name|proatm
operator|->
name|flg_25
condition|?
name|MEDIA_UTP25
else|:
name|MEDIA_OC3C
expr_stmt|;
name|proatm
operator|->
name|iu_config
operator|.
name|ac_bustype
operator|=
name|BUS_PCI
expr_stmt|;
name|proatm
operator|->
name|iu_pif
operator|.
name|pif_pcr
operator|=
name|proatm
operator|->
name|max_pcr
expr_stmt|;
name|proatm
operator|->
name|iu_pif
operator|.
name|pif_maxvpi
operator|=
literal|0xff
expr_stmt|;
name|proatm
operator|->
name|iu_pif
operator|.
name|pif_maxvci
operator|=
literal|0xffff
expr_stmt|;
name|snprintf
argument_list|(
name|proatm
operator|->
name|iu_config
operator|.
name|ac_hard_vers
argument_list|,
sizeof|sizeof
argument_list|(
name|proatm
operator|->
name|iu_config
operator|.
name|ac_hard_vers
argument_list|)
argument_list|,
name|proatm
operator|->
name|hardware
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|proatm
operator|->
name|iu_config
operator|.
name|ac_firm_vers
argument_list|,
sizeof|sizeof
argument_list|(
name|proatm
operator|->
name|iu_config
operator|.
name|ac_firm_vers
argument_list|)
argument_list|,
name|PROATM_VERSION
argument_list|)
expr_stmt|;
comment|/*      * Save device ram info for user-level programs      * NOTE: This really points to start of EEPROM      * and includes all the device registers in the      * lower 2 Megabytes.      */
name|proatm_eeprom_rd
argument_list|(
name|proatm
argument_list|,
name|EPROM_PROSUM_MAC_ADDR_OFFSET
argument_list|,
name|mac
argument_list|,
literal|6
argument_list|)
expr_stmt|;
if|if
condition|(
name|mac
index|[
literal|0
index|]
operator|!=
name|PROSUM_MAC_0
operator|||
name|mac
index|[
literal|1
index|]
operator|!=
name|PROSUM_MAC_1
operator|||
name|mac
index|[
literal|2
index|]
operator|!=
name|PROSUM_MAC_2
condition|)
name|proatm_eeprom_rd
argument_list|(
name|proatm
argument_list|,
name|EPROM_IDT_MAC_ADDR_OFFSET
argument_list|,
name|mac
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|proatm
operator|->
name|iu_config
operator|.
name|ac_ram
operator|=
name|NULL
expr_stmt|;
name|proatm
operator|->
name|iu_config
operator|.
name|ac_ramsize
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|mac
index|[
literal|3
index|]
operator||
name|mac
index|[
literal|4
index|]
operator||
name|mac
index|[
literal|5
index|]
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* looks like bad MAC */
name|GET_RDTSC
argument_list|(
name|tsc_val
argument_list|)
expr_stmt|;
comment|/* 24 bits on 500mhz CPU is about 30msec */
name|mac
index|[
literal|0
index|]
operator|=
name|PROSUM_MAC_0
expr_stmt|;
name|mac
index|[
literal|1
index|]
operator|=
name|PROSUM_MAC_1
expr_stmt|;
name|mac
index|[
literal|2
index|]
operator|=
name|PROSUM_MAC_2
expr_stmt|;
comment|/* use Prosum prefix */
name|mac
index|[
literal|3
index|]
operator|=
operator|(
name|tsc_val
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
name|mac
index|[
literal|4
index|]
operator|=
operator|(
name|tsc_val
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|mac
index|[
literal|5
index|]
operator|=
operator|(
name|tsc_val
operator|)
operator|&
literal|0xff
expr_stmt|;
name|printf
argument_list|(
literal|"proatm%d: Cannot read MAC address from EEPROM, generating it.\n"
argument_list|,
name|proatm
operator|->
name|unit
argument_list|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|proatm
operator|->
name|iu_pif
operator|.
name|pif_macaddr
operator|.
name|ma_data
argument_list|,
name|mac
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"proatm%d: MAC address %02x:%02x:%02x:%02x:%02x:%02x, HWrev=%d\n"
argument_list|,
name|proatm
operator|->
name|unit
argument_list|,
name|proatm
operator|->
name|iu_pif
operator|.
name|pif_macaddr
operator|.
name|ma_data
index|[
literal|0
index|]
argument_list|,
name|proatm
operator|->
name|iu_pif
operator|.
name|pif_macaddr
operator|.
name|ma_data
index|[
literal|1
index|]
argument_list|,
name|proatm
operator|->
name|iu_pif
operator|.
name|pif_macaddr
operator|.
name|ma_data
index|[
literal|2
index|]
argument_list|,
name|proatm
operator|->
name|iu_pif
operator|.
name|pif_macaddr
operator|.
name|ma_data
index|[
literal|3
index|]
argument_list|,
name|proatm
operator|->
name|iu_pif
operator|.
name|pif_macaddr
operator|.
name|ma_data
index|[
literal|4
index|]
argument_list|,
name|proatm
operator|->
name|iu_pif
operator|.
name|pif_macaddr
operator|.
name|ma_data
index|[
literal|5
index|]
argument_list|,
name|proatm
operator|->
name|pci_rev
argument_list|)
expr_stmt|;
name|proatm
operator|->
name|iu_config
operator|.
name|ac_macaddr
operator|=
name|proatm
operator|->
name|iu_pif
operator|.
name|pif_macaddr
expr_stmt|;
comment|/*      * Register this interface with ATM core services      */
if|if
condition|(
name|atm_physif_register
argument_list|(
operator|(
name|Cmn_unit
operator|*
operator|)
name|proatm
argument_list|,
name|PROATM_DEV_NAME
argument_list|,
name|proatm_services
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/*          * Registration failed - back everything out          */
ifdef|#
directive|ifdef
name|FBSD35
name|proatm_device_stop
argument_list|(
name|proatm
argument_list|)
expr_stmt|;
else|#
directive|else
name|proatm_detach
argument_list|(
operator|(
name|device_t
operator|)
name|arg2
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"proatm_pci_attach: atm_physif_register failed\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|proatm
operator|->
name|iu_flags
operator||=
name|CUF_INITED
expr_stmt|;
if|#
directive|if
name|BSD
operator|>=
literal|199506
comment|/*      * Add hook to out shutdown function      * at_shutdown ( (bootlist_fn)proatm_pci_shutdown, proatm, SHUTDOWN_POST_SYNC );      */
endif|#
directive|endif
return|return;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  *  Output data  */
end_comment

begin_function
name|void
name|proatm_output
parameter_list|(
name|Cmn_unit
modifier|*
name|cmnunit
parameter_list|,
name|Cmn_vcc
modifier|*
name|cmnvcc
parameter_list|,
name|KBuffer
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|vccb
modifier|*
name|vccinf
decl_stmt|;
comment|/* from HARP struct */
name|PROATM
modifier|*
name|proatm
decl_stmt|;
name|int32_t
name|vpi
decl_stmt|;
name|int32_t
name|vci
decl_stmt|;
name|proatm
operator|=
operator|(
name|PROATM
operator|*
operator|)
name|cmnunit
expr_stmt|;
if|if
condition|(
name|cmnvcc
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"proatm%d: proatm_output arg error #1\n"
argument_list|,
name|proatm
operator|->
name|unit
argument_list|)
expr_stmt|;
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* throw away packet, no VCC */
return|return;
block|}
if|if
condition|(
name|cmnvcc
operator|->
name|cv_connvc
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"proatm%d: proatm_output arg error #2\n"
argument_list|,
name|proatm
operator|->
name|unit
argument_list|)
expr_stmt|;
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* throw away packet, no VCC */
return|return;
block|}
name|vccinf
operator|=
name|cmnvcc
operator|->
name|cv_connvc
operator|->
name|cvc_vcc
expr_stmt|;
if|if
condition|(
name|vccinf
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"proatm%d: proatm_output arg error #3\n"
argument_list|,
name|proatm
operator|->
name|unit
argument_list|)
expr_stmt|;
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* throw away packet, no VCC */
return|return;
block|}
name|vpi
operator|=
name|vccinf
operator|->
name|vc_vpi
expr_stmt|;
name|vci
operator|=
name|vccinf
operator|->
name|vc_vci
expr_stmt|;
name|proatm_transmit
argument_list|(
name|proatm
argument_list|,
name|m
argument_list|,
name|vpi
argument_list|,
name|vci
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  *  Open VCC  */
end_comment

begin_function
name|int32_t
name|proatm_openvcc
parameter_list|(
name|Cmn_unit
modifier|*
name|cmnunit
parameter_list|,
name|Cmn_vcc
modifier|*
name|cmnvcc
parameter_list|)
block|{
name|Atm_attributes
modifier|*
name|attrib
decl_stmt|;
comment|/* from HARP struct */
name|struct
name|vccb
modifier|*
name|vccinf
decl_stmt|;
comment|/* from HARP struct */
name|CONNECTION
modifier|*
name|connection
init|=
name|NULL
decl_stmt|;
name|PROATM
modifier|*
name|proatm
decl_stmt|;
name|int32_t
name|vpi
decl_stmt|;
name|int32_t
name|vci
decl_stmt|;
name|int32_t
name|class
decl_stmt|;
comment|/* NICCBR, NICVBR or NICUBR */
name|proatm
operator|=
operator|(
name|PROATM
operator|*
operator|)
name|cmnunit
expr_stmt|;
if|if
condition|(
name|cmnvcc
operator|==
name|NULL
operator|||
name|cmnvcc
operator|->
name|cv_connvc
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"proatm%d: proatm_openvcc: bad request #1.\n"
argument_list|,
name|proatm
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|EFAULT
operator|)
return|;
block|}
name|attrib
operator|=
operator|&
name|cmnvcc
operator|->
name|cv_connvc
operator|->
name|cvc_attr
expr_stmt|;
name|vccinf
operator|=
name|cmnvcc
operator|->
name|cv_connvc
operator|->
name|cvc_vcc
expr_stmt|;
if|if
condition|(
name|attrib
operator|==
name|NULL
operator|||
name|vccinf
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"proatm%d: proatm_openvcc: bad request #2.\n"
argument_list|,
name|proatm
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|EFAULT
operator|)
return|;
block|}
name|vpi
operator|=
name|vccinf
operator|->
name|vc_vpi
expr_stmt|;
name|vci
operator|=
name|vccinf
operator|->
name|vc_vci
expr_stmt|;
if|if
condition|(
name|proatm_check_vc
argument_list|(
name|proatm
argument_list|,
name|vpi
argument_list|,
name|vci
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"proatm%d: proatm_openvcc: vpi/vci invalid: %d/%d\n"
argument_list|,
name|proatm
operator|->
name|unit
argument_list|,
name|vpi
argument_list|,
name|vci
argument_list|)
expr_stmt|;
name|proatm
operator|->
name|pu_stats
operator|.
name|proatm_st_drv
operator|.
name|drv_vc_badrng
operator|++
expr_stmt|;
return|return
operator|(
name|EFAULT
operator|)
return|;
block|}
name|connection
operator|=
name|proatm_connect_find
argument_list|(
name|proatm
argument_list|,
name|vpi
argument_list|,
name|vci
argument_list|)
expr_stmt|;
if|if
condition|(
name|connection
operator|->
name|flg_open
condition|)
block|{
name|printf
argument_list|(
literal|"proatm%d: proatm_openvcc: connection %s %d/%d\n"
argument_list|,
name|proatm
operator|->
name|unit
argument_list|,
name|connection
operator|->
name|flg_closing
condition|?
literal|"closing"
else|:
literal|"already open"
argument_list|,
name|connection
operator|->
name|vpi
argument_list|,
name|connection
operator|->
name|vci
argument_list|)
expr_stmt|;
return|return
operator|(
name|EEXIST
operator|)
return|;
block|}
name|connection
operator|->
name|flg_open
operator|=
literal|1
expr_stmt|;
name|connection
operator|->
name|vpi
operator|=
name|vpi
expr_stmt|;
name|connection
operator|->
name|vci
operator|=
name|vci
expr_stmt|;
name|connection
operator|->
name|recv
operator|=
name|NULL
expr_stmt|;
name|connection
operator|->
name|rlen
operator|=
literal|0
expr_stmt|;
name|connection
operator|->
name|maxpdu
operator|=
literal|20000
expr_stmt|;
switch|switch
condition|(
name|attrib
operator|->
name|aal
operator|.
name|type
condition|)
block|{
case|case
name|ATM_AAL0
case|:
name|connection
operator|->
name|aal
operator|=
name|IDTAAL0
expr_stmt|;
case|case
name|ATM_AAL3_4
case|:
name|connection
operator|->
name|aal
operator|=
name|IDTAAL3_4
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
case|case
name|ATM_AAL5
case|:
name|connection
operator|->
name|aal
operator|=
name|IDTAAL5
expr_stmt|;
comment|/* No other AAL supported at this time */
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|connection
operator|->
name|traf_pcr
operator|=
name|attrib
operator|->
name|traffic
operator|.
name|v
operator|.
name|forward
operator|.
name|PCR_all_traffic
expr_stmt|;
name|connection
operator|->
name|traf_scr
operator|=
name|attrib
operator|->
name|traffic
operator|.
name|v
operator|.
name|forward
operator|.
name|SCR_all_traffic
expr_stmt|;
name|connection
operator|->
name|traf_mbs
operator|=
name|attrib
operator|->
name|traffic
operator|.
name|v
operator|.
name|forward
operator|.
name|MBS_all_traffic
expr_stmt|;
comment|/*      * According to me the Cell Loss Priority could be set      * when the best effort service is required, because      * best effort means low priority.      */
name|connection
operator|->
name|flg_clp
operator|=
operator|(
name|attrib
operator|->
name|traffic
operator|.
name|v
operator|.
name|best_effort
operator|==
name|T_YES
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|connection
operator|->
name|vccinf
operator|=
name|vccinf
expr_stmt|;
if|if
condition|(
name|connection
operator|->
name|traf_pcr
operator|<=
literal|0
condition|)
name|connection
operator|->
name|traf_pcr
operator|=
name|connection
operator|->
name|traf_scr
expr_stmt|;
if|if
condition|(
name|connection
operator|->
name|traf_scr
operator|<=
literal|0
condition|)
name|connection
operator|->
name|traf_scr
operator|=
name|connection
operator|->
name|traf_pcr
expr_stmt|;
if|if
condition|(
name|connection
operator|->
name|traf_mbs
operator|<=
literal|0
operator|||
name|connection
operator|->
name|traf_mbs
operator|>
literal|255
condition|)
name|connection
operator|->
name|traf_mbs
operator|=
literal|255
expr_stmt|;
name|class
operator|=
name|proatm_atm_bearerclass
argument_list|(
operator|&
name|attrib
operator|->
name|bearer
argument_list|)
expr_stmt|;
if|if
condition|(
name|connection
operator|->
name|traf_pcr
operator|<=
literal|0
operator|||
name|connection
operator|->
name|traf_pcr
operator|>=
name|proatm
operator|->
name|max_pcr
condition|)
block|{
name|connection
operator|->
name|traf_pcr
operator|=
name|proatm
operator|->
name|max_pcr
expr_stmt|;
name|connection
operator|->
name|traf_scr
operator|=
name|proatm
operator|->
name|max_pcr
expr_stmt|;
name|class
operator|=
name|NICUBR0
expr_stmt|;
comment|/* single transmit queue, full speed */
block|}
name|connection
operator|->
name|class
operator|=
name|class
expr_stmt|;
if|if
condition|(
name|proatm_connect_txopen
argument_list|(
name|proatm
argument_list|,
name|connection
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"proatm%d: cannot open connection for %d/%d\n"
argument_list|,
name|proatm
operator|->
name|unit
argument_list|,
name|vpi
argument_list|,
name|vci
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|proatm_sysctl_logvcs
condition|)
name|printf
argument_list|(
literal|"proatm%d: proatm_openvcc: %d/%d, PCR=%d, SCR=%d\n"
argument_list|,
name|proatm
operator|->
name|unit
argument_list|,
name|vpi
argument_list|,
name|vci
argument_list|,
name|connection
operator|->
name|traf_pcr
argument_list|,
name|connection
operator|->
name|traf_scr
argument_list|)
expr_stmt|;
name|proatm_connect_rxopen
argument_list|(
name|proatm
argument_list|,
name|connection
argument_list|)
expr_stmt|;
comment|/* open entry in rcv connect table */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  *  Close VCC  */
end_comment

begin_function
name|int32_t
name|proatm_closevcc
parameter_list|(
name|Cmn_unit
modifier|*
name|cmnunit
parameter_list|,
name|Cmn_vcc
modifier|*
name|cmnvcc
parameter_list|)
block|{
name|CONNECTION
modifier|*
name|connection
init|=
name|NULL
decl_stmt|;
name|proatm_reg_t
modifier|*
name|proatm
init|=
operator|(
name|proatm_reg_t
operator|*
operator|)
name|cmnunit
decl_stmt|;
name|int32_t
name|vpi
decl_stmt|;
name|int32_t
name|vci
decl_stmt|;
if|if
condition|(
name|cmnvcc
operator|&&
name|cmnvcc
operator|->
name|cv_connvc
operator|&&
name|cmnvcc
operator|->
name|cv_connvc
operator|->
name|cvc_vcc
condition|)
block|{
name|vpi
operator|=
name|cmnvcc
operator|->
name|cv_connvc
operator|->
name|cvc_vcc
operator|->
name|vc_vpi
expr_stmt|;
name|vci
operator|=
name|cmnvcc
operator|->
name|cv_connvc
operator|->
name|cvc_vcc
operator|->
name|vc_vci
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"proatm%d: proatm_closevcc: bad vcivpi\n"
argument_list|,
name|proatm
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|connection
operator|=
name|proatm_connect_find
argument_list|(
name|proatm
argument_list|,
name|vpi
argument_list|,
name|vci
argument_list|)
expr_stmt|;
if|if
condition|(
name|connection
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"proatm%d: proatm_closevcc: vpi/vci invalid: %d/%d\n"
argument_list|,
name|proatm
operator|->
name|unit
argument_list|,
name|vpi
argument_list|,
name|vci
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|proatm_connect_rxclose
argument_list|(
name|proatm
argument_list|,
name|connection
argument_list|)
expr_stmt|;
comment|/* close entry in rcv connect table */
if|if
condition|(
name|connection
operator|->
name|flg_open
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"proatm%d: proatm_closevcc: close on empty connection %d/%d\n"
argument_list|,
name|proatm
operator|->
name|unit
argument_list|,
name|vpi
argument_list|,
name|vci
argument_list|)
expr_stmt|;
if|if
condition|(
name|connection
operator|->
name|recv
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|connection
operator|->
name|recv
argument_list|)
expr_stmt|;
comment|/* recycle mbuf of partial PDU */
name|proatm_connect_txclose
argument_list|(
name|proatm
argument_list|,
name|connection
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|proatm_sysctl_logvcs
condition|)
name|printf
argument_list|(
literal|"proatm%d: proatm_closevcc: vpi=%d vci=%d\n"
argument_list|,
name|proatm
operator|->
name|unit
argument_list|,
name|vpi
argument_list|,
name|vci
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  *  * VCC Stack Instantiation  *  * This function is called via the common driver code during a device VCC  * stack instantiation.  The common code has already validated some of  * the request so we just need to check a few more IDT-specific details.  *  * Called at splnet.  *  * Arguments:  *    cup    pointer to device common unit  *    cvp    pointer to common VCC entry  *  * Returns:  *    0    instantiation successful  *    err     instantiation failed - reason indicated  *  */
end_comment

begin_function
name|int32_t
name|proatm_instvcc
parameter_list|(
name|Cmn_unit
modifier|*
name|cmnunit
parameter_list|,
name|Cmn_vcc
modifier|*
name|cmnvcc
parameter_list|)
block|{
name|Atm_attributes
modifier|*
name|attrib
decl_stmt|;
comment|/* from HARP struct */
name|PROATM
modifier|*
name|proatm
decl_stmt|;
name|int32_t
name|class
decl_stmt|,
name|pcr
decl_stmt|,
name|scr
decl_stmt|,
name|mbs
decl_stmt|;
name|int32_t
name|slots_vc
decl_stmt|,
name|slots_cur
decl_stmt|,
name|slots_max
decl_stmt|;
if|if
condition|(
name|cmnvcc
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|cmnvcc
operator|->
name|cv_connvc
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|proatm
operator|=
operator|(
name|PROATM
operator|*
operator|)
name|cmnunit
expr_stmt|;
if|if
condition|(
name|proatm
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|attrib
operator|=
operator|&
name|cmnvcc
operator|->
name|cv_connvc
operator|->
name|cvc_attr
expr_stmt|;
if|if
condition|(
name|attrib
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|pcr
operator|=
name|attrib
operator|->
name|traffic
operator|.
name|v
operator|.
name|forward
operator|.
name|PCR_all_traffic
expr_stmt|;
name|scr
operator|=
name|attrib
operator|->
name|traffic
operator|.
name|v
operator|.
name|forward
operator|.
name|SCR_all_traffic
expr_stmt|;
name|mbs
operator|=
name|attrib
operator|->
name|traffic
operator|.
name|v
operator|.
name|forward
operator|.
name|MBS_all_traffic
expr_stmt|;
if|if
condition|(
name|pcr
operator|<=
literal|0
condition|)
name|pcr
operator|=
name|scr
expr_stmt|;
comment|/* if PCR missing, default to SCR */
if|if
condition|(
name|pcr
operator|<=
literal|0
condition|)
name|pcr
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|scr
operator|<=
literal|0
condition|)
name|scr
operator|=
name|pcr
expr_stmt|;
name|class
operator|=
name|proatm_atm_bearerclass
argument_list|(
operator|&
name|attrib
operator|->
name|bearer
argument_list|)
expr_stmt|;
if|if
condition|(
name|class
operator|==
name|NICCBR
condition|)
block|{
name|slots_max
operator|=
name|proatm
operator|->
name|tst_num
expr_stmt|;
name|slots_cur
operator|=
name|proatm
operator|->
name|txslots_cur
expr_stmt|;
name|slots_vc
operator|=
name|proatm_slots_cbr
argument_list|(
name|proatm
argument_list|,
name|scr
argument_list|)
expr_stmt|;
if|if
condition|(
name|slots_vc
operator|+
name|slots_cur
operator|>
name|slots_max
condition|)
block|{
name|proatm
operator|->
name|pu_stats
operator|.
name|proatm_st_drv
operator|.
name|drv_vc_outofbw
operator|++
expr_stmt|;
if|if
condition|(
name|proatm_sysctl_logvcs
condition|)
name|printf
argument_list|(
literal|"proatm%d: Insufficient bandwproatmh (vc=%d cur=%d max=%d)\n"
argument_list|,
name|proatm
operator|->
name|unit
argument_list|,
name|slots_vc
argument_list|,
name|slots_cur
argument_list|,
name|slots_max
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
comment|/* This part was taken from /sys/dev/hfa/fore_vcm.c */
switch|switch
condition|(
name|attrib
operator|->
name|aal
operator|.
name|type
condition|)
block|{
case|case
name|ATM_AAL0
case|:
break|break;
case|case
name|ATM_AAL3_4
case|:
if|if
condition|(
operator|(
name|attrib
operator|->
name|aal
operator|.
name|v
operator|.
name|aal4
operator|.
name|forward_max_SDU_size
operator|>
name|PROATM_IFF_MTU
operator|)
operator|||
operator|(
name|attrib
operator|->
name|aal
operator|.
name|v
operator|.
name|aal4
operator|.
name|backward_max_SDU_size
operator|>
name|PROATM_IFF_MTU
operator|)
condition|)
block|{
name|proatm
operator|->
name|pu_stats
operator|.
name|proatm_st_drv
operator|.
name|drv_vc_maxpdu
operator|++
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
break|break;
case|case
name|ATM_AAL5
case|:
if|if
condition|(
operator|(
name|attrib
operator|->
name|aal
operator|.
name|v
operator|.
name|aal5
operator|.
name|forward_max_SDU_size
operator|>
name|PROATM_IFF_MTU
operator|)
operator|||
operator|(
name|attrib
operator|->
name|aal
operator|.
name|v
operator|.
name|aal5
operator|.
name|backward_max_SDU_size
operator|>
name|PROATM_IFF_MTU
operator|)
condition|)
block|{
name|proatm
operator|->
name|pu_stats
operator|.
name|proatm_st_drv
operator|.
name|drv_vc_maxpdu
operator|++
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Pass Incoming PDU up Stack  *  * This function is called via the core ATM interrupt queue callback   * set in proatm_receive().  It will pass the supplied incoming   * PDU up the incoming VCC's stack.  *  * Called at splnet by the ATM's ISR.  *  * Arguments:  *    tok        token to identify stack instantiation  *    m        pointer to incoming PDU buffer chain  *  * Returns:  *    none  */
end_comment

begin_function
specifier|static
name|void
name|proatm_recv_stack
parameter_list|(
name|void
modifier|*
name|tok
parameter_list|,
name|KBuffer
modifier|*
name|m
parameter_list|)
block|{
name|Idt_vcc
modifier|*
name|ivp
init|=
operator|(
name|Idt_vcc
operator|*
operator|)
name|tok
decl_stmt|;
name|int32_t
name|err
decl_stmt|;
comment|/*      * This should never happen now but if it does and we don't stop it,      * we end up panic'ing in netatm when trying to pull a function      * pointer and token value out of a buffer with address zero.      */
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"proatm: proatm_recv_stack: Warning - null mbuf pointer.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_PKTHDR
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"proatm: proatm_recv_stack: Warning - mbuf chain has no header.\n"
argument_list|)
expr_stmt|;
name|KB_FREEALL
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*          * Send the data up the stack          */
name|STACK_CALL
argument_list|(
name|CPCS_UNITDATA_SIG
argument_list|,
name|ivp
operator|->
name|iv_upper
argument_list|,
name|ivp
operator|->
name|iv_toku
argument_list|,
name|ivp
operator|->
name|iv_vccb
argument_list|,
operator|(
name|int32_t
operator|)
name|m
argument_list|,
literal|0
argument_list|,
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|KB_FREEALL
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/******************************************************************************  *  *  Enqueue received PDU for HARP to handle  *  *  in:  PROATM device, mbuf, vpi, vci  *  */
end_comment

begin_function
specifier|static
name|void
name|proatm_receive
parameter_list|(
name|proatm_reg_t
modifier|*
name|proatm
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int32_t
name|vpi
parameter_list|,
name|int32_t
name|vci
parameter_list|)
block|{
name|caddr_t
name|cp
decl_stmt|;
name|Cmn_vcc
modifier|*
name|vcc
decl_stmt|;
name|int32_t
name|space
decl_stmt|;
comment|/*     * The STACK_CALL needs to happen at splnet() in order     * for the stack sequence processing to work.  Schedule an     * interrupt queue callback at splnet() since we are      * currently at device level.     */
comment|/*     * Prepend callback function pointer and token value to buffer.     * We have already guaranteed that the space is available     * in the first buffer.     */
comment|/*      * Locate incoming VCC for this PDU      */
name|vcc
operator|=
name|atm_dev_vcc_find
argument_list|(
operator|(
name|Cmn_unit
operator|*
operator|)
name|proatm
argument_list|,
name|vpi
argument_list|,
name|vci
argument_list|,
name|VCC_IN
argument_list|)
expr_stmt|;
if|if
condition|(
name|vcc
operator|==
name|NULL
condition|)
block|{
comment|/* harp stack not ready or no vcc */
name|printf
argument_list|(
literal|"proatm%d: proatm_receive: no VCC %d/%d\n"
argument_list|,
name|proatm
operator|->
name|unit
argument_list|,
name|vpi
argument_list|,
name|vci
argument_list|)
expr_stmt|;
name|proatm
operator|->
name|pu_stats
operator|.
name|proatm_st_drv
operator|.
name|drv_rv_novcc
operator|++
expr_stmt|;
name|proatm
operator|->
name|stats_ierrors
operator|++
expr_stmt|;
name|KB_FREEALL
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
name|space
operator|=
name|m
operator|->
name|m_data
operator|-
name|proatm_mbuf_base
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|space
operator|<
sizeof|sizeof
argument_list|(
name|atm_intr_func_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|int
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"proatm%d: proatm_receive: NOT enough buffer space (%d)\n"
argument_list|,
name|proatm
operator|->
name|unit
argument_list|,
name|space
argument_list|)
expr_stmt|;
name|proatm
operator|->
name|pu_stats
operator|.
name|proatm_st_drv
operator|.
name|drv_rv_nobufs
operator|++
expr_stmt|;
name|proatm
operator|->
name|stats_ierrors
operator|++
expr_stmt|;
name|KB_FREEALL
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
name|KB_HEADADJ
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
name|atm_intr_func_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|KB_DATASTART
argument_list|(
name|m
argument_list|,
name|cp
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
comment|/*      * Free zero-length buffer      */
if|if
condition|(
name|m
operator|->
name|m_len
operator|==
literal|0
condition|)
block|{
name|proatm
operator|->
name|pu_stats
operator|.
name|proatm_st_drv
operator|.
name|drv_rv_null
operator|++
expr_stmt|;
name|proatm
operator|->
name|stats_ierrors
operator|++
expr_stmt|;
name|KB_FREEALL
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
operator|*
operator|(
operator|(
name|atm_intr_func_t
operator|*
operator|)
name|cp
operator|)
operator|=
name|proatm_recv_stack
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|atm_intr_func_t
argument_list|)
expr_stmt|;
operator|*
operator|(
operator|(
name|void
operator|*
operator|*
operator|)
name|cp
operator|)
operator|=
operator|(
name|void
operator|*
operator|)
name|vcc
expr_stmt|;
comment|/*      * Schedule callback      */
if|if
condition|(
operator|!
name|IF_QFULL
argument_list|(
operator|&
name|atm_intrq
argument_list|)
condition|)
block|{
name|IF_ENQUEUE
argument_list|(
operator|&
name|atm_intrq
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|SCHED_ATM
expr_stmt|;
block|}
else|else
block|{
name|proatm
operator|->
name|pu_stats
operator|.
name|proatm_st_drv
operator|.
name|drv_rv_intrq
operator|++
expr_stmt|;
name|proatm
operator|->
name|stats_ierrors
operator|++
expr_stmt|;
comment|/* atm_intrq is full. Unable to pass up to the HARP stack */
name|KB_FREEALL
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

