begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1998 Nicolas Souchu, Marc Bouget  * Copyright (c) 2004 Joerg Wunsch  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<dev/iicbus/iicbus.h>
end_include

begin_include
include|#
directive|include
file|<dev/iicbus/iiconf.h>
end_include

begin_include
include|#
directive|include
file|<dev/pcf/pcfvar.h>
end_include

begin_include
include|#
directive|include
file|"iicbus_if.h"
end_include

begin_comment
comment|/* Not so official debugging option. */
end_comment

begin_comment
comment|/* #define PCFDEBUG */
end_comment

begin_function_decl
specifier|static
name|int
name|pcf_wait_byte
parameter_list|(
name|struct
name|pcf_softc
modifier|*
name|pcf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pcf_noack
parameter_list|(
name|struct
name|pcf_softc
modifier|*
name|pcf
parameter_list|,
name|int
name|timeout
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pcf_stop_locked
parameter_list|(
name|struct
name|pcf_softc
modifier|*
name|pcf
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Polling mode for master operations wait for a new  * byte incoming or outgoing  */
end_comment

begin_function
specifier|static
name|int
name|pcf_wait_byte
parameter_list|(
name|struct
name|pcf_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|counter
init|=
name|TIMEOUT
decl_stmt|;
name|PCF_ASSERT_LOCKED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
while|while
condition|(
name|counter
operator|--
condition|)
block|{
if|if
condition|(
operator|(
name|pcf_get_S1
argument_list|(
name|sc
argument_list|)
operator|&
name|PIN
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|PCFDEBUG
name|printf
argument_list|(
literal|"pcf: timeout!\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|IIC_ETIMEOUT
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pcf_stop_locked
parameter_list|(
name|struct
name|pcf_softc
modifier|*
name|sc
parameter_list|)
block|{
name|PCF_ASSERT_LOCKED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PCFDEBUG
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|">> stop\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Send STOP condition iff the START condition was previously sent. 	 * STOP is sent only once even if an iicbus_stop() is called after 	 * an iicbus_read()... see pcf_read(): the PCF needs to send the stop 	 * before the last char is read. 	 */
if|if
condition|(
name|sc
operator|->
name|pcf_started
condition|)
block|{
comment|/* set stop condition and enable IT */
name|pcf_set_S1
argument_list|(
name|sc
argument_list|,
name|PIN
operator||
name|ESO
operator||
name|ENI
operator||
name|STO
operator||
name|ACK
argument_list|)
expr_stmt|;
name|sc
operator|->
name|pcf_started
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|pcf_noack
parameter_list|(
name|struct
name|pcf_softc
modifier|*
name|sc
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
name|int
name|noack
decl_stmt|;
name|int
name|k
init|=
name|timeout
operator|/
literal|10
decl_stmt|;
name|PCF_ASSERT_LOCKED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
do|do
block|{
name|noack
operator|=
name|pcf_get_S1
argument_list|(
name|sc
argument_list|)
operator|&
name|LRB
expr_stmt|;
if|if
condition|(
operator|!
name|noack
condition|)
break|break;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
comment|/* XXX wait 10 us */
block|}
do|while
condition|(
name|k
operator|--
condition|)
do|;
return|return
operator|(
name|noack
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pcf_repeated_start
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|u_char
name|slave
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
name|struct
name|pcf_softc
modifier|*
name|sc
init|=
name|DEVTOSOFTC
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|PCF_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PCFDEBUG
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|">> repeated start for slave %#x\n"
argument_list|,
operator|(
name|unsigned
operator|)
name|slave
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* repeated start */
name|pcf_set_S1
argument_list|(
name|sc
argument_list|,
name|ESO
operator||
name|STA
operator||
name|STO
operator||
name|ACK
argument_list|)
expr_stmt|;
comment|/* set slave address to PCF. Last bit (LSB) must be set correctly 	 * according to transfer direction */
name|pcf_set_S0
argument_list|(
name|sc
argument_list|,
name|slave
argument_list|)
expr_stmt|;
comment|/* wait for address sent, polling */
if|if
condition|(
operator|(
name|error
operator|=
name|pcf_wait_byte
argument_list|(
name|sc
argument_list|)
operator|)
condition|)
goto|goto
name|error
goto|;
comment|/* check for ack */
if|if
condition|(
name|pcf_noack
argument_list|(
name|sc
argument_list|,
name|timeout
argument_list|)
condition|)
block|{
name|error
operator|=
name|IIC_ENOACK
expr_stmt|;
ifdef|#
directive|ifdef
name|PCFDEBUG
name|printf
argument_list|(
literal|"pcf: no ack on repeated_start!\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|error
goto|;
block|}
name|PCF_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|error
label|:
name|pcf_stop_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|PCF_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pcf_start
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|u_char
name|slave
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
name|struct
name|pcf_softc
modifier|*
name|sc
init|=
name|DEVTOSOFTC
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|PCF_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PCFDEBUG
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|">> start for slave %#x\n"
argument_list|,
operator|(
name|unsigned
operator|)
name|slave
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|pcf_get_S1
argument_list|(
name|sc
argument_list|)
operator|&
name|nBB
operator|)
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|PCFDEBUG
name|printf
argument_list|(
literal|"pcf: busy!\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|PCF_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|IIC_EBUSBSY
operator|)
return|;
block|}
comment|/* set slave address to PCF. Last bit (LSB) must be set correctly 	 * according to transfer direction */
name|pcf_set_S0
argument_list|(
name|sc
argument_list|,
name|slave
argument_list|)
expr_stmt|;
comment|/* START only */
name|pcf_set_S1
argument_list|(
name|sc
argument_list|,
name|PIN
operator||
name|ESO
operator||
name|STA
operator||
name|ACK
argument_list|)
expr_stmt|;
name|sc
operator|->
name|pcf_started
operator|=
literal|1
expr_stmt|;
comment|/* wait for address sent, polling */
if|if
condition|(
operator|(
name|error
operator|=
name|pcf_wait_byte
argument_list|(
name|sc
argument_list|)
operator|)
condition|)
goto|goto
name|error
goto|;
comment|/* check for ACK */
if|if
condition|(
name|pcf_noack
argument_list|(
name|sc
argument_list|,
name|timeout
argument_list|)
condition|)
block|{
name|error
operator|=
name|IIC_ENOACK
expr_stmt|;
ifdef|#
directive|ifdef
name|PCFDEBUG
name|printf
argument_list|(
literal|"pcf: no ack on start!\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|error
goto|;
block|}
name|PCF_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|error
label|:
name|pcf_stop_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|PCF_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pcf_stop
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|pcf_softc
modifier|*
name|sc
init|=
name|DEVTOSOFTC
argument_list|(
name|dev
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|PCFDEBUG
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|">> stop\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|PCF_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|pcf_stop_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|PCF_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|pcf_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|pcf_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|char
name|data
decl_stmt|,
name|status
decl_stmt|,
name|addr
decl_stmt|;
name|char
name|error
init|=
literal|0
decl_stmt|;
name|PCF_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|status
operator|=
name|pcf_get_S1
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|PIN
condition|)
block|{
name|printf
argument_list|(
literal|"pcf: spurious interrupt, status=0x%x\n"
argument_list|,
name|status
operator|&
literal|0xff
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|status
operator|&
name|LAB
condition|)
name|printf
argument_list|(
literal|"pcf: bus arbitration lost!\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|BER
condition|)
block|{
name|error
operator|=
name|IIC_EBUSERR
expr_stmt|;
name|iicbus_intr
argument_list|(
name|sc
operator|->
name|iicbus
argument_list|,
name|INTR_ERROR
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
do|do
block|{
name|status
operator|=
name|pcf_get_S1
argument_list|(
name|sc
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|pcf_slave_mode
condition|)
block|{
case|case
name|SLAVE_TRANSMITTER
case|:
if|if
condition|(
name|status
operator|&
name|LRB
condition|)
block|{
comment|/* ack interrupt line */
name|dummy_write
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* no ack, don't send anymore */
name|sc
operator|->
name|pcf_slave_mode
operator|=
name|SLAVE_RECEIVER
expr_stmt|;
name|iicbus_intr
argument_list|(
name|sc
operator|->
name|iicbus
argument_list|,
name|INTR_NOACK
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* get data from upper code */
name|iicbus_intr
argument_list|(
name|sc
operator|->
name|iicbus
argument_list|,
name|INTR_TRANSMIT
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
name|pcf_set_S0
argument_list|(
name|sc
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|SLAVE_RECEIVER
case|:
if|if
condition|(
name|status
operator|&
name|AAS
condition|)
block|{
name|addr
operator|=
name|pcf_get_S0
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|AD0
condition|)
name|iicbus_intr
argument_list|(
name|sc
operator|->
name|iicbus
argument_list|,
name|INTR_GENERAL
argument_list|,
operator|&
name|addr
argument_list|)
expr_stmt|;
else|else
name|iicbus_intr
argument_list|(
name|sc
operator|->
name|iicbus
argument_list|,
name|INTR_START
argument_list|,
operator|&
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|&
name|LSB
condition|)
block|{
name|sc
operator|->
name|pcf_slave_mode
operator|=
name|SLAVE_TRANSMITTER
expr_stmt|;
comment|/* get the first char from upper code */
name|iicbus_intr
argument_list|(
name|sc
operator|->
name|iicbus
argument_list|,
name|INTR_TRANSMIT
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
comment|/* send first data byte */
name|pcf_set_S0
argument_list|(
name|sc
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
comment|/* stop condition received? */
if|if
condition|(
name|status
operator|&
name|STS
condition|)
block|{
comment|/* ack interrupt line */
name|dummy_read
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* emulate intr stop condition */
name|iicbus_intr
argument_list|(
name|sc
operator|->
name|iicbus
argument_list|,
name|INTR_STOP
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* get data, ack interrupt line */
name|data
operator|=
name|pcf_get_S0
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* deliver the character */
name|iicbus_intr
argument_list|(
name|sc
operator|->
name|iicbus
argument_list|,
name|INTR_RECEIVE
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|panic
argument_list|(
literal|"%s: unknown slave mode (%d)!"
argument_list|,
name|__func__
argument_list|,
name|sc
operator|->
name|pcf_slave_mode
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|(
name|pcf_get_S1
argument_list|(
name|sc
argument_list|)
operator|&
name|PIN
operator|)
operator|==
literal|0
condition|)
do|;
name|PCF_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
name|error
label|:
comment|/* unknown event on bus...reset PCF */
name|pcf_set_S1
argument_list|(
name|sc
argument_list|,
name|PIN
operator||
name|ESO
operator||
name|ENI
operator||
name|ACK
argument_list|)
expr_stmt|;
name|sc
operator|->
name|pcf_slave_mode
operator|=
name|SLAVE_RECEIVER
expr_stmt|;
name|PCF_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|int
name|pcf_rst_card
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|u_char
name|speed
parameter_list|,
name|u_char
name|addr
parameter_list|,
name|u_char
modifier|*
name|oldaddr
parameter_list|)
block|{
name|struct
name|pcf_softc
modifier|*
name|sc
init|=
name|DEVTOSOFTC
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|PCF_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldaddr
condition|)
operator|*
name|oldaddr
operator|=
name|sc
operator|->
name|pcf_addr
expr_stmt|;
comment|/* retrieve own address from bus level */
if|if
condition|(
operator|!
name|addr
condition|)
name|sc
operator|->
name|pcf_addr
operator|=
name|PCF_DEFAULT_ADDR
expr_stmt|;
else|else
name|sc
operator|->
name|pcf_addr
operator|=
name|addr
expr_stmt|;
name|pcf_set_S1
argument_list|(
name|sc
argument_list|,
name|PIN
argument_list|)
expr_stmt|;
comment|/* initialize S1 */
comment|/* own address S'O<>0 */
name|pcf_set_S0
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|pcf_addr
operator|>>
literal|1
argument_list|)
expr_stmt|;
comment|/* select clock register */
name|pcf_set_S1
argument_list|(
name|sc
argument_list|,
name|PIN
operator||
name|ES1
argument_list|)
expr_stmt|;
comment|/* select bus speed : 18=90kb, 19=45kb, 1A=11kb, 1B=1.5kb */
switch|switch
condition|(
name|speed
condition|)
block|{
case|case
name|IIC_SLOW
case|:
name|pcf_set_S0
argument_list|(
name|sc
argument_list|,
literal|0x1b
argument_list|)
expr_stmt|;
comment|/* XXX Sun uses 0x1f */
break|break;
case|case
name|IIC_FAST
case|:
name|pcf_set_S0
argument_list|(
name|sc
argument_list|,
literal|0x19
argument_list|)
expr_stmt|;
comment|/* XXX Sun: 0x1d */
break|break;
case|case
name|IIC_UNKNOWN
case|:
case|case
name|IIC_FASTEST
case|:
default|default:
name|pcf_set_S0
argument_list|(
name|sc
argument_list|,
literal|0x18
argument_list|)
expr_stmt|;
comment|/* XXX Sun: 0x1c */
break|break;
block|}
comment|/* set bus on, ack=yes, INT=yes */
name|pcf_set_S1
argument_list|(
name|sc
argument_list|,
name|PIN
operator||
name|ESO
operator||
name|ENI
operator||
name|ACK
argument_list|)
expr_stmt|;
name|sc
operator|->
name|pcf_slave_mode
operator|=
name|SLAVE_RECEIVER
expr_stmt|;
name|PCF_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pcf_write
parameter_list|(
name|device_t
name|dev
parameter_list|,
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|,
name|int
modifier|*
name|sent
parameter_list|,
name|int
name|timeout
comment|/* us */
parameter_list|)
block|{
name|struct
name|pcf_softc
modifier|*
name|sc
init|=
name|DEVTOSOFTC
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|bytes
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|PCFDEBUG
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|">> writing %d bytes: %#x%s\n"
argument_list|,
name|len
argument_list|,
operator|(
name|unsigned
operator|)
name|buf
index|[
literal|0
index|]
argument_list|,
name|len
operator|>
literal|1
condition|?
literal|"..."
else|:
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bytes
operator|=
literal|0
expr_stmt|;
name|PCF_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
while|while
condition|(
name|len
condition|)
block|{
name|pcf_set_S0
argument_list|(
name|sc
argument_list|,
operator|*
name|buf
operator|++
argument_list|)
expr_stmt|;
comment|/* wait for the byte to be send */
if|if
condition|(
operator|(
name|error
operator|=
name|pcf_wait_byte
argument_list|(
name|sc
argument_list|)
operator|)
condition|)
goto|goto
name|error
goto|;
comment|/* check if ack received */
if|if
condition|(
name|pcf_noack
argument_list|(
name|sc
argument_list|,
name|timeout
argument_list|)
condition|)
block|{
name|error
operator|=
name|IIC_ENOACK
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|len
operator|--
expr_stmt|;
name|bytes
operator|++
expr_stmt|;
block|}
name|error
label|:
operator|*
name|sent
operator|=
name|bytes
expr_stmt|;
name|PCF_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PCFDEBUG
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|">> %d bytes written (%d)\n"
argument_list|,
name|bytes
argument_list|,
name|error
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pcf_read
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|,
name|int
modifier|*
name|read
parameter_list|,
name|int
name|last
parameter_list|,
name|int
name|delay
comment|/* us */
parameter_list|)
block|{
name|struct
name|pcf_softc
modifier|*
name|sc
init|=
name|DEVTOSOFTC
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|bytes
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|PCFDEBUG
name|char
modifier|*
name|obuf
init|=
name|buf
decl_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"<< reading %d bytes\n"
argument_list|,
name|len
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|PCF_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* trig the bus to get the first data byte in S0 */
if|if
condition|(
name|len
condition|)
block|{
if|if
condition|(
name|len
operator|==
literal|1
operator|&&
name|last
condition|)
comment|/* just one byte to read */
name|pcf_set_S1
argument_list|(
name|sc
argument_list|,
name|ESO
argument_list|)
expr_stmt|;
comment|/* no ack */
name|dummy_read
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|bytes
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|len
condition|)
block|{
comment|/* XXX delay needed here */
comment|/* wait for trigged byte */
if|if
condition|(
operator|(
name|error
operator|=
name|pcf_wait_byte
argument_list|(
name|sc
argument_list|)
operator|)
condition|)
block|{
name|pcf_stop_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|len
operator|==
literal|1
operator|&&
name|last
condition|)
comment|/* ok, last data byte already in S0, no I2C activity 			 * on next pcf_get_S0() */
name|pcf_stop_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|len
operator|==
literal|2
operator|&&
name|last
condition|)
comment|/* next trigged byte with no ack */
name|pcf_set_S1
argument_list|(
name|sc
argument_list|,
name|ESO
argument_list|)
expr_stmt|;
comment|/* receive byte, trig next byte */
operator|*
name|buf
operator|++
operator|=
name|pcf_get_S0
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|len
operator|--
expr_stmt|;
name|bytes
operator|++
expr_stmt|;
block|}
empty_stmt|;
name|error
label|:
operator|*
name|read
operator|=
name|bytes
expr_stmt|;
name|PCF_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PCFDEBUG
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"<< %d bytes read (%d): %#x%s\n"
argument_list|,
name|bytes
argument_list|,
name|error
argument_list|,
operator|(
name|unsigned
operator|)
name|obuf
index|[
literal|0
index|]
argument_list|,
name|bytes
operator|>
literal|1
condition|?
literal|"..."
else|:
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|iicbus
argument_list|,
name|pcf
argument_list|,
name|iicbus_driver
argument_list|,
name|iicbus_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|pcf
argument_list|,
name|iicbus
argument_list|,
name|PCF_MINVER
argument_list|,
name|PCF_PREFVER
argument_list|,
name|PCF_MAXVER
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|pcf
argument_list|,
name|PCF_MODVER
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

