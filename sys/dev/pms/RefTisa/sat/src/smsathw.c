begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************************* *Copyright (c) 2014 PMC-Sierra, Inc.  All rights reserved.  * *Redistribution and use in source and binary forms, with or without modification, are permitted provided  *that the following conditions are met:  *1. Redistributions of source code must retain the above copyright notice, this list of conditions and the *following disclaimer.  *2. Redistributions in binary form must reproduce the above copyright notice,  *this list of conditions and the following disclaimer in the documentation and/or other materials provided *with the distribution.  * *THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR IMPLIED  *WARRANTIES,INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS *FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE *FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  *NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR  *BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  *LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  *SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE  ********************************************************************************/
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<dev/pms/config.h>
end_include

begin_include
include|#
directive|include
file|<dev/pms/freebsd/driver/common/osenv.h>
end_include

begin_include
include|#
directive|include
file|<dev/pms/freebsd/driver/common/ostypes.h>
end_include

begin_include
include|#
directive|include
file|<dev/pms/freebsd/driver/common/osdebug.h>
end_include

begin_include
include|#
directive|include
file|<dev/pms/RefTisa/tisa/api/titypes.h>
end_include

begin_include
include|#
directive|include
file|<dev/pms/RefTisa/sallsdk/api/sa.h>
end_include

begin_include
include|#
directive|include
file|<dev/pms/RefTisa/sallsdk/api/saapi.h>
end_include

begin_include
include|#
directive|include
file|<dev/pms/RefTisa/sallsdk/api/saosapi.h>
end_include

begin_include
include|#
directive|include
file|<dev/pms/RefTisa/sat/api/sm.h>
end_include

begin_include
include|#
directive|include
file|<dev/pms/RefTisa/sat/api/smapi.h>
end_include

begin_include
include|#
directive|include
file|<dev/pms/RefTisa/sat/api/tdsmapi.h>
end_include

begin_include
include|#
directive|include
file|<dev/pms/RefTisa/sat/src/smdefs.h>
end_include

begin_include
include|#
directive|include
file|<dev/pms/RefTisa/sat/src/smproto.h>
end_include

begin_include
include|#
directive|include
file|<dev/pms/RefTisa/sat/src/smtypes.h>
end_include

begin_comment
comment|/*  * This table is used to map LL Layer saSATAStart() status to TISA status.  */
end_comment

begin_function
name|FORCEINLINE
name|bit32
name|smsataLLIOStart
parameter_list|(
name|smRoot_t
modifier|*
name|smRoot
parameter_list|,
name|smIORequest_t
modifier|*
name|smIORequest
parameter_list|,
name|smDeviceHandle_t
modifier|*
name|smDeviceHandle
parameter_list|,
name|smScsiInitiatorRequest_t
modifier|*
name|smScsiRequest
parameter_list|,
name|smSatIOContext_t
modifier|*
name|satIOContext
parameter_list|)
block|{
name|smDeviceData_t
modifier|*
name|oneDeviceData
init|=
operator|(
name|smDeviceData_t
operator|*
operator|)
name|smDeviceHandle
operator|->
name|smData
decl_stmt|;
name|smIntRoot_t
modifier|*
name|smIntRoot
init|=
operator|(
name|smIntRoot_t
operator|*
operator|)
name|smRoot
operator|->
name|smData
decl_stmt|;
name|smIntContext_t
modifier|*
name|smAllShared
init|=
operator|(
name|smIntContext_t
operator|*
operator|)
operator|&
operator|(
name|smIntRoot
operator|->
name|smAllShared
operator|)
decl_stmt|;
name|smIORequestBody_t
modifier|*
name|smIORequestBody
init|=
operator|(
name|smIORequestBody_t
operator|*
operator|)
name|satIOContext
operator|->
name|smRequestBody
decl_stmt|;
name|smDeviceData_t
modifier|*
name|pSatDevData
init|=
name|satIOContext
operator|->
name|pSatDevData
decl_stmt|;
name|smSatInternalIo_t
modifier|*
name|satIntIo
init|=
name|satIOContext
operator|->
name|satIntIoContext
decl_stmt|;
name|agsaRoot_t
modifier|*
name|agRoot
init|=
name|smAllShared
operator|->
name|agRoot
decl_stmt|;
name|agsaIORequest_t
modifier|*
name|agIORequest
init|=
operator|&
operator|(
name|smIORequestBody
operator|->
name|agIORequest
operator|)
decl_stmt|;
name|agsaDevHandle_t
modifier|*
name|agDevHandle
init|=
name|oneDeviceData
operator|->
name|agDevHandle
decl_stmt|;
name|agsaSATAInitiatorRequest_t
modifier|*
name|agSATAReq
init|=
operator|&
operator|(
name|smIORequestBody
operator|->
name|transport
operator|.
name|SATA
operator|.
name|agSATARequestBody
operator|)
decl_stmt|;
name|bit32
name|RLERecovery
init|=
name|agFALSE
decl_stmt|;
name|bit32
name|status
init|=
name|SM_RC_FAILURE
decl_stmt|;
name|bit32
name|nQNumber
init|=
literal|0
decl_stmt|;
comment|/*     * If this is a super I/O request, check for optional settings.    * Be careful. Use the superRequest pointer for all references     * in this block of code.    */
name|agSATAReq
operator|->
name|option
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|satIOContext
operator|->
name|superIOFlag
condition|)
block|{
name|smSuperScsiInitiatorRequest_t
modifier|*
name|superRequest
init|=
operator|(
name|smSuperScsiInitiatorRequest_t
operator|*
operator|)
name|smScsiRequest
decl_stmt|;
if|if
condition|(
name|superRequest
operator|->
name|flags
operator|&
name|SM_SCSI_INITIATOR_ENCRYPT
condition|)
block|{
comment|/* Copy all of the relevant encrypt information  */
name|agSATAReq
operator|->
name|option
operator||=
name|AGSA_SATA_ENABLE_ENCRYPTION
expr_stmt|;
name|sm_memcpy
argument_list|(
operator|&
name|agSATAReq
operator|->
name|encrypt
argument_list|,
operator|&
name|superRequest
operator|->
name|Encrypt
argument_list|,
sizeof|sizeof
argument_list|(
name|agsaEncrypt_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|{
comment|/* initialize expDataLength */
if|if
condition|(
name|satIOContext
operator|->
name|reqType
operator|==
name|AGSA_SATA_PROTOCOL_NON_DATA
operator|||
name|satIOContext
operator|->
name|reqType
operator|==
name|AGSA_SATA_PROTOCOL_SRST_ASSERT
operator|||
name|satIOContext
operator|->
name|reqType
operator|==
name|AGSA_SATA_PROTOCOL_SRST_DEASSERT
condition|)
block|{
name|smIORequestBody
operator|->
name|IOType
operator|.
name|InitiatorRegIO
operator|.
name|expDataLength
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|smIORequestBody
operator|->
name|IOType
operator|.
name|InitiatorRegIO
operator|.
name|expDataLength
operator|=
name|smScsiRequest
operator|->
name|scsiCmnd
operator|.
name|expDataLength
expr_stmt|;
block|}
name|agSATAReq
operator|->
name|dataLength
operator|=
name|smIORequestBody
operator|->
name|IOType
operator|.
name|InitiatorRegIO
operator|.
name|expDataLength
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* initialize expDataLength */
if|if
condition|(
name|satIOContext
operator|->
name|reqType
operator|==
name|AGSA_SATA_PROTOCOL_NON_DATA
operator|||
name|satIOContext
operator|->
name|reqType
operator|==
name|AGSA_SATA_PROTOCOL_SRST_ASSERT
operator|||
name|satIOContext
operator|->
name|reqType
operator|==
name|AGSA_SATA_PROTOCOL_SRST_DEASSERT
condition|)
block|{
name|smIORequestBody
operator|->
name|IOType
operator|.
name|InitiatorRegIO
operator|.
name|expDataLength
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|smIORequestBody
operator|->
name|IOType
operator|.
name|InitiatorRegIO
operator|.
name|expDataLength
operator|=
name|smScsiRequest
operator|->
name|scsiCmnd
operator|.
name|expDataLength
expr_stmt|;
block|}
name|agSATAReq
operator|->
name|dataLength
operator|=
name|smIORequestBody
operator|->
name|IOType
operator|.
name|InitiatorRegIO
operator|.
name|expDataLength
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|pSatDevData
operator|->
name|satDriveState
operator|==
name|SAT_DEV_STATE_IN_RECOVERY
operator|)
operator|&&
operator|(
name|satIOContext
operator|->
name|pFis
operator|->
name|h
operator|.
name|command
operator|==
name|SAT_READ_LOG_EXT
operator|)
condition|)
block|{
name|RLERecovery
operator|=
name|agTRUE
expr_stmt|;
block|}
comment|/* check max io, be sure to free */
if|if
condition|(
operator|(
name|pSatDevData
operator|->
name|satDriveState
operator|!=
name|SAT_DEV_STATE_IN_RECOVERY
operator|)
operator|||
operator|(
name|RLERecovery
operator|==
name|agTRUE
operator|)
condition|)
block|{
if|if
condition|(
name|RLERecovery
operator|==
name|agFALSE
condition|)
comment|/* RLE is not checked against pending IO's */
block|{
ifdef|#
directive|ifdef
name|CCFLAG_OPTIMIZE_SAT_LOCK
name|bit32
specifier|volatile
name|satPendingNCQIO
init|=
literal|0
decl_stmt|;
name|bit32
specifier|volatile
name|satPendingNONNCQIO
init|=
literal|0
decl_stmt|;
name|bit32
specifier|volatile
name|satPendingIO
init|=
literal|0
decl_stmt|;
name|tdsmInterlockedExchange
argument_list|(
name|smRoot
argument_list|,
operator|&
name|satPendingNCQIO
argument_list|,
name|pSatDevData
operator|->
name|satPendingNCQIO
argument_list|)
expr_stmt|;
name|tdsmInterlockedExchange
argument_list|(
name|smRoot
argument_list|,
operator|&
name|satPendingNONNCQIO
argument_list|,
name|pSatDevData
operator|->
name|satPendingNONNCQIO
argument_list|)
expr_stmt|;
name|tdsmInterlockedExchange
argument_list|(
name|smRoot
argument_list|,
operator|&
name|satPendingIO
argument_list|,
name|pSatDevData
operator|->
name|satPendingIO
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|satIOContext
operator|->
name|reqType
operator|==
name|AGSA_SATA_PROTOCOL_FPDMA_WRITE
operator|)
operator|||
operator|(
name|satIOContext
operator|->
name|reqType
operator|==
name|AGSA_SATA_PROTOCOL_FPDMA_READ
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|CCFLAG_OPTIMIZE_SAT_LOCK
if|if
condition|(
name|satPendingNCQIO
operator|>=
name|pSatDevData
operator|->
name|satNCQMaxIO
operator|||
name|satPendingNONNCQIO
operator|!=
literal|0
condition|)
block|{
name|SM_DBG1
argument_list|(
operator|(
literal|"smsataLLIOStart: 1st busy did %d!!!\n"
operator|,
name|pSatDevData
operator|->
name|id
operator|)
argument_list|)
expr_stmt|;
name|SM_DBG1
argument_list|(
operator|(
literal|"smsataLLIOStart: 1st busy NCQ. NCQ Pending 0x%x NONNCQ Pending 0x%x All Pending 0x%x!!!\n"
operator|,
name|satPendingNCQIO
operator|,
name|satPendingNONNCQIO
operator|,
name|satPendingIO
operator|)
argument_list|)
expr_stmt|;
comment|/* free resource */
name|smsatFreeIntIoResource
argument_list|(
name|smRoot
argument_list|,
name|pSatDevData
argument_list|,
name|satIntIo
argument_list|)
expr_stmt|;
return|return
name|SM_RC_DEVICE_BUSY
return|;
block|}
else|#
directive|else
name|tdsmSingleThreadedEnter
argument_list|(
name|smRoot
argument_list|,
name|SM_EXTERNAL_IO_LOCK
argument_list|)
expr_stmt|;
if|if
condition|(
name|pSatDevData
operator|->
name|satPendingNCQIO
operator|>=
name|pSatDevData
operator|->
name|satNCQMaxIO
operator|||
name|pSatDevData
operator|->
name|satPendingNONNCQIO
operator|!=
literal|0
condition|)
block|{
name|SM_DBG1
argument_list|(
operator|(
literal|"smsataLLIOStart: 1st busy did %d!!!\n"
operator|,
name|pSatDevData
operator|->
name|id
operator|)
argument_list|)
expr_stmt|;
name|SM_DBG1
argument_list|(
operator|(
literal|"smsataLLIOStart: 1st busy NCQ. NCQ Pending 0x%x NONNCQ Pending 0x%x All Pending 0x%x!!!\n"
operator|,
name|pSatDevData
operator|->
name|satPendingNCQIO
operator|,
name|pSatDevData
operator|->
name|satPendingNONNCQIO
operator|,
name|pSatDevData
operator|->
name|satPendingIO
operator|)
argument_list|)
expr_stmt|;
name|tdsmSingleThreadedLeave
argument_list|(
name|smRoot
argument_list|,
name|SM_EXTERNAL_IO_LOCK
argument_list|)
expr_stmt|;
comment|/* free resource */
name|smsatFreeIntIoResource
argument_list|(
name|smRoot
argument_list|,
name|pSatDevData
argument_list|,
name|satIntIo
argument_list|)
expr_stmt|;
return|return
name|SM_RC_DEVICE_BUSY
return|;
block|}
name|tdsmSingleThreadedLeave
argument_list|(
name|smRoot
argument_list|,
name|SM_EXTERNAL_IO_LOCK
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
operator|(
name|satIOContext
operator|->
name|reqType
operator|==
name|AGSA_SATA_PROTOCOL_D2H_PKT
operator|)
operator|||
operator|(
name|satIOContext
operator|->
name|reqType
operator|==
name|AGSA_SATA_PROTOCOL_H2D_PKT
operator|)
operator|||
operator|(
name|satIOContext
operator|->
name|reqType
operator|==
name|AGSA_SATA_PROTOCOL_NON_PKT
operator|)
condition|)
block|{
name|sm_memcpy
argument_list|(
name|agSATAReq
operator|->
name|scsiCDB
argument_list|,
name|smScsiRequest
operator|->
name|scsiCmnd
operator|.
name|cdb
argument_list|,
literal|16
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CCFLAG_OPTIMIZE_SAT_LOCK
if|if
condition|(
name|satPendingNONNCQIO
operator|>=
name|SAT_APAPI_CMDQ_MAX
operator|||
name|satPendingNCQIO
operator|!=
literal|0
condition|)
block|{
name|SM_DBG1
argument_list|(
operator|(
literal|"smsataLLIOStart: ATAPI busy did %d!!!\n"
operator|,
name|pSatDevData
operator|->
name|id
operator|)
argument_list|)
expr_stmt|;
name|SM_DBG1
argument_list|(
operator|(
literal|"smsataLLIOStart: ATAPI busy NON-NCQ. NCQ Pending 0x%x NON-NCQ Pending 0x%x All Pending 0x%x!!!\n"
operator|,
name|satPendingNCQIO
operator|,
name|satPendingNONNCQIO
operator|,
name|satPendingIO
operator|)
argument_list|)
expr_stmt|;
comment|/* free resource */
name|smsatFreeIntIoResource
argument_list|(
name|smRoot
argument_list|,
name|pSatDevData
argument_list|,
name|satIntIo
argument_list|)
expr_stmt|;
return|return
name|SM_RC_DEVICE_BUSY
return|;
block|}
else|#
directive|else
name|tdsmSingleThreadedEnter
argument_list|(
name|smRoot
argument_list|,
name|SM_EXTERNAL_IO_LOCK
argument_list|)
expr_stmt|;
if|if
condition|(
name|pSatDevData
operator|->
name|satPendingNONNCQIO
operator|>=
name|SAT_APAPI_CMDQ_MAX
operator|||
name|pSatDevData
operator|->
name|satPendingNCQIO
operator|!=
literal|0
condition|)
block|{
name|SM_DBG1
argument_list|(
operator|(
literal|"smsataLLIOStart: ATAPI busy did %d!!!\n"
operator|,
name|pSatDevData
operator|->
name|id
operator|)
argument_list|)
expr_stmt|;
name|SM_DBG1
argument_list|(
operator|(
literal|"smsataLLIOStart: ATAPI busy NON-NCQ. NCQ Pending 0x%x NON-NCQ Pending 0x%x All Pending 0x%x!!!\n"
operator|,
name|pSatDevData
operator|->
name|satPendingNCQIO
operator|,
name|pSatDevData
operator|->
name|satPendingNONNCQIO
operator|,
name|pSatDevData
operator|->
name|satPendingIO
operator|)
argument_list|)
expr_stmt|;
name|tdsmSingleThreadedLeave
argument_list|(
name|smRoot
argument_list|,
name|SM_EXTERNAL_IO_LOCK
argument_list|)
expr_stmt|;
comment|/* free resource */
name|smsatFreeIntIoResource
argument_list|(
name|smRoot
argument_list|,
name|pSatDevData
argument_list|,
name|satIntIo
argument_list|)
expr_stmt|;
return|return
name|SM_RC_DEVICE_BUSY
return|;
block|}
name|tdsmSingleThreadedLeave
argument_list|(
name|smRoot
argument_list|,
name|SM_EXTERNAL_IO_LOCK
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|CCFLAG_OPTIMIZE_SAT_LOCK
if|if
condition|(
name|satPendingNONNCQIO
operator|>=
name|SAT_NONNCQ_MAX
operator|||
name|satPendingNCQIO
operator|!=
literal|0
condition|)
block|{
name|SM_DBG1
argument_list|(
operator|(
literal|"smsataLLIOStart: 2nd busy did %d!!!\n"
operator|,
name|pSatDevData
operator|->
name|id
operator|)
argument_list|)
expr_stmt|;
name|SM_DBG1
argument_list|(
operator|(
literal|"smsataLLIOStart: 2nd busy NCQ. NCQ Pending 0x%x NONNCQ Pending 0x%x All Pending 0x%x!!!\n"
operator|,
name|satPendingNCQIO
operator|,
name|satPendingNONNCQIO
operator|,
name|satPendingIO
operator|)
argument_list|)
expr_stmt|;
comment|/* free resource */
name|smsatFreeIntIoResource
argument_list|(
name|smRoot
argument_list|,
name|pSatDevData
argument_list|,
name|satIntIo
argument_list|)
expr_stmt|;
return|return
name|SM_RC_DEVICE_BUSY
return|;
block|}
else|#
directive|else
name|tdsmSingleThreadedEnter
argument_list|(
name|smRoot
argument_list|,
name|SM_EXTERNAL_IO_LOCK
argument_list|)
expr_stmt|;
if|if
condition|(
name|pSatDevData
operator|->
name|satPendingNONNCQIO
operator|>=
name|SAT_NONNCQ_MAX
operator|||
name|pSatDevData
operator|->
name|satPendingNCQIO
operator|!=
literal|0
condition|)
block|{
name|SM_DBG1
argument_list|(
operator|(
literal|"smsataLLIOStart: 2nd busy did %d!!!\n"
operator|,
name|pSatDevData
operator|->
name|id
operator|)
argument_list|)
expr_stmt|;
name|SM_DBG1
argument_list|(
operator|(
literal|"smsataLLIOStart: 2nd busy NCQ. NCQ Pending 0x%x NONNCQ Pending 0x%x All Pending 0x%x!!!\n"
operator|,
name|pSatDevData
operator|->
name|satPendingNCQIO
operator|,
name|pSatDevData
operator|->
name|satPendingNONNCQIO
operator|,
name|pSatDevData
operator|->
name|satPendingIO
operator|)
argument_list|)
expr_stmt|;
name|tdsmSingleThreadedLeave
argument_list|(
name|smRoot
argument_list|,
name|SM_EXTERNAL_IO_LOCK
argument_list|)
expr_stmt|;
comment|/* free resource */
name|smsatFreeIntIoResource
argument_list|(
name|smRoot
argument_list|,
name|pSatDevData
argument_list|,
name|satIntIo
argument_list|)
expr_stmt|;
return|return
name|SM_RC_DEVICE_BUSY
return|;
block|}
name|tdsmSingleThreadedLeave
argument_list|(
name|smRoot
argument_list|,
name|SM_EXTERNAL_IO_LOCK
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
comment|/* RLE */
comment|/* for internal SATA command only */
if|if
condition|(
name|satIOContext
operator|->
name|satOrgIOContext
operator|!=
name|agNULL
condition|)
block|{
comment|/* Initialize tiIORequest */
name|smIORequestBody
operator|->
name|smIORequest
operator|=
name|smIORequest
expr_stmt|;
if|if
condition|(
name|smIORequest
operator|==
name|agNULL
condition|)
block|{
name|SM_DBG1
argument_list|(
operator|(
literal|"smsataLLIOStart: 1 check!!!\n"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Initialize tiDevhandle */
name|smIORequestBody
operator|->
name|smDevHandle
operator|=
name|smDeviceHandle
expr_stmt|;
comment|/* Initializes Scatter Gather and ESGL */
name|status
operator|=
name|smsatIOPrepareSGL
argument_list|(
name|smRoot
argument_list|,
name|smIORequestBody
argument_list|,
operator|&
name|smScsiRequest
operator|->
name|smSgl1
argument_list|,
name|smScsiRequest
operator|->
name|sglVirtualAddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|SM_RC_SUCCESS
condition|)
block|{
name|SM_DBG1
argument_list|(
operator|(
literal|"smsataLLIOStart: can't get SGL!!!\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* free resource */
name|smsatFreeIntIoResource
argument_list|(
name|smRoot
argument_list|,
name|pSatDevData
argument_list|,
name|satIntIo
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
comment|/* Initialize LL Layer agIORequest */
name|agIORequest
operator|->
name|osData
operator|=
operator|(
name|void
operator|*
operator|)
name|smIORequestBody
expr_stmt|;
name|agIORequest
operator|->
name|sdkData
operator|=
name|agNULL
expr_stmt|;
comment|/* SA takes care of this */
name|smIORequestBody
operator|->
name|ioStarted
operator|=
name|agTRUE
expr_stmt|;
name|smIORequestBody
operator|->
name|ioCompleted
operator|=
name|agFALSE
expr_stmt|;
comment|/* assign tag value for SATA */
if|if
condition|(
operator|(
name|satIOContext
operator|->
name|reqType
operator|==
name|AGSA_SATA_PROTOCOL_FPDMA_WRITE
operator|)
operator|||
operator|(
name|satIOContext
operator|->
name|reqType
operator|==
name|AGSA_SATA_PROTOCOL_FPDMA_READ
operator|)
condition|)
block|{
if|if
condition|(
name|agFALSE
operator|==
name|smsatTagAlloc
argument_list|(
name|smRoot
argument_list|,
name|pSatDevData
argument_list|,
operator|&
name|satIOContext
operator|->
name|sataTag
argument_list|)
condition|)
block|{
name|SM_DBG1
argument_list|(
operator|(
literal|"smsataLLIOStart: No more NCQ tag!!!\n"
operator|)
argument_list|)
expr_stmt|;
name|smIORequestBody
operator|->
name|ioStarted
operator|=
name|agFALSE
expr_stmt|;
name|smIORequestBody
operator|->
name|ioCompleted
operator|=
name|agTRUE
expr_stmt|;
return|return
name|SM_RC_DEVICE_BUSY
return|;
block|}
name|SM_DBG3
argument_list|(
operator|(
literal|"smsataLLIOStart: ncq tag 0x%x\n"
operator|,
name|satIOContext
operator|->
name|sataTag
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|satIOContext
operator|->
name|sataTag
operator|=
literal|0xFF
expr_stmt|;
block|}
block|}
else|else
comment|/* AGSA_SATA_PROTOCOL_SRST_ASSERT or AGSA_SATA_PROTOCOL_SRST_DEASSERT            or SAT_CHECK_POWER_MODE as ABORT */
block|{
name|agsaSgl_t
modifier|*
name|agSgl
decl_stmt|;
comment|/* for internal SATA command only */
if|if
condition|(
name|satIOContext
operator|->
name|satOrgIOContext
operator|!=
name|agNULL
condition|)
block|{
comment|/* Initialize tiIORequest */
name|smIORequestBody
operator|->
name|smIORequest
operator|=
name|smIORequest
expr_stmt|;
if|if
condition|(
name|smIORequest
operator|==
name|agNULL
condition|)
block|{
name|SM_DBG1
argument_list|(
operator|(
literal|"smsataLLIOStart: 2 check!!!\n"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Initialize tiDevhandle */
name|smIORequestBody
operator|->
name|smDevHandle
operator|=
name|smDeviceHandle
expr_stmt|;
name|smIORequestBody
operator|->
name|IOType
operator|.
name|InitiatorRegIO
operator|.
name|expDataLength
operator|=
literal|0
expr_stmt|;
comment|/* SGL for SATA request */
name|agSgl
operator|=
operator|&
operator|(
name|smIORequestBody
operator|->
name|transport
operator|.
name|SATA
operator|.
name|agSATARequestBody
operator|.
name|agSgl
operator|)
expr_stmt|;
name|agSgl
operator|->
name|len
operator|=
literal|0
expr_stmt|;
name|agSgl
operator|->
name|sgUpper
operator|=
literal|0
expr_stmt|;
name|agSgl
operator|->
name|sgLower
operator|=
literal|0
expr_stmt|;
name|agSgl
operator|->
name|len
operator|=
literal|0
expr_stmt|;
name|SM_CLEAR_ESGL_EXTEND
argument_list|(
name|agSgl
operator|->
name|extReserved
argument_list|)
expr_stmt|;
comment|/* Initialize LL Layer agIORequest */
name|agIORequest
operator|=
operator|&
operator|(
name|smIORequestBody
operator|->
name|agIORequest
operator|)
expr_stmt|;
name|agIORequest
operator|->
name|osData
operator|=
operator|(
name|void
operator|*
operator|)
name|smIORequestBody
expr_stmt|;
name|agIORequest
operator|->
name|sdkData
operator|=
name|agNULL
expr_stmt|;
comment|/* SA takes care of this */
name|smIORequestBody
operator|->
name|ioStarted
operator|=
name|agTRUE
expr_stmt|;
name|smIORequestBody
operator|->
name|ioCompleted
operator|=
name|agFALSE
expr_stmt|;
comment|/* setting the data length */
name|agSATAReq
operator|->
name|dataLength
operator|=
literal|0
expr_stmt|;
block|}
name|smIORequestBody
operator|->
name|reTries
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|TD_INTERNAL_DEBUG
name|smhexdump
argument_list|(
literal|"smsataLLIOStart"
argument_list|,
operator|(
name|bit8
operator|*
operator|)
name|satIOContext
operator|->
name|pFis
argument_list|,
sizeof|sizeof
argument_list|(
name|agsaFisRegHostToDevice_t
argument_list|)
argument_list|)
expr_stmt|;
name|smhexdump
argument_list|(
literal|"smsataLLIOStart LL"
argument_list|,
operator|(
name|bit8
operator|*
operator|)
operator|&
name|agSATAReq
operator|->
name|fis
operator|.
name|fisRegHostToDev
argument_list|,
sizeof|sizeof
argument_list|(
name|agsaFisRegHostToDevice_t
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|SM_DBG6
argument_list|(
operator|(
literal|"smsataLLIOStart: agDevHandle %p\n"
operator|,
name|agDevHandle
operator|)
argument_list|)
expr_stmt|;
comment|/* to get better IO performance, rotate the OBQ number on main IO path */
if|if
condition|(
name|smScsiRequest
operator|==
name|agNULL
condition|)
block|{
name|nQNumber
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|smScsiRequest
operator|->
name|scsiCmnd
operator|.
name|cdb
index|[
literal|0
index|]
condition|)
block|{
case|case
name|SCSIOPC_READ_10
case|:
case|case
name|SCSIOPC_WRITE_10
case|:
case|case
name|SCSIOPC_READ_6
case|:
case|case
name|SCSIOPC_WRITE_6
case|:
case|case
name|SCSIOPC_READ_12
case|:
case|case
name|SCSIOPC_WRITE_12
case|:
case|case
name|SCSIOPC_READ_16
case|:
case|case
name|SCSIOPC_WRITE_16
case|:
name|nQNumber
operator|=
name|tdsmRotateQnumber
argument_list|(
name|smRoot
argument_list|,
name|smDeviceHandle
argument_list|)
expr_stmt|;
break|break;
default|default:
name|nQNumber
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
name|SM_DBG3
argument_list|(
operator|(
literal|"sataLLIOStart: Lock in\n"
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CCFLAG_OPTIMIZE_SAT_LOCK
if|if
condition|(
operator|(
name|satIOContext
operator|->
name|reqType
operator|==
name|AGSA_SATA_PROTOCOL_FPDMA_WRITE
operator|)
operator|||
operator|(
name|satIOContext
operator|->
name|reqType
operator|==
name|AGSA_SATA_PROTOCOL_FPDMA_READ
operator|)
condition|)
block|{
name|tdsmInterlockedIncrement
argument_list|(
name|smRoot
argument_list|,
operator|&
name|pSatDevData
operator|->
name|satPendingNCQIO
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tdsmInterlockedIncrement
argument_list|(
name|smRoot
argument_list|,
operator|&
name|pSatDevData
operator|->
name|satPendingNONNCQIO
argument_list|)
expr_stmt|;
block|}
name|tdsmInterlockedIncrement
argument_list|(
name|smRoot
argument_list|,
operator|&
name|pSatDevData
operator|->
name|satPendingIO
argument_list|)
expr_stmt|;
else|#
directive|else
name|tdsmSingleThreadedEnter
argument_list|(
name|smRoot
argument_list|,
name|SM_EXTERNAL_IO_LOCK
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|satIOContext
operator|->
name|reqType
operator|==
name|AGSA_SATA_PROTOCOL_FPDMA_WRITE
operator|)
operator|||
operator|(
name|satIOContext
operator|->
name|reqType
operator|==
name|AGSA_SATA_PROTOCOL_FPDMA_READ
operator|)
condition|)
block|{
name|pSatDevData
operator|->
name|satPendingNCQIO
operator|++
expr_stmt|;
block|}
else|else
block|{
name|pSatDevData
operator|->
name|satPendingNONNCQIO
operator|++
expr_stmt|;
block|}
name|pSatDevData
operator|->
name|satPendingIO
operator|++
expr_stmt|;
name|SMLIST_INIT_ELEMENT
argument_list|(
operator|&
name|satIOContext
operator|->
name|satIoContextLink
argument_list|)
expr_stmt|;
name|SMLIST_ENQUEUE_AT_TAIL
argument_list|(
operator|&
name|satIOContext
operator|->
name|satIoContextLink
argument_list|,
operator|&
name|pSatDevData
operator|->
name|satIoLinkList
argument_list|)
expr_stmt|;
name|tdsmSingleThreadedLeave
argument_list|(
name|smRoot
argument_list|,
name|SM_EXTERNAL_IO_LOCK
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* post SATA command to low level MPI */
name|status
operator|=
name|saSATAStart
argument_list|(
name|agRoot
argument_list|,
name|agIORequest
argument_list|,
name|nQNumber
argument_list|,
name|agDevHandle
argument_list|,
name|satIOContext
operator|->
name|reqType
argument_list|,
name|agSATAReq
argument_list|,
name|satIOContext
operator|->
name|sataTag
argument_list|,
name|smllSATACompleted
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|AGSA_RC_SUCCESS
condition|)
block|{
if|if
condition|(
name|status
operator|==
name|AGSA_RC_BUSY
condition|)
block|{
name|SM_DBG1
argument_list|(
operator|(
literal|"smsataLLIOStart: saSATAStart busy!!!\n"
operator|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|SM_RC_BUSY
expr_stmt|;
block|}
else|else
block|{
name|SM_DBG1
argument_list|(
operator|(
literal|"smsataLLIOStart: saSATAStart failed!!!\n"
operator|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|SM_RC_FAILURE
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|satIOContext
operator|->
name|reqType
operator|==
name|AGSA_SATA_PROTOCOL_FPDMA_WRITE
operator|)
operator|||
operator|(
name|satIOContext
operator|->
name|reqType
operator|==
name|AGSA_SATA_PROTOCOL_FPDMA_READ
operator|)
condition|)
block|{
name|smsatTagRelease
argument_list|(
name|smRoot
argument_list|,
name|pSatDevData
argument_list|,
name|satIOContext
operator|->
name|sataTag
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|CCFLAG_OPTIMIZE_SAT_LOCK
if|if
condition|(
operator|(
name|satIOContext
operator|->
name|reqType
operator|==
name|AGSA_SATA_PROTOCOL_FPDMA_WRITE
operator|)
operator|||
operator|(
name|satIOContext
operator|->
name|reqType
operator|==
name|AGSA_SATA_PROTOCOL_FPDMA_READ
operator|)
condition|)
block|{
name|tdsmInterlockedDecrement
argument_list|(
name|smRoot
argument_list|,
operator|&
name|oneDeviceData
operator|->
name|satPendingNCQIO
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tdsmInterlockedDecrement
argument_list|(
name|smRoot
argument_list|,
operator|&
name|oneDeviceData
operator|->
name|satPendingNONNCQIO
argument_list|)
expr_stmt|;
block|}
name|tdsmInterlockedDecrement
argument_list|(
name|smRoot
argument_list|,
operator|&
name|oneDeviceData
operator|->
name|satPendingIO
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
operator|(
name|satIOContext
operator|->
name|reqType
operator|==
name|AGSA_SATA_PROTOCOL_FPDMA_WRITE
operator|)
operator|||
operator|(
name|satIOContext
operator|->
name|reqType
operator|==
name|AGSA_SATA_PROTOCOL_FPDMA_READ
operator|)
condition|)
block|{
name|tdsmSingleThreadedEnter
argument_list|(
name|smRoot
argument_list|,
name|SM_EXTERNAL_IO_LOCK
argument_list|)
expr_stmt|;
name|oneDeviceData
operator|->
name|satPendingNCQIO
operator|--
expr_stmt|;
name|oneDeviceData
operator|->
name|satPendingIO
operator|--
expr_stmt|;
name|SMLIST_DEQUEUE_THIS
argument_list|(
operator|&
name|satIOContext
operator|->
name|satIoContextLink
argument_list|)
expr_stmt|;
name|tdsmSingleThreadedLeave
argument_list|(
name|smRoot
argument_list|,
name|SM_EXTERNAL_IO_LOCK
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tdsmSingleThreadedEnter
argument_list|(
name|smRoot
argument_list|,
name|SM_EXTERNAL_IO_LOCK
argument_list|)
expr_stmt|;
name|oneDeviceData
operator|->
name|satPendingNONNCQIO
operator|--
expr_stmt|;
name|oneDeviceData
operator|->
name|satPendingIO
operator|--
expr_stmt|;
name|SMLIST_DEQUEUE_THIS
argument_list|(
operator|&
name|satIOContext
operator|->
name|satIoContextLink
argument_list|)
expr_stmt|;
name|tdsmSingleThreadedLeave
argument_list|(
name|smRoot
argument_list|,
name|SM_EXTERNAL_IO_LOCK
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* CCFLAG_OPTIMIZE_SAT_LOCK */
comment|/* Free the ESGL pages associated with this I/O */
name|smIORequestBody
operator|->
name|ioStarted
operator|=
name|agFALSE
expr_stmt|;
name|smIORequestBody
operator|->
name|ioCompleted
operator|=
name|agTRUE
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
return|return
name|SM_RC_SUCCESS
return|;
block|}
end_function

begin_function
name|osGLOBAL
name|FORCEINLINE
name|bit32
name|smsatIOPrepareSGL
parameter_list|(
name|smRoot_t
modifier|*
name|smRoot
parameter_list|,
name|smIORequestBody_t
modifier|*
name|smIORequestBody
parameter_list|,
name|smSgl_t
modifier|*
name|smSgl1
parameter_list|,
name|void
modifier|*
name|sglVirtualAddr
parameter_list|)
block|{
name|agsaSgl_t
modifier|*
name|agSgl
decl_stmt|;
comment|/* Uppper should be zero-out */
name|SM_DBG5
argument_list|(
operator|(
literal|"smsatIOPrepareSGL: start\n"
operator|)
argument_list|)
expr_stmt|;
name|SM_DBG5
argument_list|(
operator|(
literal|"smsatIOPrepareSGL: smSgl1->upper %d smSgl1->lower %d smSgl1->len %d\n"
operator|,
name|smSgl1
operator|->
name|upper
operator|,
name|smSgl1
operator|->
name|lower
operator|,
name|smSgl1
operator|->
name|len
operator|)
argument_list|)
expr_stmt|;
name|SM_DBG5
argument_list|(
operator|(
literal|"smsatIOPrepareSGL: smSgl1->type %d\n"
operator|,
name|smSgl1
operator|->
name|type
operator|)
argument_list|)
expr_stmt|;
comment|/* SGL for SATA request */
name|agSgl
operator|=
operator|&
operator|(
name|smIORequestBody
operator|->
name|transport
operator|.
name|SATA
operator|.
name|agSATARequestBody
operator|.
name|agSgl
operator|)
expr_stmt|;
name|agSgl
operator|->
name|len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|smSgl1
operator|==
name|agNULL
condition|)
block|{
name|SM_DBG1
argument_list|(
operator|(
literal|"smsatIOPrepareSGL: Error smSgl1 is NULL!!!\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|tiError
return|;
block|}
if|if
condition|(
name|smIORequestBody
operator|->
name|IOType
operator|.
name|InitiatorRegIO
operator|.
name|expDataLength
operator|==
literal|0
condition|)
block|{
name|SM_DBG3
argument_list|(
operator|(
literal|"smsatIOPrepareSGL: expDataLength is 0\n"
operator|)
argument_list|)
expr_stmt|;
name|agSgl
operator|->
name|sgUpper
operator|=
literal|0
expr_stmt|;
name|agSgl
operator|->
name|sgLower
operator|=
literal|0
expr_stmt|;
name|agSgl
operator|->
name|len
operator|=
literal|0
expr_stmt|;
name|SM_CLEAR_ESGL_EXTEND
argument_list|(
name|agSgl
operator|->
name|extReserved
argument_list|)
expr_stmt|;
return|return
name|SM_RC_SUCCESS
return|;
block|}
name|agSgl
operator|->
name|sgUpper
operator|=
name|smSgl1
operator|->
name|upper
expr_stmt|;
name|agSgl
operator|->
name|sgLower
operator|=
name|smSgl1
operator|->
name|lower
expr_stmt|;
name|agSgl
operator|->
name|len
operator|=
name|smSgl1
operator|->
name|len
expr_stmt|;
name|agSgl
operator|->
name|extReserved
operator|=
name|smSgl1
operator|->
name|type
expr_stmt|;
return|return
name|SM_RC_SUCCESS
return|;
block|}
end_function

end_unit

