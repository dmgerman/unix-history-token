begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************************* *Copyright (c) 2014 PMC-Sierra, Inc.  All rights reserved.  * *Redistribution and use in source and binary forms, with or without modification, are permitted provided  *that the following conditions are met:  *1. Redistributions of source code must retain the above copyright notice, this list of conditions and the *following disclaimer.  *2. Redistributions in binary form must reproduce the above copyright notice,  *this list of conditions and the following disclaimer in the documentation and/or other materials provided *with the distribution.  * *THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR IMPLIED  *WARRANTIES,INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS *FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE *FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  *NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR  *BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  *LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  *SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE  ********************************************************************************/
end_comment

begin_comment
comment|/*******************************************************************************/
end_comment

begin_comment
comment|/*! \file sadisc.c  *  \brief The file implements the functions to do SAS/SATA discovery  */
end_comment

begin_comment
comment|/******************************************************************************/
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<dev/pms/config.h>
end_include

begin_include
include|#
directive|include
file|<dev/pms/RefTisa/sallsdk/spc/saglobal.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SA_ENABLE_TRACE_FUNCTIONS
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|siTraceFileID
end_ifdef

begin_undef
undef|#
directive|undef
name|siTraceFileID
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|siTraceFileID
value|'C'
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*! \brief Start/Abort SAS/SATA discovery  *  *  Start/Abort SAS/SATA discovery  *  *  \param agRoot         Handles for this instance of SAS/SATA hardware  *  \param agPortContext  Pointer to this instance of port context  *  \param type           Specifies the type(s) of discovery operation to start or cancel  *  \param option         Specified the discovery option  *  *  \return If discovery is started/aborted successfully  *          - \e AGSA_RC_SUCCESS discovery is started/aborted successfully  *          - \e AGSA_RC_FAILURE discovery is not started/aborted successfully  *  */
end_comment

begin_comment
comment|/*******************************************************************************/
end_comment

begin_function
name|GLOBAL
name|bit32
name|saDiscover
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|agsaPortContext_t
modifier|*
name|agPortContext
parameter_list|,
name|bit32
name|type
parameter_list|,
name|bit32
name|option
parameter_list|)
block|{
comment|/* Currently not supported */
return|return
name|AGSA_RC_FAILURE
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*! \brief Function for target to remove stale initiator device handle  *  *  function is called to ask the LL layer to remove all LL layer and SPC firmware  *  internal resources associated with a device handle  *  *  \param agRoot       Handles for this instance of SAS/SATA hardware  *  \param agDevHandle  Handle of the device that this I/O request will be made on  *  *  \return If the device handle is removed successfully  *          - \e AGSA_RC_SUCCESS the device handle is removed successfully  *          - \e AGSA_RC_BUSY the device is busy, cannot be removed now  *  */
end_comment

begin_comment
comment|/*******************************************************************************/
end_comment

begin_function
name|GLOBAL
name|bit32
name|saDeregisterDeviceHandle
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|agsaContext_t
modifier|*
name|agContext
parameter_list|,
name|agsaDevHandle_t
modifier|*
name|agDevHandle
parameter_list|,
name|bit32
name|queueNum
parameter_list|)
block|{
name|agsaLLRoot_t
modifier|*
name|saRoot
init|=
operator|(
name|agsaLLRoot_t
operator|*
operator|)
operator|(
name|agRoot
operator|->
name|sdkData
operator|)
decl_stmt|;
name|agsaDeviceDesc_t
modifier|*
name|pDevice
decl_stmt|;
name|agsaPort_t
modifier|*
name|pPort
decl_stmt|;
name|bit32
name|ret
init|=
name|AGSA_RC_SUCCESS
decl_stmt|;
name|bit32
name|deviceid
decl_stmt|,
name|portid
decl_stmt|;
name|bit32
name|deviceIdx
decl_stmt|;
name|OS_ASSERT
argument_list|(
name|agDevHandle
operator|!=
name|agNULL
argument_list|,
literal|"saDeregisterDeviceHandle agDevHandle is NULL"
argument_list|)
expr_stmt|;
name|smTraceFuncEnter
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|"za"
argument_list|)
expr_stmt|;
if|if
condition|(
name|agNULL
operator|==
name|agDevHandle
condition|)
block|{
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'a'
argument_list|,
literal|"za"
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_FAILURE
return|;
block|}
name|pDevice
operator|=
operator|(
name|agsaDeviceDesc_t
operator|*
operator|)
operator|(
name|agDevHandle
operator|->
name|sdkData
operator|)
expr_stmt|;
name|OS_ASSERT
argument_list|(
name|pDevice
operator|!=
name|agNULL
argument_list|,
literal|"saDeregisterDeviceHandle pDevice is NULL"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pDevice
operator|==
name|agNULL
condition|)
block|{
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'b'
argument_list|,
literal|"za"
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_FAILURE
return|;
block|}
comment|/* find device id */
name|deviceid
operator|=
name|pDevice
operator|->
name|DeviceMapIndex
expr_stmt|;
name|deviceIdx
operator|=
name|deviceid
operator|&
name|DEVICE_ID_BITS
expr_stmt|;
name|OS_ASSERT
argument_list|(
name|deviceIdx
operator|<
name|MAX_IO_DEVICE_ENTRIES
argument_list|,
literal|"deviceIdx MAX_IO_DEVICE_ENTRIES"
argument_list|)
expr_stmt|;
name|pPort
operator|=
name|pDevice
operator|->
name|pPort
expr_stmt|;
comment|/* find port id */
name|portid
operator|=
name|pPort
operator|->
name|portId
expr_stmt|;
name|SA_DBG3
argument_list|(
operator|(
literal|"saDeregisterDeviceHandle: start DeviceHandle %p\n"
operator|,
name|agDevHandle
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saDeregisterDeviceHandle: deviceId 0x%x Device Context %p\n"
operator|,
name|deviceid
operator|,
name|pDevice
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|deviceid
operator|!=
name|saRoot
operator|->
name|DeviceMap
index|[
name|deviceIdx
index|]
operator|.
name|DeviceIdFromFW
operator|)
operator|||
operator|(
name|pDevice
operator|!=
name|saRoot
operator|->
name|DeviceMap
index|[
name|deviceIdx
index|]
operator|.
name|DeviceHandle
operator|)
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"saDeregisterDeviceHandle: Not match failure\n"
operator|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|AGSA_RC_FAILURE
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'c'
argument_list|,
literal|"za"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
comment|/* Build IOMB and send it to SPC */
name|ret
operator|=
name|mpiDeregDevHandleCmd
argument_list|(
name|agRoot
argument_list|,
name|agContext
argument_list|,
name|pDevice
argument_list|,
name|deviceid
argument_list|,
name|portid
argument_list|,
name|queueNum
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'d'
argument_list|,
literal|"za"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*! \brief Function for target to remove stale initiator device handle  *  *  function is called to ask the LL layer to remove all LL layer internal resources  *  associated with a device handle  *  *  \param agRoot       Handles for this instance of SAS/SATA hardware  *  \param agDevHandle  Handle of the device that this I/O request will be made on  *  *  \return If the device handle is removed successfully  *          - \e AGSA_RC_SUCCESS the device handle is removed successfully  *          - \e AGSA_RC_BUSY the device is busy, cannot be removed now  *  */
end_comment

begin_comment
comment|/*******************************************************************************/
end_comment

begin_function
name|GLOBAL
name|bit32
name|siRemoveDevHandle
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|agsaDevHandle_t
modifier|*
name|agDevHandle
parameter_list|)
block|{
name|agsaDeviceDesc_t
modifier|*
name|pDevice
init|=
operator|(
name|agsaDeviceDesc_t
operator|*
operator|)
operator|(
name|agDevHandle
operator|->
name|sdkData
operator|)
decl_stmt|;
name|agsaPort_t
modifier|*
name|pPort
decl_stmt|;
name|bit32
name|ret
init|=
name|AGSA_RC_SUCCESS
decl_stmt|;
name|OS_ASSERT
argument_list|(
name|pDevice
operator|!=
name|agNULL
argument_list|,
literal|"siRemoveDevHandle is NULL"
argument_list|)
expr_stmt|;
name|smTraceFuncEnter
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|"zb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pDevice
operator|==
name|agNULL
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"siRemoveDevHandle: pDevice is NULL \n"
operator|)
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'a'
argument_list|,
literal|"zb"
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_FAILURE
return|;
block|}
comment|/* If it's to remove an initiator device handle */
if|if
condition|(
operator|&
operator|(
name|pDevice
operator|->
name|initiatorDevHandle
operator|)
operator|==
name|agDevHandle
condition|)
block|{
operator|(
name|pDevice
operator|->
name|initiatorDevHandle
operator|)
operator|.
name|sdkData
operator|=
name|agNULL
expr_stmt|;
block|}
comment|/* If it's to remove an target device handle */
elseif|else
if|if
condition|(
operator|&
operator|(
name|pDevice
operator|->
name|targetDevHandle
operator|)
operator|==
name|agDevHandle
condition|)
block|{
operator|(
name|pDevice
operator|->
name|targetDevHandle
operator|)
operator|.
name|sdkData
operator|=
name|agNULL
expr_stmt|;
block|}
else|else
block|{
name|SA_ASSERT
argument_list|(
name|agFALSE
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
comment|/* remove the device descriptor if it doesn't have either initiator handle and target handle */
if|if
condition|(
operator|(
name|agNULL
operator|==
operator|(
name|pDevice
operator|->
name|initiatorDevHandle
operator|)
operator|.
name|sdkData
operator|)
operator|&&
operator|(
name|agNULL
operator|==
operator|(
name|pDevice
operator|->
name|targetDevHandle
operator|)
operator|.
name|sdkData
operator|)
condition|)
block|{
comment|/* Find the port of the device */
name|pPort
operator|=
name|pDevice
operator|->
name|pPort
expr_stmt|;
comment|/* remove the device descriptor free discover list */
switch|switch
condition|(
name|pDevice
operator|->
name|deviceType
condition|)
block|{
case|case
name|STP_DEVICE
case|:
comment|/* fall through */
case|case
name|SSP_SMP_DEVICE
case|:
case|case
name|DIRECT_SATA_DEVICE
case|:
block|{
name|SA_DBG3
argument_list|(
operator|(
literal|"siRemoveDevHandle: remove device context %p\n"
operator|,
name|pDevice
operator|)
argument_list|)
expr_stmt|;
name|siPortDeviceRemove
argument_list|(
name|agRoot
argument_list|,
name|pPort
argument_list|,
name|pDevice
argument_list|,
name|agTRUE
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"siRemoveDevHandle: switch. Not calling siPortDeviceRemove %d\n"
operator|,
name|pDevice
operator|->
name|deviceType
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
else|else
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"siRemoveDevHandle: else. Not caling siPortDeviceRemove\n"
operator|)
argument_list|)
expr_stmt|;
block|}
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'b'
argument_list|,
literal|"zb"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*! \brief Get Device Handles from a specific local port  *  *  Get a Device Handles  *  *  \param agRoot         Handles for this instance of SAS/SATA hardware  *  \param agsaContext    Pointer to this API context  *  \param agPortContext  Pointer to this instance of port context  *  \param flags          Device flags  *  \param agDev[]        Pointer of array of device handles  *  \param MaxDevs        Specified Maximum number of Device Handles  *  *  \return If GetDeviceHandles is successfully or failure  *          - \e AGSA_RC_SUCCESS GetDeviceHandles is successfully  *          - \e AGSA_RC_FAILURE GetDeviceHandles is not successfully  *  */
end_comment

begin_comment
comment|/*******************************************************************************/
end_comment

begin_function
name|GLOBAL
name|bit32
name|saGetDeviceHandles
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|agsaContext_t
modifier|*
name|agContext
parameter_list|,
name|bit32
name|queueNum
parameter_list|,
name|agsaPortContext_t
modifier|*
name|agPortContext
parameter_list|,
name|bit32
name|flags
parameter_list|,
name|agsaDevHandle_t
modifier|*
name|agDev
index|[]
parameter_list|,
name|bit32
name|skipCount
parameter_list|,
name|bit32
name|MaxDevs
parameter_list|)
block|{
name|agsaLLRoot_t
modifier|*
name|saRoot
init|=
operator|(
name|agsaLLRoot_t
operator|*
operator|)
operator|(
name|agRoot
operator|->
name|sdkData
operator|)
decl_stmt|;
name|agsaPort_t
modifier|*
name|pPort
init|=
operator|(
name|agsaPort_t
operator|*
operator|)
operator|(
name|agPortContext
operator|->
name|sdkData
operator|)
decl_stmt|;
name|bit32
name|portIndex
decl_stmt|,
name|i
decl_stmt|;
name|bit32
name|ret
init|=
name|AGSA_RC_SUCCESS
decl_stmt|;
name|OS_ASSERT
argument_list|(
name|pPort
operator|!=
name|agNULL
argument_list|,
literal|"saGetDeviceHandles is NULL"
argument_list|)
expr_stmt|;
name|smTraceFuncEnter
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|"zc"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pPort
operator|==
name|agNULL
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetDeviceHandles: pPort is NULL \n"
operator|)
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'a'
argument_list|,
literal|"zc"
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_FAILURE
return|;
block|}
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetDeviceHandles: start portId %d\n"
operator|,
name|pPort
operator|->
name|portId
operator|)
argument_list|)
expr_stmt|;
comment|/* save the device handles arrary pointer */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MaxDevs
condition|;
name|i
operator|++
control|)
block|{
name|saRoot
operator|->
name|DeviceHandle
index|[
name|i
index|]
operator|=
name|agDev
index|[
name|i
index|]
expr_stmt|;
block|}
comment|/* send GET_DEVICE_HANDLE IOMB to SPC */
name|portIndex
operator|=
name|pPort
operator|->
name|portId
expr_stmt|;
name|mpiGetDeviceHandleCmd
argument_list|(
name|agRoot
argument_list|,
name|agContext
argument_list|,
name|portIndex
argument_list|,
name|flags
argument_list|,
name|MaxDevs
argument_list|,
name|queueNum
argument_list|,
name|skipCount
argument_list|)
expr_stmt|;
comment|/* return */
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'b'
argument_list|,
literal|"zc"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*! \brief Register New Device from a specific local port  *  *  Register New Device API  *  *  \param agRoot         Handles for this instance of SAS/SATA hardware  *  \param agContext      Pointer to this API context  *  \param agDeviceInfo   Pointer to this instance of device info  *  \param agPortContext  Pointer to this instance of port context  *  *  \return If discovery is started/aborted successfully  *          - \e AGSA_RC_SUCCESS discovery is started/aborted successfully  *          - \e AGSA_RC_FAILURE discovery is not started/aborted successfully  *  */
end_comment

begin_comment
comment|/*******************************************************************************/
end_comment

begin_function
name|GLOBAL
name|bit32
name|saRegisterNewDevice
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|agsaContext_t
modifier|*
name|agContext
parameter_list|,
name|bit32
name|queueNum
parameter_list|,
name|agsaDeviceInfo_t
modifier|*
name|agDeviceInfo
parameter_list|,
name|agsaPortContext_t
modifier|*
name|agPortContext
parameter_list|,
name|bit16
name|hostAssignedDeviceId
parameter_list|)
block|{
name|bit32
name|ret
init|=
name|AGSA_RC_SUCCESS
decl_stmt|;
name|agsaRegDevCmd_t
name|payload
decl_stmt|;
name|agsaLLRoot_t
modifier|*
name|saRoot
init|=
operator|(
name|agsaLLRoot_t
operator|*
operator|)
operator|(
name|agRoot
operator|->
name|sdkData
operator|)
decl_stmt|;
name|agsaIORequestDesc_t
modifier|*
name|pRequest
decl_stmt|;
name|agsaPort_t
modifier|*
name|pPort
init|=
operator|(
name|agsaPort_t
operator|*
operator|)
operator|(
name|agPortContext
operator|->
name|sdkData
operator|)
decl_stmt|;
name|agsaSASIdentify_t
name|remoteIdentify
decl_stmt|;
name|bit32
name|i
decl_stmt|,
name|phyId
decl_stmt|,
name|sDTypeRate
decl_stmt|;
name|agsaDeviceDesc_t
modifier|*
name|pDevice
init|=
name|agNULL
decl_stmt|;
name|OS_ASSERT
argument_list|(
name|pPort
operator|!=
name|agNULL
argument_list|,
literal|"saRegisterNewDevice is NULL"
argument_list|)
expr_stmt|;
name|OS_ASSERT
argument_list|(
name|saRoot
operator|!=
name|agNULL
argument_list|,
literal|"saRoot is NULL"
argument_list|)
expr_stmt|;
name|smTraceFuncEnter
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|"zd"
argument_list|)
expr_stmt|;
if|if
condition|(
name|saRoot
operator|==
name|agNULL
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"saRegisterNewDevice: saRoot == agNULL\n"
operator|)
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'a'
argument_list|,
literal|"zd"
argument_list|)
expr_stmt|;
return|return
operator|(
name|AGSA_RC_FAILURE
operator|)
return|;
block|}
if|if
condition|(
name|pPort
operator|==
name|agNULL
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"saRegisterNewDevice: pPort is NULL \n"
operator|)
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'b'
argument_list|,
literal|"zd"
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_FAILURE
return|;
block|}
name|SA_DBG2
argument_list|(
operator|(
literal|"saRegisterNewDevice: start portId %d Port Context %p\n"
operator|,
name|pPort
operator|->
name|portId
operator|,
name|agPortContext
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG2
argument_list|(
operator|(
literal|"saRegisterNewDevice: smpTimeout 0x%x\n"
operator|,
name|agDeviceInfo
operator|->
name|smpTimeout
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG2
argument_list|(
operator|(
literal|"saRegisterNewDevice: it_NexusTimeout 0x%x\n"
operator|,
name|agDeviceInfo
operator|->
name|it_NexusTimeout
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG2
argument_list|(
operator|(
literal|"saRegisterNewDevice: firstBurstSize 0x%x\n"
operator|,
name|agDeviceInfo
operator|->
name|firstBurstSize
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG2
argument_list|(
operator|(
literal|"saRegisterNewDevice: devType_S_Rate 0x%x\n"
operator|,
name|agDeviceInfo
operator|->
name|devType_S_Rate
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG2
argument_list|(
operator|(
literal|"saRegisterNewDevice: flag 0x%x\n"
operator|,
name|agDeviceInfo
operator|->
name|flag
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG2
argument_list|(
operator|(
literal|"saRegisterNewDevice: hostAssignedDeviceId  0x%x\n"
operator|,
name|hostAssignedDeviceId
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG2
argument_list|(
operator|(
literal|"saRegisterNewDevice: Addr 0x%02x%02x%02x%02x 0x%02x%02x%02x%02x\n"
operator|,
name|agDeviceInfo
operator|->
name|sasAddressHi
index|[
literal|0
index|]
operator|,
name|agDeviceInfo
operator|->
name|sasAddressHi
index|[
literal|1
index|]
operator|,
name|agDeviceInfo
operator|->
name|sasAddressHi
index|[
literal|2
index|]
operator|,
name|agDeviceInfo
operator|->
name|sasAddressHi
index|[
literal|3
index|]
operator|,
name|agDeviceInfo
operator|->
name|sasAddressLo
index|[
literal|0
index|]
operator|,
name|agDeviceInfo
operator|->
name|sasAddressLo
index|[
literal|1
index|]
operator|,
name|agDeviceInfo
operator|->
name|sasAddressLo
index|[
literal|2
index|]
operator|,
name|agDeviceInfo
operator|->
name|sasAddressLo
index|[
literal|3
index|]
operator|)
argument_list|)
expr_stmt|;
name|agDeviceInfo
operator|->
name|devType_S_Rate
operator|&=
name|DEV_LINK_RATE
expr_stmt|;
comment|/*     Using agsaDeviceInfo_t, fill in only sas address and device type     of identify address frame   */
name|si_memset
argument_list|(
operator|&
name|remoteIdentify
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|agsaSASIdentify_t
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|remoteIdentify
operator|.
name|sasAddressHi
index|[
name|i
index|]
operator|=
name|agDeviceInfo
operator|->
name|sasAddressHi
index|[
name|i
index|]
expr_stmt|;
name|remoteIdentify
operator|.
name|sasAddressLo
index|[
name|i
index|]
operator|=
name|agDeviceInfo
operator|->
name|sasAddressLo
index|[
name|i
index|]
expr_stmt|;
block|}
name|remoteIdentify
operator|.
name|deviceType_addressFrameType
operator|=
call|(
name|bit8
call|)
argument_list|(
name|agDeviceInfo
operator|->
name|devType_S_Rate
operator|&
literal|0xC0
argument_list|)
expr_stmt|;
comment|/* Get request from free IORequests */
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|pRequest
operator|=
operator|(
name|agsaIORequestDesc_t
operator|*
operator|)
name|saLlistIOGetHead
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|)
expr_stmt|;
comment|/* If no LL Control request entry available */
if|if
condition|(
name|agNULL
operator|==
name|pRequest
condition|)
block|{
name|pRequest
operator|=
operator|(
name|agsaIORequestDesc_t
operator|*
operator|)
name|saLlistIOGetHead
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeReservedRequests
operator|)
argument_list|)
expr_stmt|;
comment|/**/
if|if
condition|(
name|agNULL
operator|!=
name|pRequest
condition|)
block|{
name|saLlistIORemove
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeReservedRequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saRegisterNewDevice, using saRoot->freeReservedRequests\n"
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"saRegisterNewDevice, No request from free list Not using saRoot->freeReservedRequests\n"
operator|)
argument_list|)
expr_stmt|;
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'c'
argument_list|,
literal|"zd"
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_BUSY
return|;
block|}
block|}
else|else
block|{
comment|/* If LL Control request entry avaliable */
name|saLlistIORemove
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
block|}
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|Tag
operator|=
name|pRequest
operator|->
name|HTag
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|IORequest
operator|=
operator|(
name|void
operator|*
operator|)
name|pRequest
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|agContext
operator|=
name|agContext
expr_stmt|;
name|pRequest
operator|->
name|valid
operator|=
name|agTRUE
expr_stmt|;
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
comment|/* checking bit5 for SATA direct device */
if|if
condition|(
operator|!
operator|(
name|agDeviceInfo
operator|->
name|devType_S_Rate
operator|&
literal|0x20
operator|)
condition|)
block|{
comment|/* SAS device */
comment|/* Add SAS device to the device list */
name|pDevice
operator|=
name|siPortSASDeviceAdd
argument_list|(
name|agRoot
argument_list|,
name|pPort
argument_list|,
name|remoteIdentify
argument_list|,
name|agFALSE
argument_list|,
name|agDeviceInfo
operator|->
name|smpTimeout
argument_list|,
name|agDeviceInfo
operator|->
name|it_NexusTimeout
argument_list|,
name|agDeviceInfo
operator|->
name|firstBurstSize
argument_list|,
name|agDeviceInfo
operator|->
name|devType_S_Rate
argument_list|,
operator|(
name|agDeviceInfo
operator|->
name|flag
operator|&
name|DEV_INFO_MASK
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* SATA device */
comment|/* Add SATA device to the device list */
name|pDevice
operator|=
name|siPortSATADeviceAdd
argument_list|(
name|agRoot
argument_list|,
name|pPort
argument_list|,
name|agNULL
argument_list|,
name|agNULL
argument_list|,
comment|/* no signature */
name|agFALSE
argument_list|,
literal|0
argument_list|,
name|agDeviceInfo
operator|->
name|smpTimeout
argument_list|,
name|agDeviceInfo
operator|->
name|it_NexusTimeout
argument_list|,
name|agDeviceInfo
operator|->
name|firstBurstSize
argument_list|,
name|agDeviceInfo
operator|->
name|devType_S_Rate
argument_list|,
operator|(
name|agDeviceInfo
operator|->
name|flag
operator|&
name|DEV_INFO_MASK
operator|)
argument_list|)
expr_stmt|;
block|}
name|SA_DBG1
argument_list|(
operator|(
literal|"saRegisterNewDevice: Device Context %p, TypeRate 0x%x\n"
operator|,
name|pDevice
operator|,
name|agDeviceInfo
operator|->
name|devType_S_Rate
operator|)
argument_list|)
expr_stmt|;
name|pRequest
operator|->
name|pDevice
operator|=
name|pDevice
expr_stmt|;
comment|/* adjust the flag bit to build the IOMB; use only bit0 and 1 */
name|sDTypeRate
operator|=
name|agDeviceInfo
operator|->
name|devType_S_Rate
operator|<<
name|SHIFT24
expr_stmt|;
name|sDTypeRate
operator||=
operator|(
name|agDeviceInfo
operator|->
name|flag
operator|&
literal|0x01
operator|)
expr_stmt|;
comment|/* set AWT flag */
name|sDTypeRate
operator||=
operator|(
name|agDeviceInfo
operator|->
name|flag
operator|&
literal|0x02
operator|)
operator|<<
literal|1
expr_stmt|;
comment|/* If the host assigned device ID is used, then set the HA bit. */
if|if
condition|(
name|hostAssignedDeviceId
operator|!=
literal|0
condition|)
block|{
name|sDTypeRate
operator||=
literal|2
expr_stmt|;
name|SA_DBG3
argument_list|(
operator|(
literal|"saRegisterNewDevice:hostAssignedDeviceId 0x%x sDTypeRate 0x%x\n"
operator|,
name|hostAssignedDeviceId
operator|,
name|sDTypeRate
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* Add the MCN field */
name|sDTypeRate
operator||=
operator|(
operator|(
name|agDeviceInfo
operator|->
name|flag
operator|>>
name|DEV_INFO_MCN_SHIFT
operator|)
operator|&
literal|0xf
operator|)
operator|<<
literal|4
expr_stmt|;
comment|/* Add the IR field */
name|sDTypeRate
operator||=
operator|(
operator|(
name|agDeviceInfo
operator|->
name|flag
operator|>>
name|DEV_INFO_IR_SHIFT
operator|)
operator|&
literal|0x1
operator|)
operator|<<
literal|3
expr_stmt|;
comment|/* Add the ATAPI protocol flag */
name|sDTypeRate
operator||=
operator|(
operator|(
name|agDeviceInfo
operator|->
name|flag
operator|&
name|ATAPI_DEVICE_FLAG
operator|)
operator|<<
name|SHIFT9
operator|)
expr_stmt|;
comment|/* Add the AWT  flag */
name|sDTypeRate
operator||=
operator|(
name|agDeviceInfo
operator|->
name|flag
operator|&
name|AWT_DEVICE_FLAG
operator|)
condition|?
operator|(
literal|1
operator|<<
name|SHIFT2
operator|)
else|:
literal|0
expr_stmt|;
comment|/* Add the XFER_READY flag  */
name|sDTypeRate
operator||=
operator|(
name|agDeviceInfo
operator|->
name|flag
operator|&
name|XFER_RDY_PRIORTY_DEVICE_FLAG
operator|)
condition|?
operator|(
literal|1
operator|<<
name|SHIFT31
operator|)
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|agDeviceInfo
operator|->
name|flag
operator|&
name|XFER_RDY_PRIORTY_DEVICE_FLAG
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"saRegisterNewDevice: sflag XFER_RDY_PRIORTY_DEVICE_FLAG sDTypeRate 0x%x\n"
operator|,
name|sDTypeRate
operator|)
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|CCFLAG_FORCE_AWT_ON
name|sDTypeRate
operator||=
operator|(
literal|1
operator|<<
name|SHIFT2
operator|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saRegisterNewDevice: Force AWT_DEVICE_FLAG sDTypeRate 0x%x\n"
operator|,
name|sDTypeRate
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* CCFLAG_FORCE_AWT_ON */
comment|/* create payload for IOMB */
name|si_memset
argument_list|(
operator|&
name|payload
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|agsaRegDevCmd_t
argument_list|)
argument_list|)
expr_stmt|;
name|SA_DBG2
argument_list|(
operator|(
literal|"saRegisterNewDevice,flag 0x%08X\n"
operator|,
name|agDeviceInfo
operator|->
name|flag
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|agDeviceInfo
operator|->
name|devType_S_Rate
operator|&
literal|0x30
operator|)
operator|==
literal|0x20
condition|)
block|{
if|if
condition|(
name|smIS_SPC
argument_list|(
name|agRoot
argument_list|)
condition|)
block|{
comment|/* direct SATA device */
name|phyId
operator|=
operator|(
name|agDeviceInfo
operator|->
name|flag
operator|&
literal|0xF0
operator|)
expr_stmt|;
block|}
else|else
block|{
name|phyId
operator|=
operator|(
name|agDeviceInfo
operator|->
name|flag
operator|&
literal|0xF0
operator|)
operator|<<
name|SHIFT4
expr_stmt|;
block|}
block|}
else|else
block|{
name|phyId
operator|=
literal|0
expr_stmt|;
block|}
name|smTrace
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|"QQ"
argument_list|,
name|phyId
argument_list|)
expr_stmt|;
comment|/* TP:QQ phyId */
name|smTrace
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|"QR"
argument_list|,
name|pPort
operator|->
name|portId
argument_list|)
expr_stmt|;
comment|/* TP:QR portId */
name|smTrace
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|"QS"
argument_list|,
name|sDTypeRate
argument_list|)
expr_stmt|;
comment|/* TP:QS sDTypeRate */
name|smTrace
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|"QT"
argument_list|,
name|agDeviceInfo
operator|->
name|it_NexusTimeout
argument_list|)
expr_stmt|;
comment|/* TP:QT agDeviceInfo->it_NexusTimeout */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaRegDevCmd_t
argument_list|,
name|phyIdportId
argument_list|)
argument_list|,
call|(
name|bit32
call|)
argument_list|(
name|pPort
operator|->
name|portId
operator|&
name|PORTID_MASK
argument_list|)
operator||
name|phyId
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaRegDevCmd_t
argument_list|,
name|dTypeLRateAwtHa
argument_list|)
argument_list|,
name|sDTypeRate
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaRegDevCmd_t
argument_list|,
name|ITNexusTimeOut
argument_list|)
argument_list|,
operator|(
name|agDeviceInfo
operator|->
name|it_NexusTimeout
operator|)
argument_list|)
expr_stmt|;
name|smTrace
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|"QT"
argument_list|,
call|(
name|bit32
call|)
argument_list|(
name|pPort
operator|->
name|portId
operator|&
name|PORTID_MASK
argument_list|)
operator||
name|phyId
argument_list|)
expr_stmt|;
comment|/* TP:QT phyIdportId */
comment|/* no conversion is needed since SAS address is in BE format */
name|payload
operator|.
name|sasAddrHi
operator|=
operator|*
operator|(
name|bit32
operator|*
operator|)
name|agDeviceInfo
operator|->
name|sasAddressHi
expr_stmt|;
name|payload
operator|.
name|sasAddrLo
operator|=
operator|*
operator|(
name|bit32
operator|*
operator|)
name|agDeviceInfo
operator|->
name|sasAddressLo
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaRegDevCmd_t
argument_list|,
name|tag
argument_list|)
argument_list|,
name|pRequest
operator|->
name|HTag
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaRegDevCmd_t
argument_list|,
name|DeviceId
argument_list|)
argument_list|,
operator|(
operator|(
name|bit32
operator|)
name|hostAssignedDeviceId
operator|)
operator|<<
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|smIS_SPC
argument_list|(
name|agRoot
argument_list|)
condition|)
block|{
name|ret
operator|=
name|mpiBuildCmd
argument_list|(
name|agRoot
argument_list|,
operator|(
name|bit32
operator|*
operator|)
operator|&
name|payload
argument_list|,
name|MPI_CATEGORY_SAS_SATA
argument_list|,
name|OPC_INB_SPC_REG_DEV
argument_list|,
name|IOMB_SIZE64
argument_list|,
name|queueNum
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|mpiBuildCmd
argument_list|(
name|agRoot
argument_list|,
operator|(
name|bit32
operator|*
operator|)
operator|&
name|payload
argument_list|,
name|MPI_CATEGORY_SAS_SATA
argument_list|,
name|OPC_INB_REG_DEV
argument_list|,
name|IOMB_SIZE64
argument_list|,
name|queueNum
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|AGSA_RC_SUCCESS
operator|!=
name|ret
condition|)
block|{
comment|/* return the request to free pool */
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
comment|/* remove the request from IOMap */
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|Tag
operator|=
name|MARK_OFF
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|IORequest
operator|=
name|agNULL
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|agContext
operator|=
name|agNULL
expr_stmt|;
name|pRequest
operator|->
name|valid
operator|=
name|agFALSE
expr_stmt|;
if|if
condition|(
name|saLlistIOGetCount
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeReservedRequests
operator|)
argument_list|)
operator|<
name|SA_RESERVED_REQUEST_COUNT
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"saRegisterNewDevice: saving pRequest (%p) for later use\n"
operator|,
name|pRequest
operator|)
argument_list|)
expr_stmt|;
name|saLlistIOAdd
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeReservedRequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* return the request to free pool */
name|saLlistIOAdd
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
block|}
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saRegisterNewDevice, sending IOMB failed\n"
operator|)
argument_list|)
expr_stmt|;
block|}
name|SA_DBG3
argument_list|(
operator|(
literal|"saRegisterNewDevice: end\n"
operator|)
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'d'
argument_list|,
literal|"zd"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*! \brief Register a callback for a specific event  *  *  Register a callback for a Event API  *  *  \param agRoot          Handles for this instance of SAS/SATA hardware  *  \param eventSourceType Event Type  *  \param callbackPtr     Function pointer to OS layer  *  *  \return  *          - \e AGSA_RC_SUCCESS  *          - \e AGSA_RC_FAILURE  *  */
end_comment

begin_comment
comment|/*******************************************************************************/
end_comment

begin_function
name|GLOBAL
name|bit32
name|saRegisterEventCallback
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|bit32
name|eventSourceType
parameter_list|,
name|ossaGenericCB_t
name|callbackPtr
parameter_list|)
block|{
name|agsaLLRoot_t
modifier|*
name|saRoot
init|=
operator|(
name|agsaLLRoot_t
operator|*
operator|)
operator|(
name|agRoot
operator|->
name|sdkData
operator|)
decl_stmt|;
name|bit32
name|ret
init|=
name|AGSA_RC_FAILURE
decl_stmt|;
name|SA_DBG3
argument_list|(
operator|(
literal|"saRegisterEventCallback: start\n"
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|eventSourceType
condition|)
block|{
case|case
name|OSSA_EVENT_SOURCE_DEVICE_HANDLE_ADDED
case|:
name|saRoot
operator|->
name|DeviceRegistrationCB
operator|=
operator|(
name|ossaDeviceRegistrationCB_t
operator|)
name|callbackPtr
expr_stmt|;
name|ret
operator|=
name|AGSA_RC_SUCCESS
expr_stmt|;
break|break;
case|case
name|OSSA_EVENT_SOURCE_DEVICE_HANDLE_REMOVED
case|:
name|saRoot
operator|->
name|DeviceDeregistrationCB
operator|=
operator|(
name|ossaDeregisterDeviceHandleCB_t
operator|)
name|callbackPtr
expr_stmt|;
name|ret
operator|=
name|AGSA_RC_SUCCESS
expr_stmt|;
break|break;
default|default:
name|SA_DBG1
argument_list|(
operator|(
literal|"saRegisterEventCallback: not allowed case %d\n"
operator|,
name|eventSourceType
operator|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|AGSA_RC_FAILURE
expr_stmt|;
break|break;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*! \brief Get Device Information  *  *  Get SAS/SATA device information API  *  *  \param agRoot          Handles for this instance of SAS/SATA hardware  *  \param option          device general information or extended information  *  \param agDevHandle     Pointer of device handle  *  *  \return  *          - \e AGSA_RC_SUCCESS  *          - \e AGSA_RC_FAILURE  *  */
end_comment

begin_comment
comment|/*******************************************************************************/
end_comment

begin_function
name|GLOBAL
name|bit32
name|saGetDeviceInfo
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|agsaContext_t
modifier|*
name|agContext
parameter_list|,
name|bit32
name|option
parameter_list|,
name|bit32
name|queueNum
parameter_list|,
name|agsaDevHandle_t
modifier|*
name|agDevHandle
parameter_list|)
block|{
name|agsaLLRoot_t
modifier|*
name|saRoot
init|=
operator|(
name|agsaLLRoot_t
operator|*
operator|)
operator|(
name|agRoot
operator|->
name|sdkData
operator|)
decl_stmt|;
name|agsaDeviceDesc_t
modifier|*
name|pDevice
init|=
operator|(
name|agsaDeviceDesc_t
operator|*
operator|)
operator|(
name|agDevHandle
operator|->
name|sdkData
operator|)
decl_stmt|;
name|bit32
name|deviceid
decl_stmt|;
name|bit32
name|ret
init|=
name|AGSA_RC_FAILURE
decl_stmt|;
name|OS_ASSERT
argument_list|(
name|pDevice
operator|!=
name|agNULL
argument_list|,
literal|"saGetDeviceInfo is NULL"
argument_list|)
expr_stmt|;
name|smTraceFuncEnter
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|"ze"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pDevice
operator|==
name|agNULL
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetDeviceInfo: pDevice is NULL \n"
operator|)
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'a'
argument_list|,
literal|"ze"
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_FAILURE
return|;
block|}
comment|/* Get deviceid */
name|deviceid
operator|=
name|pDevice
operator|->
name|DeviceMapIndex
expr_stmt|;
name|SA_DBG3
argument_list|(
operator|(
literal|"saGetDeviceInfo: start pDevice %p, deviceId %d\n"
operator|,
name|pDevice
operator|,
name|deviceid
operator|)
argument_list|)
expr_stmt|;
comment|/* verify the agDeviceHandle with the one in the deviceMap */
if|if
condition|(
operator|(
name|deviceid
operator|!=
name|saRoot
operator|->
name|DeviceMap
index|[
name|deviceid
operator|&
name|DEVICE_ID_BITS
index|]
operator|.
name|DeviceIdFromFW
operator|)
operator|||
operator|(
name|pDevice
operator|!=
name|saRoot
operator|->
name|DeviceMap
index|[
name|deviceid
operator|&
name|DEVICE_ID_BITS
index|]
operator|.
name|DeviceHandle
operator|)
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetDeviceInfo: Not match failure or device not exist\n"
operator|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|AGSA_RC_FAILURE
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'b'
argument_list|,
literal|"ze"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
comment|/* send IOMB to the SPC */
name|ret
operator|=
name|mpiGetDeviceInfoCmd
argument_list|(
name|agRoot
argument_list|,
name|agContext
argument_list|,
name|deviceid
argument_list|,
name|option
argument_list|,
name|queueNum
argument_list|)
expr_stmt|;
name|SA_DBG3
argument_list|(
operator|(
literal|"saGetDeviceInfo: end\n"
operator|)
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'c'
argument_list|,
literal|"ze"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*! \brief Set Device Information  *  *  Set SAS/SATA device information API  *  *  \param agRoot          Handles for this instance of SAS/SATA hardware  *  \param agContext       Pointer to this API context  *  \param queueNum        IQ/OQ number  *  \param agDevHandle     Pointer of device handle  *  \param option          device general information or extended information  *  \param param           Parameter of Set Device Infomation  *  *  \return  *          - \e AGSA_RC_SUCCESS  *          - \e AGSA_RC_FAILURE  *  */
end_comment

begin_comment
comment|/*******************************************************************************/
end_comment

begin_function
name|GLOBAL
name|bit32
name|saSetDeviceInfo
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|agsaContext_t
modifier|*
name|agContext
parameter_list|,
name|bit32
name|queueNum
parameter_list|,
name|agsaDevHandle_t
modifier|*
name|agDevHandle
parameter_list|,
name|bit32
name|option
parameter_list|,
name|bit32
name|param
parameter_list|,
name|ossaSetDeviceInfoCB_t
name|agCB
parameter_list|)
block|{
name|agsaLLRoot_t
modifier|*
name|saRoot
init|=
operator|(
name|agsaLLRoot_t
operator|*
operator|)
operator|(
name|agRoot
operator|->
name|sdkData
operator|)
decl_stmt|;
name|agsaDeviceDesc_t
modifier|*
name|pDevice
init|=
operator|(
name|agsaDeviceDesc_t
operator|*
operator|)
operator|(
name|agDevHandle
operator|->
name|sdkData
operator|)
decl_stmt|;
name|bit32
name|deviceid
decl_stmt|;
name|bit32
name|ret
init|=
name|AGSA_RC_FAILURE
decl_stmt|;
name|OS_ASSERT
argument_list|(
name|pDevice
operator|!=
name|agNULL
argument_list|,
literal|"saSetDeviceInfo is NULL"
argument_list|)
expr_stmt|;
name|smTraceFuncEnter
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|"zf"
argument_list|)
expr_stmt|;
name|SA_DBG2
argument_list|(
operator|(
literal|"saSetDeviceInfo: start pDevice %p, option=0x%x param=0x0%x\n"
operator|,
name|pDevice
operator|,
name|option
operator|,
name|param
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|agNULL
operator|==
name|pDevice
condition|)
block|{
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'a'
argument_list|,
literal|"zf"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
comment|/* Get deviceid */
name|deviceid
operator|=
name|pDevice
operator|->
name|DeviceMapIndex
expr_stmt|;
name|pDevice
operator|->
name|option
operator|=
name|option
expr_stmt|;
name|pDevice
operator|->
name|param
operator|=
name|param
expr_stmt|;
name|SA_DBG3
argument_list|(
operator|(
literal|"saSetDeviceInfo: deviceId %d\n"
operator|,
name|deviceid
operator|)
argument_list|)
expr_stmt|;
comment|/* verify the agDeviceHandle with the one in the deviceMap */
if|if
condition|(
operator|(
name|deviceid
operator|!=
name|saRoot
operator|->
name|DeviceMap
index|[
name|deviceid
operator|&
name|DEVICE_ID_BITS
index|]
operator|.
name|DeviceIdFromFW
operator|)
operator|||
operator|(
name|pDevice
operator|!=
name|saRoot
operator|->
name|DeviceMap
index|[
name|deviceid
operator|&
name|DEVICE_ID_BITS
index|]
operator|.
name|DeviceHandle
operator|)
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"saSetDeviceInfo: Not match failure or device not exist\n"
operator|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|AGSA_RC_FAILURE
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'b'
argument_list|,
literal|"zf"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
comment|/* send IOMB to the SPC */
name|ret
operator|=
name|mpiSetDeviceInfoCmd
argument_list|(
name|agRoot
argument_list|,
name|agContext
argument_list|,
name|deviceid
argument_list|,
name|option
argument_list|,
name|queueNum
argument_list|,
name|param
argument_list|,
name|agCB
argument_list|)
expr_stmt|;
name|SA_DBG3
argument_list|(
operator|(
literal|"saSetDeviceInfo: end\n"
operator|)
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'c'
argument_list|,
literal|"zf"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*! \brief Get Device State  *  *  Get SAS/SATA device state API  *  *  \param agRoot          Handles for this instance of SAS/SATA hardware  *  \param agContext       Pointer to this API context  *  \param queueNum        IQ/OQ number  *  \param agDevHandle     Pointer of device handler  *  *  \return  *          - \e AGSA_RC_SUCCESS  *          - \e AGSA_RC_FAILURE  *  */
end_comment

begin_comment
comment|/*******************************************************************************/
end_comment

begin_function
name|GLOBAL
name|bit32
name|saGetDeviceState
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|agsaContext_t
modifier|*
name|agContext
parameter_list|,
name|bit32
name|queueNum
parameter_list|,
name|agsaDevHandle_t
modifier|*
name|agDevHandle
parameter_list|)
block|{
name|agsaLLRoot_t
modifier|*
name|saRoot
init|=
operator|(
name|agsaLLRoot_t
operator|*
operator|)
operator|(
name|agRoot
operator|->
name|sdkData
operator|)
decl_stmt|;
name|agsaDeviceDesc_t
modifier|*
name|pDevice
init|=
operator|(
name|agsaDeviceDesc_t
operator|*
operator|)
operator|(
name|agDevHandle
operator|->
name|sdkData
operator|)
decl_stmt|;
name|bit32
name|deviceid
decl_stmt|;
name|bit32
name|ret
init|=
name|AGSA_RC_FAILURE
decl_stmt|;
name|OS_ASSERT
argument_list|(
name|pDevice
operator|!=
name|agNULL
argument_list|,
literal|"saGetDeviceState is NULL"
argument_list|)
expr_stmt|;
name|smTraceFuncEnter
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|"zg"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pDevice
operator|==
name|agNULL
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetDeviceState: pDevice is NULL \n"
operator|)
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'a'
argument_list|,
literal|"zg"
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_FAILURE
return|;
block|}
name|SA_DBG3
argument_list|(
operator|(
literal|"saGetDeviceState: start pDevice %p\n"
operator|,
name|pDevice
operator|)
argument_list|)
expr_stmt|;
comment|/* Get deviceid */
name|deviceid
operator|=
name|pDevice
operator|->
name|DeviceMapIndex
expr_stmt|;
comment|/* verify the agDeviceHandle with the one in the deviceMap */
if|if
condition|(
operator|(
name|deviceid
operator|!=
name|saRoot
operator|->
name|DeviceMap
index|[
name|deviceid
operator|&
name|DEVICE_ID_BITS
index|]
operator|.
name|DeviceIdFromFW
operator|)
operator|||
operator|(
name|pDevice
operator|!=
name|saRoot
operator|->
name|DeviceMap
index|[
name|deviceid
operator|&
name|DEVICE_ID_BITS
index|]
operator|.
name|DeviceHandle
operator|)
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetDeviceState: Not match failure or device not exist\n"
operator|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|AGSA_RC_FAILURE
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'b'
argument_list|,
literal|"zg"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
comment|/* send IOMB to the SPC */
name|ret
operator|=
name|mpiGetDeviceStateCmd
argument_list|(
name|agRoot
argument_list|,
name|agContext
argument_list|,
name|deviceid
argument_list|,
name|queueNum
argument_list|)
expr_stmt|;
name|SA_DBG3
argument_list|(
operator|(
literal|"saGetDeviceState: end\n"
operator|)
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'c'
argument_list|,
literal|"zg"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*! \brief Set Device State  *  *  Set SAS/SATA device state API  *  *  \param agRoot          Handles for this instance of SAS/SATA hardware  *  \param agContext       Pointer to this API context  *  \param queueNum        IQ/OQ number  *  \param agDevHandle     Pointer of device handler  *  \param newDeviceState  new device state  *  *  \return  *          - \e AGSA_RC_SUCCESS  *          - \e AGSA_RC_FAILURE  *  */
end_comment

begin_comment
comment|/*******************************************************************************/
end_comment

begin_function
name|GLOBAL
name|bit32
name|saSetDeviceState
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|agsaContext_t
modifier|*
name|agContext
parameter_list|,
name|bit32
name|queueNum
parameter_list|,
name|agsaDevHandle_t
modifier|*
name|agDevHandle
parameter_list|,
name|bit32
name|newDeviceState
parameter_list|)
block|{
name|agsaLLRoot_t
modifier|*
name|saRoot
decl_stmt|;
name|agsaDeviceDesc_t
modifier|*
name|pDevice
decl_stmt|;
name|bit32
name|deviceid
decl_stmt|;
name|bit32
name|ret
init|=
name|AGSA_RC_FAILURE
decl_stmt|;
name|saRoot
operator|=
operator|(
name|agsaLLRoot_t
operator|*
operator|)
operator|(
name|agRoot
operator|->
name|sdkData
operator|)
expr_stmt|;
name|OS_ASSERT
argument_list|(
name|saRoot
operator|!=
name|agNULL
argument_list|,
literal|"saSetDeviceState saRoot"
argument_list|)
expr_stmt|;
if|if
condition|(
name|saRoot
operator|==
name|agNULL
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"saSetDeviceState: saRoot is NULL\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|OS_ASSERT
argument_list|(
name|agDevHandle
operator|!=
name|agNULL
argument_list|,
literal|"saSetDeviceState agDevHandle  is NULL"
argument_list|)
expr_stmt|;
name|smTraceFuncEnter
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|"zh"
argument_list|)
expr_stmt|;
if|if
condition|(
name|agDevHandle
operator|==
name|agNULL
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"saSetDeviceState: agDevHandle is NULL\n"
operator|)
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'a'
argument_list|,
literal|"zh"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|pDevice
operator|=
operator|(
name|agsaDeviceDesc_t
operator|*
operator|)
operator|(
name|agDevHandle
operator|->
name|sdkData
operator|)
expr_stmt|;
name|OS_ASSERT
argument_list|(
name|pDevice
operator|!=
name|agNULL
argument_list|,
literal|"saSetDeviceState pDevice is NULL"
argument_list|)
expr_stmt|;
name|SA_DBG3
argument_list|(
operator|(
literal|"saSetDeviceState: start pDevice %p\n"
operator|,
name|pDevice
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pDevice
operator|==
name|agNULL
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"saSetDeviceState: pDevice is NULL\n"
operator|)
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'b'
argument_list|,
literal|"zh"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
comment|/* Get deviceid */
name|deviceid
operator|=
name|pDevice
operator|->
name|DeviceMapIndex
expr_stmt|;
comment|/* verify the agDeviceHandle with the one in the deviceMap */
if|if
condition|(
operator|(
name|deviceid
operator|!=
name|saRoot
operator|->
name|DeviceMap
index|[
name|deviceid
operator|&
name|DEVICE_ID_BITS
index|]
operator|.
name|DeviceIdFromFW
operator|)
operator|||
operator|(
name|pDevice
operator|!=
name|saRoot
operator|->
name|DeviceMap
index|[
name|deviceid
operator|&
name|DEVICE_ID_BITS
index|]
operator|.
name|DeviceHandle
operator|)
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"saSetDeviceState: Not match failure or device not exist\n"
operator|)
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'c'
argument_list|,
literal|"zh"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
comment|/* send IOMB to the SPC */
name|ret
operator|=
name|mpiSetDeviceStateCmd
argument_list|(
name|agRoot
argument_list|,
name|agContext
argument_list|,
name|deviceid
argument_list|,
name|newDeviceState
argument_list|,
name|queueNum
argument_list|)
expr_stmt|;
name|SA_DBG3
argument_list|(
operator|(
literal|"saSetDeviceState: end\n"
operator|)
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'d'
argument_list|,
literal|"zh"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

end_unit

