begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************************* *Copyright (c) 2014 PMC-Sierra, Inc.  All rights reserved.  * *Redistribution and use in source and binary forms, with or without modification, are permitted provided  *that the following conditions are met:  *1. Redistributions of source code must retain the above copyright notice, this list of conditions and the *following disclaimer.  *2. Redistributions in binary form must reproduce the above copyright notice,  *this list of conditions and the following disclaimer in the documentation and/or other materials provided *with the distribution.  * *THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR IMPLIED  *WARRANTIES,INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS *FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE *FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  *NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR  *BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  *LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  *SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE  ********************************************************************************/
end_comment

begin_comment
comment|/*******************************************************************************/
end_comment

begin_comment
comment|/*! \file satimer.c  *  \brief The file implements the timerTick function  *  */
end_comment

begin_comment
comment|/******************************************************************************/
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<dev/pms/config.h>
end_include

begin_include
include|#
directive|include
file|<dev/pms/RefTisa/sallsdk/spc/saglobal.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SA_FW_TEST_BUNCH_STARTS
end_ifdef

begin_function_decl
name|void
name|mpiMsgProduceBunch
parameter_list|(
name|agsaLLRoot_t
modifier|*
name|saRoot
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SA_FW_TEST_BUNCH_STARTS */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SA_ENABLE_TRACE_FUNCTIONS
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|siTraceFileID
end_ifdef

begin_undef
undef|#
directive|undef
name|siTraceFileID
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|siTraceFileID
value|'P'
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*! \brief TimerTick  *  *  TimerTick  *  *  \param agRoot handles for this instance of SAS/SATA hardware  *  *  \return -void-  */
end_comment

begin_comment
comment|/*******************************************************************************/
end_comment

begin_function
name|GLOBAL
name|void
name|saTimerTick
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|)
block|{
name|agsaLLRoot_t
modifier|*
name|saRoot
init|=
operator|(
name|agsaLLRoot_t
operator|*
operator|)
operator|(
name|agRoot
operator|->
name|sdkData
operator|)
decl_stmt|;
name|agsaTimerDesc_t
modifier|*
name|pTimer
decl_stmt|;
name|bit32
name|Event
decl_stmt|;
name|void
modifier|*
name|pParm
decl_stmt|;
if|if
condition|(
name|agNULL
operator|==
name|saRoot
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"saTimerTick:agNULL ==  saRoot \n"
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* (1) Acquire timer list lock */
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_TIMER_LOCK
argument_list|)
expr_stmt|;
comment|/* (2) Find the timers are timeout */
name|pTimer
operator|=
operator|(
name|agsaTimerDesc_t
operator|*
operator|)
name|saLlistGetHead
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|validTimers
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|agNULL
operator|!=
name|pTimer
condition|)
block|{
comment|/* (2.1) Find the first timer is timeout */
if|if
condition|(
name|pTimer
operator|->
name|timeoutTick
operator|==
name|saRoot
operator|->
name|timeTick
condition|)
block|{
comment|/* (2.1.1) remove the timer from valid timer list */
name|saLlistRemove
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|validTimers
operator|)
argument_list|,
operator|&
operator|(
name|pTimer
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
comment|/* (2.1.2) Invalid timer */
name|pTimer
operator|->
name|valid
operator|=
name|agFALSE
expr_stmt|;
comment|/* (2.1.3) Get timer event and param */
name|Event
operator|=
name|pTimer
operator|->
name|Event
expr_stmt|;
name|pParm
operator|=
name|pTimer
operator|->
name|pParm
expr_stmt|;
comment|/* (2.1.4) Release timer list lock */
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_TIMER_LOCK
argument_list|)
expr_stmt|;
comment|/* (2.1.5) Timer Callback */
name|pTimer
operator|->
name|pfnTimeout
argument_list|(
name|agRoot
argument_list|,
name|Event
argument_list|,
name|pParm
argument_list|)
expr_stmt|;
comment|/* (2.1.6) Acquire timer list lock again */
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_TIMER_LOCK
argument_list|)
expr_stmt|;
comment|/* (2.1.7) return the timer to free timer list */
name|saLlistAdd
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeTimers
operator|)
argument_list|,
operator|&
operator|(
name|pTimer
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* (2.2) the first timer is not timeout */
else|else
block|{
break|break;
block|}
name|pTimer
operator|=
operator|(
name|agsaTimerDesc_t
operator|*
operator|)
name|saLlistGetHead
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|validTimers
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* (3) increment timeTick */
name|saRoot
operator|->
name|timeTick
operator|++
expr_stmt|;
if|if
condition|(
name|saRoot
operator|->
name|ResetFailed
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"saTimerTick: siChipResetV saRoot->ResetFailed\n"
operator|)
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SA_FW_TEST_BUNCH_STARTS
if|if
condition|(
name|saRoot
operator|->
name|BunchStarts_Enable
operator|&&
name|saRoot
operator|->
name|BunchStarts_Pending
condition|)
block|{
name|SA_DBG3
argument_list|(
operator|(
literal|"saTimerTick: mpiMsgProduceBunch\n"
operator|)
argument_list|)
expr_stmt|;
name|mpiMsgProduceBunch
argument_list|(
name|saRoot
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SA_FW_TEST_BUNCH_STARTS */
ifdef|#
directive|ifdef
name|SA_FW_TEST_INTERRUPT_REASSERT
if|if
condition|(
literal|1
condition|)
block|{
name|mpiOCQueue_t
modifier|*
name|circularQ
decl_stmt|;
name|int
name|i
decl_stmt|;
name|SA_DBG4
argument_list|(
operator|(
literal|"saTimerTick:SA_FW_TEST_INTERRUPT_REASSERT\n"
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|saRoot
operator|->
name|QueueConfig
operator|.
name|numOutboundQueues
condition|;
name|i
operator|++
control|)
block|{
name|circularQ
operator|=
operator|&
name|saRoot
operator|->
name|outboundQueue
index|[
name|i
index|]
expr_stmt|;
name|OSSA_READ_LE_32
argument_list|(
name|circularQ
operator|->
name|agRoot
argument_list|,
operator|&
name|circularQ
operator|->
name|producerIdx
argument_list|,
name|circularQ
operator|->
name|piPointer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|circularQ
operator|->
name|producerIdx
operator|!=
name|circularQ
operator|->
name|consumerIdx
condition|)
block|{
if|if
condition|(
name|saRoot
operator|->
name|OldCi
index|[
name|i
index|]
operator|==
name|circularQ
operator|->
name|consumerIdx
operator|&&
name|saRoot
operator|->
name|OldPi
index|[
name|i
index|]
operator|>=
name|circularQ
operator|->
name|producerIdx
condition|)
block|{
name|agsaEchoCmd_t
name|payload
decl_stmt|;
name|payload
operator|.
name|tag
operator|=
literal|0xF0
expr_stmt|;
name|payload
operator|.
name|payload
index|[
literal|0
index|]
operator|=
literal|0x0
expr_stmt|;
if|if
condition|(
operator|++
name|saRoot
operator|->
name|OldFlag
index|[
name|i
index|]
operator|>
literal|1
condition|)
block|{
name|saRoot
operator|->
name|CheckAll
operator|++
expr_stmt|;
block|}
name|SA_DBG1
argument_list|(
operator|(
literal|"saTimerTick:Q %d (%d) PI 0x%03x CI 0x%03x (%d) CheckAll %d %d\n"
operator|,
name|i
operator|,
name|saRoot
operator|->
name|OldFlag
index|[
name|i
index|]
operator|,
name|circularQ
operator|->
name|producerIdx
operator|,
name|circularQ
operator|->
name|consumerIdx
operator|,
operator|(
name|circularQ
operator|->
name|producerIdx
operator|>
name|circularQ
operator|->
name|consumerIdx
condition|?
operator|(
name|circularQ
operator|->
name|producerIdx
operator|-
name|circularQ
operator|->
name|consumerIdx
operator|)
else|:
operator|(
name|circularQ
operator|->
name|numElements
operator|-
name|circularQ
operator|->
name|consumerIdx
operator|)
operator|+
name|circularQ
operator|->
name|producerIdx
operator|)
operator|,
name|saRoot
operator|->
name|CheckAll
operator|,
name|saRoot
operator|->
name|sysIntsActive
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|smIS64bInt
argument_list|(
name|agRoot
argument_list|)
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"saTimerTick:CheckAll %d ODR 0x%08X%08X ODMR 0x%08X%08X our Int %x\n"
operator|,
name|saRoot
operator|->
name|CheckAll
operator|,
name|ossaHwRegReadExt
argument_list|(
name|agRoot
argument_list|,
literal|0
argument_list|,
name|V_Outbound_Doorbell_Set_RegisterU
argument_list|)
operator|,
name|ossaHwRegReadExt
argument_list|(
name|agRoot
argument_list|,
literal|0
argument_list|,
name|V_Outbound_Doorbell_Set_Register
argument_list|)
operator|,
name|ossaHwRegReadExt
argument_list|(
name|agRoot
argument_list|,
literal|0
argument_list|,
name|V_Outbound_Doorbell_Mask_Set_RegisterU
argument_list|)
operator|,
name|ossaHwRegReadExt
argument_list|(
name|agRoot
argument_list|,
literal|0
argument_list|,
name|V_Outbound_Doorbell_Mask_Set_Register
argument_list|)
operator|,
name|saRoot
operator|->
name|OurInterrupt
argument_list|(
name|agRoot
argument_list|,
name|i
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"saTimerTick:CheckAll %d ODR 0x%08X ODMR 0x%08X our Int %x\n"
operator|,
name|saRoot
operator|->
name|CheckAll
operator|,
name|siHalRegReadExt
argument_list|(
name|agRoot
argument_list|,
name|GEN_MSGU_ODR
argument_list|,
name|V_Outbound_Doorbell_Set_Register
argument_list|)
operator|,
name|siHalRegReadExt
argument_list|(
name|agRoot
argument_list|,
name|GEN_MSGU_ODMR
argument_list|,
name|V_Outbound_Doorbell_Mask_Set_Register
argument_list|)
operator|,
name|saRoot
operator|->
name|OurInterrupt
argument_list|(
name|agRoot
argument_list|,
name|i
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|saRoot
operator|->
name|CheckAll
operator|>
literal|1
condition|)
block|{
name|saEchoCommand
argument_list|(
name|agRoot
argument_list|,
name|agNULL
argument_list|,
operator|(
operator|(
name|i
operator|<<
literal|16
operator|)
operator|&
literal|0xFFFF0000
operator|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|payload
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|saRoot
operator|->
name|OldFlag
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|saRoot
operator|->
name|OldPi
index|[
name|i
index|]
operator|=
name|circularQ
operator|->
name|producerIdx
expr_stmt|;
name|saRoot
operator|->
name|OldCi
index|[
name|i
index|]
operator|=
name|circularQ
operator|->
name|consumerIdx
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* SA_FW_TEST_INTERRUPT_REASSERT */
comment|/* (4) Release timer list lock */
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_TIMER_LOCK
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SA_FW_TEST_INTERRUPT_REASSERT
if|if
condition|(
name|saRoot
operator|->
name|CheckAll
condition|)
block|{
name|int
name|a
decl_stmt|;
for|for
control|(
name|a
operator|=
literal|0
init|;
name|a
operator|<
literal|32
condition|;
name|a
operator|++
control|)
block|{
if|if
condition|(
name|saRoot
operator|->
name|interruptVecIndexBitMap
index|[
name|a
index|]
operator|&
operator|(
literal|1
operator|<<
name|a
operator|)
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"saTimerTick DI %d\n"
operator|,
name|a
operator|)
argument_list|)
expr_stmt|;
name|saSystemInterruptsEnable
argument_list|(
name|agRoot
argument_list|,
name|a
argument_list|)
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* SA_FW_TEST_INTERRUPT_REASSERT */
block|}
end_function

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*! \brief add a timer  *  *  add a timer  *  *  \param agRoot       handles for this instance of SAS/SATA hardware  *  \param pTimer       the pointer to the timer being added  *  \param timeout      the timeout ticks from now  *  \param pfnTimeout   callback function when time is out  *  \param Event        the Event code passed to callback function  *  \param pParm        the pointer to parameter passed to callback function  *  *  \return If the timer is added successfully  *          - \e AGSA_RC_SUCCESS timer is added successfully  *          - \e AGSA_RC_FAILURE cannot add new timer, run out of resource  */
end_comment

begin_comment
comment|/*******************************************************************************/
end_comment

begin_function
name|GLOBAL
name|agsaTimerDesc_t
modifier|*
name|siTimerAdd
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|bit32
name|timeout
parameter_list|,
name|agsaCallback_t
name|pfnTimeout
parameter_list|,
name|bit32
name|Event
parameter_list|,
name|void
modifier|*
name|pParm
parameter_list|)
block|{
name|agsaLLRoot_t
modifier|*
name|saRoot
init|=
operator|(
name|agsaLLRoot_t
operator|*
operator|)
operator|(
name|agRoot
operator|->
name|sdkData
operator|)
decl_stmt|;
name|agsaTimerDesc_t
modifier|*
name|pTimer
decl_stmt|;
name|agsaTimerDesc_t
modifier|*
name|pValidTimer
decl_stmt|;
name|smTraceFuncEnter
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|"Ta"
argument_list|)
expr_stmt|;
comment|/* (1) Acquire timer list lock */
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_TIMER_LOCK
argument_list|)
expr_stmt|;
comment|/* (2) Get a free timer */
name|pTimer
operator|=
operator|(
name|agsaTimerDesc_t
operator|*
operator|)
name|saLlistGetHead
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeTimers
operator|)
argument_list|)
expr_stmt|;
comment|/* (3) If the timer is availble  */
if|if
condition|(
name|agNULL
operator|!=
name|pTimer
condition|)
block|{
name|saLlistRemove
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeTimers
operator|)
argument_list|,
operator|&
operator|(
name|pTimer
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
comment|/* (3.1) Setup timer */
name|saLlinkInitialize
argument_list|(
operator|&
operator|(
name|pTimer
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
comment|/*--------------------------------------**     ** the timeout shall greater than 0 **     **--------------------------------------*/
if|if
condition|(
literal|0
operator|==
name|timeout
condition|)
block|{
name|timeout
operator|=
name|timeout
operator|+
literal|1
expr_stmt|;
block|}
name|pTimer
operator|->
name|valid
operator|=
name|agTRUE
expr_stmt|;
name|pTimer
operator|->
name|timeoutTick
operator|=
name|saRoot
operator|->
name|timeTick
operator|+
name|timeout
expr_stmt|;
name|pTimer
operator|->
name|pfnTimeout
operator|=
name|pfnTimeout
expr_stmt|;
name|pTimer
operator|->
name|Event
operator|=
name|Event
expr_stmt|;
name|pTimer
operator|->
name|pParm
operator|=
name|pParm
expr_stmt|;
comment|/* (3.2) Add timer the timer to valid timer list */
name|pValidTimer
operator|=
operator|(
name|agsaTimerDesc_t
operator|*
operator|)
name|saLlistGetHead
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|validTimers
operator|)
argument_list|)
expr_stmt|;
comment|/* (3.3) for each timer in the valid timer list */
while|while
condition|(
name|agNULL
operator|!=
name|pValidTimer
condition|)
block|{
comment|/* (3.3.1) If the timeoutTick is not wrapped around */
if|if
condition|(
name|pTimer
operator|->
name|timeoutTick
operator|>
name|saRoot
operator|->
name|timeTick
condition|)
block|{
comment|/* (3.3.1.1) If validTimer wrapped around */
if|if
condition|(
name|pValidTimer
operator|->
name|timeoutTick
operator|<
name|saRoot
operator|->
name|timeTick
condition|)
block|{
name|saLlistInsert
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|validTimers
operator|)
argument_list|,
operator|&
operator|(
name|pValidTimer
operator|->
name|linkNode
operator|)
argument_list|,
operator|&
operator|(
name|pTimer
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* (3.3.1.2) If validTimer is not wrapped around */
else|else
block|{
if|if
condition|(
name|pValidTimer
operator|->
name|timeoutTick
operator|>
name|pTimer
operator|->
name|timeoutTick
condition|)
block|{
name|saLlistInsert
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|validTimers
operator|)
argument_list|,
operator|&
operator|(
name|pValidTimer
operator|->
name|linkNode
operator|)
argument_list|,
operator|&
operator|(
name|pTimer
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* (3.3.2) If the timeoutTick is wrapped around */
else|else
block|{
comment|/* (3.3.2.1) If validTimer is wrapped around */
if|if
condition|(
name|pValidTimer
operator|->
name|timeoutTick
operator|<
name|saRoot
operator|->
name|timeTick
condition|)
block|{
if|if
condition|(
name|pValidTimer
operator|->
name|timeoutTick
operator|>
name|pTimer
operator|->
name|timeoutTick
condition|)
block|{
name|saLlistInsert
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|validTimers
operator|)
argument_list|,
operator|&
operator|(
name|pValidTimer
operator|->
name|linkNode
operator|)
argument_list|,
operator|&
operator|(
name|pTimer
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* (3.3.3) Continue to the next valid timer */
name|pValidTimer
operator|=
operator|(
name|agsaTimerDesc_t
operator|*
operator|)
name|saLlistGetNext
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|validTimers
operator|)
argument_list|,
operator|&
operator|(
name|pValidTimer
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* (3.4) No timers in the validtimer list is greater than this timer */
if|if
condition|(
name|agNULL
operator|==
name|pValidTimer
condition|)
block|{
name|saLlistAdd
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|validTimers
operator|)
argument_list|,
operator|&
operator|(
name|pTimer
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* (4) Release timer list lock */
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_TIMER_LOCK
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'a'
argument_list|,
literal|"Ta"
argument_list|)
expr_stmt|;
return|return
name|pTimer
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*! \brief remove a valid timer  *  *  remove a timer  *  *  \param agRoot       handles for this instance of SAS/SATA hardware  *  \param pTimer       the timer to be removed  *  *  \return -void-  */
end_comment

begin_comment
comment|/*******************************************************************************/
end_comment

begin_function
name|GLOBAL
name|void
name|siTimerRemove
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|agsaTimerDesc_t
modifier|*
name|pTimer
parameter_list|)
block|{
name|agsaLLRoot_t
modifier|*
name|saRoot
init|=
operator|(
name|agsaLLRoot_t
operator|*
operator|)
operator|(
name|agRoot
operator|->
name|sdkData
operator|)
decl_stmt|;
comment|/* (1) Acquire timer list lock */
name|smTraceFuncEnter
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|"Tb"
argument_list|)
expr_stmt|;
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_TIMER_LOCK
argument_list|)
expr_stmt|;
comment|/* (2) If the timer is still valid */
if|if
condition|(
name|agTRUE
operator|==
name|pTimer
operator|->
name|valid
condition|)
block|{
comment|/* (2.1) remove from the valid timer list */
name|saLlistRemove
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|validTimers
operator|)
argument_list|,
operator|&
operator|(
name|pTimer
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
comment|/* (2.2) Invalid the timer */
name|pTimer
operator|->
name|valid
operator|=
name|agFALSE
expr_stmt|;
comment|/* (2.3) return the timer to the free timer list */
name|saLlistAdd
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeTimers
operator|)
argument_list|,
operator|&
operator|(
name|pTimer
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* (3) Release timer list lock */
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_TIMER_LOCK
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'a'
argument_list|,
literal|"Tb"
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*! \brief remove all valid timer  *  *  remove all timer  *  *  \param agRoot       handles for this instance of SAS/SATA hardware  *  *  \return -void-  */
end_comment

begin_comment
comment|/*******************************************************************************/
end_comment

begin_function
name|GLOBAL
name|void
name|siTimerRemoveAll
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|)
block|{
name|agsaLLRoot_t
modifier|*
name|saRoot
init|=
operator|(
name|agsaLLRoot_t
operator|*
operator|)
operator|(
name|agRoot
operator|->
name|sdkData
operator|)
decl_stmt|;
name|agsaTimerDesc_t
modifier|*
name|pTimer
decl_stmt|;
name|smTraceFuncEnter
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|"Tc"
argument_list|)
expr_stmt|;
comment|/* (1) Acquire timer list lock */
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_TIMER_LOCK
argument_list|)
expr_stmt|;
comment|/* (2) Get a valid timer */
name|pTimer
operator|=
operator|(
name|agsaTimerDesc_t
operator|*
operator|)
name|saLlistGetHead
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|validTimers
operator|)
argument_list|)
expr_stmt|;
comment|/* (3) If the timer is valid  */
while|while
condition|(
name|agNULL
operator|!=
name|pTimer
condition|)
block|{
comment|/* (3.1) remove from the valid timer list */
name|saLlistRemove
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|validTimers
operator|)
argument_list|,
operator|&
operator|(
name|pTimer
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
comment|/* (3.2) Invalid timer */
name|pTimer
operator|->
name|valid
operator|=
name|agFALSE
expr_stmt|;
comment|/* (3.3) return the timer to the free timer list */
name|saLlistAdd
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeTimers
operator|)
argument_list|,
operator|&
operator|(
name|pTimer
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
comment|/* (3.4) get next valid timer */
name|pTimer
operator|=
operator|(
name|agsaTimerDesc_t
operator|*
operator|)
name|saLlistGetHead
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|validTimers
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* (4) Release timer list lock */
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_TIMER_LOCK
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'a'
argument_list|,
literal|"Tc"
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

end_unit

