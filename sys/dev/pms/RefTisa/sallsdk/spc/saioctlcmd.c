begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************************* *Copyright (c) 2014 PMC-Sierra, Inc.  All rights reserved.  * *Redistribution and use in source and binary forms, with or without modification, are permitted provided  *that the following conditions are met:  *1. Redistributions of source code must retain the above copyright notice, this list of conditions and the *following disclaimer.  *2. Redistributions in binary form must reproduce the above copyright notice,  *this list of conditions and the following disclaimer in the documentation and/or other materials provided *with the distribution.  * *THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR IMPLIED  *WARRANTIES,INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS *FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE *FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  *NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR  *BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  *LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  *SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE  ********************************************************************************/
end_comment

begin_comment
comment|/*******************************************************************************/
end_comment

begin_comment
comment|/*! \file saioctlcmd.c  *  \brief The file implements the functions of IOCTL MPI Command/Response to/from SPC  *  */
end_comment

begin_comment
comment|/******************************************************************************/
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<dev/pms/config.h>
end_include

begin_include
include|#
directive|include
file|<dev/pms/RefTisa/sallsdk/spc/saglobal.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SA_ENABLE_TRACE_FUNCTIONS
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|siTraceFileID
end_ifdef

begin_undef
undef|#
directive|undef
name|siTraceFileID
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|siTraceFileID
value|'H'
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|bit32
name|gFPGA_TEST
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bit32
name|gWait_3
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bit32
name|gWait_2
decl_stmt|;
end_decl_stmt

begin_function_decl
name|LOCAL
name|bit32
name|siGSMDump
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|bit32
name|gsmDumpOffset
parameter_list|,
name|bit32
name|length
parameter_list|,
name|void
modifier|*
name|directData
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|SPC_ENABLE_PROFILE
end_ifdef

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*! \brief SPC FW Profile Command  *  *  This command sends FW Flash Update Command to SPC.  *  *  \param agRoot          Handles for this instance of SAS/SATA LL  *  \param agContext       Context of SPC FW Flash Update Command  *  \param queueNum        Inbound/outbound queue number  *  \param flashUpdateInfo Pointer of flash update information  *  *  \return If the MPI command is sent to SPC successfully  *          - \e AGSA_RC_SUCCESS the MPI command is successfully  *          - \e AGSA_RC_FAILURE the MPI command is failure  *  */
end_comment

begin_comment
comment|/*******************************************************************************/
end_comment

begin_function
name|GLOBAL
name|bit32
name|saFwProfile
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|agsaContext_t
modifier|*
name|agContext
parameter_list|,
name|bit32
name|queueNum
parameter_list|,
name|agsaFwProfile_t
modifier|*
name|fwProfileInfo
parameter_list|)
block|{
name|bit32
name|ret
init|=
name|AGSA_RC_SUCCESS
decl_stmt|,
name|retVal
decl_stmt|;
name|agsaLLRoot_t
modifier|*
name|saRoot
init|=
operator|(
name|agsaLLRoot_t
operator|*
operator|)
operator|(
name|agRoot
operator|->
name|sdkData
operator|)
decl_stmt|;
name|agsaIORequestDesc_t
modifier|*
name|pRequest
decl_stmt|;
name|mpiICQueue_t
modifier|*
name|circularQ
decl_stmt|;
name|void
modifier|*
name|pMessage
decl_stmt|;
name|agsaFwProfileIOMB_t
modifier|*
name|pPayload
decl_stmt|;
name|bit8
name|inq
decl_stmt|,
name|outq
decl_stmt|;
name|bit32
name|i
decl_stmt|,
name|tcid_processor_cmd
init|=
literal|0
decl_stmt|;
comment|/* sanity check */
name|SA_ASSERT
argument_list|(
operator|(
name|agNULL
operator|!=
name|agRoot
operator|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* Get request from free IORequests */
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|pRequest
operator|=
operator|(
name|agsaIORequestDesc_t
operator|*
operator|)
name|saLlistGetHead
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|)
expr_stmt|;
comment|/* If no LL Control request entry avaliable */
if|if
condition|(
name|agNULL
operator|==
name|pRequest
condition|)
block|{
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saFwProfile, No request from free list\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_BUSY
return|;
block|}
comment|/* If LL Control request entry avaliable */
else|else
block|{
comment|/* Assign inbound and outbound Ring Buffer */
name|inq
operator|=
call|(
name|bit8
call|)
argument_list|(
name|queueNum
operator|&
name|MPI_IB_NUM_MASK
argument_list|)
expr_stmt|;
name|outq
operator|=
call|(
name|bit8
call|)
argument_list|(
operator|(
name|queueNum
operator|&
name|MPI_OB_NUM_MASK
operator|)
operator|>>
name|MPI_OB_SHIFT
argument_list|)
expr_stmt|;
name|SA_ASSERT
argument_list|(
operator|(
name|AGSA_MAX_INBOUND_Q
operator|>
name|inq
operator|)
argument_list|,
literal|"The IBQ Number is out of range."
argument_list|)
expr_stmt|;
comment|/* Remove the request from free list */
name|saLlistRemove
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|Tag
operator|=
name|pRequest
operator|->
name|HTag
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|IORequest
operator|=
operator|(
name|void
operator|*
operator|)
name|pRequest
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|agContext
operator|=
name|agContext
expr_stmt|;
name|pRequest
operator|->
name|valid
operator|=
name|agTRUE
expr_stmt|;
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SA_LL_IBQ_PROTECT
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_IBQ0_LOCK
operator|+
name|inq
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SA_LL_IBQ_PROTECT */
comment|/* Get a free inbound queue entry */
name|circularQ
operator|=
operator|&
name|saRoot
operator|->
name|inboundQueue
index|[
name|inq
index|]
expr_stmt|;
name|retVal
operator|=
name|mpiMsgFreeGet
argument_list|(
name|circularQ
argument_list|,
name|IOMB_SIZE64
argument_list|,
operator|&
name|pMessage
argument_list|)
expr_stmt|;
comment|/* if message size is too large return failure */
if|if
condition|(
name|AGSA_RC_FAILURE
operator|==
name|retVal
condition|)
block|{
ifdef|#
directive|ifdef
name|SA_LL_IBQ_PROTECT
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_IBQ0_LOCK
operator|+
name|inq
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SA_LL_IBQ_PROTECT */
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
comment|/* remove the request from IOMap */
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|Tag
operator|=
name|MARK_OFF
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|IORequest
operator|=
name|agNULL
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|agContext
operator|=
name|agNULL
expr_stmt|;
name|pRequest
operator|->
name|valid
operator|=
name|agFALSE
expr_stmt|;
comment|/* return the request to free pool */
name|saLlistIOAdd
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saFwProfile, error when get free IOMB\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_FAILURE
return|;
block|}
comment|/* return busy if inbound queue is full */
if|if
condition|(
name|AGSA_RC_BUSY
operator|==
name|retVal
condition|)
block|{
ifdef|#
directive|ifdef
name|SA_LL_IBQ_PROTECT
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_IBQ0_LOCK
operator|+
name|inq
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SA_LL_IBQ_PROTECT */
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
comment|/* remove the request from IOMap */
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|Tag
operator|=
name|MARK_OFF
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|IORequest
operator|=
name|agNULL
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|agContext
operator|=
name|agNULL
expr_stmt|;
name|pRequest
operator|->
name|valid
operator|=
name|agFALSE
expr_stmt|;
comment|/* return the request to free pool */
name|saLlistIOAdd
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saFwProfile, no more IOMB\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_BUSY
return|;
block|}
name|pPayload
operator|=
operator|(
name|agsaFwProfileIOMB_t
operator|*
operator|)
name|pMessage
expr_stmt|;
name|tcid_processor_cmd
operator|=
operator|(
operator|(
operator|(
name|fwProfileInfo
operator|->
name|tcid
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|fwProfileInfo
operator|->
name|processor
operator|)
operator|<<
literal|8
operator|)
operator||
name|fwProfileInfo
operator|->
name|cmd
operator|)
expr_stmt|;
comment|/* Prepare the FW_FLASH_UPDATE IOMB payload */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
name|pPayload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaFwProfileIOMB_t
argument_list|,
name|tag
argument_list|)
argument_list|,
name|pRequest
operator|->
name|HTag
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
name|pPayload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaFwProfileIOMB_t
argument_list|,
name|tcid_processor_cmd
argument_list|)
argument_list|,
name|tcid_processor_cmd
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
name|pPayload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaFwProfileIOMB_t
argument_list|,
name|codeStartAdd
argument_list|)
argument_list|,
name|fwProfileInfo
operator|->
name|codeStartAdd
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
name|pPayload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaFwProfileIOMB_t
argument_list|,
name|codeEndAdd
argument_list|)
argument_list|,
name|fwProfileInfo
operator|->
name|codeEndAdd
argument_list|)
expr_stmt|;
name|pPayload
operator|->
name|SGLAL
operator|=
name|fwProfileInfo
operator|->
name|agSgl
operator|.
name|sgLower
expr_stmt|;
name|pPayload
operator|->
name|SGLAH
operator|=
name|fwProfileInfo
operator|->
name|agSgl
operator|.
name|sgUpper
expr_stmt|;
name|pPayload
operator|->
name|Len
operator|=
name|fwProfileInfo
operator|->
name|agSgl
operator|.
name|len
expr_stmt|;
name|pPayload
operator|->
name|extReserved
operator|=
name|fwProfileInfo
operator|->
name|agSgl
operator|.
name|extReserved
expr_stmt|;
comment|/* fill up the reserved bytes with zero */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FWPROFILE_IOMB_RESERVED_LEN
condition|;
name|i
operator|++
control|)
block|{
name|pPayload
operator|->
name|reserved0
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/* post the IOMB to SPC */
name|ret
operator|=
name|mpiMsgProduce
argument_list|(
name|circularQ
argument_list|,
operator|(
name|void
operator|*
operator|)
name|pMessage
argument_list|,
name|MPI_CATEGORY_SAS_SATA
argument_list|,
name|OPC_INB_FW_PROFILE
argument_list|,
name|outq
argument_list|,
operator|(
name|bit8
operator|)
name|circularQ
operator|->
name|priority
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SA_LL_IBQ_PROTECT
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_IBQ0_LOCK
operator|+
name|inq
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SA_LL_IBQ_PROTECT */
if|if
condition|(
name|AGSA_RC_FAILURE
operator|==
name|ret
condition|)
block|{
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
comment|/* remove the request from IOMap */
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|Tag
operator|=
name|MARK_OFF
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|IORequest
operator|=
name|agNULL
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|agContext
operator|=
name|agNULL
expr_stmt|;
name|pRequest
operator|->
name|valid
operator|=
name|agFALSE
expr_stmt|;
comment|/* return the request to free pool */
name|saLlistIOAdd
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saFwProfile, error when post FW_PROFILE IOMB\n"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|ret
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*! \brief SPC FW Flash Update Command  *  *  This command sends FW Flash Update Command to SPC.  *  *  \param agRoot          Handles for this instance of SAS/SATA LL  *  \param agContext       Context of SPC FW Flash Update Command  *  \param queueNum        Inbound/outbound queue number  *  \param flashUpdateInfo Pointer of flash update information  *  *  \return If the MPI command is sent to SPC successfully  *          - \e AGSA_RC_SUCCESS the MPI command is successfully  *          - \e AGSA_RC_FAILURE the MPI command is failure  *  */
end_comment

begin_comment
comment|/*******************************************************************************/
end_comment

begin_function
name|GLOBAL
name|bit32
name|saFwFlashUpdate
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|agsaContext_t
modifier|*
name|agContext
parameter_list|,
name|bit32
name|queueNum
parameter_list|,
name|agsaUpdateFwFlash_t
modifier|*
name|flashUpdateInfo
parameter_list|)
block|{
name|bit32
name|ret
init|=
name|AGSA_RC_SUCCESS
decl_stmt|,
name|retVal
decl_stmt|;
name|agsaLLRoot_t
modifier|*
name|saRoot
decl_stmt|;
name|agsaIORequestDesc_t
modifier|*
name|pRequest
decl_stmt|;
name|mpiICQueue_t
modifier|*
name|circularQ
decl_stmt|;
name|void
modifier|*
name|pMessage
decl_stmt|;
name|agsaFwFlashUpdate_t
modifier|*
name|pPayload
decl_stmt|;
name|bit8
name|inq
decl_stmt|,
name|outq
decl_stmt|;
name|bit32
name|i
decl_stmt|;
name|SA_ASSERT
argument_list|(
operator|(
name|agNULL
operator|!=
name|agRoot
operator|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|agRoot
operator|==
name|agNULL
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"saFwFlashUpdate: agRoot == agNULL\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_FAILURE
return|;
block|}
name|saRoot
operator|=
operator|(
name|agsaLLRoot_t
operator|*
operator|)
operator|(
name|agRoot
operator|->
name|sdkData
operator|)
expr_stmt|;
name|SA_ASSERT
argument_list|(
operator|(
name|agNULL
operator|!=
name|saRoot
operator|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|saRoot
operator|==
name|agNULL
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"saFwFlashUpdate: saRoot == agNULL\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_FAILURE
return|;
block|}
name|smTraceFuncEnter
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|"6a"
argument_list|)
expr_stmt|;
comment|/* sanity check */
name|SA_ASSERT
argument_list|(
operator|(
name|agNULL
operator|!=
name|agRoot
operator|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* Get request from free IORequests */
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|pRequest
operator|=
operator|(
name|agsaIORequestDesc_t
operator|*
operator|)
name|saLlistIOGetHead
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|)
expr_stmt|;
comment|/* If no LL Control request entry available */
if|if
condition|(
name|agNULL
operator|==
name|pRequest
condition|)
block|{
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saFwFlashUpdate, No request from free list\n"
operator|)
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'a'
argument_list|,
literal|"6a"
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_BUSY
return|;
block|}
comment|/* If LL Control request entry avaliable */
else|else
block|{
comment|/* Assign inbound and outbound Ring Buffer */
name|inq
operator|=
call|(
name|bit8
call|)
argument_list|(
name|queueNum
operator|&
name|MPI_IB_NUM_MASK
argument_list|)
expr_stmt|;
name|outq
operator|=
call|(
name|bit8
call|)
argument_list|(
operator|(
name|queueNum
operator|&
name|MPI_OB_NUM_MASK
operator|)
operator|>>
name|MPI_OB_SHIFT
argument_list|)
expr_stmt|;
name|SA_ASSERT
argument_list|(
operator|(
name|AGSA_MAX_INBOUND_Q
operator|>
name|inq
operator|)
argument_list|,
literal|"The IBQ Number is out of range."
argument_list|)
expr_stmt|;
comment|/* Remove the request from free list */
name|saLlistIORemove
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|Tag
operator|=
name|pRequest
operator|->
name|HTag
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|IORequest
operator|=
operator|(
name|void
operator|*
operator|)
name|pRequest
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|agContext
operator|=
name|agContext
expr_stmt|;
name|pRequest
operator|->
name|valid
operator|=
name|agTRUE
expr_stmt|;
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SA_LL_IBQ_PROTECT
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_IBQ0_LOCK
operator|+
name|inq
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SA_LL_IBQ_PROTECT */
comment|/* Get a free inbound queue entry */
name|circularQ
operator|=
operator|&
name|saRoot
operator|->
name|inboundQueue
index|[
name|inq
index|]
expr_stmt|;
name|retVal
operator|=
name|mpiMsgFreeGet
argument_list|(
name|circularQ
argument_list|,
name|IOMB_SIZE64
argument_list|,
operator|&
name|pMessage
argument_list|)
expr_stmt|;
comment|/* if message size is too large return failure */
if|if
condition|(
name|AGSA_RC_FAILURE
operator|==
name|retVal
condition|)
block|{
ifdef|#
directive|ifdef
name|SA_LL_IBQ_PROTECT
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_IBQ0_LOCK
operator|+
name|inq
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SA_LL_IBQ_PROTECT */
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
comment|/* remove the request from IOMap */
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|Tag
operator|=
name|MARK_OFF
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|IORequest
operator|=
name|agNULL
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|agContext
operator|=
name|agNULL
expr_stmt|;
name|pRequest
operator|->
name|valid
operator|=
name|agFALSE
expr_stmt|;
comment|/* return the request to free pool */
name|saLlistIOAdd
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saFwFlashUpdate, error when get free IOMB\n"
operator|)
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'b'
argument_list|,
literal|"6a"
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_FAILURE
return|;
block|}
comment|/* return busy if inbound queue is full */
if|if
condition|(
name|AGSA_RC_BUSY
operator|==
name|retVal
condition|)
block|{
ifdef|#
directive|ifdef
name|SA_LL_IBQ_PROTECT
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_IBQ0_LOCK
operator|+
name|inq
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SA_LL_IBQ_PROTECT */
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
comment|/* remove the request from IOMap */
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|Tag
operator|=
name|MARK_OFF
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|IORequest
operator|=
name|agNULL
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|agContext
operator|=
name|agNULL
expr_stmt|;
name|pRequest
operator|->
name|valid
operator|=
name|agFALSE
expr_stmt|;
comment|/* return the request to free pool */
name|saLlistIOAdd
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saFwFlashUpdate, no more IOMB\n"
operator|)
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'c'
argument_list|,
literal|"6a"
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_BUSY
return|;
block|}
name|pPayload
operator|=
operator|(
name|agsaFwFlashUpdate_t
operator|*
operator|)
name|pMessage
expr_stmt|;
comment|/* Prepare the FW_FLASH_UPDATE IOMB payload */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
name|pPayload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaFwFlashUpdate_t
argument_list|,
name|tag
argument_list|)
argument_list|,
name|pRequest
operator|->
name|HTag
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
name|pPayload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaFwFlashUpdate_t
argument_list|,
name|curImageOffset
argument_list|)
argument_list|,
name|flashUpdateInfo
operator|->
name|currentImageOffset
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
name|pPayload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaFwFlashUpdate_t
argument_list|,
name|curImageLen
argument_list|)
argument_list|,
name|flashUpdateInfo
operator|->
name|currentImageLen
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
name|pPayload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaFwFlashUpdate_t
argument_list|,
name|totalImageLen
argument_list|)
argument_list|,
name|flashUpdateInfo
operator|->
name|totalImageLen
argument_list|)
expr_stmt|;
name|pPayload
operator|->
name|SGLAL
operator|=
name|flashUpdateInfo
operator|->
name|agSgl
operator|.
name|sgLower
expr_stmt|;
name|pPayload
operator|->
name|SGLAH
operator|=
name|flashUpdateInfo
operator|->
name|agSgl
operator|.
name|sgUpper
expr_stmt|;
name|pPayload
operator|->
name|Len
operator|=
name|flashUpdateInfo
operator|->
name|agSgl
operator|.
name|len
expr_stmt|;
name|pPayload
operator|->
name|extReserved
operator|=
name|flashUpdateInfo
operator|->
name|agSgl
operator|.
name|extReserved
expr_stmt|;
comment|/* fill up the reserved bytes with zero */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FWFLASH_IOMB_RESERVED_LEN
condition|;
name|i
operator|++
control|)
block|{
name|pPayload
operator|->
name|reserved0
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/* post the IOMB to SPC */
name|ret
operator|=
name|mpiMsgProduce
argument_list|(
name|circularQ
argument_list|,
operator|(
name|void
operator|*
operator|)
name|pMessage
argument_list|,
name|MPI_CATEGORY_SAS_SATA
argument_list|,
name|OPC_INB_FW_FLASH_UPDATE
argument_list|,
name|outq
argument_list|,
operator|(
name|bit8
operator|)
name|circularQ
operator|->
name|priority
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SA_LL_IBQ_PROTECT
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_IBQ0_LOCK
operator|+
name|inq
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SA_LL_IBQ_PROTECT */
if|if
condition|(
name|AGSA_RC_FAILURE
operator|==
name|ret
condition|)
block|{
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
comment|/* remove the request from IOMap */
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|Tag
operator|=
name|MARK_OFF
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|IORequest
operator|=
name|agNULL
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|agContext
operator|=
name|agNULL
expr_stmt|;
name|pRequest
operator|->
name|valid
operator|=
name|agFALSE
expr_stmt|;
comment|/* return the request to free pool */
name|saLlistIOAdd
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saFwFlashUpdate, error when post FW_FLASH_UPDATE IOMB\n"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'d'
argument_list|,
literal|"6a"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|GLOBAL
name|bit32
name|saFlashExtExecute
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|agsaContext_t
modifier|*
name|agContext
parameter_list|,
name|bit32
name|queueNum
parameter_list|,
name|agsaFlashExtExecute_t
modifier|*
name|agFlashExtExe
parameter_list|)
block|{
name|bit32
name|ret
init|=
name|AGSA_RC_SUCCESS
decl_stmt|,
name|retVal
decl_stmt|;
name|agsaLLRoot_t
modifier|*
name|saRoot
init|=
operator|(
name|agsaLLRoot_t
operator|*
operator|)
operator|(
name|agRoot
operator|->
name|sdkData
operator|)
decl_stmt|;
name|agsaIORequestDesc_t
modifier|*
name|pRequest
decl_stmt|;
name|mpiICQueue_t
modifier|*
name|circularQ
decl_stmt|;
name|void
modifier|*
name|pMessage
decl_stmt|;
name|agsaFwFlashOpExt_t
modifier|*
name|pPayload
decl_stmt|;
name|bit8
name|inq
decl_stmt|,
name|outq
decl_stmt|;
name|smTraceFuncEnter
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|"2R"
argument_list|)
expr_stmt|;
comment|/* sanity check */
name|SA_ASSERT
argument_list|(
operator|(
name|agNULL
operator|!=
name|agRoot
operator|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* Get request from free IORequests */
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|pRequest
operator|=
operator|(
name|agsaIORequestDesc_t
operator|*
operator|)
name|saLlistIOGetHead
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|)
expr_stmt|;
comment|/* If no LL Control request entry available */
if|if
condition|(
name|agNULL
operator|==
name|pRequest
condition|)
block|{
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saFlashExtExecute, No request from free list\n"
operator|)
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'a'
argument_list|,
literal|"2R"
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_BUSY
return|;
block|}
comment|/* If LL Control request entry avaliable */
else|else
block|{
comment|/* Assign inbound and outbound Ring Buffer */
name|inq
operator|=
call|(
name|bit8
call|)
argument_list|(
name|queueNum
operator|&
name|MPI_IB_NUM_MASK
argument_list|)
expr_stmt|;
name|outq
operator|=
call|(
name|bit8
call|)
argument_list|(
operator|(
name|queueNum
operator|&
name|MPI_OB_NUM_MASK
operator|)
operator|>>
name|MPI_OB_SHIFT
argument_list|)
expr_stmt|;
name|SA_ASSERT
argument_list|(
operator|(
name|AGSA_MAX_INBOUND_Q
operator|>
name|inq
operator|)
argument_list|,
literal|"The IBQ Number is out of range."
argument_list|)
expr_stmt|;
comment|/* Remove the request from free list */
name|saLlistIORemove
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|Tag
operator|=
name|pRequest
operator|->
name|HTag
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|IORequest
operator|=
operator|(
name|void
operator|*
operator|)
name|pRequest
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|agContext
operator|=
name|agContext
expr_stmt|;
name|pRequest
operator|->
name|valid
operator|=
name|agTRUE
expr_stmt|;
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SA_LL_IBQ_PROTECT
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_IBQ0_LOCK
operator|+
name|inq
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SA_LL_IBQ_PROTECT */
comment|/* Get a free inbound queue entry */
name|circularQ
operator|=
operator|&
name|saRoot
operator|->
name|inboundQueue
index|[
name|inq
index|]
expr_stmt|;
name|retVal
operator|=
name|mpiMsgFreeGet
argument_list|(
name|circularQ
argument_list|,
name|IOMB_SIZE64
argument_list|,
operator|&
name|pMessage
argument_list|)
expr_stmt|;
comment|/* if message size is too large return failure */
if|if
condition|(
name|AGSA_RC_FAILURE
operator|==
name|retVal
condition|)
block|{
ifdef|#
directive|ifdef
name|SA_LL_IBQ_PROTECT
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_IBQ0_LOCK
operator|+
name|inq
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SA_LL_IBQ_PROTECT */
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
comment|/* remove the request from IOMap */
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|Tag
operator|=
name|MARK_OFF
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|IORequest
operator|=
name|agNULL
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|agContext
operator|=
name|agNULL
expr_stmt|;
name|pRequest
operator|->
name|valid
operator|=
name|agFALSE
expr_stmt|;
comment|/* return the request to free pool */
name|saLlistIOAdd
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saFlashExtExecute, error when get free IOMB\n"
operator|)
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'b'
argument_list|,
literal|"2R"
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_FAILURE
return|;
block|}
comment|/* return busy if inbound queue is full */
if|if
condition|(
name|AGSA_RC_BUSY
operator|==
name|retVal
condition|)
block|{
ifdef|#
directive|ifdef
name|SA_LL_IBQ_PROTECT
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_IBQ0_LOCK
operator|+
name|inq
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SA_LL_IBQ_PROTECT */
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
comment|/* remove the request from IOMap */
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|Tag
operator|=
name|MARK_OFF
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|IORequest
operator|=
name|agNULL
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|agContext
operator|=
name|agNULL
expr_stmt|;
name|pRequest
operator|->
name|valid
operator|=
name|agFALSE
expr_stmt|;
comment|/* return the request to free pool */
name|saLlistIOAdd
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|SA_DBG3
argument_list|(
operator|(
literal|"saFlashExtExecute, no more IOMB\n"
operator|)
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'c'
argument_list|,
literal|"2R"
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_BUSY
return|;
block|}
name|pPayload
operator|=
operator|(
name|agsaFwFlashOpExt_t
operator|*
operator|)
name|pMessage
expr_stmt|;
name|si_memset
argument_list|(
name|pPayload
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|agsaFwFlashOpExt_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Prepare the FW_FLASH_UPDATE IOMB payload */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
name|pPayload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaFwFlashOpExt_t
argument_list|,
name|tag
argument_list|)
argument_list|,
name|pRequest
operator|->
name|HTag
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
name|pPayload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaFwFlashOpExt_t
argument_list|,
name|Command
argument_list|)
argument_list|,
name|agFlashExtExe
operator|->
name|command
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
name|pPayload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaFwFlashOpExt_t
argument_list|,
name|PartOffset
argument_list|)
argument_list|,
name|agFlashExtExe
operator|->
name|partOffset
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
name|pPayload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaFwFlashOpExt_t
argument_list|,
name|DataLength
argument_list|)
argument_list|,
name|agFlashExtExe
operator|->
name|dataLen
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
name|pPayload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaFwFlashOpExt_t
argument_list|,
name|SGLAL
argument_list|)
argument_list|,
name|agFlashExtExe
operator|->
name|agSgl
operator|->
name|sgLower
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
name|pPayload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaFwFlashOpExt_t
argument_list|,
name|SGLAH
argument_list|)
argument_list|,
name|agFlashExtExe
operator|->
name|agSgl
operator|->
name|sgUpper
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
name|pPayload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaFwFlashOpExt_t
argument_list|,
name|Len
argument_list|)
argument_list|,
name|agFlashExtExe
operator|->
name|agSgl
operator|->
name|len
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
name|pPayload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaFwFlashOpExt_t
argument_list|,
name|E_sgl
argument_list|)
argument_list|,
name|agFlashExtExe
operator|->
name|agSgl
operator|->
name|extReserved
argument_list|)
expr_stmt|;
comment|/* post the IOMB to SPC */
name|ret
operator|=
name|mpiMsgProduce
argument_list|(
name|circularQ
argument_list|,
operator|(
name|void
operator|*
operator|)
name|pMessage
argument_list|,
name|MPI_CATEGORY_SAS_SATA
argument_list|,
name|OPC_INB_FLASH_OP_EXT
argument_list|,
name|outq
argument_list|,
operator|(
name|bit8
operator|)
name|circularQ
operator|->
name|priority
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SA_LL_IBQ_PROTECT
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_IBQ0_LOCK
operator|+
name|inq
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SA_LL_IBQ_PROTECT */
if|if
condition|(
name|AGSA_RC_FAILURE
operator|==
name|ret
condition|)
block|{
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
comment|/* remove the request from IOMap */
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|Tag
operator|=
name|MARK_OFF
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|IORequest
operator|=
name|agNULL
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|agContext
operator|=
name|agNULL
expr_stmt|;
name|pRequest
operator|->
name|valid
operator|=
name|agFALSE
expr_stmt|;
comment|/* return the request to free pool */
name|saLlistIOAdd
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saFlashExtExecute, error when post FW_FLASH_UPDATE IOMB\n"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'d'
argument_list|,
literal|"2R"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SPC_ENABLE_PROFILE
end_ifdef

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*! \brief SPC FW_PROFILE Respond  *  *  This command sends FW Profile Status to TD layer.  *  *  \param agRoot       Handles for this instance of SAS/SATA LL  *  \param payload      FW download response payload  *  *  \return If the MPI command is sent to SPC successfully  *          - \e AGSA_RC_SUCCESS the MPI command is successfully  *          - \e AGSA_RC_FAILURE the MPI command is failure  *  */
end_comment

begin_comment
comment|/*******************************************************************************/
end_comment

begin_function
name|GLOBAL
name|bit32
name|mpiFwProfileRsp
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|agsaFwProfileRsp_t
modifier|*
name|payload
parameter_list|)
block|{
name|bit32
name|ret
init|=
name|AGSA_RC_SUCCESS
decl_stmt|;
name|agsaLLRoot_t
modifier|*
name|saRoot
init|=
operator|(
name|agsaLLRoot_t
operator|*
operator|)
operator|(
name|agRoot
operator|->
name|sdkData
operator|)
decl_stmt|;
name|agsaIORequestDesc_t
modifier|*
name|pRequest
decl_stmt|;
name|agsaContext_t
modifier|*
name|agContext
decl_stmt|;
name|bit32
name|status
decl_stmt|,
name|tag
decl_stmt|,
name|len
decl_stmt|;
comment|/* get request from IOMap */
name|OSSA_READ_LE_32
argument_list|(
name|AGROOT
argument_list|,
operator|&
name|tag
argument_list|,
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaFwProfileRsp_t
argument_list|,
name|tag
argument_list|)
argument_list|)
expr_stmt|;
name|OSSA_READ_LE_32
argument_list|(
name|AGROOT
argument_list|,
operator|&
name|status
argument_list|,
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaFwProfileRsp_t
argument_list|,
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|OSSA_READ_LE_32
argument_list|(
name|AGROOT
argument_list|,
operator|&
name|len
argument_list|,
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaFwProfileRsp_t
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|pRequest
operator|=
name|saRoot
operator|->
name|IOMap
index|[
name|tag
index|]
operator|.
name|IORequest
expr_stmt|;
if|if
condition|(
name|agNULL
operator|==
name|pRequest
condition|)
block|{
comment|/* remove the request from IOMap */
name|saRoot
operator|->
name|IOMap
index|[
name|tag
index|]
operator|.
name|Tag
operator|=
name|MARK_OFF
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|tag
index|]
operator|.
name|IORequest
operator|=
name|agNULL
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"mpiFwProfileRsp: the request is NULL. Tag=%x\n"
operator|,
name|tag
operator|)
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_FAILURE
return|;
block|}
name|agContext
operator|=
name|saRoot
operator|->
name|IOMap
index|[
name|tag
index|]
operator|.
name|agContext
expr_stmt|;
comment|/* remove the request from IOMap */
name|saRoot
operator|->
name|IOMap
index|[
name|tag
index|]
operator|.
name|Tag
operator|=
name|MARK_OFF
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|tag
index|]
operator|.
name|IORequest
operator|=
name|agNULL
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|tag
index|]
operator|.
name|agContext
operator|=
name|agNULL
expr_stmt|;
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pRequest
operator|->
name|valid
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"mpiPortControlRsp: pRequest->valid %d not set\n"
operator|,
name|pRequest
operator|->
name|valid
operator|)
argument_list|)
expr_stmt|;
block|}
name|SA_ASSERT
argument_list|(
operator|(
name|pRequest
operator|->
name|valid
operator|)
argument_list|,
literal|"pRequest->valid"
argument_list|)
expr_stmt|;
name|pRequest
operator|->
name|valid
operator|=
name|agFALSE
expr_stmt|;
comment|/* return the request to free pool */
name|saLlistIOAdd
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|ossaFwProfileCB
argument_list|(
name|agRoot
argument_list|,
name|agContext
argument_list|,
name|status
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*! \brief SPC FW_FLASH_UPDATE Respond  *  *  This command sends FW Flash Update Status to TD layer.  *  *  \param agRoot       Handles for this instance of SAS/SATA LL  *  \param payload      FW download response payload  *  *  \return If the MPI command is sent to SPC successfully  *          - \e AGSA_RC_SUCCESS the MPI command is successfully  *          - \e AGSA_RC_FAILURE the MPI command is failure  *  */
end_comment

begin_comment
comment|/*******************************************************************************/
end_comment

begin_function
name|GLOBAL
name|bit32
name|mpiFwFlashUpdateRsp
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|agsaFwFlashUpdateRsp_t
modifier|*
name|payload
parameter_list|)
block|{
name|bit32
name|ret
init|=
name|AGSA_RC_SUCCESS
decl_stmt|;
name|agsaLLRoot_t
modifier|*
name|saRoot
init|=
operator|(
name|agsaLLRoot_t
operator|*
operator|)
operator|(
name|agRoot
operator|->
name|sdkData
operator|)
decl_stmt|;
name|agsaIORequestDesc_t
modifier|*
name|pRequest
decl_stmt|;
name|agsaContext_t
modifier|*
name|agContext
decl_stmt|;
name|bit32
name|status
decl_stmt|,
name|tag
decl_stmt|;
name|smTraceFuncEnter
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|"6b"
argument_list|)
expr_stmt|;
comment|/* get request from IOMap */
name|OSSA_READ_LE_32
argument_list|(
name|AGROOT
argument_list|,
operator|&
name|tag
argument_list|,
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaFwFlashUpdateRsp_t
argument_list|,
name|tag
argument_list|)
argument_list|)
expr_stmt|;
name|OSSA_READ_LE_32
argument_list|(
name|AGROOT
argument_list|,
operator|&
name|status
argument_list|,
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaFwFlashUpdateRsp_t
argument_list|,
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|pRequest
operator|=
name|saRoot
operator|->
name|IOMap
index|[
name|tag
index|]
operator|.
name|IORequest
expr_stmt|;
name|agContext
operator|=
name|saRoot
operator|->
name|IOMap
index|[
name|tag
index|]
operator|.
name|agContext
expr_stmt|;
comment|/* remove the request from IOMap */
name|saRoot
operator|->
name|IOMap
index|[
name|tag
index|]
operator|.
name|Tag
operator|=
name|MARK_OFF
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|tag
index|]
operator|.
name|IORequest
operator|=
name|agNULL
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|tag
index|]
operator|.
name|agContext
operator|=
name|agNULL
expr_stmt|;
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|SA_ASSERT
argument_list|(
operator|(
name|pRequest
operator|->
name|valid
operator|)
argument_list|,
literal|"pRequest->valid"
argument_list|)
expr_stmt|;
name|pRequest
operator|->
name|valid
operator|=
name|agFALSE
expr_stmt|;
comment|/* return the request to free pool */
if|if
condition|(
name|saLlistIOGetCount
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeReservedRequests
operator|)
argument_list|)
operator|<
name|SA_RESERVED_REQUEST_COUNT
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"mpiFwFlashUpdateRsp: saving pRequest (%p) for later use\n"
operator|,
name|pRequest
operator|)
argument_list|)
expr_stmt|;
name|saLlistIOAdd
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeReservedRequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* return the request to free pool */
name|saLlistIOAdd
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
block|}
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|>
literal|1
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"mpiFwFlashUpdateRsp: status = 0x%x\n"
operator|,
name|status
operator|)
argument_list|)
expr_stmt|;
block|}
name|ossaFwFlashUpdateCB
argument_list|(
name|agRoot
argument_list|,
name|agContext
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'a'
argument_list|,
literal|"6b"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|GLOBAL
name|bit32
name|mpiFwExtFlashUpdateRsp
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|agsaFwFlashOpExtRsp_t
modifier|*
name|payload
parameter_list|)
block|{
name|bit32
name|ret
init|=
name|AGSA_RC_SUCCESS
decl_stmt|;
name|agsaLLRoot_t
modifier|*
name|saRoot
init|=
operator|(
name|agsaLLRoot_t
operator|*
operator|)
operator|(
name|agRoot
operator|->
name|sdkData
operator|)
decl_stmt|;
name|agsaIORequestDesc_t
modifier|*
name|pRequest
decl_stmt|;
name|agsaContext_t
modifier|*
name|agContext
decl_stmt|;
name|agsaFlashExtResponse_t
name|FlashExtRsp
decl_stmt|;
name|bit32
name|Command
decl_stmt|,
name|Status
decl_stmt|,
name|tag
decl_stmt|;
name|smTraceFuncEnter
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|"2T"
argument_list|)
expr_stmt|;
comment|/* get request from IOMap */
name|OSSA_READ_LE_32
argument_list|(
name|AGROOT
argument_list|,
operator|&
name|tag
argument_list|,
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaFwFlashOpExtRsp_t
argument_list|,
name|tag
argument_list|)
argument_list|)
expr_stmt|;
name|OSSA_READ_LE_32
argument_list|(
name|AGROOT
argument_list|,
operator|&
name|Command
argument_list|,
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaFwFlashOpExtRsp_t
argument_list|,
name|Command
argument_list|)
argument_list|)
expr_stmt|;
name|OSSA_READ_LE_32
argument_list|(
name|AGROOT
argument_list|,
operator|&
name|Status
argument_list|,
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaFwFlashOpExtRsp_t
argument_list|,
name|Status
argument_list|)
argument_list|)
expr_stmt|;
name|OSSA_READ_LE_32
argument_list|(
name|AGROOT
argument_list|,
operator|&
name|FlashExtRsp
operator|.
name|epart_sect_size
argument_list|,
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaFwFlashOpExtRsp_t
argument_list|,
name|Epart_Size
argument_list|)
argument_list|)
expr_stmt|;
name|OSSA_READ_LE_32
argument_list|(
name|AGROOT
argument_list|,
operator|&
name|FlashExtRsp
operator|.
name|epart_size
argument_list|,
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaFwFlashOpExtRsp_t
argument_list|,
name|EpartSectSize
argument_list|)
argument_list|)
expr_stmt|;
name|pRequest
operator|=
name|saRoot
operator|->
name|IOMap
index|[
name|tag
index|]
operator|.
name|IORequest
expr_stmt|;
name|agContext
operator|=
name|saRoot
operator|->
name|IOMap
index|[
name|tag
index|]
operator|.
name|agContext
expr_stmt|;
comment|/* remove the request from IOMap */
name|saRoot
operator|->
name|IOMap
index|[
name|tag
index|]
operator|.
name|Tag
operator|=
name|MARK_OFF
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|tag
index|]
operator|.
name|IORequest
operator|=
name|agNULL
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|tag
index|]
operator|.
name|agContext
operator|=
name|agNULL
expr_stmt|;
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|SA_ASSERT
argument_list|(
operator|(
name|pRequest
operator|->
name|valid
operator|)
argument_list|,
literal|"pRequest->valid"
argument_list|)
expr_stmt|;
name|pRequest
operator|->
name|valid
operator|=
name|agFALSE
expr_stmt|;
comment|/* return the request to free pool */
if|if
condition|(
name|saLlistIOGetCount
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeReservedRequests
operator|)
argument_list|)
operator|<
name|SA_RESERVED_REQUEST_COUNT
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"mpiFwExtFlashUpdateRsp: saving pRequest (%p) for later use\n"
operator|,
name|pRequest
operator|)
argument_list|)
expr_stmt|;
name|saLlistIOAdd
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeReservedRequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* return the request to free pool */
name|saLlistIOAdd
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
block|}
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
if|if
condition|(
name|Status
operator|>
literal|1
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"mpiFwExtFlashUpdateRsp: status = 0x%x\n"
operator|,
name|Status
operator|)
argument_list|)
expr_stmt|;
block|}
name|ossaFlashExtExecuteCB
argument_list|(
name|agRoot
argument_list|,
name|agContext
argument_list|,
name|Status
argument_list|,
name|Command
argument_list|,
operator|&
name|FlashExtRsp
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'a'
argument_list|,
literal|"2T"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*! \brief SPC Get Controller Information Command  *  *  This command sends Get Controller Information Command to SPC.  *  *  \param agRoot         Handles for this instance of SAS/SATA LL  *  \param controllerInfo Controller Information  *  *  \return If the MPI command is sent to SPC successfully  *          - \e AGSA_RC_SUCCESS the MPI command is successfully  *          - \e AGSA_RC_FAILURE the MPI command is failure  *  */
end_comment

begin_comment
comment|/*******************************************************************************/
end_comment

begin_function
name|GLOBAL
name|bit32
name|saGetControllerInfo
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|agsaControllerInfo_t
modifier|*
name|controllerInfo
parameter_list|)
block|{
name|bit32
name|ret
init|=
name|AGSA_RC_SUCCESS
decl_stmt|;
name|bit32
name|max_wait_time
decl_stmt|;
name|bit32
name|max_wait_count
decl_stmt|;
name|bit32
name|ContrlCapFlag
decl_stmt|,
name|MSGUCfgTblBase
decl_stmt|,
name|CfgTblDWIdx
decl_stmt|;
name|bit32
name|value
init|=
literal|0
decl_stmt|,
name|value1
init|=
literal|0
decl_stmt|;
name|bit8
name|pcibar
decl_stmt|;
if|if
condition|(
name|agNULL
operator|!=
name|agRoot
operator|->
name|sdkData
condition|)
block|{
name|smTraceFuncEnter
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|"6e"
argument_list|)
expr_stmt|;
block|}
comment|/* clean the structure */
name|si_memset
argument_list|(
name|controllerInfo
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|agsaControllerInfo_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|smIS_SPC6V
argument_list|(
name|agRoot
argument_list|)
condition|)
block|{
name|controllerInfo
operator|->
name|sdkInterfaceRev
operator|=
name|STSDK_LL_INTERFACE_VERSION
expr_stmt|;
name|controllerInfo
operator|->
name|sdkRevision
operator|=
name|STSDK_LL_VERSION
expr_stmt|;
name|controllerInfo
operator|->
name|hwRevision
operator|=
operator|(
name|ossaHwRegReadConfig32
argument_list|(
name|agRoot
argument_list|,
literal|8
argument_list|)
operator|&
literal|0xFF
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|smIS_SPC12V
argument_list|(
name|agRoot
argument_list|)
condition|)
block|{
name|controllerInfo
operator|->
name|sdkInterfaceRev
operator|=
name|STSDK_LL_12G_INTERFACE_VERSION
expr_stmt|;
name|controllerInfo
operator|->
name|sdkRevision
operator|=
name|STSDK_LL_12G_VERSION
expr_stmt|;
name|controllerInfo
operator|->
name|hwRevision
operator|=
operator|(
name|ossaHwRegReadConfig32
argument_list|(
name|agRoot
argument_list|,
literal|8
argument_list|)
operator|&
literal|0xFF
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|smIS_SPC
argument_list|(
name|agRoot
argument_list|)
condition|)
block|{
name|controllerInfo
operator|->
name|hwRevision
operator|=
name|SPC_READ_DEV_REV
expr_stmt|;
name|controllerInfo
operator|->
name|sdkInterfaceRev
operator|=
name|MATCHING_SPC_FW_VERSION
expr_stmt|;
name|controllerInfo
operator|->
name|sdkRevision
operator|=
name|STSDK_LL_SPC_VERSION
expr_stmt|;
block|}
else|else
block|{
name|controllerInfo
operator|->
name|hwRevision
operator|=
operator|(
name|ossaHwRegReadConfig32
argument_list|(
name|agRoot
argument_list|,
literal|8
argument_list|)
operator|&
literal|0xFF
operator|)
expr_stmt|;
block|}
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetControllerInfo: SCRATCH_PAD0 value = 0x%x\n"
operator|,
name|siHalRegReadExt
argument_list|(
name|agRoot
argument_list|,
name|GEN_MSGU_SCRATCH_PAD_0
argument_list|,
name|MSGU_SCRATCH_PAD_0
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetControllerInfo: SCRATCH_PAD1 value = 0x%x\n"
operator|,
name|siHalRegReadExt
argument_list|(
name|agRoot
argument_list|,
name|GEN_MSGU_SCRATCH_PAD_1
argument_list|,
name|MSGU_SCRATCH_PAD_1
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetControllerInfo: SCRATCH_PAD2 value = 0x%x\n"
operator|,
name|siHalRegReadExt
argument_list|(
name|agRoot
argument_list|,
name|GEN_MSGU_SCRATCH_PAD_2
argument_list|,
name|MSGU_SCRATCH_PAD_2
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetControllerInfo: SCRATCH_PAD3 value = 0x%x\n"
operator|,
name|siHalRegReadExt
argument_list|(
name|agRoot
argument_list|,
name|GEN_MSGU_SCRATCH_PAD_3
argument_list|,
name|MSGU_SCRATCH_PAD_3
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetControllerInfo: SCRATCH_PAD3 value = 0x%x\n"
operator|,
name|siHalRegReadExt
argument_list|(
name|agRoot
argument_list|,
name|GEN_MSGU_SCRATCH_PAD_3
argument_list|,
name|MSGU_SCRATCH_PAD_3
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|siHalRegReadExt
argument_list|(
name|agRoot
argument_list|,
name|GEN_MSGU_SCRATCH_PAD_0
argument_list|,
name|MSGU_SCRATCH_PAD_0
argument_list|)
operator|==
literal|0xFFFFFFFF
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetControllerInfo:AGSA_RC_FAILURE SCRATCH_PAD0 value = 0x%x\n"
operator|,
name|siHalRegReadExt
argument_list|(
name|agRoot
argument_list|,
name|GEN_MSGU_SCRATCH_PAD_0
argument_list|,
name|MSGU_SCRATCH_PAD_0
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_FAILURE
return|;
block|}
if|if
condition|(
name|siHalRegReadExt
argument_list|(
name|agRoot
argument_list|,
name|GEN_MSGU_SCRATCH_PAD_0
argument_list|,
name|MSGU_SCRATCH_PAD_0
argument_list|)
operator|==
literal|0xFFFFFFFF
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetControllerInfo:AGSA_RC_FAILURE SCRATCH_PAD0 value = 0x%x\n"
operator|,
name|siHalRegReadExt
argument_list|(
name|agRoot
argument_list|,
name|GEN_MSGU_SCRATCH_PAD_0
argument_list|,
name|MSGU_SCRATCH_PAD_0
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_FAILURE
return|;
block|}
if|if
condition|(
name|SCRATCH_PAD1_V_ERROR_STATE
argument_list|(
name|siHalRegReadExt
argument_list|(
name|agRoot
argument_list|,
name|GEN_MSGU_SCRATCH_PAD_1
argument_list|,
name|MSGU_SCRATCH_PAD_1
argument_list|)
argument_list|)
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetControllerInfo: SCRATCH_PAD1 (0x%x) in error state ila %d raae %d Iop0 %d Iop1 %d\n"
operator|,
name|siHalRegReadExt
argument_list|(
name|agRoot
argument_list|,
name|GEN_MSGU_SCRATCH_PAD_1
argument_list|,
name|MSGU_SCRATCH_PAD_1
argument_list|)
operator|,
operator|(
name|SCRATCH_PAD1_V_ILA_ERROR_STATE
argument_list|(
name|siHalRegReadExt
argument_list|(
name|agRoot
argument_list|,
name|GEN_MSGU_SCRATCH_PAD_1
argument_list|,
name|MSGU_SCRATCH_PAD_1
argument_list|)
argument_list|)
condition|?
literal|1
else|:
literal|0
operator|)
operator|,
operator|(
name|SCRATCH_PAD1_V_RAAE_ERROR_STATE
argument_list|(
name|siHalRegReadExt
argument_list|(
name|agRoot
argument_list|,
name|GEN_MSGU_SCRATCH_PAD_1
argument_list|,
name|MSGU_SCRATCH_PAD_1
argument_list|)
argument_list|)
condition|?
literal|1
else|:
literal|0
operator|)
operator|,
operator|(
name|SCRATCH_PAD1_V_IOP0_ERROR_STATE
argument_list|(
name|siHalRegReadExt
argument_list|(
name|agRoot
argument_list|,
name|GEN_MSGU_SCRATCH_PAD_1
argument_list|,
name|MSGU_SCRATCH_PAD_1
argument_list|)
argument_list|)
condition|?
literal|1
else|:
literal|0
operator|)
operator|,
operator|(
name|SCRATCH_PAD1_V_IOP1_ERROR_STATE
argument_list|(
name|siHalRegReadExt
argument_list|(
name|agRoot
argument_list|,
name|GEN_MSGU_SCRATCH_PAD_1
argument_list|,
name|MSGU_SCRATCH_PAD_1
argument_list|)
argument_list|)
condition|?
literal|1
else|:
literal|0
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|smIS_SPC
argument_list|(
name|agRoot
argument_list|)
condition|)
block|{
comment|/* check HDA mode */
name|value
operator|=
name|ossaHwRegReadExt
argument_list|(
name|agRoot
argument_list|,
name|PCIBAR3
argument_list|,
name|HDA_RSP_OFFSET1MB
operator|+
name|HDA_CMD_CODE_OFFSET
argument_list|)
operator|&
name|HDA_STATUS_BITS
expr_stmt|;
if|if
condition|(
name|value
operator|==
name|BOOTTLOADERHDA_IDLE
condition|)
block|{
comment|/* HDA mode */
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetControllerInfo: HDA mode, value = 0x%x\n"
operator|,
name|value
operator|)
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_HDA_NO_FW_RUNNING
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|siHalRegReadExt
argument_list|(
name|agRoot
argument_list|,
name|GEN_MSGU_SCRATCH_PAD_1
argument_list|,
name|MSGU_SCRATCH_PAD_1
argument_list|)
operator|&
name|SCRATCH_PAD1_V_RESERVED
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetControllerInfo: Warning SCRATCH_PAD1 reserved bits set value = 0x%x\n"
operator|,
name|siHalRegReadExt
argument_list|(
name|agRoot
argument_list|,
name|GEN_MSGU_SCRATCH_PAD_1
argument_list|,
name|MSGU_SCRATCH_PAD_1
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|si_check_V_HDA
argument_list|(
name|agRoot
argument_list|)
condition|)
block|{
comment|/*  Check HDA */
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetControllerInfo: HDA mode AGSA_RC_HDA_NO_FW_RUNNING\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_HDA_NO_FW_RUNNING
return|;
block|}
block|}
comment|/* checking the fw AAP and IOP in ready state */
name|max_wait_time
operator|=
name|WAIT_SECONDS
argument_list|(
name|gWait_2
argument_list|)
expr_stmt|;
comment|/* 2 sec timeout */
name|max_wait_count
operator|=
name|MAKE_MODULO
argument_list|(
name|max_wait_time
argument_list|,
name|WAIT_INCREMENT
argument_list|)
expr_stmt|;
comment|/* wait until scratch pad 1 and 2 registers in ready state  */
if|if
condition|(
name|smIS_SPCV
argument_list|(
name|agRoot
argument_list|)
condition|)
block|{
do|do
block|{
name|ossaStallThread
argument_list|(
name|agRoot
argument_list|,
name|WAIT_INCREMENT
argument_list|)
expr_stmt|;
name|value
operator|=
name|siHalRegReadExt
argument_list|(
name|agRoot
argument_list|,
name|GEN_MSGU_SCRATCH_PAD_1
argument_list|,
name|MSGU_SCRATCH_PAD_1
argument_list|)
expr_stmt|;
name|value1
operator|=
name|siHalRegReadExt
argument_list|(
name|agRoot
argument_list|,
name|GEN_MSGU_SCRATCH_PAD_2
argument_list|,
name|MSGU_SCRATCH_PAD_2
argument_list|)
expr_stmt|;
if|if
condition|(
name|smIS_SPCV
argument_list|(
name|agRoot
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|value
operator|&
name|SCRATCH_PAD1_V_RESERVED
operator|)
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetControllerInfo: V reserved SCRATCH_PAD1 value = 0x%x (0x%x)\n"
operator|,
name|value
operator|,
name|SCRATCH_PAD1_V_RESERVED
operator|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|AGSA_RC_FW_NOT_IN_READY_STATE
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|(
name|max_wait_count
operator|-=
name|WAIT_INCREMENT
operator|)
operator|==
literal|0
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetControllerInfo:  timeout SCRATCH_PAD1_V_READY !! SCRATCH_PAD1/2 value = 0x%x 0x%x\n"
operator|,
name|value
operator|,
name|value1
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
operator|(
operator|(
name|value
operator|&
name|SCRATCH_PAD1_V_READY
operator|)
operator|!=
name|SCRATCH_PAD1_V_READY
operator|)
operator|||
operator|(
name|value
operator|==
literal|0xffffffff
operator|)
condition|)
do|;
block|}
else|else
block|{
do|do
block|{
name|ossaStallThread
argument_list|(
name|agRoot
argument_list|,
name|WAIT_INCREMENT
argument_list|)
expr_stmt|;
name|value
operator|=
name|siHalRegReadExt
argument_list|(
name|agRoot
argument_list|,
name|GEN_MSGU_SCRATCH_PAD_1
argument_list|,
name|MSGU_SCRATCH_PAD_1
argument_list|)
expr_stmt|;
comment|/* checking bit 4 to 7 for reserved in case we get 0xFFFFFFFF */
if|if
condition|(
name|value
operator|&
name|SCRATCH_PAD1_RESERVED
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetControllerInfo: SCRATCH_PAD1 value = 0x%x\n"
operator|,
name|value
operator|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|AGSA_RC_FW_NOT_IN_READY_STATE
expr_stmt|;
break|break;
block|}
name|value1
operator|=
name|siHalRegReadExt
argument_list|(
name|agRoot
argument_list|,
name|GEN_MSGU_SCRATCH_PAD_2
argument_list|,
name|MSGU_SCRATCH_PAD_2
argument_list|)
expr_stmt|;
comment|/* checking bit 4 to 7 for reserved in case we get 0xFFFFFFFF */
if|if
condition|(
name|value1
operator|&
name|SCRATCH_PAD2_RESERVED
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetControllerInfo: SCRATCH_PAD2 value = 0x%x\n"
operator|,
name|value1
operator|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|AGSA_RC_FW_NOT_IN_READY_STATE
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|max_wait_count
operator|-=
name|WAIT_INCREMENT
operator|)
operator|==
literal|0
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetControllerInfo: Timeout!! SCRATCH_PAD1/2 value = 0x%x 0x%x\n"
operator|,
name|value
operator|,
name|value1
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
operator|(
operator|(
name|value
operator|&
name|SCRATCH_PAD_STATE_MASK
operator|)
operator|!=
name|SCRATCH_PAD1_RDY
operator|)
operator|||
operator|(
operator|(
name|value1
operator|&
name|SCRATCH_PAD_STATE_MASK
operator|)
operator|!=
name|SCRATCH_PAD2_RDY
operator|)
condition|)
do|;
block|}
if|if
condition|(
operator|!
name|max_wait_count
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetControllerInfo: timeout failure\n"
operator|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|AGSA_RC_FW_NOT_IN_READY_STATE
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|==
name|AGSA_RC_SUCCESS
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetControllerInfo: FW Ready, SCRATCH_PAD1/2 value = 0x%x 0x%x\n"
operator|,
name|value
operator|,
name|value1
operator|)
argument_list|)
expr_stmt|;
comment|/* read scratch pad0 to get PCI BAR and offset of configuration table */
name|MSGUCfgTblBase
operator|=
name|siHalRegReadExt
argument_list|(
name|agRoot
argument_list|,
name|GEN_MSGU_SCRATCH_PAD_0
argument_list|,
name|MSGU_SCRATCH_PAD_0
argument_list|)
expr_stmt|;
comment|/* get offset */
name|CfgTblDWIdx
operator|=
name|MSGUCfgTblBase
operator|&
name|SCRATCH_PAD0_OFFSET_MASK
expr_stmt|;
comment|/* get PCI BAR */
name|MSGUCfgTblBase
operator|=
operator|(
name|MSGUCfgTblBase
operator|&
name|SCRATCH_PAD0_BAR_MASK
operator|)
operator|>>
name|SHIFT26
expr_stmt|;
comment|/* convert the PCI BAR to logical bar number */
name|pcibar
operator|=
operator|(
name|bit8
operator|)
name|mpiGetPCIBarIndex
argument_list|(
name|agRoot
argument_list|,
name|MSGUCfgTblBase
argument_list|)
expr_stmt|;
comment|/* get controller information */
name|controllerInfo
operator|->
name|signature
operator|=
name|ossaHwRegReadExt
argument_list|(
name|agRoot
argument_list|,
name|pcibar
argument_list|,
operator|(
name|bit32
operator|)
name|CfgTblDWIdx
argument_list|)
expr_stmt|;
name|controllerInfo
operator|->
name|fwInterfaceRev
operator|=
name|ossaHwRegReadExt
argument_list|(
name|agRoot
argument_list|,
name|pcibar
argument_list|,
operator|(
name|bit32
operator|)
name|CfgTblDWIdx
operator|+
name|MAIN_INTERFACE_REVISION
argument_list|)
expr_stmt|;
name|controllerInfo
operator|->
name|fwRevision
operator|=
name|ossaHwRegReadExt
argument_list|(
name|agRoot
argument_list|,
name|pcibar
argument_list|,
operator|(
name|bit32
operator|)
name|CfgTblDWIdx
operator|+
name|MAIN_FW_REVISION
argument_list|)
expr_stmt|;
name|controllerInfo
operator|->
name|ilaRevision
operator|=
name|ossaHwRegReadExt
argument_list|(
name|agRoot
argument_list|,
name|pcibar
argument_list|,
operator|(
name|bit32
operator|)
name|CfgTblDWIdx
operator|+
name|MAIN_ILAT_ILAV_ILASMRN_ILAMRN_ILAMJN
argument_list|)
expr_stmt|;
name|controllerInfo
operator|->
name|maxPendingIO
operator|=
name|ossaHwRegReadExt
argument_list|(
name|agRoot
argument_list|,
name|pcibar
argument_list|,
operator|(
name|bit32
operator|)
name|CfgTblDWIdx
operator|+
name|MAIN_MAX_OUTSTANDING_IO_OFFSET
argument_list|)
expr_stmt|;
name|controllerInfo
operator|->
name|maxDevices
operator|=
operator|(
name|ossaHwRegReadExt
argument_list|(
name|agRoot
argument_list|,
name|pcibar
argument_list|,
operator|(
name|bit32
operator|)
name|CfgTblDWIdx
operator|+
name|MAIN_MAX_SGL_OFFSET
argument_list|)
operator|&
name|MAIN_MAX_DEV_BITS
operator|)
expr_stmt|;
name|controllerInfo
operator|->
name|maxDevices
operator|=
name|controllerInfo
operator|->
name|maxDevices
operator|>>
name|SHIFT16
expr_stmt|;
name|controllerInfo
operator|->
name|maxSgElements
operator|=
operator|(
name|ossaHwRegReadExt
argument_list|(
name|agRoot
argument_list|,
name|pcibar
argument_list|,
operator|(
name|bit32
operator|)
name|CfgTblDWIdx
operator|+
name|MAIN_MAX_SGL_OFFSET
argument_list|)
operator|&
name|MAIN_MAX_SGL_BITS
operator|)
expr_stmt|;
if|if
condition|(
name|smIS_SPC
argument_list|(
name|agRoot
argument_list|)
condition|)
block|{
name|SA_DBG2
argument_list|(
operator|(
literal|"saGetControllerInfo: LINK_CTRL 0x%08x Speed 0x%X Lanes 0x%X \n"
operator|,
name|ossaHwRegReadConfig32
argument_list|(
name|agRoot
argument_list|,
literal|128
argument_list|)
operator|,
operator|(
operator|(
name|ossaHwRegReadConfig32
argument_list|(
name|agRoot
argument_list|,
literal|128
argument_list|)
operator|&
literal|0x000F0000
operator|)
operator|>>
literal|16
operator|)
operator|,
operator|(
operator|(
name|ossaHwRegReadConfig32
argument_list|(
name|agRoot
argument_list|,
literal|128
argument_list|)
operator|&
literal|0x0FF00000
operator|)
operator|>>
literal|20
operator|)
operator|)
argument_list|)
expr_stmt|;
name|controllerInfo
operator|->
name|PCILinkRate
operator|=
operator|(
operator|(
name|ossaHwRegReadConfig32
argument_list|(
name|agRoot
argument_list|,
literal|128
argument_list|)
operator|&
literal|0x000F0000
operator|)
operator|>>
literal|16
operator|)
expr_stmt|;
name|controllerInfo
operator|->
name|PCIWidth
operator|=
operator|(
operator|(
name|ossaHwRegReadConfig32
argument_list|(
name|agRoot
argument_list|,
literal|128
argument_list|)
operator|&
literal|0x0FF00000
operator|)
operator|>>
literal|20
operator|)
expr_stmt|;
block|}
else|else
block|{
name|SA_DBG2
argument_list|(
operator|(
literal|"saGetControllerInfo: LINK_CTRL 0x%08x Speed 0x%X Lanes 0x%X \n"
operator|,
name|ossaHwRegReadConfig32
argument_list|(
name|agRoot
argument_list|,
literal|208
argument_list|)
operator|,
operator|(
operator|(
name|ossaHwRegReadConfig32
argument_list|(
name|agRoot
argument_list|,
literal|208
argument_list|)
operator|&
literal|0x000F0000
operator|)
operator|>>
literal|16
operator|)
operator|,
operator|(
operator|(
name|ossaHwRegReadConfig32
argument_list|(
name|agRoot
argument_list|,
literal|208
argument_list|)
operator|&
literal|0x0FF00000
operator|)
operator|>>
literal|20
operator|)
operator|)
argument_list|)
expr_stmt|;
name|controllerInfo
operator|->
name|PCILinkRate
operator|=
operator|(
operator|(
name|ossaHwRegReadConfig32
argument_list|(
name|agRoot
argument_list|,
literal|208
argument_list|)
operator|&
literal|0x000F0000
operator|)
operator|>>
literal|16
operator|)
expr_stmt|;
name|controllerInfo
operator|->
name|PCIWidth
operator|=
operator|(
operator|(
name|ossaHwRegReadConfig32
argument_list|(
name|agRoot
argument_list|,
literal|208
argument_list|)
operator|&
literal|0x0FF00000
operator|)
operator|>>
literal|20
operator|)
expr_stmt|;
block|}
name|ContrlCapFlag
operator|=
name|ossaHwRegReadExt
argument_list|(
name|agRoot
argument_list|,
name|pcibar
argument_list|,
operator|(
name|bit32
operator|)
name|CfgTblDWIdx
operator|+
name|MAIN_CNTRL_CAP_OFFSET
argument_list|)
expr_stmt|;
name|controllerInfo
operator|->
name|queueSupport
operator|=
name|ContrlCapFlag
operator|&
name|MAIN_QSUPPORT_BITS
expr_stmt|;
name|controllerInfo
operator|->
name|phyCount
operator|=
call|(
name|bit8
call|)
argument_list|(
operator|(
name|ContrlCapFlag
operator|&
name|MAIN_PHY_COUNT_MASK
operator|)
operator|>>
name|SHIFT19
argument_list|)
expr_stmt|;
if|if
condition|(
name|smIS_SPCV
argument_list|(
name|agRoot
argument_list|)
condition|)
block|{
name|controllerInfo
operator|->
name|controllerSetting
operator|=
call|(
name|bit8
call|)
argument_list|(
operator|(
name|siHalRegReadExt
argument_list|(
name|agRoot
argument_list|,
name|GEN_MSGU_SCRATCH_PAD_1
argument_list|,
name|MSGU_SCRATCH_PAD_1
argument_list|)
operator|&
name|SCRATCH_PAD1_V_BOOTSTATE_MASK
operator|)
operator|>>
name|SHIFT4
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|controllerInfo
operator|->
name|controllerSetting
operator|=
call|(
name|bit8
call|)
argument_list|(
name|ossaHwRegReadExt
argument_list|(
name|agRoot
argument_list|,
name|pcibar
argument_list|,
operator|(
name|bit32
operator|)
name|CfgTblDWIdx
operator|+
name|MAIN_HDA_FLAGS_OFFSET
argument_list|)
operator|&
name|MAIN_HDA_FLAG_BITS
argument_list|)
expr_stmt|;
block|}
name|controllerInfo
operator|->
name|sasSpecsSupport
operator|=
operator|(
name|ContrlCapFlag
operator|&
name|MAIN_SAS_SUPPORT_BITS
operator|)
operator|>>
name|SHIFT25
expr_stmt|;
block|}
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetControllerInfo: signature         0x%X\n"
operator|,
name|controllerInfo
operator|->
name|signature
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetControllerInfo: fwInterfaceRev    0x%X\n"
operator|,
name|controllerInfo
operator|->
name|fwInterfaceRev
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetControllerInfo: hwRevision        0x%X\n"
operator|,
name|controllerInfo
operator|->
name|hwRevision
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetControllerInfo: fwRevision        0x%X\n"
operator|,
name|controllerInfo
operator|->
name|fwRevision
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetControllerInfo: ilaRevision       0x%X\n"
operator|,
name|controllerInfo
operator|->
name|ilaRevision
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetControllerInfo: maxPendingIO      0x%X\n"
operator|,
name|controllerInfo
operator|->
name|maxPendingIO
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetControllerInfo: maxDevices        0x%X\n"
operator|,
name|controllerInfo
operator|->
name|maxDevices
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetControllerInfo: maxSgElements     0x%X\n"
operator|,
name|controllerInfo
operator|->
name|maxSgElements
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetControllerInfo: queueSupport      0x%X\n"
operator|,
name|controllerInfo
operator|->
name|queueSupport
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetControllerInfo: phyCount          0x%X\n"
operator|,
name|controllerInfo
operator|->
name|phyCount
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetControllerInfo: controllerSetting 0x%X\n"
operator|,
name|controllerInfo
operator|->
name|controllerSetting
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetControllerInfo: PCILinkRate       0x%X\n"
operator|,
name|controllerInfo
operator|->
name|PCILinkRate
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetControllerInfo: PCIWidth          0x%X\n"
operator|,
name|controllerInfo
operator|->
name|PCIWidth
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetControllerInfo: sasSpecsSupport   0x%X\n"
operator|,
name|controllerInfo
operator|->
name|sasSpecsSupport
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetControllerInfo: sdkInterfaceRev   0x%X\n"
operator|,
name|controllerInfo
operator|->
name|sdkInterfaceRev
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetControllerInfo: sdkRevision       0x%X\n"
operator|,
name|controllerInfo
operator|->
name|sdkRevision
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|agNULL
operator|!=
name|agRoot
operator|->
name|sdkData
condition|)
block|{
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'a'
argument_list|,
literal|"6e"
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*! \brief SPC Get Controller Status Command  *  *  This command sends Get Controller Status Command to SPC.  *  *  \param agRoot           Handles for this instance of SAS/SATA LL  *  \param controllerStatus controller status  *  *  \return If the MPI command is sent to SPC successfully  *          - \e AGSA_RC_SUCCESS the MPI command is successfully  *          - \e AGSA_RC_FAILURE the MPI command is failure  *  */
end_comment

begin_comment
comment|/*******************************************************************************/
end_comment

begin_function
name|GLOBAL
name|bit32
name|saGetControllerStatus
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|agsaControllerStatus_t
modifier|*
name|controllerStatus
parameter_list|)
block|{
name|bit32
name|ret
init|=
name|AGSA_RC_SUCCESS
decl_stmt|;
name|agsaLLRoot_t
modifier|*
name|saRoot
init|=
operator|(
name|agsaLLRoot_t
operator|*
operator|)
operator|(
name|agRoot
operator|->
name|sdkData
operator|)
decl_stmt|;
name|spc_GSTableDescriptor_t
name|GSTable
decl_stmt|;
name|bit32
name|max_wait_time
decl_stmt|;
name|bit32
name|max_wait_count
decl_stmt|;
name|bit32
name|i
decl_stmt|,
name|value
decl_stmt|,
name|value1
decl_stmt|;
if|if
condition|(
name|agNULL
operator|!=
name|saRoot
condition|)
block|{
name|smTraceFuncEnter
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|"6f"
argument_list|)
expr_stmt|;
block|}
comment|/* clean the structure */
name|si_memset
argument_list|(
name|controllerStatus
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|agsaControllerStatus_t
argument_list|)
argument_list|)
expr_stmt|;
name|si_memset
argument_list|(
operator|&
name|GSTable
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|spc_GSTableDescriptor_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|siHalRegReadExt
argument_list|(
name|agRoot
argument_list|,
name|GEN_MSGU_SCRATCH_PAD_0
argument_list|,
name|MSGU_SCRATCH_PAD_0
argument_list|)
operator|==
literal|0xFFFFFFFF
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetControllerStatus:AGSA_RC_FAILURE SCRATCH_PAD0 value = 0x%x\n"
operator|,
name|siHalRegReadExt
argument_list|(
name|agRoot
argument_list|,
name|GEN_MSGU_SCRATCH_PAD_0
argument_list|,
name|MSGU_SCRATCH_PAD_0
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_FAILURE
return|;
block|}
if|if
condition|(
name|siHalRegReadExt
argument_list|(
name|agRoot
argument_list|,
name|GEN_MSGU_SCRATCH_PAD_1
argument_list|,
name|MSGU_SCRATCH_PAD_3
argument_list|)
operator|&
operator|(
name|OSSA_ENCRYPT_ENGINE_FAILURE_MASK
operator||
name|OSSA_DIF_ENGINE_FAILURE_MASK
operator|)
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetControllerStatus: BIST error in SCRATCHPAD 3 0x%x\n"
operator|,
name|siHalRegReadExt
argument_list|(
name|agRoot
argument_list|,
name|GEN_MSGU_SCRATCH_PAD_3
argument_list|,
name|MSGU_SCRATCH_PAD_3
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|smIS_SPC
argument_list|(
name|agRoot
argument_list|)
condition|)
block|{
comment|/* read detail fatal errors */
name|controllerStatus
operator|->
name|fatalErrorInfo
operator|.
name|errorInfo0
operator|=
name|ossaHwRegRead
argument_list|(
name|agRoot
argument_list|,
name|MSGU_SCRATCH_PAD_0
argument_list|)
expr_stmt|;
name|controllerStatus
operator|->
name|fatalErrorInfo
operator|.
name|errorInfo1
operator|=
name|ossaHwRegRead
argument_list|(
name|agRoot
argument_list|,
name|MSGU_SCRATCH_PAD_1
argument_list|)
expr_stmt|;
name|controllerStatus
operator|->
name|fatalErrorInfo
operator|.
name|errorInfo2
operator|=
name|ossaHwRegRead
argument_list|(
name|agRoot
argument_list|,
name|MSGU_SCRATCH_PAD_2
argument_list|)
expr_stmt|;
name|controllerStatus
operator|->
name|fatalErrorInfo
operator|.
name|errorInfo3
operator|=
name|ossaHwRegRead
argument_list|(
name|agRoot
argument_list|,
name|MSGU_SCRATCH_PAD_3
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SALLSDK_DEBUG
argument_list|)
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetControllerStatus: SCRATCH_PAD0 value = 0x%x\n"
operator|,
name|controllerStatus
operator|->
name|fatalErrorInfo
operator|.
name|errorInfo0
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetControllerStatus: SCRATCH_PAD1 value = 0x%x\n"
operator|,
name|controllerStatus
operator|->
name|fatalErrorInfo
operator|.
name|errorInfo1
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetControllerStatus: SCRATCH_PAD2 value = 0x%x\n"
operator|,
name|controllerStatus
operator|->
name|fatalErrorInfo
operator|.
name|errorInfo2
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetControllerStatus: SCRATCH_PAD3 value = 0x%x\n"
operator|,
name|controllerStatus
operator|->
name|fatalErrorInfo
operator|.
name|errorInfo3
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* check HDA mode */
name|value
operator|=
name|ossaHwRegReadExt
argument_list|(
name|agRoot
argument_list|,
name|PCIBAR3
argument_list|,
name|HDA_RSP_OFFSET1MB
operator|+
name|HDA_CMD_CODE_OFFSET
argument_list|)
operator|&
name|HDA_STATUS_BITS
expr_stmt|;
if|if
condition|(
name|value
operator|==
name|BOOTTLOADERHDA_IDLE
condition|)
block|{
comment|/* HDA mode */
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetControllerStatus: HDA mode, value = 0x%x\n"
operator|,
name|value
operator|)
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_HDA_NO_FW_RUNNING
return|;
block|}
comment|/* check error state */
name|value
operator|=
name|ossaHwRegRead
argument_list|(
name|agRoot
argument_list|,
name|MSGU_SCRATCH_PAD_1
argument_list|)
expr_stmt|;
name|value1
operator|=
name|ossaHwRegRead
argument_list|(
name|agRoot
argument_list|,
name|MSGU_SCRATCH_PAD_2
argument_list|)
expr_stmt|;
comment|/* check AAP or IOP error */
if|if
condition|(
operator|(
name|SCRATCH_PAD1_ERR
operator|==
operator|(
name|value
operator|&
name|SCRATCH_PAD_STATE_MASK
operator|)
operator|)
operator|||
operator|(
name|SCRATCH_PAD2_ERR
operator|==
operator|(
name|value1
operator|&
name|SCRATCH_PAD_STATE_MASK
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|agNULL
operator|!=
name|saRoot
condition|)
block|{
name|controllerStatus
operator|->
name|fatalErrorInfo
operator|.
name|regDumpBusBaseNum0
operator|=
name|saRoot
operator|->
name|mainConfigTable
operator|.
name|regDumpPCIBAR
expr_stmt|;
name|controllerStatus
operator|->
name|fatalErrorInfo
operator|.
name|regDumpOffset0
operator|=
name|saRoot
operator|->
name|mainConfigTable
operator|.
name|FatalErrorDumpOffset0
expr_stmt|;
name|controllerStatus
operator|->
name|fatalErrorInfo
operator|.
name|regDumpLen0
operator|=
name|saRoot
operator|->
name|mainConfigTable
operator|.
name|FatalErrorDumpLength0
expr_stmt|;
name|controllerStatus
operator|->
name|fatalErrorInfo
operator|.
name|regDumpBusBaseNum1
operator|=
name|saRoot
operator|->
name|mainConfigTable
operator|.
name|regDumpPCIBAR
expr_stmt|;
name|controllerStatus
operator|->
name|fatalErrorInfo
operator|.
name|regDumpOffset1
operator|=
name|saRoot
operator|->
name|mainConfigTable
operator|.
name|FatalErrorDumpOffset1
expr_stmt|;
name|controllerStatus
operator|->
name|fatalErrorInfo
operator|.
name|regDumpLen1
operator|=
name|saRoot
operator|->
name|mainConfigTable
operator|.
name|FatalErrorDumpLength1
expr_stmt|;
block|}
else|else
block|{
name|controllerStatus
operator|->
name|fatalErrorInfo
operator|.
name|regDumpBusBaseNum0
operator|=
literal|0
expr_stmt|;
name|controllerStatus
operator|->
name|fatalErrorInfo
operator|.
name|regDumpOffset0
operator|=
literal|0
expr_stmt|;
name|controllerStatus
operator|->
name|fatalErrorInfo
operator|.
name|regDumpLen0
operator|=
literal|0
expr_stmt|;
name|controllerStatus
operator|->
name|fatalErrorInfo
operator|.
name|regDumpBusBaseNum1
operator|=
literal|0
expr_stmt|;
name|controllerStatus
operator|->
name|fatalErrorInfo
operator|.
name|regDumpOffset1
operator|=
literal|0
expr_stmt|;
name|controllerStatus
operator|->
name|fatalErrorInfo
operator|.
name|regDumpLen1
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|agNULL
operator|!=
name|saRoot
condition|)
block|{
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'a'
argument_list|,
literal|"6f"
argument_list|)
expr_stmt|;
block|}
return|return
name|AGSA_RC_FW_NOT_IN_READY_STATE
return|;
block|}
comment|/* checking the fw AAP and IOP in ready state */
name|max_wait_time
operator|=
name|WAIT_SECONDS
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|/* 2 sec timeout */
name|max_wait_count
operator|=
name|MAKE_MODULO
argument_list|(
name|max_wait_time
argument_list|,
name|WAIT_INCREMENT
argument_list|)
expr_stmt|;
comment|/* wait until scratch pad 1 and 2 registers in ready state  */
do|do
block|{
name|ossaStallThread
argument_list|(
name|agRoot
argument_list|,
name|WAIT_INCREMENT
argument_list|)
expr_stmt|;
name|value
operator|=
name|ossaHwRegRead
argument_list|(
name|agRoot
argument_list|,
name|MSGU_SCRATCH_PAD_1
argument_list|)
expr_stmt|;
comment|/* checking bit 4 to 7 for reserved in case we get 0xFFFFFFFF */
if|if
condition|(
name|value
operator|&
name|SCRATCH_PAD1_RESERVED
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetControllerStatus: (Reserved bit not 0) SCRATCH_PAD1 value = 0x%x\n"
operator|,
name|value
operator|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|AGSA_RC_FAILURE
expr_stmt|;
break|break;
block|}
name|value1
operator|=
name|ossaHwRegRead
argument_list|(
name|agRoot
argument_list|,
name|MSGU_SCRATCH_PAD_2
argument_list|)
expr_stmt|;
comment|/* checking bit 4 to 7 for reserved in case we get 0xFFFFFFFF */
if|if
condition|(
name|value1
operator|&
name|SCRATCH_PAD2_RESERVED
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetControllerStatus: (Reserved bit not 0) SCRATCH_PAD2 value = 0x%x\n"
operator|,
name|value1
operator|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|AGSA_RC_FAILURE
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|max_wait_count
operator|-=
name|WAIT_INCREMENT
operator|)
operator|==
literal|0
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetControllerStatus: Timeout!! SCRATCH_PAD1/2 value = 0x%x 0x%x\n"
operator|,
name|value
operator|,
name|value1
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
operator|(
operator|(
name|value
operator|&
name|SCRATCH_PAD_STATE_MASK
operator|)
operator|!=
name|SCRATCH_PAD1_RDY
operator|)
operator|||
operator|(
operator|(
name|value1
operator|&
name|SCRATCH_PAD_STATE_MASK
operator|)
operator|!=
name|SCRATCH_PAD2_RDY
operator|)
condition|)
do|;
if|if
condition|(
operator|!
name|max_wait_count
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetControllerStatus: timeout failure\n"
operator|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|AGSA_RC_FAILURE
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|==
name|AGSA_RC_SUCCESS
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetControllerStatus: FW Ready, SCRATCH_PAD1/2 value = 0x%x 0x%x\n"
operator|,
name|value
operator|,
name|value1
operator|)
argument_list|)
expr_stmt|;
comment|/* read scratch pad0 to get PCI BAR and offset of configuration table */
name|value
operator|=
name|ossaHwRegRead
argument_list|(
name|agRoot
argument_list|,
name|MSGU_SCRATCH_PAD_0
argument_list|)
expr_stmt|;
comment|/* get offset */
name|value1
operator|=
name|value
operator|&
name|SCRATCH_PAD0_OFFSET_MASK
expr_stmt|;
comment|/* get PCI BAR */
name|value
operator|=
operator|(
name|value
operator|&
name|SCRATCH_PAD0_BAR_MASK
operator|)
operator|>>
name|SHIFT26
expr_stmt|;
comment|/* read GST Table state */
name|mpiReadGSTable
argument_list|(
name|agRoot
argument_list|,
operator|&
name|GSTable
argument_list|)
expr_stmt|;
comment|/* read register dump information */
name|controllerStatus
operator|->
name|fatalErrorInfo
operator|.
name|regDumpBusBaseNum0
operator|=
name|value
expr_stmt|;
name|controllerStatus
operator|->
name|fatalErrorInfo
operator|.
name|regDumpBusBaseNum1
operator|=
name|value
expr_stmt|;
comment|/* convert the PCI BAR to logical bar number */
name|value
operator|=
operator|(
name|bit8
operator|)
name|mpiGetPCIBarIndex
argument_list|(
name|agRoot
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|controllerStatus
operator|->
name|fatalErrorInfo
operator|.
name|regDumpOffset0
operator|=
name|ossaHwRegReadExt
argument_list|(
name|agRoot
argument_list|,
name|value
argument_list|,
name|value1
operator|+
name|MAIN_FATAL_ERROR_RDUMP0_OFFSET
argument_list|)
expr_stmt|;
name|controllerStatus
operator|->
name|fatalErrorInfo
operator|.
name|regDumpLen0
operator|=
name|ossaHwRegReadExt
argument_list|(
name|agRoot
argument_list|,
name|value
argument_list|,
name|value1
operator|+
name|MAIN_FATAL_ERROR_RDUMP0_LENGTH
argument_list|)
expr_stmt|;
name|controllerStatus
operator|->
name|fatalErrorInfo
operator|.
name|regDumpOffset1
operator|=
name|ossaHwRegReadExt
argument_list|(
name|agRoot
argument_list|,
name|value
argument_list|,
name|value1
operator|+
name|MAIN_FATAL_ERROR_RDUMP1_OFFSET
argument_list|)
expr_stmt|;
name|controllerStatus
operator|->
name|fatalErrorInfo
operator|.
name|regDumpLen1
operator|=
name|ossaHwRegReadExt
argument_list|(
name|agRoot
argument_list|,
name|value
argument_list|,
name|value1
operator|+
name|MAIN_FATAL_ERROR_RDUMP1_LENGTH
argument_list|)
expr_stmt|;
comment|/* AAP/IOP error state */
name|SA_DBG2
argument_list|(
operator|(
literal|"saGetControllerStatus: SCRATCH PAD0 0x%x\n"
operator|,
name|controllerStatus
operator|->
name|fatalErrorInfo
operator|.
name|errorInfo0
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG2
argument_list|(
operator|(
literal|"saGetControllerStatus: SCRATCH PAD1 0x%x\n"
operator|,
name|controllerStatus
operator|->
name|fatalErrorInfo
operator|.
name|errorInfo1
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG2
argument_list|(
operator|(
literal|"saGetControllerStatus: SCRATCH PAD2 0x%x\n"
operator|,
name|controllerStatus
operator|->
name|fatalErrorInfo
operator|.
name|errorInfo2
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG2
argument_list|(
operator|(
literal|"saGetControllerStatus: SCRATCH PAD3 0x%x\n"
operator|,
name|controllerStatus
operator|->
name|fatalErrorInfo
operator|.
name|errorInfo3
operator|)
argument_list|)
expr_stmt|;
comment|/* Register Dump information */
name|SA_DBG2
argument_list|(
operator|(
literal|"saGetControllerStatus: RegDumpOffset0 0x%x\n"
operator|,
name|controllerStatus
operator|->
name|fatalErrorInfo
operator|.
name|regDumpOffset0
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG2
argument_list|(
operator|(
literal|"saGetControllerStatus: RegDumpLen0    0x%x\n"
operator|,
name|controllerStatus
operator|->
name|fatalErrorInfo
operator|.
name|regDumpLen0
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG2
argument_list|(
operator|(
literal|"saGetControllerStatus: RegDumpOffset1 0x%x\n"
operator|,
name|controllerStatus
operator|->
name|fatalErrorInfo
operator|.
name|regDumpOffset1
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG2
argument_list|(
operator|(
literal|"saGetControllerStatus: RegDumpLen1    0x%x\n"
operator|,
name|controllerStatus
operator|->
name|fatalErrorInfo
operator|.
name|regDumpLen1
operator|)
argument_list|)
expr_stmt|;
name|controllerStatus
operator|->
name|interfaceState
operator|=
name|GSTable
operator|.
name|GSTLenMPIS
operator|&
name|GST_INF_STATE_BITS
expr_stmt|;
name|controllerStatus
operator|->
name|iqFreezeState0
operator|=
name|GSTable
operator|.
name|IQFreezeState0
expr_stmt|;
name|controllerStatus
operator|->
name|iqFreezeState1
operator|=
name|GSTable
operator|.
name|IQFreezeState1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
name|controllerStatus
operator|->
name|phyStatus
index|[
name|i
index|]
operator|=
name|GSTable
operator|.
name|PhyState
index|[
name|i
index|]
expr_stmt|;
name|controllerStatus
operator|->
name|recoverableErrorInfo
index|[
name|i
index|]
operator|=
name|GSTable
operator|.
name|recoverErrInfo
index|[
name|i
index|]
expr_stmt|;
block|}
name|controllerStatus
operator|->
name|tickCount0
operator|=
name|GSTable
operator|.
name|MsguTcnt
expr_stmt|;
name|controllerStatus
operator|->
name|tickCount1
operator|=
name|GSTable
operator|.
name|IopTcnt
expr_stmt|;
name|controllerStatus
operator|->
name|tickCount2
operator|=
name|GSTable
operator|.
name|Iop1Tcnt
expr_stmt|;
block|}
block|}
else|else
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetControllerStatus: SPCv\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|siHalRegReadExt
argument_list|(
name|agRoot
argument_list|,
name|GEN_MSGU_SCRATCH_PAD_1
argument_list|,
name|MSGU_SCRATCH_PAD_1
argument_list|)
operator|&
name|SCRATCH_PAD1_V_RESERVED
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetControllerStatus: Warning SCRATCH_PAD1 reserved bits set value = 0x%x\n"
operator|,
name|siHalRegReadExt
argument_list|(
name|agRoot
argument_list|,
name|GEN_MSGU_SCRATCH_PAD_1
argument_list|,
name|MSGU_SCRATCH_PAD_1
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|si_check_V_HDA
argument_list|(
name|agRoot
argument_list|)
condition|)
block|{
comment|/*  Check HDA */
name|controllerStatus
operator|->
name|fatalErrorInfo
operator|.
name|errorInfo0
operator|=
name|ossaHwRegRead
argument_list|(
name|agRoot
argument_list|,
name|V_Scratchpad_0_Register
argument_list|)
expr_stmt|;
name|controllerStatus
operator|->
name|fatalErrorInfo
operator|.
name|errorInfo1
operator|=
name|ossaHwRegRead
argument_list|(
name|agRoot
argument_list|,
name|V_Scratchpad_1_Register
argument_list|)
expr_stmt|;
name|controllerStatus
operator|->
name|fatalErrorInfo
operator|.
name|errorInfo2
operator|=
name|ossaHwRegRead
argument_list|(
name|agRoot
argument_list|,
name|V_Scratchpad_2_Register
argument_list|)
expr_stmt|;
name|controllerStatus
operator|->
name|fatalErrorInfo
operator|.
name|errorInfo3
operator|=
name|ossaHwRegRead
argument_list|(
name|agRoot
argument_list|,
name|V_Scratchpad_3_Register
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetControllerStatus: HDA mode, AGSA_RC_HDA_NO_FW_RUNNING errorInfo1  = 0x%x\n"
operator|,
name|controllerStatus
operator|->
name|fatalErrorInfo
operator|.
name|errorInfo1
operator|)
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_HDA_NO_FW_RUNNING
return|;
block|}
name|ret
operator|=
name|si_check_V_Ready
argument_list|(
name|agRoot
argument_list|)
expr_stmt|;
comment|/* Check ready */
if|if
condition|(
name|ret
operator|==
name|AGSA_RC_SUCCESS
condition|)
block|{
comment|/* read GST Table state */
name|mpiReadGSTable
argument_list|(
name|agRoot
argument_list|,
operator|&
name|GSTable
argument_list|)
expr_stmt|;
name|controllerStatus
operator|->
name|interfaceState
operator|=
name|GSTable
operator|.
name|GSTLenMPIS
operator|&
name|GST_INF_STATE_BITS
expr_stmt|;
name|controllerStatus
operator|->
name|iqFreezeState0
operator|=
name|GSTable
operator|.
name|IQFreezeState0
expr_stmt|;
name|controllerStatus
operator|->
name|iqFreezeState1
operator|=
name|GSTable
operator|.
name|IQFreezeState1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
name|controllerStatus
operator|->
name|phyStatus
index|[
name|i
index|]
operator|=
name|GSTable
operator|.
name|PhyState
index|[
name|i
index|]
expr_stmt|;
name|controllerStatus
operator|->
name|recoverableErrorInfo
index|[
name|i
index|]
operator|=
name|GSTable
operator|.
name|recoverErrInfo
index|[
name|i
index|]
expr_stmt|;
block|}
name|controllerStatus
operator|->
name|tickCount0
operator|=
name|GSTable
operator|.
name|MsguTcnt
expr_stmt|;
name|controllerStatus
operator|->
name|tickCount1
operator|=
name|GSTable
operator|.
name|IopTcnt
expr_stmt|;
name|controllerStatus
operator|->
name|tickCount2
operator|=
name|GSTable
operator|.
name|Iop1Tcnt
expr_stmt|;
name|controllerStatus
operator|->
name|interfaceState
operator|=
name|GSTable
operator|.
name|GSTLenMPIS
operator|&
name|GST_INF_STATE_BITS
expr_stmt|;
name|controllerStatus
operator|->
name|iqFreezeState0
operator|=
name|GSTable
operator|.
name|IQFreezeState0
expr_stmt|;
name|controllerStatus
operator|->
name|iqFreezeState1
operator|=
name|GSTable
operator|.
name|IQFreezeState1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|IS_SDKDATA
argument_list|(
name|agRoot
argument_list|)
condition|)
block|{
if|if
condition|(
name|agNULL
operator|!=
name|saRoot
condition|)
block|{
name|controllerStatus
operator|->
name|phyStatus
index|[
name|i
index|]
operator|=
operator|(
operator|(
name|saRoot
operator|->
name|phys
index|[
name|i
operator|+
literal|8
index|]
operator|.
name|linkstatus
operator|<<
name|SHIFT8
operator|)
operator||
name|saRoot
operator|->
name|phys
index|[
name|i
index|]
operator|.
name|linkstatus
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|controllerStatus
operator|->
name|phyStatus
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|controllerStatus
operator|->
name|recoverableErrorInfo
index|[
name|i
index|]
operator|=
name|GSTable
operator|.
name|recoverErrInfo
index|[
name|i
index|]
expr_stmt|;
block|}
name|controllerStatus
operator|->
name|tickCount0
operator|=
name|GSTable
operator|.
name|MsguTcnt
expr_stmt|;
name|controllerStatus
operator|->
name|tickCount1
operator|=
name|GSTable
operator|.
name|IopTcnt
expr_stmt|;
name|controllerStatus
operator|->
name|tickCount2
operator|=
name|GSTable
operator|.
name|Iop1Tcnt
expr_stmt|;
block|}
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetControllerStatus: SCRATCH_PAD0 value = 0x%x\n"
operator|,
name|ossaHwRegRead
argument_list|(
name|agRoot
argument_list|,
name|V_Scratchpad_0_Register
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetControllerStatus: SCRATCH_PAD1 value = 0x%x\n"
operator|,
name|ossaHwRegRead
argument_list|(
name|agRoot
argument_list|,
name|V_Scratchpad_1_Register
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetControllerStatus: SCRATCH_PAD2 value = 0x%x\n"
operator|,
name|ossaHwRegRead
argument_list|(
name|agRoot
argument_list|,
name|V_Scratchpad_2_Register
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetControllerStatus: SCRATCH_PAD3 value = 0x%x\n"
operator|,
name|ossaHwRegRead
argument_list|(
name|agRoot
argument_list|,
name|V_Scratchpad_3_Register
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|controllerStatus
operator|->
name|fatalErrorInfo
operator|.
name|errorInfo0
operator|=
name|ossaHwRegRead
argument_list|(
name|agRoot
argument_list|,
name|V_Scratchpad_0_Register
argument_list|)
expr_stmt|;
name|controllerStatus
operator|->
name|fatalErrorInfo
operator|.
name|errorInfo1
operator|=
name|ossaHwRegRead
argument_list|(
name|agRoot
argument_list|,
name|V_Scratchpad_1_Register
argument_list|)
expr_stmt|;
name|controllerStatus
operator|->
name|fatalErrorInfo
operator|.
name|errorInfo2
operator|=
name|ossaHwRegRead
argument_list|(
name|agRoot
argument_list|,
name|V_Scratchpad_2_Register
argument_list|)
expr_stmt|;
name|controllerStatus
operator|->
name|fatalErrorInfo
operator|.
name|errorInfo3
operator|=
name|ossaHwRegRead
argument_list|(
name|agRoot
argument_list|,
name|V_Scratchpad_3_Register
argument_list|)
expr_stmt|;
name|controllerStatus
operator|->
name|bootStatus
operator|=
operator|(
operator|(
operator|(
name|controllerStatus
operator|->
name|fatalErrorInfo
operator|.
name|errorInfo1
operator|>>
name|SHIFT9
operator|)
operator|&
literal|1
operator|)
operator||
comment|/* bit 1  */
operator|(
operator|(
name|controllerStatus
operator|->
name|fatalErrorInfo
operator|.
name|errorInfo3
operator|&
literal|0x3
operator|)
operator|<<
name|SHIFT16
operator|)
operator||
comment|/* bit 16 17 */
operator|(
operator|(
operator|(
name|controllerStatus
operator|->
name|fatalErrorInfo
operator|.
name|errorInfo3
operator|>>
name|SHIFT14
operator|)
operator|&
literal|0x7
operator|)
operator|<<
name|SHIFT18
operator|)
operator||
comment|/* bit 18 19 20 */
operator|(
operator|(
operator|(
name|controllerStatus
operator|->
name|fatalErrorInfo
operator|.
name|errorInfo3
operator|>>
name|SHIFT4
operator|)
operator|&
literal|0x1
operator|)
operator|<<
name|SHIFT23
operator|)
operator||
comment|/* bit 23 */
operator|(
operator|(
operator|(
name|controllerStatus
operator|->
name|fatalErrorInfo
operator|.
name|errorInfo3
operator|>>
name|SHIFT16
operator|)
operator|&
literal|0xFF
operator|)
operator|<<
name|SHIFT24
operator|)
operator|)
expr_stmt|;
comment|/* bit 24 31 */
name|controllerStatus
operator|->
name|bootComponentState
index|[
literal|0
index|]
operator|=
call|(
name|bit16
call|)
argument_list|(
operator|(
name|controllerStatus
operator|->
name|fatalErrorInfo
operator|.
name|errorInfo1
operator|&
literal|3
operator|)
operator||
literal|0x8000
argument_list|)
expr_stmt|;
comment|/* RAAE_STATE */
name|controllerStatus
operator|->
name|bootComponentState
index|[
literal|1
index|]
operator|=
call|(
name|bit16
call|)
argument_list|(
operator|(
operator|(
name|controllerStatus
operator|->
name|fatalErrorInfo
operator|.
name|errorInfo1
operator|>>
name|SHIFT10
operator|)
operator|&
literal|3
operator|)
operator||
literal|0x8000
argument_list|)
expr_stmt|;
comment|/* IOP0_STATE */
name|controllerStatus
operator|->
name|bootComponentState
index|[
literal|2
index|]
operator|=
call|(
name|bit16
call|)
argument_list|(
operator|(
operator|(
name|controllerStatus
operator|->
name|fatalErrorInfo
operator|.
name|errorInfo1
operator|>>
name|SHIFT12
operator|)
operator|&
literal|3
operator|)
operator||
literal|0x8000
argument_list|)
expr_stmt|;
comment|/* IOP1_STATE */
name|controllerStatus
operator|->
name|bootComponentState
index|[
literal|3
index|]
operator|=
call|(
name|bit16
call|)
argument_list|(
operator|(
operator|(
name|controllerStatus
operator|->
name|fatalErrorInfo
operator|.
name|errorInfo1
operator|>>
name|SHIFT4
operator|)
operator|&
literal|7
operator|)
operator||
literal|0x8000
argument_list|)
expr_stmt|;
comment|/* BOOTLDR_STATE  */
name|controllerStatus
operator|->
name|bootComponentState
index|[
literal|4
index|]
operator|=
call|(
name|bit16
call|)
argument_list|(
operator|(
operator|(
name|controllerStatus
operator|->
name|fatalErrorInfo
operator|.
name|errorInfo1
operator|>>
name|SHIFT2
operator|)
operator|&
literal|3
operator|)
operator||
literal|0x8000
argument_list|)
expr_stmt|;
comment|/* ILA State */
name|controllerStatus
operator|->
name|bootComponentState
index|[
literal|5
index|]
operator|=
literal|0
expr_stmt|;
name|controllerStatus
operator|->
name|bootComponentState
index|[
literal|6
index|]
operator|=
literal|0
expr_stmt|;
name|controllerStatus
operator|->
name|bootComponentState
index|[
literal|7
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|controllerStatus
operator|->
name|fatalErrorInfo
operator|.
name|errorInfo0
operator|==
literal|0xFFFFFFFF
condition|)
block|{
name|ret
operator|=
name|AGSA_RC_FAILURE
expr_stmt|;
block|}
block|}
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetControllerStatus: fatalErrorInfo.errorInfo0          0x%x\n"
operator|,
name|controllerStatus
operator|->
name|fatalErrorInfo
operator|.
name|errorInfo0
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetControllerStatus: fatalErrorInfo.errorInfo1          0x%x\n"
operator|,
name|controllerStatus
operator|->
name|fatalErrorInfo
operator|.
name|errorInfo1
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetControllerStatus: fatalErrorInfo.errorInfo2          0x%x\n"
operator|,
name|controllerStatus
operator|->
name|fatalErrorInfo
operator|.
name|errorInfo2
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetControllerStatus: fatalErrorInfo.errorInfo3          0x%x\n"
operator|,
name|controllerStatus
operator|->
name|fatalErrorInfo
operator|.
name|errorInfo3
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetControllerStatus: fatalErrorInfo.regDumpBusBaseNum0  0x%x\n"
operator|,
name|controllerStatus
operator|->
name|fatalErrorInfo
operator|.
name|regDumpBusBaseNum0
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetControllerStatus: fatalErrorInfo.regDumpOffset0      0x%x\n"
operator|,
name|controllerStatus
operator|->
name|fatalErrorInfo
operator|.
name|regDumpOffset0
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetControllerStatus: fatalErrorInfo.regDumpLen0         0x%x\n"
operator|,
name|controllerStatus
operator|->
name|fatalErrorInfo
operator|.
name|regDumpLen0
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetControllerStatus: fatalErrorInfo.regDumpBusBaseNum1  0x%x\n"
operator|,
name|controllerStatus
operator|->
name|fatalErrorInfo
operator|.
name|regDumpBusBaseNum1
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetControllerStatus: fatalErrorInfo.regDumpOffset1      0x%x\n"
operator|,
name|controllerStatus
operator|->
name|fatalErrorInfo
operator|.
name|regDumpOffset1
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetControllerStatus: fatalErrorInfo.regDumpLen1         0x%x\n"
operator|,
name|controllerStatus
operator|->
name|fatalErrorInfo
operator|.
name|regDumpLen1
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetControllerStatus: interfaceState                     0x%x\n"
operator|,
name|controllerStatus
operator|->
name|interfaceState
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetControllerStatus: iqFreezeState0                     0x%x\n"
operator|,
name|controllerStatus
operator|->
name|iqFreezeState0
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetControllerStatus: iqFreezeState1                     0x%x\n"
operator|,
name|controllerStatus
operator|->
name|iqFreezeState1
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetControllerStatus: tickCount0                         0x%x\n"
operator|,
name|controllerStatus
operator|->
name|tickCount0
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetControllerStatus: tickCount1                         0x%x\n"
operator|,
name|controllerStatus
operator|->
name|tickCount1
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetControllerStatus: tickCount2                         0x%x\n"
operator|,
name|controllerStatus
operator|->
name|tickCount2
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetControllerStatus: phyStatus[0]                       0x%08x\n"
operator|,
name|controllerStatus
operator|->
name|phyStatus
index|[
literal|0
index|]
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetControllerStatus: phyStatus[1]                       0x%08x\n"
operator|,
name|controllerStatus
operator|->
name|phyStatus
index|[
literal|1
index|]
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetControllerStatus: phyStatus[2]                       0x%08x\n"
operator|,
name|controllerStatus
operator|->
name|phyStatus
index|[
literal|2
index|]
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetControllerStatus: phyStatus[3]                       0x%08x\n"
operator|,
name|controllerStatus
operator|->
name|phyStatus
index|[
literal|3
index|]
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetControllerStatus: phyStatus[4]                       0x%08x\n"
operator|,
name|controllerStatus
operator|->
name|phyStatus
index|[
literal|4
index|]
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetControllerStatus: phyStatus[5]                       0x%08x\n"
operator|,
name|controllerStatus
operator|->
name|phyStatus
index|[
literal|5
index|]
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetControllerStatus: phyStatus[6]                       0x%08x\n"
operator|,
name|controllerStatus
operator|->
name|phyStatus
index|[
literal|6
index|]
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetControllerStatus: phyStatus[7]                       0x%08x\n"
operator|,
name|controllerStatus
operator|->
name|phyStatus
index|[
literal|7
index|]
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetControllerStatus: recoverableErrorInfo[0]            0x%08x\n"
operator|,
name|controllerStatus
operator|->
name|recoverableErrorInfo
index|[
literal|0
index|]
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetControllerStatus: recoverableErrorInfo[1]            0x%08x\n"
operator|,
name|controllerStatus
operator|->
name|recoverableErrorInfo
index|[
literal|1
index|]
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetControllerStatus: recoverableErrorInfo[2]            0x%08x\n"
operator|,
name|controllerStatus
operator|->
name|recoverableErrorInfo
index|[
literal|2
index|]
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetControllerStatus: recoverableErrorInfo[3]            0x%08x\n"
operator|,
name|controllerStatus
operator|->
name|recoverableErrorInfo
index|[
literal|3
index|]
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetControllerStatus: recoverableErrorInfo[4]            0x%08x\n"
operator|,
name|controllerStatus
operator|->
name|recoverableErrorInfo
index|[
literal|4
index|]
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetControllerStatus: recoverableErrorInfo[5]            0x%08x\n"
operator|,
name|controllerStatus
operator|->
name|recoverableErrorInfo
index|[
literal|5
index|]
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetControllerStatus: recoverableErrorInfo[6]            0x%08x\n"
operator|,
name|controllerStatus
operator|->
name|recoverableErrorInfo
index|[
literal|6
index|]
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetControllerStatus: recoverableErrorInfo[7]            0x%08x\n"
operator|,
name|controllerStatus
operator|->
name|recoverableErrorInfo
index|[
literal|7
index|]
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetControllerStatus: bootStatus                         0x%08x\n"
operator|,
name|controllerStatus
operator|->
name|bootStatus
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetControllerStatus: bootStatus  Active FW Image        %x\n"
operator|,
operator|(
name|controllerStatus
operator|->
name|bootStatus
operator|&
literal|1
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetControllerStatus: bootStatus  Encryption Cap         %x\n"
operator|,
operator|(
operator|(
name|controllerStatus
operator|->
name|bootStatus
operator|&
literal|0x30000
operator|)
operator|>>
name|SHIFT16
operator|)
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetControllerStatus: bootStatus  Encryption Sec Mode    %x\n"
operator|,
operator|(
operator|(
name|controllerStatus
operator|->
name|bootStatus
operator|&
literal|0xC0000
operator|)
operator|>>
name|SHIFT18
operator|)
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetControllerStatus: bootStatus  Encryption AES XTS     %x\n"
operator|,
operator|(
name|controllerStatus
operator|->
name|bootStatus
operator|&
literal|0x800000
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetControllerStatus: bootStatus  Encryption Engine Stat 0x%x\n"
operator|,
operator|(
operator|(
name|controllerStatus
operator|->
name|bootStatus
operator|&
literal|0xFF000000
operator|)
operator|>>
name|SHIFT24
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/*  Bit 0 : Active FW Image 0b: Primary Image 1b: Secondary Image  Bit 16-17 :  Encryption Capability 00: Not supported. Controller firmware version doesn't support encryption functionality. 01: Disabled due to error. Controller firmware supports encryption however, the functionality is currently disabled due to an error. The actual cause of the error is indicated in the error code field (bits [23:16]). 10: Enabled with Error. Encryption is currently enabled however, firmware encountered encryption-related error during initialization which might have caused the controller to enter SMF Security mode and/or disabled access to non-volatile memory for encryption-related information. The actual cause of the error is indicated in the error code field (bits [23:16]). 11: Enabled. Encryption functionality is enabled and fully functional. Bit 18-21 : Encryption Current Security Mode 0000: Security Mode Factory 0001: Security Mode A 0010: Security Mode B All other values are reserved. Bit22: Reserved Bit 23 : Encryption AES XTS Enabled 0: AES XTS is disabled. 1: AES XTS is enabled Bit 24-31 : Encryption Engine Status */
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetControllerStatus: bootComponentState[0] RAAE_STATE   0x%x\n"
operator|,
name|controllerStatus
operator|->
name|bootComponentState
index|[
literal|0
index|]
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetControllerStatus: bootComponentState[1] IOP0_STATE   0x%x\n"
operator|,
name|controllerStatus
operator|->
name|bootComponentState
index|[
literal|1
index|]
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetControllerStatus: bootComponentState[2] IOP1_STATE   0x%x\n"
operator|,
name|controllerStatus
operator|->
name|bootComponentState
index|[
literal|2
index|]
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetControllerStatus: bootComponentState[3] BOOTLDR_     0x%x\n"
operator|,
name|controllerStatus
operator|->
name|bootComponentState
index|[
literal|3
index|]
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetControllerStatus: bootComponentState[4] ILA State    0x%x\n"
operator|,
name|controllerStatus
operator|->
name|bootComponentState
index|[
literal|4
index|]
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetControllerStatus: bootComponentState[5]              0x%x\n"
operator|,
name|controllerStatus
operator|->
name|bootComponentState
index|[
literal|5
index|]
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetControllerStatus: bootComponentState[6]              0x%x\n"
operator|,
name|controllerStatus
operator|->
name|bootComponentState
index|[
literal|6
index|]
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetControllerStatus: bootComponentState[7]              0x%x\n"
operator|,
name|controllerStatus
operator|->
name|bootComponentState
index|[
literal|7
index|]
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|agNULL
operator|!=
name|saRoot
condition|)
block|{
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'b'
argument_list|,
literal|"6f"
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*! \brief SPC Get Controller Event Log Information Command  *  *  This command sends Get Controller Event Log Information Command to SPC.  *  *  \param agRoot       Handles for this instance of SAS/SATA LL  *  \param eventLogInfo event log information  *  *  \return If the MPI command is sent to SPC successfully  *          - \e AGSA_RC_SUCCESS the MPI command is successfully  *          - \e AGSA_RC_FAILURE the MPI command is failure  *  */
end_comment

begin_comment
comment|/*******************************************************************************/
end_comment

begin_function
name|GLOBAL
name|bit32
name|saGetControllerEventLogInfo
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|agsaControllerEventLog_t
modifier|*
name|eventLogInfo
parameter_list|)
block|{
name|bit32
name|ret
init|=
name|AGSA_RC_SUCCESS
decl_stmt|;
name|agsaLLRoot_t
modifier|*
name|saRoot
init|=
operator|(
name|agsaLLRoot_t
operator|*
operator|)
operator|(
name|agRoot
operator|->
name|sdkData
operator|)
decl_stmt|;
name|smTraceFuncEnter
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|"6g"
argument_list|)
expr_stmt|;
comment|/* sanity check */
name|SA_ASSERT
argument_list|(
operator|(
name|agNULL
operator|!=
name|agRoot
operator|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|eventLogInfo
operator|->
name|eventLog1
operator|=
name|saRoot
operator|->
name|memoryAllocated
operator|.
name|agMemory
index|[
name|MPI_MEM_INDEX
operator|+
name|MPI_EVENTLOG_INDEX
index|]
expr_stmt|;
name|eventLogInfo
operator|->
name|eventLog1Option
operator|=
name|saRoot
operator|->
name|mainConfigTable
operator|.
name|eventLogOption
expr_stmt|;
name|eventLogInfo
operator|->
name|eventLog2
operator|=
name|saRoot
operator|->
name|memoryAllocated
operator|.
name|agMemory
index|[
name|MPI_MEM_INDEX
operator|+
name|MPI_IOP_EVENTLOG_INDEX
index|]
expr_stmt|;
name|eventLogInfo
operator|->
name|eventLog2Option
operator|=
name|saRoot
operator|->
name|mainConfigTable
operator|.
name|IOPeventLogOption
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'a'
argument_list|,
literal|"6g"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*! \brief SPC Set GPIO Event Setup Command  *  *  This command sends GPIO Event Setup Command to SPC.  *  *  \param agRoot             Handles for this instance of SAS/SATA LL  *  \param agsaContext        Context of this command  *  \param queueNum           Queue number of inbound/outbound queue  *  \param gpioEventSetupInfo Pointer of Event Setup Information structure  *  *  \return If the MPI command is sent to SPC successfully  *          - \e AGSA_RC_SUCCESS the MPI command is successfully  *          - \e AGSA_RC_FAILURE the MPI command is failure  *  */
end_comment

begin_comment
comment|/*******************************************************************************/
end_comment

begin_function
name|GLOBAL
name|bit32
name|saGpioEventSetup
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|agsaContext_t
modifier|*
name|agContext
parameter_list|,
name|bit32
name|queueNum
parameter_list|,
name|agsaGpioEventSetupInfo_t
modifier|*
name|gpioEventSetupInfo
parameter_list|)
block|{
name|bit32
name|ret
init|=
name|AGSA_RC_SUCCESS
decl_stmt|;
name|agsaLLRoot_t
modifier|*
name|saRoot
init|=
operator|(
name|agsaLLRoot_t
operator|*
operator|)
operator|(
name|agRoot
operator|->
name|sdkData
operator|)
decl_stmt|;
name|agsaIORequestDesc_t
modifier|*
name|pRequest
decl_stmt|;
name|agsaGPIOCmd_t
name|payload
decl_stmt|;
name|smTraceFuncEnter
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|"6h"
argument_list|)
expr_stmt|;
comment|/* sanity check */
name|SA_ASSERT
argument_list|(
operator|(
name|agNULL
operator|!=
name|agRoot
operator|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* Get request from free IORequests */
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|pRequest
operator|=
operator|(
name|agsaIORequestDesc_t
operator|*
operator|)
name|saLlistIOGetHead
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|)
expr_stmt|;
comment|/* If no LL Control request entry available */
if|if
condition|(
name|agNULL
operator|==
name|pRequest
condition|)
block|{
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saGpioEventSetup, No request from free list\n"
operator|)
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'a'
argument_list|,
literal|"6h"
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_BUSY
return|;
block|}
comment|/* If LL Control request entry avaliable */
else|else
block|{
comment|/* Remove the request from free list */
name|saLlistIORemove
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|Tag
operator|=
name|pRequest
operator|->
name|HTag
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|IORequest
operator|=
operator|(
name|void
operator|*
operator|)
name|pRequest
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|agContext
operator|=
name|agContext
expr_stmt|;
name|pRequest
operator|->
name|valid
operator|=
name|agTRUE
expr_stmt|;
comment|/* set payload to zeros */
name|si_memset
argument_list|(
operator|&
name|payload
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|agsaGPIOCmd_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* build IOMB command and send to SPC */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaGPIOCmd_t
argument_list|,
name|tag
argument_list|)
argument_list|,
name|pRequest
operator|->
name|HTag
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaGPIOCmd_t
argument_list|,
name|eOBIDGeGsGrGw
argument_list|)
argument_list|,
name|GPIO_GE_BIT
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaGPIOCmd_t
argument_list|,
name|GPIEVChange
argument_list|)
argument_list|,
name|gpioEventSetupInfo
operator|->
name|gpioEventLevel
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaGPIOCmd_t
argument_list|,
name|GPIEVFall
argument_list|)
argument_list|,
name|gpioEventSetupInfo
operator|->
name|gpioEventFallingEdge
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaGPIOCmd_t
argument_list|,
name|GPIEVRise
argument_list|)
argument_list|,
name|gpioEventSetupInfo
operator|->
name|gpioEventRisingEdge
argument_list|)
expr_stmt|;
name|ret
operator|=
name|mpiBuildCmd
argument_list|(
name|agRoot
argument_list|,
operator|(
name|bit32
operator|*
operator|)
operator|&
name|payload
argument_list|,
name|MPI_CATEGORY_SAS_SATA
argument_list|,
name|OPC_INB_GPIO
argument_list|,
name|IOMB_SIZE64
argument_list|,
name|queueNum
argument_list|)
expr_stmt|;
if|if
condition|(
name|AGSA_RC_SUCCESS
operator|!=
name|ret
condition|)
block|{
comment|/* remove the request from IOMap */
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|Tag
operator|=
name|MARK_OFF
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|IORequest
operator|=
name|agNULL
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|agContext
operator|=
name|agNULL
expr_stmt|;
name|pRequest
operator|->
name|valid
operator|=
name|agFALSE
expr_stmt|;
comment|/* return the request to free pool */
if|if
condition|(
name|saLlistIOGetCount
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeReservedRequests
operator|)
argument_list|)
operator|<
name|SA_RESERVED_REQUEST_COUNT
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"saGpioEventSetup: saving pRequest (%p) for later use\n"
operator|,
name|pRequest
operator|)
argument_list|)
expr_stmt|;
name|saLlistIOAdd
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeReservedRequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* return the request to free pool */
name|saLlistIOAdd
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
block|}
name|SA_DBG1
argument_list|(
operator|(
literal|"saGpioEventSetup, sending IOMB failed\n"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'b'
argument_list|,
literal|"6h"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*! \brief SPC Set GPIO Pin Setup Command  *  *  This command sends GPIO Pin Setup Command to SPC.  *  *  \param agRoot             Handles for this instance of SAS/SATA LL  *  \param agsaContext        Context of this command  *  \param queueNum           Queue number of inbound/outbound queue  *  \param gpioPinSetupInfo   Pointer of Event Setup Information structure  *  *  \return If the MPI command is sent to SPC successfully  *          - \e AGSA_RC_SUCCESS the MPI command is successfully  *          - \e AGSA_RC_FAILURE the MPI command is failure  *  */
end_comment

begin_comment
comment|/*******************************************************************************/
end_comment

begin_function
name|GLOBAL
name|bit32
name|saGpioPinSetup
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|agsaContext_t
modifier|*
name|agContext
parameter_list|,
name|bit32
name|queueNum
parameter_list|,
name|agsaGpioPinSetupInfo_t
modifier|*
name|gpioPinSetupInfo
parameter_list|)
block|{
name|bit32
name|ret
init|=
name|AGSA_RC_SUCCESS
decl_stmt|;
name|agsaLLRoot_t
modifier|*
name|saRoot
init|=
operator|(
name|agsaLLRoot_t
operator|*
operator|)
operator|(
name|agRoot
operator|->
name|sdkData
operator|)
decl_stmt|;
name|agsaIORequestDesc_t
modifier|*
name|pRequest
decl_stmt|;
name|agsaGPIOCmd_t
name|payload
decl_stmt|;
name|smTraceFuncEnter
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|"6i"
argument_list|)
expr_stmt|;
comment|/* sanity check */
name|SA_ASSERT
argument_list|(
operator|(
name|agNULL
operator|!=
name|agRoot
operator|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* Get request from free IORequests */
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|pRequest
operator|=
operator|(
name|agsaIORequestDesc_t
operator|*
operator|)
name|saLlistIOGetHead
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|)
expr_stmt|;
comment|/* If no LL Control request entry available */
if|if
condition|(
name|agNULL
operator|==
name|pRequest
condition|)
block|{
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saGpioPinSetup, No request from free list\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_BUSY
return|;
block|}
comment|/* If LL Control request entry avaliable */
else|else
block|{
comment|/* Remove the request from free list */
name|saLlistIORemove
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|Tag
operator|=
name|pRequest
operator|->
name|HTag
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|IORequest
operator|=
operator|(
name|void
operator|*
operator|)
name|pRequest
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|agContext
operator|=
name|agContext
expr_stmt|;
name|pRequest
operator|->
name|valid
operator|=
name|agTRUE
expr_stmt|;
comment|/* set payload to zeros */
name|si_memset
argument_list|(
operator|&
name|payload
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|agsaGPIOCmd_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* build IOMB command and send to SPC */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaGPIOCmd_t
argument_list|,
name|tag
argument_list|)
argument_list|,
name|pRequest
operator|->
name|HTag
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaGPIOCmd_t
argument_list|,
name|eOBIDGeGsGrGw
argument_list|)
argument_list|,
name|GPIO_GS_BIT
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaGPIOCmd_t
argument_list|,
name|GpioIe
argument_list|)
argument_list|,
name|gpioPinSetupInfo
operator|->
name|gpioInputEnabled
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaGPIOCmd_t
argument_list|,
name|OT11_0
argument_list|)
argument_list|,
name|gpioPinSetupInfo
operator|->
name|gpioTypePart1
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaGPIOCmd_t
argument_list|,
name|OT19_12
argument_list|)
argument_list|,
name|gpioPinSetupInfo
operator|->
name|gpioTypePart2
argument_list|)
expr_stmt|;
name|ret
operator|=
name|mpiBuildCmd
argument_list|(
name|agRoot
argument_list|,
operator|(
name|bit32
operator|*
operator|)
operator|&
name|payload
argument_list|,
name|MPI_CATEGORY_SAS_SATA
argument_list|,
name|OPC_INB_GPIO
argument_list|,
name|IOMB_SIZE64
argument_list|,
name|queueNum
argument_list|)
expr_stmt|;
if|if
condition|(
name|AGSA_RC_SUCCESS
operator|!=
name|ret
condition|)
block|{
comment|/* remove the request from IOMap */
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|Tag
operator|=
name|MARK_OFF
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|IORequest
operator|=
name|agNULL
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|agContext
operator|=
name|agNULL
expr_stmt|;
name|pRequest
operator|->
name|valid
operator|=
name|agFALSE
expr_stmt|;
comment|/* return the request to free pool */
if|if
condition|(
name|saLlistIOGetCount
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeReservedRequests
operator|)
argument_list|)
operator|<
name|SA_RESERVED_REQUEST_COUNT
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"saGpioPinSetup: saving pRequest (%p) for later use\n"
operator|,
name|pRequest
operator|)
argument_list|)
expr_stmt|;
name|saLlistIOAdd
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeReservedRequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* return the request to free pool */
name|saLlistIOAdd
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
block|}
name|SA_DBG1
argument_list|(
operator|(
literal|"saGpioPinSetup, sending IOMB failed\n"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'a'
argument_list|,
literal|"6i"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*! \brief SPC GPIO Read Command  *  *  This command sends GPIO Read Command to SPC.  *  *  \param agRoot       Handles for this instance of SAS/SATA LL  *  \param agsaContext  Context of this command  *  \param queueNum     Queue number of inbound/outbound queue  *  *  \return If the MPI command is sent to SPC successfully  *          - \e AGSA_RC_SUCCESS the MPI command is successfully  *          - \e AGSA_RC_FAILURE the MPI command is failure  *  */
end_comment

begin_comment
comment|/*******************************************************************************/
end_comment

begin_function
name|GLOBAL
name|bit32
name|saGpioRead
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|agsaContext_t
modifier|*
name|agContext
parameter_list|,
name|bit32
name|queueNum
parameter_list|)
block|{
name|bit32
name|ret
init|=
name|AGSA_RC_SUCCESS
decl_stmt|;
name|agsaLLRoot_t
modifier|*
name|saRoot
init|=
operator|(
name|agsaLLRoot_t
operator|*
operator|)
operator|(
name|agRoot
operator|->
name|sdkData
operator|)
decl_stmt|;
name|agsaIORequestDesc_t
modifier|*
name|pRequest
decl_stmt|;
name|agsaGPIOCmd_t
name|payload
decl_stmt|;
name|smTraceFuncEnter
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|"6j"
argument_list|)
expr_stmt|;
comment|/* sanity check */
name|SA_ASSERT
argument_list|(
operator|(
name|agNULL
operator|!=
name|agRoot
operator|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* Get request from free IORequests */
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|pRequest
operator|=
operator|(
name|agsaIORequestDesc_t
operator|*
operator|)
name|saLlistIOGetHead
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|)
expr_stmt|;
comment|/* If no LL Control request entry available */
if|if
condition|(
name|agNULL
operator|==
name|pRequest
condition|)
block|{
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saGpioRead, No request from free list\n"
operator|)
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'a'
argument_list|,
literal|"6j"
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_BUSY
return|;
block|}
comment|/* If LL Control request entry avaliable */
else|else
block|{
comment|/* Remove the request from free list */
name|saLlistIORemove
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|Tag
operator|=
name|pRequest
operator|->
name|HTag
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|IORequest
operator|=
operator|(
name|void
operator|*
operator|)
name|pRequest
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|agContext
operator|=
name|agContext
expr_stmt|;
name|pRequest
operator|->
name|valid
operator|=
name|agTRUE
expr_stmt|;
comment|/* set payload to zeros */
name|si_memset
argument_list|(
operator|&
name|payload
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|agsaGPIOCmd_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* build IOMB command and send to SPC */
comment|/* set GR bit */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaGPIOCmd_t
argument_list|,
name|tag
argument_list|)
argument_list|,
name|pRequest
operator|->
name|HTag
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaGPIOCmd_t
argument_list|,
name|eOBIDGeGsGrGw
argument_list|)
argument_list|,
name|GPIO_GR_BIT
argument_list|)
expr_stmt|;
name|ret
operator|=
name|mpiBuildCmd
argument_list|(
name|agRoot
argument_list|,
operator|(
name|bit32
operator|*
operator|)
operator|&
name|payload
argument_list|,
name|MPI_CATEGORY_SAS_SATA
argument_list|,
name|OPC_INB_GPIO
argument_list|,
name|IOMB_SIZE64
argument_list|,
name|queueNum
argument_list|)
expr_stmt|;
if|if
condition|(
name|AGSA_RC_SUCCESS
operator|!=
name|ret
condition|)
block|{
comment|/* remove the request from IOMap */
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|Tag
operator|=
name|MARK_OFF
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|IORequest
operator|=
name|agNULL
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|agContext
operator|=
name|agNULL
expr_stmt|;
name|pRequest
operator|->
name|valid
operator|=
name|agFALSE
expr_stmt|;
comment|/* return the request to free pool */
if|if
condition|(
name|saLlistIOGetCount
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeReservedRequests
operator|)
argument_list|)
operator|<
name|SA_RESERVED_REQUEST_COUNT
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"saGpioRead: saving pRequest (%p) for later use\n"
operator|,
name|pRequest
operator|)
argument_list|)
expr_stmt|;
name|saLlistIOAdd
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeReservedRequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* return the request to free pool */
name|saLlistIOAdd
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
block|}
name|SA_DBG1
argument_list|(
operator|(
literal|"saGpioRead, sending IOMB failed\n"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'b'
argument_list|,
literal|"6j"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*! \brief SPC GPIO Write Command  *  *  This command sends GPIO Write Command to SPC.  *  *  \param agRoot         Handles for this instance of SAS/SATA LL  *  \param agsaContext    Context of this command  *  \param queueNum       Queue number of inbound/outbound queue  *  \param gpioWriteMask  GPIO Write Mask  *  \param gpioWriteValue GPIO Write Value  *  *  \return If the MPI command is sent to SPC successfully  *          - \e AGSA_RC_SUCCESS the MPI command is successfully  *          - \e AGSA_RC_FAILURE the MPI command is failure  *  */
end_comment

begin_comment
comment|/*******************************************************************************/
end_comment

begin_function
name|GLOBAL
name|bit32
name|saGpioWrite
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|agsaContext_t
modifier|*
name|agContext
parameter_list|,
name|bit32
name|queueNum
parameter_list|,
name|bit32
name|gpioWriteMask
parameter_list|,
name|bit32
name|gpioWriteValue
parameter_list|)
block|{
name|bit32
name|ret
init|=
name|AGSA_RC_SUCCESS
decl_stmt|;
name|agsaLLRoot_t
modifier|*
name|saRoot
init|=
operator|(
name|agsaLLRoot_t
operator|*
operator|)
operator|(
name|agRoot
operator|->
name|sdkData
operator|)
decl_stmt|;
name|agsaIORequestDesc_t
modifier|*
name|pRequest
decl_stmt|;
name|agsaGPIOCmd_t
name|payload
decl_stmt|;
name|smTraceFuncEnter
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|"6k"
argument_list|)
expr_stmt|;
comment|/* sanity check */
name|SA_ASSERT
argument_list|(
operator|(
name|agNULL
operator|!=
name|agRoot
operator|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* Get request from free IORequests */
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|pRequest
operator|=
operator|(
name|agsaIORequestDesc_t
operator|*
operator|)
name|saLlistIOGetHead
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|)
expr_stmt|;
comment|/* If no LL Control request entry available */
if|if
condition|(
name|agNULL
operator|==
name|pRequest
condition|)
block|{
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saGpioWrite, No request from free list\n"
operator|)
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'a'
argument_list|,
literal|"6k"
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_BUSY
return|;
block|}
comment|/* If LL Control request entry avaliable */
else|else
block|{
comment|/* Remove the request from free list */
name|saLlistIORemove
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|Tag
operator|=
name|pRequest
operator|->
name|HTag
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|IORequest
operator|=
operator|(
name|void
operator|*
operator|)
name|pRequest
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|agContext
operator|=
name|agContext
expr_stmt|;
name|pRequest
operator|->
name|valid
operator|=
name|agTRUE
expr_stmt|;
comment|/* set payload to zeros */
name|si_memset
argument_list|(
operator|&
name|payload
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|agsaGPIOCmd_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* build IOMB command and send to SPC */
comment|/* set GW bit */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaGPIOCmd_t
argument_list|,
name|tag
argument_list|)
argument_list|,
name|pRequest
operator|->
name|HTag
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaGPIOCmd_t
argument_list|,
name|eOBIDGeGsGrGw
argument_list|)
argument_list|,
name|GPIO_GW_BIT
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaGPIOCmd_t
argument_list|,
name|GpioWrMsk
argument_list|)
argument_list|,
name|gpioWriteMask
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaGPIOCmd_t
argument_list|,
name|GpioWrVal
argument_list|)
argument_list|,
name|gpioWriteValue
argument_list|)
expr_stmt|;
name|ret
operator|=
name|mpiBuildCmd
argument_list|(
name|agRoot
argument_list|,
operator|(
name|bit32
operator|*
operator|)
operator|&
name|payload
argument_list|,
name|MPI_CATEGORY_SAS_SATA
argument_list|,
name|OPC_INB_GPIO
argument_list|,
name|IOMB_SIZE64
argument_list|,
name|queueNum
argument_list|)
expr_stmt|;
if|if
condition|(
name|AGSA_RC_SUCCESS
operator|!=
name|ret
condition|)
block|{
comment|/* remove the request from IOMap */
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|Tag
operator|=
name|MARK_OFF
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|IORequest
operator|=
name|agNULL
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|agContext
operator|=
name|agNULL
expr_stmt|;
name|pRequest
operator|->
name|valid
operator|=
name|agFALSE
expr_stmt|;
comment|/* return the request to free pool */
if|if
condition|(
name|saLlistIOGetCount
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeReservedRequests
operator|)
argument_list|)
operator|<
name|SA_RESERVED_REQUEST_COUNT
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"saGpioWrite: saving pRequest (%p) for later use\n"
operator|,
name|pRequest
operator|)
argument_list|)
expr_stmt|;
name|saLlistIOAdd
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeReservedRequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* return the request to free pool */
name|saLlistIOAdd
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
block|}
name|SA_DBG1
argument_list|(
operator|(
literal|"saGpioWrite, sending IOMB failed\n"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'b'
argument_list|,
literal|"6k"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*! \brief SPC SAS Diagnostic Execute Command  *  *  This command sends SAS Diagnostic Execute Command to SPC.  *  *  \param agRoot         Handles for this instance of SAS/SATA LL  *  \param agsaContext    Context of this command  *  \param queueNum       Queue number of inbound/outbound queue  *  \param diag           Pointer of SAS Diag Execute Structure  *  *  \return If the MPI command is sent to SPC successfully  *          - \e AGSA_RC_SUCCESS the MPI command is successfully  *          - \e AGSA_RC_FAILURE the MPI command is failure  *  */
end_comment

begin_comment
comment|/*******************************************************************************/
end_comment

begin_function
name|GLOBAL
name|bit32
name|saSASDiagExecute
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|agsaContext_t
modifier|*
name|agContext
parameter_list|,
name|bit32
name|queueNum
parameter_list|,
name|agsaSASDiagExecute_t
modifier|*
name|diag
parameter_list|)
block|{
name|bit32
name|ret
init|=
name|AGSA_RC_SUCCESS
decl_stmt|;
name|agsaLLRoot_t
modifier|*
name|saRoot
init|=
name|agNULL
decl_stmt|;
name|agsaIORequestDesc_t
modifier|*
name|pRequest
init|=
name|agNULL
decl_stmt|;
name|bit32
name|payload
index|[
literal|32
index|]
decl_stmt|;
comment|/* sanity check */
name|SA_ASSERT
argument_list|(
operator|(
name|agNULL
operator|!=
name|agRoot
operator|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|saRoot
operator|=
operator|(
name|agsaLLRoot_t
operator|*
operator|)
operator|(
name|agRoot
operator|->
name|sdkData
operator|)
expr_stmt|;
comment|/* sanity check */
name|SA_ASSERT
argument_list|(
operator|(
name|agNULL
operator|!=
name|saRoot
operator|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|smTraceFuncEnter
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|"6m"
argument_list|)
expr_stmt|;
name|SA_DBG2
argument_list|(
operator|(
literal|"saSASDiagExecute,command 0x%X\n"
operator|,
name|diag
operator|->
name|command
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG2
argument_list|(
operator|(
literal|"saSASDiagExecute,param0 0x%X\n"
operator|,
name|diag
operator|->
name|param0
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG2
argument_list|(
operator|(
literal|"saSASDiagExecute,param2 0x%X\n"
operator|,
name|diag
operator|->
name|param2
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG2
argument_list|(
operator|(
literal|"saSASDiagExecute,param3 0x%X\n"
operator|,
name|diag
operator|->
name|param3
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG2
argument_list|(
operator|(
literal|"saSASDiagExecute,param4 0x%X\n"
operator|,
name|diag
operator|->
name|param4
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG2
argument_list|(
operator|(
literal|"saSASDiagExecute,param5 0x%X\n"
operator|,
name|diag
operator|->
name|param5
operator|)
argument_list|)
expr_stmt|;
comment|/* Get request from free IORequests */
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|pRequest
operator|=
operator|(
name|agsaIORequestDesc_t
operator|*
operator|)
name|saLlistIOGetHead
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|)
expr_stmt|;
comment|/* If no LL Control request entry available */
if|if
condition|(
name|agNULL
operator|==
name|pRequest
condition|)
block|{
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saSASDiagExecute, No request from free list\n"
operator|)
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'a'
argument_list|,
literal|"6m"
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_BUSY
return|;
block|}
comment|/* If LL Control request entry avaliable */
else|else
block|{
comment|/* Remove the request from free list */
name|saLlistIORemove
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|Tag
operator|=
name|pRequest
operator|->
name|HTag
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|IORequest
operator|=
operator|(
name|void
operator|*
operator|)
name|pRequest
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|agContext
operator|=
name|agContext
expr_stmt|;
name|pRequest
operator|->
name|valid
operator|=
name|agTRUE
expr_stmt|;
if|if
condition|(
name|smIS_SPC
argument_list|(
name|agRoot
argument_list|)
condition|)
block|{
name|diag
operator|->
name|param5
operator|=
literal|0
expr_stmt|;
comment|/* Reserved for SPC */
block|}
comment|/* set payload to zeros */
name|si_memset
argument_list|(
operator|&
name|payload
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|payload
argument_list|)
argument_list|)
expr_stmt|;
comment|/* set payload to zeros */
if|if
condition|(
name|smIS_SPCV
argument_list|(
name|agRoot
argument_list|)
condition|)
block|{
comment|/* build IOMB command and send to SPC */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSASDiagExecuteCmd_t
argument_list|,
name|tag
argument_list|)
argument_list|,
name|pRequest
operator|->
name|HTag
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSASDiagExecuteCmd_t
argument_list|,
name|CmdTypeDescPhyId
argument_list|)
argument_list|,
name|diag
operator|->
name|command
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSASDiagExecuteCmd_t
argument_list|,
name|Pat1Pat2
argument_list|)
argument_list|,
name|diag
operator|->
name|param0
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSASDiagExecuteCmd_t
argument_list|,
name|Threshold
argument_list|)
argument_list|,
name|diag
operator|->
name|param1
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSASDiagExecuteCmd_t
argument_list|,
name|CodePatErrMsk
argument_list|)
argument_list|,
name|diag
operator|->
name|param2
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSASDiagExecuteCmd_t
argument_list|,
name|Pmon
argument_list|)
argument_list|,
name|diag
operator|->
name|param3
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSASDiagExecuteCmd_t
argument_list|,
name|PERF1CTL
argument_list|)
argument_list|,
name|diag
operator|->
name|param4
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSASDiagExecuteCmd_t
argument_list|,
name|THRSHLD1
argument_list|)
argument_list|,
name|diag
operator|->
name|param5
argument_list|)
expr_stmt|;
name|ret
operator|=
name|mpiBuildCmd
argument_list|(
name|agRoot
argument_list|,
operator|(
name|bit32
operator|*
operator|)
operator|&
name|payload
argument_list|,
name|MPI_CATEGORY_SAS_SATA
argument_list|,
name|OPC_INB_SAS_DIAG_EXECUTE
argument_list|,
name|IOMB_SIZE128
argument_list|,
name|queueNum
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* build IOMB command and send to SPC */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsa_SPC_SASDiagExecuteCmd_t
argument_list|,
name|tag
argument_list|)
argument_list|,
name|pRequest
operator|->
name|HTag
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsa_SPC_SASDiagExecuteCmd_t
argument_list|,
name|CmdTypeDescPhyId
argument_list|)
argument_list|,
name|diag
operator|->
name|command
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsa_SPC_SASDiagExecuteCmd_t
argument_list|,
name|Pat1Pat2
argument_list|)
argument_list|,
name|diag
operator|->
name|param0
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsa_SPC_SASDiagExecuteCmd_t
argument_list|,
name|Threshold
argument_list|)
argument_list|,
name|diag
operator|->
name|param1
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsa_SPC_SASDiagExecuteCmd_t
argument_list|,
name|CodePatErrMsk
argument_list|)
argument_list|,
name|diag
operator|->
name|param2
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsa_SPC_SASDiagExecuteCmd_t
argument_list|,
name|Pmon
argument_list|)
argument_list|,
name|diag
operator|->
name|param3
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsa_SPC_SASDiagExecuteCmd_t
argument_list|,
name|PERF1CTL
argument_list|)
argument_list|,
name|diag
operator|->
name|param4
argument_list|)
expr_stmt|;
name|ret
operator|=
name|mpiBuildCmd
argument_list|(
name|agRoot
argument_list|,
operator|(
name|bit32
operator|*
operator|)
operator|&
name|payload
argument_list|,
name|MPI_CATEGORY_SAS_SATA
argument_list|,
name|OPC_INB_SAS_DIAG_EXECUTE
argument_list|,
name|IOMB_SIZE64
argument_list|,
name|queueNum
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|AGSA_RC_SUCCESS
operator|!=
name|ret
condition|)
block|{
comment|/* remove the request from IOMap */
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|Tag
operator|=
name|MARK_OFF
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|IORequest
operator|=
name|agNULL
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|agContext
operator|=
name|agNULL
expr_stmt|;
name|pRequest
operator|->
name|valid
operator|=
name|agFALSE
expr_stmt|;
comment|/* return the request to free pool */
if|if
condition|(
name|saLlistIOGetCount
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeReservedRequests
operator|)
argument_list|)
operator|<
name|SA_RESERVED_REQUEST_COUNT
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"saSASDiagExecute: saving pRequest (%p) for later use\n"
operator|,
name|pRequest
operator|)
argument_list|)
expr_stmt|;
name|saLlistIOAdd
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeReservedRequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* return the request to free pool */
name|saLlistIOAdd
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
block|}
name|SA_DBG1
argument_list|(
operator|(
literal|"saSASDiagExecute, sending IOMB failed\n"
operator|)
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'b'
argument_list|,
literal|"6m"
argument_list|)
expr_stmt|;
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
block|}
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'c'
argument_list|,
literal|"6m"
argument_list|)
expr_stmt|;
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*! \brief SPC SAS Diagnostic Start/End Command  *  *  This command sends SAS Diagnostic Start/End Command to SPC.  *  *  \param agRoot         Handles for this instance of SAS/SATA LL  *  \param agsaContext    Context of this command  *  \param queueNum       Queue number of inbound/outbound queue  *  \param phyId          Phy ID  *  \param operation      Operation of SAS Diagnostic  *  *  \return If the MPI command is sent to SPC successfully  *          - \e AGSA_RC_SUCCESS the MPI command is successfully  *          - \e AGSA_RC_FAILURE the MPI command is failure  *  */
end_comment

begin_comment
comment|/*******************************************************************************/
end_comment

begin_function
name|GLOBAL
name|bit32
name|saSASDiagStartEnd
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|agsaContext_t
modifier|*
name|agContext
parameter_list|,
name|bit32
name|queueNum
parameter_list|,
name|bit32
name|phyId
parameter_list|,
name|bit32
name|operation
parameter_list|)
block|{
name|bit32
name|ret
init|=
name|AGSA_RC_SUCCESS
decl_stmt|;
name|agsaLLRoot_t
modifier|*
name|saRoot
decl_stmt|;
name|agsaIORequestDesc_t
modifier|*
name|pRequest
decl_stmt|;
name|agsaSASDiagStartEndCmd_t
name|payload
decl_stmt|;
comment|/* sanity check */
name|SA_ASSERT
argument_list|(
operator|(
name|agNULL
operator|!=
name|agRoot
operator|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|agRoot
operator|==
name|agNULL
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"saSASDiagStartEnd: agRoot == agNULL\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_FAILURE
return|;
block|}
name|saRoot
operator|=
operator|(
name|agsaLLRoot_t
operator|*
operator|)
operator|(
name|agRoot
operator|->
name|sdkData
operator|)
expr_stmt|;
name|SA_ASSERT
argument_list|(
operator|(
name|agNULL
operator|!=
name|saRoot
operator|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|saRoot
operator|==
name|agNULL
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"saSASDiagStartEnd: saRoot == agNULL\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_FAILURE
return|;
block|}
name|smTraceFuncEnter
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|"6n"
argument_list|)
expr_stmt|;
name|SA_DBG3
argument_list|(
operator|(
literal|"saSASDiagStartEnd, phyId 0x%x operation 0x%x\n"
operator|,
name|phyId
operator|,
name|operation
operator|)
argument_list|)
expr_stmt|;
comment|/* Get request from free IORequests */
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|pRequest
operator|=
operator|(
name|agsaIORequestDesc_t
operator|*
operator|)
name|saLlistIOGetHead
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|)
expr_stmt|;
comment|/* If no LL Control request entry available */
if|if
condition|(
name|agNULL
operator|==
name|pRequest
condition|)
block|{
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saSASDiagStartEnd, No request from free list\n"
operator|)
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'a'
argument_list|,
literal|"6n"
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_BUSY
return|;
block|}
comment|/* If LL Control request entry avaliable */
else|else
block|{
comment|/* Remove the request from free list */
name|saLlistIORemove
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|Tag
operator|=
name|pRequest
operator|->
name|HTag
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|IORequest
operator|=
operator|(
name|void
operator|*
operator|)
name|pRequest
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|agContext
operator|=
name|agContext
expr_stmt|;
name|pRequest
operator|->
name|valid
operator|=
name|agTRUE
expr_stmt|;
comment|/* set payload to zeros */
name|si_memset
argument_list|(
operator|&
name|payload
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|agsaSASDiagStartEndCmd_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* build IOMB command and send to SPC */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSASDiagStartEndCmd_t
argument_list|,
name|tag
argument_list|)
argument_list|,
name|pRequest
operator|->
name|HTag
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSASDiagStartEndCmd_t
argument_list|,
name|OperationPhyId
argument_list|)
argument_list|,
operator|(
operator|(
name|phyId
operator|&
name|SM_PHYID_MASK
operator|)
operator||
operator|(
name|operation
operator|<<
name|SHIFT8
operator|)
operator|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|mpiBuildCmd
argument_list|(
name|agRoot
argument_list|,
operator|(
name|bit32
operator|*
operator|)
operator|&
name|payload
argument_list|,
name|MPI_CATEGORY_SAS_SATA
argument_list|,
name|OPC_INB_SAS_DIAG_MODE_START_END
argument_list|,
name|IOMB_SIZE64
argument_list|,
name|queueNum
argument_list|)
expr_stmt|;
if|if
condition|(
name|AGSA_RC_SUCCESS
operator|!=
name|ret
condition|)
block|{
comment|/* remove the request from IOMap */
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|Tag
operator|=
name|MARK_OFF
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|IORequest
operator|=
name|agNULL
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|agContext
operator|=
name|agNULL
expr_stmt|;
name|pRequest
operator|->
name|valid
operator|=
name|agFALSE
expr_stmt|;
comment|/* return the request to free pool */
if|if
condition|(
name|saLlistIOGetCount
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeReservedRequests
operator|)
argument_list|)
operator|<
name|SA_RESERVED_REQUEST_COUNT
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"saSASDiagStartEnd: saving pRequest (%p) for later use\n"
operator|,
name|pRequest
operator|)
argument_list|)
expr_stmt|;
name|saLlistIOAdd
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeReservedRequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* return the request to free pool */
name|saLlistIOAdd
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
block|}
name|SA_DBG1
argument_list|(
operator|(
literal|"saSASDiagStartEnd, sending IOMB failed\n"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'b'
argument_list|,
literal|"6n"
argument_list|)
expr_stmt|;
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*! \brief Initiate a GET TIME STAMP command  *  *  This function is called to initiate a Get Time Stamp command to the SPC.  *  The completion of this function is reported in ossaGetTimeStampCB().  *  *  \param agRoot      handles for this instance of SAS/SATA hardware  *  \param agContext   the context of this API  *  \param queueNum    queue number  *  *  \return  *          - SUCCESS or FAILURE  */
end_comment

begin_comment
comment|/*******************************************************************************/
end_comment

begin_function
name|GLOBAL
name|bit32
name|saGetTimeStamp
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|agsaContext_t
modifier|*
name|agContext
parameter_list|,
name|bit32
name|queueNum
parameter_list|)
block|{
name|agsaIORequestDesc_t
modifier|*
name|pRequest
decl_stmt|;
name|agsaGetTimeStampCmd_t
name|payload
decl_stmt|;
name|bit32
name|ret
init|=
name|AGSA_RC_SUCCESS
decl_stmt|;
name|agsaLLRoot_t
modifier|*
name|saRoot
decl_stmt|;
name|SA_ASSERT
argument_list|(
operator|(
name|agNULL
operator|!=
name|agRoot
operator|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|agRoot
operator|==
name|agNULL
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetTimeStamp: agRoot == agNULL\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_FAILURE
return|;
block|}
name|saRoot
operator|=
operator|(
name|agsaLLRoot_t
operator|*
operator|)
operator|(
name|agRoot
operator|->
name|sdkData
operator|)
expr_stmt|;
name|SA_ASSERT
argument_list|(
operator|(
name|agNULL
operator|!=
name|saRoot
operator|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|saRoot
operator|==
name|agNULL
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetTimeStamp: saRoot == agNULL\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_FAILURE
return|;
block|}
name|smTraceFuncEnter
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|"6o"
argument_list|)
expr_stmt|;
comment|/* sanity check */
name|SA_ASSERT
argument_list|(
operator|(
name|agNULL
operator|!=
name|agRoot
operator|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|SA_DBG3
argument_list|(
operator|(
literal|"saGetTimeStamp: agContext %p\n"
operator|,
name|agContext
operator|)
argument_list|)
expr_stmt|;
comment|/* Get request from free IORequests */
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|pRequest
operator|=
operator|(
name|agsaIORequestDesc_t
operator|*
operator|)
name|saLlistIOGetHead
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|)
expr_stmt|;
comment|/* If no LL Control request entry available */
if|if
condition|(
name|agNULL
operator|==
name|pRequest
condition|)
block|{
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetTimeStamp, No request from free list\n"
operator|)
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'a'
argument_list|,
literal|"6o"
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_BUSY
return|;
block|}
comment|/* If LL Control request entry avaliable */
else|else
block|{
comment|/* Remove the request from free list */
name|saLlistIORemove
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|Tag
operator|=
name|pRequest
operator|->
name|HTag
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|IORequest
operator|=
operator|(
name|void
operator|*
operator|)
name|pRequest
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|agContext
operator|=
name|agContext
expr_stmt|;
name|pRequest
operator|->
name|valid
operator|=
name|agTRUE
expr_stmt|;
comment|/* build IOMB command and send to SPC */
comment|/* set payload to zeros */
name|si_memset
argument_list|(
operator|&
name|payload
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|agsaGetTimeStampCmd_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* set tag */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaGetTimeStampCmd_t
argument_list|,
name|tag
argument_list|)
argument_list|,
name|pRequest
operator|->
name|HTag
argument_list|)
expr_stmt|;
comment|/* build IOMB command and send to SPC */
name|ret
operator|=
name|mpiBuildCmd
argument_list|(
name|agRoot
argument_list|,
operator|(
name|bit32
operator|*
operator|)
operator|&
name|payload
argument_list|,
name|MPI_CATEGORY_SAS_SATA
argument_list|,
name|OPC_INB_GET_TIME_STAMP
argument_list|,
name|IOMB_SIZE64
argument_list|,
name|queueNum
argument_list|)
expr_stmt|;
if|if
condition|(
name|AGSA_RC_SUCCESS
operator|!=
name|ret
condition|)
block|{
comment|/* remove the request from IOMap */
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|Tag
operator|=
name|MARK_OFF
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|IORequest
operator|=
name|agNULL
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|agContext
operator|=
name|agNULL
expr_stmt|;
name|pRequest
operator|->
name|valid
operator|=
name|agFALSE
expr_stmt|;
comment|/* return the request to free pool */
if|if
condition|(
name|saLlistIOGetCount
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeReservedRequests
operator|)
argument_list|)
operator|<
name|SA_RESERVED_REQUEST_COUNT
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetTimeStamp: saving pRequest (%p) for later use\n"
operator|,
name|pRequest
operator|)
argument_list|)
expr_stmt|;
name|saLlistIOAdd
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeReservedRequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* return the request to free pool */
name|saLlistIOAdd
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
block|}
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetTimeStamp, sending IOMB failed\n"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'b'
argument_list|,
literal|"6o"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*! \brief Update IOMap Entry    *  *  This function is called to update certain fields of IOMap Entry  *   *  \param pIOMap       IOMap Entry  *  \param HTag         Host Tag  *  \param pRequest     Request  *  \parma agContext    Context of this API  *  *  \return             NA  */
end_comment

begin_comment
comment|/*******************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|saUpdateIOMap
parameter_list|(
name|agsaIOMap_t
modifier|*
name|pIOMap
parameter_list|,
name|bit32
name|HTag
parameter_list|,
name|agsaIORequestDesc_t
modifier|*
name|pRequest
parameter_list|,
name|agsaContext_t
modifier|*
name|agContext
parameter_list|)
block|{
name|pIOMap
operator|->
name|Tag
operator|=
name|HTag
expr_stmt|;
name|pIOMap
operator|->
name|IORequest
operator|=
operator|(
name|void
operator|*
operator|)
name|pRequest
expr_stmt|;
name|pIOMap
operator|->
name|agContext
operator|=
name|agContext
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*! \brief Get a request from free pool  *  *  This function gets a request from free pool  *   *  \param agRoot       Handles for this instance of SAS/SATA LL  *  \param agsaContext  Context of this command  *  *  \return  *          - \e Pointer to request, in case of success  *          - \e NULL, in case of failure   *  */
end_comment

begin_comment
comment|/*******************************************************************************/
end_comment

begin_function
name|agsaIORequestDesc_t
modifier|*
name|saGetRequestFromFreePool
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|agsaContext_t
modifier|*
name|agContext
parameter_list|)
block|{
name|agsaLLRoot_t
modifier|*
name|saRoot
init|=
operator|(
name|agsaLLRoot_t
operator|*
operator|)
operator|(
name|agRoot
operator|->
name|sdkData
operator|)
decl_stmt|;
name|agsaIORequestDesc_t
modifier|*
name|pRequest
init|=
name|agNULL
decl_stmt|;
comment|/* Acquire LL_IOREQ_LOCKEQ_LOCK */
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
comment|/* Get request from free IORequests */
name|pRequest
operator|=
operator|(
name|agsaIORequestDesc_t
operator|*
operator|)
name|saLlistIOGetHead
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pRequest
operator|!=
name|agNULL
condition|)
block|{
comment|/* Remove the request from free list */
name|saLlistIORemove
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
comment|/* Release LL_IOREQ_LOCKEQ_LOCK */
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
comment|/* Add the request to IOMap */
name|saUpdateIOMap
argument_list|(
operator|&
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
argument_list|,
name|pRequest
operator|->
name|HTag
argument_list|,
name|pRequest
argument_list|,
name|agContext
argument_list|)
expr_stmt|;
name|pRequest
operator|->
name|valid
operator|=
name|agTRUE
expr_stmt|;
block|}
else|else
block|{
comment|/* Release LL_IOREQ_LOCKEQ_LOCK */
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
block|}
return|return
name|pRequest
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*! \brief Return request to free pool  *  *  This function returns the request to free pool  *   *  \param agRoot       Handles for this instance of SAS/SATA LL  *  \param pRequest     Request to be returned  *  *  \return             NA               *  */
end_comment

begin_comment
comment|/*******************************************************************************/
end_comment

begin_function
name|void
name|saReturnRequestToFreePool
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|agsaIORequestDesc_t
modifier|*
name|pRequest
parameter_list|)
block|{
name|agsaLLRoot_t
modifier|*
name|saRoot
init|=
operator|(
name|agsaLLRoot_t
operator|*
operator|)
operator|(
name|agRoot
operator|->
name|sdkData
operator|)
decl_stmt|;
name|SA_ASSERT
argument_list|(
operator|(
name|pRequest
operator|->
name|valid
operator|)
argument_list|,
literal|"pRequest->valid"
argument_list|)
expr_stmt|;
comment|/* Remove the request from IOMap */
name|saUpdateIOMap
argument_list|(
operator|&
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
argument_list|,
name|MARK_OFF
argument_list|,
name|agNULL
argument_list|,
name|agNULL
argument_list|)
expr_stmt|;
name|pRequest
operator|->
name|valid
operator|=
name|agFALSE
expr_stmt|;
comment|/* Acquire LL_IOREQ_LOCKEQ_LOCK */
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
if|if
condition|(
name|saLlistIOGetCount
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeReservedRequests
operator|)
argument_list|)
operator|<
name|SA_RESERVED_REQUEST_COUNT
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"saReturnRequestToFreePool: saving pRequest (%p) for later use\n"
operator|,
name|pRequest
operator|)
argument_list|)
expr_stmt|;
name|saLlistIOAdd
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeReservedRequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Return the request to free pool */
name|saLlistIOAdd
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* Release LL_IOREQ_LOCKEQ_LOCK */
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*! \brief Initiate a serial GPIO command  *  *  This function is called to initiate a serial GPIO command to the SPC.  *  The completion of this function is reported in ossaSgpioCB().  *  *  \param agRoot      handles for this instance of SAS/SATA hardware  *  \param agContext   the context of this API  *  \param queueNum    queue number  *  \param pSGpioReq   Pointer to the serial GPIO fields  *  *  \return   *          - SUCCESS or FAILURE  */
end_comment

begin_comment
comment|/*******************************************************************************/
end_comment

begin_function
name|GLOBAL
name|bit32
name|saSgpio
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|agsaContext_t
modifier|*
name|agContext
parameter_list|,
name|bit32
name|queueNum
parameter_list|,
name|agsaSGpioReqResponse_t
modifier|*
name|pSGpioReq
parameter_list|)
block|{
name|bit32
name|i
decl_stmt|;
name|agsaIORequestDesc_t
modifier|*
name|pRequest
init|=
name|agNULL
decl_stmt|;
name|agsaSGpioCmd_t
name|payload
init|=
block|{
literal|0
block|}
decl_stmt|;
name|bit32
name|ret
init|=
name|AGSA_RC_BUSY
decl_stmt|;
name|smTraceFuncEnter
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|"6t"
argument_list|)
expr_stmt|;
comment|/* Sanity check */
name|SA_ASSERT
argument_list|(
operator|(
name|agNULL
operator|!=
name|agRoot
operator|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|SA_DBG3
argument_list|(
operator|(
literal|"saSgpio: agContext %p\n"
operator|,
name|agContext
operator|)
argument_list|)
expr_stmt|;
comment|/* Get request from free pool */
name|pRequest
operator|=
name|saGetRequestFromFreePool
argument_list|(
name|agRoot
argument_list|,
name|agContext
argument_list|)
expr_stmt|;
if|if
condition|(
name|agNULL
operator|==
name|pRequest
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"saSgpio, No request from free list\n"
operator|)
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'a'
argument_list|,
literal|"6t"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Set payload to zeros */
name|si_memset
argument_list|(
operator|&
name|payload
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|agsaSGpioCmd_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* set tag */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSGpioCmd_t
argument_list|,
name|tag
argument_list|)
argument_list|,
name|pRequest
operator|->
name|HTag
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSGpioCmd_t
argument_list|,
name|regIndexRegTypeFunctionFrameType
argument_list|)
argument_list|,
operator|(
name|pSGpioReq
operator|->
name|smpFrameType
operator||
operator|(
operator|(
name|bit32
operator|)
name|pSGpioReq
operator|->
name|function
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
name|bit32
operator|)
name|pSGpioReq
operator|->
name|registerType
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|bit32
operator|)
name|pSGpioReq
operator|->
name|registerIndex
operator|<<
literal|24
operator|)
operator|)
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSGpioCmd_t
argument_list|,
name|regCount
argument_list|)
argument_list|,
name|pSGpioReq
operator|->
name|registerCount
argument_list|)
expr_stmt|;
if|if
condition|(
name|SA_SAS_SMP_WRITE_GPIO_REGISTER
operator|==
name|pSGpioReq
operator|->
name|function
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pSGpioReq
operator|->
name|registerCount
condition|;
name|i
operator|++
control|)
block|{
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSGpioCmd_t
argument_list|,
name|writeData
argument_list|)
operator|+
operator|(
name|i
operator|*
literal|4
operator|)
argument_list|,
name|pSGpioReq
operator|->
name|readWriteData
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Build IOMB command and send to SPC */
name|ret
operator|=
name|mpiBuildCmd
argument_list|(
name|agRoot
argument_list|,
operator|(
name|bit32
operator|*
operator|)
operator|&
name|payload
argument_list|,
name|MPI_CATEGORY_SAS_SATA
argument_list|,
name|OPC_INB_SGPIO
argument_list|,
name|IOMB_SIZE64
argument_list|,
name|queueNum
argument_list|)
expr_stmt|;
if|if
condition|(
name|AGSA_RC_SUCCESS
operator|!=
name|ret
condition|)
block|{
comment|/* Return the request to free pool */
name|saReturnRequestToFreePool
argument_list|(
name|agRoot
argument_list|,
name|pRequest
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saSgpio, sending IOMB failed\n"
operator|)
argument_list|)
expr_stmt|;
block|}
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'b'
argument_list|,
literal|"6t"
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*! \brief for spc card read Error Registers to memory if error occur  *  *  This function is called to get erorr registers content to memory if error occur.  *  *  \param agRoot      handles for this instance of SAS/SATA hardware  *  *  \return  */
end_comment

begin_comment
comment|/*******************************************************************************/
end_comment

begin_function
name|LOCAL
name|void
name|siSpcGetErrorContent
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|)
block|{
name|agsaLLRoot_t
modifier|*
name|saRoot
init|=
operator|(
name|agsaLLRoot_t
operator|*
operator|)
operator|(
name|agRoot
operator|->
name|sdkData
operator|)
decl_stmt|;
name|bit32
name|value
decl_stmt|,
name|value1
decl_stmt|;
name|value
operator|=
name|siHalRegReadExt
argument_list|(
name|agRoot
argument_list|,
name|GEN_MSGU_SCRATCH_PAD_1
argument_list|,
name|MSGU_SCRATCH_PAD_1
argument_list|)
operator|&
name|SCRATCH_PAD_STATE_MASK
expr_stmt|;
name|value1
operator|=
name|siHalRegReadExt
argument_list|(
name|agRoot
argument_list|,
name|GEN_MSGU_SCRATCH_PAD_2
argument_list|,
name|MSGU_SCRATCH_PAD_2
argument_list|)
operator|&
name|SCRATCH_PAD_STATE_MASK
expr_stmt|;
comment|/* check AAP error */
if|if
condition|(
operator|(
name|SCRATCH_PAD1_ERR
operator|==
name|value
operator|)
operator|||
operator|(
name|SCRATCH_PAD2_ERR
operator|==
name|value1
operator|)
condition|)
block|{
comment|/* fatal error */
comment|/* get register dump from GSM and save it to LL local memory */
name|siGetRegisterDumpGSM
argument_list|(
name|agRoot
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|saRoot
operator|->
name|registerDump0
index|[
literal|0
index|]
argument_list|,
name|REG_DUMP_NUM0
argument_list|,
literal|0
argument_list|,
name|saRoot
operator|->
name|mainConfigTable
operator|.
name|FatalErrorDumpLength0
argument_list|)
expr_stmt|;
name|siGetRegisterDumpGSM
argument_list|(
name|agRoot
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|saRoot
operator|->
name|registerDump1
index|[
literal|0
index|]
argument_list|,
name|REG_DUMP_NUM1
argument_list|,
literal|0
argument_list|,
name|saRoot
operator|->
name|mainConfigTable
operator|.
name|FatalErrorDumpLength1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*! \brief for spcv card read Error Registers to memory if error occur  *  *  This function is called to get erorr registers content to memory if error occur.  *  *  \param agRoot      handles for this instance of SAS/SATA hardware  *  *  \return  */
end_comment

begin_comment
comment|/*******************************************************************************/
end_comment

begin_function
name|LOCAL
name|void
name|siSpcvGetErrorContent
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|)
block|{
name|agsaLLRoot_t
modifier|*
name|saRoot
init|=
operator|(
name|agsaLLRoot_t
operator|*
operator|)
operator|(
name|agRoot
operator|->
name|sdkData
operator|)
decl_stmt|;
name|bit32
name|value
decl_stmt|;
name|smTraceFuncEnter
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|"2d"
argument_list|)
expr_stmt|;
name|value
operator|=
name|siHalRegReadExt
argument_list|(
name|agRoot
argument_list|,
name|GEN_MSGU_SCRATCH_PAD_1
argument_list|,
name|MSGU_SCRATCH_PAD_1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|value
operator|&
name|SPCV_RAAE_STATE_MASK
operator|)
operator|==
name|SPCV_ERROR_VALUE
operator|)
operator|||
operator|(
operator|(
name|value
operator|&
name|SPCV_IOP0_STATE_MASK
operator|)
operator|==
name|SPCV_ERROR_VALUE
operator|)
operator|||
operator|(
operator|(
name|value
operator|&
name|SPCV_IOP1_STATE_MASK
operator|)
operator|==
name|SPCV_ERROR_VALUE
operator|)
condition|)
block|{
comment|/* fatal error */
comment|/* get register dump from GSM and save it to LL local memory */
name|siGetRegisterDumpGSM
argument_list|(
name|agRoot
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|saRoot
operator|->
name|registerDump0
index|[
literal|0
index|]
argument_list|,
name|REG_DUMP_NUM0
argument_list|,
literal|0
argument_list|,
name|saRoot
operator|->
name|mainConfigTable
operator|.
name|FatalErrorDumpLength0
argument_list|)
expr_stmt|;
name|siGetRegisterDumpGSM
argument_list|(
name|agRoot
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|saRoot
operator|->
name|registerDump1
index|[
literal|0
index|]
argument_list|,
name|REG_DUMP_NUM1
argument_list|,
literal|0
argument_list|,
name|saRoot
operator|->
name|mainConfigTable
operator|.
name|FatalErrorDumpLength1
argument_list|)
expr_stmt|;
block|}
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'a'
argument_list|,
literal|"2d"
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|LEFT_BYTE_FAIL
parameter_list|(
name|x
parameter_list|,
name|v
parameter_list|)
define|\
value|do {if( (x)< (v) ) return AGSA_RC_FAILURE; } while(0);
end_define

begin_function
name|LOCAL
name|bit32
name|siDumpInboundQueue
parameter_list|(
name|void
modifier|*
name|buffer
parameter_list|,
name|bit32
name|length
parameter_list|,
name|mpiICQueue_t
modifier|*
name|q
parameter_list|)
block|{
name|bit8
modifier|*
name|_buf
init|=
name|buffer
decl_stmt|;
name|si_memcpy
argument_list|(
name|_buf
argument_list|,
operator|(
name|bit8
operator|*
operator|)
operator|(
name|q
operator|->
name|memoryRegion
operator|.
name|virtPtr
operator|)
operator|+
name|length
argument_list|,
literal|128
operator|*
literal|256
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_SUCCESS
return|;
block|}
end_function

begin_function
name|LOCAL
name|bit32
name|siDumpOutboundQueue
parameter_list|(
name|void
modifier|*
name|buffer
parameter_list|,
name|bit32
name|length
parameter_list|,
name|mpiOCQueue_t
modifier|*
name|q
parameter_list|)
block|{
name|bit8
modifier|*
name|_buf
init|=
name|buffer
decl_stmt|;
name|si_memcpy
argument_list|(
name|_buf
argument_list|,
operator|(
name|bit8
operator|*
operator|)
operator|(
name|q
operator|->
name|memoryRegion
operator|.
name|virtPtr
operator|)
operator|+
name|length
argument_list|,
literal|128
operator|*
literal|256
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_SUCCESS
return|;
block|}
end_function

begin_function
name|LOCAL
name|bit32
name|siWaitForNonFatalTransfer
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|bit32
name|pcibar
parameter_list|)
block|{
name|bit32
name|status
init|=
name|AGSA_RC_SUCCESS
decl_stmt|;
name|bit32
name|ready
decl_stmt|;
name|bit32
name|max_wait_time
decl_stmt|;
name|bit32
name|max_wait_count
decl_stmt|;
name|smTraceFuncEnter
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|"2c"
argument_list|)
expr_stmt|;
name|SA_DBG4
argument_list|(
operator|(
literal|"siWaitForNonFatalTransfer:0 IBDBS 0x%x\n"
operator|,
name|ossaHwRegReadExt
argument_list|(
name|agRoot
argument_list|,
literal|0
argument_list|,
name|V_Inbound_Doorbell_Set_Register
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* Write FDDHSHK  */
comment|/* Write bit7 of inbound doorbell set register  step 3 */
name|ossaHwRegWriteExt
argument_list|(
name|agRoot
argument_list|,
literal|0
argument_list|,
name|V_Inbound_Doorbell_Set_Register
argument_list|,
name|SPCV_MSGU_CFG_TABLE_TRANSFER_DEBUG_INFO
argument_list|)
expr_stmt|;
name|SA_DBG4
argument_list|(
operator|(
literal|"siWaitForNonFatalTransfer:1 IBDBS 0x%x\n"
operator|,
name|ossaHwRegReadExt
argument_list|(
name|agRoot
argument_list|,
literal|0
argument_list|,
name|V_Inbound_Doorbell_Set_Register
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* Poll bit7 of inbound doorbell set register until clear step 4 */
name|max_wait_time
operator|=
operator|(
literal|2000
operator|*
literal|1000
operator|)
expr_stmt|;
comment|/* wait 2 seconds */
name|max_wait_count
operator|=
name|MAKE_MODULO
argument_list|(
name|max_wait_time
argument_list|,
name|WAIT_INCREMENT
argument_list|)
operator|-
name|WAIT_INCREMENT
expr_stmt|;
do|do
block|{
name|ossaStallThread
argument_list|(
name|agRoot
argument_list|,
name|WAIT_INCREMENT
argument_list|)
expr_stmt|;
name|ready
operator|=
name|ossaHwRegReadExt
argument_list|(
name|agRoot
argument_list|,
literal|0
argument_list|,
name|V_Inbound_Doorbell_Set_Register
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|ready
operator|&
name|SPCV_MSGU_CFG_TABLE_TRANSFER_DEBUG_INFO
operator|)
operator|&&
operator|(
name|max_wait_count
operator|-=
name|WAIT_INCREMENT
operator|)
condition|)
do|;
if|if
condition|(
name|max_wait_count
operator|==
literal|0
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"siWaitForNonFatalTransfer:Timeout IBDBS 0x%x\n"
operator|,
name|ossaHwRegReadExt
argument_list|(
name|agRoot
argument_list|,
literal|0
argument_list|,
name|V_Inbound_Doorbell_Set_Register
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|AGSA_RC_FAILURE
expr_stmt|;
block|}
name|SA_DBG4
argument_list|(
operator|(
literal|"siWaitForNonFatalTransfer:3 IBDBS 0x%x\n"
operator|,
name|ossaHwRegReadExt
argument_list|(
name|agRoot
argument_list|,
literal|0
argument_list|,
name|V_Inbound_Doorbell_Set_Register
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'a'
argument_list|,
literal|"2c"
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_function
name|LOCAL
name|bit32
name|siWaitForFatalTransfer
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|bit32
name|pcibar
parameter_list|)
block|{
name|bit32
name|status
init|=
name|AGSA_RC_SUCCESS
decl_stmt|;
name|bit32
name|ready
decl_stmt|;
name|bit32
name|ErrorTableOffset
decl_stmt|;
name|bit32
name|max_wait_time
decl_stmt|;
name|bit32
name|max_wait_count
decl_stmt|;
name|smTraceFuncEnter
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|"2o"
argument_list|)
expr_stmt|;
name|ErrorTableOffset
operator|=
name|siGetTableOffset
argument_list|(
name|agRoot
argument_list|,
name|MAIN_MERRDCTO_MERRDCES
argument_list|)
expr_stmt|;
name|SA_DBG4
argument_list|(
operator|(
literal|"siWaitForFatalTransfer: MPI_FATAL_EDUMP_TABLE_STATUS    Offset 0x%x 0x%x\n"
operator|,
name|ErrorTableOffset
operator|+
name|MPI_FATAL_EDUMP_TABLE_STATUS
operator|,
name|ossaHwRegReadExt
argument_list|(
name|agRoot
argument_list|,
name|pcibar
argument_list|,
name|ErrorTableOffset
operator|+
name|MPI_FATAL_EDUMP_TABLE_STATUS
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG4
argument_list|(
operator|(
literal|"siWaitForFatalTransfer: MPI_FATAL_EDUMP_TABLE_ACCUM_LEN Offset 0x%x 0x%x\n"
operator|,
name|ErrorTableOffset
operator|+
name|MPI_FATAL_EDUMP_TABLE_ACCUM_LEN
operator|,
name|ossaHwRegReadExt
argument_list|(
name|agRoot
argument_list|,
name|pcibar
argument_list|,
name|ErrorTableOffset
operator|+
name|MPI_FATAL_EDUMP_TABLE_ACCUM_LEN
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/*   2. Write 0x1 to the Fatal Error Debug Dump Handshake control [FDDHSHK] field in Table 73 and   read back the same field (by polling) until it is 0. This prompts the debug agent to copy the next   part of the debug data into GSM shared memory. To check the completion of the copy process, the   host must poll the Fatal/Non Fatal Debug Data Transfer Status [FDDTSTAT] field in the Table   Table 73.   */
comment|/* Write FDDHSHK  */
name|ossaHwRegWriteExt
argument_list|(
name|agRoot
argument_list|,
name|pcibar
argument_list|,
name|ErrorTableOffset
operator|+
name|MPI_FATAL_EDUMP_TABLE_HANDSHAKE
argument_list|,
name|MPI_FATAL_EDUMP_HANDSHAKE_RDY
argument_list|)
expr_stmt|;
name|SA_DBG4
argument_list|(
operator|(
literal|"siWaitForFatalTransfer:1 MPI_FATAL_EDUMP_TABLE_HANDSHAKE 0x%x\n"
operator|,
name|ossaHwRegReadExt
argument_list|(
name|agRoot
argument_list|,
name|pcibar
argument_list|,
name|ErrorTableOffset
operator|+
name|MPI_FATAL_EDUMP_TABLE_HANDSHAKE
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* Poll FDDHSHK  until clear  */
name|max_wait_time
operator|=
operator|(
literal|2000
operator|*
literal|1000
operator|)
expr_stmt|;
comment|/* wait 2 seconds */
name|max_wait_count
operator|=
name|MAKE_MODULO
argument_list|(
name|max_wait_time
argument_list|,
name|WAIT_INCREMENT
argument_list|)
operator|-
name|WAIT_INCREMENT
expr_stmt|;
do|do
block|{
name|ossaStallThread
argument_list|(
name|agRoot
argument_list|,
name|WAIT_INCREMENT
argument_list|)
expr_stmt|;
name|ready
operator|=
name|ossaHwRegReadExt
argument_list|(
name|agRoot
argument_list|,
literal|0
argument_list|,
name|ErrorTableOffset
operator|+
name|MPI_FATAL_EDUMP_TABLE_HANDSHAKE
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|ready
operator|&&
operator|(
name|max_wait_count
operator|-=
name|WAIT_INCREMENT
operator|)
condition|)
do|;
if|if
condition|(
name|max_wait_count
operator|==
literal|0
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"siWaitForFatalTransfer : 1 Timeout\n"
operator|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|AGSA_RC_FAILURE
expr_stmt|;
block|}
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'a'
argument_list|,
literal|"2o"
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_function
name|LOCAL
name|bit32
name|siFatalErrorBuffer
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|agsaForensicData_t
modifier|*
name|forensicData
parameter_list|)
block|{
name|bit32
name|status
init|=
name|AGSA_RC_FAILURE
decl_stmt|;
name|bit32
name|pcibar
decl_stmt|;
name|bit32
name|ErrorTableOffset
decl_stmt|;
name|bit32
name|Accum_len
init|=
literal|0
decl_stmt|;
name|agsaLLRoot_t
modifier|*
name|saRoot
decl_stmt|;
comment|/* sanity check */
name|SA_ASSERT
argument_list|(
operator|(
name|agNULL
operator|!=
name|agRoot
operator|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|saRoot
operator|=
operator|(
name|agsaLLRoot_t
operator|*
operator|)
operator|(
name|agRoot
operator|->
name|sdkData
operator|)
expr_stmt|;
name|SA_ASSERT
argument_list|(
operator|(
name|agNULL
operator|!=
name|saRoot
operator|)
argument_list|,
literal|"saRoot"
argument_list|)
expr_stmt|;
if|if
condition|(
name|agNULL
operator|==
name|saRoot
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"siFatalErrorBuffer: agNULL  saRoot\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
if|if
condition|(
name|saRoot
operator|->
name|ResetFailed
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"siFatalErrorBuffer: saRoot->ResetFailed\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
name|smTraceFuncEnter
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|"2a"
argument_list|)
expr_stmt|;
name|SA_DBG2
argument_list|(
operator|(
literal|"siFatalErrorBuffer:In %p Offset 0x%08x Len 0x%08x Totel len 0x%x\n"
operator|,
name|forensicData
operator|->
name|BufferType
operator|.
name|dataBuf
operator|.
name|directData
operator|,
name|forensicData
operator|->
name|BufferType
operator|.
name|dataBuf
operator|.
name|directOffset
operator|,
name|forensicData
operator|->
name|BufferType
operator|.
name|dataBuf
operator|.
name|directLen
operator|,
name|forensicData
operator|->
name|BufferType
operator|.
name|dataBuf
operator|.
name|readLen
operator|)
argument_list|)
expr_stmt|;
name|pcibar
operator|=
name|siGetPciBar
argument_list|(
name|agRoot
argument_list|)
expr_stmt|;
name|ErrorTableOffset
operator|=
name|siGetTableOffset
argument_list|(
name|agRoot
argument_list|,
name|MAIN_MERRDCTO_MERRDCES
argument_list|)
expr_stmt|;
name|SA_DBG3
argument_list|(
operator|(
literal|"siFatalErrorBuffer: MPI_FATAL_EDUMP_TABLE_STATUS  0x%x LEN 0x%x\n"
operator|,
name|ossaHwRegReadExt
argument_list|(
name|agRoot
argument_list|,
name|pcibar
argument_list|,
name|ErrorTableOffset
operator|+
name|MPI_FATAL_EDUMP_TABLE_STATUS
argument_list|)
operator|,
name|ossaHwRegReadExt
argument_list|(
name|agRoot
argument_list|,
name|pcibar
argument_list|,
name|ErrorTableOffset
operator|+
name|MPI_FATAL_EDUMP_TABLE_ACCUM_LEN
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/*   This section describes sequence for the host to capture debug data under fatal error conditions.   A fatal error is an error condition that stops the SPCv controller from normal operation and causes it   to be unresponsive to host requests. Since the firmware is non-operational, the host needs to pull the   debug dump information using PCIe MEMBASE II with the assistance of the debug agent which becomes   active when the main controller firmware fails.   */
comment|/*   To capture the fatal error debug data, the host must:   1. Upon detecting the fatal error condition through a fatal error interrupt or by the MSGU scratchpad   registers, capture the first part of the fatal error debug data. Upon fatal error, the first part of the   debug data is located GSM shared memory and its length is updated in the Accumulative Debug   Data Length Transferred [ACCDDLEN] field in Table Table 82. To capture the first part:   */
if|if
condition|(
name|forensicData
operator|->
name|BufferType
operator|.
name|dataBuf
operator|.
name|directOffset
operator|==
literal|0
condition|)
block|{
comment|/* start to get data */
comment|/*     a. Program the MEMBASE II Shifting Register with 0x00.     */
name|ossaHwRegWriteExt
argument_list|(
name|agRoot
argument_list|,
name|pcibar
argument_list|,
name|V_MEMBASE_II_ShiftRegister
argument_list|,
name|saRoot
operator|->
name|FatalForensicShiftOffset
argument_list|)
expr_stmt|;
comment|// set base to zero
name|saRoot
operator|->
name|ForensicLastOffset
operator|=
literal|0
expr_stmt|;
name|saRoot
operator|->
name|FatalForensicStep
operator|=
literal|0
expr_stmt|;
name|saRoot
operator|->
name|FatalBarLoc
operator|=
literal|0
expr_stmt|;
name|saRoot
operator|->
name|FatalForensicShiftOffset
operator|=
literal|0
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"siFatalErrorBuffer: directOffset zero SCRATCH_PAD1 0x%x\n"
operator|,
name|siHalRegReadExt
argument_list|(
name|agRoot
argument_list|,
name|GEN_MSGU_SCRATCH_PAD_1
argument_list|,
name|MSGU_SCRATCH_PAD_1
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* Read until Accum_len is retrived */
name|Accum_len
operator|=
name|ossaHwRegReadExt
argument_list|(
name|agRoot
argument_list|,
name|pcibar
argument_list|,
name|ErrorTableOffset
operator|+
name|MPI_FATAL_EDUMP_TABLE_ACCUM_LEN
argument_list|)
expr_stmt|;
name|SA_DBG2
argument_list|(
operator|(
literal|"siFatalErrorBuffer: Accum_len 0x%x\n"
operator|,
name|Accum_len
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|Accum_len
operator|==
literal|0xFFFFFFFF
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"siFatalErrorBuffer: Possible PCI issue 0x%x not expected\n"
operator|,
name|Accum_len
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
if|if
condition|(
name|Accum_len
operator|==
literal|0
operator|||
name|Accum_len
operator|>=
literal|0x100000
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"siFatalErrorBuffer: Accum_len == saRoot->FatalCurrentLength 0x%x\n"
operator|,
name|Accum_len
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|IOCTL_ERROR_NO_FATAL_ERROR
operator|)
return|;
block|}
if|if
condition|(
name|saRoot
operator|->
name|FatalForensicStep
operator|==
literal|0
condition|)
comment|/* PM Step 1a and 1b */
block|{
name|moreData
label|:
if|if
condition|(
name|forensicData
operator|->
name|BufferType
operator|.
name|dataBuf
operator|.
name|directData
condition|)
block|{
name|siPciCpyMem
argument_list|(
name|agRoot
argument_list|,
name|saRoot
operator|->
name|FatalBarLoc
argument_list|,
name|forensicData
operator|->
name|BufferType
operator|.
name|dataBuf
operator|.
name|directData
argument_list|,
name|forensicData
operator|->
name|BufferType
operator|.
name|dataBuf
operator|.
name|directLen
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|saRoot
operator|->
name|FatalBarLoc
operator|+=
name|forensicData
operator|->
name|BufferType
operator|.
name|dataBuf
operator|.
name|directLen
expr_stmt|;
name|forensicData
operator|->
name|BufferType
operator|.
name|dataBuf
operator|.
name|directOffset
operator|+=
name|forensicData
operator|->
name|BufferType
operator|.
name|dataBuf
operator|.
name|directLen
expr_stmt|;
name|saRoot
operator|->
name|ForensicLastOffset
operator|+=
name|forensicData
operator|->
name|BufferType
operator|.
name|dataBuf
operator|.
name|directLen
expr_stmt|;
name|forensicData
operator|->
name|BufferType
operator|.
name|dataBuf
operator|.
name|readLen
operator|=
name|forensicData
operator|->
name|BufferType
operator|.
name|dataBuf
operator|.
name|directLen
expr_stmt|;
if|if
condition|(
name|saRoot
operator|->
name|ForensicLastOffset
operator|>=
name|Accum_len
condition|)
block|{
comment|/*       e. Repeat the above 2 steps until all debug data is retrieved as specified in the Accumulative Debug       Data Length Transferred [ACCDDLEN] field.       NOTE: The ACCDDLEN field is cumulative so the host needs to take the difference from the       previous step.       */
comment|/* This section data ends get next section */
name|SA_DBG1
argument_list|(
operator|(
literal|"siFatalErrorBuffer: Accum_len reached 0x%x directOffset 0x%x\n"
operator|,
name|Accum_len
operator|,
name|forensicData
operator|->
name|BufferType
operator|.
name|dataBuf
operator|.
name|directOffset
operator|)
argument_list|)
expr_stmt|;
name|saRoot
operator|->
name|FatalBarLoc
operator|=
literal|0
expr_stmt|;
name|saRoot
operator|->
name|FatalForensicStep
operator|=
literal|1
expr_stmt|;
name|saRoot
operator|->
name|FatalForensicShiftOffset
operator|=
literal|0
expr_stmt|;
name|status
operator|=
name|AGSA_RC_COMPLETE
expr_stmt|;
return|return
name|status
return|;
block|}
if|if
condition|(
name|saRoot
operator|->
name|FatalBarLoc
operator|<
operator|(
literal|64
operator|*
literal|1024
operator|)
condition|)
block|{
name|SA_DBG2
argument_list|(
operator|(
literal|"siFatalErrorBuffer: In same 64k FatalBarLoc 0x%x\n"
operator|,
name|saRoot
operator|->
name|FatalBarLoc
operator|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|AGSA_RC_SUCCESS
expr_stmt|;
return|return
name|status
return|;
block|}
comment|/*     c. Increment the MEMBASE II Shifting Register value by 0x100.     */
name|saRoot
operator|->
name|FatalForensicShiftOffset
operator|+=
literal|0x100
expr_stmt|;
name|ossaHwRegWriteExt
argument_list|(
name|agRoot
argument_list|,
name|pcibar
argument_list|,
name|V_MEMBASE_II_ShiftRegister
argument_list|,
name|saRoot
operator|->
name|FatalForensicShiftOffset
argument_list|)
expr_stmt|;
name|saRoot
operator|->
name|FatalBarLoc
operator|=
literal|0
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"siFatalErrorBuffer: Get next bar data 0x%x\n"
operator|,
name|saRoot
operator|->
name|FatalForensicShiftOffset
operator|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|AGSA_RC_SUCCESS
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"siFatalErrorBuffer:Offset 0x%x BarLoc 0x%x\n"
operator|,
name|saRoot
operator|->
name|FatalForensicShiftOffset
operator|,
name|saRoot
operator|->
name|FatalBarLoc
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"siFatalErrorBuffer: step 0 status %d %p Offset 0x%x Len 0x%x total_len 0x%x\n"
operator|,
name|status
operator|,
name|forensicData
operator|->
name|BufferType
operator|.
name|dataBuf
operator|.
name|directData
operator|,
name|forensicData
operator|->
name|BufferType
operator|.
name|dataBuf
operator|.
name|directOffset
operator|,
name|forensicData
operator|->
name|BufferType
operator|.
name|dataBuf
operator|.
name|directLen
operator|,
name|forensicData
operator|->
name|BufferType
operator|.
name|dataBuf
operator|.
name|readLen
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
if|if
condition|(
name|saRoot
operator|->
name|FatalForensicStep
operator|==
literal|1
condition|)
block|{
comment|/*     3. If Fatal/Non Fatal Debug Data Transfer Status [FDDTSTAT] field indicates status value of     0x00000002 or 0x00000003, read the next part of the fatal debug data by taking the difference     between the preserved ACCDDLEN value from step 2 and the new ACCDDLEN value.To capture     the second part:     a. Program the MEMBASE II Shifting Register with 0x00.     */
name|SA_DBG1
argument_list|(
operator|(
literal|"siFatalErrorBuffer: FatalForensicStep 1 Accum_len 0x%X MPI_FATAL_EDUMP_TABLE_ACCUM_LEN 0x%x\n"
operator|,
name|Accum_len
operator|,
name|ossaHwRegReadExt
argument_list|(
name|agRoot
argument_list|,
name|pcibar
argument_list|,
name|ErrorTableOffset
operator|+
name|MPI_FATAL_EDUMP_TABLE_ACCUM_LEN
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|saRoot
operator|->
name|FatalForensicShiftOffset
operator|=
literal|0
expr_stmt|;
comment|/* location in 64k region */
comment|/*     b. Read 64K of the debug data.     */
name|ossaHwRegWriteExt
argument_list|(
name|agRoot
argument_list|,
name|pcibar
argument_list|,
name|V_MEMBASE_II_ShiftRegister
argument_list|,
name|saRoot
operator|->
name|FatalForensicShiftOffset
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"siFatalErrorBuffer: FatalForensicStep 1\n"
operator|)
argument_list|)
expr_stmt|;
comment|/*     2.Write 0x1 to the Fatal Error Debug Dump Handshake control [FDDHSHK]     field inTable 82 and read back the same field (by polling for 2 seconds) until it is 0. This prompts     the debug agent to copy the next part of the debug data into GSM shared memory. To check the     completion of the copy process, the host must poll the Fatal/Non Fatal Debug Data Transfer Status     [FDDTSTAT] field for 2 secondsin the MPI Fatal and Non-Fatal Error Dump Capture Table Table 82.     */
name|siWaitForFatalTransfer
argument_list|(
name|agRoot
argument_list|,
name|pcibar
argument_list|)
expr_stmt|;
comment|/*     d. Read the next 64K of the debug data.     */
name|saRoot
operator|->
name|FatalForensicStep
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ossaHwRegReadExt
argument_list|(
name|agRoot
argument_list|,
name|pcibar
argument_list|,
name|ErrorTableOffset
operator|+
name|MPI_FATAL_EDUMP_TABLE_STATUS
argument_list|)
operator|!=
name|MPI_FATAL_EDUMP_TABLE_STAT_NF_SUCCESS_DONE
condition|)
block|{
name|SA_DBG3
argument_list|(
operator|(
literal|"siFatalErrorBuffer:Step 3\n"
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG3
argument_list|(
operator|(
literal|"siFatalErrorBuffer:Step 3 MPI_FATAL_EDUMP_TABLE_STATUS 0x%x\n"
operator|,
name|ossaHwRegReadExt
argument_list|(
name|agRoot
argument_list|,
name|pcibar
argument_list|,
name|ErrorTableOffset
operator|+
name|MPI_FATAL_EDUMP_TABLE_STATUS
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/*       2. Write FDDSTAT to 0x00000000 but preserve the Accumulative Debug Data Length Transferred       [ACCDDLEN] field.       */
name|ossaHwRegWriteExt
argument_list|(
name|agRoot
argument_list|,
name|pcibar
argument_list|,
name|ErrorTableOffset
operator|+
name|MPI_FATAL_EDUMP_TABLE_STATUS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*       4. If FDDSTAT is 0x00000002, repeat steps 2 and 3 until you reach this step with FDDSTAT being       equal to 0x00000003.       */
goto|goto
name|moreData
goto|;
block|}
else|else
block|{
comment|/*          When FDDSTAT equals 0x00000003 and ACCDDLEN is unchanged, then       */
comment|/*       the fatal error dump is complete. If ACCDDLEN increases, one more read step is required.       The content and format of the debug data is opaque to the host and must be forwarded to PMC-Sierra       Applications support for failure analysis. Debug data is retrieved in several iterations which enables       the host to use a smaller buffer and store the captured debug data in secondary storage during the process.       */
name|SA_DBG3
argument_list|(
operator|(
literal|"siFatalErrorBuffer:Step 4\n"
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"siFatalErrorBuffer:  Done  Read 0x%x accum 0x%x\n"
operator|,
name|forensicData
operator|->
name|BufferType
operator|.
name|dataBuf
operator|.
name|directOffset
operator|,
name|ossaHwRegReadExt
argument_list|(
name|agRoot
argument_list|,
name|pcibar
argument_list|,
name|ErrorTableOffset
operator|+
name|MPI_FATAL_EDUMP_TABLE_ACCUM_LEN
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SALLSDK_DEBUG
argument_list|)
name|SA_DBG1
argument_list|(
operator|(
literal|"siFatalErrorBuffer: SCRATCH_PAD1_V_ERROR_STATE 0x%x\n"
operator|,
name|SCRATCH_PAD1_V_ERROR_STATE
argument_list|(
name|siHalRegReadExt
argument_list|(
name|agRoot
argument_list|,
name|GEN_MSGU_SCRATCH_PAD_1
argument_list|,
name|MSGU_SCRATCH_PAD_1
argument_list|)
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"siFatalErrorBuffer: SCRATCH_PAD0 value = 0x%x\n"
operator|,
name|siHalRegReadExt
argument_list|(
name|agRoot
argument_list|,
name|GEN_MSGU_SCRATCH_PAD_0
argument_list|,
name|MSGU_SCRATCH_PAD_0
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"siFatalErrorBuffer: SCRATCH_PAD1 value = 0x%x\n"
operator|,
name|siHalRegReadExt
argument_list|(
name|agRoot
argument_list|,
name|GEN_MSGU_SCRATCH_PAD_1
argument_list|,
name|MSGU_SCRATCH_PAD_1
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"siFatalErrorBuffer: SCRATCH_PAD2 value = 0x%x\n"
operator|,
name|siHalRegReadExt
argument_list|(
name|agRoot
argument_list|,
name|GEN_MSGU_SCRATCH_PAD_2
argument_list|,
name|MSGU_SCRATCH_PAD_2
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"siFatalErrorBuffer: SCRATCH_PAD3 value = 0x%x\n"
operator|,
name|siHalRegReadExt
argument_list|(
name|agRoot
argument_list|,
name|GEN_MSGU_SCRATCH_PAD_3
argument_list|,
name|MSGU_SCRATCH_PAD_3
argument_list|)
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|forensicData
operator|->
name|BufferType
operator|.
name|dataBuf
operator|.
name|readLen
operator|=
literal|0xFFFFFFFF
expr_stmt|;
name|status
operator|=
name|AGSA_RC_SUCCESS
expr_stmt|;
block|}
block|}
name|SA_DBG3
argument_list|(
operator|(
literal|"siFatalErrorBuffer:status 0x%x %p directOffset 0x%x directLen 0x%x readLen 0x%x\n"
operator|,
name|status
operator|,
name|forensicData
operator|->
name|BufferType
operator|.
name|dataBuf
operator|.
name|directData
operator|,
name|forensicData
operator|->
name|BufferType
operator|.
name|dataBuf
operator|.
name|directOffset
operator|,
name|forensicData
operator|->
name|BufferType
operator|.
name|dataBuf
operator|.
name|directLen
operator|,
name|forensicData
operator|->
name|BufferType
operator|.
name|dataBuf
operator|.
name|readLen
operator|)
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'a'
argument_list|,
literal|"2a"
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_function
name|LOCAL
name|bit32
name|siNonFatalErrorBuffer
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|agsaForensicData_t
modifier|*
name|forensicData
parameter_list|)
block|{
name|bit32
name|status
init|=
name|AGSA_RC_FAILURE
decl_stmt|;
name|bit32
name|pcibar
decl_stmt|;
name|bit32
name|ErrorTableOffset
decl_stmt|;
comment|//bit32 i;
name|bit32
name|ready
decl_stmt|;
name|bit32
name|biggest
decl_stmt|;
name|bit32
name|max_wait_time
decl_stmt|;
name|bit32
name|max_wait_count
decl_stmt|;
name|agsaLLRoot_t
modifier|*
name|saRoot
decl_stmt|;
comment|/* sanity check */
name|SA_ASSERT
argument_list|(
operator|(
name|agNULL
operator|!=
name|agRoot
operator|)
argument_list|,
literal|"agRoot"
argument_list|)
expr_stmt|;
name|saRoot
operator|=
operator|(
name|agsaLLRoot_t
operator|*
operator|)
operator|(
name|agRoot
operator|->
name|sdkData
operator|)
expr_stmt|;
name|SA_ASSERT
argument_list|(
operator|(
name|agNULL
operator|!=
name|saRoot
operator|)
argument_list|,
literal|"saRoot"
argument_list|)
expr_stmt|;
if|if
condition|(
name|agNULL
operator|==
name|saRoot
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"siNonFatalErrorBuffer: agNULL  saRoot\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
name|smTraceFuncEnter
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|"2b"
argument_list|)
expr_stmt|;
name|pcibar
operator|=
name|siGetPciBar
argument_list|(
name|agRoot
argument_list|)
expr_stmt|;
name|ErrorTableOffset
operator|=
name|siGetTableOffset
argument_list|(
name|agRoot
argument_list|,
name|MAIN_MERRDCTO_MERRDCES
argument_list|)
expr_stmt|;
name|SA_DBG4
argument_list|(
operator|(
literal|"siNonFatalErrorBuffer: ErrorTableOffset 0x%x\n"
operator|,
name|ErrorTableOffset
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG4
argument_list|(
operator|(
literal|"siNonFatalErrorBuffer: MPI_FATAL_EDUMP_TABLE_STATUS Offset 0x%x   0x%x\n"
operator|,
name|ErrorTableOffset
operator|+
name|MPI_FATAL_EDUMP_TABLE_STATUS
operator|,
name|ossaHwRegReadExt
argument_list|(
name|agRoot
argument_list|,
name|pcibar
argument_list|,
name|ErrorTableOffset
operator|+
name|MPI_FATAL_EDUMP_TABLE_STATUS
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG4
argument_list|(
operator|(
literal|"siNonFatalErrorBuffer: MPI_FATAL_EDUMP_TABLE_ACCUM_LEN Offset 0x%x   0x%x\n"
operator|,
name|ErrorTableOffset
operator|+
name|MPI_FATAL_EDUMP_TABLE_ACCUM_LEN
operator|,
name|ossaHwRegReadExt
argument_list|(
name|agRoot
argument_list|,
name|pcibar
argument_list|,
name|ErrorTableOffset
operator|+
name|MPI_FATAL_EDUMP_TABLE_ACCUM_LEN
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|biggest
operator|=
name|saRoot
operator|->
name|memoryAllocated
operator|.
name|agMemory
index|[
name|HDA_DMA_BUFFER
index|]
operator|.
name|totalLength
expr_stmt|;
if|if
condition|(
name|biggest
operator|>=
name|forensicData
operator|->
name|BufferType
operator|.
name|dataBuf
operator|.
name|directLen
condition|)
block|{
name|biggest
operator|=
name|forensicData
operator|->
name|BufferType
operator|.
name|dataBuf
operator|.
name|directLen
expr_stmt|;
block|}
else|else
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"siNonFatalErrorBuffer: directLen larger than DMA Buffer 0x%x< 0x%x\n"
operator|,
name|biggest
operator|,
name|forensicData
operator|->
name|BufferType
operator|.
name|dataBuf
operator|.
name|directLen
operator|)
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'a'
argument_list|,
literal|"2b"
argument_list|)
expr_stmt|;
return|return
operator|(
name|AGSA_RC_FAILURE
operator|)
return|;
block|}
if|if
condition|(
name|saRoot
operator|->
name|memoryAllocated
operator|.
name|agMemory
index|[
name|HDA_DMA_BUFFER
index|]
operator|.
name|virtPtr
condition|)
block|{
name|si_memset
argument_list|(
name|saRoot
operator|->
name|memoryAllocated
operator|.
name|agMemory
index|[
name|HDA_DMA_BUFFER
index|]
operator|.
name|virtPtr
argument_list|,
literal|0
argument_list|,
name|biggest
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"siNonFatalErrorBuffer: Error\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|AGSA_RC_FAILURE
operator|)
return|;
block|}
if|if
condition|(
name|forensicData
operator|->
name|BufferType
operator|.
name|dataBuf
operator|.
name|directOffset
condition|)
block|{
comment|/* Write FDDSTAT and ACCDDLEN to zero step 2 */
name|ossaHwRegWriteExt
argument_list|(
name|agRoot
argument_list|,
name|pcibar
argument_list|,
name|ErrorTableOffset
operator|+
name|MPI_FATAL_EDUMP_TABLE_STATUS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|skip_setup
goto|;
block|}
name|SA_DBG1
argument_list|(
operator|(
literal|"siNonFatalErrorBuffer: %p Offset 0x%x Len 0x%x total_len 0x%x\n"
operator|,
name|forensicData
operator|->
name|BufferType
operator|.
name|dataBuf
operator|.
name|directData
operator|,
name|forensicData
operator|->
name|BufferType
operator|.
name|dataBuf
operator|.
name|directOffset
operator|,
name|forensicData
operator|->
name|BufferType
operator|.
name|dataBuf
operator|.
name|directLen
operator|,
name|forensicData
operator|->
name|BufferType
operator|.
name|dataBuf
operator|.
name|readLen
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"siNonFatalErrorBuffer: directOffset zero setup\n"
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"siNonFatalErrorBuffer: MPI_FATAL_EDUMP_TABLE_STATUS  0x%x LEN 0x%x\n"
operator|,
name|ossaHwRegReadExt
argument_list|(
name|agRoot
argument_list|,
name|pcibar
argument_list|,
name|ErrorTableOffset
operator|+
name|MPI_FATAL_EDUMP_TABLE_STATUS
argument_list|)
operator|,
name|ossaHwRegReadExt
argument_list|(
name|agRoot
argument_list|,
name|pcibar
argument_list|,
name|ErrorTableOffset
operator|+
name|MPI_FATAL_EDUMP_TABLE_ACCUM_LEN
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"siNonFatalErrorBuffer: Clear V_Scratchpad_Rsvd_0_Register 0x%x\n"
operator|,
name|ossaHwRegReadExt
argument_list|(
name|agRoot
argument_list|,
literal|0
argument_list|,
name|V_Scratchpad_Rsvd_0_Register
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|ossaHwRegWriteExt
argument_list|(
name|agRoot
argument_list|,
literal|0
argument_list|,
name|V_Scratchpad_Rsvd_0_Register
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|saRoot
operator|->
name|ForensicLastOffset
operator|=
literal|0
expr_stmt|;
comment|/* WriteACCDDLEN  for error interface Step 0 */
comment|/*ossaHwRegWriteExt(agRoot, pcibar, ErrorTableOffset + MPI_FATAL_EDUMP_TABLE_ACCUM_LEN ,0);*/
comment|/* Write DMA get Offset for error interface Step 1 */
name|ossaHwRegWriteExt
argument_list|(
name|agRoot
argument_list|,
name|pcibar
argument_list|,
name|ErrorTableOffset
operator|+
name|MPI_FATAL_EDUMP_TABLE_LO_OFFSET
argument_list|,
name|saRoot
operator|->
name|memoryAllocated
operator|.
name|agMemory
index|[
name|HDA_DMA_BUFFER
index|]
operator|.
name|phyAddrLower
argument_list|)
expr_stmt|;
name|ossaHwRegWriteExt
argument_list|(
name|agRoot
argument_list|,
name|pcibar
argument_list|,
name|ErrorTableOffset
operator|+
name|MPI_FATAL_EDUMP_TABLE_HI_OFFSET
argument_list|,
name|saRoot
operator|->
name|memoryAllocated
operator|.
name|agMemory
index|[
name|HDA_DMA_BUFFER
index|]
operator|.
name|phyAddrUpper
argument_list|)
expr_stmt|;
name|ossaHwRegWriteExt
argument_list|(
name|agRoot
argument_list|,
name|pcibar
argument_list|,
name|ErrorTableOffset
operator|+
name|MPI_FATAL_EDUMP_TABLE_LENGTH
argument_list|,
name|biggest
argument_list|)
expr_stmt|;
comment|/* Write FDDSTAT and ACCDDLEN to zero step 2 */
name|ossaHwRegWriteExt
argument_list|(
name|agRoot
argument_list|,
name|pcibar
argument_list|,
name|ErrorTableOffset
operator|+
name|MPI_FATAL_EDUMP_TABLE_STATUS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ossaHwRegWriteExt
argument_list|(
name|agRoot
argument_list|,
name|pcibar
argument_list|,
name|ErrorTableOffset
operator|+
name|MPI_FATAL_EDUMP_TABLE_ACCUM_LEN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SA_DBG4
argument_list|(
operator|(
literal|"siNonFatalErrorBuffer: MPI_FATAL_EDUMP_TABLE_STATUS Offset 0x%x   0x%x\n"
operator|,
name|ErrorTableOffset
operator|+
name|MPI_FATAL_EDUMP_TABLE_STATUS
operator|,
name|ossaHwRegReadExt
argument_list|(
name|agRoot
argument_list|,
name|pcibar
argument_list|,
name|ErrorTableOffset
operator|+
name|MPI_FATAL_EDUMP_TABLE_STATUS
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG4
argument_list|(
operator|(
literal|"siNonFatalErrorBuffer: MPI_FATAL_EDUMP_TABLE_ACCUM_LEN Offset 0x%x   0x%x\n"
operator|,
name|ErrorTableOffset
operator|+
name|MPI_FATAL_EDUMP_TABLE_ACCUM_LEN
operator|,
name|ossaHwRegReadExt
argument_list|(
name|agRoot
argument_list|,
name|pcibar
argument_list|,
name|ErrorTableOffset
operator|+
name|MPI_FATAL_EDUMP_TABLE_ACCUM_LEN
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|!=
name|ossaHwRegReadExt
argument_list|(
name|agRoot
argument_list|,
name|pcibar
argument_list|,
name|ErrorTableOffset
operator|+
name|MPI_FATAL_EDUMP_TABLE_ACCUM_LEN
argument_list|)
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"siNonFatalErrorBuffer: MPI_FATAL_EDUMP_TABLE_ACCUM_LEN  0x%x   0x%x\n"
operator|,
name|forensicData
operator|->
name|BufferType
operator|.
name|dataBuf
operator|.
name|directOffset
operator|,
name|ossaHwRegReadExt
argument_list|(
name|agRoot
argument_list|,
name|pcibar
argument_list|,
name|ErrorTableOffset
operator|+
name|MPI_FATAL_EDUMP_TABLE_ACCUM_LEN
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
name|skip_setup
label|:
if|if
condition|(
name|saRoot
operator|->
name|ForensicLastOffset
operator|==
literal|0xFFFFFFFF
condition|)
block|{
name|forensicData
operator|->
name|BufferType
operator|.
name|dataBuf
operator|.
name|readLen
operator|=
literal|0xFFFFFFFF
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'b'
argument_list|,
literal|"2b"
argument_list|)
expr_stmt|;
return|return
operator|(
name|AGSA_RC_SUCCESS
operator|)
return|;
block|}
comment|/* Write bit7 of inbound doorbell set register and wait for complete step 3 and 4*/
name|siWaitForNonFatalTransfer
argument_list|(
name|agRoot
argument_list|,
name|pcibar
argument_list|)
expr_stmt|;
name|SA_DBG3
argument_list|(
operator|(
literal|"siNonFatalErrorBuffer: MPI_FATAL_EDUMP_TABLE_STATUS  0x%x LEN 0x%x\n"
operator|,
name|ossaHwRegReadExt
argument_list|(
name|agRoot
argument_list|,
name|pcibar
argument_list|,
name|ErrorTableOffset
operator|+
name|MPI_FATAL_EDUMP_TABLE_STATUS
argument_list|)
operator|,
name|ossaHwRegReadExt
argument_list|(
name|agRoot
argument_list|,
name|pcibar
argument_list|,
name|ErrorTableOffset
operator|+
name|MPI_FATAL_EDUMP_TABLE_ACCUM_LEN
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|max_wait_time
operator|=
operator|(
literal|2000
operator|*
literal|1000
operator|)
expr_stmt|;
comment|/* wait 2 seconds */
name|max_wait_count
operator|=
name|MAKE_MODULO
argument_list|(
name|max_wait_time
argument_list|,
name|WAIT_INCREMENT
argument_list|)
operator|-
name|WAIT_INCREMENT
expr_stmt|;
name|ready
operator|=
name|ossaHwRegReadExt
argument_list|(
name|agRoot
argument_list|,
name|pcibar
argument_list|,
name|ErrorTableOffset
operator|+
name|MPI_FATAL_EDUMP_TABLE_STATUS
argument_list|)
expr_stmt|;
do|do
block|{
name|ossaStallThread
argument_list|(
name|agRoot
argument_list|,
name|WAIT_INCREMENT
argument_list|)
expr_stmt|;
name|ready
operator|=
name|ossaHwRegReadExt
argument_list|(
name|agRoot
argument_list|,
name|pcibar
argument_list|,
name|ErrorTableOffset
operator|+
name|MPI_FATAL_EDUMP_TABLE_STATUS
argument_list|)
expr_stmt|;
name|forensicData
operator|->
name|BufferType
operator|.
name|dataBuf
operator|.
name|directOffset
operator|=
name|ossaHwRegReadExt
argument_list|(
name|agRoot
argument_list|,
name|pcibar
argument_list|,
name|ErrorTableOffset
operator|+
name|MPI_FATAL_EDUMP_TABLE_ACCUM_LEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|ready
operator|==
name|MPI_FATAL_EDUMP_TABLE_STAT_NF_SUCCESS_MORE_DATA
condition|)
block|{
name|SA_DBG2
argument_list|(
operator|(
literal|"siNonFatalErrorBuffer: More data available MPI_FATAL_EDUMP_TABLE_ACCUM_LEN 0x%x\n"
operator|,
name|ossaHwRegReadExt
argument_list|(
name|agRoot
argument_list|,
name|pcibar
argument_list|,
name|ErrorTableOffset
operator|+
name|MPI_FATAL_EDUMP_TABLE_ACCUM_LEN
argument_list|)
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
name|ready
operator|!=
name|MPI_FATAL_EDUMP_TABLE_STAT_NF_SUCCESS_DONE
operator|&&
operator|(
name|max_wait_count
operator|-=
name|WAIT_INCREMENT
operator|)
condition|)
do|;
if|if
condition|(
name|max_wait_count
operator|==
literal|0
operator|||
name|ready
operator|==
name|MPI_FATAL_EDUMP_TABLE_STAT_DMA_FAILED
condition|)
block|{
name|status
operator|=
name|AGSA_RC_FAILURE
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"siNonFatalErrorBuffer: timeout waiting ready\n"
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|forensicData
operator|->
name|BufferType
operator|.
name|dataBuf
operator|.
name|readLen
operator|=
name|forensicData
operator|->
name|BufferType
operator|.
name|dataBuf
operator|.
name|directOffset
operator|-
name|saRoot
operator|->
name|ForensicLastOffset
expr_stmt|;
if|if
condition|(
name|ready
operator|==
name|MPI_FATAL_EDUMP_TABLE_STAT_NF_SUCCESS_DONE
operator|&&
name|forensicData
operator|->
name|BufferType
operator|.
name|dataBuf
operator|.
name|readLen
operator|==
literal|0
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"siNonFatalErrorBuffer:ready 0x%x readLen 0x%x\n"
operator|,
name|ready
operator|,
name|forensicData
operator|->
name|BufferType
operator|.
name|dataBuf
operator|.
name|readLen
operator|)
argument_list|)
expr_stmt|;
name|saRoot
operator|->
name|ForensicLastOffset
operator|=
literal|0xFFFFFFFF
expr_stmt|;
block|}
else|else
block|{
name|saRoot
operator|->
name|ForensicLastOffset
operator|=
name|forensicData
operator|->
name|BufferType
operator|.
name|dataBuf
operator|.
name|directOffset
expr_stmt|;
block|}
if|if
condition|(
name|forensicData
operator|->
name|BufferType
operator|.
name|dataBuf
operator|.
name|directData
condition|)
block|{
name|si_memcpy
argument_list|(
name|forensicData
operator|->
name|BufferType
operator|.
name|dataBuf
operator|.
name|directData
argument_list|,
name|saRoot
operator|->
name|memoryAllocated
operator|.
name|agMemory
index|[
name|HDA_DMA_BUFFER
index|]
operator|.
name|virtPtr
argument_list|,
name|biggest
argument_list|)
expr_stmt|;
block|}
name|status
operator|=
name|AGSA_RC_SUCCESS
expr_stmt|;
block|}
comment|/* step 5 */
name|SA_DBG3
argument_list|(
operator|(
literal|"siNonFatalErrorBuffer: %p directOffset 0x%x directLen 0x%x readLen 0x%x\n"
operator|,
name|forensicData
operator|->
name|BufferType
operator|.
name|dataBuf
operator|.
name|directData
operator|,
name|forensicData
operator|->
name|BufferType
operator|.
name|dataBuf
operator|.
name|directOffset
operator|,
name|forensicData
operator|->
name|BufferType
operator|.
name|dataBuf
operator|.
name|directLen
operator|,
name|forensicData
operator|->
name|BufferType
operator|.
name|dataBuf
operator|.
name|readLen
operator|)
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'c'
argument_list|,
literal|"2b"
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_function
name|LOCAL
name|bit32
name|siGetForensicData
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|agsaContext_t
modifier|*
name|agContext
parameter_list|,
name|agsaForensicData_t
modifier|*
name|forensicData
parameter_list|)
block|{
name|bit32
name|status
init|=
name|AGSA_RC_FAILURE
decl_stmt|;
name|agsaLLRoot_t
modifier|*
name|saRoot
init|=
operator|(
name|agsaLLRoot_t
operator|*
operator|)
operator|(
name|agRoot
operator|->
name|sdkData
operator|)
decl_stmt|;
name|smTraceFuncEnter
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|"2Z"
argument_list|)
expr_stmt|;
if|if
condition|(
name|forensicData
operator|->
name|DataType
operator|==
name|TYPE_GSM_SPACE
condition|)
block|{
define|#
directive|define
name|_1M
value|0x100000
if|if
condition|(
name|forensicData
operator|->
name|BufferType
operator|.
name|gsmBuf
operator|.
name|directLen
operator|>=
name|_1M
condition|)
block|{
return|return
name|AGSA_RC_FAILURE
return|;
block|}
if|if
condition|(
name|forensicData
operator|->
name|BufferType
operator|.
name|dataBuf
operator|.
name|readLen
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"siGetForensicData: Incorrect readLen 0x%08X\n"
operator|,
name|forensicData
operator|->
name|BufferType
operator|.
name|dataBuf
operator|.
name|readLen
operator|)
argument_list|)
expr_stmt|;
name|forensicData
operator|->
name|BufferType
operator|.
name|dataBuf
operator|.
name|readLen
operator|=
name|forensicData
operator|->
name|BufferType
operator|.
name|dataBuf
operator|.
name|directLen
expr_stmt|;
block|}
if|if
condition|(
name|forensicData
operator|->
name|BufferType
operator|.
name|dataBuf
operator|.
name|directOffset
operator|>=
name|ONE_MEGABYTE
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"siGSMDump:	total length> ONE_MEGABYTE  0x%x\n"
operator|,
name|forensicData
operator|->
name|BufferType
operator|.
name|dataBuf
operator|.
name|directOffset
operator|)
argument_list|)
expr_stmt|;
name|forensicData
operator|->
name|BufferType
operator|.
name|dataBuf
operator|.
name|readLen
operator|=
literal|0xFFFFFFFF
expr_stmt|;
return|return
operator|(
name|AGSA_RC_SUCCESS
operator|)
return|;
block|}
if|if
condition|(
name|smIS_SPC
argument_list|(
name|agRoot
argument_list|)
condition|)
block|{
if|if
condition|(
name|forensicData
operator|->
name|BufferType
operator|.
name|dataBuf
operator|.
name|directLen
operator|>=
name|SIXTYFOURKBYTE
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"siGetForensicData directLen too large !\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_FAILURE
return|;
block|}
name|SA_DBG1
argument_list|(
operator|(
literal|"siGetForensicData: TYPE_GSM_SPACE directLen 0x%X directOffset 0x%08X %p\n"
operator|,
name|forensicData
operator|->
name|BufferType
operator|.
name|dataBuf
operator|.
name|directLen
operator|,
name|forensicData
operator|->
name|BufferType
operator|.
name|dataBuf
operator|.
name|directOffset
operator|,
name|forensicData
operator|->
name|BufferType
operator|.
name|dataBuf
operator|.
name|directData
operator|)
argument_list|)
expr_stmt|;
comment|/* Shift BAR4 original address */
if|if
condition|(
name|AGSA_RC_FAILURE
operator|==
name|siBar4Shift
argument_list|(
name|agRoot
argument_list|,
name|BAR_SHIFT_GSM_OFFSET
operator|+
name|forensicData
operator|->
name|BufferType
operator|.
name|dataBuf
operator|.
name|directOffset
argument_list|)
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"siGSMDump:Shift Bar4 to 0x%x failed\n"
operator|,
literal|0x0
operator|)
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_FAILURE
return|;
block|}
comment|//if( forensicData->BufferType.dataBuf.directOffset>= ONE_MEGABYTE )
comment|//{
comment|//SA_DBG1(("siGSMDump:  total length> ONE_MEGABYTE  0x%x\n",forensicData->BufferType.dataBuf.directOffset));
comment|//forensicData->BufferType.dataBuf.readLen = 0xFFFFFFFF;
comment|//return(AGSA_RC_SUCCESS);
comment|//}
name|forensicData
operator|->
name|BufferType
operator|.
name|gsmBuf
operator|.
name|directOffset
operator|=
literal|0
expr_stmt|;
block|}
name|status
operator|=
name|siGSMDump
argument_list|(
name|agRoot
argument_list|,
name|forensicData
operator|->
name|BufferType
operator|.
name|gsmBuf
operator|.
name|directOffset
argument_list|,
name|forensicData
operator|->
name|BufferType
operator|.
name|gsmBuf
operator|.
name|directLen
argument_list|,
name|forensicData
operator|->
name|BufferType
operator|.
name|gsmBuf
operator|.
name|directData
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|AGSA_RC_SUCCESS
condition|)
block|{
name|forensicData
operator|->
name|BufferType
operator|.
name|dataBuf
operator|.
name|readLen
operator|=
name|forensicData
operator|->
name|BufferType
operator|.
name|dataBuf
operator|.
name|directLen
expr_stmt|;
block|}
if|if
condition|(
name|forensicData
operator|->
name|BufferType
operator|.
name|dataBuf
operator|.
name|directOffset
operator|==
literal|0
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"siGetForensicData: TYPE_GSM_SPACE readLen 0x%08X\n"
operator|,
name|forensicData
operator|->
name|BufferType
operator|.
name|dataBuf
operator|.
name|readLen
operator|)
argument_list|)
expr_stmt|;
block|}
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'b'
argument_list|,
literal|"2Z"
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
elseif|else
if|if
condition|(
name|forensicData
operator|->
name|DataType
operator|==
name|TYPE_INBOUND_QUEUE
condition|)
block|{
name|mpiICQueue_t
modifier|*
name|circularQ
init|=
name|NULL
decl_stmt|;
name|SA_DBG2
argument_list|(
operator|(
literal|"siGetForensicData: TYPE_INBOUND \n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|forensicData
operator|->
name|BufferType
operator|.
name|queueBuf
operator|.
name|queueIndex
operator|>=
name|AGSA_MAX_INBOUND_Q
condition|)
block|{
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'c'
argument_list|,
literal|"2Z"
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_FAILURE
return|;
block|}
name|circularQ
operator|=
operator|&
name|saRoot
operator|->
name|inboundQueue
index|[
name|forensicData
operator|->
name|BufferType
operator|.
name|queueBuf
operator|.
name|queueIndex
index|]
expr_stmt|;
name|status
operator|=
name|siDumpInboundQueue
argument_list|(
name|forensicData
operator|->
name|BufferType
operator|.
name|queueBuf
operator|.
name|directData
argument_list|,
name|forensicData
operator|->
name|BufferType
operator|.
name|queueBuf
operator|.
name|directLen
argument_list|,
name|circularQ
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'e'
argument_list|,
literal|"2Z"
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
elseif|else
if|if
condition|(
name|forensicData
operator|->
name|DataType
operator|==
name|TYPE_OUTBOUND_QUEUE
condition|)
comment|//else if( forensicData->BufferType.queueBuf.queueType == TYPE_OUTBOUND_QUEUE )
block|{
name|mpiOCQueue_t
modifier|*
name|circularQ
init|=
name|NULL
decl_stmt|;
name|SA_DBG2
argument_list|(
operator|(
literal|"siGetForensicData: TYPE_OUTBOUND\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|forensicData
operator|->
name|BufferType
operator|.
name|queueBuf
operator|.
name|queueIndex
operator|>=
name|AGSA_MAX_OUTBOUND_Q
condition|)
block|{
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'d'
argument_list|,
literal|"2Z"
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_FAILURE
return|;
block|}
name|circularQ
operator|=
operator|&
name|saRoot
operator|->
name|outboundQueue
index|[
name|forensicData
operator|->
name|BufferType
operator|.
name|queueBuf
operator|.
name|queueIndex
index|]
expr_stmt|;
name|status
operator|=
name|siDumpOutboundQueue
argument_list|(
name|forensicData
operator|->
name|BufferType
operator|.
name|queueBuf
operator|.
name|directData
argument_list|,
name|forensicData
operator|->
name|BufferType
operator|.
name|queueBuf
operator|.
name|directLen
argument_list|,
name|circularQ
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'e'
argument_list|,
literal|"2Z"
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
elseif|else
if|if
condition|(
name|forensicData
operator|->
name|DataType
operator|==
name|TYPE_NON_FATAL
condition|)
block|{
comment|// if(smIS_SPCV(agRoot))
comment|// {
name|SA_DBG2
argument_list|(
operator|(
literal|"siGetForensicData:TYPE_NON_FATAL \n"
operator|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|siNonFatalErrorBuffer
argument_list|(
name|agRoot
argument_list|,
name|forensicData
argument_list|)
expr_stmt|;
comment|// }
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'f'
argument_list|,
literal|"2Z"
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
elseif|else
if|if
condition|(
name|forensicData
operator|->
name|DataType
operator|==
name|TYPE_FATAL
condition|)
block|{
comment|// if(smIS_SPCV(agRoot))
comment|//{
name|SA_DBG2
argument_list|(
operator|(
literal|"siGetForensicData:TYPE_NON_FATAL \n"
operator|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|siFatalErrorBuffer
argument_list|(
name|agRoot
argument_list|,
name|forensicData
argument_list|)
expr_stmt|;
comment|// }
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'g'
argument_list|,
literal|"2Z"
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
else|else
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"siGetForensicData receive error parameter!\n"
operator|)
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'h'
argument_list|,
literal|"2Z"
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_FAILURE
return|;
block|}
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'i'
argument_list|,
literal|"2Z"
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|//GLOBAL bit32 saGetForensicData(
end_comment

begin_function
name|bit32
name|saGetForensicData
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|agsaContext_t
modifier|*
name|agContext
parameter_list|,
name|agsaForensicData_t
modifier|*
name|forensicData
parameter_list|)
block|{
name|bit32
name|status
decl_stmt|;
name|status
operator|=
name|siGetForensicData
argument_list|(
name|agRoot
argument_list|,
name|agContext
argument_list|,
name|forensicData
argument_list|)
expr_stmt|;
name|ossaGetForensicDataCB
argument_list|(
name|agRoot
argument_list|,
name|agContext
argument_list|,
name|status
argument_list|,
name|forensicData
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_function
name|bit32
name|saGetIOErrorStats
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|agsaContext_t
modifier|*
name|agContext
parameter_list|,
name|bit32
name|flag
parameter_list|)
block|{
name|agsaLLRoot_t
modifier|*
name|saRoot
init|=
operator|(
name|agsaLLRoot_t
operator|*
operator|)
name|agRoot
operator|->
name|sdkData
decl_stmt|;
name|bit32
name|status
init|=
name|AGSA_RC_SUCCESS
decl_stmt|;
name|ossaGetIOErrorStatsCB
argument_list|(
name|agRoot
argument_list|,
name|agContext
argument_list|,
name|status
argument_list|,
operator|&
name|saRoot
operator|->
name|IoErrorCount
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag
condition|)
block|{
comment|/* clear IO error counter */
name|si_memset
argument_list|(
operator|&
name|saRoot
operator|->
name|IoErrorCount
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|agsaIOErrorEventStats_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_function
name|bit32
name|saGetIOEventStats
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|agsaContext_t
modifier|*
name|agContext
parameter_list|,
name|bit32
name|flag
parameter_list|)
block|{
name|agsaLLRoot_t
modifier|*
name|saRoot
init|=
operator|(
name|agsaLLRoot_t
operator|*
operator|)
name|agRoot
operator|->
name|sdkData
decl_stmt|;
name|bit32
name|status
init|=
name|AGSA_RC_SUCCESS
decl_stmt|;
name|ossaGetIOEventStatsCB
argument_list|(
name|agRoot
argument_list|,
name|agContext
argument_list|,
name|status
argument_list|,
operator|&
name|saRoot
operator|->
name|IoEventCount
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag
condition|)
block|{
comment|/* clear IO event counter */
name|si_memset
argument_list|(
operator|&
name|saRoot
operator|->
name|IoEventCount
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|agsaIOErrorEventStats_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*! \brief Initiate a GET REGISTER DUMP command  *  *  This function is called to Get Register Dump from the SPC.  *  *  \param agRoot      handles for this instance of SAS/SATA hardware  *  \param agContext   the context of this API  *  \param queueNum    queue number  *  \param regDumpInfo register dump information  *  *  \return  *          - SUCCESS or FAILURE  */
end_comment

begin_comment
comment|/*******************************************************************************/
end_comment

begin_comment
comment|//GLOBAL bit32 saGetRegisterDump(
end_comment

begin_function
name|bit32
name|saGetRegisterDump
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|agsaContext_t
modifier|*
name|agContext
parameter_list|,
name|bit32
name|queueNum
parameter_list|,
name|agsaRegDumpInfo_t
modifier|*
name|regDumpInfo
parameter_list|)
block|{
name|agsaLLRoot_t
modifier|*
name|saRoot
init|=
name|agNULL
decl_stmt|;
name|bit32
name|ret
init|=
name|AGSA_RC_SUCCESS
decl_stmt|;
comment|//  bit32                 value, value1;
name|smTraceFuncEnter
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|"6p"
argument_list|)
expr_stmt|;
comment|/* sanity check */
name|SA_ASSERT
argument_list|(
operator|(
name|agNULL
operator|!=
name|agRoot
operator|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|saRoot
operator|=
operator|(
name|agsaLLRoot_t
operator|*
operator|)
operator|(
name|agRoot
operator|->
name|sdkData
operator|)
expr_stmt|;
comment|/* sanity check */
name|SA_ASSERT
argument_list|(
operator|(
name|agNULL
operator|!=
name|saRoot
operator|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* sanity check */
name|SA_ASSERT
argument_list|(
operator|(
name|agNULL
operator|!=
name|regDumpInfo
operator|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|SA_DBG3
argument_list|(
operator|(
literal|"saGetRegisterDump: agContext %p\n"
operator|,
name|agContext
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|regDumpInfo
operator|->
name|regDumpSrc
operator|>
literal|3
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetRegisterDump, regDumpSrc %d or regDumpNum %d invalid\n"
operator|,
name|regDumpInfo
operator|->
name|regDumpNum
operator|,
name|regDumpInfo
operator|->
name|regDumpNum
operator|)
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'a'
argument_list|,
literal|"6p"
argument_list|)
expr_stmt|;
comment|/* CB error for Register Dump */
name|ossaGetRegisterDumpCB
argument_list|(
name|agRoot
argument_list|,
name|agContext
argument_list|,
name|OSSA_FAILURE
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_FAILURE
return|;
block|}
switch|switch
condition|(
name|regDumpInfo
operator|->
name|regDumpSrc
condition|)
block|{
case|case
name|REG_DUMP_NONFLASH
case|:
comment|/*First 6 64k data from GSMDUMP, contains IOST and RB info*/
if|if
condition|(
name|regDumpInfo
operator|->
name|regDumpNum
operator|==
name|GET_IOST_RB_INFO
condition|)
block|{
name|regDumpInfo
operator|->
name|regDumpOffset
operator|=
name|regDumpInfo
operator|->
name|regDumpOffset
operator|+
literal|0
expr_stmt|;
name|ret
operator|=
name|siGSMDump
argument_list|(
name|agRoot
argument_list|,
name|regDumpInfo
operator|->
name|regDumpOffset
argument_list|,
name|regDumpInfo
operator|->
name|directLen
argument_list|,
name|regDumpInfo
operator|->
name|directData
argument_list|)
expr_stmt|;
comment|/* CB error for Register Dump */
name|ossaGetRegisterDumpCB
argument_list|(
name|agRoot
argument_list|,
name|agContext
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
comment|/* Last 1MB data from GSMDUMP, contains GSM_SM info*/
if|if
condition|(
name|regDumpInfo
operator|->
name|regDumpNum
operator|==
name|GET_GSM_SM_INFO
condition|)
block|{
comment|/* GSM_SM - total 1 Mbytes */
name|bit32
name|offset
decl_stmt|;
if|if
condition|(
name|smIS_SPC
argument_list|(
name|agRoot
argument_list|)
condition|)
block|{
name|offset
operator|=
name|regDumpInfo
operator|->
name|regDumpOffset
operator|+
name|SPC_GSM_SM_OFFSET
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|smIS_SPCV
argument_list|(
name|agRoot
argument_list|)
condition|)
block|{
name|offset
operator|=
name|regDumpInfo
operator|->
name|regDumpOffset
operator|+
name|SPCV_GSM_SM_OFFSET
expr_stmt|;
block|}
else|else
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetRegisterDump: the device type is not support\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_FAILURE
return|;
block|}
name|ret
operator|=
name|siGSMDump
argument_list|(
name|agRoot
argument_list|,
name|offset
argument_list|,
name|regDumpInfo
operator|->
name|directLen
argument_list|,
name|regDumpInfo
operator|->
name|directData
argument_list|)
expr_stmt|;
comment|/* CB error for Register Dump */
name|ossaGetRegisterDumpCB
argument_list|(
name|agRoot
argument_list|,
name|agContext
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
comment|/* check fatal errors */
if|if
condition|(
name|smIS_SPC
argument_list|(
name|agRoot
argument_list|)
condition|)
block|{
name|siSpcGetErrorContent
argument_list|(
name|agRoot
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|smIS_SPCV
argument_list|(
name|agRoot
argument_list|)
condition|)
block|{
name|siSpcvGetErrorContent
argument_list|(
name|agRoot
argument_list|)
expr_stmt|;
block|}
comment|/* Then read from local copy */
if|if
condition|(
name|regDumpInfo
operator|->
name|directLen
operator|>
name|REGISTER_DUMP_BUFF_SIZE
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetRegisterDump, Request too many bytes %d\n"
operator|,
name|regDumpInfo
operator|->
name|directLen
operator|)
argument_list|)
expr_stmt|;
name|regDumpInfo
operator|->
name|directLen
operator|=
name|REGISTER_DUMP_BUFF_SIZE
expr_stmt|;
block|}
if|if
condition|(
name|regDumpInfo
operator|->
name|regDumpNum
operator|==
literal|0
condition|)
block|{
comment|/* Copy the LL Local register dump0 data to the destination */
name|si_memcpy
argument_list|(
name|regDumpInfo
operator|->
name|directData
argument_list|,
operator|(
name|bit8
operator|*
operator|)
operator|&
name|saRoot
operator|->
name|registerDump0
index|[
literal|0
index|]
operator|+
name|regDumpInfo
operator|->
name|regDumpOffset
argument_list|,
name|regDumpInfo
operator|->
name|directLen
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|regDumpInfo
operator|->
name|regDumpNum
operator|==
literal|1
condition|)
block|{
comment|/* Copy the LL Local register dump1 data to the destination */
name|si_memcpy
argument_list|(
name|regDumpInfo
operator|->
name|directData
argument_list|,
operator|(
name|bit8
operator|*
operator|)
operator|&
name|saRoot
operator|->
name|registerDump1
index|[
literal|0
index|]
operator|+
name|regDumpInfo
operator|->
name|regDumpOffset
argument_list|,
name|regDumpInfo
operator|->
name|directLen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetRegisterDump, the regDumpNum value is wrong %x\n"
operator|,
name|regDumpInfo
operator|->
name|regDumpNum
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* CB for Register Dump */
name|ossaGetRegisterDumpCB
argument_list|(
name|agRoot
argument_list|,
name|agContext
argument_list|,
name|OSSA_SUCCESS
argument_list|)
expr_stmt|;
break|break;
case|case
name|REG_DUMP_FLASH
case|:
comment|/* build IOMB command and send to SPC */
name|ret
operator|=
name|mpiNVMReadRegDumpCmd
argument_list|(
name|agRoot
argument_list|,
name|agContext
argument_list|,
name|queueNum
argument_list|,
name|regDumpInfo
operator|->
name|regDumpNum
argument_list|,
name|regDumpInfo
operator|->
name|regDumpOffset
argument_list|,
name|regDumpInfo
operator|->
name|indirectAddrUpper32
argument_list|,
name|regDumpInfo
operator|->
name|indirectAddrLower32
argument_list|,
name|regDumpInfo
operator|->
name|indirectLen
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'b'
argument_list|,
literal|"6p"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*! \brief Initiate a GET REGISTER DUMP from GSM command  *  *  This function is called to Get Register Dump from the GSM of SPC.  *  *  \param agRoot      handles for this instance of SAS/SATA hardware  *  \param destinationAddress address of the register dump data copied to  *  \param regDumpNum  Register Dump # 0 or 1  *  \param regDumpOffset Offset within the register dump area  *  \param len         Length in bytes of the register dump data to copy  *  *  \return  *          - SUCCESS or FAILURE  */
end_comment

begin_comment
comment|/*******************************************************************************/
end_comment

begin_comment
comment|//GLOBAL bit32 siGetRegisterDumpGSM(
end_comment

begin_function
name|bit32
name|siGetRegisterDumpGSM
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|void
modifier|*
name|destinationAddress
parameter_list|,
name|bit32
name|regDumpNum
parameter_list|,
name|bit32
name|regDumpOffset
parameter_list|,
name|bit32
name|len
parameter_list|)
block|{
name|agsaLLRoot_t
modifier|*
name|saRoot
init|=
operator|(
name|agsaLLRoot_t
operator|*
operator|)
operator|(
name|agRoot
operator|->
name|sdkData
operator|)
decl_stmt|;
name|bit32
name|ret
init|=
name|AGSA_RC_SUCCESS
decl_stmt|;
name|bit32
name|rDumpOffset
decl_stmt|,
name|rDumpLen
decl_stmt|;
comment|//, rDumpValue;
name|bit8
modifier|*
name|dst
decl_stmt|;
name|smTraceFuncEnter
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|"2V"
argument_list|)
expr_stmt|;
comment|/* sanity check */
name|SA_ASSERT
argument_list|(
operator|(
name|agNULL
operator|!=
name|agRoot
operator|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|dst
operator|=
operator|(
name|bit8
operator|*
operator|)
name|destinationAddress
expr_stmt|;
if|if
condition|(
name|regDumpNum
operator|>
literal|1
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"siGetRegisterDump, regDumpNum %d is invalid\n"
operator|,
name|regDumpNum
operator|)
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_FAILURE
return|;
block|}
if|if
condition|(
operator|!
name|regDumpNum
condition|)
block|{
name|rDumpOffset
operator|=
name|saRoot
operator|->
name|mainConfigTable
operator|.
name|FatalErrorDumpOffset0
expr_stmt|;
name|rDumpLen
operator|=
name|saRoot
operator|->
name|mainConfigTable
operator|.
name|FatalErrorDumpLength0
expr_stmt|;
block|}
else|else
block|{
name|rDumpOffset
operator|=
name|saRoot
operator|->
name|mainConfigTable
operator|.
name|FatalErrorDumpOffset1
expr_stmt|;
name|rDumpLen
operator|=
name|saRoot
operator|->
name|mainConfigTable
operator|.
name|FatalErrorDumpLength1
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|>
name|rDumpLen
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"siGetRegisterDump, Request too many bytes %d, rDumpLen %d\n"
operator|,
name|len
operator|,
name|rDumpLen
operator|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|rDumpLen
expr_stmt|;
block|}
if|if
condition|(
name|regDumpOffset
operator|>=
name|len
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"siGetRegisterDump, Offset is not within the area %d, regDumpOffset%d\n"
operator|,
name|rDumpLen
operator|,
name|regDumpOffset
operator|)
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'a'
argument_list|,
literal|"2V"
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_FAILURE
return|;
block|}
comment|/* adjust length to dword boundary */
if|if
condition|(
operator|(
name|len
operator|%
literal|4
operator|)
operator|>
literal|0
condition|)
block|{
name|len
operator|=
operator|(
name|len
operator|/
literal|4
operator|+
literal|1
operator|)
operator|*
literal|4
expr_stmt|;
block|}
name|ret
operator|=
name|siGSMDump
argument_list|(
name|agRoot
argument_list|,
name|rDumpOffset
argument_list|,
name|len
argument_list|,
name|dst
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'b'
argument_list|,
literal|"2V"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*! \brief SPC Get NVMD Command  *  *  This command sends GET_NVMD_DATA Command to SPC.  *  *  \param agRoot       Handles for this instance of SAS/SATA LL  *  \param agContext    Context of SPC FW Flash Update Command  *  \param queueNum     Inbound/outbound queue number  *  \param NVMDInfo     Pointer of NVM Device information  *  *  \return If the MPI command is sent to SPC successfully  *          - \e AGSA_RC_SUCCESS the MPI command is successfully  *          - \e AGSA_RC_FAILURE the MPI command is failure  *  */
end_comment

begin_comment
comment|/*******************************************************************************/
end_comment

begin_comment
comment|//GLOBAL bit32 saGetNVMDCommand(
end_comment

begin_function
name|bit32
name|saGetNVMDCommand
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|agsaContext_t
modifier|*
name|agContext
parameter_list|,
name|bit32
name|queueNum
parameter_list|,
name|agsaNVMDData_t
modifier|*
name|NVMDInfo
parameter_list|)
block|{
name|bit32
name|ret
init|=
name|AGSA_RC_SUCCESS
decl_stmt|;
comment|/* sanity check */
name|SA_ASSERT
argument_list|(
operator|(
name|agNULL
operator|!=
name|agRoot
operator|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* build IOMB command and send to SPC */
name|ret
operator|=
name|mpiGetNVMDCmd
argument_list|(
name|agRoot
argument_list|,
name|agContext
argument_list|,
name|NVMDInfo
argument_list|,
name|queueNum
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*! \brief SPC Set NVMD Command  *  *  This command sends SET_NVMD_DATA Command to SPC.  *  *  \param agRoot       Handles for this instance of SAS/SATA LL  *  \param agContext    Context of SPC FW Flash Update Command  *  \param queueNum     Inbound/outbound queue number  *  \param NVMDInfo     Pointer of NVM Device information  *  *  \return If the MPI command is sent to SPC successfully  *          - \e AGSA_RC_SUCCESS the MPI command is successfully  *          - \e AGSA_RC_FAILURE the MPI command is failure  *  */
end_comment

begin_comment
comment|/*******************************************************************************/
end_comment

begin_comment
comment|//GLOBAL bit32 saSetNVMDCommand(
end_comment

begin_function
name|bit32
name|saSetNVMDCommand
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|agsaContext_t
modifier|*
name|agContext
parameter_list|,
name|bit32
name|queueNum
parameter_list|,
name|agsaNVMDData_t
modifier|*
name|NVMDInfo
parameter_list|)
block|{
name|bit32
name|ret
init|=
name|AGSA_RC_SUCCESS
decl_stmt|;
comment|/* sanity check */
name|SA_ASSERT
argument_list|(
operator|(
name|agNULL
operator|!=
name|agRoot
operator|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* build IOMB command and send to SPC */
name|ret
operator|=
name|mpiSetNVMDCmd
argument_list|(
name|agRoot
argument_list|,
name|agContext
argument_list|,
name|NVMDInfo
argument_list|,
name|queueNum
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|GLOBAL
name|bit32
name|saSendSMPIoctl
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|agsaDevHandle_t
modifier|*
name|agDevHandle
parameter_list|,
name|bit32
name|queueNum
parameter_list|,
name|agsaSMPFrame_t
modifier|*
name|pSMPFrame
parameter_list|,
name|ossaSMPCompletedCB_t
name|agCB
parameter_list|)
block|{
name|bit32
name|ret
init|=
name|AGSA_RC_SUCCESS
decl_stmt|;
comment|//bit32 IR_IP_OV_res_phyId_DPdLen_res = 0;
name|bit32
name|retVal
decl_stmt|;
name|bit8
name|inq
decl_stmt|,
name|outq
decl_stmt|;
name|agsaIORequestDesc_t
modifier|*
name|pRequest
decl_stmt|;
name|void
modifier|*
name|pMessage
decl_stmt|;
name|bit8
modifier|*
name|payload_ptr
decl_stmt|;
name|agsaDeviceDesc_t
modifier|*
name|pDevice
decl_stmt|;
name|bit8
name|using_reserved
init|=
name|agFALSE
decl_stmt|;
name|agsaPort_t
modifier|*
name|pPort
decl_stmt|;
name|mpiICQueue_t
modifier|*
name|circularQ
decl_stmt|;
name|agsaLLRoot_t
modifier|*
name|saRoot
init|=
name|agNULL
decl_stmt|;
comment|//  agsaDevHandle_t       	*agDevHandle;
name|saRoot
operator|=
operator|(
name|agsaLLRoot_t
operator|*
operator|)
operator|(
name|agRoot
operator|->
name|sdkData
operator|)
expr_stmt|;
name|SA_ASSERT
argument_list|(
operator|(
name|agNULL
operator|!=
name|saRoot
operator|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* sanity check */
name|SA_ASSERT
argument_list|(
operator|(
name|agNULL
operator|!=
name|agRoot
operator|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* Get request from free IO Requests */
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|pRequest
operator|=
operator|(
name|agsaIORequestDesc_t
operator|*
operator|)
name|saLlistIOGetHead
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|)
expr_stmt|;
comment|/**/
comment|/* If no LL IO request entry available */
if|if
condition|(
name|agNULL
operator|==
name|pRequest
condition|)
block|{
name|pRequest
operator|=
operator|(
name|agsaIORequestDesc_t
operator|*
operator|)
name|saLlistIOGetHead
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeReservedRequests
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|agNULL
operator|!=
name|pRequest
condition|)
block|{
name|using_reserved
operator|=
name|agTRUE
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saSMPStart, using saRoot->freeReservedRequests\n"
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saSMPStart, No request from free list Not using saRoot->freeReservedRequests\n"
operator|)
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'b'
argument_list|,
literal|"9a"
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_BUSY
return|;
block|}
block|}
name|inq
operator|=
call|(
name|bit8
call|)
argument_list|(
name|queueNum
operator|&
name|MPI_IB_NUM_MASK
argument_list|)
expr_stmt|;
name|outq
operator|=
call|(
name|bit8
call|)
argument_list|(
operator|(
name|queueNum
operator|&
name|MPI_OB_NUM_MASK
operator|)
operator|>>
name|MPI_OB_SHIFT
argument_list|)
expr_stmt|;
name|SA_ASSERT
argument_list|(
operator|(
name|agNULL
operator|!=
name|agDevHandle
operator|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* Find the outgoing port for the device */
if|if
condition|(
name|agNULL
operator|==
name|agDevHandle
operator|->
name|sdkData
condition|)
block|{
comment|/* Device has been removed */
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saSMPStart, Device has been removed. agDevHandle=%p\n"
operator|,
name|agDevHandle
operator|)
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'a'
argument_list|,
literal|"9a"
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_FAILURE
return|;
block|}
name|pDevice
operator|=
operator|(
name|agsaDeviceDesc_t
operator|*
operator|)
operator|(
name|agDevHandle
operator|->
name|sdkData
operator|)
expr_stmt|;
name|pPort
operator|=
name|pDevice
operator|->
name|pPort
expr_stmt|;
comment|/* If free IOMB avaliable */
comment|/* Remove the request from free list */
if|if
condition|(
name|using_reserved
condition|)
block|{
name|saLlistIORemove
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeReservedRequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|saLlistIORemove
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* Add the request to the pendingSMPRequests list of the device */
name|saLlistIOAdd
argument_list|(
operator|&
operator|(
name|pDevice
operator|->
name|pendingIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
name|SA_ASSERT
argument_list|(
operator|(
operator|!
name|pRequest
operator|->
name|valid
operator|)
argument_list|,
literal|"The pRequest is in use"
argument_list|)
expr_stmt|;
name|pRequest
operator|->
name|valid
operator|=
name|agTRUE
expr_stmt|;
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
comment|/* set up pRequest */
name|pRequest
operator|->
name|pIORequestContext
operator|=
operator|(
name|agsaIORequest_t
operator|*
operator|)
name|pRequest
expr_stmt|;
name|pRequest
operator|->
name|pDevice
operator|=
name|pDevice
expr_stmt|;
name|pRequest
operator|->
name|pPort
operator|=
name|pPort
expr_stmt|;
name|pRequest
operator|->
name|startTick
operator|=
name|saRoot
operator|->
name|timeTick
expr_stmt|;
name|pRequest
operator|->
name|completionCB
operator|=
operator|(
name|ossaSSPCompletedCB_t
operator|)
name|agCB
expr_stmt|;
name|pRequest
operator|->
name|requestType
operator|=
name|AGSA_SMP_IOCTL_REQUEST
expr_stmt|;
comment|/* Set request to the sdkData of agIORequest */
comment|// agIORequest->sdkData		  = pRequest;
comment|/* save tag to IOMap */
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|Tag
operator|=
name|pRequest
operator|->
name|HTag
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|IORequest
operator|=
operator|(
name|void
operator|*
operator|)
name|pRequest
expr_stmt|;
ifdef|#
directive|ifdef
name|SA_LL_IBQ_PROTECT
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_IBQ0_LOCK
operator|+
name|inq
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SA_LL_IBQ_PROTECT */
comment|/* If LL IO request entry avaliable */
comment|/* Get a free inbound queue entry */
name|circularQ
operator|=
operator|&
name|saRoot
operator|->
name|inboundQueue
index|[
name|inq
index|]
expr_stmt|;
name|retVal
operator|=
name|mpiMsgFreeGet
argument_list|(
name|circularQ
argument_list|,
name|IOMB_SIZE64
argument_list|,
operator|&
name|pMessage
argument_list|)
expr_stmt|;
if|if
condition|(
name|AGSA_RC_FAILURE
operator|==
name|retVal
condition|)
block|{
ifdef|#
directive|ifdef
name|SA_LL_IBQ_PROTECT
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_IBQ0_LOCK
operator|+
name|inq
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SA_LL_IBQ_PROTECT */
comment|/* if not sending return to free list rare */
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|saLlistIORemove
argument_list|(
operator|&
operator|(
name|pDevice
operator|->
name|pendingIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
name|pRequest
operator|->
name|valid
operator|=
name|agFALSE
expr_stmt|;
name|saLlistIOAdd
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saSMPStart, error when get free IOMB\n"
operator|)
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'c'
argument_list|,
literal|"9a"
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_FAILURE
return|;
block|}
comment|/* return busy if inbound queue is full */
if|if
condition|(
name|AGSA_RC_BUSY
operator|==
name|retVal
condition|)
block|{
ifdef|#
directive|ifdef
name|SA_LL_IBQ_PROTECT
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_IBQ0_LOCK
operator|+
name|inq
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SA_LL_IBQ_PROTECT */
comment|/* if not sending return to free list rare */
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|saLlistIORemove
argument_list|(
operator|&
operator|(
name|pDevice
operator|->
name|pendingIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
name|pRequest
operator|->
name|valid
operator|=
name|agFALSE
expr_stmt|;
name|saLlistIOAdd
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saSMPStart, no more IOMB\n"
operator|)
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'d'
argument_list|,
literal|"9a"
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_BUSY
return|;
block|}
ifdef|#
directive|ifdef
name|SA_LL_IBQ_PROTECT
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_IBQ0_LOCK
operator|+
name|inq
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SA_LL_IBQ_PROTECT */
if|if
condition|(
name|smIS_SPC
argument_list|(
name|agRoot
argument_list|)
condition|)
block|{
name|agsaSMPCmd_t
name|payload
decl_stmt|;
name|bit32
name|IR_IP_OV_res_phyId_DPdLen_res
init|=
literal|0
decl_stmt|;
comment|/* Prepare the payload of IOMB */
name|si_memset
argument_list|(
operator|&
name|payload
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|agsaSMPCmd_V_t
argument_list|)
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSMPCmd_t
argument_list|,
name|tag
argument_list|)
argument_list|,
name|pRequest
operator|->
name|HTag
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSMPCmd_t
argument_list|,
name|deviceId
argument_list|)
argument_list|,
name|pDevice
operator|->
name|DeviceMapIndex
argument_list|)
expr_stmt|;
comment|/*Indirect request and response*/
if|if
condition|(
name|smpFrameFlagIndirectResponse
operator|&
name|pSMPFrame
operator|->
name|flag
operator|&&
name|smpFrameFlagIndirectPayload
operator|&
name|pSMPFrame
operator|->
name|flag
condition|)
comment|/* */
block|{
name|SA_DBG2
argument_list|(
operator|(
literal|"saSMPStart:V Indirect payload and indirect response\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* Indirect Response mode */
name|pRequest
operator|->
name|IRmode
operator|=
name|INDIRECT_MODE
expr_stmt|;
name|IR_IP_OV_res_phyId_DPdLen_res
operator|=
literal|3
expr_stmt|;
comment|/* payload */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSMPCmd_t
argument_list|,
name|SMPCmd
index|[
literal|4
index|]
argument_list|)
argument_list|,
operator|(
name|pSMPFrame
operator|->
name|outFrameAddrLower32
operator|)
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSMPCmd_t
argument_list|,
name|SMPCmd
index|[
literal|5
index|]
argument_list|)
argument_list|,
operator|(
name|pSMPFrame
operator|->
name|outFrameAddrUpper32
operator|)
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSMPCmd_t
argument_list|,
name|SMPCmd
index|[
literal|6
index|]
argument_list|)
argument_list|,
operator|(
name|pSMPFrame
operator|->
name|outFrameLen
operator|)
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSMPCmd_t
argument_list|,
name|SMPCmd
index|[
literal|8
index|]
argument_list|)
argument_list|,
operator|(
name|pSMPFrame
operator|->
name|inFrameAddrLower32
operator|)
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSMPCmd_t
argument_list|,
name|SMPCmd
index|[
literal|9
index|]
argument_list|)
argument_list|,
operator|(
name|pSMPFrame
operator|->
name|inFrameAddrUpper32
operator|)
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSMPCmd_t
argument_list|,
name|SMPCmd
index|[
literal|10
index|]
argument_list|)
argument_list|,
operator|(
name|pSMPFrame
operator|->
name|inFrameLen
operator|)
argument_list|)
expr_stmt|;
block|}
name|IR_IP_OV_res_phyId_DPdLen_res
operator||=
operator|(
name|pSMPFrame
operator|->
name|flag
operator|&
literal|3
operator|)
expr_stmt|;
comment|/* fatal error if missing */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSMPCmd_t
argument_list|,
name|IR_IP_OV_res_phyId_DPdLen_res
argument_list|)
argument_list|,
name|IR_IP_OV_res_phyId_DPdLen_res
argument_list|)
expr_stmt|;
comment|/* fatal error if missing */
comment|/* check IR bit */
comment|/* Build IOMB command and send it to SPC */
name|payload_ptr
operator|=
operator|(
name|bit8
operator|*
operator|)
operator|&
name|payload
expr_stmt|;
ifdef|#
directive|ifdef
name|SA_LL_IBQ_PROTECT
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_IBQ0_LOCK
operator|+
name|inq
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SA_LL_IBQ_PROTECT */
name|ret
operator|=
name|mpiSMPCmd
argument_list|(
name|agRoot
argument_list|,
name|pMessage
argument_list|,
name|OPC_INB_SMP_REQUEST
argument_list|,
operator|(
name|agsaSMPCmd_t
operator|*
operator|)
name|payload_ptr
argument_list|,
name|inq
argument_list|,
name|outq
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SA_LL_IBQ_PROTECT
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_IBQ0_LOCK
operator|+
name|inq
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SA_LL_IBQ_PROTECT */
block|}
else|else
comment|/* IOMB is different for SPCV SMP */
block|{
name|agsaSMPCmd_V_t
name|vpayload
decl_stmt|;
name|bit32
name|IR_IP_OV_res_phyId_DPdLen_res
init|=
literal|0
decl_stmt|;
comment|/* Prepare the payload of IOMB */
name|si_memset
argument_list|(
operator|&
name|vpayload
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|agsaSMPCmd_V_t
argument_list|)
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|vpayload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSMPCmd_V_t
argument_list|,
name|tag
argument_list|)
argument_list|,
name|pRequest
operator|->
name|HTag
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|vpayload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSMPCmd_V_t
argument_list|,
name|deviceId
argument_list|)
argument_list|,
name|pDevice
operator|->
name|DeviceMapIndex
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|vpayload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSMPCmd_V_t
argument_list|,
name|SMPHDR
argument_list|)
argument_list|,
operator|*
operator|(
operator|(
name|bit32
operator|*
operator|)
name|pSMPFrame
operator|->
name|outFrameBuf
operator|+
literal|0
operator|)
argument_list|)
expr_stmt|;
comment|/*Indirect request and response*/
if|if
condition|(
name|smpFrameFlagIndirectResponse
operator|&
name|pSMPFrame
operator|->
name|flag
operator|&&
name|smpFrameFlagIndirectPayload
operator|&
name|pSMPFrame
operator|->
name|flag
condition|)
comment|/* */
block|{
name|SA_DBG2
argument_list|(
operator|(
literal|"saSMPStart:V Indirect payload and indirect response\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* Indirect Response mode */
name|pRequest
operator|->
name|IRmode
operator|=
name|INDIRECT_MODE
expr_stmt|;
name|IR_IP_OV_res_phyId_DPdLen_res
operator|=
literal|3
expr_stmt|;
comment|/* payload */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|vpayload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSMPCmd_V_t
argument_list|,
name|IndirL_SMPRF15_12
argument_list|)
argument_list|,
operator|(
name|pSMPFrame
operator|->
name|outFrameAddrLower32
operator|)
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|vpayload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSMPCmd_V_t
argument_list|,
name|IndirH_or_SMPRF19_16
argument_list|)
argument_list|,
operator|(
name|pSMPFrame
operator|->
name|outFrameAddrUpper32
operator|)
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|vpayload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSMPCmd_V_t
argument_list|,
name|IndirLen_or_SMPRF23_20
argument_list|)
argument_list|,
operator|(
name|pSMPFrame
operator|->
name|outFrameLen
operator|)
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|vpayload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSMPCmd_V_t
argument_list|,
name|ISRAL_or_SMPRF31_28
argument_list|)
argument_list|,
operator|(
name|pSMPFrame
operator|->
name|inFrameAddrLower32
operator|)
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|vpayload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSMPCmd_V_t
argument_list|,
name|ISRAH_or_SMPRF35_32
argument_list|)
argument_list|,
operator|(
name|pSMPFrame
operator|->
name|inFrameAddrUpper32
operator|)
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|vpayload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSMPCmd_V_t
argument_list|,
name|ISRL_or_SMPRF39_36
argument_list|)
argument_list|,
operator|(
name|pSMPFrame
operator|->
name|inFrameLen
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/*Direct request and indirect response*/
elseif|else
if|if
condition|(
name|smpFrameFlagIndirectResponse
operator|&
name|pSMPFrame
operator|->
name|flag
condition|)
comment|/* */
block|{
name|SA_DBG2
argument_list|(
operator|(
literal|"saSMPStart:V Direct payload and indirect response\n"
operator|)
argument_list|)
expr_stmt|;
name|IR_IP_OV_res_phyId_DPdLen_res
operator|=
operator|(
name|pSMPFrame
operator|->
name|outFrameLen
operator|<<
name|SHIFT16
operator|)
operator||
name|pSMPFrame
operator|->
name|flag
expr_stmt|;
comment|/* Write IR_IP_OV_res_phyId_DPdLen_res field in the payload*/
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|vpayload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSMPCmd_V_t
argument_list|,
name|IR_IP_OV_res_phyId_DPdLen_res
argument_list|)
argument_list|,
name|IR_IP_OV_res_phyId_DPdLen_res
argument_list|)
expr_stmt|;
comment|/* setup indirect response frame address */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|vpayload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSMPCmd_V_t
argument_list|,
name|ISRAL_or_SMPRF31_28
argument_list|)
argument_list|,
operator|(
name|pSMPFrame
operator|->
name|inFrameAddrLower32
operator|)
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|vpayload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSMPCmd_V_t
argument_list|,
name|ISRAH_or_SMPRF35_32
argument_list|)
argument_list|,
operator|(
name|pSMPFrame
operator|->
name|inFrameAddrUpper32
operator|)
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|vpayload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSMPCmd_V_t
argument_list|,
name|ISRL_or_SMPRF39_36
argument_list|)
argument_list|,
operator|(
name|pSMPFrame
operator|->
name|inFrameLen
operator|)
argument_list|)
expr_stmt|;
block|}
name|IR_IP_OV_res_phyId_DPdLen_res
operator||=
operator|(
name|pSMPFrame
operator|->
name|flag
operator|&
literal|3
operator|)
expr_stmt|;
comment|/* fatal error if missing */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|vpayload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSMPCmd_V_t
argument_list|,
name|IR_IP_OV_res_phyId_DPdLen_res
argument_list|)
argument_list|,
name|IR_IP_OV_res_phyId_DPdLen_res
argument_list|)
expr_stmt|;
comment|/* fatal error if missing */
comment|/* check IR bit */
ifdef|#
directive|ifdef
name|SA_LL_IBQ_PROTECT
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_IBQ0_LOCK
operator|+
name|inq
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SA_LL_IBQ_PROTECT */
comment|/* Build IOMB command and send it to SPCv */
name|payload_ptr
operator|=
operator|(
name|bit8
operator|*
operator|)
operator|&
name|vpayload
expr_stmt|;
name|ret
operator|=
name|mpiSMPCmd
argument_list|(
name|agRoot
argument_list|,
name|pMessage
argument_list|,
name|OPC_INB_SMP_REQUEST
argument_list|,
operator|(
name|agsaSMPCmd_t
operator|*
operator|)
name|payload_ptr
argument_list|,
name|inq
argument_list|,
name|outq
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SA_LL_IBQ_PROTECT
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_IBQ0_LOCK
operator|+
name|inq
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SA_LL_IBQ_PROTECT */
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*! \brief Reconfiguration of SAS Parameters Command  *  *  This command Reconfigure the SAS parameters to SPC.  *  *  \param agRoot       Handles for this instance of SAS/SATA LL  *  \param agContext    Context of SPC FW Flash Update Command  *  \param queueNum     Inbound/outbound queue number  *  \param agSASConfig  Pointer of SAS Configuration Parameters  *  *  \return If the MPI command is sent to SPC successfully  *          - \e AGSA_RC_SUCCESS the MPI command is successfully  *          - \e AGSA_RC_FAILURE the MPI command is failure  *  */
end_comment

begin_comment
comment|/*******************************************************************************/
end_comment

begin_comment
comment|//GLOBAL bit32 saReconfigSASParams(
end_comment

begin_function
name|bit32
name|saReconfigSASParams
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|agsaContext_t
modifier|*
name|agContext
parameter_list|,
name|bit32
name|queueNum
parameter_list|,
name|agsaSASReconfig_t
modifier|*
name|agSASConfig
parameter_list|)
block|{
name|bit32
name|ret
init|=
name|AGSA_RC_SUCCESS
decl_stmt|;
comment|/* sanity check */
name|SA_ASSERT
argument_list|(
operator|(
name|agNULL
operator|!=
name|agRoot
operator|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|smIS_SPCV
argument_list|(
name|agRoot
argument_list|)
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"saReconfigSASParams: AGSA_RC_FAILURE for SPCv\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|AGSA_RC_FAILURE
operator|)
return|;
block|}
comment|/* build IOMB command and send to SPC */
name|ret
operator|=
name|mpiSasReinitializeCmd
argument_list|(
name|agRoot
argument_list|,
name|agContext
argument_list|,
name|agSASConfig
argument_list|,
name|queueNum
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*! \brief Dump GSM registers from the controller  *  *  \param agRoot         Handles for this instance of SAS/SATA hardware  *  \param gsmDumpOffset  Offset of GSM  *  \param length         Max is 1 MB  *  \param directData     address of GSM data dump to  *  *  \return  *          - \e AGSA_RC_SUCCESS saGSMDump is successfully  *          - \e AGSA_RC_FAILURE saGSMDump is not successfully  *  */
end_comment

begin_comment
comment|/*******************************************************************************/
end_comment

begin_comment
comment|//LOCAL bit32 siGSMDump(
end_comment

begin_function
name|bit32
name|siGSMDump
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|bit32
name|gsmDumpOffset
parameter_list|,
name|bit32
name|length
parameter_list|,
name|void
modifier|*
name|directData
parameter_list|)
block|{
name|bit8
modifier|*
name|dst
decl_stmt|;
name|bit32
name|value
decl_stmt|,
name|rem
decl_stmt|,
name|offset
init|=
literal|0
decl_stmt|;
name|bit32
name|i
decl_stmt|,
name|workOffset
decl_stmt|,
name|dwLength
decl_stmt|;
name|bit32
name|bar
init|=
literal|0
decl_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"siGSMDump: gsmDumpOffset 0x%x length 0x%x\n"
operator|,
name|gsmDumpOffset
operator|,
name|length
operator|)
argument_list|)
expr_stmt|;
comment|/* check max is 64k chunks */
if|if
condition|(
name|length
operator|>
operator|(
literal|64
operator|*
literal|1024
operator|)
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"siGSMDump: Max length is greater than 64K  bytes 0x%x\n"
operator|,
name|length
operator|)
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_FAILURE
return|;
block|}
if|if
condition|(
name|gsmDumpOffset
operator|&
literal|3
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"siGSMDump: Not allow NON_DW Boundary 0x%x\n"
operator|,
name|gsmDumpOffset
operator|)
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_FAILURE
return|;
block|}
if|if
condition|(
operator|(
name|gsmDumpOffset
operator|+
name|length
operator|)
operator|>
name|ONE_MEGABYTE
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"siGSMDump: Out of GSM end address boundary 0x%x\n"
operator|,
operator|(
name|gsmDumpOffset
operator|+
name|length
operator|)
operator|)
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_FAILURE
return|;
block|}
if|if
condition|(
name|smIS_SPCV
argument_list|(
name|agRoot
argument_list|)
condition|)
block|{
name|bar
operator|=
name|PCIBAR1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|smIS_SPC
argument_list|(
name|agRoot
argument_list|)
condition|)
block|{
name|bar
operator|=
name|PCIBAR2
expr_stmt|;
block|}
else|else
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"siGSMDump: device type is not supported"
operator|)
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_FAILURE
return|;
block|}
name|workOffset
operator|=
name|gsmDumpOffset
operator|&
literal|0xFFFF0000
expr_stmt|;
name|offset
operator|=
name|gsmDumpOffset
operator|&
literal|0x0000FFFF
expr_stmt|;
name|gsmDumpOffset
operator|=
name|workOffset
expr_stmt|;
name|dst
operator|=
operator|(
name|bit8
operator|*
operator|)
name|directData
expr_stmt|;
comment|/* adjust length to dword boundary */
name|rem
operator|=
name|length
operator|&
literal|3
expr_stmt|;
name|dwLength
operator|=
name|length
operator|>>
literal|2
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dwLength
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|workOffset
operator|+
name|offset
operator|)
operator|>
name|length
condition|)
block|{
break|break;
block|}
name|value
operator|=
name|ossaHwRegReadExt
argument_list|(
name|agRoot
argument_list|,
name|bar
argument_list|,
operator|(
name|workOffset
operator|+
name|offset
operator|)
operator|&
literal|0x0000FFFF
argument_list|)
expr_stmt|;
comment|/* xfr for dw */
name|si_memcpy
argument_list|(
name|dst
argument_list|,
operator|&
name|value
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|dst
operator|+=
literal|4
expr_stmt|;
name|offset
operator|+=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|rem
operator|!=
literal|0
condition|)
block|{
name|value
operator|=
name|ossaHwRegReadExt
argument_list|(
name|agRoot
argument_list|,
name|bar
argument_list|,
operator|(
name|workOffset
operator|+
name|offset
operator|)
operator|&
literal|0x0000FFFF
argument_list|)
expr_stmt|;
comment|/* xfr for non_dw */
if|if
condition|(
name|dst
condition|)
block|{
name|si_memcpy
argument_list|(
name|dst
argument_list|,
operator|&
name|value
argument_list|,
name|rem
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Shift back to BAR4 original address */
if|if
condition|(
name|AGSA_RC_FAILURE
operator|==
name|siBar4Shift
argument_list|(
name|agRoot
argument_list|,
literal|0x0
argument_list|)
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"siGSMDump:Shift Bar4 to 0x%x failed\n"
operator|,
literal|0x0
operator|)
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_FAILURE
return|;
block|}
return|return
name|AGSA_RC_SUCCESS
return|;
block|}
end_function

begin_comment
comment|//GLOBAL bit32 saPCIeDiagExecute(
end_comment

begin_function
name|bit32
name|saPCIeDiagExecute
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|agsaContext_t
modifier|*
name|agContext
parameter_list|,
name|bit32
name|queueNum
parameter_list|,
name|agsaPCIeDiagExecute_t
modifier|*
name|diag
parameter_list|)
block|{
name|bit32
name|ret
init|=
name|AGSA_RC_SUCCESS
decl_stmt|;
name|agsaLLRoot_t
modifier|*
name|saRoot
init|=
name|agNULL
decl_stmt|;
name|agsaIORequestDesc_t
modifier|*
name|pRequest
decl_stmt|;
name|bit32
name|payload
index|[
literal|32
index|]
decl_stmt|;
name|smTraceFuncEnter
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|"6r"
argument_list|)
expr_stmt|;
comment|/* sanity check */
name|SA_ASSERT
argument_list|(
operator|(
name|agNULL
operator|!=
name|agRoot
operator|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|saRoot
operator|=
operator|(
name|agsaLLRoot_t
operator|*
operator|)
operator|(
name|agRoot
operator|->
name|sdkData
operator|)
expr_stmt|;
comment|/* sanity check */
name|SA_ASSERT
argument_list|(
operator|(
name|agNULL
operator|!=
name|saRoot
operator|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|SA_ASSERT
argument_list|(
operator|(
name|agNULL
operator|!=
name|diag
operator|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|diag
operator|->
name|len
operator|==
literal|0
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"saPCIeDiagExecute,  diag->len Zero\n"
operator|)
argument_list|)
expr_stmt|;
block|}
name|SA_DBG1
argument_list|(
operator|(
literal|"saPCIeDiagExecute, diag->command  0x%X\n"
operator|,
name|diag
operator|->
name|command
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saPCIeDiagExecute, diag->flags  0x%X\n"
operator|,
name|diag
operator|->
name|flags
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saPCIeDiagExecute,  diag->initialIOSeed  0x%X\n"
operator|,
name|diag
operator|->
name|initialIOSeed
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saPCIeDiagExecute, diag->reserved   0x%X\n"
operator|,
name|diag
operator|->
name|reserved
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saPCIeDiagExecute, diag->rdAddrLower   0x%X\n"
operator|,
name|diag
operator|->
name|rdAddrLower
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saPCIeDiagExecute, diag->rdAddrUpper   0x%X\n"
operator|,
name|diag
operator|->
name|rdAddrUpper
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saPCIeDiagExecute, diag->wrAddrLower   0x%X\n"
operator|,
name|diag
operator|->
name|wrAddrLower
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saPCIeDiagExecute, diag->wrAddrUpper   0x%X\n"
operator|,
name|diag
operator|->
name|wrAddrUpper
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saPCIeDiagExecute,  diag->len   0x%X\n"
operator|,
name|diag
operator|->
name|len
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saPCIeDiagExecute, diag->pattern  0x%X\n"
operator|,
name|diag
operator|->
name|pattern
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saPCIeDiagExecute, %02X %02X %02X %02X %02X %02X\n"
operator|,
name|diag
operator|->
name|udtArray
index|[
literal|0
index|]
operator|,
name|diag
operator|->
name|udtArray
index|[
literal|1
index|]
operator|,
name|diag
operator|->
name|udtArray
index|[
literal|2
index|]
operator|,
name|diag
operator|->
name|udtArray
index|[
literal|3
index|]
operator|,
name|diag
operator|->
name|udtArray
index|[
literal|4
index|]
operator|,
name|diag
operator|->
name|udtArray
index|[
literal|5
index|]
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saPCIeDiagExecute, %02X %02X %02X %02X %02X %02X\n"
operator|,
name|diag
operator|->
name|udrtArray
index|[
literal|0
index|]
operator|,
name|diag
operator|->
name|udrtArray
index|[
literal|1
index|]
operator|,
name|diag
operator|->
name|udrtArray
index|[
literal|2
index|]
operator|,
name|diag
operator|->
name|udrtArray
index|[
literal|3
index|]
operator|,
name|diag
operator|->
name|udrtArray
index|[
literal|4
index|]
operator|,
name|diag
operator|->
name|udrtArray
index|[
literal|5
index|]
operator|)
argument_list|)
expr_stmt|;
comment|/* Get request from free IORequests */
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|pRequest
operator|=
operator|(
name|agsaIORequestDesc_t
operator|*
operator|)
name|saLlistIOGetHead
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|)
expr_stmt|;
comment|/* If no LL Control request entry available */
if|if
condition|(
name|agNULL
operator|==
name|pRequest
condition|)
block|{
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saPCIeDiagExecute, No request from free list\n"
operator|)
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'a'
argument_list|,
literal|"6r"
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_BUSY
return|;
block|}
comment|/* If LL Control request entry avaliable */
comment|/* Remove the request from free list */
name|saLlistIORemove
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|Tag
operator|=
name|pRequest
operator|->
name|HTag
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|IORequest
operator|=
operator|(
name|void
operator|*
operator|)
name|pRequest
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|agContext
operator|=
name|agContext
expr_stmt|;
name|pRequest
operator|->
name|valid
operator|=
name|agTRUE
expr_stmt|;
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
comment|/* set payload to zeros */
name|si_memset
argument_list|(
operator|&
name|payload
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|payload
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|smIS_SPCV
argument_list|(
name|agRoot
argument_list|)
condition|)
block|{
name|bit32
name|UDTR1_UDT0
decl_stmt|,
name|UDT5_UDT2
decl_stmt|,
name|UDTR5_UDTR2
decl_stmt|;
name|UDTR5_UDTR2
operator|=
operator|(
operator|(
name|diag
operator|->
name|udrtArray
index|[
literal|5
index|]
operator|<<
name|SHIFT24
operator|)
operator||
operator|(
name|diag
operator|->
name|udrtArray
index|[
literal|4
index|]
operator|<<
name|SHIFT16
operator|)
operator||
operator|(
name|diag
operator|->
name|udrtArray
index|[
literal|3
index|]
operator|<<
name|SHIFT8
operator|)
operator||
name|diag
operator|->
name|udrtArray
index|[
literal|2
index|]
operator|)
expr_stmt|;
name|UDT5_UDT2
operator|=
operator|(
operator|(
name|diag
operator|->
name|udtArray
index|[
literal|5
index|]
operator|<<
name|SHIFT24
operator|)
operator||
operator|(
name|diag
operator|->
name|udtArray
index|[
literal|4
index|]
operator|<<
name|SHIFT16
operator|)
operator||
operator|(
name|diag
operator|->
name|udtArray
index|[
literal|3
index|]
operator|<<
name|SHIFT8
operator|)
operator||
name|diag
operator|->
name|udtArray
index|[
literal|2
index|]
operator|)
expr_stmt|;
name|UDTR1_UDT0
operator|=
operator|(
operator|(
name|diag
operator|->
name|udrtArray
index|[
literal|1
index|]
operator|<<
name|SHIFT24
operator|)
operator||
operator|(
name|diag
operator|->
name|udrtArray
index|[
literal|0
index|]
operator|<<
name|SHIFT16
operator|)
operator||
operator|(
name|diag
operator|->
name|udtArray
index|[
literal|1
index|]
operator|<<
name|SHIFT8
operator|)
operator||
name|diag
operator|->
name|udtArray
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaPCIeDiagExecuteCmd_t
argument_list|,
name|tag
argument_list|)
argument_list|,
name|pRequest
operator|->
name|HTag
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaPCIeDiagExecuteCmd_t
argument_list|,
name|CmdTypeDesc
argument_list|)
argument_list|,
name|diag
operator|->
name|command
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaPCIeDiagExecuteCmd_t
argument_list|,
name|UUM_EDA
argument_list|)
argument_list|,
name|diag
operator|->
name|flags
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaPCIeDiagExecuteCmd_t
argument_list|,
name|UDTR1_UDT0
argument_list|)
argument_list|,
name|UDTR1_UDT0
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaPCIeDiagExecuteCmd_t
argument_list|,
name|UDT5_UDT2
argument_list|)
argument_list|,
name|UDT5_UDT2
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaPCIeDiagExecuteCmd_t
argument_list|,
name|UDTR5_UDTR2
argument_list|)
argument_list|,
name|UDTR5_UDTR2
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaPCIeDiagExecuteCmd_t
argument_list|,
name|Res_IOS
argument_list|)
argument_list|,
name|diag
operator|->
name|initialIOSeed
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaPCIeDiagExecuteCmd_t
argument_list|,
name|rdAddrLower
argument_list|)
argument_list|,
name|diag
operator|->
name|rdAddrLower
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaPCIeDiagExecuteCmd_t
argument_list|,
name|rdAddrUpper
argument_list|)
argument_list|,
name|diag
operator|->
name|rdAddrUpper
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaPCIeDiagExecuteCmd_t
argument_list|,
name|wrAddrLower
argument_list|)
argument_list|,
name|diag
operator|->
name|wrAddrLower
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaPCIeDiagExecuteCmd_t
argument_list|,
name|wrAddrUpper
argument_list|)
argument_list|,
name|diag
operator|->
name|wrAddrUpper
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaPCIeDiagExecuteCmd_t
argument_list|,
name|len
argument_list|)
argument_list|,
name|diag
operator|->
name|len
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaPCIeDiagExecuteCmd_t
argument_list|,
name|pattern
argument_list|)
argument_list|,
name|diag
operator|->
name|pattern
argument_list|)
expr_stmt|;
name|ret
operator|=
name|mpiBuildCmd
argument_list|(
name|agRoot
argument_list|,
operator|(
name|bit32
operator|*
operator|)
operator|&
name|payload
argument_list|,
name|MPI_CATEGORY_SAS_SATA
argument_list|,
name|OPC_INB_PCIE_DIAG_EXECUTE
argument_list|,
name|IOMB_SIZE128
argument_list|,
name|queueNum
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* build IOMB command and send to SPC */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsa_SPC_PCIDiagExecuteCmd_t
argument_list|,
name|tag
argument_list|)
argument_list|,
name|pRequest
operator|->
name|HTag
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsa_SPC_PCIDiagExecuteCmd_t
argument_list|,
name|CmdTypeDesc
argument_list|)
argument_list|,
name|diag
operator|->
name|command
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsa_SPC_PCIDiagExecuteCmd_t
argument_list|,
name|rdAddrLower
argument_list|)
argument_list|,
name|diag
operator|->
name|rdAddrLower
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsa_SPC_PCIDiagExecuteCmd_t
argument_list|,
name|rdAddrUpper
argument_list|)
argument_list|,
name|diag
operator|->
name|rdAddrUpper
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsa_SPC_PCIDiagExecuteCmd_t
argument_list|,
name|wrAddrLower
argument_list|)
argument_list|,
name|diag
operator|->
name|wrAddrLower
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsa_SPC_PCIDiagExecuteCmd_t
argument_list|,
name|wrAddrUpper
argument_list|)
argument_list|,
name|diag
operator|->
name|wrAddrUpper
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsa_SPC_PCIDiagExecuteCmd_t
argument_list|,
name|len
argument_list|)
argument_list|,
name|diag
operator|->
name|len
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsa_SPC_PCIDiagExecuteCmd_t
argument_list|,
name|pattern
argument_list|)
argument_list|,
name|diag
operator|->
name|pattern
argument_list|)
expr_stmt|;
name|ret
operator|=
name|mpiBuildCmd
argument_list|(
name|agRoot
argument_list|,
operator|(
name|bit32
operator|*
operator|)
operator|&
name|payload
argument_list|,
name|MPI_CATEGORY_SAS_SATA
argument_list|,
name|OPC_INB_PCIE_DIAG_EXECUTE
argument_list|,
name|IOMB_SIZE64
argument_list|,
name|queueNum
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|AGSA_RC_SUCCESS
operator|!=
name|ret
condition|)
block|{
comment|/* remove the request from IOMap */
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|Tag
operator|=
name|MARK_OFF
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|IORequest
operator|=
name|agNULL
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|agContext
operator|=
name|agNULL
expr_stmt|;
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|pRequest
operator|->
name|valid
operator|=
name|agFALSE
expr_stmt|;
comment|/* return the request to free pool */
name|saLlistIOAdd
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saPCIeDiagExecute, sending IOMB failed\n"
operator|)
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'b'
argument_list|,
literal|"6r"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'c'
argument_list|,
literal|"6r"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|//GLOBAL bit32 saGetDFEData(
end_comment

begin_function
name|bit32
name|saGetDFEData
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|agsaContext_t
modifier|*
name|agContext
parameter_list|,
name|bit32
name|queueNum
parameter_list|,
name|bit32
name|interface
parameter_list|,
name|bit32
name|laneNumber
parameter_list|,
name|bit32
name|interations
parameter_list|,
name|agsaSgl_t
modifier|*
name|agSgl
parameter_list|)
block|{
name|bit32
name|ret
init|=
name|AGSA_RC_SUCCESS
decl_stmt|;
name|agsaLLRoot_t
modifier|*
name|saRoot
init|=
name|agNULL
decl_stmt|;
name|agsaIORequestDesc_t
modifier|*
name|pRequest
init|=
name|agNULL
decl_stmt|;
name|bit32
name|payload
index|[
literal|32
index|]
decl_stmt|;
name|bit32
name|reserved_In_Ln
decl_stmt|;
name|smTraceFuncEnter
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|"2X"
argument_list|)
expr_stmt|;
comment|/* sanity check */
name|SA_ASSERT
argument_list|(
operator|(
name|agNULL
operator|!=
name|agRoot
operator|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|saRoot
operator|=
operator|(
name|agsaLLRoot_t
operator|*
operator|)
operator|(
name|agRoot
operator|->
name|sdkData
operator|)
expr_stmt|;
name|SA_ASSERT
argument_list|(
operator|(
name|agNULL
operator|!=
name|saRoot
operator|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|SA_ASSERT
argument_list|(
operator|(
name|agNULL
operator|!=
name|agSgl
operator|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* Get request from free IORequests */
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|pRequest
operator|=
operator|(
name|agsaIORequestDesc_t
operator|*
operator|)
name|saLlistIOGetHead
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|)
expr_stmt|;
comment|/* If no LL Control request entry available */
if|if
condition|(
name|agNULL
operator|==
name|pRequest
condition|)
block|{
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetDFEData, No request from free list\n"
operator|)
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'a'
argument_list|,
literal|"2X"
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_BUSY
return|;
block|}
comment|/* If LL Control request entry avaliable */
comment|/* Remove the request from free list */
name|saLlistIORemove
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|Tag
operator|=
name|pRequest
operator|->
name|HTag
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|IORequest
operator|=
operator|(
name|void
operator|*
operator|)
name|pRequest
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|agContext
operator|=
name|agContext
expr_stmt|;
name|pRequest
operator|->
name|valid
operator|=
name|agTRUE
expr_stmt|;
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
comment|/* set payload to zeros */
name|si_memset
argument_list|(
operator|&
name|payload
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|payload
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|smIS_SPCV
argument_list|(
name|agRoot
argument_list|)
condition|)
block|{
name|reserved_In_Ln
operator|=
operator|(
operator|(
name|interface
operator|&
literal|0x1
operator|)
operator|<<
name|SHIFT7
operator|)
operator||
operator|(
name|laneNumber
operator|&
literal|0x7F
operator|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaGetDDEFDataCmd_t
argument_list|,
name|tag
argument_list|)
argument_list|,
name|pRequest
operator|->
name|HTag
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaGetDDEFDataCmd_t
argument_list|,
name|reserved_In_Ln
argument_list|)
argument_list|,
name|reserved_In_Ln
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaGetDDEFDataCmd_t
argument_list|,
name|MCNT
argument_list|)
argument_list|,
name|interations
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaGetDDEFDataCmd_t
argument_list|,
name|Buf_AddrL
argument_list|)
argument_list|,
name|agSgl
operator|->
name|sgLower
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaGetDDEFDataCmd_t
argument_list|,
name|Buf_AddrH
argument_list|)
argument_list|,
name|agSgl
operator|->
name|sgUpper
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaGetDDEFDataCmd_t
argument_list|,
name|Buf_Len
argument_list|)
argument_list|,
name|agSgl
operator|->
name|len
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaGetDDEFDataCmd_t
argument_list|,
name|E_reserved
argument_list|)
argument_list|,
name|agSgl
operator|->
name|extReserved
argument_list|)
expr_stmt|;
name|ret
operator|=
name|mpiBuildCmd
argument_list|(
name|agRoot
argument_list|,
operator|(
name|bit32
operator|*
operator|)
operator|&
name|payload
argument_list|,
name|MPI_CATEGORY_SAS_SATA
argument_list|,
name|OPC_INB_GET_DFE_DATA
argument_list|,
name|IOMB_SIZE128
argument_list|,
name|queueNum
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* SPC does not support this command */
name|ret
operator|=
name|AGSA_RC_FAILURE
expr_stmt|;
block|}
if|if
condition|(
name|AGSA_RC_SUCCESS
operator|!=
name|ret
condition|)
block|{
comment|/* remove the request from IOMap */
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|Tag
operator|=
name|MARK_OFF
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|IORequest
operator|=
name|agNULL
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|agContext
operator|=
name|agNULL
expr_stmt|;
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|pRequest
operator|->
name|valid
operator|=
name|agFALSE
expr_stmt|;
comment|/* return the request to free pool */
name|saLlistIOAdd
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saPCIeDiagExecute, sending IOMB failed\n"
operator|)
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'b'
argument_list|,
literal|"2X"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'c'
argument_list|,
literal|"2X"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

end_unit

