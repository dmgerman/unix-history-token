begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************************* *Copyright (c) 2014 PMC-Sierra, Inc.  All rights reserved.  * *Redistribution and use in source and binary forms, with or without modification, are permitted provided  *that the following conditions are met:  *1. Redistributions of source code must retain the above copyright notice, this list of conditions and the *following disclaimer.  *2. Redistributions in binary form must reproduce the above copyright notice,  *this list of conditions and the following disclaimer in the documentation and/or other materials provided *with the distribution.  * *THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR IMPLIED  *WARRANTIES,INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS *FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE *FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  *NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR  *BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  *LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  *SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE  ********************************************************************************/
end_comment

begin_comment
comment|/*******************************************************************************/
end_comment

begin_comment
comment|/*! \file mpidebug.c  *  \brief The file is a MPI Libraries to implement the MPI debug and trace functions  *  * The file implements the MPI functions.  *  */
end_comment

begin_comment
comment|/*******************************************************************************/
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<dev/pms/config.h>
end_include

begin_include
include|#
directive|include
file|<dev/pms/RefTisa/sallsdk/spc/saglobal.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|MPI_DEBUG_TRACE_ENABLE
end_ifdef

begin_comment
comment|/* enable with CCBUILD_MPI_TRACE*/
end_comment

begin_comment
comment|/*******************************************************************************/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|OSLAYER_USE_HI_RES_TIMER
end_ifdef

begin_function_decl
name|unsigned
name|__int64
name|GetHiResTimeStamp
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OSLAYER_USE_HI_RES_TIMER */
end_comment

begin_comment
comment|/*******************************************************************************/
end_comment

begin_comment
comment|/*******************************************************************************/
end_comment

begin_comment
comment|/* FUNCTIONS                                                                   */
end_comment

begin_comment
comment|/*******************************************************************************/
end_comment

begin_decl_stmt
name|mpiDebugObTrace_t
name|obTraceData
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|mpiDebugIbTrace_t
name|ibTraceData
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|mpiTraceInit
parameter_list|(
name|void
parameter_list|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"mpiTraceInit:obTraceData @ %p\n"
operator|,
operator|&
name|obTraceData
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"mpiTraceInit:ibTraceData @ %p\n"
operator|,
operator|&
name|ibTraceData
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"mpiTraceInit: num enties %d Ib Iomb size %d Ob Iomb size %d\n"
operator|,
name|MPI_DEBUG_TRACE_BUFFER_MAX
operator|,
name|MPI_DEBUG_TRACE_IB_IOMB_SIZE
operator|,
name|MPI_DEBUG_TRACE_OB_IOMB_SIZE
operator|)
argument_list|)
expr_stmt|;
name|si_memset
argument_list|(
operator|&
name|obTraceData
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|obTraceData
argument_list|)
argument_list|)
expr_stmt|;
name|si_memset
argument_list|(
operator|&
name|ibTraceData
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ibTraceData
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|mpiTraceAdd
parameter_list|(
name|bit32
name|q
parameter_list|,
name|bit32
name|pici
parameter_list|,
name|bit32
name|ib
parameter_list|,
name|void
modifier|*
name|iomb
parameter_list|,
name|bit32
name|numBytes
parameter_list|)
block|{
name|bit32
name|curIdx
decl_stmt|;
name|mpiDebugIbTraceEntry_t
modifier|*
name|curIbTrace
decl_stmt|;
name|mpiDebugObTraceEntry_t
modifier|*
name|curObTrace
decl_stmt|;
name|mpiDebugIbTrace_t
modifier|*
name|ibTrace
init|=
operator|&
name|ibTraceData
decl_stmt|;
name|mpiDebugObTrace_t
modifier|*
name|obTrace
init|=
operator|&
name|obTraceData
decl_stmt|;
if|if
condition|(
name|ib
condition|)
block|{
if|if
condition|(
name|ibTrace
operator|->
name|Idx
operator|>=
name|MPI_DEBUG_TRACE_BUFFER_MAX
condition|)
block|{
name|ibTrace
operator|->
name|Idx
operator|=
literal|0
expr_stmt|;
block|}
name|curIdx
operator|=
name|ibTrace
operator|->
name|Idx
expr_stmt|;
name|curIbTrace
operator|=
operator|&
name|ibTrace
operator|->
name|Data
index|[
name|curIdx
index|]
expr_stmt|;
name|curIbTrace
operator|->
name|pEntry
operator|=
name|iomb
expr_stmt|;
name|curIbTrace
operator|->
name|QNum
operator|=
name|q
expr_stmt|;
name|curIbTrace
operator|->
name|pici
operator|=
name|pici
expr_stmt|;
ifdef|#
directive|ifdef
name|OSLAYER_USE_HI_RES_TIMER
ifdef|#
directive|ifdef
name|SA_64BIT_TIMESTAMP
name|curIbTrace
operator|->
name|Time
operator|=
name|ossaTimeStamp64
argument_list|(
name|agNULL
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* SA_64BIT_TIMESTAMP */
name|curIbTrace
operator|->
name|Time
operator|=
name|ossaTimeStamp
argument_list|(
name|agNULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SA_64BIT_TIMESTAMP */
else|#
directive|else
comment|/* OSLAYER_USE_HI_RES_TIMER */
name|curIbTrace
operator|->
name|Time
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|si_memcpy
argument_list|(
name|curIbTrace
operator|->
name|Iomb
argument_list|,
name|iomb
argument_list|,
name|MIN
argument_list|(
name|numBytes
argument_list|,
name|MPI_DEBUG_TRACE_IB_IOMB_SIZE
argument_list|)
argument_list|)
expr_stmt|;
name|ibTrace
operator|->
name|Idx
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|obTrace
operator|->
name|Idx
operator|>=
name|MPI_DEBUG_TRACE_BUFFER_MAX
condition|)
block|{
name|obTrace
operator|->
name|Idx
operator|=
literal|0
expr_stmt|;
block|}
name|curIdx
operator|=
name|obTrace
operator|->
name|Idx
expr_stmt|;
name|curObTrace
operator|=
operator|&
name|obTrace
operator|->
name|Data
index|[
name|curIdx
index|]
expr_stmt|;
name|curObTrace
operator|->
name|pEntry
operator|=
name|iomb
expr_stmt|;
name|curObTrace
operator|->
name|QNum
operator|=
name|q
expr_stmt|;
name|curObTrace
operator|->
name|pici
operator|=
name|pici
expr_stmt|;
ifdef|#
directive|ifdef
name|OSLAYER_USE_HI_RES_TIMER
ifdef|#
directive|ifdef
name|SA_64BIT_TIMESTAMP
name|curObTrace
operator|->
name|Time
operator|=
name|ossaTimeStamp64
argument_list|(
name|agNULL
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* SA_64BIT_TIMESTAMP */
name|curObTrace
operator|->
name|Time
operator|=
name|ossaTimeStamp
argument_list|(
name|agNULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SA_64BIT_TIMESTAMP */
else|#
directive|else
comment|/* OSLAYER_USE_HI_RES_TIMER */
name|curObTrace
operator|->
name|Time
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|si_memcpy
argument_list|(
name|curObTrace
operator|->
name|Iomb
argument_list|,
name|iomb
argument_list|,
name|MIN
argument_list|(
name|numBytes
argument_list|,
name|MPI_DEBUG_TRACE_OB_IOMB_SIZE
argument_list|)
argument_list|)
expr_stmt|;
name|obTrace
operator|->
name|Idx
operator|++
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MPI_DEBUG_TRACE_ENABLE */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SA_ENABLE_TRACE_FUNCTIONS
end_ifdef

begin_comment
comment|/**  * fiEnableTracing  *  *    This fucntion is called to initialize tracing of FC layer.  *  */
end_comment

begin_function
name|void
name|siEnableTracing
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|)
block|{
name|agsaLLRoot_t
modifier|*
name|saRoot
init|=
operator|(
name|agsaLLRoot_t
operator|*
operator|)
operator|(
name|agRoot
operator|->
name|sdkData
operator|)
decl_stmt|;
name|agsaSwConfig_t
modifier|*
name|swC
init|=
operator|&
name|saRoot
operator|->
name|swConfig
decl_stmt|;
name|bit32
name|count
decl_stmt|;
name|OS_ASSERT
argument_list|(
name|saRoot
operator|!=
name|NULL
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|saRoot
operator|->
name|TraceBlockReInit
operator|!=
literal|0
condition|)
block|{
return|return;
block|}
comment|/* Initialize tracing first */
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
literal|10
condition|;
name|count
operator|++
control|)
block|{
name|saRoot
operator|->
name|traceBuffLookup
index|[
name|count
index|]
operator|=
call|(
name|bit8
call|)
argument_list|(
literal|'0'
operator|+
name|count
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
literal|6
condition|;
name|count
operator|++
control|)
block|{
name|saRoot
operator|->
name|traceBuffLookup
index|[
operator|(
name|bitptr
operator|)
name|count
operator|+
literal|10
index|]
operator|=
call|(
name|bit8
call|)
argument_list|(
literal|'a'
operator|+
name|count
argument_list|)
expr_stmt|;
block|}
name|saRoot
operator|->
name|TraceDestination
operator|=
name|swC
operator|->
name|TraceDestination
expr_stmt|;
name|saRoot
operator|->
name|TraceMask
operator|=
name|swC
operator|->
name|TraceMask
expr_stmt|;
name|saRoot
operator|->
name|CurrentTraceIndexWrapCount
operator|=
literal|0
expr_stmt|;
name|saRoot
operator|->
name|CurrentTraceIndex
operator|=
literal|0
expr_stmt|;
name|saRoot
operator|->
name|TraceBlockReInit
operator|=
literal|1
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"siEnableTracing: \n"
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"      length       = %08x\n"
operator|,
name|saRoot
operator|->
name|TraceBufferLength
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"      virt         = %p\n"
operator|,
name|saRoot
operator|->
name|TraceBuffer
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"    traceMask        = %08x @ %p\n"
operator|,
name|saRoot
operator|->
name|TraceMask
operator|,
operator|&
name|saRoot
operator|->
name|TraceMask
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"    last trace entry @ %p\n"
operator|,
operator|&
name|saRoot
operator|->
name|CurrentTraceIndex
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"    TraceWrapAround  = %x\n"
operator|,
name|saRoot
operator|->
name|TraceMask
operator|&
name|hpDBG_TraceBufferWrapAround
condition|?
literal|1
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"    da %p l %x\n"
operator|,
name|saRoot
operator|->
name|TraceBuffer
operator|,
name|saRoot
operator|->
name|TraceBufferLength
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SA_PRINTOUT_IN_WINDBG
ifndef|#
directive|ifndef
name|DBG
name|DbgPrint
argument_list|(
literal|"siTraceEnable: \n"
argument_list|)
expr_stmt|;
name|DbgPrint
argument_list|(
literal|"      length       = %08x\n"
argument_list|,
name|saRoot
operator|->
name|TraceBufferLength
argument_list|)
expr_stmt|;
name|DbgPrint
argument_list|(
literal|"      virt         = %p\n"
argument_list|,
name|saRoot
operator|->
name|TraceBuffer
argument_list|)
expr_stmt|;
name|DbgPrint
argument_list|(
literal|"    last trace entry @ %p\n"
argument_list|,
operator|&
name|saRoot
operator|->
name|CurrentTraceIndex
argument_list|)
expr_stmt|;
name|DbgPrint
argument_list|(
literal|"    traceMask      = %08x @ %p\n"
argument_list|,
name|saRoot
operator|->
name|TraceMask
argument_list|,
operator|&
name|saRoot
operator|->
name|TraceMask
argument_list|)
expr_stmt|;
name|DbgPrint
argument_list|(
literal|"    da %p l %x\n"
argument_list|,
name|saRoot
operator|->
name|TraceBuffer
argument_list|,
name|saRoot
operator|->
name|TraceBufferLength
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DBG  */
endif|#
directive|endif
comment|/* SA_PRINTOUT_IN_WINDBG  */
comment|/*   ** Init trace buffer with all spaces   */
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|saRoot
operator|->
name|TraceBufferLength
condition|;
name|count
operator|++
control|)
block|{
name|saRoot
operator|->
name|TraceBuffer
index|[
name|count
index|]
operator|=
operator|(
name|bit8
operator|)
literal|' '
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * IF_DO_TRACE  *  * PURPOSE:     convenience macro for the "to output or not to output" logic  *  * PARAMETERS:  *  * CALLS:  *  * SIDE EFFECTS& CAVEATS:  *  * ALGORITHM:  *  *  *  *     MODIFICATION HISTORY     ***********************  *  * ENGINEER NAME      DATE     DESCRIPTION  * -------------    --------   -----------  */
end_comment

begin_define
define|#
directive|define
name|IF_DO_TRACE
define|\
value|if ( (saRoot != NULL)&&                              \        (saRoot->TraceDestination& siTraceDestMask)&&  \        (mask& saRoot->TraceMask) )
end_define

begin_comment
unit|\
comment|/* #define TRACE_ENTER_LOCK  ossaSingleThreadedEnter(agRoot, LL_TRACE_LOCK); */
end_comment

begin_comment
comment|/* #define TRACE_LEAVE_LOCK  ossaSingleThreadedLeave(agRoot, LL_TRACE_LOCK); */
end_comment

begin_define
define|#
directive|define
name|TRACE_ENTER_LOCK
end_define

begin_define
define|#
directive|define
name|TRACE_LEAVE_LOCK
end_define

begin_comment
comment|/**  * BUFFER_WRAP_CHECK  *  * PURPOSE: Checks if the tracing buffer tracing index is too high.  If it is,  *          the buffer index gets reset to 0 or tracing stops..  */
end_comment

begin_define
define|#
directive|define
name|BUFFER_WRAP_CHECK
define|\
value|if( (saRoot->CurrentTraceIndex + TMP_TRACE_BUFF_SIZE)               \>= saRoot->TraceBufferLength )               \     {                                                                   \
comment|/* Trace wrap-Around is enabled.  */
value|\         if( saRoot->TraceMask& hpDBG_TraceBufferWrapAround )           \         {                                                               \
comment|/* Fill the end of the buffer with spaces */
value|\             for( i = saRoot->CurrentTraceIndex;                         \                      i< saRoot->TraceBufferLength; i++ )               \             {                                                           \                 saRoot->TraceBuffer[i] = (bit8)' ';                     \             }                                                           \
comment|/* Wrap the current trace index back to 0.. */
value|\             saRoot->CurrentTraceIndex = 0;                              \             saRoot->CurrentTraceIndexWrapCount++;                       \         }                                                               \         else                                                            \         {                                                               \
comment|/* Don't do anything -- trace buffer is filled up */
value|\             return;                                                     \         }                                                               \     }
end_define

begin_comment
comment|/**  * LOCAL_OS_LOG_DEBUG_STRING  *  * PURPOSE:     protects against a change in the api for this function  *  * PARAMETERS:  *  * CALLS:  *  * SIDE EFFECTS& CAVEATS:  *  * ALGORITHM:  *  *  *  *     MODIFICATION HISTORY     ***********************  *  * ENGINEER NAME      DATE     DESCRIPTION  * -------------    --------   -----------  * Laurent Chavey   03/09/00   - changed cast of 3rd parameter to (char *)  */
end_comment

begin_define
define|#
directive|define
name|LOCAL_OS_LOG_DEBUG_STRING
parameter_list|(
name|H
parameter_list|,
name|S
parameter_list|)
define|\
value|osLogDebugString(H,hpDBG_ALWAYS,(char *)(S))
end_define

begin_comment
comment|/****************************************************************************** ******************************************************************************* ** ** copyHex ** ** PURPOSE:  Copies a hex version of a bit32 into a bit8 buffer ** ******************************************************************************* ******************************************************************************/
end_comment

begin_define
define|#
directive|define
name|copyHex
parameter_list|(
name|bit32Val
parameter_list|,
name|bitSize
parameter_list|)
define|\
value|{                                                                      \   bit32 nibbleLen = bitSize / 4;                                       \   bit32 scratch = 0;                                                   \   for( i = 0; i< nibbleLen; i++ )                                     \   {                                                                    \     bPtr[pos++] =                                                      \         saRoot->traceBuffLookup[0xf& (bit32Val>> ((bitSize - 4) - (i<< 2)))];  \     i++;                                                               \     bPtr[pos++] =                                                      \     saRoot->traceBuffLookup[0xf& (bit32Val>> ((bitSize - 4) - (i<< 2)))]; \
comment|/* Skip leading 0-s to save memory buffer space */
value|\     if( !scratch                                                       \&& (bPtr[pos-2] == '0')                                      \&& (bPtr[pos-1] == '0') )                                    \     {                                                                  \       pos -= 2;                                                        \       continue;                                                        \     }                                                                  \     else                                                               \     {                                                                  \       scratch = 1;                                                     \     }                                                                  \   }                                                                    \   if( scratch == 0 )                                                   \   {                                                                    \
comment|/* The value is 0 and nothing got put in the buffer.  Do       */
value|\
comment|/* print at least two zeros.                                   */
value|\     bPtr[pos++] = '0';                                                 \     bPtr[pos++] = '0';                                                 \   }                                                                    \ }
end_define

begin_comment
comment|/**  * TRACE_OTHER_DEST  *  * PURPOSE:  Check if any other destinations are enabled.  If yes, use them  *           for debug log.  */
end_comment

begin_define
define|#
directive|define
name|TRACE_OTHER_DEST
define|\
value|{                                                                   \     bit32 bitptrscratch;                                                \     if( saRoot->TraceDestination& smTraceDestDebugger )                \     {                                                                   \         bPtr[pos++] = (bit8)'\n';                                       \         bPtr[pos++] = (bit8)0;                                          \         LOCAL_OS_LOG_DEBUG_STRING(hpRoot, (char *)bPtr);                \     }                                                                   \     if( saRoot->TraceDestination& smTraceDestRegister )                \     {                                                                   \         while( (pos& 0x3) != 0x3 )                                     \         {                                                               \             bPtr[pos++] = (bit8)' ';                                    \         }                                                               \         bPtr[pos] = ' ';                                                \         for( i = 0; i< pos; i = i + 4 )                                \         {                                                               \             bitptrscratch =  bPtr[i+0];                                 \             bitptrscratch<<= 8;                                        \             bitptrscratch |= bPtr[i+1];                                 \             bitptrscratch<<= 8;                                        \             bitptrscratch |= bPtr[i+2];                                 \             bitptrscratch<<= 8;                                        \             bitptrscratch |= bPtr[i+3];                                 \             osChipRegWrite(hpRoot,                                      \                  FC_rFMReceivedALPA, (bit32)bitptrscratch );            \         }                                                               \     }                                                                   \     }
end_define

begin_comment
comment|/**  * siGetCurrentTraceIndex()  *  * PURPOSE:     Returns the current tracing index ( if tracing buffer is  *              used ).  *  * PARAMETERS:  *  * CALLS:  *  * SIDE EFFECTS& CAVEATS:  *  * ALGORITHM:  *  *  *     MODIFICATION HISTORY     ***********************  *  * ENGINEER NAME      DATE     DESCRIPTION  * -------------    --------   -----------  * Tom Nalepa       02/27/03  *  * @param hpRoot  *  * @return  */
end_comment

begin_function
name|GLOBAL
name|bit32
name|siGetCurrentTraceIndex
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|)
block|{
name|agsaLLRoot_t
modifier|*
name|saRoot
init|=
operator|(
name|agsaLLRoot_t
operator|*
operator|)
operator|(
name|agRoot
operator|->
name|sdkData
operator|)
decl_stmt|;
return|return
operator|(
name|saRoot
operator|->
name|CurrentTraceIndex
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * siResetTraceBuffer  *  * PURPOSE:     Sets saRoot->CurrentTraceIndex to 0.  *  * @param hpRoot  *  * @return  */
end_comment

begin_function
name|GLOBAL
name|void
name|siResetTraceBuffer
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|)
block|{
name|bit32
name|count
decl_stmt|;
name|agsaLLRoot_t
modifier|*
name|saRoot
init|=
operator|(
name|agsaLLRoot_t
operator|*
operator|)
operator|(
name|agRoot
operator|->
name|sdkData
operator|)
decl_stmt|;
name|saRoot
operator|->
name|CurrentTraceIndex
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|saRoot
operator|->
name|TraceBufferLength
condition|;
name|count
operator|++
control|)
block|{
name|saRoot
operator|->
name|TraceBuffer
index|[
name|count
index|]
operator|=
operator|(
name|bit8
operator|)
literal|' '
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * siTraceFuncEnter  *  * PURPOSE:     Format a function entry trace and post it to the appropriate  *              destination.  *  * PARAMETERS:  *  * CALLS:  *  * SIDE EFFECTS& CAVEATS:  *  * ALGORITHM:  *  * siTraceFuncEnter  :    _[Xxxxx_  *                 fileid---^  ^------funcid  *  *  *     MODIFICATION HISTORY     ***********************  *  * ENGINEER NAME      DATE     DESCRIPTION  * -------------    --------   -----------  *  * @param hpRoot  * @param mask  * @param fileid  * @param funcid  *  * @return  */
end_comment

begin_define
define|#
directive|define
name|TMP_TRACE_BUFF_SIZE
value|32
end_define

begin_function
name|GLOBAL
name|void
name|siTraceFuncEnter
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|bit32
name|mask
parameter_list|,
name|bit32
name|fileid
parameter_list|,
name|char
modifier|*
name|funcid
parameter_list|)
block|{
name|agsaLLRoot_t
modifier|*
name|saRoot
init|=
operator|(
name|agsaLLRoot_t
operator|*
operator|)
operator|(
name|agRoot
operator|->
name|sdkData
operator|)
decl_stmt|;
name|bitptr
name|i
decl_stmt|;
name|bit8
name|tmpB
index|[
name|TMP_TRACE_BUFF_SIZE
index|]
decl_stmt|;
name|bit8
modifier|*
name|bPtr
decl_stmt|;
name|bit8
name|pos
init|=
literal|0
decl_stmt|;
name|IF_DO_TRACE
block|{
name|TRACE_ENTER_LOCK
if|if
condition|(
name|saRoot
operator|->
name|TraceDestination
operator|&
name|smTraceDestBuffer
condition|)
block|{
name|BUFFER_WRAP_CHECK
name|bPtr
init|=
operator|&
name|saRoot
operator|->
name|TraceBuffer
index|[
name|saRoot
operator|->
name|CurrentTraceIndex
index|]
decl_stmt|;
block|}
else|else
block|{
name|bPtr
operator|=
name|tmpB
expr_stmt|;
block|}
name|bPtr
index|[
name|pos
operator|++
index|]
operator|=
operator|(
name|bit8
operator|)
literal|'['
expr_stmt|;
ifndef|#
directive|ifndef
name|FC_DO_NOT_INCLUDE_FILE_NAME_TAGS_IN_ENTER_EXIT_TRACE
name|bPtr
index|[
name|pos
operator|++
index|]
operator|=
operator|(
name|bit8
operator|)
name|fileid
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|funcid
index|[
name|i
index|]
operator|==
literal|0
condition|)
block|{
break|break;
block|}
name|bPtr
index|[
name|pos
operator|++
index|]
operator|=
operator|(
name|bit8
operator|)
name|funcid
index|[
name|i
index|]
expr_stmt|;
block|}
name|bPtr
index|[
name|pos
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
name|saRoot
operator|->
name|traceLineFeedCnt
operator|>
name|FC_TRACE_LINE_SIZE
condition|)
block|{
name|bPtr
index|[
name|pos
operator|++
index|]
operator|=
literal|'\r'
expr_stmt|;
name|bPtr
index|[
name|pos
operator|++
index|]
operator|=
literal|'\n'
expr_stmt|;
name|saRoot
operator|->
name|traceLineFeedCnt
operator|=
literal|0
expr_stmt|;
block|}
name|saRoot
operator|->
name|CurrentTraceIndex
operator|+=
name|pos
expr_stmt|;
comment|//        TRACE_OTHER_DEST
name|TRACE_LEAVE_LOCK
block|}
return|return;
block|}
end_function

begin_comment
comment|/**  * siTraceFuncExit  *  * PURPOSE:     Format a function exit trace and post it to the appropriate  *              destination.  *  * PARAMETERS:  *  * CALLS:  *  * SIDE EFFECTS& CAVEATS:  *  * ALGORITHM:  *  * siTraceFuncExit         _Xxxxx]_  *                 fileid---^  ^------funcid  *  *  *     MODIFICATION HISTORY     ***********************  *  * ENGINEER NAME      DATE     DESCRIPTION  * -------------    --------   -----------  *  * @param hpRoot  * @param mask  * @param fileid  * @param funcid  * @param exitId  *  * @return  */
end_comment

begin_function
name|GLOBAL
name|void
name|siTraceFuncExit
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|bit32
name|mask
parameter_list|,
name|char
name|fileid
parameter_list|,
name|char
modifier|*
name|funcid
parameter_list|,
name|char
name|exitId
parameter_list|)
block|{
name|bitptr
name|i
decl_stmt|;
name|bit8
name|tmpB
index|[
name|TMP_TRACE_BUFF_SIZE
index|]
decl_stmt|;
name|bit8
modifier|*
name|bPtr
decl_stmt|;
name|bit8
name|pos
init|=
literal|0
decl_stmt|;
name|agsaLLRoot_t
modifier|*
name|saRoot
init|=
operator|(
name|agsaLLRoot_t
operator|*
operator|)
operator|(
name|agRoot
operator|->
name|sdkData
operator|)
decl_stmt|;
name|IF_DO_TRACE
block|{
name|TRACE_ENTER_LOCK
if|if
condition|(
name|saRoot
operator|->
name|TraceDestination
operator|&
name|smTraceDestBuffer
condition|)
block|{
name|BUFFER_WRAP_CHECK
name|bPtr
init|=
operator|&
name|saRoot
operator|->
name|TraceBuffer
index|[
name|saRoot
operator|->
name|CurrentTraceIndex
index|]
decl_stmt|;
block|}
else|else
block|{
name|bPtr
operator|=
name|tmpB
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|FC_DO_NOT_INCLUDE_FILE_NAME_TAGS_IN_ENTER_EXIT_TRACE
name|bPtr
index|[
name|pos
operator|++
index|]
operator|=
operator|(
name|bit8
operator|)
name|fileid
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|funcid
index|[
name|i
index|]
operator|==
literal|0
condition|)
block|{
break|break;
block|}
name|bPtr
index|[
name|pos
operator|++
index|]
operator|=
operator|(
name|bit8
operator|)
name|funcid
index|[
name|i
index|]
expr_stmt|;
block|}
name|bPtr
index|[
name|pos
operator|++
index|]
operator|=
operator|(
name|bit8
operator|)
name|exitId
expr_stmt|;
name|bPtr
index|[
name|pos
operator|++
index|]
operator|=
operator|(
name|bit8
operator|)
literal|']'
expr_stmt|;
name|bPtr
index|[
name|pos
operator|++
index|]
operator|=
operator|(
name|bit8
operator|)
literal|' '
expr_stmt|;
if|if
condition|(
name|saRoot
operator|->
name|traceLineFeedCnt
operator|>
name|FC_TRACE_LINE_SIZE
condition|)
block|{
name|bPtr
index|[
name|pos
operator|++
index|]
operator|=
literal|'\r'
expr_stmt|;
name|bPtr
index|[
name|pos
operator|++
index|]
operator|=
literal|'\n'
expr_stmt|;
name|saRoot
operator|->
name|traceLineFeedCnt
operator|=
literal|0
expr_stmt|;
block|}
name|saRoot
operator|->
name|CurrentTraceIndex
operator|+=
name|pos
expr_stmt|;
comment|//        TRACE_OTHER_DEST
name|TRACE_LEAVE_LOCK
block|}
return|return;
block|}
end_function

begin_comment
comment|/**  * siTraceListRemove  *  * PURPOSE:     Adds a trace tag for an exchange that is removed from a list  *  * PARAMETERS:  *  * CALLS:  *  * SIDE EFFECTS& CAVEATS:  *  * ALGORITHM:  *  *  *     MODIFICATION HISTORY     ***********************  *  * ENGINEER NAME      DATE     DESCRIPTION  * -------------    --------   -----------  * Tom Nalepa       12/16/02   Initial Developmet  *  * @param hpRoot  * @param mask  * @param listId  * @param exchangeId  *  * @return  */
end_comment

begin_function
name|GLOBAL
name|void
name|siTraceListRemove
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|bit32
name|mask
parameter_list|,
name|char
name|listId
parameter_list|,
name|bitptr
name|exchangeId
parameter_list|)
block|{
name|agsaLLRoot_t
modifier|*
name|saRoot
init|=
operator|(
name|agsaLLRoot_t
operator|*
operator|)
operator|(
name|agRoot
operator|->
name|sdkData
operator|)
decl_stmt|;
name|bitptr
name|i
decl_stmt|;
name|bit8
name|tmpB
index|[
name|TMP_TRACE_BUFF_SIZE
index|]
decl_stmt|;
name|bit8
modifier|*
name|bPtr
decl_stmt|;
name|bit8
name|pos
init|=
literal|0
decl_stmt|;
name|IF_DO_TRACE
block|{
name|TRACE_ENTER_LOCK
if|if
condition|(
name|saRoot
operator|->
name|TraceDestination
operator|&
name|smTraceDestBuffer
condition|)
block|{
name|BUFFER_WRAP_CHECK
name|bPtr
init|=
operator|&
name|saRoot
operator|->
name|TraceBuffer
index|[
name|saRoot
operator|->
name|CurrentTraceIndex
index|]
decl_stmt|;
block|}
else|else
block|{
name|bPtr
operator|=
name|tmpB
expr_stmt|;
block|}
name|bPtr
index|[
name|pos
operator|++
index|]
operator|=
operator|(
name|bit8
operator|)
literal|'<'
expr_stmt|;
name|bPtr
index|[
name|pos
operator|++
index|]
operator|=
operator|(
name|bit8
operator|)
name|listId
expr_stmt|;
name|copyHex
argument_list|(
name|exchangeId
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|bPtr
index|[
name|pos
operator|++
index|]
operator|=
operator|(
name|bit8
operator|)
literal|' '
expr_stmt|;
if|if
condition|(
name|saRoot
operator|->
name|traceLineFeedCnt
operator|>
name|FC_TRACE_LINE_SIZE
condition|)
block|{
name|bPtr
index|[
name|pos
operator|++
index|]
operator|=
literal|'\r'
expr_stmt|;
name|bPtr
index|[
name|pos
operator|++
index|]
operator|=
literal|'\n'
expr_stmt|;
name|saRoot
operator|->
name|traceLineFeedCnt
operator|=
literal|0
expr_stmt|;
block|}
name|saRoot
operator|->
name|CurrentTraceIndex
operator|+=
name|pos
expr_stmt|;
comment|//        TRACE_OTHER_DEST
name|TRACE_LEAVE_LOCK
block|}
return|return;
block|}
end_function

begin_comment
comment|/**  * siTraceListAdd  *  * PURPOSE:     Adds a trace tag for an exchange that is added to a list  *  * PARAMETERS:  *  * CALLS:  *  * SIDE EFFECTS& CAVEATS:  *  * ALGORITHM:  *  *  *     MODIFICATION HISTORY     ***********************  *  * ENGINEER NAME      DATE     DESCRIPTION  * -------------    --------   -----------  * Tom Nalepa       12/16/02   Initial Developmet  *  * @param hpRoot  * @param mask  * @param listId  * @param exchangeId  *  * @return  */
end_comment

begin_function
name|GLOBAL
name|void
name|siTraceListAdd
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|bit32
name|mask
parameter_list|,
name|char
name|listId
parameter_list|,
name|bitptr
name|exchangeId
parameter_list|)
block|{
name|agsaLLRoot_t
modifier|*
name|saRoot
init|=
operator|(
name|agsaLLRoot_t
operator|*
operator|)
operator|(
name|agRoot
operator|->
name|sdkData
operator|)
decl_stmt|;
name|bitptr
name|i
decl_stmt|;
name|bit8
name|tmpB
index|[
name|TMP_TRACE_BUFF_SIZE
index|]
decl_stmt|;
name|bit8
modifier|*
name|bPtr
decl_stmt|;
name|bit8
name|pos
init|=
literal|0
decl_stmt|;
name|IF_DO_TRACE
block|{
if|if
condition|(
name|saRoot
operator|->
name|TraceDestination
operator|&
name|smTraceDestBuffer
condition|)
block|{
name|BUFFER_WRAP_CHECK
name|bPtr
init|=
operator|&
name|saRoot
operator|->
name|TraceBuffer
index|[
name|saRoot
operator|->
name|CurrentTraceIndex
index|]
decl_stmt|;
block|}
else|else
block|{
name|bPtr
operator|=
name|tmpB
expr_stmt|;
block|}
name|bPtr
index|[
name|pos
operator|++
index|]
operator|=
operator|(
name|bit8
operator|)
literal|'>'
expr_stmt|;
name|bPtr
index|[
name|pos
operator|++
index|]
operator|=
operator|(
name|bit8
operator|)
name|listId
expr_stmt|;
name|copyHex
argument_list|(
name|exchangeId
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|bPtr
index|[
name|pos
operator|++
index|]
operator|=
operator|(
name|bit8
operator|)
literal|' '
expr_stmt|;
if|if
condition|(
name|saRoot
operator|->
name|traceLineFeedCnt
operator|>
name|FC_TRACE_LINE_SIZE
condition|)
block|{
name|bPtr
index|[
name|pos
operator|++
index|]
operator|=
literal|'\r'
expr_stmt|;
name|bPtr
index|[
name|pos
operator|++
index|]
operator|=
literal|'\n'
expr_stmt|;
name|saRoot
operator|->
name|traceLineFeedCnt
operator|=
literal|0
expr_stmt|;
block|}
name|saRoot
operator|->
name|CurrentTraceIndex
operator|+=
name|pos
expr_stmt|;
comment|//        TRACE_OTHER_DEST
block|}
return|return;
block|}
end_function

begin_comment
comment|/**  * siTrace64  *  * PURPOSE:     Format a function parameter trace and post it to the appropriate  *              destination.  *  * PARAMETERS:  *  * CALLS:  *  * SIDE EFFECTS& CAVEATS:  *  * ALGORITHM:  *  * siTrace : index is 0 for return value, 1 for first parm after "("  *           produces:   _nn" XXXXXXXXXX  *           index-----^    value--^  *  *  *     MODIFICATION HISTORY     ***********************  *  * ENGINEER NAME      DATE     DESCRIPTION  * -------------    --------   -----------  *  * @param hpRoot  * @param mask  * @param uId  * @param value  *  * @return  */
end_comment

begin_function
name|GLOBAL
name|void
name|siTrace64
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|bit32
name|mask
parameter_list|,
name|char
modifier|*
name|uId
parameter_list|,
name|bit64
name|value
parameter_list|,
name|bit32
name|dataSizeInBits
parameter_list|)
block|{
name|agsaLLRoot_t
modifier|*
name|saRoot
init|=
operator|(
name|agsaLLRoot_t
operator|*
operator|)
operator|(
name|agRoot
operator|->
name|sdkData
operator|)
decl_stmt|;
name|bitptr
name|i
decl_stmt|;
name|bit8
name|tmpB
index|[
name|TMP_TRACE_BUFF_SIZE
index|]
decl_stmt|;
name|bit8
modifier|*
name|bPtr
decl_stmt|;
name|bit8
name|pos
init|=
literal|0
decl_stmt|;
name|IF_DO_TRACE
block|{
if|if
condition|(
name|saRoot
operator|->
name|TraceDestination
operator|&
name|smTraceDestBuffer
condition|)
block|{
name|BUFFER_WRAP_CHECK
name|bPtr
init|=
operator|&
name|saRoot
operator|->
name|TraceBuffer
index|[
name|saRoot
operator|->
name|CurrentTraceIndex
index|]
decl_stmt|;
block|}
else|else
block|{
name|bPtr
operator|=
name|tmpB
expr_stmt|;
block|}
name|bPtr
index|[
name|pos
operator|++
index|]
operator|=
operator|(
name|bit8
operator|)
literal|'"'
expr_stmt|;
name|bPtr
index|[
name|pos
operator|++
index|]
operator|=
operator|(
name|bit8
operator|)
name|uId
index|[
literal|0
index|]
expr_stmt|;
name|bPtr
index|[
name|pos
operator|++
index|]
operator|=
operator|(
name|bit8
operator|)
name|uId
index|[
literal|1
index|]
expr_stmt|;
name|bPtr
index|[
name|pos
operator|++
index|]
operator|=
operator|(
name|bit8
operator|)
literal|':'
expr_stmt|;
name|copyHex
argument_list|(
name|value
argument_list|,
name|dataSizeInBits
argument_list|)
expr_stmt|;
name|bPtr
index|[
name|pos
operator|++
index|]
operator|=
operator|(
name|bit8
operator|)
literal|' '
expr_stmt|;
if|if
condition|(
name|saRoot
operator|->
name|traceLineFeedCnt
operator|>
name|FC_TRACE_LINE_SIZE
condition|)
block|{
name|bPtr
index|[
name|pos
operator|++
index|]
operator|=
literal|'\r'
expr_stmt|;
name|bPtr
index|[
name|pos
operator|++
index|]
operator|=
literal|'\n'
expr_stmt|;
name|saRoot
operator|->
name|traceLineFeedCnt
operator|=
literal|0
expr_stmt|;
block|}
name|saRoot
operator|->
name|CurrentTraceIndex
operator|+=
name|pos
expr_stmt|;
comment|//        TRACE_OTHER_DEST
block|}
return|return;
block|}
end_function

begin_comment
comment|/**  * siTrace  *  * PURPOSE:     Format a function parameter trace and post it to the appropriate  *              destination.  *  * PARAMETERS:  *  * CALLS:  *  * SIDE EFFECTS& CAVEATS:  *  * ALGORITHM:  *  * fiTrace : index is 0 for return value, 1 for first parm after "("  *           produces:   _nn" XXXXXXXXXX  *           index-----^    value--^  *  *  *     MODIFICATION HISTORY     ***********************  *  * ENGINEER NAME      DATE     DESCRIPTION  * -------------    --------   -----------  *  * @param hpRoot  * @param mask  * @param uId  * @param value  *  * @return  */
end_comment

begin_function
name|GLOBAL
name|void
name|siTrace
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|bit32
name|mask
parameter_list|,
name|char
modifier|*
name|uId
parameter_list|,
name|bit32
name|value
parameter_list|,
name|bit32
name|dataSizeInBits
parameter_list|)
block|{
name|agsaLLRoot_t
modifier|*
name|saRoot
init|=
operator|(
name|agsaLLRoot_t
operator|*
operator|)
operator|(
name|agRoot
operator|->
name|sdkData
operator|)
decl_stmt|;
name|bitptr
name|i
decl_stmt|;
name|bit8
name|tmpB
index|[
name|TMP_TRACE_BUFF_SIZE
index|]
decl_stmt|;
name|bit8
modifier|*
name|bPtr
decl_stmt|;
name|bit8
name|pos
init|=
literal|0
decl_stmt|;
name|IF_DO_TRACE
block|{
if|if
condition|(
name|saRoot
operator|->
name|TraceDestination
operator|&
name|smTraceDestBuffer
condition|)
block|{
name|BUFFER_WRAP_CHECK
name|bPtr
init|=
operator|&
name|saRoot
operator|->
name|TraceBuffer
index|[
name|saRoot
operator|->
name|CurrentTraceIndex
index|]
decl_stmt|;
block|}
else|else
block|{
name|bPtr
operator|=
name|tmpB
expr_stmt|;
block|}
name|bPtr
index|[
name|pos
operator|++
index|]
operator|=
operator|(
name|bit8
operator|)
literal|'"'
expr_stmt|;
name|bPtr
index|[
name|pos
operator|++
index|]
operator|=
operator|(
name|bit8
operator|)
name|uId
index|[
literal|0
index|]
expr_stmt|;
name|bPtr
index|[
name|pos
operator|++
index|]
operator|=
operator|(
name|bit8
operator|)
name|uId
index|[
literal|1
index|]
expr_stmt|;
name|bPtr
index|[
name|pos
operator|++
index|]
operator|=
operator|(
name|bit8
operator|)
literal|':'
expr_stmt|;
name|copyHex
argument_list|(
name|value
argument_list|,
name|dataSizeInBits
argument_list|)
expr_stmt|;
name|bPtr
index|[
name|pos
operator|++
index|]
operator|=
operator|(
name|bit8
operator|)
literal|' '
expr_stmt|;
if|if
condition|(
name|saRoot
operator|->
name|traceLineFeedCnt
operator|>
name|FC_TRACE_LINE_SIZE
condition|)
block|{
name|bPtr
index|[
name|pos
operator|++
index|]
operator|=
literal|'\r'
expr_stmt|;
name|bPtr
index|[
name|pos
operator|++
index|]
operator|=
literal|'\n'
expr_stmt|;
name|saRoot
operator|->
name|traceLineFeedCnt
operator|=
literal|0
expr_stmt|;
block|}
name|saRoot
operator|->
name|CurrentTraceIndex
operator|+=
name|pos
expr_stmt|;
comment|//        TRACE_OTHER_DEST
block|}
return|return;
block|}
end_function

begin_comment
comment|/*Set Wrap 0 for Wrapping non zero stops when full  */
end_comment

begin_function
name|GLOBAL
name|void
name|siTraceGetInfo
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|hpTraceBufferParms_t
modifier|*
name|pBParms
parameter_list|)
block|{
name|agsaLLRoot_t
modifier|*
name|saRoot
init|=
operator|(
name|agsaLLRoot_t
operator|*
operator|)
name|agRoot
operator|->
name|sdkData
decl_stmt|;
name|pBParms
operator|->
name|TraceCompiled
operator|=
name|TRUE
expr_stmt|;
name|pBParms
operator|->
name|TraceWrap
operator|=
name|saRoot
operator|->
name|TraceMask
operator|&
literal|0x80000000
expr_stmt|;
name|pBParms
operator|->
name|CurrentTraceIndexWrapCount
operator|=
name|saRoot
operator|->
name|CurrentTraceIndexWrapCount
expr_stmt|;
name|pBParms
operator|->
name|BufferSize
operator|=
name|saRoot
operator|->
name|TraceBufferLength
expr_stmt|;
name|pBParms
operator|->
name|CurrentIndex
operator|=
name|saRoot
operator|->
name|CurrentTraceIndex
expr_stmt|;
name|pBParms
operator|->
name|pTrace
operator|=
name|saRoot
operator|->
name|TraceBuffer
expr_stmt|;
name|pBParms
operator|->
name|pTraceIndexWrapCount
operator|=
operator|&
name|saRoot
operator|->
name|CurrentTraceIndexWrapCount
expr_stmt|;
name|pBParms
operator|->
name|pTraceMask
operator|=
operator|&
name|saRoot
operator|->
name|TraceMask
expr_stmt|;
name|pBParms
operator|->
name|pCurrentTraceIndex
operator|=
operator|&
name|saRoot
operator|->
name|CurrentTraceIndex
expr_stmt|;
block|}
end_function

begin_comment
comment|/**/
end_comment

begin_function
name|GLOBAL
name|void
name|siTraceSetMask
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|bit32
name|TraceMask
parameter_list|)
block|{
name|agsaLLRoot_t
modifier|*
name|saRoot
init|=
operator|(
name|agsaLLRoot_t
operator|*
operator|)
name|agRoot
operator|->
name|sdkData
decl_stmt|;
name|saRoot
operator|->
name|TraceMask
operator|=
name|TraceMask
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

