begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************************* *Copyright (c) 2014 PMC-Sierra, Inc.  All rights reserved.  * *Redistribution and use in source and binary forms, with or without modification, are permitted provided  *that the following conditions are met:  *1. Redistributions of source code must retain the above copyright notice, this list of conditions and the *following disclaimer.  *2. Redistributions in binary form must reproduce the above copyright notice,  *this list of conditions and the following disclaimer in the documentation and/or other materials provided *with the distribution.  * *THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR IMPLIED  *WARRANTIES,INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS *FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE *FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  *NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR  *BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  *LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  *SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE  ********************************************************************************/
end_comment

begin_comment
comment|/*******************************************************************************/
end_comment

begin_comment
comment|/*! \file sasmp.c  *  \brief The file implements the functions for SMP request/response  *  */
end_comment

begin_comment
comment|/*******************************************************************************/
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<dev/pms/config.h>
end_include

begin_include
include|#
directive|include
file|<dev/pms/RefTisa/sallsdk/spc/saglobal.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SA_ENABLE_TRACE_FUNCTIONS
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|siTraceFileID
end_ifdef

begin_undef
undef|#
directive|undef
name|siTraceFileID
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|siTraceFileID
value|'N'
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*! \brief Start SMP request  *  *  Start SMP request  *  *  \param agRoot handles for this instance of SAS/SATA hardware  *  \param queueNum  *  \param agIORequest  *  \param agDevHandle  *  \param agRequestType  *  \param agRequestBody  *  \param agCB  * Spc - support    direct mode direct response  * SpcV - support   direct mode direct response  * SpcV - support indirect mode  direct response  * SpcV - support indirect mode indirect response  *  *  \return If request is started successfully  *          - \e AGSA_RC_SUCCESS request is started successfully  *          - \e AGSA_RC_BUSY No resource available, try again later  */
end_comment

begin_comment
comment|/*******************************************************************************/
end_comment

begin_function
name|GLOBAL
name|bit32
name|saSMPStart
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|agsaIORequest_t
modifier|*
name|agIORequest
parameter_list|,
name|bit32
name|queueNum
parameter_list|,
name|agsaDevHandle_t
modifier|*
name|agDevHandle
parameter_list|,
name|bit32
name|agRequestType
parameter_list|,
name|agsaSASRequestBody_t
modifier|*
name|agRequestBody
parameter_list|,
name|ossaSMPCompletedCB_t
name|agCB
parameter_list|)
block|{
name|bit32
name|ret
init|=
name|AGSA_RC_SUCCESS
decl_stmt|,
name|retVal
decl_stmt|;
name|agsaLLRoot_t
modifier|*
name|saRoot
init|=
name|agNULL
decl_stmt|;
name|mpiICQueue_t
modifier|*
name|circularQ
decl_stmt|;
name|agsaDeviceDesc_t
modifier|*
name|pDevice
decl_stmt|;
name|agsaPort_t
modifier|*
name|pPort
decl_stmt|;
name|agsaIORequestDesc_t
modifier|*
name|pRequest
decl_stmt|;
name|void
modifier|*
name|pMessage
decl_stmt|;
name|bit8
name|i
decl_stmt|,
name|inq
decl_stmt|,
name|outq
decl_stmt|;
name|bit8
name|using_reserved
init|=
name|agFALSE
decl_stmt|;
name|bit8
modifier|*
name|payload_ptr
decl_stmt|;
name|agsaSMPFrame_t
modifier|*
name|pSMPFrame
decl_stmt|;
name|SA_DBG4
argument_list|(
operator|(
literal|"saSMPStart: start\n"
operator|)
argument_list|)
expr_stmt|;
name|smTraceFuncEnter
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|"9a"
argument_list|)
expr_stmt|;
comment|/* sanity check */
name|SA_ASSERT
argument_list|(
operator|(
name|agNULL
operator|!=
name|agRoot
operator|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|SA_ASSERT
argument_list|(
operator|(
name|agNULL
operator|!=
name|agIORequest
operator|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|SA_ASSERT
argument_list|(
operator|(
name|agNULL
operator|!=
name|agDevHandle
operator|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|SA_ASSERT
argument_list|(
operator|(
name|agNULL
operator|!=
name|agRequestBody
operator|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* sanity check */
name|saRoot
operator|=
operator|(
name|agsaLLRoot_t
operator|*
operator|)
operator|(
name|agRoot
operator|->
name|sdkData
operator|)
expr_stmt|;
name|SA_ASSERT
argument_list|(
operator|(
name|agNULL
operator|!=
name|saRoot
operator|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|saRoot
operator|==
name|agNULL
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"saSMPStart : saRoot is NULL!!\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_FAILURE
return|;
block|}
comment|/* Assign inbound and outbound queue number */
name|inq
operator|=
call|(
name|bit8
call|)
argument_list|(
name|queueNum
operator|&
name|MPI_IB_NUM_MASK
argument_list|)
expr_stmt|;
name|outq
operator|=
call|(
name|bit8
call|)
argument_list|(
operator|(
name|queueNum
operator|&
name|MPI_OB_NUM_MASK
operator|)
operator|>>
name|MPI_OB_SHIFT
argument_list|)
expr_stmt|;
name|SA_ASSERT
argument_list|(
operator|(
name|AGSA_MAX_INBOUND_Q
operator|>
name|inq
operator|)
argument_list|,
literal|"The IBQ Number is out of range."
argument_list|)
expr_stmt|;
comment|/* Find the outgoing port for the device */
if|if
condition|(
name|agNULL
operator|==
name|agDevHandle
operator|->
name|sdkData
condition|)
block|{
comment|/* Device has been removed */
name|SA_DBG1
argument_list|(
operator|(
literal|"saSMPStart, Device has been removed. agDevHandle=%p\n"
operator|,
name|agDevHandle
operator|)
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'a'
argument_list|,
literal|"9a"
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_FAILURE
return|;
block|}
name|pDevice
operator|=
operator|(
name|agsaDeviceDesc_t
operator|*
operator|)
operator|(
name|agDevHandle
operator|->
name|sdkData
operator|)
expr_stmt|;
name|pPort
operator|=
name|pDevice
operator|->
name|pPort
expr_stmt|;
comment|/* Get request from free IO Requests */
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|pRequest
operator|=
operator|(
name|agsaIORequestDesc_t
operator|*
operator|)
name|saLlistIOGetHead
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|)
expr_stmt|;
comment|/**/
comment|/* If no LL IO request entry available */
if|if
condition|(
name|agNULL
operator|==
name|pRequest
condition|)
block|{
name|pRequest
operator|=
operator|(
name|agsaIORequestDesc_t
operator|*
operator|)
name|saLlistIOGetHead
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeReservedRequests
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|agNULL
operator|!=
name|pRequest
condition|)
block|{
name|using_reserved
operator|=
name|agTRUE
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saSMPStart, using saRoot->freeReservedRequests\n"
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saSMPStart, No request from free list Not using saRoot->freeReservedRequests\n"
operator|)
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'b'
argument_list|,
literal|"9a"
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_BUSY
return|;
block|}
block|}
comment|/* If free IOMB avaliable */
comment|/* Remove the request from free list */
if|if
condition|(
name|using_reserved
condition|)
block|{
name|saLlistIORemove
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeReservedRequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|saLlistIORemove
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* Add the request to the pendingSMPRequests list of the device */
name|saLlistIOAdd
argument_list|(
operator|&
operator|(
name|pDevice
operator|->
name|pendingIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
name|SA_ASSERT
argument_list|(
operator|(
operator|!
name|pRequest
operator|->
name|valid
operator|)
argument_list|,
literal|"The pRequest is in use"
argument_list|)
expr_stmt|;
name|pRequest
operator|->
name|valid
operator|=
name|agTRUE
expr_stmt|;
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
comment|/* set up pRequest */
name|pRequest
operator|->
name|pIORequestContext
operator|=
name|agIORequest
expr_stmt|;
name|pRequest
operator|->
name|pDevice
operator|=
name|pDevice
expr_stmt|;
name|pRequest
operator|->
name|pPort
operator|=
name|pPort
expr_stmt|;
name|pRequest
operator|->
name|requestType
operator|=
name|agRequestType
expr_stmt|;
name|pRequest
operator|->
name|startTick
operator|=
name|saRoot
operator|->
name|timeTick
expr_stmt|;
name|pRequest
operator|->
name|completionCB
operator|=
operator|(
name|ossaSSPCompletedCB_t
operator|)
name|agCB
expr_stmt|;
comment|/* Set request to the sdkData of agIORequest */
name|agIORequest
operator|->
name|sdkData
operator|=
name|pRequest
expr_stmt|;
comment|/* save tag to IOMap */
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|Tag
operator|=
name|pRequest
operator|->
name|HTag
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|IORequest
operator|=
operator|(
name|void
operator|*
operator|)
name|pRequest
expr_stmt|;
ifdef|#
directive|ifdef
name|SA_LL_IBQ_PROTECT
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_IBQ0_LOCK
operator|+
name|inq
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SA_LL_IBQ_PROTECT */
comment|/* If LL IO request entry avaliable */
comment|/* Get a free inbound queue entry */
name|circularQ
operator|=
operator|&
name|saRoot
operator|->
name|inboundQueue
index|[
name|inq
index|]
expr_stmt|;
name|retVal
operator|=
name|mpiMsgFreeGet
argument_list|(
name|circularQ
argument_list|,
name|IOMB_SIZE64
argument_list|,
operator|&
name|pMessage
argument_list|)
expr_stmt|;
if|if
condition|(
name|AGSA_RC_FAILURE
operator|==
name|retVal
condition|)
block|{
ifdef|#
directive|ifdef
name|SA_LL_IBQ_PROTECT
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_IBQ0_LOCK
operator|+
name|inq
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SA_LL_IBQ_PROTECT */
comment|/* if not sending return to free list rare */
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|saLlistIORemove
argument_list|(
operator|&
operator|(
name|pDevice
operator|->
name|pendingIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
name|pRequest
operator|->
name|valid
operator|=
name|agFALSE
expr_stmt|;
name|saLlistIOAdd
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saSMPStart, error when get free IOMB\n"
operator|)
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'c'
argument_list|,
literal|"9a"
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_FAILURE
return|;
block|}
comment|/* return busy if inbound queue is full */
if|if
condition|(
name|AGSA_RC_BUSY
operator|==
name|retVal
condition|)
block|{
ifdef|#
directive|ifdef
name|SA_LL_IBQ_PROTECT
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_IBQ0_LOCK
operator|+
name|inq
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SA_LL_IBQ_PROTECT */
comment|/* if not sending return to free list rare */
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|saLlistIORemove
argument_list|(
operator|&
operator|(
name|pDevice
operator|->
name|pendingIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
name|pRequest
operator|->
name|valid
operator|=
name|agFALSE
expr_stmt|;
name|saLlistIOAdd
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saSMPStart, no more IOMB\n"
operator|)
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'d'
argument_list|,
literal|"9a"
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_BUSY
return|;
block|}
comment|/* Setup SMP Frame */
name|pSMPFrame
operator|=
operator|(
name|agsaSMPFrame_t
operator|*
operator|)
operator|&
operator|(
name|agRequestBody
operator|->
name|smpFrame
operator|)
expr_stmt|;
name|SA_DBG2
argument_list|(
operator|(
literal|"saSMPStart:DeviceMapIndex 0x%x portId 0x%x portId 0x%x\n"
operator|,
name|pDevice
operator|->
name|DeviceMapIndex
operator|,
name|pPort
operator|->
name|portId
operator|,
name|pPort
operator|->
name|portId
operator|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SALLSDK_DEBUG
argument_list|)
name|SA_DBG2
argument_list|(
operator|(
literal|"saSMPStart: outFrameBuf  %p\n"
operator|,
name|pSMPFrame
operator|->
name|outFrameBuf
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pSMPFrame
operator|->
name|outFrameBuf
condition|)
block|{
name|SA_DBG2
argument_list|(
operator|(
literal|"saSMPStart: outFrameBuf 0  0x%08X\n"
operator|,
operator|*
operator|(
operator|(
name|bit32
operator|*
operator|)
name|pSMPFrame
operator|->
name|outFrameBuf
operator|+
literal|0
operator|)
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG2
argument_list|(
operator|(
literal|"saSMPStart: outFrameBuf 1  0x%08X\n"
operator|,
operator|*
operator|(
operator|(
name|bit32
operator|*
operator|)
name|pSMPFrame
operator|->
name|outFrameBuf
operator|+
literal|1
operator|)
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG2
argument_list|(
operator|(
literal|"saSMPStart: outFrameBuf 2  0x%08X\n"
operator|,
operator|*
operator|(
operator|(
name|bit32
operator|*
operator|)
name|pSMPFrame
operator|->
name|outFrameBuf
operator|+
literal|2
operator|)
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG2
argument_list|(
operator|(
literal|"saSMPStart: outFrameBuf 3  0x%08X\n"
operator|,
operator|*
operator|(
operator|(
name|bit32
operator|*
operator|)
name|pSMPFrame
operator|->
name|outFrameBuf
operator|+
literal|3
operator|)
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG2
argument_list|(
operator|(
literal|"saSMPStart: outFrameBuf 4  0x%08X\n"
operator|,
operator|*
operator|(
operator|(
name|bit32
operator|*
operator|)
name|pSMPFrame
operator|->
name|outFrameBuf
operator|+
literal|4
operator|)
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG2
argument_list|(
operator|(
literal|"saSMPStart: outFrameBuf 5  0x%08X\n"
operator|,
operator|*
operator|(
operator|(
name|bit32
operator|*
operator|)
name|pSMPFrame
operator|->
name|outFrameBuf
operator|+
literal|5
operator|)
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG2
argument_list|(
operator|(
literal|"saSMPStart: outFrameBuf 6  0x%08X\n"
operator|,
operator|*
operator|(
operator|(
name|bit32
operator|*
operator|)
name|pSMPFrame
operator|->
name|outFrameBuf
operator|+
literal|6
operator|)
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG2
argument_list|(
operator|(
literal|"saSMPStart: outFrameBuf 7  0x%08X\n"
operator|,
operator|*
operator|(
operator|(
name|bit32
operator|*
operator|)
name|pSMPFrame
operator|->
name|outFrameBuf
operator|+
literal|7
operator|)
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG2
argument_list|(
operator|(
literal|"saSMPStart: outFrameBuf 8  0x%08X\n"
operator|,
operator|*
operator|(
operator|(
name|bit32
operator|*
operator|)
name|pSMPFrame
operator|->
name|outFrameBuf
operator|+
literal|8
operator|)
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG2
argument_list|(
operator|(
literal|"saSMPStart: outFrameBuf 9  0x%08X\n"
operator|,
operator|*
operator|(
operator|(
name|bit32
operator|*
operator|)
name|pSMPFrame
operator|->
name|outFrameBuf
operator|+
literal|9
operator|)
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG2
argument_list|(
operator|(
literal|"saSMPStart: outFrameBuf 11 0x%08X\n"
operator|,
operator|*
operator|(
operator|(
name|bit32
operator|*
operator|)
name|pSMPFrame
operator|->
name|outFrameBuf
operator|+
literal|10
operator|)
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG2
argument_list|(
operator|(
literal|"saSMPStart: outFrameBuf 11 0x%08X\n"
operator|,
operator|*
operator|(
operator|(
name|bit32
operator|*
operator|)
name|pSMPFrame
operator|->
name|outFrameBuf
operator|+
literal|11
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
name|SA_DBG2
argument_list|(
operator|(
literal|"saSMPStart: outFrameAddrUpper32 0x%08X\n"
operator|,
name|pSMPFrame
operator|->
name|outFrameAddrUpper32
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG2
argument_list|(
operator|(
literal|"saSMPStart: outFrameAddrLower32 0x%08X\n"
operator|,
name|pSMPFrame
operator|->
name|outFrameAddrLower32
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG2
argument_list|(
operator|(
literal|"saSMPStart: outFrameLen         0x%08X\n"
operator|,
name|pSMPFrame
operator|->
name|outFrameLen
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG2
argument_list|(
operator|(
literal|"saSMPStart: inFrameAddrUpper32  0x%08X\n"
operator|,
name|pSMPFrame
operator|->
name|inFrameAddrUpper32
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG2
argument_list|(
operator|(
literal|"saSMPStart: inFrameAddrLower32  0x%08X\n"
operator|,
name|pSMPFrame
operator|->
name|inFrameAddrLower32
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG2
argument_list|(
operator|(
literal|"saSMPStart: inFrameLen          0x%08X\n"
operator|,
name|pSMPFrame
operator|->
name|inFrameLen
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG2
argument_list|(
operator|(
literal|"saSMPStart: expectedRespLen     0x%08X\n"
operator|,
name|pSMPFrame
operator|->
name|expectedRespLen
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG2
argument_list|(
operator|(
literal|"saSMPStart: flag                0x%08X\n"
operator|,
name|pSMPFrame
operator|->
name|flag
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SALLSDK_DEBUG */
if|if
condition|(
name|smIS_SPC
argument_list|(
name|agRoot
argument_list|)
condition|)
comment|// if(1)
block|{
name|agsaSMPCmd_t
name|payload
decl_stmt|;
switch|switch
condition|(
name|agRequestType
condition|)
block|{
case|case
name|AGSA_SMP_INIT_REQ
case|:
block|{
name|bit32
name|IR_IP_OV_res_phyId_DPdLen_res
init|=
literal|0
decl_stmt|;
comment|/* Prepare the payload of IOMB */
name|si_memset
argument_list|(
operator|&
name|payload
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|agsaSMPCmd_t
argument_list|)
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSMPCmd_t
argument_list|,
name|tag
argument_list|)
argument_list|,
name|pRequest
operator|->
name|HTag
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSMPCmd_t
argument_list|,
name|deviceId
argument_list|)
argument_list|,
name|pDevice
operator|->
name|DeviceMapIndex
argument_list|)
expr_stmt|;
comment|/* check SMP Response Frame with IR mode */
comment|/* check if the SMP Response is indirect mode */
if|if
condition|(
literal|0
operator|==
name|pSMPFrame
operator|->
name|inFrameLen
condition|)
block|{
comment|/* PHY override not support */
comment|/* Direct Response mode */
name|pRequest
operator|->
name|IRmode
operator|=
name|DIRECT_MODE
expr_stmt|;
block|}
else|else
block|{
comment|/* Indirect Response mode */
name|pRequest
operator|->
name|IRmode
operator|=
name|INDIRECT_MODE
expr_stmt|;
name|IR_IP_OV_res_phyId_DPdLen_res
operator|=
literal|1
expr_stmt|;
comment|/* check SMP direct payload mode len */
if|if
condition|(
name|pSMPFrame
operator|->
name|outFrameLen
operator|>
literal|32
condition|)
block|{
ifdef|#
directive|ifdef
name|SA_LL_IBQ_PROTECT
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_IBQ0_LOCK
operator|+
name|inq
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SA_LL_IBQ_PROTECT */
comment|/* if not sending return to free list rare */
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|saLlistIORemove
argument_list|(
operator|&
operator|(
name|pDevice
operator|->
name|pendingIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
name|pRequest
operator|->
name|valid
operator|=
name|agFALSE
expr_stmt|;
name|saLlistIOAdd
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
comment|/* can not handle SMP frame length> 32 bytes it if IP=0 and IR=1 */
name|SA_DBG1
argument_list|(
operator|(
literal|"saSMPStart, outFrameLen> 32 bytes error.\n"
operator|)
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'e'
argument_list|,
literal|"9a"
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_FAILURE
return|;
block|}
block|}
comment|/* check Direct mode or Indirect mode for IP mode */
if|if
condition|(
operator|(
name|pSMPFrame
operator|->
name|outFrameBuf
operator|&&
operator|(
name|pSMPFrame
operator|->
name|outFrameLen
operator|<=
name|AGSA_MAX_SMPPAYLOAD_VIA_SFO
operator|)
operator|)
operator|||
operator|(
operator|(
name|pSMPFrame
operator|->
name|outFrameBuf
operator|==
name|agNULL
operator|)
operator|&&
operator|(
name|pSMPFrame
operator|->
name|outFrameLen
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
name|SA_DBG4
argument_list|(
operator|(
literal|"saSMPStart: DIRECT Request SMP\n"
operator|)
argument_list|)
expr_stmt|;
name|IR_IP_OV_res_phyId_DPdLen_res
operator|=
operator|(
name|DIRECT_MODE
operator|<<
literal|1
operator|)
operator||
name|IR_IP_OV_res_phyId_DPdLen_res
expr_stmt|;
comment|/* Direct payload length */
name|IR_IP_OV_res_phyId_DPdLen_res
operator||=
operator|(
operator|(
operator|(
name|pSMPFrame
operator|->
name|outFrameLen
operator|)
operator|&
literal|0xff
operator|)
operator|<<
name|SHIFT16
operator|)
expr_stmt|;
comment|/* copy payload - upto 48 bytes */
name|si_memcpy
argument_list|(
operator|&
operator|(
name|payload
operator|.
name|SMPCmd
index|[
literal|0
index|]
operator|)
argument_list|,
name|pSMPFrame
operator|->
name|outFrameBuf
argument_list|,
name|pSMPFrame
operator|->
name|outFrameLen
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pSMPFrame
operator|->
name|outFrameLen
operator|/
sizeof|sizeof
argument_list|(
name|bit32
argument_list|)
operator|+
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|SA_DBG4
argument_list|(
operator|(
literal|"saSMPStart: payload.SMPCmd[%d] %x\n"
operator|,
name|i
operator|,
name|payload
operator|.
name|SMPCmd
index|[
name|i
index|]
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|SA_DBG4
argument_list|(
operator|(
literal|"saSMPStart: INDIRECT Request SMP\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* use physical address */
name|IR_IP_OV_res_phyId_DPdLen_res
operator|=
operator|(
name|INDIRECT_MODE
operator|<<
literal|1
operator|)
operator||
name|IR_IP_OV_res_phyId_DPdLen_res
expr_stmt|;
comment|/* Direct payload length = 0 */
name|IR_IP_OV_res_phyId_DPdLen_res
operator|=
name|IR_IP_OV_res_phyId_DPdLen_res
operator|&
literal|0xff00ffff
expr_stmt|;
comment|/* payload */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSMPCmd_t
argument_list|,
name|SMPCmd
index|[
literal|4
index|]
argument_list|)
argument_list|,
operator|(
name|pSMPFrame
operator|->
name|outFrameAddrLower32
operator|)
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSMPCmd_t
argument_list|,
name|SMPCmd
index|[
literal|5
index|]
argument_list|)
argument_list|,
operator|(
name|pSMPFrame
operator|->
name|outFrameAddrUpper32
operator|)
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSMPCmd_t
argument_list|,
name|SMPCmd
index|[
literal|6
index|]
argument_list|)
argument_list|,
operator|(
name|pSMPFrame
operator|->
name|outFrameLen
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* Write IR_IP_OV_res_phyId_DPdLen_res field in the payload*/
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSMPCmd_t
argument_list|,
name|IR_IP_OV_res_phyId_DPdLen_res
argument_list|)
argument_list|,
name|IR_IP_OV_res_phyId_DPdLen_res
argument_list|)
expr_stmt|;
comment|/* check IR bit */
if|if
condition|(
name|IR_IP_OV_res_phyId_DPdLen_res
operator|&
name|INDIRECT_MODE
condition|)
block|{
comment|/* setup indirect response frame address */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSMPCmd_t
argument_list|,
name|SMPCmd
index|[
literal|8
index|]
argument_list|)
argument_list|,
operator|(
name|pSMPFrame
operator|->
name|inFrameAddrLower32
operator|)
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSMPCmd_t
argument_list|,
name|SMPCmd
index|[
literal|9
index|]
argument_list|)
argument_list|,
operator|(
name|pSMPFrame
operator|->
name|inFrameAddrUpper32
operator|)
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSMPCmd_t
argument_list|,
name|SMPCmd
index|[
literal|10
index|]
argument_list|)
argument_list|,
operator|(
name|pSMPFrame
operator|->
name|inFrameLen
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* Build IOMB command and send it to SPC */
name|payload_ptr
operator|=
operator|(
name|bit8
operator|*
operator|)
operator|&
name|payload
expr_stmt|;
name|ret
operator|=
name|mpiSMPCmd
argument_list|(
name|agRoot
argument_list|,
name|pMessage
argument_list|,
name|OPC_INB_SMP_REQUEST
argument_list|,
operator|(
name|agsaSMPCmd_t
operator|*
operator|)
name|payload_ptr
argument_list|,
name|inq
argument_list|,
name|outq
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SA_LL_IBQ_PROTECT
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_IBQ0_LOCK
operator|+
name|inq
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SA_LL_IBQ_PROTECT */
break|break;
block|}
default|default:
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"saSMPStart: SPC unknown agRequestType  %x\n"
operator|,
name|agRequestType
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
ifdef|#
directive|ifdef
name|SALL_API_TEST
if|if
condition|(
name|ret
operator|==
name|AGSA_RC_SUCCESS
condition|)
name|saRoot
operator|->
name|LLCounters
operator|.
name|IOCounter
operator|.
name|numSMPStarted
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
else|else
comment|/* IOMB is different for SPCV SMP */
block|{
name|agsaSMPCmd_V_t
name|vpayload
decl_stmt|;
switch|switch
condition|(
name|agRequestType
condition|)
block|{
case|case
name|AGSA_SMP_INIT_REQ
case|:
block|{
name|bit32
name|IR_IP_OV_res_phyId_DPdLen_res
init|=
literal|0
decl_stmt|;
comment|/* Prepare the payload of IOMB */
name|si_memset
argument_list|(
operator|&
name|vpayload
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|agsaSMPCmd_V_t
argument_list|)
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|vpayload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSMPCmd_V_t
argument_list|,
name|tag
argument_list|)
argument_list|,
name|pRequest
operator|->
name|HTag
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|vpayload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSMPCmd_V_t
argument_list|,
name|deviceId
argument_list|)
argument_list|,
name|pDevice
operator|->
name|DeviceMapIndex
argument_list|)
expr_stmt|;
comment|/* Request header must be valid regardless of IP bit */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|vpayload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSMPCmd_V_t
argument_list|,
name|SMPHDR
argument_list|)
argument_list|,
operator|*
operator|(
operator|(
name|bit32
operator|*
operator|)
name|pSMPFrame
operator|->
name|outFrameBuf
operator|+
literal|0
operator|)
argument_list|)
expr_stmt|;
comment|/* check SMP Response Frame with IR mode */
comment|/* check if the SMP Response is indirect mode */
comment|// smpFrameFlagDirectResponse smpFrameFlagDirectPayload
if|if
condition|(
literal|0
operator|==
name|pSMPFrame
operator|->
name|flag
operator|&&
name|pSMPFrame
operator|->
name|outFrameBuf
condition|)
block|{
comment|/* PHY override not support */
comment|/* Direct Response mode */
name|pRequest
operator|->
name|IRmode
operator|=
name|DIRECT_MODE
expr_stmt|;
name|SA_DBG2
argument_list|(
operator|(
literal|"saSMPStart:V DIRECT Request SMP\n"
operator|)
argument_list|)
expr_stmt|;
name|IR_IP_OV_res_phyId_DPdLen_res
operator|=
operator|(
name|DIRECT_MODE
operator|<<
literal|1
operator|)
operator||
name|IR_IP_OV_res_phyId_DPdLen_res
expr_stmt|;
comment|/* Direct payload length */
name|IR_IP_OV_res_phyId_DPdLen_res
operator||=
operator|(
operator|(
operator|(
name|pSMPFrame
operator|->
name|outFrameLen
operator|)
operator|&
literal|0xff
operator|)
operator|<<
name|SHIFT16
operator|)
expr_stmt|;
comment|/* Write IR_IP_OV_res_phyId_DPdLen_res field in the payload*/
comment|/* fatal error if missing */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|vpayload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSMPCmd_V_t
argument_list|,
name|IR_IP_OV_res_phyId_DPdLen_res
argument_list|)
argument_list|,
name|IR_IP_OV_res_phyId_DPdLen_res
argument_list|)
expr_stmt|;
comment|/* fatal error if missing */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|vpayload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSMPCmd_V_t
argument_list|,
name|SMP3_0
argument_list|)
argument_list|,
operator|*
operator|(
operator|(
name|bit32
operator|*
operator|)
name|pSMPFrame
operator|->
name|outFrameBuf
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|vpayload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSMPCmd_V_t
argument_list|,
name|SMP7_4
argument_list|)
argument_list|,
operator|*
operator|(
operator|(
name|bit32
operator|*
operator|)
name|pSMPFrame
operator|->
name|outFrameBuf
operator|+
literal|2
operator|)
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|vpayload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSMPCmd_V_t
argument_list|,
name|SMP11_8
argument_list|)
argument_list|,
operator|*
operator|(
operator|(
name|bit32
operator|*
operator|)
name|pSMPFrame
operator|->
name|outFrameBuf
operator|+
literal|3
operator|)
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|vpayload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSMPCmd_V_t
argument_list|,
name|IndirL_SMPRF15_12
argument_list|)
argument_list|,
operator|*
operator|(
operator|(
name|bit32
operator|*
operator|)
name|pSMPFrame
operator|->
name|outFrameBuf
operator|+
literal|4
operator|)
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|vpayload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSMPCmd_V_t
argument_list|,
name|IndirH_or_SMPRF19_16
argument_list|)
argument_list|,
operator|*
operator|(
operator|(
name|bit32
operator|*
operator|)
name|pSMPFrame
operator|->
name|outFrameBuf
operator|+
literal|5
operator|)
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|vpayload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSMPCmd_V_t
argument_list|,
name|IndirLen_or_SMPRF23_20
argument_list|)
argument_list|,
operator|*
operator|(
operator|(
name|bit32
operator|*
operator|)
name|pSMPFrame
operator|->
name|outFrameBuf
operator|+
literal|6
operator|)
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|vpayload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSMPCmd_V_t
argument_list|,
name|R_or_SMPRF27_24
argument_list|)
argument_list|,
operator|*
operator|(
operator|(
name|bit32
operator|*
operator|)
name|pSMPFrame
operator|->
name|outFrameBuf
operator|+
literal|7
operator|)
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|vpayload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSMPCmd_V_t
argument_list|,
name|ISRAL_or_SMPRF31_28
argument_list|)
argument_list|,
operator|*
operator|(
operator|(
name|bit32
operator|*
operator|)
name|pSMPFrame
operator|->
name|outFrameBuf
operator|+
literal|8
operator|)
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|vpayload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSMPCmd_V_t
argument_list|,
name|ISRAH_or_SMPRF35_32
argument_list|)
argument_list|,
operator|*
operator|(
operator|(
name|bit32
operator|*
operator|)
name|pSMPFrame
operator|->
name|outFrameBuf
operator|+
literal|9
operator|)
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|vpayload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSMPCmd_V_t
argument_list|,
name|ISRL_or_SMPRF39_36
argument_list|)
argument_list|,
operator|*
operator|(
operator|(
name|bit32
operator|*
operator|)
name|pSMPFrame
operator|->
name|outFrameBuf
operator|+
literal|10
operator|)
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|vpayload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSMPCmd_V_t
argument_list|,
name|R_or_SMPRF43_40
argument_list|)
argument_list|,
operator|*
operator|(
operator|(
name|bit32
operator|*
operator|)
name|pSMPFrame
operator|->
name|outFrameBuf
operator|+
literal|11
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|smpFrameFlagIndirectResponse
operator|&
name|pSMPFrame
operator|->
name|flag
operator|&&
name|smpFrameFlagIndirectPayload
operator|&
name|pSMPFrame
operator|->
name|flag
condition|)
comment|/* */
block|{
comment|/* IR IP */
name|SA_DBG2
argument_list|(
operator|(
literal|"saSMPStart:V smpFrameFlagIndirectResponse smpFrameFlagIndirectPayload SMP\n"
operator|)
argument_list|)
expr_stmt|;
name|pRequest
operator|->
name|IRmode
operator|=
name|INDIRECT_MODE
expr_stmt|;
name|IR_IP_OV_res_phyId_DPdLen_res
operator|=
literal|3
expr_stmt|;
comment|/* Indirect payload mode */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|vpayload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSMPCmd_V_t
argument_list|,
name|IndirL_SMPRF15_12
argument_list|)
argument_list|,
name|pSMPFrame
operator|->
name|outFrameAddrLower32
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|vpayload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSMPCmd_V_t
argument_list|,
name|IndirH_or_SMPRF19_16
argument_list|)
argument_list|,
name|pSMPFrame
operator|->
name|outFrameAddrUpper32
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|vpayload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSMPCmd_V_t
argument_list|,
name|IndirLen_or_SMPRF23_20
argument_list|)
argument_list|,
name|pSMPFrame
operator|->
name|outFrameLen
argument_list|)
expr_stmt|;
comment|/* Indirect Response mode */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|vpayload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSMPCmd_V_t
argument_list|,
name|ISRAL_or_SMPRF31_28
argument_list|)
argument_list|,
operator|(
name|pSMPFrame
operator|->
name|inFrameAddrLower32
operator|)
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|vpayload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSMPCmd_V_t
argument_list|,
name|ISRAH_or_SMPRF35_32
argument_list|)
argument_list|,
operator|(
name|pSMPFrame
operator|->
name|inFrameAddrUpper32
operator|)
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|vpayload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSMPCmd_V_t
argument_list|,
name|ISRL_or_SMPRF39_36
argument_list|)
argument_list|,
operator|(
name|pSMPFrame
operator|->
name|inFrameLen
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|smpFrameFlagIndirectPayload
operator|&
name|pSMPFrame
operator|->
name|flag
condition|)
comment|/* */
block|{
comment|/* IP */
name|SA_DBG2
argument_list|(
operator|(
literal|"saSMPStart:V  smpFrameFlagIndirectPayload SMP\n"
operator|)
argument_list|)
expr_stmt|;
name|pRequest
operator|->
name|IRmode
operator|=
name|DIRECT_MODE
expr_stmt|;
name|IR_IP_OV_res_phyId_DPdLen_res
operator|=
literal|2
expr_stmt|;
comment|/* Indirect payload mode */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|vpayload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSMPCmd_V_t
argument_list|,
name|IndirL_SMPRF15_12
argument_list|)
argument_list|,
name|pSMPFrame
operator|->
name|outFrameAddrLower32
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|vpayload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSMPCmd_V_t
argument_list|,
name|IndirH_or_SMPRF19_16
argument_list|)
argument_list|,
name|pSMPFrame
operator|->
name|outFrameAddrUpper32
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|vpayload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSMPCmd_V_t
argument_list|,
name|IndirLen_or_SMPRF23_20
argument_list|)
argument_list|,
name|pSMPFrame
operator|->
name|outFrameLen
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|smpFrameFlagIndirectResponse
operator|&
name|pSMPFrame
operator|->
name|flag
condition|)
comment|/* */
block|{
comment|/* check IR bit */
comment|/* Indirect Response mode */
name|pRequest
operator|->
name|IRmode
operator|=
name|INDIRECT_MODE
expr_stmt|;
name|SA_DBG2
argument_list|(
operator|(
literal|"saSMPStart:V smpFrameFlagIndirectResponse SMP\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* use physical address */
name|IR_IP_OV_res_phyId_DPdLen_res
operator|=
literal|1
expr_stmt|;
comment|/* Direct payload length */
name|IR_IP_OV_res_phyId_DPdLen_res
operator||=
operator|(
operator|(
operator|(
name|pSMPFrame
operator|->
name|outFrameLen
operator|)
operator|&
literal|0xff
operator|)
operator|<<
name|SHIFT16
operator|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|vpayload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSMPCmd_V_t
argument_list|,
name|SMP3_0
argument_list|)
argument_list|,
operator|*
operator|(
operator|(
name|bit32
operator|*
operator|)
name|pSMPFrame
operator|->
name|outFrameBuf
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|vpayload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSMPCmd_V_t
argument_list|,
name|SMP7_4
argument_list|)
argument_list|,
operator|*
operator|(
operator|(
name|bit32
operator|*
operator|)
name|pSMPFrame
operator|->
name|outFrameBuf
operator|+
literal|2
operator|)
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|vpayload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSMPCmd_V_t
argument_list|,
name|SMP11_8
argument_list|)
argument_list|,
operator|*
operator|(
operator|(
name|bit32
operator|*
operator|)
name|pSMPFrame
operator|->
name|outFrameBuf
operator|+
literal|3
operator|)
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|vpayload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSMPCmd_V_t
argument_list|,
name|IndirL_SMPRF15_12
argument_list|)
argument_list|,
operator|*
operator|(
operator|(
name|bit32
operator|*
operator|)
name|pSMPFrame
operator|->
name|outFrameBuf
operator|+
literal|4
operator|)
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|vpayload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSMPCmd_V_t
argument_list|,
name|IndirH_or_SMPRF19_16
argument_list|)
argument_list|,
operator|*
operator|(
operator|(
name|bit32
operator|*
operator|)
name|pSMPFrame
operator|->
name|outFrameBuf
operator|+
literal|5
operator|)
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|vpayload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSMPCmd_V_t
argument_list|,
name|IndirLen_or_SMPRF23_20
argument_list|)
argument_list|,
operator|*
operator|(
operator|(
name|bit32
operator|*
operator|)
name|pSMPFrame
operator|->
name|outFrameBuf
operator|+
literal|6
operator|)
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|vpayload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSMPCmd_V_t
argument_list|,
name|R_or_SMPRF27_24
argument_list|)
argument_list|,
operator|*
operator|(
operator|(
name|bit32
operator|*
operator|)
name|pSMPFrame
operator|->
name|outFrameBuf
operator|+
literal|7
operator|)
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|vpayload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSMPCmd_V_t
argument_list|,
name|ISRAL_or_SMPRF31_28
argument_list|)
argument_list|,
operator|(
name|pSMPFrame
operator|->
name|inFrameAddrLower32
operator|)
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|vpayload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSMPCmd_V_t
argument_list|,
name|ISRAH_or_SMPRF35_32
argument_list|)
argument_list|,
operator|(
name|pSMPFrame
operator|->
name|inFrameAddrUpper32
operator|)
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|vpayload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSMPCmd_V_t
argument_list|,
name|ISRL_or_SMPRF39_36
argument_list|)
argument_list|,
operator|(
name|pSMPFrame
operator|->
name|inFrameLen
operator|)
argument_list|)
expr_stmt|;
block|}
name|IR_IP_OV_res_phyId_DPdLen_res
operator||=
operator|(
name|pSMPFrame
operator|->
name|flag
operator|&
literal|3
operator|)
expr_stmt|;
comment|/* fatal error if missing */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|vpayload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSMPCmd_V_t
argument_list|,
name|IR_IP_OV_res_phyId_DPdLen_res
argument_list|)
argument_list|,
name|IR_IP_OV_res_phyId_DPdLen_res
argument_list|)
expr_stmt|;
comment|/* fatal error if missing */
block|}
comment|/* Build IOMB command and send it to SPCv */
name|payload_ptr
operator|=
operator|(
name|bit8
operator|*
operator|)
operator|&
name|vpayload
expr_stmt|;
name|ret
operator|=
name|mpiSMPCmd
argument_list|(
name|agRoot
argument_list|,
name|pMessage
argument_list|,
name|OPC_INB_SMP_REQUEST
argument_list|,
operator|(
name|agsaSMPCmd_t
operator|*
operator|)
name|payload_ptr
argument_list|,
name|inq
argument_list|,
name|outq
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SA_LL_IBQ_PROTECT
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_IBQ0_LOCK
operator|+
name|inq
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SA_LL_IBQ_PROTECT */
break|break;
default|default:
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"saSMPStart: SPCv unknown agRequestType  %x\n"
operator|,
name|agRequestType
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'f'
argument_list|,
literal|"9a"
argument_list|)
expr_stmt|;
comment|/* return */
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*! \brief Abort SMP request  *  *  Abort SMP request  *  *  \param agRoot handles for this instance of SAS/SATA hardware  *  \param queueNum  *  \param agIORequest  *  *  \return If request is aborted successfully  *          - \e AGSA_RC_SUCCESS request is aborted successfully  *          - \e AGSA_RC_FAILURE request is not aborted successfully  */
end_comment

begin_comment
comment|/*******************************************************************************/
end_comment

begin_function
name|GLOBAL
name|bit32
name|saSMPAbort
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|agsaIORequest_t
modifier|*
name|agIORequest
parameter_list|,
name|bit32
name|queueNum
parameter_list|,
name|agsaDevHandle_t
modifier|*
name|agDevHandle
parameter_list|,
name|bit32
name|flag
parameter_list|,
name|void
modifier|*
name|abortParam
parameter_list|,
name|ossaGenericAbortCB_t
name|agCB
parameter_list|)
block|{
name|bit32
name|ret
init|=
name|AGSA_RC_SUCCESS
decl_stmt|;
name|agsaLLRoot_t
modifier|*
name|saRoot
init|=
operator|(
name|agsaLLRoot_t
operator|*
operator|)
operator|(
name|agRoot
operator|->
name|sdkData
operator|)
decl_stmt|;
name|agsaIORequestDesc_t
modifier|*
name|pRequest
decl_stmt|;
name|agsaIORequestDesc_t
modifier|*
name|pRequestABT
init|=
name|NULL
decl_stmt|;
name|agsaIORequest_t
modifier|*
name|agIOToBeAborted
decl_stmt|;
name|agsaDeviceDesc_t
modifier|*
name|pDevice
decl_stmt|;
name|agsaSMPAbortCmd_t
name|payload
decl_stmt|;
name|bit32
name|using_reserved
init|=
name|agFALSE
decl_stmt|;
name|smTraceFuncEnter
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|"9b"
argument_list|)
expr_stmt|;
comment|/* sanity check */
name|SA_ASSERT
argument_list|(
operator|(
name|agNULL
operator|!=
name|agRoot
operator|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|SA_ASSERT
argument_list|(
operator|(
name|agNULL
operator|!=
name|agIORequest
operator|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|SA_ASSERT
argument_list|(
operator|(
name|agNULL
operator|!=
name|agDevHandle
operator|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|SA_DBG3
argument_list|(
operator|(
literal|"saSMPAbort: Aborting request %p\n"
operator|,
name|agIORequest
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ABORT_SINGLE
operator|==
operator|(
name|flag
operator|&
name|ABORT_MASK
operator|)
condition|)
block|{
name|agIOToBeAborted
operator|=
operator|(
name|agsaIORequest_t
operator|*
operator|)
name|abortParam
expr_stmt|;
comment|/* Get LL IORequest entry for saSMPAbort() */
name|pRequestABT
operator|=
operator|(
name|agsaIORequestDesc_t
operator|*
operator|)
operator|(
name|agIOToBeAborted
operator|->
name|sdkData
operator|)
expr_stmt|;
if|if
condition|(
name|agNULL
operator|==
name|pRequestABT
condition|)
block|{
comment|/* The IO to Be Abort is no longer exist - can not Abort */
name|SA_DBG1
argument_list|(
operator|(
literal|"saSMPAbort: pRequestABT AGSA_RC_FAILURE\n"
operator|)
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'a'
argument_list|,
literal|"9b"
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_FAILURE
return|;
block|}
comment|/* Find the device the request Abort to */
name|pDevice
operator|=
name|pRequestABT
operator|->
name|pDevice
expr_stmt|;
if|if
condition|(
name|agNULL
operator|==
name|pDevice
condition|)
block|{
comment|/* no deviceID - can not build IOMB */
name|SA_DBG1
argument_list|(
operator|(
literal|"saSMPAbort: pDevice AGSA_RC_FAILURE\n"
operator|)
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'b'
argument_list|,
literal|"9b"
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_FAILURE
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|ABORT_ALL
operator|==
operator|(
name|flag
operator|&
name|ABORT_MASK
operator|)
condition|)
block|{
comment|/* abort All with Device or Port */
comment|/* Find the outgoing port for the device */
name|pDevice
operator|=
operator|(
name|agsaDeviceDesc_t
operator|*
operator|)
operator|(
name|agDevHandle
operator|->
name|sdkData
operator|)
expr_stmt|;
if|if
condition|(
name|agNULL
operator|==
name|pDevice
condition|)
block|{
comment|/* no deviceID - can not build IOMB */
name|SA_DBG1
argument_list|(
operator|(
literal|"saSMPAbort:ABORT_ALL pDevice AGSA_RC_FAILURE\n"
operator|)
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'c'
argument_list|,
literal|"9b"
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_FAILURE
return|;
block|}
block|}
else|else
block|{
comment|/* only support 00 and 01 for flag */
name|SA_DBG1
argument_list|(
operator|(
literal|"saSMPAbort:flag  AGSA_RC_FAILURE\n"
operator|)
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'d'
argument_list|,
literal|"9b"
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_FAILURE
return|;
block|}
block|}
comment|/* Get LL IORequest entry */
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|pRequest
operator|=
operator|(
name|agsaIORequestDesc_t
operator|*
operator|)
name|saLlistIOGetHead
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|)
expr_stmt|;
comment|/* If no LL IO request entry available */
if|if
condition|(
name|agNULL
operator|==
name|pRequest
condition|)
block|{
name|pRequest
operator|=
operator|(
name|agsaIORequestDesc_t
operator|*
operator|)
name|saLlistIOGetHead
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeReservedRequests
operator|)
argument_list|)
expr_stmt|;
comment|/**/
comment|/* If no LL Control request entry available */
if|if
condition|(
name|agNULL
operator|!=
name|pRequest
condition|)
block|{
name|using_reserved
operator|=
name|agTRUE
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saSMPAbort, using saRoot->freeReservedRequests\n"
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saSMPAbort, No request from free list Not using saRoot->freeReservedRequests\n"
operator|)
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'e'
argument_list|,
literal|"9b"
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_BUSY
return|;
block|}
block|}
comment|/* If free IOMB avaliable */
comment|/* Remove the request from free list */
if|if
condition|(
name|using_reserved
condition|)
block|{
name|saLlistIORemove
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeReservedRequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|saLlistIORemove
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* Add the request to the pendingSMPRequests list of the device */
name|saLlistIOAdd
argument_list|(
operator|&
operator|(
name|pDevice
operator|->
name|pendingIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
name|SA_ASSERT
argument_list|(
operator|(
operator|!
name|pRequest
operator|->
name|valid
operator|)
argument_list|,
literal|"The pRequest is in use"
argument_list|)
expr_stmt|;
name|pRequest
operator|->
name|valid
operator|=
name|agTRUE
expr_stmt|;
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
comment|/* set up pRequest */
name|pRequest
operator|->
name|pIORequestContext
operator|=
name|agIORequest
expr_stmt|;
name|pRequest
operator|->
name|requestType
operator|=
name|AGSA_SMP_REQTYPE
expr_stmt|;
name|pRequest
operator|->
name|completionCB
operator|=
operator|(
name|void
operator|*
operator|)
name|agCB
expr_stmt|;
name|pRequest
operator|->
name|pDevice
operator|=
name|pDevice
expr_stmt|;
name|pRequest
operator|->
name|startTick
operator|=
name|saRoot
operator|->
name|timeTick
expr_stmt|;
comment|/* Set request to the sdkData of agIORequest */
name|agIORequest
operator|->
name|sdkData
operator|=
name|pRequest
expr_stmt|;
comment|/* save tag to IOMap */
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|Tag
operator|=
name|pRequest
operator|->
name|HTag
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|IORequest
operator|=
operator|(
name|void
operator|*
operator|)
name|pRequest
expr_stmt|;
comment|/* setup payload */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSMPAbortCmd_t
argument_list|,
name|tag
argument_list|)
argument_list|,
name|pRequest
operator|->
name|HTag
argument_list|)
expr_stmt|;
if|if
condition|(
name|ABORT_SINGLE
operator|==
operator|(
name|flag
operator|&
name|ABORT_MASK
operator|)
condition|)
block|{
if|if
condition|(
name|agNULL
operator|==
name|pRequestABT
condition|)
block|{
comment|/* remove the request from IOMap */
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|Tag
operator|=
name|MARK_OFF
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|IORequest
operator|=
name|agNULL
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|agContext
operator|=
name|agNULL
expr_stmt|;
comment|/* Delete the request from the pendingSMPRequests */
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|saLlistIORemove
argument_list|(
operator|&
operator|(
name|pDevice
operator|->
name|pendingIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
comment|/* return the request to free pool */
if|if
condition|(
name|saLlistIOGetCount
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeReservedRequests
operator|)
argument_list|)
operator|<
name|SA_RESERVED_REQUEST_COUNT
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"saSMPAbort: saving pRequest (%p) for later use\n"
operator|,
name|pRequest
operator|)
argument_list|)
expr_stmt|;
name|saLlistIOAdd
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeReservedRequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* return the request to free pool */
name|saLlistIOAdd
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
block|}
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saSMPAbort, agNULL == pRequestABT\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* The IO to Be Abort is no longer exist - can not Abort */
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'f'
argument_list|,
literal|"9b"
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_FAILURE
return|;
block|}
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSMPAbortCmd_t
argument_list|,
name|HTagAbort
argument_list|)
argument_list|,
name|pRequestABT
operator|->
name|HTag
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* abort all */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSMPAbortCmd_t
argument_list|,
name|HTagAbort
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSMPAbortCmd_t
argument_list|,
name|deviceId
argument_list|)
argument_list|,
name|pDevice
operator|->
name|DeviceMapIndex
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSMPAbortCmd_t
argument_list|,
name|Scp
argument_list|)
argument_list|,
name|flag
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saSMPAbort, HTag 0x%x HTagABT 0x%x deviceId 0x%x\n"
operator|,
name|payload
operator|.
name|tag
operator|,
name|payload
operator|.
name|HTagAbort
operator|,
name|payload
operator|.
name|deviceId
operator|)
argument_list|)
expr_stmt|;
comment|/* build IOMB command and send to SPC */
name|ret
operator|=
name|mpiBuildCmd
argument_list|(
name|agRoot
argument_list|,
operator|(
name|bit32
operator|*
operator|)
operator|&
name|payload
argument_list|,
name|MPI_CATEGORY_SAS_SATA
argument_list|,
name|OPC_INB_SMP_ABORT
argument_list|,
name|IOMB_SIZE64
argument_list|,
name|queueNum
argument_list|)
expr_stmt|;
if|if
condition|(
name|AGSA_RC_SUCCESS
operator|!=
name|ret
condition|)
block|{
comment|/* remove the request from IOMap */
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|Tag
operator|=
name|MARK_OFF
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|IORequest
operator|=
name|agNULL
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|agContext
operator|=
name|agNULL
expr_stmt|;
comment|/* Delete the request from the pendingSMPRequests */
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|saLlistIORemove
argument_list|(
operator|&
operator|(
name|pDevice
operator|->
name|pendingIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
comment|/* return the request to free pool */
if|if
condition|(
name|saLlistIOGetCount
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeReservedRequests
operator|)
argument_list|)
operator|<
name|SA_RESERVED_REQUEST_COUNT
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"saSMPAbort: saving pRequest (%p) for later use\n"
operator|,
name|pRequest
operator|)
argument_list|)
expr_stmt|;
name|saLlistIOAdd
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeReservedRequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* return the request to free pool */
name|saLlistIOAdd
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
block|}
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saSMPAbort, sending IOMB failed\n"
operator|)
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SALL_API_TEST
else|else
block|{
name|saRoot
operator|->
name|LLCounters
operator|.
name|IOCounter
operator|.
name|numSMPAborted
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'g'
argument_list|,
literal|"9b"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

end_unit

