begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************************* *Copyright (c) 2014 PMC-Sierra, Inc.  All rights reserved.  * *Redistribution and use in source and binary forms, with or without modification, are permitted provided  *that the following conditions are met:  *1. Redistributions of source code must retain the above copyright notice, this list of conditions and the *following disclaimer.  *2. Redistributions in binary form must reproduce the above copyright notice,  *this list of conditions and the following disclaimer in the documentation and/or other materials provided *with the distribution.  * *THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR IMPLIED  *WARRANTIES,INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS *FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE *FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  *NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR  *BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  *LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  *SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE  ********************************************************************************/
end_comment

begin_comment
comment|/*******************************************************************************/
end_comment

begin_comment
comment|/*! \file saphy.c  *  \brief The file implements the functions to Start, Stop a phy  *  *  */
end_comment

begin_comment
comment|/******************************************************************************/
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<dev/pms/config.h>
end_include

begin_include
include|#
directive|include
file|<dev/pms/RefTisa/sallsdk/spc/saglobal.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SA_ENABLE_TRACE_FUNCTIONS
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|siTraceFileID
end_ifdef

begin_undef
undef|#
directive|undef
name|siTraceFileID
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|siTraceFileID
value|'K'
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|bit32
name|gFPGA_TEST
decl_stmt|;
end_decl_stmt

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*! \brief Start a Phy  *  *  Start a Phy  *  *  \param agRoot handles for this instance of SAS/SATA hardware  *  \param agContext  *  \param phyId the phy id of the link will be started  *  \param agPhyConfig the phy configuration  *  \param agSASIdentify the SAS identify frame will be sent by the phy  *  *  \return If phy is started successfully  *          - \e AGSA_RC_SUCCESS phy is started successfully  *          - \e AGSA_RC_BUSY phy is already started or starting  *          - \e AGSA_RC_FAILURE phy is not started successfully  */
end_comment

begin_comment
comment|/*******************************************************************************/
end_comment

begin_function
name|GLOBAL
name|bit32
name|saPhyStart
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|agsaContext_t
modifier|*
name|agContext
parameter_list|,
name|bit32
name|queueNum
parameter_list|,
name|bit32
name|phyId
parameter_list|,
name|agsaPhyConfig_t
modifier|*
name|agPhyConfig
parameter_list|,
name|agsaSASIdentify_t
modifier|*
name|agSASIdentify
parameter_list|)
block|{
name|agsaLLRoot_t
modifier|*
name|saRoot
init|=
operator|(
name|agsaLLRoot_t
operator|*
operator|)
operator|(
name|agRoot
operator|->
name|sdkData
operator|)
decl_stmt|;
name|agsaIORequestDesc_t
modifier|*
name|pRequest
decl_stmt|;
name|bit32
name|ret
init|=
name|AGSA_RC_SUCCESS
decl_stmt|;
name|bit32
name|using_reserved
init|=
name|agFALSE
decl_stmt|;
name|smTraceFuncEnter
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|"7a"
argument_list|)
expr_stmt|;
comment|/* sanity check */
name|SA_ASSERT
argument_list|(
operator|(
name|agNULL
operator|!=
name|agRoot
operator|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|SA_ASSERT
argument_list|(
operator|(
name|agNULL
operator|!=
name|agSASIdentify
operator|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|SA_DBG3
argument_list|(
operator|(
literal|"saPhyStart: phy%d started with ID %08X:%08X\n"
operator|,
name|phyId
operator|,
name|SA_IDFRM_GET_SAS_ADDRESSHI
argument_list|(
name|agSASIdentify
argument_list|)
operator|,
name|SA_IDFRM_GET_SAS_ADDRESSLO
argument_list|(
name|agSASIdentify
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* If phyId is invalid, return failure */
if|if
condition|(
name|phyId
operator|>=
name|saRoot
operator|->
name|phyCount
condition|)
block|{
name|ret
operator|=
name|AGSA_RC_FAILURE
expr_stmt|;
block|}
comment|/* If phyId is valid */
else|else
block|{
comment|/* Get request from free IORequests */
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|pRequest
operator|=
operator|(
name|agsaIORequestDesc_t
operator|*
operator|)
name|saLlistIOGetHead
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|)
expr_stmt|;
comment|/* */
comment|/* If no LL Control request entry available */
if|if
condition|(
name|agNULL
operator|==
name|pRequest
condition|)
block|{
name|pRequest
operator|=
operator|(
name|agsaIORequestDesc_t
operator|*
operator|)
name|saLlistIOGetHead
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeReservedRequests
operator|)
argument_list|)
expr_stmt|;
comment|/* If no LL Control request entry available */
if|if
condition|(
name|agNULL
operator|!=
name|pRequest
condition|)
block|{
name|using_reserved
operator|=
name|agTRUE
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saPhyStart, using saRoot->freeReservedRequests\n"
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saPhyStart, No request from free list Not using saRoot->freeReservedRequests\n"
operator|)
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'a'
argument_list|,
literal|"7a"
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_BUSY
return|;
block|}
block|}
name|SA_ASSERT
argument_list|(
operator|(
operator|!
name|pRequest
operator|->
name|valid
operator|)
argument_list|,
literal|"The pRequest is in use"
argument_list|)
expr_stmt|;
name|pRequest
operator|->
name|valid
operator|=
name|agTRUE
expr_stmt|;
comment|/* If LL Control request entry avaliable */
if|if
condition|(
name|using_reserved
condition|)
block|{
name|saLlistIORemove
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeReservedRequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Remove the request from free list */
name|saLlistIORemove
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
block|}
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|Tag
operator|=
name|pRequest
operator|->
name|HTag
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|IORequest
operator|=
operator|(
name|void
operator|*
operator|)
name|pRequest
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|agContext
operator|=
name|agContext
expr_stmt|;
name|pRequest
operator|->
name|valid
operator|=
name|agTRUE
expr_stmt|;
comment|/* Build the Phy Start IOMB command and send to SPC */
name|smTrace
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|"P2"
argument_list|,
name|phyId
argument_list|)
expr_stmt|;
comment|/* TP:P2 phyId */
name|ret
operator|=
name|mpiPhyStartCmd
argument_list|(
name|agRoot
argument_list|,
name|pRequest
operator|->
name|HTag
argument_list|,
name|phyId
argument_list|,
name|agPhyConfig
argument_list|,
name|agSASIdentify
argument_list|,
name|queueNum
argument_list|)
expr_stmt|;
if|if
condition|(
name|AGSA_RC_SUCCESS
operator|!=
name|ret
condition|)
block|{
comment|/* remove the request from IOMap */
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|Tag
operator|=
name|MARK_OFF
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|IORequest
operator|=
name|agNULL
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|agContext
operator|=
name|agNULL
expr_stmt|;
name|pRequest
operator|->
name|valid
operator|=
name|agFALSE
expr_stmt|;
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
comment|/* return the request to free pool */
if|if
condition|(
name|saLlistIOGetCount
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeReservedRequests
operator|)
argument_list|)
operator|<
name|SA_RESERVED_REQUEST_COUNT
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"saPhyStart: saving pRequest (%p) for later use\n"
operator|,
name|pRequest
operator|)
argument_list|)
expr_stmt|;
name|saLlistIOAdd
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeReservedRequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* return the request to free pool */
name|saLlistIOAdd
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
block|}
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saPhyStart, sending IOMB failed\n"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'b'
argument_list|,
literal|"7a"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*! \brief Stop a Phy  *  *  Stop a Phy  *  *  \param agRoot handles for this instance of SAS/SATA hardware  *  \param agContext the context of this API  *  \param phyId the phy id of the link will be stopped  *  *  \return If phy is stopped successfully  *          - \e AGSA_RC_SUCCESS phy is stopped successfully  *          - \e AGSA_RC_FAILURE phy is not stopped successfully  */
end_comment

begin_comment
comment|/*******************************************************************************/
end_comment

begin_function
name|GLOBAL
name|bit32
name|saPhyStop
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|agsaContext_t
modifier|*
name|agContext
parameter_list|,
name|bit32
name|queueNum
parameter_list|,
name|bit32
name|phyId
parameter_list|)
block|{
name|agsaLLRoot_t
modifier|*
name|saRoot
init|=
operator|(
name|agsaLLRoot_t
operator|*
operator|)
operator|(
name|agRoot
operator|->
name|sdkData
operator|)
decl_stmt|;
name|agsaIORequestDesc_t
modifier|*
name|pRequest
decl_stmt|;
name|bit32
name|ret
init|=
name|AGSA_RC_SUCCESS
decl_stmt|;
name|bit32
name|using_reserved
init|=
name|agFALSE
decl_stmt|;
name|smTraceFuncEnter
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|"7b"
argument_list|)
expr_stmt|;
comment|/* sanity check */
name|SA_ASSERT
argument_list|(
operator|(
name|agNULL
operator|!=
name|agRoot
operator|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|SA_DBG2
argument_list|(
operator|(
literal|"saPhyStop: phy%d stop\n"
operator|,
name|phyId
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
literal|1
condition|)
block|{
name|mpiOCQueue_t
modifier|*
name|circularQ
decl_stmt|;
name|int
name|i
decl_stmt|;
name|SA_DBG4
argument_list|(
operator|(
literal|"saPhyStop:\n"
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|saRoot
operator|->
name|QueueConfig
operator|.
name|numOutboundQueues
condition|;
name|i
operator|++
control|)
block|{
name|circularQ
operator|=
operator|&
name|saRoot
operator|->
name|outboundQueue
index|[
name|i
index|]
expr_stmt|;
name|OSSA_READ_LE_32
argument_list|(
name|circularQ
operator|->
name|agRoot
argument_list|,
operator|&
name|circularQ
operator|->
name|producerIdx
argument_list|,
name|circularQ
operator|->
name|piPointer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|circularQ
operator|->
name|producerIdx
operator|!=
name|circularQ
operator|->
name|consumerIdx
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"saPhyStop: PI 0x%03x CI 0x%03x\n"
operator|,
name|circularQ
operator|->
name|producerIdx
operator|,
name|circularQ
operator|->
name|consumerIdx
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|smIS_SPC
argument_list|(
name|agRoot
argument_list|)
condition|)
block|{
name|phyId
operator|&=
literal|0xF
expr_stmt|;
block|}
comment|/* If phyId is invalid, return failure */
if|if
condition|(
operator|(
name|phyId
operator|&
literal|0xF
operator|)
operator|>=
name|saRoot
operator|->
name|phyCount
condition|)
block|{
name|ret
operator|=
name|AGSA_RC_FAILURE
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saPhyStop: phy%d - failure with phyId\n"
operator|,
name|phyId
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* If phyId is valid */
comment|/* Get request from free IORequests */
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|pRequest
operator|=
operator|(
name|agsaIORequestDesc_t
operator|*
operator|)
name|saLlistIOGetHead
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|)
expr_stmt|;
comment|/**/
comment|/* If no LL Control request entry available */
if|if
condition|(
name|agNULL
operator|==
name|pRequest
condition|)
block|{
name|pRequest
operator|=
operator|(
name|agsaIORequestDesc_t
operator|*
operator|)
name|saLlistIOGetHead
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeReservedRequests
operator|)
argument_list|)
expr_stmt|;
comment|/* If no LL Control request entry available */
if|if
condition|(
name|agNULL
operator|!=
name|pRequest
condition|)
block|{
name|using_reserved
operator|=
name|agTRUE
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saPhyStop: using saRoot->freeReservedRequests\n"
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saPhyStop, No request from free list Not using saRoot->freeReservedRequests\n"
operator|)
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'a'
argument_list|,
literal|"7b"
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_BUSY
return|;
block|}
block|}
comment|/* Remove the request from free list */
if|if
condition|(
name|using_reserved
condition|)
block|{
name|saLlistIORemove
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeReservedRequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|saLlistIORemove
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
block|}
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|SA_ASSERT
argument_list|(
operator|(
operator|!
name|pRequest
operator|->
name|valid
operator|)
argument_list|,
literal|"The pRequest is in use"
argument_list|)
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|Tag
operator|=
name|pRequest
operator|->
name|HTag
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|IORequest
operator|=
operator|(
name|void
operator|*
operator|)
name|pRequest
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|agContext
operator|=
name|agContext
expr_stmt|;
name|pRequest
operator|->
name|valid
operator|=
name|agTRUE
expr_stmt|;
comment|/* build IOMB command and send to SPC */
name|ret
operator|=
name|mpiPhyStopCmd
argument_list|(
name|agRoot
argument_list|,
name|pRequest
operator|->
name|HTag
argument_list|,
name|phyId
argument_list|,
name|queueNum
argument_list|)
expr_stmt|;
if|if
condition|(
name|AGSA_RC_SUCCESS
operator|!=
name|ret
condition|)
block|{
comment|/* remove the request from IOMap */
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|Tag
operator|=
name|MARK_OFF
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|IORequest
operator|=
name|agNULL
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|agContext
operator|=
name|agNULL
expr_stmt|;
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
comment|/* return the request to free pool */
if|if
condition|(
name|saLlistIOGetCount
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeReservedRequests
operator|)
argument_list|)
operator|<
name|SA_RESERVED_REQUEST_COUNT
condition|)
block|{
name|SA_DBG2
argument_list|(
operator|(
literal|"saPhyStop: saving pRequest (%p) for later use\n"
operator|,
name|pRequest
operator|)
argument_list|)
expr_stmt|;
name|saLlistIOAdd
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeReservedRequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* return the request to free pool */
name|saLlistIOAdd
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
block|}
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saPhyStop, sending IOMB failed\n"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'b'
argument_list|,
literal|"7b"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*! \brief CallBack Routine to stop a Phy  *  *  CallBack for Stop a Phy  *  *  \param agRoot handles for this instance of SAS/SATA hardware  *  \param phyId the phy id of the link will be stopped  *  \param status the status of the phy  *  \param agContext the context of the saPhyStop  *  *  \return If phy is stopped successfully  *          - \e AGSA_RC_SUCCESS phy is stopped successfully  *          - \e AGSA_RC_FAILURE phy is not stopped successfully  */
end_comment

begin_comment
comment|/*******************************************************************************/
end_comment

begin_function
name|GLOBAL
name|bit32
name|siPhyStopCB
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|bit32
name|phyId
parameter_list|,
name|bit32
name|status
parameter_list|,
name|agsaContext_t
modifier|*
name|agContext
parameter_list|,
name|bit32
name|portId
parameter_list|,
name|bit32
name|npipps
parameter_list|)
block|{
name|agsaLLRoot_t
modifier|*
name|saRoot
init|=
operator|(
name|agsaLLRoot_t
operator|*
operator|)
operator|(
name|agRoot
operator|->
name|sdkData
operator|)
decl_stmt|;
name|agsaPhy_t
modifier|*
name|pPhy
decl_stmt|;
name|agsaPort_t
modifier|*
name|pPort
decl_stmt|;
name|bit32
name|ret
init|=
name|AGSA_RC_SUCCESS
decl_stmt|;
name|bit32
name|iomb_status
init|=
name|status
decl_stmt|;
name|smTraceFuncEnter
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|"7c"
argument_list|)
expr_stmt|;
comment|/* sanity check */
name|SA_ASSERT
argument_list|(
operator|(
name|agNULL
operator|!=
name|agRoot
operator|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* If phyId is invalid, return failure */
if|if
condition|(
name|phyId
operator|>=
name|saRoot
operator|->
name|phyCount
condition|)
block|{
name|ret
operator|=
name|AGSA_RC_FAILURE
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"siPhyStopCB: phy%d - failure with phyId\n"
operator|,
name|phyId
operator|)
argument_list|)
expr_stmt|;
comment|/* makeup for CB */
name|status
operator|=
operator|(
name|status
operator|<<
name|SHIFT8
operator|)
operator||
name|phyId
expr_stmt|;
name|status
operator||=
operator|(
operator|(
name|npipps
operator|&
name|PORT_STATE_MASK
operator|)
operator|<<
name|SHIFT16
operator|)
expr_stmt|;
name|ossaHwCB
argument_list|(
name|agRoot
argument_list|,
name|agNULL
argument_list|,
name|OSSA_HW_EVENT_PHY_STOP_STATUS
argument_list|,
name|status
argument_list|,
name|agContext
argument_list|,
name|agNULL
argument_list|)
expr_stmt|;
block|}
comment|/* If phyId is valid */
else|else
block|{
name|pPhy
operator|=
operator|&
operator|(
name|saRoot
operator|->
name|phys
index|[
name|phyId
index|]
operator|)
expr_stmt|;
comment|/* get the port of the phy */
name|pPort
operator|=
name|pPhy
operator|->
name|pPort
expr_stmt|;
comment|/* makeup for CB */
name|status
operator|=
operator|(
name|status
operator|<<
name|SHIFT8
operator|)
operator||
name|phyId
expr_stmt|;
name|status
operator||=
operator|(
operator|(
name|npipps
operator|&
name|PORT_STATE_MASK
operator|)
operator|<<
name|SHIFT16
operator|)
expr_stmt|;
comment|/* Callback to stop phy */
if|if
condition|(
name|agNULL
operator|!=
name|pPort
condition|)
block|{
if|if
condition|(
name|iomb_status
operator|==
name|OSSA_SUCCESS
operator|&&
operator|(
name|OSSA_PORT_INVALID
operator|==
operator|(
name|npipps
operator|&
name|PORT_STATE_MASK
operator|)
operator|)
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"siPhyStopCB: phy%d invalidating port\n"
operator|,
name|phyId
operator|)
argument_list|)
expr_stmt|;
comment|/* invalid port state, remove the port */
name|pPort
operator|->
name|status
operator||=
name|PORT_INVALIDATING
expr_stmt|;
name|saRoot
operator|->
name|PortMap
index|[
name|portId
index|]
operator|.
name|PortStatus
operator||=
name|PORT_INVALIDATING
expr_stmt|;
comment|/* invalid the port */
name|siPortInvalid
argument_list|(
name|agRoot
argument_list|,
name|pPort
argument_list|)
expr_stmt|;
comment|/* map out the portmap */
name|saRoot
operator|->
name|PortMap
index|[
name|pPort
operator|->
name|portId
index|]
operator|.
name|PortContext
operator|=
name|agNULL
expr_stmt|;
name|saRoot
operator|->
name|PortMap
index|[
name|pPort
operator|->
name|portId
index|]
operator|.
name|PortID
operator|=
name|PORT_MARK_OFF
expr_stmt|;
name|saRoot
operator|->
name|PortMap
index|[
name|pPort
operator|->
name|portId
index|]
operator|.
name|PortStatus
operator||=
name|PORT_INVALIDATING
expr_stmt|;
block|}
name|ossaHwCB
argument_list|(
name|agRoot
argument_list|,
operator|&
operator|(
name|pPort
operator|->
name|portContext
operator|)
argument_list|,
name|OSSA_HW_EVENT_PHY_STOP_STATUS
argument_list|,
name|status
argument_list|,
name|agContext
argument_list|,
name|agNULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"siPhyStopCB: phy%d - Port is not established\n"
operator|,
name|phyId
operator|)
argument_list|)
expr_stmt|;
name|ossaHwCB
argument_list|(
name|agRoot
argument_list|,
name|agNULL
argument_list|,
name|OSSA_HW_EVENT_PHY_STOP_STATUS
argument_list|,
name|status
argument_list|,
name|agContext
argument_list|,
name|agNULL
argument_list|)
expr_stmt|;
block|}
comment|/* set PHY_STOPPED status */
name|PHY_STATUS_SET
argument_list|(
name|pPhy
argument_list|,
name|PHY_STOPPED
argument_list|)
expr_stmt|;
comment|/* Exclude the phy from a port */
if|if
condition|(
name|agNULL
operator|!=
name|pPort
condition|)
block|{
comment|/* Acquire port list lock */
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_PORT_LOCK
argument_list|)
expr_stmt|;
comment|/* Delete the phy from the port */
name|pPort
operator|->
name|phyMap
index|[
name|phyId
index|]
operator|=
name|agFALSE
expr_stmt|;
name|saRoot
operator|->
name|phys
index|[
name|phyId
index|]
operator|.
name|pPort
operator|=
name|agNULL
expr_stmt|;
comment|/* Release port list lock */
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_PORT_LOCK
argument_list|)
expr_stmt|;
block|}
block|}
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'a'
argument_list|,
literal|"7c"
argument_list|)
expr_stmt|;
comment|/* return */
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*! \brief Initiate a Local PHY control command  *  *  This function is called to initiate a PHY control command to the local PHY.  *  The completion of this function is reported in ossaLocalPhyControlCB()   *  *  \param agRoot handles for this instance of SAS/SATA hardware  *  \param agContext the context of this API  *  \param phyId  phy number  *  \param phyOperation  *    one of AGSA_PHY_LINK_RESET, AGSA_PHY_HARD_RESET, AGSA_PHY_ENABLE_SPINUP  *  *  \return  *          - none  */
end_comment

begin_comment
comment|/*******************************************************************************/
end_comment

begin_function
name|GLOBAL
name|bit32
name|saLocalPhyControl
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|agsaContext_t
modifier|*
name|agContext
parameter_list|,
name|bit32
name|queueNum
parameter_list|,
name|bit32
name|phyId
parameter_list|,
name|bit32
name|phyOperation
parameter_list|,
name|ossaLocalPhyControlCB_t
name|agCB
parameter_list|)
block|{
name|agsaLLRoot_t
modifier|*
name|saRoot
init|=
operator|(
name|agsaLLRoot_t
operator|*
operator|)
operator|(
name|agRoot
operator|->
name|sdkData
operator|)
decl_stmt|;
name|agsaIORequestDesc_t
modifier|*
name|pRequest
decl_stmt|;
name|agsaPhyErrCounters_t
name|errorParam
decl_stmt|;
name|bit32
name|ret
init|=
name|AGSA_RC_SUCCESS
decl_stmt|;
name|bit32
name|value
decl_stmt|,
name|value1
decl_stmt|,
name|value2
decl_stmt|,
name|copyPhyId
decl_stmt|;
name|bit32
name|count
init|=
literal|100
decl_stmt|;
name|bit32
name|using_reserved
init|=
name|agFALSE
decl_stmt|;
comment|/* sanity check */
name|SA_ASSERT
argument_list|(
operator|(
name|agNULL
operator|!=
name|saRoot
operator|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|saRoot
operator|==
name|agNULL
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"saLocalPhyControl: saRoot == agNULL\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|AGSA_RC_FAILURE
operator|)
return|;
block|}
name|smTraceFuncEnter
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|"7d"
argument_list|)
expr_stmt|;
name|si_memset
argument_list|(
operator|&
name|errorParam
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|agsaPhyErrCounters_t
argument_list|)
argument_list|)
expr_stmt|;
name|SA_DBG2
argument_list|(
operator|(
literal|"saLocalPhyControl: phy%d operation %08X\n"
operator|,
name|phyId
operator|,
name|phyOperation
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|phyOperation
condition|)
block|{
case|case
name|AGSA_PHY_LINK_RESET
case|:
case|case
name|AGSA_PHY_HARD_RESET
case|:
case|case
name|AGSA_PHY_NOTIFY_ENABLE_SPINUP
case|:
case|case
name|AGSA_PHY_BROADCAST_ASYNCH_EVENT
case|:
case|case
name|AGSA_PHY_COMINIT_OOB
case|:
block|{
comment|/* Get request from free IORequests */
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|pRequest
operator|=
operator|(
name|agsaIORequestDesc_t
operator|*
operator|)
name|saLlistIOGetHead
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|)
expr_stmt|;
comment|/**/
comment|/* If no LL Control request entry available */
if|if
condition|(
name|agNULL
operator|==
name|pRequest
condition|)
block|{
name|pRequest
operator|=
operator|(
name|agsaIORequestDesc_t
operator|*
operator|)
name|saLlistIOGetHead
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeReservedRequests
operator|)
argument_list|)
expr_stmt|;
comment|/* If no LL Control request entry available */
if|if
condition|(
name|agNULL
operator|!=
name|pRequest
condition|)
block|{
name|using_reserved
operator|=
name|agTRUE
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saLocalPhyControl, using saRoot->freeReservedRequests\n"
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saLocalPhyControl, No request from free list Not using saRoot->freeReservedRequests\n"
operator|)
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'a'
argument_list|,
literal|"7d"
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_BUSY
return|;
block|}
block|}
if|if
condition|(
name|using_reserved
condition|)
block|{
name|saLlistIORemove
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeReservedRequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|saLlistIORemove
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* Remove the request from free list */
name|SA_ASSERT
argument_list|(
operator|(
operator|!
name|pRequest
operator|->
name|valid
operator|)
argument_list|,
literal|"The pRequest is in use"
argument_list|)
expr_stmt|;
name|pRequest
operator|->
name|completionCB
operator|=
operator|(
name|void
operator|*
operator|)
name|agCB
expr_stmt|;
comment|//  pRequest->abortCompletionCB = agCB;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|Tag
operator|=
name|pRequest
operator|->
name|HTag
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|IORequest
operator|=
operator|(
name|void
operator|*
operator|)
name|pRequest
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|agContext
operator|=
name|agContext
expr_stmt|;
name|pRequest
operator|->
name|valid
operator|=
name|agTRUE
expr_stmt|;
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
comment|/* Build the local phy control IOMB command and send to SPC */
name|ret
operator|=
name|mpiLocalPhyControlCmd
argument_list|(
name|agRoot
argument_list|,
name|pRequest
operator|->
name|HTag
argument_list|,
name|phyId
argument_list|,
name|phyOperation
argument_list|,
name|queueNum
argument_list|)
expr_stmt|;
if|if
condition|(
name|AGSA_RC_SUCCESS
operator|!=
name|ret
condition|)
block|{
comment|/* remove the request from IOMap */
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|Tag
operator|=
name|MARK_OFF
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|IORequest
operator|=
name|agNULL
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|agContext
operator|=
name|agNULL
expr_stmt|;
name|pRequest
operator|->
name|valid
operator|=
name|agFALSE
expr_stmt|;
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
comment|/* return the request to free pool */
if|if
condition|(
name|saLlistIOGetCount
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeReservedRequests
operator|)
argument_list|)
operator|<
name|SA_RESERVED_REQUEST_COUNT
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"saLocalPhyControl: saving pRequest (%p) for later use\n"
operator|,
name|pRequest
operator|)
argument_list|)
expr_stmt|;
name|saLlistIOAdd
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeReservedRequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* return the request to free pool */
name|saLlistIOAdd
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
block|}
name|SA_DBG1
argument_list|(
operator|(
literal|"saLocalPhyControl, sending IOMB failed\n"
operator|)
argument_list|)
expr_stmt|;
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
block|}
break|break;
case|case
name|AGSA_PHY_GET_ERROR_COUNTS
case|:
block|{
if|if
condition|(
name|smIS_SPCV
argument_list|(
name|agRoot
argument_list|)
condition|)
block|{
name|SA_ASSERT
argument_list|(
operator|(
name|smIS_SPC
argument_list|(
name|agRoot
argument_list|)
operator|)
argument_list|,
literal|"SPC only"
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saLocalPhyControl: V AGSA_PHY_GET_ERROR_COUNTS\n"
operator|)
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'b'
argument_list|,
literal|"7d"
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_FAILURE
return|;
block|}
comment|/* If phyId is invalid, return failure */
if|if
condition|(
name|phyId
operator|>=
name|saRoot
operator|->
name|phyCount
condition|)
block|{
name|ret
operator|=
name|AGSA_RC_FAILURE
expr_stmt|;
name|si_memset
argument_list|(
operator|&
name|errorParam
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|agsaPhyErrCounters_t
argument_list|)
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saLocalPhyControl: phy%d - failure with phyId\n"
operator|,
name|phyId
operator|)
argument_list|)
expr_stmt|;
comment|/* call back with the status */
if|if
condition|(
name|agCB
operator|==
name|agNULL
condition|)
block|{
name|ossaLocalPhyControlCB
argument_list|(
name|agRoot
argument_list|,
name|agContext
argument_list|,
name|phyId
argument_list|,
name|phyOperation
argument_list|,
name|OSSA_FAILURE
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|errorParam
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|agCB
argument_list|(
name|agRoot
argument_list|,
name|agContext
argument_list|,
name|phyId
argument_list|,
name|phyOperation
argument_list|,
name|OSSA_FAILURE
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|errorParam
argument_list|)
expr_stmt|;
block|}
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'c'
argument_list|,
literal|"7d"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
comment|/* save phyId */
name|copyPhyId
operator|=
name|phyId
expr_stmt|;
comment|/* map 0x030000 or 0x040000 based on phyId to BAR4(0x20), BAT2(win) to access the register  */
if|if
condition|(
name|phyId
operator|<
literal|4
condition|)
block|{
comment|/* for phyId = 0, 1, 2, 3 */
name|value
operator|=
literal|0x030000
expr_stmt|;
block|}
else|else
block|{
comment|/* for phyId = 4, 5, 6, 7 */
name|phyId
operator|=
name|phyId
operator|-
literal|4
expr_stmt|;
name|value
operator|=
literal|0x040000
expr_stmt|;
block|}
comment|/* Need to make sure DEVICE_LCLK_GENERATION register bit 6 is 0 */
name|value1
operator|=
name|ossaHwRegReadExt
argument_list|(
name|agRoot
argument_list|,
name|PCIBAR2
argument_list|,
name|SPC_REG_DEVICE_LCLK
argument_list|)
expr_stmt|;
name|SA_DBG3
argument_list|(
operator|(
literal|"saLocalPhyControl: TOP DEVICE LCLK Register value = %08X\n"
operator|,
name|value1
operator|)
argument_list|)
expr_stmt|;
comment|/* If LCLK_CLEAR bit set then disable it */
if|if
condition|(
name|value1
operator|&
name|DEVICE_LCLK_CLEAR
condition|)
block|{
name|ossaHwRegWriteExt
argument_list|(
name|agRoot
argument_list|,
name|PCIBAR2
argument_list|,
name|SPC_REG_DEVICE_LCLK
argument_list|,
operator|(
name|value1
operator|&
literal|0xFFFFFFBF
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG3
argument_list|(
operator|(
literal|"saLocalPhyControl: TOP DEVICE LCLK value = %08X\n"
operator|,
operator|(
name|value1
operator|&
literal|0xFFFFFFBF
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|AGSA_RC_FAILURE
operator|==
name|siBar4Shift
argument_list|(
name|agRoot
argument_list|,
name|value
argument_list|)
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"saLocalPhyControl:Shift Bar4 to 0x%x failed\n"
operator|,
name|value
operator|)
argument_list|)
expr_stmt|;
name|phyId
operator|=
name|copyPhyId
expr_stmt|;
comment|/* call back with the status */
if|if
condition|(
name|agCB
operator|==
name|agNULL
condition|)
block|{
name|ossaLocalPhyControlCB
argument_list|(
name|agRoot
argument_list|,
name|agContext
argument_list|,
name|phyId
argument_list|,
name|phyOperation
argument_list|,
name|OSSA_FAILURE
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|errorParam
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|agCB
argument_list|(
name|agRoot
argument_list|,
name|agContext
argument_list|,
name|phyId
argument_list|,
name|phyOperation
argument_list|,
name|OSSA_FAILURE
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|errorParam
argument_list|)
expr_stmt|;
block|}
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'d'
argument_list|,
literal|"7d"
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_FAILURE
return|;
block|}
comment|/* set LCLK = 1 and LCLK_CLEAR = 0 */
name|SPC_WRITE_COUNTER_CNTL
argument_list|(
name|phyId
argument_list|,
name|LCLK
argument_list|)
expr_stmt|;
comment|/* LCLK bit should be low to be able to read error registers */
while|while
condition|(
operator|(
name|value
operator|=
name|SPC_READ_COUNTER_CNTL
argument_list|(
name|phyId
argument_list|)
operator|)
operator|&
name|LCLK
condition|)
block|{
if|if
condition|(
operator|--
name|count
operator|==
literal|0
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"saLocalPhyControl: Timeout,SPC_COUNTER_CNTL value = %08X\n"
operator|,
name|value
operator|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|AGSA_RC_FAILURE
expr_stmt|;
break|break;
block|}
block|}
comment|/* while */
name|value
operator|=
name|SPC_READ_COUNTER_CNTL
argument_list|(
name|phyId
argument_list|)
expr_stmt|;
name|SA_DBG3
argument_list|(
operator|(
literal|"saLocalPhyControl: SPC_COUNTER_CNTL value = %08X\n"
operator|,
name|value
operator|)
argument_list|)
expr_stmt|;
comment|/* invalidDword */
name|errorParam
operator|.
name|invalidDword
operator|=
name|SPC_READ_INV_DW_COUNT
argument_list|(
name|phyId
argument_list|)
expr_stmt|;
comment|/* runningDisparityError */
name|errorParam
operator|.
name|runningDisparityError
operator|=
name|SPC_READ_DISP_ERR_COUNT
argument_list|(
name|phyId
argument_list|)
expr_stmt|;
comment|/* lossOfDwordSynch */
name|errorParam
operator|.
name|lossOfDwordSynch
operator|=
name|SPC_READ_LOSS_DW_COUNT
argument_list|(
name|phyId
argument_list|)
expr_stmt|;
comment|/* phyResetProblem */
name|errorParam
operator|.
name|phyResetProblem
operator|=
name|SPC_READ_PHY_RESET_COUNT
argument_list|(
name|phyId
argument_list|)
expr_stmt|;
comment|/* codeViolation */
name|errorParam
operator|.
name|codeViolation
operator|=
name|SPC_READ_CODE_VIO_COUNT
argument_list|(
name|phyId
argument_list|)
expr_stmt|;
comment|/* never occurred in SPC8x6G */
name|errorParam
operator|.
name|elasticityBufferOverflow
operator|=
literal|0
expr_stmt|;
name|errorParam
operator|.
name|receivedErrorPrimitive
operator|=
literal|0
expr_stmt|;
name|errorParam
operator|.
name|inboundCRCError
operator|=
literal|0
expr_stmt|;
name|SA_DBG3
argument_list|(
operator|(
literal|"saLocalPhyControl:INV_DW_COUNT         0x%x\n"
operator|,
name|SPC_READ_INV_DW_COUNT
argument_list|(
name|phyId
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG3
argument_list|(
operator|(
literal|"saLocalPhyControl:DISP_ERR_COUNT       0x%x\n"
operator|,
name|SPC_READ_DISP_ERR_COUNT
argument_list|(
name|phyId
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG3
argument_list|(
operator|(
literal|"saLocalPhyControl:LOSS_DW_COUNT        0x%x\n"
operator|,
name|SPC_READ_LOSS_DW_COUNT
argument_list|(
name|phyId
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG3
argument_list|(
operator|(
literal|"saLocalPhyControl:PHY_RESET_COUNT      0x%x\n"
operator|,
name|SPC_READ_PHY_RESET_COUNT
argument_list|(
name|phyId
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG3
argument_list|(
operator|(
literal|"saLocalPhyControl:CODE_VIOLATION_COUNT 0x%x\n"
operator|,
name|SPC_READ_CODE_VIO_COUNT
argument_list|(
name|phyId
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* Shift back to BAR4 original address */
if|if
condition|(
name|AGSA_RC_FAILURE
operator|==
name|siBar4Shift
argument_list|(
name|agRoot
argument_list|,
literal|0x0
argument_list|)
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"saLocalPhyControl:Shift Bar4 to 0x%x failed\n"
operator|,
literal|0x0
operator|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|AGSA_RC_FAILURE
expr_stmt|;
block|}
comment|/* restore back the Top Device LCLK generation register value */
name|ossaHwRegWriteExt
argument_list|(
name|agRoot
argument_list|,
name|PCIBAR2
argument_list|,
name|SPC_REG_DEVICE_LCLK
argument_list|,
name|value1
argument_list|)
expr_stmt|;
comment|/* restore phyId */
name|phyId
operator|=
name|copyPhyId
expr_stmt|;
comment|/* call back with the status */
if|if
condition|(
name|AGSA_RC_SUCCESS
operator|==
name|ret
condition|)
block|{
if|if
condition|(
name|agCB
operator|==
name|agNULL
condition|)
block|{
name|ossaLocalPhyControlCB
argument_list|(
name|agRoot
argument_list|,
name|agContext
argument_list|,
name|copyPhyId
argument_list|,
name|phyOperation
argument_list|,
name|OSSA_SUCCESS
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|errorParam
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|agCB
argument_list|(
name|agRoot
argument_list|,
name|agContext
argument_list|,
name|copyPhyId
argument_list|,
name|phyOperation
argument_list|,
name|OSSA_SUCCESS
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|errorParam
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|agCB
operator|==
name|agNULL
condition|)
block|{
name|ossaLocalPhyControlCB
argument_list|(
name|agRoot
argument_list|,
name|agContext
argument_list|,
name|phyId
argument_list|,
name|phyOperation
argument_list|,
name|OSSA_FAILURE
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|errorParam
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|agCB
argument_list|(
name|agRoot
argument_list|,
name|agContext
argument_list|,
name|phyId
argument_list|,
name|phyOperation
argument_list|,
name|OSSA_FAILURE
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|errorParam
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
case|case
name|AGSA_PHY_CLEAR_ERROR_COUNTS
case|:
block|{
if|if
condition|(
name|smIS_SPCV
argument_list|(
name|agRoot
argument_list|)
condition|)
block|{
name|SA_ASSERT
argument_list|(
operator|(
name|smIS_SPC
argument_list|(
name|agRoot
argument_list|)
operator|)
argument_list|,
literal|"SPC only"
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saLocalPhyControl: V AGSA_PHY_CLEAR_ERROR_COUNTS\n"
operator|)
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'e'
argument_list|,
literal|"7d"
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_FAILURE
return|;
block|}
comment|/* If phyId is invalid, return failure */
if|if
condition|(
name|phyId
operator|>=
name|saRoot
operator|->
name|phyCount
condition|)
block|{
name|si_memset
argument_list|(
operator|&
name|errorParam
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|agsaPhyErrCountersPage_t
argument_list|)
argument_list|)
expr_stmt|;
name|SA_DBG3
argument_list|(
operator|(
literal|"saLocalPhyControl(CLEAR): phy%d - failure with phyId\n"
operator|,
name|phyId
operator|)
argument_list|)
expr_stmt|;
comment|/* call back with the status */
if|if
condition|(
name|agCB
operator|==
name|agNULL
condition|)
block|{
name|ossaLocalPhyControlCB
argument_list|(
name|agRoot
argument_list|,
name|agContext
argument_list|,
name|phyId
argument_list|,
name|phyOperation
argument_list|,
name|OSSA_FAILURE
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|errorParam
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|agCB
argument_list|(
name|agRoot
argument_list|,
name|agContext
argument_list|,
name|phyId
argument_list|,
name|phyOperation
argument_list|,
name|OSSA_FAILURE
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|errorParam
argument_list|)
expr_stmt|;
block|}
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'f'
argument_list|,
literal|"7d"
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_FAILURE
return|;
block|}
comment|/* save phyId */
name|copyPhyId
operator|=
name|phyId
expr_stmt|;
comment|/* map 0x030000 or 0x040000 based on phyId to BAR4(0x20), BAT2(win) to access the register  */
if|if
condition|(
name|phyId
operator|<
literal|4
condition|)
block|{
comment|/* for phyId = 0, 1, 2, 3 */
name|value
operator|=
literal|0x030000
expr_stmt|;
block|}
else|else
block|{
comment|/* for phyId = 4, 5, 6, 7 */
name|phyId
operator|=
name|phyId
operator|-
literal|4
expr_stmt|;
name|value
operator|=
literal|0x040000
expr_stmt|;
block|}
comment|/* Need to make sure DEVICE_LCLK_GENERATION register bit 6 is 1 */
name|value2
operator|=
name|ossaHwRegReadExt
argument_list|(
name|agRoot
argument_list|,
name|PCIBAR2
argument_list|,
name|SPC_REG_DEVICE_LCLK
argument_list|)
expr_stmt|;
name|SA_DBG3
argument_list|(
operator|(
literal|"saLocalPhyControl: TOP DEVICE LCLK Register value = %08X\n"
operator|,
name|value2
operator|)
argument_list|)
expr_stmt|;
comment|/* If LCLK_CLEAR bit not set then set it */
if|if
condition|(
operator|(
name|value2
operator|&
name|DEVICE_LCLK_CLEAR
operator|)
operator|==
literal|0
condition|)
block|{
name|ossaHwRegWriteExt
argument_list|(
name|agRoot
argument_list|,
name|PCIBAR2
argument_list|,
name|SPC_REG_DEVICE_LCLK
argument_list|,
operator|(
name|value2
operator||
name|DEVICE_LCLK_CLEAR
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG3
argument_list|(
operator|(
literal|"saLocalPhyControl: TOP DEVICE LCLK value = %08X\n"
operator|,
operator|(
name|value2
operator|&
literal|0xFFFFFFBF
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|AGSA_RC_FAILURE
operator|==
name|siBar4Shift
argument_list|(
name|agRoot
argument_list|,
name|value
argument_list|)
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"saLocalPhyControl(CLEAR):Shift Bar4 to 0x%x failed\n"
operator|,
name|value
operator|)
argument_list|)
expr_stmt|;
name|phyId
operator|=
name|copyPhyId
expr_stmt|;
comment|/* call back with the status */
if|if
condition|(
name|agCB
operator|==
name|agNULL
condition|)
block|{
name|ossaLocalPhyControlCB
argument_list|(
name|agRoot
argument_list|,
name|agContext
argument_list|,
name|phyId
argument_list|,
name|phyOperation
argument_list|,
name|OSSA_FAILURE
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|errorParam
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|agCB
argument_list|(
name|agRoot
argument_list|,
name|agContext
argument_list|,
name|phyId
argument_list|,
name|phyOperation
argument_list|,
name|OSSA_FAILURE
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|errorParam
argument_list|)
expr_stmt|;
block|}
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'g'
argument_list|,
literal|"7d"
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_FAILURE
return|;
block|}
comment|/* read Counter Control register */
name|value1
operator|=
name|SPC_READ_COUNTER_CNTL
argument_list|(
name|phyId
argument_list|)
expr_stmt|;
name|SA_DBG3
argument_list|(
operator|(
literal|"saLocalPhyControl(CLEAR): SPC_COUNTER_CNTL value = %08X\n"
operator|,
name|value1
operator|)
argument_list|)
expr_stmt|;
comment|/* set LCLK and LCLK_CLEAR */
name|SPC_WRITE_COUNTER_CNTL
argument_list|(
name|phyId
argument_list|,
operator|(
name|LCLK_CLEAR
operator||
name|LCLK
operator|)
argument_list|)
expr_stmt|;
comment|/* read back the value of register */
comment|/* poll LCLK bit = 0 */
while|while
condition|(
operator|(
name|value
operator|=
name|SPC_READ_COUNTER_CNTL
argument_list|(
name|phyId
argument_list|)
operator|)
operator|&
name|LCLK
condition|)
block|{
if|if
condition|(
operator|--
name|count
operator|==
literal|0
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"saLocalPhyControl: Timeout,SPC_COUNTER_CNTL value = %08X\n"
operator|,
name|value
operator|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|AGSA_RC_FAILURE
expr_stmt|;
break|break;
block|}
block|}
comment|/* while */
name|value
operator|=
name|SPC_READ_COUNTER_CNTL
argument_list|(
name|phyId
argument_list|)
expr_stmt|;
name|SA_DBG3
argument_list|(
operator|(
literal|"saLocalPhyControl(CLEAR): SPC_COUNTER_CNTL value = %08X\n"
operator|,
name|value
operator|)
argument_list|)
expr_stmt|;
comment|/* restore the value */
name|SPC_WRITE_COUNTER_CNTL
argument_list|(
name|phyId
argument_list|,
name|value1
argument_list|)
expr_stmt|;
comment|/* Shift back to BAR4 original address */
if|if
condition|(
name|AGSA_RC_FAILURE
operator|==
name|siBar4Shift
argument_list|(
name|agRoot
argument_list|,
literal|0x0
argument_list|)
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"saLocalPhyControl:Shift Bar4 to 0x%x failed\n"
operator|,
literal|0x0
operator|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|AGSA_RC_FAILURE
expr_stmt|;
block|}
comment|/* restore back the Top Device LCLK generation register value */
name|ossaHwRegWriteExt
argument_list|(
name|agRoot
argument_list|,
name|PCIBAR2
argument_list|,
name|SPC_REG_DEVICE_LCLK
argument_list|,
name|value2
argument_list|)
expr_stmt|;
comment|/* restore phyId */
name|phyId
operator|=
name|copyPhyId
expr_stmt|;
comment|/* call back with the status */
if|if
condition|(
name|AGSA_RC_SUCCESS
operator|==
name|ret
condition|)
block|{
if|if
condition|(
name|agCB
operator|==
name|agNULL
condition|)
block|{
name|ossaLocalPhyControlCB
argument_list|(
name|agRoot
argument_list|,
name|agContext
argument_list|,
name|phyId
argument_list|,
name|phyOperation
argument_list|,
name|OSSA_SUCCESS
argument_list|,
name|agNULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|agCB
argument_list|(
name|agRoot
argument_list|,
name|agContext
argument_list|,
name|phyId
argument_list|,
name|phyOperation
argument_list|,
name|OSSA_SUCCESS
argument_list|,
name|agNULL
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|agCB
operator|==
name|agNULL
condition|)
block|{
name|ossaLocalPhyControlCB
argument_list|(
name|agRoot
argument_list|,
name|agContext
argument_list|,
name|phyId
argument_list|,
name|phyOperation
argument_list|,
name|OSSA_FAILURE
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|errorParam
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|agCB
argument_list|(
name|agRoot
argument_list|,
name|agContext
argument_list|,
name|phyId
argument_list|,
name|phyOperation
argument_list|,
name|OSSA_FAILURE
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|errorParam
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
case|case
name|AGSA_PHY_GET_BW_COUNTS
case|:
block|{
name|SA_ASSERT
argument_list|(
operator|(
name|smIS_SPC
argument_list|(
name|agRoot
argument_list|)
operator|)
argument_list|,
literal|"SPCv only"
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saLocalPhyControl: AGSA_PHY_GET_BW_COUNTS\n"
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|ret
operator|=
name|AGSA_RC_FAILURE
expr_stmt|;
name|SA_ASSERT
argument_list|(
name|agFALSE
argument_list|,
literal|"(saLocalPhyControl) Unknown operation"
argument_list|)
expr_stmt|;
break|break;
block|}
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'h'
argument_list|,
literal|"7d"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|GLOBAL
name|bit32
name|saGetPhyProfile
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|agsaContext_t
modifier|*
name|agContext
parameter_list|,
name|bit32
name|queueNum
parameter_list|,
name|bit32
name|ppc
parameter_list|,
name|bit32
name|phyId
parameter_list|)
block|{
name|bit32
name|ret
init|=
name|AGSA_RC_SUCCESS
decl_stmt|;
name|agsaLLRoot_t
modifier|*
name|saRoot
init|=
name|agNULL
decl_stmt|;
name|agsaPhyErrCountersPage_t
name|errorParam
decl_stmt|;
name|ossaLocalPhyControlCB_t
name|agCB
init|=
name|ossaGetPhyProfileCB
decl_stmt|;
comment|/* sanity check */
name|SA_ASSERT
argument_list|(
operator|(
name|agNULL
operator|!=
name|agRoot
operator|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|saRoot
operator|=
operator|(
name|agsaLLRoot_t
operator|*
operator|)
operator|(
name|agRoot
operator|->
name|sdkData
operator|)
expr_stmt|;
name|SA_ASSERT
argument_list|(
operator|(
name|agNULL
operator|!=
name|saRoot
operator|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|saRoot
operator|==
name|agNULL
condition|)
block|{
name|SA_DBG3
argument_list|(
operator|(
literal|"saGetPhyProfile : saRoot is NULL"
operator|)
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_FAILURE
return|;
block|}
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetPhyProfile: ppc 0x%x phyID %d\n"
operator|,
name|ppc
operator|,
name|phyId
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ppc
condition|)
block|{
case|case
name|AGSA_SAS_PHY_ERR_COUNTERS_PAGE
case|:
block|{
if|if
condition|(
name|smIS_SPCV
argument_list|(
name|agRoot
argument_list|)
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetPhyProfile: V AGSA_SAS_PHY_ERR_COUNTERS_PAGE\n"
operator|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|mpiGetPhyProfileCmd
argument_list|(
name|agRoot
argument_list|,
name|agContext
argument_list|,
name|ppc
argument_list|,
name|phyId
argument_list|,
name|agCB
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'i'
argument_list|,
literal|"7d"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
block|}
case|case
name|AGSA_SAS_PHY_ERR_COUNTERS_CLR_PAGE
case|:
block|{
comment|/* If phyId is invalid, return failure */
if|if
condition|(
name|phyId
operator|>=
name|saRoot
operator|->
name|phyCount
condition|)
block|{
name|si_memset
argument_list|(
operator|&
name|errorParam
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|agsaPhyErrCountersPage_t
argument_list|)
argument_list|)
expr_stmt|;
name|SA_DBG3
argument_list|(
operator|(
literal|"saGetPhyProfile(CLEAR): phy%d - failure with phyId\n"
operator|,
name|phyId
operator|)
argument_list|)
expr_stmt|;
comment|/* call back with the status */
name|ossaGetPhyProfileCB
argument_list|(
name|agRoot
argument_list|,
name|agContext
argument_list|,
name|phyId
argument_list|,
name|ppc
argument_list|,
name|OSSA_FAILURE
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|errorParam
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'j'
argument_list|,
literal|"7d"
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_FAILURE
return|;
block|}
if|if
condition|(
name|smIS_SPCV
argument_list|(
name|agRoot
argument_list|)
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetPhyProfile: V AGSA_SAS_PHY_ERR_COUNTERS_CLR_PAGE\n"
operator|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|mpiGetPhyProfileCmd
argument_list|(
name|agRoot
argument_list|,
name|agContext
argument_list|,
name|ppc
argument_list|,
name|phyId
argument_list|,
name|agCB
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'k'
argument_list|,
literal|"7d"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
block|}
case|case
name|AGSA_SAS_PHY_BW_COUNTERS_PAGE
case|:
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetPhyProfile: AGSA_SAS_PHY_BW_COUNTERS_PAGE\n"
operator|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|mpiGetPhyProfileCmd
argument_list|(
name|agRoot
argument_list|,
name|agContext
argument_list|,
name|ppc
argument_list|,
name|phyId
argument_list|,
name|agCB
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|AGSA_SAS_PHY_ANALOG_SETTINGS_PAGE
case|:
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetPhyProfile: AGSA_SAS_PHY_ANALOG_SETTINGS_PAGE\n"
operator|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|mpiGetPhyProfileCmd
argument_list|(
name|agRoot
argument_list|,
name|agContext
argument_list|,
name|ppc
argument_list|,
name|phyId
argument_list|,
name|agCB
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|AGSA_SAS_PHY_GENERAL_STATUS_PAGE
case|:
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetPhyProfile: AGSA_SAS_PHY_GENERAL_STATUS_PAGE\n"
operator|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|mpiGetPhyProfileCmd
argument_list|(
name|agRoot
argument_list|,
name|agContext
argument_list|,
name|ppc
argument_list|,
name|phyId
argument_list|,
name|agCB
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|AGSA_PHY_SNW3_PAGE
case|:
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetPhyProfile: AGSA_PHY_SNW3_PAGE\n"
operator|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|mpiGetPhyProfileCmd
argument_list|(
name|agRoot
argument_list|,
name|agContext
argument_list|,
name|ppc
argument_list|,
name|phyId
argument_list|,
name|agCB
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|AGSA_PHY_RATE_CONTROL_PAGE
case|:
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetPhyProfile: AGSA_PHY_RATE_CONTROL_PAGE\n"
operator|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|mpiGetPhyProfileCmd
argument_list|(
name|agRoot
argument_list|,
name|agContext
argument_list|,
name|ppc
argument_list|,
name|phyId
argument_list|,
name|agCB
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|AGSA_SAS_PHY_OPEN_REJECT_RETRY_BACKOFF_THRESHOLD_PAGE
case|:
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetPhyProfile: AGSA_SAS_PHY_OPEN_REJECT_RETRY_BACKOFF_THRESHOLD_PAGE\n"
operator|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|mpiGetPhyProfileCmd
argument_list|(
name|agRoot
argument_list|,
name|agContext
argument_list|,
name|ppc
argument_list|,
name|phyId
argument_list|,
name|agCB
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetPhyProfile: Unknown operation 0x%X\n"
operator|,
name|ppc
operator|)
argument_list|)
expr_stmt|;
name|SA_ASSERT
argument_list|(
name|agFALSE
argument_list|,
literal|"saGetPhyProfile Unknown operation "
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
name|GLOBAL
name|bit32
name|saSetPhyProfile
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|agsaContext_t
modifier|*
name|agContext
parameter_list|,
name|bit32
name|queueNum
parameter_list|,
name|bit32
name|ppc
parameter_list|,
name|bit32
name|length
parameter_list|,
name|void
modifier|*
name|buffer
parameter_list|,
name|bit32
name|phyID
parameter_list|)
block|{
name|bit32
name|ret
init|=
name|AGSA_RC_SUCCESS
decl_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saSetPhyProfile: ppc 0x%x length 0x%x phyID %d\n"
operator|,
name|ppc
operator|,
name|length
operator|,
name|phyID
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ppc
condition|)
block|{
case|case
name|AGSA_SAS_PHY_ANALOG_SETTINGS_PAGE
case|:
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"saSetPhyProfile: AGSA_SAS_PHY_ANALOG_SETTINGS_PAGE\n"
operator|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|mpiSetPhyProfileCmd
argument_list|(
name|agRoot
argument_list|,
name|agContext
argument_list|,
name|ppc
argument_list|,
name|phyID
argument_list|,
name|length
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|AGSA_PHY_SNW3_PAGE
case|:
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"saSetPhyProfile: AGSA_PHY_SNW3_PAGE\n"
operator|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|mpiSetPhyProfileCmd
argument_list|(
name|agRoot
argument_list|,
name|agContext
argument_list|,
name|ppc
argument_list|,
name|phyID
argument_list|,
name|length
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|AGSA_PHY_RATE_CONTROL_PAGE
case|:
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"saSetPhyProfile: AGSA_PHY_RATE_CONTROL_PAGE\n"
operator|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|mpiSetPhyProfileCmd
argument_list|(
name|agRoot
argument_list|,
name|agContext
argument_list|,
name|ppc
argument_list|,
name|phyID
argument_list|,
name|length
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|AGSA_SAS_PHY_MISC_PAGE
case|:
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"saSetPhyProfile: AGSA_SAS_PHY_MISC_PAGE\n"
operator|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|mpiSetPhyProfileCmd
argument_list|(
name|agRoot
argument_list|,
name|agContext
argument_list|,
name|ppc
argument_list|,
name|phyID
argument_list|,
name|length
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|SA_DBG1
argument_list|(
operator|(
literal|"saSetPhyProfile: Unknown operation 0x%X\n"
operator|,
name|ppc
operator|)
argument_list|)
expr_stmt|;
name|SA_ASSERT
argument_list|(
name|agFALSE
argument_list|,
literal|"saSetPhyProfile Unknown operation "
argument_list|)
expr_stmt|;
name|ret
operator|=
name|AGSA_RC_FAILURE
expr_stmt|;
break|break;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*! \brief Initiate a HW Event Ack command  *  *  This function is called to initiate a HW Event Ack command to the SPC.  *  The completion of this function is reported in ossaHwEventAckCB().  *  *  \param agRoot      handles for this instance of SAS/SATA hardware  *  \param agContext   the context of this API  *  \param queueNum    queue number  *  \param eventSource point to the event source structure  *  \param param0  *  \param param1  *  *  \return  *          - none  */
end_comment

begin_comment
comment|/*******************************************************************************/
end_comment

begin_function
name|GLOBAL
name|bit32
name|saHwEventAck
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|agsaContext_t
modifier|*
name|agContext
parameter_list|,
name|bit32
name|queueNum
parameter_list|,
name|agsaEventSource_t
modifier|*
name|eventSource
parameter_list|,
name|bit32
name|param0
parameter_list|,
name|bit32
name|param1
parameter_list|)
block|{
name|agsaLLRoot_t
modifier|*
name|saRoot
init|=
operator|(
name|agsaLLRoot_t
operator|*
operator|)
operator|(
name|agRoot
operator|->
name|sdkData
operator|)
decl_stmt|;
name|agsaIORequestDesc_t
modifier|*
name|pRequest
decl_stmt|;
name|agsaPortContext_t
modifier|*
name|agPortContext
decl_stmt|;
name|agsaPort_t
modifier|*
name|pPort
init|=
name|agNULL
decl_stmt|;
name|agsaSASHwEventAckCmd_t
name|payload
decl_stmt|;
name|bit32
name|phyportid
decl_stmt|;
name|bit32
name|ret
init|=
name|AGSA_RC_SUCCESS
decl_stmt|;
name|bit32
name|using_reserved
init|=
name|agFALSE
decl_stmt|;
name|smTraceFuncEnter
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|"7e"
argument_list|)
expr_stmt|;
comment|/* sanity check */
name|SA_ASSERT
argument_list|(
operator|(
name|agNULL
operator|!=
name|saRoot
operator|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|saRoot
operator|==
name|agNULL
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"saHwEventAck: saRoot == agNULL\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|AGSA_RC_FAILURE
operator|)
return|;
block|}
name|SA_DBG2
argument_list|(
operator|(
literal|"saHwEventAck: agContext %p eventSource %p\n"
operator|,
name|agContext
operator|,
name|eventSource
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saHwEventAck: event 0x%x param0 0x%x param1 0x%x\n"
operator|,
name|eventSource
operator|->
name|event
operator|,
name|param0
operator|,
name|param1
operator|)
argument_list|)
expr_stmt|;
name|agPortContext
operator|=
name|eventSource
operator|->
name|agPortContext
expr_stmt|;
comment|/* Get request from free IORequests */
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|pRequest
operator|=
operator|(
name|agsaIORequestDesc_t
operator|*
operator|)
name|saLlistIOGetHead
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|)
expr_stmt|;
comment|/**/
comment|/* If no LL Control request entry available */
if|if
condition|(
name|agNULL
operator|==
name|pRequest
condition|)
block|{
name|pRequest
operator|=
operator|(
name|agsaIORequestDesc_t
operator|*
operator|)
name|saLlistIOGetHead
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeReservedRequests
operator|)
argument_list|)
expr_stmt|;
comment|/**/
if|if
condition|(
name|agNULL
operator|!=
name|pRequest
condition|)
block|{
name|using_reserved
operator|=
name|agTRUE
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saHwEventAck, using saRoot->freeReservedRequests\n"
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
comment|/* If no LL Control request entry available */
name|SA_DBG1
argument_list|(
operator|(
literal|"saHwEventAck, No request from free list Not using saRoot->freeReservedRequests\n"
operator|)
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'a'
argument_list|,
literal|"7e"
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_BUSY
return|;
block|}
block|}
if|if
condition|(
name|using_reserved
condition|)
block|{
name|saLlistIORemove
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeReservedRequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Remove the request from free list */
name|saLlistIORemove
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
block|}
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|SA_ASSERT
argument_list|(
operator|(
operator|!
name|pRequest
operator|->
name|valid
operator|)
argument_list|,
literal|"The pRequest is in use"
argument_list|)
expr_stmt|;
name|SA_DBG2
argument_list|(
operator|(
literal|"saHwEventAck: queueNum 0x%x HTag 0x%x\n"
operator|,
name|queueNum
operator|,
name|pRequest
operator|->
name|HTag
operator|)
argument_list|)
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|Tag
operator|=
name|pRequest
operator|->
name|HTag
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|IORequest
operator|=
operator|(
name|void
operator|*
operator|)
name|pRequest
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|agContext
operator|=
name|agContext
expr_stmt|;
name|pRequest
operator|->
name|valid
operator|=
name|agTRUE
expr_stmt|;
comment|/* build IOMB command and send to SPC */
comment|/* set payload to zeros */
name|si_memset
argument_list|(
operator|&
name|payload
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|agsaSASHwEventAckCmd_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* find port id */
if|if
condition|(
name|agPortContext
condition|)
block|{
name|pPort
operator|=
operator|(
name|agsaPort_t
operator|*
operator|)
operator|(
name|agPortContext
operator|->
name|sdkData
operator|)
expr_stmt|;
if|if
condition|(
name|pPort
condition|)
block|{
if|if
condition|(
name|eventSource
operator|->
name|event
operator|==
name|OSSA_HW_EVENT_PHY_DOWN
condition|)
block|{
name|pPort
operator|->
name|tobedeleted
operator|=
name|agTRUE
expr_stmt|;
block|}
name|SA_DBG3
argument_list|(
operator|(
literal|"saHwEventAck,pPort->portId %X\n"
operator|,
name|pPort
operator|->
name|portId
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|smIS_SPC
argument_list|(
name|agRoot
argument_list|)
condition|)
block|{
comment|/* fillup PORT_ID field */
name|phyportid
operator|=
name|pPort
operator|->
name|portId
operator|&
literal|0xF
expr_stmt|;
block|}
else|else
block|{
comment|/* fillup PORT_ID field */
name|phyportid
operator|=
name|pPort
operator|->
name|portId
operator|&
literal|0xFF
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/*  pPort is NULL - set PORT_ID to not intialized  */
if|if
condition|(
name|smIS_SPC
argument_list|(
name|agRoot
argument_list|)
condition|)
block|{
name|phyportid
operator|=
literal|0xF
expr_stmt|;
block|}
else|else
block|{
name|phyportid
operator|=
literal|0xFF
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* agPortContext is NULL - set PORT_ID to not intialized  */
if|if
condition|(
name|smIS_SPC
argument_list|(
name|agRoot
argument_list|)
condition|)
block|{
name|phyportid
operator|=
literal|0xF
expr_stmt|;
block|}
else|else
block|{
name|phyportid
operator|=
literal|0xFF
expr_stmt|;
block|}
block|}
name|pRequest
operator|->
name|pPort
operator|=
name|pPort
expr_stmt|;
name|SA_DBG3
argument_list|(
operator|(
literal|"saHwEventAck,eventSource->param 0x%X\n"
operator|,
name|eventSource
operator|->
name|param
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG3
argument_list|(
operator|(
literal|"saHwEventAck,eventSource->event 0x%X\n"
operator|,
name|eventSource
operator|->
name|event
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|smIS_SPC
argument_list|(
name|agRoot
argument_list|)
condition|)
block|{
comment|/* fillup up PHY_ID */
name|phyportid
operator||=
operator|(
operator|(
name|eventSource
operator|->
name|param
operator|&
literal|0x0000000F
operator|)
operator|<<
literal|4
operator|)
expr_stmt|;
comment|/* fillup SEA field */
name|phyportid
operator||=
operator|(
name|eventSource
operator|->
name|event
operator|&
literal|0x0000FFFF
operator|)
operator|<<
literal|8
expr_stmt|;
name|SA_DBG3
argument_list|(
operator|(
literal|"saHwEventAck: portId 0x%x phyId 0x%x SEA 0x%x\n"
operator|,
name|phyportid
operator|&
literal|0xF
operator|,
name|eventSource
operator|->
name|param
operator|&
literal|0x0000000F
operator|,
name|eventSource
operator|->
name|event
operator|&
literal|0x0000FFFF
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* fillup up PHY_ID */
name|phyportid
operator||=
operator|(
operator|(
name|eventSource
operator|->
name|param
operator|&
literal|0x000000FF
operator|)
operator|<<
name|SHIFT24
operator|)
expr_stmt|;
comment|/* fillup SEA field */
name|phyportid
operator||=
operator|(
name|eventSource
operator|->
name|event
operator|&
literal|0x00FFFFFF
operator|)
operator|<<
name|SHIFT8
expr_stmt|;
name|SA_DBG3
argument_list|(
operator|(
literal|"saHwEventAck: portId 0x%x phyId 0x%x SEA 0x%x\n"
operator|,
name|phyportid
operator|&
literal|0xFF
operator|,
name|eventSource
operator|->
name|param
operator|&
literal|0x0000000F
operator|,
name|eventSource
operator|->
name|event
operator|&
literal|0x0000FFFF
operator|)
argument_list|)
expr_stmt|;
block|}
name|pRequest
operator|->
name|HwAckType
operator|=
operator|(
name|bit16
operator|)
name|phyportid
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saHwEventAck,phyportid 0x%X HwAckType 0x%X\n"
operator|,
name|phyportid
operator|,
name|pRequest
operator|->
name|HwAckType
operator|)
argument_list|)
expr_stmt|;
comment|/* set tag */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSASHwEventAckCmd_t
argument_list|,
name|tag
argument_list|)
argument_list|,
name|pRequest
operator|->
name|HTag
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSASHwEventAckCmd_t
argument_list|,
name|sEaPhyIdPortId
argument_list|)
argument_list|,
name|phyportid
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSASHwEventAckCmd_t
argument_list|,
name|Param0
argument_list|)
argument_list|,
name|param0
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSASHwEventAckCmd_t
argument_list|,
name|Param1
argument_list|)
argument_list|,
name|param1
argument_list|)
expr_stmt|;
comment|/* build IOMB command and send to SPC */
if|if
condition|(
name|smIS_SPC
argument_list|(
name|agRoot
argument_list|)
condition|)
block|{
name|ret
operator|=
name|mpiBuildCmd
argument_list|(
name|agRoot
argument_list|,
operator|(
name|bit32
operator|*
operator|)
operator|&
name|payload
argument_list|,
name|MPI_CATEGORY_SAS_SATA
argument_list|,
name|OPC_INB_SPC_SAS_HW_EVENT_ACK
argument_list|,
name|IOMB_SIZE64
argument_list|,
name|queueNum
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|mpiBuildCmd
argument_list|(
name|agRoot
argument_list|,
operator|(
name|bit32
operator|*
operator|)
operator|&
name|payload
argument_list|,
name|MPI_CATEGORY_SAS_SATA
argument_list|,
name|OPC_INB_SAS_HW_EVENT_ACK
argument_list|,
name|IOMB_SIZE64
argument_list|,
name|queueNum
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|AGSA_RC_SUCCESS
operator|!=
name|ret
condition|)
block|{
comment|/* remove the request from IOMap */
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|Tag
operator|=
name|MARK_OFF
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|IORequest
operator|=
name|agNULL
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|agContext
operator|=
name|agNULL
expr_stmt|;
name|pRequest
operator|->
name|valid
operator|=
name|agFALSE
expr_stmt|;
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
comment|/* return the request to free pool */
if|if
condition|(
name|saLlistIOGetCount
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeReservedRequests
operator|)
argument_list|)
operator|<
name|SA_RESERVED_REQUEST_COUNT
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"saHwEventAck: saving pRequest (%p) for later use\n"
operator|,
name|pRequest
operator|)
argument_list|)
expr_stmt|;
name|saLlistIOAdd
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeReservedRequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* return the request to free pool */
name|saLlistIOAdd
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
block|}
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saHwEventAck, sending IOMB failed\n"
operator|)
argument_list|)
expr_stmt|;
block|}
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'b'
argument_list|,
literal|"7e"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|GLOBAL
name|bit32
name|saVhistCapture
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|agsaContext_t
modifier|*
name|agContext
parameter_list|,
name|bit32
name|queueNum
parameter_list|,
name|bit32
name|Channel
parameter_list|,
name|bit32
name|NumBitLo
parameter_list|,
name|bit32
name|NumBitHi
parameter_list|,
name|bit32
name|PcieAddrLo
parameter_list|,
name|bit32
name|PcieAddrHi
parameter_list|,
name|bit32
name|ByteCount
parameter_list|)
block|{
name|agsaLLRoot_t
modifier|*
name|saRoot
init|=
operator|(
name|agsaLLRoot_t
operator|*
operator|)
operator|(
name|agRoot
operator|->
name|sdkData
operator|)
decl_stmt|;
name|agsaIORequestDesc_t
modifier|*
name|pRequest
decl_stmt|;
name|bit32
name|ret
init|=
name|AGSA_RC_SUCCESS
decl_stmt|;
name|bit32
name|using_reserved
init|=
name|agFALSE
decl_stmt|;
name|smTraceFuncEnter
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|"3N"
argument_list|)
expr_stmt|;
comment|/* sanity check */
name|SA_ASSERT
argument_list|(
operator|(
name|agNULL
operator|!=
name|agRoot
operator|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saVhistCapture:Channel 0x%08X 0x%08X%08X 0x%08X%08X  count 0x%X\n"
operator|,
name|Channel
operator|,
name|NumBitHi
operator|,
name|NumBitLo
operator|,
name|PcieAddrHi
operator|,
name|PcieAddrLo
operator|,
name|ByteCount
operator|)
argument_list|)
expr_stmt|;
block|{
comment|/* Get request from free IORequests */
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|pRequest
operator|=
operator|(
name|agsaIORequestDesc_t
operator|*
operator|)
name|saLlistIOGetHead
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|)
expr_stmt|;
comment|/* */
comment|/* If no LL Control request entry available */
if|if
condition|(
name|agNULL
operator|==
name|pRequest
condition|)
block|{
name|pRequest
operator|=
operator|(
name|agsaIORequestDesc_t
operator|*
operator|)
name|saLlistIOGetHead
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeReservedRequests
operator|)
argument_list|)
expr_stmt|;
comment|/* If no LL Control request entry available */
if|if
condition|(
name|agNULL
operator|!=
name|pRequest
condition|)
block|{
name|using_reserved
operator|=
name|agTRUE
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|", using saRoot->freeReservedRequests\n"
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saVhistCapture: No request from free list Not using saRoot->freeReservedRequests\n"
operator|)
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'a'
argument_list|,
literal|"3N"
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_BUSY
return|;
block|}
block|}
name|SA_ASSERT
argument_list|(
operator|(
operator|!
name|pRequest
operator|->
name|valid
operator|)
argument_list|,
literal|"The pRequest is in use"
argument_list|)
expr_stmt|;
name|pRequest
operator|->
name|valid
operator|=
name|agTRUE
expr_stmt|;
comment|/* If LL Control request entry avaliable */
if|if
condition|(
name|using_reserved
condition|)
block|{
name|saLlistIORemove
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeReservedRequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Remove the request from free list */
name|saLlistIORemove
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
block|}
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|Tag
operator|=
name|pRequest
operator|->
name|HTag
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|IORequest
operator|=
operator|(
name|void
operator|*
operator|)
name|pRequest
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|agContext
operator|=
name|agContext
expr_stmt|;
name|pRequest
operator|->
name|valid
operator|=
name|agTRUE
expr_stmt|;
comment|/* Build the VhisCapture IOMB command and send to SPCv */
name|ret
operator|=
name|mpiVHistCapCmd
argument_list|(
name|agRoot
argument_list|,
name|agContext
argument_list|,
name|queueNum
argument_list|,
name|Channel
argument_list|,
name|NumBitLo
argument_list|,
name|NumBitHi
argument_list|,
name|PcieAddrLo
argument_list|,
name|PcieAddrHi
argument_list|,
name|ByteCount
argument_list|)
expr_stmt|;
if|if
condition|(
name|AGSA_RC_SUCCESS
operator|!=
name|ret
condition|)
block|{
comment|/* remove the request from IOMap */
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|Tag
operator|=
name|MARK_OFF
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|IORequest
operator|=
name|agNULL
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|agContext
operator|=
name|agNULL
expr_stmt|;
name|pRequest
operator|->
name|valid
operator|=
name|agFALSE
expr_stmt|;
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
comment|/* return the request to free pool */
if|if
condition|(
name|saLlistIOGetCount
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeReservedRequests
operator|)
argument_list|)
operator|<
name|SA_RESERVED_REQUEST_COUNT
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"saPhyStart: saving pRequest (%p) for later use\n"
operator|,
name|pRequest
operator|)
argument_list|)
expr_stmt|;
name|saLlistIOAdd
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeReservedRequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* return the request to free pool */
name|saLlistIOAdd
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
block|}
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saVhistCapture: sending IOMB failed\n"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'b'
argument_list|,
literal|"3N"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

end_unit

