begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************************* *Copyright (c) 2014 PMC-Sierra, Inc.  All rights reserved.  * *Redistribution and use in source and binary forms, with or without modification, are permitted provided  *that the following conditions are met:  *1. Redistributions of source code must retain the above copyright notice, this list of conditions and the *following disclaimer.  *2. Redistributions in binary form must reproduce the above copyright notice,  *this list of conditions and the following disclaimer in the documentation and/or other materials provided *with the distribution.  * *THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR IMPLIED  *WARRANTIES,INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS *FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE *FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  *NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR  *BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  *LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  *SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE  ********************************************************************************/
end_comment

begin_comment
comment|/*******************************************************************************/
end_comment

begin_comment
comment|/*! \file saport.c  *  \brief The file implements the functions to handle port  *  */
end_comment

begin_comment
comment|/******************************************************************************/
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<dev/pms/config.h>
end_include

begin_include
include|#
directive|include
file|<dev/pms/RefTisa/sallsdk/spc/saglobal.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SA_ENABLE_TRACE_FUNCTIONS
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|siTraceFileID
end_ifdef

begin_undef
undef|#
directive|undef
name|siTraceFileID
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|siTraceFileID
value|'L'
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|bit32
name|gFPGA_TEST
decl_stmt|;
end_decl_stmt

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*! \brief Add a SAS device to the discovery list of the port  *  *  Add a SAS device from the discovery list of the port  *  *  \param agRoot handles for this instance of SAS/SATA LLL  *  \param pPort  *  \param sasIdentify  *  \param sasInitiator  *  \param smpTimeout  *  \param itNexusTimeout  *  \param firstBurstSize  *  \param dTypeSRate -- device type and link rate  *  \param flag  *  *  \return -the device descriptor-  */
end_comment

begin_comment
comment|/*******************************************************************************/
end_comment

begin_function
name|GLOBAL
name|agsaDeviceDesc_t
modifier|*
name|siPortSASDeviceAdd
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|agsaPort_t
modifier|*
name|pPort
parameter_list|,
name|agsaSASIdentify_t
name|sasIdentify
parameter_list|,
name|bit32
name|sasInitiator
parameter_list|,
name|bit32
name|smpTimeout
parameter_list|,
name|bit32
name|itNexusTimeout
parameter_list|,
name|bit32
name|firstBurstSize
parameter_list|,
name|bit8
name|dTypeSRate
parameter_list|,
name|bit32
name|flag
parameter_list|)
block|{
name|agsaLLRoot_t
modifier|*
name|saRoot
init|=
operator|(
name|agsaLLRoot_t
operator|*
operator|)
operator|(
name|agRoot
operator|->
name|sdkData
operator|)
decl_stmt|;
name|agsaDeviceDesc_t
modifier|*
name|pDevice
decl_stmt|;
name|SA_DBG3
argument_list|(
operator|(
literal|"siPortSASDeviceAdd: start\n"
operator|)
argument_list|)
expr_stmt|;
name|smTraceFuncEnter
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|"23"
argument_list|)
expr_stmt|;
comment|/* sanity check */
name|SA_ASSERT
argument_list|(
operator|(
name|agNULL
operator|!=
name|agRoot
operator|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|SA_ASSERT
argument_list|(
operator|(
name|agNULL
operator|!=
name|pPort
operator|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* Acquire Device Lock */
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_DEVICE_LOCK
argument_list|)
expr_stmt|;
comment|/* Try to Allocate from device list */
name|pDevice
operator|=
operator|(
name|agsaDeviceDesc_t
operator|*
operator|)
name|saLlistGetHead
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeDevicesList
operator|)
argument_list|)
expr_stmt|;
comment|/* If device handle available */
if|if
condition|(
name|agNULL
operator|!=
name|pDevice
condition|)
block|{
name|int
name|i
decl_stmt|;
comment|/* Remove from free device list */
name|saLlistRemove
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeDevicesList
operator|)
argument_list|,
operator|&
operator|(
name|pDevice
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
comment|/* Initialize device descriptor */
if|if
condition|(
name|agTRUE
operator|==
name|sasInitiator
condition|)
block|{
name|pDevice
operator|->
name|initiatorDevHandle
operator|.
name|sdkData
operator|=
name|pDevice
expr_stmt|;
name|pDevice
operator|->
name|targetDevHandle
operator|.
name|sdkData
operator|=
name|agNULL
expr_stmt|;
block|}
else|else
block|{
name|pDevice
operator|->
name|initiatorDevHandle
operator|.
name|sdkData
operator|=
name|agNULL
expr_stmt|;
name|pDevice
operator|->
name|targetDevHandle
operator|.
name|sdkData
operator|=
name|pDevice
expr_stmt|;
block|}
name|pDevice
operator|->
name|initiatorDevHandle
operator|.
name|osData
operator|=
name|agNULL
expr_stmt|;
name|pDevice
operator|->
name|targetDevHandle
operator|.
name|osData
operator|=
name|agNULL
expr_stmt|;
comment|/* setup device type */
name|pDevice
operator|->
name|deviceType
operator|=
call|(
name|bit8
call|)
argument_list|(
operator|(
name|dTypeSRate
operator|&
literal|0x30
operator|)
operator|>>
name|SHIFT4
argument_list|)
expr_stmt|;
name|SA_DBG3
argument_list|(
operator|(
literal|"siPortSASDeviceAdd: Device Type 0x%x, Port Context %p\n"
operator|,
name|pDevice
operator|->
name|deviceType
operator|,
name|pPort
operator|)
argument_list|)
expr_stmt|;
name|pDevice
operator|->
name|pPort
operator|=
name|pPort
expr_stmt|;
name|saLlistInitialize
argument_list|(
operator|&
operator|(
name|pDevice
operator|->
name|pendingIORequests
operator|)
argument_list|)
expr_stmt|;
comment|/* setup sasDeviceInfo */
name|pDevice
operator|->
name|devInfo
operator|.
name|sasDeviceInfo
operator|.
name|commonDevInfo
operator|.
name|smpTimeout
operator|=
operator|(
name|bit16
operator|)
name|smpTimeout
expr_stmt|;
name|pDevice
operator|->
name|devInfo
operator|.
name|sasDeviceInfo
operator|.
name|commonDevInfo
operator|.
name|it_NexusTimeout
operator|=
operator|(
name|bit16
operator|)
name|itNexusTimeout
expr_stmt|;
name|pDevice
operator|->
name|devInfo
operator|.
name|sasDeviceInfo
operator|.
name|commonDevInfo
operator|.
name|firstBurstSize
operator|=
operator|(
name|bit16
operator|)
name|firstBurstSize
expr_stmt|;
name|pDevice
operator|->
name|devInfo
operator|.
name|sasDeviceInfo
operator|.
name|commonDevInfo
operator|.
name|devType_S_Rate
operator|=
name|dTypeSRate
expr_stmt|;
name|pDevice
operator|->
name|devInfo
operator|.
name|sasDeviceInfo
operator|.
name|commonDevInfo
operator|.
name|flag
operator|=
name|flag
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|pDevice
operator|->
name|devInfo
operator|.
name|sasDeviceInfo
operator|.
name|commonDevInfo
operator|.
name|sasAddressHi
index|[
name|i
index|]
operator|=
name|sasIdentify
operator|.
name|sasAddressHi
index|[
name|i
index|]
expr_stmt|;
name|pDevice
operator|->
name|devInfo
operator|.
name|sasDeviceInfo
operator|.
name|commonDevInfo
operator|.
name|sasAddressLo
index|[
name|i
index|]
operator|=
name|sasIdentify
operator|.
name|sasAddressLo
index|[
name|i
index|]
expr_stmt|;
block|}
name|pDevice
operator|->
name|devInfo
operator|.
name|sasDeviceInfo
operator|.
name|initiator_ssp_stp_smp
operator|=
name|sasIdentify
operator|.
name|initiator_ssp_stp_smp
expr_stmt|;
name|pDevice
operator|->
name|devInfo
operator|.
name|sasDeviceInfo
operator|.
name|target_ssp_stp_smp
operator|=
name|sasIdentify
operator|.
name|target_ssp_stp_smp
expr_stmt|;
name|pDevice
operator|->
name|devInfo
operator|.
name|sasDeviceInfo
operator|.
name|phyIdentifier
operator|=
name|sasIdentify
operator|.
name|phyIdentifier
expr_stmt|;
comment|/* Add to discoverd device for the port */
name|saLlistAdd
argument_list|(
operator|&
operator|(
name|pPort
operator|->
name|listSASATADevices
operator|)
argument_list|,
operator|&
operator|(
name|pDevice
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
comment|/* Release Device Lock */
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_DEVICE_LOCK
argument_list|)
expr_stmt|;
comment|/* Log Messages */
name|SA_DBG3
argument_list|(
operator|(
literal|"siPortSASDeviceAdd: sasIdentify addrHI 0x%x\n"
operator|,
name|SA_IDFRM_GET_SAS_ADDRESSHI
argument_list|(
operator|&
name|sasIdentify
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG3
argument_list|(
operator|(
literal|"siPortSASDeviceAdd: sasIdentify addrLO 0x%x\n"
operator|,
name|SA_IDFRM_GET_SAS_ADDRESSLO
argument_list|(
operator|&
name|sasIdentify
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Release Device Lock */
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_DEVICE_LOCK
argument_list|)
expr_stmt|;
name|SA_ASSERT
argument_list|(
operator|(
name|agNULL
operator|!=
name|pDevice
operator|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"siPortSASDeviceAdd: device allocation failed\n"
operator|)
argument_list|)
expr_stmt|;
block|}
name|SA_DBG3
argument_list|(
operator|(
literal|"siPortSASDeviceAdd: end\n"
operator|)
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'a'
argument_list|,
literal|"23"
argument_list|)
expr_stmt|;
return|return
name|pDevice
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*! \brief The function to remove a device descriptor  *  *  The function to remove a device descriptor  *  *  \param agRoot handles for this instance of SAS/SATA hardware  *  \param pPort  The pointer to the port  *  \param pDevice The pointer to the device  *  *  \return -void-  */
end_comment

begin_comment
comment|/*******************************************************************************/
end_comment

begin_function
name|GLOBAL
name|void
name|siPortDeviceRemove
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|agsaPort_t
modifier|*
name|pPort
parameter_list|,
name|agsaDeviceDesc_t
modifier|*
name|pDevice
parameter_list|,
name|bit32
name|unmap
parameter_list|)
block|{
name|agsaLLRoot_t
modifier|*
name|saRoot
init|=
operator|(
name|agsaLLRoot_t
operator|*
operator|)
operator|(
name|agRoot
operator|->
name|sdkData
operator|)
decl_stmt|;
name|bit32
name|deviceIdx
decl_stmt|;
name|smTraceFuncEnter
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|"24"
argument_list|)
expr_stmt|;
comment|/* sanity check */
name|SA_ASSERT
argument_list|(
operator|(
name|agNULL
operator|!=
name|agRoot
operator|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|SA_ASSERT
argument_list|(
operator|(
name|agNULL
operator|!=
name|pPort
operator|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|SA_ASSERT
argument_list|(
operator|(
name|agNULL
operator|!=
name|pDevice
operator|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|SA_ASSERT
argument_list|(
operator|(
name|SAS_SATA_UNKNOWN_DEVICE
operator|!=
name|pDevice
operator|->
name|deviceType
operator|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* remove the device from discovered list */
name|SA_DBG3
argument_list|(
operator|(
literal|"siPortDeviceRemove(SAS/SATA): DeviceIndex %d Device Context %p\n"
operator|,
name|pDevice
operator|->
name|DeviceMapIndex
operator|,
name|pDevice
operator|)
argument_list|)
expr_stmt|;
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_DEVICE_LOCK
argument_list|)
expr_stmt|;
name|saLlistRemove
argument_list|(
operator|&
operator|(
name|pPort
operator|->
name|listSASATADevices
operator|)
argument_list|,
operator|&
operator|(
name|pDevice
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
comment|/* Reset the device data structure */
name|pDevice
operator|->
name|pPort
operator|=
name|agNULL
expr_stmt|;
name|pDevice
operator|->
name|initiatorDevHandle
operator|.
name|osData
operator|=
name|agNULL
expr_stmt|;
name|pDevice
operator|->
name|initiatorDevHandle
operator|.
name|sdkData
operator|=
name|agNULL
expr_stmt|;
name|pDevice
operator|->
name|targetDevHandle
operator|.
name|osData
operator|=
name|agNULL
expr_stmt|;
name|pDevice
operator|->
name|targetDevHandle
operator|.
name|sdkData
operator|=
name|agNULL
expr_stmt|;
name|saLlistAdd
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeDevicesList
operator|)
argument_list|,
operator|&
operator|(
name|pDevice
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|unmap
condition|)
block|{
comment|/* remove the DeviceMap and MapIndex */
name|deviceIdx
operator|=
name|pDevice
operator|->
name|DeviceMapIndex
operator|&
name|DEVICE_ID_BITS
expr_stmt|;
name|OS_ASSERT
argument_list|(
name|deviceIdx
operator|<
name|MAX_IO_DEVICE_ENTRIES
argument_list|,
literal|"deviceIdx MAX_IO_DEVICE_ENTRIES"
argument_list|)
expr_stmt|;
name|saRoot
operator|->
name|DeviceMap
index|[
name|deviceIdx
index|]
operator|.
name|DeviceIdFromFW
operator|=
literal|0
expr_stmt|;
name|saRoot
operator|->
name|DeviceMap
index|[
name|deviceIdx
index|]
operator|.
name|DeviceHandle
operator|=
name|agNULL
expr_stmt|;
name|pDevice
operator|->
name|DeviceMapIndex
operator|=
literal|0
expr_stmt|;
block|}
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_DEVICE_LOCK
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'a'
argument_list|,
literal|"24"
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*! \brief Add a SATA device to the discovery list of the port  *  *  Add a SATA device from the discovery list of the port  *  *  \param agRoot handles for this instance of SAS/SATA hardware  *  \param pPort  *  \param pSTPBridge  *  \param pSignature  *  \param pm  *  \param pmField  *  \param smpReqTimeout  *  \param itNexusTimeout  *  \param firstBurstSize  *  \param dTypeSRate  *  *  \return -the device descriptor-  */
end_comment

begin_comment
comment|/*******************************************************************************/
end_comment

begin_function
name|GLOBAL
name|agsaDeviceDesc_t
modifier|*
name|siPortSATADeviceAdd
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|agsaPort_t
modifier|*
name|pPort
parameter_list|,
name|agsaDeviceDesc_t
modifier|*
name|pSTPBridge
parameter_list|,
name|bit8
modifier|*
name|pSignature
parameter_list|,
name|bit8
name|pm
parameter_list|,
name|bit8
name|pmField
parameter_list|,
name|bit32
name|smpReqTimeout
parameter_list|,
name|bit32
name|itNexusTimeout
parameter_list|,
name|bit32
name|firstBurstSize
parameter_list|,
name|bit8
name|dTypeSRate
parameter_list|,
name|bit32
name|flag
parameter_list|)
block|{
name|agsaLLRoot_t
modifier|*
name|saRoot
init|=
operator|(
name|agsaLLRoot_t
operator|*
operator|)
operator|(
name|agRoot
operator|->
name|sdkData
operator|)
decl_stmt|;
name|agsaDeviceDesc_t
modifier|*
name|pDevice
decl_stmt|;
name|smTraceFuncEnter
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|"25"
argument_list|)
expr_stmt|;
comment|/* sanity check */
name|SA_ASSERT
argument_list|(
operator|(
name|agNULL
operator|!=
name|agRoot
operator|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|SA_ASSERT
argument_list|(
operator|(
name|agNULL
operator|!=
name|pPort
operator|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* Acquire Device Lock */
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_DEVICE_LOCK
argument_list|)
expr_stmt|;
comment|/* Try to Allocate from device list */
name|pDevice
operator|=
operator|(
name|agsaDeviceDesc_t
operator|*
operator|)
name|saLlistGetHead
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeDevicesList
operator|)
argument_list|)
expr_stmt|;
comment|/* If device handle available */
if|if
condition|(
name|agNULL
operator|!=
name|pDevice
condition|)
block|{
name|int
name|i
decl_stmt|;
comment|/* Remove from free device list */
name|saLlistRemove
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeDevicesList
operator|)
argument_list|,
operator|&
operator|(
name|pDevice
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
comment|/* Initialize the device descriptor */
name|pDevice
operator|->
name|initiatorDevHandle
operator|.
name|sdkData
operator|=
name|agNULL
expr_stmt|;
name|pDevice
operator|->
name|targetDevHandle
operator|.
name|sdkData
operator|=
name|pDevice
expr_stmt|;
name|pDevice
operator|->
name|initiatorDevHandle
operator|.
name|osData
operator|=
name|agNULL
expr_stmt|;
name|pDevice
operator|->
name|targetDevHandle
operator|.
name|osData
operator|=
name|agNULL
expr_stmt|;
name|pDevice
operator|->
name|deviceType
operator|=
call|(
name|bit8
call|)
argument_list|(
operator|(
name|dTypeSRate
operator|&
literal|0x30
operator|)
operator|>>
name|SHIFT4
argument_list|)
expr_stmt|;
name|SA_DBG3
argument_list|(
operator|(
literal|"siPortSATADeviceAdd: DeviceType 0x%x Port Context %p\n"
operator|,
name|pDevice
operator|->
name|deviceType
operator|,
name|pPort
operator|)
argument_list|)
expr_stmt|;
comment|/* setup device common infomation */
name|pDevice
operator|->
name|devInfo
operator|.
name|sataDeviceInfo
operator|.
name|commonDevInfo
operator|.
name|smpTimeout
operator|=
operator|(
name|bit16
operator|)
name|smpReqTimeout
expr_stmt|;
name|pDevice
operator|->
name|devInfo
operator|.
name|sataDeviceInfo
operator|.
name|commonDevInfo
operator|.
name|it_NexusTimeout
operator|=
operator|(
name|bit16
operator|)
name|itNexusTimeout
expr_stmt|;
name|pDevice
operator|->
name|devInfo
operator|.
name|sataDeviceInfo
operator|.
name|commonDevInfo
operator|.
name|firstBurstSize
operator|=
operator|(
name|bit16
operator|)
name|firstBurstSize
expr_stmt|;
name|pDevice
operator|->
name|devInfo
operator|.
name|sataDeviceInfo
operator|.
name|commonDevInfo
operator|.
name|devType_S_Rate
operator|=
name|dTypeSRate
expr_stmt|;
name|pDevice
operator|->
name|devInfo
operator|.
name|sataDeviceInfo
operator|.
name|commonDevInfo
operator|.
name|flag
operator|=
name|flag
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|pDevice
operator|->
name|devInfo
operator|.
name|sataDeviceInfo
operator|.
name|commonDevInfo
operator|.
name|sasAddressHi
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|pDevice
operator|->
name|devInfo
operator|.
name|sataDeviceInfo
operator|.
name|commonDevInfo
operator|.
name|sasAddressLo
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/* setup SATA device information */
name|pDevice
operator|->
name|devInfo
operator|.
name|sataDeviceInfo
operator|.
name|connection
operator|=
name|pm
expr_stmt|;
name|pDevice
operator|->
name|devInfo
operator|.
name|sataDeviceInfo
operator|.
name|portMultiplierField
operator|=
name|pmField
expr_stmt|;
name|pDevice
operator|->
name|devInfo
operator|.
name|sataDeviceInfo
operator|.
name|stpPhyIdentifier
operator|=
literal|0
expr_stmt|;
name|pDevice
operator|->
name|pPort
operator|=
name|pPort
expr_stmt|;
comment|/* Add to discoverd device for the port */
name|saLlistAdd
argument_list|(
operator|&
operator|(
name|pPort
operator|->
name|listSASATADevices
operator|)
argument_list|,
operator|&
operator|(
name|pDevice
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
comment|/* Release Device Lock */
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_DEVICE_LOCK
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Release Device Lock */
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_DEVICE_LOCK
argument_list|)
expr_stmt|;
name|SA_ASSERT
argument_list|(
operator|(
name|agNULL
operator|!=
name|pDevice
operator|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"siPortSATADeviceAdd: device allocation failed\n"
operator|)
argument_list|)
expr_stmt|;
block|}
name|SA_DBG3
argument_list|(
operator|(
literal|"siPortSATADeviceAdd: end\n"
operator|)
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'a'
argument_list|,
literal|"25"
argument_list|)
expr_stmt|;
return|return
name|pDevice
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*! \brief Invalid a port  *  *  Invalid a port  *  *  \param agRoot handles for this instance of SAS/SATA hardware  *  \param pPort  *  *  \return -void-  */
end_comment

begin_comment
comment|/*******************************************************************************/
end_comment

begin_function
name|GLOBAL
name|void
name|siPortInvalid
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|agsaPort_t
modifier|*
name|pPort
parameter_list|)
block|{
name|agsaLLRoot_t
modifier|*
name|saRoot
init|=
operator|(
name|agsaLLRoot_t
operator|*
operator|)
operator|(
name|agRoot
operator|->
name|sdkData
operator|)
decl_stmt|;
name|smTraceFuncEnter
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|"26"
argument_list|)
expr_stmt|;
comment|/* sanity check */
name|SA_ASSERT
argument_list|(
operator|(
name|agNULL
operator|!=
name|agRoot
operator|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|SA_ASSERT
argument_list|(
operator|(
name|agNULL
operator|!=
name|pPort
operator|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* set port's status to invalidating */
name|pPort
operator|->
name|status
operator||=
name|PORT_INVALIDATING
expr_stmt|;
comment|/* Remove from validPort and add the port back to the free port link list */
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_PORT_LOCK
argument_list|)
expr_stmt|;
name|saLlistRemove
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|validPorts
operator|)
argument_list|,
operator|&
operator|(
name|pPort
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
name|saLlistAdd
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freePorts
operator|)
argument_list|,
operator|&
operator|(
name|pPort
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
name|pPort
operator|->
name|tobedeleted
operator|=
name|agFALSE
expr_stmt|;
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_PORT_LOCK
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'a'
argument_list|,
literal|"26"
argument_list|)
expr_stmt|;
comment|/* return */
block|}
end_function

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*! \brief The function to remove a device descriptor  *  *  The function to remove a device descriptor  *  *  \param agRoot handles for this instance of SAS/SATA hardware  *  \param pPort  The pointer to the port  *  \param pDevice The pointer to the device  *  *  \return -void-  */
end_comment

begin_comment
comment|/*******************************************************************************/
end_comment

begin_function
name|GLOBAL
name|void
name|siPortDeviceListRemove
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|agsaPort_t
modifier|*
name|pPort
parameter_list|,
name|agsaDeviceDesc_t
modifier|*
name|pDevice
parameter_list|)
block|{
name|agsaLLRoot_t
modifier|*
name|saRoot
init|=
operator|(
name|agsaLLRoot_t
operator|*
operator|)
operator|(
name|agRoot
operator|->
name|sdkData
operator|)
decl_stmt|;
name|smTraceFuncEnter
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|"27"
argument_list|)
expr_stmt|;
comment|/* sanity check */
name|SA_ASSERT
argument_list|(
operator|(
name|agNULL
operator|!=
name|agRoot
operator|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|SA_ASSERT
argument_list|(
operator|(
name|agNULL
operator|!=
name|pPort
operator|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|SA_ASSERT
argument_list|(
operator|(
name|agNULL
operator|!=
name|pDevice
operator|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|SA_ASSERT
argument_list|(
operator|(
name|SAS_SATA_UNKNOWN_DEVICE
operator|!=
name|pDevice
operator|->
name|deviceType
operator|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* remove the device from discovered list */
name|SA_DBG3
argument_list|(
operator|(
literal|"siPortDeviceListRemove(SAS/SATA): PortID %d Device Context %p\n"
operator|,
name|pPort
operator|->
name|portId
operator|,
name|pDevice
operator|)
argument_list|)
expr_stmt|;
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_DEVICE_LOCK
argument_list|)
expr_stmt|;
name|saLlistRemove
argument_list|(
operator|&
operator|(
name|pPort
operator|->
name|listSASATADevices
operator|)
argument_list|,
operator|&
operator|(
name|pDevice
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
comment|/* Reset the device data structure */
name|pDevice
operator|->
name|pPort
operator|=
name|agNULL
expr_stmt|;
name|pDevice
operator|->
name|initiatorDevHandle
operator|.
name|osData
operator|=
name|agNULL
expr_stmt|;
name|pDevice
operator|->
name|initiatorDevHandle
operator|.
name|sdkData
operator|=
name|agNULL
expr_stmt|;
name|pDevice
operator|->
name|targetDevHandle
operator|.
name|osData
operator|=
name|agNULL
expr_stmt|;
name|pDevice
operator|->
name|targetDevHandle
operator|.
name|sdkData
operator|=
name|agNULL
expr_stmt|;
name|saLlistAdd
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeDevicesList
operator|)
argument_list|,
operator|&
operator|(
name|pDevice
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_DEVICE_LOCK
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'a'
argument_list|,
literal|"27"
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*! \brief Initiate a Port COntrol IOMB command  *  *  This function is called to initiate a Port COntrol command to the SPC.  *  The completion of this function is reported in ossaPortControlCB().  *  *  \param agRoot        handles for this instance of SAS/SATA hardware  *  \param agContext     the context of this API  *  \param queueNum      queue number  *  \param agPortContext point to the event source structure  *  \param param0        parameter 0  *  \param param1        parameter 1  *  *  \return - successful or failure  */
end_comment

begin_comment
comment|/*******************************************************************************/
end_comment

begin_function
name|GLOBAL
name|bit32
name|saPortControl
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|agsaContext_t
modifier|*
name|agContext
parameter_list|,
name|bit32
name|queueNum
parameter_list|,
name|agsaPortContext_t
modifier|*
name|agPortContext
parameter_list|,
name|bit32
name|portOperation
parameter_list|,
name|bit32
name|param0
parameter_list|,
name|bit32
name|param1
parameter_list|)
block|{
name|agsaLLRoot_t
modifier|*
name|saRoot
init|=
operator|(
name|agsaLLRoot_t
operator|*
operator|)
operator|(
name|agRoot
operator|->
name|sdkData
operator|)
decl_stmt|;
name|agsaIORequestDesc_t
modifier|*
name|pRequest
decl_stmt|;
name|agsaPort_t
modifier|*
name|pPort
decl_stmt|;
name|bit32
name|ret
init|=
name|AGSA_RC_SUCCESS
decl_stmt|;
name|bit32
name|opportId
decl_stmt|;
name|agsaPortControlCmd_t
name|payload
decl_stmt|;
name|bit32
name|using_reserved
init|=
name|agFALSE
decl_stmt|;
comment|/* sanity check */
name|SA_ASSERT
argument_list|(
operator|(
name|agNULL
operator|!=
name|saRoot
operator|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|SA_ASSERT
argument_list|(
operator|(
name|agNULL
operator|!=
name|agPortContext
operator|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|saRoot
operator|==
name|agNULL
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"saPortControl: saRoot == agNULL\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|AGSA_RC_FAILURE
operator|)
return|;
block|}
name|smTraceFuncEnter
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|"28"
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saPortControl: portContext %p portOperation 0x%x param0 0x%x param1 0x%x\n"
operator|,
name|agPortContext
operator|,
name|portOperation
operator|,
name|param0
operator|,
name|param1
operator|)
argument_list|)
expr_stmt|;
comment|/* Get request from free IORequests */
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|pRequest
operator|=
operator|(
name|agsaIORequestDesc_t
operator|*
operator|)
name|saLlistIOGetHead
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|)
expr_stmt|;
comment|/**/
comment|/* If no LL Control request entry available */
if|if
condition|(
name|agNULL
operator|==
name|pRequest
condition|)
block|{
name|pRequest
operator|=
operator|(
name|agsaIORequestDesc_t
operator|*
operator|)
name|saLlistIOGetHead
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeReservedRequests
operator|)
argument_list|)
expr_stmt|;
comment|/* If no LL Control request entry available */
if|if
condition|(
name|agNULL
operator|!=
name|pRequest
condition|)
block|{
name|using_reserved
operator|=
name|agTRUE
expr_stmt|;
name|SA_DBG2
argument_list|(
operator|(
literal|"saPortControl, using saRoot->freeReservedRequests\n"
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saPortControl, No request from free list Not using saRoot->freeReservedRequests\n"
operator|)
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'a'
argument_list|,
literal|"28"
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_BUSY
return|;
block|}
block|}
comment|/* If LL Control request entry avaliable */
if|if
condition|(
name|using_reserved
condition|)
block|{
name|saLlistIORemove
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeReservedRequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Remove the request from free list */
name|saLlistIORemove
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
block|}
name|SA_ASSERT
argument_list|(
operator|(
operator|!
name|pRequest
operator|->
name|valid
operator|)
argument_list|,
literal|"The pRequest is in use"
argument_list|)
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|Tag
operator|=
name|pRequest
operator|->
name|HTag
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|IORequest
operator|=
operator|(
name|void
operator|*
operator|)
name|pRequest
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|agContext
operator|=
name|agContext
expr_stmt|;
name|pRequest
operator|->
name|valid
operator|=
name|agTRUE
expr_stmt|;
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
comment|/* build IOMB command and send to SPC */
comment|/* set payload to zeros */
name|si_memset
argument_list|(
operator|&
name|payload
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|agsaPortControlCmd_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* find port id */
name|pPort
operator|=
operator|(
name|agsaPort_t
operator|*
operator|)
operator|(
name|agPortContext
operator|->
name|sdkData
operator|)
expr_stmt|;
name|opportId
operator|=
operator|(
name|pPort
operator|->
name|portId
operator|&
name|PORTID_MASK
operator|)
operator||
operator|(
name|portOperation
operator|<<
name|SHIFT8
operator|)
expr_stmt|;
comment|/* set tag */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaPortControlCmd_t
argument_list|,
name|tag
argument_list|)
argument_list|,
name|pRequest
operator|->
name|HTag
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaPortControlCmd_t
argument_list|,
name|portOPPortId
argument_list|)
argument_list|,
name|opportId
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaPortControlCmd_t
argument_list|,
name|Param0
argument_list|)
argument_list|,
name|param0
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaPortControlCmd_t
argument_list|,
name|Param1
argument_list|)
argument_list|,
name|param1
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saPortControl: portId 0x%x portOperation 0x%x\n"
operator|,
operator|(
name|pPort
operator|->
name|portId
operator|&
name|PORTID_MASK
operator|)
operator|,
name|portOperation
operator|)
argument_list|)
expr_stmt|;
comment|/* build IOMB command and send to SPC */
name|ret
operator|=
name|mpiBuildCmd
argument_list|(
name|agRoot
argument_list|,
operator|(
name|bit32
operator|*
operator|)
operator|&
name|payload
argument_list|,
name|MPI_CATEGORY_SAS_SATA
argument_list|,
name|OPC_INB_PORT_CONTROL
argument_list|,
name|IOMB_SIZE64
argument_list|,
name|queueNum
argument_list|)
expr_stmt|;
if|if
condition|(
name|AGSA_RC_SUCCESS
operator|!=
name|ret
condition|)
block|{
comment|/* remove the request from IOMap */
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|Tag
operator|=
name|MARK_OFF
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|IORequest
operator|=
name|agNULL
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|agContext
operator|=
name|agNULL
expr_stmt|;
name|pRequest
operator|->
name|valid
operator|=
name|agFALSE
expr_stmt|;
comment|/* return the request to free pool */
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
if|if
condition|(
name|saLlistIOGetCount
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeReservedRequests
operator|)
argument_list|)
operator|<
name|SA_RESERVED_REQUEST_COUNT
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"saPortControl: saving pRequest (%p) for later use\n"
operator|,
name|pRequest
operator|)
argument_list|)
expr_stmt|;
name|saLlistIOAdd
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeReservedRequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* return the request to free pool */
name|saLlistIOAdd
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
block|}
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saPortControl, sending IOMB failed\n"
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|portOperation
operator|==
name|AGSA_PORT_HARD_RESET
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"saPortControl,0x%x AGSA_PORT_HARD_RESET 0x%x param0 0x%x\n"
operator|,
name|pPort
operator|->
name|portId
operator|,
name|param0
operator|,
name|param0
operator|&
name|AUTO_HARD_RESET_DEREG_FLAG
operator|)
argument_list|)
expr_stmt|;
name|saRoot
operator|->
name|autoDeregDeviceflag
index|[
name|pPort
operator|->
name|portId
operator|&
name|PORTID_MASK
index|]
operator|=
name|param0
operator|&
name|AUTO_HARD_RESET_DEREG_FLAG
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|portOperation
operator|==
name|AGSA_PORT_CLEAN_UP
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"saPortControl, 0x%x AGSA_PORT_CLEAN_UP param0 0x%x %d\n"
operator|,
name|pPort
operator|->
name|portId
operator|,
name|param0
operator|,
operator|(
operator|(
name|param0
operator|&
name|AUTO_FW_CLEANUP_DEREG_FLAG
operator|)
condition|?
literal|0
else|:
literal|1
operator|)
operator|)
argument_list|)
expr_stmt|;
name|saRoot
operator|->
name|autoDeregDeviceflag
index|[
name|pPort
operator|->
name|portId
operator|&
name|PORTID_MASK
index|]
operator|=
operator|(
operator|(
name|param0
operator|&
name|AUTO_FW_CLEANUP_DEREG_FLAG
operator|)
condition|?
literal|0
else|:
literal|1
operator|)
expr_stmt|;
block|}
name|SA_DBG1
argument_list|(
operator|(
literal|"saPortControl, sending IOMB SUCCESS, portId 0x%x autoDeregDeviceflag=0x%x\n"
operator|,
name|pPort
operator|->
name|portId
operator|,
name|saRoot
operator|->
name|autoDeregDeviceflag
index|[
name|pPort
operator|->
name|portId
operator|&
name|PORTID_MASK
index|]
operator|)
argument_list|)
expr_stmt|;
block|}
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'b'
argument_list|,
literal|"28"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  * saEncryptGetMode()  *  *     Returns the status, working state and sector size  *     registers of the encryption engine  *  * @param saRoot  * @param encryptInfo  *  * @return  */
end_comment

begin_function
name|GLOBAL
name|bit32
name|saEncryptGetMode
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|agsaContext_t
modifier|*
name|agContext
parameter_list|,
name|agsaEncryptInfo_t
modifier|*
name|encryptInfo
parameter_list|)
block|{
name|bit32
name|ret
init|=
name|AGSA_RC_NOT_SUPPORTED
decl_stmt|;
name|smTraceFuncEnter
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|"29"
argument_list|)
expr_stmt|;
name|agContext
operator|=
name|agContext
expr_stmt|;
comment|/* Lint*/
name|SA_DBG4
argument_list|(
operator|(
literal|"saEncryptGetMode, encryptInfo %p\n"
operator|,
name|encryptInfo
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|smIS_SPCV
argument_list|(
name|agRoot
argument_list|)
condition|)
block|{
name|bit32
name|ScratchPad1
init|=
literal|0
decl_stmt|;
name|bit32
name|ScratchPad3
init|=
literal|0
decl_stmt|;
name|encryptInfo
operator|->
name|status
operator|=
literal|0
expr_stmt|;
name|encryptInfo
operator|->
name|encryptionCipherMode
operator|=
literal|0
expr_stmt|;
name|encryptInfo
operator|->
name|encryptionSecurityMode
operator|=
literal|0
expr_stmt|;
name|encryptInfo
operator|->
name|flag
operator|=
literal|0
expr_stmt|;
name|ScratchPad1
operator|=
name|ossaHwRegRead
argument_list|(
name|agRoot
argument_list|,
name|V_Scratchpad_1_Register
argument_list|)
expr_stmt|;
name|ScratchPad3
operator|=
name|ossaHwRegRead
argument_list|(
name|agRoot
argument_list|,
name|V_Scratchpad_3_Register
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ScratchPad1
operator|&
name|SCRATCH_PAD1_V_RAAE_MASK
operator|)
operator|==
name|SCRATCH_PAD1_V_RAAE_MASK
condition|)
block|{
if|if
condition|(
operator|(
name|ScratchPad3
operator|&
name|SCRATCH_PAD3_V_ENC_MASK
operator|)
operator|==
name|SCRATCH_PAD3_V_ENC_READY
condition|)
comment|/* 3 */
block|{
if|if
condition|(
name|ScratchPad3
operator|&
name|SCRATCH_PAD3_V_XTS_ENABLED
condition|)
block|{
name|encryptInfo
operator|->
name|encryptionCipherMode
operator|=
name|agsaEncryptCipherModeXTS
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ScratchPad3
operator|&
name|SCRATCH_PAD3_V_SM_MASK
operator|)
operator|==
name|SCRATCH_PAD3_V_SMF_ENABLED
condition|)
block|{
name|encryptInfo
operator|->
name|encryptionSecurityMode
operator|=
name|agsaEncryptSMF
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ScratchPad3
operator|&
name|SCRATCH_PAD3_V_SM_MASK
operator|)
operator|==
name|SCRATCH_PAD3_V_SMA_ENABLED
condition|)
block|{
name|encryptInfo
operator|->
name|encryptionSecurityMode
operator|=
name|agsaEncryptSMA
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ScratchPad3
operator|&
name|SCRATCH_PAD3_V_SM_MASK
operator|)
operator|==
name|SCRATCH_PAD3_V_SMB_ENABLED
condition|)
block|{
name|encryptInfo
operator|->
name|encryptionSecurityMode
operator|=
name|agsaEncryptSMB
expr_stmt|;
block|}
name|encryptInfo
operator|->
name|status
operator|=
name|AGSA_RC_SUCCESS
expr_stmt|;
name|ret
operator|=
name|AGSA_RC_SUCCESS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ScratchPad3
operator|&
name|SCRATCH_PAD3_V_ENC_READY
operator|)
operator|==
name|SCRATCH_PAD3_V_ENC_DISABLED
condition|)
comment|/* 0 */
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"saEncryptGetMode, SCRATCH_PAD3_V_ENC_DISABLED 1 0x%08X 3 0x%08X\n"
operator|,
name|ScratchPad1
operator|,
name|ScratchPad3
operator|)
argument_list|)
expr_stmt|;
name|encryptInfo
operator|->
name|status
operator|=
literal|0xFFFF
expr_stmt|;
name|encryptInfo
operator|->
name|encryptionCipherMode
operator|=
literal|0
expr_stmt|;
name|encryptInfo
operator|->
name|encryptionSecurityMode
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
name|AGSA_RC_NOT_SUPPORTED
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ScratchPad3
operator|&
name|SCRATCH_PAD3_V_ENC_MASK
operator|)
operator|==
name|SCRATCH_PAD3_V_ENC_DIS_ERR
condition|)
comment|/* 1 */
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"saEncryptGetMode, SCRATCH_PAD3_V_ENC_DIS_ERR 1 0x%08X 3 0x%08X\n"
operator|,
name|ScratchPad1
operator|,
name|ScratchPad3
operator|)
argument_list|)
expr_stmt|;
name|encryptInfo
operator|->
name|status
operator|=
operator|(
name|ScratchPad3
operator|&
name|SCRATCH_PAD3_V_ERR_CODE
operator|)
operator|>>
name|SHIFT16
expr_stmt|;
if|if
condition|(
name|ScratchPad3
operator|&
name|SCRATCH_PAD3_V_XTS_ENABLED
condition|)
block|{
name|encryptInfo
operator|->
name|encryptionCipherMode
operator|=
name|agsaEncryptCipherModeXTS
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ScratchPad3
operator|&
name|SCRATCH_PAD3_V_SM_MASK
operator|)
operator|==
name|SCRATCH_PAD3_V_SMF_ENABLED
condition|)
block|{
name|encryptInfo
operator|->
name|encryptionSecurityMode
operator|=
name|agsaEncryptSMF
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ScratchPad3
operator|&
name|SCRATCH_PAD3_V_SM_MASK
operator|)
operator|==
name|SCRATCH_PAD3_V_SMA_ENABLED
condition|)
block|{
name|encryptInfo
operator|->
name|encryptionSecurityMode
operator|=
name|agsaEncryptSMA
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ScratchPad3
operator|&
name|SCRATCH_PAD3_V_SM_MASK
operator|)
operator|==
name|SCRATCH_PAD3_V_SMB_ENABLED
condition|)
block|{
name|encryptInfo
operator|->
name|encryptionSecurityMode
operator|=
name|agsaEncryptSMB
expr_stmt|;
block|}
name|ret
operator|=
name|AGSA_RC_FAILURE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ScratchPad3
operator|&
name|SCRATCH_PAD3_V_ENC_MASK
operator|)
operator|==
name|SCRATCH_PAD3_V_ENC_ENA_ERR
condition|)
comment|/* 2 */
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"saEncryptGetMode, SCRATCH_PAD3_V_ENC_ENA_ERR 1 0x%08X 3 0x%08X\n"
operator|,
name|ScratchPad1
operator|,
name|ScratchPad3
operator|)
argument_list|)
expr_stmt|;
name|encryptInfo
operator|->
name|status
operator|=
operator|(
name|ScratchPad3
operator|&
name|SCRATCH_PAD3_V_ERR_CODE
operator|)
operator|>>
name|SHIFT16
expr_stmt|;
if|if
condition|(
name|ScratchPad3
operator|&
name|SCRATCH_PAD3_V_XTS_ENABLED
condition|)
block|{
name|encryptInfo
operator|->
name|encryptionCipherMode
operator|=
name|agsaEncryptCipherModeXTS
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saEncryptGetMode, SCRATCH_PAD3_V_ENC_ENA_ERR 2 0x%08X 3 0x%08X\n"
operator|,
name|ScratchPad1
operator|,
name|ScratchPad3
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ScratchPad3
operator|&
name|SCRATCH_PAD3_V_SM_MASK
operator|)
operator|==
name|SCRATCH_PAD3_V_SMF_ENABLED
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"saEncryptGetMode, SCRATCH_PAD3_V_ENC_ENA_ERR 3 0x%08X 3 0x%08X\n"
operator|,
name|ScratchPad1
operator|,
name|ScratchPad3
operator|)
argument_list|)
expr_stmt|;
name|encryptInfo
operator|->
name|encryptionSecurityMode
operator|=
name|agsaEncryptSMF
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ScratchPad3
operator|&
name|SCRATCH_PAD3_V_SM_MASK
operator|)
operator|==
name|SCRATCH_PAD3_V_SMA_ENABLED
condition|)
block|{
name|encryptInfo
operator|->
name|encryptionSecurityMode
operator|=
name|agsaEncryptSMA
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ScratchPad3
operator|&
name|SCRATCH_PAD3_V_SM_MASK
operator|)
operator|==
name|SCRATCH_PAD3_V_SMB_ENABLED
condition|)
block|{
name|encryptInfo
operator|->
name|encryptionSecurityMode
operator|=
name|agsaEncryptSMB
expr_stmt|;
block|}
name|SA_DBG1
argument_list|(
operator|(
literal|"saEncryptGetMode,encryptInfo status 0x%08X CipherMode 0x%X SecurityMode 0x%X\n"
operator|,
name|encryptInfo
operator|->
name|status
operator|,
name|encryptInfo
operator|->
name|encryptionCipherMode
operator|,
name|encryptInfo
operator|->
name|encryptionSecurityMode
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CCFLAGS_SPCV_FPGA_REVB
comment|/*The FPGA platform hasn't EEPROM*/
name|ret
operator|=
name|AGSA_RC_SUCCESS
expr_stmt|;
else|#
directive|else
name|ret
operator|=
name|AGSA_RC_FAILURE
expr_stmt|;
endif|#
directive|endif
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|ScratchPad1
operator|&
name|SCRATCH_PAD1_V_RAAE_MASK
operator|)
operator|==
name|SCRATCH_PAD1_V_RAAE_ERR
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"saEncryptGetMode, SCRATCH_PAD1_V_RAAE_ERR 1 0x%08X 3 0x%08X\n"
operator|,
name|ScratchPad1
operator|,
name|ScratchPad3
operator|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|AGSA_RC_FAILURE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ScratchPad1
operator|&
name|SCRATCH_PAD1_V_RAAE_MASK
operator|)
operator|==
literal|0x0
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"saEncryptGetMode, RAAE not ready AGSA_RC_BUSY 1 0x%08X 3 0x%08X\n"
operator|,
name|ScratchPad1
operator|,
name|ScratchPad3
operator|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|AGSA_RC_BUSY
expr_stmt|;
block|}
if|if
condition|(
name|ScratchPad3
operator|&
name|SCRATCH_PAD3_V_AUT
condition|)
block|{
name|encryptInfo
operator|->
name|flag
operator||=
name|OperatorAuthenticationEnable_AUT
expr_stmt|;
block|}
if|if
condition|(
name|ScratchPad3
operator|&
name|SCRATCH_PAD3_V_ARF
condition|)
block|{
name|encryptInfo
operator|->
name|flag
operator||=
name|ReturnToFactoryMode_ARF
expr_stmt|;
block|}
name|SA_DBG2
argument_list|(
operator|(
literal|"saEncryptGetMode, encryptionCipherMode 0x%x encryptionSecurityMode 0x%x flag 0x%x status 0x%x\n"
operator|,
name|encryptInfo
operator|->
name|encryptionCipherMode
operator|,
name|encryptInfo
operator|->
name|encryptionSecurityMode
operator|,
name|encryptInfo
operator|->
name|flag
operator|,
name|encryptInfo
operator|->
name|status
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG2
argument_list|(
operator|(
literal|"saEncryptGetMode, ScratchPad3 0x%x returns 0x%x\n"
operator|,
name|ScratchPad3
operator|,
name|ret
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"saEncryptGetMode, SPC AGSA_RC_NOT_SUPPORTED\n"
operator|)
argument_list|)
expr_stmt|;
block|}
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'a'
argument_list|,
literal|"29"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**/
end_comment

begin_function
name|GLOBAL
name|bit32
name|saEncryptSetMode
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|agsaContext_t
modifier|*
name|agContext
parameter_list|,
name|bit32
name|queueNum
parameter_list|,
name|agsaEncryptInfo_t
modifier|*
name|mode
parameter_list|)
block|{
name|bit32
name|ret
init|=
name|AGSA_RC_NOT_SUPPORTED
decl_stmt|;
name|agsaSetControllerConfigCmd_t
name|agControllerConfig
decl_stmt|;
name|agsaSetControllerConfigCmd_t
modifier|*
name|pagControllerConfig
init|=
operator|&
name|agControllerConfig
decl_stmt|;
name|bit32
name|smode
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|smIS_SPCV
argument_list|(
name|agRoot
argument_list|)
condition|)
block|{
name|bit32
name|ScratchPad1
init|=
literal|0
decl_stmt|;
name|ScratchPad1
operator|=
name|ossaHwRegRead
argument_list|(
name|agRoot
argument_list|,
name|V_Scratchpad_1_Register
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ScratchPad1
operator|&
name|SCRATCH_PAD1_V_RAAE_MASK
operator|)
operator|==
name|SCRATCH_PAD1_V_RAAE_MASK
condition|)
block|{
name|si_memset
argument_list|(
name|pagControllerConfig
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|agsaSetControllerConfigCmd_t
argument_list|)
argument_list|)
expr_stmt|;
name|SA_DBG2
argument_list|(
operator|(
literal|"saEncryptSetMode, encryptionCipherMode 0x%x encryptionSecurityMode 0x%x status 0x%x\n"
operator|,
name|mode
operator|->
name|encryptionCipherMode
operator|,
name|mode
operator|->
name|encryptionSecurityMode
operator|,
name|mode
operator|->
name|status
operator|)
argument_list|)
expr_stmt|;
name|smode
operator|=
name|mode
operator|->
name|encryptionSecurityMode
expr_stmt|;
if|if
condition|(
name|mode
operator|->
name|encryptionCipherMode
operator|&
name|agsaEncryptCipherModeXTS
condition|)
block|{
name|smode
operator||=
literal|1
operator|<<
name|SHIFT22
expr_stmt|;
block|}
name|pagControllerConfig
operator|->
name|pageCode
operator|=
name|AGSA_ENCRYPTION_CONTROL_PARM_PAGE
operator||
name|smode
expr_stmt|;
name|pagControllerConfig
operator|->
name|tag
operator|=
literal|0
expr_stmt|;
name|SA_DBG2
argument_list|(
operator|(
literal|"saEncryptSetMode,tag 0x%x pageCode 0x%x\n"
operator|,
name|pagControllerConfig
operator|->
name|tag
operator|,
name|pagControllerConfig
operator|->
name|pageCode
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG2
argument_list|(
operator|(
literal|"saEncryptSetMode, 0x%x 0x%x 0x%x 0x%x\n"
operator|,
name|pagControllerConfig
operator|->
name|configPage
index|[
literal|0
index|]
operator|,
name|pagControllerConfig
operator|->
name|configPage
index|[
literal|1
index|]
operator|,
name|pagControllerConfig
operator|->
name|configPage
index|[
literal|2
index|]
operator|,
name|pagControllerConfig
operator|->
name|configPage
index|[
literal|3
index|]
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG2
argument_list|(
operator|(
literal|"saEncryptSetMode, 0x%x 0x%x 0x%x 0x%x\n"
operator|,
name|pagControllerConfig
operator|->
name|configPage
index|[
literal|4
index|]
operator|,
name|pagControllerConfig
operator|->
name|configPage
index|[
literal|5
index|]
operator|,
name|pagControllerConfig
operator|->
name|configPage
index|[
literal|6
index|]
operator|,
name|pagControllerConfig
operator|->
name|configPage
index|[
literal|7
index|]
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG2
argument_list|(
operator|(
literal|"saEncryptSetMode, 0x%x 0x%x 0x%x 0x%x\n"
operator|,
name|pagControllerConfig
operator|->
name|configPage
index|[
literal|8
index|]
operator|,
name|pagControllerConfig
operator|->
name|configPage
index|[
literal|9
index|]
operator|,
name|pagControllerConfig
operator|->
name|configPage
index|[
literal|10
index|]
operator|,
name|pagControllerConfig
operator|->
name|configPage
index|[
literal|11
index|]
operator|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|mpiSetControllerConfigCmd
argument_list|(
name|agRoot
argument_list|,
name|agContext
argument_list|,
name|pagControllerConfig
argument_list|,
name|queueNum
argument_list|,
name|agTRUE
argument_list|)
expr_stmt|;
name|SA_DBG2
argument_list|(
operator|(
literal|"saEncryptSetMode,  pageCode 0x%x tag 0x%x status 0x%x\n"
operator|,
name|pagControllerConfig
operator|->
name|pageCode
operator|,
name|pagControllerConfig
operator|->
name|tag
operator|,
name|ret
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SA_DBG2
argument_list|(
operator|(
literal|"saEncryptSetMode,ScratchPad1 not ready %08X\n"
operator|,
name|ScratchPad1
operator|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|AGSA_RC_BUSY
expr_stmt|;
block|}
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  * saEncryptKekUpdate()  *  *     Replace a KEK within the controller  *  * @param saRoot  * @param flags  * @param newKekIndex  * @param wrapperKekIndex  * @param encryptKekBlob  *  * @return  */
end_comment

begin_function
name|GLOBAL
name|bit32
name|saEncryptKekUpdate
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|agsaContext_t
modifier|*
name|agContext
parameter_list|,
name|bit32
name|queueNum
parameter_list|,
name|bit32
name|flags
parameter_list|,
name|bit32
name|newKekIndex
parameter_list|,
name|bit32
name|wrapperKekIndex
parameter_list|,
name|bit32
name|blobFormat
parameter_list|,
name|agsaEncryptKekBlob_t
modifier|*
name|encryptKekBlob
parameter_list|)
block|{
name|agsaKekManagementCmd_t
name|payload
decl_stmt|;
name|bit32
name|ret
decl_stmt|,
name|i
decl_stmt|;
name|smTraceFuncEnter
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|"30"
argument_list|)
expr_stmt|;
name|SA_DBG2
argument_list|(
operator|(
literal|"saEncryptKekUpdate, flags 0x%x newKekIndex 0x%x wrapperKekIndex 0x%x encryptKekBlob %p\n"
operator|,
name|flags
operator|,
name|newKekIndex
operator|,
name|wrapperKekIndex
operator|,
name|encryptKekBlob
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG2
argument_list|(
operator|(
literal|"saEncryptKekUpdate, 0x%02X%02X%02X%02X 0x%02X%02X%02X%02X\n"
operator|,
name|encryptKekBlob
operator|->
name|kekBlob
index|[
literal|0
index|]
operator|,
name|encryptKekBlob
operator|->
name|kekBlob
index|[
literal|1
index|]
operator|,
name|encryptKekBlob
operator|->
name|kekBlob
index|[
literal|2
index|]
operator|,
name|encryptKekBlob
operator|->
name|kekBlob
index|[
literal|3
index|]
operator|,
name|encryptKekBlob
operator|->
name|kekBlob
index|[
literal|4
index|]
operator|,
name|encryptKekBlob
operator|->
name|kekBlob
index|[
literal|5
index|]
operator|,
name|encryptKekBlob
operator|->
name|kekBlob
index|[
literal|6
index|]
operator|,
name|encryptKekBlob
operator|->
name|kekBlob
index|[
literal|7
index|]
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG2
argument_list|(
operator|(
literal|"saEncryptKekUpdate, 0x%02X%02X%02X%02X 0x%02X%02X%02X%02X\n"
operator|,
name|encryptKekBlob
operator|->
name|kekBlob
index|[
literal|8
index|]
operator|,
name|encryptKekBlob
operator|->
name|kekBlob
index|[
literal|9
index|]
operator|,
name|encryptKekBlob
operator|->
name|kekBlob
index|[
literal|10
index|]
operator|,
name|encryptKekBlob
operator|->
name|kekBlob
index|[
literal|11
index|]
operator|,
name|encryptKekBlob
operator|->
name|kekBlob
index|[
literal|12
index|]
operator|,
name|encryptKekBlob
operator|->
name|kekBlob
index|[
literal|13
index|]
operator|,
name|encryptKekBlob
operator|->
name|kekBlob
index|[
literal|14
index|]
operator|,
name|encryptKekBlob
operator|->
name|kekBlob
index|[
literal|15
index|]
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG2
argument_list|(
operator|(
literal|"saEncryptKekUpdate, 0x%02X%02X%02X%02X 0x%02X%02X%02X%02X\n"
operator|,
name|encryptKekBlob
operator|->
name|kekBlob
index|[
literal|16
index|]
operator|,
name|encryptKekBlob
operator|->
name|kekBlob
index|[
literal|17
index|]
operator|,
name|encryptKekBlob
operator|->
name|kekBlob
index|[
literal|18
index|]
operator|,
name|encryptKekBlob
operator|->
name|kekBlob
index|[
literal|19
index|]
operator|,
name|encryptKekBlob
operator|->
name|kekBlob
index|[
literal|20
index|]
operator|,
name|encryptKekBlob
operator|->
name|kekBlob
index|[
literal|21
index|]
operator|,
name|encryptKekBlob
operator|->
name|kekBlob
index|[
literal|22
index|]
operator|,
name|encryptKekBlob
operator|->
name|kekBlob
index|[
literal|23
index|]
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG2
argument_list|(
operator|(
literal|"saEncryptKekUpdate, 0x%02X%02X%02X%02X 0x%02X%02X%02X%02X\n"
operator|,
name|encryptKekBlob
operator|->
name|kekBlob
index|[
literal|24
index|]
operator|,
name|encryptKekBlob
operator|->
name|kekBlob
index|[
literal|25
index|]
operator|,
name|encryptKekBlob
operator|->
name|kekBlob
index|[
literal|26
index|]
operator|,
name|encryptKekBlob
operator|->
name|kekBlob
index|[
literal|27
index|]
operator|,
name|encryptKekBlob
operator|->
name|kekBlob
index|[
literal|28
index|]
operator|,
name|encryptKekBlob
operator|->
name|kekBlob
index|[
literal|29
index|]
operator|,
name|encryptKekBlob
operator|->
name|kekBlob
index|[
literal|30
index|]
operator|,
name|encryptKekBlob
operator|->
name|kekBlob
index|[
literal|31
index|]
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG2
argument_list|(
operator|(
literal|"saEncryptKekUpdate, 0x%02X%02X%02X%02X 0x%02X%02X%02X%02X\n"
operator|,
name|encryptKekBlob
operator|->
name|kekBlob
index|[
literal|32
index|]
operator|,
name|encryptKekBlob
operator|->
name|kekBlob
index|[
literal|33
index|]
operator|,
name|encryptKekBlob
operator|->
name|kekBlob
index|[
literal|34
index|]
operator|,
name|encryptKekBlob
operator|->
name|kekBlob
index|[
literal|35
index|]
operator|,
name|encryptKekBlob
operator|->
name|kekBlob
index|[
literal|36
index|]
operator|,
name|encryptKekBlob
operator|->
name|kekBlob
index|[
literal|37
index|]
operator|,
name|encryptKekBlob
operator|->
name|kekBlob
index|[
literal|38
index|]
operator|,
name|encryptKekBlob
operator|->
name|kekBlob
index|[
literal|39
index|]
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG2
argument_list|(
operator|(
literal|"saEncryptKekUpdate, 0x%02X%02X%02X%02X 0x%02X%02X%02X%02X\n"
operator|,
name|encryptKekBlob
operator|->
name|kekBlob
index|[
literal|40
index|]
operator|,
name|encryptKekBlob
operator|->
name|kekBlob
index|[
literal|41
index|]
operator|,
name|encryptKekBlob
operator|->
name|kekBlob
index|[
literal|42
index|]
operator|,
name|encryptKekBlob
operator|->
name|kekBlob
index|[
literal|43
index|]
operator|,
name|encryptKekBlob
operator|->
name|kekBlob
index|[
literal|44
index|]
operator|,
name|encryptKekBlob
operator|->
name|kekBlob
index|[
literal|45
index|]
operator|,
name|encryptKekBlob
operator|->
name|kekBlob
index|[
literal|46
index|]
operator|,
name|encryptKekBlob
operator|->
name|kekBlob
index|[
literal|47
index|]
operator|)
argument_list|)
expr_stmt|;
comment|/* create payload for IOMB */
name|si_memset
argument_list|(
operator|&
name|payload
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|agsaKekManagementCmd_t
argument_list|)
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaKekManagementCmd_t
argument_list|,
name|NEWKIDX_CURKIDX_KBF_Reserved_SKNV_KSOP
argument_list|)
argument_list|,
operator|(
name|newKekIndex
operator|<<
name|SHIFT24
operator|)
operator||
operator|(
name|wrapperKekIndex
operator|<<
name|SHIFT16
operator|)
operator||
name|blobFormat
operator|<<
name|SHIFT14
operator||
operator|(
name|flags
operator|<<
name|SHIFT8
operator|)
operator||
name|KEK_MGMT_SUBOP_UPDATE
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|12
condition|;
name|i
operator|++
control|)
block|{
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaKekManagementCmd_t
argument_list|,
name|kekBlob
index|[
name|i
index|]
argument_list|)
argument_list|,
operator|(
name|bit32
operator|)
operator|*
operator|(
name|bit32
operator|*
operator|)
operator|&
name|encryptKekBlob
operator|->
name|kekBlob
index|[
name|i
operator|*
sizeof|sizeof
argument_list|(
name|bit32
argument_list|)
index|]
argument_list|)
expr_stmt|;
comment|/**/
block|}
name|ret
operator|=
name|mpiKekManagementCmd
argument_list|(
name|agRoot
argument_list|,
name|agContext
argument_list|,
operator|&
name|payload
argument_list|,
name|queueNum
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'a'
argument_list|,
literal|"30"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|HIALEAH_ENCRYPTION
end_ifdef

begin_function
name|GLOBAL
name|bit32
name|saEncryptHilUpdate
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|agsaContext_t
modifier|*
name|agContext
parameter_list|,
name|bit32
name|queueNum
parameter_list|)
block|{
name|agsaKekManagementCmd_t
name|payload
decl_stmt|;
name|bit32
name|ScratchPad1
init|=
literal|0
decl_stmt|;
name|bit32
name|ScratchPad3
init|=
literal|0
decl_stmt|;
name|bit32
name|ret
init|=
literal|0
decl_stmt|;
name|ScratchPad1
operator|=
name|ossaHwRegRead
argument_list|(
name|agRoot
argument_list|,
name|V_Scratchpad_1_Register
argument_list|)
expr_stmt|;
name|ScratchPad3
operator|=
name|ossaHwRegRead
argument_list|(
name|agRoot
argument_list|,
name|V_Scratchpad_3_Register
argument_list|)
expr_stmt|;
name|smTraceFuncEnter
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|"xxx"
argument_list|)
expr_stmt|;
name|SA_DBG2
argument_list|(
operator|(
literal|"saEncryptHilUpdate ScratchPad1 0x08%x ScratchPad3 0x08%x\n"
operator|,
name|ScratchPad1
operator|,
name|ScratchPad3
operator|)
argument_list|)
expr_stmt|;
comment|/* create payload for IOMB */
name|si_memset
argument_list|(
operator|&
name|payload
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|agsaKekManagementCmd_t
argument_list|)
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaKekManagementCmd_t
argument_list|,
name|NEWKIDX_CURKIDX_KBF_Reserved_SKNV_KSOP
argument_list|)
argument_list|,
operator|(
literal|1
operator|<<
name|SHIFT24
operator|)
operator||
operator|(
literal|1
operator|<<
name|SHIFT16
operator|)
operator||
operator|(
literal|1
operator|<<
name|SHIFT8
operator|)
operator||
name|KEK_MGMT_SUBOP_KEYCARDUPDATE
argument_list|)
expr_stmt|;
comment|/**/
name|ret
operator|=
name|mpiKekManagementCmd
argument_list|(
name|agRoot
argument_list|,
name|agContext
argument_list|,
operator|&
name|payload
argument_list|,
name|queueNum
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'a'
argument_list|,
literal|"xxx"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HIALEAH_ENCRYPTION */
end_comment

begin_comment
comment|/**  * saEncryptKekInvalidate()  *  *     Remove a KEK from the controller  *  * @param saRoot  * @param flags  * @param newKekIndex  * @param wrapperKekIndex  * @param encryptKekBlob  *  * @return  */
end_comment

begin_function
name|GLOBAL
name|bit32
name|saEncryptKekInvalidate
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|agsaContext_t
modifier|*
name|agContext
parameter_list|,
name|bit32
name|queueNum
parameter_list|,
name|bit32
name|kekIndex
parameter_list|)
block|{
name|agsaKekManagementCmd_t
name|payload
decl_stmt|;
name|bit32
name|ret
decl_stmt|;
name|smTraceFuncEnter
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|"31"
argument_list|)
expr_stmt|;
name|SA_DBG2
argument_list|(
operator|(
literal|"saEncryptKekInvalidate, kekIndex 0x%x \n"
operator|,
name|kekIndex
operator|)
argument_list|)
expr_stmt|;
comment|/* create payload for IOMB */
name|si_memset
argument_list|(
operator|&
name|payload
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|agsaDekManagementCmd_t
argument_list|)
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaKekManagementCmd_t
argument_list|,
name|NEWKIDX_CURKIDX_KBF_Reserved_SKNV_KSOP
argument_list|)
argument_list|,
name|kekIndex
operator|<<
name|SHIFT16
operator||
name|KEK_MGMT_SUBOP_INVALIDATE
argument_list|)
expr_stmt|;
name|ret
operator|=
name|mpiKekManagementCmd
argument_list|(
name|agRoot
argument_list|,
name|agContext
argument_list|,
operator|&
name|payload
argument_list|,
name|queueNum
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'a'
argument_list|,
literal|"31"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  * saEncryptDekCacheUpdate()  *  *     Replace a DEK within the controller cache  *  * @param saRoot  * @param kekIndex  * @param dekTableSelect  * @param dekAddrHi  * @param dekAddrLo  * @param dekIndex  * @param dekNumberOfEntries  *  * @return  */
end_comment

begin_function
name|GLOBAL
name|bit32
name|saEncryptDekCacheUpdate
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|agsaContext_t
modifier|*
name|agContext
parameter_list|,
name|bit32
name|queueNum
parameter_list|,
name|bit32
name|kekIndex
parameter_list|,
name|bit32
name|dekTableSelect
parameter_list|,
name|bit32
name|dekAddrHi
parameter_list|,
name|bit32
name|dekAddrLo
parameter_list|,
name|bit32
name|dekIndex
parameter_list|,
name|bit32
name|dekNumberOfEntries
parameter_list|,
name|bit32
name|dekBlobFormat
parameter_list|,
name|bit32
name|dekTableKeyEntrySize
parameter_list|)
block|{
name|agsaDekManagementCmd_t
name|payload
decl_stmt|;
name|bit32
name|ret
decl_stmt|;
name|smTraceFuncEnter
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|"32"
argument_list|)
expr_stmt|;
name|SA_DBG2
argument_list|(
operator|(
literal|"saEncryptDekCacheUpdate, kekIndex 0x%x dekTableSelect 0x%x dekAddrHi 0x%x dekAddrLo 0x%x\n"
operator|,
name|kekIndex
operator|,
name|dekTableSelect
operator|,
name|dekAddrHi
operator|,
name|dekAddrLo
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG2
argument_list|(
operator|(
literal|"saEncryptDekCacheUpdate, dekIndex 0x%x dekNumberOfEntries 0x%x dekBlobFormat 0x%x dekTableKeyEntrySize 0x%x\n"
operator|,
name|dekIndex
operator|,
name|dekNumberOfEntries
operator|,
name|dekBlobFormat
operator|,
name|dekTableKeyEntrySize
operator|)
argument_list|)
expr_stmt|;
comment|/* create payload for IOMB */
name|si_memset
argument_list|(
operator|&
name|payload
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|agsaDekManagementCmd_t
argument_list|)
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaDekManagementCmd_t
argument_list|,
name|KEKIDX_Reserved_TBLS_DSOP
argument_list|)
argument_list|,
operator|(
name|kekIndex
operator|<<
name|SHIFT24
operator|)
operator||
operator|(
name|dekTableSelect
operator|<<
name|SHIFT8
operator|)
operator||
name|DEK_MGMT_SUBOP_UPDATE
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaDekManagementCmd_t
argument_list|,
name|dekIndex
argument_list|)
argument_list|,
name|dekIndex
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaDekManagementCmd_t
argument_list|,
name|tableAddrLo
argument_list|)
argument_list|,
name|dekAddrLo
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaDekManagementCmd_t
argument_list|,
name|tableAddrHi
argument_list|)
argument_list|,
name|dekAddrHi
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaDekManagementCmd_t
argument_list|,
name|tableEntries
argument_list|)
argument_list|,
name|dekNumberOfEntries
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaDekManagementCmd_t
argument_list|,
name|Reserved_DBF_TBL_SIZE
argument_list|)
argument_list|,
name|dekBlobFormat
operator|<<
name|SHIFT8
operator||
name|dekTableKeyEntrySize
argument_list|)
expr_stmt|;
name|ret
operator|=
name|mpiDekManagementCmd
argument_list|(
name|agRoot
argument_list|,
name|agContext
argument_list|,
operator|&
name|payload
argument_list|,
name|queueNum
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'a'
argument_list|,
literal|"32"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  * saEncryptDekCacheInvalidate()  *  *     Remove a DEK from the controller cache  *  * @param saRoot  * @param kekIndex  * @param dekTable  * @param dekAddrHi  * @param dekAddrLo  * @param dekIndex  * @param dekNumberOfEntries  *  * @return  */
end_comment

begin_function
name|GLOBAL
name|bit32
name|saEncryptDekCacheInvalidate
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|agsaContext_t
modifier|*
name|agContext
parameter_list|,
name|bit32
name|queueNum
parameter_list|,
name|bit32
name|dekTable
parameter_list|,
name|bit32
name|dekIndex
parameter_list|)
block|{
name|agsaDekManagementCmd_t
name|payload
decl_stmt|;
name|bit32
name|ret
decl_stmt|;
name|smTraceFuncEnter
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|"33"
argument_list|)
expr_stmt|;
name|SA_DBG2
argument_list|(
operator|(
literal|"saEncryptDekCacheInvalidate,dekTable  0x%x dekIndex 0x%x\n"
operator|,
name|dekTable
operator|,
name|dekIndex
operator|)
argument_list|)
expr_stmt|;
comment|/* create payload for IOMB */
name|si_memset
argument_list|(
operator|&
name|payload
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|agsaDekManagementCmd_t
argument_list|)
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaDekManagementCmd_t
argument_list|,
name|KEKIDX_Reserved_TBLS_DSOP
argument_list|)
argument_list|,
operator|(
name|dekTable
operator|<<
name|SHIFT8
operator|)
operator||
name|DEK_MGMT_SUBOP_INVALIDATE
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaDekManagementCmd_t
argument_list|,
name|dekIndex
argument_list|)
argument_list|,
name|dekIndex
argument_list|)
expr_stmt|;
comment|/* Assume all DEKs are 80 bytes*/
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaDekManagementCmd_t
argument_list|,
name|Reserved_DBF_TBL_SIZE
argument_list|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|ret
operator|=
name|mpiDekManagementCmd
argument_list|(
name|agRoot
argument_list|,
name|agContext
argument_list|,
operator|&
name|payload
argument_list|,
name|queueNum
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'a'
argument_list|,
literal|"33"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  * saDIFEncryptionOffloadStart()  *  *     initiate the SPCv controller offload function   *  * @param saRoot  * @param agContext  * @param queueNum  * @param op  * @param agsaDifEncPayload  * @param agCB  *  * @return  */
end_comment

begin_function
name|GLOBAL
name|bit32
name|saDIFEncryptionOffloadStart
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|agsaContext_t
modifier|*
name|agContext
parameter_list|,
name|bit32
name|queueNum
parameter_list|,
name|bit32
name|op
parameter_list|,
name|agsaDifEncPayload_t
modifier|*
name|agsaDifEncPayload
parameter_list|,
name|ossaDIFEncryptionOffloadStartCB_t
name|agCB
parameter_list|)
block|{
name|bit32
name|ret
init|=
name|AGSA_RC_FAILURE
decl_stmt|;
name|smTraceFuncEnter
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|"3I"
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saDIFEncryptionOffloadStart: start op=%d, agsaDifEncPayload=%p\n"
operator|,
name|op
operator|,
name|agsaDifEncPayload
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|smIS_SPCV
argument_list|(
name|agRoot
argument_list|)
condition|)
block|{
name|ret
operator|=
name|mpiDIFEncryptionOffloadCmd
argument_list|(
name|agRoot
argument_list|,
name|agContext
argument_list|,
name|queueNum
argument_list|,
name|op
argument_list|,
name|agsaDifEncPayload
argument_list|,
name|agCB
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"saDIFEncryptionOffloadStart: spcv only AGSA_RC_FAILURE \n"
operator|)
argument_list|)
expr_stmt|;
block|}
name|SA_DBG1
argument_list|(
operator|(
literal|"saDIFEncryptionOffloadStart: end status 0x%x\n"
operator|,
name|ret
operator|)
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'a'
argument_list|,
literal|"3I"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  * saSetControllerConfig()  *  *     Update a controller mode page  *  * @param saRoot  * @param modePage  * @param length  * @param buffer  * @param agContext  *  * @return  */
end_comment

begin_function
name|GLOBAL
name|bit32
name|saSetControllerConfig
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|bit32
name|queueNum
parameter_list|,
name|bit32
name|modePage
parameter_list|,
name|bit32
name|length
parameter_list|,
name|void
modifier|*
name|buffer
parameter_list|,
name|agsaContext_t
modifier|*
name|agContext
parameter_list|)
block|{
name|agsaSetControllerConfigCmd_t
name|agControllerConfig
decl_stmt|;
name|bit32
modifier|*
name|src
decl_stmt|;
name|bit32
name|i
decl_stmt|,
name|ret
decl_stmt|;
name|smTraceFuncEnter
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|"34"
argument_list|)
expr_stmt|;
if|if
condition|(
name|smIS_SPCV
argument_list|(
name|agRoot
argument_list|)
condition|)
block|{
name|SA_DBG2
argument_list|(
operator|(
literal|"saSetControllerConfig: queueNum %d modePage 0x%x length %d\n"
operator|,
name|queueNum
operator|,
name|modePage
operator|,
name|length
operator|)
argument_list|)
expr_stmt|;
comment|/* If the page is well known, validate the size of the buffer */
if|if
condition|(
operator|(
operator|(
name|modePage
operator|==
name|AGSA_INTERRUPT_CONFIGURATION_PAGE
operator|)
operator|&&
operator|(
name|length
operator|!=
sizeof|sizeof
argument_list|(
name|agsaInterruptConfigPage_t
argument_list|)
operator|)
operator|)
operator|||
operator|(
operator|(
name|modePage
operator|==
name|AGSA_ENCRYPTION_DEK_CONFIG_PAGE
operator|)
operator|&&
operator|(
name|length
operator|!=
sizeof|sizeof
argument_list|(
name|agsaEncryptDekConfigPage_t
argument_list|)
operator|)
operator|)
operator|||
operator|(
operator|(
name|modePage
operator|==
name|AGSA_ENCRYPTION_CONTROL_PARM_PAGE
operator|)
operator|&&
operator|(
name|length
operator|!=
sizeof|sizeof
argument_list|(
name|agsaEncryptControlParamPage_t
argument_list|)
operator|)
operator|)
operator|||
operator|(
operator|(
name|modePage
operator|==
name|AGSA_ENCRYPTION_HMAC_CONFIG_PAGE
operator|)
operator|&&
operator|(
name|length
operator|!=
sizeof|sizeof
argument_list|(
name|agsaEncryptHMACConfigPage_t
argument_list|)
operator|)
operator|)
operator|||
operator|(
operator|(
name|modePage
operator|==
name|AGSA_SAS_PROTOCOL_TIMER_CONFIG_PAGE
operator|)
operator|&&
operator|(
name|length
operator|!=
sizeof|sizeof
argument_list|(
name|agsaSASProtocolTimerConfigurationPage_t
argument_list|)
operator|)
operator|)
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"saSetControllerConfig: AGSA_RC_FAILURE queueNum %d modePage 0x%x length %d\n"
operator|,
name|queueNum
operator|,
name|modePage
operator|,
name|length
operator|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|AGSA_RC_FAILURE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|modePage
operator|==
name|AGSA_ENCRYPTION_GENERAL_CONFIG_PAGE
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"saSetControllerConfig: Warning!!!!GENERAL_CONFIG_PAGE cannot be set\n"
operator|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|AGSA_RC_FAILURE
expr_stmt|;
block|}
else|else
block|{
comment|/* Copy the raw mode page data into something that can be wrapped in an IOMB. */
name|si_memset
argument_list|(
operator|&
name|agControllerConfig
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|agsaSetControllerConfigCmd_t
argument_list|)
argument_list|)
expr_stmt|;
name|agControllerConfig
operator|.
name|tag
operator|=
literal|0
expr_stmt|;
comment|/*HTAG */
name|src
operator|=
operator|(
name|bit32
operator|*
operator|)
name|buffer
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|length
operator|/
literal|4
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|agControllerConfig
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSetControllerConfigCmd_t
argument_list|,
name|pageCode
argument_list|)
operator|+
operator|(
name|i
operator|*
literal|4
operator|)
argument_list|,
operator|*
name|src
argument_list|)
expr_stmt|;
name|src
operator|++
expr_stmt|;
block|}
name|ret
operator|=
name|mpiSetControllerConfigCmd
argument_list|(
name|agRoot
argument_list|,
name|agContext
argument_list|,
operator|&
name|agControllerConfig
argument_list|,
name|queueNum
argument_list|,
name|agFALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"saSetControllerConfig: AGSA_RC_FAILURE (sending) queueNum %d modePage 0x%x length %d\n"
operator|,
name|queueNum
operator|,
name|modePage
operator|,
name|length
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"saSetControllerConfig: spcv only AGSA_RC_FAILURE queueNum %d modePage 0x%x length %d\n"
operator|,
name|queueNum
operator|,
name|modePage
operator|,
name|length
operator|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|AGSA_RC_FAILURE
expr_stmt|;
block|}
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'a'
argument_list|,
literal|"34"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  * saGetControllerConfig()  *  *     Retrieve the contents of a controller mode page  *  * @param saRoot  * @param modePage  * @param agContext  *  * @return  */
end_comment

begin_function
name|GLOBAL
name|bit32
name|saGetControllerConfig
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|bit32
name|queueNum
parameter_list|,
name|bit32
name|modePage
parameter_list|,
name|bit32
name|flag0
parameter_list|,
name|bit32
name|flag1
parameter_list|,
name|agsaContext_t
modifier|*
name|agContext
parameter_list|)
block|{
name|bit32
name|ret
decl_stmt|;
name|agsaGetControllerConfigCmd_t
name|agControllerConfig
decl_stmt|;
name|smTraceFuncEnter
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|"35"
argument_list|)
expr_stmt|;
name|SA_DBG2
argument_list|(
operator|(
literal|"saGetControllerConfig, modePage 0x%x  agContext %p flag0 0x%08x flag1 0x%08x\n"
operator|,
name|modePage
operator|,
name|agContext
operator|,
name|flag0
operator|,
name|flag1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|smIS_SPCV
argument_list|(
name|agRoot
argument_list|)
condition|)
block|{
name|si_memset
argument_list|(
operator|&
name|agControllerConfig
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|agsaGetControllerConfigCmd_t
argument_list|)
argument_list|)
expr_stmt|;
name|agControllerConfig
operator|.
name|pageCode
operator|=
name|modePage
expr_stmt|;
if|if
condition|(
name|modePage
operator|==
name|AGSA_INTERRUPT_CONFIGURATION_PAGE
condition|)
block|{
name|agControllerConfig
operator|.
name|INT_VEC_MSK0
operator|=
name|flag0
expr_stmt|;
name|agControllerConfig
operator|.
name|INT_VEC_MSK1
operator|=
name|flag1
expr_stmt|;
block|}
name|ret
operator|=
name|mpiGetControllerConfigCmd
argument_list|(
name|agRoot
argument_list|,
name|agContext
argument_list|,
operator|&
name|agControllerConfig
argument_list|,
name|queueNum
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetControllerConfig: spcv only AGSA_RC_FAILURE queueNum %d modePage 0x%x flag0 0x%08x flag1 0x%08x\n"
operator|,
name|queueNum
operator|,
name|modePage
operator|,
name|flag0
operator|,
name|flag1
operator|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|AGSA_RC_FAILURE
expr_stmt|;
block|}
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'a'
argument_list|,
literal|"35"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|GLOBAL
name|bit32
name|saEncryptSelftestExecute
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|agsaContext_t
modifier|*
name|agContext
parameter_list|,
name|bit32
name|queueNum
parameter_list|,
name|bit32
name|type
parameter_list|,
name|bit32
name|length
parameter_list|,
name|void
modifier|*
name|TestDescriptor
parameter_list|)
block|{
name|bit32
name|ret
init|=
name|AGSA_RC_SUCCESS
decl_stmt|;
name|agsaEncryptBist_t
name|bist
decl_stmt|;
name|smTraceFuncEnter
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|"2e"
argument_list|)
expr_stmt|;
name|si_memset
argument_list|(
operator|&
name|bist
argument_list|,
literal|0
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
name|agsaEncryptBist_t
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saEncryptSelftestExecute, enter\n"
operator|)
argument_list|)
expr_stmt|;
name|bist
operator|.
name|r_subop
operator|=
operator|(
name|type
operator|&
literal|0xFF
operator|)
expr_stmt|;
name|si_memcpy
argument_list|(
operator|&
name|bist
operator|.
name|testDiscption
argument_list|,
name|TestDescriptor
argument_list|,
name|length
argument_list|)
expr_stmt|;
comment|/* setup IOMB payload */
name|ret
operator|=
name|mpiEncryptBistCmd
argument_list|(
name|agRoot
argument_list|,
name|queueNum
argument_list|,
name|agContext
argument_list|,
operator|&
name|bist
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'a'
argument_list|,
literal|"2e"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|GLOBAL
name|bit32
name|saOperatorManagement
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|agsaContext_t
modifier|*
name|agContext
parameter_list|,
name|bit32
name|queueNum
parameter_list|,
name|bit32
name|flag
parameter_list|,
name|bit8
name|role
parameter_list|,
name|agsaID_t
modifier|*
name|id
parameter_list|,
name|agsaEncryptKekBlob_t
modifier|*
name|kblob
parameter_list|)
block|{
name|bit32
name|ret
init|=
name|AGSA_RC_SUCCESS
decl_stmt|;
name|agsaOperatorMangmentCmd_t
name|opmcmd
decl_stmt|;
name|smTraceFuncEnter
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|"2i"
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saOperatorManagement, enter\n"
operator|)
argument_list|)
expr_stmt|;
name|si_memset
argument_list|(
operator|&
name|opmcmd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|agsaOperatorMangmentCmd_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/*role = ((flag& SA_OPR_MGMNT_FLAG_MASK)>> SA_OPR_MGMNT_FLAG_SHIFT);*/
name|flag
operator|=
operator|(
name|flag
operator|&
operator|~
name|SA_OPR_MGMNT_FLAG_MASK
operator|)
expr_stmt|;
name|opmcmd
operator|.
name|OPRIDX_AUTIDX_R_KBF_PKT_OMO
operator|=
name|flag
expr_stmt|;
name|opmcmd
operator|.
name|IDString_Role
index|[
literal|0
index|]
operator|=
operator|(
name|bit8
operator|)
name|role
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saOperatorManagement, role 0x%X flags 0x%08X\n"
operator|,
name|role
operator|,
name|opmcmd
operator|.
name|OPRIDX_AUTIDX_R_KBF_PKT_OMO
operator|)
argument_list|)
expr_stmt|;
name|si_memcpy
argument_list|(
operator|&
name|opmcmd
operator|.
name|IDString_Role
index|[
literal|1
index|]
argument_list|,
name|id
operator|->
name|ID
argument_list|,
name|AGSA_ID_SIZE
argument_list|)
expr_stmt|;
name|si_memcpy
argument_list|(
operator|&
name|opmcmd
operator|.
name|Kblob
argument_list|,
name|kblob
argument_list|,
sizeof|sizeof
argument_list|(
name|agsaEncryptKekBlob_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* setup IOMB payload */
name|ret
operator|=
name|mpiOperatorManagementCmd
argument_list|(
name|agRoot
argument_list|,
name|queueNum
argument_list|,
name|agContext
argument_list|,
operator|&
name|opmcmd
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'a'
argument_list|,
literal|"2i"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*     The command is for an operator to login to/logout from SPCve.     Only when all IOs are quiesced, can an operator logout.      flag:       Access type (ACS) [4 bits]         0x1: login         0x2: logout         Others: reserved       KEYopr pinned in the KEK RAM (PIN) [1 bit]         0: not pinned, operator ID table will be searched during authentication.         1: pinned, OPRIDX is referenced to unwrap the certificate.       KEYopr Index in the KEK RAM (OPRIDX) [8 bits]         If KEYopr is pinned in the KEK RAM, OPRIDX is to reference to the KEK for authentication      cert       Operator Certificate (CERT) [40 bytes]        response calls ossaSetOperatorCB */
end_comment

begin_function
name|GLOBAL
name|bit32
name|saSetOperator
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|agsaContext_t
modifier|*
name|agContext
parameter_list|,
name|bit32
name|queueNum
parameter_list|,
name|bit32
name|flag
parameter_list|,
name|void
modifier|*
name|cert
parameter_list|)
block|{
name|bit32
name|ret
init|=
name|AGSA_RC_SUCCESS
decl_stmt|;
name|agsaSetOperatorCmd_t
name|SetOperatorCmd
decl_stmt|;
name|smTraceFuncEnter
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|"3c"
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saSetOperator, flag 0x%x cert %p\n"
operator|,
name|flag
operator|,
name|cert
operator|)
argument_list|)
expr_stmt|;
comment|/* initialize set operator IOMB */
name|si_memset
argument_list|(
operator|&
name|SetOperatorCmd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|agsaSetOperatorCmd_t
argument_list|)
argument_list|)
expr_stmt|;
name|SetOperatorCmd
operator|.
name|OPRIDX_PIN_ACS
operator|=
name|flag
expr_stmt|;
name|si_memcpy
argument_list|(
operator|(
name|bit8
operator|*
operator|)
name|SetOperatorCmd
operator|.
name|cert
argument_list|,
operator|(
name|bit8
operator|*
operator|)
name|cert
argument_list|,
literal|40
argument_list|)
expr_stmt|;
comment|/* setup IOMB payload */
name|ret
operator|=
name|mpiSetOperatorCmd
argument_list|(
name|agRoot
argument_list|,
name|queueNum
argument_list|,
name|agContext
argument_list|,
operator|&
name|SetOperatorCmd
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'a'
argument_list|,
literal|"3c"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*     The command is to get role and ID of either current or all operators from SPCve.     Option         0x1: current operator         0x2: all operators         Others: reserved      OprBufAddr         the host buffer address to store the role and ID of all operators. Valid only when option == 0x2.         Buffer size must be 1KB to store max 32 operators's role and ID.     response calls ossaGetOperatorCB */
end_comment

begin_function
name|GLOBAL
name|bit32
name|saGetOperator
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|agsaContext_t
modifier|*
name|agContext
parameter_list|,
name|bit32
name|queueNum
parameter_list|,
name|bit32
name|option
parameter_list|,
name|bit32
name|AddrHi
parameter_list|,
name|bit32
name|AddrLo
parameter_list|)
block|{
name|bit32
name|ret
init|=
name|AGSA_RC_SUCCESS
decl_stmt|;
name|agsaGetOperatorCmd_t
name|GetOperatorCmd
decl_stmt|;
name|smTraceFuncEnter
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|"3d"
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saGetOperator, option 0x%x 0x%08x_%08x\n"
operator|,
name|option
operator|,
name|AddrHi
operator|,
name|AddrLo
operator|)
argument_list|)
expr_stmt|;
comment|/* initialize get operator IOMB */
name|si_memset
argument_list|(
operator|&
name|GetOperatorCmd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|agsaGetOperatorCmd_t
argument_list|)
argument_list|)
expr_stmt|;
name|GetOperatorCmd
operator|.
name|option
operator|=
name|option
expr_stmt|;
name|GetOperatorCmd
operator|.
name|OprBufAddrLo
operator|=
name|AddrLo
expr_stmt|;
name|GetOperatorCmd
operator|.
name|OprBufAddrHi
operator|=
name|AddrHi
expr_stmt|;
comment|/* setup IOMB payload */
name|ret
operator|=
name|mpiGetOperatorCmd
argument_list|(
name|agRoot
argument_list|,
name|queueNum
argument_list|,
name|agContext
argument_list|,
operator|&
name|GetOperatorCmd
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'a'
argument_list|,
literal|"3d"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

end_unit

