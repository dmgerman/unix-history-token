begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************************* *Copyright (c) 2014 PMC-Sierra, Inc.  All rights reserved.  * *Redistribution and use in source and binary forms, with or without modification, are permitted provided  *that the following conditions are met:  *1. Redistributions of source code must retain the above copyright notice, this list of conditions and the *following disclaimer.  *2. Redistributions in binary form must reproduce the above copyright notice,  *this list of conditions and the following disclaimer in the documentation and/or other materials provided *with the distribution.  * *THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR IMPLIED  *WARRANTIES,INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS *FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE *FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  *NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR  *BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  *LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  *SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE  ********************************************************************************/
end_comment

begin_comment
comment|/*******************************************************************************/
end_comment

begin_comment
comment|/*! \file sampicmd.c  *  \brief The file implements the functions of MPI Inbound IOMB/Command to SPC  *  */
end_comment

begin_comment
comment|/******************************************************************************/
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<dev/pms/config.h>
end_include

begin_include
include|#
directive|include
file|<dev/pms/RefTisa/sallsdk/spc/saglobal.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SA_ENABLE_TRACE_FUNCTIONS
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|siTraceFileID
end_ifdef

begin_undef
undef|#
directive|undef
name|siTraceFileID
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|siTraceFileID
value|'I'
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*! \brief SAS/SATA LL API ECHO Command  *  *  This command used to test that MPI between host and SPC IOP is operational.  *  *  \param agRoot       Handles for this instance of SAS/SATA hardware  *  \param agContext    Context of SPC FW Flash Update Command  *  \param queueNum     Inbound/outbound queue number  *  \param echoPayload  Pointer of Echo payload of IOMB  *  *  \return If the MPI command is sent to SPC successfully  *          - \e AGSA_RC_SUCCESS the MPI command is successfully  *          - \e AGSA_RC_BUSY the SPC is no resource, cannot send now  *          - \e AGSA_RC_FAILURE the MPI command is failure  *  */
end_comment

begin_comment
comment|/*******************************************************************************/
end_comment

begin_function
name|GLOBAL
name|bit32
name|saEchoCommand
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|agsaContext_t
modifier|*
name|agContext
parameter_list|,
name|bit32
name|queueNum
parameter_list|,
name|void
modifier|*
name|echoPayload
parameter_list|)
block|{
name|bit32
name|ret
init|=
name|AGSA_RC_SUCCESS
decl_stmt|;
name|smTraceFuncEnter
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|"xa"
argument_list|)
expr_stmt|;
comment|/* setup IOMB payload */
name|ret
operator|=
name|mpiEchoCmd
argument_list|(
name|agRoot
argument_list|,
name|queueNum
argument_list|,
name|agContext
argument_list|,
name|echoPayload
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'a'
argument_list|,
literal|"xa"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*! \brief Build a IOMB command and send to SPC  *  *  Build an IOMB if there is a free message buffer and Send it to SPC  *  *  \param agRoot       Handles for this instance of SAS/SATA hardware  *  \param payload      Pointer of payload in the IOMB  *  \param category     Category of IOMB  *  \param opcode       Opcode of IOMB  *  \param size         Size of IOMB  *  \param queueNum     Inbound/outbound queue number  *  *  \return If the MPI command is sent to SPC successfully  *          - \e AGSA_RC_SUCCESS the MPI command is successfully  *          - \e AGSA_RC_BUSY the SPC is no resource, cannot send now  *          - \e AGSA_RC_FAILURE the MPI command is failure  */
end_comment

begin_comment
comment|/*******************************************************************************/
end_comment

begin_function
name|GLOBAL
name|bit32
name|mpiBuildCmd
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|bit32
modifier|*
name|payload
parameter_list|,
name|mpiMsgCategory_t
name|category
parameter_list|,
name|bit16
name|opcode
parameter_list|,
name|bit16
name|size
parameter_list|,
name|bit32
name|queueNum
parameter_list|)
block|{
name|agsaLLRoot_t
modifier|*
name|saRoot
init|=
operator|(
name|agsaLLRoot_t
operator|*
operator|)
operator|(
name|agRoot
operator|->
name|sdkData
operator|)
decl_stmt|;
name|mpiICQueue_t
modifier|*
name|circularQ
decl_stmt|;
name|void
modifier|*
name|pMessage
decl_stmt|;
name|bit32
name|ret
init|=
name|AGSA_RC_SUCCESS
decl_stmt|;
name|bit32
name|retVal
decl_stmt|;
name|bit8
name|inq
decl_stmt|,
name|outq
decl_stmt|;
name|smTraceFuncEnter
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|"xb"
argument_list|)
expr_stmt|;
name|inq
operator|=
call|(
name|bit8
call|)
argument_list|(
name|queueNum
operator|&
name|MPI_IB_NUM_MASK
argument_list|)
expr_stmt|;
name|outq
operator|=
call|(
name|bit8
call|)
argument_list|(
operator|(
name|queueNum
operator|&
name|MPI_OB_NUM_MASK
operator|)
operator|>>
name|MPI_OB_SHIFT
argument_list|)
expr_stmt|;
name|SA_ASSERT
argument_list|(
operator|(
name|AGSA_MAX_INBOUND_Q
operator|>
name|inq
operator|)
argument_list|,
literal|"The IBQ Number is out of range."
argument_list|)
expr_stmt|;
name|SA_ASSERT
argument_list|(
operator|(
name|AGSA_MAX_OUTBOUND_Q
operator|>
name|outq
operator|)
argument_list|,
literal|"The OBQ Number is out of range."
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SA_USE_MAX_Q
name|outq
operator|=
name|saRoot
operator|->
name|QueueConfig
operator|.
name|numOutboundQueues
operator|-
literal|1
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"mpiBuildCmd, set OBQ to  %d\n"
operator|,
name|outq
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SA_USE_MAX_Q */
comment|/* get a free inbound queue entry */
ifdef|#
directive|ifdef
name|SA_LL_IBQ_PROTECT
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_IBQ0_LOCK
operator|+
name|inq
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SA_LL_IBQ_PROTECT */
name|circularQ
operator|=
operator|&
name|saRoot
operator|->
name|inboundQueue
index|[
name|inq
index|]
expr_stmt|;
name|retVal
operator|=
name|mpiMsgFreeGet
argument_list|(
name|circularQ
argument_list|,
name|size
argument_list|,
operator|&
name|pMessage
argument_list|)
expr_stmt|;
comment|/* return FAILURE if error happened */
if|if
condition|(
name|AGSA_RC_FAILURE
operator|==
name|retVal
condition|)
block|{
ifdef|#
directive|ifdef
name|SA_LL_IBQ_PROTECT
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_IBQ0_LOCK
operator|+
name|inq
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SA_LL_IBQ_PROTECT */
comment|/* the message size exceeds the inbound queue message size */
name|SA_DBG1
argument_list|(
operator|(
literal|"mpiBuildCmd, failure\n"
operator|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|AGSA_RC_FAILURE
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'a'
argument_list|,
literal|"xb"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
comment|/* return BUSY if no more inbound queue entry available */
if|if
condition|(
name|AGSA_RC_BUSY
operator|==
name|retVal
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"mpiBuildCmd, no more IOMB\n"
operator|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|AGSA_RC_BUSY
expr_stmt|;
block|}
else|else
block|{
comment|/* copy payload if it is necessary */
if|if
condition|(
name|agNULL
operator|!=
name|payload
condition|)
block|{
name|si_memcpy
argument_list|(
name|pMessage
argument_list|,
name|payload
argument_list|,
operator|(
name|size
operator|-
sizeof|sizeof
argument_list|(
name|mpiMsgHeader_t
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* post the message to SPC */
if|if
condition|(
name|AGSA_RC_FAILURE
operator|==
name|mpiMsgProduce
argument_list|(
name|circularQ
argument_list|,
operator|(
name|void
operator|*
operator|)
name|pMessage
argument_list|,
name|category
argument_list|,
name|opcode
argument_list|,
name|outq
argument_list|,
operator|(
name|bit8
operator|)
name|circularQ
operator|->
name|priority
argument_list|)
condition|)
block|{
name|ret
operator|=
name|AGSA_RC_FAILURE
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|SA_LL_IBQ_PROTECT
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_IBQ0_LOCK
operator|+
name|inq
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SA_LL_IBQ_PROTECT */
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'b'
argument_list|,
literal|"xb"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*! \brief SPC MPI ECHO Command  *  *  This command used to test that MPI between host and SPC IOP is operational.  *  *  \param agRoot       Handles for this instance of SAS/SATA LLL  *  \param queueNum     Inbound/outbound queue number  *  \param tag          Tag of this IOMB  *  \param echoPayload  Pointer to the ECHO payload of inbound IOMB  *  *  \return If the MPI command is sent to SPC successfully  *          - \e AGSA_RC_SUCCESS the MPI command is successfully  *          - \e AGSA_RC_BUSY the SPC is no resource, cannot send now  *          - \e AGSA_RC_FAILURE the MPI command is failure  *  */
end_comment

begin_comment
comment|/*******************************************************************************/
end_comment

begin_function
name|GLOBAL
name|bit32
name|mpiEchoCmd
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|bit32
name|queueNum
parameter_list|,
name|agsaContext_t
modifier|*
name|agContext
parameter_list|,
name|void
modifier|*
name|echoPayload
parameter_list|)
block|{
name|bit32
name|ret
init|=
name|AGSA_RC_SUCCESS
decl_stmt|;
name|agsaLLRoot_t
modifier|*
name|saRoot
init|=
operator|(
name|agsaLLRoot_t
operator|*
operator|)
operator|(
name|agRoot
operator|->
name|sdkData
operator|)
decl_stmt|;
name|agsaIORequestDesc_t
modifier|*
name|pRequest
decl_stmt|;
name|agsaEchoCmd_t
name|payload
decl_stmt|;
name|smTraceFuncEnter
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|"xc"
argument_list|)
expr_stmt|;
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
comment|/* Get request from free IORequests */
name|pRequest
operator|=
operator|(
name|agsaIORequestDesc_t
operator|*
operator|)
name|saLlistIOGetHead
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|)
expr_stmt|;
comment|/* If no LL Control request entry available */
if|if
condition|(
name|agNULL
operator|==
name|pRequest
condition|)
block|{
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"mpiEchoCmd, No request from free list\n"
operator|)
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'a'
argument_list|,
literal|"xc"
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_BUSY
return|;
block|}
comment|/* If LL Control request entry avaliable */
else|else
block|{
comment|/* Remove the request from free list */
name|SA_ASSERT
argument_list|(
operator|(
operator|!
name|pRequest
operator|->
name|valid
operator|)
argument_list|,
literal|"The pRequest is in use"
argument_list|)
expr_stmt|;
name|saLlistIORemove
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|Tag
operator|=
name|pRequest
operator|->
name|HTag
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|IORequest
operator|=
operator|(
name|void
operator|*
operator|)
name|pRequest
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|agContext
operator|=
name|agContext
expr_stmt|;
name|pRequest
operator|->
name|valid
operator|=
name|agTRUE
expr_stmt|;
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
comment|/* build IOMB command and send to SPC */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaEchoCmd_t
argument_list|,
name|tag
argument_list|)
argument_list|,
name|pRequest
operator|->
name|HTag
argument_list|)
expr_stmt|;
comment|/* copy Echo payload */
name|si_memcpy
argument_list|(
operator|&
name|payload
operator|.
name|payload
index|[
literal|0
index|]
argument_list|,
name|echoPayload
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
name|agsaEchoCmd_t
argument_list|)
operator|-
literal|4
operator|)
argument_list|)
expr_stmt|;
comment|/* build IOMB command and send to SPC */
name|ret
operator|=
name|mpiBuildCmd
argument_list|(
name|agRoot
argument_list|,
operator|(
name|bit32
operator|*
operator|)
operator|&
name|payload
argument_list|,
name|MPI_CATEGORY_SAS_SATA
argument_list|,
name|OPC_INB_ECHO
argument_list|,
name|IOMB_SIZE64
argument_list|,
name|queueNum
argument_list|)
expr_stmt|;
name|SA_DBG3
argument_list|(
operator|(
literal|"mpiEchoCmd, return value = %d\n"
operator|,
name|ret
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|AGSA_RC_SUCCESS
operator|!=
name|ret
condition|)
block|{
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
comment|/* remove the request from IOMap */
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|Tag
operator|=
name|MARK_OFF
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|IORequest
operator|=
name|agNULL
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|agContext
operator|=
name|agNULL
expr_stmt|;
name|pRequest
operator|->
name|valid
operator|=
name|agFALSE
expr_stmt|;
comment|/* return the request to free pool */
name|saLlistIOAdd
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"mpiEchoCmd, sending IOMB failed\n"
operator|)
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SALL_API_TEST
else|else
block|{
name|saRoot
operator|->
name|LLCounters
operator|.
name|IOCounter
operator|.
name|numEchoSent
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
block|}
comment|/* return value */
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'b'
argument_list|,
literal|"xc"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*! \brief Get Phy Profile Command SPCv  *  *  This command is get # of phys and support speeds from SPCV.  *  *  \param agRoot       Handles for this instance of SAS/SATA LLL  *  \param agDevHandle  Handle of device  *  *  \return If the MPI command is sent to SPC successfully  *          - \e AGSA_RC_SUCCESS the MPI command is successfully  *          - \e AGSA_RC_BUSY the SPC is no resource, cannot send now  *          - \e AGSA_RC_FAILURE the MPI command is failure  *  */
end_comment

begin_comment
comment|/*******************************************************************************/
end_comment

begin_function
name|GLOBAL
name|bit32
name|mpiGetPhyProfileCmd
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|agsaContext_t
modifier|*
name|agContext
parameter_list|,
name|bit32
name|Operation
parameter_list|,
name|bit32
name|PhyId
parameter_list|,
name|void
modifier|*
name|agCB
parameter_list|)
block|{
name|agsaLLRoot_t
modifier|*
name|saRoot
init|=
operator|(
name|agsaLLRoot_t
operator|*
operator|)
operator|(
name|agRoot
operator|->
name|sdkData
operator|)
decl_stmt|;
name|agsaIORequestDesc_t
modifier|*
name|pRequest
decl_stmt|;
name|bit32
name|ret
init|=
name|AGSA_RC_SUCCESS
decl_stmt|;
name|agsaGetPhyProfileCmd_V_t
name|payload
decl_stmt|;
name|smTraceFuncEnter
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|"xd"
argument_list|)
expr_stmt|;
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
comment|/* Get request from free IORequests */
name|pRequest
operator|=
operator|(
name|agsaIORequestDesc_t
operator|*
operator|)
name|saLlistGetHead
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"mpiGetPhyProfileCmd, Operation 0x%x PhyId %d \n"
operator|,
name|Operation
operator|,
name|PhyId
operator|)
argument_list|)
expr_stmt|;
comment|/* If no LL Control request entry avalibale */
if|if
condition|(
name|agNULL
operator|==
name|pRequest
condition|)
block|{
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"mpiGetPhyProfileCmd, No request from free list\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_BUSY
return|;
block|}
comment|/* If LL Control request entry avaliable */
else|else
block|{
name|SA_ASSERT
argument_list|(
operator|(
operator|!
name|pRequest
operator|->
name|valid
operator|)
argument_list|,
literal|"The pRequest is in use"
argument_list|)
expr_stmt|;
comment|/* Remove the request from free list */
name|saLlistRemove
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|Tag
operator|=
name|pRequest
operator|->
name|HTag
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|IORequest
operator|=
operator|(
name|void
operator|*
operator|)
name|pRequest
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|agContext
operator|=
name|agContext
expr_stmt|;
name|pRequest
operator|->
name|valid
operator|=
name|agTRUE
expr_stmt|;
name|pRequest
operator|->
name|completionCB
operator|=
name|agCB
expr_stmt|;
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
comment|/* set payload to zeros */
name|si_memset
argument_list|(
operator|&
name|payload
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|agsaGetPhyProfileCmd_V_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* set tag field */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaGetPhyProfileCmd_V_t
argument_list|,
name|tag
argument_list|)
argument_list|,
name|pRequest
operator|->
name|HTag
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaGetPhyProfileCmd_V_t
argument_list|,
name|Reserved_Ppc_SOP_PHYID
argument_list|)
argument_list|,
operator|(
operator|(
operator|(
name|Operation
operator|&
literal|0xF
operator|)
operator|<<
name|SHIFT8
operator|)
operator||
operator|(
name|PhyId
operator|&
literal|0xFF
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* build IOMB command and send to SPC */
name|ret
operator|=
name|mpiBuildCmd
argument_list|(
name|agRoot
argument_list|,
operator|(
name|bit32
operator|*
operator|)
operator|&
name|payload
argument_list|,
name|MPI_CATEGORY_SAS_SATA
argument_list|,
name|OPC_INB_GET_PHY_PROFILE
argument_list|,
name|IOMB_SIZE128
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|AGSA_RC_SUCCESS
operator|!=
name|ret
condition|)
block|{
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|pRequest
operator|->
name|valid
operator|=
name|agFALSE
expr_stmt|;
comment|/* return the request to free pool */
name|saLlistAdd
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
comment|/* remove the request from IOMap */
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|Tag
operator|=
name|MARK_OFF
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|IORequest
operator|=
name|agNULL
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|agContext
operator|=
name|agNULL
expr_stmt|;
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"mpiGetPhyProfileCmd, sending IOMB failed\n"
operator|)
argument_list|)
expr_stmt|;
block|}
name|SA_DBG3
argument_list|(
operator|(
literal|"mpiGetPhyProfileCmd, return value = %d\n"
operator|,
name|ret
operator|)
argument_list|)
expr_stmt|;
block|}
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'a'
argument_list|,
literal|"xd"
argument_list|)
expr_stmt|;
comment|/* return value */
return|return
name|ret
return|;
block|}
end_function

begin_function
name|GLOBAL
name|bit32
name|mpiVHistCapCmd
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|agsaContext_t
modifier|*
name|agContext
parameter_list|,
name|bit32
name|queueNum
parameter_list|,
name|bit32
name|Channel
parameter_list|,
name|bit32
name|NumBitLo
parameter_list|,
name|bit32
name|NumBitHi
parameter_list|,
name|bit32
name|PcieAddrLo
parameter_list|,
name|bit32
name|PcieAddrHi
parameter_list|,
name|bit32
name|ByteCount
parameter_list|)
block|{
name|agsaLLRoot_t
modifier|*
name|saRoot
init|=
operator|(
name|agsaLLRoot_t
operator|*
operator|)
operator|(
name|agRoot
operator|->
name|sdkData
operator|)
decl_stmt|;
name|agsaIORequestDesc_t
modifier|*
name|pRequest
init|=
name|agNULL
decl_stmt|;
name|bit32
name|ret
init|=
name|AGSA_RC_SUCCESS
decl_stmt|;
name|agsaGetVHistCap_V_t
name|payload
decl_stmt|;
name|smTraceFuncEnter
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|"3C"
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"mpiVHistCapCmd\n"
operator|)
argument_list|)
expr_stmt|;
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
comment|/* Get request from free IORequests */
name|pRequest
operator|=
operator|(
name|agsaIORequestDesc_t
operator|*
operator|)
name|saLlistGetHead
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|)
expr_stmt|;
comment|/* If no LL Control request entry avalibale */
if|if
condition|(
name|agNULL
operator|==
name|pRequest
condition|)
block|{
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|", No request from free list\n"
operator|)
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'a'
argument_list|,
literal|"3C"
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_BUSY
return|;
block|}
comment|/* If LL Control request entry avaliable */
else|else
block|{
name|SA_ASSERT
argument_list|(
operator|(
operator|!
name|pRequest
operator|->
name|valid
operator|)
argument_list|,
literal|"The pRequest is in use"
argument_list|)
expr_stmt|;
comment|/* Remove the request from free list */
name|saLlistRemove
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|Tag
operator|=
name|pRequest
operator|->
name|HTag
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|IORequest
operator|=
operator|(
name|void
operator|*
operator|)
name|pRequest
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|agContext
operator|=
name|agContext
expr_stmt|;
name|pRequest
operator|->
name|valid
operator|=
name|agTRUE
expr_stmt|;
name|pRequest
operator|->
name|completionCB
operator|=
operator|(
name|void
operator|*
operator|)
name|ossaGetPhyProfileCB
expr_stmt|;
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
comment|/* set payload to zeros */
name|si_memset
argument_list|(
operator|&
name|payload
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|agsaGetVHistCap_V_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* set tag field */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaGetVHistCap_V_t
argument_list|,
name|tag
argument_list|)
argument_list|,
name|pRequest
operator|->
name|HTag
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaGetVHistCap_V_t
argument_list|,
name|Channel
argument_list|)
argument_list|,
name|Channel
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaGetVHistCap_V_t
argument_list|,
name|NumBitLo
argument_list|)
argument_list|,
name|NumBitLo
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaGetVHistCap_V_t
argument_list|,
name|NumBitHi
argument_list|)
argument_list|,
name|NumBitHi
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaGetVHistCap_V_t
argument_list|,
name|PcieAddrLo
argument_list|)
argument_list|,
name|PcieAddrLo
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaGetVHistCap_V_t
argument_list|,
name|PcieAddrHi
argument_list|)
argument_list|,
name|PcieAddrHi
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaGetVHistCap_V_t
argument_list|,
name|ByteCount
argument_list|)
argument_list|,
name|ByteCount
argument_list|)
expr_stmt|;
comment|/* build IOMB command and send to SPC */
name|ret
operator|=
name|mpiBuildCmd
argument_list|(
name|agRoot
argument_list|,
operator|(
name|bit32
operator|*
operator|)
operator|&
name|payload
argument_list|,
name|MPI_CATEGORY_SAS_SATA
argument_list|,
name|OPC_INB_GET_VHIST_CAP
argument_list|,
name|IOMB_SIZE128
argument_list|,
name|queueNum
argument_list|)
expr_stmt|;
if|if
condition|(
name|AGSA_RC_SUCCESS
operator|!=
name|ret
condition|)
block|{
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|pRequest
operator|->
name|valid
operator|=
name|agFALSE
expr_stmt|;
comment|/* return the request to free pool */
name|saLlistAdd
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
comment|/* remove the request from IOMap */
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|Tag
operator|=
name|MARK_OFF
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|IORequest
operator|=
name|agNULL
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|agContext
operator|=
name|agNULL
expr_stmt|;
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"mpiVHistCapCmd, sending IOMB failed\n"
operator|)
argument_list|)
expr_stmt|;
block|}
name|SA_DBG3
argument_list|(
operator|(
literal|"mpiVHistCapCmd, return value = %d\n"
operator|,
name|ret
operator|)
argument_list|)
expr_stmt|;
block|}
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'b'
argument_list|,
literal|"3C"
argument_list|)
expr_stmt|;
comment|/* return value */
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|GLOBAL
name|bit32
name|mpiSetPhyProfileCmd
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|agsaContext_t
modifier|*
name|agContext
parameter_list|,
name|bit32
name|Operation
parameter_list|,
name|bit32
name|PhyId
parameter_list|,
name|bit32
name|length
parameter_list|,
name|void
modifier|*
name|buffer
parameter_list|)
block|{
name|agsaLLRoot_t
modifier|*
name|saRoot
init|=
operator|(
name|agsaLLRoot_t
operator|*
operator|)
operator|(
name|agRoot
operator|->
name|sdkData
operator|)
decl_stmt|;
name|agsaIORequestDesc_t
modifier|*
name|pRequest
decl_stmt|;
name|bit32
name|ret
init|=
name|AGSA_RC_SUCCESS
decl_stmt|;
name|bit32
name|i
decl_stmt|;
name|agsaSetPhyProfileCmd_V_t
name|payload
decl_stmt|;
name|bit32
modifier|*
name|PageData
init|=
operator|(
name|bit32
operator|*
operator|)
name|buffer
decl_stmt|;
name|smTraceFuncEnter
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|"2P"
argument_list|)
expr_stmt|;
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
comment|/* Get request from free IORequests */
name|pRequest
operator|=
operator|(
name|agsaIORequestDesc_t
operator|*
operator|)
name|saLlistGetHead
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"mpiSetPhyProfileCmd, Operation 0x%x PhyId %d \n"
operator|,
name|Operation
operator|,
name|PhyId
operator|)
argument_list|)
expr_stmt|;
comment|/* If no LL Control request entry avalibale */
if|if
condition|(
name|agNULL
operator|==
name|pRequest
condition|)
block|{
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"mpiSetPhyProfileCmd, No request from free list\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_BUSY
return|;
block|}
comment|/* If LL Control request entry avaliable */
else|else
block|{
name|SA_ASSERT
argument_list|(
operator|(
operator|!
name|pRequest
operator|->
name|valid
operator|)
argument_list|,
literal|"The pRequest is in use"
argument_list|)
expr_stmt|;
comment|/* Remove the request from free list */
name|saLlistRemove
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|Tag
operator|=
name|pRequest
operator|->
name|HTag
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|IORequest
operator|=
operator|(
name|void
operator|*
operator|)
name|pRequest
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|agContext
operator|=
name|agContext
expr_stmt|;
name|pRequest
operator|->
name|valid
operator|=
name|agTRUE
expr_stmt|;
name|pRequest
operator|->
name|SOP
operator|=
operator|(
name|bit16
operator|)
name|Operation
expr_stmt|;
name|pRequest
operator|->
name|completionCB
operator|=
operator|(
name|void
operator|*
operator|)
name|ossaGetPhyProfileCB
expr_stmt|;
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
comment|/* set payload to zeros */
name|si_memset
argument_list|(
operator|&
name|payload
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|agsaSetPhyProfileCmd_V_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* set tag field */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSetPhyProfileCmd_V_t
argument_list|,
name|tag
argument_list|)
argument_list|,
name|pRequest
operator|->
name|HTag
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSetPhyProfileCmd_V_t
argument_list|,
name|Reserved_Ppc_SOP_PHYID
argument_list|)
argument_list|,
operator|(
operator|(
operator|(
name|Operation
operator|&
literal|0xF
operator|)
operator|<<
name|SHIFT8
operator|)
operator||
operator|(
name|PhyId
operator|&
literal|0xFF
operator|)
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|length
operator|/
sizeof|sizeof
argument_list|(
name|bit32
argument_list|)
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSetPhyProfileCmd_V_t
argument_list|,
name|PageSpecificArea
index|[
name|i
index|]
argument_list|)
argument_list|,
operator|*
operator|(
name|PageData
operator|+
name|i
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* build IOMB command and send to SPC */
name|ret
operator|=
name|mpiBuildCmd
argument_list|(
name|agRoot
argument_list|,
operator|(
name|bit32
operator|*
operator|)
operator|&
name|payload
argument_list|,
name|MPI_CATEGORY_SAS_SATA
argument_list|,
name|OPC_INB_SET_PHY_PROFILE
argument_list|,
name|IOMB_SIZE128
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|AGSA_RC_SUCCESS
operator|!=
name|ret
condition|)
block|{
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|pRequest
operator|->
name|valid
operator|=
name|agFALSE
expr_stmt|;
comment|/* return the request to free pool */
name|saLlistAdd
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
comment|/* remove the request from IOMap */
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|Tag
operator|=
name|MARK_OFF
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|IORequest
operator|=
name|agNULL
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|agContext
operator|=
name|agNULL
expr_stmt|;
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"mpiSetPhyProfileCmd, sending IOMB failed\n"
operator|)
argument_list|)
expr_stmt|;
block|}
name|SA_DBG3
argument_list|(
operator|(
literal|"mpiGetPhyProfileCmd, return value = %d\n"
operator|,
name|ret
operator|)
argument_list|)
expr_stmt|;
block|}
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'a'
argument_list|,
literal|"2P"
argument_list|)
expr_stmt|;
comment|/* return value */
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*! \brief Get Device Information Command  *  *  This command is get # of phys and support speeds from SPC.  *  *  \param agRoot       Handles for this instance of SAS/SATA LLL  *  \param agDevHandle  Handle of device  *  \param deviceid     Device Id  *  \param opton        oprion  *  *  \return If the MPI command is sent to SPC successfully  *          - \e AGSA_RC_SUCCESS the MPI command is successfully  *          - \e AGSA_RC_BUSY the SPC is no resource, cannot send now  *          - \e AGSA_RC_FAILURE the MPI command is failure  *  */
end_comment

begin_comment
comment|/*******************************************************************************/
end_comment

begin_function
name|GLOBAL
name|bit32
name|mpiGetDeviceInfoCmd
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|agsaContext_t
modifier|*
name|agContext
parameter_list|,
name|bit32
name|deviceid
parameter_list|,
name|bit32
name|option
parameter_list|,
name|bit32
name|queueNum
parameter_list|)
block|{
name|agsaLLRoot_t
modifier|*
name|saRoot
init|=
operator|(
name|agsaLLRoot_t
operator|*
operator|)
operator|(
name|agRoot
operator|->
name|sdkData
operator|)
decl_stmt|;
name|agsaIORequestDesc_t
modifier|*
name|pRequest
decl_stmt|;
name|bit32
name|ret
init|=
name|AGSA_RC_SUCCESS
decl_stmt|;
name|agsaGetDevInfoCmd_t
name|payload
decl_stmt|;
name|SA_ASSERT
argument_list|(
operator|(
name|agNULL
operator|!=
name|saRoot
operator|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|saRoot
operator|==
name|agNULL
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"mpiGetDeviceInfoCmd: saRoot == agNULL\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|AGSA_RC_FAILURE
operator|)
return|;
block|}
name|smTraceFuncEnter
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|"2K"
argument_list|)
expr_stmt|;
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
comment|/* Get request from free IORequests */
name|pRequest
operator|=
operator|(
name|agsaIORequestDesc_t
operator|*
operator|)
name|saLlistIOGetHead
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|)
expr_stmt|;
comment|/* If no LL Control request entry available */
if|if
condition|(
name|agNULL
operator|==
name|pRequest
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"mpiGetDeviceInfoCmd, No request from free list\n"
operator|)
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'a'
argument_list|,
literal|"2K"
argument_list|)
expr_stmt|;
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_BUSY
return|;
block|}
comment|/* If LL Control request entry avaliable */
else|else
block|{
comment|/* Remove the request from free list */
name|SA_ASSERT
argument_list|(
operator|(
operator|!
name|pRequest
operator|->
name|valid
operator|)
argument_list|,
literal|"The pRequest is in use"
argument_list|)
expr_stmt|;
name|saLlistIORemove
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|Tag
operator|=
name|pRequest
operator|->
name|HTag
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|IORequest
operator|=
operator|(
name|void
operator|*
operator|)
name|pRequest
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|agContext
operator|=
name|agContext
expr_stmt|;
name|pRequest
operator|->
name|valid
operator|=
name|agTRUE
expr_stmt|;
name|pRequest
operator|->
name|DeviceInfoCmdOption
operator|=
operator|(
name|bit8
operator|)
name|option
expr_stmt|;
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
comment|/* set payload to zeros */
name|si_memset
argument_list|(
operator|&
name|payload
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|agsaGetDevInfoCmd_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* set tag field */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaGetDevInfoCmd_t
argument_list|,
name|tag
argument_list|)
argument_list|,
name|pRequest
operator|->
name|HTag
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaGetDevInfoCmd_t
argument_list|,
name|DeviceId
argument_list|)
argument_list|,
name|deviceid
argument_list|)
expr_stmt|;
comment|/* build IOMB command and send to SPC */
if|if
condition|(
name|smIS_SPC
argument_list|(
name|agRoot
argument_list|)
condition|)
block|{
name|ret
operator|=
name|mpiBuildCmd
argument_list|(
name|agRoot
argument_list|,
operator|(
name|bit32
operator|*
operator|)
operator|&
name|payload
argument_list|,
name|MPI_CATEGORY_SAS_SATA
argument_list|,
name|OPC_INB_SPC_GET_DEV_INFO
argument_list|,
name|IOMB_SIZE64
argument_list|,
name|queueNum
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|mpiBuildCmd
argument_list|(
name|agRoot
argument_list|,
operator|(
name|bit32
operator|*
operator|)
operator|&
name|payload
argument_list|,
name|MPI_CATEGORY_SAS_SATA
argument_list|,
name|OPC_INB_GET_DEV_INFO
argument_list|,
name|IOMB_SIZE64
argument_list|,
name|queueNum
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|AGSA_RC_SUCCESS
operator|!=
name|ret
condition|)
block|{
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
comment|/* remove the request from IOMap */
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|Tag
operator|=
name|MARK_OFF
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|IORequest
operator|=
name|agNULL
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|agContext
operator|=
name|agNULL
expr_stmt|;
name|pRequest
operator|->
name|valid
operator|=
name|agFALSE
expr_stmt|;
comment|/* return the request to free pool */
name|saLlistIOAdd
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"mpiGetDeviceInfoCmd, sending IOMB failed\n"
operator|)
argument_list|)
expr_stmt|;
block|}
name|SA_DBG3
argument_list|(
operator|(
literal|"mpiGetDeviceInfoCmd, return value = %d\n"
operator|,
name|ret
operator|)
argument_list|)
expr_stmt|;
block|}
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'b'
argument_list|,
literal|"2K"
argument_list|)
expr_stmt|;
comment|/* return value */
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*! \brief Set Device Information Command  *  *  This command is Set Device Information to SPC.  *  *  \param agRoot       Handles for this instance of SAS/SATA LLL  *  \param agDevHandle  Handle of device  *  \param deviceid     Device Id  *  \param opton        oprion  *  *  \return If the MPI command is sent to SPC successfully  *          - \e AGSA_RC_SUCCESS the MPI command is successfully  *          - \e AGSA_RC_BUSY the SPC is no resource, cannot send now  *          - \e AGSA_RC_FAILURE the MPI command is failure  *  */
end_comment

begin_comment
comment|/*******************************************************************************/
end_comment

begin_function
name|GLOBAL
name|bit32
name|mpiSetDeviceInfoCmd
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|agsaContext_t
modifier|*
name|agContext
parameter_list|,
name|bit32
name|deviceid
parameter_list|,
name|bit32
name|option
parameter_list|,
name|bit32
name|queueNum
parameter_list|,
name|bit32
name|param
parameter_list|,
name|ossaSetDeviceInfoCB_t
name|agCB
parameter_list|)
block|{
name|agsaLLRoot_t
modifier|*
name|saRoot
init|=
name|agNULL
decl_stmt|;
name|agsaIORequestDesc_t
modifier|*
name|pRequest
init|=
name|agNULL
decl_stmt|;
name|bit32
name|ret
init|=
name|AGSA_RC_SUCCESS
decl_stmt|;
name|agsaSetDevInfoCmd_t
name|payload
decl_stmt|;
name|smTraceFuncEnter
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|"xe"
argument_list|)
expr_stmt|;
comment|/* sanity check */
name|SA_ASSERT
argument_list|(
operator|(
name|agNULL
operator|!=
name|agRoot
operator|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|saRoot
operator|=
operator|(
name|agsaLLRoot_t
operator|*
operator|)
operator|(
name|agRoot
operator|->
name|sdkData
operator|)
expr_stmt|;
name|SA_ASSERT
argument_list|(
operator|(
name|agNULL
operator|!=
name|saRoot
operator|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* Get request from free IORequests */
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|pRequest
operator|=
operator|(
name|agsaIORequestDesc_t
operator|*
operator|)
name|saLlistIOGetHead
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG2
argument_list|(
operator|(
literal|"mpiSetDeviceInfoCmd, param 0x%08X option 0x%08X\n"
operator|,
name|param
operator|,
name|option
operator|)
argument_list|)
expr_stmt|;
comment|/* If no LL Control request entry available */
if|if
condition|(
name|agNULL
operator|==
name|pRequest
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"mpiSetDeviceInfoCmd, No request from free list\n"
operator|)
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'a'
argument_list|,
literal|"xe"
argument_list|)
expr_stmt|;
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_BUSY
return|;
block|}
comment|/* If LL Control request entry avaliable */
else|else
block|{
comment|/* Remove the request from free list */
name|saLlistIORemove
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|Tag
operator|=
name|pRequest
operator|->
name|HTag
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|IORequest
operator|=
operator|(
name|void
operator|*
operator|)
name|pRequest
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|agContext
operator|=
name|agContext
expr_stmt|;
name|pRequest
operator|->
name|valid
operator|=
name|agTRUE
expr_stmt|;
name|pRequest
operator|->
name|completionCB
operator|=
operator|(
name|ossaSSPCompletedCB_t
operator|)
name|agCB
expr_stmt|;
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
comment|/* set payload to zeros */
name|si_memset
argument_list|(
operator|&
name|payload
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|agsaSetDevInfoCmd_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* set tag field */
if|if
condition|(
name|smIS_SPC
argument_list|(
name|agRoot
argument_list|)
condition|)
block|{
name|option
operator|&=
name|SET_DEV_INFO_SPC_DW3_MASK
expr_stmt|;
name|param
operator|&=
name|SET_DEV_INFO_SPC_DW4_MASK
expr_stmt|;
block|}
else|else
block|{
name|option
operator|&=
name|SET_DEV_INFO_V_DW3_MASK
expr_stmt|;
name|param
operator|&=
name|SET_DEV_INFO_V_DW4_MASK
expr_stmt|;
block|}
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSetDevInfoCmd_t
argument_list|,
name|tag
argument_list|)
argument_list|,
name|pRequest
operator|->
name|HTag
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSetDevInfoCmd_t
argument_list|,
name|deviceId
argument_list|)
argument_list|,
name|deviceid
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSetDevInfoCmd_t
argument_list|,
name|SA_SR_SI
argument_list|)
argument_list|,
name|option
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSetDevInfoCmd_t
argument_list|,
name|DEVA_MCN_R_ITNT
argument_list|)
argument_list|,
name|param
argument_list|)
expr_stmt|;
comment|/* build IOMB command and send to SPC */
name|ret
operator|=
name|mpiBuildCmd
argument_list|(
name|agRoot
argument_list|,
operator|(
name|bit32
operator|*
operator|)
operator|&
name|payload
argument_list|,
name|MPI_CATEGORY_SAS_SATA
argument_list|,
name|OPC_INB_SET_DEV_INFO
argument_list|,
name|IOMB_SIZE64
argument_list|,
name|queueNum
argument_list|)
expr_stmt|;
if|if
condition|(
name|AGSA_RC_SUCCESS
operator|!=
name|ret
condition|)
block|{
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
comment|/* remove the request from IOMap */
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|Tag
operator|=
name|MARK_OFF
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|IORequest
operator|=
name|agNULL
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|agContext
operator|=
name|agNULL
expr_stmt|;
name|pRequest
operator|->
name|valid
operator|=
name|agFALSE
expr_stmt|;
comment|/* return the request to free pool */
name|saLlistIOAdd
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"mpiSetDeviceInfoCmd, sending IOMB failed\n"
operator|)
argument_list|)
expr_stmt|;
block|}
name|SA_DBG3
argument_list|(
operator|(
literal|"mpiSetDeviceInfoCmd, return value = %d\n"
operator|,
name|ret
operator|)
argument_list|)
expr_stmt|;
block|}
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'b'
argument_list|,
literal|"xe"
argument_list|)
expr_stmt|;
comment|/* return value */
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*! \brief SPC MPI Phy Start Command  *  *  This command sends to SPC for the I/O.  *  *  \param agRoot        Handles for this instance of SAS/SATA LLL  *  \param tag           tage for IOMB  *  \param phyId         the phy id of the link will be started  *  \param agPhyConfig   the phy properity  *  \param agSASIdentify the SAS identify frame will be sent by the phy  *  *  \return If the MPI command is sent to SPC successfully  *          - \e AGSA_RC_SUCCESS the MPI command is successfully  *          - \e AGSA_RC_BUSY the SPC is no resource, cannot send now  *          - \e AGSA_RC_FAILURE the MPI command is failure  *  */
end_comment

begin_comment
comment|/*******************************************************************************/
end_comment

begin_function
name|GLOBAL
name|bit32
name|mpiPhyStartCmd
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|bit32
name|tag
parameter_list|,
name|bit32
name|phyId
parameter_list|,
name|agsaPhyConfig_t
modifier|*
name|agPhyConfig
parameter_list|,
name|agsaSASIdentify_t
modifier|*
name|agSASIdentify
parameter_list|,
name|bit32
name|queueNum
parameter_list|)
block|{
name|bit32
name|ret
init|=
name|AGSA_RC_SUCCESS
decl_stmt|;
name|agsaPhyStartCmd_t
name|payload
decl_stmt|;
name|bit32
modifier|*
name|pValue
decl_stmt|;
name|bit32
modifier|*
name|ptemp
decl_stmt|;
name|bit32
name|index
decl_stmt|;
name|bit32
name|dw2
init|=
literal|0
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SALLSDK_DEBUG
argument_list|)
name|bit32
name|Sscd
decl_stmt|;
endif|#
directive|endif
comment|/* SALLSDK_DEBUG */
name|smTraceFuncEnter
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|"xg"
argument_list|)
expr_stmt|;
comment|/* set payload to zeros */
name|si_memset
argument_list|(
operator|&
name|payload
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|agsaPhyStartCmd_t
argument_list|)
argument_list|)
expr_stmt|;
name|pValue
operator|=
operator|(
name|bit32
operator|*
operator|)
name|agSASIdentify
expr_stmt|;
name|ptemp
operator|=
operator|(
name|bit32
operator|*
operator|)
operator|&
name|payload
operator|.
name|sasIdentify
expr_stmt|;
name|index
operator|=
operator|(
name|agPhyConfig
operator|->
name|phyProperties
operator|&
literal|0x0ff00
operator|)
operator|>>
name|SHIFT8
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SALLSDK_DEBUG
argument_list|)
name|Sscd
operator|=
operator|(
name|agPhyConfig
operator|->
name|phyProperties
operator|&
literal|0xf0000
operator|)
operator|>>
name|SHIFT16
expr_stmt|;
endif|#
directive|endif
comment|/* SALLSDK_DEBUG */
name|SA_DBG1
argument_list|(
operator|(
literal|"mpiPhyStartCmd,phyId = %d dw 2 0x%08X\n"
operator|,
name|phyId
operator|,
operator|(
operator|(
name|phyId
operator|&
name|SM_PHYID_MASK
operator|)
operator||
operator|(
operator|(
name|agPhyConfig
operator|->
name|phyProperties
operator|&
literal|0xfff
operator|)
operator|<<
name|SHIFT8
operator|)
operator||
operator|(
name|agPhyConfig
operator|->
name|phyProperties
operator|&
literal|0xf0000
operator|)
operator|)
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG2
argument_list|(
operator|(
literal|"mpiPhyStartCmd,phyId 0x%x phyProperties 0x%x index 0x%x Sscd 0x%x\n"
operator|,
name|phyId
operator|,
name|agPhyConfig
operator|->
name|phyProperties
operator|,
name|index
operator|,
name|Sscd
operator|)
argument_list|)
expr_stmt|;
name|dw2
operator|=
operator|(
operator|(
name|phyId
operator|&
name|SM_PHYID_MASK
operator|)
operator||
comment|/* PHY id */
operator|(
operator|(
name|agPhyConfig
operator|->
name|phyProperties
operator|&
literal|0x000000FF
operator|)
operator|<<
name|SHIFT8
operator|)
operator||
comment|/* SLR Mode */
operator|(
name|agPhyConfig
operator|->
name|phyProperties
operator|&
literal|0x000f0000
operator|)
operator||
comment|/* SSCD */
operator|(
name|agPhyConfig
operator|->
name|phyProperties
operator|&
literal|0x00700000
operator|)
operator||
comment|/* setting bit20, bit21 and bit22 for optical mode */
operator|(
name|agPhyConfig
operator|->
name|phyProperties
operator|&
literal|0x00800000
operator|)
operator|)
expr_stmt|;
comment|/* bit23 active cable mode BCT Disable 12g only*/
comment|/* Haileah Phy analogsetting bit enable*/
if|if
condition|(
name|smIS_SPC
argument_list|(
name|agRoot
argument_list|)
condition|)
block|{
if|if
condition|(
name|smIS_spc8081
argument_list|(
name|agRoot
argument_list|)
condition|)
block|{
name|dw2
operator|=
name|dw2
operator||
literal|0x08000
expr_stmt|;
block|}
block|}
name|SA_DBG1
argument_list|(
operator|(
literal|"mpiPhyStartCmd,dw2 0x%08x\n"
operator|,
name|dw2
operator|)
argument_list|)
expr_stmt|;
name|SA_ASSERT
argument_list|(
operator|(
operator|(
name|agSASIdentify
operator|->
name|sasAddressHi
index|[
literal|0
index|]
operator|||
name|agSASIdentify
operator|->
name|sasAddressHi
index|[
literal|1
index|]
operator|||
name|agSASIdentify
operator|->
name|sasAddressHi
index|[
literal|2
index|]
operator|||
name|agSASIdentify
operator|->
name|sasAddressHi
index|[
literal|3
index|]
operator|||
name|agSASIdentify
operator|->
name|sasAddressLo
index|[
literal|0
index|]
operator|||
name|agSASIdentify
operator|->
name|sasAddressLo
index|[
literal|1
index|]
operator|||
name|agSASIdentify
operator|->
name|sasAddressLo
index|[
literal|2
index|]
operator|||
name|agSASIdentify
operator|->
name|sasAddressLo
index|[
literal|3
index|]
operator|)
operator|)
argument_list|,
literal|"SAS Address Zero"
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"mpiPhyStartCmd,SAS addr Hi 0x%02X%02X%02X%02X Lo 0x%02X%02X%02X%02X\n"
operator|,
name|agSASIdentify
operator|->
name|sasAddressHi
index|[
literal|0
index|]
operator|,
name|agSASIdentify
operator|->
name|sasAddressHi
index|[
literal|1
index|]
operator|,
name|agSASIdentify
operator|->
name|sasAddressHi
index|[
literal|2
index|]
operator|,
name|agSASIdentify
operator|->
name|sasAddressHi
index|[
literal|3
index|]
operator|,
name|agSASIdentify
operator|->
name|sasAddressLo
index|[
literal|0
index|]
operator|,
name|agSASIdentify
operator|->
name|sasAddressLo
index|[
literal|1
index|]
operator|,
name|agSASIdentify
operator|->
name|sasAddressLo
index|[
literal|2
index|]
operator|,
name|agSASIdentify
operator|->
name|sasAddressLo
index|[
literal|3
index|]
operator|)
argument_list|)
expr_stmt|;
comment|/* setup phy ID field */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaPhyStartCmd_t
argument_list|,
name|SscdAseSHLmMlrPhyId
argument_list|)
argument_list|,
name|dw2
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaPhyStartCmd_t
argument_list|,
name|tag
argument_list|)
argument_list|,
name|tag
argument_list|)
expr_stmt|;
comment|/* setup analog setting index field */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaPhyStartCmd_t
argument_list|,
name|analogSetupIdx
argument_list|)
argument_list|,
name|index
argument_list|)
expr_stmt|;
comment|/* copy SASIdentify to payload of IOMB */
name|si_memcpy
argument_list|(
name|ptemp
argument_list|,
name|pValue
argument_list|,
sizeof|sizeof
argument_list|(
name|agsaSASIdentify_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* build IOMB command and send to SPC */
name|ret
operator|=
name|mpiBuildCmd
argument_list|(
name|agRoot
argument_list|,
operator|(
name|bit32
operator|*
operator|)
operator|&
name|payload
argument_list|,
name|MPI_CATEGORY_SAS_SATA
argument_list|,
name|OPC_INB_PHYSTART
argument_list|,
name|IOMB_SIZE64
argument_list|,
name|queueNum
argument_list|)
expr_stmt|;
name|SA_DBG3
argument_list|(
operator|(
literal|"mpiPhyStartCmd, return value = %d\n"
operator|,
name|ret
operator|)
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'a'
argument_list|,
literal|"xg"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*! \brief SPC MPI Phy Stop Command  *  *  This command sends to SPC for the I/O.  *  *  \param agRoot       Handles for this instance of SAS/SATA LLL  *  \param tag          tag of IOMB  *  \param phyId        To stop the phyId  *  *  \return If the MPI command is sent to SPC successfully  *          - \e AGSA_RC_SUCCESS the MPI command is successfully  *          - \e AGSA_RC_BUSY the SPC is no resource, cannot send now  *          - \e AGSA_RC_FAILURE the MPI command is failure  *  */
end_comment

begin_comment
comment|/*******************************************************************************/
end_comment

begin_function
name|GLOBAL
name|bit32
name|mpiPhyStopCmd
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|bit32
name|tag
parameter_list|,
name|bit32
name|phyId
parameter_list|,
name|bit32
name|queueNum
parameter_list|)
block|{
name|bit32
name|ret
init|=
name|AGSA_RC_SUCCESS
decl_stmt|;
name|agsaPhyStopCmd_t
name|payload
decl_stmt|;
name|smTraceFuncEnter
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|"xh"
argument_list|)
expr_stmt|;
comment|/* set payload to zeros */
name|si_memset
argument_list|(
operator|&
name|payload
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|agsaPhyStopCmd_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* set tag */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaPhyStopCmd_t
argument_list|,
name|tag
argument_list|)
argument_list|,
name|tag
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaPhyStopCmd_t
argument_list|,
name|phyId
argument_list|)
argument_list|,
operator|(
name|phyId
operator|&
name|SM_PHYID_MASK
operator|)
argument_list|)
expr_stmt|;
comment|/* build IOMB command and send to SPC */
name|ret
operator|=
name|mpiBuildCmd
argument_list|(
name|agRoot
argument_list|,
operator|(
name|bit32
operator|*
operator|)
operator|&
name|payload
argument_list|,
name|MPI_CATEGORY_SAS_SATA
argument_list|,
name|OPC_INB_PHYSTOP
argument_list|,
name|IOMB_SIZE64
argument_list|,
name|queueNum
argument_list|)
expr_stmt|;
name|SA_DBG3
argument_list|(
operator|(
literal|"mpiPhyStopCmd, return value = %d\n"
operator|,
name|ret
operator|)
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'a'
argument_list|,
literal|"xh"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*! \brief SPC MPI SMP Request Command  *  *  This command sends to SPC for the SMP.  *  *  \param agRoot       Handles for this instance of SAS/SATA LLL  *  \param pIomb        pointer of IOMB  *  \param opcode       opcode of IOMB  *  \param payload      pointer of payload  *  \param inq          inbound queue number  *  \param outq         outbound queue number  *  *  \return If the MPI command is sent to SPC successfully  *          - \e AGSA_RC_SUCCESS the MPI command is successfully  *          - \e AGSA_RC_BUSY the SPC is no resource, cannot send now  *          - \e AGSA_RC_FAILURE the MPI command is failure  *  */
end_comment

begin_comment
comment|/*******************************************************************************/
end_comment

begin_function
name|GLOBAL
name|bit32
name|mpiSMPCmd
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|void
modifier|*
name|pIomb
parameter_list|,
name|bit16
name|opcode
parameter_list|,
name|agsaSMPCmd_t
modifier|*
name|payload
parameter_list|,
name|bit8
name|inq
parameter_list|,
name|bit8
name|outq
parameter_list|)
block|{
name|agsaLLRoot_t
modifier|*
name|saRoot
init|=
operator|(
name|agsaLLRoot_t
operator|*
operator|)
operator|(
name|agRoot
operator|->
name|sdkData
operator|)
decl_stmt|;
name|mpiICQueue_t
modifier|*
name|circularQ
decl_stmt|;
name|bit32
name|ret
init|=
name|AGSA_RC_SUCCESS
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SALLSDK_DEBUG
argument_list|)
name|mpiMsgHeader_t
modifier|*
name|msgHeader
decl_stmt|;
name|bit32
name|bc
decl_stmt|;
endif|#
directive|endif
comment|/* SALLSDK_DEBUG */
name|smTraceFuncEnter
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|"xi"
argument_list|)
expr_stmt|;
name|SA_DBG6
argument_list|(
operator|(
literal|"mpiSMPCmd: start\n"
operator|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SALLSDK_DEBUG
argument_list|)
name|msgHeader
operator|=
operator|(
name|mpiMsgHeader_t
operator|*
operator|)
operator|(
operator|(
operator|(
name|bit8
operator|*
operator|)
name|pIomb
operator|)
operator|-
sizeof|sizeof
argument_list|(
name|mpiMsgHeader_t
argument_list|)
operator|)
expr_stmt|;
name|bc
operator|=
operator|(
operator|(
operator|(
name|msgHeader
operator|->
name|Header
operator|)
operator|>>
name|SHIFT24
operator|)
operator|&
name|BC_MASK
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* SALLSDK_DEBUG */
name|SA_DBG6
argument_list|(
operator|(
literal|"mpiSMPCmd: before msgHeader bc %d\n"
operator|,
name|bc
operator|)
argument_list|)
expr_stmt|;
comment|/* copy payload if it is necessary */
if|if
condition|(
name|agNULL
operator|!=
name|payload
condition|)
block|{
name|si_memcpy
argument_list|(
name|pIomb
argument_list|,
name|payload
argument_list|,
sizeof|sizeof
argument_list|(
name|agsaSMPCmd_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SA_DBG6
argument_list|(
operator|(
literal|"mpiSMPCmd: after msgHeader bc %d\n"
operator|,
name|bc
operator|)
argument_list|)
expr_stmt|;
comment|/* post the IOMB to SPC */
name|circularQ
operator|=
operator|&
name|saRoot
operator|->
name|inboundQueue
index|[
name|inq
index|]
expr_stmt|;
if|if
condition|(
name|AGSA_RC_FAILURE
operator|==
name|mpiMsgProduce
argument_list|(
name|circularQ
argument_list|,
operator|(
name|void
operator|*
operator|)
name|pIomb
argument_list|,
name|MPI_CATEGORY_SAS_SATA
argument_list|,
name|opcode
argument_list|,
name|outq
argument_list|,
operator|(
name|bit8
operator|)
name|circularQ
operator|->
name|priority
argument_list|)
condition|)
name|ret
operator|=
name|AGSA_RC_FAILURE
expr_stmt|;
name|SA_DBG3
argument_list|(
operator|(
literal|"mpiSMPCmd, return value = %d\n"
operator|,
name|ret
operator|)
argument_list|)
expr_stmt|;
comment|/* return value */
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'a'
argument_list|,
literal|"xi"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*! \brief SPC MPI Deregister Device Handle Command  *  *  This command used to deregister(remove) the device handle.  *  *  \param agRoot       Handles for this instance of SAS/SATA LLL  *  \param agDevHandle  Device Handle  *  \param deviceId     index of device  *  \param portId       index of port  *  \param queueNum     IQ/OQ number  *  *  \return If the MPI command is sent to SPC successfully  *          - \e AGSA_RC_SUCCESS the MPI command is successfully  *          - \e AGSA_RC_BUSY the SPC is no resource, cannot send now  *          - \e AGSA_RC_FAILURE the MPI command is failure  *  */
end_comment

begin_comment
comment|/*******************************************************************************/
end_comment

begin_function
name|GLOBAL
name|bit32
name|mpiDeregDevHandleCmd
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|agsaContext_t
modifier|*
name|agContext
parameter_list|,
name|agsaDeviceDesc_t
modifier|*
name|pDevice
parameter_list|,
name|bit32
name|deviceId
parameter_list|,
name|bit32
name|portId
parameter_list|,
name|bit32
name|queueNum
parameter_list|)
block|{
name|bit32
name|ret
init|=
name|AGSA_RC_SUCCESS
decl_stmt|;
name|agsaLLRoot_t
modifier|*
name|saRoot
init|=
operator|(
name|agsaLLRoot_t
operator|*
operator|)
operator|(
name|agRoot
operator|->
name|sdkData
operator|)
decl_stmt|;
name|agsaIORequestDesc_t
modifier|*
name|pRequest
decl_stmt|;
name|agsaDeregDevHandleCmd_t
name|payload
decl_stmt|;
name|smTraceFuncEnter
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|"xp"
argument_list|)
expr_stmt|;
comment|/* Get request from free IORequests */
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|pRequest
operator|=
operator|(
name|agsaIORequestDesc_t
operator|*
operator|)
name|saLlistIOGetHead
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|)
expr_stmt|;
comment|/* If no LL Control request entry available */
if|if
condition|(
name|agNULL
operator|==
name|pRequest
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"mpiDeregDevHandleCmd, No request from free list\n"
operator|)
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'a'
argument_list|,
literal|"xp"
argument_list|)
expr_stmt|;
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_BUSY
return|;
block|}
comment|/* If LL Control request entry avaliable */
else|else
block|{
name|pRequest
operator|->
name|pDevice
operator|=
name|pDevice
expr_stmt|;
comment|/* Remove the request from free list */
name|SA_ASSERT
argument_list|(
operator|(
operator|!
name|pRequest
operator|->
name|valid
operator|)
argument_list|,
literal|"The pRequest is in use"
argument_list|)
expr_stmt|;
name|pRequest
operator|->
name|valid
operator|=
name|agTRUE
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|Tag
operator|=
name|pRequest
operator|->
name|HTag
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|IORequest
operator|=
operator|(
name|void
operator|*
operator|)
name|pRequest
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|agContext
operator|=
name|agContext
expr_stmt|;
name|saLlistIORemove
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
comment|/* clean the payload to zeros */
name|si_memset
argument_list|(
operator|&
name|payload
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|agsaDeregDevHandleCmd_t
argument_list|)
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaDeregDevHandleCmd_t
argument_list|,
name|tag
argument_list|)
argument_list|,
name|pRequest
operator|->
name|HTag
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaDeregDevHandleCmd_t
argument_list|,
name|deviceId
argument_list|)
argument_list|,
name|deviceId
argument_list|)
expr_stmt|;
comment|/* build IOMB command and send it to SPC */
name|ret
operator|=
name|mpiBuildCmd
argument_list|(
name|agRoot
argument_list|,
operator|(
name|bit32
operator|*
operator|)
operator|&
name|payload
argument_list|,
name|MPI_CATEGORY_SAS_SATA
argument_list|,
name|OPC_INB_DEREG_DEV_HANDLE
argument_list|,
name|IOMB_SIZE64
argument_list|,
name|queueNum
argument_list|)
expr_stmt|;
if|if
condition|(
name|AGSA_RC_SUCCESS
operator|!=
name|ret
condition|)
block|{
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
comment|/* remove the request from IOMap */
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|Tag
operator|=
name|MARK_OFF
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|IORequest
operator|=
name|agNULL
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|agContext
operator|=
name|agNULL
expr_stmt|;
name|pRequest
operator|->
name|valid
operator|=
name|agFALSE
expr_stmt|;
comment|/* return the request to free pool */
name|saLlistIOAdd
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"mpiSetVPDCmd, sending IOMB failed\n"
operator|)
argument_list|)
expr_stmt|;
block|}
name|SA_DBG3
argument_list|(
operator|(
literal|"mpiDeregDevHandleCmd, return value = %d\n"
operator|,
name|ret
operator|)
argument_list|)
expr_stmt|;
block|}
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'b'
argument_list|,
literal|"xp"
argument_list|)
expr_stmt|;
comment|/* return value */
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*! \brief SPC MPI Get Device Handle Command  *  *  This command used to get device handle.  *  *  \param agRoot       Handles for this instance of SAS/SATA LLL  *  \param agContext    Context of Device Handle Command  *  \param portId       index of port  *  \param flags        flags  *  \param maxDevs      Maximum Device Handles  *  \param queueNum     IQ/OQ number  *  \param skipCount    skip device entry count  *  *  \return If the MPI command is sent to SPC successfully  *          - \e AGSA_RC_SUCCESS the MPI command is successfully  *          - \e AGSA_RC_BUSY the SPC is no resource, cannot send now  *          - \e AGSA_RC_FAILURE the MPI command is failure  *  */
end_comment

begin_comment
comment|/*******************************************************************************/
end_comment

begin_function
name|GLOBAL
name|bit32
name|mpiGetDeviceHandleCmd
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|agsaContext_t
modifier|*
name|agContext
parameter_list|,
name|bit32
name|portId
parameter_list|,
name|bit32
name|flags
parameter_list|,
name|bit32
name|maxDevs
parameter_list|,
name|bit32
name|queueNum
parameter_list|,
name|bit32
name|skipCount
parameter_list|)
block|{
name|bit32
name|ret
init|=
name|AGSA_RC_SUCCESS
decl_stmt|;
name|agsaLLRoot_t
modifier|*
name|saRoot
init|=
operator|(
name|agsaLLRoot_t
operator|*
operator|)
operator|(
name|agRoot
operator|->
name|sdkData
operator|)
decl_stmt|;
name|agsaIORequestDesc_t
modifier|*
name|pRequest
decl_stmt|;
name|agsaGetDevHandleCmd_t
name|payload
decl_stmt|;
name|bit32
name|using_reserved
init|=
name|agFALSE
decl_stmt|;
name|smTraceFuncEnter
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|"xj"
argument_list|)
expr_stmt|;
comment|/* Get request from free CntrlRequests */
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|pRequest
operator|=
operator|(
name|agsaIORequestDesc_t
operator|*
operator|)
name|saLlistIOGetHead
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|)
expr_stmt|;
comment|/* If no LL Control request entry available */
if|if
condition|(
name|agNULL
operator|==
name|pRequest
condition|)
block|{
name|pRequest
operator|=
operator|(
name|agsaIORequestDesc_t
operator|*
operator|)
name|saLlistIOGetHead
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeReservedRequests
operator|)
argument_list|)
expr_stmt|;
comment|/**/
if|if
condition|(
name|agNULL
operator|!=
name|pRequest
condition|)
block|{
name|using_reserved
operator|=
name|agTRUE
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"mpiGetDeviceHandleCmd, using saRoot->freeReservedRequests\n"
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"mpiGetDeviceHandleCmd, No request from free list Not using saRoot->freeReservedRequests\n"
operator|)
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'a'
argument_list|,
literal|"xj"
argument_list|)
expr_stmt|;
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_BUSY
return|;
block|}
block|}
comment|/* Remove the request from free list */
if|if
condition|(
name|using_reserved
condition|)
block|{
name|saLlistIORemove
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeReservedRequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|saLlistIORemove
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
block|}
name|SA_ASSERT
argument_list|(
operator|(
operator|!
name|pRequest
operator|->
name|valid
operator|)
argument_list|,
literal|"The pRequest is in use"
argument_list|)
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|Tag
operator|=
name|pRequest
operator|->
name|HTag
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|IORequest
operator|=
operator|(
name|void
operator|*
operator|)
name|pRequest
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|agContext
operator|=
name|agContext
expr_stmt|;
name|pRequest
operator|->
name|valid
operator|=
name|agTRUE
expr_stmt|;
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
comment|/* clean the payload to zeros */
name|si_memset
argument_list|(
operator|&
name|payload
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|agsaGetDevHandleCmd_t
argument_list|)
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaGetDevHandleCmd_t
argument_list|,
name|tag
argument_list|)
argument_list|,
name|pRequest
operator|->
name|HTag
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaGetDevHandleCmd_t
argument_list|,
name|DevADevTMaxDIDportId
argument_list|)
argument_list|,
operator|(
operator|(
name|portId
operator|&
name|PORTID_MASK
operator|)
operator||
operator|(
name|maxDevs
operator|<<
name|SHIFT8
operator|)
operator||
operator|(
name|flags
operator|<<
name|SHIFT24
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* set starting Number */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaGetDevHandleCmd_t
argument_list|,
name|skipCount
argument_list|)
argument_list|,
name|skipCount
argument_list|)
expr_stmt|;
comment|/* build IOMB command and send it to SPC */
name|ret
operator|=
name|mpiBuildCmd
argument_list|(
name|agRoot
argument_list|,
operator|(
name|bit32
operator|*
operator|)
operator|&
name|payload
argument_list|,
name|MPI_CATEGORY_SAS_SATA
argument_list|,
name|OPC_INB_GET_DEV_HANDLE
argument_list|,
name|IOMB_SIZE64
argument_list|,
name|queueNum
argument_list|)
expr_stmt|;
if|if
condition|(
name|AGSA_RC_SUCCESS
operator|!=
name|ret
condition|)
block|{
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
comment|/* remove the request from IOMap */
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|Tag
operator|=
name|MARK_OFF
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|IORequest
operator|=
name|agNULL
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|agContext
operator|=
name|agNULL
expr_stmt|;
name|pRequest
operator|->
name|valid
operator|=
name|agFALSE
expr_stmt|;
comment|/* return the request to free pool */
if|if
condition|(
name|saLlistIOGetCount
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeReservedRequests
operator|)
argument_list|)
operator|<
name|SA_RESERVED_REQUEST_COUNT
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"mpiGetDeviceHandleCmd: saving pRequest (%p) for later use\n"
operator|,
name|pRequest
operator|)
argument_list|)
expr_stmt|;
name|saLlistIOAdd
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeReservedRequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* return the request to free pool */
name|saLlistIOAdd
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
block|}
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"mpiGetDeviceHandleCmd, sending IOMB failed\n"
operator|)
argument_list|)
expr_stmt|;
block|}
name|SA_DBG3
argument_list|(
operator|(
literal|"mpiGetDeviceHandleCmd, return value = %d\n"
operator|,
name|ret
operator|)
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'b'
argument_list|,
literal|"xj"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*! \brief SPC MPI LOCAL PHY CONTROL Command  *  *  This command used to do the SPC Phy operation.  *  *  \param agRoot       Handles for this instance of SAS/SATA LLL  *  \param tag          tag of IOMB  *  \param phyId        PHY Id  *  \param operation    operation of PHY control  *  \param queueNum     IQ/OQ number  *  *  \return If the MPI command is sent to SPC successfully  *          - \e AGSA_RC_SUCCESS the MPI command is successfully  *          - \e AGSA_RC_BUSY the SPC is no resource, cannot send now  *          - \e AGSA_RC_FAILURE the MPI command is failure  *  */
end_comment

begin_comment
comment|/*******************************************************************************/
end_comment

begin_function
name|GLOBAL
name|bit32
name|mpiLocalPhyControlCmd
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|bit32
name|tag
parameter_list|,
name|bit32
name|phyId
parameter_list|,
name|bit32
name|operation
parameter_list|,
name|bit32
name|queueNum
parameter_list|)
block|{
name|bit32
name|ret
init|=
name|AGSA_RC_SUCCESS
decl_stmt|;
name|agsaLocalPhyCntrlCmd_t
name|payload
decl_stmt|;
name|smTraceFuncEnter
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|"xl"
argument_list|)
expr_stmt|;
name|SA_DBG3
argument_list|(
operator|(
literal|"mpiLocalPhyControlCmd, phyId 0x%X operation 0x%x dw2 0x%x\n"
operator|,
name|phyId
operator|,
name|operation
operator|,
operator|(
operator|(
operator|(
name|operation
operator|&
name|BYTE_MASK
operator|)
operator|<<
name|SHIFT8
operator|)
operator||
operator|(
name|phyId
operator|&
name|SM_PHYID_MASK
operator|)
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* clean the payload field */
name|si_memset
argument_list|(
operator|&
name|payload
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|agsaLocalPhyCntrlCmd_t
argument_list|)
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaLocalPhyCntrlCmd_t
argument_list|,
name|phyOpPhyId
argument_list|)
argument_list|,
operator|(
operator|(
operator|(
name|operation
operator|&
name|BYTE_MASK
operator|)
operator|<<
name|SHIFT8
operator|)
operator||
operator|(
name|phyId
operator|&
name|SM_PHYID_MASK
operator|)
operator|)
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaLocalPhyCntrlCmd_t
argument_list|,
name|tag
argument_list|)
argument_list|,
name|tag
argument_list|)
expr_stmt|;
comment|/* build IOMB command and send to SPC */
name|ret
operator|=
name|mpiBuildCmd
argument_list|(
name|agRoot
argument_list|,
operator|(
name|bit32
operator|*
operator|)
operator|&
name|payload
argument_list|,
name|MPI_CATEGORY_SAS_SATA
argument_list|,
name|OPC_INB_LOCAL_PHY_CONTROL
argument_list|,
name|IOMB_SIZE64
argument_list|,
name|queueNum
argument_list|)
expr_stmt|;
name|SA_DBG3
argument_list|(
operator|(
literal|"mpiLocalPhyControlCmd, return value = %d\n"
operator|,
name|ret
operator|)
argument_list|)
expr_stmt|;
comment|/* return value */
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'a'
argument_list|,
literal|"xl"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*! \brief Device Handle Accept Command  *  *  This command is Device Handle Accept IOMB to SPC.  *  *  \param agRoot       Handles for this instance of SAS/SATA LLL  *  \param agContext    Context for the set VPD command  *  \param ctag         controller tag  *  \param deviceId     device Id  *  \param action       action  *  \param queueNum     queue Number  *  *  \return If the MPI command is sent to SPC successfully  *          - \e AGSA_RC_SUCCESS the MPI command is successfully  *          - \e AGSA_RC_BUSY the SPC is no resource, cannot send now  *          - \e AGSA_RC_FAILURE the MPI command is failure  *  */
end_comment

begin_comment
comment|/*******************************************************************************/
end_comment

begin_function
name|GLOBAL
name|bit32
name|mpiDevHandleAcceptCmd
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|agsaContext_t
modifier|*
name|agContext
parameter_list|,
name|bit32
name|ctag
parameter_list|,
name|bit32
name|deviceId
parameter_list|,
name|bit32
name|action
parameter_list|,
name|bit32
name|flag
parameter_list|,
name|bit32
name|itlnx
parameter_list|,
name|bit32
name|queueNum
parameter_list|)
block|{
name|bit32
name|ret
init|=
name|AGSA_RC_SUCCESS
decl_stmt|;
name|agsaLLRoot_t
modifier|*
name|saRoot
init|=
operator|(
name|agsaLLRoot_t
operator|*
operator|)
operator|(
name|agRoot
operator|->
name|sdkData
operator|)
decl_stmt|;
name|agsaIORequestDesc_t
modifier|*
name|pRequest
decl_stmt|;
name|agsaDevHandleAcceptCmd_t
name|payload
decl_stmt|;
name|bit32
name|DW4
init|=
literal|0
decl_stmt|;
name|bit32
name|mcn
init|=
literal|0
decl_stmt|;
name|bit32
name|awt
init|=
literal|0
decl_stmt|;
name|bit32
name|ha
init|=
literal|0
decl_stmt|;
name|smTraceFuncEnter
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|"xt"
argument_list|)
expr_stmt|;
if|if
condition|(
name|deviceId
operator|&
literal|0xFFFF0000
condition|)
block|{
name|ha
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Get request from free IORequests */
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|pRequest
operator|=
operator|(
name|agsaIORequestDesc_t
operator|*
operator|)
name|saLlistIOGetHead
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG2
argument_list|(
operator|(
literal|"mpiDevHandleAcceptCmd, deviceId 0x%x action 0x%x flag 0x%x itlnx 0x%x\n"
operator|,
name|deviceId
operator|,
name|action
operator|,
name|flag
operator|,
name|itlnx
operator|)
argument_list|)
expr_stmt|;
comment|/* If no LL Control request entry available */
if|if
condition|(
name|agNULL
operator|==
name|pRequest
condition|)
block|{
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"mpiDevHandleAcceptCmd, No request from free list\n"
operator|)
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'a'
argument_list|,
literal|"xt"
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_BUSY
return|;
block|}
comment|/* If LL Control request entry avaliable */
else|else
block|{
comment|/* Remove the request from free list */
name|SA_ASSERT
argument_list|(
operator|(
operator|!
name|pRequest
operator|->
name|valid
operator|)
argument_list|,
literal|"The pRequest is in use"
argument_list|)
expr_stmt|;
name|saLlistIORemove
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|Tag
operator|=
name|pRequest
operator|->
name|HTag
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|IORequest
operator|=
operator|(
name|void
operator|*
operator|)
name|pRequest
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|agContext
operator|=
name|agContext
expr_stmt|;
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
comment|/* Do not mark as valid at this IOMB does not complete in OBQ */
comment|/* set payload to zeros */
name|si_memset
argument_list|(
operator|&
name|payload
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|agsaDevHandleAcceptCmd_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* set tag field */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaDevHandleAcceptCmd_t
argument_list|,
name|tag
argument_list|)
argument_list|,
name|pRequest
operator|->
name|HTag
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaDevHandleAcceptCmd_t
argument_list|,
name|deviceId
argument_list|)
argument_list|,
name|deviceId
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaDevHandleAcceptCmd_t
argument_list|,
name|Ctag
argument_list|)
argument_list|,
name|ctag
argument_list|)
expr_stmt|;
name|mcn
operator|=
operator|(
name|flag
operator|&
literal|0xF0000
operator|)
operator|>>
name|SHIFT16
expr_stmt|;
name|awt
operator|=
operator|(
name|flag
operator|&
literal|2
operator|)
operator|>>
name|SHIFT1
expr_stmt|;
name|DW4
operator|=
operator|(
name|action
operator|<<
name|SHIFT24
operator|)
operator||
expr|\
name|mcn
operator|<<
name|SHIFT20
operator||
expr|\
name|awt
operator|<<
name|SHIFT17
operator||
expr|\
name|ha
operator|<<
name|SHIFT16
operator||
expr|\
name|itlnx
expr_stmt|;
name|SA_DBG2
argument_list|(
operator|(
literal|"mpiDevHandleAcceptCmd,DW4 0x%x\n"
operator|,
name|DW4
operator|)
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaDevHandleAcceptCmd_t
argument_list|,
name|DevA_MCN_R_R_HA_ITNT
argument_list|)
argument_list|,
name|DW4
argument_list|)
expr_stmt|;
block|}
comment|/* build IOMB command and send to SPC */
name|ret
operator|=
name|mpiBuildCmd
argument_list|(
name|agRoot
argument_list|,
operator|(
name|bit32
operator|*
operator|)
operator|&
name|payload
argument_list|,
name|MPI_CATEGORY_SAS_SATA
argument_list|,
name|OPC_INB_DEV_HANDLE_ACCEPT
argument_list|,
name|IOMB_SIZE64
argument_list|,
name|queueNum
argument_list|)
expr_stmt|;
if|if
condition|(
name|AGSA_RC_SUCCESS
operator|!=
name|ret
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"mpiDevHandleAcceptCmd, sending IOMB failed\n"
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"mpiDevHandleAcceptCmd, sending IOMB succeeded\n"
operator|)
argument_list|)
expr_stmt|;
block|}
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
comment|/* remove the request from IOMap */
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|Tag
operator|=
name|MARK_OFF
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|IORequest
operator|=
name|agNULL
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|agContext
operator|=
name|agNULL
expr_stmt|;
name|pRequest
operator|->
name|valid
operator|=
name|agFALSE
expr_stmt|;
comment|/* return the request to free pool */
if|if
condition|(
name|saLlistIOGetCount
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeReservedRequests
operator|)
argument_list|)
operator|<
name|SA_RESERVED_REQUEST_COUNT
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"mpiDevHandleAcceptCmd: saving pRequest (%p) for later use\n"
operator|,
name|pRequest
operator|)
argument_list|)
expr_stmt|;
name|saLlistIOAdd
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeReservedRequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* return the request to free pool */
name|saLlistIOAdd
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* return value */
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'b'
argument_list|,
literal|"xt"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*! \brief SPC READ REGISTER DUMP Command  *  *  This command used to do the SPC Read Register Dump command.  *  *  \param agRoot       Handles for this instance of SAS/SATA LLL  *  \param tag          tag of IOMB  *  \param cpuId        CPU Id  *  \param queueNum     IQ/OQ number  *  \param cpuId        AAP1 or IOP  *  \param cOffset      offset of the register dump data  *  \param addrHi       Hi address if Register Dump data  *  \param addrHi       Low address if Register Dump data  *  \param len          the length of for read  *  *  \return If the MPI command is sent to SPC successfully  *          - \e AGSA_RC_SUCCESS the MPI command is successfully  *          - \e AGSA_RC_BUSY the SPC is no resource, cannot send now  *          - \e AGSA_RC_FAILURE the MPI command is failure  *  */
end_comment

begin_comment
comment|/*******************************************************************************/
end_comment

begin_function
name|GLOBAL
name|bit32
name|mpiNVMReadRegDumpCmd
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|agsaContext_t
modifier|*
name|agContext
parameter_list|,
name|bit32
name|queueNum
parameter_list|,
name|bit32
name|cpuId
parameter_list|,
name|bit32
name|cOffset
parameter_list|,
name|bit32
name|addrHi
parameter_list|,
name|bit32
name|addrLo
parameter_list|,
name|bit32
name|len
parameter_list|)
block|{
name|bit32
name|ret
init|=
name|AGSA_RC_SUCCESS
decl_stmt|;
name|agsaLLRoot_t
modifier|*
name|saRoot
init|=
operator|(
name|agsaLLRoot_t
operator|*
operator|)
operator|(
name|agRoot
operator|->
name|sdkData
operator|)
decl_stmt|;
name|agsaIORequestDesc_t
modifier|*
name|pRequest
decl_stmt|;
name|agsaGetNVMDataCmd_t
name|payload
decl_stmt|;
name|bit32
name|nvmd
init|=
literal|0
decl_stmt|;
name|smTraceFuncEnter
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|"xk"
argument_list|)
expr_stmt|;
comment|/* Get request from free IORequests */
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|pRequest
operator|=
operator|(
name|agsaIORequestDesc_t
operator|*
operator|)
name|saLlistIOGetHead
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|)
expr_stmt|;
comment|/* If no LL Control request entry available */
if|if
condition|(
name|agNULL
operator|==
name|pRequest
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"mpiNVMReadRegDumpCmd, No request from free list\n"
operator|)
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'a'
argument_list|,
literal|"xk"
argument_list|)
expr_stmt|;
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_BUSY
return|;
block|}
comment|/* If LL Control request entry avaliable */
else|else
block|{
comment|/* Remove the request from free list */
name|SA_ASSERT
argument_list|(
operator|(
operator|!
name|pRequest
operator|->
name|valid
operator|)
argument_list|,
literal|"The pRequest is in use"
argument_list|)
expr_stmt|;
name|saLlistIORemove
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|Tag
operator|=
name|pRequest
operator|->
name|HTag
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|IORequest
operator|=
operator|(
name|void
operator|*
operator|)
name|pRequest
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|agContext
operator|=
name|agContext
expr_stmt|;
name|pRequest
operator|->
name|valid
operator|=
name|agTRUE
expr_stmt|;
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
comment|/* clean the payload field */
name|si_memset
argument_list|(
operator|&
name|payload
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|agsaGetNVMDataCmd_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* only indirect mode */
if|if
condition|(
name|cpuId
operator|<=
literal|1
condition|)
block|{
if|if
condition|(
name|cpuId
operator|==
literal|0
condition|)
name|nvmd
operator|=
name|AAP1_RDUMP
operator||
name|IRMode
expr_stmt|;
else|else
name|nvmd
operator|=
name|IOP_RDUMP
operator||
name|IRMode
expr_stmt|;
comment|/* setup IOMB */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaGetNVMDataCmd_t
argument_list|,
name|tag
argument_list|)
argument_list|,
name|pRequest
operator|->
name|HTag
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaGetNVMDataCmd_t
argument_list|,
name|LEN_IR_VPDD
argument_list|)
argument_list|,
name|nvmd
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaGetNVMDataCmd_t
argument_list|,
name|VPDOffset
argument_list|)
argument_list|,
name|cOffset
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaGetNVMDataCmd_t
argument_list|,
name|respAddrLo
argument_list|)
argument_list|,
name|addrLo
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaGetNVMDataCmd_t
argument_list|,
name|respAddrHi
argument_list|)
argument_list|,
name|addrHi
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaGetNVMDataCmd_t
argument_list|,
name|respLen
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* build IOMB command and send to SPC */
name|ret
operator|=
name|mpiBuildCmd
argument_list|(
name|agRoot
argument_list|,
operator|(
name|bit32
operator|*
operator|)
operator|&
name|payload
argument_list|,
name|MPI_CATEGORY_SAS_SATA
argument_list|,
name|OPC_INB_GET_NVMD_DATA
argument_list|,
name|IOMB_SIZE64
argument_list|,
name|queueNum
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"mpiNVMReadRegDumpCmd, Wrong device type\n"
operator|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|AGSA_RC_FAILURE
expr_stmt|;
block|}
if|if
condition|(
name|AGSA_RC_SUCCESS
operator|!=
name|ret
condition|)
block|{
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
comment|/* remove the request from IOMap */
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|Tag
operator|=
name|MARK_OFF
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|IORequest
operator|=
name|agNULL
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|agContext
operator|=
name|agNULL
expr_stmt|;
name|pRequest
operator|->
name|valid
operator|=
name|agFALSE
expr_stmt|;
comment|/* return the request to free pool */
name|saLlistIOAdd
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"mpiNVMReadRegDumpCmd, sending IOMB failed\n"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
name|SA_DBG3
argument_list|(
operator|(
literal|"mpiNVMReadRegDumpCmd, return value = %d\n"
operator|,
name|ret
operator|)
argument_list|)
expr_stmt|;
comment|/* return value */
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'b'
argument_list|,
literal|"xk"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*! \brief Get NVM Data command  *  *  This command is get NVM Data from SPC.  *  *  \param agRoot       Handles for this instance of SAS/SATA LLL  *  \param agContext    Context for the VPD command  *  \param VPDInfo      Pointer of VPD Information  *  \param queueNum     Queue Number of inbound/outbound queue  *  *  \return If the MPI command is sent to SPC successfully  *          - \e AGSA_RC_SUCCESS the MPI command is successfully  *          - \e AGSA_RC_BUSY the SPC is no resource, cannot send now  *          - \e AGSA_RC_FAILURE the MPI command is failure  *  */
end_comment

begin_comment
comment|/*******************************************************************************/
end_comment

begin_function
name|GLOBAL
name|bit32
name|mpiGetNVMDCmd
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|agsaContext_t
modifier|*
name|agContext
parameter_list|,
name|agsaNVMDData_t
modifier|*
name|NVMDInfo
parameter_list|,
name|bit32
name|queueNum
parameter_list|)
block|{
name|bit32
name|ret
init|=
name|AGSA_RC_FAILURE
decl_stmt|;
name|agsaLLRoot_t
modifier|*
name|saRoot
init|=
operator|(
name|agsaLLRoot_t
operator|*
operator|)
operator|(
name|agRoot
operator|->
name|sdkData
operator|)
decl_stmt|;
name|agsaIORequestDesc_t
modifier|*
name|pRequest
decl_stmt|;
name|agsaGetNVMDataCmd_t
name|payload
decl_stmt|;
name|smTraceFuncEnter
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|"xr"
argument_list|)
expr_stmt|;
comment|/* Get request from free IORequests */
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|pRequest
operator|=
operator|(
name|agsaIORequestDesc_t
operator|*
operator|)
name|saLlistIOGetHead
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|)
expr_stmt|;
comment|/* If no LL Control request entry available */
if|if
condition|(
name|agNULL
operator|==
name|pRequest
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"mpiGetNVMDCmd, No request from free list\n"
operator|)
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'a'
argument_list|,
literal|"xr"
argument_list|)
expr_stmt|;
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_BUSY
return|;
block|}
comment|/* If LL Control request entry avaliable */
else|else
block|{
name|SA_DBG3
argument_list|(
operator|(
literal|"mpiGetNVMDCmd, Build IOMB NVMDDevice= 0x%x\n"
operator|,
name|NVMDInfo
operator|->
name|NVMDevice
operator|)
argument_list|)
expr_stmt|;
comment|/* Remove the request from free list */
name|SA_ASSERT
argument_list|(
operator|(
operator|!
name|pRequest
operator|->
name|valid
operator|)
argument_list|,
literal|"The pRequest is in use"
argument_list|)
expr_stmt|;
name|saLlistIORemove
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|Tag
operator|=
name|pRequest
operator|->
name|HTag
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|IORequest
operator|=
operator|(
name|void
operator|*
operator|)
name|pRequest
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|agContext
operator|=
name|agContext
expr_stmt|;
name|pRequest
operator|->
name|valid
operator|=
name|agTRUE
expr_stmt|;
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
comment|/* set payload to zeros */
name|si_memset
argument_list|(
operator|&
name|payload
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|agsaGetNVMDataCmd_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* set tag field */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaGetNVMDataCmd_t
argument_list|,
name|tag
argument_list|)
argument_list|,
name|pRequest
operator|->
name|HTag
argument_list|)
expr_stmt|;
if|if
condition|(
name|NVMDInfo
operator|->
name|indirectPayload
condition|)
block|{
comment|/* indirect payload IP = 1 */
switch|switch
condition|(
name|NVMDInfo
operator|->
name|NVMDevice
condition|)
block|{
case|case
name|AGSA_NVMD_TWI_DEVICES
case|:
comment|/* NVMD = 0 */
comment|/* indirect payload IP = 1 and 0x0 (TWI) */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaGetNVMDataCmd_t
argument_list|,
name|LEN_IR_VPDD
argument_list|)
argument_list|,
operator|(
name|NVMDInfo
operator|->
name|TWIDeviceAddress
operator|<<
literal|16
operator|)
operator||
operator|(
name|NVMDInfo
operator|->
name|TWIBusNumber
operator|<<
literal|12
operator|)
operator||
operator|(
name|NVMDInfo
operator|->
name|TWIDevicePageSize
operator|<<
literal|8
operator|)
operator||
operator|(
name|NVMDInfo
operator|->
name|TWIDeviceAddressSize
operator|<<
literal|4
operator|)
operator||
operator|(
name|NVMDInfo
operator|->
name|indirectPayload
operator|<<
literal|31
operator|)
operator||
name|NVMDInfo
operator|->
name|NVMDevice
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaGetNVMDataCmd_t
argument_list|,
name|VPDOffset
argument_list|)
argument_list|,
name|NVMDInfo
operator|->
name|dataOffsetAddress
argument_list|)
expr_stmt|;
break|break;
case|case
name|AGSA_NVMD_CONFIG_SEEPROM
case|:
comment|/* NVMD = 1 */
comment|/* Data Offset should be 0 */
if|if
condition|(
name|NVMDInfo
operator|->
name|dataOffsetAddress
operator|!=
literal|0
condition|)
block|{
comment|/* Error for Offset */
name|SA_DBG1
argument_list|(
operator|(
literal|"mpiGetNVMDCmd, (IP=1)wrong offset = 0x%x\n"
operator|,
name|NVMDInfo
operator|->
name|dataOffsetAddress
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* indirect payload IP = 1, NVMD = 0x1 (SEEPROM0) */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaGetNVMDataCmd_t
argument_list|,
name|LEN_IR_VPDD
argument_list|)
argument_list|,
operator|(
name|NVMDInfo
operator|->
name|indirectPayload
operator|<<
name|SHIFT31
operator|)
operator||
operator|(
name|NVMDInfo
operator|->
name|NVMDevice
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|AGSA_NVMD_VPD_FLASH
case|:
comment|/* indirect payload IP = 1 and 0x4 (FLASH) */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaGetNVMDataCmd_t
argument_list|,
name|LEN_IR_VPDD
argument_list|)
argument_list|,
operator|(
name|NVMDInfo
operator|->
name|indirectPayload
operator|<<
name|SHIFT31
operator|)
operator||
name|NVMDInfo
operator|->
name|NVMDevice
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaGetNVMDataCmd_t
argument_list|,
name|VPDOffset
argument_list|)
argument_list|,
name|NVMDInfo
operator|->
name|dataOffsetAddress
argument_list|)
expr_stmt|;
break|break;
case|case
name|AGSA_NVMD_EXPANSION_ROM
case|:
comment|/* indirect payload IP = 1 and 0x7 (EXPANSION ROM PARTITION) */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaGetNVMDataCmd_t
argument_list|,
name|LEN_IR_VPDD
argument_list|)
argument_list|,
operator|(
name|NVMDInfo
operator|->
name|indirectPayload
operator|<<
name|SHIFT31
operator|)
operator||
name|NVMDInfo
operator|->
name|NVMDevice
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaGetNVMDataCmd_t
argument_list|,
name|VPDOffset
argument_list|)
argument_list|,
name|NVMDInfo
operator|->
name|dataOffsetAddress
argument_list|)
expr_stmt|;
break|break;
case|case
name|AGSA_NVMD_AAP1_REG_FLASH
case|:
comment|/* AGSA_NVMD_REG_FLASH  SPCv uses 5 as well */
comment|/* indirect payload IP = 1 and 0x5 (AGSA_NVMD_AAP1_REG_FLASH ) */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaGetNVMDataCmd_t
argument_list|,
name|LEN_IR_VPDD
argument_list|)
argument_list|,
operator|(
name|NVMDInfo
operator|->
name|indirectPayload
operator|<<
name|SHIFT31
operator|)
operator||
name|NVMDInfo
operator|->
name|NVMDevice
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaGetNVMDataCmd_t
argument_list|,
name|VPDOffset
argument_list|)
argument_list|,
name|NVMDInfo
operator|->
name|dataOffsetAddress
argument_list|)
expr_stmt|;
break|break;
case|case
name|AGSA_NVMD_IOP_REG_FLASH
case|:
comment|/* indirect payload IP = 1 and 0x6 ( AGSA_NVMD_IOP_REG_FLASH ) */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaGetNVMDataCmd_t
argument_list|,
name|LEN_IR_VPDD
argument_list|)
argument_list|,
operator|(
name|NVMDInfo
operator|->
name|indirectPayload
operator|<<
name|SHIFT31
operator|)
operator||
name|NVMDInfo
operator|->
name|NVMDevice
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaGetNVMDataCmd_t
argument_list|,
name|VPDOffset
argument_list|)
argument_list|,
name|NVMDInfo
operator|->
name|dataOffsetAddress
argument_list|)
expr_stmt|;
break|break;
default|default:
name|SA_DBG1
argument_list|(
operator|(
literal|"mpiGetNVMDCmd, (IP=1)wrong device type = 0x%x\n"
operator|,
name|NVMDInfo
operator|->
name|NVMDevice
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaGetNVMDataCmd_t
argument_list|,
name|respAddrLo
argument_list|)
argument_list|,
name|NVMDInfo
operator|->
name|indirectAddrLower32
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaGetNVMDataCmd_t
argument_list|,
name|respAddrHi
argument_list|)
argument_list|,
name|NVMDInfo
operator|->
name|indirectAddrUpper32
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaGetNVMDataCmd_t
argument_list|,
name|respLen
argument_list|)
argument_list|,
name|NVMDInfo
operator|->
name|indirectLen
argument_list|)
expr_stmt|;
comment|/* build IOMB command and send to SPC */
name|ret
operator|=
name|mpiBuildCmd
argument_list|(
name|agRoot
argument_list|,
operator|(
name|bit32
operator|*
operator|)
operator|&
name|payload
argument_list|,
name|MPI_CATEGORY_SAS_SATA
argument_list|,
name|OPC_INB_GET_NVMD_DATA
argument_list|,
name|IOMB_SIZE64
argument_list|,
name|queueNum
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* direct payload IP = 0 only for TWI device */
if|if
condition|(
name|AGSA_NVMD_TWI_DEVICES
operator|==
name|NVMDInfo
operator|->
name|NVMDevice
condition|)
block|{
comment|/* NVMD = 0 */
comment|/* indirect payload IP = 0 and 0x0 (TWI) */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaGetNVMDataCmd_t
argument_list|,
name|LEN_IR_VPDD
argument_list|)
argument_list|,
operator|(
name|NVMDInfo
operator|->
name|TWIDeviceAddress
operator|<<
name|SHIFT16
operator|)
operator||
operator|(
name|NVMDInfo
operator|->
name|TWIBusNumber
operator|<<
name|SHIFT12
operator|)
operator||
operator|(
name|NVMDInfo
operator|->
name|TWIDevicePageSize
operator|<<
name|SHIFT8
operator|)
operator||
operator|(
name|NVMDInfo
operator|->
name|TWIDeviceAddressSize
operator|<<
name|SHIFT4
operator|)
operator||
name|NVMDInfo
operator|->
name|NVMDevice
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaGetNVMDataCmd_t
argument_list|,
name|VPDOffset
argument_list|)
argument_list|,
name|NVMDInfo
operator|->
name|dataOffsetAddress
operator||
operator|(
name|NVMDInfo
operator|->
name|directLen
operator|<<
name|SHIFT24
operator|)
argument_list|)
expr_stmt|;
comment|/* build IOMB command and send to SPC */
name|ret
operator|=
name|mpiBuildCmd
argument_list|(
name|agRoot
argument_list|,
operator|(
name|bit32
operator|*
operator|)
operator|&
name|payload
argument_list|,
name|MPI_CATEGORY_SAS_SATA
argument_list|,
name|OPC_INB_GET_NVMD_DATA
argument_list|,
name|IOMB_SIZE64
argument_list|,
name|queueNum
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"mpiGetNVMDCmd, (IP=0)wrong device type = 0x%x\n"
operator|,
name|NVMDInfo
operator|->
name|NVMDevice
operator|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|AGSA_RC_FAILURE
expr_stmt|;
comment|/* CB for NVMD with error */
name|ossaGetNVMDResponseCB
argument_list|(
name|agRoot
argument_list|,
name|agContext
argument_list|,
name|OSSA_NVMD_MODE_ERROR
argument_list|,
literal|0
argument_list|,
name|NVMDInfo
operator|->
name|directLen
argument_list|,
name|agNULL
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|AGSA_RC_SUCCESS
operator|!=
name|ret
condition|)
block|{
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
comment|/* remove the request from IOMap */
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|Tag
operator|=
name|MARK_OFF
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|IORequest
operator|=
name|agNULL
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|agContext
operator|=
name|agNULL
expr_stmt|;
name|pRequest
operator|->
name|valid
operator|=
name|agFALSE
expr_stmt|;
comment|/* return the request to free pool */
name|saLlistIOAdd
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"mpiGetNVMDCmd, sending IOMB failed\n"
operator|)
argument_list|)
expr_stmt|;
block|}
name|SA_DBG3
argument_list|(
operator|(
literal|"mpiGetNVMDCmd, return value = %d\n"
operator|,
name|ret
operator|)
argument_list|)
expr_stmt|;
block|}
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'b'
argument_list|,
literal|"xr"
argument_list|)
expr_stmt|;
comment|/* return value */
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*! \brief Set NVM Data Command  *  *  This command is set NVM Data to SPC.  *  *  \param agRoot       Handles for this instance of SAS/SATA LLL  *  \param agContext    Context for the set VPD command  *  \param NVMDInfo      pointer of VPD information  *  \param queueNum     queue Number  *  *  \return If the MPI command is sent to SPC successfully  *          - \e AGSA_RC_SUCCESS the MPI command is successfully  *          - \e AGSA_RC_BUSY the SPC is no resource, cannot send now  *          - \e AGSA_RC_FAILURE the MPI command is failure  *  */
end_comment

begin_comment
comment|/*******************************************************************************/
end_comment

begin_function
name|GLOBAL
name|bit32
name|mpiSetNVMDCmd
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|agsaContext_t
modifier|*
name|agContext
parameter_list|,
name|agsaNVMDData_t
modifier|*
name|NVMDInfo
parameter_list|,
name|bit32
name|queueNum
parameter_list|)
block|{
name|bit32
name|ret
init|=
name|AGSA_RC_FAILURE
decl_stmt|;
name|agsaLLRoot_t
modifier|*
name|saRoot
init|=
operator|(
name|agsaLLRoot_t
operator|*
operator|)
operator|(
name|agRoot
operator|->
name|sdkData
operator|)
decl_stmt|;
name|agsaIORequestDesc_t
modifier|*
name|pRequest
decl_stmt|;
name|agsaSetNVMDataCmd_t
name|payload
decl_stmt|;
name|smTraceFuncEnter
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|"xm"
argument_list|)
expr_stmt|;
comment|/* Get request from free IORequests */
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|pRequest
operator|=
operator|(
name|agsaIORequestDesc_t
operator|*
operator|)
name|saLlistIOGetHead
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|)
expr_stmt|;
comment|/* If no LL Control request entry available */
if|if
condition|(
name|agNULL
operator|==
name|pRequest
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"mpiSetNVMDCmd, No request from free list\n"
operator|)
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'a'
argument_list|,
literal|"xm"
argument_list|)
expr_stmt|;
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_BUSY
return|;
block|}
comment|/* If LL Control request entry avaliable */
else|else
block|{
name|SA_DBG3
argument_list|(
operator|(
literal|"mpiSetNVMDCmd, Build IOMB NVMDDevice= 0x%x\n"
operator|,
name|NVMDInfo
operator|->
name|NVMDevice
operator|)
argument_list|)
expr_stmt|;
comment|/* Remove the request from free list */
name|SA_ASSERT
argument_list|(
operator|(
operator|!
name|pRequest
operator|->
name|valid
operator|)
argument_list|,
literal|"The pRequest is in use"
argument_list|)
expr_stmt|;
name|saLlistIORemove
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|Tag
operator|=
name|pRequest
operator|->
name|HTag
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|IORequest
operator|=
operator|(
name|void
operator|*
operator|)
name|pRequest
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|agContext
operator|=
name|agContext
expr_stmt|;
name|pRequest
operator|->
name|valid
operator|=
name|agTRUE
expr_stmt|;
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
comment|/* set payload to zeros */
name|si_memset
argument_list|(
operator|&
name|payload
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|agsaSetNVMDataCmd_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* set tag field */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSetNVMDataCmd_t
argument_list|,
name|tag
argument_list|)
argument_list|,
name|pRequest
operator|->
name|HTag
argument_list|)
expr_stmt|;
if|if
condition|(
name|NVMDInfo
operator|->
name|indirectPayload
condition|)
block|{
comment|/* indirect payload IP = 1 */
switch|switch
condition|(
name|NVMDInfo
operator|->
name|NVMDevice
condition|)
block|{
case|case
name|AGSA_NVMD_TWI_DEVICES
case|:
comment|/* NVMD = 0 */
comment|/* indirect payload IP = 1 and 0x0 (TWI) */
comment|/* set up signature */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSetNVMDataCmd_t
argument_list|,
name|Data
operator|.
name|indirectData
operator|.
name|signature
argument_list|)
argument_list|,
name|NVMDInfo
operator|->
name|signature
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSetNVMDataCmd_t
argument_list|,
name|LEN_IR_VPDD
argument_list|)
argument_list|,
operator|(
name|NVMDInfo
operator|->
name|TWIDeviceAddress
operator|<<
name|SHIFT16
operator|)
operator||
operator|(
name|NVMDInfo
operator|->
name|TWIBusNumber
operator|<<
name|SHIFT12
operator|)
operator||
operator|(
name|NVMDInfo
operator|->
name|TWIDevicePageSize
operator|<<
name|SHIFT8
operator|)
operator||
operator|(
name|NVMDInfo
operator|->
name|TWIDeviceAddressSize
operator|<<
name|SHIFT4
operator|)
operator||
operator|(
name|NVMDInfo
operator|->
name|indirectPayload
operator|<<
name|SHIFT31
operator|)
operator||
name|NVMDInfo
operator|->
name|NVMDevice
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSetNVMDataCmd_t
argument_list|,
name|VPDOffset
argument_list|)
argument_list|,
name|NVMDInfo
operator|->
name|dataOffsetAddress
argument_list|)
expr_stmt|;
break|break;
comment|/* 0x01:SEEPROM-0 and 0x04:FLASH only in indirect mode */
case|case
name|AGSA_NVMD_CONFIG_SEEPROM
case|:
comment|/* NVMD=1 */
comment|/* Data Offset should be 0 */
comment|/* set up signature */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSetNVMDataCmd_t
argument_list|,
name|Data
operator|.
name|indirectData
operator|.
name|signature
argument_list|)
argument_list|,
name|NVMDInfo
operator|->
name|signature
argument_list|)
expr_stmt|;
comment|/* indirect payload IP = 1, NVMD = 0x1 (SEEPROM0) */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSetNVMDataCmd_t
argument_list|,
name|LEN_IR_VPDD
argument_list|)
argument_list|,
operator|(
name|NVMDInfo
operator|->
name|indirectPayload
operator|<<
name|SHIFT31
operator|)
operator||
name|NVMDInfo
operator|->
name|NVMDevice
argument_list|)
expr_stmt|;
break|break;
case|case
name|AGSA_NVMD_VPD_FLASH
case|:
comment|/* indirect payload IP = 1, NVMD=0x4 (FLASH) */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSetNVMDataCmd_t
argument_list|,
name|LEN_IR_VPDD
argument_list|)
argument_list|,
operator|(
name|NVMDInfo
operator|->
name|indirectPayload
operator|<<
name|SHIFT31
operator|)
operator||
name|NVMDInfo
operator|->
name|NVMDevice
argument_list|)
expr_stmt|;
comment|/* set up Offset */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSetNVMDataCmd_t
argument_list|,
name|VPDOffset
argument_list|)
argument_list|,
name|NVMDInfo
operator|->
name|dataOffsetAddress
argument_list|)
expr_stmt|;
break|break;
default|default:
name|SA_DBG1
argument_list|(
operator|(
literal|"mpiSetNVMDCmd, (IP=1)wrong device type = 0x%x\n"
operator|,
name|NVMDInfo
operator|->
name|NVMDevice
operator|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|AGSA_RC_FAILURE
expr_stmt|;
name|ossaSetNVMDResponseCB
argument_list|(
name|agRoot
argument_list|,
name|agContext
argument_list|,
name|OSSA_NVMD_MODE_ERROR
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* set up SGL field */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSetNVMDataCmd_t
argument_list|,
name|Data
operator|.
name|indirectData
operator|.
name|ISglAL
argument_list|)
argument_list|,
operator|(
name|NVMDInfo
operator|->
name|indirectAddrLower32
operator|)
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSetNVMDataCmd_t
argument_list|,
name|Data
operator|.
name|indirectData
operator|.
name|ISglAH
argument_list|)
argument_list|,
operator|(
name|NVMDInfo
operator|->
name|indirectAddrUpper32
operator|)
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSetNVMDataCmd_t
argument_list|,
name|Data
operator|.
name|indirectData
operator|.
name|ILen
argument_list|)
argument_list|,
operator|(
name|NVMDInfo
operator|->
name|indirectLen
operator|)
argument_list|)
expr_stmt|;
comment|/* build IOMB command and send to SPC */
name|ret
operator|=
name|mpiBuildCmd
argument_list|(
name|agRoot
argument_list|,
operator|(
name|bit32
operator|*
operator|)
operator|&
name|payload
argument_list|,
name|MPI_CATEGORY_SAS_SATA
argument_list|,
name|OPC_INB_SET_NVMD_DATA
argument_list|,
name|IOMB_SIZE64
argument_list|,
name|queueNum
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* direct payload IP = 0 */
if|if
condition|(
name|AGSA_NVMD_TWI_DEVICES
operator|==
name|NVMDInfo
operator|->
name|NVMDevice
condition|)
block|{
comment|/* NVMD = 0 */
comment|/* indirect payload IP = 0 and 0x0 (TWI) */
comment|/* not allow write to Config SEEPROM for direct mode, so don't set singature */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSetNVMDataCmd_t
argument_list|,
name|LEN_IR_VPDD
argument_list|)
argument_list|,
operator|(
name|NVMDInfo
operator|->
name|TWIDeviceAddress
operator|<<
name|SHIFT16
operator|)
operator||
operator|(
name|NVMDInfo
operator|->
name|TWIBusNumber
operator|<<
name|SHIFT12
operator|)
operator||
operator|(
name|NVMDInfo
operator|->
name|TWIDevicePageSize
operator|<<
name|SHIFT8
operator|)
operator||
operator|(
name|NVMDInfo
operator|->
name|TWIDeviceAddressSize
operator|<<
name|SHIFT4
operator|)
operator||
name|NVMDInfo
operator|->
name|NVMDevice
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSetNVMDataCmd_t
argument_list|,
name|VPDOffset
argument_list|)
argument_list|,
name|NVMDInfo
operator|->
name|dataOffsetAddress
operator||
operator|(
name|NVMDInfo
operator|->
name|directLen
operator|<<
name|SHIFT24
operator|)
argument_list|)
expr_stmt|;
name|si_memcpy
argument_list|(
operator|&
name|payload
operator|.
name|Data
operator|.
name|NVMData
index|[
literal|0
index|]
argument_list|,
name|NVMDInfo
operator|->
name|directData
argument_list|,
name|NVMDInfo
operator|->
name|directLen
argument_list|)
expr_stmt|;
comment|/* build IOMB command and send to SPC */
name|ret
operator|=
name|mpiBuildCmd
argument_list|(
name|agRoot
argument_list|,
operator|(
name|bit32
operator|*
operator|)
operator|&
name|payload
argument_list|,
name|MPI_CATEGORY_SAS_SATA
argument_list|,
name|OPC_INB_SET_NVMD_DATA
argument_list|,
name|IOMB_SIZE64
argument_list|,
name|queueNum
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"mpiSetNVMDCmd, (IP=0)wrong device type = 0x%x\n"
operator|,
name|NVMDInfo
operator|->
name|NVMDevice
operator|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|AGSA_RC_FAILURE
expr_stmt|;
name|ossaSetNVMDResponseCB
argument_list|(
name|agRoot
argument_list|,
name|agContext
argument_list|,
name|OSSA_NVMD_MODE_ERROR
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|AGSA_RC_SUCCESS
operator|!=
name|ret
condition|)
block|{
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
comment|/* remove the request from IOMap */
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|Tag
operator|=
name|MARK_OFF
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|IORequest
operator|=
name|agNULL
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|agContext
operator|=
name|agNULL
expr_stmt|;
name|pRequest
operator|->
name|valid
operator|=
name|agFALSE
expr_stmt|;
comment|/* return the request to free pool */
name|saLlistIOAdd
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"mpiSetVPDCmd, sending IOMB failed\n"
operator|)
argument_list|)
expr_stmt|;
block|}
name|SA_DBG3
argument_list|(
operator|(
literal|"mpiSetNVMDCmd, return value = %d\n"
operator|,
name|ret
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* return value */
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'b'
argument_list|,
literal|"xm"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*! \brief Set Device State command  *  *  This command is set Device State to SPC.  *  *  \param agRoot       Handles for this instance of SAS/SATA LLL  *  \param agContext    Context for the Set Nexus State command  *  \param deviceId     DeviceId  *  \param queueNum     Queue Number of inbound/outbound queue  *  *  \return If the MPI command is sent to SPC successfully  *          - \e AGSA_RC_SUCCESS the MPI command is successfully  *          - \e AGSA_RC_BUSY the SPC is no resource, cannot send now  *          - \e AGSA_RC_FAILURE the MPI command is failure  *  */
end_comment

begin_comment
comment|/*******************************************************************************/
end_comment

begin_function
name|GLOBAL
name|bit32
name|mpiSetDeviceStateCmd
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|agsaContext_t
modifier|*
name|agContext
parameter_list|,
name|bit32
name|deviceId
parameter_list|,
name|bit32
name|nds
parameter_list|,
name|bit32
name|queueNum
parameter_list|)
block|{
name|bit32
name|ret
init|=
name|AGSA_RC_SUCCESS
decl_stmt|;
name|agsaLLRoot_t
modifier|*
name|saRoot
init|=
operator|(
name|agsaLLRoot_t
operator|*
operator|)
operator|(
name|agRoot
operator|->
name|sdkData
operator|)
decl_stmt|;
name|agsaIORequestDesc_t
modifier|*
name|pRequest
decl_stmt|;
name|agsaSetDeviceStateCmd_t
name|payload
decl_stmt|;
name|smTraceFuncEnter
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|"xn"
argument_list|)
expr_stmt|;
comment|/* Get request from free IORequests */
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|pRequest
operator|=
operator|(
name|agsaIORequestDesc_t
operator|*
operator|)
name|saLlistIOGetHead
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|)
expr_stmt|;
comment|/* If no LL Control request entry available */
if|if
condition|(
name|agNULL
operator|==
name|pRequest
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"mpiSetDeviceStateCmd, No request from free list\n"
operator|)
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'a'
argument_list|,
literal|"xn"
argument_list|)
expr_stmt|;
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_BUSY
return|;
block|}
comment|/* If LL Control request entry avaliable */
else|else
block|{
name|SA_DBG3
argument_list|(
operator|(
literal|"mpiSetDeviceStateCmd, Build IOMB DeviceId= 0x%x\n"
operator|,
name|deviceId
operator|)
argument_list|)
expr_stmt|;
comment|/* Remove the request from free list */
name|saLlistIORemove
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|Tag
operator|=
name|pRequest
operator|->
name|HTag
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|IORequest
operator|=
operator|(
name|void
operator|*
operator|)
name|pRequest
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|agContext
operator|=
name|agContext
expr_stmt|;
name|pRequest
operator|->
name|valid
operator|=
name|agTRUE
expr_stmt|;
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
comment|/* set payload to zeros */
name|si_memset
argument_list|(
operator|&
name|payload
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|agsaSetDeviceStateCmd_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* set tag field */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSetDeviceStateCmd_t
argument_list|,
name|tag
argument_list|)
argument_list|,
name|pRequest
operator|->
name|HTag
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSetDeviceStateCmd_t
argument_list|,
name|deviceId
argument_list|)
argument_list|,
name|deviceId
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSetDeviceStateCmd_t
argument_list|,
name|NDS
argument_list|)
argument_list|,
name|nds
argument_list|)
expr_stmt|;
comment|/* build IOMB command and send to SPC */
name|ret
operator|=
name|mpiBuildCmd
argument_list|(
name|agRoot
argument_list|,
operator|(
name|bit32
operator|*
operator|)
operator|&
name|payload
argument_list|,
name|MPI_CATEGORY_SAS_SATA
argument_list|,
name|OPC_INB_SET_DEVICE_STATE
argument_list|,
name|IOMB_SIZE64
argument_list|,
name|queueNum
argument_list|)
expr_stmt|;
if|if
condition|(
name|AGSA_RC_SUCCESS
operator|!=
name|ret
condition|)
block|{
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
comment|/* remove the request from IOMap */
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|Tag
operator|=
name|MARK_OFF
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|IORequest
operator|=
name|agNULL
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|agContext
operator|=
name|agNULL
expr_stmt|;
name|pRequest
operator|->
name|valid
operator|=
name|agFALSE
expr_stmt|;
comment|/* return the request to free pool */
name|saLlistIOAdd
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"mpiSetNexusStateCmd, sending IOMB failed\n"
operator|)
argument_list|)
expr_stmt|;
block|}
name|SA_DBG3
argument_list|(
operator|(
literal|"mpiSetDeviceStateCmd, return value = %d\n"
operator|,
name|ret
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* return value */
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'b'
argument_list|,
literal|"xn"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*! \brief Get Device State command  *  *  This command is get device State to SPC.  *  *  \param agRoot       Handles for this instance of SAS/SATA LLL  *  \param agContext    Context for the Get Nexus State command  *  \param deviceId     DeviceId  *  \param queueNum     Queue Number of inbound/outbound queue  *  *  \return If the MPI command is sent to SPC successfully  *          - \e AGSA_RC_SUCCESS the MPI command is successfully  *          - \e AGSA_RC_BUSY the SPC is no resource, cannot send now  *          - \e AGSA_RC_FAILURE the MPI command is failure  *  */
end_comment

begin_comment
comment|/*******************************************************************************/
end_comment

begin_function
name|GLOBAL
name|bit32
name|mpiGetDeviceStateCmd
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|agsaContext_t
modifier|*
name|agContext
parameter_list|,
name|bit32
name|deviceId
parameter_list|,
name|bit32
name|queueNum
parameter_list|)
block|{
name|bit32
name|ret
init|=
name|AGSA_RC_SUCCESS
decl_stmt|;
name|agsaLLRoot_t
modifier|*
name|saRoot
init|=
operator|(
name|agsaLLRoot_t
operator|*
operator|)
operator|(
name|agRoot
operator|->
name|sdkData
operator|)
decl_stmt|;
name|agsaIORequestDesc_t
modifier|*
name|pRequest
decl_stmt|;
name|agsaGetDeviceStateCmd_t
name|payload
decl_stmt|;
name|bit32
name|using_reserved
init|=
name|agFALSE
decl_stmt|;
name|smTraceFuncEnter
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|"xf"
argument_list|)
expr_stmt|;
comment|/* Get request from free IORequests */
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|pRequest
operator|=
operator|(
name|agsaIORequestDesc_t
operator|*
operator|)
name|saLlistIOGetHead
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|)
expr_stmt|;
comment|/* If no LL Control request entry available */
if|if
condition|(
name|agNULL
operator|==
name|pRequest
condition|)
block|{
name|pRequest
operator|=
operator|(
name|agsaIORequestDesc_t
operator|*
operator|)
name|saLlistIOGetHead
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeReservedRequests
operator|)
argument_list|)
expr_stmt|;
comment|/**/
comment|/* If no LL Control request entry available */
if|if
condition|(
name|agNULL
operator|!=
name|pRequest
condition|)
block|{
name|using_reserved
operator|=
name|agTRUE
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"mpiGetDeviceStateCmd, using saRoot->freeReservedRequests\n"
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"mpiGetDeviceStateCmd, No request from free list Not using saRoot->freeReservedRequests\n"
operator|)
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'a'
argument_list|,
literal|"xf"
argument_list|)
expr_stmt|;
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_BUSY
return|;
block|}
block|}
comment|/* If LL Control request entry avaliable */
name|SA_DBG3
argument_list|(
operator|(
literal|"mpiGetDeviceStateCmd, Build IOMB DeviceId= 0x%x\n"
operator|,
name|deviceId
operator|)
argument_list|)
expr_stmt|;
comment|/* Remove the request from free list */
if|if
condition|(
name|using_reserved
condition|)
block|{
name|saLlistIORemove
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeReservedRequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|saLlistIORemove
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
block|}
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|Tag
operator|=
name|pRequest
operator|->
name|HTag
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|IORequest
operator|=
operator|(
name|void
operator|*
operator|)
name|pRequest
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|agContext
operator|=
name|agContext
expr_stmt|;
name|pRequest
operator|->
name|valid
operator|=
name|agTRUE
expr_stmt|;
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
comment|/* set payload to zeros */
name|si_memset
argument_list|(
operator|&
name|payload
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|agsaGetDeviceStateCmd_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* set tag field */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaGetDeviceStateCmd_t
argument_list|,
name|tag
argument_list|)
argument_list|,
name|pRequest
operator|->
name|HTag
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaGetDeviceStateCmd_t
argument_list|,
name|deviceId
argument_list|)
argument_list|,
name|deviceId
argument_list|)
expr_stmt|;
comment|/* build IOMB command and send to SPC */
name|ret
operator|=
name|mpiBuildCmd
argument_list|(
name|agRoot
argument_list|,
operator|(
name|bit32
operator|*
operator|)
operator|&
name|payload
argument_list|,
name|MPI_CATEGORY_SAS_SATA
argument_list|,
name|OPC_INB_GET_DEVICE_STATE
argument_list|,
name|IOMB_SIZE64
argument_list|,
name|queueNum
argument_list|)
expr_stmt|;
if|if
condition|(
name|AGSA_RC_SUCCESS
operator|!=
name|ret
condition|)
block|{
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
comment|/* remove the request from IOMap */
name|SA_ASSERT
argument_list|(
operator|(
operator|!
name|pRequest
operator|->
name|valid
operator|)
argument_list|,
literal|"The pRequest is in use"
argument_list|)
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|Tag
operator|=
name|MARK_OFF
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|IORequest
operator|=
name|agNULL
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|agContext
operator|=
name|agNULL
expr_stmt|;
name|pRequest
operator|->
name|valid
operator|=
name|agFALSE
expr_stmt|;
comment|/* return the request to free pool */
if|if
condition|(
name|saLlistIOGetCount
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeReservedRequests
operator|)
argument_list|)
operator|<
name|SA_RESERVED_REQUEST_COUNT
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"mpiGetDeviceStateCmd: saving pRequest (%p) for later use\n"
operator|,
name|pRequest
operator|)
argument_list|)
expr_stmt|;
name|saLlistIOAdd
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeReservedRequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* return the request to free pool */
name|saLlistIOAdd
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
block|}
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"mpiGetDeviceStateCmd, sending IOMB failed\n"
operator|)
argument_list|)
expr_stmt|;
block|}
name|SA_DBG3
argument_list|(
operator|(
literal|"mpiGetDeviceStateCmd, return value = %d\n"
operator|,
name|ret
operator|)
argument_list|)
expr_stmt|;
comment|/* return value */
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'b'
argument_list|,
literal|"xf"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*! \brief SAS ReInitialize command  *  *  This command is Reinitialize SAS paremeters to SPC.  *  *  \param agRoot       Handles for this instance of SAS/SATA LLL  *  \param agContext    Context for the Get Nexus State command  *  \param agSASConfig  SAS Configuration Parameters  *  \param queueNum     Queue Number of inbound/outbound queue  *  *  \return If the MPI command is sent to SPC successfully  *          - \e AGSA_RC_SUCCESS the MPI command is successfully  *          - \e AGSA_RC_BUSY the SPC is no resource, cannot send now  *          - \e AGSA_RC_FAILURE the MPI command is failure  *  */
end_comment

begin_comment
comment|/*******************************************************************************/
end_comment

begin_function
name|GLOBAL
name|bit32
name|mpiSasReinitializeCmd
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|agsaContext_t
modifier|*
name|agContext
parameter_list|,
name|agsaSASReconfig_t
modifier|*
name|agSASConfig
parameter_list|,
name|bit32
name|queueNum
parameter_list|)
block|{
name|bit32
name|ret
init|=
name|AGSA_RC_SUCCESS
decl_stmt|;
name|agsaLLRoot_t
modifier|*
name|saRoot
init|=
operator|(
name|agsaLLRoot_t
operator|*
operator|)
operator|(
name|agRoot
operator|->
name|sdkData
operator|)
decl_stmt|;
name|agsaIORequestDesc_t
modifier|*
name|pRequest
decl_stmt|;
name|agsaSasReInitializeCmd_t
name|payload
decl_stmt|;
name|smTraceFuncEnter
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|"xo"
argument_list|)
expr_stmt|;
comment|/* Get request from free IORequests */
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|pRequest
operator|=
operator|(
name|agsaIORequestDesc_t
operator|*
operator|)
name|saLlistIOGetHead
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|)
expr_stmt|;
comment|/* If no LL Control request entry available */
if|if
condition|(
name|agNULL
operator|==
name|pRequest
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"mpiSasReinitializeCmd, No request from free list\n"
operator|)
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'a'
argument_list|,
literal|"xo"
argument_list|)
expr_stmt|;
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_BUSY
return|;
block|}
comment|/* If LL Control request entry avaliable */
else|else
block|{
name|SA_DBG3
argument_list|(
operator|(
literal|"mpiSasReinitializeCmd, Build IOMB SAS_RE_INITIALIZE\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* Remove the request from free list */
name|saLlistIORemove
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|Tag
operator|=
name|pRequest
operator|->
name|HTag
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|IORequest
operator|=
operator|(
name|void
operator|*
operator|)
name|pRequest
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|agContext
operator|=
name|agContext
expr_stmt|;
name|pRequest
operator|->
name|valid
operator|=
name|agTRUE
expr_stmt|;
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
comment|/* set payload to zeros */
name|si_memset
argument_list|(
operator|&
name|payload
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|agsaSasReInitializeCmd_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* set tag field */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSasReInitializeCmd_t
argument_list|,
name|tag
argument_list|)
argument_list|,
name|pRequest
operator|->
name|HTag
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSasReInitializeCmd_t
argument_list|,
name|setFlags
argument_list|)
argument_list|,
name|agSASConfig
operator|->
name|flags
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSasReInitializeCmd_t
argument_list|,
name|MaxPorts
argument_list|)
argument_list|,
name|agSASConfig
operator|->
name|maxPorts
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSasReInitializeCmd_t
argument_list|,
name|openRejReCmdData
argument_list|)
argument_list|,
operator|(
name|agSASConfig
operator|->
name|openRejectRetriesCmd
operator|<<
name|SHIFT16
operator|)
operator||
name|agSASConfig
operator|->
name|openRejectRetriesData
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSasReInitializeCmd_t
argument_list|,
name|sataHOLTMO
argument_list|)
argument_list|,
name|agSASConfig
operator|->
name|sataHolTmo
argument_list|)
expr_stmt|;
comment|/* build IOMB command and send to SPC */
name|ret
operator|=
name|mpiBuildCmd
argument_list|(
name|agRoot
argument_list|,
operator|(
name|bit32
operator|*
operator|)
operator|&
name|payload
argument_list|,
name|MPI_CATEGORY_SAS_SATA
argument_list|,
name|OPC_INB_SAS_RE_INITIALIZE
argument_list|,
name|IOMB_SIZE64
argument_list|,
name|queueNum
argument_list|)
expr_stmt|;
if|if
condition|(
name|AGSA_RC_SUCCESS
operator|!=
name|ret
condition|)
block|{
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
comment|/* remove the request from IOMap */
name|SA_ASSERT
argument_list|(
operator|(
operator|!
name|pRequest
operator|->
name|valid
operator|)
argument_list|,
literal|"The pRequest is in use"
argument_list|)
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|Tag
operator|=
name|MARK_OFF
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|IORequest
operator|=
name|agNULL
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|agContext
operator|=
name|agNULL
expr_stmt|;
name|pRequest
operator|->
name|valid
operator|=
name|agFALSE
expr_stmt|;
comment|/* return the request to free pool */
name|saLlistIOAdd
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"mpiSasReinitializeCmd, sending IOMB failed\n"
operator|)
argument_list|)
expr_stmt|;
block|}
name|SA_DBG3
argument_list|(
operator|(
literal|"mpiSasReinitializeCmd, return value = %d\n"
operator|,
name|ret
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* return value */
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'b'
argument_list|,
literal|"xo"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*! \brief SAS Set Controller Configuration Command  *  *  This command updates the contents of a controller mode page.  *  *  \param agRoot               Handles for this instance of SAS/SATA LLL  *  \param agContext            Context for the Get Nexus State command  *  \param agControllerConfig   Mode page being sent to the controller  *  \param queueNum             Queue Number of inbound/outbound queue  *  *  \return If the MPI command is sent to SPC successfully  *          - \e AGSA_RC_SUCCESS the MPI command is successfully  *          - \e AGSA_RC_BUSY the SPC is no resource, cannot send now  *          - \e AGSA_RC_FAILURE the MPI command is failure  *  */
end_comment

begin_comment
comment|/*******************************************************************************/
end_comment

begin_function
name|GLOBAL
name|bit32
name|mpiSetControllerConfigCmd
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|agsaContext_t
modifier|*
name|agContext
parameter_list|,
name|agsaSetControllerConfigCmd_t
modifier|*
name|agControllerConfig
parameter_list|,
name|bit32
name|queueNum
parameter_list|,
name|bit8
name|modePageContext
parameter_list|)
block|{
name|bit32
name|ret
init|=
name|AGSA_RC_SUCCESS
decl_stmt|;
name|agsaLLRoot_t
modifier|*
name|saRoot
init|=
operator|(
name|agsaLLRoot_t
operator|*
operator|)
operator|(
name|agRoot
operator|->
name|sdkData
operator|)
decl_stmt|;
name|agsaIORequestDesc_t
modifier|*
name|pRequest
decl_stmt|;
name|smTraceFuncEnter
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|"x1"
argument_list|)
expr_stmt|;
name|SA_DBG2
argument_list|(
operator|(
literal|"mpiSetControllerConfigCmd: agControllerConfig 0x%08x 0x%08x 0x%08x 0x%08x\n"
operator|,
name|agControllerConfig
operator|->
name|pageCode
operator|,
name|agControllerConfig
operator|->
name|configPage
index|[
literal|0
index|]
operator|,
name|agControllerConfig
operator|->
name|configPage
index|[
literal|1
index|]
operator|,
name|agControllerConfig
operator|->
name|configPage
index|[
literal|2
index|]
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG2
argument_list|(
operator|(
literal|"mpiSetControllerConfigCmd: agControllerConfig 0x%08x 0x%08x 0x%08x 0x%08x\n"
operator|,
name|agControllerConfig
operator|->
name|configPage
index|[
literal|3
index|]
operator|,
name|agControllerConfig
operator|->
name|configPage
index|[
literal|4
index|]
operator|,
name|agControllerConfig
operator|->
name|configPage
index|[
literal|5
index|]
operator|,
name|agControllerConfig
operator|->
name|configPage
index|[
literal|6
index|]
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG2
argument_list|(
operator|(
literal|"mpiSetControllerConfigCmd: agControllerConfig 0x%08x 0x%08x 0x%08x 0x%08x\n"
operator|,
name|agControllerConfig
operator|->
name|configPage
index|[
literal|7
index|]
operator|,
name|agControllerConfig
operator|->
name|configPage
index|[
literal|8
index|]
operator|,
name|agControllerConfig
operator|->
name|configPage
index|[
literal|9
index|]
operator|,
name|agControllerConfig
operator|->
name|configPage
index|[
literal|10
index|]
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG2
argument_list|(
operator|(
literal|"mpiSetControllerConfigCmd: agControllerConfig 0x%08x 0x%08x\n"
operator|,
name|agControllerConfig
operator|->
name|configPage
index|[
literal|11
index|]
operator|,
name|agControllerConfig
operator|->
name|configPage
index|[
literal|12
index|]
operator|)
argument_list|)
expr_stmt|;
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
comment|/* Get request from free IORequests */
name|pRequest
operator|=
operator|(
name|agsaIORequestDesc_t
operator|*
operator|)
name|saLlistIOGetHead
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|)
expr_stmt|;
comment|/* If no LL Control request entry available */
if|if
condition|(
name|agNULL
operator|==
name|pRequest
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"mpiSetControllerConfigCmd, No request from free list\n"
operator|)
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'a'
argument_list|,
literal|"x1"
argument_list|)
expr_stmt|;
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_BUSY
return|;
block|}
comment|/* If LL Control request entry avaliable */
else|else
block|{
name|SA_DBG2
argument_list|(
operator|(
literal|"mpiSetControllerConfigCmd, Build IOMB pageCode 0x%x configPage[0] 0x%x\n"
operator|,
name|agControllerConfig
operator|->
name|pageCode
operator|,
name|agControllerConfig
operator|->
name|configPage
index|[
literal|0
index|]
operator|)
argument_list|)
expr_stmt|;
comment|/* Remove the request from free list */
name|SA_ASSERT
argument_list|(
operator|(
operator|!
name|pRequest
operator|->
name|valid
operator|)
argument_list|,
literal|"The pRequest is in use"
argument_list|)
expr_stmt|;
name|saLlistIORemove
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|Tag
operator|=
name|pRequest
operator|->
name|HTag
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|IORequest
operator|=
operator|(
name|void
operator|*
operator|)
name|pRequest
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|agContext
operator|=
name|agContext
expr_stmt|;
name|pRequest
operator|->
name|valid
operator|=
name|agTRUE
expr_stmt|;
name|pRequest
operator|->
name|modePageContext
operator|=
name|modePageContext
expr_stmt|;
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
comment|/* set tag field */
name|agControllerConfig
operator|->
name|tag
operator|=
name|pRequest
operator|->
name|HTag
expr_stmt|;
name|ret
operator|=
name|mpiBuildCmd
argument_list|(
name|agRoot
argument_list|,
operator|(
name|bit32
operator|*
operator|)
name|agControllerConfig
argument_list|,
name|MPI_CATEGORY_SAS_SATA
argument_list|,
name|OPC_INB_SET_CONTROLLER_CONFIG
argument_list|,
name|IOMB_SIZE64
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|AGSA_RC_SUCCESS
operator|!=
name|ret
condition|)
block|{
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
comment|/* remove the request from IOMap */
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|Tag
operator|=
name|MARK_OFF
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|IORequest
operator|=
name|agNULL
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|agContext
operator|=
name|agNULL
expr_stmt|;
name|pRequest
operator|->
name|valid
operator|=
name|agFALSE
expr_stmt|;
comment|/* return the request to free pool */
name|saLlistIOAdd
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"mpiSetControllerConfigCmd, sending IOMB failed\n"
operator|)
argument_list|)
expr_stmt|;
block|}
name|SA_DBG3
argument_list|(
operator|(
literal|"mpiSetControllerConfigCmd, return value = %d\n"
operator|,
name|ret
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* return value */
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'b'
argument_list|,
literal|"x1"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*! \brief SAS Get Controller Configuration Command  *  *  This command retrieves the contents of a controller mode page.  *  *  \param agRoot               Handles for this instance of SAS/SATA LLL  *  \param agContext            Context for the Get Nexus State command  *  \param agControllerConfig   Mode page to retrieve from the controller  *  \param queueNum             Queue Number of inbound/outbound queue  *  *  \return If the MPI command is sent to SPC successfully  *          - \e AGSA_RC_SUCCESS the MPI command is successfully  *          - \e AGSA_RC_BUSY the SPC is no resource, cannot send now  *          - \e AGSA_RC_FAILURE the MPI command is failure  *  */
end_comment

begin_comment
comment|/*******************************************************************************/
end_comment

begin_function
name|GLOBAL
name|bit32
name|mpiGetControllerConfigCmd
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|agsaContext_t
modifier|*
name|agContext
parameter_list|,
name|agsaGetControllerConfigCmd_t
modifier|*
name|agControllerConfig
parameter_list|,
name|bit32
name|queueNum
parameter_list|)
block|{
name|bit32
name|ret
init|=
name|AGSA_RC_SUCCESS
decl_stmt|;
name|agsaLLRoot_t
modifier|*
name|saRoot
init|=
operator|(
name|agsaLLRoot_t
operator|*
operator|)
operator|(
name|agRoot
operator|->
name|sdkData
operator|)
decl_stmt|;
name|agsaIORequestDesc_t
modifier|*
name|pRequest
decl_stmt|;
name|smTraceFuncEnter
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|"xq"
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"mpiGetControllerConfigCmd: Tag 0x%0X Page Code %0X\n"
operator|,
name|agControllerConfig
operator|->
name|tag
operator|,
name|agControllerConfig
operator|->
name|pageCode
operator|)
argument_list|)
expr_stmt|;
comment|/* Get request from free IORequests */
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|pRequest
operator|=
operator|(
name|agsaIORequestDesc_t
operator|*
operator|)
name|saLlistIOGetHead
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|)
expr_stmt|;
comment|/* If no LL Control request entry available */
if|if
condition|(
name|agNULL
operator|==
name|pRequest
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"mpiGetControllerConfigCmd, No request from free list\n"
operator|)
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'a'
argument_list|,
literal|"xq"
argument_list|)
expr_stmt|;
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_BUSY
return|;
block|}
comment|/* If LL Control request entry avaliable */
else|else
block|{
name|SA_DBG3
argument_list|(
operator|(
literal|"mpiGetControllerConfig, Build IOMB mpiGetControllerConfigCmd\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* Remove the request from free list */
name|SA_ASSERT
argument_list|(
operator|(
operator|!
name|pRequest
operator|->
name|valid
operator|)
argument_list|,
literal|"The pRequest is in use"
argument_list|)
expr_stmt|;
name|saLlistIORemove
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|Tag
operator|=
name|pRequest
operator|->
name|HTag
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|IORequest
operator|=
operator|(
name|void
operator|*
operator|)
name|pRequest
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|agContext
operator|=
name|agContext
expr_stmt|;
name|pRequest
operator|->
name|valid
operator|=
name|agTRUE
expr_stmt|;
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
comment|/* set tag field */
name|agControllerConfig
operator|->
name|tag
operator|=
name|pRequest
operator|->
name|HTag
expr_stmt|;
name|ret
operator|=
name|mpiBuildCmd
argument_list|(
name|agRoot
argument_list|,
operator|(
name|bit32
operator|*
operator|)
name|agControllerConfig
argument_list|,
name|MPI_CATEGORY_SAS_SATA
argument_list|,
name|OPC_INB_GET_CONTROLLER_CONFIG
argument_list|,
name|IOMB_SIZE64
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|AGSA_RC_SUCCESS
operator|!=
name|ret
condition|)
block|{
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
comment|/* remove the request from IOMap */
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|Tag
operator|=
name|MARK_OFF
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|IORequest
operator|=
name|agNULL
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|agContext
operator|=
name|agNULL
expr_stmt|;
name|pRequest
operator|->
name|valid
operator|=
name|agFALSE
expr_stmt|;
comment|/* return the request to free pool */
name|saLlistIOAdd
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"mpiGetControllerConfigCmd, sending IOMB failed\n"
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SA_DBG3
argument_list|(
operator|(
literal|"mpiGetControllerConfigCmd, set OK\n"
operator|)
argument_list|)
expr_stmt|;
block|}
name|SA_DBG3
argument_list|(
operator|(
literal|"mpiGetControllerConfigCmd, return value = %d\n"
operator|,
name|ret
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* return value */
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'b'
argument_list|,
literal|"xq"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*! \brief SAS Encryption KEK command  *  *  This command updates one or more KEK in a controller that supports encryption.  *  *  \param agRoot      Handles for this instance of SAS/SATA LLL  *  \param agContext   Context for the Get Nexus State command  *  \param agKekMgmt   Kek information that will be sent to the controller  *  \param queueNum    Queue Number of inbound/outbound queue  *  *  \return If the MPI command is sent to SPC successfully  *          - \e AGSA_RC_SUCCESS the MPI command is successfully  *          - \e AGSA_RC_BUSY the SPC is no resource, cannot send now  *          - \e AGSA_RC_FAILURE the MPI command is failure  *  */
end_comment

begin_comment
comment|/*******************************************************************************/
end_comment

begin_function
name|GLOBAL
name|bit32
name|mpiKekManagementCmd
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|agsaContext_t
modifier|*
name|agContext
parameter_list|,
name|agsaKekManagementCmd_t
modifier|*
name|agKekMgmt
parameter_list|,
name|bit32
name|queueNum
parameter_list|)
block|{
name|bit32
name|ret
init|=
name|AGSA_RC_SUCCESS
decl_stmt|;
name|agsaLLRoot_t
modifier|*
name|saRoot
init|=
operator|(
name|agsaLLRoot_t
operator|*
operator|)
operator|(
name|agRoot
operator|->
name|sdkData
operator|)
decl_stmt|;
name|agsaIORequestDesc_t
modifier|*
name|pRequest
decl_stmt|;
name|smTraceFuncEnter
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|"x2"
argument_list|)
expr_stmt|;
comment|/* Get request from free IORequests */
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|pRequest
operator|=
operator|(
name|agsaIORequestDesc_t
operator|*
operator|)
name|saLlistIOGetHead
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|)
expr_stmt|;
comment|/* If no LL Control request entry available */
if|if
condition|(
name|agNULL
operator|==
name|pRequest
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"mpiKekManagementCmd, No request from free list\n"
operator|)
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'a'
argument_list|,
literal|"x2"
argument_list|)
expr_stmt|;
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_BUSY
return|;
block|}
comment|/* If LL Control request entry avaliable */
else|else
block|{
name|SA_DBG3
argument_list|(
operator|(
literal|"mpiKekManagementCmd, Build OPC_INB_KEK_MANAGEMENT\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* Remove the request from free list */
name|SA_ASSERT
argument_list|(
operator|(
operator|!
name|pRequest
operator|->
name|valid
operator|)
argument_list|,
literal|"The pRequest is in use"
argument_list|)
expr_stmt|;
name|saLlistIORemove
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|Tag
operator|=
name|pRequest
operator|->
name|HTag
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|IORequest
operator|=
operator|(
name|void
operator|*
operator|)
name|pRequest
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|agContext
operator|=
name|agContext
expr_stmt|;
name|pRequest
operator|->
name|valid
operator|=
name|agTRUE
expr_stmt|;
name|agKekMgmt
operator|->
name|tag
operator|=
name|pRequest
operator|->
name|HTag
expr_stmt|;
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"mpiKekManagementCmd, 0x%X 0x%X 0x%X\n"
operator|,
name|agKekMgmt
operator|->
name|tag
operator|,
name|agKekMgmt
operator|->
name|NEWKIDX_CURKIDX_KBF_Reserved_SKNV_KSOP
operator|,
name|agKekMgmt
operator|->
name|reserved
operator|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|mpiBuildCmd
argument_list|(
name|agRoot
argument_list|,
operator|(
name|bit32
operator|*
operator|)
name|agKekMgmt
argument_list|,
name|MPI_CATEGORY_SAS_SATA
argument_list|,
name|OPC_INB_KEK_MANAGEMENT
argument_list|,
name|IOMB_SIZE64
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|AGSA_RC_SUCCESS
operator|!=
name|ret
condition|)
block|{
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
comment|/* remove the request from IOMap */
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|Tag
operator|=
name|MARK_OFF
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|IORequest
operator|=
name|agNULL
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|agContext
operator|=
name|agNULL
expr_stmt|;
name|pRequest
operator|->
name|valid
operator|=
name|agFALSE
expr_stmt|;
comment|/* return the request to free pool */
name|saLlistIOAdd
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"mpiKekManagementCmd, sending IOMB failed\n"
operator|)
argument_list|)
expr_stmt|;
block|}
name|SA_DBG3
argument_list|(
operator|(
literal|"mpiKekManagementCmd, return value = %d\n"
operator|,
name|ret
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* return value */
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'b'
argument_list|,
literal|"x2"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*! \brief SAS Encryption DEK management command  *  *  This command updates one or more DEK in a controller that supports encryption.  *  *  \param agRoot      Handles for this instance of SAS/SATA LLL  *  \param agContext   Context for the Get Nexus State command  *  \param agDekMgmt   DEK information that will be sent to the controller  *  \param queueNum    Queue Number of inbound/outbound queue  *  *  \return If the MPI command is sent to SPC successfully  *          - \e AGSA_RC_SUCCESS the MPI command is successfully  *          - \e AGSA_RC_BUSY the SPC is no resource, cannot send now  *          - \e AGSA_RC_FAILURE the MPI command is failure  *  */
end_comment

begin_comment
comment|/*******************************************************************************/
end_comment

begin_function
name|GLOBAL
name|bit32
name|mpiDekManagementCmd
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|agsaContext_t
modifier|*
name|agContext
parameter_list|,
name|agsaDekManagementCmd_t
modifier|*
name|agDekMgmt
parameter_list|,
name|bit32
name|queueNum
parameter_list|)
block|{
name|bit32
name|ret
init|=
name|AGSA_RC_SUCCESS
decl_stmt|;
name|agsaLLRoot_t
modifier|*
name|saRoot
init|=
operator|(
name|agsaLLRoot_t
operator|*
operator|)
operator|(
name|agRoot
operator|->
name|sdkData
operator|)
decl_stmt|;
name|agsaIORequestDesc_t
modifier|*
name|pRequest
decl_stmt|;
name|smTraceFuncEnter
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|"xs"
argument_list|)
expr_stmt|;
comment|/* Get request from free IORequests */
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|pRequest
operator|=
operator|(
name|agsaIORequestDesc_t
operator|*
operator|)
name|saLlistIOGetHead
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|)
expr_stmt|;
comment|/* If no LL Control request entry available */
if|if
condition|(
name|agNULL
operator|==
name|pRequest
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"mpiDekManagementCmd, No request from free list\n"
operator|)
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'a'
argument_list|,
literal|"xs"
argument_list|)
expr_stmt|;
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_BUSY
return|;
block|}
comment|/* If LL Control request entry avaliable */
else|else
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"mpiDekManagementCmd, Build OPC_INB_DEK_MANAGEMENT pRequest %p\n"
operator|,
name|pRequest
operator|)
argument_list|)
expr_stmt|;
comment|/* Remove the request from free list */
name|SA_ASSERT
argument_list|(
operator|(
operator|!
name|pRequest
operator|->
name|valid
operator|)
argument_list|,
literal|"The pRequest is in use"
argument_list|)
expr_stmt|;
name|saLlistIORemove
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|Tag
operator|=
name|pRequest
operator|->
name|HTag
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|IORequest
operator|=
operator|(
name|void
operator|*
operator|)
name|pRequest
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|agContext
operator|=
name|agContext
expr_stmt|;
name|pRequest
operator|->
name|valid
operator|=
name|agTRUE
expr_stmt|;
name|agDekMgmt
operator|->
name|tag
operator|=
name|pRequest
operator|->
name|HTag
expr_stmt|;
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"mpiDekManagementCmd: 0x%X 0x%X 0x%X 0x%X 0x%X 0x%X 0x%X\n"
operator|,
name|agDekMgmt
operator|->
name|tag
operator|,
name|agDekMgmt
operator|->
name|KEKIDX_Reserved_TBLS_DSOP
operator|,
name|agDekMgmt
operator|->
name|dekIndex
operator|,
name|agDekMgmt
operator|->
name|tableAddrLo
operator|,
name|agDekMgmt
operator|->
name|tableAddrHi
operator|,
name|agDekMgmt
operator|->
name|tableEntries
operator|,
name|agDekMgmt
operator|->
name|Reserved_DBF_TBL_SIZE
operator|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|mpiBuildCmd
argument_list|(
name|agRoot
argument_list|,
operator|(
name|bit32
operator|*
operator|)
name|agDekMgmt
argument_list|,
name|MPI_CATEGORY_SAS_SATA
argument_list|,
name|OPC_INB_DEK_MANAGEMENT
argument_list|,
name|IOMB_SIZE64
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|AGSA_RC_SUCCESS
operator|!=
name|ret
condition|)
block|{
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
comment|/* remove the request from IOMap */
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|Tag
operator|=
name|MARK_OFF
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|IORequest
operator|=
name|agNULL
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|agContext
operator|=
name|agNULL
expr_stmt|;
name|pRequest
operator|->
name|valid
operator|=
name|agFALSE
expr_stmt|;
comment|/* return the request to free pool */
name|saLlistIOAdd
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"mpiDekManagementCmd, sending IOMB failed\n"
operator|)
argument_list|)
expr_stmt|;
block|}
name|SA_DBG3
argument_list|(
operator|(
literal|"mpiDekManagementCmd, return value = %d\n"
operator|,
name|ret
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* return value */
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'b'
argument_list|,
literal|"xs"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*! \brief  *  *  This command sends operator management command.  *  *  \param agRoot      Handles for this instance of SAS/SATA LLL  *  \param agContext   Context  *  \param queueNum    Queue Number of inbound/outbound queue  *  *  \return If the MPI command is sent to SPC successfully  *          - \e AGSA_RC_SUCCESS the MPI command is successfully  *          - \e AGSA_RC_BUSY the SPC is no resource, cannot send now  *          - \e AGSA_RC_FAILURE the MPI command is failure  *  */
end_comment

begin_comment
comment|/*******************************************************************************/
end_comment

begin_function
name|GLOBAL
name|bit32
name|mpiOperatorManagementCmd
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|bit32
name|queueNum
parameter_list|,
name|agsaContext_t
modifier|*
name|agContext
parameter_list|,
name|agsaOperatorMangmentCmd_t
modifier|*
name|operatorcode
parameter_list|)
block|{
name|bit32
name|ret
init|=
name|AGSA_RC_SUCCESS
decl_stmt|;
name|agsaLLRoot_t
modifier|*
name|saRoot
init|=
operator|(
name|agsaLLRoot_t
operator|*
operator|)
operator|(
name|agRoot
operator|->
name|sdkData
operator|)
decl_stmt|;
name|agsaIORequestDesc_t
modifier|*
name|pRequest
decl_stmt|;
name|smTraceFuncEnter
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|"2q"
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"mpiOperatorManagementCmd, enter\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* Get request from free IORequests */
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|pRequest
operator|=
operator|(
name|agsaIORequestDesc_t
operator|*
operator|)
name|saLlistIOGetHead
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|)
expr_stmt|;
comment|/* If no LL Control request entry available */
if|if
condition|(
name|agNULL
operator|==
name|pRequest
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"mpiOperatorManagementCmd, No request from free list\n"
operator|)
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'a'
argument_list|,
literal|"2q"
argument_list|)
expr_stmt|;
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_BUSY
return|;
block|}
comment|/* If LL Control request entry avaliable */
else|else
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"mpiOperatorManagementCmd, Build OPC_INB_OPR_MGMT\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* Remove the request from free list */
name|SA_ASSERT
argument_list|(
operator|(
operator|!
name|pRequest
operator|->
name|valid
operator|)
argument_list|,
literal|"The pRequest is in use"
argument_list|)
expr_stmt|;
name|saLlistIORemove
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|Tag
operator|=
name|pRequest
operator|->
name|HTag
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|IORequest
operator|=
operator|(
name|void
operator|*
operator|)
name|pRequest
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|agContext
operator|=
name|agContext
expr_stmt|;
name|pRequest
operator|->
name|valid
operator|=
name|agTRUE
expr_stmt|;
name|operatorcode
operator|->
name|tag
operator|=
name|pRequest
operator|->
name|HTag
expr_stmt|;
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|ret
operator|=
name|mpiBuildCmd
argument_list|(
name|agRoot
argument_list|,
operator|(
name|bit32
operator|*
operator|)
name|operatorcode
argument_list|,
name|MPI_CATEGORY_SAS_SATA
argument_list|,
name|OPC_INB_OPR_MGMT
argument_list|,
name|IOMB_SIZE128
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|AGSA_RC_SUCCESS
operator|!=
name|ret
condition|)
block|{
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
comment|/* remove the request from IOMap */
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|Tag
operator|=
name|MARK_OFF
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|IORequest
operator|=
name|agNULL
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|agContext
operator|=
name|agNULL
expr_stmt|;
name|pRequest
operator|->
name|valid
operator|=
name|agFALSE
expr_stmt|;
comment|/* return the request to free pool */
name|saLlistIOAdd
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"mpiOperatorManagementCmd, sending IOMB failed\n"
operator|)
argument_list|)
expr_stmt|;
block|}
name|SA_DBG1
argument_list|(
operator|(
literal|"mpiOperatorManagementCmd, return value = %d\n"
operator|,
name|ret
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* return value */
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'b'
argument_list|,
literal|"2q"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*! \brief  *  *  This command sends encrypt self test command.  *  *  \param agRoot      Handles for this instance of SAS/SATA LLL  *  \param agContext   Context  *  \param queueNum    Queue Number of inbound/outbound queue  *  *  \return If the MPI command is sent to SPC successfully  *          - \e AGSA_RC_SUCCESS the MPI command is successfully  *          - \e AGSA_RC_BUSY the SPC is no resource, cannot send now  *          - \e AGSA_RC_FAILURE the MPI command is failure  *  */
end_comment

begin_comment
comment|/*******************************************************************************/
end_comment

begin_function
name|GLOBAL
name|bit32
name|mpiEncryptBistCmd
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|bit32
name|queueNum
parameter_list|,
name|agsaContext_t
modifier|*
name|agContext
parameter_list|,
name|agsaEncryptBist_t
modifier|*
name|bist
parameter_list|)
block|{
name|bit32
name|ret
init|=
name|AGSA_RC_SUCCESS
decl_stmt|;
name|agsaLLRoot_t
modifier|*
name|saRoot
init|=
operator|(
name|agsaLLRoot_t
operator|*
operator|)
operator|(
name|agRoot
operator|->
name|sdkData
operator|)
decl_stmt|;
name|agsaIORequestDesc_t
modifier|*
name|pRequest
decl_stmt|;
name|smTraceFuncEnter
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|"2z"
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"mpiEncryptBistCmd, enter\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* Get request from free IORequests */
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|pRequest
operator|=
operator|(
name|agsaIORequestDesc_t
operator|*
operator|)
name|saLlistIOGetHead
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|)
expr_stmt|;
comment|/* If no LL Control request entry available */
if|if
condition|(
name|agNULL
operator|==
name|pRequest
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"mpiEncryptBistCmd, No request from free list\n"
operator|)
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'a'
argument_list|,
literal|"2z"
argument_list|)
expr_stmt|;
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_BUSY
return|;
block|}
comment|/* If LL Control request entry avaliable */
else|else
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"mpiEncryptBistCmd, Build OPC_INB_ENC_TEST_EXECUTE\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* Remove the request from free list */
name|SA_ASSERT
argument_list|(
operator|(
operator|!
name|pRequest
operator|->
name|valid
operator|)
argument_list|,
literal|"The pRequest is in use"
argument_list|)
expr_stmt|;
name|saLlistIORemove
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|Tag
operator|=
name|pRequest
operator|->
name|HTag
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|IORequest
operator|=
operator|(
name|void
operator|*
operator|)
name|pRequest
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|agContext
operator|=
name|agContext
expr_stmt|;
name|pRequest
operator|->
name|valid
operator|=
name|agTRUE
expr_stmt|;
name|bist
operator|->
name|tag
operator|=
name|pRequest
operator|->
name|HTag
expr_stmt|;
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"mpiEncryptBistCmd: 0x%X 0x%X 0x%X 0x%X 0x%X 0x%X 0x%X\n"
operator|,
name|bist
operator|->
name|tag
operator|,
name|bist
operator|->
name|r_subop
operator|,
name|bist
operator|->
name|testDiscption
index|[
literal|0
index|]
operator|,
name|bist
operator|->
name|testDiscption
index|[
literal|1
index|]
operator|,
name|bist
operator|->
name|testDiscption
index|[
literal|2
index|]
operator|,
name|bist
operator|->
name|testDiscption
index|[
literal|3
index|]
operator|,
name|bist
operator|->
name|testDiscption
index|[
literal|4
index|]
operator|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|mpiBuildCmd
argument_list|(
name|agRoot
argument_list|,
operator|(
name|bit32
operator|*
operator|)
name|bist
argument_list|,
name|MPI_CATEGORY_SAS_SATA
argument_list|,
name|OPC_INB_ENC_TEST_EXECUTE
argument_list|,
name|IOMB_SIZE64
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|AGSA_RC_SUCCESS
operator|!=
name|ret
condition|)
block|{
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
comment|/* remove the request from IOMap */
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|Tag
operator|=
name|MARK_OFF
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|IORequest
operator|=
name|agNULL
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|agContext
operator|=
name|agNULL
expr_stmt|;
name|pRequest
operator|->
name|valid
operator|=
name|agFALSE
expr_stmt|;
comment|/* return the request to free pool */
name|saLlistIOAdd
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"mpiEncryptBistCmd, sending IOMB failed\n"
operator|)
argument_list|)
expr_stmt|;
block|}
name|SA_DBG1
argument_list|(
operator|(
literal|"mpiEncryptBistCmd, return value = %d\n"
operator|,
name|ret
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* return value */
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'b'
argument_list|,
literal|"2z"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*! \brief  *  *  This command sends set operator command.  *  *  \param agRoot      Handles for this instance of SAS/SATA LLL  *  \param agContext   Context  *  \param queueNum    Queue Number of inbound/outbound queue  *  *  \return If the MPI command is sent to SPC successfully  *          - \e AGSA_RC_SUCCESS the MPI command is successfully  *          - \e AGSA_RC_BUSY the SPC is no resource, cannot send now  *          - \e AGSA_RC_FAILURE the MPI command is failure  *  */
end_comment

begin_comment
comment|/*******************************************************************************/
end_comment

begin_function
name|GLOBAL
name|bit32
name|mpiSetOperatorCmd
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|bit32
name|queueNum
parameter_list|,
name|agsaContext_t
modifier|*
name|agContext
parameter_list|,
name|agsaSetOperatorCmd_t
modifier|*
name|operatorcode
parameter_list|)
block|{
name|bit32
name|ret
init|=
name|AGSA_RC_SUCCESS
decl_stmt|;
name|agsaLLRoot_t
modifier|*
name|saRoot
init|=
operator|(
name|agsaLLRoot_t
operator|*
operator|)
operator|(
name|agRoot
operator|->
name|sdkData
operator|)
decl_stmt|;
name|agsaIORequestDesc_t
modifier|*
name|pRequest
decl_stmt|;
name|smTraceFuncEnter
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|"39"
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"mpiSetOperatorCmd, enter\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* Get request from free IORequests */
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|pRequest
operator|=
operator|(
name|agsaIORequestDesc_t
operator|*
operator|)
name|saLlistIOGetHead
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|)
expr_stmt|;
comment|/* If no LL Control request entry available */
if|if
condition|(
name|agNULL
operator|==
name|pRequest
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"mpiSetOperatorCmd, No request from free list\n"
operator|)
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'a'
argument_list|,
literal|"39"
argument_list|)
expr_stmt|;
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_BUSY
return|;
block|}
comment|/* If LL Control request entry avaliable */
else|else
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"mpiSetOperatorCmd, Build OPC_INB_SET_OPERATOR\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* Remove the request from free list */
name|SA_ASSERT
argument_list|(
operator|(
operator|!
name|pRequest
operator|->
name|valid
operator|)
argument_list|,
literal|"The pRequest is in use"
argument_list|)
expr_stmt|;
name|saLlistIORemove
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|Tag
operator|=
name|pRequest
operator|->
name|HTag
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|IORequest
operator|=
operator|(
name|void
operator|*
operator|)
name|pRequest
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|agContext
operator|=
name|agContext
expr_stmt|;
name|pRequest
operator|->
name|valid
operator|=
name|agTRUE
expr_stmt|;
name|operatorcode
operator|->
name|tag
operator|=
name|pRequest
operator|->
name|HTag
expr_stmt|;
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|ret
operator|=
name|mpiBuildCmd
argument_list|(
name|agRoot
argument_list|,
operator|(
name|bit32
operator|*
operator|)
name|operatorcode
argument_list|,
name|MPI_CATEGORY_SAS_SATA
argument_list|,
name|OPC_INB_SET_OPERATOR
argument_list|,
name|IOMB_SIZE64
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|AGSA_RC_SUCCESS
operator|!=
name|ret
condition|)
block|{
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
comment|/* remove the request from IOMap */
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|Tag
operator|=
name|MARK_OFF
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|IORequest
operator|=
name|agNULL
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|agContext
operator|=
name|agNULL
expr_stmt|;
name|pRequest
operator|->
name|valid
operator|=
name|agFALSE
expr_stmt|;
comment|/* return the request to free pool */
name|saLlistIOAdd
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"mpiSetOperatorCmd, sending IOMB failed\n"
operator|)
argument_list|)
expr_stmt|;
block|}
name|SA_DBG1
argument_list|(
operator|(
literal|"mpiSetOperatorCmd, return value = %d\n"
operator|,
name|ret
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* return value */
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'b'
argument_list|,
literal|"39"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*! \brief  *  *  This command sends get operator command.  *  *  \param agRoot      Handles for this instance of SAS/SATA LLL  *  \param agContext   Context  *  \param queueNum    Queue Number of inbound/outbound queue  *  *  \return If the MPI command is sent to SPC successfully  *          - \e AGSA_RC_SUCCESS the MPI command is successfully  *          - \e AGSA_RC_BUSY the SPC is no resource, cannot send now  *          - \e AGSA_RC_FAILURE the MPI command is failure  *  */
end_comment

begin_comment
comment|/*******************************************************************************/
end_comment

begin_function
name|GLOBAL
name|bit32
name|mpiGetOperatorCmd
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|bit32
name|queueNum
parameter_list|,
name|agsaContext_t
modifier|*
name|agContext
parameter_list|,
name|agsaGetOperatorCmd_t
modifier|*
name|operatorcode
parameter_list|)
block|{
name|bit32
name|ret
init|=
name|AGSA_RC_SUCCESS
decl_stmt|;
name|agsaLLRoot_t
modifier|*
name|saRoot
init|=
operator|(
name|agsaLLRoot_t
operator|*
operator|)
operator|(
name|agRoot
operator|->
name|sdkData
operator|)
decl_stmt|;
name|agsaIORequestDesc_t
modifier|*
name|pRequest
decl_stmt|;
name|smTraceFuncEnter
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|"3e"
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"mpiGetOperatorCmd, enter\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* Get request from free IORequests */
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|pRequest
operator|=
operator|(
name|agsaIORequestDesc_t
operator|*
operator|)
name|saLlistIOGetHead
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|)
expr_stmt|;
comment|/* If no LL Control request entry available */
if|if
condition|(
name|agNULL
operator|==
name|pRequest
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"mpiGetOperatorCmd, No request from free list\n"
operator|)
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'a'
argument_list|,
literal|"3e"
argument_list|)
expr_stmt|;
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_BUSY
return|;
block|}
comment|/* If LL Control request entry avaliable */
else|else
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"mpiGetOperatorCmd, Build OPC_INB_GET_OPERATOR\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* Remove the request from free list */
name|SA_ASSERT
argument_list|(
operator|(
operator|!
name|pRequest
operator|->
name|valid
operator|)
argument_list|,
literal|"The pRequest is in use"
argument_list|)
expr_stmt|;
name|saLlistIORemove
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|Tag
operator|=
name|pRequest
operator|->
name|HTag
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|IORequest
operator|=
operator|(
name|void
operator|*
operator|)
name|pRequest
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|agContext
operator|=
name|agContext
expr_stmt|;
name|pRequest
operator|->
name|valid
operator|=
name|agTRUE
expr_stmt|;
name|operatorcode
operator|->
name|tag
operator|=
name|pRequest
operator|->
name|HTag
expr_stmt|;
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|ret
operator|=
name|mpiBuildCmd
argument_list|(
name|agRoot
argument_list|,
operator|(
name|bit32
operator|*
operator|)
name|operatorcode
argument_list|,
name|MPI_CATEGORY_SAS_SATA
argument_list|,
name|OPC_INB_GET_OPERATOR
argument_list|,
name|IOMB_SIZE64
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|AGSA_RC_SUCCESS
operator|!=
name|ret
condition|)
block|{
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
comment|/* remove the request from IOMap */
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|Tag
operator|=
name|MARK_OFF
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|IORequest
operator|=
name|agNULL
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|agContext
operator|=
name|agNULL
expr_stmt|;
name|pRequest
operator|->
name|valid
operator|=
name|agFALSE
expr_stmt|;
comment|/* return the request to free pool */
name|saLlistIOAdd
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"mpiGetOperatorCmd, sending IOMB failed\n"
operator|)
argument_list|)
expr_stmt|;
block|}
name|SA_DBG1
argument_list|(
operator|(
literal|"mpiGetOperatorCmd, return value = %d\n"
operator|,
name|ret
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* return value */
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'b'
argument_list|,
literal|"3e"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|GLOBAL
name|bit32
name|mpiDIFEncryptionOffloadCmd
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|agsaContext_t
modifier|*
name|agContext
parameter_list|,
name|bit32
name|queueNum
parameter_list|,
name|bit32
name|op
parameter_list|,
name|agsaDifEncPayload_t
modifier|*
name|agDifEncOffload
parameter_list|,
name|ossaDIFEncryptionOffloadStartCB_t
name|agCB
parameter_list|)
block|{
name|bit32
name|ret
init|=
name|AGSA_RC_SUCCESS
decl_stmt|;
name|bit32
name|dw8
init|=
literal|0
decl_stmt|;
name|bit32
name|dw9
init|=
literal|0
decl_stmt|;
name|bit32
name|dw10
init|=
literal|0
decl_stmt|;
name|bit32
name|dw14
init|=
literal|0
decl_stmt|;
name|bit32
name|dw15
init|=
literal|0
decl_stmt|;
name|agsaLLRoot_t
modifier|*
name|saRoot
init|=
operator|(
name|agsaLLRoot_t
operator|*
operator|)
operator|(
name|agRoot
operator|->
name|sdkData
operator|)
decl_stmt|;
name|agsaIORequestDesc_t
modifier|*
name|pRequest
decl_stmt|;
name|agsaDifEncOffloadCmd_t
name|payload
decl_stmt|;
name|smTraceFuncEnter
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|"2b"
argument_list|)
expr_stmt|;
comment|/* Get request from free IORequests */
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|pRequest
operator|=
operator|(
name|agsaIORequestDesc_t
operator|*
operator|)
name|saLlistIOGetHead
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|)
expr_stmt|;
comment|/* If no LL Control request entry available */
if|if
condition|(
name|agNULL
operator|==
name|pRequest
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"mpiDIFEncryptionOffloadCmd: No request from free list\n"
operator|)
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'a'
argument_list|,
literal|"2b"
argument_list|)
expr_stmt|;
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_BUSY
return|;
block|}
comment|/* If LL Control request entry avaliable */
else|else
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"mpiDIFEncryptionOffloadCmd: Build OPC_INB_DIF_ENC_OFFLOAD_CMD pRequest %p\n"
operator|,
name|pRequest
operator|)
argument_list|)
expr_stmt|;
comment|/* Remove the request from free list */
name|SA_ASSERT
argument_list|(
operator|(
operator|!
name|pRequest
operator|->
name|valid
operator|)
argument_list|,
literal|"The pRequest is in use"
argument_list|)
expr_stmt|;
name|saLlistIORemove
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|Tag
operator|=
name|pRequest
operator|->
name|HTag
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|IORequest
operator|=
operator|(
name|void
operator|*
operator|)
name|pRequest
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|agContext
operator|=
name|agContext
expr_stmt|;
name|pRequest
operator|->
name|valid
operator|=
name|agTRUE
expr_stmt|;
name|pRequest
operator|->
name|completionCB
operator|=
operator|(
name|ossaSSPCompletedCB_t
operator|)
name|agCB
expr_stmt|;
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|si_memset
argument_list|(
operator|&
name|payload
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|agsaDifEncOffloadCmd_t
argument_list|)
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"mpiDIFEncryptionOffloadCmd: op %d\n"
operator|,
name|op
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|smIS_SPCV
argument_list|(
name|agRoot
argument_list|)
condition|)
block|{
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaDifEncOffloadCmd_t
argument_list|,
name|tag
argument_list|)
argument_list|,
name|pRequest
operator|->
name|HTag
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaDifEncOffloadCmd_t
argument_list|,
name|option
argument_list|)
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaDifEncOffloadCmd_t
argument_list|,
name|Src_Data_Len
argument_list|)
argument_list|,
name|agDifEncOffload
operator|->
name|SrcDL
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaDifEncOffloadCmd_t
argument_list|,
name|Dst_Data_Len
argument_list|)
argument_list|,
name|agDifEncOffload
operator|->
name|DstDL
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaDifEncOffloadCmd_t
argument_list|,
name|flags
argument_list|)
argument_list|,
name|agDifEncOffload
operator|->
name|dif
operator|.
name|flags
argument_list|)
expr_stmt|;
name|dw8
operator|=
name|agDifEncOffload
operator|->
name|dif
operator|.
name|udrtArray
index|[
literal|1
index|]
operator|<<
name|SHIFT24
operator||
name|agDifEncOffload
operator|->
name|dif
operator|.
name|udrtArray
index|[
literal|0
index|]
operator|<<
name|SHIFT16
operator||
name|agDifEncOffload
operator|->
name|dif
operator|.
name|udtArray
index|[
literal|1
index|]
operator|<<
name|SHIFT8
operator||
name|agDifEncOffload
operator|->
name|dif
operator|.
name|udtArray
index|[
literal|0
index|]
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaDifEncOffloadCmd_t
argument_list|,
name|UDTR01UDT01
argument_list|)
argument_list|,
name|dw8
argument_list|)
expr_stmt|;
name|dw9
operator|=
name|agDifEncOffload
operator|->
name|dif
operator|.
name|udtArray
index|[
literal|5
index|]
operator|<<
name|SHIFT24
operator||
name|agDifEncOffload
operator|->
name|dif
operator|.
name|udtArray
index|[
literal|4
index|]
operator|<<
name|SHIFT16
operator||
name|agDifEncOffload
operator|->
name|dif
operator|.
name|udtArray
index|[
literal|3
index|]
operator|<<
name|SHIFT8
operator||
name|agDifEncOffload
operator|->
name|dif
operator|.
name|udtArray
index|[
literal|2
index|]
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaDifEncOffloadCmd_t
argument_list|,
name|UDT2345
argument_list|)
argument_list|,
name|dw9
argument_list|)
expr_stmt|;
name|dw10
operator|=
name|agDifEncOffload
operator|->
name|dif
operator|.
name|udrtArray
index|[
literal|5
index|]
operator|<<
name|SHIFT24
operator||
name|agDifEncOffload
operator|->
name|dif
operator|.
name|udrtArray
index|[
literal|4
index|]
operator|<<
name|SHIFT16
operator||
name|agDifEncOffload
operator|->
name|dif
operator|.
name|udrtArray
index|[
literal|3
index|]
operator|<<
name|SHIFT8
operator||
name|agDifEncOffload
operator|->
name|dif
operator|.
name|udrtArray
index|[
literal|2
index|]
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaDifEncOffloadCmd_t
argument_list|,
name|UDTR2345
argument_list|)
argument_list|,
name|dw10
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaDifEncOffloadCmd_t
argument_list|,
name|DPLR0SecCnt_IOSeed
argument_list|)
argument_list|,
name|agDifEncOffload
operator|->
name|dif
operator|.
name|DIFPerLARegion0SecCount
operator|<<
name|SHIFT16
operator||
name|agDifEncOffload
operator|->
name|dif
operator|.
name|initialIOSeed
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaDifEncOffloadCmd_t
argument_list|,
name|DPL_Addr_Lo
argument_list|)
argument_list|,
name|agDifEncOffload
operator|->
name|dif
operator|.
name|DIFPerLAAddrLo
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaDifEncOffloadCmd_t
argument_list|,
name|DPL_Addr_Hi
argument_list|)
argument_list|,
name|agDifEncOffload
operator|->
name|dif
operator|.
name|DIFPerLAAddrHi
argument_list|)
expr_stmt|;
name|dw14
operator|=
name|agDifEncOffload
operator|->
name|encrypt
operator|.
name|dekInfo
operator|.
name|dekIndex
operator|<<
name|SHIFT8
operator||
operator|(
name|agDifEncOffload
operator|->
name|encrypt
operator|.
name|dekInfo
operator|.
name|dekTable
operator|&
literal|0x3
operator|)
operator|<<
name|SHIFT2
operator||
operator|(
name|agDifEncOffload
operator|->
name|encrypt
operator|.
name|keyTagCheck
operator|&
literal|0x1
operator|)
operator|<<
name|SHIFT1
expr_stmt|;
if|if
condition|(
name|agDifEncOffload
operator|->
name|encrypt
operator|.
name|cipherMode
operator|==
name|agsaEncryptCipherModeXTS
condition|)
block|{
name|dw14
operator||=
name|AGSA_ENCRYPT_XTS_Mode
operator|<<
name|SHIFT4
expr_stmt|;
block|}
else|else
block|{
name|dw14
operator||=
operator|(
name|agDifEncOffload
operator|->
name|encrypt
operator|.
name|cipherMode
operator|&
literal|0xF
operator|)
operator|<<
name|SHIFT4
expr_stmt|;
block|}
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaDifEncOffloadCmd_t
argument_list|,
name|KeyIndex_CMode_KTS_ENT_R
argument_list|)
argument_list|,
name|dw14
argument_list|)
expr_stmt|;
name|dw15
operator|=
name|agDifEncOffload
operator|->
name|encrypt
operator|.
name|EncryptionPerLRegion0SecCount
operator|<<
name|SHIFT16
operator||
operator|(
name|agDifEncOffload
operator|->
name|encrypt
operator|.
name|kekIndex
operator|&
literal|0xF
operator|)
operator|<<
name|SHIFT5
operator||
operator|(
name|agDifEncOffload
operator|->
name|encrypt
operator|.
name|sectorSizeIndex
operator|&
literal|0x1F
operator|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaDifEncOffloadCmd_t
argument_list|,
name|EPLR0SecCnt_KS_ENSS
argument_list|)
argument_list|,
name|dw15
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaDifEncOffloadCmd_t
argument_list|,
name|keyTag_W0
argument_list|)
argument_list|,
name|agDifEncOffload
operator|->
name|encrypt
operator|.
name|keyTag_W0
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaDifEncOffloadCmd_t
argument_list|,
name|keyTag_W1
argument_list|)
argument_list|,
name|agDifEncOffload
operator|->
name|encrypt
operator|.
name|keyTag_W1
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaDifEncOffloadCmd_t
argument_list|,
name|tweakVal_W0
argument_list|)
argument_list|,
name|agDifEncOffload
operator|->
name|encrypt
operator|.
name|tweakVal_W0
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaDifEncOffloadCmd_t
argument_list|,
name|tweakVal_W1
argument_list|)
argument_list|,
name|agDifEncOffload
operator|->
name|encrypt
operator|.
name|tweakVal_W1
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaDifEncOffloadCmd_t
argument_list|,
name|tweakVal_W2
argument_list|)
argument_list|,
name|agDifEncOffload
operator|->
name|encrypt
operator|.
name|tweakVal_W2
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaDifEncOffloadCmd_t
argument_list|,
name|tweakVal_W3
argument_list|)
argument_list|,
name|agDifEncOffload
operator|->
name|encrypt
operator|.
name|tweakVal_W3
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaDifEncOffloadCmd_t
argument_list|,
name|EPL_Addr_Lo
argument_list|)
argument_list|,
name|agDifEncOffload
operator|->
name|encrypt
operator|.
name|EncryptionPerLAAddrLo
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
operator|&
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaDifEncOffloadCmd_t
argument_list|,
name|EPL_Addr_Hi
argument_list|)
argument_list|,
name|agDifEncOffload
operator|->
name|encrypt
operator|.
name|EncryptionPerLAAddrHi
argument_list|)
expr_stmt|;
name|si_memcpy
argument_list|(
operator|(
name|bit32
operator|*
operator|)
operator|&
operator|(
name|payload
operator|.
name|SrcSgl
operator|)
argument_list|,
operator|(
name|bit32
operator|*
operator|)
operator|&
operator|(
name|agDifEncOffload
operator|->
name|SrcSgl
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|agsaSgl_t
argument_list|)
argument_list|)
expr_stmt|;
name|si_memcpy
argument_list|(
operator|(
name|bit32
operator|*
operator|)
operator|&
operator|(
name|payload
operator|.
name|DstSgl
operator|)
argument_list|,
operator|(
name|bit32
operator|*
operator|)
operator|&
operator|(
name|agDifEncOffload
operator|->
name|DstSgl
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|agsaSgl_t
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|mpiBuildCmd
argument_list|(
name|agRoot
argument_list|,
operator|(
name|bit32
operator|*
operator|)
operator|&
name|payload
argument_list|,
name|MPI_CATEGORY_SAS_SATA
argument_list|,
name|OPC_INB_DIF_ENC_OFFLOAD_CMD
argument_list|,
name|IOMB_SIZE128
argument_list|,
name|queueNum
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* SPC does not support this command */
name|ret
operator|=
name|AGSA_RC_FAILURE
expr_stmt|;
block|}
if|if
condition|(
name|AGSA_RC_SUCCESS
operator|!=
name|ret
condition|)
block|{
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
comment|/* remove the request from IOMap */
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|Tag
operator|=
name|MARK_OFF
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|IORequest
operator|=
name|agNULL
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|agContext
operator|=
name|agNULL
expr_stmt|;
name|pRequest
operator|->
name|valid
operator|=
name|agFALSE
expr_stmt|;
comment|/* return the request to free pool */
name|saLlistIOAdd
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"mpiDIFEncryptionOffloadCmd: sending IOMB failed\n"
operator|)
argument_list|)
expr_stmt|;
block|}
name|SA_DBG3
argument_list|(
operator|(
literal|"mpiDIFEncryptionOffloadCmd: return value = %d\n"
operator|,
name|ret
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* return value */
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'b'
argument_list|,
literal|"2b"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

end_unit

