begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************************* *Copyright (c) 2014 PMC-Sierra, Inc.  All rights reserved.  * *Redistribution and use in source and binary forms, with or without modification, are permitted provided  *that the following conditions are met:  *1. Redistributions of source code must retain the above copyright notice, this list of conditions and the *following disclaimer.  *2. Redistributions in binary form must reproduce the above copyright notice,  *this list of conditions and the following disclaimer in the documentation and/or other materials provided *with the distribution.  * *THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR IMPLIED  *WARRANTIES,INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS *FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE *FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  *NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR  *BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  *LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  *SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE  ********************************************************************************/
end_comment

begin_comment
comment|/*******************************************************************************/
end_comment

begin_comment
comment|/*! \file sasata.c  *  \brief The file implements the functions to SATA IO  *  */
end_comment

begin_comment
comment|/******************************************************************************/
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<dev/pms/config.h>
end_include

begin_include
include|#
directive|include
file|<dev/pms/RefTisa/sallsdk/spc/saglobal.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SA_ENABLE_TRACE_FUNCTIONS
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|siTraceFileID
end_ifdef

begin_undef
undef|#
directive|undef
name|siTraceFileID
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|siTraceFileID
value|'M'
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*! \brief Start SATA command  *  *  Start SATA command  *  *  \param agRoot handles for this instance of SAS/SATA hardware  *  \param queueNum  *  \param agIORequest  *  \param agDevHandle  *  \param agRequestType  *  \param agSATAReq  *  \param agTag  *  \param agCB  *  *  \return If command is started successfully  *          - \e AGSA_RC_SUCCESS command is started successfully  *          - \e AGSA_RC_FAILURE command is not started successfully  */
end_comment

begin_comment
comment|/*******************************************************************************/
end_comment

begin_function
name|GLOBAL
name|bit32
name|saSATAStart
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|agsaIORequest_t
modifier|*
name|agIORequest
parameter_list|,
name|bit32
name|queueNum
parameter_list|,
name|agsaDevHandle_t
modifier|*
name|agDevHandle
parameter_list|,
name|bit32
name|agRequestType
parameter_list|,
name|agsaSATAInitiatorRequest_t
modifier|*
name|agSATAReq
parameter_list|,
name|bit8
name|agTag
parameter_list|,
name|ossaSATACompletedCB_t
name|agCB
parameter_list|)
block|{
name|agsaLLRoot_t
modifier|*
name|saRoot
init|=
operator|(
name|agsaLLRoot_t
operator|*
operator|)
operator|(
name|agRoot
operator|->
name|sdkData
operator|)
decl_stmt|;
name|mpiICQueue_t
modifier|*
name|circularQ
init|=
name|agNULL
decl_stmt|;
name|agsaDeviceDesc_t
modifier|*
name|pDevice
init|=
name|agNULL
decl_stmt|;
name|agsaPort_t
modifier|*
name|pPort
init|=
name|agNULL
decl_stmt|;
name|agsaIORequestDesc_t
modifier|*
name|pRequest
init|=
name|agNULL
decl_stmt|;
name|void
modifier|*
name|pMessage
init|=
name|agNULL
decl_stmt|;
name|agsaSgl_t
modifier|*
name|pSgl
init|=
name|agNULL
decl_stmt|;
name|bit32
modifier|*
name|payload
init|=
name|agNULL
decl_stmt|;
name|bit32
name|deviceIndex
init|=
literal|0
decl_stmt|;
name|bit32
name|ret
init|=
name|AGSA_RC_SUCCESS
decl_stmt|,
name|retVal
init|=
literal|0
decl_stmt|;
name|bit32
name|AtapDir
init|=
literal|0
decl_stmt|;
name|bit32
name|encryptFlags
init|=
literal|0
decl_stmt|;
name|bit16
name|size
init|=
literal|0
decl_stmt|;
name|bit16
name|opCode
init|=
literal|0
decl_stmt|;
name|bit8
name|inq
init|=
literal|0
decl_stmt|,
name|outq
init|=
literal|0
decl_stmt|;
name|OSSA_INP_ENTER
argument_list|(
name|agRoot
argument_list|)
expr_stmt|;
name|smTraceFuncEnter
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|"8a"
argument_list|)
expr_stmt|;
name|SA_DBG3
argument_list|(
operator|(
literal|"saSATAStart: in\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* sanity check */
name|SA_ASSERT
argument_list|(
operator|(
name|agNULL
operator|!=
name|agRoot
operator|)
argument_list|,
literal|"(saSATAStart) agRoot is NULL"
argument_list|)
expr_stmt|;
name|SA_ASSERT
argument_list|(
operator|(
name|agNULL
operator|!=
name|agIORequest
operator|)
argument_list|,
literal|"(saSATAStart) agIORequest is NULL"
argument_list|)
expr_stmt|;
name|SA_ASSERT
argument_list|(
operator|(
name|agNULL
operator|!=
name|agDevHandle
operator|)
argument_list|,
literal|"(saSATAStart) agDevHandle is NULL"
argument_list|)
expr_stmt|;
name|SA_ASSERT
argument_list|(
operator|(
name|agNULL
operator|!=
name|agSATAReq
operator|)
argument_list|,
literal|"(saSATAStart) agSATAReq is NULL"
argument_list|)
expr_stmt|;
comment|/* Assign inbound and outbound queue */
name|inq
operator|=
call|(
name|bit8
call|)
argument_list|(
name|queueNum
operator|&
name|MPI_IB_NUM_MASK
argument_list|)
expr_stmt|;
name|outq
operator|=
call|(
name|bit8
call|)
argument_list|(
operator|(
name|queueNum
operator|&
name|MPI_OB_NUM_MASK
operator|)
operator|>>
name|MPI_OB_SHIFT
argument_list|)
expr_stmt|;
name|SA_ASSERT
argument_list|(
operator|(
name|AGSA_MAX_INBOUND_Q
operator|>
name|inq
operator|)
argument_list|,
literal|"The IBQ Number is out of range."
argument_list|)
expr_stmt|;
comment|/* Find the outgoing port for the device */
name|pDevice
operator|=
operator|(
name|agsaDeviceDesc_t
operator|*
operator|)
operator|(
name|agDevHandle
operator|->
name|sdkData
operator|)
expr_stmt|;
name|SA_ASSERT
argument_list|(
operator|(
name|agNULL
operator|!=
name|pDevice
operator|)
argument_list|,
literal|"(saSATAStart) pDevice is NULL"
argument_list|)
expr_stmt|;
name|pPort
operator|=
name|pDevice
operator|->
name|pPort
expr_stmt|;
name|SA_ASSERT
argument_list|(
operator|(
name|agNULL
operator|!=
name|pPort
operator|)
argument_list|,
literal|"(saSATAStart) pPort is NULL"
argument_list|)
expr_stmt|;
comment|/* SATA DIF is obsolete */
if|if
condition|(
name|agSATAReq
operator|->
name|option
operator|&
name|AGSA_SATA_ENABLE_DIF
condition|)
block|{
return|return
name|AGSA_RC_FAILURE
return|;
block|}
comment|/* find deviceID for IOMB */
name|deviceIndex
operator|=
name|pDevice
operator|->
name|DeviceMapIndex
expr_stmt|;
comment|/*  Get request from free IORequests */
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|pRequest
operator|=
operator|(
name|agsaIORequestDesc_t
operator|*
operator|)
name|saLlistIOGetHead
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|agNULL
operator|!=
name|pRequest
condition|)
block|{
comment|/* If free IOMB avaliable */
comment|/* Remove the request from free list */
name|saLlistIORemove
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
comment|/* Add the request to the pendingSTARequests list of the device */
name|pRequest
operator|->
name|valid
operator|=
name|agTRUE
expr_stmt|;
name|saLlistIOAdd
argument_list|(
operator|&
operator|(
name|pDevice
operator|->
name|pendingIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|agSATAReq
operator|->
name|option
operator|&
name|AGSA_SATA_ENABLE_ENCRYPTION
operator|)
operator|||
operator|(
name|agSATAReq
operator|->
name|option
operator|&
name|AGSA_SATA_ENABLE_DIF
operator|)
condition|)
block|{
name|opCode
operator|=
name|OPC_INB_SATA_DIF_ENC_OPSTART
expr_stmt|;
name|size
operator|=
name|IOMB_SIZE128
expr_stmt|;
block|}
else|else
block|{
name|opCode
operator|=
name|OPC_INB_SATA_HOST_OPSTART
expr_stmt|;
if|if
condition|(
name|agRequestType
operator|==
name|AGSA_SATA_PROTOCOL_NON_PKT
operator|||
name|agRequestType
operator|==
name|AGSA_SATA_PROTOCOL_H2D_PKT
operator|||
name|agRequestType
operator|==
name|AGSA_SATA_PROTOCOL_D2H_PKT
condition|)
name|size
operator|=
name|IOMB_SIZE128
expr_stmt|;
else|else
name|size
operator|=
name|IOMB_SIZE64
expr_stmt|;
block|}
comment|/* If LL IO request entry avaliable */
comment|/* set up pRequest */
name|pRequest
operator|->
name|pIORequestContext
operator|=
name|agIORequest
expr_stmt|;
name|pRequest
operator|->
name|pDevice
operator|=
name|pDevice
expr_stmt|;
name|pRequest
operator|->
name|pPort
operator|=
name|pPort
expr_stmt|;
name|pRequest
operator|->
name|requestType
operator|=
name|agRequestType
expr_stmt|;
name|pRequest
operator|->
name|startTick
operator|=
name|saRoot
operator|->
name|timeTick
expr_stmt|;
name|pRequest
operator|->
name|completionCB
operator|=
operator|(
name|ossaSSPCompletedCB_t
operator|)
name|agCB
expr_stmt|;
comment|/* Set request to the sdkData of agIORequest */
name|agIORequest
operator|->
name|sdkData
operator|=
name|pRequest
expr_stmt|;
comment|/* save tag and IOrequest pointer to IOMap */
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|Tag
operator|=
name|pRequest
operator|->
name|HTag
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|IORequest
operator|=
operator|(
name|void
operator|*
operator|)
name|pRequest
expr_stmt|;
ifdef|#
directive|ifdef
name|SA_LL_IBQ_PROTECT
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_IBQ0_LOCK
operator|+
name|inq
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SA_LL_IBQ_PROTECT */
comment|/* get a free inbound queue entry */
name|circularQ
operator|=
operator|&
name|saRoot
operator|->
name|inboundQueue
index|[
name|inq
index|]
expr_stmt|;
name|retVal
operator|=
name|mpiMsgFreeGet
argument_list|(
name|circularQ
argument_list|,
name|size
argument_list|,
operator|&
name|pMessage
argument_list|)
expr_stmt|;
if|if
condition|(
name|AGSA_RC_FAILURE
operator|==
name|retVal
condition|)
block|{
ifdef|#
directive|ifdef
name|SA_LL_IBQ_PROTECT
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_IBQ0_LOCK
operator|+
name|inq
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SA_LL_IBQ_PROTECT */
comment|/* if not sending return to free list rare */
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|saLlistIORemove
argument_list|(
operator|&
operator|(
name|pDevice
operator|->
name|pendingIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
name|pRequest
operator|->
name|valid
operator|=
name|agFALSE
expr_stmt|;
name|saLlistIOAdd
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|SA_DBG3
argument_list|(
operator|(
literal|"saSATAStart, error when get free IOMB\n"
operator|)
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'a'
argument_list|,
literal|"8a"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|AGSA_RC_FAILURE
expr_stmt|;
goto|goto
name|ext
goto|;
block|}
comment|/* return busy if inbound queue is full */
if|if
condition|(
name|AGSA_RC_BUSY
operator|==
name|retVal
condition|)
block|{
ifdef|#
directive|ifdef
name|SA_LL_IBQ_PROTECT
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_IBQ0_LOCK
operator|+
name|inq
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SA_LL_IBQ_PROTECT */
comment|/* if not sending return to free list rare */
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|saLlistIORemove
argument_list|(
operator|&
operator|(
name|pDevice
operator|->
name|pendingIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
name|pRequest
operator|->
name|valid
operator|=
name|agFALSE
expr_stmt|;
name|saLlistIOAdd
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saSATAStart, no more IOMB\n"
operator|)
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'b'
argument_list|,
literal|"8a"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|AGSA_RC_BUSY
expr_stmt|;
goto|goto
name|ext
goto|;
block|}
block|}
else|else
comment|/* If no LL IO request entry available */
block|{
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saSATAStart, No request from free list\n"
operator|)
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'c'
argument_list|,
literal|"8a"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|AGSA_RC_BUSY
expr_stmt|;
goto|goto
name|ext
goto|;
block|}
name|payload
operator|=
operator|(
name|bit32
operator|*
operator|)
name|pMessage
expr_stmt|;
name|SA_DBG4
argument_list|(
operator|(
literal|"saSATAStart: Payload offset 0x%X\n"
operator|,
call|(
name|unsigned
name|int
call|)
argument_list|(
name|payload
operator|-
operator|(
name|bit32
operator|*
operator|)
name|pMessage
argument_list|)
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|agRequestType
condition|)
block|{
case|case
name|AGSA_SATA_PROTOCOL_FPDMA_READ
case|:
case|case
name|AGSA_SATA_PROTOCOL_FPDMA_WRITE
case|:
case|case
name|AGSA_SATA_PROTOCOL_FPDMA_READ_M
case|:
case|case
name|AGSA_SATA_PROTOCOL_FPDMA_WRITE_M
case|:
name|pSgl
operator|=
operator|&
operator|(
name|agSATAReq
operator|->
name|agSgl
operator|)
expr_stmt|;
name|AtapDir
operator|=
name|agRequestType
operator|&
operator|(
name|AGSA_DIR_MASK
operator||
name|AGSA_SATA_ATAP_MASK
operator|)
expr_stmt|;
if|if
condition|(
name|agRequestType
operator|&
name|AGSA_MSG
condition|)
block|{
comment|/* set M bit */
name|AtapDir
operator||=
name|AGSA_MSG_BIT
expr_stmt|;
block|}
break|break;
case|case
name|AGSA_SATA_PROTOCOL_DMA_READ
case|:
case|case
name|AGSA_SATA_PROTOCOL_DMA_WRITE
case|:
case|case
name|AGSA_SATA_PROTOCOL_DMA_READ_M
case|:
case|case
name|AGSA_SATA_PROTOCOL_DMA_WRITE_M
case|:
case|case
name|AGSA_SATA_PROTOCOL_PIO_READ_M
case|:
case|case
name|AGSA_SATA_PROTOCOL_PIO_WRITE_M
case|:
case|case
name|AGSA_SATA_PROTOCOL_PIO_READ
case|:
case|case
name|AGSA_SATA_PROTOCOL_PIO_WRITE
case|:
case|case
name|AGSA_SATA_PROTOCOL_H2D_PKT
case|:
case|case
name|AGSA_SATA_PROTOCOL_D2H_PKT
case|:
name|agTag
operator|=
literal|0
expr_stmt|;
comment|/* agTag not valid for these requests */
name|pSgl
operator|=
operator|&
operator|(
name|agSATAReq
operator|->
name|agSgl
operator|)
expr_stmt|;
name|AtapDir
operator|=
name|agRequestType
operator|&
operator|(
name|AGSA_DIR_MASK
operator||
name|AGSA_SATA_ATAP_MASK
operator|)
expr_stmt|;
if|if
condition|(
name|agRequestType
operator|&
name|AGSA_MSG
condition|)
block|{
comment|/* set M bit */
name|AtapDir
operator||=
name|AGSA_MSG_BIT
expr_stmt|;
block|}
break|break;
case|case
name|AGSA_SATA_PROTOCOL_NON_DATA
case|:
case|case
name|AGSA_SATA_PROTOCOL_NON_DATA_M
case|:
case|case
name|AGSA_SATA_PROTOCOL_NON_PKT
case|:
name|agTag
operator|=
literal|0
expr_stmt|;
comment|/* agTag not valid for these requests */
name|AtapDir
operator|=
name|agRequestType
operator|&
operator|(
name|AGSA_DIR_MASK
operator||
name|AGSA_SATA_ATAP_MASK
operator|)
expr_stmt|;
if|if
condition|(
name|agRequestType
operator|&
name|AGSA_MSG
condition|)
block|{
comment|/* set M bit */
name|AtapDir
operator||=
name|AGSA_MSG_BIT
expr_stmt|;
block|}
break|break;
case|case
name|AGSA_SATA_PROTOCOL_SRST_ASSERT
case|:
name|agTag
operator|=
literal|0
expr_stmt|;
comment|/* agTag not valid for these requests */
name|AtapDir
operator|=
name|AGSA_SATA_ATAP_SRST_ASSERT
expr_stmt|;
break|break;
case|case
name|AGSA_SATA_PROTOCOL_SRST_DEASSERT
case|:
name|agTag
operator|=
literal|0
expr_stmt|;
comment|/* agTag not valid for these requests */
name|AtapDir
operator|=
name|AGSA_SATA_ATAP_SRST_DEASSERT
expr_stmt|;
break|break;
case|case
name|AGSA_SATA_PROTOCOL_DEV_RESET
case|:
case|case
name|AGSA_SATA_PROTOCOL_DEV_RESET_M
case|:
comment|/* TestBase */
name|agTag
operator|=
literal|0
expr_stmt|;
comment|/* agTag not valid for these requests */
name|AtapDir
operator|=
name|AGSA_SATA_ATAP_PKT_DEVRESET
expr_stmt|;
if|if
condition|(
name|agRequestType
operator|&
name|AGSA_MSG
condition|)
block|{
comment|/* set M bit */
name|AtapDir
operator||=
name|AGSA_MSG_BIT
expr_stmt|;
comment|/* TestBase */
block|}
break|break;
default|default:
name|SA_DBG1
argument_list|(
operator|(
literal|"saSATAStart: (Unknown agRequestType) 0x%X \n"
operator|,
name|agRequestType
operator|)
argument_list|)
expr_stmt|;
name|SA_ASSERT
argument_list|(
operator|(
literal|0
operator|)
argument_list|,
literal|"saSATAStart: (Unknown agRequestType)"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|AGSA_SATA_PROTOCOL_SRST_ASSERT
operator|==
name|agRequestType
operator|)
operator|||
operator|(
name|AGSA_SATA_PROTOCOL_SRST_DEASSERT
operator|==
name|agRequestType
operator|)
operator|||
operator|(
name|AGSA_SATA_PROTOCOL_DEV_RESET
operator|==
name|agRequestType
operator|)
condition|)
block|{
name|SA_DBG3
argument_list|(
operator|(
literal|"saSATAStart:AGSA_SATA_PROTOCOL_SRST_DEASSERT AGSA_SATA_PROTOCOL_SRST_ASSERT\n"
operator|)
argument_list|)
expr_stmt|;
name|si_memset
argument_list|(
operator|(
name|void
operator|*
operator|)
name|payload
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|agsaSATAStartCmd_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* build IOMB DW 1 */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSATAStartCmd_t
argument_list|,
name|tag
argument_list|)
argument_list|,
name|pRequest
operator|->
name|HTag
argument_list|)
expr_stmt|;
comment|/* DWORD 2 */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSATAStartCmd_t
argument_list|,
name|deviceId
argument_list|)
argument_list|,
name|deviceIndex
argument_list|)
expr_stmt|;
comment|/* DWORD 3 */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSATAStartCmd_t
argument_list|,
name|dataLen
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* DWORD 4 */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSATAStartCmd_t
argument_list|,
name|optNCQTagataProt
argument_list|)
argument_list|,
operator|(
operator|(
operator|(
name|agSATAReq
operator|->
name|option
operator|&
name|SATA_FIS_MASK
operator|)
operator|<<
name|SHIFT24
operator|)
operator||
operator|(
name|agTag
operator|<<
name|SHIFT16
operator|)
operator||
name|AtapDir
operator|)
argument_list|)
expr_stmt|;
name|si_memcpy
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|payload
operator|+
literal|4
operator|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|agSATAReq
operator|->
name|fis
operator|.
name|fisRegHostToDev
argument_list|,
sizeof|sizeof
argument_list|(
name|agsaFisRegHostToDevice_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* build IOMB DW 1 */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSATAStartCmd_t
argument_list|,
name|tag
argument_list|)
argument_list|,
name|pRequest
operator|->
name|HTag
argument_list|)
expr_stmt|;
comment|/* DWORD 2 */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSATAStartCmd_t
argument_list|,
name|deviceId
argument_list|)
argument_list|,
name|deviceIndex
argument_list|)
expr_stmt|;
comment|/* DWORD 3 */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSATAStartCmd_t
argument_list|,
name|dataLen
argument_list|)
argument_list|,
name|agSATAReq
operator|->
name|dataLength
argument_list|)
expr_stmt|;
comment|/* Since we are writing the payload in order, check for any special modes now. */
if|if
condition|(
name|agSATAReq
operator|->
name|option
operator|&
name|AGSA_SATA_ENABLE_ENCRYPTION
condition|)
block|{
name|SA_ASSERT
argument_list|(
operator|(
name|opCode
operator|==
name|OPC_INB_SATA_DIF_ENC_OPSTART
operator|)
argument_list|,
literal|"opcode"
argument_list|)
expr_stmt|;
name|SA_DBG4
argument_list|(
operator|(
literal|"saSATAStart: 1 Payload offset 0x%X\n"
operator|,
call|(
name|unsigned
name|int
call|)
argument_list|(
name|payload
operator|-
operator|(
name|bit32
operator|*
operator|)
name|pMessage
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|AtapDir
operator||=
name|AGSA_ENCRYPT_BIT
expr_stmt|;
block|}
if|if
condition|(
name|agSATAReq
operator|->
name|option
operator|&
name|AGSA_SATA_ENABLE_DIF
condition|)
block|{
name|SA_ASSERT
argument_list|(
operator|(
name|opCode
operator|==
name|OPC_INB_SATA_DIF_ENC_OPSTART
operator|)
argument_list|,
literal|"opcode"
argument_list|)
expr_stmt|;
name|AtapDir
operator||=
name|AGSA_DIF_BIT
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|CCBUILD_TEST_EPL
if|if
condition|(
name|agSATAReq
operator|->
name|encrypt
operator|.
name|enableEncryptionPerLA
condition|)
name|AtapDir
operator||=
operator|(
literal|1
operator|<<
name|SHIFT4
operator|)
expr_stmt|;
comment|// enable EPL
endif|#
directive|endif
comment|/* DWORD 4 */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSATAStartCmd_t
argument_list|,
name|optNCQTagataProt
argument_list|)
argument_list|,
operator|(
operator|(
operator|(
name|agSATAReq
operator|->
name|option
operator|&
name|SATA_FIS_MASK
operator|)
operator|<<
name|SHIFT24
operator|)
operator||
operator|(
name|agTag
operator|<<
name|SHIFT16
operator|)
operator||
name|AtapDir
operator|)
argument_list|)
expr_stmt|;
comment|/* DWORD 5 6 7 8 9 */
name|si_memcpy
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|payload
operator|+
literal|4
operator|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|agSATAReq
operator|->
name|fis
operator|.
name|fisRegHostToDev
argument_list|,
sizeof|sizeof
argument_list|(
name|agsaFisRegHostToDevice_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* DWORD 10 reserved */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSATAStartCmd_t
argument_list|,
name|reserved1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* DWORD 11 reserved */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSATAStartCmd_t
argument_list|,
name|reserved2
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SA_DBG4
argument_list|(
operator|(
literal|"saSATAStart: 2 Payload offset 0x%X\n"
operator|,
call|(
name|unsigned
name|int
call|)
argument_list|(
name|payload
operator|-
operator|(
name|bit32
operator|*
operator|)
name|pMessage
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|agSATAReq
operator|->
name|option
operator|&
name|AGSA_SATA_ENABLE_ENCRYPTION
condition|)
block|{
comment|/* Write 10 dwords of zeroes as payload, skipping all DIF fields */
name|SA_DBG4
argument_list|(
operator|(
literal|"saSATAStart: 2a Payload offset 0x%X\n"
operator|,
call|(
name|unsigned
name|int
call|)
argument_list|(
name|payload
operator|-
operator|(
name|bit32
operator|*
operator|)
name|pMessage
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|opCode
operator|==
name|OPC_INB_SATA_DIF_ENC_OPSTART
condition|)
block|{
comment|/* DW 11 */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSATAEncryptStartCmd_t
argument_list|,
name|Res_EPL_DESCL
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* DW 12 */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSATAEncryptStartCmd_t
argument_list|,
name|resSKIPBYTES
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* DW 13 */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSATAEncryptStartCmd_t
argument_list|,
name|Res_DPL_DESCL_NDPLR
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* DW 14 */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSATAEncryptStartCmd_t
argument_list|,
name|Res_EDPL_DESCH
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* DW 15 */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSATAEncryptStartCmd_t
argument_list|,
name|DIF_flags
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* DW 16 */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSATAEncryptStartCmd_t
argument_list|,
name|udt
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* DW 17 */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSATAEncryptStartCmd_t
argument_list|,
name|udtReplacementLo
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* DW 18 */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSATAEncryptStartCmd_t
argument_list|,
name|udtReplacementHi
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* DW 19 */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSATAEncryptStartCmd_t
argument_list|,
name|DIF_seed
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|agSATAReq
operator|->
name|option
operator|&
name|AGSA_SATA_ENABLE_ENCRYPTION
condition|)
block|{
name|SA_ASSERT
argument_list|(
operator|(
name|opCode
operator|==
name|OPC_INB_SATA_DIF_ENC_OPSTART
operator|)
argument_list|,
literal|"opcode"
argument_list|)
expr_stmt|;
name|SA_DBG4
argument_list|(
operator|(
literal|"saSATAStart: 3 Payload offset 0x%X\n"
operator|,
call|(
name|unsigned
name|int
call|)
argument_list|(
name|payload
operator|-
operator|(
name|bit32
operator|*
operator|)
name|pMessage
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* Configure DWORD 20 */
name|encryptFlags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|agSATAReq
operator|->
name|encrypt
operator|.
name|keyTagCheck
operator|==
name|agTRUE
condition|)
block|{
name|encryptFlags
operator||=
name|AGSA_ENCRYPT_KEY_TAG_BIT
expr_stmt|;
block|}
if|if
condition|(
name|agSATAReq
operator|->
name|encrypt
operator|.
name|cipherMode
operator|==
name|agsaEncryptCipherModeXTS
condition|)
block|{
name|encryptFlags
operator||=
name|AGSA_ENCRYPT_XTS_Mode
operator|<<
name|SHIFT4
expr_stmt|;
block|}
name|encryptFlags
operator||=
name|agSATAReq
operator|->
name|encrypt
operator|.
name|dekInfo
operator|.
name|dekTable
operator|<<
name|SHIFT2
expr_stmt|;
name|encryptFlags
operator||=
operator|(
name|agSATAReq
operator|->
name|encrypt
operator|.
name|dekInfo
operator|.
name|dekIndex
operator|&
literal|0xFFFFFF
operator|)
operator|<<
name|SHIFT8
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSATAEncryptStartCmd_t
argument_list|,
name|encryptFlagsLo
argument_list|)
argument_list|,
name|encryptFlags
argument_list|)
expr_stmt|;
comment|/* Configure DWORD 21*/
comment|/* This information is available in the sectorSizeIndex */
name|encryptFlags
operator|=
name|agSATAReq
operator|->
name|encrypt
operator|.
name|sectorSizeIndex
expr_stmt|;
comment|/*          * Set Region0 sectors count          */
if|if
condition|(
name|agSATAReq
operator|->
name|encrypt
operator|.
name|enableEncryptionPerLA
condition|)
block|{
name|encryptFlags
operator||=
operator|(
name|agSATAReq
operator|->
name|encrypt
operator|.
name|EncryptionPerLRegion0SecCount
operator|<<
name|SHIFT16
operator|)
expr_stmt|;
block|}
name|encryptFlags
operator||=
operator|(
name|agSATAReq
operator|->
name|encrypt
operator|.
name|kekIndex
operator|)
operator|<<
name|SHIFT5
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSATAEncryptStartCmd_t
argument_list|,
name|encryptFlagsHi
argument_list|)
argument_list|,
name|encryptFlags
argument_list|)
expr_stmt|;
comment|/* Configure DWORD 22*/
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSATAEncryptStartCmd_t
argument_list|,
name|keyTagLo
argument_list|)
argument_list|,
name|agSATAReq
operator|->
name|encrypt
operator|.
name|keyTag_W0
argument_list|)
expr_stmt|;
comment|/* Configure DWORD 23 */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSATAEncryptStartCmd_t
argument_list|,
name|keyTagHi
argument_list|)
argument_list|,
name|agSATAReq
operator|->
name|encrypt
operator|.
name|keyTag_W1
argument_list|)
expr_stmt|;
comment|/* Configure DWORD 24 */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSATAEncryptStartCmd_t
argument_list|,
name|tweakVal_W0
argument_list|)
argument_list|,
name|agSATAReq
operator|->
name|encrypt
operator|.
name|tweakVal_W0
argument_list|)
expr_stmt|;
comment|/* Configure DWORD 25 */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSATAEncryptStartCmd_t
argument_list|,
name|tweakVal_W1
argument_list|)
argument_list|,
name|agSATAReq
operator|->
name|encrypt
operator|.
name|tweakVal_W1
argument_list|)
expr_stmt|;
comment|/* Configure DWORD 26 */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSATAEncryptStartCmd_t
argument_list|,
name|tweakVal_W2
argument_list|)
argument_list|,
name|agSATAReq
operator|->
name|encrypt
operator|.
name|tweakVal_W2
argument_list|)
expr_stmt|;
comment|/* Configure DWORD 27 */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSATAEncryptStartCmd_t
argument_list|,
name|tweakVal_W3
argument_list|)
argument_list|,
name|agSATAReq
operator|->
name|encrypt
operator|.
name|tweakVal_W3
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Write 8 dwords of zeros as payload, skipping all encryption fields */
if|if
condition|(
name|opCode
operator|==
name|OPC_INB_SATA_DIF_ENC_OPSTART
condition|)
block|{
comment|/* Configure DWORD 22*/
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSATAEncryptStartCmd_t
argument_list|,
name|keyTagLo
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Configure DWORD 23 */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSATAEncryptStartCmd_t
argument_list|,
name|keyTagHi
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Configure DWORD 24 */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSATAEncryptStartCmd_t
argument_list|,
name|tweakVal_W0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Configure DWORD 25 */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSATAEncryptStartCmd_t
argument_list|,
name|tweakVal_W1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Configure DWORD 26 */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSATAEncryptStartCmd_t
argument_list|,
name|tweakVal_W2
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Configure DWORD 27 */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSATAEncryptStartCmd_t
argument_list|,
name|tweakVal_W3
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|SA_DBG4
argument_list|(
operator|(
literal|"saSATAStart: 4 Payload offset 0x%X\n"
operator|,
call|(
name|unsigned
name|int
call|)
argument_list|(
name|payload
operator|-
operator|(
name|bit32
operator|*
operator|)
name|pMessage
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* DWORD 11 13 14*/
if|if
condition|(
name|agSATAReq
operator|->
name|encrypt
operator|.
name|enableEncryptionPerLA
condition|)
block|{
comment|/* DWORD 11 */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSATAEncryptStartCmd_t
argument_list|,
name|Res_EPL_DESCL
argument_list|)
argument_list|,
name|agSATAReq
operator|->
name|encrypt
operator|.
name|EncryptionPerLAAddrLo
argument_list|)
expr_stmt|;
comment|/* DWORD 13 */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSATAEncryptStartCmd_t
argument_list|,
name|Res_DPL_DESCL_NDPLR
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* DWORD 14 */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSATAEncryptStartCmd_t
argument_list|,
name|Res_EDPL_DESCH
argument_list|)
argument_list|,
name|agSATAReq
operator|->
name|encrypt
operator|.
name|EncryptionPerLAAddrHi
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* DWORD 11 */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSATAEncryptStartCmd_t
argument_list|,
name|Res_EPL_DESCL
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* DW 13 */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSATAEncryptStartCmd_t
argument_list|,
name|Res_DPL_DESCL_NDPLR
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* DWORD 14 */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSATAEncryptStartCmd_t
argument_list|,
name|Res_EDPL_DESCH
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Configure DWORD 28 for encryption*/
if|if
condition|(
name|pSgl
condition|)
block|{
comment|/* Configure DWORD 28 */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSATAEncryptStartCmd_t
argument_list|,
name|AddrLow0
argument_list|)
argument_list|,
name|pSgl
operator|->
name|sgLower
argument_list|)
expr_stmt|;
comment|/* Configure DWORD 29 */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSATAEncryptStartCmd_t
argument_list|,
name|AddrHi0
argument_list|)
argument_list|,
name|pSgl
operator|->
name|sgUpper
argument_list|)
expr_stmt|;
comment|/* Configure DWORD 30 */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSATAEncryptStartCmd_t
argument_list|,
name|Len0
argument_list|)
argument_list|,
name|pSgl
operator|->
name|len
argument_list|)
expr_stmt|;
comment|/* Configure DWORD 31 */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSATAEncryptStartCmd_t
argument_list|,
name|E0
argument_list|)
argument_list|,
name|pSgl
operator|->
name|extReserved
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Configure DWORD 28 */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSATAEncryptStartCmd_t
argument_list|,
name|AddrLow0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Configure DWORD 29 */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSATAEncryptStartCmd_t
argument_list|,
name|AddrHi0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Configure DWORD 30 */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSATAEncryptStartCmd_t
argument_list|,
name|Len0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Configure DWORD 31 */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSATAEncryptStartCmd_t
argument_list|,
name|E0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|SA_ASSERT
argument_list|(
operator|(
name|opCode
operator|==
name|OPC_INB_SATA_HOST_OPSTART
operator|)
argument_list|,
literal|"opcode"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pSgl
condition|)
block|{
comment|/* Configure DWORD 12 */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSATAStartCmd_t
argument_list|,
name|AddrLow0
argument_list|)
argument_list|,
name|pSgl
operator|->
name|sgLower
argument_list|)
expr_stmt|;
comment|/* Configure DWORD 13 */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSATAStartCmd_t
argument_list|,
name|AddrHi0
argument_list|)
argument_list|,
name|pSgl
operator|->
name|sgUpper
argument_list|)
expr_stmt|;
comment|/* Configure DWORD 14 */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSATAStartCmd_t
argument_list|,
name|Len0
argument_list|)
argument_list|,
name|pSgl
operator|->
name|len
argument_list|)
expr_stmt|;
comment|/* Configure DWORD 15 */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSATAStartCmd_t
argument_list|,
name|E0
argument_list|)
argument_list|,
name|pSgl
operator|->
name|extReserved
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Configure DWORD 12 */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSATAStartCmd_t
argument_list|,
name|AddrLow0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Configure DWORD 13 */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSATAStartCmd_t
argument_list|,
name|AddrHi0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Configure DWORD 14 */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSATAStartCmd_t
argument_list|,
name|Len0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Configure DWORD 15 */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSATAStartCmd_t
argument_list|,
name|E0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* support ATAPI packet command */
if|if
condition|(
operator|(
name|agRequestType
operator|==
name|AGSA_SATA_PROTOCOL_NON_PKT
operator|||
name|agRequestType
operator|==
name|AGSA_SATA_PROTOCOL_H2D_PKT
operator|||
name|agRequestType
operator|==
name|AGSA_SATA_PROTOCOL_D2H_PKT
operator|)
condition|)
block|{
comment|/*DWORD 16 - 19 as SCSI CDB for support ATAPI Packet command*/
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSATAStartCmd_t
argument_list|,
name|ATAPICDB
argument_list|)
argument_list|,
call|(
name|bit32
call|)
argument_list|(
name|agSATAReq
operator|->
name|scsiCDB
index|[
literal|0
index|]
operator||
operator|(
name|agSATAReq
operator|->
name|scsiCDB
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|agSATAReq
operator|->
name|scsiCDB
index|[
literal|2
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|agSATAReq
operator|->
name|scsiCDB
index|[
literal|3
index|]
operator|<<
literal|24
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSATAStartCmd_t
argument_list|,
name|ATAPICDB
argument_list|)
operator|+
literal|4
argument_list|,
call|(
name|bit32
call|)
argument_list|(
name|agSATAReq
operator|->
name|scsiCDB
index|[
literal|4
index|]
operator||
operator|(
name|agSATAReq
operator|->
name|scsiCDB
index|[
literal|5
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|agSATAReq
operator|->
name|scsiCDB
index|[
literal|6
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|agSATAReq
operator|->
name|scsiCDB
index|[
literal|7
index|]
operator|<<
literal|24
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSATAStartCmd_t
argument_list|,
name|ATAPICDB
argument_list|)
operator|+
literal|8
argument_list|,
call|(
name|bit32
call|)
argument_list|(
name|agSATAReq
operator|->
name|scsiCDB
index|[
literal|8
index|]
operator||
operator|(
name|agSATAReq
operator|->
name|scsiCDB
index|[
literal|9
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|agSATAReq
operator|->
name|scsiCDB
index|[
literal|10
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|agSATAReq
operator|->
name|scsiCDB
index|[
literal|11
index|]
operator|<<
literal|24
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSATAStartCmd_t
argument_list|,
name|ATAPICDB
argument_list|)
operator|+
literal|12
argument_list|,
call|(
name|bit32
call|)
argument_list|(
name|agSATAReq
operator|->
name|scsiCDB
index|[
literal|12
index|]
operator||
operator|(
name|agSATAReq
operator|->
name|scsiCDB
index|[
literal|13
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|agSATAReq
operator|->
name|scsiCDB
index|[
literal|14
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|agSATAReq
operator|->
name|scsiCDB
index|[
literal|15
index|]
operator|<<
literal|24
operator|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* send IOMB to SPC */
name|ret
operator|=
name|mpiMsgProduce
argument_list|(
name|circularQ
argument_list|,
operator|(
name|void
operator|*
operator|)
name|pMessage
argument_list|,
name|MPI_CATEGORY_SAS_SATA
argument_list|,
name|opCode
argument_list|,
name|outq
argument_list|,
operator|(
name|bit8
operator|)
name|circularQ
operator|->
name|priority
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SA_LL_IBQ_PROTECT
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_IBQ0_LOCK
operator|+
name|inq
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SA_LL_IBQ_PROTECT */
ifdef|#
directive|ifdef
name|SALL_API_TEST
if|if
condition|(
name|AGSA_RC_FAILURE
operator|!=
name|ret
condition|)
block|{
name|saRoot
operator|->
name|LLCounters
operator|.
name|IOCounter
operator|.
name|numSataStarted
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'d'
argument_list|,
literal|"8a"
argument_list|)
expr_stmt|;
name|ext
label|:
name|OSSA_INP_LEAVE
argument_list|(
name|agRoot
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*! \brief Abort SATA command  *  *  Abort SATA command  *  *  \param agRoot      handles for this instance of SAS/SATA hardware  *  \param queueNum    inbound/outbound queue number  *  \param agIORequest the IO Request descriptor  *  \param agIOtoBeAborted  *  *  \return If command is aborted successfully  *          - \e AGSA_RC_SUCCESS command is aborted successfully  *          - \e AGSA_RC_FAILURE command is not aborted successfully  */
end_comment

begin_comment
comment|/*******************************************************************************/
end_comment

begin_function
name|GLOBAL
name|bit32
name|saSATAAbort
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|agsaIORequest_t
modifier|*
name|agIORequest
parameter_list|,
name|bit32
name|queueNum
parameter_list|,
name|agsaDevHandle_t
modifier|*
name|agDevHandle
parameter_list|,
name|bit32
name|flag
parameter_list|,
name|void
modifier|*
name|abortParam
parameter_list|,
name|ossaGenericAbortCB_t
name|agCB
parameter_list|)
block|{
name|bit32
name|ret
init|=
name|AGSA_RC_SUCCESS
decl_stmt|,
name|retVal
decl_stmt|;
name|agsaLLRoot_t
modifier|*
name|saRoot
init|=
operator|(
name|agsaLLRoot_t
operator|*
operator|)
operator|(
name|agRoot
operator|->
name|sdkData
operator|)
decl_stmt|;
name|agsaIORequestDesc_t
modifier|*
name|pRequest
decl_stmt|;
name|agsaIORequestDesc_t
modifier|*
name|pRequestABT
init|=
name|agNULL
decl_stmt|;
name|agsaDeviceDesc_t
modifier|*
name|pDevice
init|=
name|agNULL
decl_stmt|;
name|agsaDeviceDesc_t
modifier|*
name|pDeviceABT
init|=
name|NULL
decl_stmt|;
name|agsaPort_t
modifier|*
name|pPort
init|=
name|agNULL
decl_stmt|;
name|mpiICQueue_t
modifier|*
name|circularQ
decl_stmt|;
name|void
modifier|*
name|pMessage
decl_stmt|;
name|agsaSATAAbortCmd_t
modifier|*
name|payload
decl_stmt|;
name|agsaIORequest_t
modifier|*
name|agIOToBeAborted
decl_stmt|;
name|bit8
name|inq
decl_stmt|,
name|outq
decl_stmt|;
name|bit32
name|flag_copy
init|=
name|flag
decl_stmt|;
name|smTraceFuncEnter
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|"8b"
argument_list|)
expr_stmt|;
comment|/* sanity check */
name|SA_ASSERT
argument_list|(
operator|(
name|agNULL
operator|!=
name|agRoot
operator|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|SA_ASSERT
argument_list|(
operator|(
name|agNULL
operator|!=
name|agIORequest
operator|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|SA_DBG3
argument_list|(
operator|(
literal|"saSATAAbort: Aborting request %p ITtoBeAborted %p\n"
operator|,
name|agIORequest
operator|,
name|abortParam
operator|)
argument_list|)
expr_stmt|;
comment|/* Assign inbound and outbound Ring Buffer */
name|inq
operator|=
call|(
name|bit8
call|)
argument_list|(
name|queueNum
operator|&
name|MPI_IB_NUM_MASK
argument_list|)
expr_stmt|;
name|outq
operator|=
call|(
name|bit8
call|)
argument_list|(
operator|(
name|queueNum
operator|&
name|MPI_OB_NUM_MASK
operator|)
operator|>>
name|MPI_OB_SHIFT
argument_list|)
expr_stmt|;
name|SA_ASSERT
argument_list|(
operator|(
name|AGSA_MAX_INBOUND_Q
operator|>
name|inq
operator|)
argument_list|,
literal|"The IBQ Number is out of range."
argument_list|)
expr_stmt|;
if|if
condition|(
name|ABORT_SINGLE
operator|==
operator|(
name|flag
operator|&
name|ABORT_MASK
operator|)
condition|)
block|{
name|agIOToBeAborted
operator|=
operator|(
name|agsaIORequest_t
operator|*
operator|)
name|abortParam
expr_stmt|;
comment|/* Get LL IORequest entry for saSATAAbort() */
name|pRequest
operator|=
operator|(
name|agsaIORequestDesc_t
operator|*
operator|)
operator|(
name|agIOToBeAborted
operator|->
name|sdkData
operator|)
expr_stmt|;
if|if
condition|(
name|agNULL
operator|==
name|pRequest
condition|)
block|{
comment|/* no pRequest found - can not Abort */
name|SA_DBG1
argument_list|(
operator|(
literal|"saSATAAbort: pRequest AGSA_RC_FAILURE\n"
operator|)
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'a'
argument_list|,
literal|"8b"
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_FAILURE
return|;
block|}
comment|/* Find the device the request sent to */
name|pDevice
operator|=
name|pRequest
operator|->
name|pDevice
expr_stmt|;
comment|/* Get LL IORequest entry */
name|pRequestABT
operator|=
operator|(
name|agsaIORequestDesc_t
operator|*
operator|)
operator|(
name|agIOToBeAborted
operator|->
name|sdkData
operator|)
expr_stmt|;
comment|/* Find the device the request sent to */
if|if
condition|(
name|agNULL
operator|==
name|pRequestABT
condition|)
block|{
comment|/* no pRequestABT - can not find pDeviceABT */
name|SA_DBG1
argument_list|(
operator|(
literal|"saSATAAbort: pRequestABT AGSA_RC_FAILURE\n"
operator|)
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'b'
argument_list|,
literal|"8b"
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_FAILURE
return|;
block|}
name|pDeviceABT
operator|=
name|pRequestABT
operator|->
name|pDevice
expr_stmt|;
if|if
condition|(
name|agNULL
operator|==
name|pDeviceABT
condition|)
block|{
comment|/* no deviceID - can not build IOMB */
name|SA_DBG1
argument_list|(
operator|(
literal|"saSATAAbort: pDeviceABT AGSA_RC_FAILURE\n"
operator|)
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'c'
argument_list|,
literal|"8b"
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_FAILURE
return|;
block|}
if|if
condition|(
name|agNULL
operator|!=
name|pDevice
condition|)
block|{
comment|/* Find the port the request was sent to */
name|pPort
operator|=
name|pDevice
operator|->
name|pPort
expr_stmt|;
block|}
comment|/* Get request from free IORequests */
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|pRequest
operator|=
operator|(
name|agsaIORequestDesc_t
operator|*
operator|)
name|saLlistIOGetHead
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ABORT_ALL
operator|==
operator|(
name|flag
operator|&
name|ABORT_MASK
operator|)
condition|)
block|{
comment|/* abort all */
comment|/* Find the outgoing port for the device */
name|pDevice
operator|=
operator|(
name|agsaDeviceDesc_t
operator|*
operator|)
operator|(
name|agDevHandle
operator|->
name|sdkData
operator|)
expr_stmt|;
name|pPort
operator|=
name|pDevice
operator|->
name|pPort
expr_stmt|;
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|pRequest
operator|=
operator|(
name|agsaIORequestDesc_t
operator|*
operator|)
name|saLlistIOGetHead
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* only support 00 and 01 for flag */
name|SA_DBG1
argument_list|(
operator|(
literal|"saSATAAbort: flag AGSA_RC_FAILURE\n"
operator|)
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'d'
argument_list|,
literal|"8b"
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_FAILURE
return|;
block|}
block|}
comment|/* If no LL IO request entry avalable */
if|if
condition|(
name|agNULL
operator|==
name|pRequest
condition|)
block|{
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saSATAAbort, No request from free list\n"
operator|)
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'e'
argument_list|,
literal|"8b"
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_BUSY
return|;
block|}
comment|/* If free IOMB avaliable */
comment|/* Remove the request from free list */
name|saLlistIORemove
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
name|SA_ASSERT
argument_list|(
operator|(
operator|!
name|pRequest
operator|->
name|valid
operator|)
argument_list|,
literal|"The pRequest is in use"
argument_list|)
expr_stmt|;
comment|/* Add the request to the pendingIORequests list of the device */
name|pRequest
operator|->
name|valid
operator|=
name|agTRUE
expr_stmt|;
name|saLlistIOAdd
argument_list|(
operator|&
operator|(
name|pDevice
operator|->
name|pendingIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
comment|/* set up pRequest */
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|pRequest
operator|->
name|pIORequestContext
operator|=
name|agIORequest
expr_stmt|;
name|pRequest
operator|->
name|requestType
operator|=
name|AGSA_SATA_REQTYPE
expr_stmt|;
name|pRequest
operator|->
name|pDevice
operator|=
name|pDevice
expr_stmt|;
name|pRequest
operator|->
name|pPort
operator|=
name|pPort
expr_stmt|;
name|pRequest
operator|->
name|completionCB
operator|=
operator|(
name|void
operator|*
operator|)
name|agCB
expr_stmt|;
comment|/* pRequest->abortCompletionCB = agCB; */
name|pRequest
operator|->
name|startTick
operator|=
name|saRoot
operator|->
name|timeTick
expr_stmt|;
comment|/* Set request to the sdkData of agIORequest */
name|agIORequest
operator|->
name|sdkData
operator|=
name|pRequest
expr_stmt|;
comment|/* save tag and IOrequest pointer to IOMap */
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|Tag
operator|=
name|pRequest
operator|->
name|HTag
expr_stmt|;
name|saRoot
operator|->
name|IOMap
index|[
name|pRequest
operator|->
name|HTag
index|]
operator|.
name|IORequest
operator|=
operator|(
name|void
operator|*
operator|)
name|pRequest
expr_stmt|;
ifdef|#
directive|ifdef
name|SA_LL_IBQ_PROTECT
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_IBQ0_LOCK
operator|+
name|inq
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SA_LL_IBQ_PROTECT */
comment|/* If LL IO request entry avaliable */
comment|/* Get a free inbound queue entry */
name|circularQ
operator|=
operator|&
name|saRoot
operator|->
name|inboundQueue
index|[
name|inq
index|]
expr_stmt|;
name|retVal
operator|=
name|mpiMsgFreeGet
argument_list|(
name|circularQ
argument_list|,
name|IOMB_SIZE64
argument_list|,
operator|&
name|pMessage
argument_list|)
expr_stmt|;
comment|/* if message size is too large return failure */
if|if
condition|(
name|AGSA_RC_FAILURE
operator|==
name|retVal
condition|)
block|{
ifdef|#
directive|ifdef
name|SA_LL_IBQ_PROTECT
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_IBQ0_LOCK
operator|+
name|inq
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SA_LL_IBQ_PROTECT */
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|saLlistIORemove
argument_list|(
operator|&
operator|(
name|pDevice
operator|->
name|pendingIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
name|pRequest
operator|->
name|valid
operator|=
name|agFALSE
expr_stmt|;
name|saLlistIOAdd
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saSATAAbort, error when get free IOMB\n"
operator|)
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'f'
argument_list|,
literal|"8b"
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_FAILURE
return|;
block|}
comment|/* return busy if inbound queue is full */
if|if
condition|(
name|AGSA_RC_BUSY
operator|==
name|retVal
condition|)
block|{
ifdef|#
directive|ifdef
name|SA_LL_IBQ_PROTECT
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_IBQ0_LOCK
operator|+
name|inq
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SA_LL_IBQ_PROTECT */
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|saLlistIORemove
argument_list|(
operator|&
operator|(
name|pDevice
operator|->
name|pendingIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
name|pRequest
operator|->
name|valid
operator|=
name|agFALSE
expr_stmt|;
name|saLlistIOAdd
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saSATASAbort, no more IOMB\n"
operator|)
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'g'
argument_list|,
literal|"8b"
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_BUSY
return|;
block|}
comment|/* setup payload */
name|payload
operator|=
operator|(
name|agsaSATAAbortCmd_t
operator|*
operator|)
name|pMessage
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSATAAbortCmd_t
argument_list|,
name|tag
argument_list|)
argument_list|,
name|pRequest
operator|->
name|HTag
argument_list|)
expr_stmt|;
if|if
condition|(
name|ABORT_SINGLE
operator|==
operator|(
name|flag
operator|&
name|ABORT_MASK
operator|)
condition|)
block|{
comment|/* If no device  */
if|if
condition|(
name|agNULL
operator|==
name|pDeviceABT
condition|)
block|{
ifdef|#
directive|ifdef
name|SA_LL_IBQ_PROTECT
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_IBQ0_LOCK
operator|+
name|inq
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SA_LL_IBQ_PROTECT */
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|saLlistIORemove
argument_list|(
operator|&
operator|(
name|pDevice
operator|->
name|pendingIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
name|pRequest
operator|->
name|valid
operator|=
name|agFALSE
expr_stmt|;
name|saLlistIOAdd
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saSATAAbort,no device\n"
operator|)
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'h'
argument_list|,
literal|"8b"
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_FAILURE
return|;
block|}
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSATAAbortCmd_t
argument_list|,
name|deviceId
argument_list|)
argument_list|,
name|pDeviceABT
operator|->
name|DeviceMapIndex
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSATAAbortCmd_t
argument_list|,
name|HTagAbort
argument_list|)
argument_list|,
name|pRequestABT
operator|->
name|HTag
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* abort all */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSATAAbortCmd_t
argument_list|,
name|deviceId
argument_list|)
argument_list|,
name|pDevice
operator|->
name|DeviceMapIndex
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSATAAbortCmd_t
argument_list|,
name|HTagAbort
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag
operator|&
name|ABORT_TSDK_QUARANTINE
condition|)
block|{
if|if
condition|(
name|smIS_SPCV
argument_list|(
name|agRoot
argument_list|)
condition|)
block|{
name|flag_copy
operator|&=
name|ABORT_SCOPE
expr_stmt|;
name|flag_copy
operator||=
name|ABORT_QUARANTINE_SPCV
expr_stmt|;
block|}
block|}
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
name|payload
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|agsaSATAAbortCmd_t
argument_list|,
name|abortAll
argument_list|)
argument_list|,
name|flag_copy
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"saSATAAbort, HTag 0x%x HTagABT 0x%x deviceId 0x%x\n"
operator|,
name|payload
operator|->
name|tag
operator|,
name|payload
operator|->
name|HTagAbort
operator|,
name|payload
operator|->
name|deviceId
operator|)
argument_list|)
expr_stmt|;
comment|/* post the IOMB to SPC */
name|ret
operator|=
name|mpiMsgProduce
argument_list|(
name|circularQ
argument_list|,
operator|(
name|void
operator|*
operator|)
name|pMessage
argument_list|,
name|MPI_CATEGORY_SAS_SATA
argument_list|,
name|OPC_INB_SATA_ABORT
argument_list|,
name|outq
argument_list|,
operator|(
name|bit8
operator|)
name|circularQ
operator|->
name|priority
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SA_LL_IBQ_PROTECT
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_IBQ0_LOCK
operator|+
name|inq
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SA_LL_IBQ_PROTECT */
ifdef|#
directive|ifdef
name|SALL_API_TEST
if|if
condition|(
name|AGSA_RC_FAILURE
operator|!=
name|ret
condition|)
block|{
name|saRoot
operator|->
name|LLCounters
operator|.
name|IOCounter
operator|.
name|numSataAborted
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
name|siCountActiveIORequestsOnDevice
argument_list|(
name|agRoot
argument_list|,
name|payload
operator|->
name|deviceId
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'i'
argument_list|,
literal|"8b"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*! \brief Routine to handle for received SATA with data payload event  *  *  The handle for received SATA with data payload event  *  *  \param agRoot       handles for this instance of SAS/SATA hardware  *  \param pRequest     the IO request descriptor  *  \param agFirstDword pointer to the first Dword  *  \param pResp        pointer to the rest of SATA response  *  \param lengthResp   total length of SATA Response frame  *  *  \return -void-  */
end_comment

begin_comment
comment|/*******************************************************************************/
end_comment

begin_function
name|GLOBAL
name|void
name|siEventSATAResponseWtDataRcvd
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|,
name|agsaIORequestDesc_t
modifier|*
name|pRequest
parameter_list|,
name|bit32
modifier|*
name|agFirstDword
parameter_list|,
name|bit32
modifier|*
name|pResp
parameter_list|,
name|bit32
name|lengthResp
parameter_list|)
block|{
name|agsaLLRoot_t
modifier|*
name|saRoot
init|=
operator|(
name|agsaLLRoot_t
operator|*
operator|)
operator|(
name|agRoot
operator|->
name|sdkData
operator|)
decl_stmt|;
name|agsaDeviceDesc_t
modifier|*
name|pDevice
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SALLSDK_DEBUG
argument_list|)
name|agsaFrameHandle_t
name|frameHandle
decl_stmt|;
comment|/* get frame handle */
name|frameHandle
operator|=
call|(
name|agsaFrameHandle_t
call|)
argument_list|(
name|pResp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SALLSDK_DEBUG */
name|smTraceFuncEnter
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|"8c"
argument_list|)
expr_stmt|;
comment|/* If the request is still valid */
if|if
condition|(
name|agTRUE
operator|==
name|pRequest
operator|->
name|valid
condition|)
block|{
comment|/* get device */
name|pDevice
operator|=
name|pRequest
operator|->
name|pDevice
expr_stmt|;
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
comment|/* Delete the request from the pendingIORequests */
name|saLlistIORemove
argument_list|(
operator|&
operator|(
name|pDevice
operator|->
name|pendingIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
operator|(
operator|*
call|(
name|ossaSATACompletedCB_t
call|)
argument_list|(
name|pRequest
operator|->
name|completionCB
argument_list|)
operator|)
operator|(
name|agRoot
operator|,
name|pRequest
operator|->
name|pIORequestContext
operator|,
name|OSSA_IO_SUCCESS
operator|,
name|agFirstDword
operator|,
name|lengthResp
operator|,
operator|(
name|void
operator|*
operator|)
name|pResp
operator|)
expr_stmt|;
name|ossaSingleThreadedEnter
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
name|pRequest
operator|->
name|valid
operator|=
name|agFALSE
expr_stmt|;
comment|/* return the request to free pool */
name|saLlistIOAdd
argument_list|(
operator|&
operator|(
name|saRoot
operator|->
name|freeIORequests
operator|)
argument_list|,
operator|&
operator|(
name|pRequest
operator|->
name|linkNode
operator|)
argument_list|)
expr_stmt|;
name|ossaSingleThreadedLeave
argument_list|(
name|agRoot
argument_list|,
name|LL_IOREQ_LOCKEQ_LOCK
argument_list|)
expr_stmt|;
block|}
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'a'
argument_list|,
literal|"8c"
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*! \brief copy a SATA signature to another  *  *  copy a SATA signature to another  *  *  \param pDstSignature pointer to the destination signature  *  \param pSrcSignature pointer to the source signature  *  *  \return If they match  *          - \e agTRUE match  *          - \e agFALSE  doesn't match  */
end_comment

begin_comment
comment|/*******************************************************************************/
end_comment

begin_function
name|GLOBAL
name|void
name|siSATASignatureCpy
parameter_list|(
name|bit8
modifier|*
name|pDstSignature
parameter_list|,
name|bit8
modifier|*
name|pSrcSignature
parameter_list|)
block|{
name|bit32
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
block|{
name|pDstSignature
index|[
name|i
index|]
operator|=
name|pSrcSignature
index|[
name|i
index|]
expr_stmt|;
block|}
return|return;
block|}
end_function

end_unit

