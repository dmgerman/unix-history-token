begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************************* ** *Copyright (c) 2014 PMC-Sierra, Inc.  All rights reserved.  * *Redistribution and use in source and binary forms, with or without modification, are permitted provided  *that the following conditions are met:  *1. Redistributions of source code must retain the above copyright notice, this list of conditions and the *following disclaimer.  *2. Redistributions in binary form must reproduce the above copyright notice,  *this list of conditions and the following disclaimer in the documentation and/or other materials provided *with the distribution.  * *THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR IMPLIED  *WARRANTIES,INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS *FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE *FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  *NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR  *BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  *LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  *SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE  ********************************************************************************/
end_comment

begin_comment
comment|/*******************************************************************************/
end_comment

begin_comment
comment|/*! \file mpi.c  *  \brief The file is a MPI Libraries to implement the MPI functions  *  * The file implements the MPI Library functions.  *  */
end_comment

begin_comment
comment|/*******************************************************************************/
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<dev/pms/config.h>
end_include

begin_include
include|#
directive|include
file|<dev/pms/RefTisa/sallsdk/spc/saglobal.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SA_ENABLE_TRACE_FUNCTIONS
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|siTraceFileID
end_ifdef

begin_undef
undef|#
directive|undef
name|siTraceFileID
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|siTraceFileID
value|'A'
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|LOOPBACK_MPI
end_ifdef

begin_decl_stmt
specifier|extern
name|int
name|loopback
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*******************************************************************************/
end_comment

begin_comment
comment|/*******************************************************************************/
end_comment

begin_comment
comment|/*******************************************************************************/
end_comment

begin_comment
comment|/* FUNCTIONS                                                                   */
end_comment

begin_comment
comment|/*******************************************************************************/
end_comment

begin_comment
comment|/*******************************************************************************/
end_comment

begin_comment
comment|/** \fn void mpiRequirementsGet(mpiConfig_t* config, mpiMemReq_t* memoryRequirement)  *  \brief Retrieves the MPI layer resource requirements  *  \param config            MPI configuration for the Host MPI Message Unit  *  \param memoryRequirement Returned data structure as defined by mpiMemReq_t  *                           that holds the different chunks of memory that are required  *  * The mpiRequirementsGet() function is used to determine the resource requirements  * for the SPC device interface  *  * Return: None  */
end_comment

begin_comment
comment|/*******************************************************************************/
end_comment

begin_function
name|void
name|mpiRequirementsGet
parameter_list|(
name|mpiConfig_t
modifier|*
name|config
parameter_list|,
name|mpiMemReq_t
modifier|*
name|memoryRequirement
parameter_list|)
block|{
name|bit32
name|qIdx
decl_stmt|,
name|numq
decl_stmt|;
name|mpiMemReq_t
modifier|*
name|memoryMap
decl_stmt|;
name|SA_DBG2
argument_list|(
operator|(
literal|"Entering function:mpiRequirementsGet\n"
operator|)
argument_list|)
expr_stmt|;
name|SA_ASSERT
argument_list|(
operator|(
name|NULL
operator|!=
name|config
operator|)
argument_list|,
literal|"config argument cannot be null"
argument_list|)
expr_stmt|;
name|memoryMap
operator|=
name|memoryRequirement
expr_stmt|;
name|memoryMap
operator|->
name|count
operator|=
literal|0
expr_stmt|;
comment|/* MPI Memory region 0 for MSGU(AAP1) Event Log for fw */
name|memoryMap
operator|->
name|region
index|[
name|memoryMap
operator|->
name|count
index|]
operator|.
name|numElements
operator|=
literal|1
expr_stmt|;
name|memoryMap
operator|->
name|region
index|[
name|memoryMap
operator|->
name|count
index|]
operator|.
name|elementSize
operator|=
sizeof|sizeof
argument_list|(
name|bit8
argument_list|)
operator|*
name|config
operator|->
name|mainConfig
operator|.
name|eventLogSize
expr_stmt|;
name|memoryMap
operator|->
name|region
index|[
name|memoryMap
operator|->
name|count
index|]
operator|.
name|totalLength
operator|=
sizeof|sizeof
argument_list|(
name|bit8
argument_list|)
operator|*
name|config
operator|->
name|mainConfig
operator|.
name|eventLogSize
expr_stmt|;
name|memoryMap
operator|->
name|region
index|[
name|memoryMap
operator|->
name|count
index|]
operator|.
name|alignment
operator|=
literal|32
expr_stmt|;
name|memoryMap
operator|->
name|region
index|[
name|memoryMap
operator|->
name|count
index|]
operator|.
name|type
operator|=
name|AGSA_DMA_MEM
expr_stmt|;
name|SA_DBG2
argument_list|(
operator|(
literal|"mpiRequirementsGet:eventLogSize region[%d] 0x%X\n"
operator|,
name|memoryMap
operator|->
name|count
operator|,
name|memoryMap
operator|->
name|region
index|[
name|memoryMap
operator|->
name|count
index|]
operator|.
name|totalLength
operator|)
argument_list|)
expr_stmt|;
name|memoryMap
operator|->
name|count
operator|++
expr_stmt|;
name|SA_DBG2
argument_list|(
operator|(
literal|"mpiRequirementsGet:eventLogSize region[%d] 0x%X\n"
operator|,
name|memoryMap
operator|->
name|count
operator|,
name|memoryMap
operator|->
name|region
index|[
name|memoryMap
operator|->
name|count
index|]
operator|.
name|totalLength
operator|)
argument_list|)
expr_stmt|;
comment|/* MPI Memory region 1 for IOP Event Log for fw */
name|memoryMap
operator|->
name|region
index|[
name|memoryMap
operator|->
name|count
index|]
operator|.
name|numElements
operator|=
literal|1
expr_stmt|;
name|memoryMap
operator|->
name|region
index|[
name|memoryMap
operator|->
name|count
index|]
operator|.
name|elementSize
operator|=
sizeof|sizeof
argument_list|(
name|bit8
argument_list|)
operator|*
name|config
operator|->
name|mainConfig
operator|.
name|IOPeventLogSize
expr_stmt|;
name|memoryMap
operator|->
name|region
index|[
name|memoryMap
operator|->
name|count
index|]
operator|.
name|totalLength
operator|=
sizeof|sizeof
argument_list|(
name|bit8
argument_list|)
operator|*
name|config
operator|->
name|mainConfig
operator|.
name|IOPeventLogSize
expr_stmt|;
name|memoryMap
operator|->
name|region
index|[
name|memoryMap
operator|->
name|count
index|]
operator|.
name|alignment
operator|=
literal|32
expr_stmt|;
name|memoryMap
operator|->
name|region
index|[
name|memoryMap
operator|->
name|count
index|]
operator|.
name|type
operator|=
name|AGSA_DMA_MEM
expr_stmt|;
name|SA_DBG2
argument_list|(
operator|(
literal|"mpiRequirementsGet:IOPeventLogSize region[%d] 0x%X\n"
operator|,
name|memoryMap
operator|->
name|count
operator|,
name|memoryMap
operator|->
name|region
index|[
name|memoryMap
operator|->
name|count
index|]
operator|.
name|totalLength
operator|)
argument_list|)
expr_stmt|;
name|memoryMap
operator|->
name|count
operator|++
expr_stmt|;
comment|/* MPI Memory region 2 for consumer Index of inbound queues */
name|memoryMap
operator|->
name|region
index|[
name|memoryMap
operator|->
name|count
index|]
operator|.
name|numElements
operator|=
literal|1
expr_stmt|;
name|memoryMap
operator|->
name|region
index|[
name|memoryMap
operator|->
name|count
index|]
operator|.
name|elementSize
operator|=
sizeof|sizeof
argument_list|(
name|bit32
argument_list|)
operator|*
name|config
operator|->
name|numInboundQueues
expr_stmt|;
name|memoryMap
operator|->
name|region
index|[
name|memoryMap
operator|->
name|count
index|]
operator|.
name|totalLength
operator|=
sizeof|sizeof
argument_list|(
name|bit32
argument_list|)
operator|*
name|config
operator|->
name|numInboundQueues
expr_stmt|;
name|memoryMap
operator|->
name|region
index|[
name|memoryMap
operator|->
name|count
index|]
operator|.
name|alignment
operator|=
literal|4
expr_stmt|;
name|memoryMap
operator|->
name|region
index|[
name|memoryMap
operator|->
name|count
index|]
operator|.
name|type
operator|=
name|AGSA_DMA_MEM
expr_stmt|;
name|SA_DBG2
argument_list|(
operator|(
literal|"mpiRequirementsGet:numInboundQueues region[%d] 0x%X\n"
operator|,
name|memoryMap
operator|->
name|count
operator|,
name|memoryMap
operator|->
name|region
index|[
name|memoryMap
operator|->
name|count
index|]
operator|.
name|totalLength
operator|)
argument_list|)
expr_stmt|;
name|memoryMap
operator|->
name|count
operator|++
expr_stmt|;
comment|/* MPI Memory region 3 for producer Index of outbound queues */
name|memoryMap
operator|->
name|region
index|[
name|memoryMap
operator|->
name|count
index|]
operator|.
name|numElements
operator|=
literal|1
expr_stmt|;
name|memoryMap
operator|->
name|region
index|[
name|memoryMap
operator|->
name|count
index|]
operator|.
name|elementSize
operator|=
sizeof|sizeof
argument_list|(
name|bit32
argument_list|)
operator|*
name|config
operator|->
name|numOutboundQueues
expr_stmt|;
name|memoryMap
operator|->
name|region
index|[
name|memoryMap
operator|->
name|count
index|]
operator|.
name|totalLength
operator|=
sizeof|sizeof
argument_list|(
name|bit32
argument_list|)
operator|*
name|config
operator|->
name|numOutboundQueues
expr_stmt|;
name|memoryMap
operator|->
name|region
index|[
name|memoryMap
operator|->
name|count
index|]
operator|.
name|alignment
operator|=
literal|4
expr_stmt|;
name|memoryMap
operator|->
name|region
index|[
name|memoryMap
operator|->
name|count
index|]
operator|.
name|type
operator|=
name|AGSA_DMA_MEM
expr_stmt|;
name|SA_DBG2
argument_list|(
operator|(
literal|"mpiRequirementsGet:numOutboundQueues region[%d] 0x%X\n"
operator|,
name|memoryMap
operator|->
name|count
operator|,
name|memoryMap
operator|->
name|region
index|[
name|memoryMap
operator|->
name|count
index|]
operator|.
name|totalLength
operator|)
argument_list|)
expr_stmt|;
name|memoryMap
operator|->
name|count
operator|++
expr_stmt|;
comment|/* MPI Memory regions 4, ... for the inbound queues - depends on configuration */
name|numq
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|qIdx
operator|=
literal|0
init|;
name|qIdx
operator|<
name|config
operator|->
name|numInboundQueues
condition|;
name|qIdx
operator|++
control|)
block|{
if|if
condition|(
literal|0
operator|!=
name|config
operator|->
name|inboundQueues
index|[
name|qIdx
index|]
operator|.
name|numElements
condition|)
block|{
name|bit32
name|memSize
init|=
name|config
operator|->
name|inboundQueues
index|[
name|qIdx
index|]
operator|.
name|numElements
operator|*
name|config
operator|->
name|inboundQueues
index|[
name|qIdx
index|]
operator|.
name|elementSize
decl_stmt|;
name|bit32
name|remainder
init|=
name|memSize
operator|&
literal|127
decl_stmt|;
comment|/* Calculate the size of this queue padded to 128 bytes */
if|if
condition|(
name|remainder
operator|>
literal|0
condition|)
block|{
name|memSize
operator|+=
operator|(
literal|128
operator|-
name|remainder
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|numq
operator|==
literal|0
condition|)
block|{
name|memoryMap
operator|->
name|region
index|[
name|memoryMap
operator|->
name|count
index|]
operator|.
name|numElements
operator|=
literal|1
expr_stmt|;
name|memoryMap
operator|->
name|region
index|[
name|memoryMap
operator|->
name|count
index|]
operator|.
name|elementSize
operator|=
name|memSize
expr_stmt|;
name|memoryMap
operator|->
name|region
index|[
name|memoryMap
operator|->
name|count
index|]
operator|.
name|totalLength
operator|=
name|memSize
expr_stmt|;
name|memoryMap
operator|->
name|region
index|[
name|memoryMap
operator|->
name|count
index|]
operator|.
name|alignment
operator|=
literal|128
expr_stmt|;
name|memoryMap
operator|->
name|region
index|[
name|memoryMap
operator|->
name|count
index|]
operator|.
name|type
operator|=
name|AGSA_CACHED_DMA_MEM
expr_stmt|;
block|}
else|else
block|{
name|memoryMap
operator|->
name|region
index|[
name|memoryMap
operator|->
name|count
index|]
operator|.
name|elementSize
operator|+=
name|memSize
expr_stmt|;
name|memoryMap
operator|->
name|region
index|[
name|memoryMap
operator|->
name|count
index|]
operator|.
name|totalLength
operator|+=
name|memSize
expr_stmt|;
block|}
name|numq
operator|++
expr_stmt|;
if|if
condition|(
operator|(
literal|0
operator|==
operator|(
operator|(
name|qIdx
operator|+
literal|1
operator|)
operator|%
name|MAX_QUEUE_EACH_MEM
operator|)
operator|)
operator|||
operator|(
name|qIdx
operator|==
call|(
name|bit32
call|)
argument_list|(
name|config
operator|->
name|numInboundQueues
operator|-
literal|1
argument_list|)
operator|)
condition|)
block|{
name|SA_DBG2
argument_list|(
operator|(
literal|"mpiRequirementsGet: (inboundQueues) memoryMap->region[%d].elementSize = %d\n"
operator|,
name|memoryMap
operator|->
name|count
operator|,
name|memoryMap
operator|->
name|region
index|[
name|memoryMap
operator|->
name|count
index|]
operator|.
name|elementSize
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG2
argument_list|(
operator|(
literal|"mpiRequirementsGet: (inboundQueues) memoryMap->region[%d].numElements = %d\n"
operator|,
name|memoryMap
operator|->
name|count
operator|,
name|memoryMap
operator|->
name|region
index|[
name|memoryMap
operator|->
name|count
index|]
operator|.
name|numElements
operator|)
argument_list|)
expr_stmt|;
name|memoryMap
operator|->
name|count
operator|++
expr_stmt|;
name|numq
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
comment|/* MPI Memory regions for the outbound queues - depends on configuration */
name|numq
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|qIdx
operator|=
literal|0
init|;
name|qIdx
operator|<
name|config
operator|->
name|numOutboundQueues
condition|;
name|qIdx
operator|++
control|)
block|{
if|if
condition|(
literal|0
operator|!=
name|config
operator|->
name|outboundQueues
index|[
name|qIdx
index|]
operator|.
name|numElements
condition|)
block|{
name|bit32
name|memSize
init|=
name|config
operator|->
name|outboundQueues
index|[
name|qIdx
index|]
operator|.
name|numElements
operator|*
name|config
operator|->
name|outboundQueues
index|[
name|qIdx
index|]
operator|.
name|elementSize
decl_stmt|;
name|bit32
name|remainder
init|=
name|memSize
operator|&
literal|127
decl_stmt|;
comment|/* Calculate the size of this queue padded to 128 bytes */
if|if
condition|(
name|remainder
operator|>
literal|0
condition|)
block|{
name|memSize
operator|+=
operator|(
literal|128
operator|-
name|remainder
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|numq
operator|==
literal|0
condition|)
block|{
name|memoryMap
operator|->
name|region
index|[
name|memoryMap
operator|->
name|count
index|]
operator|.
name|numElements
operator|=
literal|1
expr_stmt|;
name|memoryMap
operator|->
name|region
index|[
name|memoryMap
operator|->
name|count
index|]
operator|.
name|elementSize
operator|=
name|memSize
expr_stmt|;
name|memoryMap
operator|->
name|region
index|[
name|memoryMap
operator|->
name|count
index|]
operator|.
name|totalLength
operator|=
name|memSize
expr_stmt|;
name|memoryMap
operator|->
name|region
index|[
name|memoryMap
operator|->
name|count
index|]
operator|.
name|alignment
operator|=
literal|128
expr_stmt|;
name|memoryMap
operator|->
name|region
index|[
name|memoryMap
operator|->
name|count
index|]
operator|.
name|type
operator|=
name|AGSA_CACHED_DMA_MEM
expr_stmt|;
block|}
else|else
block|{
name|memoryMap
operator|->
name|region
index|[
name|memoryMap
operator|->
name|count
index|]
operator|.
name|elementSize
operator|+=
name|memSize
expr_stmt|;
name|memoryMap
operator|->
name|region
index|[
name|memoryMap
operator|->
name|count
index|]
operator|.
name|totalLength
operator|+=
name|memSize
expr_stmt|;
block|}
name|numq
operator|++
expr_stmt|;
if|if
condition|(
operator|(
literal|0
operator|==
operator|(
operator|(
name|qIdx
operator|+
literal|1
operator|)
operator|%
name|MAX_QUEUE_EACH_MEM
operator|)
operator|)
operator|||
operator|(
name|qIdx
operator|==
call|(
name|bit32
call|)
argument_list|(
name|config
operator|->
name|numOutboundQueues
operator|-
literal|1
argument_list|)
operator|)
condition|)
block|{
name|SA_DBG2
argument_list|(
operator|(
literal|"mpiRequirementsGet: (outboundQueues) memoryMap->region[%d].elementSize = %d\n"
operator|,
name|memoryMap
operator|->
name|count
operator|,
name|memoryMap
operator|->
name|region
index|[
name|memoryMap
operator|->
name|count
index|]
operator|.
name|elementSize
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG2
argument_list|(
operator|(
literal|"mpiRequirementsGet: (outboundQueues) memoryMap->region[%d].numElements = %d\n"
operator|,
name|memoryMap
operator|->
name|count
operator|,
name|memoryMap
operator|->
name|region
index|[
name|memoryMap
operator|->
name|count
index|]
operator|.
name|numElements
operator|)
argument_list|)
expr_stmt|;
name|memoryMap
operator|->
name|count
operator|++
expr_stmt|;
name|numq
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*******************************************************************************/
end_comment

begin_comment
comment|/** \fn mpiMsgFreeGet(mpiICQueue_t *circularQ, bit16 messageSize, void** messagePtr)  *  \brief Retrieves a free message buffer from an inbound queue  *  \param circularQ    Pointer to an inbound circular queue  *  \param messageSize  Requested message size in bytes - only support 64 bytes/element  *  \param messagePtr   Pointer to the free message buffer payload (not including message header) or NULL if no free message buffers are available  *  * This function is used to retrieve a free message buffer for the given inbound queue of at least  * messageSize bytes.  * The caller can use the returned buffer to construct the message and then call mpiMsgProduce()  * to deliver the message to the device message unit or mpiMsgInvalidate() if the message buffer  * is not going to be used  *  * Return:  *         AGSA_RC_SUCCESS if messagePtr contains a valid message buffer pointer  *         AGSA_RC_FAILURE if messageSize larger than the elementSize of queue  *         AGSA_RC_BUSY    if there are not free message buffers (Queue full)  */
end_comment

begin_comment
comment|/*******************************************************************************/
end_comment

begin_function
name|GLOBAL
name|FORCEINLINE
name|bit32
name|mpiMsgFreeGet
parameter_list|(
name|mpiICQueue_t
modifier|*
name|circularQ
parameter_list|,
name|bit16
name|messageSize
parameter_list|,
name|void
modifier|*
modifier|*
name|messagePtr
parameter_list|)
block|{
name|bit32
name|offset
decl_stmt|;
name|agsaRoot_t
modifier|*
name|agRoot
init|=
name|circularQ
operator|->
name|agRoot
decl_stmt|;
name|mpiMsgHeader_t
modifier|*
name|msgHeader
decl_stmt|;
name|bit8
name|bcCount
init|=
literal|1
decl_stmt|;
comment|/* only support single buffer */
name|SA_DBG4
argument_list|(
operator|(
literal|"Entering function:mpiMsgFreeGet\n"
operator|)
argument_list|)
expr_stmt|;
name|SA_ASSERT
argument_list|(
name|NULL
operator|!=
name|circularQ
argument_list|,
literal|"circularQ cannot be null"
argument_list|)
expr_stmt|;
name|SA_ASSERT
argument_list|(
name|NULL
operator|!=
name|messagePtr
argument_list|,
literal|"messagePtr argument cannot be null"
argument_list|)
expr_stmt|;
name|SA_ASSERT
argument_list|(
literal|0
operator|!=
name|circularQ
operator|->
name|numElements
argument_list|,
literal|"The number of elements in this queue is 0"
argument_list|)
expr_stmt|;
comment|/* Checks is the requested message size can be allocated in this queue */
if|if
condition|(
name|messageSize
operator|>
name|circularQ
operator|->
name|elementSize
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"mpiMsgFreeGet: Message Size (%d) is larger than Q element size (%d)\n"
operator|,
name|messageSize
operator|,
name|circularQ
operator|->
name|elementSize
operator|)
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_FAILURE
return|;
block|}
comment|/* Stores the new consumer index */
name|OSSA_READ_LE_32
argument_list|(
name|circularQ
operator|->
name|agRoot
argument_list|,
operator|&
name|circularQ
operator|->
name|consumerIdx
argument_list|,
name|circularQ
operator|->
name|ciPointer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* if inbound queue is full, return busy */
comment|/* This queue full logic may only works for bc == 1 ( == ) */
comment|/* ( pi + bc ) % size> ci not fully works for bc> 1 */
comment|/* To do - support bc> 1 case and wrap around case */
if|if
condition|(
operator|(
operator|(
name|circularQ
operator|->
name|producerIdx
operator|+
name|bcCount
operator|)
operator|%
name|circularQ
operator|->
name|numElements
operator|)
operator|==
name|circularQ
operator|->
name|consumerIdx
condition|)
block|{
operator|*
name|messagePtr
operator|=
name|NULL
expr_stmt|;
name|smTrace
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|"Za"
argument_list|,
operator|(
operator|(
operator|(
name|circularQ
operator|->
name|producerIdx
operator|&
literal|0xFFF
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
name|circularQ
operator|->
name|consumerIdx
operator|&
literal|0xFFF
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* TP:Za IQ PI CI */
name|ossaHwRegRead
argument_list|(
name|agRoot
argument_list|,
name|MSGU_HOST_SCRATCH_PAD_0
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"mpiMsgFreeGet: %d + %d == %d AGSA_RC_BUSY\n"
operator|,
name|circularQ
operator|->
name|producerIdx
operator|,
name|bcCount
operator|,
name|circularQ
operator|->
name|consumerIdx
operator|)
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_BUSY
return|;
block|}
name|smTrace
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|"Zb"
argument_list|,
operator|(
operator|(
operator|(
name|circularQ
operator|->
name|producerIdx
operator|&
literal|0xFFF
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
name|circularQ
operator|->
name|consumerIdx
operator|&
literal|0xFFF
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* TP:Zb IQ PI CI */
comment|/* get memory IOMB buffer address */
name|offset
operator|=
name|circularQ
operator|->
name|producerIdx
operator|*
name|circularQ
operator|->
name|elementSize
expr_stmt|;
comment|/* increment to next bcCount element */
name|circularQ
operator|->
name|producerIdx
operator|=
operator|(
name|circularQ
operator|->
name|producerIdx
operator|+
name|bcCount
operator|)
operator|%
name|circularQ
operator|->
name|numElements
expr_stmt|;
comment|/* Adds that distance to the base of the region virtual address plus the message header size*/
name|msgHeader
operator|=
operator|(
name|mpiMsgHeader_t
operator|*
operator|)
operator|(
operator|(
operator|(
name|bit8
operator|*
operator|)
operator|(
name|circularQ
operator|->
name|memoryRegion
operator|.
name|virtPtr
operator|)
operator|)
operator|+
name|offset
operator|)
expr_stmt|;
name|SA_DBG3
argument_list|(
operator|(
literal|"mpiMsgFreeGet: msgHeader = %p Offset = 0x%x\n"
operator|,
operator|(
name|void
operator|*
operator|)
name|msgHeader
operator|,
name|offset
operator|)
argument_list|)
expr_stmt|;
comment|/* Sets the message buffer in "allocated" state */
comment|/* bc always is 1 for inbound queue */
comment|/* temporarily store it in the native endian format, when the rest of the */
comment|/* header is filled, this would be converted to Little Endian */
name|msgHeader
operator|->
name|Header
operator|=
operator|(
literal|1
operator|<<
literal|24
operator|)
expr_stmt|;
operator|*
name|messagePtr
operator|=
operator|(
operator|(
name|bit8
operator|*
operator|)
name|msgHeader
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|mpiMsgHeader_t
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_SUCCESS
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|LOOPBACK_MPI
end_ifdef

begin_function
name|GLOBAL
name|bit32
name|mpiMsgFreeGetOQ
parameter_list|(
name|mpiOCQueue_t
modifier|*
name|circularQ
parameter_list|,
name|bit16
name|messageSize
parameter_list|,
name|void
modifier|*
modifier|*
name|messagePtr
parameter_list|)
block|{
name|bit32
name|offset
decl_stmt|;
name|mpiMsgHeader_t
modifier|*
name|msgHeader
decl_stmt|;
name|bit8
name|bcCount
init|=
literal|1
decl_stmt|;
comment|/* only support single buffer */
name|SA_DBG4
argument_list|(
operator|(
literal|"Entering function:mpiMsgFreeGet\n"
operator|)
argument_list|)
expr_stmt|;
name|SA_ASSERT
argument_list|(
name|NULL
operator|!=
name|circularQ
argument_list|,
literal|"circularQ cannot be null"
argument_list|)
expr_stmt|;
name|SA_ASSERT
argument_list|(
name|NULL
operator|!=
name|messagePtr
argument_list|,
literal|"messagePtr argument cannot be null"
argument_list|)
expr_stmt|;
name|SA_ASSERT
argument_list|(
literal|0
operator|!=
name|circularQ
operator|->
name|numElements
argument_list|,
literal|"The number of elements in this queue is 0"
argument_list|)
expr_stmt|;
comment|/* Checks is the requested message size can be allocated in this queue */
if|if
condition|(
name|messageSize
operator|>
name|circularQ
operator|->
name|elementSize
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"mpiMsgFreeGet: Message Size is not fit in\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_FAILURE
return|;
block|}
comment|/* Stores the new consumer index */
comment|//OSSA_READ_LE_32(circularQ->agRoot,&circularQ->consumerIdx, circularQ->ciPointer, 0);
comment|/* if inbound queue is full, return busy */
comment|/* This queue full logic may only works for bc == 1 ( == ) */
comment|/* ( pi + bc ) % size> ci not fully works for bc> 1 */
comment|/* To do - support bc> 1 case and wrap around case */
if|if
condition|(
operator|(
operator|(
name|circularQ
operator|->
name|producerIdx
operator|+
name|bcCount
operator|)
operator|%
name|circularQ
operator|->
name|numElements
operator|)
operator|==
name|circularQ
operator|->
name|consumerIdx
condition|)
block|{
operator|*
name|messagePtr
operator|=
name|NULL
expr_stmt|;
return|return
name|AGSA_RC_BUSY
return|;
block|}
comment|/* get memory IOMB buffer address */
name|offset
operator|=
name|circularQ
operator|->
name|producerIdx
operator|*
name|circularQ
operator|->
name|elementSize
expr_stmt|;
comment|/* increment to next bcCount element */
name|circularQ
operator|->
name|producerIdx
operator|=
operator|(
name|circularQ
operator|->
name|producerIdx
operator|+
name|bcCount
operator|)
operator|%
name|circularQ
operator|->
name|numElements
expr_stmt|;
comment|/* Adds that distance to the base of the region virtual address plus the message header size*/
name|msgHeader
operator|=
operator|(
name|mpiMsgHeader_t
operator|*
operator|)
operator|(
operator|(
operator|(
name|bit8
operator|*
operator|)
operator|(
name|circularQ
operator|->
name|memoryRegion
operator|.
name|virtPtr
operator|)
operator|)
operator|+
name|offset
operator|)
expr_stmt|;
name|SA_DBG3
argument_list|(
operator|(
literal|"mpiMsgFreeGet: msgHeader = %p Offset = 0x%x\n"
operator|,
operator|(
name|void
operator|*
operator|)
name|msgHeader
operator|,
name|offset
operator|)
argument_list|)
expr_stmt|;
comment|/* Sets the message buffer in "allocated" state */
comment|/* bc always is 1 for inbound queue */
comment|/* temporarily store it in the native endian format, when the rest of the */
comment|/* header is filled, this would be converted to Little Endian */
name|msgHeader
operator|->
name|Header
operator|=
operator|(
literal|1
operator|<<
literal|24
operator|)
expr_stmt|;
operator|*
name|messagePtr
operator|=
operator|(
operator|(
name|bit8
operator|*
operator|)
name|msgHeader
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|mpiMsgHeader_t
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_SUCCESS
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*******************************************************************************/
end_comment

begin_comment
comment|/** \fn mpiMsgProduce(mpiICQueue_t *circularQ, void *messagePtr, mpiMsgCategory_t category, bit16 opCode, bit8 responseQueue)  *  \brief Add a header of IOMB then send to a inbound queue and update the Producer index  *  \param circularQ     Pointer to an inbound queue  *  \param messagePtr    Pointer to the message buffer payload (not including message header))  *  \param category      Message category (ETHERNET, FC, SAS-SATA, SCSI)  *  \param opCode        Message operation code  *  \param responseQueue If the message requires response, this paramater indicates the outbound queue for the response  *  * This function is used to sumit a message buffer, previously obtained from  mpiMsgFreeGet()  * function call, to the given Inbound queue  *  * Return:  *         AGSA_RC_SUCCESS if the message has been posted succesfully  */
end_comment

begin_comment
comment|/*******************************************************************************/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|FAST_IO_TEST
end_ifdef

begin_function
name|GLOBAL
name|bit32
name|mpiMsgPrepare
parameter_list|(
name|mpiICQueue_t
modifier|*
name|circularQ
parameter_list|,
name|void
modifier|*
name|messagePtr
parameter_list|,
name|mpiMsgCategory_t
name|category
parameter_list|,
name|bit16
name|opCode
parameter_list|,
name|bit8
name|responseQueue
parameter_list|,
name|bit8
name|hiPriority
parameter_list|)
block|{
name|mpiMsgHeader_t
modifier|*
name|msgHeader
decl_stmt|;
name|bit32
name|bc
decl_stmt|;
name|bit32
name|Header
init|=
literal|0
decl_stmt|;
name|bit32
name|hpriority
init|=
literal|0
decl_stmt|;
name|SA_DBG4
argument_list|(
operator|(
literal|"Entering function:mpiMsgProduce\n"
operator|)
argument_list|)
expr_stmt|;
name|SA_ASSERT
argument_list|(
name|NULL
operator|!=
name|circularQ
argument_list|,
literal|"circularQ argument cannot be null"
argument_list|)
expr_stmt|;
name|SA_ASSERT
argument_list|(
name|NULL
operator|!=
name|messagePtr
argument_list|,
literal|"messagePtr argument cannot be null"
argument_list|)
expr_stmt|;
name|SA_ASSERT
argument_list|(
literal|0
operator|!=
name|circularQ
operator|->
name|numElements
argument_list|,
literal|"The number of elements in this queue"
literal|" is 0"
argument_list|)
expr_stmt|;
name|SA_ASSERT
argument_list|(
name|MPI_MAX_OUTBOUND_QUEUES
operator|>
name|responseQueue
argument_list|,
literal|"oQueue ID is wrong"
argument_list|)
expr_stmt|;
comment|/* Obtains the address of the entire message buffer, including the header */
name|msgHeader
operator|=
operator|(
name|mpiMsgHeader_t
operator|*
operator|)
operator|(
operator|(
operator|(
name|bit8
operator|*
operator|)
name|messagePtr
operator|)
operator|-
sizeof|sizeof
argument_list|(
name|mpiMsgHeader_t
argument_list|)
operator|)
expr_stmt|;
comment|/* Read the BC from header, its stored in native endian format when message      was allocated */
comment|/* intially */
name|bc
operator|=
operator|(
operator|(
operator|(
name|msgHeader
operator|->
name|Header
operator|)
operator|>>
name|SHIFT24
operator|)
operator|&
name|BC_MASK
operator|)
expr_stmt|;
name|SA_DBG6
argument_list|(
operator|(
literal|"mpiMsgProduce: msgHeader bc %d\n"
operator|,
name|bc
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|circularQ
operator|->
name|priority
condition|)
name|hpriority
operator|=
literal|1
expr_stmt|;
comment|/* Checks the message is in "allocated" state */
name|SA_ASSERT
argument_list|(
literal|0
operator|!=
name|bc
argument_list|,
literal|"The message buffer is not in \"allocated\" state "
literal|"(bc == 0)"
argument_list|)
expr_stmt|;
name|Header
operator|=
operator|(
operator|(
name|V_BIT
operator|<<
name|SHIFT31
operator|)
operator||
operator|(
name|hpriority
operator|<<
name|SHIFT30
operator|)
operator||
operator|(
operator|(
name|bc
operator|&
name|BC_MASK
operator|)
operator|<<
name|SHIFT24
operator|)
operator||
operator|(
operator|(
name|responseQueue
operator|&
name|OBID_MASK
operator|)
operator|<<
name|SHIFT16
operator|)
operator||
operator|(
operator|(
name|category
operator|&
name|CAT_MASK
operator|)
operator|<<
name|SHIFT12
operator|)
operator||
operator|(
name|opCode
operator|&
name|OPCODE_MASK
operator|)
operator|)
expr_stmt|;
comment|/* pre flush the IOMB cache line */
name|ossaCachePreFlush
argument_list|(
name|circularQ
operator|->
name|agRoot
argument_list|,
operator|(
name|void
operator|*
operator|)
name|circularQ
operator|->
name|memoryRegion
operator|.
name|appHandle
argument_list|,
operator|(
name|void
operator|*
operator|)
name|msgHeader
argument_list|,
name|circularQ
operator|->
name|elementSize
operator|*
name|bc
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|circularQ
operator|->
name|agRoot
argument_list|,
name|msgHeader
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|mpiMsgHeader_t
argument_list|,
name|Header
argument_list|)
argument_list|,
name|Header
argument_list|)
expr_stmt|;
comment|/* flush the IOMB cache line */
name|ossaCacheFlush
argument_list|(
name|circularQ
operator|->
name|agRoot
argument_list|,
operator|(
name|void
operator|*
operator|)
name|circularQ
operator|->
name|memoryRegion
operator|.
name|appHandle
argument_list|,
operator|(
name|void
operator|*
operator|)
name|msgHeader
argument_list|,
name|circularQ
operator|->
name|elementSize
operator|*
name|bc
argument_list|)
expr_stmt|;
name|MPI_DEBUG_TRACE
argument_list|(
name|circularQ
operator|->
name|qNumber
argument_list|,
operator|(
operator|(
name|circularQ
operator|->
name|producerIdx
operator|<<
literal|16
operator|)
operator||
name|circularQ
operator|->
name|consumerIdx
operator|)
argument_list|,
name|MPI_DEBUG_TRACE_IBQ
argument_list|,
operator|(
name|void
operator|*
operator|)
name|msgHeader
argument_list|,
name|circularQ
operator|->
name|elementSize
argument_list|)
expr_stmt|;
name|ossaLogIomb
argument_list|(
name|circularQ
operator|->
name|agRoot
argument_list|,
name|circularQ
operator|->
name|qNumber
argument_list|,
name|TRUE
argument_list|,
operator|(
name|void
operator|*
operator|)
name|msgHeader
argument_list|,
name|circularQ
operator|->
name|elementSize
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* mpiMsgPrepare */
end_comment

begin_function
name|GLOBAL
name|bit32
name|mpiMsgProduce
parameter_list|(
name|mpiICQueue_t
modifier|*
name|circularQ
parameter_list|,
name|void
modifier|*
name|messagePtr
parameter_list|,
name|mpiMsgCategory_t
name|category
parameter_list|,
name|bit16
name|opCode
parameter_list|,
name|bit8
name|responseQueue
parameter_list|,
name|bit8
name|hiPriority
parameter_list|)
block|{
name|bit32
name|ret
decl_stmt|;
name|ret
operator|=
name|mpiMsgPrepare
argument_list|(
name|circularQ
argument_list|,
name|messagePtr
argument_list|,
name|category
argument_list|,
name|opCode
argument_list|,
name|responseQueue
argument_list|,
name|hiPriority
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|AGSA_RC_SUCCESS
condition|)
block|{
comment|/* update PI of inbound queue */
name|ossaHwRegWriteExt
argument_list|(
name|circularQ
operator|->
name|agRoot
argument_list|,
name|circularQ
operator|->
name|PIPCIBar
argument_list|,
name|circularQ
operator|->
name|PIPCIOffset
argument_list|,
name|circularQ
operator|->
name|producerIdx
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
name|GLOBAL
name|void
name|mpiIBQMsgSend
parameter_list|(
name|mpiICQueue_t
modifier|*
name|circularQ
parameter_list|)
block|{
name|ossaHwRegWriteExt
argument_list|(
name|circularQ
operator|->
name|agRoot
argument_list|,
name|circularQ
operator|->
name|PIPCIBar
argument_list|,
name|circularQ
operator|->
name|PIPCIOffset
argument_list|,
name|circularQ
operator|->
name|producerIdx
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* FAST_IO_TEST */
end_comment

begin_function
name|GLOBAL
name|FORCEINLINE
name|bit32
name|mpiMsgProduce
parameter_list|(
name|mpiICQueue_t
modifier|*
name|circularQ
parameter_list|,
name|void
modifier|*
name|messagePtr
parameter_list|,
name|mpiMsgCategory_t
name|category
parameter_list|,
name|bit16
name|opCode
parameter_list|,
name|bit8
name|responseQueue
parameter_list|,
name|bit8
name|hiPriority
parameter_list|)
block|{
name|mpiMsgHeader_t
modifier|*
name|msgHeader
decl_stmt|;
name|bit32
name|bc
decl_stmt|;
name|bit32
name|Header
init|=
literal|0
decl_stmt|;
name|bit32
name|hpriority
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|SA_FW_TEST_BUNCH_STARTS
define|#
directive|define
name|Need_agRootDefined
value|1
endif|#
directive|endif
comment|/* SA_FW_TEST_BUNCH_STARTS */
ifdef|#
directive|ifdef
name|SA_ENABLE_TRACE_FUNCTIONS
name|bit32
name|i
decl_stmt|;
define|#
directive|define
name|Need_agRootDefined
value|1
endif|#
directive|endif
comment|/* SA_ENABLE_TRACE_FUNCTIONS */
ifdef|#
directive|ifdef
name|MPI_DEBUG_TRACE_ENABLE
define|#
directive|define
name|Need_agRootDefined
value|1
endif|#
directive|endif
comment|/* MPI_DEBUG_TRACE_ENABLE */
ifdef|#
directive|ifdef
name|Need_agRootDefined
name|agsaRoot_t
modifier|*
name|agRoot
init|=
name|circularQ
operator|->
name|agRoot
decl_stmt|;
ifdef|#
directive|ifdef
name|SA_FW_TEST_BUNCH_STARTS
name|agsaLLRoot_t
modifier|*
name|saRoot
init|=
name|agNULL
decl_stmt|;
name|saRoot
operator|=
name|agRoot
operator|->
name|sdkData
expr_stmt|;
endif|#
directive|endif
comment|/* SA_FW_TEST_BUNCH_STARTS */
undef|#
directive|undef
name|Need_agRootDefined
endif|#
directive|endif
comment|/* Need_agRootDefined */
name|SA_DBG4
argument_list|(
operator|(
literal|"Entering function:mpiMsgProduce\n"
operator|)
argument_list|)
expr_stmt|;
name|SA_ASSERT
argument_list|(
name|NULL
operator|!=
name|circularQ
argument_list|,
literal|"circularQ argument cannot be null"
argument_list|)
expr_stmt|;
name|SA_ASSERT
argument_list|(
name|NULL
operator|!=
name|messagePtr
argument_list|,
literal|"messagePtr argument cannot be null"
argument_list|)
expr_stmt|;
name|SA_ASSERT
argument_list|(
literal|0
operator|!=
name|circularQ
operator|->
name|numElements
argument_list|,
literal|"The number of elements in this queue is 0"
argument_list|)
expr_stmt|;
name|SA_ASSERT
argument_list|(
name|MPI_MAX_OUTBOUND_QUEUES
operator|>
name|responseQueue
argument_list|,
literal|"oQueue ID is wrong"
argument_list|)
expr_stmt|;
comment|/* REB Start extra trace */
name|smTraceFuncEnter
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|"22"
argument_list|)
expr_stmt|;
comment|/* REB End extra trace */
comment|/* Obtains the address of the entire message buffer, including the header */
name|msgHeader
operator|=
operator|(
name|mpiMsgHeader_t
operator|*
operator|)
operator|(
operator|(
operator|(
name|bit8
operator|*
operator|)
name|messagePtr
operator|)
operator|-
sizeof|sizeof
argument_list|(
name|mpiMsgHeader_t
argument_list|)
operator|)
expr_stmt|;
comment|/* Read the BC from header, its stored in native endian format when message was allocated */
comment|/* intially */
name|bc
operator|=
operator|(
operator|(
operator|(
name|msgHeader
operator|->
name|Header
operator|)
operator|>>
name|SHIFT24
operator|)
operator|&
name|BC_MASK
operator|)
expr_stmt|;
name|SA_DBG6
argument_list|(
operator|(
literal|"mpiMsgProduce: msgHeader bc %d\n"
operator|,
name|bc
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|circularQ
operator|->
name|priority
condition|)
block|{
name|hpriority
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Checks the message is in "allocated" state */
name|SA_ASSERT
argument_list|(
literal|0
operator|!=
name|bc
argument_list|,
literal|"The message buffer is not in \"allocated\" state (bc == 0)"
argument_list|)
expr_stmt|;
name|Header
operator|=
operator|(
operator|(
name|V_BIT
operator|<<
name|SHIFT31
operator|)
operator||
operator|(
name|hpriority
operator|<<
name|SHIFT30
operator|)
operator||
operator|(
operator|(
name|bc
operator|&
name|BC_MASK
operator|)
operator|<<
name|SHIFT24
operator|)
operator||
operator|(
operator|(
name|responseQueue
operator|&
name|OBID_MASK
operator|)
operator|<<
name|SHIFT16
operator|)
operator||
operator|(
operator|(
name|category
operator|&
name|CAT_MASK
operator|)
operator|<<
name|SHIFT12
operator|)
operator||
operator|(
name|opCode
operator|&
name|OPCODE_MASK
operator|)
operator|)
expr_stmt|;
comment|/* pre flush the cache line */
name|ossaCachePreFlush
argument_list|(
name|circularQ
operator|->
name|agRoot
argument_list|,
operator|(
name|void
operator|*
operator|)
name|circularQ
operator|->
name|memoryRegion
operator|.
name|appHandle
argument_list|,
operator|(
name|void
operator|*
operator|)
name|msgHeader
argument_list|,
name|circularQ
operator|->
name|elementSize
operator|*
name|bc
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|circularQ
operator|->
name|agRoot
argument_list|,
name|msgHeader
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|mpiMsgHeader_t
argument_list|,
name|Header
argument_list|)
argument_list|,
name|Header
argument_list|)
expr_stmt|;
comment|/* flush the cache line for IOMB */
name|ossaCacheFlush
argument_list|(
name|circularQ
operator|->
name|agRoot
argument_list|,
operator|(
name|void
operator|*
operator|)
name|circularQ
operator|->
name|memoryRegion
operator|.
name|appHandle
argument_list|,
operator|(
name|void
operator|*
operator|)
name|msgHeader
argument_list|,
name|circularQ
operator|->
name|elementSize
operator|*
name|bc
argument_list|)
expr_stmt|;
name|MPI_DEBUG_TRACE
argument_list|(
name|circularQ
operator|->
name|qNumber
argument_list|,
operator|(
operator|(
name|circularQ
operator|->
name|producerIdx
operator|<<
literal|16
operator|)
operator||
name|circularQ
operator|->
name|consumerIdx
operator|)
argument_list|,
name|MPI_DEBUG_TRACE_IBQ
argument_list|,
operator|(
name|void
operator|*
operator|)
name|msgHeader
argument_list|,
name|circularQ
operator|->
name|elementSize
argument_list|)
expr_stmt|;
name|ossaLogIomb
argument_list|(
name|circularQ
operator|->
name|agRoot
argument_list|,
name|circularQ
operator|->
name|qNumber
argument_list|,
name|TRUE
argument_list|,
operator|(
name|void
operator|*
operator|)
name|msgHeader
argument_list|,
name|circularQ
operator|->
name|elementSize
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SALLSDK_DEBUG
argument_list|)
name|MPI_IBQ_IOMB_LOG
argument_list|(
name|circularQ
operator|->
name|qNumber
argument_list|,
operator|(
name|void
operator|*
operator|)
name|msgHeader
argument_list|,
name|circularQ
operator|->
name|elementSize
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SALLSDK_DEBUG */
comment|/* REB Start extra trace */
ifdef|#
directive|ifdef
name|SA_ENABLE_TRACE_FUNCTIONS
name|smTrace
argument_list|(
name|hpDBG_IOMB
argument_list|,
literal|"M1"
argument_list|,
name|circularQ
operator|->
name|qNumber
argument_list|)
expr_stmt|;
comment|/* TP:M1 circularQ->qNumber */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
operator|(
name|bit32
operator|)
name|bc
operator|*
operator|(
name|circularQ
operator|->
name|elementSize
operator|/
literal|4
operator|)
operator|)
condition|;
name|i
operator|++
control|)
block|{
comment|/* The -sizeof(mpiMsgHeader_t) is to account for mpiMsgProduce adding the header to the pMessage pointer */
name|smTrace
argument_list|(
name|hpDBG_IOMB
argument_list|,
literal|"MD"
argument_list|,
operator|*
operator|(
operator|(
operator|(
name|bit32
operator|*
operator|)
operator|(
operator|(
name|bit8
operator|*
operator|)
name|messagePtr
operator|-
sizeof|sizeof
argument_list|(
name|mpiMsgHeader_t
argument_list|)
operator|)
operator|)
operator|+
name|i
operator|)
argument_list|)
expr_stmt|;
comment|/* TP:MD Inbound IOMB Dword */
block|}
endif|#
directive|endif
comment|/* SA_ENABLE_TRACE_FUNCTIONS */
comment|/* update PI of inbound queue */
ifdef|#
directive|ifdef
name|SA_FW_TEST_BUNCH_STARTS
if|if
condition|(
name|saRoot
operator|->
name|BunchStarts_Enable
condition|)
block|{
if|if
condition|(
name|circularQ
operator|->
name|BunchStarts_QPending
operator|==
literal|0
condition|)
block|{
comment|// store tick value for 1st deferred IO only
name|circularQ
operator|->
name|BunchStarts_QPendingTick
operator|=
name|saRoot
operator|->
name|timeTick
expr_stmt|;
block|}
comment|// update queue's pending count
name|circularQ
operator|->
name|BunchStarts_QPending
operator|++
expr_stmt|;
comment|// update global pending count
name|saRoot
operator|->
name|BunchStarts_Pending
operator|++
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"mpiMsgProduce: BunchStarts - Global Pending %d\n"
operator|,
name|saRoot
operator|->
name|BunchStarts_Pending
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"mpiMsgProduce: BunchStarts - QPending %d, Q-%d\n"
operator|,
name|circularQ
operator|->
name|BunchStarts_QPending
operator|,
name|circularQ
operator|->
name|qNumber
operator|)
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'a'
argument_list|,
literal|"22"
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_SUCCESS
return|;
block|}
name|saRoot
operator|->
name|BunchStarts_Pending
operator|=
literal|0
expr_stmt|;
name|circularQ
operator|->
name|BunchStarts_QPending
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* SA_FW_TEST_BUNCH_STARTS */
name|ossaHwRegWriteExt
argument_list|(
name|circularQ
operator|->
name|agRoot
argument_list|,
name|circularQ
operator|->
name|PIPCIBar
argument_list|,
name|circularQ
operator|->
name|PIPCIOffset
argument_list|,
name|circularQ
operator|->
name|producerIdx
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'b'
argument_list|,
literal|"22"
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* mpiMsgProduce */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FAST_IO_TEST */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SA_FW_TEST_BUNCH_STARTS
end_ifdef

begin_function
name|void
name|mpiMsgProduceBunch
parameter_list|(
name|agsaLLRoot_t
modifier|*
name|saRoot
parameter_list|)
block|{
name|mpiICQueue_t
modifier|*
name|circularQ
decl_stmt|;
name|bit32
name|inq
decl_stmt|;
for|for
control|(
name|inq
operator|=
literal|0
init|;
operator|(
operator|(
name|inq
operator|<
name|saRoot
operator|->
name|QueueConfig
operator|.
name|numInboundQueues
operator|)
operator|&&
name|saRoot
operator|->
name|BunchStarts_Pending
operator|)
condition|;
name|inq
operator|++
control|)
block|{
name|circularQ
operator|=
operator|&
name|saRoot
operator|->
name|inboundQueue
index|[
name|inq
index|]
expr_stmt|;
comment|/* If any pending IOs present then either process if BunchStarts_Threshold      * IO limit reached or if the timer has popped      */
if|if
condition|(
name|circularQ
operator|->
name|BunchStarts_QPending
operator|&&
operator|(
operator|(
name|circularQ
operator|->
name|BunchStarts_QPending
operator|>=
name|saRoot
operator|->
name|BunchStarts_Threshold
operator|)
operator|||
operator|(
operator|(
name|saRoot
operator|->
name|timeTick
operator|-
name|circularQ
operator|->
name|BunchStarts_QPendingTick
operator|)
operator|>=
name|saRoot
operator|->
name|BunchStarts_TimeoutTicks
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|circularQ
operator|->
name|qNumber
operator|!=
name|inq
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"mpiMsgProduceBunch:circularQ->qNumber(%d) != inq(%d)\n"
operator|,
name|circularQ
operator|->
name|qNumber
operator|,
name|inq
operator|)
argument_list|)
expr_stmt|;
block|}
name|SA_DBG1
argument_list|(
operator|(
literal|"mpiMsgProduceBunch: IQ=%d, PI=%d\n"
operator|,
name|inq
operator|,
name|circularQ
operator|->
name|producerIdx
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"mpiMsgProduceBunch: Qpending=%d, TotPending=%d\n"
operator|,
name|circularQ
operator|->
name|BunchStarts_QPending
operator|,
name|saRoot
operator|->
name|BunchStarts_Pending
operator|)
argument_list|)
expr_stmt|;
name|ossaHwRegWriteExt
argument_list|(
name|circularQ
operator|->
name|agRoot
argument_list|,
name|circularQ
operator|->
name|PIPCIBar
argument_list|,
name|circularQ
operator|->
name|PIPCIOffset
argument_list|,
name|circularQ
operator|->
name|producerIdx
argument_list|)
expr_stmt|;
comment|// update global pending count
name|saRoot
operator|->
name|BunchStarts_Pending
operator|-=
name|circularQ
operator|->
name|BunchStarts_QPending
expr_stmt|;
comment|// clear current queue's pending count after processing
name|circularQ
operator|->
name|BunchStarts_QPending
operator|=
literal|0
expr_stmt|;
name|circularQ
operator|->
name|BunchStarts_QPendingTick
operator|=
name|saRoot
operator|->
name|timeTick
expr_stmt|;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SA_FW_TEST_BUNCH_STARTS */
end_comment

begin_comment
comment|/*******************************************************************************/
end_comment

begin_comment
comment|/** \fn mpiMsgConsume(mpiOCQueue_t *circularQ, void *messagePtr1,  *                mpiMsgCategory_t * pCategory, bit16 * pOpCode, bit8 * pBC)  *  \brief Get a received message  *  \param circularQ   Pointer to a outbound queue  *  \param messagePtr1 Pointer to the returned message buffer or NULL if no valid message  *  \param pCategory   Pointer to Message category (ETHERNET, FC, SAS-SATA, SCSI)  *  \param pOpCode     Pointer to Message operation code  *  \param pBC         Pointer to buffer count  *  * Consume a receive message in the specified outbound queue  *  * Return:  *         AGSA_RC_SUCCESS if the message has been retrieved succesfully  *         AGSA_RC_BUSY    if the circular is empty  */
end_comment

begin_comment
comment|/*******************************************************************************/
end_comment

begin_function
name|GLOBAL
name|FORCEINLINE
name|bit32
name|mpiMsgConsume
parameter_list|(
name|mpiOCQueue_t
modifier|*
name|circularQ
parameter_list|,
name|void
modifier|*
modifier|*
name|messagePtr1
parameter_list|,
name|mpiMsgCategory_t
modifier|*
name|pCategory
parameter_list|,
name|bit16
modifier|*
name|pOpCode
parameter_list|,
name|bit8
modifier|*
name|pBC
parameter_list|)
block|{
name|mpiMsgHeader_t
modifier|*
name|msgHeader
decl_stmt|;
name|bit32
name|msgHeader_tmp
decl_stmt|;
name|SA_ASSERT
argument_list|(
name|NULL
operator|!=
name|circularQ
argument_list|,
literal|"circularQ argument cannot be null"
argument_list|)
expr_stmt|;
name|SA_ASSERT
argument_list|(
name|NULL
operator|!=
name|messagePtr1
argument_list|,
literal|"messagePtr1 argument cannot be null"
argument_list|)
expr_stmt|;
name|SA_ASSERT
argument_list|(
name|NULL
operator|!=
name|pCategory
argument_list|,
literal|"pCategory argument cannot be null"
argument_list|)
expr_stmt|;
name|SA_ASSERT
argument_list|(
name|NULL
operator|!=
name|pOpCode
argument_list|,
literal|"pOpCode argument cannot be null"
argument_list|)
expr_stmt|;
name|SA_ASSERT
argument_list|(
name|NULL
operator|!=
name|pBC
argument_list|,
literal|"pBC argument cannot be null"
argument_list|)
expr_stmt|;
name|SA_ASSERT
argument_list|(
literal|0
operator|!=
name|circularQ
operator|->
name|numElements
argument_list|,
literal|"The number of elements in this queue is 0"
argument_list|)
expr_stmt|;
do|do
block|{
comment|/* If there are not-yet-delivered messages ... */
if|if
condition|(
name|circularQ
operator|->
name|producerIdx
operator|!=
name|circularQ
operator|->
name|consumerIdx
condition|)
block|{
comment|/* Get the pointer to the circular queue buffer element */
name|msgHeader
operator|=
operator|(
name|mpiMsgHeader_t
operator|*
operator|)
operator|(
operator|(
name|bit8
operator|*
operator|)
operator|(
name|circularQ
operator|->
name|memoryRegion
operator|.
name|virtPtr
operator|)
operator|+
name|circularQ
operator|->
name|consumerIdx
operator|*
name|circularQ
operator|->
name|elementSize
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LOOPBACK_MPI
if|if
condition|(
operator|!
name|loopback
condition|)
endif|#
directive|endif
comment|/* invalidate the cache line of IOMB */
name|ossaCacheInvalidate
argument_list|(
name|circularQ
operator|->
name|agRoot
argument_list|,
operator|(
name|void
operator|*
operator|)
name|circularQ
operator|->
name|memoryRegion
operator|.
name|appHandle
argument_list|,
operator|(
name|void
operator|*
operator|)
name|msgHeader
argument_list|,
name|circularQ
operator|->
name|elementSize
argument_list|)
expr_stmt|;
comment|/* read header */
name|OSSA_READ_LE_32
argument_list|(
name|circularQ
operator|->
name|agRoot
argument_list|,
operator|&
name|msgHeader_tmp
argument_list|,
name|msgHeader
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SA_DBG4
argument_list|(
operator|(
literal|"mpiMsgConsume: process an IOMB, header=0x%x\n"
operator|,
name|msgHeader_tmp
operator|)
argument_list|)
expr_stmt|;
name|SA_ASSERT
argument_list|(
literal|0
operator|!=
operator|(
name|msgHeader_tmp
operator|&
name|HEADER_BC_MASK
operator|)
argument_list|,
literal|"The bc field in the header is 0"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TEST
comment|/* for debugging */
if|if
condition|(
literal|0
operator|==
operator|(
name|msgHeader_tmp
operator|&
name|HEADER_BC_MASK
operator|)
condition|)
block|{
name|SA_DBG1
argument_list|(
operator|(
literal|"mpiMsgConsume: CI=%d PI=%d msgHeader=%p\n"
operator|,
name|circularQ
operator|->
name|consumerIdx
operator|,
name|circularQ
operator|->
name|producerIdx
operator|,
operator|(
name|void
operator|*
operator|)
name|msgHeader
operator|)
argument_list|)
expr_stmt|;
name|circularQ
operator|->
name|consumerIdx
operator|=
operator|(
name|circularQ
operator|->
name|consumerIdx
operator|+
literal|1
operator|)
operator|%
name|circularQ
operator|->
name|numElements
expr_stmt|;
comment|/* update the CI of outbound queue - skip this blank IOMB, for test only */
name|ossaHwRegWriteExt
argument_list|(
name|circularQ
operator|->
name|agRoot
argument_list|,
name|circularQ
operator|->
name|CIPCIBar
argument_list|,
name|circularQ
operator|->
name|CIPCIOffset
argument_list|,
name|circularQ
operator|->
name|consumerIdx
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_FAILURE
return|;
block|}
endif|#
directive|endif
comment|/* get message pointer of valid entry */
if|if
condition|(
literal|0
operator|!=
operator|(
name|msgHeader_tmp
operator|&
name|HEADER_V_MASK
operator|)
condition|)
block|{
name|SA_ASSERT
argument_list|(
name|circularQ
operator|->
name|consumerIdx
operator|<=
name|circularQ
operator|->
name|numElements
argument_list|,
literal|"Multi-buffer messages cannot wrap around"
argument_list|)
expr_stmt|;
if|if
condition|(
name|OPC_OUB_SKIP_ENTRY
operator|!=
operator|(
name|msgHeader_tmp
operator|&
name|OPCODE_MASK
operator|)
condition|)
block|{
comment|/* ... return the message payload */
operator|*
name|messagePtr1
operator|=
operator|(
operator|(
name|bit8
operator|*
operator|)
name|msgHeader
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|mpiMsgHeader_t
argument_list|)
expr_stmt|;
operator|*
name|pCategory
operator|=
call|(
name|mpiMsgCategory_t
call|)
argument_list|(
name|msgHeader_tmp
operator|>>
name|SHIFT12
argument_list|)
operator|&
name|CAT_MASK
expr_stmt|;
operator|*
name|pOpCode
operator|=
call|(
name|bit16
call|)
argument_list|(
name|msgHeader_tmp
operator|&
name|OPCODE_MASK
argument_list|)
expr_stmt|;
operator|*
name|pBC
operator|=
call|(
name|bit8
call|)
argument_list|(
operator|(
name|msgHeader_tmp
operator|>>
name|SHIFT24
operator|)
operator|&
name|BC_MASK
argument_list|)
expr_stmt|;
comment|/* invalidate the cache line for IOMB */
ifdef|#
directive|ifdef
name|LOOPBACK_MPI
if|if
condition|(
operator|!
name|loopback
condition|)
endif|#
directive|endif
name|ossaCacheInvalidate
argument_list|(
name|circularQ
operator|->
name|agRoot
argument_list|,
operator|(
name|void
operator|*
operator|)
name|circularQ
operator|->
name|memoryRegion
operator|.
name|appHandle
argument_list|,
operator|(
name|void
operator|*
operator|)
name|msgHeader
argument_list|,
operator|(
operator|*
name|pBC
operator|-
literal|1
operator|)
operator|*
name|circularQ
operator|->
name|elementSize
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SALLSDK_DEBUG
argument_list|)
name|SA_DBG3
argument_list|(
operator|(
literal|"mpiMsgConsume: CI=%d PI=%d msgHeader=%p\n"
operator|,
name|circularQ
operator|->
name|consumerIdx
operator|,
name|circularQ
operator|->
name|producerIdx
operator|,
operator|(
name|void
operator|*
operator|)
name|msgHeader
operator|)
argument_list|)
expr_stmt|;
name|MPI_OBQ_IOMB_LOG
argument_list|(
name|circularQ
operator|->
name|qNumber
argument_list|,
operator|(
name|void
operator|*
operator|)
name|msgHeader
argument_list|,
name|circularQ
operator|->
name|elementSize
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|AGSA_RC_SUCCESS
return|;
block|}
else|else
block|{
name|SA_DBG3
argument_list|(
operator|(
literal|"mpiMsgConsume: SKIP_ENTRIES_IOMB BC=%d\n"
operator|,
operator|(
name|msgHeader_tmp
operator|>>
name|SHIFT24
operator|)
operator|&
name|BC_MASK
operator|)
argument_list|)
expr_stmt|;
comment|/* Updated comsumerIdx and skip it */
name|circularQ
operator|->
name|consumerIdx
operator|=
operator|(
name|circularQ
operator|->
name|consumerIdx
operator|+
operator|(
operator|(
name|msgHeader_tmp
operator|>>
name|SHIFT24
operator|)
operator|&
name|BC_MASK
operator|)
operator|)
operator|%
name|circularQ
operator|->
name|numElements
expr_stmt|;
comment|/* clean header to 0 */
name|msgHeader_tmp
operator|=
literal|0
expr_stmt|;
comment|/*ossaSingleThreadedEnter(agRoot, LL_IOREQ_OBQ_LOCK);*/
name|OSSA_WRITE_LE_32
argument_list|(
name|circularQ
operator|->
name|agRoot
argument_list|,
name|msgHeader
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|mpiMsgHeader_t
argument_list|,
name|Header
argument_list|)
argument_list|,
name|msgHeader_tmp
argument_list|)
expr_stmt|;
comment|/* update the CI of outbound queue */
name|ossaHwRegWriteExt
argument_list|(
name|circularQ
operator|->
name|agRoot
argument_list|,
name|circularQ
operator|->
name|CIPCIBar
argument_list|,
name|circularQ
operator|->
name|CIPCIOffset
argument_list|,
name|circularQ
operator|->
name|consumerIdx
argument_list|)
expr_stmt|;
comment|/* Update the producer index */
name|OSSA_READ_LE_32
argument_list|(
name|circularQ
operator|->
name|agRoot
argument_list|,
operator|&
name|circularQ
operator|->
name|producerIdx
argument_list|,
name|circularQ
operator|->
name|piPointer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*ossaSingleThreadedLeave(agRoot, LL_IOREQ_OBQ_LOCK); */
block|}
block|}
else|else
block|{
comment|/* V bit is not set */
if|#
directive|if
name|defined
argument_list|(
name|SALLSDK_DEBUG
argument_list|)
name|agsaRoot_t
modifier|*
name|agRoot
init|=
name|circularQ
operator|->
name|agRoot
decl_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"mpiMsgConsume: V bit not set, PI=%d CI=%d msgHeader=%p\n"
operator|,
name|circularQ
operator|->
name|producerIdx
operator|,
name|circularQ
operator|->
name|consumerIdx
operator|,
operator|(
name|void
operator|*
operator|)
name|msgHeader
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"mpiMsgConsume: V bit not set, 0x%08X Q=%d  \n"
operator|,
name|msgHeader_tmp
operator|,
name|circularQ
operator|->
name|qNumber
operator|)
argument_list|)
expr_stmt|;
name|MPI_DEBUG_TRACE
argument_list|(
name|MPI_DEBUG_TRACE_QNUM_ERROR
operator|+
name|circularQ
operator|->
name|qNumber
argument_list|,
operator|(
operator|(
name|circularQ
operator|->
name|producerIdx
operator|<<
literal|16
operator|)
operator||
name|circularQ
operator|->
name|consumerIdx
operator|)
argument_list|,
name|MPI_DEBUG_TRACE_OBQ
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
operator|(
name|bit8
operator|*
operator|)
name|msgHeader
operator|)
operator|-
sizeof|sizeof
argument_list|(
name|mpiMsgHeader_t
argument_list|)
operator|)
argument_list|,
name|circularQ
operator|->
name|elementSize
argument_list|)
expr_stmt|;
name|circularQ
operator|->
name|consumerIdx
operator|=
name|circularQ
operator|->
name|consumerIdx
operator|%
name|circularQ
operator|->
name|numElements
expr_stmt|;
name|circularQ
operator|->
name|consumerIdx
operator|++
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|circularQ
operator|->
name|agRoot
argument_list|,
name|msgHeader
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|mpiMsgHeader_t
argument_list|,
name|Header
argument_list|)
argument_list|,
name|msgHeader_tmp
argument_list|)
expr_stmt|;
name|ossaHwRegWriteExt
argument_list|(
name|agRoot
argument_list|,
name|circularQ
operator|->
name|CIPCIBar
argument_list|,
name|circularQ
operator|->
name|CIPCIOffset
argument_list|,
name|circularQ
operator|->
name|consumerIdx
argument_list|)
expr_stmt|;
name|MPI_OBQ_IOMB_LOG
argument_list|(
name|circularQ
operator|->
name|qNumber
argument_list|,
operator|(
name|void
operator|*
operator|)
name|msgHeader
argument_list|,
name|circularQ
operator|->
name|elementSize
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|SA_DBG1
argument_list|(
operator|(
literal|"mpiMsgConsume: V bit is not set!!!!! HW CI=%d\n"
operator|,
name|ossaHwRegReadExt
argument_list|(
name|circularQ
operator|->
name|agRoot
argument_list|,
name|circularQ
operator|->
name|CIPCIBar
argument_list|,
name|circularQ
operator|->
name|CIPCIOffset
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|SA_ASSERT
argument_list|(
literal|0
argument_list|,
literal|"V bit is not set"
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_FAILURE
return|;
block|}
block|}
else|else
block|{
comment|/* Update the producer index from SPC */
name|OSSA_READ_LE_32
argument_list|(
name|circularQ
operator|->
name|agRoot
argument_list|,
operator|&
name|circularQ
operator|->
name|producerIdx
argument_list|,
name|circularQ
operator|->
name|piPointer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|circularQ
operator|->
name|producerIdx
operator|!=
name|circularQ
operator|->
name|consumerIdx
condition|)
do|;
comment|/* while we don't have any more not-yet-delivered message */
ifdef|#
directive|ifdef
name|TEST
name|SA_DBG4
argument_list|(
operator|(
literal|"mpiMsgConsume: Outbound queue is empty.\n"
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* report empty */
return|return
name|AGSA_RC_BUSY
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************************/
end_comment

begin_comment
comment|/** \fn mpiMsgFreeSet(mpiOCQueue_t *circularQ, void *messagePtr)  *  \brief Returns a received message to the outbound queue  *  \param circularQ   Pointer to an outbound queue  *  \param messagePtr1 Pointer to the returned message buffer to free  *  \param messagePtr2 Pointer to the returned message buffer to free if bc> 1  *  * Returns consumed and processed message to the specified outbounf queue  *  * Return:  *         AGSA_RC_SUCCESS if the message has been returned succesfully  */
end_comment

begin_comment
comment|/*******************************************************************************/
end_comment

begin_function
name|GLOBAL
name|FORCEINLINE
name|bit32
name|mpiMsgFreeSet
parameter_list|(
name|mpiOCQueue_t
modifier|*
name|circularQ
parameter_list|,
name|void
modifier|*
name|messagePtr1
parameter_list|,
name|bit8
name|bc
parameter_list|)
block|{
name|mpiMsgHeader_t
modifier|*
name|msgHeader
decl_stmt|;
name|SA_DBG4
argument_list|(
operator|(
literal|"Entering function:mpiMsgFreeSet\n"
operator|)
argument_list|)
expr_stmt|;
name|SA_ASSERT
argument_list|(
name|NULL
operator|!=
name|circularQ
argument_list|,
literal|"circularQ argument cannot be null"
argument_list|)
expr_stmt|;
name|SA_ASSERT
argument_list|(
name|NULL
operator|!=
name|messagePtr1
argument_list|,
literal|"messagePtr1 argument cannot be null"
argument_list|)
expr_stmt|;
name|SA_ASSERT
argument_list|(
literal|0
operator|!=
name|circularQ
operator|->
name|numElements
argument_list|,
literal|"The number of elements in this queue is 0"
argument_list|)
expr_stmt|;
comment|/* Obtains the address of the entire message buffer, including the header */
name|msgHeader
operator|=
operator|(
name|mpiMsgHeader_t
operator|*
operator|)
operator|(
operator|(
operator|(
name|bit8
operator|*
operator|)
name|messagePtr1
operator|)
operator|-
sizeof|sizeof
argument_list|(
name|mpiMsgHeader_t
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|mpiMsgHeader_t
operator|*
operator|)
operator|(
operator|(
name|bit8
operator|*
operator|)
name|circularQ
operator|->
name|memoryRegion
operator|.
name|virtPtr
operator|+
name|circularQ
operator|->
name|consumerIdx
operator|*
name|circularQ
operator|->
name|elementSize
operator|)
operator|)
operator|!=
name|msgHeader
condition|)
block|{
comment|/* IOMB of CI points mismatch with Message Header - should never happened */
name|SA_DBG1
argument_list|(
operator|(
literal|"mpiMsgFreeSet: Wrong CI, Q %d ConsumeIdx = %d msgHeader 0x%08x\n"
operator|,
name|circularQ
operator|->
name|qNumber
operator|,
name|circularQ
operator|->
name|consumerIdx
operator|,
name|msgHeader
operator|->
name|Header
operator|)
argument_list|)
expr_stmt|;
name|SA_DBG1
argument_list|(
operator|(
literal|"mpiMsgFreeSet: msgHeader %p != %p\n"
operator|,
name|msgHeader
operator|,
operator|(
operator|(
name|mpiMsgHeader_t
operator|*
operator|)
operator|(
operator|(
name|bit8
operator|*
operator|)
name|circularQ
operator|->
name|memoryRegion
operator|.
name|virtPtr
operator|+
name|circularQ
operator|->
name|consumerIdx
operator|*
name|circularQ
operator|->
name|elementSize
operator|)
operator|)
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LOOPBACK_MPI
if|if
condition|(
operator|!
name|loopback
condition|)
endif|#
directive|endif
comment|/* Update the producer index from SPC */
name|OSSA_READ_LE_32
argument_list|(
name|circularQ
operator|->
name|agRoot
argument_list|,
operator|&
name|circularQ
operator|->
name|producerIdx
argument_list|,
name|circularQ
operator|->
name|piPointer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SALLSDK_DEBUG
argument_list|)
name|SA_DBG3
argument_list|(
operator|(
literal|"mpiMsgFreeSet: ProducerIdx = %d\n"
operator|,
name|circularQ
operator|->
name|producerIdx
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|AGSA_RC_SUCCESS
return|;
block|}
comment|/* ... free the circular queue buffer elements associated with the message ... */
comment|/*... by incrementing the consumer index (with wrap arround) */
name|circularQ
operator|->
name|consumerIdx
operator|=
operator|(
name|circularQ
operator|->
name|consumerIdx
operator|+
name|bc
operator|)
operator|%
name|circularQ
operator|->
name|numElements
expr_stmt|;
comment|/* Invalidates this circular queue buffer element */
name|msgHeader
operator|->
name|Header
operator|&=
operator|~
name|HEADER_V_MASK
expr_stmt|;
comment|/* Clear Valid bit to indicate IOMB consumed by host */
name|SA_ASSERT
argument_list|(
name|circularQ
operator|->
name|consumerIdx
operator|<=
name|circularQ
operator|->
name|numElements
argument_list|,
literal|"Multi-buffer messages cannot wrap arround"
argument_list|)
expr_stmt|;
comment|/* update the CI of outbound queue */
ifdef|#
directive|ifdef
name|LOOPBACK_MPI
if|if
condition|(
operator|!
name|loopback
condition|)
endif|#
directive|endif
block|{
name|ossaHwRegWriteExt
argument_list|(
name|circularQ
operator|->
name|agRoot
argument_list|,
name|circularQ
operator|->
name|CIPCIBar
argument_list|,
name|circularQ
operator|->
name|CIPCIOffset
argument_list|,
name|circularQ
operator|->
name|consumerIdx
argument_list|)
expr_stmt|;
comment|/* Update the producer index from SPC */
name|OSSA_READ_LE_32
argument_list|(
name|circularQ
operator|->
name|agRoot
argument_list|,
operator|&
name|circularQ
operator|->
name|producerIdx
argument_list|,
name|circularQ
operator|->
name|piPointer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|SALLSDK_DEBUG
argument_list|)
name|SA_DBG5
argument_list|(
operator|(
literal|"mpiMsgFreeSet: CI=%d PI=%d\n"
operator|,
name|circularQ
operator|->
name|consumerIdx
operator|,
name|circularQ
operator|->
name|producerIdx
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|AGSA_RC_SUCCESS
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|TEST
end_ifdef

begin_function
name|GLOBAL
name|bit32
name|mpiRotateQnumber
parameter_list|(
name|agsaRoot_t
modifier|*
name|agRoot
parameter_list|)
block|{
name|agsaLLRoot_t
modifier|*
name|saRoot
init|=
operator|(
name|agsaLLRoot_t
operator|*
operator|)
operator|(
name|agRoot
operator|->
name|sdkData
operator|)
decl_stmt|;
name|bit32
name|denom
decl_stmt|;
name|bit32
name|ret
init|=
literal|0
decl_stmt|;
comment|/* inbound queue number */
name|saRoot
operator|->
name|IBQnumber
operator|++
expr_stmt|;
name|denom
operator|=
name|saRoot
operator|->
name|QueueConfig
operator|.
name|numInboundQueues
expr_stmt|;
if|if
condition|(
name|saRoot
operator|->
name|IBQnumber
operator|%
name|denom
operator|==
literal|0
condition|)
comment|/* % Qnumber*/
block|{
name|saRoot
operator|->
name|IBQnumber
operator|=
literal|0
expr_stmt|;
block|}
name|SA_DBG3
argument_list|(
operator|(
literal|"mpiRotateQnumber: IBQnumber %d\n"
operator|,
name|saRoot
operator|->
name|IBQnumber
operator|)
argument_list|)
expr_stmt|;
comment|/* outbound queue number */
name|saRoot
operator|->
name|OBQnumber
operator|++
expr_stmt|;
name|denom
operator|=
name|saRoot
operator|->
name|QueueConfig
operator|.
name|numOutboundQueues
expr_stmt|;
if|if
condition|(
name|saRoot
operator|->
name|OBQnumber
operator|%
name|denom
operator|==
literal|0
condition|)
comment|/* % Qnumber*/
block|{
name|saRoot
operator|->
name|OBQnumber
operator|=
literal|0
expr_stmt|;
block|}
name|SA_DBG3
argument_list|(
operator|(
literal|"mpiRotateQnumber: OBQnumber %d\n"
operator|,
name|saRoot
operator|->
name|OBQnumber
operator|)
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|(
name|saRoot
operator|->
name|OBQnumber
operator|<<
name|SHIFT16
operator|)
operator||
name|saRoot
operator|->
name|IBQnumber
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|LOOPBACK_MPI
end_ifdef

begin_function
name|GLOBAL
name|bit32
name|mpiMsgProduceOQ
parameter_list|(
name|mpiOCQueue_t
modifier|*
name|circularQ
parameter_list|,
name|void
modifier|*
name|messagePtr
parameter_list|,
name|mpiMsgCategory_t
name|category
parameter_list|,
name|bit16
name|opCode
parameter_list|,
name|bit8
name|responseQueue
parameter_list|,
name|bit8
name|hiPriority
parameter_list|)
block|{
name|mpiMsgHeader_t
modifier|*
name|msgHeader
decl_stmt|;
name|bit32
name|bc
decl_stmt|;
name|bit32
name|Header
init|=
literal|0
decl_stmt|;
name|bit32
name|hpriority
init|=
literal|0
decl_stmt|;
name|SA_DBG4
argument_list|(
operator|(
literal|"Entering function:mpiMsgProduceOQ\n"
operator|)
argument_list|)
expr_stmt|;
name|SA_ASSERT
argument_list|(
name|NULL
operator|!=
name|circularQ
argument_list|,
literal|"circularQ argument cannot be null"
argument_list|)
expr_stmt|;
name|SA_ASSERT
argument_list|(
name|NULL
operator|!=
name|messagePtr
argument_list|,
literal|"messagePtr argument cannot be null"
argument_list|)
expr_stmt|;
name|SA_ASSERT
argument_list|(
literal|0
operator|!=
name|circularQ
operator|->
name|numElements
argument_list|,
literal|"The number of elements in this queue"
literal|" is 0"
argument_list|)
expr_stmt|;
name|SA_ASSERT
argument_list|(
name|MPI_MAX_OUTBOUND_QUEUES
operator|>
name|responseQueue
argument_list|,
literal|"oQueue ID is wrong"
argument_list|)
expr_stmt|;
comment|/* REB Start extra trace */
name|smTraceFuncEnter
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|"2I"
argument_list|)
expr_stmt|;
comment|/* REB End extra trace */
comment|/* Obtains the address of the entire message buffer, including the header */
name|msgHeader
operator|=
operator|(
name|mpiMsgHeader_t
operator|*
operator|)
operator|(
operator|(
operator|(
name|bit8
operator|*
operator|)
name|messagePtr
operator|)
operator|-
sizeof|sizeof
argument_list|(
name|mpiMsgHeader_t
argument_list|)
operator|)
expr_stmt|;
comment|/* Read the BC from header, its stored in native endian format when message      was allocated */
comment|/* intially */
name|SA_DBG4
argument_list|(
operator|(
literal|"mpiMsgProduceOQ: msgHeader %p opcode %d pi/ci %d / %d\n"
operator|,
name|msgHeader
operator|,
name|opCode
operator|,
name|circularQ
operator|->
name|producerIdx
operator|,
name|circularQ
operator|->
name|consumerIdx
operator|)
argument_list|)
expr_stmt|;
name|bc
operator|=
operator|(
operator|(
operator|(
name|msgHeader
operator|->
name|Header
operator|)
operator|>>
name|SHIFT24
operator|)
operator|&
name|BC_MASK
operator|)
expr_stmt|;
name|SA_DBG6
argument_list|(
operator|(
literal|"mpiMsgProduceOQ: msgHeader bc %d\n"
operator|,
name|bc
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|circularQ
operator|->
name|priority
condition|)
name|hpriority
operator|=
literal|1
expr_stmt|;
comment|/* Checks the message is in "allocated" state */
name|SA_ASSERT
argument_list|(
literal|0
operator|!=
name|bc
argument_list|,
literal|"The message buffer is not in \"allocated\" state "
literal|"(bc == 0)"
argument_list|)
expr_stmt|;
name|Header
operator|=
operator|(
operator|(
name|V_BIT
operator|<<
name|SHIFT31
operator|)
operator||
operator|(
name|hpriority
operator|<<
name|SHIFT30
operator|)
operator||
operator|(
operator|(
name|bc
operator|&
name|BC_MASK
operator|)
operator|<<
name|SHIFT24
operator|)
operator||
operator|(
operator|(
name|responseQueue
operator|&
name|OBID_MASK
operator|)
operator|<<
name|SHIFT16
operator|)
operator||
operator|(
operator|(
name|category
operator|&
name|CAT_MASK
operator|)
operator|<<
name|SHIFT12
operator|)
operator||
operator|(
name|opCode
operator|&
name|OPCODE_MASK
operator|)
operator|)
expr_stmt|;
comment|/* pre flush the IOMB cache line */
comment|//ossaCachePreFlush(circularQ->agRoot,
comment|//                  (void *)circularQ->memoryRegion.appHandle,
comment|//                  (void *)msgHeader, circularQ->elementSize * bc);
name|OSSA_WRITE_LE_32
argument_list|(
name|circularQ
operator|->
name|agRoot
argument_list|,
name|msgHeader
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|mpiMsgHeader_t
argument_list|,
name|Header
argument_list|)
argument_list|,
name|Header
argument_list|)
expr_stmt|;
comment|/* flush the IOMB cache line */
comment|//ossaCacheFlush(circularQ->agRoot, (void *)circularQ->memoryRegion.appHandle,
comment|//               (void *)msgHeader, circularQ->elementSize * bc);
name|MPI_DEBUG_TRACE
argument_list|(
name|circularQ
operator|->
name|qNumber
argument_list|,
operator|(
operator|(
name|circularQ
operator|->
name|producerIdx
operator|<<
literal|16
operator|)
operator||
name|circularQ
operator|->
name|consumerIdx
operator|)
argument_list|,
name|MPI_DEBUG_TRACE_OBQ
argument_list|,
operator|(
name|void
operator|*
operator|)
name|msgHeader
argument_list|,
name|circularQ
operator|->
name|elementSize
argument_list|)
expr_stmt|;
name|ossaLogIomb
argument_list|(
name|circularQ
operator|->
name|agRoot
argument_list|,
name|circularQ
operator|->
name|qNumber
argument_list|,
name|TRUE
argument_list|,
operator|(
name|void
operator|*
operator|)
name|msgHeader
argument_list|,
name|circularQ
operator|->
name|elementSize
argument_list|)
expr_stmt|;
name|smTraceFuncExit
argument_list|(
name|hpDBG_VERY_LOUD
argument_list|,
literal|'a'
argument_list|,
literal|"2I"
argument_list|)
expr_stmt|;
return|return
name|AGSA_RC_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* mpiMsgProduceOQ */
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

