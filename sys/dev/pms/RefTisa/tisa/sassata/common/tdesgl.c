begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************************* *Copyright (c) 2014 PMC-Sierra, Inc.  All rights reserved.  * *Redistribution and use in source and binary forms, with or without modification, are permitted provided  *that the following conditions are met:  *1. Redistributions of source code must retain the above copyright notice, this list of conditions and the *following disclaimer.  *2. Redistributions in binary form must reproduce the above copyright notice,  *this list of conditions and the following disclaimer in the documentation and/or other materials provided *with the distribution.  * *THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR IMPLIED  *WARRANTIES,INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS *FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE *FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  *NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR  *BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  *LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  *SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE  ** ********************************************************************************/
end_comment

begin_comment
comment|/*******************************************************************************/
end_comment

begin_comment
comment|/** \file  *  *  * This file contains ESGL realted functions  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<dev/pms/config.h>
end_include

begin_include
include|#
directive|include
file|<dev/pms/freebsd/driver/common/osenv.h>
end_include

begin_include
include|#
directive|include
file|<dev/pms/freebsd/driver/common/ostypes.h>
end_include

begin_include
include|#
directive|include
file|<dev/pms/freebsd/driver/common/osdebug.h>
end_include

begin_include
include|#
directive|include
file|<dev/pms/RefTisa/sallsdk/api/sa.h>
end_include

begin_include
include|#
directive|include
file|<dev/pms/RefTisa/sallsdk/api/saapi.h>
end_include

begin_include
include|#
directive|include
file|<dev/pms/RefTisa/sallsdk/api/saosapi.h>
end_include

begin_include
include|#
directive|include
file|<dev/pms/RefTisa/tisa/api/titypes.h>
end_include

begin_include
include|#
directive|include
file|<dev/pms/RefTisa/tisa/api/ostiapi.h>
end_include

begin_include
include|#
directive|include
file|<dev/pms/RefTisa/tisa/api/tiapi.h>
end_include

begin_include
include|#
directive|include
file|<dev/pms/RefTisa/tisa/api/tiglobal.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|FDS_SM
end_ifdef

begin_include
include|#
directive|include
file|<dev/pms/RefTisa/sat/api/sm.h>
end_include

begin_include
include|#
directive|include
file|<dev/pms/RefTisa/sat/api/smapi.h>
end_include

begin_include
include|#
directive|include
file|<dev/pms/RefTisa/sat/api/tdsmapi.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|FDS_DM
end_ifdef

begin_include
include|#
directive|include
file|<dev/pms/RefTisa/discovery/api/dm.h>
end_include

begin_include
include|#
directive|include
file|<dev/pms/RefTisa/discovery/api/dmapi.h>
end_include

begin_include
include|#
directive|include
file|<dev/pms/RefTisa/discovery/api/tddmapi.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<dev/pms/RefTisa/tisa/sassata/sas/common/tdtypes.h>
end_include

begin_include
include|#
directive|include
file|<dev/pms/freebsd/driver/common/osstring.h>
end_include

begin_include
include|#
directive|include
file|<dev/pms/RefTisa/tisa/sassata/common/tdutil.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INITIATOR_DRIVER
end_ifdef

begin_include
include|#
directive|include
file|<dev/pms/RefTisa/tisa/sassata/sas/ini/itdtypes.h>
end_include

begin_include
include|#
directive|include
file|<dev/pms/RefTisa/tisa/sassata/sas/ini/itddefs.h>
end_include

begin_include
include|#
directive|include
file|<dev/pms/RefTisa/tisa/sassata/sas/ini/itdglobl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|TARGET_DRIVER
end_ifdef

begin_include
include|#
directive|include
file|<dev/pms/RefTisa/tisa/sassata/sas/tgt/ttdglobl.h>
end_include

begin_include
include|#
directive|include
file|<dev/pms/RefTisa/tisa/sassata/sas/tgt/ttdxchg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pms/RefTisa/tisa/sassata/sas/tgt/ttdtypes.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<dev/pms/RefTisa/tisa/sassata/common/tdsatypes.h>
end_include

begin_include
include|#
directive|include
file|<dev/pms/RefTisa/tisa/sassata/common/tdproto.h>
end_include

begin_comment
comment|/* no more esgl related functions */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|REMOVED
end_ifdef

begin_comment
comment|/***************************************************************************** *! \brief  tdsaEsglInit * *  Purpose: This function initializes the linked list of ESGL pool * *  \param  tiRoot:  Pointer to root data structure. * *  \return: None * *  \note  * *****************************************************************************/
end_comment

begin_function
name|osGLOBAL
name|void
name|tdsaEsglInit
parameter_list|(
name|tiRoot_t
modifier|*
name|tiRoot
parameter_list|)
block|{
name|tdsaRoot_t
modifier|*
name|tdsaRoot
init|=
operator|(
name|tdsaRoot_t
operator|*
operator|)
name|tiRoot
operator|->
name|tdData
decl_stmt|;
name|tdsaContext_t
modifier|*
name|tdsaAllShared
init|=
operator|(
name|tdsaContext_t
operator|*
operator|)
operator|&
name|tdsaRoot
operator|->
name|tdsaAllShared
decl_stmt|;
name|tdsaEsglAllInfo_t
modifier|*
name|pEsglAllInfo
init|=
operator|(
name|tdsaEsglAllInfo_t
operator|*
operator|)
operator|&
operator|(
name|tdsaAllShared
operator|->
name|EsglAllInfo
operator|)
decl_stmt|;
name|tdsaEsglPagePool_t
modifier|*
name|pEsglPagePool
decl_stmt|;
name|bit32
name|pageno
decl_stmt|;
name|bit32
name|PagePhysAddrUpper
decl_stmt|;
name|bit32
name|PagePhysAddrLower
decl_stmt|;
name|bit32
name|prev_PagePhysAddrLower
decl_stmt|;
name|tdsaEsglPageInfo_t
modifier|*
name|pEsglPageInfo
decl_stmt|;
name|void
modifier|*
name|PageVirtAddr
decl_stmt|;
name|bit32
name|PageSizeInBytes
decl_stmt|;
comment|/* for memory index requirement */
name|agsaRoot_t
name|agRoot
decl_stmt|;
name|bit32
name|maxSALocks
init|=
literal|0
decl_stmt|;
name|bit32
name|usecsPerTick
init|=
literal|0
decl_stmt|;
name|agsaSwConfig_t
name|SwConfig
decl_stmt|;
name|agsaMemoryRequirement_t
name|memRequirement
decl_stmt|;
name|agsaQueueConfig_t
modifier|*
name|QueueConfig
decl_stmt|;
name|bit32
name|i
decl_stmt|;
name|TI_DBG6
argument_list|(
operator|(
literal|"tdsaEsglInit: start\n"
operator|)
argument_list|)
expr_stmt|;
name|tdsaGetSwConfigParams
argument_list|(
name|tiRoot
argument_list|)
expr_stmt|;
name|QueueConfig
operator|=
operator|&
name|tdsaAllShared
operator|->
name|QueueConfig
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|QueueConfig
operator|->
name|numInboundQueues
condition|;
name|i
operator|++
control|)
block|{
name|QueueConfig
operator|->
name|inboundQueues
index|[
name|i
index|]
operator|.
name|elementCount
operator|=
name|tdsaAllShared
operator|->
name|InboundQueueSize
expr_stmt|;
name|QueueConfig
operator|->
name|inboundQueues
index|[
name|i
index|]
operator|.
name|elementSize
operator|=
name|tdsaAllShared
operator|->
name|InboundQueueEleSize
expr_stmt|;
name|QueueConfig
operator|->
name|inboundQueues
index|[
name|i
index|]
operator|.
name|priority
operator|=
name|tdsaAllShared
operator|->
name|InboundQueuePriority
index|[
name|i
index|]
expr_stmt|;
name|QueueConfig
operator|->
name|inboundQueues
index|[
name|i
index|]
operator|.
name|reserved
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|QueueConfig
operator|->
name|numOutboundQueues
condition|;
name|i
operator|++
control|)
block|{
name|QueueConfig
operator|->
name|outboundQueues
index|[
name|i
index|]
operator|.
name|elementCount
operator|=
name|tdsaAllShared
operator|->
name|OutboundQueueSize
expr_stmt|;
name|QueueConfig
operator|->
name|outboundQueues
index|[
name|i
index|]
operator|.
name|elementSize
operator|=
name|tdsaAllShared
operator|->
name|OutboundQueueEleSize
expr_stmt|;
name|QueueConfig
operator|->
name|outboundQueues
index|[
name|i
index|]
operator|.
name|interruptDelay
operator|=
name|tdsaAllShared
operator|->
name|OutboundQueueInterruptDelay
index|[
name|i
index|]
expr_stmt|;
comment|/* default 0; no interrupt delay */
name|QueueConfig
operator|->
name|outboundQueues
index|[
name|i
index|]
operator|.
name|interruptCount
operator|=
name|tdsaAllShared
operator|->
name|OutboundQueueInterruptCount
index|[
name|i
index|]
expr_stmt|;
comment|/* default 1*/
name|QueueConfig
operator|->
name|outboundQueues
index|[
name|i
index|]
operator|.
name|interruptVectorIndex
operator|=
literal|0
expr_stmt|;
block|}
comment|/*     hardcoded Queue numbers   */
name|QueueConfig
operator|->
name|sasHwEventQueue
operator|=
literal|0
expr_stmt|;
name|QueueConfig
operator|->
name|sataNCQErrorEventQueue
operator|=
literal|0
expr_stmt|;
name|SwConfig
operator|.
name|sizefEventLog1
operator|=
name|HOST_EVENT_LOG_SIZE
expr_stmt|;
name|SwConfig
operator|.
name|sizefEventLog2
operator|=
name|HOST_EVENT_LOG_SIZE
expr_stmt|;
name|SwConfig
operator|.
name|eventLog1Option
operator|=
literal|0
expr_stmt|;
name|SwConfig
operator|.
name|eventLog2Option
operator|=
literal|0
expr_stmt|;
name|SwConfig
operator|.
name|fatalErrorInterrtuptEnable
operator|=
literal|1
expr_stmt|;
name|SwConfig
operator|.
name|fatalErrorInterruptVector
operator|=
literal|1
expr_stmt|;
name|SwConfig
operator|.
name|reserved
operator|=
literal|0
expr_stmt|;
name|SwConfig
operator|.
name|param3
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
operator|(
name|tdsaAllShared
operator|->
name|QueueConfig
operator|)
expr_stmt|;
comment|/* to find out memRequirement */
name|saGetRequirements
argument_list|(
operator|&
name|agRoot
argument_list|,
operator|&
name|SwConfig
argument_list|,
operator|&
name|memRequirement
argument_list|,
operator|&
name|usecsPerTick
argument_list|,
operator|&
name|maxSALocks
argument_list|)
expr_stmt|;
comment|/* initializes tdsaEsglAllInfo_t */
name|pEsglAllInfo
operator|->
name|physAddrUpper
operator|=
name|tdsaAllShared
operator|->
name|loResource
operator|.
name|loLevelMem
operator|.
name|mem
index|[
name|memRequirement
operator|.
name|count
index|]
operator|.
name|physAddrUpper
expr_stmt|;
name|pEsglAllInfo
operator|->
name|physAddrLower
operator|=
name|tdsaAllShared
operator|->
name|loResource
operator|.
name|loLevelMem
operator|.
name|mem
index|[
name|memRequirement
operator|.
name|count
index|]
operator|.
name|physAddrLower
expr_stmt|;
name|pEsglAllInfo
operator|->
name|virtPtr
operator|=
name|tdsaAllShared
operator|->
name|loResource
operator|.
name|loLevelMem
operator|.
name|mem
index|[
name|memRequirement
operator|.
name|count
index|]
operator|.
name|virtPtr
expr_stmt|;
name|pEsglAllInfo
operator|->
name|NumEsglPages
operator|=
name|tdsaAllShared
operator|->
name|loResource
operator|.
name|loLevelMem
operator|.
name|mem
index|[
name|memRequirement
operator|.
name|count
index|]
operator|.
name|numElements
expr_stmt|;
comment|/*   NUM_ESGL_PAGES;  number of esgl pages; configurable */
name|pEsglAllInfo
operator|->
name|EsglPageSize
operator|=
name|tdsaAllShared
operator|->
name|loResource
operator|.
name|loLevelMem
operator|.
name|mem
index|[
name|memRequirement
operator|.
name|count
index|]
operator|.
name|singleElementLength
expr_stmt|;
comment|/* sizeof(agsaEsgl_t) */
name|pEsglAllInfo
operator|->
name|NumFreeEsglPages
operator|=
name|pEsglAllInfo
operator|->
name|NumEsglPages
expr_stmt|;
name|pEsglPagePool
operator|=
name|pEsglAllInfo
operator|->
name|EsglPagePool
expr_stmt|;
name|TI_DBG6
argument_list|(
operator|(
literal|"tdsaEsglInit: pEsglPagePool %p\n"
operator|,
name|pEsglPagePool
operator|)
argument_list|)
expr_stmt|;
name|TI_DBG6
argument_list|(
operator|(
literal|"tdsaEsglInit: tdsaAllShared->loResource.loLevelMem.mem[18].singleElementLength %d\n"
operator|,
name|tdsaAllShared
operator|->
name|loResource
operator|.
name|loLevelMem
operator|.
name|mem
index|[
literal|18
index|]
operator|.
name|singleElementLength
operator|)
argument_list|)
expr_stmt|;
name|TI_DBG6
argument_list|(
operator|(
literal|"tdsaEsglInit: NumEsglPage %d EsglPageSize %d\n"
operator|,
name|pEsglAllInfo
operator|->
name|NumEsglPages
operator|,
name|pEsglAllInfo
operator|->
name|EsglPageSize
operator|)
argument_list|)
expr_stmt|;
comment|/* ?, 128 */
name|TI_DBG6
argument_list|(
operator|(
literal|"tdsaEsglInit: NumFreeEsglPages %d\n"
operator|,
name|pEsglAllInfo
operator|->
name|NumFreeEsglPages
operator|)
argument_list|)
expr_stmt|;
comment|/* initialize the linked lists */
name|TDLIST_INIT_HDR
argument_list|(
operator|&
name|pEsglAllInfo
operator|->
name|freelist
argument_list|)
expr_stmt|;
name|PageVirtAddr
operator|=
name|pEsglAllInfo
operator|->
name|virtPtr
expr_stmt|;
name|PagePhysAddrUpper
operator|=
name|pEsglAllInfo
operator|->
name|physAddrUpper
expr_stmt|;
name|PagePhysAddrLower
operator|=
name|pEsglAllInfo
operator|->
name|physAddrLower
expr_stmt|;
name|PageSizeInBytes
operator|=
name|pEsglAllInfo
operator|->
name|EsglPageSize
expr_stmt|;
name|TI_DBG6
argument_list|(
operator|(
literal|"tdsaEsglInit:  PageSizeInBytes 0x%x\n"
operator|,
name|PageSizeInBytes
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|pageno
operator|=
literal|0
init|;
name|pageno
operator|<
name|pEsglAllInfo
operator|->
name|NumEsglPages
condition|;
name|pageno
operator|++
control|)
block|{
name|pEsglPageInfo
operator|=
operator|&
operator|(
name|pEsglPagePool
operator|->
name|EsglPages
index|[
name|pageno
index|]
operator|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
name|pEsglPageInfo
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|pEsglPageInfo
argument_list|,
name|physAddressUpper
argument_list|)
argument_list|,
name|PagePhysAddrUpper
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
name|pEsglPageInfo
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|pEsglPageInfo
argument_list|,
name|physAddressLower
argument_list|)
argument_list|,
name|PagePhysAddrLower
argument_list|)
expr_stmt|;
name|pEsglPageInfo
operator|->
name|len
operator|=
name|PageSizeInBytes
expr_stmt|;
comment|/* for debugging onlye*/
name|pEsglPageInfo
operator|->
name|id
operator|=
name|pageno
operator|+
literal|123
expr_stmt|;
name|pEsglPageInfo
operator|->
name|agEsgl
operator|=
operator|(
name|agsaEsgl_t
operator|*
operator|)
name|PageVirtAddr
expr_stmt|;
comment|/* for debugging only */
name|TI_DBG6
argument_list|(
operator|(
literal|"tdsaEsglInit: index %d upper 0x%8x lower 0x%8x PageVirtAddr %p\n"
operator|,
name|pageno
operator|,
name|PagePhysAddrUpper
operator|,
name|PagePhysAddrLower
operator|,
name|PageVirtAddr
operator|)
argument_list|)
expr_stmt|;
comment|/* updates addresses */
name|prev_PagePhysAddrLower
operator|=
name|PagePhysAddrLower
expr_stmt|;
name|PagePhysAddrLower
operator|+=
name|pEsglAllInfo
operator|->
name|EsglPageSize
expr_stmt|;
comment|/* if lower wraps around, increment upper */
if|if
condition|(
name|PagePhysAddrLower
operator|<=
name|prev_PagePhysAddrLower
condition|)
block|{
name|PagePhysAddrUpper
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|pageno
operator|==
name|pEsglAllInfo
operator|->
name|NumEsglPages
operator|-
literal|1
condition|)
comment|/* last page */
block|{
name|pEsglPageInfo
operator|->
name|agEsgl
operator|->
name|descriptor
index|[
name|MAX_ESGL_ENTRIES
operator|-
literal|1
index|]
operator|.
name|len
operator|=
literal|0
expr_stmt|;
comment|/* set bit31 to zero */
name|CLEAR_ESGL_EXTEND
argument_list|(
name|pEsglPageInfo
operator|->
name|agEsgl
operator|->
name|descriptor
index|[
name|MAX_ESGL_ENTRIES
operator|-
literal|1
index|]
operator|.
name|extReserved
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* first and so on */
name|pEsglPageInfo
operator|->
name|agEsgl
operator|->
name|descriptor
index|[
name|MAX_ESGL_ENTRIES
operator|-
literal|1
index|]
operator|.
name|sgLower
operator|=
name|PagePhysAddrLower
expr_stmt|;
name|pEsglPageInfo
operator|->
name|agEsgl
operator|->
name|descriptor
index|[
name|MAX_ESGL_ENTRIES
operator|-
literal|1
index|]
operator|.
name|sgUpper
operator|=
name|PagePhysAddrUpper
expr_stmt|;
name|pEsglPageInfo
operator|->
name|agEsgl
operator|->
name|descriptor
index|[
name|MAX_ESGL_ENTRIES
operator|-
literal|1
index|]
operator|.
name|len
operator|=
name|PageSizeInBytes
expr_stmt|;
comment|/* sizeof (agsaEsgl_t)*/
comment|/* set bit31 to one */
name|SET_ESGL_EXTEND
argument_list|(
name|pEsglPageInfo
operator|->
name|agEsgl
operator|->
name|descriptor
index|[
name|MAX_ESGL_ENTRIES
operator|-
literal|1
index|]
operator|.
name|extReserved
argument_list|)
expr_stmt|;
block|}
name|TDLIST_INIT_ELEMENT
argument_list|(
operator|&
name|pEsglPageInfo
operator|->
name|tdlist
argument_list|)
expr_stmt|;
name|tdsaSingleThreadedEnter
argument_list|(
name|tiRoot
argument_list|,
name|TD_ESGL_LOCK
argument_list|)
expr_stmt|;
name|TDLIST_ENQUEUE_AT_TAIL
argument_list|(
operator|&
name|pEsglPageInfo
operator|->
name|tdlist
argument_list|,
operator|&
name|pEsglAllInfo
operator|->
name|freelist
argument_list|)
expr_stmt|;
name|tdsaSingleThreadedLeave
argument_list|(
name|tiRoot
argument_list|,
name|TD_ESGL_LOCK
argument_list|)
expr_stmt|;
name|PageVirtAddr
operator|=
operator|(
name|bit8
operator|*
operator|)
name|PageVirtAddr
operator|+
name|PageSizeInBytes
expr_stmt|;
block|}
comment|/* end for */
ifdef|#
directive|ifdef
name|TD_INTERNAL_DEBUG
comment|/* for debugging only, for keep now */
for|for
control|(
name|pageno
operator|=
literal|0
init|;
name|pageno
operator|<
name|pEsglAllInfo
operator|->
name|NumEsglPages
condition|;
name|pageno
operator|++
control|)
block|{
name|TI_DBG6
argument_list|(
operator|(
literal|"tdsaEsglInit: index %d EsglPages %p\n"
operator|,
name|pageno
operator|,
operator|&
name|pEsglPagePool
operator|->
name|EsglPages
index|[
name|pageno
index|]
operator|)
argument_list|)
expr_stmt|;
name|TI_DBG6
argument_list|(
operator|(
literal|"tdsaEsglInit: nextupper 0x%8x nextlower 0x%8x\n"
operator|,
name|pEsglPagePool
operator|->
name|EsglPages
index|[
name|pageno
index|]
operator|.
name|agEsgl
operator|->
name|nextPageUpper
operator|,
name|pEsglPagePool
operator|->
name|EsglPages
index|[
name|pageno
index|]
operator|.
name|agEsgl
operator|->
name|nextPageLower
operator|)
argument_list|)
expr_stmt|;
block|}
name|TI_DBG6
argument_list|(
operator|(
literal|"tdsaEsglInit:  tdsaEsglPageInfo_t size %d 0x%x\n"
operator|,
sizeof|sizeof
argument_list|(
name|tdsaEsglPageInfo_t
argument_list|)
operator|,
sizeof|sizeof
argument_list|(
name|tdsaEsglPageInfo_t
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|TI_DBG6
argument_list|(
operator|(
literal|"tdsaEsglInit: sizeof(SASG_DESCRIPTOR) %d 0x%x\n"
operator|,
sizeof|sizeof
argument_list|(
name|SASG_DESCRIPTOR
argument_list|)
operator|,
sizeof|sizeof
argument_list|(
name|SASG_DESCRIPTOR
argument_list|)
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
end_function

begin_comment
comment|/***************************************************************************** *! \brief  tdsaGetEsglPages * *  Purpose: This function prepares linked list of ESGL pages from *           the given scatter-gather list. * *  \param tiRoot:       Pointer to root data structure. *  \param EsglListHdr:  pointer to list header where the list needs to be stored. *  \param ptiSgl:       Pointer to scatter-gather list. *  \param virtSgl:      virtual pointer to scatter-gather list. * *  \return None *   *  \note -  *       1. If we are out of ESGL pages, then no pages will be added to the list *          pointed to by EsglListHdr. The list should be empty before calling  *          this function, so that after returning from this function, the  *          function can check for the emptyness of the list and find out if *          any pages were added or not. * *****************************************************************************/
end_comment

begin_function
name|osGLOBAL
name|void
name|tdsaGetEsglPages
parameter_list|(
name|tiRoot_t
modifier|*
name|tiRoot
parameter_list|,
name|tdList_t
modifier|*
name|EsglListHdr
parameter_list|,
name|tiSgl_t
modifier|*
name|ptiSgl
parameter_list|,
name|tiSgl_t
modifier|*
name|virtSgl
parameter_list|)
block|{
name|tdsaRoot_t
modifier|*
name|tdsaRoot
init|=
operator|(
name|tdsaRoot_t
operator|*
operator|)
name|tiRoot
operator|->
name|tdData
decl_stmt|;
name|tdsaContext_t
modifier|*
name|tdsaAllShared
init|=
operator|(
name|tdsaContext_t
operator|*
operator|)
operator|&
name|tdsaRoot
operator|->
name|tdsaAllShared
decl_stmt|;
name|tdsaEsglAllInfo_t
modifier|*
name|pEsglAllInfo
init|=
operator|&
operator|(
name|tdsaAllShared
operator|->
name|EsglAllInfo
operator|)
decl_stmt|;
name|bit32
name|numSgElements
init|=
name|ptiSgl
operator|->
name|len
decl_stmt|;
name|bit32
name|numEntriesPerPage
init|=
name|MAX_ESGL_ENTRIES
decl_stmt|;
name|bit32
name|numPagesRequired
init|=
operator|(
operator|(
name|numSgElements
operator|-
literal|1
operator|)
operator|/
name|numEntriesPerPage
operator|)
operator|+
literal|1
decl_stmt|;
name|bit32
name|i
decl_stmt|,
name|j
decl_stmt|;
name|tdList_t
modifier|*
name|tdlist_to_fill
decl_stmt|;
name|tdsaEsglPageInfo_t
modifier|*
name|page_to_fill
decl_stmt|;
name|tiSgl_t
modifier|*
name|tmp_tiSgl
init|=
operator|(
name|tiSgl_t
operator|*
operator|)
name|virtSgl
decl_stmt|;
name|agsaSgl_t
modifier|*
name|pDesc
decl_stmt|;
name|agsaEsgl_t
modifier|*
name|agEsgl
decl_stmt|,
modifier|*
name|PrevagEsgl
init|=
name|agNULL
decl_stmt|;
name|TI_DBG6
argument_list|(
operator|(
literal|"tdsaGetEsglPages: start\n"
operator|)
argument_list|)
expr_stmt|;
name|TI_DBG6
argument_list|(
operator|(
literal|"tdsaGetEsglPages: pEsglPagePool %p\n"
operator|,
name|pEsglAllInfo
operator|->
name|EsglPagePool
operator|)
argument_list|)
expr_stmt|;
name|TI_DBG6
argument_list|(
operator|(
literal|"tdsaGetEsglPages:&(pEsglAllInfo->freelist) %p\n"
operator|,
operator|&
name|pEsglAllInfo
operator|->
name|freelist
operator|)
argument_list|)
expr_stmt|;
name|TI_DBG6
argument_list|(
operator|(
literal|"tdsaGetEsglPages: numSgElements %d numEntriesPerPage %d\n"
operator|,
name|numSgElements
operator|,
name|numEntriesPerPage
operator|)
argument_list|)
expr_stmt|;
comment|/* ?,  10 */
name|TI_DBG6
argument_list|(
operator|(
literal|"tdsaGetEsglPages: numPagesRequired %d NumFreeEsglPages %d\n"
operator|,
name|numPagesRequired
operator|,
name|pEsglAllInfo
operator|->
name|NumFreeEsglPages
operator|)
argument_list|)
expr_stmt|;
comment|/* 1, 2 */
name|TI_DBG6
argument_list|(
operator|(
literal|"tdsaGetEsglPages: free Pages %d\n"
operator|,
name|pEsglAllInfo
operator|->
name|NumFreeEsglPages
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|numPagesRequired
operator|>
name|pEsglAllInfo
operator|->
name|NumFreeEsglPages
condition|)
block|{
name|TI_DBG1
argument_list|(
operator|(
literal|"tdsaGetEsglPages:don't have enough freepages. required %d free %d\n"
operator|,
name|numPagesRequired
operator|,
name|pEsglAllInfo
operator|->
name|NumFreeEsglPages
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|tdsaSingleThreadedEnter
argument_list|(
name|tiRoot
argument_list|,
name|TD_ESGL_LOCK
argument_list|)
expr_stmt|;
name|pEsglAllInfo
operator|->
name|NumFreeEsglPages
operator|-=
name|numPagesRequired
expr_stmt|;
name|tdsaSingleThreadedLeave
argument_list|(
name|tiRoot
argument_list|,
name|TD_ESGL_LOCK
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TD_INTERNAL_DEBUG
comment|/* for debugging only */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
comment|/* remove one page from freelist */
name|tdsaSingleThreadedEnter
argument_list|(
name|tiRoot
argument_list|,
name|TD_ESGL_LOCK
argument_list|)
expr_stmt|;
name|TDLIST_DEQUEUE_FROM_HEAD
argument_list|(
operator|&
name|tdlist_to_fill
argument_list|,
operator|&
name|pEsglAllInfo
operator|->
name|freelist
argument_list|)
expr_stmt|;
name|tdsaSingleThreadedLeave
argument_list|(
name|tiRoot
argument_list|,
name|TD_ESGL_LOCK
argument_list|)
expr_stmt|;
comment|/* get the pointer to the page from list pointer */
name|page_to_fill
operator|=
name|TDLIST_OBJECT_BASE
argument_list|(
name|tdsaEsglPageInfo_t
argument_list|,
name|tdlist
argument_list|,
name|tdlist_to_fill
argument_list|)
expr_stmt|;
comment|/* for debugging */
name|TI_DBG6
argument_list|(
operator|(
literal|"tdsaGetEsglPages:page ID %d\n"
operator|,
name|page_to_fill
operator|->
name|id
operator|)
argument_list|)
expr_stmt|;
name|agEsgl
operator|=
name|page_to_fill
operator|->
name|agEsgl
expr_stmt|;
name|pDesc
operator|=
operator|(
name|SASG_DESCRIPTOR
operator|*
operator|)
name|agEsgl
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|numEntriesPerPage
condition|;
name|j
operator|++
control|)
block|{
name|TI_DBG6
argument_list|(
operator|(
literal|"tdsaGetEsglPages: lower %d  upper %d\n"
operator|,
name|pDesc
operator|->
name|sgLower
operator|,
name|pDesc
operator|->
name|sgUpper
operator|)
argument_list|)
expr_stmt|;
name|TI_DBG6
argument_list|(
operator|(
literal|"tdsaGetEsglPages: len %d\n"
operator|,
name|pDesc
operator|->
name|len
operator|)
argument_list|)
expr_stmt|;
name|pDesc
operator|++
expr_stmt|;
block|}
name|TI_DBG6
argument_list|(
operator|(
literal|"tdsaGetEsglPages: next lower %d next upper %d\n"
operator|,
name|agEsgl
operator|->
name|nextPageLower
operator|,
name|agEsgl
operator|->
name|nextPageUpper
operator|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* for debugging only  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numPagesRequired
condition|;
name|i
operator|++
control|)
block|{
comment|/* remove one page from freelist */
name|tdsaSingleThreadedEnter
argument_list|(
name|tiRoot
argument_list|,
name|TD_ESGL_LOCK
argument_list|)
expr_stmt|;
name|TDLIST_DEQUEUE_FROM_HEAD
argument_list|(
operator|&
name|tdlist_to_fill
argument_list|,
operator|&
name|pEsglAllInfo
operator|->
name|freelist
argument_list|)
expr_stmt|;
name|tdsaSingleThreadedLeave
argument_list|(
name|tiRoot
argument_list|,
name|TD_ESGL_LOCK
argument_list|)
expr_stmt|;
comment|/* get the pointer to the page from list pointer */
name|page_to_fill
operator|=
name|TDLIST_OBJECT_BASE
argument_list|(
name|tdsaEsglPageInfo_t
argument_list|,
name|tdlist
argument_list|,
name|tdlist_to_fill
argument_list|)
expr_stmt|;
comment|/* for debugging */
name|TI_DBG6
argument_list|(
operator|(
literal|"tdsaGetEsglPages:page ID %d\n"
operator|,
name|page_to_fill
operator|->
name|id
operator|)
argument_list|)
expr_stmt|;
name|agEsgl
operator|=
name|page_to_fill
operator|->
name|agEsgl
expr_stmt|;
name|pDesc
operator|=
operator|(
name|agsaSgl_t
operator|*
operator|)
name|agEsgl
expr_stmt|;
comment|/*       adjust next page's address in the followings so that       the last entry must be (0,0,0)     */
if|if
condition|(
name|i
operator|==
name|numPagesRequired
operator|-
literal|1
condition|)
comment|/* only one page of last page */
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|numSgElements
condition|;
name|j
operator|++
control|)
block|{
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
name|pDesc
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|pDesc
argument_list|,
name|sgLower
argument_list|)
argument_list|,
name|tmp_tiSgl
operator|->
name|lower
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
name|pDesc
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|pDesc
argument_list|,
name|sgUpper
argument_list|)
argument_list|,
name|tmp_tiSgl
operator|->
name|upper
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
name|pDesc
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|pDesc
argument_list|,
name|len
argument_list|)
argument_list|,
name|tmp_tiSgl
operator|->
name|len
argument_list|)
expr_stmt|;
name|CLEAR_ESGL_EXTEND
argument_list|(
name|pDesc
operator|->
name|extReserved
argument_list|)
expr_stmt|;
name|pDesc
operator|++
expr_stmt|;
name|tmp_tiSgl
operator|++
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
name|numSgElements
init|;
name|j
operator|<
name|numEntriesPerPage
condition|;
name|j
operator|++
control|)
block|{
comment|/* left over(unused) in the page */
name|pDesc
operator|->
name|sgLower
operator|=
literal|0x0
expr_stmt|;
name|pDesc
operator|->
name|sgUpper
operator|=
literal|0x0
expr_stmt|;
name|pDesc
operator|->
name|len
operator|=
literal|0x0
expr_stmt|;
name|CLEAR_ESGL_EXTEND
argument_list|(
name|pDesc
operator|->
name|extReserved
argument_list|)
expr_stmt|;
name|pDesc
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* in case of muliple pages, first and later, except one page only or last page */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|numEntriesPerPage
operator|-
literal|1
condition|;
name|j
operator|++
control|)
comment|/* else */
block|{
comment|/* do this till (last - 1) */
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
name|pDesc
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|pDesc
argument_list|,
name|sgLower
argument_list|)
argument_list|,
name|tmp_tiSgl
operator|->
name|lower
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
name|pDesc
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|pDesc
argument_list|,
name|sgUpper
argument_list|)
argument_list|,
name|tmp_tiSgl
operator|->
name|upper
argument_list|)
expr_stmt|;
name|OSSA_WRITE_LE_32
argument_list|(
name|agRoot
argument_list|,
name|pDesc
argument_list|,
name|OSSA_OFFSET_OF
argument_list|(
name|pDesc
argument_list|,
name|len
argument_list|)
argument_list|,
name|tmp_tiSgl
operator|->
name|len
argument_list|)
expr_stmt|;
name|CLEAR_ESGL_EXTEND
argument_list|(
name|pDesc
operator|->
name|extReserved
argument_list|)
expr_stmt|;
name|pDesc
operator|++
expr_stmt|;
name|tmp_tiSgl
operator|++
expr_stmt|;
block|}
name|numSgElements
operator|-=
operator|(
name|numEntriesPerPage
operator|-
literal|1
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|PrevagEsgl
operator|!=
name|agNULL
condition|)
block|{
comment|/* subsequent pages (second or later pages) */
name|PrevagEsgl
operator|->
name|descriptor
index|[
name|MAX_ESGL_ENTRIES
operator|-
literal|1
index|]
operator|.
name|sgLower
operator|=
name|page_to_fill
operator|->
name|physAddressLower
expr_stmt|;
name|PrevagEsgl
operator|->
name|descriptor
index|[
name|MAX_ESGL_ENTRIES
operator|-
literal|1
index|]
operator|.
name|sgUpper
operator|=
name|page_to_fill
operator|->
name|physAddressUpper
expr_stmt|;
name|PrevagEsgl
operator|->
name|descriptor
index|[
name|MAX_ESGL_ENTRIES
operator|-
literal|1
index|]
operator|.
name|len
operator|=
name|numSgElements
expr_stmt|;
comment|/* set bit31 to one */
name|SET_ESGL_EXTEND
argument_list|(
name|PrevagEsgl
operator|->
name|descriptor
index|[
name|MAX_ESGL_ENTRIES
operator|-
literal|1
index|]
operator|.
name|extReserved
argument_list|)
expr_stmt|;
block|}
name|PrevagEsgl
operator|=
name|agEsgl
expr_stmt|;
comment|/* put ESGL onto the EsglListHdr */
name|tdsaSingleThreadedEnter
argument_list|(
name|tiRoot
argument_list|,
name|TD_ESGL_LOCK
argument_list|)
expr_stmt|;
name|TDLIST_ENQUEUE_AT_TAIL
argument_list|(
name|tdlist_to_fill
argument_list|,
name|EsglListHdr
argument_list|)
expr_stmt|;
name|tdsaSingleThreadedLeave
argument_list|(
name|tiRoot
argument_list|,
name|TD_ESGL_LOCK
argument_list|)
expr_stmt|;
block|}
comment|/* end for */
return|return;
block|}
end_function

begin_comment
comment|/***************************************************************************** *! \brief  tdsaFreeEsglPages * *  Purpose: This function frees the ESGL pages pointed to by EsglListHdr *           and puts them back onto the free list. * *  \param  tiRoot:       Pointer to root data structure. *  \param  EsglListHdr:  pointer to list header where the pages to be freed *                        are stored. * *  \return:     None *   *  \note - *   1. This function removes all the pages from the list until the list  *      empty and chains them at the end of the free list. *****************************************************************************/
end_comment

begin_function
name|osGLOBAL
name|void
name|tdsaFreeEsglPages
parameter_list|(
name|tiRoot_t
modifier|*
name|tiRoot
parameter_list|,
name|tdList_t
modifier|*
name|EsglListHdr
parameter_list|)
block|{
name|tdsaRoot_t
modifier|*
name|tdsaRoot
init|=
operator|(
name|tdsaRoot_t
operator|*
operator|)
name|tiRoot
operator|->
name|tdData
decl_stmt|;
name|tdsaContext_t
modifier|*
name|tdsaAllShared
init|=
operator|(
name|tdsaContext_t
operator|*
operator|)
operator|&
name|tdsaRoot
operator|->
name|tdsaAllShared
decl_stmt|;
name|tdsaEsglAllInfo_t
modifier|*
name|pEsglAllInfo
init|=
operator|(
name|tdsaEsglAllInfo_t
operator|*
operator|)
operator|&
operator|(
name|tdsaAllShared
operator|->
name|EsglAllInfo
operator|)
decl_stmt|;
name|tdList_t
modifier|*
name|tdlist_to_free
decl_stmt|;
name|TI_DBG6
argument_list|(
operator|(
literal|"tdsaFreeEsglPages: start\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tiRoot
operator|==
name|agNULL
condition|)
block|{
name|TI_DBG1
argument_list|(
operator|(
literal|"tdsaFreeEsglPages: tiRoot is NULL\n"
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|EsglListHdr
operator|==
name|agNULL
condition|)
block|{
name|TI_DBG1
argument_list|(
operator|(
literal|"tdsaFreeEsglPages: EsglListHdr is NULL\n"
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|TI_DBG6
argument_list|(
operator|(
literal|"tdsaFreeEsglPages: EsglListHdr %p\n"
operator|,
name|EsglListHdr
operator|)
argument_list|)
expr_stmt|;
name|tdsaSingleThreadedEnter
argument_list|(
name|tiRoot
argument_list|,
name|TD_ESGL_LOCK
argument_list|)
expr_stmt|;
while|while
condition|(
name|TDLIST_NOT_EMPTY
argument_list|(
name|EsglListHdr
argument_list|)
condition|)
block|{
name|TDLIST_DEQUEUE_FROM_HEAD
argument_list|(
operator|&
name|tdlist_to_free
argument_list|,
name|EsglListHdr
argument_list|)
expr_stmt|;
name|TDLIST_ENQUEUE_AT_TAIL
argument_list|(
name|tdlist_to_free
argument_list|,
operator|&
name|pEsglAllInfo
operator|->
name|freelist
argument_list|)
expr_stmt|;
name|pEsglAllInfo
operator|->
name|NumFreeEsglPages
operator|++
expr_stmt|;
block|}
name|tdsaSingleThreadedLeave
argument_list|(
name|tiRoot
argument_list|,
name|TD_ESGL_LOCK
argument_list|)
expr_stmt|;
name|TI_DBG6
argument_list|(
operator|(
literal|"tdsaFreeEsglPages: NumFreeEsglPages  %d\n"
operator|,
name|pEsglAllInfo
operator|->
name|NumFreeEsglPages
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/***************************************************************************** *! \brief  tdsaGetEsglPagesInfo * *  Purpose: This function gets the information about the size of ESGL pages *           and number pages to be configured. * *  \param tiRoot:     Pointer to root data structure. *  \param pPageSize:  pointer to bit32 where pagesize information is to be *                     stored *  \param pNumPages:  Pointer to bit32 where number of pages information is *                     to be stored * *  \return:     None * *  \note - * *****************************************************************************/
end_comment

begin_function
name|osGLOBAL
name|void
name|tdsaGetEsglPagesInfo
parameter_list|(
name|tiRoot_t
modifier|*
name|tiRoot
parameter_list|,
name|bit32
modifier|*
name|pPageSize
parameter_list|,
name|bit32
modifier|*
name|pNumPages
parameter_list|)
block|{
name|char
modifier|*
name|buffer
decl_stmt|;
name|bit32
name|buffLen
decl_stmt|;
name|bit32
name|lenRecv
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|pLastUsedChar
init|=
name|agNULL
decl_stmt|;
name|char
name|globalStr
index|[]
init|=
literal|"Global"
decl_stmt|;
name|char
name|SwParmsStr
index|[]
init|=
literal|"ESGLParms"
decl_stmt|;
name|char
name|tmpBuffer
index|[
name|DEFAULT_KEY_BUFFER_SIZE
index|]
decl_stmt|;
comment|/* default value, defined in tdsatypes.h */
name|bit32
name|NumEsglPages
init|=
name|NUM_ESGL_PAGES
decl_stmt|;
name|TI_DBG6
argument_list|(
operator|(
literal|"tdsaGetEsglPagesInfo: start \n"
operator|)
argument_list|)
expr_stmt|;
comment|/*     calls ostiGetTransportParam which parses the configuration file to get     parameters.   */
name|buffer
operator|=
name|tmpBuffer
expr_stmt|;
name|buffLen
operator|=
sizeof|sizeof
argument_list|(
name|tmpBuffer
argument_list|)
expr_stmt|;
name|osti_memset
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
name|buffLen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ostiGetTransportParam
argument_list|(
name|tiRoot
argument_list|,
name|globalStr
argument_list|,
comment|/* key */
name|SwParmsStr
argument_list|,
comment|/* subkey1 */
name|agNULL
argument_list|,
comment|/* subkey2 */
name|agNULL
argument_list|,
name|agNULL
argument_list|,
name|agNULL
argument_list|,
comment|/* subkey5 */
literal|"NumESGLPg"
argument_list|,
comment|/* valueName */
name|buffer
argument_list|,
name|buffLen
argument_list|,
operator|&
name|lenRecv
argument_list|)
operator|==
name|tiSuccess
operator|)
operator|&&
operator|(
name|lenRecv
operator|!=
literal|0
operator|)
condition|)
block|{
name|NumEsglPages
operator|=
name|osti_strtoul
argument_list|(
name|buffer
argument_list|,
operator|&
name|pLastUsedChar
argument_list|,
literal|10
argument_list|)
expr_stmt|;
block|}
name|osti_memset
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
name|buffLen
argument_list|)
expr_stmt|;
name|lenRecv
operator|=
literal|0
expr_stmt|;
name|TI_DBG6
argument_list|(
operator|(
literal|"tdsaGetEsglPagesInfo: esgl page number %d\n"
operator|,
name|NumEsglPages
operator|)
argument_list|)
expr_stmt|;
operator|*
name|pPageSize
operator|=
name|ESGL_PAGES_SIZE
expr_stmt|;
comment|/* sizeof(agsaEsgl_t); defined in tdsatypes.h */
operator|*
name|pNumPages
operator|=
name|NumEsglPages
expr_stmt|;
return|return;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

