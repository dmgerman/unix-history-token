begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************************* *Copyright (c) 2014 PMC-Sierra, Inc.  All rights reserved.  * *Redistribution and use in source and binary forms, with or without modification, are permitted provided  *that the following conditions are met:  *1. Redistributions of source code must retain the above copyright notice, this list of conditions and the *following disclaimer.  *2. Redistributions in binary form must reproduce the above copyright notice,  *this list of conditions and the following disclaimer in the documentation and/or other materials provided *with the distribution.  * *THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR IMPLIED  *WARRANTIES,INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS *FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE *FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  *NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR  *BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  *LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  *SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE * * $FreeBSD$ * *******************************************************************************/
end_comment

begin_comment
comment|/******************************************************************************* ** ** Version Control Information: ** **  $Revision: 113920 $ **  $Author: mcleanda $ **  $Date: 2012-05-08 11:30:44 -0700 (Tue, 08 May 2012) $ **  $Id: lxencrypt.c 113920 2012-05-08 18:30:44Z mcleanda $ ** *******************************************************************************/
end_comment

begin_include
include|#
directive|include
file|<dev/pms/RefTisa/tisa/sassata/common/tdioctl.h>
end_include

begin_include
include|#
directive|include
file|<dev/pms/RefTisa/tisa/api/titypes.h>
end_include

begin_include
include|#
directive|include
file|<dev/pms/freebsd/driver/common/lxencrypt.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<vm/uma.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|ENCRYPT_ENHANCE
end_ifdef

begin_decl_stmt
specifier|static
name|atomic_t
name|ioerr_queue_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/****************************************************************************** careful_write():  Purpose: Parameters: Return: Note: ******************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|careful_write
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|max
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
specifier|static
name|char
name|s
index|[
name|PAGE_SIZE
index|]
decl_stmt|;
comment|/* Assumes serialization */
name|va_list
name|args
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|offset
operator|>
name|max
condition|)
return|return
literal|0
return|;
name|s
index|[
name|PAGE_SIZE
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|i
operator|=
name|vsnprintf
argument_list|(
name|s
argument_list|,
name|PAGE_SIZE
operator|-
literal|1
argument_list|,
name|fmt
argument_list|,
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|offset
operator|+
name|i
operator|)
operator|>
name|max
condition|)
return|return
literal|0
return|;
name|memcpy
argument_list|(
name|buf
operator|+
name|offset
argument_list|,
name|s
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
return|return
name|i
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************** set_dek_table_entry():  Purpose: Parameters: Return: Note: ******************************************************************************/
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|set_dek_table_entry
parameter_list|(
name|struct
name|device
modifier|*
name|dev
parameter_list|,
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|,
name|dek_table_e
name|table
parameter_list|)
block|{
name|int
name|index
decl_stmt|;
name|struct
name|Scsi_Host
modifier|*
name|shost
init|=
name|class_to_shost
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|agtiapi_softc
modifier|*
name|pCard
init|=
operator|(
expr|struct
name|agtiapi_softc
operator|*
operator|)
name|shost
operator|->
name|hostdata
decl_stmt|;
comment|/* Check permissions */
if|if
condition|(
operator|!
name|capable
argument_list|(
name|CAP_SYS_ADMIN
argument_list|)
condition|)
return|return
operator|-
name|EACCES
return|;
if|if
condition|(
operator|!
name|pCard
operator|->
name|encrypt
condition|)
return|return
operator|-
name|EINVAL
return|;
if|if
condition|(
name|table
operator|!=
name|DEK_TABLE_0
operator|&&
name|table
operator|!=
name|DEK_TABLE_1
condition|)
return|return
operator|-
name|EINVAL
return|;
name|sscanf
argument_list|(
name|buf
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|>=
literal|0
operator|&&
name|index
operator|<
name|DEK_MAX_TABLE_ITEMS
condition|)
block|{
name|pCard
operator|->
name|dek_index
index|[
name|table
index|]
operator|=
name|index
expr_stmt|;
return|return
name|strlen
argument_list|(
name|buf
argument_list|)
return|;
block|}
return|return
operator|-
name|EINVAL
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************** set_dek_table_entry0():  Purpose: Parameters: Return: Note: ******************************************************************************/
end_comment

begin_function
name|ssize_t
name|set_dek_table_entry0
parameter_list|(
name|struct
name|device
modifier|*
name|dev
parameter_list|,
name|struct
name|device_attribute
modifier|*
name|attr
parameter_list|,
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
return|return
name|set_dek_table_entry
argument_list|(
name|dev
argument_list|,
name|buf
argument_list|,
name|len
argument_list|,
name|DEK_TABLE_0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************** set_dek_table_entry1():  Purpose: Parameters: Return: Note: ******************************************************************************/
end_comment

begin_function
name|ssize_t
name|set_dek_table_entry1
parameter_list|(
name|struct
name|device
modifier|*
name|dev
parameter_list|,
name|struct
name|device_attribute
modifier|*
name|attr
parameter_list|,
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
return|return
name|set_dek_table_entry
argument_list|(
name|dev
argument_list|,
name|buf
argument_list|,
name|len
argument_list|,
name|DEK_TABLE_1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************** show_dek_table_entry():  Purpose: Parameters: Return: Note: ******************************************************************************/
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|show_dek_table_entry
parameter_list|(
name|struct
name|device
modifier|*
name|dev
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|unsigned
name|int
name|table
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|,
name|j
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|struct
name|Scsi_Host
modifier|*
name|sh
init|=
name|class_to_shost
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|ag_card_t
modifier|*
name|pCard
init|=
operator|(
name|ag_card_t
operator|*
operator|)
name|sh
operator|->
name|hostdata
decl_stmt|;
name|ag_card_info_t
modifier|*
name|pCardInfo
init|=
name|pCard
operator|->
name|pCardInfo
decl_stmt|;
name|ag_resource_info_t
modifier|*
name|pRscInfo
init|=
operator|&
name|pCardInfo
operator|->
name|tiRscInfo
decl_stmt|;
name|tiEncryptDekBlob_t
modifier|*
name|pDekTable
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|pCard
operator|->
name|encrypt
condition|)
return|return
operator|-
name|EINVAL
return|;
if|if
condition|(
name|table
operator|==
name|DEK_TABLE_0
condition|)
name|pDekTable
operator|=
name|pRscInfo
operator|->
name|tiLoLevelResource
operator|.
name|loLevelMem
operator|.
name|mem
index|[
name|DEK_MEM_INDEX_1
index|]
operator|.
name|virtPtr
expr_stmt|;
elseif|else
if|if
condition|(
name|table
operator|==
name|DEK_TABLE_1
condition|)
name|pDekTable
operator|=
name|pRscInfo
operator|->
name|tiLoLevelResource
operator|.
name|loLevelMem
operator|.
name|mem
index|[
name|DEK_MEM_INDEX_2
index|]
operator|.
name|virtPtr
expr_stmt|;
if|if
condition|(
name|pDekTable
operator|==
name|NULL
condition|)
return|return
operator|-
name|EINVAL
return|;
if|if
condition|(
name|pCard
operator|->
name|dek_index
index|[
name|table
index|]
operator|>=
literal|0
operator|||
name|pCard
operator|->
name|dek_index
index|[
name|table
index|]
operator|<
name|DEK_MAX_TABLE_ITEMS
condition|)
block|{
name|i
operator|+=
name|careful_write
argument_list|(
name|buf
argument_list|,
name|i
argument_list|,
name|PAGE_SIZE
argument_list|,
literal|"%4d: "
argument_list|,
name|pCard
operator|->
name|dek_index
index|[
name|table
index|]
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|pDekTable
index|[
name|pCard
operator|->
name|dek_index
index|[
name|table
index|]
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
sizeof|sizeof
argument_list|(
name|tiEncryptDekBlob_t
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
name|i
operator|+=
name|careful_write
argument_list|(
name|buf
argument_list|,
name|i
argument_list|,
name|PAGE_SIZE
argument_list|,
literal|"%02x"
argument_list|,
name|p
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
name|i
operator|+=
name|careful_write
argument_list|(
name|buf
argument_list|,
name|i
argument_list|,
name|PAGE_SIZE
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|i
operator|+=
name|careful_write
argument_list|(
name|buf
argument_list|,
name|i
argument_list|,
name|PAGE_SIZE
argument_list|,
literal|"Bad DEK index %d; range: 0 - %d\n"
argument_list|,
name|pCard
operator|->
name|dek_index
index|[
name|table
index|]
argument_list|,
name|DEK_MAX_TABLE_ITEMS
argument_list|)
expr_stmt|;
block|}
comment|/* BUG if we return more than a single page of data */
comment|//BUG_ON(i> PAGE_SIZE);
if|if
condition|(
name|i
operator|>
name|PAGE_SIZE
condition|)
name|i
operator|=
name|PAGE_SIZE
expr_stmt|;
return|return
name|i
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************** show_dek_table_entry0():  Purpose: Parameters: Return: Note: ******************************************************************************/
end_comment

begin_function
name|ssize_t
name|show_dek_table_entry0
parameter_list|(
name|struct
name|device
modifier|*
name|dev
parameter_list|,
name|struct
name|device_attribute
modifier|*
name|attr
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|)
block|{
return|return
name|show_dek_table_entry
argument_list|(
name|dev
argument_list|,
name|buf
argument_list|,
name|DEK_TABLE_0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************** show_dek_table_entry1():  Purpose: Parameters: Return: Note: ******************************************************************************/
end_comment

begin_function
name|ssize_t
name|show_dek_table_entry1
parameter_list|(
name|struct
name|device
modifier|*
name|dev
parameter_list|,
name|struct
name|device_attribute
modifier|*
name|attr
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|)
block|{
return|return
name|show_dek_table_entry
argument_list|(
name|dev
argument_list|,
name|buf
argument_list|,
name|DEK_TABLE_1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************** show_kek_table():  Purpose: Parameters: Return: Note: ******************************************************************************/
end_comment

begin_function
name|ssize_t
name|show_kek_table
parameter_list|(
name|struct
name|device
modifier|*
name|dev
parameter_list|,
name|struct
name|device_attribute
modifier|*
name|attr
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|,
name|j
decl_stmt|,
name|kek_index
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|struct
name|Scsi_Host
modifier|*
name|sh
init|=
name|class_to_shost
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|ag_card_t
modifier|*
name|pCard
init|=
operator|(
name|ag_card_t
operator|*
operator|)
name|sh
operator|->
name|hostdata
decl_stmt|;
if|if
condition|(
operator|!
name|pCard
operator|->
name|encrypt
condition|)
return|return
operator|-
name|EINVAL
return|;
for|for
control|(
name|kek_index
operator|=
literal|0
init|;
name|kek_index
operator|<
name|KEK_TABLE_MAX_ENTRY
condition|;
name|kek_index
operator|++
control|)
block|{
name|i
operator|+=
name|careful_write
argument_list|(
name|buf
argument_list|,
name|i
argument_list|,
name|PAGE_SIZE
argument_list|,
literal|" %4d: %08x "
argument_list|,
name|kek_index
argument_list|,
name|pCard
operator|->
name|kek_table
index|[
name|kek_index
index|]
operator|.
name|wrapperIndex
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|pCard
operator|->
name|kek_table
index|[
name|kek_index
index|]
operator|.
name|kekBlob
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
sizeof|sizeof
argument_list|(
name|tiEncryptKekBlob_t
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
name|i
operator|+=
name|careful_write
argument_list|(
name|buf
argument_list|,
name|i
argument_list|,
name|PAGE_SIZE
argument_list|,
literal|"%02x"
argument_list|,
name|p
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
name|i
operator|+=
name|careful_write
argument_list|(
name|buf
argument_list|,
name|i
argument_list|,
name|PAGE_SIZE
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|i
operator|+=
name|careful_write
argument_list|(
name|buf
argument_list|,
name|i
argument_list|,
name|PAGE_SIZE
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* BUG if we return more than a single page of data */
comment|//BUG_ON(i> PAGE_SIZE);
if|if
condition|(
name|i
operator|>
name|PAGE_SIZE
condition|)
name|i
operator|=
name|PAGE_SIZE
expr_stmt|;
return|return
name|i
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************** show_dek_kek_map():  Purpose: Parameters: Return: Note: ******************************************************************************/
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|show_dek_kek_map
parameter_list|(
name|struct
name|device
modifier|*
name|dev
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|unsigned
name|int
name|table
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|,
name|dek_index
decl_stmt|;
name|struct
name|Scsi_Host
modifier|*
name|sh
init|=
name|class_to_shost
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|ag_card_t
modifier|*
name|pCard
init|=
operator|(
name|ag_card_t
operator|*
operator|)
name|sh
operator|->
name|hostdata
decl_stmt|;
if|if
condition|(
operator|!
name|pCard
operator|->
name|encrypt
condition|)
return|return
operator|-
name|EINVAL
return|;
if|if
condition|(
name|table
operator|!=
name|DEK_TABLE_0
operator|&&
name|table
operator|!=
name|DEK_TABLE_1
condition|)
return|return
operator|-
name|EINVAL
return|;
name|i
operator|+=
name|careful_write
argument_list|(
name|buf
argument_list|,
name|i
argument_list|,
name|PAGE_SIZE
argument_list|,
literal|"Table %d\n"
argument_list|,
name|table
argument_list|)
expr_stmt|;
name|i
operator|+=
name|careful_write
argument_list|(
name|buf
argument_list|,
name|i
argument_list|,
name|PAGE_SIZE
argument_list|,
literal|"=======\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|dek_index
operator|=
literal|0
init|;
name|dek_index
operator|<
name|DEK_MAX_TABLE_ITEMS
condition|;
name|dek_index
operator|++
control|)
block|{
name|i
operator|+=
name|careful_write
argument_list|(
name|buf
argument_list|,
name|i
argument_list|,
name|PAGE_SIZE
argument_list|,
literal|" %4d: %08x\n"
argument_list|,
name|dek_index
argument_list|,
name|pCard
operator|->
name|dek_kek_map
index|[
name|table
index|]
index|[
name|dek_index
index|]
operator|.
name|kekIndex
argument_list|)
expr_stmt|;
block|}
name|i
operator|+=
name|sprintf
argument_list|(
name|buf
operator|+
name|i
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* BUG if we return more than a single page of data */
comment|//BUG_ON(i> PAGE_SIZE);
if|if
condition|(
name|i
operator|>
name|PAGE_SIZE
condition|)
name|i
operator|=
name|PAGE_SIZE
expr_stmt|;
return|return
name|i
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************** show_dek_kek_map0():  Purpose: Parameters: Return: Note: ******************************************************************************/
end_comment

begin_function
name|ssize_t
name|show_dek_kek_map0
parameter_list|(
name|struct
name|device
modifier|*
name|dev
parameter_list|,
name|struct
name|device_attribute
modifier|*
name|attr
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|)
block|{
return|return
name|show_dek_kek_map
argument_list|(
name|dev
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************** show_dek_kek_map1():  Purpose: Parameters: Return: Note: ******************************************************************************/
end_comment

begin_function
name|ssize_t
name|show_dek_kek_map1
parameter_list|(
name|struct
name|device
modifier|*
name|dev
parameter_list|,
name|struct
name|device_attribute
modifier|*
name|attr
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|)
block|{
return|return
name|show_dek_kek_map
argument_list|(
name|dev
argument_list|,
name|buf
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************** show_target_dek_map():  Purpose: Parameters: Return: Note: ******************************************************************************/
end_comment

begin_function
name|ssize_t
name|show_target_dek_map
parameter_list|(
name|struct
name|device
modifier|*
name|dev
parameter_list|,
name|struct
name|device_attribute
modifier|*
name|attr
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|chan
decl_stmt|,
name|device
decl_stmt|,
name|lun
init|=
literal|0
decl_stmt|;
name|ag_encrypt_map_t
modifier|*
name|p
decl_stmt|;
name|struct
name|list_head
modifier|*
name|lh
decl_stmt|;
name|struct
name|Scsi_Host
modifier|*
name|sh
init|=
name|class_to_shost
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|ag_card_t
modifier|*
name|pCard
init|=
operator|(
name|ag_card_t
operator|*
operator|)
name|sh
operator|->
name|hostdata
decl_stmt|;
if|if
condition|(
operator|!
name|pCard
operator|->
name|encrypt
condition|)
return|return
operator|-
name|EINVAL
return|;
for|for
control|(
name|chan
operator|=
literal|0
init|;
name|chan
operator|<=
name|AGTIAPI_MAX_CHANNEL_NUM
condition|;
name|chan
operator|++
control|)
block|{
for|for
control|(
name|device
operator|=
literal|0
init|;
name|device
operator|<
name|pCard
operator|->
name|devDiscover
condition|;
name|device
operator|++
control|)
block|{
ifdef|#
directive|ifdef
name|REPORT_ALL_LUNS
for|for
control|(
name|lun
operator|=
literal|0
init|;
name|lun
operator|<
name|AGTIAPI_MAX_LUN
condition|;
name|lun
operator|++
control|)
block|{
endif|#
directive|endif
name|lh
operator|=
name|MAP_TABLE_ENTRY
argument_list|(
name|pCard
argument_list|,
name|chan
argument_list|,
name|device
argument_list|,
name|lun
argument_list|)
expr_stmt|;
if|if
condition|(
name|lh
condition|)
block|{
name|list_for_each_entry
argument_list|(
argument|p
argument_list|,
argument|lh
argument_list|,
argument|list
argument_list|)
block|{
if|if
condition|(
name|p
operator|->
name|dekIndex
operator|!=
name|DEK_INDEX_INVALID
condition|)
name|i
operator|+=
name|careful_write
argument_list|(
name|buf
argument_list|,
name|i
argument_list|,
name|PAGE_SIZE
argument_list|,
literal|" %u:%u:%u: %x %8x %8x %16lx %16lx %08x:%08x %1x\n"
argument_list|,
name|chan
argument_list|,
name|device
argument_list|,
name|lun
argument_list|,
name|p
operator|->
name|dekTable
argument_list|,
name|p
operator|->
name|dekIndex
argument_list|,
name|p
operator|->
name|kekIndex
argument_list|,
name|p
operator|->
name|lbaMin
argument_list|,
name|p
operator|->
name|lbaMax
argument_list|,
name|p
operator|->
name|keyTag
index|[
literal|1
index|]
argument_list|,
name|p
operator|->
name|keyTag
index|[
literal|0
index|]
argument_list|,
name|p
operator|->
name|keyTagCheck
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|REPORT_ALL_LUNS
block|}
endif|#
directive|endif
block|}
block|}
if|if
condition|(
name|i
operator|>
name|PAGE_SIZE
condition|)
name|i
operator|=
name|PAGE_SIZE
expr_stmt|;
return|return
name|i
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************** agtiapi_AddDek():  Purpose: Parameters: Return: Note: ******************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|agtiapi_AddDek
parameter_list|(
name|ag_card_t
modifier|*
name|pCard
parameter_list|,
name|bit32
name|dek_table
parameter_list|,
name|bit32
name|dek_index
parameter_list|,
name|bit32
name|blob_format
parameter_list|,
name|bit32
name|entry_sz
parameter_list|,
name|tiEncryptDekBlob_t
modifier|*
name|dek_blob
parameter_list|,
name|U32_64
modifier|*
name|addr
parameter_list|)
block|{
name|ag_resource_info_t
modifier|*
name|pRscInfo
init|=
operator|&
name|pCard
operator|->
name|pCardInfo
operator|->
name|tiRscInfo
decl_stmt|;
name|tiEncryptDekBlob_t
modifier|*
name|pDekTable
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|dek_index
operator|>=
name|DEK_MAX_TABLE_ITEMS
condition|)
block|{
name|printf
argument_list|(
literal|"%s: Bad dek index 0x%x (MAX: 0x%x).\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|dek_index
argument_list|,
name|DEK_MAX_TABLE_ITEMS
argument_list|)
expr_stmt|;
return|return
operator|-
name|E_DEK_INDEX
return|;
block|}
switch|switch
condition|(
name|dek_table
condition|)
block|{
case|case
name|DEK_TABLE_0
case|:
name|pDekTable
operator|=
name|pRscInfo
operator|->
name|tiLoLevelResource
operator|.
name|loLevelMem
operator|.
name|mem
index|[
name|DEK_MEM_INDEX_1
index|]
operator|.
name|virtPtr
expr_stmt|;
break|break;
case|case
name|DEK_TABLE_1
case|:
name|pDekTable
operator|=
name|pRscInfo
operator|->
name|tiLoLevelResource
operator|.
name|loLevelMem
operator|.
name|mem
index|[
name|DEK_MEM_INDEX_2
index|]
operator|.
name|virtPtr
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"%s: Unknown dek table %d\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|dek_table
argument_list|)
expr_stmt|;
return|return
operator|-
name|E_DEK_TABLE
return|;
block|}
ifdef|#
directive|ifdef
name|__VMKLNX__
operator|*
name|addr
operator|=
operator|(
name|U32_64
operator|)
name|__pa
argument_list|(
operator|&
name|pDekTable
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
else|#
directive|else
operator|*
name|addr
operator|=
operator|(
name|U32_64
operator|)
name|virt_to_phys
argument_list|(
operator|&
name|pDekTable
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|p
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|pDekTable
index|[
literal|0
index|]
operator|+
operator|(
name|dek_index
operator|*
name|pCard
operator|->
name|dek_size
operator|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: Base: %p, Index: %08x, Virt: %p Size: %d\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|pDekTable
argument_list|,
name|dek_index
argument_list|,
operator|&
name|pDekTable
index|[
name|dek_index
index|]
argument_list|,
name|pCard
operator|->
name|dek_size
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|p
argument_list|,
name|dek_blob
argument_list|,
name|pCard
operator|->
name|dek_size
argument_list|)
expr_stmt|;
name|wmb
argument_list|()
expr_stmt|;
comment|/* Flush entry */
name|ostiCacheFlush
argument_list|(
operator|&
name|pCard
operator|->
name|tiRoot
argument_list|,
name|NULL
argument_list|,
name|p
argument_list|,
name|pCard
operator|->
name|dek_size
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************** agtiapi_MapDekKek():  Purpose: Parameters: Return: Note: ******************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|agtiapi_MapDekKek
parameter_list|(
name|ag_card_t
modifier|*
name|pCard
parameter_list|,
name|bit32
name|dek_table
parameter_list|,
name|bit32
name|dek_index
parameter_list|,
name|bit32
name|kek_index
parameter_list|)
block|{
if|if
condition|(
name|dek_index
operator|>=
name|DEK_MAX_TABLE_ITEMS
condition|)
block|{
name|printf
argument_list|(
literal|"%s: Bad dek index 0x%x (MAX: 0x%x).\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|dek_index
argument_list|,
name|DEK_MAX_TABLE_ITEMS
argument_list|)
expr_stmt|;
return|return
operator|-
name|E_DEK_INDEX
return|;
block|}
if|if
condition|(
name|dek_table
operator|>=
name|DEK_MAX_TABLES
condition|)
block|{
name|printf
argument_list|(
literal|"%s: Bad dek table.\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
return|return
operator|-
name|E_DEK_TABLE
return|;
block|}
if|if
condition|(
name|kek_index
operator|>=
name|KEK_TABLE_MAX_ENTRY
condition|)
block|{
name|printf
argument_list|(
literal|"%s: Bad kek index.\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
return|return
operator|-
name|E_KEK_INDEX
return|;
block|}
name|pCard
operator|->
name|dek_kek_map
index|[
name|dek_table
index|]
index|[
name|dek_index
index|]
operator|.
name|kekIndex
operator|=
name|kek_index
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************** agtiapi_AddKek():  Purpose: Parameters: Return: Note: ******************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|agtiapi_AddKek
parameter_list|(
name|ag_card_t
modifier|*
name|pCard
parameter_list|,
name|bit32
name|kek_index
parameter_list|,
name|bit32
name|wrapper_kek_index
parameter_list|,
name|tiEncryptKekBlob_t
modifier|*
name|kek_blob
parameter_list|)
block|{
if|if
condition|(
name|kek_index
operator|>=
name|KEK_TABLE_MAX_ENTRY
condition|)
block|{
name|printf
argument_list|(
literal|"%s: Bad kek index.\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
return|return
operator|-
name|E_KEK_INDEX
return|;
block|}
if|if
condition|(
name|wrapper_kek_index
operator|>=
name|KEK_TABLE_MAX_ENTRY
condition|)
block|{
name|printf
argument_list|(
literal|"%s: Bad kek wrapper index.\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
return|return
operator|-
name|E_KEK_INDEX
return|;
block|}
name|pCard
operator|->
name|kek_table
index|[
name|kek_index
index|]
operator|.
name|wrapperIndex
operator|=
name|wrapper_kek_index
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|pCard
operator|->
name|kek_table
index|[
name|kek_index
index|]
operator|.
name|kekBlob
argument_list|,
name|kek_blob
argument_list|,
sizeof|sizeof
argument_list|(
name|tiEncryptKekBlob_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************** agtiapi_MapDek():  Purpose: Parameters: Return: Note: ******************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|agtiapi_MapDek
parameter_list|(
name|ag_card_t
modifier|*
name|pCard
parameter_list|,
name|EncryptDeviceDekMap_t
modifier|*
name|dek_map
parameter_list|)
block|{
name|int
name|found
init|=
literal|0
decl_stmt|;
name|bit32
name|chan
decl_stmt|,
name|device
decl_stmt|,
name|lun
decl_stmt|;
name|bit32
name|dek_table
decl_stmt|,
name|dek_index
decl_stmt|,
name|kek_index
decl_stmt|;
name|unsigned
name|long
name|long
name|lba_min
decl_stmt|,
name|lba_max
decl_stmt|;
name|ag_encrypt_map_t
modifier|*
name|p
decl_stmt|,
modifier|*
name|n
decl_stmt|;
name|struct
name|list_head
modifier|*
name|lh
decl_stmt|;
name|chan
operator|=
name|dek_map
operator|->
name|channel
expr_stmt|;
name|device
operator|=
name|dek_map
operator|->
name|device
expr_stmt|;
name|lun
operator|=
name|dek_map
operator|->
name|lun
expr_stmt|;
name|lba_min
operator|=
name|dek_map
operator|->
name|dekMapEntry
index|[
literal|0
index|]
operator|.
name|startLBA
expr_stmt|;
name|lba_max
operator|=
name|dek_map
operator|->
name|dekMapEntry
index|[
literal|0
index|]
operator|.
name|endLBA
expr_stmt|;
name|dek_table
operator|=
name|dek_map
operator|->
name|dekMapEntry
index|[
literal|0
index|]
operator|.
name|dek
operator|.
name|dekTable
expr_stmt|;
name|dek_index
operator|=
name|dek_map
operator|->
name|dekMapEntry
index|[
literal|0
index|]
operator|.
name|dek
operator|.
name|dekIndex
expr_stmt|;
comment|/* Sanity check channel, device, lun */
if|if
condition|(
name|chan
operator|>
name|AGTIAPI_MAX_CHANNEL_NUM
condition|)
block|{
name|printf
argument_list|(
literal|"%s: Bad channel %d.\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|chan
argument_list|)
expr_stmt|;
return|return
operator|-
name|E_CHANNEL_INDEX
return|;
block|}
if|if
condition|(
name|device
operator|>=
name|pCard
operator|->
name|devDiscover
condition|)
block|{
name|printf
argument_list|(
literal|"%s: Bad device %d.\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|device
argument_list|)
expr_stmt|;
return|return
operator|-
name|E_DEVICE_INDEX
return|;
block|}
if|if
condition|(
name|lun
operator|>=
name|AGTIAPI_MAX_LUN
condition|)
block|{
name|printf
argument_list|(
literal|"%s: Bad lun %d.\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|lun
argument_list|)
expr_stmt|;
return|return
operator|-
name|E_LUN_INDEX
return|;
block|}
comment|/* Sanity check dek index */
if|if
condition|(
name|dek_index
operator|>=
name|DEK_MAX_TABLE_ITEMS
condition|)
block|{
name|printf
argument_list|(
literal|"%s: Bad dek index 0x%x (MAX: 0x%x).\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|dek_index
argument_list|,
name|DEK_MAX_TABLE_ITEMS
argument_list|)
expr_stmt|;
return|return
operator|-
name|E_DEK_INDEX
return|;
block|}
comment|/* Sanity check dek table */
if|if
condition|(
name|dek_table
operator|>=
name|DEK_MAX_TABLES
condition|)
block|{
name|printf
argument_list|(
literal|"%s: Bad dek table %d.\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|dek_table
argument_list|)
expr_stmt|;
return|return
operator|-
name|E_DEK_TABLE
return|;
block|}
comment|/* Check that lba min and lba max are sane */
if|if
condition|(
name|lba_min
operator|>=
name|lba_max
condition|)
block|{
name|printf
argument_list|(
literal|"%s: Bad lba min and lba max: %llx %llx.\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|lba_min
argument_list|,
name|lba_max
argument_list|)
expr_stmt|;
return|return
operator|-
name|E_LBA_RANGE
return|;
block|}
comment|/* dek_table and dek_index are valid, look up kek */
name|kek_index
operator|=
name|pCard
operator|->
name|dek_kek_map
index|[
name|dek_table
index|]
index|[
name|dek_index
index|]
operator|.
name|kekIndex
expr_stmt|;
name|lh
operator|=
name|MAP_TABLE_ENTRY
argument_list|(
name|pCard
argument_list|,
name|chan
argument_list|,
name|device
argument_list|,
name|lun
argument_list|)
expr_stmt|;
if|if
condition|(
name|dek_map
operator|->
name|dekMapEntry
index|[
literal|0
index|]
operator|.
name|flags
operator|&
name|ENCRYPT_DEK_MAP_ENTRY_CLEAR
condition|)
block|{
comment|/* Delete the entry */
name|found
operator|=
literal|0
expr_stmt|;
name|list_for_each_entry_safe
argument_list|(
argument|p
argument_list|,
argument|n
argument_list|,
argument|lh
argument_list|,
argument|list
argument_list|)
block|{
if|if
condition|(
name|p
operator|->
name|lbaMin
operator|==
name|lba_min
operator|&&
name|p
operator|->
name|lbaMax
operator|==
name|lba_max
operator|&&
name|p
operator|->
name|dekTable
operator|==
name|dek_table
operator|&&
name|p
operator|->
name|dekIndex
operator|==
name|dek_index
operator|&&
name|p
operator|->
name|kekIndex
operator|==
name|kek_index
condition|)
block|{
comment|/* Entry found, unlink and reclaim it */
name|found
operator|=
literal|1
expr_stmt|;
name|list_del
argument_list|(
operator|&
name|p
operator|->
name|list
argument_list|)
expr_stmt|;
name|mempool_free
argument_list|(
name|p
argument_list|,
name|pCard
operator|->
name|map_mempool
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
name|printf
argument_list|(
literal|"%s: Entry %x %x %x %llx %llx not found.\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|dek_table
argument_list|,
name|dek_index
argument_list|,
name|kek_index
argument_list|,
name|lba_min
argument_list|,
name|lba_max
argument_list|)
expr_stmt|;
return|return
operator|-
name|E_NOT_FOUND
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|dek_map
operator|->
name|dekMapEntry
index|[
literal|0
index|]
operator|.
name|flags
operator|&
name|ENCRYPT_DEK_MAP_ENTRY_VALID
condition|)
block|{
comment|/* Add the entry */
name|p
operator|=
operator|(
name|ag_encrypt_map_t
operator|*
operator|)
name|uma_zalloc
argument_list|(
name|pCard
operator|->
name|map_cache
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
comment|//Encryption
if|if
condition|(
operator|!
name|p
condition|)
block|{
name|printf
argument_list|(
literal|"%s: Unable to allocate from memory pool.\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
return|return
operator|-
name|E_MEMPOOL_ALLOC
return|;
block|}
comment|/* Populate it */
name|p
operator|->
name|lbaMin
operator|=
name|lba_min
expr_stmt|;
name|p
operator|->
name|lbaMax
operator|=
name|lba_max
expr_stmt|;
name|p
operator|->
name|dekTable
operator|=
name|dek_table
expr_stmt|;
name|p
operator|->
name|dekIndex
operator|=
name|dek_index
expr_stmt|;
name|p
operator|->
name|kekIndex
operator|=
name|kek_index
expr_stmt|;
name|p
operator|->
name|keyTagCheck
operator|=
name|dek_map
operator|->
name|keytag_check
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|p
operator|->
name|keyTag
argument_list|,
operator|&
name|dek_map
operator|->
name|keytag
argument_list|,
sizeof|sizeof
argument_list|(
name|p
operator|->
name|keyTag
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Test to see if this new mapping overlaps an existing mapping */
name|list_for_each_entry
argument_list|(
argument|n
argument_list|,
argument|lh
argument_list|,
argument|list
argument_list|)
block|{
comment|/*               * Check if the start lba falls in existing range ||              * Check if the end lba falls in existing range   ||              * Check if the start lba of the existing range falls in the new range              */
if|if
condition|(
operator|(
operator|(
name|p
operator|->
name|lbaMin
operator|>=
name|n
operator|->
name|lbaMin
operator|)
operator|&&
operator|(
name|p
operator|->
name|lbaMin
operator|<=
name|n
operator|->
name|lbaMax
operator|)
operator|)
operator|||
operator|(
operator|(
name|p
operator|->
name|lbaMax
operator|>=
name|n
operator|->
name|lbaMin
operator|)
operator|&&
operator|(
name|p
operator|->
name|lbaMax
operator|<=
name|n
operator|->
name|lbaMax
operator|)
operator|)
operator|||
operator|(
operator|(
name|n
operator|->
name|lbaMin
operator|>=
name|p
operator|->
name|lbaMin
operator|)
operator|&&
operator|(
name|n
operator|->
name|lbaMin
operator|<=
name|p
operator|->
name|lbaMax
operator|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s: WARNING: New entry lba range overlap: %llx - %llx vs %llx - %llx.\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|p
operator|->
name|lbaMin
argument_list|,
name|p
operator|->
name|lbaMax
argument_list|,
name|n
operator|->
name|lbaMin
argument_list|,
name|n
operator|->
name|lbaMax
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Link it in to list at the head so it takes precedence */
name|list_add
argument_list|(
operator|&
name|p
operator|->
name|list
argument_list|,
name|lh
argument_list|)
expr_stmt|;
comment|/* TODO: Decide if/how to refcount each dek/kek index used by the mapping */
block|}
else|else
block|{
name|printf
argument_list|(
literal|"%s: Bad flags %08x\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|dek_map
operator|->
name|dekMapEntry
index|[
literal|0
index|]
operator|.
name|flags
argument_list|)
expr_stmt|;
return|return
operator|-
name|E_FLAGS
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HIALEAH_ENCRYPTION
end_ifdef

begin_comment
comment|/****************************************************************************** agtiapi_SetupEncryption():  Purpose: Parameters: Return: Note: ******************************************************************************/
end_comment

begin_function
name|int
name|agtiapi_SetupEncryption
parameter_list|(
name|struct
name|agtiapi_softc
modifier|*
name|pCard
parameter_list|)
block|{
name|tiRoot_t
modifier|*
name|tiRoot
init|=
operator|(
name|tiRoot_t
operator|*
operator|)
operator|&
name|pCard
operator|->
name|tiRoot
decl_stmt|;
name|bit32
name|status
init|=
name|tiSuccess
decl_stmt|;
name|printf
argument_list|(
literal|"agtiapi_SetupEncryption: HIALEAH_ENCRYPTION\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pCard
operator|->
name|encrypt
operator|==
name|agTRUE
condition|)
block|{
name|status
operator|=
name|tiCOMEncryptGetInfo
argument_list|(
name|tiRoot
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"agtiapi_SetupEncryption: HIALEAH_ENCRYPTION tiCOMEncryptGetInfo Status 0x%x\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|1
condition|)
block|{
name|status
operator|=
name|tiCOMEncryptHilSet
argument_list|(
name|tiRoot
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
name|pCard
operator|->
name|encrypt
operator|=
name|agFALSE
expr_stmt|;
name|printf
argument_list|(
literal|"agtiapi_SetupEncryption: HIALEAH_ENCRYPTION not set\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ENCRYPT_ENHANCE
end_ifdef

begin_comment
comment|/****************************************************************************** agtiapi_SetupEncryptionPools():  Purpose: Parameters: Return: Note: ******************************************************************************/
end_comment

begin_function
name|int
name|agtiapi_SetupEncryptionPools
parameter_list|(
name|struct
name|agtiapi_softc
modifier|*
name|pCard
parameter_list|)
block|{
comment|/* Configure encryption memory pool */
name|memset
argument_list|(
name|pCard
operator|->
name|map_cache_name
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|pCard
operator|->
name|map_cache_name
argument_list|)
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|pCard
operator|->
name|map_cache_name
argument_list|,
sizeof|sizeof
argument_list|(
name|pCard
operator|->
name|map_cache_name
argument_list|)
operator|-
literal|1
argument_list|,
literal|"map_cache_%d"
argument_list|,
name|pCard
operator|->
name|cardNo
argument_list|)
expr_stmt|;
comment|//zone allocation
name|pCard
operator|->
name|map_cache
operator|=
name|uma_zcreate
argument_list|(
name|pCard
operator|->
name|map_cache_name
argument_list|,
sizeof|sizeof
argument_list|(
name|ag_encrypt_map_t
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pCard
operator|->
name|map_cache
condition|)
block|{
comment|/*          * This error may be due to an existing cache in the kernel          * from an earlier kmem_cache that wasn't properly freed          */
name|printf
argument_list|(
literal|"Unable to create uma_zcreate cache for encryption map mempool.\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EFAULT
return|;
block|}
name|uma_zone_set_max
argument_list|(
name|pCard
operator|->
name|map_cache
argument_list|,
name|ENCRYPTION_MAP_MEMPOOL_SIZE
argument_list|)
expr_stmt|;
comment|/* Configure encryption IO error pool */
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|pCard
operator|->
name|ioerr_queue
argument_list|)
expr_stmt|;
comment|/*#if (LINUX_VERSION_CODE< KERNEL_VERSION(2,6,34)) // ####     pCard->ioerr_queue_lock = SPIN_LOCK_UNLOCKED; #else */
name|pCard
operator|->
name|ioerr_queue_lock
operator|=
name|AG_SPIN_UNLOCK
argument_list|(
name|pCard
operator|->
name|ioerr_queue_lock
argument_list|)
expr_stmt|;
comment|//#endif
name|memset
argument_list|(
name|pCard
operator|->
name|ioerr_cache_name
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|pCard
operator|->
name|ioerr_cache_name
argument_list|)
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|pCard
operator|->
name|ioerr_cache_name
argument_list|,
sizeof|sizeof
argument_list|(
name|pCard
operator|->
name|ioerr_cache_name
argument_list|)
operator|-
literal|1
argument_list|,
literal|"ioerr_cache_%d"
argument_list|,
name|pCard
operator|->
name|cardNo
argument_list|)
expr_stmt|;
name|pCard
operator|->
name|ioerr_cache
operator|=
name|uma_zcreate
argument_list|(
name|pCard
operator|->
name|ioerr_cache_name
argument_list|,
sizeof|sizeof
argument_list|(
name|ag_encrypt_ioerr_t
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pCard
operator|->
name|ioerr_cache
condition|)
block|{
comment|/*          * This error may be due to an existing cache in the kernel          * from an earlier kmem_cache that wasn't properly freed          */
name|printf
argument_list|(
literal|"Unable to create kmem cache for encryption IO error mempool.\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EFAULT
return|;
block|}
name|uma_zone_set_max
argument_list|(
name|pCard
operator|->
name|ioerr_cache
argument_list|,
name|ENCRYPTION_IO_ERR_MEMPOOL_SIZE
argument_list|)
expr_stmt|;
comment|/* Set cipher mode to something invalid */
name|pCard
operator|->
name|cipher_mode
operator|=
name|CIPHER_MODE_INVALID
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/****************************************************************************** agtiapi_CleanupEncryption():  Purpose: Parameters: Return: Note: ******************************************************************************/
end_comment

begin_function
name|void
name|agtiapi_CleanupEncryption
parameter_list|(
name|struct
name|agtiapi_softc
modifier|*
name|pCard
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|ENCRYPT_ENHANCE
if|if
condition|(
name|pCard
operator|->
name|encrypt_map
condition|)
block|{
name|int
name|chan
decl_stmt|,
name|device
decl_stmt|,
name|lun
decl_stmt|;
name|struct
name|list_head
modifier|*
name|lh
decl_stmt|;
name|ag_encrypt_map_t
modifier|*
name|p
decl_stmt|,
modifier|*
name|n
decl_stmt|;
for|for
control|(
name|chan
operator|=
literal|0
init|;
name|chan
operator|<
operator|(
name|AGTIAPI_MAX_CHANNEL_NUM
operator|+
literal|1
operator|)
condition|;
name|chan
operator|++
control|)
block|{
for|for
control|(
name|device
operator|=
literal|0
init|;
name|device
operator|<
name|pCard
operator|->
name|devDiscover
condition|;
name|device
operator|++
control|)
block|{
for|for
control|(
name|lun
operator|=
literal|0
init|;
name|lun
operator|<
name|AGTIAPI_MAX_LUN
condition|;
name|lun
operator|++
control|)
block|{
name|lh
operator|=
name|MAP_TABLE_ENTRY
argument_list|(
name|pCard
argument_list|,
name|chan
argument_list|,
name|device
argument_list|,
name|lun
argument_list|)
expr_stmt|;
name|list_for_each_entry_safe
argument_list|(
argument|p
argument_list|,
argument|n
argument_list|,
argument|lh
argument_list|,
argument|list
argument_list|)
block|{
comment|//                mempool_free(p, pCard->map_mempool);
block|}
block|}
block|}
block|}
name|vfree
argument_list|(
name|pCard
operator|->
name|encrypt_map
argument_list|)
expr_stmt|;
name|pCard
operator|->
name|encrypt_map
operator|=
name|NULL
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ENCRYPT_ENHANCE
end_ifdef

begin_comment
comment|/****************************************************************************** agtiapi_CleanupEncryptionPools():  Purpose: Parameters: Return: Note: ******************************************************************************/
end_comment

begin_function
name|void
name|agtiapi_CleanupEncryptionPools
parameter_list|(
name|struct
name|agtiapi_softc
modifier|*
name|pCard
parameter_list|)
block|{
name|ag_encrypt_ioerr_t
modifier|*
name|ioerr
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|atomic_set
argument_list|(
operator|&
name|ioerr_queue_count
argument_list|)
expr_stmt|;
comment|/*       * TODO: check "outstanding_encrypted_io_count" for non-zero       *       and free all mempool items prior to destroying pool      */
comment|/* Clean up memory pools */
if|if
condition|(
name|pCard
operator|->
name|map_mempool
condition|)
block|{
name|mempool_destroy
argument_list|(
name|pCard
operator|->
name|map_mempool
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Encryption Map mempool released.\n"
argument_list|)
expr_stmt|;
name|pCard
operator|->
name|map_mempool
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Clean up kmem cache */
if|if
condition|(
name|pCard
operator|->
name|map_cache
condition|)
block|{
name|kmem_cache_destroy
argument_list|(
name|pCard
operator|->
name|map_cache
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Kernel memory cache %s released.\n"
argument_list|,
name|pCard
operator|->
name|map_cache_name
argument_list|)
expr_stmt|;
name|pCard
operator|->
name|map_cache
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Clean up memory pools */
name|list_for_each_entry_safe
argument_list|(
argument|ioerr
argument_list|,
argument|tmp
argument_list|,
argument|&pCard->ioerr_queue
argument_list|,
argument|list
argument_list|)
block|{
name|list_del_init
argument_list|(
operator|&
name|ioerr
operator|->
name|list
argument_list|)
expr_stmt|;
name|mempool_free
argument_list|(
name|ioerr
argument_list|,
name|pCard
operator|->
name|ioerr_mempool
argument_list|)
expr_stmt|;
name|atomic_dec
argument_list|(
operator|&
name|ioerr_queue_count
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pCard
operator|->
name|ioerr_mempool
condition|)
block|{
name|mempool_destroy
argument_list|(
name|pCard
operator|->
name|ioerr_mempool
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Encryption IO Error mempool released.\n"
argument_list|)
expr_stmt|;
name|pCard
operator|->
name|ioerr_mempool
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Clean up kmem cache */
if|if
condition|(
name|pCard
operator|->
name|ioerr_cache
condition|)
block|{
name|kmem_cache_destroy
argument_list|(
name|pCard
operator|->
name|ioerr_cache
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Kernel memory cache %s released.\n"
argument_list|,
name|pCard
operator|->
name|ioerr_cache_name
argument_list|)
expr_stmt|;
name|pCard
operator|->
name|ioerr_cache
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/****************************************************************************** agtiapi_EncryptionIoctl():  Purpose: Parameters: Return: Note: ******************************************************************************/
end_comment

begin_function
name|int
name|agtiapi_EncryptionIoctl
parameter_list|(
name|struct
name|agtiapi_softc
modifier|*
name|pCard
parameter_list|,
name|IoctlEncrypt_t
modifier|*
name|pIoctlPayload
parameter_list|)
block|{
name|int
name|rv
decl_stmt|,
name|rc
init|=
literal|0
decl_stmt|,
name|skip_wait
init|=
literal|0
decl_stmt|;
name|tiRoot_t
modifier|*
name|tiRoot
init|=
operator|(
name|tiRoot_t
operator|*
operator|)
operator|&
name|pCard
operator|->
name|tiRoot
decl_stmt|;
name|IoctlTISAEncrypt_t
modifier|*
name|ioctl_data
init|=
operator|&
name|pIoctlPayload
operator|->
name|body
decl_stmt|;
name|pIoctlPayload
operator|->
name|hdr
operator|.
name|Status
operator|=
name|IOCTL_ERR_STATUS_INVALID_CODE
expr_stmt|;
name|pCard
operator|->
name|ioctl_data
operator|=
operator|(
name|void
operator|*
operator|)
name|ioctl_data
expr_stmt|;
name|init_completion
argument_list|(
operator|&
name|pCard
operator|->
name|ioctl_completion
argument_list|)
expr_stmt|;
comment|/* Check that the system is quiesced */
if|if
condition|(
name|atomic_read
argument_list|(
operator|&
name|outstanding_encrypted_io_count
argument_list|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"%s: WARNING: Attempting encryption management update with outstanding encrypted IOs!\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: Minor %d\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|pIoctlPayload
operator|->
name|hdr
operator|.
name|MinorFunction
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pIoctlPayload
operator|->
name|hdr
operator|.
name|MinorFunction
condition|)
block|{
case|case
name|IOCTL_MN_ENCRYPTION_GET_INFO
case|:
block|{
comment|//IoctlEncryptGetInfo_t *get_info = (IoctlEncryptGetInfo_t *)&ioctl_data->request;
name|rc
operator|=
name|tiCOMEncryptGetInfo
argument_list|(
name|tiRoot
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|IOCTL_MN_ENCRYPTION_SET_MODE
case|:
block|{
name|u32
name|reg_val
init|=
literal|0
decl_stmt|,
name|new_cipher_mode
init|=
literal|0
decl_stmt|;
name|IoctlEncryptSetMode_t
modifier|*
name|set_mode
init|=
operator|(
name|IoctlEncryptSetMode_t
operator|*
operator|)
operator|&
name|ioctl_data
operator|->
name|request
decl_stmt|;
name|printf
argument_list|(
literal|"%s: input %08x\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|set_mode
operator|->
name|securityCipherMode
argument_list|)
expr_stmt|;
comment|/* Set security mode */
if|if
condition|(
name|TI_ENCRYPT_SEC_MODE_FACT_INIT
condition|)
if|if
condition|(
name|set_mode
operator|->
name|securityCipherMode
operator|&
name|TI_ENCRYPT_SEC_MODE_FACT_INIT
condition|)
block|{
name|reg_val
operator||=
name|TI_ENCRYPT_SEC_MODE_FACT_INIT
expr_stmt|;
name|pCard
operator|->
name|dek_size
operator|=
name|DEK_SIZE_PLAIN
expr_stmt|;
block|}
if|if
condition|(
name|set_mode
operator|->
name|securityCipherMode
operator|&
name|TI_ENCRYPT_SEC_MODE_A
condition|)
block|{
name|reg_val
operator||=
name|TI_ENCRYPT_SEC_MODE_A
expr_stmt|;
name|pCard
operator|->
name|dek_size
operator|=
name|DEK_SIZE_ENCRYPT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|set_mode
operator|->
name|securityCipherMode
operator|&
name|TI_ENCRYPT_SEC_MODE_B
condition|)
block|{
name|reg_val
operator||=
name|TI_ENCRYPT_SEC_MODE_B
expr_stmt|;
name|pCard
operator|->
name|dek_size
operator|=
name|DEK_SIZE_ENCRYPT
expr_stmt|;
block|}
comment|/* Set cipher mode */
if|if
condition|(
name|set_mode
operator|->
name|securityCipherMode
operator|&
name|TI_ENCRYPT_ATTRIB_CIPHER_XTS
condition|)
block|{
name|reg_val
operator||=
name|TI_ENCRYPT_ATTRIB_CIPHER_XTS
expr_stmt|;
name|new_cipher_mode
operator|=
name|TI_ENCRYPT_MODE_XTS_AES
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%s: Setting security cipher mode to: 0x%08x\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|reg_val
argument_list|)
expr_stmt|;
name|pCard
operator|->
name|cipher_mode
operator|=
name|new_cipher_mode
expr_stmt|;
name|rc
operator|=
name|tiCOMEncryptSetMode
argument_list|(
name|tiRoot
argument_list|,
name|reg_val
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|IOCTL_MN_ENCRYPTION_KEK_ADD
case|:
block|{
name|tiEncryptKekBlob_t
name|kek_blob
decl_stmt|;
name|IoctlEncryptKekAdd_t
modifier|*
name|kek_add
init|=
operator|(
name|IoctlEncryptKekAdd_t
operator|*
operator|)
operator|&
name|ioctl_data
operator|->
name|request
decl_stmt|;
name|printf
argument_list|(
literal|"%s: Add kek at index 0x%x wrapper 0x%x format 0x%x\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|kek_add
operator|->
name|kekIndex
argument_list|,
name|kek_add
operator|->
name|wrapperKekIndex
argument_list|,
name|kek_add
operator|->
name|blobFormat
argument_list|)
expr_stmt|;
comment|/* Copy kek_blob from user pointer to local buffer */
if|if
condition|(
name|access_ok
argument_list|(
name|VERIFY_READ
argument_list|,
name|kek_add
operator|->
name|EncryptKekBlob
argument_list|,
sizeof|sizeof
argument_list|(
name|kek_blob
argument_list|)
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s: Starting copy from user %p to kernel %p\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|kek_add
operator|->
name|EncryptKekBlob
argument_list|,
operator|&
name|kek_blob
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rv
operator|=
name|copy_from_user
argument_list|(
operator|&
name|kek_blob
argument_list|,
name|kek_add
operator|->
name|EncryptKekBlob
argument_list|,
sizeof|sizeof
argument_list|(
name|kek_blob
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: Copy error, %d left\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|rv
argument_list|)
expr_stmt|;
return|return
name|IOCTL_CALL_FAIL
return|;
block|}
name|rc
operator|=
name|tiCOMEncryptKekAdd
argument_list|(
name|tiRoot
argument_list|,
name|kek_add
operator|->
name|kekIndex
argument_list|,
name|kek_add
operator|->
name|wrapperKekIndex
argument_list|,
name|kek_add
operator|->
name|blobFormat
argument_list|,
operator|&
name|kek_blob
argument_list|)
expr_stmt|;
comment|/* Add kek to local kek table (in case of chip reset) */
if|if
condition|(
name|rc
operator|==
name|tiSuccess
condition|)
block|{
if|if
condition|(
name|agtiapi_AddKek
argument_list|(
name|pCard
argument_list|,
name|kek_add
operator|->
name|kekIndex
argument_list|,
name|kek_add
operator|->
name|wrapperKekIndex
argument_list|,
operator|&
name|kek_blob
argument_list|)
operator|<
literal|0
condition|)
block|{
return|return
name|IOCTL_CALL_FAIL
return|;
block|}
block|}
block|}
else|else
block|{
return|return
name|IOCTL_CALL_FAIL
return|;
block|}
block|}
break|break;
case|case
name|IOCTL_MN_ENCRYPTION_DEK_ADD
case|:
block|{
name|tiEncryptDekBlob_t
name|dek_blob
decl_stmt|;
comment|/* Copied in */
name|IoctlEncryptDekAdd_t
modifier|*
name|dek_add
init|=
operator|(
name|IoctlEncryptDekAdd_t
operator|*
operator|)
operator|&
name|ioctl_data
operator|->
name|request
decl_stmt|;
name|bit32
name|kek_index
init|=
name|dek_add
operator|->
name|kekIndex
decl_stmt|;
name|bit32
name|dek_index
init|=
name|dek_add
operator|->
name|dekIndex
decl_stmt|;
name|bit32
name|dek_table
init|=
name|dek_add
operator|->
name|dekTable
decl_stmt|;
name|bit32
name|blob_format
init|=
name|dek_add
operator|->
name|dekBlobFormat
decl_stmt|;
name|bit32
name|entry_sz
init|=
name|dek_add
operator|->
name|dekTableKeyEntrySize
decl_stmt|;
name|U32_64
name|addr
init|=
literal|0
decl_stmt|;
name|bit32
name|addr_table
index|[
literal|2
index|]
decl_stmt|;
name|memset
argument_list|(
name|addr_table
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|addr_table
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: Add dek at index 0x%x, table %x, kek index %x, blob format %x, entry size %x\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|dek_index
argument_list|,
name|dek_table
argument_list|,
name|kek_index
argument_list|,
name|blob_format
argument_list|,
name|entry_sz
argument_list|)
expr_stmt|;
comment|/* Copy dek_blob from user pointer to local buffer */
if|if
condition|(
name|access_ok
argument_list|(
name|VERIFY_READ
argument_list|,
name|dek_add
operator|->
name|dekBlob
argument_list|,
sizeof|sizeof
argument_list|(
name|dek_blob
argument_list|)
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s: Starting copy from user %p to kernel %p\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|dek_add
operator|->
name|dekBlob
argument_list|,
operator|&
name|dek_blob
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rv
operator|=
name|copy_from_user
argument_list|(
operator|&
name|dek_blob
argument_list|,
name|dek_add
operator|->
name|dekBlob
argument_list|,
sizeof|sizeof
argument_list|(
name|dek_blob
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: Copy error, %d left\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|rv
argument_list|)
expr_stmt|;
return|return
name|IOCTL_CALL_FAIL
return|;
block|}
comment|/* Add DEK to local table */
if|if
condition|(
name|agtiapi_AddDek
argument_list|(
name|pCard
argument_list|,
name|dek_table
argument_list|,
name|dek_index
argument_list|,
name|blob_format
argument_list|,
name|entry_sz
argument_list|,
operator|&
name|dek_blob
argument_list|,
operator|&
name|addr
argument_list|)
operator|<
literal|0
condition|)
block|{
return|return
name|IOCTL_CALL_FAIL
return|;
block|}
name|memcpy
argument_list|(
name|addr_table
argument_list|,
operator|&
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Add DEK-KEK association in local table */
if|if
condition|(
name|agtiapi_MapDekKek
argument_list|(
name|pCard
argument_list|,
name|dek_table
argument_list|,
name|dek_index
argument_list|,
name|kek_index
argument_list|)
operator|<
literal|0
condition|)
block|{
return|return
name|IOCTL_CALL_FAIL
return|;
block|}
comment|/* Push DEK to chip */
name|rc
operator|=
name|tiCOMEncryptDekAdd
argument_list|(
name|tiRoot
argument_list|,
name|kek_index
argument_list|,
name|dek_table
argument_list|,
name|addr_table
index|[
literal|1
index|]
argument_list|,
name|addr_table
index|[
literal|0
index|]
argument_list|,
name|dek_index
argument_list|,
literal|1
argument_list|,
name|blob_format
argument_list|,
name|entry_sz
argument_list|)
expr_stmt|;
block|}
else|else
block|{
return|return
name|IOCTL_CALL_FAIL
return|;
block|}
block|}
break|break;
case|case
name|IOCTL_MN_ENCRYPTION_DEK_INVALID
case|:
block|{
name|IoctlEncryptDekInvalidate_t
modifier|*
name|dek_to_invalidate
init|=
operator|(
name|IoctlEncryptDekInvalidate_t
operator|*
operator|)
operator|&
name|ioctl_data
operator|->
name|request
decl_stmt|;
name|printf
argument_list|(
literal|"%s: Invalidating dek at index 0x%x, table %x\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|dek_to_invalidate
operator|->
name|dek
operator|.
name|dekIndex
argument_list|,
name|dek_to_invalidate
operator|->
name|dek
operator|.
name|dekTable
argument_list|)
expr_stmt|;
name|rc
operator|=
name|tiCOMEncryptDekInvalidate
argument_list|(
name|tiRoot
argument_list|,
name|dek_to_invalidate
operator|->
name|dek
operator|.
name|dekTable
argument_list|,
name|dek_to_invalidate
operator|->
name|dek
operator|.
name|dekIndex
argument_list|)
expr_stmt|;
comment|/* TODO: What to do in local tables? Mark it? */
block|}
break|break;
case|case
name|IOCTL_MN_ENCRYPTION_KEK_NVRAM
case|:
block|{
name|rc
operator|=
name|tiError
expr_stmt|;
block|}
break|break;
case|case
name|IOCTL_MN_ENCRYPTION_DEK_ASSIGN
case|:
block|{
name|IoctlEncryptDekMapTable_t
modifier|*
name|p_dek_map
init|=
operator|(
name|IoctlEncryptDekMapTable_t
operator|*
operator|)
operator|&
name|ioctl_data
operator|->
name|request
decl_stmt|;
comment|/* Fill in host */
name|p_dek_map
operator|->
name|dekMap
index|[
literal|0
index|]
operator|.
name|host
operator|=
operator|(
name|bit32
operator|)
name|pCard
operator|->
name|pHost
operator|->
name|host_no
expr_stmt|;
name|printf
argument_list|(
literal|"%s: Host %u: Mapping %u:%u:%u (%llx to %llx) to dek at index 0x%x, table %x, keytag %08x:%08x\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|p_dek_map
operator|->
name|dekMap
index|[
literal|0
index|]
operator|.
name|host
argument_list|,
name|p_dek_map
operator|->
name|dekMap
index|[
literal|0
index|]
operator|.
name|channel
argument_list|,
name|p_dek_map
operator|->
name|dekMap
index|[
literal|0
index|]
operator|.
name|device
argument_list|,
name|p_dek_map
operator|->
name|dekMap
index|[
literal|0
index|]
operator|.
name|lun
argument_list|,
name|p_dek_map
operator|->
name|dekMap
index|[
literal|0
index|]
operator|.
name|dekMapEntry
index|[
literal|0
index|]
operator|.
name|startLBA
argument_list|,
name|p_dek_map
operator|->
name|dekMap
index|[
literal|0
index|]
operator|.
name|dekMapEntry
index|[
literal|0
index|]
operator|.
name|endLBA
argument_list|,
name|p_dek_map
operator|->
name|dekMap
index|[
literal|0
index|]
operator|.
name|dekMapEntry
index|[
literal|0
index|]
operator|.
name|dek
operator|.
name|dekIndex
argument_list|,
name|p_dek_map
operator|->
name|dekMap
index|[
literal|0
index|]
operator|.
name|dekMapEntry
index|[
literal|0
index|]
operator|.
name|dek
operator|.
name|dekTable
argument_list|,
name|p_dek_map
operator|->
name|dekMap
index|[
literal|0
index|]
operator|.
name|keytag
index|[
literal|1
index|]
argument_list|,
name|p_dek_map
operator|->
name|dekMap
index|[
literal|0
index|]
operator|.
name|keytag
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* Create a mapping in local tables */
if|if
condition|(
name|agtiapi_MapDek
argument_list|(
name|pCard
argument_list|,
operator|&
name|p_dek_map
operator|->
name|dekMap
index|[
literal|0
index|]
argument_list|)
operator|<
literal|0
condition|)
block|{
name|pIoctlPayload
operator|->
name|hdr
operator|.
name|Status
operator|=
name|IOCTL_ERR_STATUS_INVALID_CODE
expr_stmt|;
return|return
name|IOCTL_CALL_FAIL
return|;
block|}
name|rc
operator|=
name|tiSuccess
expr_stmt|;
name|skip_wait
operator|=
literal|1
expr_stmt|;
name|ioctl_data
operator|->
name|encryptFunction
operator|=
name|encryptSetDekMap
expr_stmt|;
name|ioctl_data
operator|->
name|status
operator|=
name|tiSuccess
expr_stmt|;
name|ioctl_data
operator|->
name|subEvent
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|IOCTL_MN_ENCRYPTION_ERROR_QUERY
case|:
block|{
name|unsigned
name|long
name|flags
decl_stmt|,
name|i
decl_stmt|,
name|query_flag
decl_stmt|;
name|ag_encrypt_ioerr_t
modifier|*
name|ioerr
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|IoctlEncryptErrorQuery_t
modifier|*
name|perr
init|=
operator|(
name|IoctlEncryptErrorQuery_t
operator|*
operator|)
operator|&
name|ioctl_data
operator|->
name|request
decl_stmt|;
name|printf
argument_list|(
literal|"%s: query flag %x\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|perr
operator|->
name|query_flag
argument_list|)
expr_stmt|;
name|query_flag
operator|=
name|perr
operator|->
name|query_flag
expr_stmt|;
comment|/* initialize */
name|memset
argument_list|(
name|perr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|IoctlEncryptErrorQuery_t
argument_list|)
argument_list|)
expr_stmt|;
name|error_query_restart
label|:
comment|/* Take spinlock */
comment|//  spin_lock_irqsave(&pCard->ioerr_queue_lock, flags);
name|AG_SPIN_LOCK_IRQ
argument_list|(
operator|&
name|pCard
operator|->
name|ioerr_queue_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* Walk list */
name|i
operator|=
literal|0
expr_stmt|;
name|list_for_each_entry_safe
argument_list|(
argument|ioerr
argument_list|,
argument|tmp
argument_list|,
argument|&pCard->ioerr_queue
argument_list|,
argument|list
argument_list|)
block|{
if|if
condition|(
name|i
operator|>=
literal|32
condition|)
break|break;
name|perr
operator|->
name|valid_mask
operator||=
operator|(
literal|1
operator|<<
name|i
operator|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|perr
operator|->
name|error
index|[
name|i
index|]
argument_list|,
operator|&
name|ioerr
operator|->
name|ioerr
argument_list|,
sizeof|sizeof
argument_list|(
name|IoctlEncryptIOError_t
argument_list|)
argument_list|)
expr_stmt|;
name|list_del_init
argument_list|(
operator|&
name|ioerr
operator|->
name|list
argument_list|)
expr_stmt|;
name|mempool_free
argument_list|(
name|ioerr
argument_list|,
name|pCard
operator|->
name|ioerr_mempool
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
name|atomic_dec
argument_list|(
operator|&
name|ioerr_queue_count
argument_list|)
expr_stmt|;
block|}
comment|/* Release spinlock */
comment|//   spin_unlock_irqrestore(&pCard->ioerr_queue_lock, flags);
name|AG_SPIN_UNLOCK_IRQ
argument_list|(
operator|&
name|pCard
operator|->
name|ioerr_queue_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|//for test
if|if
condition|(
operator|!
name|perr
operator|->
name|valid_mask
condition|)
block|{
comment|/* No encryption IO error events, check flags to see if blocking wait OK */
if|if
condition|(
name|query_flag
operator|==
name|ERROR_QUERY_FLAG_BLOCK
condition|)
block|{
if|if
condition|(
name|wait_event_interruptible
argument_list|(
name|ioerr_waitq
argument_list|,
operator|(
name|atomic_read
argument_list|(
operator|&
name|ioerr_queue_count
argument_list|)
operator|)
argument_list|)
condition|)
block|{
comment|/* Awoken by signal */
return|return
name|IOCTL_CALL_FAIL
return|;
block|}
else|else
block|{
comment|/* Awoken by IO error */
goto|goto
name|error_query_restart
goto|;
block|}
block|}
block|}
name|rc
operator|=
name|tiSuccess
expr_stmt|;
name|skip_wait
operator|=
literal|1
expr_stmt|;
name|ioctl_data
operator|->
name|encryptFunction
operator|=
name|encryptErrorQuery
expr_stmt|;
name|ioctl_data
operator|->
name|status
operator|=
name|tiSuccess
expr_stmt|;
name|ioctl_data
operator|->
name|subEvent
operator|=
literal|0
expr_stmt|;
block|}
break|break;
default|default:
name|printf
argument_list|(
literal|"%s: Unrecognized Minor Function %d\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|pIoctlPayload
operator|->
name|hdr
operator|.
name|MinorFunction
argument_list|)
expr_stmt|;
name|pIoctlPayload
operator|->
name|hdr
operator|.
name|Status
operator|=
name|IOCTL_ERR_STATUS_INVALID_CODE
expr_stmt|;
return|return
name|IOCTL_CALL_FAIL
return|;
break|break;
block|}
comment|/* Demux rc */
switch|switch
condition|(
name|rc
condition|)
block|{
case|case
name|tiSuccess
case|:
if|if
condition|(
operator|!
name|skip_wait
condition|)
name|wait_for_completion
argument_list|(
operator|&
name|pCard
operator|->
name|ioctl_completion
argument_list|)
expr_stmt|;
comment|/* Maybe: wait_for_completion_timeout() */
name|pIoctlPayload
operator|->
name|hdr
operator|.
name|Status
operator|=
name|ioctl_data
operator|->
name|status
expr_stmt|;
break|break;
case|case
name|tiNotSupported
case|:
name|pIoctlPayload
operator|->
name|hdr
operator|.
name|Status
operator|=
name|IOCTL_ERR_STATUS_NOT_SUPPORTED
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"%s: Status: %d\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|rc
argument_list|)
expr_stmt|;
name|pIoctlPayload
operator|->
name|hdr
operator|.
name|Status
operator|=
name|IOCTL_ERR_STATUS_INVALID_CODE
expr_stmt|;
break|break;
block|}
name|printf
argument_list|(
literal|"%s: Encryption ioctl %d successful.\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|pIoctlPayload
operator|->
name|hdr
operator|.
name|MinorFunction
argument_list|)
expr_stmt|;
return|return
name|IOCTL_CALL_SUCCESS
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/****************************************************************************** agtiapi_SetupEncryptedIO():  Purpose: Parameters: Return: Note: ******************************************************************************/
end_comment

begin_function
name|int
name|agtiapi_SetupEncryptedIO
parameter_list|(
name|struct
name|agtiapi_softc
modifier|*
name|pCard
parameter_list|,
name|ccb_t
modifier|*
name|pccb
parameter_list|,
name|unsigned
name|long
name|long
name|block
parameter_list|)
block|{
name|pCard
operator|->
name|cipher_mode
operator|=
name|TI_ENCRYPT_ATTRIB_CIPHER_XTS
expr_stmt|;
comment|/* Check that cipher mode is set properly */
if|if
condition|(
name|pCard
operator|->
name|cipher_mode
operator|==
name|CIPHER_MODE_INVALID
condition|)
block|{
name|printf
argument_list|(
literal|"%s: Cipher mode not yet set.\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
return|return
operator|-
name|E_BAD_CIPHER_MODE
return|;
block|}
name|memset
argument_list|(
operator|&
operator|(
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|Encrypt
operator|)
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|Encrypt
argument_list|)
argument_list|)
expr_stmt|;
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|Encrypt
operator|.
name|keyTagCheck
operator|=
name|FALSE
expr_stmt|;
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|Encrypt
operator|.
name|encryptMode
operator|=
name|pCard
operator|->
name|cipher_mode
expr_stmt|;
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|Encrypt
operator|.
name|tweakVal_W0
operator|=
name|block
expr_stmt|;
if|if
condition|(
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|scsiCmnd
operator|.
name|cdb
index|[
literal|0
index|]
operator|==
name|READ_16
operator|||
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|scsiCmnd
operator|.
name|cdb
index|[
literal|0
index|]
operator|==
name|WRITE_16
condition|)
block|{
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|Encrypt
operator|.
name|tweakVal_W0
operator|=
operator|(
operator|(
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|scsiCmnd
operator|.
name|cdb
index|[
literal|6
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|scsiCmnd
operator|.
name|cdb
index|[
literal|7
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|scsiCmnd
operator|.
name|cdb
index|[
literal|8
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|scsiCmnd
operator|.
name|cdb
index|[
literal|9
index|]
operator|)
operator|)
expr_stmt|;
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|Encrypt
operator|.
name|tweakVal_W1
operator|=
operator|(
operator|(
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|scsiCmnd
operator|.
name|cdb
index|[
literal|2
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|scsiCmnd
operator|.
name|cdb
index|[
literal|3
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|scsiCmnd
operator|.
name|cdb
index|[
literal|4
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|scsiCmnd
operator|.
name|cdb
index|[
literal|5
index|]
operator|)
operator|)
expr_stmt|;
block|}
comment|/* Mark IO as valid encrypted IO */
name|pccb
operator|->
name|flags
operator||=
name|ENCRYPTED_IO
expr_stmt|;
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|flags
operator|=
name|TI_SCSI_INITIATOR_ENCRYPT
expr_stmt|;
comment|/* Bump refcount (atomic) */
name|atomic_inc
argument_list|(
operator|&
name|outstanding_encrypted_io_count
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************** agtiapi_CleanupEncryptedIO():  Purpose: Parameters: Return: Note: ******************************************************************************/
end_comment

begin_function
name|void
name|agtiapi_CleanupEncryptedIO
parameter_list|(
name|struct
name|agtiapi_softc
modifier|*
name|pCard
parameter_list|,
name|ccb_t
modifier|*
name|pccb
parameter_list|)
block|{
if|if
condition|(
operator|(
name|pccb
operator|->
name|flags
operator|&
name|ENCRYPTED_IO
operator|)
condition|)
block|{
comment|/* Decrement refcount */
name|atomic_dec
argument_list|(
operator|&
name|outstanding_encrypted_io_count
argument_list|)
expr_stmt|;
block|}
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|flags
operator|&=
operator|~
name|TI_SCSI_INITIATOR_ENCRYPT
expr_stmt|;
name|pccb
operator|->
name|flags
operator|&=
operator|~
name|ENCRYPTED_IO
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ENCRYPT_ENHANCE
end_ifdef

begin_comment
comment|/****************************************************************************** agtiapi_HandleEncryptedIOFailure():  Purpose: Parameters: Return: Note: ******************************************************************************/
end_comment

begin_function
name|void
name|agtiapi_HandleEncryptedIOFailure
parameter_list|(
name|ag_device_t
modifier|*
name|pDev
parameter_list|,
name|ccb_t
modifier|*
name|pccb
parameter_list|)
block|{
name|unsigned
name|long
name|flags
decl_stmt|,
name|qdepth
decl_stmt|;
name|struct
name|scsi_cmnd
modifier|*
name|cmd
decl_stmt|;
name|ag_encrypt_ioerr_t
modifier|*
name|perr
decl_stmt|;
name|ag_card_t
modifier|*
name|pCard
decl_stmt|;
name|cmd
operator|=
name|pccb
operator|->
name|cmd
expr_stmt|;
if|if
condition|(
operator|!
name|cmd
condition|)
block|{
name|printf
argument_list|(
literal|"%s: Malformed pccb %p.\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|pccb
argument_list|)
expr_stmt|;
return|return;
block|}
name|pCard
operator|=
name|pDev
operator|->
name|pCard
expr_stmt|;
comment|/* Sanity check */
if|if
condition|(
operator|!
operator|(
name|pccb
operator|->
name|flags
operator|&
name|ENCRYPTED_IO
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s: Skipping IO %lx: Not Encrypted.\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|cmd
operator|->
name|serial_number
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Check queue depth against max */
name|qdepth
operator|=
name|atomic_read
argument_list|(
operator|&
name|ioerr_queue_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|qdepth
operator|>=
name|IOERR_QUEUE_DEPTH_MAX
condition|)
block|{
name|printf
argument_list|(
literal|"%s: Not queueing IO error due to queue full: %lu entries.\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|qdepth
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Get a container for the ag_encrypt_ioerr_t item from the mempool */
comment|//    perr = mempool_alloc(pCard->ioerr_mempool, GFP_ATOMIC);
name|p
operator|=
operator|(
name|ag_encrypt_map_t
operator|*
operator|)
name|uma_zalloc
argument_list|(
name|pCard
operator|->
name|map_cache
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
comment|//Encryption
if|if
condition|(
operator|!
name|perr
condition|)
block|{
name|printf
argument_list|(
literal|"%s: Mempool allocation failure.\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Populate ag_encrypt_ioerr_t container */
name|perr
operator|->
name|ioerr
operator|.
name|error_id
operator|=
name|cmd
operator|->
name|serial_number
expr_stmt|;
name|perr
operator|->
name|ioerr
operator|.
name|timestamp
operator|=
name|cmd
operator|->
name|jiffies_at_alloc
expr_stmt|;
name|perr
operator|->
name|ioerr
operator|.
name|host
operator|=
operator|(
name|unsigned
name|int
operator|)
name|cmd
operator|->
name|device
operator|->
name|host
operator|->
name|host_no
expr_stmt|;
name|perr
operator|->
name|ioerr
operator|.
name|channel
operator|=
name|cmd
operator|->
name|device
operator|->
name|channel
expr_stmt|;
name|perr
operator|->
name|ioerr
operator|.
name|device
operator|=
name|cmd
operator|->
name|device
operator|->
name|id
expr_stmt|;
name|perr
operator|->
name|ioerr
operator|.
name|lun
operator|=
name|cmd
operator|->
name|device
operator|->
name|lun
expr_stmt|;
name|perr
operator|->
name|ioerr
operator|.
name|scsi_cmd
operator|=
operator|(
name|unsigned
name|int
operator|)
name|cmd
operator|->
name|cmnd
index|[
literal|0
index|]
expr_stmt|;
name|perr
operator|->
name|ioerr
operator|.
name|dek_index
operator|=
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|Encrypt
operator|.
name|dekInfo
operator|.
name|dekIndex
expr_stmt|;
name|perr
operator|->
name|ioerr
operator|.
name|dek_table
operator|=
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|Encrypt
operator|.
name|dekInfo
operator|.
name|dekTable
expr_stmt|;
name|perr
operator|->
name|ioerr
operator|.
name|kek_index
operator|=
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|Encrypt
operator|.
name|kekIndex
expr_stmt|;
name|perr
operator|->
name|ioerr
operator|.
name|keytag_check
operator|=
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|Encrypt
operator|.
name|keyTagCheck
expr_stmt|;
name|perr
operator|->
name|ioerr
operator|.
name|encrypt_mode
operator|=
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|Encrypt
operator|.
name|encryptMode
expr_stmt|;
name|perr
operator|->
name|ioerr
operator|.
name|keytag
index|[
literal|0
index|]
operator|=
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|Encrypt
operator|.
name|keyTag_W0
expr_stmt|;
name|perr
operator|->
name|ioerr
operator|.
name|keytag
index|[
literal|1
index|]
operator|=
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|Encrypt
operator|.
name|keyTag_W1
expr_stmt|;
switch|switch
condition|(
name|pccb
operator|->
name|scsiStatus
condition|)
block|{
case|case
name|tiDetailDekKeyCacheMiss
case|:
case|case
name|tiDetailDekIVMismatch
case|:
name|perr
operator|->
name|ioerr
operator|.
name|error_type
operator|=
name|pccb
operator|->
name|scsiStatus
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"%s: Unrecognized encrypted IO completion error status: %d\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|pccb
operator|->
name|scsiStatus
argument_list|)
expr_stmt|;
name|perr
operator|->
name|ioerr
operator|.
name|error_type
operator|=
literal|0xffffffff
expr_stmt|;
break|break;
block|}
comment|/* Link IO err into queue */
name|AG_SPIN_LOCK_IRQ
argument_list|(
operator|&
name|pCard
operator|->
name|ioerr_queue_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|list_add_tail
argument_list|(
operator|&
name|perr
operator|->
name|list
argument_list|,
operator|&
name|pCard
operator|->
name|ioerr_queue
argument_list|)
expr_stmt|;
name|AG_SPIN_UNLOCK_IRQ
argument_list|(
operator|&
name|pCard
operator|->
name|ioerr_queue_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* Notify any wait queue waiters that an IO error has occurred */
name|atomic_inc
argument_list|(
operator|&
name|ioerr_queue_count
argument_list|)
expr_stmt|;
name|wake_up_interruptible
argument_list|(
operator|&
name|ioerr_waitq
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

end_unit

