begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************************* ** *Copyright (c) 2014 PMC-Sierra, Inc.  All rights reserved.   * *Redistribution and use in source and binary forms, with or without modification, are permitted provided  *that the following conditions are met:  *1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.  *2. Redistributions in binary form must reproduce the above copyright notice,  *this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.  * *THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, * *INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  *ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  *SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  *OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, *WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF *THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE ** *******************************************************************************/
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<dev/pms/config.h>
end_include

begin_define
define|#
directive|define
name|MAJOR_REVISION
value|1
end_define

begin_define
define|#
directive|define
name|MINOR_REVISION
value|3
end_define

begin_define
define|#
directive|define
name|BUILD_REVISION
value|10800
end_define

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_comment
comment|// defines used in kernel.h
end_comment

begin_include
include|#
directive|include
file|<sys/ioccom.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_comment
comment|// types used in module initialization
end_comment

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_comment
comment|// cdevsw struct
end_comment

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_comment
comment|// uio struct
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_comment
comment|// structs, prototypes for pci bus stuff
end_comment

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_comment
comment|// 1. for vtophys
end_comment

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_comment
comment|// 2. for vtophys
end_comment

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_comment
comment|// For pci_get macros
end_comment

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/sema.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<machine/atomic.h>
end_include

begin_include
include|#
directive|include
file|<sys/libkern.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_ccb.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_debug.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_periph.h>
end_include

begin_comment
comment|//
end_comment

begin_include
include|#
directive|include
file|<cam/cam_sim.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_xpt_sim.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_all.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_message.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<dev/pms/RefTisa/tisa/api/tiapi.h>
end_include

begin_include
include|#
directive|include
file|<dev/pms/freebsd/driver/ini/src/agtiapi.h>
end_include

begin_include
include|#
directive|include
file|<dev/pms/freebsd/driver/ini/src/agtiproto.h>
end_include

begin_include
include|#
directive|include
file|<dev/pms/RefTisa/tisa/api/ostiapi.h>
end_include

begin_include
include|#
directive|include
file|<dev/pms/RefTisa/tisa/sassata/common/tdsatypes.h>
end_include

begin_include
include|#
directive|include
file|<dev/pms/freebsd/driver/common/lxencrypt.h>
end_include

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_PMC_MCCB
argument_list|,
literal|"CCB List"
argument_list|,
literal|"CCB List for PMCS driver"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_PMC_MSTL
argument_list|,
literal|"STLock malloc"
argument_list|,
literal|"allocated in agtiapi_attach as memory for lock use"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_PMC_MDVT
argument_list|,
literal|"ag_device_t malloc"
argument_list|,
literal|"allocated in agtiapi_attach as mem for ag_device_t pDevList"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_PMC_MPRT
argument_list|,
literal|"ag_portal_data_t malloc"
argument_list|,
literal|"allocated in agtiapi_attach as mem for *pPortalData"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_PMC_MDEV
argument_list|,
literal|"tiDeviceHandle_t * malloc"
argument_list|,
literal|"allocated in agtiapi_GetDevHandle as local mem for **agDev"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_PMC_MFLG
argument_list|,
literal|"lDevFlags * malloc"
argument_list|,
literal|"allocated in agtiapi_GetDevHandle as local mem for * flags"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|LINUX_PERBI_SUPPORT
end_ifdef

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_PMC_MSLR
argument_list|,
literal|"ag_slr_map_t malloc"
argument_list|,
literal|"mem allocated in agtiapi_attach for pSLRList"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_PMC_MTGT
argument_list|,
literal|"ag_tgt_map_t malloc"
argument_list|,
literal|"mem allocated in agtiapi_attach for pWWNList"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|TEMP
argument_list|,
literal|"tempbuff"
argument_list|,
literal|"buffer for payload"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|TEMP2
argument_list|,
literal|"tempbuff"
argument_list|,
literal|"buffer for agtiapi_getdevlist"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|STATIC
name|U32
name|agtiapi_intx_mode
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|U08
name|ag_Perbi
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|U32
name|agtiapi_polling_mode
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|U32
name|ag_card_good
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|// * total card initialized
end_comment

begin_decl_stmt
name|STATIC
name|U32
name|ag_option_flag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|// * adjustable parameter flag
end_comment

begin_decl_stmt
name|STATIC
name|U32
name|agtiapi_1st_time
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|U32
name|ag_timeout_secs
init|=
literal|10
decl_stmt|;
end_decl_stmt

begin_comment
comment|//Made timeout equivalent to linux
end_comment

begin_decl_stmt
name|U32
name|gTiDebugLevel
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|S32
name|ag_encryption_enable
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|atomic_t
name|outstanding_encrypted_io_count
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|cache_line_size
parameter_list|()
value|CACHE_LINE_SIZE
end_define

begin_define
define|#
directive|define
name|PMCoffsetof
parameter_list|(
name|TYPE
parameter_list|,
name|MEMBER
parameter_list|)
value|((size_t)&((TYPE *)0)->MEMBER)
end_define

begin_define
define|#
directive|define
name|CPU_TO_LE32
parameter_list|(
name|dst
parameter_list|,
name|src
parameter_list|)
define|\
value|dst.lower = htole32(LOW_32_BITS(src)); \     dst.upper = htole32(HIGH_32_BITS(src))
end_define

begin_define
define|#
directive|define
name|CMND_TO_CHANNEL
parameter_list|(
name|ccb
parameter_list|)
value|( ccb->ccb_h.path_id )
end_define

begin_define
define|#
directive|define
name|CMND_TO_TARGET
parameter_list|(
name|ccb
parameter_list|)
value|( ccb->ccb_h.target_id )
end_define

begin_define
define|#
directive|define
name|CMND_TO_LUN
parameter_list|(
name|ccb
parameter_list|)
value|( ccb->ccb_h.target_lun )
end_define

begin_decl_stmt
name|STATIC
name|U08
name|agtiapi_AddrModes
index|[
name|AGTIAPI_MAX_CHANNEL_NUM
operator|+
literal|1
index|]
init|=
block|{
name|AGTIAPI_PERIPHERAL
block|}
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|LINUX_PERBI_SUPPORT
end_ifdef

begin_comment
comment|// Holding area for target-WWN mapping assignments on the boot line
end_comment

begin_decl_stmt
specifier|static
name|ag_mapping_t
modifier|*
name|agMappingList
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|// modified by agtiapi_Setup()
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// * For Debugging Purpose
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|AGTIAPI_DEBUG
end_ifdef

begin_define
define|#
directive|define
name|AGTIAPI_WWN
parameter_list|(
name|name
parameter_list|,
name|len
parameter_list|)
value|wwnprintk(name, len)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|AGTIAPI_WWN
parameter_list|(
name|name
parameter_list|,
name|len
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|AGTIAPI_WWNPRINTK
parameter_list|(
name|name
parameter_list|,
name|len
parameter_list|,
name|format
parameter_list|,
name|a
modifier|...
parameter_list|)
define|\
value|AGTIAPI_PRINTK(format "name ", a);           \           AGTIAPI_WWN((unsigned char*)name, len);
end_define

begin_define
define|#
directive|define
name|AGTIAPI_ERR_WWNPRINTK
parameter_list|(
name|name
parameter_list|,
name|len
parameter_list|,
name|format
parameter_list|,
name|a
modifier|...
parameter_list|)
define|\
value|printk(KERN_DEBUG format "name ", ## a);     \           wwnprintk((unsigned char*)name, len);
end_define

begin_define
define|#
directive|define
name|AGTIAPI_CPY_DEV_INFO
parameter_list|(
name|root
parameter_list|,
name|dev
parameter_list|,
name|pDev
parameter_list|)
define|\
value|tiINIGetDeviceInfo(root, dev,&pDev->devInfo); \           wwncpy(pDev);
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|AGTIAPI_LOCAL_LOCK
end_ifdef

begin_define
define|#
directive|define
name|AG_CARD_LOCAL_LOCK
parameter_list|(
name|lock
parameter_list|)
value|,(lock)
end_define

begin_define
define|#
directive|define
name|AG_SPIN_LOCK_IRQ
parameter_list|(
name|lock
parameter_list|,
name|flags
parameter_list|)
end_define

begin_define
define|#
directive|define
name|AG_SPIN_UNLOCK_IRQ
parameter_list|(
name|lock
parameter_list|,
name|flags
parameter_list|)
end_define

begin_define
define|#
directive|define
name|AG_SPIN_LOCK
parameter_list|(
name|lock
parameter_list|)
end_define

begin_define
define|#
directive|define
name|AG_SPIN_UNLOCK
parameter_list|(
name|lock
parameter_list|)
end_define

begin_define
define|#
directive|define
name|AG_GLOBAL_ARG
parameter_list|(
name|arg
parameter_list|)
end_define

begin_define
define|#
directive|define
name|AG_PERF_SPINLOCK
parameter_list|(
name|lock
parameter_list|)
end_define

begin_define
define|#
directive|define
name|AG_PERF_SPINLOCK_IRQ
parameter_list|(
name|lock
parameter_list|,
name|flags
parameter_list|)
end_define

begin_define
define|#
directive|define
name|AG_LOCAL_LOCK
parameter_list|(
name|lock
parameter_list|)
value|if (lock) \                                          mtx_lock(lock)
end_define

begin_define
define|#
directive|define
name|AG_LOCAL_UNLOCK
parameter_list|(
name|lock
parameter_list|)
value|if (lock) \                                          mtx_unlock(lock)
end_define

begin_define
define|#
directive|define
name|AG_LOCAL_FLAGS
parameter_list|(
name|_flags
parameter_list|)
value|unsigned long _flags = 0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|AG_GET_DONE_PCCB
parameter_list|(
name|pccb
parameter_list|,
name|pmcsc
parameter_list|)
define|\
value|{                                              \     AG_LOCAL_LOCK(&pmcsc->doneLock);             \     pccb = pmcsc->ccbDoneHead;                   \     if (pccb != NULL)                            \     {                                            \       pmcsc->ccbDoneHead = NULL;                 \       pmcsc->ccbDoneTail = NULL;                 \       AG_LOCAL_UNLOCK(&pmcsc->doneLock);         \       agtiapi_Done(pmcsc, pccb);                 \     }                                            \     else                                         \       AG_LOCAL_UNLOCK(&pmcsc->doneLock);         \   }
end_define

begin_define
define|#
directive|define
name|AG_GET_DONE_SMP_PCCB
parameter_list|(
name|pccb
parameter_list|,
name|pmcsc
parameter_list|)
define|\
value|{                                              \     AG_LOCAL_LOCK(&pmcsc->doneSMPLock);          \     pccb = pmcsc->smpDoneHead;                   \     if (pccb != NULL)                            \     {                                            \       pmcsc->smpDoneHead = NULL;                 \       pmcsc->smpDoneTail = NULL;                 \       AG_LOCAL_UNLOCK(&pmcsc->doneSMPLock);      \       agtiapi_SMPDone(pmcsc, pccb);              \     }                                            \     else                                         \       AG_LOCAL_UNLOCK(&pmcsc->doneSMPLock);      \   }
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|AGTIAPI_DUMP_IO_DEBUG
end_ifdef

begin_define
define|#
directive|define
name|AG_IO_DUMPCCB
parameter_list|(
name|pccb
parameter_list|)
value|agtiapi_DumpCCB(pccb)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|AG_IO_DUMPCCB
parameter_list|(
name|pccb
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|SCHED_DELAY_JIFFIES
value|4
end_define

begin_comment
comment|/* in seconds */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HOTPLUG_SUPPORT
end_ifdef

begin_define
define|#
directive|define
name|AG_HOTPLUG_LOCK_INIT
parameter_list|(
name|lock
parameter_list|)
value|mxt_init(lock)
end_define

begin_define
define|#
directive|define
name|AG_LIST_LOCK
parameter_list|(
name|lock
parameter_list|)
value|mtx_lock(lock)
end_define

begin_define
define|#
directive|define
name|AG_LIST_UNLOCK
parameter_list|(
name|lock
parameter_list|)
value|mtx_unlock(lock)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|AG_HOTPLUG_LOCK_INIT
parameter_list|(
name|lock
parameter_list|)
end_define

begin_define
define|#
directive|define
name|AG_LIST_LOCK
parameter_list|(
name|lock
parameter_list|)
end_define

begin_define
define|#
directive|define
name|AG_LIST_UNLOCK
parameter_list|(
name|lock
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
name|STATIC
name|void
name|agtiapi_CheckIOTimeout
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|ag_card_info_t
name|agCardInfoList
index|[
name|AGTIAPI_MAX_CARDS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|// card info list
end_comment

begin_function_decl
specifier|static
name|void
name|agtiapi_cam_action
parameter_list|(
name|struct
name|cam_sim
modifier|*
parameter_list|,
name|union
name|ccb
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|agtiapi_cam_poll
parameter_list|(
name|struct
name|cam_sim
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|// Function prototypes
end_comment

begin_decl_stmt
specifier|static
name|d_open_t
name|agtiapi_open
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|agtiapi_close
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_read_t
name|agtiapi_read
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_write_t
name|agtiapi_write
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|agtiapi_CharIoctl
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|agtiapi_async
parameter_list|(
name|void
modifier|*
name|callback_arg
parameter_list|,
name|u_int32_t
name|code
parameter_list|,
name|struct
name|cam_path
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|agtiapi_adjust_queue_depth
parameter_list|(
name|struct
name|cam_path
modifier|*
name|path
parameter_list|,
name|bit32
name|QueueDepth
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|// Character device entry points
end_comment

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|agtiapi_cdevsw
init|=
block|{
operator|.
name|d_version
operator|=
name|D_VERSION
block|,
operator|.
name|d_open
operator|=
name|agtiapi_open
block|,
operator|.
name|d_close
operator|=
name|agtiapi_close
block|,
operator|.
name|d_read
operator|=
name|agtiapi_read
block|,
operator|.
name|d_write
operator|=
name|agtiapi_write
block|,
operator|.
name|d_ioctl
operator|=
name|agtiapi_CharIoctl
block|,
operator|.
name|d_name
operator|=
literal|"pmspcv"
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|U32
name|maxTargets
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|U32
name|ag_portal_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|// In the cdevsw routines, we find our softc by using the si_drv1 member
end_comment

begin_comment
comment|// of struct cdev. We set this variable to point to our softc in our
end_comment

begin_comment
comment|// attach routine when we create the /dev entry.
end_comment

begin_function
name|int
name|agtiapi_open
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|oflags
parameter_list|,
name|int
name|devtype
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|agtiapi_softc
modifier|*
name|sc
decl_stmt|;
comment|/* Look up our softc. */
name|sc
operator|=
name|dev
operator|->
name|si_drv1
expr_stmt|;
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_open\n"
argument_list|)
expr_stmt|;
name|AGTIAPI_PRINTK
argument_list|(
literal|"Opened successfully. sc->my_dev %p\n"
argument_list|,
name|sc
operator|->
name|my_dev
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|agtiapi_close
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|fflag
parameter_list|,
name|int
name|devtype
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|agtiapi_softc
modifier|*
name|sc
decl_stmt|;
comment|// Look up our softc
name|sc
operator|=
name|dev
operator|->
name|si_drv1
expr_stmt|;
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_close\n"
argument_list|)
expr_stmt|;
name|AGTIAPI_PRINTK
argument_list|(
literal|"Closed. sc->my_dev %p\n"
argument_list|,
name|sc
operator|->
name|my_dev
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|agtiapi_read
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|ioflag
parameter_list|)
block|{
name|struct
name|agtiapi_softc
modifier|*
name|sc
decl_stmt|;
comment|// Look up our softc
name|sc
operator|=
name|dev
operator|->
name|si_drv1
expr_stmt|;
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_read\n"
argument_list|)
expr_stmt|;
name|AGTIAPI_PRINTK
argument_list|(
literal|"Asked to read %lu bytes. sc->my_dev %p\n"
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|,
name|sc
operator|->
name|my_dev
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|agtiapi_write
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|ioflag
parameter_list|)
block|{
name|struct
name|agtiapi_softc
modifier|*
name|sc
decl_stmt|;
comment|// Look up our softc
name|sc
operator|=
name|dev
operator|->
name|si_drv1
expr_stmt|;
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_write\n"
argument_list|)
expr_stmt|;
name|AGTIAPI_PRINTK
argument_list|(
literal|"Asked to write %lu bytes. sc->my_dev %p\n"
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|,
name|sc
operator|->
name|my_dev
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|agtiapi_getdevlist
parameter_list|(
name|struct
name|agtiapi_softc
modifier|*
name|pCard
parameter_list|,
name|tiIOCTLPayload_t
modifier|*
name|agIOCTLPayload
parameter_list|)
block|{
name|tdDeviceListPayload_t
modifier|*
name|pIoctlPayload
init|=
operator|(
name|tdDeviceListPayload_t
operator|*
operator|)
name|agIOCTLPayload
operator|->
name|FunctionSpecificArea
decl_stmt|;
name|tdDeviceInfoIOCTL_t
modifier|*
name|pDeviceInfo
init|=
name|NULL
decl_stmt|;
name|bit8
modifier|*
name|pDeviceInfoOrg
decl_stmt|;
name|tdsaDeviceData_t
modifier|*
name|pDeviceData
init|=
name|NULL
decl_stmt|;
name|tiDeviceHandle_t
modifier|*
modifier|*
name|devList
init|=
name|NULL
decl_stmt|;
name|tiDeviceHandle_t
modifier|*
modifier|*
name|devHandleArray
init|=
name|NULL
decl_stmt|;
name|tiDeviceHandle_t
modifier|*
name|pDeviceHandle
init|=
name|NULL
decl_stmt|;
name|bit32
name|x
decl_stmt|,
name|memNeeded1
decl_stmt|;
name|bit32
name|count
decl_stmt|,
name|total
decl_stmt|;
name|bit32
name|MaxDeviceCount
decl_stmt|;
name|bit32
name|ret_val
init|=
name|IOCTL_CALL_INVALID_CODE
decl_stmt|;
name|ag_portal_data_t
modifier|*
name|pPortalData
decl_stmt|;
name|bit8
modifier|*
name|pDeviceHandleList
init|=
name|NULL
decl_stmt|;
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_getdevlist: Enter\n"
argument_list|)
expr_stmt|;
name|pDeviceInfoOrg
operator|=
name|pIoctlPayload
operator|->
name|pDeviceInfo
expr_stmt|;
name|MaxDeviceCount
operator|=
name|pCard
operator|->
name|devDiscover
expr_stmt|;
if|if
condition|(
name|MaxDeviceCount
operator|>
name|pIoctlPayload
operator|->
name|deviceLength
condition|)
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_getdevlist: MaxDeviceCount: %d> Requested device length: %d\n"
argument_list|,
name|MaxDeviceCount
argument_list|,
name|pIoctlPayload
operator|->
name|deviceLength
argument_list|)
expr_stmt|;
name|MaxDeviceCount
operator|=
name|pIoctlPayload
operator|->
name|deviceLength
expr_stmt|;
name|ret_val
operator|=
name|IOCTL_CALL_FAIL
expr_stmt|;
block|}
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_getdevlist: MaxDeviceCount: %d> Requested device length: %d\n"
argument_list|,
name|MaxDeviceCount
argument_list|,
name|pIoctlPayload
operator|->
name|deviceLength
argument_list|)
expr_stmt|;
name|memNeeded1
operator|=
name|AG_ALIGNSIZE
argument_list|(
name|MaxDeviceCount
operator|*
sizeof|sizeof
argument_list|(
name|tiDeviceHandle_t
operator|*
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_getdevlist: portCount %d\n"
argument_list|,
name|pCard
operator|->
name|portCount
argument_list|)
expr_stmt|;
name|devList
operator|=
name|malloc
argument_list|(
name|memNeeded1
argument_list|,
name|TEMP2
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|devList
operator|==
name|NULL
condition|)
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_getdevlist: failed to allocate memory\n"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|IOCTL_CALL_FAIL
expr_stmt|;
name|agIOCTLPayload
operator|->
name|Status
operator|=
name|IOCTL_ERR_STATUS_INTERNAL_ERROR
expr_stmt|;
return|return
name|ret_val
return|;
block|}
name|osti_memset
argument_list|(
name|devList
argument_list|,
literal|0
argument_list|,
name|memNeeded1
argument_list|)
expr_stmt|;
name|pPortalData
operator|=
operator|&
name|pCard
operator|->
name|pPortalData
index|[
literal|0
index|]
expr_stmt|;
name|pDeviceHandleList
operator|=
operator|(
name|bit8
operator|*
operator|)
name|devList
expr_stmt|;
for|for
control|(
name|total
operator|=
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|pCard
operator|->
name|portCount
condition|;
name|x
operator|++
operator|,
name|pPortalData
operator|++
control|)
block|{
name|count
operator|=
name|tiINIGetDeviceHandlesForWinIOCTL
argument_list|(
operator|&
name|pCard
operator|->
name|tiRoot
argument_list|,
operator|&
name|pPortalData
operator|->
name|portalInfo
operator|.
name|tiPortalContext
argument_list|,
operator|(
name|tiDeviceHandle_t
operator|*
operator|*
operator|)
name|pDeviceHandleList
argument_list|,
name|MaxDeviceCount
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|==
name|DISCOVERY_IN_PROGRESS
condition|)
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_getdevlist: DISCOVERY_IN_PROGRESS on "
literal|"portal %d\n"
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|devList
argument_list|,
name|TEMP2
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|IOCTL_CALL_FAIL
expr_stmt|;
name|agIOCTLPayload
operator|->
name|Status
operator|=
name|IOCTL_ERR_STATUS_INTERNAL_ERROR
expr_stmt|;
return|return
name|ret_val
return|;
block|}
name|total
operator|+=
name|count
expr_stmt|;
name|pDeviceHandleList
operator|+=
name|count
operator|*
sizeof|sizeof
argument_list|(
name|tiDeviceHandle_t
operator|*
argument_list|)
expr_stmt|;
name|MaxDeviceCount
operator|-=
name|count
expr_stmt|;
block|}
if|if
condition|(
name|total
operator|>
name|pIoctlPayload
operator|->
name|deviceLength
condition|)
block|{
name|total
operator|=
name|pIoctlPayload
operator|->
name|deviceLength
expr_stmt|;
block|}
comment|// dump device information from device handle list
name|count
operator|=
literal|0
expr_stmt|;
name|devHandleArray
operator|=
name|devList
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|pCard
operator|->
name|devDiscover
condition|;
name|x
operator|++
control|)
block|{
name|pDeviceHandle
operator|=
operator|(
name|tiDeviceHandle_t
operator|*
operator|)
name|devHandleArray
index|[
name|x
index|]
expr_stmt|;
if|if
condition|(
name|devList
index|[
name|x
index|]
operator|!=
name|agNULL
condition|)
block|{
name|pDeviceData
operator|=
name|devList
index|[
name|x
index|]
operator|->
name|tdData
expr_stmt|;
name|pDeviceInfo
operator|=
operator|(
name|tdDeviceInfoIOCTL_t
operator|*
operator|)
operator|(
name|pDeviceInfoOrg
operator|+
sizeof|sizeof
argument_list|(
name|tdDeviceInfoIOCTL_t
argument_list|)
operator|*
name|count
operator|)
expr_stmt|;
if|if
condition|(
name|pDeviceData
operator|!=
name|agNULL
operator|&&
name|pDeviceInfo
operator|!=
name|agNULL
condition|)
block|{
name|osti_memcpy
argument_list|(
operator|&
name|pDeviceInfo
operator|->
name|sasAddressHi
argument_list|,
name|pDeviceData
operator|->
name|agDeviceInfo
operator|.
name|sasAddressHi
argument_list|,
sizeof|sizeof
argument_list|(
name|bit32
argument_list|)
argument_list|)
expr_stmt|;
name|osti_memcpy
argument_list|(
operator|&
name|pDeviceInfo
operator|->
name|sasAddressLo
argument_list|,
name|pDeviceData
operator|->
name|agDeviceInfo
operator|.
name|sasAddressLo
argument_list|,
sizeof|sizeof
argument_list|(
name|bit32
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|pDeviceInfo->sasAddressHi =           DMA_BEBIT32_TO_BIT32( pDeviceInfo->sasAddressHi );         pDeviceInfo->sasAddressLo =           DMA_BEBIT32_TO_BIT32( pDeviceInfo->sasAddressLo );
endif|#
directive|endif
name|pDeviceInfo
operator|->
name|deviceType
operator|=
operator|(
name|pDeviceData
operator|->
name|agDeviceInfo
operator|.
name|devType_S_Rate
operator|&
literal|0x30
operator|)
operator|>>
literal|4
expr_stmt|;
name|pDeviceInfo
operator|->
name|linkRate
operator|=
name|pDeviceData
operator|->
name|agDeviceInfo
operator|.
name|devType_S_Rate
operator|&
literal|0x0F
expr_stmt|;
name|pDeviceInfo
operator|->
name|phyId
operator|=
name|pDeviceData
operator|->
name|phyID
expr_stmt|;
name|pDeviceInfo
operator|->
name|ishost
operator|=
name|pDeviceData
operator|->
name|target_ssp_stp_smp
expr_stmt|;
name|pDeviceInfo
operator|->
name|DeviceHandle
operator|=
operator|(
name|unsigned
name|long
operator|)
name|pDeviceHandle
expr_stmt|;
if|if
condition|(
name|pDeviceInfo
operator|->
name|deviceType
operator|==
literal|0x02
condition|)
block|{
name|bit8
modifier|*
name|sasAddressHi
decl_stmt|;
name|bit8
modifier|*
name|sasAddressLo
decl_stmt|;
name|tiIniGetDirectSataSasAddr
argument_list|(
operator|&
name|pCard
operator|->
name|tiRoot
argument_list|,
name|pDeviceData
operator|->
name|phyID
argument_list|,
operator|&
name|sasAddressHi
argument_list|,
operator|&
name|sasAddressLo
argument_list|)
expr_stmt|;
name|pDeviceInfo
operator|->
name|sasAddressHi
operator|=
name|DMA_BEBIT32_TO_BIT32
argument_list|(
operator|*
operator|(
name|bit32
operator|*
operator|)
name|sasAddressHi
argument_list|)
expr_stmt|;
name|pDeviceInfo
operator|->
name|sasAddressLo
operator|=
name|DMA_BEBIT32_TO_BIT32
argument_list|(
operator|*
operator|(
name|bit32
operator|*
operator|)
name|sasAddressLo
argument_list|)
operator|+
name|pDeviceData
operator|->
name|phyID
operator|+
literal|16
expr_stmt|;
block|}
else|else
block|{
name|pDeviceInfo
operator|->
name|sasAddressHi
operator|=
name|DMA_BEBIT32_TO_BIT32
argument_list|(
name|pDeviceInfo
operator|->
name|sasAddressHi
argument_list|)
expr_stmt|;
name|pDeviceInfo
operator|->
name|sasAddressLo
operator|=
name|DMA_BEBIT32_TO_BIT32
argument_list|(
name|pDeviceInfo
operator|->
name|sasAddressLo
argument_list|)
expr_stmt|;
block|}
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_getdevlist: devicetype %x\n"
argument_list|,
name|pDeviceInfo
operator|->
name|deviceType
argument_list|)
expr_stmt|;
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_getdevlist: linkrate %x\n"
argument_list|,
name|pDeviceInfo
operator|->
name|linkRate
argument_list|)
expr_stmt|;
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_getdevlist: phyID %x\n"
argument_list|,
name|pDeviceInfo
operator|->
name|phyId
argument_list|)
expr_stmt|;
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_getdevlist: addresshi %x\n"
argument_list|,
name|pDeviceInfo
operator|->
name|sasAddressHi
argument_list|)
expr_stmt|;
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_getdevlist: addresslo %x\n"
argument_list|,
name|pDeviceInfo
operator|->
name|sasAddressHi
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_getdevlist: pDeviceData %p or pDeviceInfo "
literal|"%p is NULL %d\n"
argument_list|,
name|pDeviceData
argument_list|,
name|pDeviceInfo
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
name|count
operator|++
expr_stmt|;
block|}
block|}
name|pIoctlPayload
operator|->
name|realDeviceCount
operator|=
name|count
expr_stmt|;
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_getdevlist: Exit RealDeviceCount = %d\n"
argument_list|,
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|devList
condition|)
block|{
name|free
argument_list|(
name|devList
argument_list|,
name|TEMP2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ret_val
operator|!=
name|IOCTL_CALL_FAIL
condition|)
block|{
name|ret_val
operator|=
name|IOCTL_CALL_SUCCESS
expr_stmt|;
block|}
name|agIOCTLPayload
operator|->
name|Status
operator|=
name|IOCTL_ERR_STATUS_OK
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************** agtiapi_getCardInfo()  Purpose:   This function retrives the Card information Parameters:     Return:   A number - error     0        - HBA has been detected Note:     ******************************************************************************/
end_comment

begin_function
name|int
name|agtiapi_getCardInfo
parameter_list|(
name|struct
name|agtiapi_softc
modifier|*
name|pCard
parameter_list|,
name|U32_64
name|size
parameter_list|,
name|void
modifier|*
name|buffer
parameter_list|)
block|{
name|CardInfo_t
modifier|*
name|pCardInfo
decl_stmt|;
name|pCardInfo
operator|=
operator|(
name|CardInfo_t
operator|*
operator|)
name|buffer
expr_stmt|;
name|pCardInfo
operator|->
name|deviceId
operator|=
name|pci_get_device
argument_list|(
name|pCard
operator|->
name|my_dev
argument_list|)
expr_stmt|;
name|pCardInfo
operator|->
name|vendorId
operator|=
name|pci_get_vendor
argument_list|(
name|pCard
operator|->
name|my_dev
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|pCardInfo
operator|->
name|pciMemBaseSpc
argument_list|,
name|pCard
operator|->
name|pCardInfo
operator|->
name|pciMemBaseSpc
argument_list|,
operator|(
operator|(
sizeof|sizeof
argument_list|(
name|U32_64
argument_list|)
operator|)
operator|*
name|PCI_NUMBER_BARS
operator|)
argument_list|)
expr_stmt|;
name|pCardInfo
operator|->
name|deviceNum
operator|=
name|pci_get_slot
argument_list|(
name|pCard
operator|->
name|my_dev
argument_list|)
expr_stmt|;
name|pCardInfo
operator|->
name|pciMemBase
operator|=
name|pCard
operator|->
name|pCardInfo
operator|->
name|pciMemBase
expr_stmt|;
name|pCardInfo
operator|->
name|pciIOAddrLow
operator|=
name|pCard
operator|->
name|pCardInfo
operator|->
name|pciIOAddrLow
expr_stmt|;
name|pCardInfo
operator|->
name|pciIOAddrUp
operator|=
name|pCard
operator|->
name|pCardInfo
operator|->
name|pciIOAddrUp
expr_stmt|;
name|pCardInfo
operator|->
name|busNum
operator|=
name|pci_get_bus
argument_list|(
name|pCard
operator|->
name|my_dev
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|agtiapi_adjust_queue_depth
parameter_list|(
name|struct
name|cam_path
modifier|*
name|path
parameter_list|,
name|bit32
name|QueueDepth
parameter_list|)
block|{
name|struct
name|ccb_relsim
name|crs
decl_stmt|;
name|xpt_setup_ccb
argument_list|(
operator|&
name|crs
operator|.
name|ccb_h
argument_list|,
name|path
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|crs
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_REL_SIMQ
expr_stmt|;
name|crs
operator|.
name|ccb_h
operator|.
name|flags
operator|=
name|CAM_DEV_QFREEZE
expr_stmt|;
name|crs
operator|.
name|release_flags
operator|=
name|RELSIM_ADJUST_OPENINGS
expr_stmt|;
name|crs
operator|.
name|openings
operator|=
name|QueueDepth
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
operator|&
name|crs
argument_list|)
expr_stmt|;
if|if
condition|(
name|crs
operator|.
name|ccb_h
operator|.
name|status
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|printf
argument_list|(
literal|"XPT_REL_SIMQ failed\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|agtiapi_async
parameter_list|(
name|void
modifier|*
name|callback_arg
parameter_list|,
name|u_int32_t
name|code
parameter_list|,
name|struct
name|cam_path
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|agtiapi_softc
modifier|*
name|pmsc
decl_stmt|;
name|U32
name|TID
decl_stmt|;
name|ag_device_t
modifier|*
name|targ
decl_stmt|;
name|pmsc
operator|=
operator|(
expr|struct
name|agtiapi_softc
operator|*
operator|)
name|callback_arg
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|AC_FOUND_DEVICE
case|:
block|{
name|struct
name|ccb_getdev
modifier|*
name|cgd
decl_stmt|;
name|cgd
operator|=
operator|(
expr|struct
name|ccb_getdev
operator|*
operator|)
name|arg
expr_stmt|;
if|if
condition|(
name|cgd
operator|==
name|NULL
condition|)
block|{
break|break;
block|}
name|TID
operator|=
name|cgd
operator|->
name|ccb_h
operator|.
name|target_id
expr_stmt|;
if|if
condition|(
name|TID
operator|>=
literal|0
operator|&&
name|TID
operator|<
name|maxTargets
condition|)
block|{
if|if
condition|(
name|pmsc
operator|!=
name|NULL
condition|)
block|{
name|TID
operator|=
name|INDEX
argument_list|(
name|pmsc
argument_list|,
name|TID
argument_list|)
expr_stmt|;
name|targ
operator|=
operator|&
name|pmsc
operator|->
name|pDevList
index|[
name|TID
index|]
expr_stmt|;
name|agtiapi_adjust_queue_depth
argument_list|(
name|path
argument_list|,
name|targ
operator|->
name|qdepth
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
default|default:
break|break;
block|}
block|}
end_function

begin_comment
comment|/****************************************************************************** agtiapi_CharIoctl()  Purpose:   This function handles the ioctl from application layer Parameters:    Return:   A number - error     0        - HBA has been detected Note:     ******************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|agtiapi_CharIoctl
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|int
name|fflag
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|sema
name|mx
decl_stmt|;
name|datatosend
modifier|*
name|load
decl_stmt|;
comment|// structure defined in lxcommon.h
name|tiIOCTLPayload_t
modifier|*
name|pIoctlPayload
decl_stmt|;
name|struct
name|agtiapi_softc
modifier|*
name|pCard
decl_stmt|;
name|pCard
operator|=
name|dev
operator|->
name|si_drv1
expr_stmt|;
name|U32
name|status
init|=
literal|0
decl_stmt|;
name|U32
name|retValue
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|tdDeviceListPayload_t
modifier|*
name|pDeviceList
init|=
name|NULL
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|AGTIAPI_IOCTL
case|:
name|load
operator|=
operator|(
name|datatosend
operator|*
operator|)
name|data
expr_stmt|;
name|pIoctlPayload
operator|=
name|malloc
argument_list|(
name|load
operator|->
name|datasize
argument_list|,
name|TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_CharIoctl: old load->datasize = %d\n"
argument_list|,
name|load
operator|->
name|datasize
argument_list|)
expr_stmt|;
comment|//Copy payload to kernel buffer, on success it returns 0
name|err
operator|=
name|copyin
argument_list|(
name|load
operator|->
name|data
argument_list|,
name|pIoctlPayload
argument_list|,
name|load
operator|->
name|datasize
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|status
operator|=
name|IOCTL_CALL_FAIL
expr_stmt|;
return|return
name|status
return|;
block|}
name|sema_init
argument_list|(
operator|&
name|mx
argument_list|,
literal|0
argument_list|,
literal|"sem"
argument_list|)
expr_stmt|;
name|pCard
operator|->
name|pIoctlSem
operator|=
operator|&
name|mx
expr_stmt|;
name|pCard
operator|->
name|up_count
operator|=
name|pCard
operator|->
name|down_count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pIoctlPayload
operator|->
name|MajorFunction
operator|==
name|IOCTL_MJ_GET_DEVICE_LIST
condition|)
block|{
name|retValue
operator|=
name|agtiapi_getdevlist
argument_list|(
name|pCard
argument_list|,
name|pIoctlPayload
argument_list|)
expr_stmt|;
if|if
condition|(
name|retValue
operator|==
literal|0
condition|)
block|{
name|pIoctlPayload
operator|->
name|Status
operator|=
name|IOCTL_CALL_SUCCESS
expr_stmt|;
name|status
operator|=
name|IOCTL_CALL_SUCCESS
expr_stmt|;
block|}
else|else
block|{
name|pIoctlPayload
operator|->
name|Status
operator|=
name|IOCTL_CALL_FAIL
expr_stmt|;
name|status
operator|=
name|IOCTL_CALL_FAIL
expr_stmt|;
block|}
comment|//update new device length
name|pDeviceList
operator|=
operator|(
name|tdDeviceListPayload_t
operator|*
operator|)
name|pIoctlPayload
operator|->
name|FunctionSpecificArea
expr_stmt|;
name|load
operator|->
name|datasize
operator|=
name|load
operator|->
name|datasize
operator|-
sizeof|sizeof
argument_list|(
name|tdDeviceInfoIOCTL_t
argument_list|)
operator|*
operator|(
name|pDeviceList
operator|->
name|deviceLength
operator|-
name|pDeviceList
operator|->
name|realDeviceCount
operator|)
expr_stmt|;
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_CharIoctl: new load->datasize = %d\n"
argument_list|,
name|load
operator|->
name|datasize
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pIoctlPayload
operator|->
name|MajorFunction
operator|==
name|IOCTL_MN_GET_CARD_INFO
condition|)
block|{
name|retValue
operator|=
name|agtiapi_getCardInfo
argument_list|(
name|pCard
argument_list|,
name|pIoctlPayload
operator|->
name|Length
argument_list|,
operator|(
name|pIoctlPayload
operator|->
name|FunctionSpecificArea
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|retValue
operator|==
literal|0
condition|)
block|{
name|pIoctlPayload
operator|->
name|Status
operator|=
name|IOCTL_CALL_SUCCESS
expr_stmt|;
name|status
operator|=
name|IOCTL_CALL_SUCCESS
expr_stmt|;
block|}
else|else
block|{
name|pIoctlPayload
operator|->
name|Status
operator|=
name|IOCTL_CALL_FAIL
expr_stmt|;
name|status
operator|=
name|IOCTL_CALL_FAIL
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|pIoctlPayload
operator|->
name|MajorFunction
operator|==
name|IOCTL_MJ_CHECK_DPMC_EVENT
condition|)
block|{
if|if
condition|(
name|pCard
operator|->
name|flags
operator|&
name|AGTIAPI_PORT_PANIC
condition|)
block|{
name|strcpy
argument_list|(
name|pIoctlPayload
operator|->
name|FunctionSpecificArea
argument_list|,
literal|"DPMC LEAN\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strcpy
argument_list|(
name|pIoctlPayload
operator|->
name|FunctionSpecificArea
argument_list|,
literal|"do not dpmc lean\n"
argument_list|)
expr_stmt|;
block|}
name|pIoctlPayload
operator|->
name|Status
operator|=
name|IOCTL_CALL_SUCCESS
expr_stmt|;
name|status
operator|=
name|IOCTL_CALL_SUCCESS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pIoctlPayload
operator|->
name|MajorFunction
operator|==
name|IOCTL_MJ_CHECK_FATAL_ERROR
condition|)
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_CharIoctl: IOCTL_MJ_CHECK_FATAL_ERROR call received for card %d\n"
argument_list|,
name|pCard
operator|->
name|cardNo
argument_list|)
expr_stmt|;
comment|//read port status to see if there is a fatal event
if|if
condition|(
name|pCard
operator|->
name|flags
operator|&
name|AGTIAPI_PORT_PANIC
condition|)
block|{
name|printf
argument_list|(
literal|"agtiapi_CharIoctl: Port Panic Status For Card %d is True\n"
argument_list|,
name|pCard
operator|->
name|cardNo
argument_list|)
expr_stmt|;
name|pIoctlPayload
operator|->
name|Status
operator|=
name|IOCTL_MJ_FATAL_ERR_CHK_SEND_TRUE
expr_stmt|;
block|}
else|else
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_CharIoctl: Port Panic Status For Card %d is False\n"
argument_list|,
name|pCard
operator|->
name|cardNo
argument_list|)
expr_stmt|;
name|pIoctlPayload
operator|->
name|Status
operator|=
name|IOCTL_MJ_FATAL_ERR_CHK_SEND_FALSE
expr_stmt|;
block|}
name|status
operator|=
name|IOCTL_CALL_SUCCESS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pIoctlPayload
operator|->
name|MajorFunction
operator|==
name|IOCTL_MJ_FATAL_ERROR_DUMP_COMPLETE
condition|)
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_CharIoctl: IOCTL_MJ_FATAL_ERROR_DUMP_COMPLETE call received for card %d\n"
argument_list|,
name|pCard
operator|->
name|cardNo
argument_list|)
expr_stmt|;
comment|//set flags bit status to be a soft reset
name|pCard
operator|->
name|flags
operator||=
name|AGTIAPI_SOFT_RESET
expr_stmt|;
comment|//trigger soft reset for the card
name|retValue
operator|=
name|agtiapi_ResetCard
argument_list|(
name|pCard
argument_list|,
operator|&
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|retValue
operator|==
name|AGTIAPI_SUCCESS
condition|)
block|{
comment|//clear port panic status
name|pCard
operator|->
name|flags
operator|&=
operator|~
name|AGTIAPI_PORT_PANIC
expr_stmt|;
name|pIoctlPayload
operator|->
name|Status
operator|=
name|IOCTL_MJ_FATAL_ERROR_SOFT_RESET_TRIG
expr_stmt|;
name|status
operator|=
name|IOCTL_CALL_SUCCESS
expr_stmt|;
block|}
else|else
block|{
name|pIoctlPayload
operator|->
name|Status
operator|=
name|IOCTL_CALL_FAIL
expr_stmt|;
name|status
operator|=
name|IOCTL_CALL_FAIL
expr_stmt|;
block|}
block|}
else|else
block|{
name|status
operator|=
name|tiCOMMgntIOCTL
argument_list|(
operator|&
name|pCard
operator|->
name|tiRoot
argument_list|,
name|pIoctlPayload
argument_list|,
name|pCard
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|IOCTL_CALL_PENDING
condition|)
block|{
name|ostiIOCTLWaitForSignal
argument_list|(
operator|&
name|pCard
operator|->
name|tiRoot
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|status
operator|=
name|IOCTL_CALL_SUCCESS
expr_stmt|;
block|}
block|}
name|pCard
operator|->
name|pIoctlSem
operator|=
name|NULL
expr_stmt|;
name|err
operator|=
literal|0
expr_stmt|;
comment|//copy kernel buffer to userland buffer
name|err
operator|=
name|copyout
argument_list|(
name|pIoctlPayload
argument_list|,
name|load
operator|->
name|data
argument_list|,
name|load
operator|->
name|datasize
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|status
operator|=
name|IOCTL_CALL_FAIL
expr_stmt|;
return|return
name|status
return|;
block|}
name|free
argument_list|(
name|pIoctlPayload
argument_list|,
name|TEMP
argument_list|)
expr_stmt|;
name|pIoctlPayload
operator|=
name|NULL
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|ENOTTY
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************** agtiapi_probe()  Purpose:   This function initialize and registere all detected HBAs.   The first function being called in driver after agtiapi_probe() Parameters:    device_t dev (IN)  - device pointer Return:   A number - error     0        - HBA has been detected Note:     ******************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|agtiapi_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|retVal
decl_stmt|;
name|int
name|thisCard
decl_stmt|;
name|ag_card_info_t
modifier|*
name|thisCardInst
decl_stmt|;
name|thisCard
operator|=
name|device_get_unit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|thisCard
operator|>=
name|AGTIAPI_MAX_CARDS
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Too many PMC-Sierra cards detected ERROR!\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|// maybe change to different return value?
block|}
name|thisCardInst
operator|=
operator|&
name|agCardInfoList
index|[
name|thisCard
index|]
expr_stmt|;
name|retVal
operator|=
name|agtiapi_ProbeCard
argument_list|(
name|dev
argument_list|,
name|thisCardInst
argument_list|,
name|thisCard
argument_list|)
expr_stmt|;
if|if
condition|(
name|retVal
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|// maybe change to different return value?
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
comment|// successful probe
block|}
end_function

begin_comment
comment|/****************************************************************************** agtiapi_attach()  Purpose:   This function initialize and registere all detected HBAs.   The first function being called in driver after agtiapi_probe() Parameters:    device_t dev (IN)  - device pointer Return:   A number - error     0        - HBA has been detected Note:     ******************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|agtiapi_attach
parameter_list|(
name|device_t
name|devx
parameter_list|)
block|{
comment|// keeping get_unit call to once
name|int
name|thisCard
init|=
name|device_get_unit
argument_list|(
name|devx
argument_list|)
decl_stmt|;
name|struct
name|agtiapi_softc
modifier|*
name|pmsc
decl_stmt|;
name|ag_card_info_t
modifier|*
name|thisCardInst
init|=
operator|&
name|agCardInfoList
index|[
name|thisCard
index|]
decl_stmt|;
name|ag_resource_info_t
modifier|*
name|pRscInfo
decl_stmt|;
name|int
name|idx
decl_stmt|;
name|int
name|lenRecv
decl_stmt|;
name|char
name|buffer
index|[
literal|256
index|]
decl_stmt|,
modifier|*
name|pLastUsedChar
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|int
name|bus
decl_stmt|,
name|tid
decl_stmt|,
name|lun
decl_stmt|;
name|struct
name|ccb_setasync
name|csa
decl_stmt|;
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_attach: start dev %p thisCard %d\n"
argument_list|,
name|devx
argument_list|,
name|thisCard
argument_list|)
expr_stmt|;
comment|// AGTIAPI_PRINTK( "agtiapi_attach: entry pointer values  A %p / %p\n",
comment|//        thisCardInst->pPCIDev, thisCardInst );
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_attach: deviceID: 0x%x\n"
argument_list|,
name|pci_get_devid
argument_list|(
name|devx
argument_list|)
argument_list|)
expr_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
literal|"DPMC_TIMEOUT_SECS"
argument_list|,
operator|&
name|ag_timeout_secs
argument_list|)
expr_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
literal|"DPMC_TIDEBUG_LEVEL"
argument_list|,
operator|&
name|gTiDebugLevel
argument_list|)
expr_stmt|;
comment|// printf( "agtiapi_attach: debugLevel %d, timeout %d\n",
comment|//         gTiDebugLevel, ag_timeout_secs );
if|if
condition|(
name|ag_timeout_secs
operator|<
literal|1
condition|)
block|{
name|ag_timeout_secs
operator|=
literal|1
expr_stmt|;
comment|// set minimum timeout value of 1 second
block|}
name|ag_timeout_secs
operator|=
operator|(
name|ag_timeout_secs
operator|*
literal|1000
operator|)
expr_stmt|;
comment|// convert to millisecond notation
comment|// Look up our softc and initialize its fields.
name|pmsc
operator|=
name|device_get_softc
argument_list|(
name|devx
argument_list|)
expr_stmt|;
name|pmsc
operator|->
name|my_dev
operator|=
name|devx
expr_stmt|;
comment|/* Get NumberOfPortals */
if|if
condition|(
operator|(
name|ostiGetTransportParam
argument_list|(
operator|&
name|pmsc
operator|->
name|tiRoot
argument_list|,
literal|"Global"
argument_list|,
literal|"CardDefault"
argument_list|,
name|agNULL
argument_list|,
name|agNULL
argument_list|,
name|agNULL
argument_list|,
name|agNULL
argument_list|,
literal|"NumberOfPortals"
argument_list|,
name|buffer
argument_list|,
literal|255
argument_list|,
operator|&
name|lenRecv
argument_list|)
operator|==
name|tiSuccess
operator|)
operator|&&
operator|(
name|lenRecv
operator|!=
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|osti_strncmp
argument_list|(
name|buffer
argument_list|,
literal|"0x"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ag_portal_count
operator|=
name|osti_strtoul
argument_list|(
name|buffer
argument_list|,
operator|&
name|pLastUsedChar
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ag_portal_count
operator|=
name|osti_strtoul
argument_list|(
name|buffer
argument_list|,
operator|&
name|pLastUsedChar
argument_list|,
literal|10
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ag_portal_count
operator|>
name|AGTIAPI_MAX_PORTALS
condition|)
name|ag_portal_count
operator|=
name|AGTIAPI_MAX_PORTALS
expr_stmt|;
block|}
else|else
block|{
name|ag_portal_count
operator|=
name|AGTIAPI_MAX_PORTALS
expr_stmt|;
block|}
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_attach: ag_portal_count=%d\n"
argument_list|,
name|ag_portal_count
argument_list|)
expr_stmt|;
comment|// initialize hostdata structure
name|pmsc
operator|->
name|flags
operator||=
name|AGTIAPI_INIT_TIME
operator||
name|AGTIAPI_SCSI_REGISTERED
operator||
name|AGTIAPI_INITIATOR
expr_stmt|;
name|pmsc
operator|->
name|cardNo
operator|=
name|thisCard
expr_stmt|;
name|pmsc
operator|->
name|ccbTotal
operator|=
literal|0
expr_stmt|;
name|pmsc
operator|->
name|portCount
operator|=
name|ag_portal_count
expr_stmt|;
name|pmsc
operator|->
name|pCardInfo
operator|=
name|thisCardInst
expr_stmt|;
name|pmsc
operator|->
name|tiRoot
operator|.
name|osData
operator|=
name|pmsc
expr_stmt|;
name|pmsc
operator|->
name|pCardInfo
operator|->
name|pCard
operator|=
operator|(
name|void
operator|*
operator|)
name|pmsc
expr_stmt|;
name|pmsc
operator|->
name|VidDid
operator|=
operator|(
name|pci_get_vendor
argument_list|(
name|devx
argument_list|)
operator|<<
literal|16
operator|)
operator||
name|pci_get_device
argument_list|(
name|devx
argument_list|)
expr_stmt|;
name|pmsc
operator|->
name|SimQFrozen
operator|=
name|agFALSE
expr_stmt|;
name|pmsc
operator|->
name|devq_flag
operator|=
name|agFALSE
expr_stmt|;
name|pRscInfo
operator|=
operator|&
name|thisCardInst
operator|->
name|tiRscInfo
expr_stmt|;
name|osti_memset
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
literal|256
argument_list|)
expr_stmt|;
name|lenRecv
operator|=
literal|0
expr_stmt|;
comment|/* Get MaxTargets */
if|if
condition|(
operator|(
name|ostiGetTransportParam
argument_list|(
operator|&
name|pmsc
operator|->
name|tiRoot
argument_list|,
literal|"Global"
argument_list|,
literal|"InitiatorParms"
argument_list|,
name|agNULL
argument_list|,
name|agNULL
argument_list|,
name|agNULL
argument_list|,
name|agNULL
argument_list|,
literal|"MaxTargets"
argument_list|,
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|,
operator|&
name|lenRecv
argument_list|)
operator|==
name|tiSuccess
operator|)
operator|&&
operator|(
name|lenRecv
operator|!=
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|osti_strncmp
argument_list|(
name|buffer
argument_list|,
literal|"0x"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|maxTargets
operator|=
name|osti_strtoul
argument_list|(
name|buffer
argument_list|,
operator|&
name|pLastUsedChar
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_attach:  maxTargets = osti_strtoul  0 \n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|maxTargets
operator|=
name|osti_strtoul
argument_list|(
name|buffer
argument_list|,
operator|&
name|pLastUsedChar
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_attach:  maxTargets = osti_strtoul 10\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|Is_ADP8H
argument_list|(
name|pmsc
argument_list|)
condition|)
name|maxTargets
operator|=
name|AGTIAPI_MAX_DEVICE_8H
expr_stmt|;
elseif|else
if|if
condition|(
name|Is_ADP7H
argument_list|(
name|pmsc
argument_list|)
condition|)
name|maxTargets
operator|=
name|AGTIAPI_MAX_DEVICE_7H
expr_stmt|;
else|else
name|maxTargets
operator|=
name|AGTIAPI_MAX_DEVICE
expr_stmt|;
block|}
if|if
condition|(
name|maxTargets
operator|>
name|AGTIAPI_HW_LIMIT_DEVICE
condition|)
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_attach: maxTargets: %d> AGTIAPI_HW_LIMIT_DEVICE: %d\n"
argument_list|,
name|maxTargets
argument_list|,
name|AGTIAPI_HW_LIMIT_DEVICE
argument_list|)
expr_stmt|;
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_attach: change maxTargets = AGTIAPI_HW_LIMIT_DEVICE\n"
argument_list|)
expr_stmt|;
name|maxTargets
operator|=
name|AGTIAPI_HW_LIMIT_DEVICE
expr_stmt|;
block|}
name|pmsc
operator|->
name|devDiscover
operator|=
name|maxTargets
expr_stmt|;
ifdef|#
directive|ifdef
name|HIALEAH_ENCRYPTION
name|ag_encryption_enable
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ag_encryption_enable
operator|&&
name|pci_get_device
argument_list|(
name|pmsc
operator|->
name|pCardInfo
operator|->
name|pPCIDev
argument_list|)
operator|==
name|PCI_DEVICE_ID_HIALEAH_HBA_SPCVE
condition|)
block|{
name|pmsc
operator|->
name|encrypt
operator|=
literal|1
expr_stmt|;
name|pRscInfo
operator|->
name|tiLoLevelResource
operator|.
name|loLevelOption
operator|.
name|encryption
operator|=
name|agTRUE
expr_stmt|;
name|printf
argument_list|(
literal|"agtiapi_attach: Encryption Enabled\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|// ## for now, skip calls to ostiGetTransportParam(...)
comment|// ## for now, skip references to DIF& EDC
comment|// Create a /dev entry for this device. The kernel will assign us
comment|// a major number automatically. We use the unit number of this
comment|// device as the minor number and name the character device
comment|// "agtiapi<unit>".
name|pmsc
operator|->
name|my_cdev
operator|=
name|make_dev
argument_list|(
operator|&
name|agtiapi_cdevsw
argument_list|,
name|thisCard
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0600
argument_list|,
literal|"spcv%u"
argument_list|,
name|thisCard
argument_list|)
expr_stmt|;
name|pmsc
operator|->
name|my_cdev
operator|->
name|si_drv1
operator|=
name|pmsc
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|thisCardInst
operator|->
name|pmIOLock
argument_list|,
literal|"pmc SAS I/O lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
operator||
name|MTX_RECURSE
argument_list|)
expr_stmt|;
name|struct
name|cam_devq
modifier|*
name|devq
decl_stmt|;
comment|/* set the maximum number of pending IOs */
name|devq
operator|=
name|cam_simq_alloc
argument_list|(
name|AGTIAPI_MAX_CAM_Q_DEPTH
argument_list|)
expr_stmt|;
if|if
condition|(
name|devq
operator|==
name|NULL
condition|)
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_attach: cam_simq_alloc is NULL\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|struct
name|cam_sim
modifier|*
name|lsim
decl_stmt|;
name|lsim
operator|=
name|cam_sim_alloc
argument_list|(
name|agtiapi_cam_action
argument_list|,
name|agtiapi_cam_poll
argument_list|,
literal|"pmspcbsd"
argument_list|,
name|pmsc
argument_list|,
name|thisCard
argument_list|,
operator|&
name|thisCardInst
operator|->
name|pmIOLock
argument_list|,
literal|1
argument_list|,
comment|// queued per target
name|AGTIAPI_MAX_CAM_Q_DEPTH
argument_list|,
comment|// max tag depth
name|devq
argument_list|)
expr_stmt|;
if|if
condition|(
name|lsim
operator|==
name|NULL
condition|)
block|{
name|cam_simq_free
argument_list|(
name|devq
argument_list|)
expr_stmt|;
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_attach: cam_sim_alloc is NULL\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|pmsc
operator|->
name|dev_scan
operator|=
name|agFALSE
expr_stmt|;
comment|//one cam sim per scsi bus
name|mtx_lock
argument_list|(
operator|&
name|thisCardInst
operator|->
name|pmIOLock
argument_list|)
expr_stmt|;
if|if
condition|(
name|xpt_bus_register
argument_list|(
name|lsim
argument_list|,
name|devx
argument_list|,
literal|0
argument_list|)
operator|!=
name|CAM_SUCCESS
condition|)
block|{
comment|// bus 0
name|cam_sim_free
argument_list|(
name|lsim
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|thisCardInst
operator|->
name|pmIOLock
argument_list|)
expr_stmt|;
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_attach: xpt_bus_register fails\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|pmsc
operator|->
name|sim
operator|=
name|lsim
expr_stmt|;
name|bus
operator|=
name|cam_sim_path
argument_list|(
name|pmsc
operator|->
name|sim
argument_list|)
expr_stmt|;
name|tid
operator|=
name|CAM_TARGET_WILDCARD
expr_stmt|;
name|lun
operator|=
name|CAM_LUN_WILDCARD
expr_stmt|;
name|ccb
operator|=
name|xpt_alloc_ccb_nowait
argument_list|()
expr_stmt|;
if|if
condition|(
name|ccb
operator|==
name|agNULL
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|thisCardInst
operator|->
name|pmIOLock
argument_list|)
expr_stmt|;
name|cam_sim_free
argument_list|(
name|lsim
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|cam_simq_free
argument_list|(
name|devq
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
if|if
condition|(
name|xpt_create_path
argument_list|(
operator|&
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|agNULL
argument_list|,
name|bus
argument_list|,
name|tid
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|thisCardInst
operator|->
name|pmIOLock
argument_list|)
expr_stmt|;
name|cam_sim_free
argument_list|(
name|lsim
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|cam_simq_free
argument_list|(
name|devq
argument_list|)
expr_stmt|;
name|xpt_free_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|pmsc
operator|->
name|path
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|path
expr_stmt|;
name|xpt_setup_ccb
argument_list|(
operator|&
name|csa
operator|.
name|ccb_h
argument_list|,
name|pmsc
operator|->
name|path
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|csa
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_SASYNC_CB
expr_stmt|;
name|csa
operator|.
name|event_enable
operator|=
name|AC_FOUND_DEVICE
expr_stmt|;
name|csa
operator|.
name|callback
operator|=
name|agtiapi_async
expr_stmt|;
name|csa
operator|.
name|callback_arg
operator|=
name|pmsc
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
operator|&
name|csa
argument_list|)
expr_stmt|;
if|if
condition|(
name|csa
operator|.
name|ccb_h
operator|.
name|status
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_attach: Unable to register AC_FOUND_DEVICE\n"
argument_list|)
expr_stmt|;
block|}
name|lsim
operator|->
name|devq
operator|=
name|devq
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|thisCardInst
operator|->
name|pmIOLock
argument_list|)
expr_stmt|;
comment|// get TD and lower layer memory requirements
name|tiCOMGetResource
argument_list|(
operator|&
name|pmsc
operator|->
name|tiRoot
argument_list|,
operator|&
name|pRscInfo
operator|->
name|tiLoLevelResource
argument_list|,
operator|&
name|pRscInfo
operator|->
name|tiInitiatorResource
argument_list|,
name|NULL
argument_list|,
operator|&
name|pRscInfo
operator|->
name|tiSharedMem
argument_list|)
expr_stmt|;
name|agtiapi_ScopeDMARes
argument_list|(
name|thisCardInst
argument_list|)
expr_stmt|;
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_attach: size from the call agtiapi_ScopeDMARes"
literal|" 0x%x \n"
argument_list|,
name|pmsc
operator|->
name|typhn
argument_list|)
expr_stmt|;
comment|// initialize card information and get resource ready
if|if
condition|(
name|agtiapi_InitResource
argument_list|(
name|thisCardInst
argument_list|)
operator|==
name|AGTIAPI_FAIL
condition|)
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_attach: Card %d initialize resource ERROR\n"
argument_list|,
name|thisCard
argument_list|)
expr_stmt|;
block|}
comment|// begin: allocate and initialize card portal info resource
name|ag_portal_data_t
modifier|*
name|pPortalData
decl_stmt|;
if|if
condition|(
name|pmsc
operator|->
name|portCount
operator|==
literal|0
condition|)
block|{
name|pmsc
operator|->
name|pPortalData
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|pmsc
operator|->
name|pPortalData
operator|=
operator|(
name|ag_portal_data_t
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ag_portal_data_t
argument_list|)
operator|*
name|pmsc
operator|->
name|portCount
argument_list|,
name|M_PMC_MPRT
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmsc
operator|->
name|pPortalData
operator|==
name|NULL
condition|)
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_attach: Portal memory allocation ERROR\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|pPortalData
operator|=
name|pmsc
operator|->
name|pPortalData
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|pmsc
operator|->
name|portCount
condition|;
name|idx
operator|++
control|)
block|{
name|pPortalData
operator|->
name|pCard
operator|=
name|pmsc
expr_stmt|;
name|pPortalData
operator|->
name|portalInfo
operator|.
name|portID
operator|=
name|idx
expr_stmt|;
name|pPortalData
operator|->
name|portalInfo
operator|.
name|tiPortalContext
operator|.
name|osData
operator|=
operator|(
name|void
operator|*
operator|)
name|pPortalData
expr_stmt|;
name|pPortalData
operator|++
expr_stmt|;
block|}
comment|// end: allocate and initialize card portal info resource
comment|// begin: enable msix
comment|// setup msix
comment|// map to interrupt handler
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|mesgs
init|=
name|MAX_MSIX_NUM_VECTOR
decl_stmt|;
name|int
name|i
decl_stmt|,
name|cnt
decl_stmt|;
name|void
function_decl|(
modifier|*
name|intrHandler
index|[
name|MAX_MSIX_NUM_ISR
index|]
function_decl|)
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
init|=
block|{
name|agtiapi_IntrHandler0
operator|,
function_decl|agtiapi_IntrHandler1
operator|,
function_decl|agtiapi_IntrHandler2
operator|,
function_decl|agtiapi_IntrHandler3
operator|,
function_decl|agtiapi_IntrHandler4
operator|,
function_decl|agtiapi_IntrHandler5
operator|,
function_decl|agtiapi_IntrHandler6
operator|,
function_decl|agtiapi_IntrHandler7
operator|,
function_decl|agtiapi_IntrHandler8
operator|,
function_decl|agtiapi_IntrHandler9
operator|,
function_decl|agtiapi_IntrHandler10
operator|,
function_decl|agtiapi_IntrHandler11
operator|,
function_decl|agtiapi_IntrHandler12
operator|,
function_decl|agtiapi_IntrHandler13
operator|,
function_decl|agtiapi_IntrHandler14
operator|,
function_decl|agtiapi_IntrHandler15
block|}
end_function

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|cnt
operator|=
name|pci_msix_count
argument_list|(
name|devx
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|AGTIAPI_PRINTK
argument_list|(
literal|"supported MSIX %d\n"
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|//this should be 64
end_comment

begin_expr_stmt
name|mesgs
operator|=
name|MIN
argument_list|(
name|mesgs
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|error
operator|=
name|pci_alloc_msix
argument_list|(
name|devx
argument_list|,
operator|&
name|mesgs
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"pci_alloc_msix error %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|AGTIAPI_PRINTK
argument_list|(
literal|"error %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
end_if

begin_for
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mesgs
condition|;
name|i
operator|++
control|)
block|{
name|pmsc
operator|->
name|rscID
index|[
name|i
index|]
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|pmsc
operator|->
name|irq
index|[
name|i
index|]
operator|=
name|bus_alloc_resource_any
argument_list|(
name|devx
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|pmsc
operator|->
name|rscID
index|[
name|i
index|]
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmsc
operator|->
name|irq
index|[
name|i
index|]
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"RES_IRQ went terribly bad at %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|bus_setup_intr
argument_list|(
name|devx
argument_list|,
name|pmsc
operator|->
name|irq
index|[
name|i
index|]
argument_list|,
name|INTR_TYPE_CAM
operator||
name|INTR_MPSAFE
argument_list|,
name|NULL
argument_list|,
name|intrHandler
index|[
name|i
index|]
argument_list|,
name|pmsc
argument_list|,
operator|&
name|pmsc
operator|->
name|intrcookie
index|[
name|i
index|]
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|devx
argument_list|,
literal|"Failed to register handler"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
block|}
end_for

begin_expr_stmt
name|pmsc
operator|->
name|flags
operator||=
name|AGTIAPI_IRQ_REQUESTED
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|pmsc
operator|->
name|pCardInfo
operator|->
name|maxInterruptVectors
operator|=
name|MAX_MSIX_NUM_VECTOR
expr_stmt|;
end_expr_stmt

begin_comment
comment|// end: enable msix
end_comment

begin_decl_stmt
name|int
name|ret
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|ret
operator|=
name|agtiapi_InitCardSW
argument_list|(
name|pmsc
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|ret
operator|==
name|AGTIAPI_FAIL
operator|||
name|ret
operator|==
name|AGTIAPI_UNKNOWN
condition|)
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_attach: agtiapi_InitCardSW failure %d\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
end_if

begin_expr_stmt
name|pmsc
operator|->
name|ccbFreeList
operator|=
name|NULL
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|pmsc
operator|->
name|ccbChainList
operator|=
name|NULL
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|pmsc
operator|->
name|ccbAllocList
operator|=
name|NULL
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|pmsc
operator|->
name|flags
operator||=
operator|(
name|AGTIAPI_INSTALLED
operator|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ret
operator|=
name|agtiapi_alloc_requests
argument_list|(
name|pmsc
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_attach: agtiapi_alloc_requests failure %d\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
end_if

begin_expr_stmt
name|ret
operator|=
name|agtiapi_alloc_ostimem
argument_list|(
name|pmsc
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|ret
operator|!=
name|AGTIAPI_SUCCESS
condition|)
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_attach: agtiapi_alloc_ostimem failure %d\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
end_if

begin_expr_stmt
name|ret
operator|=
name|agtiapi_InitCardHW
argument_list|(
name|pmsc
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_attach: agtiapi_InitCardHW failure %d\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|HIALEAH_ENCRYPTION
end_ifdef

begin_if
if|if
condition|(
name|pmsc
operator|->
name|encrypt
condition|)
block|{
if|if
condition|(
operator|(
name|agtiapi_SetupEncryption
argument_list|(
name|pmsc
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|AGTIAPI_PRINTK
argument_list|(
literal|"SetupEncryption returned less than 0\n"
argument_list|)
expr_stmt|;
block|}
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|pmsc
operator|->
name|flags
operator|&=
operator|~
name|AGTIAPI_INIT_TIME
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|(
literal|0
operator|)
return|;
end_return

begin_comment
unit|}
comment|/****************************************************************************** agtiapi_InitCardSW()  Purpose:   Host Bus Adapter Initialization Parameters:    struct agtiapi_softc *pmsc (IN)  Pointer to the HBA data structure Return:   AGTIAPI_SUCCESS - success   AGTIAPI_FAIL    - fail Note:       TBD, need chip register information ******************************************************************************/
end_comment

begin_function
unit|STATIC
name|agBOOLEAN
name|agtiapi_InitCardSW
parameter_list|(
name|struct
name|agtiapi_softc
modifier|*
name|pmsc
parameter_list|)
block|{
name|ag_card_info_t
modifier|*
name|thisCardInst
init|=
name|pmsc
operator|->
name|pCardInfo
decl_stmt|;
name|ag_resource_info_t
modifier|*
name|pRscInfo
init|=
operator|&
name|thisCardInst
operator|->
name|tiRscInfo
decl_stmt|;
name|int
name|initSWIdx
decl_stmt|;
comment|// begin: agtiapi_InitCardSW()
comment|// now init some essential locks  n agtiapi_InitCardSW
name|mtx_init
argument_list|(
operator|&
name|pmsc
operator|->
name|sendLock
argument_list|,
literal|"local q send lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|pmsc
operator|->
name|doneLock
argument_list|,
literal|"local q done lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|pmsc
operator|->
name|sendSMPLock
argument_list|,
literal|"local q send lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|pmsc
operator|->
name|doneSMPLock
argument_list|,
literal|"local q done lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|pmsc
operator|->
name|ccbLock
argument_list|,
literal|"ccb list lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|pmsc
operator|->
name|devListLock
argument_list|,
literal|"hotP devListLock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|pmsc
operator|->
name|memLock
argument_list|,
literal|"dynamic memory lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|pmsc
operator|->
name|freezeLock
argument_list|,
literal|"sim freeze lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
operator||
name|MTX_RECURSE
argument_list|)
expr_stmt|;
comment|// initialize lower layer resources
comment|//## if (pCard->flags& AGTIAPI_INIT_TIME) {
ifdef|#
directive|ifdef
name|HIALEAH_ENCRYPTION
comment|/* Enable encryption if chip supports it */
if|if
condition|(
name|pci_get_device
argument_list|(
name|pmsc
operator|->
name|pCardInfo
operator|->
name|pPCIDev
argument_list|)
operator|==
name|PCI_DEVICE_ID_HIALEAH_HBA_SPCVE
condition|)
name|pmsc
operator|->
name|encrypt
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|pmsc
operator|->
name|encrypt
condition|)
name|pRscInfo
operator|->
name|tiLoLevelResource
operator|.
name|loLevelOption
operator|.
name|encryption
operator|=
name|agTRUE
expr_stmt|;
endif|#
directive|endif
name|pmsc
operator|->
name|flags
operator|&=
operator|~
operator|(
name|AGTIAPI_PORT_INITIALIZED
operator||
name|AGTIAPI_SYS_INTR_ON
operator|)
expr_stmt|;
comment|// For now, up to 16 MSIX vectors are supported
name|thisCardInst
operator|->
name|tiRscInfo
operator|.
name|tiLoLevelResource
operator|.
name|loLevelOption
operator|.
name|maxInterruptVectors
operator|=
name|pmsc
operator|->
name|pCardInfo
operator|->
name|maxInterruptVectors
expr_stmt|;
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_InitCardSW: maxInterruptVectors set to %d"
argument_list|,
name|pmsc
operator|->
name|pCardInfo
operator|->
name|maxInterruptVectors
argument_list|)
expr_stmt|;
name|thisCardInst
operator|->
name|tiRscInfo
operator|.
name|tiLoLevelResource
operator|.
name|loLevelOption
operator|.
name|max_MSI_InterruptVectors
operator|=
literal|0
expr_stmt|;
name|thisCardInst
operator|->
name|tiRscInfo
operator|.
name|tiLoLevelResource
operator|.
name|loLevelOption
operator|.
name|flag
operator|=
literal|0
expr_stmt|;
name|pRscInfo
operator|->
name|tiLoLevelResource
operator|.
name|loLevelOption
operator|.
name|maxNumOSLocks
operator|=
literal|0
expr_stmt|;
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_InitCardSW: tiCOMInit root %p, dev %p, pmsc %p\n"
argument_list|,
operator|&
name|pmsc
operator|->
name|tiRoot
argument_list|,
name|pmsc
operator|->
name|my_dev
argument_list|,
name|pmsc
argument_list|)
expr_stmt|;
if|if
condition|(
name|tiCOMInit
argument_list|(
operator|&
name|pmsc
operator|->
name|tiRoot
argument_list|,
operator|&
name|thisCardInst
operator|->
name|tiRscInfo
operator|.
name|tiLoLevelResource
argument_list|,
operator|&
name|thisCardInst
operator|->
name|tiRscInfo
operator|.
name|tiInitiatorResource
argument_list|,
name|NULL
argument_list|,
operator|&
name|thisCardInst
operator|->
name|tiRscInfo
operator|.
name|tiSharedMem
argument_list|)
operator|!=
name|tiSuccess
condition|)
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_InitCardSW: tiCOMInit ERROR\n"
argument_list|)
expr_stmt|;
return|return
name|AGTIAPI_FAIL
return|;
block|}
name|int
name|maxLocks
decl_stmt|;
name|maxLocks
operator|=
name|pRscInfo
operator|->
name|tiLoLevelResource
operator|.
name|loLevelOption
operator|.
name|numOfQueuesPerPort
expr_stmt|;
name|pmsc
operator|->
name|STLock
operator|=
name|malloc
argument_list|(
operator|(
name|maxLocks
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|mtx
argument_list|)
operator|)
argument_list|,
name|M_PMC_MSTL
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
for|for
control|(
name|initSWIdx
operator|=
literal|0
init|;
name|initSWIdx
operator|<
name|maxLocks
condition|;
name|initSWIdx
operator|++
control|)
block|{
comment|// init all indexes
name|mtx_init
argument_list|(
operator|&
name|pmsc
operator|->
name|STLock
index|[
name|initSWIdx
index|]
argument_list|,
literal|"LL& TD lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tiCOMPortInit
argument_list|(
operator|&
name|pmsc
operator|->
name|tiRoot
argument_list|,
name|agFALSE
argument_list|)
operator|!=
name|tiSuccess
condition|)
block|{
name|printf
argument_list|(
literal|"agtiapi_InitCardSW: tiCOMPortInit ERROR -- AGTIAPI_FAIL\n"
argument_list|)
expr_stmt|;
return|return
name|AGTIAPI_FAIL
return|;
block|}
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_InitCardSW: tiCOMPortInit"
literal|" root %p, dev %p, pmsc %p\n"
argument_list|,
operator|&
name|pmsc
operator|->
name|tiRoot
argument_list|,
name|pmsc
operator|->
name|my_dev
argument_list|,
name|pmsc
argument_list|)
expr_stmt|;
name|pmsc
operator|->
name|flags
operator||=
name|AGTIAPI_PORT_INITIALIZED
expr_stmt|;
name|pmsc
operator|->
name|freezeSim
operator|=
name|agFALSE
expr_stmt|;
ifdef|#
directive|ifdef
name|HIALEAH_ENCRYPTION
name|atomic_set
argument_list|(
operator|&
name|outstanding_encrypted_io_count
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*fix below*/
comment|/*if(pmsc->encrypt&& (pmsc->flags& AGTIAPI_INIT_TIME)) 	   if((agtiapi_SetupEncryptionPools(pmsc)) != 0) 	     printf("SetupEncryptionPools failed\n"); */
endif|#
directive|endif
return|return
name|AGTIAPI_SUCCESS
return|;
comment|// end: agtiapi_InitCardSW()
block|}
end_function

begin_comment
comment|/****************************************************************************** agtiapi_InitCardHW()  Purpose:   Host Bus Adapter Initialization Parameters:    struct agtiapi_softc *pmsc (IN)  Pointer to the HBA data structure Return:   AGTIAPI_SUCCESS - success   AGTIAPI_FAIL    - fail Note:       TBD, need chip register information ******************************************************************************/
end_comment

begin_function
name|STATIC
name|agBOOLEAN
name|agtiapi_InitCardHW
parameter_list|(
name|struct
name|agtiapi_softc
modifier|*
name|pmsc
parameter_list|)
block|{
name|U32
name|numVal
decl_stmt|;
name|U32
name|count
decl_stmt|;
name|U32
name|loop
decl_stmt|;
comment|// begin: agtiapi_InitCardHW()
name|ag_portal_info_t
modifier|*
name|pPortalInfo
init|=
name|NULL
decl_stmt|;
name|ag_portal_data_t
modifier|*
name|pPortalData
decl_stmt|;
comment|// ISR is registered, enable chip interrupt.
name|tiCOMSystemInterruptsActive
argument_list|(
operator|&
name|pmsc
operator|->
name|tiRoot
argument_list|,
name|agTRUE
argument_list|)
expr_stmt|;
name|pmsc
operator|->
name|flags
operator||=
name|AGTIAPI_SYS_INTR_ON
expr_stmt|;
name|numVal
operator|=
sizeof|sizeof
argument_list|(
name|ag_device_t
argument_list|)
operator|*
name|pmsc
operator|->
name|devDiscover
expr_stmt|;
name|pmsc
operator|->
name|pDevList
operator|=
operator|(
name|ag_device_t
operator|*
operator|)
name|malloc
argument_list|(
name|numVal
argument_list|,
name|M_PMC_MDVT
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pmsc
operator|->
name|pDevList
condition|)
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_InitCardHW: kmalloc %d DevList ERROR\n"
argument_list|,
name|numVal
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"agtiapi_InitCardHW\n"
argument_list|)
expr_stmt|;
return|return
name|AGTIAPI_FAIL
return|;
block|}
ifdef|#
directive|ifdef
name|LINUX_PERBI_SUPPORT
name|numVal
operator|=
sizeof|sizeof
argument_list|(
name|ag_slr_map_t
argument_list|)
operator|*
name|pmsc
operator|->
name|devDiscover
expr_stmt|;
name|pmsc
operator|->
name|pSLRList
operator|=
operator|(
name|ag_slr_map_t
operator|*
operator|)
name|malloc
argument_list|(
name|numVal
argument_list|,
name|M_PMC_MSLR
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pmsc
operator|->
name|pSLRList
condition|)
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_InitCardHW: kmalloc %d SLRList ERROR\n"
argument_list|,
name|numVal
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"agtiapi_InitCardHW SLRL\n"
argument_list|)
expr_stmt|;
return|return
name|AGTIAPI_FAIL
return|;
block|}
name|numVal
operator|=
sizeof|sizeof
argument_list|(
name|ag_tgt_map_t
argument_list|)
operator|*
name|pmsc
operator|->
name|devDiscover
expr_stmt|;
name|pmsc
operator|->
name|pWWNList
operator|=
operator|(
name|ag_tgt_map_t
operator|*
operator|)
name|malloc
argument_list|(
name|numVal
argument_list|,
name|M_PMC_MTGT
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pmsc
operator|->
name|pWWNList
condition|)
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_InitCardHW: kmalloc %d WWNList ERROR\n"
argument_list|,
name|numVal
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"agtiapi_InitCardHW WWNL\n"
argument_list|)
expr_stmt|;
return|return
name|AGTIAPI_FAIL
return|;
block|}
comment|// Get the WWN_to_target_ID mappings from the
comment|// holding area which contains the input of the
comment|// system configuration file.
if|if
condition|(
name|ag_Perbi
condition|)
name|agtiapi_GetWWNMappings
argument_list|(
name|pmsc
argument_list|,
name|agMappingList
argument_list|)
expr_stmt|;
else|else
block|{
name|agtiapi_GetWWNMappings
argument_list|(
name|pmsc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|agMappingList
condition|)
name|printf
argument_list|(
literal|"agtiapi_InitCardHW: WWN PERBI disabled WARN\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|//agtiapi_DelaySec(5);
name|DELAY
argument_list|(
literal|500000
argument_list|)
expr_stmt|;
name|pmsc
operator|->
name|tgtCount
operator|=
literal|0
expr_stmt|;
name|pmsc
operator|->
name|flags
operator|&=
operator|~
name|AGTIAPI_CB_DONE
expr_stmt|;
name|pPortalData
operator|=
name|pmsc
operator|->
name|pPortalData
expr_stmt|;
comment|//start port
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|pmsc
operator|->
name|portCount
condition|;
name|count
operator|++
control|)
block|{
name|AG_SPIN_LOCK_IRQ
argument_list|(
name|agtiapi_host_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|pPortalInfo
operator|=
operator|&
name|pPortalData
operator|->
name|portalInfo
expr_stmt|;
name|pPortalInfo
operator|->
name|portStatus
operator|&=
operator|~
operator|(
name|AGTIAPI_PORT_START
operator||
name|AGTIAPI_PORT_DISC_READY
operator||
name|AGTIAPI_DISC_DONE
operator||
name|AGTIAPI_DISC_COMPLETE
operator|)
expr_stmt|;
for|for
control|(
name|loop
operator|=
literal|0
init|;
name|loop
operator|<
name|AGTIAPI_LOOP_MAX
condition|;
name|loop
operator|++
control|)
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"tiCOMPortStart entry data %p / %d / %p\n"
argument_list|,
operator|&
name|pmsc
operator|->
name|tiRoot
argument_list|,
name|pPortalInfo
operator|->
name|portID
argument_list|,
operator|&
name|pPortalInfo
operator|->
name|tiPortalContext
argument_list|)
expr_stmt|;
if|if
condition|(
name|tiCOMPortStart
argument_list|(
operator|&
name|pmsc
operator|->
name|tiRoot
argument_list|,
name|pPortalInfo
operator|->
name|portID
argument_list|,
operator|&
name|pPortalInfo
operator|->
name|tiPortalContext
argument_list|,
literal|0
argument_list|)
operator|!=
name|tiSuccess
condition|)
block|{
name|AG_SPIN_UNLOCK_IRQ
argument_list|(
name|agtiapi_host_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|agtiapi_DelayMSec
argument_list|(
name|AGTIAPI_EXTRA_DELAY
argument_list|)
expr_stmt|;
name|AG_SPIN_LOCK_IRQ
argument_list|(
name|agtiapi_host_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|AGTIAPI_PRINTK
argument_list|(
literal|"tiCOMPortStart failed -- no loop, portalData %p\n"
argument_list|,
name|pPortalData
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"tiCOMPortStart success no loop, portalData %p\n"
argument_list|,
name|pPortalData
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|// end of for loop
comment|/* release lock */
name|AG_SPIN_UNLOCK_IRQ
argument_list|(
name|agtiapi_host_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|loop
operator|>=
name|AGTIAPI_LOOP_MAX
condition|)
block|{
return|return
name|AGTIAPI_FAIL
return|;
block|}
name|tiCOMGetPortInfo
argument_list|(
operator|&
name|pmsc
operator|->
name|tiRoot
argument_list|,
operator|&
name|pPortalInfo
operator|->
name|tiPortalContext
argument_list|,
operator|&
name|pPortalInfo
operator|->
name|tiPortInfo
argument_list|)
expr_stmt|;
name|pPortalData
operator|++
expr_stmt|;
block|}
comment|/* discover target device */
ifndef|#
directive|ifndef
name|HOTPLUG_SUPPORT
name|agtiapi_DiscoverTgt
argument_list|(
name|pCard
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pmsc
operator|->
name|flags
operator||=
name|AGTIAPI_INSTALLED
expr_stmt|;
if|if
condition|(
name|pmsc
operator|->
name|flags
operator|&
name|AGTIAPI_INIT_TIME
condition|)
block|{
name|agtiapi_TITimer
argument_list|(
operator|(
name|void
operator|*
operator|)
name|pmsc
argument_list|)
expr_stmt|;
name|pmsc
operator|->
name|flags
operator||=
name|AGTIAPI_TIMER_ON
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************** agtiapi_IntrHandlerx_()  Purpose:   Interrupt service routine. Parameters:   void arg (IN)              Pointer to the HBA data structure   bit32 idx (IN)             Vector index ******************************************************************************/
end_comment

begin_function
name|void
name|agtiapi_IntrHandlerx_
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|index
parameter_list|)
block|{
name|struct
name|agtiapi_softc
modifier|*
name|pCard
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|pCard
operator|=
operator|(
expr|struct
name|agtiapi_softc
operator|*
operator|)
name|arg
expr_stmt|;
ifndef|#
directive|ifndef
name|AGTIAPI_DPC
name|ccb_t
modifier|*
name|pccb
decl_stmt|;
endif|#
directive|endif
name|AG_LOCAL_LOCK
argument_list|(
operator|&
operator|(
name|pCard
operator|->
name|pCardInfo
operator|->
name|pmIOLock
operator|)
argument_list|)
expr_stmt|;
name|AG_PERF_SPINLOCK
argument_list|(
name|agtiapi_host_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|pCard
operator|->
name|flags
operator|&
name|AGTIAPI_SHUT_DOWN
condition|)
goto|goto
name|ext
goto|;
name|rv
operator|=
name|tiCOMInterruptHandler
argument_list|(
operator|&
name|pCard
operator|->
name|tiRoot
argument_list|,
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|==
name|agFALSE
condition|)
block|{
comment|/* not our irq */
name|AG_SPIN_UNLOCK
argument_list|(
name|agtiapi_host_lock
argument_list|)
expr_stmt|;
name|AG_LOCAL_UNLOCK
argument_list|(
operator|&
operator|(
name|pCard
operator|->
name|pCardInfo
operator|->
name|pmIOLock
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|AGTIAPI_DPC
name|tasklet_hi_schedule
argument_list|(
operator|&
name|pCard
operator|->
name|tasklet_dpc
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* consume all completed entries, 100 is random number to be big enough */
name|tiCOMDelayedInterruptHandler
argument_list|(
operator|&
name|pCard
operator|->
name|tiRoot
argument_list|,
name|index
argument_list|,
literal|100
argument_list|,
name|tiInterruptContext
argument_list|)
expr_stmt|;
name|AG_GET_DONE_PCCB
argument_list|(
name|pccb
argument_list|,
name|pCard
argument_list|)
expr_stmt|;
name|AG_GET_DONE_SMP_PCCB
argument_list|(
name|pccb
argument_list|,
name|pCard
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ext
label|:
name|AG_SPIN_UNLOCK
argument_list|(
name|agtiapi_host_lock
argument_list|)
expr_stmt|;
name|AG_LOCAL_UNLOCK
argument_list|(
operator|&
operator|(
name|pCard
operator|->
name|pCardInfo
operator|->
name|pmIOLock
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/****************************************************************************** agtiapi_IntrHandler0() Purpose:     Interrupt service routine for interrupt vector index 0. Parameters:  void arg (IN)       Pointer to the HBA data structure ******************************************************************************/
end_comment

begin_function
name|void
name|agtiapi_IntrHandler0
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|agtiapi_IntrHandlerx_
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/****************************************************************************** agtiapi_IntrHandler1() Purpose:     Interrupt service routine for interrupt vector index 1. Parameters:  void arg (IN)       Pointer to the HBA data structure ******************************************************************************/
end_comment

begin_function
name|void
name|agtiapi_IntrHandler1
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|agtiapi_IntrHandlerx_
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/****************************************************************************** agtiapi_IntrHandler2() Purpose:     Interrupt service routine for interrupt vector index 2. Parameters:  void arg (IN)       Pointer to the HBA data structure ******************************************************************************/
end_comment

begin_function
name|void
name|agtiapi_IntrHandler2
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|agtiapi_IntrHandlerx_
argument_list|(
name|arg
argument_list|,
literal|2
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/****************************************************************************** agtiapi_IntrHandler3() Purpose:     Interrupt service routine for interrupt vector index 3. Parameters:  void arg (IN)       Pointer to the HBA data structure ******************************************************************************/
end_comment

begin_function
name|void
name|agtiapi_IntrHandler3
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|agtiapi_IntrHandlerx_
argument_list|(
name|arg
argument_list|,
literal|3
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/****************************************************************************** agtiapi_IntrHandler4() Purpose:     Interrupt service routine for interrupt vector index 4. Parameters:  void arg (IN)       Pointer to the HBA data structure ******************************************************************************/
end_comment

begin_function
name|void
name|agtiapi_IntrHandler4
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|agtiapi_IntrHandlerx_
argument_list|(
name|arg
argument_list|,
literal|4
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/****************************************************************************** agtiapi_IntrHandler5() Purpose:     Interrupt service routine for interrupt vector index 5. Parameters:  void arg (IN)       Pointer to the HBA data structure ******************************************************************************/
end_comment

begin_function
name|void
name|agtiapi_IntrHandler5
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|agtiapi_IntrHandlerx_
argument_list|(
name|arg
argument_list|,
literal|5
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/****************************************************************************** agtiapi_IntrHandler6() Purpose:     Interrupt service routine for interrupt vector index 6. Parameters:  void arg (IN)       Pointer to the HBA data structure ******************************************************************************/
end_comment

begin_function
name|void
name|agtiapi_IntrHandler6
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|agtiapi_IntrHandlerx_
argument_list|(
name|arg
argument_list|,
literal|6
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/****************************************************************************** agtiapi_IntrHandler7() Purpose:     Interrupt service routine for interrupt vector index 7. Parameters:  void arg (IN)       Pointer to the HBA data structure ******************************************************************************/
end_comment

begin_function
name|void
name|agtiapi_IntrHandler7
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|agtiapi_IntrHandlerx_
argument_list|(
name|arg
argument_list|,
literal|7
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/****************************************************************************** agtiapi_IntrHandler8() Purpose:     Interrupt service routine for interrupt vector index 8. Parameters:  void arg (IN)       Pointer to the HBA data structure ******************************************************************************/
end_comment

begin_function
name|void
name|agtiapi_IntrHandler8
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|agtiapi_IntrHandlerx_
argument_list|(
name|arg
argument_list|,
literal|8
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/****************************************************************************** agtiapi_IntrHandler9() Purpose:     Interrupt service routine for interrupt vector index 9. Parameters:  void arg (IN)       Pointer to the HBA data structure ******************************************************************************/
end_comment

begin_function
name|void
name|agtiapi_IntrHandler9
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|agtiapi_IntrHandlerx_
argument_list|(
name|arg
argument_list|,
literal|9
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/****************************************************************************** agtiapi_IntrHandler10() Purpose:     Interrupt service routine for interrupt vector index 10. Parameters:  void arg (IN)       Pointer to the HBA data structure ******************************************************************************/
end_comment

begin_function
name|void
name|agtiapi_IntrHandler10
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|agtiapi_IntrHandlerx_
argument_list|(
name|arg
argument_list|,
literal|10
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/****************************************************************************** agtiapi_IntrHandler11() Purpose:     Interrupt service routine for interrupt vector index 11. Parameters:  void arg (IN)       Pointer to the HBA data structure ******************************************************************************/
end_comment

begin_function
name|void
name|agtiapi_IntrHandler11
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|agtiapi_IntrHandlerx_
argument_list|(
name|arg
argument_list|,
literal|11
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/****************************************************************************** agtiapi_IntrHandler12() Purpose:     Interrupt service routine for interrupt vector index 12. Parameters:  void arg (IN)       Pointer to the HBA data structure ******************************************************************************/
end_comment

begin_function
name|void
name|agtiapi_IntrHandler12
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|agtiapi_IntrHandlerx_
argument_list|(
name|arg
argument_list|,
literal|12
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/****************************************************************************** agtiapi_IntrHandler13() Purpose:     Interrupt service routine for interrupt vector index 13. Parameters:  void arg (IN)       Pointer to the HBA data structure ******************************************************************************/
end_comment

begin_function
name|void
name|agtiapi_IntrHandler13
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|agtiapi_IntrHandlerx_
argument_list|(
name|arg
argument_list|,
literal|13
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/****************************************************************************** agtiapi_IntrHandler14() Purpose:     Interrupt service routine for interrupt vector index 14. Parameters:  void arg (IN)       Pointer to the HBA data structure ******************************************************************************/
end_comment

begin_function
name|void
name|agtiapi_IntrHandler14
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|agtiapi_IntrHandlerx_
argument_list|(
name|arg
argument_list|,
literal|14
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/****************************************************************************** agtiapi_IntrHandler15() Purpose:     Interrupt service routine for interrupt vector index 15. Parameters:  void arg (IN)       Pointer to the HBA data structure ******************************************************************************/
end_comment

begin_function
name|void
name|agtiapi_IntrHandler15
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|agtiapi_IntrHandlerx_
argument_list|(
name|arg
argument_list|,
literal|15
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|agtiapi_SglMemoryCB
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|dm_segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|bus_addr_t
modifier|*
name|addr
decl_stmt|;
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_SglMemoryCB: start\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_SglMemoryCB: error %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"agtiapi_SglMemoryCB: error %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return;
block|}
name|addr
operator|=
name|arg
expr_stmt|;
operator|*
name|addr
operator|=
name|dm_segs
index|[
literal|0
index|]
operator|.
name|ds_addr
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|agtiapi_MemoryCB
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|dm_segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|bus_addr_t
modifier|*
name|addr
decl_stmt|;
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_MemoryCB: start\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_MemoryCB: error %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"agtiapi_MemoryCB: error %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return;
block|}
name|addr
operator|=
name|arg
expr_stmt|;
operator|*
name|addr
operator|=
name|dm_segs
index|[
literal|0
index|]
operator|.
name|ds_addr
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/****************************************************************************** agtiapi_alloc_requests()  Purpose:   Allocates resources such as dma tag and timer Parameters:    struct agtiapi_softc *pmsc (IN)  Pointer to the HBA data structure Return:   AGTIAPI_SUCCESS - success   AGTIAPI_FAIL    - fail Note:     ******************************************************************************/
end_comment

begin_function
name|int
name|agtiapi_alloc_requests
parameter_list|(
name|struct
name|agtiapi_softc
modifier|*
name|pmcsc
parameter_list|)
block|{
name|int
name|rsize
decl_stmt|,
name|nsegs
decl_stmt|;
name|U32
name|next_tick
decl_stmt|;
name|nsegs
operator|=
name|AGTIAPI_NSEGS
expr_stmt|;
name|rsize
operator|=
name|AGTIAPI_MAX_DMA_SEGS
expr_stmt|;
comment|// 128
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_alloc_requests: MAXPHYS 0x%x PAGE_SIZE 0x%x \n"
argument_list|,
name|MAXPHYS
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_alloc_requests: nsegs %d rsize %d \n"
argument_list|,
name|nsegs
argument_list|,
name|rsize
argument_list|)
expr_stmt|;
comment|// 32, 128
comment|// This is for csio->data_ptr
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|agNULL
argument_list|,
comment|// parent
literal|1
argument_list|,
comment|// alignment
literal|0
argument_list|,
comment|// boundary
name|BUS_SPACE_MAXADDR
argument_list|,
comment|// lowaddr
name|BUS_SPACE_MAXADDR
argument_list|,
comment|// highaddr
name|NULL
argument_list|,
comment|// filter
name|NULL
argument_list|,
comment|// filterarg
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
comment|// maxsize
name|nsegs
argument_list|,
comment|// nsegments
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
comment|// maxsegsize
name|BUS_DMA_ALLOCNOW
argument_list|,
comment|// flags
name|busdma_lock_mutex
argument_list|,
comment|// lockfunc
operator|&
name|pmcsc
operator|->
name|pCardInfo
operator|->
name|pmIOLock
argument_list|,
comment|// lockarg
operator|&
name|pmcsc
operator|->
name|buffer_dmat
argument_list|)
condition|)
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_alloc_requests: Cannot alloc request DMA tag\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|// This is for tiSgl_t of pccb in agtiapi_PrepCCBs()
name|rsize
operator|=
operator|(
sizeof|sizeof
argument_list|(
name|tiSgl_t
argument_list|)
operator|*
name|AGTIAPI_NSEGS
operator|)
operator|*
name|AGTIAPI_CCB_PER_DEVICE
operator|*
name|maxTargets
expr_stmt|;
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_alloc_requests: rsize %d \n"
argument_list|,
name|rsize
argument_list|)
expr_stmt|;
comment|// 32, 128
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|agNULL
argument_list|,
comment|// parent
literal|32
argument_list|,
comment|// alignment
literal|0
argument_list|,
comment|// boundary
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|// lowaddr
name|BUS_SPACE_MAXADDR
argument_list|,
comment|// highaddr
name|NULL
argument_list|,
comment|// filter
name|NULL
argument_list|,
comment|// filterarg
name|rsize
argument_list|,
comment|// maxsize
literal|1
argument_list|,
comment|// nsegments
name|rsize
argument_list|,
comment|// maxsegsize
name|BUS_DMA_ALLOCNOW
argument_list|,
comment|// flags
name|NULL
argument_list|,
comment|// lockfunc
name|NULL
argument_list|,
comment|// lockarg
operator|&
name|pmcsc
operator|->
name|tisgl_dmat
argument_list|)
condition|)
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_alloc_requests: Cannot alloc request DMA tag\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|pmcsc
operator|->
name|tisgl_dmat
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|pmcsc
operator|->
name|tisgl_mem
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|pmcsc
operator|->
name|tisgl_map
argument_list|)
condition|)
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_alloc_requests: Cannot allocate SGL memory\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|bzero
argument_list|(
name|pmcsc
operator|->
name|tisgl_mem
argument_list|,
name|rsize
argument_list|)
expr_stmt|;
name|bus_dmamap_load
argument_list|(
name|pmcsc
operator|->
name|tisgl_dmat
argument_list|,
name|pmcsc
operator|->
name|tisgl_map
argument_list|,
name|pmcsc
operator|->
name|tisgl_mem
argument_list|,
name|rsize
argument_list|,
name|agtiapi_SglMemoryCB
argument_list|,
operator|&
name|pmcsc
operator|->
name|tisgl_busaddr
argument_list|,
name|BUS_DMA_NOWAIT
comment|/* 0 */
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|pmcsc
operator|->
name|OS_timer_lock
argument_list|,
literal|"OS timer lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|pmcsc
operator|->
name|IO_timer_lock
argument_list|,
literal|"IO timer lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|pmcsc
operator|->
name|devRmTimerLock
argument_list|,
literal|"targ rm timer lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|callout_init_mtx
argument_list|(
operator|&
name|pmcsc
operator|->
name|OS_timer
argument_list|,
operator|&
name|pmcsc
operator|->
name|OS_timer_lock
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|callout_init_mtx
argument_list|(
operator|&
name|pmcsc
operator|->
name|IO_timer
argument_list|,
operator|&
name|pmcsc
operator|->
name|IO_timer_lock
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|callout_init_mtx
argument_list|(
operator|&
name|pmcsc
operator|->
name|devRmTimer
argument_list|,
operator|&
name|pmcsc
operator|->
name|devRmTimerLock
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|next_tick
operator|=
name|pmcsc
operator|->
name|pCardInfo
operator|->
name|tiRscInfo
operator|.
name|tiLoLevelResource
operator|.
name|loLevelOption
operator|.
name|usecsPerTick
operator|/
name|USEC_PER_TICK
expr_stmt|;
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_alloc_requests: before callout_reset, "
literal|"next_tick 0x%x\n"
argument_list|,
name|next_tick
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|pmcsc
operator|->
name|OS_timer
argument_list|,
name|next_tick
argument_list|,
name|agtiapi_TITimer
argument_list|,
name|pmcsc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************** agtiapi_alloc_ostimem()  Purpose:   Allocates memory used later in ostiAllocMemory Parameters:   struct agtiapi_softc *pmcsc (IN)  Pointer to the HBA data structure Return:   AGTIAPI_SUCCESS - success   AGTIAPI_FAIL    - fail Note:   This is a pre-allocation for ostiAllocMemory() "non-cacheable" function calls ******************************************************************************/
end_comment

begin_function
name|int
name|agtiapi_alloc_ostimem
parameter_list|(
name|struct
name|agtiapi_softc
modifier|*
name|pmcsc
parameter_list|)
block|{
name|int
name|rsize
decl_stmt|,
name|nomsize
decl_stmt|;
name|nomsize
operator|=
literal|4096
expr_stmt|;
name|rsize
operator|=
name|AGTIAPI_DYNAMIC_MAX
operator|*
name|nomsize
expr_stmt|;
comment|// 8M
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_alloc_ostimem: rsize %d \n"
argument_list|,
name|rsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|agNULL
argument_list|,
comment|// parent
literal|32
argument_list|,
comment|// alignment
literal|0
argument_list|,
comment|// boundary
name|BUS_SPACE_MAXADDR
argument_list|,
comment|// lowaddr
name|BUS_SPACE_MAXADDR
argument_list|,
comment|// highaddr
name|NULL
argument_list|,
comment|// filter
name|NULL
argument_list|,
comment|// filterarg
name|rsize
argument_list|,
comment|// maxsize (size)
literal|1
argument_list|,
comment|// number of segments
name|rsize
argument_list|,
comment|// maxsegsize
literal|0
argument_list|,
comment|// flags
name|NULL
argument_list|,
comment|// lockfunc
name|NULL
argument_list|,
comment|// lockarg
operator|&
name|pmcsc
operator|->
name|osti_dmat
argument_list|)
condition|)
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_alloc_ostimem: Can't create no-cache mem tag\n"
argument_list|)
expr_stmt|;
return|return
name|AGTIAPI_FAIL
return|;
block|}
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|pmcsc
operator|->
name|osti_dmat
argument_list|,
operator|&
name|pmcsc
operator|->
name|osti_mem
argument_list|,
name|BUS_DMA_WAITOK
operator||
name|BUS_DMA_ZERO
operator||
name|BUS_DMA_NOCACHE
argument_list|,
operator|&
name|pmcsc
operator|->
name|osti_mapp
argument_list|)
condition|)
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_alloc_ostimem: Cannot allocate cache mem %d\n"
argument_list|,
name|rsize
argument_list|)
expr_stmt|;
return|return
name|AGTIAPI_FAIL
return|;
block|}
name|bus_dmamap_load
argument_list|(
name|pmcsc
operator|->
name|osti_dmat
argument_list|,
name|pmcsc
operator|->
name|osti_mapp
argument_list|,
name|pmcsc
operator|->
name|osti_mem
argument_list|,
name|rsize
argument_list|,
name|agtiapi_MemoryCB
argument_list|,
comment|// try reuse of CB for same goal
operator|&
name|pmcsc
operator|->
name|osti_busaddr
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
comment|// populate all the ag_dma_addr_t osti_busaddr/mem fields with addresses for
comment|//  handy reference when driver is in motion
name|int
name|idx
decl_stmt|;
name|ag_card_info_t
modifier|*
name|pCardInfo
init|=
name|pmcsc
operator|->
name|pCardInfo
decl_stmt|;
name|ag_dma_addr_t
modifier|*
name|pMem
decl_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|AGTIAPI_DYNAMIC_MAX
condition|;
name|idx
operator|++
control|)
block|{
name|pMem
operator|=
operator|&
name|pCardInfo
operator|->
name|dynamicMem
index|[
name|idx
index|]
expr_stmt|;
name|pMem
operator|->
name|nocache_busaddr
operator|=
name|pmcsc
operator|->
name|osti_busaddr
operator|+
operator|(
name|idx
operator|*
name|nomsize
operator|)
expr_stmt|;
name|pMem
operator|->
name|nocache_mem
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|U64
operator|)
name|pmcsc
operator|->
name|osti_mem
operator|+
operator|(
name|idx
operator|*
name|nomsize
operator|)
operator|)
expr_stmt|;
name|pCardInfo
operator|->
name|freeDynamicMem
index|[
name|idx
index|]
operator|=
operator|&
name|pCardInfo
operator|->
name|dynamicMem
index|[
name|idx
index|]
expr_stmt|;
block|}
name|pCardInfo
operator|->
name|topOfFreeDynamicMem
operator|=
name|AGTIAPI_DYNAMIC_MAX
expr_stmt|;
return|return
name|AGTIAPI_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************** agtiapi_cam_action()  Purpose:   Parses CAM frames and triggers a corresponding action Parameters:    struct cam_sim *sim (IN)  Pointer to SIM data structure   union ccb * ccb (IN)      Pointer to CAM ccb data structure Return: Note:     ******************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|agtiapi_cam_action
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|struct
name|agtiapi_softc
modifier|*
name|pmcsc
decl_stmt|;
name|tiDeviceHandle_t
modifier|*
name|pDevHandle
init|=
name|NULL
decl_stmt|;
comment|// acts as flag as well
name|tiDeviceInfo_t
name|devInfo
decl_stmt|;
name|int
name|pathID
decl_stmt|,
name|targetID
decl_stmt|,
name|lunID
decl_stmt|;
name|int
name|lRetVal
decl_stmt|;
name|U32
name|TID
decl_stmt|;
name|U32
name|speed
init|=
literal|150000
decl_stmt|;
name|pmcsc
operator|=
name|cam_sim_softc
argument_list|(
name|sim
argument_list|)
expr_stmt|;
name|AGTIAPI_IO
argument_list|(
literal|"agtiapi_cam_action: start pmcs %p\n"
argument_list|,
name|pmcsc
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmcsc
operator|==
name|agNULL
condition|)
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_cam_action: start pmcs is NULL\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|mtx_assert
argument_list|(
operator|&
operator|(
name|pmcsc
operator|->
name|pCardInfo
operator|->
name|pmIOLock
operator|)
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|AGTIAPI_IO
argument_list|(
literal|"agtiapi_cam_action: cardNO %d func_code 0x%x\n"
argument_list|,
name|pmcsc
operator|->
name|cardNo
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
argument_list|)
expr_stmt|;
name|pathID
operator|=
name|xpt_path_path_id
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|targetID
operator|=
name|xpt_path_target_id
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|lunID
operator|=
name|xpt_path_lun_id
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|AGTIAPI_IO
argument_list|(
literal|"agtiapi_cam_action: P 0x%x T 0x%x L 0x%x\n"
argument_list|,
name|pathID
argument_list|,
name|targetID
argument_list|,
name|lunID
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
condition|)
block|{
case|case
name|XPT_PATH_INQ
case|:
block|{
name|struct
name|ccb_pathinq
modifier|*
name|cpi
decl_stmt|;
comment|/* See architecure book p180*/
name|cpi
operator|=
operator|&
name|ccb
operator|->
name|cpi
expr_stmt|;
name|cpi
operator|->
name|version_num
operator|=
literal|1
expr_stmt|;
name|cpi
operator|->
name|hba_inquiry
operator|=
name|PI_SDTR_ABLE
operator||
name|PI_TAG_ABLE
operator||
name|PI_WIDE_16
expr_stmt|;
name|cpi
operator|->
name|target_sprt
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|hba_misc
operator|=
name|PIM_NOBUSRESET
operator||
name|PIM_SEQSCAN
expr_stmt|;
name|cpi
operator|->
name|hba_eng_cnt
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|max_target
operator|=
name|maxTargets
operator|-
literal|1
expr_stmt|;
name|cpi
operator|->
name|max_lun
operator|=
name|AGTIAPI_MAX_LUN
expr_stmt|;
name|cpi
operator|->
name|maxio
operator|=
literal|1024
operator|*
literal|1024
expr_stmt|;
comment|/* Max supported I/O size, in bytes. */
name|cpi
operator|->
name|initiator_id
operator|=
literal|255
expr_stmt|;
name|strlcpy
argument_list|(
name|cpi
operator|->
name|sim_vid
argument_list|,
literal|"FreeBSD"
argument_list|,
name|SIM_IDLEN
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|cpi
operator|->
name|hba_vid
argument_list|,
literal|"PMC"
argument_list|,
name|HBA_IDLEN
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|cpi
operator|->
name|dev_name
argument_list|,
name|cam_sim_name
argument_list|(
name|sim
argument_list|)
argument_list|,
name|DEV_IDLEN
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|unit_number
operator|=
name|cam_sim_unit
argument_list|(
name|sim
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|bus_id
operator|=
name|cam_sim_bus
argument_list|(
name|sim
argument_list|)
expr_stmt|;
comment|// rate is set when XPT_GET_TRAN_SETTINGS is processed
name|cpi
operator|->
name|base_transfer_speed
operator|=
literal|150000
expr_stmt|;
name|cpi
operator|->
name|transport
operator|=
name|XPORT_SAS
expr_stmt|;
name|cpi
operator|->
name|transport_version
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|protocol
operator|=
name|PROTO_SCSI
expr_stmt|;
name|cpi
operator|->
name|protocol_version
operator|=
name|SCSI_REV_SPC3
expr_stmt|;
name|cpi
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
break|break;
block|}
case|case
name|XPT_GET_TRAN_SETTINGS
case|:
block|{
name|struct
name|ccb_trans_settings
modifier|*
name|cts
decl_stmt|;
name|struct
name|ccb_trans_settings_sas
modifier|*
name|sas
decl_stmt|;
name|struct
name|ccb_trans_settings_scsi
modifier|*
name|scsi
decl_stmt|;
if|if
condition|(
name|pmcsc
operator|->
name|flags
operator|&
name|AGTIAPI_SHUT_DOWN
condition|)
block|{
return|return;
block|}
name|cts
operator|=
operator|&
name|ccb
operator|->
name|cts
expr_stmt|;
name|sas
operator|=
operator|&
name|ccb
operator|->
name|cts
operator|.
name|xport_specific
operator|.
name|sas
expr_stmt|;
name|scsi
operator|=
operator|&
name|cts
operator|->
name|proto_specific
operator|.
name|scsi
expr_stmt|;
name|cts
operator|->
name|protocol
operator|=
name|PROTO_SCSI
expr_stmt|;
name|cts
operator|->
name|protocol_version
operator|=
name|SCSI_REV_SPC3
expr_stmt|;
name|cts
operator|->
name|transport
operator|=
name|XPORT_SAS
expr_stmt|;
name|cts
operator|->
name|transport_version
operator|=
literal|0
expr_stmt|;
name|sas
operator|->
name|valid
operator|=
name|CTS_SAS_VALID_SPEED
expr_stmt|;
comment|/* this sets the "MB/s transfers" */
if|if
condition|(
name|pmcsc
operator|!=
name|NULL
operator|&&
name|targetID
operator|>=
literal|0
operator|&&
name|targetID
operator|<
name|maxTargets
condition|)
block|{
if|if
condition|(
name|pmcsc
operator|->
name|pWWNList
operator|!=
name|NULL
condition|)
block|{
name|TID
operator|=
name|INDEX
argument_list|(
name|pmcsc
argument_list|,
name|targetID
argument_list|)
expr_stmt|;
if|if
condition|(
name|TID
operator|<
name|maxTargets
condition|)
block|{
name|pDevHandle
operator|=
name|pmcsc
operator|->
name|pDevList
index|[
name|TID
index|]
operator|.
name|pDevHandle
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|pDevHandle
condition|)
block|{
name|tiINIGetDeviceInfo
argument_list|(
operator|&
name|pmcsc
operator|->
name|tiRoot
argument_list|,
name|pDevHandle
argument_list|,
operator|&
name|devInfo
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|devInfo
operator|.
name|info
operator|.
name|devType_S_Rate
operator|&
literal|0xF
condition|)
block|{
case|case
literal|0x8
case|:
name|speed
operator|=
literal|150000
expr_stmt|;
break|break;
case|case
literal|0x9
case|:
name|speed
operator|=
literal|300000
expr_stmt|;
break|break;
case|case
literal|0xA
case|:
name|speed
operator|=
literal|600000
expr_stmt|;
break|break;
case|case
literal|0xB
case|:
name|speed
operator|=
literal|1200000
expr_stmt|;
break|break;
default|default:
name|speed
operator|=
literal|150000
expr_stmt|;
break|break;
block|}
block|}
name|sas
operator|->
name|bitrate
operator|=
name|speed
expr_stmt|;
name|scsi
operator|->
name|valid
operator|=
name|CTS_SCSI_VALID_TQ
expr_stmt|;
name|scsi
operator|->
name|flags
operator|=
name|CTS_SCSI_FLAGS_TAG_ENB
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
break|break;
block|}
case|case
name|XPT_RESET_BUS
case|:
block|{
name|lRetVal
operator|=
name|agtiapi_eh_HostReset
argument_list|(
name|pmcsc
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
comment|// usually works first time
if|if
condition|(
name|SUCCESS
operator|==
name|lRetVal
condition|)
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_cam_action: bus reset success.\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_cam_action: bus reset failed.\n"
argument_list|)
expr_stmt|;
block|}
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
break|break;
block|}
case|case
name|XPT_RESET_DEV
case|:
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
break|break;
block|}
case|case
name|XPT_ABORT
case|:
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
break|break;
block|}
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|900026
case|case
name|XPT_SMP_IO
case|:
block|{
name|agtiapi_QueueSMP
argument_list|(
name|pmcsc
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* __FreeBSD_version>= 900026 */
case|case
name|XPT_SCSI_IO
case|:
block|{
if|if
condition|(
name|pmcsc
operator|->
name|dev_scan
operator|==
name|agFALSE
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_SEL_TIMEOUT
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|pmcsc
operator|->
name|flags
operator|&
name|AGTIAPI_SHUT_DOWN
condition|)
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_cam_action: shutdown, XPT_SCSI_IO 0x%x\n"
argument_list|,
name|XPT_SCSI_IO
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_FUNC_NOTAVAIL
expr_stmt|;
break|break;
block|}
else|else
block|{
name|AGTIAPI_IO
argument_list|(
literal|"agtiapi_cam_action: Zero XPT_SCSI_IO 0x%x, doing IOs\n"
argument_list|,
name|XPT_SCSI_IO
argument_list|)
expr_stmt|;
name|agtiapi_QueueCmnd_
argument_list|(
name|pmcsc
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
case|case
name|XPT_CALC_GEOMETRY
case|:
block|{
name|cam_calc_geometry
argument_list|(
operator|&
name|ccb
operator|->
name|ccg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
break|break;
block|}
default|default:
block|{
comment|/*       XPT_SET_TRAN_SETTINGS	     */
name|AGTIAPI_IO
argument_list|(
literal|"agtiapi_cam_action: default function code 0x%x\n"
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_FUNC_NOTAVAIL
expr_stmt|;
break|break;
block|}
block|}
comment|/* switch */
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************** agtiapi_GetCCB()  Purpose:   Get a ccb from free list or allocate a new one Parameters:   struct agtiapi_softc *pmcsc (IN)  Pointer to HBA structure Return:   Pointer to a ccb structure, or NULL if not available Note: ******************************************************************************/
end_comment

begin_function
name|STATIC
name|pccb_t
name|agtiapi_GetCCB
parameter_list|(
name|struct
name|agtiapi_softc
modifier|*
name|pmcsc
parameter_list|)
block|{
name|pccb_t
name|pccb
decl_stmt|;
name|AGTIAPI_IO
argument_list|(
literal|"agtiapi_GetCCB: start\n"
argument_list|)
expr_stmt|;
name|AG_LOCAL_LOCK
argument_list|(
operator|&
name|pmcsc
operator|->
name|ccbLock
argument_list|)
expr_stmt|;
comment|/* get the ccb from the head of the free list */
if|if
condition|(
operator|(
name|pccb
operator|=
operator|(
name|pccb_t
operator|)
name|pmcsc
operator|->
name|ccbFreeList
operator|)
operator|!=
name|NULL
condition|)
block|{
name|pmcsc
operator|->
name|ccbFreeList
operator|=
operator|(
name|caddr_t
operator|*
operator|)
name|pccb
operator|->
name|pccbNext
expr_stmt|;
name|pccb
operator|->
name|pccbNext
operator|=
name|NULL
expr_stmt|;
name|pccb
operator|->
name|flags
operator|=
name|ACTIVE
expr_stmt|;
name|pccb
operator|->
name|startTime
operator|=
literal|0
expr_stmt|;
name|pmcsc
operator|->
name|activeCCB
operator|++
expr_stmt|;
name|AGTIAPI_IO
argument_list|(
literal|"agtiapi_GetCCB: re-allocated ccb %p\n"
argument_list|,
name|pccb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_GetCCB: kmalloc ERROR - no ccb allocated\n"
argument_list|)
expr_stmt|;
block|}
name|AG_LOCAL_UNLOCK
argument_list|(
operator|&
name|pmcsc
operator|->
name|ccbLock
argument_list|)
expr_stmt|;
return|return
name|pccb
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************** agtiapi_QueueCmnd_()  Purpose:   Calls for sending CCB and excuting on HBA. Parameters:   struct agtiapi_softc *pmsc (IN)  Pointer to the HBA data structure   union ccb * ccb (IN)      Pointer to CAM ccb data structure Return:   0 - Command is pending to execute   1 - Command returned without further process Note: ******************************************************************************/
end_comment

begin_function
name|int
name|agtiapi_QueueCmnd_
parameter_list|(
name|struct
name|agtiapi_softc
modifier|*
name|pmcsc
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|struct
name|ccb_scsiio
modifier|*
name|csio
init|=
operator|&
name|ccb
operator|->
name|csio
decl_stmt|;
name|pccb_t
name|pccb
init|=
name|agNULL
decl_stmt|;
comment|// call dequeue
name|int
name|status
init|=
name|tiSuccess
decl_stmt|;
name|U32
name|Channel
init|=
name|CMND_TO_CHANNEL
argument_list|(
name|ccb
argument_list|)
decl_stmt|;
name|U32
name|TID
init|=
name|CMND_TO_TARGET
argument_list|(
name|ccb
argument_list|)
decl_stmt|;
name|U32
name|LUN
init|=
name|CMND_TO_LUN
argument_list|(
name|ccb
argument_list|)
decl_stmt|;
name|AGTIAPI_IO
argument_list|(
literal|"agtiapi_QueueCmnd_: start\n"
argument_list|)
expr_stmt|;
comment|/* no support for CBD> 16 */
if|if
condition|(
name|csio
operator|->
name|cdb_len
operator|>
literal|16
condition|)
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_QueueCmnd_: unsupported CDB length %d\n"
argument_list|,
name|csio
operator|->
name|cdb_len
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&=
operator|~
name|CAM_SIM_QUEUED
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&=
operator|~
name|CAM_STATUS_MASK
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQ_INVALID
expr_stmt|;
comment|//CAM_REQ_CMP;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
name|tiError
return|;
block|}
if|if
condition|(
name|TID
operator|<
literal|0
operator|||
name|TID
operator|>=
name|maxTargets
condition|)
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_QueueCmnd_: INVALID TID ERROR\n"
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&=
operator|~
name|CAM_SIM_QUEUED
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&=
operator|~
name|CAM_STATUS_MASK
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_DEV_NOT_THERE
expr_stmt|;
comment|//CAM_REQ_CMP;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
name|tiError
return|;
block|}
comment|/* get a ccb */
if|if
condition|(
operator|(
name|pccb
operator|=
name|agtiapi_GetCCB
argument_list|(
name|pmcsc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_QueueCmnd_: GetCCB ERROR\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmcsc
operator|!=
name|NULL
condition|)
block|{
name|ag_device_t
modifier|*
name|targ
decl_stmt|;
name|TID
operator|=
name|INDEX
argument_list|(
name|pmcsc
argument_list|,
name|TID
argument_list|)
expr_stmt|;
name|targ
operator|=
operator|&
name|pmcsc
operator|->
name|pDevList
index|[
name|TID
index|]
expr_stmt|;
name|agtiapi_adjust_queue_depth
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|targ
operator|->
name|qdepth
argument_list|)
expr_stmt|;
block|}
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&=
operator|~
name|CAM_SIM_QUEUED
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&=
operator|~
name|CAM_STATUS_MASK
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQUEUE_REQ
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
name|tiBusy
return|;
block|}
name|pccb
operator|->
name|pmcsc
operator|=
name|pmcsc
expr_stmt|;
comment|/* initialize Command Control Block (CCB) */
name|pccb
operator|->
name|targetId
operator|=
name|TID
expr_stmt|;
name|pccb
operator|->
name|lun
operator|=
name|LUN
expr_stmt|;
name|pccb
operator|->
name|channel
operator|=
name|Channel
expr_stmt|;
name|pccb
operator|->
name|ccb
operator|=
name|ccb
expr_stmt|;
comment|/* for struct scsi_cmnd */
name|pccb
operator|->
name|senseLen
operator|=
name|csio
operator|->
name|sense_len
expr_stmt|;
name|pccb
operator|->
name|startTime
operator|=
name|ticks
expr_stmt|;
name|pccb
operator|->
name|pSenseData
operator|=
operator|(
name|caddr_t
operator|)
operator|&
name|csio
operator|->
name|sense_data
expr_stmt|;
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
comment|/* each channel is reserved for different addr modes */
name|pccb
operator|->
name|addrMode
operator|=
name|agtiapi_AddrModes
index|[
name|Channel
index|]
expr_stmt|;
name|status
operator|=
name|agtiapi_PrepareSGList
argument_list|(
name|pmcsc
argument_list|,
name|pccb
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|tiSuccess
condition|)
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_QueueCmnd_: agtiapi_PrepareSGList failure\n"
argument_list|)
expr_stmt|;
name|agtiapi_FreeCCB
argument_list|(
name|pmcsc
argument_list|,
name|pccb
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|tiReject
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
block|}
else|else
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
block|}
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
name|tiError
return|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************** agtiapi_DumpCDB()  Purpose:   Prints out CDB Parameters:   const char *ptitle (IN)  A string to be printed   ccb_t *pccb (IN)         A pointer to the driver's own CCB, not CAM's CCB Return: Note: ******************************************************************************/
end_comment

begin_function
name|STATIC
name|void
name|agtiapi_DumpCDB
parameter_list|(
specifier|const
name|char
modifier|*
name|ptitle
parameter_list|,
name|ccb_t
modifier|*
name|pccb
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|struct
name|ccb_scsiio
modifier|*
name|csio
decl_stmt|;
name|bit8
name|cdb
index|[
literal|64
index|]
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
name|pccb
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"agtiapi_DumpCDB: no pccb here \n"
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"agtiapi_DumpCDB: pccb is NULL. called from %s\n"
argument_list|,
name|ptitle
argument_list|)
expr_stmt|;
return|return;
block|}
name|ccb
operator|=
name|pccb
operator|->
name|ccb
expr_stmt|;
if|if
condition|(
name|ccb
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"agtiapi_DumpCDB: no ccb here \n"
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"agtiapi_DumpCDB: pccb %p ccb %p flags %d ccb NULL! "
literal|"called from %s\n"
argument_list|,
name|pccb
argument_list|,
name|pccb
operator|->
name|ccb
argument_list|,
name|pccb
operator|->
name|flags
argument_list|,
name|ptitle
argument_list|)
expr_stmt|;
return|return;
block|}
name|csio
operator|=
operator|&
name|ccb
operator|->
name|csio
expr_stmt|;
if|if
condition|(
name|csio
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"agtiapi_DumpCDB: no csio here \n"
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"agtiapi_DumpCDB: pccb%p ccb%p flags%d csio NULL! called from %s\n"
argument_list|,
name|pccb
argument_list|,
name|pccb
operator|->
name|ccb
argument_list|,
name|pccb
operator|->
name|flags
argument_list|,
name|ptitle
argument_list|)
expr_stmt|;
return|return;
block|}
name|len
operator|=
name|MIN
argument_list|(
literal|64
argument_list|,
name|csio
operator|->
name|cdb_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|csio
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_CDB_POINTER
condition|)
block|{
name|bcopy
argument_list|(
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_ptr
argument_list|,
operator|&
name|cdb
index|[
literal|0
index|]
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bcopy
argument_list|(
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
argument_list|,
operator|&
name|cdb
index|[
literal|0
index|]
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
name|AGTIAPI_IO
argument_list|(
literal|"agtiapi_DumpCDB: pccb%p CDB0x%x csio->cdb_len %d"
literal|" len %d from %s\n"
argument_list|,
name|pccb
argument_list|,
name|cdb
index|[
literal|0
index|]
argument_list|,
name|csio
operator|->
name|cdb_len
argument_list|,
name|len
argument_list|,
name|ptitle
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/****************************************************************************** agtiapi_DoSoftReset()  Purpose:   Do card reset Parameters:   *data (IN)               point to pmcsc (struct agtiapi_softc *) Return: Note: ******************************************************************************/
end_comment

begin_function
name|int
name|agtiapi_DoSoftReset
parameter_list|(
name|struct
name|agtiapi_softc
modifier|*
name|pmcsc
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
name|pmcsc
operator|->
name|flags
operator||=
name|AGTIAPI_SOFT_RESET
expr_stmt|;
name|AG_SPIN_LOCK_IRQ
argument_list|(
name|agtiapi_host_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|ret
operator|=
name|agtiapi_ResetCard
argument_list|(
name|pmcsc
argument_list|,
operator|&
name|flags
argument_list|)
expr_stmt|;
name|AG_SPIN_UNLOCK_IRQ
argument_list|(
name|agtiapi_host_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|AGTIAPI_SUCCESS
condition|)
return|return
name|tiError
return|;
return|return
name|SUCCESS
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************** agtiapi_CheckIOTimeout()  Purpose:   Timeout function for SCSI IO or TM  Parameters:   *data (IN)               point to pCard (ag_card_t *) Return: Note: ******************************************************************************/
end_comment

begin_function
name|STATIC
name|void
name|agtiapi_CheckIOTimeout
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|U32
name|status
init|=
name|AGTIAPI_SUCCESS
decl_stmt|;
name|ccb_t
modifier|*
name|pccb
decl_stmt|;
name|struct
name|agtiapi_softc
modifier|*
name|pmcsc
decl_stmt|;
name|pccb_t
name|pccb_curr
decl_stmt|;
name|pccb_t
name|pccb_next
decl_stmt|;
name|pmcsc
operator|=
operator|(
expr|struct
name|agtiapi_softc
operator|*
operator|)
name|data
expr_stmt|;
comment|//AGTIAPI_PRINTK("agtiapi_CheckIOTimeout: Enter\n");
comment|//AGTIAPI_PRINTK("agtiapi_CheckIOTimeout: Active CCB %d\n", pmcsc->activeCCB);
name|pccb
operator|=
operator|(
name|pccb_t
operator|)
name|pmcsc
operator|->
name|ccbChainList
expr_stmt|;
comment|/* if link is down, do nothing */
if|if
condition|(
operator|(
name|pccb
operator|==
name|NULL
operator|)
operator|||
operator|(
name|pmcsc
operator|->
name|activeCCB
operator|==
literal|0
operator|)
condition|)
block|{
comment|//AGTIAPI_PRINTK("agtiapi_CheckIOTimeout: goto restart_timer\n");
goto|goto
name|restart_timer
goto|;
block|}
name|AG_SPIN_LOCK_IRQ
argument_list|(
name|agtiapi_host_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmcsc
operator|->
name|flags
operator|&
name|AGTIAPI_SHUT_DOWN
condition|)
goto|goto
name|ext
goto|;
name|pccb_curr
operator|=
name|pccb
expr_stmt|;
comment|/* Walk thorugh the IO Chain linked list to find the pending io */
comment|/* Set the TM flag based on the pccb type, i.e SCSI IO or TM cmd */
while|while
condition|(
name|pccb_curr
operator|!=
name|NULL
condition|)
block|{
comment|/* start from 1st ccb in the chain */
name|pccb_next
operator|=
name|pccb_curr
operator|->
name|pccbChainNext
expr_stmt|;
if|if
condition|(
operator|(
name|pccb_curr
operator|->
name|flags
operator|==
literal|0
operator|)
operator|||
operator|(
name|pccb_curr
operator|->
name|tiIORequest
operator|.
name|tdData
operator|==
name|NULL
operator|)
operator|||
operator|(
name|pccb_curr
operator|->
name|startTime
operator|==
literal|0
operator|)
comment|/*&& (pccb->startTime == 0) */
condition|)
block|{
comment|//AGTIAPI_PRINTK("agtiapi_CheckIOTimeout: move to next element\n");
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
name|ticks
operator|-
name|pccb_curr
operator|->
name|startTime
operator|)
operator|>=
name|ag_timeout_secs
operator|)
operator|&&
operator|!
operator|(
name|pccb_curr
operator|->
name|flags
operator|&
name|TIMEDOUT
operator|)
condition|)
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_CheckIOTimeout: pccb %p timed out, call TM "
literal|"function -- flags=%x startTime=%ld tdData = %p\n"
argument_list|,
name|pccb_curr
argument_list|,
name|pccb_curr
operator|->
name|flags
argument_list|,
name|pccb
operator|->
name|startTime
argument_list|,
name|pccb_curr
operator|->
name|tiIORequest
operator|.
name|tdData
argument_list|)
expr_stmt|;
name|pccb_curr
operator|->
name|flags
operator||=
name|TIMEDOUT
expr_stmt|;
name|status
operator|=
name|agtiapi_StartTM
argument_list|(
name|pmcsc
argument_list|,
name|pccb_curr
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|AGTIAPI_SUCCESS
condition|)
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_CheckIOTimeout: TM Request sent with "
literal|"success\n"
argument_list|)
expr_stmt|;
goto|goto
name|restart_timer
goto|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|AGTIAPI_LOCAL_RESET
comment|/* abort request did not go through */
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_CheckIOTimeout: Abort request failed\n"
argument_list|)
expr_stmt|;
comment|/* TODO: call Soft reset here */
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_CheckIOTimeout:in agtiapi_CheckIOTimeout() "
literal|"abort request did not go thru ==> soft reset#7, then "
literal|"restart timer\n"
argument_list|)
expr_stmt|;
name|agtiapi_DoSoftReset
argument_list|(
name|pmcsc
argument_list|)
expr_stmt|;
goto|goto
name|restart_timer
goto|;
endif|#
directive|endif
block|}
block|}
name|pccb_curr
operator|=
name|pccb_next
expr_stmt|;
block|}
name|restart_timer
label|:
name|callout_reset
argument_list|(
operator|&
name|pmcsc
operator|->
name|IO_timer
argument_list|,
literal|1
operator|*
name|hz
argument_list|,
name|agtiapi_CheckIOTimeout
argument_list|,
name|pmcsc
argument_list|)
expr_stmt|;
name|ext
label|:
name|AG_SPIN_UNLOCK_IRQ
argument_list|(
name|agtiapi_host_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/****************************************************************************** agtiapi_StartTM()  Purpose:   DDI calls for aborting outstanding IO command  Parameters:    struct scsi_cmnd *pccb (IN) Pointer to the command to be aborted     unsigned long flags (IN/out) spinlock flags used in locking from                                calling layers Return:   AGTIAPI_SUCCESS  - success   AGTIAPI_FAIL     - fail ******************************************************************************/
end_comment

begin_function
name|int
name|agtiapi_StartTM
parameter_list|(
name|struct
name|agtiapi_softc
modifier|*
name|pCard
parameter_list|,
name|ccb_t
modifier|*
name|pccb
parameter_list|)
block|{
name|ccb_t
modifier|*
name|pTMccb
init|=
name|NULL
decl_stmt|;
name|U32
name|status
init|=
name|AGTIAPI_SUCCESS
decl_stmt|;
name|ag_device_t
modifier|*
name|pDevice
init|=
name|NULL
decl_stmt|;
name|U32
name|TMstatus
init|=
name|tiSuccess
decl_stmt|;
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_StartTM: pccb %p, pccb->flags %x\n"
argument_list|,
name|pccb
argument_list|,
name|pccb
operator|->
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|pccb
operator|==
name|NULL
condition|)
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_StartTM: %p not found\n"
argument_list|,
name|pccb
argument_list|)
expr_stmt|;
name|status
operator|=
name|AGTIAPI_SUCCESS
expr_stmt|;
goto|goto
name|ext
goto|;
block|}
if|if
condition|(
operator|!
name|pccb
operator|->
name|tiIORequest
operator|.
name|tdData
condition|)
block|{
comment|/* should not be the case */
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_StartTM: ccb %p flag 0x%x tid %d no tdData "
literal|"ERROR\n"
argument_list|,
name|pccb
argument_list|,
name|pccb
operator|->
name|flags
argument_list|,
name|pccb
operator|->
name|targetId
argument_list|)
expr_stmt|;
name|status
operator|=
name|AGTIAPI_FAIL
expr_stmt|;
block|}
else|else
block|{
comment|/* If timedout CCB is TM_ABORT_TASK command, issue LocalAbort first to        clear pending TM_ABORT_TASK */
comment|/* Else Device State will not be put back to Operational, (refer FW) */
if|if
condition|(
name|pccb
operator|->
name|flags
operator|&
name|TASK_MANAGEMENT
condition|)
block|{
if|if
condition|(
name|tiINIIOAbort
argument_list|(
operator|&
name|pCard
operator|->
name|tiRoot
argument_list|,
operator|&
name|pccb
operator|->
name|tiIORequest
argument_list|)
operator|!=
name|tiSuccess
condition|)
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_StartTM: LocalAbort Request for Abort_TASK "
literal|"TM failed\n"
argument_list|)
expr_stmt|;
comment|/* TODO: call Soft reset here */
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_StartTM: in agtiapi_StartTM() abort "
literal|"tiINIIOAbort() failed ==> soft reset#8\n"
argument_list|)
expr_stmt|;
name|agtiapi_DoSoftReset
argument_list|(
name|pCard
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_StartTM: LocalAbort for Abort_TASK TM "
literal|"Request sent\n"
argument_list|)
expr_stmt|;
name|status
operator|=
name|AGTIAPI_SUCCESS
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* get a ccb */
if|if
condition|(
operator|(
name|pTMccb
operator|=
name|agtiapi_GetCCB
argument_list|(
name|pCard
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_StartTM: TM resource unavailable!\n"
argument_list|)
expr_stmt|;
name|status
operator|=
name|AGTIAPI_FAIL
expr_stmt|;
goto|goto
name|ext
goto|;
block|}
name|pTMccb
operator|->
name|pmcsc
operator|=
name|pCard
expr_stmt|;
name|pTMccb
operator|->
name|targetId
operator|=
name|pccb
operator|->
name|targetId
expr_stmt|;
name|pTMccb
operator|->
name|devHandle
operator|=
name|pccb
operator|->
name|devHandle
expr_stmt|;
if|if
condition|(
name|pTMccb
operator|->
name|targetId
operator|>=
name|pCard
operator|->
name|devDiscover
condition|)
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_StartTM: Incorrect dev Id in TM!\n"
argument_list|)
expr_stmt|;
name|status
operator|=
name|AGTIAPI_FAIL
expr_stmt|;
goto|goto
name|ext
goto|;
block|}
if|if
condition|(
name|pTMccb
operator|->
name|targetId
operator|<
literal|0
operator|||
name|pTMccb
operator|->
name|targetId
operator|>=
name|maxTargets
condition|)
block|{
return|return
name|AGTIAPI_FAIL
return|;
block|}
if|if
condition|(
name|INDEX
argument_list|(
name|pCard
argument_list|,
name|pTMccb
operator|->
name|targetId
argument_list|)
operator|>=
name|maxTargets
condition|)
block|{
return|return
name|AGTIAPI_FAIL
return|;
block|}
name|pDevice
operator|=
operator|&
name|pCard
operator|->
name|pDevList
index|[
name|INDEX
argument_list|(
name|pCard
argument_list|,
name|pTMccb
operator|->
name|targetId
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|pDevice
operator|==
name|NULL
operator|)
operator|||
operator|!
operator|(
name|pDevice
operator|->
name|flags
operator|&
name|ACTIVE
operator|)
condition|)
block|{
return|return
name|AGTIAPI_FAIL
return|;
block|}
comment|/* save pending io to issue local abort at Task mgmt CB */
name|pTMccb
operator|->
name|pccbIO
operator|=
name|pccb
expr_stmt|;
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_StartTM: pTMccb %p flag %x tid %d via TM "
literal|"request !\n"
argument_list|,
name|pTMccb
argument_list|,
name|pTMccb
operator|->
name|flags
argument_list|,
name|pTMccb
operator|->
name|targetId
argument_list|)
expr_stmt|;
name|pTMccb
operator|->
name|flags
operator|&=
operator|~
operator|(
name|TASK_SUCCESS
operator||
name|ACTIVE
operator|)
expr_stmt|;
name|pTMccb
operator|->
name|flags
operator||=
name|TASK_MANAGEMENT
expr_stmt|;
name|TMstatus
operator|=
name|tiINITaskManagement
argument_list|(
operator|&
name|pCard
operator|->
name|tiRoot
argument_list|,
name|pccb
operator|->
name|devHandle
argument_list|,
name|AG_ABORT_TASK
argument_list|,
operator|&
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|scsiCmnd
operator|.
name|lun
argument_list|,
operator|&
name|pccb
operator|->
name|tiIORequest
argument_list|,
operator|&
name|pTMccb
operator|->
name|tiIORequest
argument_list|)
expr_stmt|;
if|if
condition|(
name|TMstatus
operator|==
name|tiSuccess
condition|)
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_StartTM: TM_ABORT_TASK request success ccb "
literal|"%p, pTMccb %p\n"
argument_list|,
name|pccb
argument_list|,
name|pTMccb
argument_list|)
expr_stmt|;
name|pTMccb
operator|->
name|startTime
operator|=
name|ticks
expr_stmt|;
name|status
operator|=
name|AGTIAPI_SUCCESS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TMstatus
operator|==
name|tiIONoDevice
condition|)
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_StartTM: TM_ABORT_TASK request tiIONoDevice ccb "
literal|"%p, pTMccb %p\n"
argument_list|,
name|pccb
argument_list|,
name|pTMccb
argument_list|)
expr_stmt|;
name|status
operator|=
name|AGTIAPI_SUCCESS
expr_stmt|;
block|}
else|else
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_StartTM: TM_ABORT_TASK request failed ccb %p, "
literal|"pTMccb %p\n"
argument_list|,
name|pccb
argument_list|,
name|pTMccb
argument_list|)
expr_stmt|;
name|status
operator|=
name|AGTIAPI_FAIL
expr_stmt|;
name|agtiapi_FreeTMCCB
argument_list|(
name|pCard
argument_list|,
name|pTMccb
argument_list|)
expr_stmt|;
comment|/* TODO */
comment|/* call TM_TARGET_RESET */
block|}
block|}
block|}
name|ext
label|:
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_StartTM: return %d flgs %x\n"
argument_list|,
name|status
argument_list|,
operator|(
name|pccb
operator|)
condition|?
name|pccb
operator|->
name|flags
else|:
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/* agtiapi_StartTM */
end_comment

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|>
literal|901000
end_if

begin_comment
comment|/****************************************************************************** agtiapi_PrepareSGList()  Purpose:   This function prepares scatter-gather list for the given ccb Parameters:   struct agtiapi_softc *pmsc (IN)  Pointer to the HBA data structure   ccb_t *pccb (IN)      A pointer to the driver's own CCB, not CAM's CCB Return:   0 - success   1 - failure  Note: ******************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|agtiapi_PrepareSGList
parameter_list|(
name|struct
name|agtiapi_softc
modifier|*
name|pmcsc
parameter_list|,
name|ccb_t
modifier|*
name|pccb
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
init|=
name|pccb
operator|->
name|ccb
decl_stmt|;
name|struct
name|ccb_scsiio
modifier|*
name|csio
init|=
operator|&
name|ccb
operator|->
name|csio
decl_stmt|;
name|struct
name|ccb_hdr
modifier|*
name|ccbh
init|=
operator|&
name|ccb
operator|->
name|ccb_h
decl_stmt|;
name|AGTIAPI_IO
argument_list|(
literal|"agtiapi_PrepareSGList: start\n"
argument_list|)
expr_stmt|;
comment|//  agtiapi_DumpCDB("agtiapi_PrepareSGList", pccb);
name|AGTIAPI_IO
argument_list|(
literal|"agtiapi_PrepareSGList: dxfer_len %d\n"
argument_list|,
name|csio
operator|->
name|dxfer_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ccbh
operator|->
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|!=
name|CAM_DIR_NONE
condition|)
block|{
switch|switch
condition|(
operator|(
name|ccbh
operator|->
name|flags
operator|&
name|CAM_DATA_MASK
operator|)
condition|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|bus_dma_segment
name|seg
decl_stmt|;
case|case
name|CAM_DATA_VADDR
case|:
comment|/* Virtual address that needs to translated into one or more physical address ranges. */
comment|//  int error;
comment|//  AG_LOCAL_LOCK(&(pmcsc->pCardInfo->pmIOLock));
name|AGTIAPI_IO
argument_list|(
literal|"agtiapi_PrepareSGList: virtual address\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|pmcsc
operator|->
name|buffer_dmat
argument_list|,
name|pccb
operator|->
name|CCB_dmamap
argument_list|,
name|csio
operator|->
name|data_ptr
argument_list|,
name|csio
operator|->
name|dxfer_len
argument_list|,
name|agtiapi_PrepareSGListCB
argument_list|,
name|pccb
argument_list|,
name|BUS_DMA_NOWAIT
comment|/* 0 */
argument_list|)
expr_stmt|;
comment|//  AG_LOCAL_UNLOCK(&(pmcsc->pCardInfo->pmIOLock) );
if|if
condition|(
name|error
operator|==
name|EINPROGRESS
condition|)
block|{
comment|/* So as to maintain ordering, freeze the controller queue until our mapping is returned. */
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_PrepareSGList: EINPROGRESS\n"
argument_list|)
expr_stmt|;
name|xpt_freeze_simq
argument_list|(
name|pmcsc
operator|->
name|sim
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pmcsc
operator|->
name|SimQFrozen
operator|=
name|agTRUE
expr_stmt|;
name|ccbh
operator|->
name|status
operator||=
name|CAM_RELEASE_SIMQ
expr_stmt|;
block|}
break|break;
case|case
name|CAM_DATA_PADDR
case|:
comment|/* We have been given a pointer to single physical buffer. */
comment|/* pccb->tiSuperScsiRequest.sglVirtualAddr = seg.ds_addr; */
comment|//struct bus_dma_segment seg;
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_PrepareSGList: physical address\n"
argument_list|)
expr_stmt|;
name|seg
operator|.
name|ds_addr
operator|=
operator|(
name|bus_addr_t
operator|)
operator|(
name|vm_offset_t
operator|)
name|csio
operator|->
name|data_ptr
expr_stmt|;
name|seg
operator|.
name|ds_len
operator|=
name|csio
operator|->
name|dxfer_len
expr_stmt|;
comment|// * 0xFF to be defined
name|agtiapi_PrepareSGListCB
argument_list|(
name|pccb
argument_list|,
operator|&
name|seg
argument_list|,
literal|1
argument_list|,
literal|0xAABBCCDD
argument_list|)
expr_stmt|;
break|break;
default|default:
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_PrepareSGList: unexpected case\n"
argument_list|)
expr_stmt|;
return|return
name|tiReject
return|;
block|}
block|}
else|else
block|{
name|agtiapi_PrepareSGListCB
argument_list|(
name|pccb
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0xAAAAAAAA
argument_list|)
expr_stmt|;
block|}
return|return
name|tiSuccess
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/****************************************************************************** agtiapi_PrepareSGList()  Purpose:   This function prepares scatter-gather list for the given ccb Parameters:   struct agtiapi_softc *pmsc (IN)  Pointer to the HBA data structure   ccb_t *pccb (IN)      A pointer to the driver's own CCB, not CAM's CCB Return:   0 - success   1 - failure  Note: ******************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|agtiapi_PrepareSGList
parameter_list|(
name|struct
name|agtiapi_softc
modifier|*
name|pmcsc
parameter_list|,
name|ccb_t
modifier|*
name|pccb
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
init|=
name|pccb
operator|->
name|ccb
decl_stmt|;
name|struct
name|ccb_scsiio
modifier|*
name|csio
init|=
operator|&
name|ccb
operator|->
name|csio
decl_stmt|;
name|struct
name|ccb_hdr
modifier|*
name|ccbh
init|=
operator|&
name|ccb
operator|->
name|ccb_h
decl_stmt|;
name|AGTIAPI_IO
argument_list|(
literal|"agtiapi_PrepareSGList: start\n"
argument_list|)
expr_stmt|;
comment|//  agtiapi_DumpCDB("agtiapi_PrepareSGList", pccb);
name|AGTIAPI_IO
argument_list|(
literal|"agtiapi_PrepareSGList: dxfer_len %d\n"
argument_list|,
name|csio
operator|->
name|dxfer_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ccbh
operator|->
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|!=
name|CAM_DIR_NONE
condition|)
block|{
if|if
condition|(
operator|(
name|ccbh
operator|->
name|flags
operator|&
name|CAM_SCATTER_VALID
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* We've been given a pointer to a single buffer. */
if|if
condition|(
operator|(
name|ccbh
operator|->
name|flags
operator|&
name|CAM_DATA_PHYS
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Virtual address that needs to translated into one or more physical address ranges. */
name|int
name|error
decl_stmt|;
comment|//  AG_LOCAL_LOCK(&(pmcsc->pCardInfo->pmIOLock));
name|AGTIAPI_IO
argument_list|(
literal|"agtiapi_PrepareSGList: virtual address\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|pmcsc
operator|->
name|buffer_dmat
argument_list|,
name|pccb
operator|->
name|CCB_dmamap
argument_list|,
name|csio
operator|->
name|data_ptr
argument_list|,
name|csio
operator|->
name|dxfer_len
argument_list|,
name|agtiapi_PrepareSGListCB
argument_list|,
name|pccb
argument_list|,
name|BUS_DMA_NOWAIT
comment|/* 0 */
argument_list|)
expr_stmt|;
comment|//  AG_LOCAL_UNLOCK(&(pmcsc->pCardInfo->pmIOLock) );
if|if
condition|(
name|error
operator|==
name|EINPROGRESS
condition|)
block|{
comment|/* So as to maintain ordering, freeze the controller queue until our mapping is returned. */
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_PrepareSGList: EINPROGRESS\n"
argument_list|)
expr_stmt|;
name|xpt_freeze_simq
argument_list|(
name|pmcsc
operator|->
name|sim
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pmcsc
operator|->
name|SimQFrozen
operator|=
name|agTRUE
expr_stmt|;
name|ccbh
operator|->
name|status
operator||=
name|CAM_RELEASE_SIMQ
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* We have been given a pointer to single physical buffer. */
comment|/* pccb->tiSuperScsiRequest.sglVirtualAddr = seg.ds_addr; */
name|struct
name|bus_dma_segment
name|seg
decl_stmt|;
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_PrepareSGList: physical address\n"
argument_list|)
expr_stmt|;
name|seg
operator|.
name|ds_addr
operator|=
operator|(
name|bus_addr_t
operator|)
operator|(
name|vm_offset_t
operator|)
name|csio
operator|->
name|data_ptr
expr_stmt|;
name|seg
operator|.
name|ds_len
operator|=
name|csio
operator|->
name|dxfer_len
expr_stmt|;
comment|// * 0xFF to be defined
name|agtiapi_PrepareSGListCB
argument_list|(
name|pccb
argument_list|,
operator|&
name|seg
argument_list|,
literal|1
argument_list|,
literal|0xAABBCCDD
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_PrepareSGList: unexpected case\n"
argument_list|)
expr_stmt|;
return|return
name|tiReject
return|;
block|}
block|}
else|else
block|{
name|agtiapi_PrepareSGListCB
argument_list|(
name|pccb
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0xAAAAAAAA
argument_list|)
expr_stmt|;
block|}
return|return
name|tiSuccess
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/****************************************************************************** agtiapi_PrepareSGListCB()  Purpose:   Callback function for bus_dmamap_load()   This fuctions sends IO to LL layer. Parameters:   void *arg (IN)                Pointer to the HBA data structure   bus_dma_segment_t *segs (IN)  Pointer to dma segment   int nsegs (IN)                number of dma segment   int error (IN)                error Return: Note: ******************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|agtiapi_PrepareSGListCB
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nsegs
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|pccb_t
name|pccb
init|=
name|arg
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
init|=
name|pccb
operator|->
name|ccb
decl_stmt|;
name|struct
name|ccb_scsiio
modifier|*
name|csio
init|=
operator|&
name|ccb
operator|->
name|csio
decl_stmt|;
name|struct
name|agtiapi_softc
modifier|*
name|pmcsc
decl_stmt|;
name|tiIniScsiCmnd_t
modifier|*
name|pScsiCmnd
decl_stmt|;
name|bit32
name|i
decl_stmt|;
name|bus_dmasync_op_t
name|op
decl_stmt|;
name|U32_64
name|phys_addr
decl_stmt|;
name|U08
modifier|*
name|CDB
decl_stmt|;
name|int
name|io_is_encryptable
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|long
name|start_lba
init|=
literal|0
decl_stmt|;
name|ag_device_t
modifier|*
name|pDev
decl_stmt|;
name|U32
name|TID
init|=
name|CMND_TO_TARGET
argument_list|(
name|ccb
argument_list|)
decl_stmt|;
name|AGTIAPI_IO
argument_list|(
literal|"agtiapi_PrepareSGListCB: start, nsegs %d error 0x%x\n"
argument_list|,
name|nsegs
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|pmcsc
operator|=
name|pccb
operator|->
name|pmcsc
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|tiSuccess
condition|)
block|{
if|if
condition|(
name|error
operator|==
literal|0xAABBCCDD
operator|||
name|error
operator|==
literal|0xAAAAAAAA
condition|)
block|{
comment|// do nothing
block|}
else|else
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_PrepareSGListCB: error status 0x%x\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|pmcsc
operator|->
name|buffer_dmat
argument_list|,
name|pccb
operator|->
name|CCB_dmamap
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|pmcsc
operator|->
name|buffer_dmat
argument_list|,
name|pccb
operator|->
name|CCB_dmamap
argument_list|)
expr_stmt|;
name|agtiapi_FreeCCB
argument_list|(
name|pmcsc
argument_list|,
name|pccb
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|nsegs
operator|>
name|AGTIAPI_MAX_DMA_SEGS
condition|)
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_PrepareSGListCB: over the limit. nsegs %d"
literal|" AGTIAPI_MAX_DMA_SEGS %d\n"
argument_list|,
name|nsegs
argument_list|,
name|AGTIAPI_MAX_DMA_SEGS
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|pmcsc
operator|->
name|buffer_dmat
argument_list|,
name|pccb
operator|->
name|CCB_dmamap
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|pmcsc
operator|->
name|buffer_dmat
argument_list|,
name|pccb
operator|->
name|CCB_dmamap
argument_list|)
expr_stmt|;
name|agtiapi_FreeCCB
argument_list|(
name|pmcsc
argument_list|,
name|pccb
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* fill in IO information */
name|pccb
operator|->
name|dataLen
operator|=
name|csio
operator|->
name|dxfer_len
expr_stmt|;
comment|/* start fill in sgl structure */
if|if
condition|(
name|nsegs
operator|==
literal|1
operator|&&
name|error
operator|==
literal|0xAABBCCDD
condition|)
block|{
comment|/* to be tested */
comment|/* A single physical buffer */
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_PrepareSGListCB: nsegs is 1\n"
argument_list|)
expr_stmt|;
name|CPU_TO_LE32
argument_list|(
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|agSgl1
argument_list|,
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
argument_list|)
expr_stmt|;
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|agSgl1
operator|.
name|len
operator|=
name|htole32
argument_list|(
name|pccb
operator|->
name|dataLen
argument_list|)
expr_stmt|;
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|agSgl1
operator|.
name|type
operator|=
name|htole32
argument_list|(
name|tiSgl
argument_list|)
expr_stmt|;
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|sglVirtualAddr
operator|=
operator|(
name|void
operator|*
operator|)
name|segs
operator|->
name|ds_addr
expr_stmt|;
name|pccb
operator|->
name|numSgElements
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nsegs
operator|==
literal|0
operator|&&
name|error
operator|==
literal|0xAAAAAAAA
condition|)
block|{
comment|/* no data transfer */
name|AGTIAPI_IO
argument_list|(
literal|"agtiapi_PrepareSGListCB: no data transfer\n"
argument_list|)
expr_stmt|;
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|agSgl1
operator|.
name|len
operator|=
literal|0
expr_stmt|;
name|pccb
operator|->
name|dataLen
operator|=
literal|0
expr_stmt|;
name|pccb
operator|->
name|numSgElements
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* virtual/logical buffer */
if|if
condition|(
name|nsegs
operator|==
literal|1
condition|)
block|{
name|pccb
operator|->
name|dataLen
operator|=
name|segs
index|[
literal|0
index|]
operator|.
name|ds_len
expr_stmt|;
name|CPU_TO_LE32
argument_list|(
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|agSgl1
argument_list|,
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
argument_list|)
expr_stmt|;
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|agSgl1
operator|.
name|type
operator|=
name|htole32
argument_list|(
name|tiSgl
argument_list|)
expr_stmt|;
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|agSgl1
operator|.
name|len
operator|=
name|htole32
argument_list|(
name|segs
index|[
literal|0
index|]
operator|.
name|ds_len
argument_list|)
expr_stmt|;
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|sglVirtualAddr
operator|=
operator|(
name|void
operator|*
operator|)
name|csio
operator|->
name|data_ptr
expr_stmt|;
name|pccb
operator|->
name|numSgElements
operator|=
name|nsegs
expr_stmt|;
block|}
else|else
block|{
name|pccb
operator|->
name|dataLen
operator|=
literal|0
expr_stmt|;
comment|/* loop */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsegs
condition|;
name|i
operator|++
control|)
block|{
name|pccb
operator|->
name|sgList
index|[
name|i
index|]
operator|.
name|len
operator|=
name|htole32
argument_list|(
name|segs
index|[
name|i
index|]
operator|.
name|ds_len
argument_list|)
expr_stmt|;
name|CPU_TO_LE32
argument_list|(
name|pccb
operator|->
name|sgList
index|[
name|i
index|]
argument_list|,
name|segs
index|[
name|i
index|]
operator|.
name|ds_addr
argument_list|)
expr_stmt|;
name|pccb
operator|->
name|sgList
index|[
name|i
index|]
operator|.
name|type
operator|=
name|htole32
argument_list|(
name|tiSgl
argument_list|)
expr_stmt|;
name|pccb
operator|->
name|dataLen
operator|+=
name|segs
index|[
name|i
index|]
operator|.
name|ds_len
expr_stmt|;
block|}
comment|/* for */
name|pccb
operator|->
name|numSgElements
operator|=
name|nsegs
expr_stmt|;
comment|/* set up sgl buffer address */
name|CPU_TO_LE32
argument_list|(
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|agSgl1
argument_list|,
name|pccb
operator|->
name|tisgl_busaddr
argument_list|)
expr_stmt|;
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|agSgl1
operator|.
name|type
operator|=
name|htole32
argument_list|(
name|tiSglList
argument_list|)
expr_stmt|;
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|agSgl1
operator|.
name|len
operator|=
name|htole32
argument_list|(
name|pccb
operator|->
name|dataLen
argument_list|)
expr_stmt|;
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|sglVirtualAddr
operator|=
operator|(
name|void
operator|*
operator|)
name|csio
operator|->
name|data_ptr
expr_stmt|;
name|pccb
operator|->
name|numSgElements
operator|=
name|nsegs
expr_stmt|;
block|}
comment|/* else */
block|}
comment|/* set data transfer direction */
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|==
name|CAM_DIR_OUT
condition|)
block|{
name|op
operator|=
name|BUS_DMASYNC_PREWRITE
expr_stmt|;
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|dataDirection
operator|=
name|tiDirectionOut
expr_stmt|;
block|}
else|else
block|{
name|op
operator|=
name|BUS_DMASYNC_PREREAD
expr_stmt|;
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|dataDirection
operator|=
name|tiDirectionIn
expr_stmt|;
block|}
name|pScsiCmnd
operator|=
operator|&
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|scsiCmnd
expr_stmt|;
name|pScsiCmnd
operator|->
name|expDataLength
operator|=
name|pccb
operator|->
name|dataLen
expr_stmt|;
if|if
condition|(
name|csio
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_CDB_POINTER
condition|)
block|{
name|bcopy
argument_list|(
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_ptr
argument_list|,
operator|&
name|pScsiCmnd
operator|->
name|cdb
index|[
literal|0
index|]
argument_list|,
name|csio
operator|->
name|cdb_len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bcopy
argument_list|(
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
argument_list|,
operator|&
name|pScsiCmnd
operator|->
name|cdb
index|[
literal|0
index|]
argument_list|,
name|csio
operator|->
name|cdb_len
argument_list|)
expr_stmt|;
block|}
name|CDB
operator|=
operator|&
name|pScsiCmnd
operator|->
name|cdb
index|[
literal|0
index|]
expr_stmt|;
switch|switch
condition|(
name|CDB
index|[
literal|0
index|]
condition|)
block|{
case|case
name|REQUEST_SENSE
case|:
comment|/* requires different buffer */
comment|/* This code should not be excercised because SAS support auto sense         For the completeness, vtophys() is still used here.      */
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_PrepareSGListCB: QueueCmnd - REQUEST SENSE new\n"
argument_list|)
expr_stmt|;
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|agSgl1
operator|.
name|len
operator|=
name|htole32
argument_list|(
name|pccb
operator|->
name|senseLen
argument_list|)
expr_stmt|;
name|phys_addr
operator|=
name|vtophys
argument_list|(
operator|&
name|csio
operator|->
name|sense_data
argument_list|)
expr_stmt|;
name|CPU_TO_LE32
argument_list|(
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|agSgl1
argument_list|,
name|phys_addr
argument_list|)
expr_stmt|;
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|agSgl1
operator|.
name|type
operator|=
name|htole32
argument_list|(
name|tiSgl
argument_list|)
expr_stmt|;
name|pccb
operator|->
name|dataLen
operator|=
name|pccb
operator|->
name|senseLen
expr_stmt|;
name|pccb
operator|->
name|numSgElements
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|INQUIRY
case|:
comment|/* only using lun 0 for device type detection */
name|pccb
operator|->
name|flags
operator||=
name|AGTIAPI_INQUIRY
expr_stmt|;
break|break;
case|case
name|TEST_UNIT_READY
case|:
case|case
name|RESERVE
case|:
case|case
name|RELEASE
case|:
case|case
name|START_STOP
case|:
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|agSgl1
operator|.
name|len
operator|=
literal|0
expr_stmt|;
name|pccb
operator|->
name|dataLen
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|READ_6
case|:
case|case
name|WRITE_6
case|:
comment|/* Extract LBA */
name|start_lba
operator|=
operator|(
operator|(
name|CDB
index|[
literal|1
index|]
operator|&
literal|0x1f
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
name|CDB
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|CDB
index|[
literal|3
index|]
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HIALEAH_ENCRYPTION
name|io_is_encryptable
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|READ_10
case|:
case|case
name|WRITE_10
case|:
case|case
name|READ_12
case|:
case|case
name|WRITE_12
case|:
comment|/* Extract LBA */
name|start_lba
operator|=
operator|(
name|CDB
index|[
literal|2
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|CDB
index|[
literal|3
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|CDB
index|[
literal|4
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|CDB
index|[
literal|5
index|]
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HIALEAH_ENCRYPTION
name|io_is_encryptable
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|READ_16
case|:
case|case
name|WRITE_16
case|:
comment|/* Extract LBA */
name|start_lba
operator|=
operator|(
name|CDB
index|[
literal|2
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|CDB
index|[
literal|3
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|CDB
index|[
literal|4
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|CDB
index|[
literal|5
index|]
operator|)
expr_stmt|;
name|start_lba
operator|<<=
literal|32
expr_stmt|;
name|start_lba
operator||=
operator|(
operator|(
name|CDB
index|[
literal|6
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|CDB
index|[
literal|7
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|CDB
index|[
literal|8
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|CDB
index|[
literal|9
index|]
operator|)
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HIALEAH_ENCRYPTION
name|io_is_encryptable
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
break|break;
default|default:
break|break;
block|}
comment|/* fill device lun based one address mode */
name|agtiapi_SetLunField
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
if|if
condition|(
name|pccb
operator|->
name|targetId
operator|<
literal|0
operator|||
name|pccb
operator|->
name|targetId
operator|>=
name|maxTargets
condition|)
block|{
name|pccb
operator|->
name|ccbStatus
operator|=
name|tiIOFailed
expr_stmt|;
name|pccb
operator|->
name|scsiStatus
operator|=
name|tiDetailNoLogin
expr_stmt|;
name|agtiapi_FreeCCB
argument_list|(
name|pmcsc
argument_list|,
name|pccb
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_DEV_NOT_THERE
expr_stmt|;
comment|// ## v. CAM_FUNC_NOTAVAIL
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|pccb
operator|->
name|ccb
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|INDEX
argument_list|(
name|pmcsc
argument_list|,
name|pccb
operator|->
name|targetId
argument_list|)
operator|>=
name|maxTargets
condition|)
block|{
name|pccb
operator|->
name|ccbStatus
operator|=
name|tiIOFailed
expr_stmt|;
name|pccb
operator|->
name|scsiStatus
operator|=
name|tiDetailNoLogin
expr_stmt|;
name|agtiapi_FreeCCB
argument_list|(
name|pmcsc
argument_list|,
name|pccb
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_DEV_NOT_THERE
expr_stmt|;
comment|// ## v. CAM_FUNC_NOTAVAIL
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|pccb
operator|->
name|ccb
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
name|pDev
operator|=
operator|&
name|pmcsc
operator|->
name|pDevList
index|[
name|INDEX
argument_list|(
name|pmcsc
argument_list|,
name|pccb
operator|->
name|targetId
argument_list|)
index|]
expr_stmt|;
if|#
directive|if
literal|1
if|if
condition|(
operator|(
name|pmcsc
operator|->
name|flags
operator|&
name|EDC_DATA
operator|)
operator|&&
operator|(
name|pDev
operator|->
name|flags
operator|&
name|EDC_DATA
operator|)
condition|)
block|{
comment|/*      * EDC support:      *      * Possible command supported -      * READ_6, READ_10, READ_12, READ_16, READ_LONG, READ_BUFFER,      * READ_DEFECT_DATA, etc.      * WRITE_6, WRITE_10, WRITE_12, WRITE_16, WRITE_LONG, WRITE_LONG2,       * WRITE_BUFFER, WRITE_VERIFY, WRITE_VERIFY_12, etc.      *      * Do some data length adjustment and set chip operation instruction.      */
switch|switch
condition|(
name|CDB
index|[
literal|0
index|]
condition|)
block|{
case|case
name|READ_6
case|:
case|case
name|READ_10
case|:
case|case
name|READ_12
case|:
case|case
name|READ_16
case|:
comment|//  BUG_ON(pccb->tiSuperScsiRequest.flags& TI_SCSI_INITIATOR_ENCRYPT);
ifdef|#
directive|ifdef
name|AGTIAPI_TEST_DIF
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|flags
operator||=
name|TI_SCSI_INITIATOR_DIF
expr_stmt|;
endif|#
directive|endif
name|pccb
operator|->
name|flags
operator||=
name|EDC_DATA
expr_stmt|;
ifdef|#
directive|ifdef
name|TEST_VERIFY_AND_FORWARD
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|Dif
operator|.
name|flags
operator|=
name|DIF_VERIFY_FORWARD
operator||
name|DIF_UDT_REF_BLOCK_COUNT
expr_stmt|;
if|if
condition|(
name|pDev
operator|->
name|sector_size
operator|==
literal|520
condition|)
block|{
name|pScsiCmnd
operator|->
name|expDataLength
operator|+=
operator|(
name|pccb
operator|->
name|dataLen
operator|/
literal|512
operator|)
operator|*
literal|8
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pDev
operator|->
name|sector_size
operator|==
literal|4104
condition|)
block|{
name|pScsiCmnd
operator|->
name|expDataLength
operator|+=
operator|(
name|pccb
operator|->
name|dataLen
operator|/
literal|4096
operator|)
operator|*
literal|8
expr_stmt|;
block|}
else|#
directive|else
ifdef|#
directive|ifdef
name|AGTIAPI_TEST_DIF
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|Dif
operator|.
name|flags
operator|=
name|DIF_VERIFY_DELETE
operator||
name|DIF_UDT_REF_BLOCK_COUNT
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
ifdef|#
directive|ifdef
name|AGTIAPI_TEST_DIF
switch|switch
condition|(
name|pDev
operator|->
name|sector_size
condition|)
block|{
case|case
literal|528
case|:
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|Dif
operator|.
name|flags
operator||=
operator|(
name|DIF_BLOCK_SIZE_520
operator|<<
literal|16
operator|)
expr_stmt|;
break|break;
case|case
literal|4104
case|:
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|Dif
operator|.
name|flags
operator||=
operator|(
name|DIF_BLOCK_SIZE_4096
operator|<<
literal|16
operator|)
expr_stmt|;
break|break;
case|case
literal|4168
case|:
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|Dif
operator|.
name|flags
operator||=
operator|(
name|DIF_BLOCK_SIZE_4160
operator|<<
literal|16
operator|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|pCard
operator|->
name|flags
operator|&
name|EDC_DATA_CRC
condition|)
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|Dif
operator|.
name|flags
operator||=
name|DIF_CRC_VERIFICATION
expr_stmt|;
comment|/* Turn on upper 4 bits of UVM */
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|Dif
operator|.
name|flags
operator||=
literal|0x03c00000
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|AGTIAPI_TEST_DPL
if|if
condition|(
name|agtiapi_SetupDifPerLA
argument_list|(
name|pCard
argument_list|,
name|pccb
argument_list|,
name|start_lba
argument_list|)
operator|<
literal|0
condition|)
block|{
name|printk
argument_list|(
name|KERN_ERR
literal|"SetupDifPerLA Failed.\n"
argument_list|)
expr_stmt|;
name|cmnd
operator|->
name|result
operator|=
name|SCSI_HOST
argument_list|(
name|DID_ERROR
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|Dif
operator|.
name|enableDIFPerLA
operator|=
name|TRUE
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|AGTIAPI_TEST_DIF
comment|/* Set App Tag */
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|Dif
operator|.
name|udtArray
index|[
literal|0
index|]
operator|=
literal|0xaa
expr_stmt|;
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|Dif
operator|.
name|udtArray
index|[
literal|1
index|]
operator|=
literal|0xbb
expr_stmt|;
comment|/* Set LBA in UDT array */
if|if
condition|(
name|CDB
index|[
literal|0
index|]
operator|==
name|READ_6
condition|)
block|{
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|Dif
operator|.
name|udtArray
index|[
literal|2
index|]
operator|=
name|CDB
index|[
literal|3
index|]
expr_stmt|;
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|Dif
operator|.
name|udtArray
index|[
literal|3
index|]
operator|=
name|CDB
index|[
literal|2
index|]
expr_stmt|;
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|Dif
operator|.
name|udtArray
index|[
literal|4
index|]
operator|=
name|CDB
index|[
literal|1
index|]
operator|&
literal|0x1f
expr_stmt|;
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|Dif
operator|.
name|udtArray
index|[
literal|5
index|]
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CDB
index|[
literal|0
index|]
operator|==
name|READ_10
operator|||
name|CDB
index|[
literal|0
index|]
operator|==
name|READ_12
condition|)
block|{
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|Dif
operator|.
name|udtArray
index|[
literal|2
index|]
operator|=
name|CDB
index|[
literal|5
index|]
expr_stmt|;
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|Dif
operator|.
name|udtArray
index|[
literal|3
index|]
operator|=
name|CDB
index|[
literal|4
index|]
expr_stmt|;
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|Dif
operator|.
name|udtArray
index|[
literal|4
index|]
operator|=
name|CDB
index|[
literal|3
index|]
expr_stmt|;
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|Dif
operator|.
name|udtArray
index|[
literal|5
index|]
operator|=
name|CDB
index|[
literal|2
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CDB
index|[
literal|0
index|]
operator|==
name|READ_16
condition|)
block|{
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|Dif
operator|.
name|udtArray
index|[
literal|2
index|]
operator|=
name|CDB
index|[
literal|9
index|]
expr_stmt|;
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|Dif
operator|.
name|udtArray
index|[
literal|3
index|]
operator|=
name|CDB
index|[
literal|8
index|]
expr_stmt|;
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|Dif
operator|.
name|udtArray
index|[
literal|4
index|]
operator|=
name|CDB
index|[
literal|7
index|]
expr_stmt|;
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|Dif
operator|.
name|udtArray
index|[
literal|5
index|]
operator|=
name|CDB
index|[
literal|6
index|]
expr_stmt|;
comment|/* Note: 32 bits lost */
block|}
endif|#
directive|endif
break|break;
case|case
name|WRITE_6
case|:
case|case
name|WRITE_10
case|:
case|case
name|WRITE_12
case|:
case|case
name|WRITE_16
case|:
comment|//   BUG_ON(pccb->tiSuperScsiRequest.flags& TI_SCSI_INITIATOR_ENCRYPT);
name|pccb
operator|->
name|flags
operator||=
name|EDC_DATA
expr_stmt|;
ifdef|#
directive|ifdef
name|AGTIAPI_TEST_DIF
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|flags
operator||=
name|TI_SCSI_INITIATOR_DIF
expr_stmt|;
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|Dif
operator|.
name|flags
operator|=
name|DIF_INSERT
operator||
name|DIF_UDT_REF_BLOCK_COUNT
expr_stmt|;
switch|switch
condition|(
name|pDev
operator|->
name|sector_size
condition|)
block|{
case|case
literal|528
case|:
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|Dif
operator|.
name|flags
operator||=
operator|(
name|DIF_BLOCK_SIZE_520
operator|<<
literal|16
operator|)
expr_stmt|;
break|break;
case|case
literal|4104
case|:
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|Dif
operator|.
name|flags
operator||=
operator|(
name|DIF_BLOCK_SIZE_4096
operator|<<
literal|16
operator|)
expr_stmt|;
break|break;
case|case
literal|4168
case|:
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|Dif
operator|.
name|flags
operator||=
operator|(
name|DIF_BLOCK_SIZE_4160
operator|<<
literal|16
operator|)
expr_stmt|;
break|break;
block|}
comment|/* Turn on upper 4 bits of UUM */
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|Dif
operator|.
name|flags
operator||=
literal|0xf0000000
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|AGTIAPI_TEST_DPL
if|if
condition|(
name|agtiapi_SetupDifPerLA
argument_list|(
name|pCard
argument_list|,
name|pccb
argument_list|,
name|start_lba
argument_list|)
operator|<
literal|0
condition|)
block|{
name|printk
argument_list|(
name|KERN_ERR
literal|"SetupDifPerLA Failed.\n"
argument_list|)
expr_stmt|;
name|cmnd
operator|->
name|result
operator|=
name|SCSI_HOST
argument_list|(
name|DID_ERROR
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|Dif
operator|.
name|enableDIFPerLA
operator|=
name|TRUE
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|AGTIAPI_TEST_DIF
comment|/* Set App Tag */
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|Dif
operator|.
name|udtArray
index|[
literal|0
index|]
operator|=
literal|0xaa
expr_stmt|;
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|Dif
operator|.
name|udtArray
index|[
literal|1
index|]
operator|=
literal|0xbb
expr_stmt|;
comment|/* Set LBA in UDT array */
if|if
condition|(
name|CDB
index|[
literal|0
index|]
operator|==
name|WRITE_6
condition|)
block|{
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|Dif
operator|.
name|udtArray
index|[
literal|2
index|]
operator|=
name|CDB
index|[
literal|3
index|]
expr_stmt|;
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|Dif
operator|.
name|udtArray
index|[
literal|3
index|]
operator|=
name|CDB
index|[
literal|2
index|]
expr_stmt|;
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|Dif
operator|.
name|udtArray
index|[
literal|4
index|]
operator|=
name|CDB
index|[
literal|1
index|]
operator|&
literal|0x1f
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CDB
index|[
literal|0
index|]
operator|==
name|WRITE_10
operator|||
name|CDB
index|[
literal|0
index|]
operator|==
name|WRITE_12
condition|)
block|{
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|Dif
operator|.
name|udtArray
index|[
literal|2
index|]
operator|=
name|CDB
index|[
literal|5
index|]
expr_stmt|;
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|Dif
operator|.
name|udtArray
index|[
literal|3
index|]
operator|=
name|CDB
index|[
literal|4
index|]
expr_stmt|;
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|Dif
operator|.
name|udtArray
index|[
literal|4
index|]
operator|=
name|CDB
index|[
literal|3
index|]
expr_stmt|;
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|Dif
operator|.
name|udtArray
index|[
literal|5
index|]
operator|=
name|CDB
index|[
literal|2
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CDB
index|[
literal|0
index|]
operator|==
name|WRITE_16
condition|)
block|{
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|Dif
operator|.
name|udtArray
index|[
literal|2
index|]
operator|=
name|CDB
index|[
literal|5
index|]
expr_stmt|;
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|Dif
operator|.
name|udtArray
index|[
literal|3
index|]
operator|=
name|CDB
index|[
literal|4
index|]
expr_stmt|;
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|Dif
operator|.
name|udtArray
index|[
literal|4
index|]
operator|=
name|CDB
index|[
literal|3
index|]
expr_stmt|;
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|Dif
operator|.
name|udtArray
index|[
literal|5
index|]
operator|=
name|CDB
index|[
literal|2
index|]
expr_stmt|;
comment|/* Note: 32 bits lost */
block|}
endif|#
directive|endif
break|break;
block|}
block|}
endif|#
directive|endif
comment|/* end of DIF */
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_TAG_ACTION_VALID
operator|)
operator|!=
literal|0
condition|)
block|{
switch|switch
condition|(
name|csio
operator|->
name|tag_action
condition|)
block|{
case|case
name|MSG_HEAD_OF_Q_TAG
case|:
name|pScsiCmnd
operator|->
name|taskAttribute
operator|=
name|TASK_HEAD_OF_QUEUE
expr_stmt|;
break|break;
case|case
name|MSG_ACA_TASK
case|:
name|pScsiCmnd
operator|->
name|taskAttribute
operator|=
name|TASK_ACA
expr_stmt|;
break|break;
case|case
name|MSG_ORDERED_Q_TAG
case|:
name|pScsiCmnd
operator|->
name|taskAttribute
operator|=
name|TASK_ORDERED
expr_stmt|;
break|break;
case|case
name|MSG_SIMPLE_Q_TAG
case|:
comment|/* fall through */
default|default:
name|pScsiCmnd
operator|->
name|taskAttribute
operator|=
name|TASK_SIMPLE
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|agSgl1
operator|.
name|len
operator|!=
literal|0
operator|&&
name|pccb
operator|->
name|dataLen
operator|!=
literal|0
condition|)
block|{
comment|/* should be just before start IO */
name|bus_dmamap_sync
argument_list|(
name|pmcsc
operator|->
name|buffer_dmat
argument_list|,
name|pccb
operator|->
name|CCB_dmamap
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
comment|/*    * If assigned pDevHandle is not available    * then there is no need to send it to StartIO()    */
if|if
condition|(
name|pccb
operator|->
name|targetId
operator|<
literal|0
operator|||
name|pccb
operator|->
name|targetId
operator|>=
name|maxTargets
condition|)
block|{
name|pccb
operator|->
name|ccbStatus
operator|=
name|tiIOFailed
expr_stmt|;
name|pccb
operator|->
name|scsiStatus
operator|=
name|tiDetailNoLogin
expr_stmt|;
name|agtiapi_FreeCCB
argument_list|(
name|pmcsc
argument_list|,
name|pccb
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_DEV_NOT_THERE
expr_stmt|;
comment|// ## v. CAM_FUNC_NOTAVAIL
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|pccb
operator|->
name|ccb
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
name|TID
operator|=
name|INDEX
argument_list|(
name|pmcsc
argument_list|,
name|pccb
operator|->
name|targetId
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|TID
operator|>=
name|pmcsc
operator|->
name|devDiscover
operator|)
operator|||
operator|!
operator|(
name|pccb
operator|->
name|devHandle
operator|=
name|pmcsc
operator|->
name|pDevList
index|[
name|TID
index|]
operator|.
name|pDevHandle
operator|)
condition|)
block|{
comment|/*     AGTIAPI_PRINTK( "agtiapi_PrepareSGListCB: not sending ccb devH %p,"                     " target %d tid %d/%d card %p ERROR pccb %p\n",                     pccb->devHandle, pccb->targetId, TID,                     pmcsc->devDiscover, pmcsc, pccb );     */
name|pccb
operator|->
name|ccbStatus
operator|=
name|tiIOFailed
expr_stmt|;
name|pccb
operator|->
name|scsiStatus
operator|=
name|tiDetailNoLogin
expr_stmt|;
name|agtiapi_FreeCCB
argument_list|(
name|pmcsc
argument_list|,
name|pccb
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_DEV_NOT_THERE
expr_stmt|;
comment|// ## v. CAM_FUNC_NOTAVAIL
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|pccb
operator|->
name|ccb
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
name|AGTIAPI_IO
argument_list|(
literal|"agtiapi_PrepareSGListCB: send ccb pccb->devHandle %p, "
literal|"pccb->targetId %d TID %d pmcsc->devDiscover %d card %p\n"
argument_list|,
name|pccb
operator|->
name|devHandle
argument_list|,
name|pccb
operator|->
name|targetId
argument_list|,
name|TID
argument_list|,
name|pmcsc
operator|->
name|devDiscover
argument_list|,
name|pmcsc
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HIALEAH_ENCRYPTION
if|if
condition|(
name|pmcsc
operator|->
name|encrypt
operator|&&
name|io_is_encryptable
condition|)
block|{
name|agtiapi_SetupEncryptedIO
argument_list|(
name|pmcsc
argument_list|,
name|pccb
argument_list|,
name|start_lba
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|io_is_encryptable
operator|=
literal|0
expr_stmt|;
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
comment|// put the request in send queue
name|agtiapi_QueueCCB
argument_list|(
argument|pmcsc
argument_list|,
argument|&pmcsc->ccbSendHead
argument_list|,
argument|&pmcsc->ccbSendTail                     AG_CARD_LOCAL_LOCK(&pmcsc->sendLock)
argument_list|,
argument|pccb
argument_list|)
empty_stmt|;
name|agtiapi_StartIO
argument_list|(
name|pmcsc
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/****************************************************************************** agtiapi_StartIO()  Purpose:   Send IO request down for processing. Parameters:   (struct agtiapi_softc *pmcsc (IN)  Pointer to HBA data structure Return: Note: ******************************************************************************/
end_comment

begin_function
name|STATIC
name|void
name|agtiapi_StartIO
parameter_list|(
name|struct
name|agtiapi_softc
modifier|*
name|pmcsc
parameter_list|)
block|{
name|ccb_t
modifier|*
name|pccb
decl_stmt|;
name|int
name|TID
decl_stmt|;
name|ag_device_t
modifier|*
name|targ
decl_stmt|;
name|AGTIAPI_IO
argument_list|(
literal|"agtiapi_StartIO: start\n"
argument_list|)
expr_stmt|;
name|AG_LOCAL_LOCK
argument_list|(
operator|&
name|pmcsc
operator|->
name|sendLock
argument_list|)
expr_stmt|;
name|pccb
operator|=
name|pmcsc
operator|->
name|ccbSendHead
expr_stmt|;
comment|/* if link is down, do nothing */
if|if
condition|(
operator|(
name|pccb
operator|==
name|NULL
operator|)
operator|||
name|pmcsc
operator|->
name|flags
operator|&
name|AGTIAPI_RESET
condition|)
block|{
name|AG_LOCAL_UNLOCK
argument_list|(
operator|&
name|pmcsc
operator|->
name|sendLock
argument_list|)
expr_stmt|;
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_StartIO: goto ext\n"
argument_list|)
expr_stmt|;
goto|goto
name|ext
goto|;
block|}
if|if
condition|(
name|pmcsc
operator|!=
name|NULL
operator|&&
name|pccb
operator|->
name|targetId
operator|>=
literal|0
operator|&&
name|pccb
operator|->
name|targetId
operator|<
name|maxTargets
condition|)
block|{
name|TID
operator|=
name|INDEX
argument_list|(
name|pmcsc
argument_list|,
name|pccb
operator|->
name|targetId
argument_list|)
expr_stmt|;
name|targ
operator|=
operator|&
name|pmcsc
operator|->
name|pDevList
index|[
name|TID
index|]
expr_stmt|;
block|}
comment|/* clear send queue */
name|pmcsc
operator|->
name|ccbSendHead
operator|=
name|NULL
expr_stmt|;
name|pmcsc
operator|->
name|ccbSendTail
operator|=
name|NULL
expr_stmt|;
name|AG_LOCAL_UNLOCK
argument_list|(
operator|&
name|pmcsc
operator|->
name|sendLock
argument_list|)
expr_stmt|;
comment|/* send all ccbs down */
while|while
condition|(
name|pccb
condition|)
block|{
name|pccb_t
name|pccb_next
decl_stmt|;
name|U32
name|status
decl_stmt|;
name|pccb_next
operator|=
name|pccb
operator|->
name|pccbNext
expr_stmt|;
name|pccb
operator|->
name|pccbNext
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|pccb
operator|->
name|ccb
condition|)
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_StartIO: pccb->ccb is NULL ERROR!\n"
argument_list|)
expr_stmt|;
name|pccb
operator|=
name|pccb_next
expr_stmt|;
continue|continue;
block|}
name|AG_IO_DUMPCCB
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pccb
operator|->
name|devHandle
condition|)
block|{
name|agtiapi_DumpCCB
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_StartIO: ccb NULL device ERROR!\n"
argument_list|)
expr_stmt|;
name|pccb
operator|=
name|pccb_next
expr_stmt|;
continue|continue;
block|}
name|AGTIAPI_IO
argument_list|(
literal|"agtiapi_StartIO: ccb %p retry %d\n"
argument_list|,
name|pccb
argument_list|,
name|pccb
operator|->
name|retryCount
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|ABORT_TEST
if|if
condition|(
operator|!
name|pccb
operator|->
name|devHandle
operator|||
operator|!
name|pccb
operator|->
name|devHandle
operator|->
name|osData
operator|||
comment|/* in rmmod case */
operator|!
operator|(
operator|(
operator|(
name|ag_device_t
operator|*
operator|)
operator|(
name|pccb
operator|->
name|devHandle
operator|->
name|osData
operator|)
operator|)
operator|->
name|flags
operator|&
name|ACTIVE
operator|)
condition|)
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_StartIO: device %p not active! ERROR\n"
argument_list|,
name|pccb
operator|->
name|devHandle
argument_list|)
expr_stmt|;
if|if
condition|(
name|pccb
operator|->
name|devHandle
condition|)
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_StartIO: device not active detail"
literal|" -- osData:%p\n"
argument_list|,
name|pccb
operator|->
name|devHandle
operator|->
name|osData
argument_list|)
expr_stmt|;
if|if
condition|(
name|pccb
operator|->
name|devHandle
operator|->
name|osData
condition|)
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_StartIO: more device not active detail"
literal|" -- active flag:%d\n"
argument_list|,
operator|(
operator|(
name|ag_device_t
operator|*
operator|)
operator|(
name|pccb
operator|->
name|devHandle
operator|->
name|osData
operator|)
operator|)
operator|->
name|flags
operator|&
name|ACTIVE
argument_list|)
expr_stmt|;
block|}
block|}
name|pccb
operator|->
name|ccbStatus
operator|=
name|tiIOFailed
expr_stmt|;
name|pccb
operator|->
name|scsiStatus
operator|=
name|tiDetailNoLogin
expr_stmt|;
name|agtiapi_Done
argument_list|(
name|pmcsc
argument_list|,
name|pccb
argument_list|)
expr_stmt|;
name|pccb
operator|=
name|pccb_next
expr_stmt|;
continue|continue;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|FAST_IO_TEST
name|status
operator|=
name|agtiapi_FastIOTest
argument_list|(
name|pmcsc
argument_list|,
name|pccb
argument_list|)
expr_stmt|;
else|#
directive|else
name|status
operator|=
name|tiINISuperIOStart
argument_list|(
operator|&
name|pmcsc
operator|->
name|tiRoot
argument_list|,
operator|&
name|pccb
operator|->
name|tiIORequest
argument_list|,
name|pccb
operator|->
name|devHandle
argument_list|,
operator|&
name|pccb
operator|->
name|tiSuperScsiRequest
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|pccb
operator|->
name|tdIOReqBody
argument_list|,
name|tiInterruptContext
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|status
condition|)
block|{
case|case
name|tiSuccess
case|:
comment|/*         static int squelchCount = 0;         if ( 200000 == squelchCount++ ) // squelch prints         {           AGTIAPI_PRINTK( "agtiapi_StartIO: tiINIIOStart stat tiSuccess %p\n",                           pccb );           squelchCount = 0; // reset count         }         */
break|break;
case|case
name|tiDeviceBusy
case|:
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_StartIO: tiINIIOStart status tiDeviceBusy %p\n"
argument_list|,
name|pccb
operator|->
name|ccb
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LOGEVENT
name|agtiapi_LogEvent
argument_list|(
name|pmcsc
argument_list|,
name|IOCTL_EVT_SEV_INFORMATIONAL
argument_list|,
literal|0
argument_list|,
name|agNULL
argument_list|,
literal|0
argument_list|,
literal|"tiINIIOStart tiDeviceBusy "
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pccb
operator|->
name|ccbStatus
operator|=
name|tiIOFailed
expr_stmt|;
name|pccb
operator|->
name|scsiStatus
operator|=
name|tiDeviceBusy
expr_stmt|;
name|agtiapi_Done
argument_list|(
name|pmcsc
argument_list|,
name|pccb
argument_list|)
expr_stmt|;
break|break;
case|case
name|tiBusy
case|:
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_StartIO: tiINIIOStart status tiBusy %p\n"
argument_list|,
name|pccb
operator|->
name|ccb
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LOGEVENT
name|agtiapi_LogEvent
argument_list|(
name|pmcsc
argument_list|,
name|IOCTL_EVT_SEV_INFORMATIONAL
argument_list|,
literal|0
argument_list|,
name|agNULL
argument_list|,
literal|0
argument_list|,
literal|"tiINIIOStart tiBusy "
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pccb
operator|->
name|ccbStatus
operator|=
name|tiIOFailed
expr_stmt|;
name|pccb
operator|->
name|scsiStatus
operator|=
name|tiBusy
expr_stmt|;
name|agtiapi_Done
argument_list|(
name|pmcsc
argument_list|,
name|pccb
argument_list|)
expr_stmt|;
break|break;
case|case
name|tiIONoDevice
case|:
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_StartIO: tiINIIOStart status tiNoDevice %p "
literal|"ERROR\n"
argument_list|,
name|pccb
operator|->
name|ccb
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LOGEVENT
name|agtiapi_LogEvent
argument_list|(
name|pmcsc
argument_list|,
name|IOCTL_EVT_SEV_INFORMATIONAL
argument_list|,
literal|0
argument_list|,
name|agNULL
argument_list|,
literal|0
argument_list|,
literal|"tiINIIOStart invalid device handle "
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|ABORT_TEST
comment|/* return command back to OS due to no device available */
operator|(
operator|(
name|ag_device_t
operator|*
operator|)
operator|(
name|pccb
operator|->
name|devHandle
operator|->
name|osData
operator|)
operator|)
operator|->
name|flags
operator|&=
operator|~
name|ACTIVE
expr_stmt|;
name|pccb
operator|->
name|ccbStatus
operator|=
name|tiIOFailed
expr_stmt|;
name|pccb
operator|->
name|scsiStatus
operator|=
name|tiDetailNoLogin
expr_stmt|;
name|agtiapi_Done
argument_list|(
name|pmcsc
argument_list|,
name|pccb
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* for short cable pull, we want IO retried - 3-18-2005 */
name|agtiapi_QueueCCB
argument_list|(
argument|pmcsc
argument_list|,
argument|&pmcsc->ccbSendHead
argument_list|,
argument|&pmcsc->ccbSendTail                          AG_CARD_LOCAL_LOCK(&pmcsc->sendLock)
argument_list|,
argument|pccb
argument_list|)
empty_stmt|;
endif|#
directive|endif
break|break;
case|case
name|tiError
case|:
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_StartIO: tiINIIOStart status tiError %p\n"
argument_list|,
name|pccb
operator|->
name|ccb
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LOGEVENT
name|agtiapi_LogEvent
argument_list|(
name|pmcsc
argument_list|,
name|IOCTL_EVT_SEV_INFORMATIONAL
argument_list|,
literal|0
argument_list|,
name|agNULL
argument_list|,
literal|0
argument_list|,
literal|"tiINIIOStart tiError "
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pccb
operator|->
name|ccbStatus
operator|=
name|tiIOFailed
expr_stmt|;
name|pccb
operator|->
name|scsiStatus
operator|=
name|tiDetailOtherError
expr_stmt|;
name|agtiapi_Done
argument_list|(
name|pmcsc
argument_list|,
name|pccb
argument_list|)
expr_stmt|;
break|break;
default|default:
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_StartIO: tiINIIOStart status default %x %p\n"
argument_list|,
name|status
argument_list|,
name|pccb
operator|->
name|ccb
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LOGEVENT
name|agtiapi_LogEvent
argument_list|(
name|pmcsc
argument_list|,
name|IOCTL_EVT_SEV_ERROR
argument_list|,
literal|0
argument_list|,
name|agNULL
argument_list|,
literal|0
argument_list|,
literal|"tiINIIOStart unexpected status "
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pccb
operator|->
name|ccbStatus
operator|=
name|tiIOFailed
expr_stmt|;
name|pccb
operator|->
name|scsiStatus
operator|=
name|tiDetailOtherError
expr_stmt|;
name|agtiapi_Done
argument_list|(
name|pmcsc
argument_list|,
name|pccb
argument_list|)
expr_stmt|;
block|}
name|pccb
operator|=
name|pccb_next
expr_stmt|;
block|}
name|ext
label|:
comment|/* some IO requests might have been completed */
name|AG_GET_DONE_PCCB
argument_list|(
name|pccb
argument_list|,
name|pmcsc
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/****************************************************************************** agtiapi_StartSMP()  Purpose:   Send SMP request down for processing. Parameters:   (struct agtiapi_softc *pmcsc (IN)  Pointer to HBA data structure Return: Note: ******************************************************************************/
end_comment

begin_function
name|STATIC
name|void
name|agtiapi_StartSMP
parameter_list|(
name|struct
name|agtiapi_softc
modifier|*
name|pmcsc
parameter_list|)
block|{
name|ccb_t
modifier|*
name|pccb
decl_stmt|;
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_StartSMP: start\n"
argument_list|)
expr_stmt|;
name|AG_LOCAL_LOCK
argument_list|(
operator|&
name|pmcsc
operator|->
name|sendSMPLock
argument_list|)
expr_stmt|;
name|pccb
operator|=
name|pmcsc
operator|->
name|smpSendHead
expr_stmt|;
comment|/* if link is down, do nothing */
if|if
condition|(
operator|(
name|pccb
operator|==
name|NULL
operator|)
operator|||
name|pmcsc
operator|->
name|flags
operator|&
name|AGTIAPI_RESET
condition|)
block|{
name|AG_LOCAL_UNLOCK
argument_list|(
operator|&
name|pmcsc
operator|->
name|sendSMPLock
argument_list|)
expr_stmt|;
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_StartSMP: goto ext\n"
argument_list|)
expr_stmt|;
goto|goto
name|ext
goto|;
block|}
comment|/* clear send queue */
name|pmcsc
operator|->
name|smpSendHead
operator|=
name|NULL
expr_stmt|;
name|pmcsc
operator|->
name|smpSendTail
operator|=
name|NULL
expr_stmt|;
name|AG_LOCAL_UNLOCK
argument_list|(
operator|&
name|pmcsc
operator|->
name|sendSMPLock
argument_list|)
expr_stmt|;
comment|/* send all ccbs down */
while|while
condition|(
name|pccb
condition|)
block|{
name|pccb_t
name|pccb_next
decl_stmt|;
name|U32
name|status
decl_stmt|;
name|pccb_next
operator|=
name|pccb
operator|->
name|pccbNext
expr_stmt|;
name|pccb
operator|->
name|pccbNext
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|pccb
operator|->
name|ccb
condition|)
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_StartSMP: pccb->ccb is NULL ERROR!\n"
argument_list|)
expr_stmt|;
name|pccb
operator|=
name|pccb_next
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|pccb
operator|->
name|devHandle
condition|)
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_StartSMP: ccb NULL device ERROR!\n"
argument_list|)
expr_stmt|;
name|pccb
operator|=
name|pccb_next
expr_stmt|;
continue|continue;
block|}
name|pccb
operator|->
name|flags
operator||=
name|TAG_SMP
expr_stmt|;
comment|// mark as SMP for later tracking
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_StartSMP: ccb %p retry %d\n"
argument_list|,
name|pccb
argument_list|,
name|pccb
operator|->
name|retryCount
argument_list|)
expr_stmt|;
name|status
operator|=
name|tiINISMPStart
argument_list|(
operator|&
name|pmcsc
operator|->
name|tiRoot
argument_list|,
operator|&
name|pccb
operator|->
name|tiIORequest
argument_list|,
name|pccb
operator|->
name|devHandle
argument_list|,
operator|&
name|pccb
operator|->
name|tiSMPFrame
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|pccb
operator|->
name|tdIOReqBody
argument_list|,
name|tiInterruptContext
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|status
condition|)
block|{
case|case
name|tiSuccess
case|:
break|break;
case|case
name|tiBusy
case|:
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_StartSMP: tiINISMPStart status tiBusy %p\n"
argument_list|,
name|pccb
operator|->
name|ccb
argument_list|)
expr_stmt|;
comment|/* pending ccb back to send queue */
name|agtiapi_QueueCCB
argument_list|(
argument|pmcsc
argument_list|,
argument|&pmcsc->smpSendHead
argument_list|,
argument|&pmcsc->smpSendTail                        AG_CARD_LOCAL_LOCK(&pmcsc->sendSMPLock)
argument_list|,
argument|pccb
argument_list|)
empty_stmt|;
break|break;
case|case
name|tiError
case|:
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_StartIO: tiINIIOStart status tiError %p\n"
argument_list|,
name|pccb
operator|->
name|ccb
argument_list|)
expr_stmt|;
name|pccb
operator|->
name|ccbStatus
operator|=
name|tiSMPFailed
expr_stmt|;
name|agtiapi_SMPDone
argument_list|(
name|pmcsc
argument_list|,
name|pccb
argument_list|)
expr_stmt|;
break|break;
default|default:
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_StartIO: tiINIIOStart status default %x %p\n"
argument_list|,
name|status
argument_list|,
name|pccb
operator|->
name|ccb
argument_list|)
expr_stmt|;
name|pccb
operator|->
name|ccbStatus
operator|=
name|tiSMPFailed
expr_stmt|;
name|agtiapi_SMPDone
argument_list|(
name|pmcsc
argument_list|,
name|pccb
argument_list|)
expr_stmt|;
block|}
name|pccb
operator|=
name|pccb_next
expr_stmt|;
block|}
name|ext
label|:
comment|/* some SMP requests might have been completed */
name|AG_GET_DONE_SMP_PCCB
argument_list|(
name|pccb
argument_list|,
name|pmcsc
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|>
literal|901000
end_if

begin_comment
comment|/****************************************************************************** agtiapi_PrepareSMPSGList()  Purpose:   This function prepares scatter-gather list for the given ccb Parameters:   struct agtiapi_softc *pmsc (IN)  Pointer to the HBA data structure   ccb_t *pccb (IN)      A pointer to the driver's own CCB, not CAM's CCB Return:   0 - success   1 - failure  Note: ******************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|agtiapi_PrepareSMPSGList
parameter_list|(
name|struct
name|agtiapi_softc
modifier|*
name|pmcsc
parameter_list|,
name|ccb_t
modifier|*
name|pccb
parameter_list|)
block|{
comment|/* Pointer to CAM's ccb */
name|union
name|ccb
modifier|*
name|ccb
init|=
name|pccb
operator|->
name|ccb
decl_stmt|;
name|struct
name|ccb_smpio
modifier|*
name|csmpio
init|=
operator|&
name|ccb
operator|->
name|smpio
decl_stmt|;
name|struct
name|ccb_hdr
modifier|*
name|ccbh
init|=
operator|&
name|ccb
operator|->
name|ccb_h
decl_stmt|;
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_PrepareSMPSGList: start\n"
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|(
name|ccbh
operator|->
name|flags
operator|&
name|CAM_DATA_MASK
operator|)
condition|)
block|{
case|case
name|CAM_DATA_PADDR
case|:
case|case
name|CAM_DATA_SG_PADDR
case|:
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_PrepareSMPSGList: Physical Address not supported\n"
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
name|tiReject
return|;
case|case
name|CAM_DATA_SG
case|:
comment|/*       * Currently we do not support Multiple SG list       * return error for now       */
if|if
condition|(
operator|(
name|csmpio
operator|->
name|smp_request_sglist_cnt
operator|>
literal|1
operator|)
operator|||
operator|(
name|csmpio
operator|->
name|smp_response_sglist_cnt
operator|>
literal|1
operator|)
condition|)
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_PrepareSMPSGList: Multiple SG list not supported\n"
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
name|tiReject
return|;
block|}
block|}
if|if
condition|(
name|csmpio
operator|->
name|smp_request_sglist_cnt
operator|!=
literal|0
condition|)
block|{
comment|/*         * Virtual address that needs to translated into        * one or more physical address ranges.        */
name|int
name|error
decl_stmt|;
comment|//AG_LOCAL_LOCK(&(pmcsc->pCardInfo->pmIOLock));
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_PrepareSGList: virtual address\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|pmcsc
operator|->
name|buffer_dmat
argument_list|,
name|pccb
operator|->
name|CCB_dmamap
argument_list|,
name|csmpio
operator|->
name|smp_request
argument_list|,
name|csmpio
operator|->
name|smp_request_len
argument_list|,
name|agtiapi_PrepareSMPSGListCB
argument_list|,
name|pccb
argument_list|,
name|BUS_DMA_NOWAIT
comment|/* 0 */
argument_list|)
expr_stmt|;
comment|//AG_LOCAL_UNLOCK(&(pmcsc->pCardInfo->pmIOLock));
if|if
condition|(
name|error
operator|==
name|EINPROGRESS
condition|)
block|{
comment|/*          * So as to maintain ordering,          * freeze the controller queue          * until our mapping is          * returned.          */
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_PrepareSGList: EINPROGRESS\n"
argument_list|)
expr_stmt|;
name|xpt_freeze_simq
argument_list|(
name|pmcsc
operator|->
name|sim
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pmcsc
operator|->
name|SimQFrozen
operator|=
name|agTRUE
expr_stmt|;
name|ccbh
operator|->
name|status
operator||=
name|CAM_RELEASE_SIMQ
expr_stmt|;
block|}
block|}
if|if
condition|(
name|csmpio
operator|->
name|smp_response_sglist_cnt
operator|!=
literal|0
condition|)
block|{
comment|/*        * Virtual address that needs to translated into        * one or more physical address ranges.        */
name|int
name|error
decl_stmt|;
comment|//AG_LOCAL_LOCK(&(pmcsc->pCardInfo->pmIOLock) );
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_PrepareSGList: virtual address\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|pmcsc
operator|->
name|buffer_dmat
argument_list|,
name|pccb
operator|->
name|CCB_dmamap
argument_list|,
name|csmpio
operator|->
name|smp_response
argument_list|,
name|csmpio
operator|->
name|smp_response_len
argument_list|,
name|agtiapi_PrepareSMPSGListCB
argument_list|,
name|pccb
argument_list|,
name|BUS_DMA_NOWAIT
comment|/* 0 */
argument_list|)
expr_stmt|;
comment|//AG_LOCAL_UNLOCK(&(pmcsc->pCardInfo->pmIOLock) );
if|if
condition|(
name|error
operator|==
name|EINPROGRESS
condition|)
block|{
comment|/*          * So as to maintain ordering,          * freeze the controller queue          * until our mapping is          * returned.          */
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_PrepareSGList: EINPROGRESS\n"
argument_list|)
expr_stmt|;
name|xpt_freeze_simq
argument_list|(
name|pmcsc
operator|->
name|sim
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pmcsc
operator|->
name|SimQFrozen
operator|=
name|agTRUE
expr_stmt|;
name|ccbh
operator|->
name|status
operator||=
name|CAM_RELEASE_SIMQ
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|csmpio
operator|->
name|smp_request_sglist_cnt
operator|==
literal|0
operator|)
operator|&&
operator|(
name|csmpio
operator|->
name|smp_response_sglist_cnt
operator|==
literal|0
operator|)
condition|)
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_PrepareSMPSGList: physical address\n"
argument_list|)
expr_stmt|;
name|pccb
operator|->
name|tiSMPFrame
operator|.
name|outFrameBuf
operator|=
operator|(
name|void
operator|*
operator|)
name|csmpio
operator|->
name|smp_request
expr_stmt|;
name|pccb
operator|->
name|tiSMPFrame
operator|.
name|outFrameLen
operator|=
name|csmpio
operator|->
name|smp_request_len
expr_stmt|;
name|pccb
operator|->
name|tiSMPFrame
operator|.
name|expectedRespLen
operator|=
name|csmpio
operator|->
name|smp_response_len
expr_stmt|;
comment|// 0xFF to be defined
name|agtiapi_PrepareSMPSGListCB
argument_list|(
name|pccb
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0xAABBCCDD
argument_list|)
expr_stmt|;
block|}
name|pccb
operator|->
name|tiSMPFrame
operator|.
name|flag
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|tiSuccess
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/****************************************************************************** agtiapi_PrepareSMPSGList()  Purpose:   This function prepares scatter-gather list for the given ccb Parameters:   struct agtiapi_softc *pmsc (IN)  Pointer to the HBA data structure   ccb_t *pccb (IN)      A pointer to the driver's own CCB, not CAM's CCB Return:   0 - success   1 - failure  Note: ******************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|agtiapi_PrepareSMPSGList
parameter_list|(
name|struct
name|agtiapi_softc
modifier|*
name|pmcsc
parameter_list|,
name|ccb_t
modifier|*
name|pccb
parameter_list|)
block|{
comment|/* Pointer to CAM's ccb */
name|union
name|ccb
modifier|*
name|ccb
init|=
name|pccb
operator|->
name|ccb
decl_stmt|;
name|struct
name|ccb_smpio
modifier|*
name|csmpio
init|=
operator|&
name|ccb
operator|->
name|smpio
decl_stmt|;
name|struct
name|ccb_hdr
modifier|*
name|ccbh
init|=
operator|&
name|ccb
operator|->
name|ccb_h
decl_stmt|;
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_PrepareSMPSGList: start\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccbh
operator|->
name|flags
operator|&
operator|(
name|CAM_DATA_PHYS
operator||
name|CAM_SG_LIST_PHYS
operator|)
condition|)
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_PrepareSMPSGList: Physical Address "
literal|"not supported\n"
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
name|tiReject
return|;
empty_stmt|;
block|}
if|if
condition|(
name|ccbh
operator|->
name|flags
operator|&
name|CAM_SCATTER_VALID
condition|)
block|{
comment|/*       * Currently we do not support Multiple SG list       * return error for now       */
if|if
condition|(
operator|(
name|csmpio
operator|->
name|smp_request_sglist_cnt
operator|>
literal|1
operator|)
operator|||
operator|(
name|csmpio
operator|->
name|smp_response_sglist_cnt
operator|>
literal|1
operator|)
condition|)
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_PrepareSMPSGList: Multiple SG list "
literal|"not supported\n"
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
name|tiReject
return|;
empty_stmt|;
block|}
if|if
condition|(
name|csmpio
operator|->
name|smp_request_sglist_cnt
operator|!=
literal|0
condition|)
block|{
comment|/*         * Virtual address that needs to translated into        * one or more physical address ranges.        */
name|int
name|error
decl_stmt|;
comment|//AG_LOCAL_LOCK(&(pmcsc->pCardInfo->pmIOLock));
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_PrepareSGList: virtual address\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|pmcsc
operator|->
name|buffer_dmat
argument_list|,
name|pccb
operator|->
name|CCB_dmamap
argument_list|,
name|csmpio
operator|->
name|smp_request
argument_list|,
name|csmpio
operator|->
name|smp_request_len
argument_list|,
name|agtiapi_PrepareSMPSGListCB
argument_list|,
name|pccb
argument_list|,
name|BUS_DMA_NOWAIT
comment|/* 0 */
argument_list|)
expr_stmt|;
comment|//AG_LOCAL_UNLOCK(&(pmcsc->pCardInfo->pmIOLock));
if|if
condition|(
name|error
operator|==
name|EINPROGRESS
condition|)
block|{
comment|/*          * So as to maintain ordering,          * freeze the controller queue          * until our mapping is          * returned.          */
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_PrepareSGList: EINPROGRESS\n"
argument_list|)
expr_stmt|;
name|xpt_freeze_simq
argument_list|(
name|pmcsc
operator|->
name|sim
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pmcsc
operator|->
name|SimQFrozen
operator|=
name|agTRUE
expr_stmt|;
name|ccbh
operator|->
name|status
operator||=
name|CAM_RELEASE_SIMQ
expr_stmt|;
block|}
block|}
if|if
condition|(
name|csmpio
operator|->
name|smp_response_sglist_cnt
operator|!=
literal|0
condition|)
block|{
comment|/*        * Virtual address that needs to translated into        * one or more physical address ranges.        */
name|int
name|error
decl_stmt|;
comment|//AG_LOCAL_LOCK(&(pmcsc->pCardInfo->pmIOLock) );
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_PrepareSGList: virtual address\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|pmcsc
operator|->
name|buffer_dmat
argument_list|,
name|pccb
operator|->
name|CCB_dmamap
argument_list|,
name|csmpio
operator|->
name|smp_response
argument_list|,
name|csmpio
operator|->
name|smp_response_len
argument_list|,
name|agtiapi_PrepareSMPSGListCB
argument_list|,
name|pccb
argument_list|,
name|BUS_DMA_NOWAIT
comment|/* 0 */
argument_list|)
expr_stmt|;
comment|//AG_LOCAL_UNLOCK(&(pmcsc->pCardInfo->pmIOLock) );
if|if
condition|(
name|error
operator|==
name|EINPROGRESS
condition|)
block|{
comment|/*          * So as to maintain ordering,          * freeze the controller queue          * until our mapping is          * returned.          */
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_PrepareSGList: EINPROGRESS\n"
argument_list|)
expr_stmt|;
name|xpt_freeze_simq
argument_list|(
name|pmcsc
operator|->
name|sim
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pmcsc
operator|->
name|SimQFrozen
operator|=
name|agTRUE
expr_stmt|;
name|ccbh
operator|->
name|status
operator||=
name|CAM_RELEASE_SIMQ
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|csmpio
operator|->
name|smp_request_sglist_cnt
operator|==
literal|0
operator|)
operator|&&
operator|(
name|csmpio
operator|->
name|smp_response_sglist_cnt
operator|==
literal|0
operator|)
condition|)
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_PrepareSMPSGList: physical address\n"
argument_list|)
expr_stmt|;
name|pccb
operator|->
name|tiSMPFrame
operator|.
name|outFrameBuf
operator|=
operator|(
name|void
operator|*
operator|)
name|csmpio
operator|->
name|smp_request
expr_stmt|;
name|pccb
operator|->
name|tiSMPFrame
operator|.
name|outFrameLen
operator|=
name|csmpio
operator|->
name|smp_request_len
expr_stmt|;
name|pccb
operator|->
name|tiSMPFrame
operator|.
name|expectedRespLen
operator|=
name|csmpio
operator|->
name|smp_response_len
expr_stmt|;
comment|// 0xFF to be defined
name|agtiapi_PrepareSMPSGListCB
argument_list|(
name|pccb
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0xAABBCCDD
argument_list|)
expr_stmt|;
block|}
name|pccb
operator|->
name|tiSMPFrame
operator|.
name|flag
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|tiSuccess
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/****************************************************************************** agtiapi_PrepareSMPSGListCB()  Purpose:   Callback function for bus_dmamap_load()   This fuctions sends IO to LL layer. Parameters:   void *arg (IN)                Pointer to the HBA data structure   bus_dma_segment_t *segs (IN)  Pointer to dma segment   int nsegs (IN)                number of dma segment   int error (IN)                error Return: Note: ******************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|agtiapi_PrepareSMPSGListCB
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nsegs
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|pccb_t
name|pccb
init|=
name|arg
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
init|=
name|pccb
operator|->
name|ccb
decl_stmt|;
name|struct
name|agtiapi_softc
modifier|*
name|pmcsc
decl_stmt|;
name|U32
name|TID
init|=
name|CMND_TO_TARGET
argument_list|(
name|ccb
argument_list|)
decl_stmt|;
name|int
name|status
decl_stmt|;
name|tiDeviceHandle_t
modifier|*
name|tiExpDevHandle
decl_stmt|;
name|tiPortalContext_t
modifier|*
name|tiExpPortalContext
decl_stmt|;
name|ag_portal_info_t
modifier|*
name|tiExpPortalInfo
decl_stmt|;
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_PrepareSMPSGListCB: start, nsegs %d error 0x%x\n"
argument_list|,
name|nsegs
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|pmcsc
operator|=
name|pccb
operator|->
name|pmcsc
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|tiSuccess
condition|)
block|{
if|if
condition|(
name|error
operator|==
literal|0xAABBCCDD
condition|)
block|{
comment|// do nothing
block|}
else|else
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_PrepareSMPSGListCB: error status 0x%x\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|pmcsc
operator|->
name|buffer_dmat
argument_list|,
name|pccb
operator|->
name|CCB_dmamap
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|pmcsc
operator|->
name|buffer_dmat
argument_list|,
name|pccb
operator|->
name|CCB_dmamap
argument_list|)
expr_stmt|;
name|agtiapi_FreeCCB
argument_list|(
name|pmcsc
argument_list|,
name|pccb
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|nsegs
operator|>
name|AGTIAPI_MAX_DMA_SEGS
condition|)
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_PrepareSMPSGListCB: over the limit. nsegs %d "
literal|"AGTIAPI_MAX_DMA_SEGS %d\n"
argument_list|,
name|nsegs
argument_list|,
name|AGTIAPI_MAX_DMA_SEGS
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|pmcsc
operator|->
name|buffer_dmat
argument_list|,
name|pccb
operator|->
name|CCB_dmamap
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|pmcsc
operator|->
name|buffer_dmat
argument_list|,
name|pccb
operator|->
name|CCB_dmamap
argument_list|)
expr_stmt|;
name|agtiapi_FreeCCB
argument_list|(
name|pmcsc
argument_list|,
name|pccb
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*    * If assigned pDevHandle is not available    * then there is no need to send it to StartIO()    */
comment|/* TODO: Add check for deviceType */
if|if
condition|(
name|pccb
operator|->
name|targetId
operator|<
literal|0
operator|||
name|pccb
operator|->
name|targetId
operator|>=
name|maxTargets
condition|)
block|{
name|agtiapi_FreeCCB
argument_list|(
name|pmcsc
argument_list|,
name|pccb
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_FUNC_NOTAVAIL
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|pccb
operator|->
name|ccb
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
name|TID
operator|=
name|INDEX
argument_list|(
name|pmcsc
argument_list|,
name|pccb
operator|->
name|targetId
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|TID
operator|>=
name|pmcsc
operator|->
name|devDiscover
operator|)
operator|||
operator|!
operator|(
name|pccb
operator|->
name|devHandle
operator|=
name|pmcsc
operator|->
name|pDevList
index|[
name|TID
index|]
operator|.
name|pDevHandle
operator|)
condition|)
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_PrepareSMPSGListCB: not sending ccb devH %p, "
literal|"target %d tid %d/%d "
literal|"card %p ERROR pccb %p\n"
argument_list|,
name|pccb
operator|->
name|devHandle
argument_list|,
name|pccb
operator|->
name|targetId
argument_list|,
name|TID
argument_list|,
name|pmcsc
operator|->
name|devDiscover
argument_list|,
name|pmcsc
argument_list|,
name|pccb
argument_list|)
expr_stmt|;
name|agtiapi_FreeCCB
argument_list|(
name|pmcsc
argument_list|,
name|pccb
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_FUNC_NOTAVAIL
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|pccb
operator|->
name|ccb
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
comment|/* TODO: add indirect handling */
comment|/* set the flag correctly based on Indiret SMP request and response */
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_PrepareSMPSGListCB: send ccb pccb->devHandle %p, "
literal|"pccb->targetId %d TID %d pmcsc->devDiscover %d card %p\n"
argument_list|,
name|pccb
operator|->
name|devHandle
argument_list|,
name|pccb
operator|->
name|targetId
argument_list|,
name|TID
argument_list|,
name|pmcsc
operator|->
name|devDiscover
argument_list|,
name|pmcsc
argument_list|)
expr_stmt|;
name|tiExpDevHandle
operator|=
name|pccb
operator|->
name|devHandle
expr_stmt|;
name|tiExpPortalInfo
operator|=
name|pmcsc
operator|->
name|pDevList
index|[
name|TID
index|]
operator|.
name|pPortalInfo
expr_stmt|;
name|tiExpPortalContext
operator|=
operator|&
name|tiExpPortalInfo
operator|->
name|tiPortalContext
expr_stmt|;
comment|/* Look for the expander associated with the ses device */
name|status
operator|=
name|tiINIGetExpander
argument_list|(
operator|&
name|pmcsc
operator|->
name|tiRoot
argument_list|,
name|tiExpPortalContext
argument_list|,
name|pccb
operator|->
name|devHandle
argument_list|,
operator|&
name|tiExpDevHandle
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|tiSuccess
condition|)
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_PrepareSMPSGListCB: Error getting Expander "
literal|"device\n"
argument_list|)
expr_stmt|;
name|agtiapi_FreeCCB
argument_list|(
name|pmcsc
argument_list|,
name|pccb
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_FUNC_NOTAVAIL
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|pccb
operator|->
name|ccb
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
comment|/* this is expander device */
name|pccb
operator|->
name|devHandle
operator|=
name|tiExpDevHandle
expr_stmt|;
comment|/* put the request in send queue */
name|agtiapi_QueueCCB
argument_list|(
argument|pmcsc
argument_list|,
argument|&pmcsc->smpSendHead
argument_list|,
argument|&pmcsc->smpSendTail                     AG_CARD_LOCAL_LOCK(&pmcsc->sendSMPLock)
argument_list|,
argument|pccb
argument_list|)
empty_stmt|;
name|agtiapi_StartSMP
argument_list|(
name|pmcsc
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/****************************************************************************** agtiapi_Done()  Purpose:   Processing completed ccbs Parameters:   struct agtiapi_softc *pmcsc (IN)   Pointer to HBA data structure   ccb_t *pccb (IN)     A pointer to the driver's own CCB, not CAM's CCB Return: Note: ******************************************************************************/
end_comment

begin_function
name|STATIC
name|void
name|agtiapi_Done
parameter_list|(
name|struct
name|agtiapi_softc
modifier|*
name|pmcsc
parameter_list|,
name|ccb_t
modifier|*
name|pccb
parameter_list|)
block|{
name|pccb_t
name|pccb_curr
init|=
name|pccb
decl_stmt|;
name|pccb_t
name|pccb_next
decl_stmt|;
name|tiIniScsiCmnd_t
modifier|*
name|cmnd
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|AGTIAPI_IO
argument_list|(
literal|"agtiapi_Done: start\n"
argument_list|)
expr_stmt|;
while|while
condition|(
name|pccb_curr
condition|)
block|{
comment|/* start from 1st ccb in the chain */
name|pccb_next
operator|=
name|pccb_curr
operator|->
name|pccbNext
expr_stmt|;
if|if
condition|(
name|agtiapi_CheckError
argument_list|(
name|pmcsc
argument_list|,
name|pccb_curr
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* send command back and release the ccb */
name|cmnd
operator|=
operator|&
name|pccb_curr
operator|->
name|tiSuperScsiRequest
operator|.
name|scsiCmnd
expr_stmt|;
if|if
condition|(
name|cmnd
operator|->
name|cdb
index|[
literal|0
index|]
operator|==
name|RECEIVE_DIAGNOSTIC
condition|)
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_Done: RECEIVE_DIAG pg %d id %d cmnd %p pccb "
literal|"%p\n"
argument_list|,
name|cmnd
operator|->
name|cdb
index|[
literal|2
index|]
argument_list|,
name|pccb_curr
operator|->
name|targetId
argument_list|,
name|cmnd
argument_list|,
name|pccb_curr
argument_list|)
expr_stmt|;
block|}
name|CMND_DMA_UNMAP
argument_list|(
name|pmcsc
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
comment|/* send the request back to the CAM */
name|ccb
operator|=
name|pccb_curr
operator|->
name|ccb
expr_stmt|;
name|agtiapi_FreeCCB
argument_list|(
name|pmcsc
argument_list|,
name|pccb_curr
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
block|}
name|pccb_curr
operator|=
name|pccb_next
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/****************************************************************************** agtiapi_SMPDone()  Purpose:   Processing completed ccbs Parameters:   struct agtiapi_softc *pmcsc (IN)  Ponter to HBA data structure   ccb_t *pccb (IN)                  A pointer to the driver's own CCB, not                                     CAM's CCB Return: Note: ******************************************************************************/
end_comment

begin_function
name|STATIC
name|void
name|agtiapi_SMPDone
parameter_list|(
name|struct
name|agtiapi_softc
modifier|*
name|pmcsc
parameter_list|,
name|ccb_t
modifier|*
name|pccb
parameter_list|)
block|{
name|pccb_t
name|pccb_curr
init|=
name|pccb
decl_stmt|;
name|pccb_t
name|pccb_next
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_SMPDone: start\n"
argument_list|)
expr_stmt|;
while|while
condition|(
name|pccb_curr
condition|)
block|{
comment|/* start from 1st ccb in the chain */
name|pccb_next
operator|=
name|pccb_curr
operator|->
name|pccbNext
expr_stmt|;
if|if
condition|(
name|agtiapi_CheckSMPError
argument_list|(
name|pmcsc
argument_list|,
name|pccb_curr
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|CMND_DMA_UNMAP
argument_list|(
name|pmcsc
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
comment|/* send the request back to the CAM */
name|ccb
operator|=
name|pccb_curr
operator|->
name|ccb
expr_stmt|;
name|agtiapi_FreeSMPCCB
argument_list|(
name|pmcsc
argument_list|,
name|pccb_curr
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
block|}
name|pccb_curr
operator|=
name|pccb_next
expr_stmt|;
block|}
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_SMPDone: Done\n"
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/****************************************************************************** agtiapi_hexdump()  Purpose:   Utility function for dumping in hex Parameters:   const char *ptitle (IN)  A string to be printed   bit8 *pbuf (IN)          A pointer to a buffer to be printed.    int len (IN)             The lengther of the buffer Return: Note: ******************************************************************************/
end_comment

begin_function
name|void
name|agtiapi_hexdump
parameter_list|(
specifier|const
name|char
modifier|*
name|ptitle
parameter_list|,
name|bit8
modifier|*
name|pbuf
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|AGTIAPI_PRINTK
argument_list|(
literal|"%s - hexdump(len=%d):\n"
argument_list|,
name|ptitle
argument_list|,
operator|(
name|int
operator|)
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pbuf
condition|)
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"pbuf is NULL\n"
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
control|)
block|{
if|if
condition|(
name|len
operator|-
name|i
operator|>
literal|4
condition|)
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|" 0x%02x, 0x%02x, 0x%02x, 0x%02x,\n"
argument_list|,
name|pbuf
index|[
name|i
index|]
argument_list|,
name|pbuf
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
name|pbuf
index|[
name|i
operator|+
literal|2
index|]
argument_list|,
name|pbuf
index|[
name|i
operator|+
literal|3
index|]
argument_list|)
expr_stmt|;
name|i
operator|+=
literal|4
expr_stmt|;
block|}
else|else
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|" 0x%02x,"
argument_list|,
name|pbuf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
block|}
name|AGTIAPI_PRINTK
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************** agtiapi_CheckError()  Purpose:   Processes status pertaining to the ccb -- whether it was   completed successfully, aborted, or error encountered. Parameters:    ag_card_t *pCard (IN)  Pointer to HBA data structure   ccb_t *pccd (IN)       A pointer to the driver's own CCB, not CAM's CCB Return:   0 - the command retry is required   1 - the command process is completed Note:      ******************************************************************************/
end_comment

begin_function
name|STATIC
name|U32
name|agtiapi_CheckError
parameter_list|(
name|struct
name|agtiapi_softc
modifier|*
name|pmcsc
parameter_list|,
name|ccb_t
modifier|*
name|pccb
parameter_list|)
block|{
name|ag_device_t
modifier|*
name|pDevice
decl_stmt|;
comment|// union ccb * ccb = pccb->ccb;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|int
name|is_error
decl_stmt|,
name|TID
decl_stmt|;
if|if
condition|(
name|pccb
operator|==
name|NULL
condition|)
block|{
return|return
literal|0
return|;
block|}
name|ccb
operator|=
name|pccb
operator|->
name|ccb
expr_stmt|;
name|AGTIAPI_IO
argument_list|(
literal|"agtiapi_CheckError: start\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb
operator|==
name|NULL
condition|)
block|{
comment|/* shouldn't be here but just in case we do */
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_CheckError: CCB orphan = %p ERROR\n"
argument_list|,
name|pccb
argument_list|)
expr_stmt|;
name|agtiapi_FreeCCB
argument_list|(
name|pmcsc
argument_list|,
name|pccb
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|is_error
operator|=
literal|1
expr_stmt|;
name|pDevice
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|pmcsc
operator|!=
name|NULL
operator|&&
name|pccb
operator|->
name|targetId
operator|>=
literal|0
operator|&&
name|pccb
operator|->
name|targetId
operator|<
name|maxTargets
condition|)
block|{
if|if
condition|(
name|pmcsc
operator|->
name|pWWNList
operator|!=
name|NULL
condition|)
block|{
name|TID
operator|=
name|INDEX
argument_list|(
name|pmcsc
argument_list|,
name|pccb
operator|->
name|targetId
argument_list|)
expr_stmt|;
if|if
condition|(
name|TID
operator|<
name|maxTargets
condition|)
block|{
name|pDevice
operator|=
operator|&
name|pmcsc
operator|->
name|pDevList
index|[
name|TID
index|]
expr_stmt|;
if|if
condition|(
name|pDevice
operator|!=
name|NULL
condition|)
block|{
name|is_error
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|is_error
condition|)
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_CheckError: pDevice == NULL\n"
argument_list|)
expr_stmt|;
name|agtiapi_FreeCCB
argument_list|(
name|pmcsc
argument_list|,
name|pccb
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* SCSI status */
name|ccb
operator|->
name|csio
operator|.
name|scsi_status
operator|=
name|pccb
operator|->
name|scsiStatus
expr_stmt|;
if|if
condition|(
name|pDevice
operator|->
name|CCBCount
operator|>
literal|0
condition|)
block|{
name|atomic_subtract_int
argument_list|(
operator|&
name|pDevice
operator|->
name|CCBCount
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|AG_LOCAL_LOCK
argument_list|(
operator|&
name|pmcsc
operator|->
name|freezeLock
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmcsc
operator|->
name|freezeSim
operator|==
name|agTRUE
condition|)
block|{
name|pmcsc
operator|->
name|freezeSim
operator|=
name|agFALSE
expr_stmt|;
name|xpt_release_simq
argument_list|(
name|pmcsc
operator|->
name|sim
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|AG_LOCAL_UNLOCK
argument_list|(
operator|&
name|pmcsc
operator|->
name|freezeLock
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pccb
operator|->
name|ccbStatus
condition|)
block|{
case|case
name|tiIOSuccess
case|:
name|AGTIAPI_IO
argument_list|(
literal|"agtiapi_CheckError: tiIOSuccess pccb %p\n"
argument_list|,
name|pccb
argument_list|)
expr_stmt|;
comment|/* CAM status */
if|if
condition|(
name|pccb
operator|->
name|scsiStatus
operator|==
name|SCSI_STATUS_OK
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pccb
operator|->
name|scsiStatus
operator|==
name|SCSI_TASK_ABORTED
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_ABORTED
expr_stmt|;
block|}
else|else
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_SCSI_STATUS_ERROR
expr_stmt|;
block|}
if|if
condition|(
name|ccb
operator|->
name|csio
operator|.
name|scsi_status
operator|==
name|SCSI_CHECK_CONDITION
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_AUTOSNS_VALID
expr_stmt|;
block|}
break|break;
case|case
name|tiIOOverRun
case|:
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_CheckError: tiIOOverRun pccb %p\n"
argument_list|,
name|pccb
argument_list|)
expr_stmt|;
comment|/* resid is ignored for this condition */
name|ccb
operator|->
name|csio
operator|.
name|resid
operator|=
literal|0
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_DATA_RUN_ERR
expr_stmt|;
break|break;
case|case
name|tiIOUnderRun
case|:
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_CheckError: tiIOUnderRun pccb %p\n"
argument_list|,
name|pccb
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|csio
operator|.
name|resid
operator|=
name|pccb
operator|->
name|scsiStatus
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|ccb
operator|->
name|csio
operator|.
name|scsi_status
operator|=
name|SCSI_STATUS_OK
expr_stmt|;
break|break;
case|case
name|tiIOFailed
case|:
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_CheckError: pccb %p tiIOFailed %d id %d ERROR\n"
argument_list|,
name|pccb
argument_list|,
name|pccb
operator|->
name|scsiStatus
argument_list|,
name|pccb
operator|->
name|targetId
argument_list|)
expr_stmt|;
if|if
condition|(
name|pccb
operator|->
name|scsiStatus
operator|==
name|tiDeviceBusy
condition|)
block|{
name|AGTIAPI_IO
argument_list|(
literal|"agtiapi_CheckError: pccb %p tiIOFailed - tiDetailBusy\n"
argument_list|,
name|pccb
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&=
operator|~
name|CAM_STATUS_MASK
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQUEUE_REQ
expr_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_DEV_QFRZN
operator|)
operator|==
literal|0
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_DEV_QFRZN
expr_stmt|;
name|xpt_freeze_devq
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
comment|/*count*/
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|pccb
operator|->
name|scsiStatus
operator|==
name|tiBusy
condition|)
block|{
name|AG_LOCAL_LOCK
argument_list|(
operator|&
name|pmcsc
operator|->
name|freezeLock
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmcsc
operator|->
name|freezeSim
operator|==
name|agFALSE
condition|)
block|{
name|pmcsc
operator|->
name|freezeSim
operator|=
name|agTRUE
expr_stmt|;
name|xpt_freeze_simq
argument_list|(
name|pmcsc
operator|->
name|sim
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|AG_LOCAL_UNLOCK
argument_list|(
operator|&
name|pmcsc
operator|->
name|freezeLock
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&=
operator|~
name|CAM_SIM_QUEUED
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQUEUE_REQ
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pccb
operator|->
name|scsiStatus
operator|==
name|tiDetailNoLogin
condition|)
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_CheckError: pccb %p tiIOFailed - "
literal|"tiDetailNoLogin ERROR\n"
argument_list|,
name|pccb
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_DEV_NOT_THERE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pccb
operator|->
name|scsiStatus
operator|==
name|tiDetailNotValid
condition|)
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_CheckError: pccb %p tiIOFailed - "
literal|"tiDetailNotValid ERROR\n"
argument_list|,
name|pccb
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pccb
operator|->
name|scsiStatus
operator|==
name|tiDetailAbortLogin
condition|)
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_CheckError: pccb %p tiIOFailed - "
literal|"tiDetailAbortLogin ERROR\n"
argument_list|,
name|pccb
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_ABORTED
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pccb
operator|->
name|scsiStatus
operator|==
name|tiDetailAbortReset
condition|)
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_CheckError: pccb %p tiIOFailed - "
literal|"tiDetailAbortReset ERROR\n"
argument_list|,
name|pccb
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_ABORTED
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pccb
operator|->
name|scsiStatus
operator|==
name|tiDetailAborted
condition|)
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_CheckError: pccb %p tiIOFailed - "
literal|"tiDetailAborted ERROR\n"
argument_list|,
name|pccb
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_ABORTED
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pccb
operator|->
name|scsiStatus
operator|==
name|tiDetailOtherError
condition|)
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_CheckError: pccb %p tiIOFailed - "
literal|"tiDetailOtherError ERROR\n"
argument_list|,
name|pccb
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_ABORTED
expr_stmt|;
block|}
break|break;
case|case
name|tiIODifError
case|:
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_CheckError: pccb %p tiIOFailed %d id %d ERROR\n"
argument_list|,
name|pccb
argument_list|,
name|pccb
operator|->
name|scsiStatus
argument_list|,
name|pccb
operator|->
name|targetId
argument_list|)
expr_stmt|;
if|if
condition|(
name|pccb
operator|->
name|scsiStatus
operator|==
name|tiDetailDifAppTagMismatch
condition|)
block|{
name|AGTIAPI_IO
argument_list|(
literal|"agtiapi_CheckError: pccb %p tiIOFailed - "
literal|"tiDetailDifAppTagMismatch\n"
argument_list|,
name|pccb
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP_ERR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pccb
operator|->
name|scsiStatus
operator|==
name|tiDetailDifRefTagMismatch
condition|)
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_CheckError: pccb %p tiIOFailed - "
literal|"tiDetailDifRefTagMismatch\n"
argument_list|,
name|pccb
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP_ERR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pccb
operator|->
name|scsiStatus
operator|==
name|tiDetailDifCrcMismatch
condition|)
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_CheckError: pccb %p tiIOFailed - "
literal|"tiDetailDifCrcMismatch\n"
argument_list|,
name|pccb
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP_ERR
expr_stmt|;
block|}
break|break;
ifdef|#
directive|ifdef
name|HIALEAH_ENCRYPTION
case|case
name|tiIOEncryptError
case|:
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_CheckError: pccb %p tiIOFailed %d id %d ERROR\n"
argument_list|,
name|pccb
argument_list|,
name|pccb
operator|->
name|scsiStatus
argument_list|,
name|pccb
operator|->
name|targetId
argument_list|)
expr_stmt|;
if|if
condition|(
name|pccb
operator|->
name|scsiStatus
operator|==
name|tiDetailDekKeyCacheMiss
condition|)
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_CheckError: %s: pccb %p tiIOFailed - "
literal|"tiDetailDekKeyCacheMiss ERROR\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|pccb
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_ABORTED
expr_stmt|;
name|agtiapi_HandleEncryptedIOFailure
argument_list|(
name|pDevice
argument_list|,
name|pccb
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pccb
operator|->
name|scsiStatus
operator|==
name|tiDetailDekIVMismatch
condition|)
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_CheckError: %s: pccb %p tiIOFailed - "
literal|"tiDetailDekIVMismatch ERROR\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|pccb
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_ABORTED
expr_stmt|;
name|agtiapi_HandleEncryptedIOFailure
argument_list|(
name|pDevice
argument_list|,
name|pccb
argument_list|)
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
default|default:
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_CheckError: pccb %p tiIOdefault %d id %d ERROR\n"
argument_list|,
name|pccb
argument_list|,
name|pccb
operator|->
name|ccbStatus
argument_list|,
name|pccb
operator|->
name|targetId
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP_ERR
expr_stmt|;
break|break;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************** agtiapi_SMPCheckError()  Purpose:   Processes status pertaining to the ccb -- whether it was   completed successfully, aborted, or error encountered. Parameters:    ag_card_t *pCard (IN)  Pointer to HBA data structure   ccb_t *pccd (IN)       A pointer to the driver's own CCB, not CAM's CCB Return:   0 - the command retry is required   1 - the command process is completed Note:      ******************************************************************************/
end_comment

begin_function
name|STATIC
name|U32
name|agtiapi_CheckSMPError
parameter_list|(
name|struct
name|agtiapi_softc
modifier|*
name|pmcsc
parameter_list|,
name|ccb_t
modifier|*
name|pccb
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
init|=
name|pccb
operator|->
name|ccb
decl_stmt|;
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_CheckSMPError: start\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ccb
condition|)
block|{
comment|/* shouldn't be here but just in case we do */
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_CheckSMPError: CCB orphan = %p ERROR\n"
argument_list|,
name|pccb
argument_list|)
expr_stmt|;
name|agtiapi_FreeSMPCCB
argument_list|(
name|pmcsc
argument_list|,
name|pccb
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
switch|switch
condition|(
name|pccb
operator|->
name|ccbStatus
condition|)
block|{
case|case
name|tiSMPSuccess
case|:
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_CheckSMPError: tiSMPSuccess pccb %p\n"
argument_list|,
name|pccb
argument_list|)
expr_stmt|;
comment|/* CAM status */
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
break|break;
case|case
name|tiSMPFailed
case|:
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_CheckSMPError: tiSMPFailed pccb %p\n"
argument_list|,
name|pccb
argument_list|)
expr_stmt|;
comment|/* CAM status */
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP_ERR
expr_stmt|;
break|break;
default|default:
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_CheckSMPError: pccb %p tiSMPdefault %d "
literal|"id %d ERROR\n"
argument_list|,
name|pccb
argument_list|,
name|pccb
operator|->
name|ccbStatus
argument_list|,
name|pccb
operator|->
name|targetId
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP_ERR
expr_stmt|;
break|break;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************** agtiapi_HandleEncryptedIOFailure():  Purpose: Parameters: Return: Note:    Currently not used. ******************************************************************************/
end_comment

begin_function
name|void
name|agtiapi_HandleEncryptedIOFailure
parameter_list|(
name|ag_device_t
modifier|*
name|pDev
parameter_list|,
name|ccb_t
modifier|*
name|pccb
parameter_list|)
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_HandleEncryptedIOFailure: start\n"
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/****************************************************************************** agtiapi_Retry()  Purpose:   Retry a ccb. Parameters:    struct agtiapi_softc *pmcsc (IN)  Pointer to the HBA structure   ccb_t *pccb (IN)            A pointer to the driver's own CCB, not CAM's CCB  Return: Note:   Currently not used.     ******************************************************************************/
end_comment

begin_function
name|STATIC
name|void
name|agtiapi_Retry
parameter_list|(
name|struct
name|agtiapi_softc
modifier|*
name|pmcsc
parameter_list|,
name|ccb_t
modifier|*
name|pccb
parameter_list|)
block|{
name|pccb
operator|->
name|retryCount
operator|++
expr_stmt|;
name|pccb
operator|->
name|flags
operator|=
name|ACTIVE
operator||
name|AGTIAPI_RETRY
expr_stmt|;
name|pccb
operator|->
name|ccbStatus
operator|=
literal|0
expr_stmt|;
name|pccb
operator|->
name|scsiStatus
operator|=
literal|0
expr_stmt|;
name|pccb
operator|->
name|startTime
operator|=
name|ticks
expr_stmt|;
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_Retry: start\n"
argument_list|)
expr_stmt|;
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_Retry: ccb %p retry %d flgs x%x\n"
argument_list|,
name|pccb
argument_list|,
name|pccb
operator|->
name|retryCount
argument_list|,
name|pccb
operator|->
name|flags
argument_list|)
expr_stmt|;
name|agtiapi_QueueCCB
argument_list|(
argument|pmcsc
argument_list|,
argument|&pmcsc->ccbSendHead
argument_list|,
argument|&pmcsc->ccbSendTail                    AG_CARD_LOCAL_LOCK(&pmcsc->sendLock)
argument_list|,
argument|pccb
argument_list|)
empty_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/****************************************************************************** agtiapi_DumpCCB()  Purpose:   Dump CCB for debuging Parameters:   ccb_t *pccb (IN)  A pointer to the driver's own CCB, not CAM's CCB Return: Note: ******************************************************************************/
end_comment

begin_function
name|STATIC
name|void
name|agtiapi_DumpCCB
parameter_list|(
name|ccb_t
modifier|*
name|pccb
parameter_list|)
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_DumpCCB: pccb %p, devHandle %p, tid %d, lun %d\n"
argument_list|,
name|pccb
argument_list|,
name|pccb
operator|->
name|devHandle
argument_list|,
name|pccb
operator|->
name|targetId
argument_list|,
name|pccb
operator|->
name|lun
argument_list|)
expr_stmt|;
name|AGTIAPI_PRINTK
argument_list|(
literal|"flag 0x%x, add_mode 0x%x, ccbStatus 0x%x, scsiStatus 0x%x\n"
argument_list|,
name|pccb
operator|->
name|flags
argument_list|,
name|pccb
operator|->
name|addrMode
argument_list|,
name|pccb
operator|->
name|ccbStatus
argument_list|,
name|pccb
operator|->
name|scsiStatus
argument_list|)
expr_stmt|;
name|AGTIAPI_PRINTK
argument_list|(
literal|"scsi comand = 0x%x, numSgElements = %d\n"
argument_list|,
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|scsiCmnd
operator|.
name|cdb
index|[
literal|0
index|]
argument_list|,
name|pccb
operator|->
name|numSgElements
argument_list|)
expr_stmt|;
name|AGTIAPI_PRINTK
argument_list|(
literal|"dataLen = 0x%x, sens_len = 0x%x\n"
argument_list|,
name|pccb
operator|->
name|dataLen
argument_list|,
name|pccb
operator|->
name|senseLen
argument_list|)
expr_stmt|;
name|AGTIAPI_PRINTK
argument_list|(
literal|"tiSuperScsiRequest:\n"
argument_list|)
expr_stmt|;
name|AGTIAPI_PRINTK
argument_list|(
literal|"scsiCmnd: expDataLength 0x%x, taskAttribute 0x%x\n"
argument_list|,
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|scsiCmnd
operator|.
name|expDataLength
argument_list|,
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|scsiCmnd
operator|.
name|taskAttribute
argument_list|)
expr_stmt|;
name|AGTIAPI_PRINTK
argument_list|(
literal|"cdb[0] = 0x%x, cdb[1] = 0x%x, cdb[2] = 0x%x, cdb[3] = 0x%x\n"
argument_list|,
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|scsiCmnd
operator|.
name|cdb
index|[
literal|0
index|]
argument_list|,
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|scsiCmnd
operator|.
name|cdb
index|[
literal|1
index|]
argument_list|,
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|scsiCmnd
operator|.
name|cdb
index|[
literal|2
index|]
argument_list|,
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|scsiCmnd
operator|.
name|cdb
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|AGTIAPI_PRINTK
argument_list|(
literal|"cdb[4] = 0x%x, cdb[5] = 0x%x, cdb[6] = 0x%x, cdb[7] = 0x%x\n"
argument_list|,
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|scsiCmnd
operator|.
name|cdb
index|[
literal|4
index|]
argument_list|,
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|scsiCmnd
operator|.
name|cdb
index|[
literal|5
index|]
argument_list|,
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|scsiCmnd
operator|.
name|cdb
index|[
literal|6
index|]
argument_list|,
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|scsiCmnd
operator|.
name|cdb
index|[
literal|7
index|]
argument_list|)
expr_stmt|;
name|AGTIAPI_PRINTK
argument_list|(
literal|"cdb[8] = 0x%x, cdb[9] = 0x%x, cdb[10] = 0x%x, "
literal|"cdb[11] = 0x%x\n"
argument_list|,
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|scsiCmnd
operator|.
name|cdb
index|[
literal|8
index|]
argument_list|,
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|scsiCmnd
operator|.
name|cdb
index|[
literal|9
index|]
argument_list|,
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|scsiCmnd
operator|.
name|cdb
index|[
literal|10
index|]
argument_list|,
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|scsiCmnd
operator|.
name|cdb
index|[
literal|11
index|]
argument_list|)
expr_stmt|;
name|AGTIAPI_PRINTK
argument_list|(
literal|"agSgl1: upper 0x%x, lower 0x%x, len 0x%x, type %d\n"
argument_list|,
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|agSgl1
operator|.
name|upper
argument_list|,
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|agSgl1
operator|.
name|lower
argument_list|,
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|agSgl1
operator|.
name|len
argument_list|,
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|agSgl1
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************** agtiapi_eh_HostReset()  Purpose:   A new error handler of Host Reset command. Parameters:   scsi_cmnd *cmnd (IN)  Pointer to a command to the HBA to be reset Return:   SUCCESS - success   FAILED  - fail Note: ******************************************************************************/
end_comment

begin_function
name|int
name|agtiapi_eh_HostReset
parameter_list|(
name|struct
name|agtiapi_softc
modifier|*
name|pmcsc
parameter_list|,
name|union
name|ccb
modifier|*
name|cmnd
parameter_list|)
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_eh_HostReset: ccb pointer %p\n"
argument_list|,
name|cmnd
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmnd
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"agtiapi_eh_HostReset: null command, skipping reset.\n"
argument_list|)
expr_stmt|;
return|return
name|tiInvalidHandle
return|;
block|}
ifdef|#
directive|ifdef
name|LOGEVENT
name|agtiapi_LogEvent
argument_list|(
name|pmcsc
argument_list|,
name|IOCTL_EVT_SEV_INFORMATIONAL
argument_list|,
literal|0
argument_list|,
name|agNULL
argument_list|,
literal|0
argument_list|,
literal|"agtiapi_eh_HostReset! "
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|agtiapi_DoSoftReset
argument_list|(
name|pmcsc
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************** agtiapi_QueueCCB()  Purpose:   Put ccb in ccb queue at the tail Parameters:   struct agtiapi_softc *pmcsc (IN)  Pointer to HBA data structure   pccb_t *phead (IN)                Double pointer to ccb queue head   pccb_t *ptail (IN)                Double pointer to ccb queue tail   ccb_t *pccb (IN)                  Poiner to a ccb to be queued Return: Note:   Put the ccb to the tail of queue ******************************************************************************/
end_comment

begin_function
name|STATIC
name|void
name|agtiapi_QueueCCB
parameter_list|(
name|struct
name|agtiapi_softc
modifier|*
name|pmcsc
parameter_list|,
name|pccb_t
modifier|*
name|phead
parameter_list|,
name|pccb_t
modifier|*
name|ptail
parameter_list|,
ifdef|#
directive|ifdef
name|AGTIAPI_LOCAL_LOCK
name|struct
name|mtx
modifier|*
name|mutex
parameter_list|,
endif|#
directive|endif
name|ccb_t
modifier|*
name|pccb
parameter_list|)
block|{
name|AGTIAPI_IO
argument_list|(
literal|"agtiapi_QueueCCB: start\n"
argument_list|)
expr_stmt|;
name|AGTIAPI_IO
argument_list|(
literal|"agtiapi_QueueCCB: %p to %p\n"
argument_list|,
name|pccb
argument_list|,
name|phead
argument_list|)
expr_stmt|;
if|if
condition|(
name|phead
operator|==
name|NULL
operator|||
name|ptail
operator|==
name|NULL
condition|)
block|{
name|panic
argument_list|(
literal|"agtiapi_QueueCCB: phead %p ptail %p"
argument_list|,
name|phead
argument_list|,
name|ptail
argument_list|)
expr_stmt|;
block|}
name|pccb
operator|->
name|pccbNext
operator|=
name|NULL
expr_stmt|;
name|AG_LOCAL_LOCK
argument_list|(
name|mutex
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|phead
operator|==
name|NULL
condition|)
block|{
comment|//WARN_ON(*ptail != NULL); /* critical, just get more logs */
operator|*
name|phead
operator|=
name|pccb
expr_stmt|;
block|}
else|else
block|{
comment|//WARN_ON(*ptail == NULL); /* critical, just get more logs */
if|if
condition|(
operator|*
name|ptail
condition|)
operator|(
operator|*
name|ptail
operator|)
operator|->
name|pccbNext
operator|=
name|pccb
expr_stmt|;
block|}
operator|*
name|ptail
operator|=
name|pccb
expr_stmt|;
name|AG_LOCAL_UNLOCK
argument_list|(
name|mutex
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/****************************************************************************** agtiapi_QueueCCB()  Purpose:   Parameters:       Return: Note:    ******************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|agtiapi_QueueSMP
parameter_list|(
name|struct
name|agtiapi_softc
modifier|*
name|pmcsc
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|pccb_t
name|pccb
init|=
name|agNULL
decl_stmt|;
comment|/* call dequeue */
name|int
name|status
init|=
name|tiSuccess
decl_stmt|;
name|int
name|targetID
init|=
name|xpt_path_target_id
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
decl_stmt|;
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_QueueSMP: start\n"
argument_list|)
expr_stmt|;
comment|/* get a ccb */
if|if
condition|(
operator|(
name|pccb
operator|=
name|agtiapi_GetCCB
argument_list|(
name|pmcsc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_QueueSMP: GetCCB ERROR\n"
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
name|tiBusy
return|;
block|}
name|pccb
operator|->
name|pmcsc
operator|=
name|pmcsc
expr_stmt|;
comment|/* initialize Command Control Block (CCB) */
name|pccb
operator|->
name|targetId
operator|=
name|targetID
expr_stmt|;
name|pccb
operator|->
name|ccb
operator|=
name|ccb
expr_stmt|;
comment|/* for struct scsi_cmnd */
name|status
operator|=
name|agtiapi_PrepareSMPSGList
argument_list|(
name|pmcsc
argument_list|,
name|pccb
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|tiSuccess
condition|)
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_QueueSMP: agtiapi_PrepareSMPSGList failure\n"
argument_list|)
expr_stmt|;
name|agtiapi_FreeCCB
argument_list|(
name|pmcsc
argument_list|,
name|pccb
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|tiReject
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
block|}
else|else
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
block|}
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
name|tiError
return|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************** agtiapi_SetLunField()  Purpose:   Set LUN field based on different address mode Parameters:   ccb_t *pccb (IN)  A pointer to the driver's own CCB, not CAM's CCB Return: Note: ******************************************************************************/
end_comment

begin_function
name|void
name|agtiapi_SetLunField
parameter_list|(
name|ccb_t
modifier|*
name|pccb
parameter_list|)
block|{
name|U08
modifier|*
name|pchar
decl_stmt|;
name|pchar
operator|=
operator|(
name|U08
operator|*
operator|)
operator|&
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|scsiCmnd
operator|.
name|lun
expr_stmt|;
comment|//  AGTIAPI_PRINTK("agtiapi_SetLunField: start\n");
switch|switch
condition|(
name|pccb
operator|->
name|addrMode
condition|)
block|{
case|case
name|AGTIAPI_PERIPHERAL
case|:
operator|*
name|pchar
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|pchar
operator|=
operator|(
name|U08
operator|)
name|pccb
operator|->
name|lun
expr_stmt|;
break|break;
case|case
name|AGTIAPI_VOLUME_SET
case|:
operator|*
name|pchar
operator|++
operator|=
operator|(
name|AGTIAPI_VOLUME_SET
operator|<<
name|AGTIAPI_ADDRMODE_SHIFT
operator|)
operator||
call|(
name|U08
call|)
argument_list|(
operator|(
name|pccb
operator|->
name|lun
operator|>>
literal|8
operator|)
operator|&
literal|0x3F
argument_list|)
expr_stmt|;
operator|*
name|pchar
operator|=
operator|(
name|U08
operator|)
name|pccb
operator|->
name|lun
expr_stmt|;
break|break;
case|case
name|AGTIAPI_LUN_ADDR
case|:
operator|*
name|pchar
operator|++
operator|=
operator|(
name|AGTIAPI_LUN_ADDR
operator|<<
name|AGTIAPI_ADDRMODE_SHIFT
operator|)
operator||
name|pccb
operator|->
name|targetId
expr_stmt|;
operator|*
name|pchar
operator|=
operator|(
name|U08
operator|)
name|pccb
operator|->
name|lun
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/***************************************************************************** agtiapi_FreeCCB()  Purpose:   Free a ccb and put it back to ccbFreeList. Parameters:   struct agtiapi_softc *pmcsc (IN)  Pointer to HBA data structure   pccb_t pccb (IN)                  A pointer to the driver's own CCB, not                                     CAM's CCB Returns: Note: *****************************************************************************/
end_comment

begin_function
name|STATIC
name|void
name|agtiapi_FreeCCB
parameter_list|(
name|struct
name|agtiapi_softc
modifier|*
name|pmcsc
parameter_list|,
name|pccb_t
name|pccb
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
init|=
name|pccb
operator|->
name|ccb
decl_stmt|;
name|bus_dmasync_op_t
name|op
decl_stmt|;
name|AG_LOCAL_LOCK
argument_list|(
operator|&
name|pmcsc
operator|->
name|ccbLock
argument_list|)
expr_stmt|;
name|AGTIAPI_IO
argument_list|(
literal|"agtiapi_FreeCCB: start %p\n"
argument_list|,
name|pccb
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AGTIAPI_TEST_EPL
name|tiEncrypt_t
modifier|*
name|encrypt
decl_stmt|;
endif|#
directive|endif
name|agtiapi_DumpCDB
argument_list|(
literal|"agtiapi_FreeCCB"
argument_list|,
name|pccb
argument_list|)
expr_stmt|;
if|if
condition|(
name|pccb
operator|->
name|sgList
operator|!=
name|agNULL
condition|)
block|{
name|AGTIAPI_IO
argument_list|(
literal|"agtiapi_FreeCCB: pccb->sgList is NOT null\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_FreeCCB: pccb->sgList is null\n"
argument_list|)
expr_stmt|;
block|}
comment|/* set data transfer direction */
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|==
name|CAM_DIR_OUT
condition|)
block|{
name|op
operator|=
name|BUS_DMASYNC_POSTWRITE
expr_stmt|;
block|}
else|else
block|{
name|op
operator|=
name|BUS_DMASYNC_POSTREAD
expr_stmt|;
block|}
if|if
condition|(
name|pccb
operator|->
name|numSgElements
operator|==
literal|0
condition|)
block|{
comment|// do nothing
name|AGTIAPI_IO
argument_list|(
literal|"agtiapi_FreeCCB: numSgElements zero\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pccb
operator|->
name|numSgElements
operator|==
literal|1
condition|)
block|{
name|AGTIAPI_IO
argument_list|(
literal|"agtiapi_FreeCCB: numSgElements is one\n"
argument_list|)
expr_stmt|;
comment|//op is either BUS_DMASYNC_POSTWRITE or BUS_DMASYNC_POSTREAD
name|bus_dmamap_sync
argument_list|(
name|pmcsc
operator|->
name|buffer_dmat
argument_list|,
name|pccb
operator|->
name|CCB_dmamap
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|pmcsc
operator|->
name|buffer_dmat
argument_list|,
name|pccb
operator|->
name|CCB_dmamap
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_FreeCCB: numSgElements 2 or higher \n"
argument_list|)
expr_stmt|;
comment|//op is either BUS_DMASYNC_POSTWRITE or BUS_DMASYNC_POSTREAD
name|bus_dmamap_sync
argument_list|(
name|pmcsc
operator|->
name|buffer_dmat
argument_list|,
name|pccb
operator|->
name|CCB_dmamap
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|pmcsc
operator|->
name|buffer_dmat
argument_list|,
name|pccb
operator|->
name|CCB_dmamap
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|AGTIAPI_TEST_DPL
if|if
condition|(
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|Dif
operator|.
name|enableDIFPerLA
operator|==
name|TRUE
condition|)
block|{
if|if
condition|(
name|pccb
operator|->
name|dplPtr
condition|)
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pccb
operator|->
name|dplPtr
argument_list|,
literal|0
argument_list|,
name|MAX_DPL_REGIONS
operator|*
sizeof|sizeof
argument_list|(
name|dplaRegion_t
argument_list|)
argument_list|)
expr_stmt|;
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|Dif
operator|.
name|enableDIFPerLA
operator|=
name|FALSE
expr_stmt|;
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|Dif
operator|.
name|DIFPerLAAddrLo
operator|=
literal|0
expr_stmt|;
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|Dif
operator|.
name|DIFPerLAAddrHi
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|AGTIAPI_TEST_EPL
name|encrypt
operator|=
operator|&
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|Encrypt
expr_stmt|;
if|if
condition|(
name|encrypt
operator|->
name|enableEncryptionPerLA
operator|==
name|TRUE
condition|)
block|{
name|encrypt
operator|->
name|enableEncryptionPerLA
operator|=
name|FALSE
expr_stmt|;
name|encrypt
operator|->
name|EncryptionPerLAAddrLo
operator|=
literal|0
expr_stmt|;
name|encrypt
operator|->
name|EncryptionPerLAAddrHi
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ENABLE_SATA_DIF
if|if
condition|(
name|pccb
operator|->
name|holePtr
operator|&&
name|pccb
operator|->
name|dmaHandleHole
condition|)
name|pci_free_consistent
argument_list|(
name|pmcsc
operator|->
name|pCardInfo
operator|->
name|pPCIDev
argument_list|,
literal|512
argument_list|,
name|pccb
operator|->
name|holePtr
argument_list|,
name|pccb
operator|->
name|dmaHandleHole
argument_list|)
expr_stmt|;
name|pccb
operator|->
name|holePtr
operator|=
literal|0
expr_stmt|;
name|pccb
operator|->
name|dmaHandleHole
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|pccb
operator|->
name|dataLen
operator|=
literal|0
expr_stmt|;
name|pccb
operator|->
name|retryCount
operator|=
literal|0
expr_stmt|;
name|pccb
operator|->
name|ccbStatus
operator|=
literal|0
expr_stmt|;
name|pccb
operator|->
name|scsiStatus
operator|=
literal|0
expr_stmt|;
name|pccb
operator|->
name|startTime
operator|=
literal|0
expr_stmt|;
name|pccb
operator|->
name|dmaHandle
operator|=
literal|0
expr_stmt|;
name|pccb
operator|->
name|numSgElements
operator|=
literal|0
expr_stmt|;
name|pccb
operator|->
name|tiIORequest
operator|.
name|tdData
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|pccb
operator|->
name|tiSuperScsiRequest
argument_list|,
literal|0
argument_list|,
name|AGSCSI_INIT_XCHG_LEN
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HIALEAH_ENCRYPTION
if|if
condition|(
name|pmcsc
operator|->
name|encrypt
condition|)
name|agtiapi_CleanupEncryptedIO
argument_list|(
name|pmcsc
argument_list|,
name|pccb
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pccb
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|pccb
operator|->
name|ccb
operator|=
name|NULL
expr_stmt|;
name|pccb
operator|->
name|pccbIO
operator|=
name|NULL
expr_stmt|;
name|pccb
operator|->
name|pccbNext
operator|=
operator|(
name|pccb_t
operator|)
name|pmcsc
operator|->
name|ccbFreeList
expr_stmt|;
name|pmcsc
operator|->
name|ccbFreeList
operator|=
operator|(
name|caddr_t
operator|*
operator|)
name|pccb
expr_stmt|;
name|pmcsc
operator|->
name|activeCCB
operator|--
expr_stmt|;
name|AG_LOCAL_UNLOCK
argument_list|(
operator|&
name|pmcsc
operator|->
name|ccbLock
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/****************************************************************************** agtiapi_FlushCCBs()  Purpose:   Flush all in processed ccbs. Parameters:   ag_card_t *pCard (IN)  Pointer to HBA data structure   U32 flag (IN)            Flag to call back Return: Note: ******************************************************************************/
end_comment

begin_function
name|STATIC
name|void
name|agtiapi_FlushCCBs
parameter_list|(
name|struct
name|agtiapi_softc
modifier|*
name|pCard
parameter_list|,
name|U32
name|flag
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|ccb_t
modifier|*
name|pccb
decl_stmt|;
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_FlushCCBs: enter \n"
argument_list|)
expr_stmt|;
for|for
control|(
name|pccb
operator|=
operator|(
name|pccb_t
operator|)
name|pCard
operator|->
name|ccbChainList
init|;
name|pccb
operator|!=
name|NULL
condition|;
name|pccb
operator|=
name|pccb
operator|->
name|pccbChainNext
control|)
block|{
if|if
condition|(
name|pccb
operator|->
name|flags
operator|==
literal|0
condition|)
block|{
comment|// printf( "agtiapi_FlushCCBs: nothing, continue \n" );
continue|continue;
block|}
name|ccb
operator|=
name|pccb
operator|->
name|ccb
expr_stmt|;
if|if
condition|(
name|pccb
operator|->
name|flags
operator|&
operator|(
name|TASK_MANAGEMENT
operator||
name|DEV_RESET
operator|)
condition|)
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_FlushCCBs: agtiapi_FreeTMCCB \n"
argument_list|)
expr_stmt|;
name|agtiapi_FreeTMCCB
argument_list|(
name|pCard
argument_list|,
name|pccb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|pccb
operator|->
name|flags
operator|&
name|TAG_SMP
condition|)
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_FlushCCBs: agtiapi_FreeSMPCCB \n"
argument_list|)
expr_stmt|;
name|agtiapi_FreeSMPCCB
argument_list|(
name|pCard
argument_list|,
name|pccb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_FlushCCBs: agtiapi_FreeCCB \n"
argument_list|)
expr_stmt|;
name|agtiapi_FreeCCB
argument_list|(
name|pCard
argument_list|,
name|pccb
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ccb
condition|)
block|{
name|CMND_DMA_UNMAP
argument_list|(
name|pCard
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag
operator|==
name|AGTIAPI_CALLBACK
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_SCSI_BUS_RESET
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/***************************************************************************** agtiapi_FreeSMPCCB()  Purpose:   Free a ccb and put it back to ccbFreeList. Parameters:   struct agtiapi_softc *pmcsc (IN)  Pointer to HBA data structure   pccb_t pccb (IN)                  A pointer to the driver's own CCB, not                                     CAM's CCB Returns: Note: *****************************************************************************/
end_comment

begin_function
name|STATIC
name|void
name|agtiapi_FreeSMPCCB
parameter_list|(
name|struct
name|agtiapi_softc
modifier|*
name|pmcsc
parameter_list|,
name|pccb_t
name|pccb
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
init|=
name|pccb
operator|->
name|ccb
decl_stmt|;
name|bus_dmasync_op_t
name|op
decl_stmt|;
name|AG_LOCAL_LOCK
argument_list|(
operator|&
name|pmcsc
operator|->
name|ccbLock
argument_list|)
expr_stmt|;
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_FreeSMPCCB: start %p\n"
argument_list|,
name|pccb
argument_list|)
expr_stmt|;
comment|/* set data transfer direction */
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|==
name|CAM_DIR_OUT
condition|)
block|{
name|op
operator|=
name|BUS_DMASYNC_POSTWRITE
expr_stmt|;
block|}
else|else
block|{
name|op
operator|=
name|BUS_DMASYNC_POSTREAD
expr_stmt|;
block|}
if|if
condition|(
name|pccb
operator|->
name|numSgElements
operator|==
literal|0
condition|)
block|{
comment|// do nothing
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_FreeSMPCCB: numSgElements 0\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pccb
operator|->
name|numSgElements
operator|==
literal|1
condition|)
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_FreeSMPCCB: numSgElements 1\n"
argument_list|)
expr_stmt|;
comment|//op is either BUS_DMASYNC_POSTWRITE or BUS_DMASYNC_POSTREAD
name|bus_dmamap_sync
argument_list|(
name|pmcsc
operator|->
name|buffer_dmat
argument_list|,
name|pccb
operator|->
name|CCB_dmamap
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|pmcsc
operator|->
name|buffer_dmat
argument_list|,
name|pccb
operator|->
name|CCB_dmamap
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_FreeSMPCCB: numSgElements 2 or higher \n"
argument_list|)
expr_stmt|;
comment|//op is either BUS_DMASYNC_POSTWRITE or BUS_DMASYNC_POSTREAD
name|bus_dmamap_sync
argument_list|(
name|pmcsc
operator|->
name|buffer_dmat
argument_list|,
name|pccb
operator|->
name|CCB_dmamap
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|pmcsc
operator|->
name|buffer_dmat
argument_list|,
name|pccb
operator|->
name|CCB_dmamap
argument_list|)
expr_stmt|;
block|}
comment|/*dma api cleanning*/
name|pccb
operator|->
name|dataLen
operator|=
literal|0
expr_stmt|;
name|pccb
operator|->
name|retryCount
operator|=
literal|0
expr_stmt|;
name|pccb
operator|->
name|ccbStatus
operator|=
literal|0
expr_stmt|;
name|pccb
operator|->
name|startTime
operator|=
literal|0
expr_stmt|;
name|pccb
operator|->
name|dmaHandle
operator|=
literal|0
expr_stmt|;
name|pccb
operator|->
name|numSgElements
operator|=
literal|0
expr_stmt|;
name|pccb
operator|->
name|tiIORequest
operator|.
name|tdData
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|pccb
operator|->
name|tiSMPFrame
argument_list|,
literal|0
argument_list|,
name|AGSMP_INIT_XCHG_LEN
argument_list|)
expr_stmt|;
name|pccb
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|pccb
operator|->
name|ccb
operator|=
name|NULL
expr_stmt|;
name|pccb
operator|->
name|pccbNext
operator|=
operator|(
name|pccb_t
operator|)
name|pmcsc
operator|->
name|ccbFreeList
expr_stmt|;
name|pmcsc
operator|->
name|ccbFreeList
operator|=
operator|(
name|caddr_t
operator|*
operator|)
name|pccb
expr_stmt|;
name|pmcsc
operator|->
name|activeCCB
operator|--
expr_stmt|;
name|AG_LOCAL_UNLOCK
argument_list|(
operator|&
name|pmcsc
operator|->
name|ccbLock
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/***************************************************************************** agtiapi_FreeTMCCB()  Purpose:   Free a ccb and put it back to ccbFreeList. Parameters:   struct agtiapi_softc *pmcsc (IN)  Pointer to HBA data structure   pccb_t pccb (IN)                  A pointer to the driver's own CCB, not                                     CAM's CCB Returns: Note: *****************************************************************************/
end_comment

begin_function
name|STATIC
name|void
name|agtiapi_FreeTMCCB
parameter_list|(
name|struct
name|agtiapi_softc
modifier|*
name|pmcsc
parameter_list|,
name|pccb_t
name|pccb
parameter_list|)
block|{
name|AG_LOCAL_LOCK
argument_list|(
operator|&
name|pmcsc
operator|->
name|ccbLock
argument_list|)
expr_stmt|;
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_FreeTMCCB: start %p\n"
argument_list|,
name|pccb
argument_list|)
expr_stmt|;
name|pccb
operator|->
name|dataLen
operator|=
literal|0
expr_stmt|;
name|pccb
operator|->
name|retryCount
operator|=
literal|0
expr_stmt|;
name|pccb
operator|->
name|ccbStatus
operator|=
literal|0
expr_stmt|;
name|pccb
operator|->
name|scsiStatus
operator|=
literal|0
expr_stmt|;
name|pccb
operator|->
name|startTime
operator|=
literal|0
expr_stmt|;
name|pccb
operator|->
name|dmaHandle
operator|=
literal|0
expr_stmt|;
name|pccb
operator|->
name|numSgElements
operator|=
literal|0
expr_stmt|;
name|pccb
operator|->
name|tiIORequest
operator|.
name|tdData
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|pccb
operator|->
name|tiSuperScsiRequest
argument_list|,
literal|0
argument_list|,
name|AGSCSI_INIT_XCHG_LEN
argument_list|)
expr_stmt|;
name|pccb
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|pccb
operator|->
name|ccb
operator|=
name|NULL
expr_stmt|;
name|pccb
operator|->
name|pccbIO
operator|=
name|NULL
expr_stmt|;
name|pccb
operator|->
name|pccbNext
operator|=
operator|(
name|pccb_t
operator|)
name|pmcsc
operator|->
name|ccbFreeList
expr_stmt|;
name|pmcsc
operator|->
name|ccbFreeList
operator|=
operator|(
name|caddr_t
operator|*
operator|)
name|pccb
expr_stmt|;
name|pmcsc
operator|->
name|activeCCB
operator|--
expr_stmt|;
name|AG_LOCAL_UNLOCK
argument_list|(
operator|&
name|pmcsc
operator|->
name|ccbLock
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/****************************************************************************** agtiapi_CheckAllVectors():  Purpose: Parameters: Return: Note:   Currently, not used. ******************************************************************************/
end_comment

begin_function
name|void
name|agtiapi_CheckAllVectors
parameter_list|(
name|struct
name|agtiapi_softc
modifier|*
name|pCard
parameter_list|,
name|bit32
name|context
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|SPC_MSIX_INTR
if|if
condition|(
operator|!
name|agtiapi_intx_mode
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pCard
operator|->
name|pCardInfo
operator|->
name|maxInterruptVectors
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|tiCOMInterruptHandler
argument_list|(
operator|&
name|pCard
operator|->
name|tiRoot
argument_list|,
name|i
argument_list|)
operator|==
name|agTRUE
condition|)
name|tiCOMDelayedInterruptHandler
argument_list|(
operator|&
name|pCard
operator|->
name|tiRoot
argument_list|,
name|i
argument_list|,
literal|100
argument_list|,
name|context
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tiCOMInterruptHandler
argument_list|(
operator|&
name|pCard
operator|->
name|tiRoot
argument_list|,
literal|0
argument_list|)
operator|==
name|agTRUE
condition|)
name|tiCOMDelayedInterruptHandler
argument_list|(
operator|&
name|pCard
operator|->
name|tiRoot
argument_list|,
literal|0
argument_list|,
literal|100
argument_list|,
name|context
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|tiCOMInterruptHandler
argument_list|(
operator|&
name|pCard
operator|->
name|tiRoot
argument_list|,
literal|0
argument_list|)
operator|==
name|agTRUE
condition|)
name|tiCOMDelayedInterruptHandler
argument_list|(
operator|&
name|pCard
operator|->
name|tiRoot
argument_list|,
literal|0
argument_list|,
literal|100
argument_list|,
name|context
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/****************************************************************************** agtiapi_CheckCB()  Purpose:   Check call back function returned event for process completion Parameters:    struct agtiapi_softc *pCard  Pointer to card data structure   U32 milisec (IN)       Waiting time for expected event   U32 flag (IN)          Flag of the event to check   U32 *pStatus (IN)      Pointer to status of the card or port to check Return:   AGTIAPI_SUCCESS - event comes as expected   AGTIAPI_FAIL    - event not coming Note:   Currently, not used     ******************************************************************************/
end_comment

begin_function
name|agBOOLEAN
name|agtiapi_CheckCB
parameter_list|(
name|struct
name|agtiapi_softc
modifier|*
name|pCard
parameter_list|,
name|U32
name|milisec
parameter_list|,
name|U32
name|flag
parameter_list|,
specifier|volatile
name|U32
modifier|*
name|pStatus
parameter_list|)
block|{
name|U32
name|msecsPerTick
init|=
name|pCard
operator|->
name|pCardInfo
operator|->
name|tiRscInfo
operator|.
name|tiInitiatorResource
operator|.
name|initiatorOption
operator|.
name|usecsPerTick
operator|/
literal|1000
decl_stmt|;
name|S32
name|i
init|=
name|milisec
operator|/
name|msecsPerTick
decl_stmt|;
name|AG_GLOBAL_ARG
argument_list|(
name|_flags
argument_list|)
expr_stmt|;
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_CheckCB: start\n"
argument_list|)
expr_stmt|;
name|AGTIAPI_FLOW
argument_list|(
literal|"agtiapi_CheckCB: start\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
name|i
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|i
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|pStatus
operator|&
name|TASK_MANAGEMENT
condition|)
block|{
if|if
condition|(
operator|*
name|pStatus
operator|&
name|AGTIAPI_CB_DONE
condition|)
block|{
if|if
condition|(
name|flag
operator|==
literal|0
operator|||
operator|*
name|pStatus
operator|&
name|flag
condition|)
return|return
name|AGTIAPI_SUCCESS
return|;
else|else
return|return
name|AGTIAPI_FAIL
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|pCard
operator|->
name|flags
operator|&
name|AGTIAPI_CB_DONE
condition|)
block|{
if|if
condition|(
name|flag
operator|==
literal|0
operator|||
operator|*
name|pStatus
operator|&
name|flag
condition|)
return|return
name|AGTIAPI_SUCCESS
return|;
else|else
return|return
name|AGTIAPI_FAIL
return|;
block|}
name|agtiapi_DelayMSec
argument_list|(
name|msecsPerTick
argument_list|)
expr_stmt|;
name|AG_SPIN_LOCK_IRQ
argument_list|(
name|agtiapi_host_lock
argument_list|,
name|_flags
argument_list|)
expr_stmt|;
name|tiCOMTimerTick
argument_list|(
operator|&
name|pCard
operator|->
name|tiRoot
argument_list|)
expr_stmt|;
name|agtiapi_CheckAllVectors
argument_list|(
name|pCard
argument_list|,
name|tiNonInterruptContext
argument_list|)
expr_stmt|;
name|AG_SPIN_UNLOCK_IRQ
argument_list|(
name|agtiapi_host_lock
argument_list|,
name|_flags
argument_list|)
expr_stmt|;
name|i
operator|--
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|pStatus
operator|&
name|TASK_MANAGEMENT
condition|)
operator|*
name|pStatus
operator||=
name|TASK_TIMEOUT
expr_stmt|;
return|return
name|AGTIAPI_FAIL
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************** agtiapi_DiscoverTgt()  Purpose:   Discover available devices Parameters:   struct agtiapi_softc *pCard (IN)  Pointer to the HBA data structure Return: Note: ******************************************************************************/
end_comment

begin_function
name|STATIC
name|void
name|agtiapi_DiscoverTgt
parameter_list|(
name|struct
name|agtiapi_softc
modifier|*
name|pCard
parameter_list|)
block|{
name|ag_portal_data_t
modifier|*
name|pPortalData
decl_stmt|;
name|U32
name|count
decl_stmt|;
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_DiscoverTgt: start\n"
argument_list|)
expr_stmt|;
name|AGTIAPI_FLOW
argument_list|(
literal|"agtiapi_DiscoverTgt\n"
argument_list|)
expr_stmt|;
name|AGTIAPI_INIT
argument_list|(
literal|"agtiapi_DiscoverTgt\n"
argument_list|)
expr_stmt|;
name|pPortalData
operator|=
name|pCard
operator|->
name|pPortalData
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|pCard
operator|->
name|portCount
condition|;
name|count
operator|++
operator|,
name|pPortalData
operator|++
control|)
block|{
name|pCard
operator|->
name|flags
operator|&=
operator|~
name|AGTIAPI_CB_DONE
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|PORTAL_STATUS
argument_list|(
name|pPortalData
argument_list|)
operator|&
name|AGTIAPI_PORT_DISC_READY
operator|)
condition|)
block|{
if|if
condition|(
name|pCard
operator|->
name|flags
operator|&
name|AGTIAPI_INIT_TIME
condition|)
block|{
if|if
condition|(
name|agtiapi_CheckCB
argument_list|(
name|pCard
argument_list|,
literal|5000
argument_list|,
name|AGTIAPI_PORT_DISC_READY
argument_list|,
operator|&
name|PORTAL_STATUS
argument_list|(
name|pPortalData
argument_list|)
argument_list|)
operator|==
name|AGTIAPI_FAIL
condition|)
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_DiscoverTgt: Port %p / %d not ready for "
literal|"discovery\n"
argument_list|,
name|pPortalData
argument_list|,
name|count
argument_list|)
expr_stmt|;
comment|/*             * There is no need to spend time on discovering device             * if port is not ready to do so.            */
continue|continue;
block|}
block|}
else|else
continue|continue;
block|}
name|AGTIAPI_FLOW
argument_list|(
literal|"agtiapi_DiscoverTgt: Portal %p DiscoverTargets starts\n"
argument_list|,
name|pPortalData
argument_list|)
expr_stmt|;
name|AGTIAPI_INIT_DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|pCard
operator|->
name|flags
operator|&=
operator|~
name|AGTIAPI_CB_DONE
expr_stmt|;
if|if
condition|(
name|tiINIDiscoverTargets
argument_list|(
operator|&
name|pCard
operator|->
name|tiRoot
argument_list|,
operator|&
name|pPortalData
operator|->
name|portalInfo
operator|.
name|tiPortalContext
argument_list|,
name|FORCE_PERSISTENT_ASSIGN_MASK
argument_list|)
operator|!=
name|tiSuccess
condition|)
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_DiscoverTgt: tiINIDiscoverTargets ERROR\n"
argument_list|)
expr_stmt|;
comment|/*      * Should wait till discovery completion to start      * next portal. However, lower layer have issue on       * multi-portal case under Linux.      */
block|}
name|pPortalData
operator|=
name|pCard
operator|->
name|pPortalData
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|pCard
operator|->
name|portCount
condition|;
name|count
operator|++
operator|,
name|pPortalData
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|PORTAL_STATUS
argument_list|(
name|pPortalData
argument_list|)
operator|&
name|AGTIAPI_PORT_DISC_READY
operator|)
condition|)
block|{
if|if
condition|(
name|agtiapi_CheckCB
argument_list|(
name|pCard
argument_list|,
literal|20000
argument_list|,
name|AGTIAPI_DISC_COMPLETE
argument_list|,
operator|&
name|PORTAL_STATUS
argument_list|(
name|pPortalData
argument_list|)
argument_list|)
operator|==
name|AGTIAPI_FAIL
condition|)
block|{
if|if
condition|(
operator|(
name|PORTAL_STATUS
argument_list|(
name|pPortalData
argument_list|)
operator|&
name|AGTIAPI_DISC_COMPLETE
operator|)
condition|)
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_DiscoverTgt: Portal %p discover complete, "
literal|"status 0x%x\n"
argument_list|,
name|pPortalData
argument_list|,
name|PORTAL_STATUS
argument_list|(
name|pPortalData
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_DiscoverTgt: Portal %p discover is not "
literal|"completed, status 0x%x\n"
argument_list|,
name|pPortalData
argument_list|,
name|PORTAL_STATUS
argument_list|(
name|pPortalData
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_DiscoverTgt: Portal %d discover target "
literal|"success\n"
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*     * Calling to get device handle should be done per portal based     * and better right after discovery is done. However, lower iscsi    * layer may not returns discovery complete in correct sequence or we    * ran out time. We get device handle for all portals together    * after discovery is done or timed out.    */
name|pPortalData
operator|=
name|pCard
operator|->
name|pPortalData
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|pCard
operator|->
name|portCount
condition|;
name|count
operator|++
operator|,
name|pPortalData
operator|++
control|)
block|{
comment|/*       * We try to get device handle no matter       * if discovery is completed or not.       */
if|if
condition|(
name|PORTAL_STATUS
argument_list|(
name|pPortalData
argument_list|)
operator|&
name|AGTIAPI_PORT_DISC_READY
condition|)
block|{
name|U32
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AGTIAPI_GET_DEV_MAX
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|agtiapi_GetDevHandle
argument_list|(
name|pCard
argument_list|,
operator|&
name|pPortalData
operator|->
name|portalInfo
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
break|break;
name|agtiapi_DelayMSec
argument_list|(
name|AGTIAPI_EXTRA_DELAY
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|PORTAL_STATUS
argument_list|(
name|pPortalData
argument_list|)
operator|&
name|AGTIAPI_DISC_COMPLETE
operator|)
operator|||
operator|(
name|pCard
operator|->
name|tgtCount
operator|>
literal|0
operator|)
condition|)
name|PORTAL_STATUS
argument_list|(
name|pPortalData
argument_list|)
operator||=
operator|(
name|AGTIAPI_DISC_DONE
operator||
name|AGTIAPI_PORT_LINK_UP
operator|)
expr_stmt|;
block|}
block|}
return|return;
block|}
end_function

begin_comment
comment|/****************************************************************************** agtiapi_PrepCCBs()  Purpose:   Prepares CCB including DMA map. Parameters:    struct agtiapi_softc *pCard (IN)  Pointer to the HBA data structure   ccb_hdr_t *hdr (IN)               Pointer to the CCB header   U32 size (IN)                     size   U32 max_ccb (IN)                  count    Return: Note:     ******************************************************************************/
end_comment

begin_function
name|STATIC
name|void
name|agtiapi_PrepCCBs
parameter_list|(
name|struct
name|agtiapi_softc
modifier|*
name|pCard
parameter_list|,
name|ccb_hdr_t
modifier|*
name|hdr
parameter_list|,
name|U32
name|size
parameter_list|,
name|U32
name|max_ccb
parameter_list|,
name|int
name|tid
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|U32
name|hdr_sz
decl_stmt|,
name|ccb_sz
decl_stmt|;
name|ccb_t
modifier|*
name|pccb
init|=
name|NULL
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
name|int
name|nsegs
init|=
literal|0
decl_stmt|;
name|int
name|sgl_sz
init|=
literal|0
decl_stmt|;
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_PrepCCBs: start\n"
argument_list|)
expr_stmt|;
name|offset
operator|=
name|tid
operator|*
name|AGTIAPI_CCB_PER_DEVICE
expr_stmt|;
name|nsegs
operator|=
name|AGTIAPI_NSEGS
expr_stmt|;
name|sgl_sz
operator|=
sizeof|sizeof
argument_list|(
name|tiSgl_t
argument_list|)
operator|*
name|nsegs
expr_stmt|;
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_PrepCCBs: tid %d offset %d nsegs %d sizeof(tiSgl_t) "
literal|"%lu, max_ccb %d\n"
argument_list|,
name|tid
argument_list|,
name|offset
argument_list|,
name|nsegs
argument_list|,
sizeof|sizeof
argument_list|(
name|tiSgl_t
argument_list|)
argument_list|,
name|max_ccb
argument_list|)
expr_stmt|;
name|ccb_sz
operator|=
name|roundup2
argument_list|(
name|AGTIAPI_CCB_SIZE
argument_list|,
name|cache_line_size
argument_list|()
argument_list|)
expr_stmt|;
name|hdr_sz
operator|=
name|roundup2
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
argument_list|,
name|cache_line_size
argument_list|()
argument_list|)
expr_stmt|;
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_PrepCCBs: after cache line\n"
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|void
operator|*
operator|)
name|hdr
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|next
operator|=
name|pCard
operator|->
name|ccbAllocList
expr_stmt|;
name|pCard
operator|->
name|ccbAllocList
operator|=
name|hdr
expr_stmt|;
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_PrepCCBs: after memset\n"
argument_list|)
expr_stmt|;
name|pccb
operator|=
operator|(
name|ccb_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|hdr
operator|+
name|hdr_sz
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_ccb
condition|;
name|i
operator|++
operator|,
name|pccb
operator|=
operator|(
name|ccb_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|pccb
operator|+
name|ccb_sz
operator|)
control|)
block|{
name|pccb
operator|->
name|tiIORequest
operator|.
name|osData
operator|=
operator|(
name|void
operator|*
operator|)
name|pccb
expr_stmt|;
comment|/*      * Initially put all the ccbs on the free list      * in addition to chainlist.      * ccbChainList is a list of all available ccbs      * (free/active everything)      */
name|pccb
operator|->
name|pccbChainNext
operator|=
operator|(
name|pccb_t
operator|)
name|pCard
operator|->
name|ccbChainList
expr_stmt|;
name|pccb
operator|->
name|pccbNext
operator|=
operator|(
name|pccb_t
operator|)
name|pCard
operator|->
name|ccbFreeList
expr_stmt|;
name|pCard
operator|->
name|ccbChainList
operator|=
operator|(
name|caddr_t
operator|*
operator|)
name|pccb
expr_stmt|;
name|pCard
operator|->
name|ccbFreeList
operator|=
operator|(
name|caddr_t
operator|*
operator|)
name|pccb
expr_stmt|;
name|pCard
operator|->
name|ccbTotal
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|AGTIAPI_ALIGN_CHECK
if|if
condition|(
operator|&
name|pccb
operator|&
literal|0x63
condition|)
name|AGTIAPI_PRINTK
argument_list|(
literal|"pccb = %p\n"
argument_list|,
name|pccb
argument_list|)
expr_stmt|;
if|if
condition|(
name|pccb
operator|->
name|devHandle
operator|&
literal|0x63
condition|)
name|AGTIAPI_PRINTK
argument_list|(
literal|"devHandle addr = %p\n"
argument_list|,
operator|&
name|pccb
operator|->
name|devHandle
argument_list|)
expr_stmt|;
if|if
condition|(
operator|&
name|pccb
operator|->
name|lun
operator|&
literal|0x63
condition|)
name|AGTIAPI_PRINTK
argument_list|(
literal|"lun addr = %p\n"
argument_list|,
operator|&
name|pccb
operator|->
name|lun
argument_list|)
expr_stmt|;
if|if
condition|(
operator|&
name|pccb
operator|->
name|targetId
operator|&
literal|0x63
condition|)
name|AGTIAPI_PRINTK
argument_list|(
literal|"tig addr = %p\n"
argument_list|,
operator|&
name|pccb
operator|->
name|targetId
argument_list|)
expr_stmt|;
if|if
condition|(
operator|&
name|pccb
operator|->
name|ccbStatus
operator|&
literal|0x63
condition|)
name|AGTIAPI_PRINTK
argument_list|(
literal|"ccbStatus addr = %p\n"
argument_list|,
operator|&
name|pccb
operator|->
name|ccbStatus
argument_list|)
expr_stmt|;
if|if
condition|(
operator|&
name|pccb
operator|->
name|scsiStatus
operator|&
literal|0x63
condition|)
name|AGTIAPI_PRINTK
argument_list|(
literal|"scsiStatus addr = %p\n"
argument_list|,
operator|&
name|pccb
operator|->
name|scsiStatus
argument_list|)
expr_stmt|;
if|if
condition|(
operator|&
name|pccb
operator|->
name|dataLen
operator|&
literal|0x63
condition|)
name|AGTIAPI_PRINTK
argument_list|(
literal|"dataLen addr = %p\n"
argument_list|,
operator|&
name|pccb
operator|->
name|dataLen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|&
name|pccb
operator|->
name|senseLen
operator|&
literal|0x63
condition|)
name|AGTIAPI_PRINTK
argument_list|(
literal|"senseLen addr = %p\n"
argument_list|,
operator|&
name|pccb
operator|->
name|senseLen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|&
name|pccb
operator|->
name|numSgElements
operator|&
literal|0x63
condition|)
name|AGTIAPI_PRINTK
argument_list|(
literal|"numSgElements addr = %p\n"
argument_list|,
operator|&
name|pccb
operator|->
name|numSgElements
argument_list|)
expr_stmt|;
if|if
condition|(
operator|&
name|pccb
operator|->
name|retryCount
operator|&
literal|0x63
condition|)
name|AGTIAPI_PRINTK
argument_list|(
literal|"retry cnt addr = %p\n"
argument_list|,
operator|&
name|pccb
operator|->
name|retryCount
argument_list|)
expr_stmt|;
if|if
condition|(
operator|&
name|pccb
operator|->
name|flags
operator|&
literal|0x63
condition|)
name|AGTIAPI_PRINTK
argument_list|(
literal|"flag addr = %p\n"
argument_list|,
operator|&
name|pccb
operator|->
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|&
name|pccb
operator|->
name|pSenseData
operator|&
literal|0x63
condition|)
name|AGTIAPI_PRINTK
argument_list|(
literal|"senseData addr = %p\n"
argument_list|,
operator|&
name|pccb
operator|->
name|pSenseData
argument_list|)
expr_stmt|;
if|if
condition|(
operator|&
name|pccb
operator|->
name|sgList
index|[
literal|0
index|]
operator|&
literal|0x63
condition|)
name|AGTIAPI_PRINTK
argument_list|(
literal|"SgList 0 = %p\n"
argument_list|,
operator|&
name|pccb
operator|->
name|sgList
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|&
name|pccb
operator|->
name|pccbNext
operator|&
literal|0x63
condition|)
name|AGTIAPI_PRINTK
argument_list|(
literal|"ccb next = %p\n"
argument_list|,
operator|&
name|pccb
operator|->
name|pccbNext
argument_list|)
expr_stmt|;
if|if
condition|(
operator|&
name|pccb
operator|->
name|pccbChainNext
operator|&
literal|0x63
condition|)
name|AGTIAPI_PRINTK
argument_list|(
literal|"ccbChainNext = %p\n"
argument_list|,
operator|&
name|pccb
operator|->
name|pccbChainNext
argument_list|)
expr_stmt|;
if|if
condition|(
operator|&
name|pccb
operator|->
name|cmd
operator|&
literal|0x63
condition|)
name|AGTIAPI_PRINTK
argument_list|(
literal|"command = %p\n"
argument_list|,
operator|&
name|pccb
operator|->
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|&
name|pccb
operator|->
name|startTime
operator|&
literal|0x63
condition|)
name|AGTIAPI_PRINTK
argument_list|(
literal|"startTime = %p\n"
argument_list|,
operator|&
name|pccb
operator|->
name|startTime
argument_list|)
expr_stmt|;
if|if
condition|(
operator|&
name|pccb
operator|->
name|tiIORequest
operator|&
literal|0x63
condition|)
name|AGTIAPI_PRINTK
argument_list|(
literal|"tiIOReq addr = %p\n"
argument_list|,
operator|&
name|pccb
operator|->
name|tiIORequest
argument_list|)
expr_stmt|;
if|if
condition|(
operator|&
name|pccb
operator|->
name|tdIOReqBody
operator|&
literal|0x63
condition|)
name|AGTIAPI_PRINTK
argument_list|(
literal|"tdIORequestBody addr = %p\n"
argument_list|,
operator|&
name|pccb
operator|->
name|tdIOReqBody
argument_list|)
expr_stmt|;
if|if
condition|(
operator|&
name|pccb
operator|->
name|tiSuperScsiRequest
operator|&
literal|0x63
condition|)
name|AGTIAPI_PRINTK
argument_list|(
literal|"InitiatorExchange addr = %p\n"
argument_list|,
operator|&
name|pccb
operator|->
name|tiSuperScsiRequest
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|bus_dmamap_create
argument_list|(
name|pCard
operator|->
name|buffer_dmat
argument_list|,
literal|0
argument_list|,
operator|&
name|pccb
operator|->
name|CCB_dmamap
argument_list|)
operator|!=
name|tiSuccess
condition|)
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_PrepCCBs: can't create dma\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* assigns tiSgl_t memory to pccb */
name|pccb
operator|->
name|sgList
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|U64
operator|)
name|pCard
operator|->
name|tisgl_mem
operator|+
operator|(
operator|(
name|i
operator|+
name|offset
operator|)
operator|*
name|sgl_sz
operator|)
operator|)
expr_stmt|;
name|pccb
operator|->
name|tisgl_busaddr
operator|=
name|pCard
operator|->
name|tisgl_busaddr
operator|+
operator|(
operator|(
name|i
operator|+
name|offset
operator|)
operator|*
name|sgl_sz
operator|)
expr_stmt|;
name|pccb
operator|->
name|ccb
operator|=
name|NULL
expr_stmt|;
name|pccb
operator|->
name|pccbIO
operator|=
name|NULL
expr_stmt|;
name|pccb
operator|->
name|startTime
operator|=
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|AGTIAPI_ALIGN_CHECK
name|AGTIAPI_PRINTK
argument_list|(
literal|"ccb size = %d / %d\n"
argument_list|,
sizeof|sizeof
argument_list|(
name|ccb_t
argument_list|)
argument_list|,
name|ccb_sz
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
end_function

begin_comment
comment|/****************************************************************************** agtiapi_InitCCBs()  Purpose:   Create and initialize per card based CCB pool. Parameters:    struct agtiapi_softc *pCard (IN)  Pointer to the HBA data structure   int tgtCount (IN)                 Count Return:   Total number of ccb allocated Note:     ******************************************************************************/
end_comment

begin_function
name|STATIC
name|U32
name|agtiapi_InitCCBs
parameter_list|(
name|struct
name|agtiapi_softc
modifier|*
name|pCard
parameter_list|,
name|int
name|tgtCount
parameter_list|,
name|int
name|tid
parameter_list|)
block|{
name|U32
name|max_ccb
decl_stmt|,
name|size
decl_stmt|,
name|ccb_sz
decl_stmt|,
name|hdr_sz
decl_stmt|;
name|int
name|no_allocs
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|;
name|ccb_hdr_t
modifier|*
name|hdr
init|=
name|NULL
decl_stmt|;
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_InitCCBs: start\n"
argument_list|)
expr_stmt|;
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_InitCCBs: tgtCount %d tid %d\n"
argument_list|,
name|tgtCount
argument_list|,
name|tid
argument_list|)
expr_stmt|;
name|AGTIAPI_FLOW
argument_list|(
literal|"agtiapi_InitCCBs: tgtCount %d tid %d\n"
argument_list|,
name|tgtCount
argument_list|,
name|tid
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|HOTPLUG_SUPPORT
if|if
condition|(
name|pCard
operator|->
name|tgtCount
operator|>
name|AGSA_MAX_INBOUND_Q
condition|)
return|return
literal|1
return|;
else|#
directive|else
if|if
condition|(
name|tgtCount
operator|>
name|AGSA_MAX_INBOUND_Q
condition|)
name|tgtCount
operator|=
name|AGSA_MAX_INBOUND_Q
expr_stmt|;
endif|#
directive|endif
name|max_ccb
operator|=
name|tgtCount
operator|*
name|AGTIAPI_CCB_PER_DEVICE
expr_stmt|;
comment|//      / 4; // TBR
name|ccb_sz
operator|=
name|roundup2
argument_list|(
name|AGTIAPI_CCB_SIZE
argument_list|,
name|cache_line_size
argument_list|()
argument_list|)
expr_stmt|;
name|hdr_sz
operator|=
name|roundup2
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
argument_list|,
name|cache_line_size
argument_list|()
argument_list|)
expr_stmt|;
name|size
operator|=
name|ccb_sz
operator|*
name|max_ccb
operator|+
name|hdr_sz
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
literal|1
operator|<<
name|no_allocs
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|hdr
operator|=
operator|(
name|ccb_hdr_t
operator|*
operator|)
name|malloc
argument_list|(
name|size
argument_list|,
name|M_PMC_MCCB
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hdr
condition|)
block|{
name|panic
argument_list|(
literal|"agtiapi_InitCCBs: bug!!!\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|agtiapi_PrepCCBs
argument_list|(
name|pCard
argument_list|,
name|hdr
argument_list|,
name|size
argument_list|,
name|max_ccb
argument_list|,
name|tid
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|LINUX_PERBI_SUPPORT
end_ifdef

begin_comment
comment|/****************************************************************************** agtiapi_GetWWNMappings()  Purpose:   Get the mappings from target IDs to WWNs, if any.   Store them in the WWN_list array, indexed by target ID.   Leave the devListIndex field blank; this will be filled-in later. Parameters:   ag_card_t *pCard (IN)        Pointer to HBA data structure   ag_mapping_t *pMapList (IN)  Pointer to mapped device list Return: Note:  The boot command line parameters are used to load the   mapping information, which is contained in the system   configuration file. ******************************************************************************/
end_comment

begin_function
name|STATIC
name|void
name|agtiapi_GetWWNMappings
parameter_list|(
name|struct
name|agtiapi_softc
modifier|*
name|pCard
parameter_list|,
name|ag_mapping_t
modifier|*
name|pMapList
parameter_list|)
block|{
name|int
name|devDisc
decl_stmt|;
name|int
name|lIdx
init|=
literal|0
decl_stmt|;
name|ag_tgt_map_t
modifier|*
name|pWWNList
decl_stmt|;
name|ag_slr_map_t
modifier|*
name|pSLRList
decl_stmt|;
name|ag_device_t
modifier|*
name|pDevList
decl_stmt|;
if|if
condition|(
operator|!
name|pCard
condition|)
name|panic
argument_list|(
literal|"agtiapi_GetWWNMappings: no pCard \n"
argument_list|)
expr_stmt|;
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_GetWWNMappings: start\n"
argument_list|)
expr_stmt|;
name|pWWNList
operator|=
name|pCard
operator|->
name|pWWNList
expr_stmt|;
name|pSLRList
operator|=
name|pCard
operator|->
name|pSLRList
expr_stmt|;
name|pDevList
operator|=
name|pCard
operator|->
name|pDevList
expr_stmt|;
name|pCard
operator|->
name|numTgtHardMapped
operator|=
literal|0
expr_stmt|;
name|devDisc
operator|=
name|pCard
operator|->
name|devDiscover
expr_stmt|;
name|pWWNList
index|[
name|devDisc
operator|-
literal|1
index|]
operator|.
name|devListIndex
operator|=
name|maxTargets
expr_stmt|;
name|pSLRList
index|[
name|devDisc
operator|-
literal|1
index|]
operator|.
name|localeNameLen
operator|=
operator|-
literal|2
expr_stmt|;
name|pSLRList
index|[
name|devDisc
operator|-
literal|1
index|]
operator|.
name|remoteNameLen
operator|=
operator|-
literal|2
expr_stmt|;
name|pDevList
index|[
name|devDisc
operator|-
literal|1
index|]
operator|.
name|targetId
operator|=
name|maxTargets
expr_stmt|;
comment|/*    * Get the mappings from holding area which contains    * the input of the system file and store them    * in the WWN_list array, indexed by target ID.    */
for|for
control|(
name|lIdx
operator|=
literal|0
init|;
name|lIdx
operator|<
name|devDisc
operator|-
literal|1
condition|;
name|lIdx
operator|++
control|)
block|{
name|pWWNList
index|[
name|lIdx
index|]
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|pWWNList
index|[
name|lIdx
index|]
operator|.
name|devListIndex
operator|=
name|maxTargets
expr_stmt|;
name|pSLRList
index|[
name|lIdx
index|]
operator|.
name|localeNameLen
operator|=
operator|-
literal|1
expr_stmt|;
name|pSLRList
index|[
name|lIdx
index|]
operator|.
name|remoteNameLen
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|//  this is where we would propagate values fed to pMapList
block|}
end_function

begin_comment
comment|/* agtiapi_GetWWNMappings */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/****************************************************************************** agtiapi_FindWWNListNext() Purpose:   finds first available new (unused) wwn list entry  Parameters:   ag_tgt_map_t *pWWNList              Pointer to head of wwn list   int lstMax                          Number of entries in WWNList Return:   index into WWNList indicating available entry space;   if available entry space is not found, return negative value ******************************************************************************/
end_comment

begin_function
name|STATIC
name|int
name|agtiapi_FindWWNListNext
parameter_list|(
name|ag_tgt_map_t
modifier|*
name|pWWNList
parameter_list|,
name|int
name|lstMax
parameter_list|)
block|{
name|int
name|lLstIdx
decl_stmt|;
for|for
control|(
name|lLstIdx
operator|=
literal|0
init|;
name|lLstIdx
operator|<
name|lstMax
condition|;
name|lLstIdx
operator|++
control|)
block|{
if|if
condition|(
name|pWWNList
index|[
name|lLstIdx
index|]
operator|.
name|devListIndex
operator|==
name|lstMax
operator|&&
name|pWWNList
index|[
name|lLstIdx
index|]
operator|.
name|targetLen
operator|==
literal|0
condition|)
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_FindWWNListNext: %d %d %d %d v. %d\n"
argument_list|,
name|lLstIdx
argument_list|,
name|pWWNList
index|[
name|lLstIdx
index|]
operator|.
name|devListIndex
argument_list|,
name|pWWNList
index|[
name|lLstIdx
index|]
operator|.
name|targetLen
argument_list|,
name|pWWNList
index|[
name|lLstIdx
index|]
operator|.
name|portId
argument_list|,
name|lstMax
argument_list|)
expr_stmt|;
return|return
name|lLstIdx
return|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************** agtiapi_GetDevHandle()  Purpose:   Get device handle.  Handles will be placed in the   devlist array with same order as TargetList provided and   will be mapped to a scsi target id and registered to OS later. Parameters:   struct agtiapi_softc *pCard (IN)    Pointer to the HBA data structure   ag_portal_info_t *pPortalInfo (IN)  Pointer to the portal data structure   U32 eType (IN)                      Port event   U32 eStatus (IN)                    Port event status Return:   Number of device handle slot present Note:   The sequence of device handle will match the sequence of taregt list ******************************************************************************/
end_comment

begin_function
name|STATIC
name|U32
name|agtiapi_GetDevHandle
parameter_list|(
name|struct
name|agtiapi_softc
modifier|*
name|pCard
parameter_list|,
name|ag_portal_info_t
modifier|*
name|pPortalInfo
parameter_list|,
name|U32
name|eType
parameter_list|,
name|U32
name|eStatus
parameter_list|)
block|{
name|ag_device_t
modifier|*
name|pDevice
decl_stmt|;
comment|// tiDeviceHandle_t *agDev[pCard->devDiscover];
name|tiDeviceHandle_t
modifier|*
modifier|*
name|agDev
decl_stmt|;
name|int
name|devIdx
decl_stmt|,
name|szdv
decl_stmt|,
name|devTotal
decl_stmt|,
name|cmpsetRtn
decl_stmt|;
name|int
name|lDevIndex
init|=
literal|0
decl_stmt|,
name|lRunScanFlag
init|=
name|FALSE
decl_stmt|;
name|int
modifier|*
name|lDevFlags
decl_stmt|;
name|tiPortInfo_t
name|portInfT
decl_stmt|;
name|ag_device_t
name|lTmpDevice
decl_stmt|;
name|ag_tgt_map_t
modifier|*
name|pWWNList
decl_stmt|;
name|ag_slr_map_t
modifier|*
name|pSLRList
decl_stmt|;
name|bit32
name|lReadRm
decl_stmt|;
name|bit16
name|lReadCt
decl_stmt|;
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_GetDevHandle: start\n"
argument_list|)
expr_stmt|;
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_GetDevHandle: pCard->devDiscover %d / tgtCt %d\n"
argument_list|,
name|pCard
operator|->
name|devDiscover
argument_list|,
name|pCard
operator|->
name|tgtCount
argument_list|)
expr_stmt|;
name|AGTIAPI_FLOW
argument_list|(
literal|"agtiapi_GetDevHandle: portalInfo %p\n"
argument_list|,
name|pPortalInfo
argument_list|)
expr_stmt|;
name|AGTIAPI_INIT_DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|agDev
operator|=
operator|(
name|tiDeviceHandle_t
operator|*
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|tiDeviceHandle_t
operator|*
argument_list|)
operator|*
name|pCard
operator|->
name|devDiscover
argument_list|,
name|M_PMC_MDEV
argument_list|,
name|M_ZERO
operator||
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|agDev
operator|==
name|NULL
condition|)
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_GetDevHandle: failed to alloc agDev[]\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|lDevFlags
operator|=
operator|(
name|int
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|pCard
operator|->
name|devDiscover
argument_list|,
name|M_PMC_MFLG
argument_list|,
name|M_ZERO
operator||
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|lDevFlags
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|agDev
argument_list|,
name|M_PMC_MDEV
argument_list|)
expr_stmt|;
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_GetDevHandle: failed to alloc lDevFlags[]\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|pWWNList
operator|=
name|pCard
operator|->
name|pWWNList
expr_stmt|;
name|pSLRList
operator|=
name|pCard
operator|->
name|pSLRList
expr_stmt|;
name|memset
argument_list|(
operator|(
name|void
operator|*
operator|)
name|agDev
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
operator|*
name|pCard
operator|->
name|devDiscover
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|lDevFlags
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|pCard
operator|->
name|devDiscover
argument_list|)
expr_stmt|;
comment|// get device handles
name|devTotal
operator|=
name|tiINIGetDeviceHandles
argument_list|(
operator|&
name|pCard
operator|->
name|tiRoot
argument_list|,
operator|&
name|pPortalInfo
operator|->
name|tiPortalContext
argument_list|,
operator|(
name|tiDeviceHandle_t
operator|*
operator|*
operator|)
name|agDev
argument_list|,
name|pCard
operator|->
name|devDiscover
argument_list|)
expr_stmt|;
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_GetDevHandle: portalInfo %p port id %d event %u "
literal|"status %u card %p pCard->devDiscover %d devTotal %d "
literal|"pPortalInfo->devTotal %d pPortalInfo->devPrev %d "
literal|"AGTIAPI_INIT_TIME %x\n"
argument_list|,
name|pPortalInfo
argument_list|,
name|pPortalInfo
operator|->
name|portID
argument_list|,
name|eType
argument_list|,
name|eStatus
argument_list|,
name|pCard
argument_list|,
name|pCard
operator|->
name|devDiscover
argument_list|,
name|devTotal
argument_list|,
name|pPortalInfo
operator|->
name|devTotal
argument_list|,
name|pPortalInfo
operator|->
name|devPrev
argument_list|,
name|pCard
operator|->
name|flags
operator|&
name|AGTIAPI_INIT_TIME
argument_list|)
expr_stmt|;
comment|// reset devTotal from any previous runs of this
name|pPortalInfo
operator|->
name|devPrev
operator|=
name|devTotal
expr_stmt|;
name|pPortalInfo
operator|->
name|devTotal
operator|=
name|devTotal
expr_stmt|;
name|AG_LIST_LOCK
argument_list|(
operator|&
name|pCard
operator|->
name|devListLock
argument_list|)
expr_stmt|;
if|if
condition|(
name|tiCOMGetPortInfo
argument_list|(
operator|&
name|pCard
operator|->
name|tiRoot
argument_list|,
operator|&
name|pPortalInfo
operator|->
name|tiPortalContext
argument_list|,
operator|&
name|portInfT
argument_list|)
operator|!=
name|tiSuccess
condition|)
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_GetDevHandle: tiCOMGetPortInfo did not succeed. \n"
argument_list|)
expr_stmt|;
block|}
name|szdv
operator|=
sizeof|sizeof
argument_list|(
name|pPortalInfo
operator|->
name|pDevList
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|pPortalInfo
operator|->
name|pDevList
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|szdv
operator|>
name|pCard
operator|->
name|devDiscover
condition|)
block|{
name|szdv
operator|=
name|pCard
operator|->
name|devDiscover
expr_stmt|;
block|}
comment|// reconstructing dev list via comparison of wwn
for|for
control|(
name|devIdx
operator|=
literal|0
init|;
name|devIdx
operator|<
name|pCard
operator|->
name|devDiscover
condition|;
name|devIdx
operator|++
control|)
block|{
if|if
condition|(
name|agDev
index|[
name|devIdx
index|]
operator|!=
name|NULL
condition|)
block|{
comment|// AGTIAPI_PRINTK( "agtiapi_GetDevHandle: agDev %d not NULL %p\n",
comment|//                 devIdx, agDev[devIdx] );
comment|// pack temp device structure for tiINIGetDeviceInfo call
name|pDevice
operator|=
operator|&
name|lTmpDevice
expr_stmt|;
name|pDevice
operator|->
name|devType
operator|=
name|DIRECT_DEVICE
expr_stmt|;
name|pDevice
operator|->
name|pCard
operator|=
operator|(
name|void
operator|*
operator|)
name|pCard
expr_stmt|;
name|pDevice
operator|->
name|flags
operator|=
name|ACTIVE
expr_stmt|;
name|pDevice
operator|->
name|pPortalInfo
operator|=
name|pPortalInfo
expr_stmt|;
name|pDevice
operator|->
name|pDevHandle
operator|=
name|agDev
index|[
name|devIdx
index|]
expr_stmt|;
name|pDevice
operator|->
name|qbusy
operator|=
name|agFALSE
expr_stmt|;
comment|//AGTIAPI_PRINTK( "agtiapi_GetDevHandle: idx %d / %d : %p \n",
comment|//                devIdx, pCard->devDiscover, agDev[devIdx] );
name|tiINIGetDeviceInfo
argument_list|(
operator|&
name|pCard
operator|->
name|tiRoot
argument_list|,
name|agDev
index|[
name|devIdx
index|]
argument_list|,
operator|&
name|pDevice
operator|->
name|devInfo
argument_list|)
expr_stmt|;
comment|//AGTIAPI_PRINTK( "agtiapi_GetDevHandle: wwn sizes %ld %d/%d ",
comment|//                sizeof(pDevice->targetName),
comment|//                pDevice->devInfo.osAddress1,
comment|//                pDevice->devInfo.osAddress2 );
name|wwncpy
argument_list|(
name|pDevice
argument_list|)
expr_stmt|;
name|wwnprintk
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|pDevice
operator|->
name|targetName
argument_list|,
name|pDevice
operator|->
name|targetLen
argument_list|)
expr_stmt|;
for|for
control|(
name|lDevIndex
operator|=
literal|0
init|;
name|lDevIndex
operator|<
name|szdv
condition|;
name|lDevIndex
operator|++
control|)
comment|// match w/ wwn list
block|{
if|if
condition|(
operator|(
name|pCard
operator|->
name|pDevList
index|[
name|lDevIndex
index|]
operator|.
name|portalId
operator|==
name|pPortalInfo
operator|->
name|portID
operator|)
operator|&&
name|pDevice
operator|->
name|targetLen
operator|>
literal|0
operator|&&
name|portInfT
operator|.
name|localNameLen
operator|>
literal|0
operator|&&
name|portInfT
operator|.
name|remoteNameLen
operator|>
literal|0
operator|&&
name|pSLRList
index|[
name|pWWNList
index|[
name|lDevIndex
index|]
operator|.
name|sasLrIdx
index|]
operator|.
name|localeNameLen
operator|>
literal|0
operator|&&
name|pSLRList
index|[
name|pWWNList
index|[
name|lDevIndex
index|]
operator|.
name|sasLrIdx
index|]
operator|.
name|remoteNameLen
operator|>
literal|0
operator|&&
operator|(
name|portInfT
operator|.
name|localNameLen
operator|==
name|pSLRList
index|[
name|pWWNList
index|[
name|lDevIndex
index|]
operator|.
name|sasLrIdx
index|]
operator|.
name|localeNameLen
operator|)
operator|&&
operator|(
name|portInfT
operator|.
name|remoteNameLen
operator|==
name|pSLRList
index|[
name|pWWNList
index|[
name|lDevIndex
index|]
operator|.
name|sasLrIdx
index|]
operator|.
name|remoteNameLen
operator|)
operator|&&
name|memcmp
argument_list|(
name|pWWNList
index|[
name|lDevIndex
index|]
operator|.
name|targetName
argument_list|,
name|pDevice
operator|->
name|targetName
argument_list|,
name|pDevice
operator|->
name|targetLen
argument_list|)
operator|==
literal|0
operator|&&
name|memcmp
argument_list|(
name|pSLRList
index|[
name|pWWNList
index|[
name|lDevIndex
index|]
operator|.
name|sasLrIdx
index|]
operator|.
name|localeName
argument_list|,
name|portInfT
operator|.
name|localName
argument_list|,
name|portInfT
operator|.
name|localNameLen
argument_list|)
operator|==
literal|0
operator|&&
name|memcmp
argument_list|(
name|pSLRList
index|[
name|pWWNList
index|[
name|lDevIndex
index|]
operator|.
name|sasLrIdx
index|]
operator|.
name|remoteName
argument_list|,
name|portInfT
operator|.
name|remoteName
argument_list|,
name|portInfT
operator|.
name|remoteNameLen
argument_list|)
operator|==
literal|0
condition|)
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|" pWWNList match @ %d/%d/%d \n"
argument_list|,
name|lDevIndex
argument_list|,
name|devIdx
argument_list|,
name|pPortalInfo
operator|->
name|portID
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pCard
operator|->
name|pDevList
index|[
name|lDevIndex
index|]
operator|.
name|targetId
operator|==
name|lDevIndex
operator|)
operator|&&
operator|(
name|pPortalInfo
operator|->
name|pDevList
index|[
name|lDevIndex
index|]
operator|==
operator|&
name|pCard
operator|->
name|pDevList
index|[
name|lDevIndex
index|]
operator|)
condition|)
comment|// active
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_GetDevHandle: dev in use %d of %d/%d\n"
argument_list|,
name|lDevIndex
argument_list|,
name|devTotal
argument_list|,
name|pPortalInfo
operator|->
name|portID
argument_list|)
expr_stmt|;
name|lDevFlags
index|[
name|devIdx
index|]
operator||=
name|DPMC_LEANFLAG_AGDEVUSED
expr_stmt|;
comment|// agDev handle
name|lDevFlags
index|[
name|lDevIndex
index|]
operator||=
name|DPMC_LEANFLAG_PDEVSUSED
expr_stmt|;
comment|// pDevice used
name|lReadRm
operator|=
name|atomic_readandclear_32
argument_list|(
operator|&
name|pWWNList
index|[
name|lDevIndex
index|]
operator|.
name|devRemoved
argument_list|)
expr_stmt|;
if|if
condition|(
name|lReadRm
condition|)
comment|// cleared timeout, now remove count for timer
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_GetDevHandle: clear timer count for"
literal|" %d of %d\n"
argument_list|,
name|lDevIndex
argument_list|,
name|pPortalInfo
operator|->
name|portID
argument_list|)
expr_stmt|;
name|atomic_subtract_16
argument_list|(
operator|&
name|pCard
operator|->
name|rmChkCt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|lReadCt
operator|=
name|atomic_load_acq_16
argument_list|(
operator|&
name|pCard
operator|->
name|rmChkCt
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|lReadCt
condition|)
block|{
name|callout_stop
argument_list|(
operator|&
name|pCard
operator|->
name|devRmTimer
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_GetDevHandle: goin fresh on %d of %d/%d\n"
argument_list|,
name|lDevIndex
argument_list|,
comment|// reactivate now
name|devTotal
argument_list|,
name|pPortalInfo
operator|->
name|portID
argument_list|)
expr_stmt|;
comment|// pDevice going fresh
name|lRunScanFlag
operator|=
name|TRUE
expr_stmt|;
comment|// scan and clear outstanding removals
comment|// pCard->tgtCount++; ##
name|pDevice
operator|->
name|targetId
operator|=
name|lDevIndex
expr_stmt|;
name|pDevice
operator|->
name|portalId
operator|=
name|pPortalInfo
operator|->
name|portID
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|pCard
operator|->
name|pDevList
index|[
name|lDevIndex
index|]
argument_list|,
name|pDevice
argument_list|,
sizeof|sizeof
argument_list|(
name|lTmpDevice
argument_list|)
argument_list|)
expr_stmt|;
name|agDev
index|[
name|devIdx
index|]
operator|->
name|osData
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|pCard
operator|->
name|pDevList
index|[
name|lDevIndex
index|]
expr_stmt|;
if|if
condition|(
name|agtiapi_InitCCBs
argument_list|(
name|pCard
argument_list|,
literal|1
argument_list|,
name|pDevice
operator|->
name|targetId
argument_list|)
operator|==
literal|0
condition|)
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_GetDevHandle: InitCCB "
literal|"tgtCnt %d ERROR!\n"
argument_list|,
name|pCard
operator|->
name|tgtCount
argument_list|)
expr_stmt|;
name|AG_LIST_UNLOCK
argument_list|(
operator|&
name|pCard
operator|->
name|devListLock
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|lDevFlags
argument_list|,
name|M_PMC_MFLG
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|agDev
argument_list|,
name|M_PMC_MDEV
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|pPortalInfo
operator|->
name|pDevList
index|[
name|lDevIndex
index|]
operator|=
operator|&
name|pCard
operator|->
name|pDevList
index|[
name|lDevIndex
index|]
expr_stmt|;
comment|// (ag_device_t *)
if|if
condition|(
literal|0
operator|==
name|lDevFlags
index|[
name|devIdx
index|]
condition|)
block|{
name|pPortalInfo
operator|->
name|devTotal
operator|++
expr_stmt|;
name|lDevFlags
index|[
name|devIdx
index|]
operator||=
name|DPMC_LEANFLAG_AGDEVUSED
expr_stmt|;
comment|// agDev used
name|lDevFlags
index|[
name|lDevIndex
index|]
operator||=
name|DPMC_LEANFLAG_PDEVSUSED
expr_stmt|;
comment|// pDevice used
block|}
else|else
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_GetDevHandle: odd dev handle "
literal|"status inspect %d %d %d\n"
argument_list|,
name|lDevFlags
index|[
name|devIdx
index|]
argument_list|,
name|devIdx
argument_list|,
name|lDevIndex
argument_list|)
expr_stmt|;
name|pPortalInfo
operator|->
name|devTotal
operator|++
expr_stmt|;
name|lDevFlags
index|[
name|devIdx
index|]
operator||=
name|DPMC_LEANFLAG_AGDEVUSED
expr_stmt|;
comment|// agDev used
name|lDevFlags
index|[
name|lDevIndex
index|]
operator||=
name|DPMC_LEANFLAG_PDEVSUSED
expr_stmt|;
comment|// pDevice used
block|}
break|break;
block|}
block|}
comment|// end: match this wwn with previous wwn list
comment|// we have an agDev entry, but no pWWNList target for it
if|if
condition|(
operator|!
operator|(
name|lDevFlags
index|[
name|devIdx
index|]
operator|&
name|DPMC_LEANFLAG_AGDEVUSED
operator|)
condition|)
block|{
comment|// flag dev handle not accounted for yet
name|lDevFlags
index|[
name|devIdx
index|]
operator||=
name|DPMC_LEANFLAG_NOWWNLIST
expr_stmt|;
comment|// later, get an empty pDevice and map this agDev.
comment|// AGTIAPI_PRINTK( "agtiapi_GetDevHandle: devIdx %d flags 0x%x, %d\n",
comment|//                 devIdx, lDevFlags[devIdx], (lDevFlags[devIdx]& 8) );
block|}
block|}
else|else
block|{
name|lDevFlags
index|[
name|devIdx
index|]
operator||=
name|DPMC_LEANFLAG_NOAGDEVYT
expr_stmt|;
comment|// known empty agDev handle
block|}
block|}
comment|// AGTIAPI_PRINTK( "agtiapi_GetDevHandle: all WWN all the time, "
comment|//                 "devLstIdx/flags/(WWNL)portId ... \n" );
comment|// review device list for further action needed
for|for
control|(
name|devIdx
operator|=
literal|0
init|;
name|devIdx
operator|<
name|pCard
operator|->
name|devDiscover
condition|;
name|devIdx
operator|++
control|)
block|{
if|if
condition|(
name|lDevFlags
index|[
name|devIdx
index|]
operator|&
name|DPMC_LEANFLAG_NOWWNLIST
condition|)
comment|// new target, register
block|{
name|int
name|lNextDyad
decl_stmt|;
comment|// find next available dyad entry
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_GetDevHandle: register new target, "
literal|"devIdx %d -- %d \n"
argument_list|,
name|devIdx
argument_list|,
name|pCard
operator|->
name|devDiscover
argument_list|)
expr_stmt|;
name|lRunScanFlag
operator|=
name|TRUE
expr_stmt|;
comment|// scan and clear outstanding removals
for|for
control|(
name|lNextDyad
operator|=
literal|0
init|;
name|lNextDyad
operator|<
name|pCard
operator|->
name|devDiscover
condition|;
name|lNextDyad
operator|++
control|)
block|{
if|if
condition|(
name|pSLRList
index|[
name|lNextDyad
index|]
operator|.
name|localeNameLen
operator|<
literal|0
operator|&&
name|pSLRList
index|[
name|lNextDyad
index|]
operator|.
name|remoteNameLen
operator|<
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|lNextDyad
operator|==
name|pCard
operator|->
name|devDiscover
condition|)
block|{
name|printf
argument_list|(
literal|"agtiapi_GetDevHandle: failed to find available SAS LR\n"
argument_list|)
expr_stmt|;
name|AG_LIST_UNLOCK
argument_list|(
operator|&
name|pCard
operator|->
name|devListLock
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|lDevFlags
argument_list|,
name|M_PMC_MFLG
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|agDev
argument_list|,
name|M_PMC_MDEV
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|// index of new entry
name|lDevIndex
operator|=
name|agtiapi_FindWWNListNext
argument_list|(
name|pWWNList
argument_list|,
name|pCard
operator|->
name|devDiscover
argument_list|)
expr_stmt|;
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_GetDevHandle: listIdx new target %d of %d/%d\n"
argument_list|,
name|lDevIndex
argument_list|,
name|devTotal
argument_list|,
name|pPortalInfo
operator|->
name|portID
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|>
name|lDevIndex
condition|)
block|{
name|printf
argument_list|(
literal|"agtiapi_GetDevHandle: WARNING -- WWNList exhausted.\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|pDevice
operator|=
operator|&
name|pCard
operator|->
name|pDevList
index|[
name|lDevIndex
index|]
expr_stmt|;
name|tiINIGetDeviceInfo
argument_list|(
operator|&
name|pCard
operator|->
name|tiRoot
argument_list|,
name|agDev
index|[
name|devIdx
index|]
argument_list|,
operator|&
name|pDevice
operator|->
name|devInfo
argument_list|)
expr_stmt|;
name|wwncpy
argument_list|(
name|pDevice
argument_list|)
expr_stmt|;
name|agtiapi_InitCCBs
argument_list|(
name|pCard
argument_list|,
literal|1
argument_list|,
name|lDevIndex
argument_list|)
expr_stmt|;
name|pDevice
operator|->
name|pCard
operator|=
operator|(
name|void
operator|*
operator|)
name|pCard
expr_stmt|;
name|pDevice
operator|->
name|devType
operator|=
name|DIRECT_DEVICE
expr_stmt|;
comment|// begin to populate new WWNList entry
name|memcpy
argument_list|(
name|pWWNList
index|[
name|lDevIndex
index|]
operator|.
name|targetName
argument_list|,
name|pDevice
operator|->
name|targetName
argument_list|,
name|pDevice
operator|->
name|targetLen
argument_list|)
expr_stmt|;
name|pWWNList
index|[
name|lDevIndex
index|]
operator|.
name|targetLen
operator|=
name|pDevice
operator|->
name|targetLen
expr_stmt|;
name|pWWNList
index|[
name|lDevIndex
index|]
operator|.
name|flags
operator|=
name|SOFT_MAPPED
expr_stmt|;
name|pWWNList
index|[
name|lDevIndex
index|]
operator|.
name|portId
operator|=
name|pPortalInfo
operator|->
name|portID
expr_stmt|;
name|pWWNList
index|[
name|lDevIndex
index|]
operator|.
name|devListIndex
operator|=
name|lDevIndex
expr_stmt|;
name|pWWNList
index|[
name|lDevIndex
index|]
operator|.
name|sasLrIdx
operator|=
name|lNextDyad
expr_stmt|;
name|pSLRList
index|[
name|lNextDyad
index|]
operator|.
name|localeNameLen
operator|=
name|portInfT
operator|.
name|localNameLen
expr_stmt|;
name|pSLRList
index|[
name|lNextDyad
index|]
operator|.
name|remoteNameLen
operator|=
name|portInfT
operator|.
name|remoteNameLen
expr_stmt|;
name|memcpy
argument_list|(
name|pSLRList
index|[
name|lNextDyad
index|]
operator|.
name|localeName
argument_list|,
name|portInfT
operator|.
name|localName
argument_list|,
name|portInfT
operator|.
name|localNameLen
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|pSLRList
index|[
name|lNextDyad
index|]
operator|.
name|remoteName
argument_list|,
name|portInfT
operator|.
name|remoteName
argument_list|,
name|portInfT
operator|.
name|remoteNameLen
argument_list|)
expr_stmt|;
comment|// end of populating new WWNList entry
name|pDevice
operator|->
name|targetId
operator|=
name|lDevIndex
expr_stmt|;
name|pDevice
operator|->
name|flags
operator|=
name|ACTIVE
expr_stmt|;
name|pDevice
operator|->
name|CCBCount
operator|=
literal|0
expr_stmt|;
name|pDevice
operator|->
name|pDevHandle
operator|=
name|agDev
index|[
name|devIdx
index|]
expr_stmt|;
name|agDev
index|[
name|devIdx
index|]
operator|->
name|osData
operator|=
operator|(
name|void
operator|*
operator|)
name|pDevice
expr_stmt|;
name|pDevice
operator|->
name|pPortalInfo
operator|=
name|pPortalInfo
expr_stmt|;
name|pDevice
operator|->
name|portalId
operator|=
name|pPortalInfo
operator|->
name|portID
expr_stmt|;
name|pPortalInfo
operator|->
name|pDevList
index|[
name|lDevIndex
index|]
operator|=
operator|(
name|void
operator|*
operator|)
name|pDevice
expr_stmt|;
name|lDevFlags
index|[
name|lDevIndex
index|]
operator||=
name|DPMC_LEANFLAG_PDEVSUSED
expr_stmt|;
comment|// mark pDevice slot used
block|}
if|if
condition|(
operator|(
name|pCard
operator|->
name|pDevList
index|[
name|devIdx
index|]
operator|.
name|portalId
operator|==
name|pPortalInfo
operator|->
name|portID
operator|)
operator|&&
operator|!
operator|(
name|lDevFlags
index|[
name|devIdx
index|]
operator|&
name|DPMC_LEANFLAG_PDEVSUSED
operator|)
condition|)
comment|// pDevice not used
block|{
name|pDevice
operator|=
operator|&
name|pCard
operator|->
name|pDevList
index|[
name|devIdx
index|]
expr_stmt|;
comment|//pDevice->flags&= ~ACTIVE;
if|if
condition|(
operator|(
name|pDevice
operator|->
name|pDevHandle
operator|!=
name|NULL
operator|||
name|pPortalInfo
operator|->
name|pDevList
index|[
name|devIdx
index|]
operator|!=
name|NULL
operator|)
condition|)
block|{
name|atomic_add_16
argument_list|(
operator|&
name|pCard
operator|->
name|rmChkCt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|// show count of lost device
if|if
condition|(
name|FALSE
operator|==
name|lRunScanFlag
condition|)
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_GetDevHandle: targ dropped out %d of %d/%d\n"
argument_list|,
name|devIdx
argument_list|,
name|devTotal
argument_list|,
name|pPortalInfo
operator|->
name|portID
argument_list|)
expr_stmt|;
comment|// if ( 0 == pWWNList[devIdx].devRemoved ) '.devRemoved = 5;
name|cmpsetRtn
operator|=
name|atomic_cmpset_32
argument_list|(
operator|&
name|pWWNList
index|[
name|devIdx
index|]
operator|.
name|devRemoved
argument_list|,
literal|0
argument_list|,
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|cmpsetRtn
condition|)
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_GetDevHandle: target %d timer already set\n"
argument_list|,
name|devIdx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|callout_reset
argument_list|(
operator|&
name|pCard
operator|->
name|devRmTimer
argument_list|,
literal|1
operator|*
name|hz
argument_list|,
name|agtiapi_devRmCheck
argument_list|,
name|pCard
argument_list|)
expr_stmt|;
block|}
block|}
comment|// else ... scan coming soon enough anyway, ignore timer for dropout
block|}
block|}
block|}
comment|// end of for ( devIdx = 0; ...
name|AG_LIST_UNLOCK
argument_list|(
operator|&
name|pCard
operator|->
name|devListLock
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|lDevFlags
argument_list|,
name|M_PMC_MFLG
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|agDev
argument_list|,
name|M_PMC_MDEV
argument_list|)
expr_stmt|;
if|if
condition|(
name|TRUE
operator|==
name|lRunScanFlag
condition|)
name|agtiapi_clrRmScan
argument_list|(
name|pCard
argument_list|)
expr_stmt|;
return|return
name|devTotal
return|;
block|}
end_function

begin_comment
comment|// end  agtiapi_GetDevHandle
end_comment

begin_comment
comment|/****************************************************************************** agtiapi_scan()  Purpose:   Triggers CAM's scan Parameters:    struct agtiapi_softc *pCard (IN)    Pointer to the HBA data structure Return: Note:     ******************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|agtiapi_scan
parameter_list|(
name|struct
name|agtiapi_softc
modifier|*
name|pmcsc
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|int
name|bus
decl_stmt|,
name|tid
decl_stmt|,
name|lun
decl_stmt|;
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_scan: start cardNO %d \n"
argument_list|,
name|pmcsc
operator|->
name|cardNo
argument_list|)
expr_stmt|;
name|bus
operator|=
name|cam_sim_path
argument_list|(
name|pmcsc
operator|->
name|sim
argument_list|)
expr_stmt|;
name|tid
operator|=
name|CAM_TARGET_WILDCARD
expr_stmt|;
name|lun
operator|=
name|CAM_LUN_WILDCARD
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
operator|(
name|pmcsc
operator|->
name|pCardInfo
operator|->
name|pmIOLock
operator|)
argument_list|)
expr_stmt|;
name|ccb
operator|=
name|xpt_alloc_ccb_nowait
argument_list|()
expr_stmt|;
if|if
condition|(
name|ccb
operator|==
name|agNULL
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
operator|(
name|pmcsc
operator|->
name|pCardInfo
operator|->
name|pmIOLock
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|xpt_create_path
argument_list|(
operator|&
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|agNULL
argument_list|,
name|bus
argument_list|,
name|tid
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
operator|(
name|pmcsc
operator|->
name|pCardInfo
operator|->
name|pmIOLock
operator|)
argument_list|)
expr_stmt|;
name|xpt_free_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
name|mtx_unlock
argument_list|(
operator|&
operator|(
name|pmcsc
operator|->
name|pCardInfo
operator|->
name|pmIOLock
operator|)
argument_list|)
expr_stmt|;
name|pmcsc
operator|->
name|dev_scan
operator|=
name|agTRUE
expr_stmt|;
name|xpt_rescan
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/****************************************************************************** agtiapi_DeQueueCCB()  Purpose:   Remove a ccb from a queue Parameters:    struct agtiapi_softc *pCard (IN)  Pointer to the card structure   pccb_t *phead (IN)     Pointer to a head of ccb queue   ccb_t  *pccd  (IN)     Pointer to the ccb to be processed Return:   AGTIAPI_SUCCESS - the ccb is removed from queue   AGTIAPI_FAIL    - the ccb is not found from queue Note:     ******************************************************************************/
end_comment

begin_function
name|STATIC
name|agBOOLEAN
name|agtiapi_DeQueueCCB
parameter_list|(
name|struct
name|agtiapi_softc
modifier|*
name|pCard
parameter_list|,
name|pccb_t
modifier|*
name|phead
parameter_list|,
name|pccb_t
modifier|*
name|ptail
parameter_list|,
ifdef|#
directive|ifdef
name|AGTIAPI_LOCAL_LOCK
name|struct
name|mtx
modifier|*
name|lock
parameter_list|,
endif|#
directive|endif
name|ccb_t
modifier|*
name|pccb
parameter_list|)
block|{
name|ccb_t
modifier|*
name|pccb_curr
decl_stmt|;
name|U32
name|status
init|=
name|AGTIAPI_FAIL
decl_stmt|;
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_DeQueueCCB: %p from %p\n"
argument_list|,
name|pccb
argument_list|,
name|phead
argument_list|)
expr_stmt|;
if|if
condition|(
name|pccb
operator|==
name|NULL
operator|||
operator|*
name|phead
operator|==
name|NULL
condition|)
block|{
return|return
name|AGTIAPI_FAIL
return|;
block|}
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_DeQueueCCB: %p from %p\n"
argument_list|,
name|pccb
argument_list|,
name|phead
argument_list|)
expr_stmt|;
name|AG_LOCAL_LOCK
argument_list|(
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|pccb
operator|==
operator|*
name|phead
condition|)
block|{
operator|*
name|phead
operator|=
operator|(
operator|*
name|phead
operator|)
operator|->
name|pccbNext
expr_stmt|;
if|if
condition|(
name|pccb
operator|==
operator|*
name|ptail
condition|)
block|{
operator|*
name|ptail
operator|=
name|NULL
expr_stmt|;
block|}
else|else
name|pccb
operator|->
name|pccbNext
operator|=
name|NULL
expr_stmt|;
name|status
operator|=
name|AGTIAPI_SUCCESS
expr_stmt|;
block|}
else|else
block|{
name|pccb_curr
operator|=
operator|*
name|phead
expr_stmt|;
while|while
condition|(
name|pccb_curr
operator|->
name|pccbNext
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|pccb_curr
operator|->
name|pccbNext
operator|==
name|pccb
condition|)
block|{
name|pccb_curr
operator|->
name|pccbNext
operator|=
name|pccb
operator|->
name|pccbNext
expr_stmt|;
name|pccb
operator|->
name|pccbNext
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|pccb
operator|==
operator|*
name|ptail
condition|)
block|{
operator|*
name|ptail
operator|=
name|pccb_curr
expr_stmt|;
block|}
else|else
name|pccb
operator|->
name|pccbNext
operator|=
name|NULL
expr_stmt|;
name|status
operator|=
name|AGTIAPI_SUCCESS
expr_stmt|;
break|break;
block|}
name|pccb_curr
operator|=
name|pccb_curr
operator|->
name|pccbNext
expr_stmt|;
block|}
block|}
name|AG_LOCAL_UNLOCK
argument_list|(
name|lock
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_function
name|STATIC
name|void
name|wwnprintk
parameter_list|(
name|unsigned
name|char
modifier|*
name|name
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
operator|,
name|name
operator|++
control|)
name|AGTIAPI_PRINTK
argument_list|(
literal|"%02x"
argument_list|,
operator|*
name|name
argument_list|)
expr_stmt|;
name|AGTIAPI_PRINTK
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*   * SAS and SATA behind expander has 8 byte long unique address.   * However, direct connect SATA device use 512 byte unique device id.  * SPC uses remoteName to indicate length of ID and remoteAddress for the  * address of memory that holding ID.  */
end_comment

begin_function
name|STATIC
name|int
name|wwncpy
parameter_list|(
name|ag_device_t
modifier|*
name|pDevice
parameter_list|)
block|{
name|int
name|rc
init|=
literal|0
decl_stmt|;
if|if
condition|(
sizeof|sizeof
argument_list|(
name|pDevice
operator|->
name|targetName
argument_list|)
operator|>=
name|pDevice
operator|->
name|devInfo
operator|.
name|osAddress1
operator|+
name|pDevice
operator|->
name|devInfo
operator|.
name|osAddress2
condition|)
block|{
name|memcpy
argument_list|(
name|pDevice
operator|->
name|targetName
argument_list|,
name|pDevice
operator|->
name|devInfo
operator|.
name|remoteName
argument_list|,
name|pDevice
operator|->
name|devInfo
operator|.
name|osAddress1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|pDevice
operator|->
name|targetName
operator|+
name|pDevice
operator|->
name|devInfo
operator|.
name|osAddress1
argument_list|,
name|pDevice
operator|->
name|devInfo
operator|.
name|remoteAddress
argument_list|,
name|pDevice
operator|->
name|devInfo
operator|.
name|osAddress2
argument_list|)
expr_stmt|;
name|pDevice
operator|->
name|targetLen
operator|=
name|pDevice
operator|->
name|devInfo
operator|.
name|osAddress1
operator|+
name|pDevice
operator|->
name|devInfo
operator|.
name|osAddress2
expr_stmt|;
name|rc
operator|=
name|pDevice
operator|->
name|targetLen
expr_stmt|;
block|}
else|else
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"WWN wrong size: %d + %d ERROR\n"
argument_list|,
name|pDevice
operator|->
name|devInfo
operator|.
name|osAddress1
argument_list|,
name|pDevice
operator|->
name|devInfo
operator|.
name|osAddress2
argument_list|)
expr_stmt|;
name|rc
operator|=
operator|-
literal|1
expr_stmt|;
block|}
return|return
name|rc
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************** agtiapi_ReleaseCCBs()  Purpose:   Free all allocated CCB memories for the Host Adapter. Parameters:   struct agtiapi_softc *pCard (IN)  Pointer to HBA data structure Return: Note: ******************************************************************************/
end_comment

begin_function
name|STATIC
name|void
name|agtiapi_ReleaseCCBs
parameter_list|(
name|struct
name|agtiapi_softc
modifier|*
name|pCard
parameter_list|)
block|{
name|ccb_hdr_t
modifier|*
name|hdr
decl_stmt|;
name|U32
name|hdr_sz
decl_stmt|;
name|ccb_t
modifier|*
name|pccb
init|=
name|NULL
decl_stmt|;
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_ReleaseCCBs: start\n"
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|AGTIAPI_TEST_DPL
operator|||
name|defined
name|AGTIAPI_TEST_EPL
operator|)
name|ccb_t
modifier|*
name|pccb
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|AGTIAPI_TEST_DPL
for|for
control|(
name|pccb
operator|=
operator|(
name|pccb_t
operator|)
name|pCard
operator|->
name|ccbChainList
init|;
name|pccb
operator|!=
name|NULL
condition|;
name|pccb
operator|=
name|pccb
operator|->
name|pccbChainNext
control|)
block|{
if|if
condition|(
name|pccb
operator|->
name|dplPtr
operator|&&
name|pccb
operator|->
name|dplDma
condition|)
name|pci_pool_free
argument_list|(
name|pCard
operator|->
name|dpl_ctx_pool
argument_list|,
name|pccb
operator|->
name|dplPtr
argument_list|,
name|pccb
operator|->
name|dplDma
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|AGTIAPI_TEST_EPL
for|for
control|(
name|pccb
operator|=
operator|(
name|pccb_t
operator|)
name|pCard
operator|->
name|ccbChainList
init|;
name|pccb
operator|!=
name|NULL
condition|;
name|pccb
operator|=
name|pccb
operator|->
name|pccbChainNext
control|)
block|{
if|if
condition|(
name|pccb
operator|->
name|epl_ptr
operator|&&
name|pccb
operator|->
name|epl_dma_ptr
condition|)
name|pci_pool_free
argument_list|(
name|pCard
operator|->
name|epl_ctx_pool
argument_list|,
name|pccb
operator|->
name|epl_ptr
argument_list|,
name|pccb
operator|->
name|epl_dma_ptr
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
while|while
condition|(
operator|(
name|hdr
operator|=
name|pCard
operator|->
name|ccbAllocList
operator|)
operator|!=
name|NULL
condition|)
block|{
name|pCard
operator|->
name|ccbAllocList
operator|=
name|hdr
operator|->
name|next
expr_stmt|;
name|hdr_sz
operator|=
name|roundup2
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
argument_list|,
name|cache_line_size
argument_list|()
argument_list|)
expr_stmt|;
name|pccb
operator|=
operator|(
name|ccb_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|hdr
operator|+
name|hdr_sz
operator|)
expr_stmt|;
if|if
condition|(
name|pCard
operator|->
name|buffer_dmat
operator|!=
name|NULL
operator|&&
name|pccb
operator|->
name|CCB_dmamap
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_destroy
argument_list|(
name|pCard
operator|->
name|buffer_dmat
argument_list|,
name|pccb
operator|->
name|CCB_dmamap
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|hdr
argument_list|,
name|M_PMC_MCCB
argument_list|)
expr_stmt|;
block|}
name|pCard
operator|->
name|ccbAllocList
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/****************************************************************************** agtiapi_TITimer()  Purpose:   Timer tick for tisa common layer Parameters:   void *data (IN)  Pointer to the HBA data structure Return: Note: ******************************************************************************/
end_comment

begin_function
name|STATIC
name|void
name|agtiapi_TITimer
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|U32
name|next_tick
decl_stmt|;
name|struct
name|agtiapi_softc
modifier|*
name|pCard
decl_stmt|;
name|pCard
operator|=
operator|(
expr|struct
name|agtiapi_softc
operator|*
operator|)
name|data
expr_stmt|;
comment|//  AGTIAPI_PRINTK("agtiapi_TITimer: start\n");
name|AG_GLOBAL_ARG
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|next_tick
operator|=
name|pCard
operator|->
name|pCardInfo
operator|->
name|tiRscInfo
operator|.
name|tiLoLevelResource
operator|.
name|loLevelOption
operator|.
name|usecsPerTick
operator|/
name|USEC_PER_TICK
expr_stmt|;
if|if
condition|(
name|next_tick
operator|==
literal|0
condition|)
comment|/* no timer required */
return|return;
name|AG_SPIN_LOCK_IRQ
argument_list|(
name|agtiapi_host_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|pCard
operator|->
name|flags
operator|&
name|AGTIAPI_SHUT_DOWN
condition|)
goto|goto
name|ext
goto|;
name|tiCOMTimerTick
argument_list|(
operator|&
name|pCard
operator|->
name|tiRoot
argument_list|)
expr_stmt|;
comment|/* tisa common layer timer tick */
comment|//add for polling mode
ifdef|#
directive|ifdef
name|PMC_SPC
if|if
condition|(
name|agtiapi_polling_mode
condition|)
name|agtiapi_CheckAllVectors
argument_list|(
name|pCard
argument_list|,
name|tiNonInterruptContext
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|callout_reset
argument_list|(
operator|&
name|pCard
operator|->
name|OS_timer
argument_list|,
name|next_tick
argument_list|,
name|agtiapi_TITimer
argument_list|,
name|pCard
argument_list|)
expr_stmt|;
name|ext
label|:
name|AG_SPIN_UNLOCK_IRQ
argument_list|(
name|agtiapi_host_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/****************************************************************************** agtiapi_clrRmScan()  Purpose:   Clears device list entries scheduled for timeout and calls scan Parameters:   struct agtiapi_softc *pCard (IN)  Pointer to HBA data structure ******************************************************************************/
end_comment

begin_function
name|STATIC
name|void
name|agtiapi_clrRmScan
parameter_list|(
name|struct
name|agtiapi_softc
modifier|*
name|pCard
parameter_list|)
block|{
name|ag_tgt_map_t
modifier|*
name|pWWNList
decl_stmt|;
name|ag_portal_info_t
modifier|*
name|pPortalInfo
decl_stmt|;
name|ag_portal_data_t
modifier|*
name|pPortalData
decl_stmt|;
name|int
name|lIdx
decl_stmt|;
name|bit32
name|lReadRm
decl_stmt|;
name|bit16
name|lReadCt
decl_stmt|;
name|pWWNList
operator|=
name|pCard
operator|->
name|pWWNList
expr_stmt|;
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_clrRmScan: start\n"
argument_list|)
expr_stmt|;
name|AG_LIST_LOCK
argument_list|(
operator|&
name|pCard
operator|->
name|devListLock
argument_list|)
expr_stmt|;
for|for
control|(
name|lIdx
operator|=
literal|0
init|;
name|lIdx
operator|<
name|pCard
operator|->
name|devDiscover
condition|;
name|lIdx
operator|++
control|)
block|{
name|lReadCt
operator|=
name|atomic_load_acq_16
argument_list|(
operator|&
name|pCard
operator|->
name|rmChkCt
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|lReadCt
condition|)
block|{
break|break;
comment|// trim to who cares
block|}
name|lReadRm
operator|=
name|atomic_readandclear_32
argument_list|(
operator|&
name|pWWNList
index|[
name|lIdx
index|]
operator|.
name|devRemoved
argument_list|)
expr_stmt|;
if|if
condition|(
name|lReadRm
operator|>
literal|0
condition|)
block|{
name|pCard
operator|->
name|pDevList
index|[
name|lIdx
index|]
operator|.
name|flags
operator|&=
operator|~
name|ACTIVE
expr_stmt|;
name|pCard
operator|->
name|pDevList
index|[
name|lIdx
index|]
operator|.
name|pDevHandle
operator|=
name|NULL
expr_stmt|;
name|pPortalData
operator|=
operator|&
name|pCard
operator|->
name|pPortalData
index|[
name|pWWNList
index|[
name|lIdx
index|]
operator|.
name|portId
index|]
expr_stmt|;
name|pPortalInfo
operator|=
operator|&
name|pPortalData
operator|->
name|portalInfo
expr_stmt|;
name|pPortalInfo
operator|->
name|pDevList
index|[
name|lIdx
index|]
operator|=
name|NULL
expr_stmt|;
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_clrRmScan: cleared dev %d at port %d\n"
argument_list|,
name|lIdx
argument_list|,
name|pWWNList
index|[
name|lIdx
index|]
operator|.
name|portId
argument_list|)
expr_stmt|;
name|atomic_subtract_16
argument_list|(
operator|&
name|pCard
operator|->
name|rmChkCt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|AG_LIST_UNLOCK
argument_list|(
operator|&
name|pCard
operator|->
name|devListLock
argument_list|)
expr_stmt|;
name|agtiapi_scan
argument_list|(
name|pCard
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************** agtiapi_devRmCheck()  Purpose:   Timer tick to check for timeout on missing targets   Removes device list entry when timeout is reached Parameters:   void *data (IN)  Pointer to the HBA data structure ******************************************************************************/
end_comment

begin_function
name|STATIC
name|void
name|agtiapi_devRmCheck
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|agtiapi_softc
modifier|*
name|pCard
decl_stmt|;
name|ag_tgt_map_t
modifier|*
name|pWWNList
decl_stmt|;
name|int
name|lIdx
decl_stmt|,
name|cmpsetRtn
decl_stmt|,
name|lRunScanFlag
init|=
name|FALSE
decl_stmt|;
name|bit16
name|lReadCt
decl_stmt|;
name|bit32
name|lReadRm
decl_stmt|;
name|pCard
operator|=
operator|(
expr|struct
name|agtiapi_softc
operator|*
operator|)
name|data
expr_stmt|;
comment|// routine overhead
if|if
condition|(
name|callout_pending
argument_list|(
operator|&
name|pCard
operator|->
name|devRmTimer
argument_list|)
condition|)
comment|// callout was reset
block|{
return|return;
block|}
if|if
condition|(
operator|!
name|callout_active
argument_list|(
operator|&
name|pCard
operator|->
name|devRmTimer
argument_list|)
condition|)
comment|// callout was stopped
block|{
return|return;
block|}
name|callout_deactivate
argument_list|(
operator|&
name|pCard
operator|->
name|devRmTimer
argument_list|)
expr_stmt|;
if|if
condition|(
name|pCard
operator|->
name|flags
operator|&
name|AGTIAPI_SHUT_DOWN
condition|)
block|{
return|return;
comment|// implicit timer clear
block|}
name|pWWNList
operator|=
name|pCard
operator|->
name|pWWNList
expr_stmt|;
name|AG_LIST_LOCK
argument_list|(
operator|&
name|pCard
operator|->
name|devListLock
argument_list|)
expr_stmt|;
name|lReadCt
operator|=
name|atomic_load_acq_16
argument_list|(
operator|&
name|pCard
operator|->
name|rmChkCt
argument_list|)
expr_stmt|;
if|if
condition|(
name|lReadCt
condition|)
block|{
if|if
condition|(
name|callout_pending
argument_list|(
operator|&
name|pCard
operator|->
name|devRmTimer
argument_list|)
operator|==
name|FALSE
condition|)
block|{
name|callout_reset
argument_list|(
operator|&
name|pCard
operator|->
name|devRmTimer
argument_list|,
literal|1
operator|*
name|hz
argument_list|,
name|agtiapi_devRmCheck
argument_list|,
name|pCard
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|AG_LIST_UNLOCK
argument_list|(
operator|&
name|pCard
operator|->
name|devListLock
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|lIdx
operator|=
literal|0
init|;
name|lIdx
operator|<
name|pCard
operator|->
name|devDiscover
condition|;
name|lIdx
operator|++
control|)
block|{
name|lReadCt
operator|=
name|atomic_load_acq_16
argument_list|(
operator|&
name|pCard
operator|->
name|rmChkCt
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|lReadCt
condition|)
block|{
break|break;
comment|// if handled somewhere else, get out
block|}
name|lReadRm
operator|=
name|atomic_load_acq_32
argument_list|(
operator|&
name|pWWNList
index|[
name|lIdx
index|]
operator|.
name|devRemoved
argument_list|)
expr_stmt|;
if|if
condition|(
name|lReadRm
operator|>
literal|0
condition|)
block|{
if|if
condition|(
literal|1
operator|==
name|lReadRm
condition|)
comment|// timed out
block|{
comment|// no decrement of devRemoved as way to leave a clrRmScan marker
name|lRunScanFlag
operator|=
name|TRUE
expr_stmt|;
comment|// other devRemoved values are about to get wiped
break|break;
comment|// ... so bail out
block|}
else|else
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_devRmCheck: counting down dev %d @ %d; %d\n"
argument_list|,
name|lIdx
argument_list|,
name|lReadRm
argument_list|,
name|lReadCt
argument_list|)
expr_stmt|;
name|cmpsetRtn
operator|=
name|atomic_cmpset_32
argument_list|(
operator|&
name|pWWNList
index|[
name|lIdx
index|]
operator|.
name|devRemoved
argument_list|,
name|lReadRm
argument_list|,
name|lReadRm
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|cmpsetRtn
condition|)
block|{
name|printf
argument_list|(
literal|"agtiapi_devRmCheck: %d decrement already handled\n"
argument_list|,
name|lIdx
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|AG_LIST_UNLOCK
argument_list|(
operator|&
name|pCard
operator|->
name|devListLock
argument_list|)
expr_stmt|;
if|if
condition|(
name|TRUE
operator|==
name|lRunScanFlag
condition|)
name|agtiapi_clrRmScan
argument_list|(
name|pCard
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|AG_LIST_UNLOCK
argument_list|(
operator|&
name|pCard
operator|->
name|devListLock
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|agtiapi_cam_poll
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|asim
parameter_list|)
block|{
return|return;
block|}
end_function

begin_comment
comment|/***************************************************************************** agtiapi_ResetCard()  Purpose:   Hard or soft reset on the controller and resend any   outstanding requests if needed. Parameters:   struct agtiapi_softc *pCard (IN)  Pointer to HBA data structure   unsigned lomg flags (IN/OUT) Flags used in locking done from calling layers Return:   AGTIAPI_SUCCESS - reset successful   AGTIAPI_FAIL    - reset failed Note: *****************************************************************************/
end_comment

begin_function
name|U32
name|agtiapi_ResetCard
parameter_list|(
name|struct
name|agtiapi_softc
modifier|*
name|pCard
parameter_list|,
name|unsigned
name|long
modifier|*
name|flags
parameter_list|)
block|{
name|ag_device_t
modifier|*
name|pDevice
decl_stmt|;
name|U32
name|lIdx
init|=
literal|0
decl_stmt|;
name|U32
name|lFlagVal
decl_stmt|;
name|agBOOLEAN
name|ret
decl_stmt|;
name|ag_portal_info_t
modifier|*
name|pPortalInfo
decl_stmt|;
name|ag_portal_data_t
modifier|*
name|pPortalData
decl_stmt|;
name|U32
name|count
decl_stmt|,
name|loop
decl_stmt|;
name|int
name|szdv
decl_stmt|;
if|if
condition|(
name|pCard
operator|->
name|flags
operator|&
name|AGTIAPI_RESET
condition|)
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_ResetCard: reset card already in progress!\n"
argument_list|)
expr_stmt|;
return|return
name|AGTIAPI_FAIL
return|;
block|}
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_ResetCard: Enter cnt %d\n"
argument_list|,
name|pCard
operator|->
name|resetCount
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LOGEVENT
name|agtiapi_LogEvent
argument_list|(
name|pCard
argument_list|,
name|IOCTL_EVT_SEV_INFORMATIONAL
argument_list|,
literal|0
argument_list|,
name|agNULL
argument_list|,
literal|0
argument_list|,
literal|"Reset initiator time = %d!"
argument_list|,
name|pCard
operator|->
name|resetCount
operator|+
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pCard
operator|->
name|flags
operator||=
name|AGTIAPI_RESET
expr_stmt|;
name|pCard
operator|->
name|flags
operator|&=
operator|~
operator|(
name|AGTIAPI_CB_DONE
operator||
name|AGTIAPI_RESET_SUCCESS
operator|)
expr_stmt|;
name|tiCOMSystemInterruptsActive
argument_list|(
operator|&
name|pCard
operator|->
name|tiRoot
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|pCard
operator|->
name|flags
operator|&=
operator|~
name|AGTIAPI_SYS_INTR_ON
expr_stmt|;
name|agtiapi_FlushCCBs
argument_list|(
name|pCard
argument_list|,
name|AGTIAPI_CALLBACK
argument_list|)
expr_stmt|;
for|for
control|(
name|lIdx
operator|=
literal|1
init|;
literal|3
operator|>=
name|lIdx
condition|;
name|lIdx
operator|++
control|)
comment|// we try reset up to 3 times
block|{
if|if
condition|(
name|pCard
operator|->
name|flags
operator|&
name|AGTIAPI_SOFT_RESET
condition|)
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_ResetCard: soft variant\n"
argument_list|)
expr_stmt|;
name|tiCOMReset
argument_list|(
operator|&
name|pCard
operator|->
name|tiRoot
argument_list|,
name|tiSoftReset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_ResetCard: no flag, no reset!\n"
argument_list|)
expr_stmt|;
block|}
name|lFlagVal
operator|=
name|AGTIAPI_RESET_SUCCESS
expr_stmt|;
name|AG_SPIN_UNLOCK_IRQ
argument_list|(
name|agtiapi_host_lock
argument_list|,
operator|*
name|flags
argument_list|)
expr_stmt|;
name|ret
operator|=
name|agtiapi_CheckCB
argument_list|(
name|pCard
argument_list|,
literal|50000
argument_list|,
name|lFlagVal
argument_list|,
operator|&
name|pCard
operator|->
name|flags
argument_list|)
expr_stmt|;
name|AG_SPIN_LOCK_IRQ
argument_list|(
name|agtiapi_host_lock
argument_list|,
operator|*
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|AGTIAPI_FAIL
condition|)
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_ResetCard: CheckCB indicates failed reset call, "
literal|"try again?\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
if|if
condition|(
literal|1
operator|<
name|lIdx
condition|)
block|{
if|if
condition|(
name|AGTIAPI_FAIL
operator|==
name|ret
condition|)
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_ResetCard: soft reset failed after try %d\n"
argument_list|,
name|lIdx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_ResetCard: soft reset success at try %d\n"
argument_list|,
name|lIdx
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|AGTIAPI_FAIL
operator|==
name|ret
condition|)
block|{
name|printf
argument_list|(
literal|"agtiapi_ResetCard: reset ERROR\n"
argument_list|)
expr_stmt|;
name|pCard
operator|->
name|flags
operator|&=
operator|~
name|AGTIAPI_INSTALLED
expr_stmt|;
return|return
name|AGTIAPI_FAIL
return|;
block|}
name|pCard
operator|->
name|flags
operator|&=
operator|~
name|AGTIAPI_SOFT_RESET
expr_stmt|;
comment|// disable all devices
name|pDevice
operator|=
name|pCard
operator|->
name|pDevList
expr_stmt|;
for|for
control|(
name|lIdx
operator|=
literal|0
init|;
name|lIdx
operator|<
name|maxTargets
condition|;
name|lIdx
operator|++
operator|,
name|pDevice
operator|++
control|)
block|{
comment|/* if ( pDevice->flags& ACTIVE )     {       printf( "agtiapi_ResetCard: before ... active device %d\n", lIdx );     } */
name|pDevice
operator|->
name|flags
operator|&=
operator|~
name|ACTIVE
expr_stmt|;
block|}
name|AG_SPIN_UNLOCK_IRQ
argument_list|(
name|agtiapi_host_lock
argument_list|,
operator|*
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|tiCOMPortInit
argument_list|(
operator|&
name|pCard
operator|->
name|tiRoot
argument_list|,
name|agFALSE
argument_list|)
operator|!=
name|tiSuccess
condition|)
name|printf
argument_list|(
literal|"agtiapi_ResetCard: tiCOMPortInit FAILED \n"
argument_list|)
expr_stmt|;
else|else
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_ResetCard: tiCOMPortInit success\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pCard
operator|->
name|pDevList
condition|)
block|{
comment|// try to get a little sanity here
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_ResetCard: no pDevList ERROR %p\n"
argument_list|,
name|pCard
operator|->
name|pDevList
argument_list|)
expr_stmt|;
return|return
name|AGTIAPI_FAIL
return|;
block|}
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_ResetCard: pre target-count %d port-count %d\n"
argument_list|,
name|pCard
operator|->
name|tgtCount
argument_list|,
name|pCard
operator|->
name|portCount
argument_list|)
expr_stmt|;
name|pCard
operator|->
name|tgtCount
operator|=
literal|0
expr_stmt|;
name|DELAY
argument_list|(
literal|500000
argument_list|)
expr_stmt|;
name|pCard
operator|->
name|flags
operator|&=
operator|~
name|AGTIAPI_CB_DONE
expr_stmt|;
name|pPortalData
operator|=
name|pCard
operator|->
name|pPortalData
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|pCard
operator|->
name|portCount
condition|;
name|count
operator|++
control|)
block|{
name|AG_SPIN_LOCK_IRQ
argument_list|(
name|agtiapi_host_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|pPortalInfo
operator|=
operator|&
name|pPortalData
operator|->
name|portalInfo
expr_stmt|;
name|pPortalInfo
operator|->
name|portStatus
operator|=
literal|0
expr_stmt|;
name|pPortalInfo
operator|->
name|portStatus
operator|&=
operator|~
operator|(
name|AGTIAPI_PORT_START
operator||
name|AGTIAPI_PORT_DISC_READY
operator||
name|AGTIAPI_DISC_DONE
operator||
name|AGTIAPI_DISC_COMPLETE
operator|)
expr_stmt|;
name|szdv
operator|=
sizeof|sizeof
argument_list|(
name|pPortalInfo
operator|->
name|pDevList
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|pPortalInfo
operator|->
name|pDevList
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|szdv
operator|>
name|pCard
operator|->
name|devDiscover
condition|)
block|{
name|szdv
operator|=
name|pCard
operator|->
name|devDiscover
expr_stmt|;
block|}
for|for
control|(
name|lIdx
operator|=
literal|0
operator|,
name|loop
operator|=
literal|0
init|;
name|lIdx
operator|<
name|szdv
operator|&&
name|loop
operator|<
name|pPortalInfo
operator|->
name|devTotal
condition|;
name|lIdx
operator|++
control|)
block|{
name|pDevice
operator|=
operator|(
name|ag_device_t
operator|*
operator|)
name|pPortalInfo
operator|->
name|pDevList
index|[
name|lIdx
index|]
expr_stmt|;
if|if
condition|(
name|pDevice
condition|)
block|{
name|loop
operator|++
expr_stmt|;
name|pDevice
operator|->
name|pDevHandle
operator|=
literal|0
expr_stmt|;
comment|// mark for availability in pCard->pDevList[]
comment|// don't erase more as the device is scheduled for removal on DPC
block|}
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_ResetCard: reset pDev %p pDevList %p idx %d\n"
argument_list|,
name|pDevice
argument_list|,
name|pPortalInfo
operator|->
name|pDevList
argument_list|,
name|lIdx
argument_list|)
expr_stmt|;
name|pPortalInfo
operator|->
name|devTotal
operator|=
name|pPortalInfo
operator|->
name|devPrev
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|lIdx
operator|=
literal|0
init|;
name|lIdx
operator|<
name|maxTargets
condition|;
name|lIdx
operator|++
control|)
block|{
comment|// we reconstruct dev list later in get dev handle
name|pPortalInfo
operator|->
name|pDevList
index|[
name|lIdx
index|]
operator|=
name|NULL
expr_stmt|;
block|}
for|for
control|(
name|loop
operator|=
literal|0
init|;
name|loop
operator|<
name|AGTIAPI_LOOP_MAX
condition|;
name|loop
operator|++
control|)
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_ResetCard: tiCOMPortStart entry data "
literal|"%p / %d / %p\n"
argument_list|,
operator|&
name|pCard
operator|->
name|tiRoot
argument_list|,
name|pPortalInfo
operator|->
name|portID
argument_list|,
operator|&
name|pPortalInfo
operator|->
name|tiPortalContext
argument_list|)
expr_stmt|;
if|if
condition|(
name|tiCOMPortStart
argument_list|(
operator|&
name|pCard
operator|->
name|tiRoot
argument_list|,
name|pPortalInfo
operator|->
name|portID
argument_list|,
operator|&
name|pPortalInfo
operator|->
name|tiPortalContext
argument_list|,
literal|0
argument_list|)
operator|!=
name|tiSuccess
condition|)
block|{
name|printf
argument_list|(
literal|"agtiapi_ResetCard: tiCOMPortStart %d FAILED\n"
argument_list|,
name|pPortalInfo
operator|->
name|portID
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_ResetCard: tiCOMPortStart %d success\n"
argument_list|,
name|pPortalInfo
operator|->
name|portID
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|AG_SPIN_UNLOCK_IRQ
argument_list|(
name|agtiapi_host_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|tiCOMGetPortInfo
argument_list|(
operator|&
name|pCard
operator|->
name|tiRoot
argument_list|,
operator|&
name|pPortalInfo
operator|->
name|tiPortalContext
argument_list|,
operator|&
name|pPortalInfo
operator|->
name|tiPortInfo
argument_list|)
expr_stmt|;
name|pPortalData
operator|++
expr_stmt|;
block|}
comment|// ## fail case:  pCard->flags&= ~AGTIAPI_INSTALLED;
name|AG_SPIN_LOCK_IRQ
argument_list|(
name|agtiapi_host_lock
argument_list|,
operator|*
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|pCard
operator|->
name|flags
operator|&
name|AGTIAPI_INSTALLED
operator|)
condition|)
comment|// driver not installed !
block|{
name|printf
argument_list|(
literal|"agtiapi_ResetCard: error, driver not intstalled? "
literal|"!AGTIAPI_INSTALLED \n"
argument_list|)
expr_stmt|;
return|return
name|AGTIAPI_FAIL
return|;
block|}
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_ResetCard: total device %d\n"
argument_list|,
name|pCard
operator|->
name|tgtCount
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LOGEVENT
name|agtiapi_LogEvent
argument_list|(
name|pCard
argument_list|,
name|IOCTL_EVT_SEV_INFORMATIONAL
argument_list|,
literal|0
argument_list|,
name|agNULL
argument_list|,
literal|0
argument_list|,
literal|"Reset initiator total device = %d!"
argument_list|,
name|pCard
operator|->
name|tgtCount
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pCard
operator|->
name|resetCount
operator|++
expr_stmt|;
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_ResetCard: clear send and done queues\n"
argument_list|)
expr_stmt|;
comment|// clear send& done queue
name|AG_LOCAL_LOCK
argument_list|(
operator|&
name|pCard
operator|->
name|sendLock
argument_list|)
expr_stmt|;
name|pCard
operator|->
name|ccbSendHead
operator|=
name|NULL
expr_stmt|;
name|pCard
operator|->
name|ccbSendTail
operator|=
name|NULL
expr_stmt|;
name|AG_LOCAL_UNLOCK
argument_list|(
operator|&
name|pCard
operator|->
name|sendLock
argument_list|)
expr_stmt|;
name|AG_LOCAL_LOCK
argument_list|(
operator|&
name|pCard
operator|->
name|doneLock
argument_list|)
expr_stmt|;
name|pCard
operator|->
name|ccbDoneHead
operator|=
name|NULL
expr_stmt|;
name|pCard
operator|->
name|ccbDoneTail
operator|=
name|NULL
expr_stmt|;
name|AG_LOCAL_UNLOCK
argument_list|(
operator|&
name|pCard
operator|->
name|doneLock
argument_list|)
expr_stmt|;
comment|// clear smp queues also
name|AG_LOCAL_LOCK
argument_list|(
operator|&
name|pCard
operator|->
name|sendSMPLock
argument_list|)
expr_stmt|;
name|pCard
operator|->
name|smpSendHead
operator|=
name|NULL
expr_stmt|;
name|pCard
operator|->
name|smpSendTail
operator|=
name|NULL
expr_stmt|;
name|AG_LOCAL_UNLOCK
argument_list|(
operator|&
name|pCard
operator|->
name|sendSMPLock
argument_list|)
expr_stmt|;
name|AG_LOCAL_LOCK
argument_list|(
operator|&
name|pCard
operator|->
name|doneSMPLock
argument_list|)
expr_stmt|;
name|pCard
operator|->
name|smpDoneHead
operator|=
name|NULL
expr_stmt|;
name|pCard
operator|->
name|smpDoneTail
operator|=
name|NULL
expr_stmt|;
name|AG_LOCAL_UNLOCK
argument_list|(
operator|&
name|pCard
operator|->
name|doneSMPLock
argument_list|)
expr_stmt|;
comment|// finished with all reset stuff, now start things back up
name|tiCOMSystemInterruptsActive
argument_list|(
operator|&
name|pCard
operator|->
name|tiRoot
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|pCard
operator|->
name|flags
operator||=
name|AGTIAPI_SYS_INTR_ON
expr_stmt|;
name|pCard
operator|->
name|flags
operator||=
name|AGTIAPI_HAD_RESET
expr_stmt|;
name|pCard
operator|->
name|flags
operator|&=
operator|~
name|AGTIAPI_RESET
expr_stmt|;
comment|// ##
name|agtiapi_StartIO
argument_list|(
name|pCard
argument_list|)
expr_stmt|;
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_ResetCard: local return success\n"
argument_list|)
expr_stmt|;
return|return
name|AGTIAPI_SUCCESS
return|;
block|}
end_function

begin_comment
comment|// agtiapi_ResetCard
end_comment

begin_comment
comment|/****************************************************************************** agtiapi_ReleaseHBA()  Purpose:   Releases all resources previously acquired to support    a specific Host Adapter, including the I/O Address range,    and unregisters the agtiapi Host Adapter. Parameters:    device_t dev (IN)  - device pointer Return:   always return 0 - success Note:     ******************************************************************************/
end_comment

begin_function
name|int
name|agtiapi_ReleaseHBA
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|thisCard
init|=
name|device_get_unit
argument_list|(
name|dev
argument_list|)
decl_stmt|;
comment|// keeping get_unit call to once
name|int
name|i
decl_stmt|;
name|ag_card_info_t
modifier|*
name|thisCardInst
init|=
operator|&
name|agCardInfoList
index|[
name|thisCard
index|]
decl_stmt|;
name|struct
name|ccb_setasync
name|csa
decl_stmt|;
name|struct
name|agtiapi_softc
modifier|*
name|pCard
decl_stmt|;
name|pCard
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ag_card_info_t
modifier|*
name|pCardInfo
init|=
name|pCard
operator|->
name|pCardInfo
decl_stmt|;
name|ag_resource_info_t
modifier|*
name|pRscInfo
init|=
operator|&
name|thisCardInst
operator|->
name|tiRscInfo
decl_stmt|;
name|AG_GLOBAL_ARG
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_ReleaseHBA: start\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|thisCardInst
operator|!=
name|pCardInfo
condition|)
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_ReleaseHBA: Wrong ag_card_info_t thisCardInst %p "
literal|"pCardInfo %p\n"
argument_list|,
name|thisCardInst
argument_list|,
name|pCardInfo
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"agtiapi_ReleaseHBA: Wrong ag_card_info_t thisCardInst %p pCardInfo "
literal|"%p\n"
argument_list|,
name|thisCardInst
argument_list|,
name|pCardInfo
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_ReleaseHBA card %p\n"
argument_list|,
name|pCard
argument_list|)
expr_stmt|;
name|pCard
operator|->
name|flags
operator||=
name|AGTIAPI_SHUT_DOWN
expr_stmt|;
comment|// remove timer
if|if
condition|(
name|pCard
operator|->
name|flags
operator|&
name|AGTIAPI_TIMER_ON
condition|)
block|{
name|AG_SPIN_LOCK_IRQ
argument_list|(
name|agtiapi_host_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|pCard
operator|->
name|OS_timer
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|pCard
operator|->
name|devRmTimer
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|pCard
operator|->
name|IO_timer
argument_list|)
expr_stmt|;
name|AG_SPIN_UNLOCK_IRQ
argument_list|(
name|agtiapi_host_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_ReleaseHBA: timer released\n"
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|HIALEAH_ENCRYPTION
comment|//Release encryption table memory - Fix it
comment|//if(pCard->encrypt&& (pCard->flags& AGTIAPI_INSTALLED))
comment|//agtiapi_CleanupEncryption(pCard);
endif|#
directive|endif
comment|/*    * Shutdown the channel so that chip gets frozen    * and it does not do any more pci-bus accesses.    */
if|if
condition|(
name|pCard
operator|->
name|flags
operator|&
name|AGTIAPI_SYS_INTR_ON
condition|)
block|{
name|tiCOMSystemInterruptsActive
argument_list|(
operator|&
name|pCard
operator|->
name|tiRoot
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|pCard
operator|->
name|flags
operator|&=
operator|~
name|AGTIAPI_SYS_INTR_ON
expr_stmt|;
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_ReleaseHBA: card interrupt off\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pCard
operator|->
name|flags
operator|&
name|AGTIAPI_INSTALLED
condition|)
block|{
name|tiCOMShutDown
argument_list|(
operator|&
name|pCard
operator|->
name|tiRoot
argument_list|)
expr_stmt|;
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_ReleaseHBA: low layers shutdown\n"
argument_list|)
expr_stmt|;
block|}
comment|/*     * first release IRQ, so that we do not get any more interrupts    * from this host    */
if|if
condition|(
name|pCard
operator|->
name|flags
operator|&
name|AGTIAPI_IRQ_REQUESTED
condition|)
block|{
if|if
condition|(
operator|!
name|agtiapi_intx_mode
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_MSIX_NUM_VECTOR
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pCard
operator|->
name|irq
index|[
name|i
index|]
operator|!=
name|agNULL
operator|&&
name|pCard
operator|->
name|rscID
index|[
name|i
index|]
operator|!=
literal|0
condition|)
block|{
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|pCard
operator|->
name|irq
index|[
name|i
index|]
argument_list|,
name|pCard
operator|->
name|intrcookie
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|pCard
operator|->
name|rscID
index|[
name|i
index|]
argument_list|,
name|pCard
operator|->
name|irq
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|pci_release_msi
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
name|pCard
operator|->
name|flags
operator|&=
operator|~
name|AGTIAPI_IRQ_REQUESTED
expr_stmt|;
ifdef|#
directive|ifdef
name|AGTIAPI_DPC
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_MSIX_NUM_DPC
condition|;
name|i
operator|++
control|)
name|tasklet_kill
argument_list|(
operator|&
name|pCard
operator|->
name|tasklet_dpc
index|[
name|i
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_ReleaseHBA: IRQ released\n"
argument_list|)
expr_stmt|;
block|}
comment|// release memory vs. alloc in agtiapi_alloc_ostimem; used in ostiAllocMemory
if|if
condition|(
name|pCard
operator|->
name|osti_busaddr
operator|!=
literal|0
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|pCard
operator|->
name|osti_dmat
argument_list|,
name|pCard
operator|->
name|osti_mapp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pCard
operator|->
name|osti_mem
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamem_free
argument_list|(
name|pCard
operator|->
name|osti_dmat
argument_list|,
name|pCard
operator|->
name|osti_mem
argument_list|,
name|pCard
operator|->
name|osti_mapp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pCard
operator|->
name|osti_dmat
operator|!=
name|NULL
condition|)
block|{
name|bus_dma_tag_destroy
argument_list|(
name|pCard
operator|->
name|osti_dmat
argument_list|)
expr_stmt|;
block|}
comment|/* unmap the mapped PCI memory */
comment|/* calls bus_release_resource( ,SYS_RES_MEMORY, ..) */
name|agtiapi_ReleasePCIMem
argument_list|(
name|thisCardInst
argument_list|)
expr_stmt|;
comment|/* release all ccbs */
if|if
condition|(
name|pCard
operator|->
name|ccbTotal
condition|)
block|{
comment|//calls bus_dmamap_destroy() for all pccbs
name|agtiapi_ReleaseCCBs
argument_list|(
name|pCard
argument_list|)
expr_stmt|;
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_ReleaseHBA: CCB released\n"
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|HIALEAH_ENCRYPTION
comment|/*release encryption resources - Fix it*/
if|if
condition|(
name|pCard
operator|->
name|encrypt
condition|)
block|{
comment|/*Check that all IO's are completed */
if|if
condition|(
name|atomic_read
argument_list|(
operator|&
name|outstanding_encrypted_io_count
argument_list|)
operator|>
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: WARNING: %d outstanding encrypted IOs !\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|atomic_read
argument_list|(
operator|&
name|outstanding_encrypted_io_count
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|//agtiapi_CleanupEncryptionPools(pCard);
block|}
endif|#
directive|endif
comment|/* release device list */
if|if
condition|(
name|pCard
operator|->
name|pDevList
condition|)
block|{
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|pCard
operator|->
name|pDevList
argument_list|,
name|M_PMC_MDVT
argument_list|)
expr_stmt|;
name|pCard
operator|->
name|pDevList
operator|=
name|NULL
expr_stmt|;
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_ReleaseHBA: device list released\n"
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|LINUX_PERBI_SUPPORT
comment|// ## review use of PERBI
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_ReleaseHBA: WWN list %p \n"
argument_list|,
name|pCard
operator|->
name|pWWNList
argument_list|)
expr_stmt|;
if|if
condition|(
name|pCard
operator|->
name|pWWNList
condition|)
block|{
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|pCard
operator|->
name|pWWNList
argument_list|,
name|M_PMC_MTGT
argument_list|)
expr_stmt|;
name|pCard
operator|->
name|pWWNList
operator|=
name|NULL
expr_stmt|;
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_ReleaseHBA: WWN list released\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pCard
operator|->
name|pSLRList
condition|)
block|{
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|pCard
operator|->
name|pSLRList
argument_list|,
name|M_PMC_MSLR
argument_list|)
expr_stmt|;
name|pCard
operator|->
name|pSLRList
operator|=
name|NULL
expr_stmt|;
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_ReleaseHBA: SAS Local Remote list released\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|pCard
operator|->
name|pPortalData
condition|)
block|{
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|pCard
operator|->
name|pPortalData
argument_list|,
name|M_PMC_MPRT
argument_list|)
expr_stmt|;
name|pCard
operator|->
name|pPortalData
operator|=
name|NULL
expr_stmt|;
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_ReleaseHBA: PortalData released\n"
argument_list|)
expr_stmt|;
block|}
comment|//calls contigfree() or free()
name|agtiapi_MemFree
argument_list|(
name|pCardInfo
argument_list|)
expr_stmt|;
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_ReleaseHBA: low level resource released\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HOTPLUG_SUPPORT
if|if
condition|(
name|pCard
operator|->
name|flags
operator|&
name|AGTIAPI_PORT_INITIALIZED
condition|)
block|{
comment|//    agtiapi_FreeDevWorkList(pCard);
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_ReleaseHBA: (HP dev) work resources released\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/*     * TBD, scsi_unregister may release wrong host data structure    * which cause NULL pointer shows up.      */
if|if
condition|(
name|pCard
operator|->
name|flags
operator|&
name|AGTIAPI_SCSI_REGISTERED
condition|)
block|{
name|pCard
operator|->
name|flags
operator|&=
operator|~
name|AGTIAPI_SCSI_REGISTERED
expr_stmt|;
ifdef|#
directive|ifdef
name|AGTIAPI_LOCAL_LOCK
if|if
condition|(
name|pCard
operator|->
name|STLock
condition|)
block|{
comment|//destroy mtx
name|int
name|maxLocks
decl_stmt|;
name|maxLocks
operator|=
name|pRscInfo
operator|->
name|tiLoLevelResource
operator|.
name|loLevelOption
operator|.
name|numOfQueuesPerPort
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|maxLocks
condition|;
name|i
operator|++
control|)
block|{
name|mtx_destroy
argument_list|(
operator|&
name|pCard
operator|->
name|STLock
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|pCard
operator|->
name|STLock
argument_list|,
name|M_PMC_MSTL
argument_list|)
expr_stmt|;
name|pCard
operator|->
name|STLock
operator|=
name|NULL
expr_stmt|;
block|}
endif|#
directive|endif
block|}
name|ag_card_good
operator|--
expr_stmt|;
comment|/* reset agtiapi_1st_time if this is the only card */
if|if
condition|(
operator|!
name|ag_card_good
operator|&&
operator|!
name|agtiapi_1st_time
condition|)
block|{
name|agtiapi_1st_time
operator|=
literal|1
expr_stmt|;
block|}
comment|/* for tiSgl_t memeory */
if|if
condition|(
name|pCard
operator|->
name|tisgl_busaddr
operator|!=
literal|0
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|pCard
operator|->
name|tisgl_dmat
argument_list|,
name|pCard
operator|->
name|tisgl_map
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pCard
operator|->
name|tisgl_mem
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamem_free
argument_list|(
name|pCard
operator|->
name|tisgl_dmat
argument_list|,
name|pCard
operator|->
name|tisgl_mem
argument_list|,
name|pCard
operator|->
name|tisgl_map
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pCard
operator|->
name|tisgl_dmat
operator|!=
name|NULL
condition|)
block|{
name|bus_dma_tag_destroy
argument_list|(
name|pCard
operator|->
name|tisgl_dmat
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pCard
operator|->
name|buffer_dmat
operator|!=
name|agNULL
condition|)
block|{
name|bus_dma_tag_destroy
argument_list|(
name|pCard
operator|->
name|buffer_dmat
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pCard
operator|->
name|sim
operator|!=
name|NULL
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|thisCardInst
operator|->
name|pmIOLock
argument_list|)
expr_stmt|;
name|xpt_setup_ccb
argument_list|(
operator|&
name|csa
operator|.
name|ccb_h
argument_list|,
name|pCard
operator|->
name|path
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|csa
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_SASYNC_CB
expr_stmt|;
name|csa
operator|.
name|event_enable
operator|=
literal|0
expr_stmt|;
name|csa
operator|.
name|callback
operator|=
name|agtiapi_async
expr_stmt|;
name|csa
operator|.
name|callback_arg
operator|=
name|pCard
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
operator|&
name|csa
argument_list|)
expr_stmt|;
name|xpt_free_path
argument_list|(
name|pCard
operator|->
name|path
argument_list|)
expr_stmt|;
comment|//   if (pCard->ccbTotal == 0)
if|if
condition|(
name|pCard
operator|->
name|ccbTotal
operator|<=
name|thisCard
condition|)
block|{
comment|/*         no link up so that simq has not been released.         In order to remove cam, we call this.       */
name|xpt_release_simq
argument_list|(
name|pCard
operator|->
name|sim
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|xpt_bus_deregister
argument_list|(
name|cam_sim_path
argument_list|(
name|pCard
operator|->
name|sim
argument_list|)
argument_list|)
expr_stmt|;
name|cam_sim_free
argument_list|(
name|pCard
operator|->
name|sim
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|thisCardInst
operator|->
name|pmIOLock
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pCard
operator|->
name|devq
operator|!=
name|NULL
condition|)
block|{
name|cam_simq_free
argument_list|(
name|pCard
operator|->
name|devq
argument_list|)
expr_stmt|;
block|}
comment|//destroy mtx
name|mtx_destroy
argument_list|(
operator|&
name|thisCardInst
operator|->
name|pmIOLock
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|pCard
operator|->
name|sendLock
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|pCard
operator|->
name|doneLock
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|pCard
operator|->
name|sendSMPLock
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|pCard
operator|->
name|doneSMPLock
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|pCard
operator|->
name|ccbLock
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|pCard
operator|->
name|devListLock
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|pCard
operator|->
name|OS_timer_lock
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|pCard
operator|->
name|devRmTimerLock
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|pCard
operator|->
name|memLock
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|pCard
operator|->
name|freezeLock
argument_list|)
expr_stmt|;
name|destroy_dev
argument_list|(
name|pCard
operator|->
name|my_cdev
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|void
operator|*
operator|)
name|pCardInfo
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ag_card_info_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|// Called during system shutdown after sync
end_comment

begin_function
specifier|static
name|int
name|agtiapi_shutdown
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_shutdown\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|agtiapi_suspend
parameter_list|(
name|device_t
name|dev
parameter_list|)
comment|// Device suspend routine.
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_suspend\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|agtiapi_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
comment|// Device resume routine.
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_resume\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|agtiapi_methods
index|[]
init|=
block|{
comment|// Device interface
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|agtiapi_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|agtiapi_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|agtiapi_ReleaseHBA
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|agtiapi_shutdown
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|agtiapi_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|agtiapi_resume
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|pmspcv_devclass
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|pmspcv_driver
init|=
block|{
literal|"pmspcv"
block|,
name|agtiapi_methods
block|,
expr|sizeof
operator|(
expr|struct
name|agtiapi_softc
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|pmspcv
argument_list|,
name|pci
argument_list|,
name|pmspcv_driver
argument_list|,
name|pmspcv_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|pmspcv
argument_list|,
name|cam
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|pmspcv
argument_list|,
name|pci
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<dev/pms/freebsd/driver/common/lxosapi.c>
end_include

begin_include
include|#
directive|include
file|<dev/pms/freebsd/driver/ini/src/osapi.c>
end_include

begin_include
include|#
directive|include
file|<dev/pms/freebsd/driver/common/lxutil.c>
end_include

begin_include
include|#
directive|include
file|<dev/pms/freebsd/driver/common/lxencrypt.c>
end_include

end_unit

