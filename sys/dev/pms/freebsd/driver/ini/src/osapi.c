begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************************* *Copyright (c) 2014 PMC-Sierra, Inc.  All rights reserved.  * *Redistribution and use in source and binary forms, with or without modification, are permitted provided  *that the following conditions are met:  *1. Redistributions of source code must retain the above copyright notice, this list of conditions and the *following disclaimer.  *2. Redistributions in binary form must reproduce the above copyright notice,  *this list of conditions and the following disclaimer in the documentation and/or other materials provided *with the distribution.  * *THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR IMPLIED  *WARRANTIES,INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS *FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE *FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  *NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR  *BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  *LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  *SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE * * $FreeBSD$ * *******************************************************************************/
end_comment

begin_comment
comment|/****************************************************************************** PMC-Sierra TISA Initiator Device Driver for Linux 2.x.x.  Module Name:     osapi.c Abstract:     Linux iSCSI/FC Initiator driver module itsdk required OS functions Environment:     Part of oslayer module, Kernel or loadable module    ******************************************************************************* ostiInitiatorEvent()  Purpose:   TI layer call back to OSlayer to inform events  Parameters:    tiRoot_t *ptiRoot (IN)               Pointer to HBA data structure     tiDeviceHandle_t *ptiDevHandle (IN)  Pointer to device handle   tiIntrEvenType_t evenType (IN)       Event type   tiIntrEventStatus_t evetStatus (IN)  Event status   void *parm (IN)                      pointer to even specific data Return: Note:       TBD, further event process required. ******************************************************************************/
end_comment

begin_function
name|void
name|ostiInitiatorEvent
parameter_list|(
name|tiRoot_t
modifier|*
name|ptiRoot
parameter_list|,
name|tiPortalContext_t
modifier|*
name|ptiPortalContext
parameter_list|,
name|tiDeviceHandle_t
modifier|*
name|ptiDevHandle
parameter_list|,
name|tiIntrEventType_t
name|eventType
parameter_list|,
name|U32
name|eventStatus
parameter_list|,
name|void
modifier|*
name|parm
parameter_list|)
block|{
name|ag_portal_data_t
modifier|*
name|pPortalData
decl_stmt|;
name|ag_portal_info_t
modifier|*
name|pPortalInfo
decl_stmt|;
name|struct
name|agtiapi_softc
modifier|*
name|pCard
init|=
name|TIROOT_TO_CARD
argument_list|(
name|ptiRoot
argument_list|)
decl_stmt|;
name|ccb_t
modifier|*
name|pccb
decl_stmt|;
name|ccb_t
modifier|*
name|pTMccb
decl_stmt|;
name|ccb_t
modifier|*
name|ccbIO
decl_stmt|;
ifdef|#
directive|ifdef
name|AGTIAPI_EVENT_LOG
name|AGTIAPI_PRINTK
argument_list|(
literal|"Initiator Event:\n"
argument_list|)
expr_stmt|;
name|AGTIAPI_PRINTK
argument_list|(
literal|"DevHandle %p, eventType 0x%x, eventStatus 0x%x\n"
argument_list|,
name|ptiDevHandle
argument_list|,
name|eventType
argument_list|,
name|eventStatus
argument_list|)
expr_stmt|;
name|AGTIAPI_PRINTK
argument_list|(
literal|"Parameter: %s\n"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|parm
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|AGTIAPI_PRINTK
argument_list|(
literal|"ostiInitiatorEvent: eventType 0x%x eventStatus 0x%x\n"
argument_list|,
name|eventType
argument_list|,
name|eventStatus
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|eventType
condition|)
block|{
case|case
name|tiIntrEventTypeCnxError
case|:
if|if
condition|(
name|eventStatus
operator|==
name|tiCnxUp
condition|)
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"tiIntrEventTypeCnxError - tiCnxUp!\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|eventStatus
operator|==
name|tiCnxDown
condition|)
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"tiIntrEventTypeCnxError - tiCnxDown!\n"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|tiIntrEventTypeDiscovery
case|:
name|pPortalData
operator|=
name|PORTAL_CONTEXT_TO_PORTALDATA
argument_list|(
name|ptiPortalContext
argument_list|)
expr_stmt|;
name|pCard
operator|->
name|flags
operator||=
name|AGTIAPI_CB_DONE
expr_stmt|;
if|if
condition|(
name|eventStatus
operator|==
name|tiDiscOK
condition|)
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"eventStatus - tiDiscOK\n"
argument_list|)
expr_stmt|;
name|AGTIAPI_PRINTK
argument_list|(
literal|"ostiInitiatorEvent: pcard %d eventStatus - tiDiscOK\n"
argument_list|,
name|pCard
operator|->
name|cardNo
argument_list|)
expr_stmt|;
name|PORTAL_STATUS
argument_list|(
name|pPortalData
argument_list|)
operator||=
name|AGTIAPI_DISC_COMPLETE
expr_stmt|;
ifndef|#
directive|ifndef
name|HOTPLUG_SUPPORT
if|if
condition|(
operator|!
operator|(
name|pCard
operator|->
name|flags
operator|&
name|AGTIAPI_INIT_TIME
operator|)
condition|)
else|#
directive|else
if|if
condition|(
name|TRUE
condition|)
endif|#
directive|endif
block|{
name|agtiapi_GetDevHandle
argument_list|(
name|pCard
argument_list|,
operator|&
name|pPortalData
operator|->
name|portalInfo
argument_list|,
name|tiIntrEventTypeDiscovery
argument_list|,
name|tiDiscOK
argument_list|)
expr_stmt|;
name|PORTAL_STATUS
argument_list|(
name|pPortalData
argument_list|)
operator||=
operator|(
name|AGTIAPI_DISC_DONE
operator||
name|AGTIAPI_PORT_LINK_UP
operator|)
expr_stmt|;
block|}
comment|/* Trigger CheckIOTimeout */
name|callout_reset
argument_list|(
operator|&
name|pCard
operator|->
name|IO_timer
argument_list|,
literal|20
operator|*
name|hz
argument_list|,
name|agtiapi_CheckIOTimeout
argument_list|,
name|pCard
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|eventStatus
operator|==
name|tiDiscFailed
condition|)
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"eventStatus - tiDiscFailed\n"
argument_list|)
expr_stmt|;
name|agtiapi_GetDevHandle
argument_list|(
name|pCard
argument_list|,
operator|&
name|pPortalData
operator|->
name|portalInfo
argument_list|,
name|tiIntrEventTypeDiscovery
argument_list|,
name|tiDiscFailed
argument_list|)
expr_stmt|;
name|PORTAL_STATUS
argument_list|(
name|pPortalData
argument_list|)
operator|&=
operator|~
name|AGTIAPI_DISC_DONE
expr_stmt|;
block|}
name|AGTIAPI_PRINTK
argument_list|(
literal|"tiIntrEventTypeDiscovery - portal %p, status 0x%x\n"
argument_list|,
name|pPortalData
argument_list|,
name|PORTAL_STATUS
argument_list|(
name|pPortalData
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|tiIntrEventTypeDeviceChange
case|:
name|AGTIAPI_PRINTK
argument_list|(
literal|"tiIntrEventTypeDeviceChange - portal %p es %d\n"
argument_list|,
name|ptiPortalContext
operator|->
name|osData
argument_list|,
name|eventStatus
argument_list|)
expr_stmt|;
name|pPortalData
operator|=
name|PORTAL_CONTEXT_TO_PORTALDATA
argument_list|(
name|ptiPortalContext
argument_list|)
expr_stmt|;
name|pPortalInfo
operator|=
operator|&
name|pPortalData
operator|->
name|portalInfo
expr_stmt|;
ifndef|#
directive|ifndef
name|HOTPLUG_SUPPORT
if|if
condition|(
operator|!
operator|(
name|pCard
operator|->
name|flags
operator|&
name|AGTIAPI_INIT_TIME
operator|)
condition|)
else|#
directive|else
if|if
condition|(
name|TRUE
condition|)
endif|#
directive|endif
block|{
name|agtiapi_GetDevHandle
argument_list|(
name|pCard
argument_list|,
name|pPortalInfo
argument_list|,
name|tiIntrEventTypeDeviceChange
argument_list|,
name|eventStatus
argument_list|)
expr_stmt|;
comment|//         agtiapi_StartIO(pCard);
block|}
break|break;
case|case
name|tiIntrEventTypeTransportRecovery
case|:
name|AGTIAPI_PRINTK
argument_list|(
literal|"tiIntrEventTypeTransportRecovery!\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|tiIntrEventTypeTaskManagement
case|:
name|AGTIAPI_PRINTK
argument_list|(
literal|"tiIntrEventTypeTaskManagement!\n"
argument_list|)
expr_stmt|;
name|pccb
operator|=
call|(
name|pccb_t
call|)
argument_list|(
operator|(
name|tiIORequest_t
operator|*
operator|)
name|parm
argument_list|)
operator|->
name|osData
expr_stmt|;
if|if
condition|(
name|pccb
operator|->
name|flags
operator|&
name|TASK_TIMEOUT
condition|)
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"tiIntrEventTypeTaskManagement: TM timeout!\n"
argument_list|)
expr_stmt|;
name|agtiapi_FreeTMCCB
argument_list|(
name|pCard
argument_list|,
name|pccb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pccb
operator|->
name|flags
operator||=
name|AGTIAPI_CB_DONE
expr_stmt|;
if|if
condition|(
name|eventStatus
operator|==
name|tiTMOK
condition|)
block|{
name|pccb
operator|->
name|flags
operator||=
name|TASK_SUCCESS
expr_stmt|;
name|AGTIAPI_PRINTK
argument_list|(
literal|"tiIntrEventTypeTaskManagement: pTMccb %p flag %x \n"
argument_list|,
name|pccb
argument_list|,
name|pccb
operator|->
name|flags
argument_list|)
expr_stmt|;
comment|/* Incase of TM_DEV_RESET, issue LocalAbort to abort pending IO */
if|if
condition|(
name|pccb
operator|->
name|flags
operator|&
name|DEV_RESET
condition|)
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"tiIntrEventTypeTaskManagement: Target Reset\n"
argument_list|)
expr_stmt|;
name|ccbIO
operator|=
name|pccb
operator|->
name|pccbIO
expr_stmt|;
name|AGTIAPI_PRINTK
argument_list|(
literal|"tiIntrEventTypeTaskManagement: IO to be aborted locally %p flag %x \n"
argument_list|,
name|ccbIO
argument_list|,
name|ccbIO
operator|->
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccbIO
operator|->
name|startTime
operator|==
literal|0
condition|)
comment|/* IO has been completed. No local abort */
block|{                }
elseif|else
if|if
condition|(
name|tiINIIOAbort
argument_list|(
operator|&
name|pCard
operator|->
name|tiRoot
argument_list|,
operator|&
name|ccbIO
operator|->
name|tiIORequest
argument_list|)
operator|!=
name|tiSuccess
condition|)
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"tiIntrEventTypeTaskManagement: Local Abort failed\n"
argument_list|)
expr_stmt|;
comment|/* TODO: call Soft reset here */
block|}
block|}
elseif|else
if|if
condition|(
name|eventStatus
operator|==
name|tiTMFailed
condition|)
block|{
name|ccbIO
operator|=
name|pccb
operator|->
name|pccbIO
expr_stmt|;
if|if
condition|(
name|ccbIO
operator|->
name|startTime
operator|==
literal|0
condition|)
comment|/* IO has been completed. */
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"tiIntrEventTypeTaskManagement: TM failed because IO has been completed! pTMccb %p flag %x \n"
argument_list|,
name|pccb
argument_list|,
name|pccb
operator|->
name|flags
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"tiIntrEventTypeTaskManagement: TM failed! pTMccb %p flag %x \n"
argument_list|,
name|pccb
argument_list|,
name|pccb
operator|->
name|flags
argument_list|)
expr_stmt|;
comment|/* TODO:*/
comment|/* if TM_ABORT_TASK, call TM_TARGET_RESET */
comment|/* if TM_TARGET_RESET, call Soft_Reset */
block|}
block|}
comment|/* Free TM_DEV_RESET ccb */
name|agtiapi_FreeTMCCB
argument_list|(
name|pCard
argument_list|,
name|pccb
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|tiIntrEventTypeLocalAbort
case|:
name|AGTIAPI_PRINTK
argument_list|(
literal|"tiIntrEventTypeLocalAbort!\n"
argument_list|)
expr_stmt|;
name|pccb
operator|=
call|(
name|pccb_t
call|)
argument_list|(
operator|(
name|tiIORequest_t
operator|*
operator|)
name|parm
argument_list|)
operator|->
name|osData
expr_stmt|;
name|pccb
operator|->
name|flags
operator||=
name|AGTIAPI_CB_DONE
expr_stmt|;
if|if
condition|(
name|eventStatus
operator|==
name|tiAbortOK
condition|)
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"tiIntrEventTypeLocalAbort: taskTag pccb %p flag %x \n"
argument_list|,
name|pccb
argument_list|,
name|pccb
operator|->
name|flags
argument_list|)
expr_stmt|;
comment|/* If this was LocalAbort for TM ABORT_TASK, issue TM_DEV_RESET */
if|if
condition|(
name|pccb
operator|->
name|flags
operator|&
name|TASK_MANAGEMENT
condition|)
block|{
if|if
condition|(
operator|(
name|pTMccb
operator|=
name|agtiapi_GetCCB
argument_list|(
name|pCard
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"tiIntrEventTypeLocalAbort: TM resource unavailable!\n"
argument_list|)
expr_stmt|;
comment|/* TODO: SoftReset here? */
block|}
name|pTMccb
operator|->
name|pmcsc
operator|=
name|pCard
expr_stmt|;
name|pTMccb
operator|->
name|targetId
operator|=
name|pccb
operator|->
name|targetId
expr_stmt|;
name|pTMccb
operator|->
name|devHandle
operator|=
name|pccb
operator|->
name|devHandle
expr_stmt|;
comment|/* save pending io to issue local abort at Task mgmt CB */
name|pTMccb
operator|->
name|pccbIO
operator|=
name|pccb
operator|->
name|pccbIO
expr_stmt|;
name|pTMccb
operator|->
name|flags
operator|&=
operator|~
operator|(
name|TASK_SUCCESS
operator||
name|ACTIVE
operator|)
expr_stmt|;
name|pTMccb
operator|->
name|flags
operator||=
name|DEV_RESET
expr_stmt|;
if|if
condition|(
name|tiINITaskManagement
argument_list|(
operator|&
name|pCard
operator|->
name|tiRoot
argument_list|,
name|pccb
operator|->
name|devHandle
argument_list|,
name|AG_TARGET_WARM_RESET
argument_list|,
operator|&
name|pccb
operator|->
name|tiSuperScsiRequest
operator|.
name|scsiCmnd
operator|.
name|lun
argument_list|,
operator|&
name|pccb
operator|->
name|tiIORequest
argument_list|,
operator|&
name|pTMccb
operator|->
name|tiIORequest
argument_list|)
operator|==
name|tiSuccess
condition|)
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"tiIntrEventTypeLocalAbort: TM_TARGET_RESET request success ccb %p, pTMccb %p\n"
argument_list|,
name|pccb
argument_list|,
name|pTMccb
argument_list|)
expr_stmt|;
name|pTMccb
operator|->
name|startTime
operator|=
name|ticks
expr_stmt|;
block|}
else|else
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"tiIntrEventTypeLocalAbort: TM_TARGET_RESET request failed ccb %p, pTMccb %p\n"
argument_list|,
name|pccb
argument_list|,
name|pTMccb
argument_list|)
expr_stmt|;
name|agtiapi_FreeTMCCB
argument_list|(
name|pCard
argument_list|,
name|pTMccb
argument_list|)
expr_stmt|;
comment|/* TODO: SoftReset here? */
block|}
comment|/* Free ABORT_TASK TM ccb */
name|agtiapi_FreeTMCCB
argument_list|(
name|pCard
argument_list|,
name|pccb
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|eventStatus
operator|==
name|tiAbortFailed
condition|)
block|{
comment|/* TODO: */
comment|/* If TM_ABORT_TASK fails, issue TM_DEV_RESET */
comment|/* if TM_DEV_RESET fails, issue Soft_Reset */
name|AGTIAPI_PRINTK
argument_list|(
literal|"tiIntrEventTypeLocalAbort: Abort Failed pccb %p\n"
argument_list|,
name|pccb
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|AGTIAPI_PRINTK
argument_list|(
literal|"tiIntrEventType default!\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/****************************************************************************** ostiInitiatorIOCompleted()  Purpose:   IO request completion call back  Parameters:   tiRoot_t *ptiRoot (IN)               Pointer to the HBA tiRoot   tiIORequest_t *ptiIORequest (IN)     Pointer to the tiIORequest structure   tiIOStatus_t IOStatus (IN)           I/O complated status     U32 statusDetail (IN)                Additional information on status   tiSenseData_t *pSensedata (IN)       Sense data buffer pointer   U32 context (IN)                     Interrupt dealing context Returns: Note: ******************************************************************************/
end_comment

begin_function
name|void
name|ostiInitiatorIOCompleted
parameter_list|(
name|tiRoot_t
modifier|*
name|ptiRoot
parameter_list|,
name|tiIORequest_t
modifier|*
name|ptiIORequest
parameter_list|,
name|tiIOStatus_t
name|IOStatus
parameter_list|,
name|U32
name|statusDetail
parameter_list|,
name|tiSenseData_t
modifier|*
name|pSenseData
parameter_list|,
name|U32
name|context
parameter_list|)
block|{
name|struct
name|agtiapi_softc
modifier|*
name|pCard
decl_stmt|;
name|ccb_t
modifier|*
name|pccb
decl_stmt|;
name|pCard
operator|=
name|TIROOT_TO_CARD
argument_list|(
name|ptiRoot
argument_list|)
expr_stmt|;
name|pccb
operator|=
operator|(
name|ccb_t
operator|*
operator|)
name|ptiIORequest
operator|->
name|osData
expr_stmt|;
name|AGTIAPI_IO
argument_list|(
literal|"ostiInitiatorIOCompleted: start\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|IOStatus
operator|==
name|tiIODifError
condition|)
block|{
return|return;
block|}
name|OSTI_OUT_ENTER
argument_list|(
name|ptiRoot
argument_list|)
expr_stmt|;
name|pccb
operator|->
name|ccbStatus
operator|=
operator|(
name|U16
operator|)
name|IOStatus
expr_stmt|;
name|pccb
operator|->
name|scsiStatus
operator|=
name|statusDetail
expr_stmt|;
if|if
condition|(
operator|(
name|IOStatus
operator|==
name|tiIOSuccess
operator|)
operator|&&
operator|(
name|statusDetail
operator|==
name|SCSI_CHECK_CONDITION
operator|)
condition|)
block|{
if|if
condition|(
name|pSenseData
operator|==
operator|(
name|tiSenseData_t
operator|*
operator|)
name|agNULL
condition|)
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"ostiInitiatorIOCompleted: "
literal|"check condition without sense data!\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|union
name|ccb
modifier|*
name|ccb
init|=
name|pccb
operator|->
name|ccb
decl_stmt|;
name|struct
name|ccb_scsiio
modifier|*
name|csio
init|=
operator|&
name|ccb
operator|->
name|csio
decl_stmt|;
name|int
name|sense_len
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|pccb
operator|->
name|senseLen
operator|>
name|pSenseData
operator|->
name|senseLen
condition|)
block|{
name|csio
operator|->
name|sense_resid
operator|=
name|pccb
operator|->
name|senseLen
operator|-
name|pSenseData
operator|->
name|senseLen
expr_stmt|;
block|}
else|else
block|{
name|csio
operator|->
name|sense_resid
operator|=
literal|0
expr_stmt|;
block|}
name|sense_len
operator|=
name|MIN
argument_list|(
name|pSenseData
operator|->
name|senseLen
argument_list|,
name|pccb
operator|->
name|senseLen
operator|-
name|csio
operator|->
name|sense_resid
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|csio
operator|->
name|sense_data
argument_list|,
sizeof|sizeof
argument_list|(
name|csio
operator|->
name|sense_data
argument_list|)
argument_list|)
expr_stmt|;
name|AGTIAPI_PRINTK
argument_list|(
literal|"ostiInitiatorIOCompleted: check condition copying\n"
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|void
operator|*
operator|)
name|pccb
operator|->
name|pSenseData
argument_list|,
name|pSenseData
operator|->
name|senseData
argument_list|,
name|sense_len
argument_list|)
expr_stmt|;
name|agtiapi_hexdump
argument_list|(
literal|"ostiInitiatorIOCompleted check condition"
argument_list|,
operator|(
name|bit8
operator|*
operator|)
operator|&
name|csio
operator|->
name|sense_data
argument_list|,
name|sense_len
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|IOStatus
operator|==
name|tiIOFailed
operator|)
operator|&&
operator|(
name|statusDetail
operator|==
name|tiDetailAborted
operator|)
condition|)
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"ostiInitiatorIOCompleted - aborted ccb %p, flag %x\n"
argument_list|,
name|pccb
argument_list|,
name|pccb
operator|->
name|flags
argument_list|)
expr_stmt|;
comment|/* indicate aborted IO completion */
name|pccb
operator|->
name|startTime
operator|=
literal|0
expr_stmt|;
name|agtiapi_Done
argument_list|(
name|pCard
argument_list|,
name|pccb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|AGTIAPI_SA
comment|/*       * SAS no data command does not trigger interrupt.      * Command is completed in tdlayer and IO completion is called directly.      * The completed IO therefore is not post processed.      * Flag is raised and TDTimer will check and process IO for SAS.      * This is a temporary solution. - Eddie, 07-17-2006      */
name|pCard
operator|->
name|flags
operator||=
name|AGTIAPI_FLAG_UP
expr_stmt|;
endif|#
directive|endif
name|pccb
operator|->
name|flags
operator||=
name|REQ_DONE
expr_stmt|;
name|agtiapi_QueueCCB
argument_list|(
argument|pCard
argument_list|,
argument|&pCard->ccbDoneHead
argument_list|,
argument|&pCard->ccbDoneTail                      AG_CARD_LOCAL_LOCK(&pCard->doneLock)
argument_list|,
argument|pccb
argument_list|)
empty_stmt|;
block|}
name|OSTI_OUT_LEAVE
argument_list|(
name|ptiRoot
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|HIALEAH_ENCRYPTION
end_ifdef

begin_function
name|osGLOBAL
name|void
name|ostidisableEncryption
parameter_list|(
name|tiRoot_t
modifier|*
name|ptiRoot
parameter_list|)
block|{
name|struct
name|agtiapi_softc
modifier|*
name|pCard
decl_stmt|;
name|pCard
operator|=
name|TIROOT_TO_CARD
argument_list|(
name|ptiRoot
argument_list|)
expr_stmt|;
name|pCard
operator|->
name|encrypt
operator|=
name|agFALSE
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* device Handle */
end_comment

begin_function
name|osGLOBAL
comment|//FORCEINLINE
name|tiDeviceHandle_t
modifier|*
name|ostiGetDevHandleFromSasAddr
parameter_list|(
name|tiRoot_t
modifier|*
name|root
parameter_list|,
name|unsigned
name|char
modifier|*
name|sas_addr
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|unsigned
name|long
name|x
decl_stmt|;
name|ag_portal_data_t
modifier|*
name|pPortal
init|=
name|NULL
decl_stmt|;
name|tiDeviceHandle_t
modifier|*
name|devHandle
init|=
name|NULL
decl_stmt|;
name|struct
name|agtiapi_softc
modifier|*
name|pCard
init|=
name|TIROOT_TO_CARD
argument_list|(
name|root
argument_list|)
decl_stmt|;
name|bit8
name|sas_addr_hi
index|[
literal|4
index|]
decl_stmt|,
name|sas_addr_lo
index|[
literal|4
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|sas_addr_hi
index|[
name|i
index|]
operator|=
name|sas_addr
index|[
literal|3
operator|-
name|i
index|]
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|sas_addr_lo
index|[
name|i
index|]
operator|=
name|sas_addr
index|[
literal|7
operator|-
name|i
index|]
expr_stmt|;
block|}
comment|/* Retrieve the handles for each portal */
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|pCard
operator|->
name|portCount
condition|;
name|x
operator|++
control|)
block|{
name|pPortal
operator|=
operator|&
name|pCard
operator|->
name|pPortalData
index|[
name|x
index|]
expr_stmt|;
name|devHandle
operator|=
name|tiINIGetExpDeviceHandleBySasAddress
argument_list|(
operator|&
name|pCard
operator|->
name|tiRoot
argument_list|,
operator|&
name|pPortal
operator|->
name|portalInfo
operator|.
name|tiPortalContext
argument_list|,
operator|*
operator|(
name|bit32
operator|*
operator|)
name|sas_addr_hi
argument_list|,
operator|*
operator|(
name|bit32
operator|*
operator|)
name|sas_addr_lo
argument_list|,
operator|(
name|bit32
operator|)
literal|1024
comment|/*gMaxTargets*/
argument_list|)
expr_stmt|;
if|if
condition|(
name|devHandle
operator|!=
name|NULL
condition|)
break|break;
block|}
return|return
name|devHandle
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************** ostiInitiatorSMPCompleted()  Purpose:   IO request completion call back  Parameters:   tiRoot_t *ptiRoot (IN)               Pointer to the HBA tiRoot   tiIORequest_t *ptiSMPRequest (IN)    Pointer to the SMP request structure   tiIOStatus_t IOStatus (IN)           I/O complated status     U32 tiSMPInfoLen (IN)                Number of bytes of response frame len   tiFrameHandle    (IN)                Handle that referes to response frame   U32 context (IN)                     Interrupt dealing context Returns: Note: ******************************************************************************/
end_comment

begin_function
name|void
name|ostiInitiatorSMPCompleted
parameter_list|(
name|tiRoot_t
modifier|*
name|ptiRoot
parameter_list|,
name|tiIORequest_t
modifier|*
name|ptiSMPRequest
parameter_list|,
name|tiSMPStatus_t
name|smpStatus
parameter_list|,
name|bit32
name|tiSMPInfoLen
parameter_list|,
name|void
modifier|*
name|tiFrameHandle
parameter_list|,
name|bit32
name|context
parameter_list|)
block|{
name|struct
name|agtiapi_softc
modifier|*
name|pCard
decl_stmt|;
name|ccb_t
modifier|*
name|pccb
decl_stmt|;
name|pCard
operator|=
name|TIROOT_TO_CARD
argument_list|(
name|ptiRoot
argument_list|)
expr_stmt|;
name|pccb
operator|=
operator|(
name|ccb_t
operator|*
operator|)
name|ptiSMPRequest
operator|->
name|osData
expr_stmt|;
name|AGTIAPI_PRINTK
argument_list|(
literal|"ostiInitiatorSMPCompleted: start\n"
argument_list|)
expr_stmt|;
name|OSTI_OUT_ENTER
argument_list|(
name|ptiRoot
argument_list|)
expr_stmt|;
name|pccb
operator|->
name|ccbStatus
operator|=
operator|(
name|U16
operator|)
name|smpStatus
expr_stmt|;
if|if
condition|(
name|smpStatus
operator|!=
name|tiSMPSuccess
condition|)
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"ostiInitiatorSMPCompleted: SMP Error\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|union
name|ccb
modifier|*
name|ccb
init|=
name|pccb
operator|->
name|ccb
decl_stmt|;
name|struct
name|ccb_smpio
modifier|*
name|csmpio
init|=
operator|&
name|ccb
operator|->
name|smpio
decl_stmt|;
name|memcpy
argument_list|(
name|csmpio
operator|->
name|smp_response
argument_list|,
name|tiFrameHandle
argument_list|,
name|tiSMPInfoLen
argument_list|)
expr_stmt|;
name|csmpio
operator|->
name|smp_response_len
operator|=
name|tiSMPInfoLen
expr_stmt|;
name|agtiapi_hexdump
argument_list|(
literal|"ostiInitiatorSMPCompleted: Response Payload in CAM"
argument_list|,
operator|(
name|bit8
operator|*
operator|)
name|csmpio
operator|->
name|smp_response
argument_list|,
name|csmpio
operator|->
name|smp_response_len
argument_list|)
expr_stmt|;
block|}
name|pccb
operator|->
name|flags
operator||=
name|REQ_DONE
expr_stmt|;
name|agtiapi_QueueCCB
argument_list|(
argument|pCard
argument_list|,
argument|&pCard->smpDoneHead
argument_list|,
argument|&pCard->smpDoneTail                      AG_CARD_LOCAL_LOCK(&pCard->doneSMPLock)
argument_list|,
argument|pccb
argument_list|)
empty_stmt|;
name|AGTIAPI_PRINTK
argument_list|(
literal|"ostiInitiatorSMPCompleted: Done\n"
argument_list|)
expr_stmt|;
name|OSTI_OUT_LEAVE
argument_list|(
name|ptiRoot
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|FAST_IO_TEST
end_ifdef

begin_function
name|void
name|osti_FastIOCb
parameter_list|(
name|tiRoot_t
modifier|*
name|ptiRoot
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|tiIOStatus_t
name|IOStatus
parameter_list|,
name|U32
name|statusDetail
parameter_list|)
block|{
name|ccb_t
modifier|*
name|pccb
init|=
operator|(
name|ccb_t
operator|*
operator|)
name|arg
decl_stmt|;
name|ag_card_t
modifier|*
name|pCard
decl_stmt|;
specifier|static
name|int
name|callNum
init|=
literal|0
decl_stmt|;
name|callNum
operator|++
expr_stmt|;
name|BUG_ON
argument_list|(
operator|!
name|pccb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|callNum
operator|%
name|CMDS_PER_IO_DUP
operator|)
operator|!=
literal|0
condition|)
block|{
goto|goto
name|err
goto|;
block|}
name|pccb
operator|->
name|ccbStatus
operator|=
name|IOStatus
expr_stmt|;
name|pccb
operator|->
name|scsiStatus
operator|=
name|statusDetail
expr_stmt|;
comment|/* pccb->pSenseData is copied already */
if|if
condition|(
name|pccb
operator|->
name|flags
operator|&
name|AGTIAPI_ABORT
condition|)
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"agtiapi_SuperIOCb: aborted ccb %p, flag %x\n"
argument_list|,
name|pccb
argument_list|,
name|pccb
operator|->
name|flags
argument_list|)
expr_stmt|;
name|pccb
operator|->
name|startTime
operator|=
literal|0
expr_stmt|;
comment|/* indicate aborted IO completion */
name|BUG_ON
argument_list|(
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|pCard
operator|=
name|TIROOT_TO_CARD
argument_list|(
name|ptiRoot
argument_list|)
expr_stmt|;
name|pccb
operator|->
name|flags
operator||=
name|REQ_DONE
expr_stmt|;
name|agtiapi_QueueCCB
argument_list|(
argument|pCard
argument_list|,
argument|&pCard->ccbDoneHead
argument_list|,
argument|&pCard->ccbDoneTail                    AG_CARD_LOCAL_LOCK(&pCard->doneLock)
argument_list|,
argument|pccb
argument_list|)
empty_stmt|;
name|err
label|:
return|return;
block|}
end_function

begin_comment
comment|/* osti_FastIOCb */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/****************************************************************************** ostiSingleThreadedEnter()  Purpose:   Critical region code excution protection. Parameters:   tiRoot_t *ptiRoot (IN)  Pointer to tiRoot data structure   U32 queueId (IN)     spinlock Id Returns: Note:   Lock is held by oslayer. ******************************************************************************/
end_comment

begin_function
name|void
name|ostiSingleThreadedEnter
parameter_list|(
name|tiRoot_t
modifier|*
name|ptiRoot
parameter_list|,
name|U32
name|queueId
parameter_list|)
block|{
name|struct
name|agtiapi_softc
modifier|*
name|pCard
init|=
name|TIROOT_TO_CARD
argument_list|(
name|ptiRoot
argument_list|)
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|pCard
operator|->
name|STLock
index|[
name|queueId
index|]
argument_list|)
expr_stmt|;
comment|// review: need irq save? ##
block|}
end_function

begin_comment
comment|/****************************************************************************** ostiSingleThreadedLeave()  Purpose:   Restore multi-threading environment. Parameters:   tiRoot_t *ptiRoot (IN)  Pointer to the tiRoot data structure   U32 queueId (IN)     spinlock Id Returns: Note:   Lock is held by oslayer. ******************************************************************************/
end_comment

begin_function
name|void
name|ostiSingleThreadedLeave
parameter_list|(
name|tiRoot_t
modifier|*
name|ptiRoot
parameter_list|,
name|U32
name|queueId
parameter_list|)
block|{
name|struct
name|agtiapi_softc
modifier|*
name|pCard
init|=
name|TIROOT_TO_CARD
argument_list|(
name|ptiRoot
argument_list|)
decl_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|pCard
operator|->
name|STLock
index|[
name|queueId
index|]
argument_list|)
expr_stmt|;
comment|// review: need irq restore? ##
block|}
end_function

begin_function
name|osGLOBAL
name|tiDeviceHandle_t
modifier|*
name|ostiMapToDevHandle
parameter_list|(
name|tiRoot_t
modifier|*
name|root
parameter_list|,
name|bit8
name|pathId
parameter_list|,
name|bit8
name|targetId
parameter_list|,
name|bit8
name|LUN
parameter_list|)
block|{
name|tiDeviceHandle_t
modifier|*
name|dev
init|=
name|NULL
decl_stmt|;
name|struct
name|agtiapi_softc
modifier|*
name|pCard
decl_stmt|;
name|bit32
name|offset
decl_stmt|;
name|pCard
operator|=
name|TIROOT_TO_CARD
argument_list|(
name|root
argument_list|)
expr_stmt|;
name|offset
operator|=
name|pathId
operator|*
name|pCard
operator|->
name|tgtCount
operator|+
name|targetId
expr_stmt|;
if|if
condition|(
name|offset
operator|>
operator|(
name|pCard
operator|->
name|tgtCount
operator|-
literal|1
operator|)
condition|)
block|{
name|dev
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|dev
operator|=
name|pCard
operator|->
name|pDevList
index|[
name|offset
index|]
operator|.
name|pDevHandle
expr_stmt|;
block|}
return|return
name|dev
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|PERF_COUNT
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|AGTIAPI_LOCAL_LOCK
end_ifdef

begin_define
define|#
directive|define
name|OSTI_SPIN_LOCK
parameter_list|(
name|lock
parameter_list|)
value|spin_lock(lock)
end_define

begin_define
define|#
directive|define
name|OSTI_SPIN_UNLOCK
parameter_list|(
name|lock
parameter_list|)
value|spin_unlock(lock)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|OSTI_SPIN_LOCK
parameter_list|(
name|lock
parameter_list|)
end_define

begin_define
define|#
directive|define
name|OSTI_SPIN_UNLOCK
parameter_list|(
name|lock
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|ostiEnter
parameter_list|(
name|tiRoot_t
modifier|*
name|ptiRoot
parameter_list|,
name|U32
name|layer
parameter_list|,
name|int
name|io
parameter_list|)
block|{
name|ag_card_t
modifier|*
name|pCard
init|=
operator|(
operator|(
name|ag_card_info_t
operator|*
operator|)
name|ptiRoot
operator|->
name|osData
operator|)
operator|->
name|pCard
decl_stmt|;
name|int
name|ini
init|=
operator|(
operator|(
name|pCard
operator|->
name|flags
operator|&
name|AGTIAPI_INIT_TIME
operator|)
operator|==
name|AGTIAPI_INIT_TIME
operator|)
decl_stmt|;
name|BUG_ON
argument_list|(
operator|(
name|io
operator|!=
literal|0
operator|&&
name|io
operator|!=
literal|1
operator|)
operator|||
operator|(
name|layer
operator|!=
literal|0
operator|&&
name|layer
operator|!=
literal|1
operator|&&
name|layer
operator|!=
literal|2
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ini
condition|)
block|{
name|unsigned
name|long
name|long
name|cycles
init|=
name|get_cycles
argument_list|()
decl_stmt|;
name|OSTI_SPIN_LOCK
argument_list|(
operator|&
name|pCard
operator|->
name|latLock
argument_list|)
expr_stmt|;
name|BUG_ON
argument_list|(
name|pCard
operator|->
name|callLevel
index|[
name|io
index|]
operator|>=
sizeof|sizeof
argument_list|(
name|pCard
operator|->
name|layer
index|[
literal|0
index|]
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|pCard
operator|->
name|layer
index|[
literal|0
index|]
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pCard
operator|->
name|callLevel
index|[
name|io
index|]
operator|>
literal|0
condition|)
block|{
name|unsigned
name|int
name|prev_layer
init|=
name|pCard
operator|->
name|layer
index|[
name|io
index|]
index|[
name|pCard
operator|->
name|callLevel
index|[
name|io
index|]
operator|-
literal|1
index|]
decl_stmt|;
name|pCard
operator|->
name|totalCycles
index|[
name|io
index|]
index|[
name|prev_layer
index|]
operator|+=
name|cycles
operator|-
name|pCard
operator|->
name|enterCycles
index|[
name|io
index|]
index|[
name|prev_layer
index|]
expr_stmt|;
block|}
name|pCard
operator|->
name|enterCycles
index|[
name|io
index|]
index|[
name|layer
index|]
operator|=
name|cycles
expr_stmt|;
name|pCard
operator|->
name|layer
index|[
name|io
index|]
index|[
name|pCard
operator|->
name|callLevel
index|[
name|io
index|]
index|]
operator|=
name|layer
expr_stmt|;
name|pCard
operator|->
name|callLevel
index|[
name|io
index|]
operator|++
expr_stmt|;
name|OSTI_SPIN_UNLOCK
argument_list|(
operator|&
name|pCard
operator|->
name|latLock
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ostiLeave
parameter_list|(
name|tiRoot_t
modifier|*
name|ptiRoot
parameter_list|,
name|U32
name|layer
parameter_list|,
name|int
name|io
parameter_list|)
block|{
name|ag_card_t
modifier|*
name|pCard
init|=
operator|(
operator|(
name|ag_card_info_t
operator|*
operator|)
name|ptiRoot
operator|->
name|osData
operator|)
operator|->
name|pCard
decl_stmt|;
name|int
name|ini
init|=
operator|(
operator|(
name|pCard
operator|->
name|flags
operator|&
name|AGTIAPI_INIT_TIME
operator|)
operator|==
name|AGTIAPI_INIT_TIME
operator|)
decl_stmt|;
name|BUG_ON
argument_list|(
operator|(
name|io
operator|!=
literal|0
operator|&&
name|io
operator|!=
literal|1
operator|)
operator|||
operator|(
name|layer
operator|!=
literal|0
operator|&&
name|layer
operator|!=
literal|1
operator|&&
name|layer
operator|!=
literal|2
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ini
condition|)
block|{
name|unsigned
name|long
name|long
name|cycles
init|=
name|get_cycles
argument_list|()
decl_stmt|;
name|OSTI_SPIN_LOCK
argument_list|(
operator|&
name|pCard
operator|->
name|latLock
argument_list|)
expr_stmt|;
name|pCard
operator|->
name|callLevel
index|[
name|io
index|]
operator|--
expr_stmt|;
name|BUG_ON
argument_list|(
name|pCard
operator|->
name|callLevel
index|[
name|io
index|]
operator|<
literal|0
argument_list|)
expr_stmt|;
name|BUG_ON
argument_list|(
name|pCard
operator|->
name|layer
index|[
name|io
index|]
index|[
name|pCard
operator|->
name|callLevel
index|[
name|io
index|]
index|]
operator|!=
name|layer
argument_list|)
expr_stmt|;
name|pCard
operator|->
name|totalCycles
index|[
name|io
index|]
index|[
name|layer
index|]
operator|+=
name|cycles
operator|-
name|pCard
operator|->
name|enterCycles
index|[
name|io
index|]
index|[
name|layer
index|]
expr_stmt|;
if|if
condition|(
name|pCard
operator|->
name|callLevel
index|[
name|io
index|]
operator|>
literal|0
condition|)
name|pCard
operator|->
name|enterCycles
index|[
name|io
index|]
index|[
name|pCard
operator|->
name|layer
index|[
name|io
index|]
index|[
name|pCard
operator|->
name|callLevel
index|[
name|io
index|]
operator|-
literal|1
index|]
index|]
operator|=
name|cycles
expr_stmt|;
name|OSTI_SPIN_UNLOCK
argument_list|(
operator|&
name|pCard
operator|->
name|latLock
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|osGLOBAL
name|FORCEINLINE
name|bit8
name|ostiBitScanForward
parameter_list|(
name|tiRoot_t
modifier|*
name|root
parameter_list|,
name|bit32
modifier|*
name|Index
parameter_list|,
name|bit32
name|Mask
parameter_list|)
block|{
return|return
literal|1
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|REMOVED
end_ifdef

begin_function
name|osGLOBAL
name|sbit32
name|ostiAtomicIncrement
parameter_list|(
name|tiRoot_t
modifier|*
name|root
parameter_list|,
name|sbit32
specifier|volatile
modifier|*
name|Addend
parameter_list|)
block|{
return|return
literal|1
return|;
block|}
end_function

begin_function
name|osGLOBAL
name|sbit32
name|ostiAtomicDecrement
parameter_list|(
name|tiRoot_t
modifier|*
name|root
parameter_list|,
name|sbit32
specifier|volatile
modifier|*
name|Addend
parameter_list|)
block|{
return|return
literal|1
return|;
block|}
end_function

begin_function
name|osGLOBAL
name|sbit32
name|ostiAtomicBitClear
parameter_list|(
name|tiRoot_t
modifier|*
name|root
parameter_list|,
name|sbit32
specifier|volatile
modifier|*
name|Destination
parameter_list|,
name|sbit32
name|Value
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
name|osGLOBAL
name|sbit32
name|ostiAtomicBitSet
parameter_list|(
name|tiRoot_t
modifier|*
name|root
parameter_list|,
name|sbit32
specifier|volatile
modifier|*
name|Destination
parameter_list|,
name|sbit32
name|Value
parameter_list|)
block|{
return|return
literal|0
return|;
comment|/*    set_bit(Value, (volatile unsigned long *)Destination);    return 0;   */
block|}
end_function

begin_function
name|osGLOBAL
name|sbit32
name|ostiAtomicExchange
parameter_list|(
name|tiRoot_t
modifier|*
name|root
parameter_list|,
name|sbit32
specifier|volatile
modifier|*
name|Target
parameter_list|,
name|sbit32
name|Value
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|osGLOBAL
name|FORCEINLINE
name|sbit32
name|ostiInterlockedExchange
parameter_list|(
name|tiRoot_t
modifier|*
name|root
parameter_list|,
name|sbit32
specifier|volatile
modifier|*
name|Target
parameter_list|,
name|sbit32
name|Value
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
name|osGLOBAL
name|FORCEINLINE
name|sbit32
name|ostiInterlockedIncrement
parameter_list|(
name|tiRoot_t
modifier|*
name|root
parameter_list|,
name|sbit32
specifier|volatile
modifier|*
name|Addend
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
name|osGLOBAL
name|FORCEINLINE
name|sbit32
name|ostiInterlockedDecrement
parameter_list|(
name|tiRoot_t
modifier|*
name|root
parameter_list|,
name|sbit32
specifier|volatile
modifier|*
name|Addend
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
name|osGLOBAL
name|FORCEINLINE
name|sbit32
name|ostiInterlockedAnd
parameter_list|(
name|tiRoot_t
modifier|*
name|root
parameter_list|,
name|sbit32
specifier|volatile
modifier|*
name|Destination
parameter_list|,
name|sbit32
name|Value
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
name|osGLOBAL
name|FORCEINLINE
name|sbit32
name|ostiInterlockedOr
parameter_list|(
name|tiRoot_t
modifier|*
name|root
parameter_list|,
name|sbit32
specifier|volatile
modifier|*
name|Destination
parameter_list|,
name|sbit32
name|Value
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|// this is just stub code to allow compile and use of the module ...
end_comment

begin_comment
comment|// now that a call to this function has been added with windows specific
end_comment

begin_comment
comment|// intentions.
end_comment

begin_function
name|osGLOBAL
name|bit32
name|ostiSetDeviceQueueDepth
parameter_list|(
name|tiRoot_t
modifier|*
name|tiRoot
parameter_list|,
name|tiIORequest_t
modifier|*
name|tiIORequest
parameter_list|,
name|bit32
name|QueueDepth
parameter_list|)
block|{
name|bit32
name|retVal
init|=
literal|0
decl_stmt|;
name|struct
name|agtiapi_softc
modifier|*
name|pCard
init|=
name|TIROOT_TO_CARD
argument_list|(
name|tiRoot
argument_list|)
decl_stmt|;
name|ccb_t
modifier|*
name|pccb
init|=
operator|(
name|ccb_t
operator|*
operator|)
name|tiIORequest
operator|->
name|osData
decl_stmt|;
name|tiDeviceHandle_t
modifier|*
name|tiDeviceHandle
init|=
name|pccb
operator|->
name|devHandle
decl_stmt|;
name|ag_device_t
modifier|*
name|pDevice
init|=
operator|(
name|ag_device_t
operator|*
operator|)
name|tiDeviceHandle
operator|->
name|osData
decl_stmt|;
name|AGTIAPI_PRINTK
argument_list|(
literal|"ostiSetDeviceQueueDepth stub only: root%p, req%p, qdeep%d\n"
argument_list|,
name|tiRoot
argument_list|,
name|tiIORequest
argument_list|,
name|QueueDepth
argument_list|)
expr_stmt|;
name|pDevice
operator|->
name|qdepth
operator|=
name|QueueDepth
expr_stmt|;
return|return
name|retVal
return|;
block|}
end_function

begin_comment
comment|// this is just stub code to allow compile and use of the module ...
end_comment

begin_comment
comment|// now that a call to this function has been added with windows specific
end_comment

begin_comment
comment|// intentions.
end_comment

begin_function
name|osGLOBAL
name|void
name|ostiGetSenseKeyCount
parameter_list|(
name|tiRoot_t
modifier|*
name|root
parameter_list|,
name|bit32
name|fIsClear
parameter_list|,
name|void
modifier|*
name|SenseKeyCount
parameter_list|,
name|bit32
name|length
parameter_list|)
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"ostiGetSenseKeyCount stub only: rt%p, fcl%d, kyCt%p, ln%d\n"
argument_list|,
name|root
argument_list|,
name|fIsClear
argument_list|,
name|SenseKeyCount
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|osGLOBAL
name|void
name|ostiGetSCSIStatusCount
parameter_list|(
name|tiRoot_t
modifier|*
name|root
parameter_list|,
name|bit32
name|fIsClear
parameter_list|,
name|void
modifier|*
name|ScsiStatusCount
parameter_list|,
name|bit32
name|length
parameter_list|)
block|{
name|AGTIAPI_PRINTK
argument_list|(
literal|"ostiGetSCSIStatusCount: stub only rt%p, fcl%d, kyCt%p, ln%d\n"
argument_list|,
name|root
argument_list|,
name|fIsClear
argument_list|,
name|ScsiStatusCount
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|osGLOBAL
name|void
name|ostiPCI_TRIGGER
parameter_list|(
name|tiRoot_t
modifier|*
name|tiRoot
parameter_list|)
block|{
name|ostiChipReadBit32Ext
argument_list|(
name|tiRoot
argument_list|,
literal|0
argument_list|,
literal|0x5C
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|osGLOBAL
name|bit32
name|ostiNumOfLUNIOCTLreq
parameter_list|(
name|tiRoot_t
modifier|*
name|root
parameter_list|,
name|void
modifier|*
name|param1
parameter_list|,
name|void
modifier|*
name|param2
parameter_list|,
name|void
modifier|*
modifier|*
name|tiRequestBody
parameter_list|,
name|tiIORequest_t
modifier|*
modifier|*
name|tiIORequest
parameter_list|)
block|{
name|bit32
name|status
init|=
name|IOCTL_CALL_SUCCESS
decl_stmt|;
name|pccb_t
name|pccb
decl_stmt|;
name|AGTIAPI_PRINTK
argument_list|(
literal|"ostiNumOfLUNIOCTLreq: start\n"
argument_list|)
expr_stmt|;
name|struct
name|agtiapi_softc
modifier|*
name|pCard
init|=
name|TIROOT_TO_CARD
argument_list|(
name|root
argument_list|)
decl_stmt|;
comment|/* get a ccb */
if|if
condition|(
operator|(
name|pccb
operator|=
name|agtiapi_GetCCB
argument_list|(
name|pCard
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"ostiNumOfLUNIOCTLreq - GetCCB ERROR\n"
argument_list|)
expr_stmt|;
name|status
operator|=
name|IOCTL_CALL_FAIL
expr_stmt|;
comment|//BUG_ON(1);
block|}
operator|*
name|tiIORequest
operator|=
operator|(
name|tiIORequest_t
operator|*
operator|)
operator|&
name|pccb
operator|->
name|tiIORequest
expr_stmt|;
operator|*
name|tiRequestBody
operator|=
operator|&
name|pccb
operator|->
name|tdIOReqBody
expr_stmt|;
name|AGTIAPI_PRINTK
argument_list|(
literal|"ostiNumOfLUNIOCTLreq:end\n"
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

end_unit

