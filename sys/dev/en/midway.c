begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: midway.c,v 1.30 1997/09/29 17:40:38 chuck Exp $	*/
end_comment

begin_comment
comment|/*	(sync'd to midway.c 1.68)	*/
end_comment

begin_comment
comment|/*  *  * Copyright (c) 1996 Charles D. Cranor and Washington University.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *      This product includes software developed by Charles D. Cranor and  *	Washington University.  * 4. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  *  * m i d w a y . c   e n i 1 5 5   d r i v e r   *  * author: Chuck Cranor<chuck@ccrc.wustl.edu>  * started: spring, 1996 (written from scratch).  *  * notes from the author:  *   Extra special thanks go to Werner Almesberger, EPFL LRC.   Werner's  *   ENI driver was especially useful in figuring out how this card works.  *   I would also like to thank Werner for promptly answering email and being  *   generally helpful.  */
end_comment

begin_comment
comment|/*  *  1997/12/02 kjc  *    new features added:  *	- support vc/vp shaping  *	- integrate IPv6 support.  *	- support pvc shadow interface  *	  (initial work on per-pvc-interface for ipv6 was done  *	  by Katsushi Kobayashi<ikob@cc.uec.ac.jp> of the WIDE Project,  *	  extensively modified by kjc.)  *    code cleanup:  *	- remove WMAYBE related code.  ENI WMAYBE DMA doen't work.  *	- drop support of FreeBSD-2.1.x and FreeBSD-3.0-SNAP-970124.  *	- remove updating if_lastchange for every packet.  *	- BPF related code is moved to midway.c as it should be.  *	  (bpfwrite should work if atm_pseudohdr and LLC/SNAP are  *	  prepended.)  *	- BPF link type is changed to DLT_ATM_RFC1483.  *	  BPF now understands only LLC/SNAP!! (because bpf can't  *	  handle variable link header length.)  *	  It is recommended to use LLC/SNAP instead of NULL  *	  encapsulation for various reasons.  (BPF, IPv6,  *	  interoperability, etc.)  *	- altq queue implementation is moved from the driver internal  *	  queue to if_snd.  *	- AFMAP related code cleanup.  */
end_comment

begin_undef
undef|#
directive|undef
name|EN_DEBUG
end_undef

begin_undef
undef|#
directive|undef
name|EN_DEBUG_RANGE
end_undef

begin_comment
comment|/* check ranges on en_read/en_write's? */
end_comment

begin_define
define|#
directive|define
name|EN_MBUF_OPT
end_define

begin_comment
comment|/* try and put more stuff in mbuf? */
end_comment

begin_define
define|#
directive|define
name|EN_DIAG
end_define

begin_define
define|#
directive|define
name|EN_STAT
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|EN_DMA
end_ifndef

begin_define
define|#
directive|define
name|EN_DMA
value|1
end_define

begin_comment
comment|/* use dma? */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|EN_NOTXDMA
value|0
end_define

begin_comment
comment|/* hook to disable tx dma only */
end_comment

begin_define
define|#
directive|define
name|EN_NORXDMA
value|0
end_define

begin_comment
comment|/* hook to disable rx dma only */
end_comment

begin_define
define|#
directive|define
name|EN_DDBHOOK
value|1
end_define

begin_comment
comment|/* compile in ddb functions */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|MIDWAY_ADPONLY
argument_list|)
end_if

begin_define
define|#
directive|define
name|EN_ENIDMAFIX
value|0
end_define

begin_comment
comment|/* no ENI cards to worry about */
end_comment

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|EN_ENIDMAFIX
value|1
end_define

begin_comment
comment|/* avoid byte DMA on the ENI card (see below) */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * note on EN_ENIDMAFIX: the byte aligner on the ENI version of the card  * appears to be broken.   it works just fine if there is no load... however  * when the card is loaded the data get corrupted.   to see this, one only  * has to use "telnet" over ATM.   do the following command in "telnet":  * 	cat /usr/share/misc/termcap  * "telnet" seems to generate lots of 1023 byte mbufs (which make great  * use of the byte aligner).   watch "netstat -s" for checksum errors.  *   * I further tested this by adding a function that compared the transmit   * data on the card's SRAM with the data in the mbuf chain _after_ the   * "transmit DMA complete" interrupt.   using the "telnet" test I got data  * mismatches where the byte-aligned data should have been.   using ddb  * and en_dumpmem() I verified that the DTQs fed into the card were   * absolutely correct.   thus, we are forced to concluded that the ENI  * hardware is buggy.   note that the Adaptec version of the card works  * just fine with byte DMA.  *  * bottom line: we set EN_ENIDMAFIX to 1 to avoid byte DMAs on the ENI  * card.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DIAGNOSTIC
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|EN_DIAG
argument_list|)
end_if

begin_define
define|#
directive|define
name|EN_DIAG
end_define

begin_comment
comment|/* link in with master DIAG option */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|EN_STAT
end_ifdef

begin_define
define|#
directive|define
name|EN_COUNT
parameter_list|(
name|X
parameter_list|)
value|(X)++
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|EN_COUNT
parameter_list|(
name|X
parameter_list|)
end_define

begin_comment
comment|/* nothing */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|EN_DEBUG
end_ifdef

begin_undef
undef|#
directive|undef
name|EN_DDBHOOK
end_undef

begin_define
define|#
directive|define
name|EN_DDBHOOK
value|1
end_define

begin_define
define|#
directive|define
name|STATIC
end_define

begin_comment
comment|/* nothing */
end_comment

begin_define
define|#
directive|define
name|INLINE
end_define

begin_comment
comment|/* nothing */
end_comment

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* EN_DEBUG */
end_comment

begin_define
define|#
directive|define
name|STATIC
value|static
end_define

begin_define
define|#
directive|define
name|INLINE
value|__inline
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* EN_DEBUG */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_include
include|#
directive|include
file|"en.h"
end_include

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_natm.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|NEN
operator|>
literal|0
operator|||
operator|!
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__bsdi__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/device.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_atm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|||
name|defined
argument_list|(
name|INET6
argument_list|)
end_if

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_atm.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|NATM
end_ifdef

begin_include
include|#
directive|include
file|<netnatm/natm.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|sparc
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<dev/ic/midwayreg.h>
end_include

begin_include
include|#
directive|include
file|<dev/ic/midwayvar.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__alpha__
argument_list|)
end_if

begin_comment
comment|/* XXX XXX NEED REAL DMA MAPPING SUPPORT XXX XXX */
end_comment

begin_undef
undef|#
directive|undef
name|vtophys
end_undef

begin_define
define|#
directive|define
name|vtophys
parameter_list|(
name|va
parameter_list|)
value|alpha_XXX_dmamap((vm_offset_t)(va))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_elif

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_comment
comment|/* for DELAY */
end_comment

begin_include
include|#
directive|include
file|<dev/en/midwayreg.h>
end_include

begin_include
include|#
directive|include
file|<dev/en/midwayvar.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_comment
comment|/* for vtophys proto */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|IFF_NOTRAILERS
end_ifndef

begin_define
define|#
directive|define
name|IFF_NOTRAILERS
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __FreeBSD__ */
end_comment

begin_include
include|#
directive|include
file|"bpfilter.h"
end_include

begin_if
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_define
define|#
directive|define
name|BPFATTACH
parameter_list|(
name|ifp
parameter_list|,
name|dlt
parameter_list|,
name|hlen
parameter_list|)
value|bpfattach((ifp), (dlt), (hlen))
end_define

begin_define
define|#
directive|define
name|BPF_MTAP
parameter_list|(
name|ifp
parameter_list|,
name|m
parameter_list|)
value|bpf_mtap((ifp), (m))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|BPFATTACH
parameter_list|(
name|ifp
parameter_list|,
name|dlt
parameter_list|,
name|hlen
parameter_list|)
value|bpfattach(&(ifp)->if_bpf, (ifp), (dlt), (hlen))
end_define

begin_define
define|#
directive|define
name|BPF_MTAP
parameter_list|(
name|ifp
parameter_list|,
name|m
parameter_list|)
value|bpf_mtap((ifp)->if_bpf, (m))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NBPFILTER> 0 */
end_comment

begin_comment
comment|/*  * params  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|EN_TXHIWAT
end_ifndef

begin_define
define|#
directive|define
name|EN_TXHIWAT
value|(64*1024)
end_define

begin_comment
comment|/* max 64 KB waiting to be DMAd out */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|EN_MINDMA
end_ifndef

begin_define
define|#
directive|define
name|EN_MINDMA
value|32
end_define

begin_comment
comment|/* don't DMA anything less than this (bytes) */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|RX_NONE
value|0xffff
end_define

begin_comment
comment|/* recv VC not in use */
end_comment

begin_define
define|#
directive|define
name|EN_OBHDR
value|ATM_PH_DRIVER7
end_define

begin_comment
comment|/* TBD in first mbuf ! */
end_comment

begin_define
define|#
directive|define
name|EN_OBTRL
value|ATM_PH_DRIVER8
end_define

begin_comment
comment|/* PDU trailier in last mbuf ! */
end_comment

begin_define
define|#
directive|define
name|ENOTHER_FREE
value|0x01
end_define

begin_comment
comment|/* free rxslot */
end_comment

begin_define
define|#
directive|define
name|ENOTHER_DRAIN
value|0x02
end_define

begin_comment
comment|/* almost free (drain DRQ dma) */
end_comment

begin_define
define|#
directive|define
name|ENOTHER_RAW
value|0x04
end_define

begin_comment
comment|/* 'raw' access  (aka boodi mode) */
end_comment

begin_define
define|#
directive|define
name|ENOTHER_SWSL
value|0x08
end_define

begin_comment
comment|/* in software service list */
end_comment

begin_decl_stmt
specifier|static
name|int
name|en_dma
init|=
name|EN_DMA
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* use DMA (switch off for dbg) */
end_comment

begin_comment
comment|/*  * autoconfig attachments  */
end_comment

begin_decl_stmt
name|struct
name|cfdriver
name|en_cd
init|=
block|{
literal|0
block|,
literal|"en"
block|,
name|DV_IFNET
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * local structures  */
end_comment

begin_comment
comment|/*  * params to en_txlaunch() function  */
end_comment

begin_struct
struct|struct
name|en_launch
block|{
name|u_int32_t
name|tbd1
decl_stmt|;
comment|/* TBD 1 */
name|u_int32_t
name|tbd2
decl_stmt|;
comment|/* TBD 2 */
name|u_int32_t
name|pdu1
decl_stmt|;
comment|/* PDU 1 (aal5) */
name|int
name|nodma
decl_stmt|;
comment|/* don't use DMA */
name|int
name|need
decl_stmt|;
comment|/* total space we need (pad out if less data) */
name|int
name|mlen
decl_stmt|;
comment|/* length of mbuf (for dtq) */
name|struct
name|mbuf
modifier|*
name|t
decl_stmt|;
comment|/* data */
name|u_int32_t
name|aal
decl_stmt|;
comment|/* aal code */
name|u_int32_t
name|atm_vci
decl_stmt|;
comment|/* vci */
name|u_int8_t
name|atm_flags
decl_stmt|;
comment|/* flags */
block|}
struct|;
end_struct

begin_comment
comment|/*  * dma table (index by # of words)  *  * plan A: use WMAYBE (obsolete)  * plan B: avoid WMAYBE  */
end_comment

begin_struct
struct|struct
name|en_dmatab
block|{
name|u_int8_t
name|bcode
decl_stmt|;
comment|/* code */
name|u_int8_t
name|divshift
decl_stmt|;
comment|/* byte divisor */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|en_dmatab
name|en_dma_planB
index|[]
init|=
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/* 0 */
block|{
name|MIDDMA_WORD
block|,
literal|2
block|}
block|,
comment|/* 1 */
block|{
name|MIDDMA_2WORD
block|,
literal|3
block|}
block|,
comment|/* 2 */
block|{
name|MIDDMA_WORD
block|,
literal|2
block|}
block|,
comment|/* 3 */
block|{
name|MIDDMA_4WORD
block|,
literal|4
block|}
block|,
comment|/* 4 */
block|{
name|MIDDMA_WORD
block|,
literal|2
block|}
block|,
comment|/* 5 */
block|{
name|MIDDMA_2WORD
block|,
literal|3
block|}
block|,
comment|/* 6 */
block|{
name|MIDDMA_WORD
block|,
literal|2
block|}
block|,
comment|/* 7 */
block|{
name|MIDDMA_8WORD
block|,
literal|5
block|}
block|,
comment|/* 8 */
block|{
name|MIDDMA_WORD
block|,
literal|2
block|}
block|,
comment|/* 9 */
block|{
name|MIDDMA_2WORD
block|,
literal|3
block|}
block|,
comment|/* 10 */
block|{
name|MIDDMA_WORD
block|,
literal|2
block|}
block|,
comment|/* 11 */
block|{
name|MIDDMA_4WORD
block|,
literal|4
block|}
block|,
comment|/* 12 */
block|{
name|MIDDMA_WORD
block|,
literal|2
block|}
block|,
comment|/* 13 */
block|{
name|MIDDMA_2WORD
block|,
literal|3
block|}
block|,
comment|/* 14 */
block|{
name|MIDDMA_WORD
block|,
literal|2
block|}
block|,
comment|/* 15 */
block|{
name|MIDDMA_16WORD
block|,
literal|6
block|}
block|,
comment|/* 16 */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|en_dmatab
modifier|*
name|en_dmaplan
init|=
name|en_dma_planB
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * prototypes  */
end_comment

begin_decl_stmt
name|STATIC
name|INLINE
name|int
name|en_b2sz
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
name|__attribute__
argument_list|(
operator|(
name|unused
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|EN_DDBHOOK
end_ifdef

begin_decl_stmt
name|int
name|en_dump
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|en_dumpmem
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|STATIC
name|void
name|en_dmaprobe
name|__P
argument_list|(
operator|(
expr|struct
name|en_softc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|int
name|en_dmaprobe_doit
name|__P
argument_list|(
operator|(
expr|struct
name|en_softc
operator|*
operator|,
name|u_int8_t
operator|*
operator|,
name|u_int8_t
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|INLINE
name|int
name|en_dqneed
name|__P
argument_list|(
operator|(
expr|struct
name|en_softc
operator|*
operator|,
name|caddr_t
operator|,
name|u_int
operator|,
name|u_int
operator|)
argument_list|)
name|__attribute__
argument_list|(
operator|(
name|unused
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|void
name|en_init
name|__P
argument_list|(
operator|(
expr|struct
name|en_softc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|int
name|en_ioctl
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
operator|,
name|EN_IOCTL_CMDT
operator|,
name|caddr_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|INLINE
name|int
name|en_k2sz
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
name|__attribute__
argument_list|(
operator|(
name|unused
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|void
name|en_loadvc
name|__P
argument_list|(
operator|(
expr|struct
name|en_softc
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|int
name|en_mfix
name|__P
argument_list|(
operator|(
expr|struct
name|en_softc
operator|*
operator|,
expr|struct
name|mbuf
operator|*
operator|*
operator|,
expr|struct
name|mbuf
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|STATIC
name|INLINE
expr|struct
name|mbuf
operator|*
name|en_mget
name|__P
argument_list|(
argument|(struct en_softc *, u_int, 		    u_int *)
argument_list|)
name|__attribute__
argument_list|(
operator|(
name|unused
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|STATIC
name|INLINE
name|u_int32_t
name|en_read
name|__P
argument_list|(
operator|(
expr|struct
name|en_softc
operator|*
operator|,
name|u_int32_t
operator|)
argument_list|)
name|__attribute__
argument_list|(
operator|(
name|unused
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|int
name|en_rxctl
name|__P
argument_list|(
operator|(
expr|struct
name|en_softc
operator|*
operator|,
expr|struct
name|atm_pseudoioctl
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|void
name|en_txdma
name|__P
argument_list|(
operator|(
expr|struct
name|en_softc
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|void
name|en_txlaunch
name|__P
argument_list|(
operator|(
expr|struct
name|en_softc
operator|*
operator|,
name|int
operator|,
expr|struct
name|en_launch
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|void
name|en_service
name|__P
argument_list|(
operator|(
expr|struct
name|en_softc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|void
name|en_start
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|INLINE
name|int
name|en_sz2b
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
name|__attribute__
argument_list|(
operator|(
name|unused
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|INLINE
name|void
name|en_write
name|__P
argument_list|(
operator|(
expr|struct
name|en_softc
operator|*
operator|,
name|u_int32_t
operator|,
name|u_int32_t
operator|)
argument_list|)
name|__attribute__
argument_list|(
operator|(
name|unused
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|ATM_PVCEXT
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|en_txctl
name|__P
argument_list|(
operator|(
expr|struct
name|en_softc
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|en_pvctx
name|__P
argument_list|(
operator|(
expr|struct
name|en_softc
operator|*
operator|,
expr|struct
name|pvctxreq
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|en_pvctxget
name|__P
argument_list|(
operator|(
expr|struct
name|en_softc
operator|*
operator|,
expr|struct
name|pvctxreq
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|en_pcr2txspeed
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|en_txspeed2pcr
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * macros/inline  */
end_comment

begin_comment
comment|/*  * raw read/write macros  */
end_comment

begin_define
define|#
directive|define
name|EN_READDAT
parameter_list|(
name|SC
parameter_list|,
name|R
parameter_list|)
value|en_read(SC,R)
end_define

begin_define
define|#
directive|define
name|EN_WRITEDAT
parameter_list|(
name|SC
parameter_list|,
name|R
parameter_list|,
name|V
parameter_list|)
value|en_write(SC,R,V)
end_define

begin_comment
comment|/*  * cooked read/write macros  */
end_comment

begin_define
define|#
directive|define
name|EN_READ
parameter_list|(
name|SC
parameter_list|,
name|R
parameter_list|)
value|ntohl(en_read(SC,R))
end_define

begin_define
define|#
directive|define
name|EN_WRITE
parameter_list|(
name|SC
parameter_list|,
name|R
parameter_list|,
name|V
parameter_list|)
value|en_write(SC,R, htonl(V))
end_define

begin_define
define|#
directive|define
name|EN_WRAPADD
parameter_list|(
name|START
parameter_list|,
name|STOP
parameter_list|,
name|CUR
parameter_list|,
name|VAL
parameter_list|)
value|{ \ 	(CUR) = (CUR) + (VAL); \ 	if ((CUR)>= (STOP)) \ 		(CUR) = (START) + ((CUR) - (STOP)); \ 	}
end_define

begin_define
define|#
directive|define
name|WORD_IDX
parameter_list|(
name|START
parameter_list|,
name|X
parameter_list|)
value|(((X) - (START)) / sizeof(u_int32_t))
end_define

begin_comment
comment|/* we store sc->dtq and sc->drq data in the following format... */
end_comment

begin_define
define|#
directive|define
name|EN_DQ_MK
parameter_list|(
name|SLOT
parameter_list|,
name|LEN
parameter_list|)
value|(((SLOT)<< 20)|(LEN)|(0x80000))
end_define

begin_comment
comment|/* the 0x80000 ensures we != 0 */
end_comment

begin_define
define|#
directive|define
name|EN_DQ_SLOT
parameter_list|(
name|X
parameter_list|)
value|((X)>> 20)
end_define

begin_define
define|#
directive|define
name|EN_DQ_LEN
parameter_list|(
name|X
parameter_list|)
value|((X)& 0x3ffff)
end_define

begin_comment
comment|/* format of DTQ/DRQ word 1 differs between ENI and ADP */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|MIDWAY_ENIONLY
argument_list|)
end_if

begin_define
define|#
directive|define
name|MID_MK_TXQ
parameter_list|(
name|SC
parameter_list|,
name|CNT
parameter_list|,
name|CHAN
parameter_list|,
name|END
parameter_list|,
name|BCODE
parameter_list|)
define|\
value|EN_WRITE((SC), (SC)->dtq_us, \ 		MID_MK_TXQ_ENI((CNT), (CHAN), (END), (BCODE)));
end_define

begin_define
define|#
directive|define
name|MID_MK_RXQ
parameter_list|(
name|SC
parameter_list|,
name|CNT
parameter_list|,
name|VCI
parameter_list|,
name|END
parameter_list|,
name|BCODE
parameter_list|)
define|\
value|EN_WRITE((SC), (SC)->drq_us, \ 		MID_MK_RXQ_ENI((CNT), (VCI), (END), (BCODE)));
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|MIDWAY_ADPONLY
argument_list|)
end_elif

begin_define
define|#
directive|define
name|MID_MK_TXQ
parameter_list|(
name|SC
parameter_list|,
name|CNT
parameter_list|,
name|CHAN
parameter_list|,
name|END
parameter_list|,
name|JK
parameter_list|)
define|\
value|EN_WRITE((SC), (SC)->dtq_us, \ 		MID_MK_TXQ_ADP((CNT), (CHAN), (END), (JK)));
end_define

begin_define
define|#
directive|define
name|MID_MK_RXQ
parameter_list|(
name|SC
parameter_list|,
name|CNT
parameter_list|,
name|VCI
parameter_list|,
name|END
parameter_list|,
name|JK
parameter_list|)
define|\
value|EN_WRITE((SC), (SC)->drq_us, \ 		MID_MK_RXQ_ADP((CNT), (VCI), (END), (JK)));
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|MID_MK_TXQ
parameter_list|(
name|SC
parameter_list|,
name|CNT
parameter_list|,
name|CHAN
parameter_list|,
name|END
parameter_list|,
name|JK_OR_BCODE
parameter_list|)
value|{ \ 	if ((SC)->is_adaptec) \ 	  EN_WRITE((SC), (SC)->dtq_us, \ 		  MID_MK_TXQ_ADP((CNT), (CHAN), (END), (JK_OR_BCODE))); \ 	else \ 	  EN_WRITE((SC), (SC)->dtq_us, \ 		  MID_MK_TXQ_ENI((CNT), (CHAN), (END), (JK_OR_BCODE))); \ 	}
end_define

begin_define
define|#
directive|define
name|MID_MK_RXQ
parameter_list|(
name|SC
parameter_list|,
name|CNT
parameter_list|,
name|VCI
parameter_list|,
name|END
parameter_list|,
name|JK_OR_BCODE
parameter_list|)
value|{ \ 	if ((SC)->is_adaptec) \ 	  EN_WRITE((SC), (SC)->drq_us, \ 		  MID_MK_RXQ_ADP((CNT), (VCI), (END), (JK_OR_BCODE))); \ 	else \ 	  EN_WRITE((SC), (SC)->drq_us, \ 		   MID_MK_RXQ_ENI((CNT), (VCI), (END), (JK_OR_BCODE))); \ 	}
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* add an item to the DTQ */
end_comment

begin_define
define|#
directive|define
name|EN_DTQADD
parameter_list|(
name|SC
parameter_list|,
name|CNT
parameter_list|,
name|CHAN
parameter_list|,
name|JK_OR_BCODE
parameter_list|,
name|ADDR
parameter_list|,
name|LEN
parameter_list|,
name|END
parameter_list|)
value|{ \ 	if (END) \ 	  (SC)->dtq[MID_DTQ_A2REG((SC)->dtq_us)] = EN_DQ_MK(CHAN,LEN); \ 	MID_MK_TXQ(SC,CNT,CHAN,END,JK_OR_BCODE); \ 	(SC)->dtq_us += 4; \ 	EN_WRITE((SC), (SC)->dtq_us, (ADDR)); \ 	EN_WRAPADD(MID_DTQOFF, MID_DTQEND, (SC)->dtq_us, 4); \ 	(SC)->dtq_free--; \ 	if (END) \ 	  EN_WRITE((SC), MID_DMA_WRTX, MID_DTQ_A2REG((SC)->dtq_us)); \ }
end_define

begin_comment
comment|/* DRQ add macro */
end_comment

begin_define
define|#
directive|define
name|EN_DRQADD
parameter_list|(
name|SC
parameter_list|,
name|CNT
parameter_list|,
name|VCI
parameter_list|,
name|JK_OR_BCODE
parameter_list|,
name|ADDR
parameter_list|,
name|LEN
parameter_list|,
name|SLOT
parameter_list|,
name|END
parameter_list|)
value|{ \ 	if (END) \ 	  (SC)->drq[MID_DRQ_A2REG((SC)->drq_us)] = EN_DQ_MK(SLOT,LEN); \ 	MID_MK_RXQ(SC,CNT,VCI,END,JK_OR_BCODE); \ 	(SC)->drq_us += 4; \ 	EN_WRITE((SC), (SC)->drq_us, (ADDR)); \ 	EN_WRAPADD(MID_DRQOFF, MID_DRQEND, (SC)->drq_us, 4); \ 	(SC)->drq_free--; \ 	if (END) \ 	  EN_WRITE((SC), MID_DMA_WRRX, MID_DRQ_A2REG((SC)->drq_us)); \ }
end_define

begin_comment
comment|/*  * the driver code  *  * the code is arranged in a specific way:  * [1] short/inline functions  * [2] autoconfig stuff  * [3] ioctl stuff  * [4] reset -> init -> trasmit -> intr -> receive functions  *  */
end_comment

begin_comment
comment|/***********************************************************************/
end_comment

begin_comment
comment|/*  * en_read: read a word from the card.   this is the only function  * that reads from the card.  */
end_comment

begin_function
name|STATIC
name|INLINE
name|u_int32_t
name|en_read
parameter_list|(
name|sc
parameter_list|,
name|r
parameter_list|)
name|struct
name|en_softc
modifier|*
name|sc
decl_stmt|;
name|u_int32_t
name|r
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|EN_DEBUG_RANGE
if|if
condition|(
name|r
operator|>
name|MID_MAXOFF
operator|||
operator|(
name|r
operator|%
literal|4
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"en_read out of range, r=0x%x\n"
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"en_read"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
name|bus_space_read_4
argument_list|(
name|sc
operator|->
name|en_memt
argument_list|,
name|sc
operator|->
name|en_base
argument_list|,
name|r
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * en_write: write a word to the card.   this is the only function that  * writes to the card.  */
end_comment

begin_function
name|STATIC
name|INLINE
name|void
name|en_write
parameter_list|(
name|sc
parameter_list|,
name|r
parameter_list|,
name|v
parameter_list|)
name|struct
name|en_softc
modifier|*
name|sc
decl_stmt|;
name|u_int32_t
name|r
decl_stmt|,
name|v
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|EN_DEBUG_RANGE
if|if
condition|(
name|r
operator|>
name|MID_MAXOFF
operator|||
operator|(
name|r
operator|%
literal|4
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"en_write out of range, r=0x%x\n"
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"en_write"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|bus_space_write_4
argument_list|(
name|sc
operator|->
name|en_memt
argument_list|,
name|sc
operator|->
name|en_base
argument_list|,
name|r
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * en_k2sz: convert KBytes to a size parameter (a log2)  */
end_comment

begin_function
name|STATIC
name|INLINE
name|int
name|en_k2sz
parameter_list|(
name|k
parameter_list|)
name|int
name|k
decl_stmt|;
block|{
switch|switch
condition|(
name|k
condition|)
block|{
case|case
literal|1
case|:
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|2
case|:
return|return
operator|(
literal|1
operator|)
return|;
case|case
literal|4
case|:
return|return
operator|(
literal|2
operator|)
return|;
case|case
literal|8
case|:
return|return
operator|(
literal|3
operator|)
return|;
case|case
literal|16
case|:
return|return
operator|(
literal|4
operator|)
return|;
case|case
literal|32
case|:
return|return
operator|(
literal|5
operator|)
return|;
case|case
literal|64
case|:
return|return
operator|(
literal|6
operator|)
return|;
case|case
literal|128
case|:
return|return
operator|(
literal|7
operator|)
return|;
default|default:
name|panic
argument_list|(
literal|"en_k2sz"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|en_log2
parameter_list|(
name|X
parameter_list|)
value|en_k2sz(X)
end_define

begin_comment
comment|/*  * en_b2sz: convert a DMA burst code to its byte size  */
end_comment

begin_function
name|STATIC
name|INLINE
name|int
name|en_b2sz
parameter_list|(
name|b
parameter_list|)
name|int
name|b
decl_stmt|;
block|{
switch|switch
condition|(
name|b
condition|)
block|{
case|case
name|MIDDMA_WORD
case|:
return|return
operator|(
literal|1
operator|*
literal|4
operator|)
return|;
case|case
name|MIDDMA_2WMAYBE
case|:
case|case
name|MIDDMA_2WORD
case|:
return|return
operator|(
literal|2
operator|*
literal|4
operator|)
return|;
case|case
name|MIDDMA_4WMAYBE
case|:
case|case
name|MIDDMA_4WORD
case|:
return|return
operator|(
literal|4
operator|*
literal|4
operator|)
return|;
case|case
name|MIDDMA_8WMAYBE
case|:
case|case
name|MIDDMA_8WORD
case|:
return|return
operator|(
literal|8
operator|*
literal|4
operator|)
return|;
case|case
name|MIDDMA_16WMAYBE
case|:
case|case
name|MIDDMA_16WORD
case|:
return|return
operator|(
literal|16
operator|*
literal|4
operator|)
return|;
default|default:
name|panic
argument_list|(
literal|"en_b2sz"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * en_sz2b: convert a burst size (bytes) to DMA burst code  */
end_comment

begin_function
name|STATIC
name|INLINE
name|int
name|en_sz2b
parameter_list|(
name|sz
parameter_list|)
name|int
name|sz
decl_stmt|;
block|{
switch|switch
condition|(
name|sz
condition|)
block|{
case|case
literal|1
operator|*
literal|4
case|:
return|return
operator|(
name|MIDDMA_WORD
operator|)
return|;
case|case
literal|2
operator|*
literal|4
case|:
return|return
operator|(
name|MIDDMA_2WORD
operator|)
return|;
case|case
literal|4
operator|*
literal|4
case|:
return|return
operator|(
name|MIDDMA_4WORD
operator|)
return|;
case|case
literal|8
operator|*
literal|4
case|:
return|return
operator|(
name|MIDDMA_8WORD
operator|)
return|;
case|case
literal|16
operator|*
literal|4
case|:
return|return
operator|(
name|MIDDMA_16WORD
operator|)
return|;
default|default:
name|panic
argument_list|(
literal|"en_sz2b"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * en_dqneed: calculate number of DTQ/DRQ's needed for a buffer  */
end_comment

begin_function
name|STATIC
name|INLINE
name|int
name|en_dqneed
parameter_list|(
name|sc
parameter_list|,
name|data
parameter_list|,
name|len
parameter_list|,
name|tx
parameter_list|)
name|struct
name|en_softc
modifier|*
name|sc
decl_stmt|;
name|caddr_t
name|data
decl_stmt|;
name|u_int
name|len
decl_stmt|,
name|tx
decl_stmt|;
block|{
name|int
name|result
decl_stmt|,
name|needalign
decl_stmt|,
name|sz
decl_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|MIDWAY_ENIONLY
argument_list|)
if|#
directive|if
operator|!
name|defined
argument_list|(
name|MIDWAY_ADPONLY
argument_list|)
if|if
condition|(
name|sc
operator|->
name|is_adaptec
condition|)
endif|#
directive|endif
comment|/* !MIDWAY_ADPONLY */
return|return
operator|(
literal|1
operator|)
return|;
comment|/* adaptec can DMA anything in one go */
endif|#
directive|endif
if|#
directive|if
operator|!
name|defined
argument_list|(
name|MIDWAY_ADPONLY
argument_list|)
name|result
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|len
operator|<
name|EN_MINDMA
condition|)
block|{
if|if
condition|(
operator|!
name|tx
condition|)
comment|/* XXX: conservative */
return|return
operator|(
literal|1
operator|)
return|;
comment|/* will copy/DMA_JK */
block|}
if|if
condition|(
name|tx
condition|)
block|{
comment|/* byte burst? */
name|needalign
operator|=
operator|(
operator|(
operator|(
name|uintptr_t
operator|)
operator|(
name|void
operator|*
operator|)
name|data
operator|)
operator|%
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|needalign
condition|)
block|{
name|result
operator|++
expr_stmt|;
name|sz
operator|=
name|min
argument_list|(
name|len
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
operator|-
name|needalign
argument_list|)
expr_stmt|;
name|len
operator|-=
name|sz
expr_stmt|;
name|data
operator|+=
name|sz
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sc
operator|->
name|alburst
operator|&&
name|len
condition|)
block|{
name|needalign
operator|=
operator|(
operator|(
operator|(
name|uintptr_t
operator|)
operator|(
name|void
operator|*
operator|)
name|data
operator|)
operator|&
name|sc
operator|->
name|bestburstmask
operator|)
expr_stmt|;
if|if
condition|(
name|needalign
condition|)
block|{
name|result
operator|++
expr_stmt|;
comment|/* alburst */
name|sz
operator|=
name|min
argument_list|(
name|len
argument_list|,
name|sc
operator|->
name|bestburstlen
operator|-
name|needalign
argument_list|)
expr_stmt|;
name|len
operator|-=
name|sz
expr_stmt|;
block|}
block|}
if|if
condition|(
name|len
operator|>=
name|sc
operator|->
name|bestburstlen
condition|)
block|{
name|sz
operator|=
name|len
operator|/
name|sc
operator|->
name|bestburstlen
expr_stmt|;
name|sz
operator|=
name|sz
operator|*
name|sc
operator|->
name|bestburstlen
expr_stmt|;
name|len
operator|-=
name|sz
expr_stmt|;
name|result
operator|++
expr_stmt|;
comment|/* best shot */
block|}
if|if
condition|(
name|len
condition|)
block|{
name|result
operator|++
expr_stmt|;
comment|/* clean up */
if|if
condition|(
name|tx
operator|&&
operator|(
name|len
operator|%
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|result
operator|++
expr_stmt|;
comment|/* byte cleanup */
block|}
return|return
operator|(
name|result
operator|)
return|;
endif|#
directive|endif
comment|/* !MIDWAY_ADPONLY */
block|}
end_function

begin_comment
comment|/*  * en_mget: get an mbuf chain that can hold totlen bytes and return it  * (for recv)   [based on am7990_get from if_le and ieget from if_ie]  * after this call the sum of all the m_len's in the chain will be totlen.  */
end_comment

begin_expr_stmt
name|STATIC
name|INLINE
expr|struct
name|mbuf
operator|*
name|en_mget
argument_list|(
argument|sc
argument_list|,
argument|totlen
argument_list|,
argument|drqneed
argument_list|)
expr|struct
name|en_softc
operator|*
name|sc
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|u_int
name|totlen
decl_stmt|,
modifier|*
name|drqneed
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|top
decl_stmt|,
modifier|*
modifier|*
name|mp
decl_stmt|;
operator|*
name|drqneed
operator|=
literal|0
expr_stmt|;
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
operator|&
name|sc
operator|->
name|enif
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|totlen
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|MHLEN
expr_stmt|;
name|top
operator|=
name|NULL
expr_stmt|;
name|mp
operator|=
operator|&
name|top
expr_stmt|;
comment|/* if (top != NULL) then we've already got 1 mbuf on the chain */
while|while
condition|(
name|totlen
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|top
condition|)
block|{
name|MGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
block|{
name|m_freem
argument_list|(
name|top
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* out of mbufs */
block|}
name|m
operator|->
name|m_len
operator|=
name|MLEN
expr_stmt|;
block|}
if|if
condition|(
name|totlen
operator|>=
name|MINCLSIZE
condition|)
block|{
name|MCLGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|==
literal|0
condition|)
block|{
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|top
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* out of mbuf clusters */
block|}
name|m
operator|->
name|m_len
operator|=
name|MCLBYTES
expr_stmt|;
block|}
name|m
operator|->
name|m_len
operator|=
name|min
argument_list|(
name|totlen
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|totlen
operator|-=
name|m
operator|->
name|m_len
expr_stmt|;
operator|*
name|mp
operator|=
name|m
expr_stmt|;
name|mp
operator|=
operator|&
name|m
operator|->
name|m_next
expr_stmt|;
operator|*
name|drqneed
operator|+=
name|en_dqneed
argument_list|(
name|sc
argument_list|,
name|m
operator|->
name|m_data
argument_list|,
name|m
operator|->
name|m_len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|top
operator|)
return|;
block|}
end_block

begin_comment
comment|/***********************************************************************/
end_comment

begin_comment
comment|/*  * autoconfig stuff  */
end_comment

begin_function
name|void
name|en_attach
parameter_list|(
name|sc
parameter_list|)
name|struct
name|en_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|enif
decl_stmt|;
name|int
name|sz
decl_stmt|;
name|u_int32_t
name|reg
decl_stmt|,
name|lcv
decl_stmt|,
name|check
decl_stmt|,
name|ptr
decl_stmt|,
name|sav
decl_stmt|,
name|midvloc
decl_stmt|;
comment|/*    * probe card to determine memory size.   the stupid ENI card always    * reports to PCI that it needs 4MB of space (2MB regs and 2MB RAM).    * if it has less than 2MB RAM the addresses wrap in the RAM address space.    * (i.e. on a 512KB card addresses 0x3ffffc, 0x37fffc, and 0x2ffffc    * are aliases for 0x27fffc  [note that RAM starts at offset 0x200000]).    */
if|if
condition|(
name|sc
operator|->
name|en_busreset
condition|)
name|sc
operator|->
name|en_busreset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|EN_WRITE
argument_list|(
name|sc
argument_list|,
name|MID_RESID
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
comment|/* reset card before touching RAM */
for|for
control|(
name|lcv
operator|=
name|MID_PROBEOFF
init|;
name|lcv
operator|<=
name|MID_MAXOFF
condition|;
name|lcv
operator|+=
name|MID_PROBSIZE
control|)
block|{
name|EN_WRITE
argument_list|(
name|sc
argument_list|,
name|lcv
argument_list|,
name|lcv
argument_list|)
expr_stmt|;
comment|/* data[address] = address */
for|for
control|(
name|check
operator|=
name|MID_PROBEOFF
init|;
name|check
operator|<
name|lcv
condition|;
name|check
operator|+=
name|MID_PROBSIZE
control|)
block|{
name|reg
operator|=
name|EN_READ
argument_list|(
name|sc
argument_list|,
name|check
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|!=
name|check
condition|)
block|{
comment|/* found an alias! */
goto|goto
name|done_probe
goto|;
comment|/* and quit */
block|}
block|}
block|}
name|done_probe
label|:
name|lcv
operator|-=
name|MID_PROBSIZE
expr_stmt|;
comment|/* take one step back */
name|sc
operator|->
name|en_obmemsz
operator|=
operator|(
name|lcv
operator|+
literal|4
operator|)
operator|-
name|MID_RAMOFF
expr_stmt|;
comment|/*    * determine the largest DMA burst supported    */
name|en_dmaprobe
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/*    * "hello world"    */
if|if
condition|(
name|sc
operator|->
name|en_busreset
condition|)
name|sc
operator|->
name|en_busreset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|EN_WRITE
argument_list|(
name|sc
argument_list|,
name|MID_RESID
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
comment|/* reset */
for|for
control|(
name|lcv
operator|=
name|MID_RAMOFF
init|;
name|lcv
operator|<
name|MID_RAMOFF
operator|+
name|sc
operator|->
name|en_obmemsz
condition|;
name|lcv
operator|+=
literal|4
control|)
name|EN_WRITE
argument_list|(
name|sc
argument_list|,
name|lcv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* zero memory */
name|reg
operator|=
name|EN_READ
argument_list|(
name|sc
argument_list|,
name|MID_RESID
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: ATM midway v%d, board IDs %d.%d, %s%s%s, %ldKB on-board RAM\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|MID_VER
argument_list|(
name|reg
argument_list|)
argument_list|,
name|MID_MID
argument_list|(
name|reg
argument_list|)
argument_list|,
name|MID_DID
argument_list|(
name|reg
argument_list|)
argument_list|,
operator|(
name|MID_IS_SABRE
argument_list|(
name|reg
argument_list|)
operator|)
condition|?
literal|"sabre controller, "
else|:
literal|""
argument_list|,
operator|(
name|MID_IS_SUNI
argument_list|(
name|reg
argument_list|)
operator|)
condition|?
literal|"SUNI"
else|:
literal|"Utopia"
argument_list|,
operator|(
operator|!
name|MID_IS_SUNI
argument_list|(
name|reg
argument_list|)
operator|&&
name|MID_IS_UPIPE
argument_list|(
name|reg
argument_list|)
operator|)
condition|?
literal|" (pipelined)"
else|:
literal|""
argument_list|,
name|sc
operator|->
name|en_obmemsz
operator|/
literal|1024
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|is_adaptec
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|bestburstlen
operator|==
literal|64
operator|&&
name|sc
operator|->
name|alburst
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"%s: passed 64 byte DMA test\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%s: FAILED DMA TEST: burst=%d, alburst=%d\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|sc
operator|->
name|bestburstlen
argument_list|,
name|sc
operator|->
name|alburst
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"%s: maximum DMA burst length = %d bytes%s\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|sc
operator|->
name|bestburstlen
argument_list|,
operator|(
name|sc
operator|->
name|alburst
operator|)
condition|?
literal|" (must align)"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
comment|/*    * link into network subsystem and prepare card    */
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
name|bcopy
argument_list|(
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|sc
operator|->
name|enif
operator|.
name|if_xname
argument_list|,
name|IFNAMSIZ
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sc
operator|->
name|enif
operator|.
name|if_softc
operator|=
name|sc
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_SIMPLEX
operator||
name|IFF_NOTRAILERS
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|en_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_output
operator|=
name|atm_output
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|en_start
expr_stmt|;
comment|/*    * init softc    */
for|for
control|(
name|lcv
operator|=
literal|0
init|;
name|lcv
operator|<
name|MID_N_VC
condition|;
name|lcv
operator|++
control|)
block|{
name|sc
operator|->
name|rxvc2slot
index|[
name|lcv
index|]
operator|=
name|RX_NONE
expr_stmt|;
name|sc
operator|->
name|txspeed
index|[
name|lcv
index|]
operator|=
literal|0
expr_stmt|;
comment|/* full */
name|sc
operator|->
name|txvc2slot
index|[
name|lcv
index|]
operator|=
literal|0
expr_stmt|;
comment|/* full speed == slot 0 */
block|}
name|sz
operator|=
name|sc
operator|->
name|en_obmemsz
operator|-
operator|(
name|MID_BUFOFF
operator|-
name|MID_RAMOFF
operator|)
expr_stmt|;
name|ptr
operator|=
name|sav
operator|=
name|MID_BUFOFF
expr_stmt|;
name|ptr
operator|=
name|roundup
argument_list|(
name|ptr
argument_list|,
name|EN_TXSZ
operator|*
literal|1024
argument_list|)
expr_stmt|;
comment|/* align */
name|sz
operator|=
name|sz
operator|-
operator|(
name|ptr
operator|-
name|sav
operator|)
expr_stmt|;
if|if
condition|(
name|EN_TXSZ
operator|*
literal|1024
operator|*
name|EN_NTX
operator|>
name|sz
condition|)
block|{
name|printf
argument_list|(
literal|"%s: EN_NTX/EN_TXSZ too big\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|lcv
operator|=
literal|0
init|;
name|lcv
operator|<
name|EN_NTX
condition|;
name|lcv
operator|++
control|)
block|{
name|sc
operator|->
name|txslot
index|[
name|lcv
index|]
operator|.
name|mbsize
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|txslot
index|[
name|lcv
index|]
operator|.
name|start
operator|=
name|ptr
expr_stmt|;
name|ptr
operator|+=
operator|(
name|EN_TXSZ
operator|*
literal|1024
operator|)
expr_stmt|;
name|sz
operator|-=
operator|(
name|EN_TXSZ
operator|*
literal|1024
operator|)
expr_stmt|;
name|sc
operator|->
name|txslot
index|[
name|lcv
index|]
operator|.
name|stop
operator|=
name|ptr
expr_stmt|;
name|sc
operator|->
name|txslot
index|[
name|lcv
index|]
operator|.
name|nref
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|sc
operator|->
name|txslot
index|[
name|lcv
index|]
operator|.
name|indma
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|txslot
index|[
name|lcv
index|]
operator|.
name|indma
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|sc
operator|->
name|txslot
index|[
name|lcv
index|]
operator|.
name|q
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|txslot
index|[
name|lcv
index|]
operator|.
name|q
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EN_DEBUG
name|printf
argument_list|(
literal|"%s: tx%d: start 0x%x, stop 0x%x\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|lcv
argument_list|,
name|sc
operator|->
name|txslot
index|[
name|lcv
index|]
operator|.
name|start
argument_list|,
name|sc
operator|->
name|txslot
index|[
name|lcv
index|]
operator|.
name|stop
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|sav
operator|=
name|ptr
expr_stmt|;
name|ptr
operator|=
name|roundup
argument_list|(
name|ptr
argument_list|,
name|EN_RXSZ
operator|*
literal|1024
argument_list|)
expr_stmt|;
comment|/* align */
name|sz
operator|=
name|sz
operator|-
operator|(
name|ptr
operator|-
name|sav
operator|)
expr_stmt|;
name|sc
operator|->
name|en_nrx
operator|=
name|sz
operator|/
operator|(
name|EN_RXSZ
operator|*
literal|1024
operator|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|en_nrx
operator|<=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: EN_NTX/EN_TXSZ/EN_RXSZ too big\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*     * ensure that there is always one VC slot on the service list free    * so that we can tell the difference between a full and empty list.    */
if|if
condition|(
name|sc
operator|->
name|en_nrx
operator|>=
name|MID_N_VC
condition|)
name|sc
operator|->
name|en_nrx
operator|=
name|MID_N_VC
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|lcv
operator|=
literal|0
init|;
name|lcv
operator|<
name|sc
operator|->
name|en_nrx
condition|;
name|lcv
operator|++
control|)
block|{
name|sc
operator|->
name|rxslot
index|[
name|lcv
index|]
operator|.
name|rxhand
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|rxslot
index|[
name|lcv
index|]
operator|.
name|oth_flags
operator|=
name|ENOTHER_FREE
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|sc
operator|->
name|rxslot
index|[
name|lcv
index|]
operator|.
name|indma
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|rxslot
index|[
name|lcv
index|]
operator|.
name|indma
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|sc
operator|->
name|rxslot
index|[
name|lcv
index|]
operator|.
name|q
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|rxslot
index|[
name|lcv
index|]
operator|.
name|q
argument_list|)
argument_list|)
expr_stmt|;
name|midvloc
operator|=
name|sc
operator|->
name|rxslot
index|[
name|lcv
index|]
operator|.
name|start
operator|=
name|ptr
expr_stmt|;
name|ptr
operator|+=
operator|(
name|EN_RXSZ
operator|*
literal|1024
operator|)
expr_stmt|;
name|sz
operator|-=
operator|(
name|EN_RXSZ
operator|*
literal|1024
operator|)
expr_stmt|;
name|sc
operator|->
name|rxslot
index|[
name|lcv
index|]
operator|.
name|stop
operator|=
name|ptr
expr_stmt|;
name|midvloc
operator|=
name|midvloc
operator|-
name|MID_RAMOFF
expr_stmt|;
name|midvloc
operator|=
operator|(
name|midvloc
operator|&
operator|~
operator|(
operator|(
name|EN_RXSZ
operator|*
literal|1024
operator|)
operator|-
literal|1
operator|)
operator|)
operator|>>
literal|2
expr_stmt|;
comment|/* mask, cvt to words */
name|midvloc
operator|=
name|midvloc
operator|>>
name|MIDV_LOCTOPSHFT
expr_stmt|;
comment|/* we only want the top 11 bits */
name|midvloc
operator|=
operator|(
name|midvloc
operator|&
name|MIDV_LOCMASK
operator|)
operator|<<
name|MIDV_LOCSHIFT
expr_stmt|;
name|sc
operator|->
name|rxslot
index|[
name|lcv
index|]
operator|.
name|mode
operator|=
name|midvloc
operator||
operator|(
name|en_k2sz
argument_list|(
name|EN_RXSZ
argument_list|)
operator|<<
name|MIDV_SZSHIFT
operator|)
operator||
name|MIDV_TRASH
expr_stmt|;
ifdef|#
directive|ifdef
name|EN_DEBUG
name|printf
argument_list|(
literal|"%s: rx%d: start 0x%x, stop 0x%x, mode 0x%x\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|lcv
argument_list|,
name|sc
operator|->
name|rxslot
index|[
name|lcv
index|]
operator|.
name|start
argument_list|,
name|sc
operator|->
name|rxslot
index|[
name|lcv
index|]
operator|.
name|stop
argument_list|,
name|sc
operator|->
name|rxslot
index|[
name|lcv
index|]
operator|.
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|EN_STAT
name|sc
operator|->
name|vtrash
operator|=
name|sc
operator|->
name|otrash
operator|=
name|sc
operator|->
name|mfix
operator|=
name|sc
operator|->
name|txmbovr
operator|=
name|sc
operator|->
name|dmaovr
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|txoutspace
operator|=
name|sc
operator|->
name|txdtqout
operator|=
name|sc
operator|->
name|launch
operator|=
name|sc
operator|->
name|lheader
operator|=
name|sc
operator|->
name|ltail
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|hwpull
operator|=
name|sc
operator|->
name|swadd
operator|=
name|sc
operator|->
name|rxqnotus
operator|=
name|sc
operator|->
name|rxqus
operator|=
name|sc
operator|->
name|rxoutboth
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|rxdrqout
operator|=
name|sc
operator|->
name|ttrash
operator|=
name|sc
operator|->
name|rxmbufout
operator|=
name|sc
operator|->
name|mfixfail
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|headbyte
operator|=
name|sc
operator|->
name|tailbyte
operator|=
name|sc
operator|->
name|tailflush
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|sc
operator|->
name|need_drqs
operator|=
name|sc
operator|->
name|need_dtqs
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"%s: %d %dKB receive buffers, %d %dKB transmit buffers allocated\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|sc
operator|->
name|en_nrx
argument_list|,
name|EN_RXSZ
argument_list|,
name|EN_NTX
argument_list|,
name|EN_TXSZ
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: End Station Identifier (mac address) %6D\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|sc
operator|->
name|macaddr
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
comment|/*    * final commit    */
name|if_attach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|atm_ifattach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
name|BPFATTACH
argument_list|(
name|ifp
argument_list|,
name|DLT_ATM_RFC1483
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|atmllc
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * en_dmaprobe: helper function for en_attach.  *  * see how the card handles DMA by running a few DMA tests.   we need  * to figure out the largest number of bytes we can DMA in one burst  * ("bestburstlen"), and if the starting address for a burst needs to  * be aligned on any sort of boundary or not ("alburst").  *  * typical findings:  * sparc1: bestburstlen=4, alburst=0 (ick, broken DMA!)  * sparc2: bestburstlen=64, alburst=1  * p166:   bestburstlen=64, alburst=0   */
end_comment

begin_if
if|#
directive|if
literal|1
end_if

begin_comment
comment|/* __FreeBSD__ */
end_comment

begin_define
define|#
directive|define
name|NBURSTS
value|3
end_define

begin_comment
comment|/* number of bursts to use for dmaprobe */
end_comment

begin_define
define|#
directive|define
name|BOUNDARY
value|1024
end_define

begin_comment
comment|/* test misaligned dma crossing the bounday. 			   should be n * 64.  at least 64*(NBURSTS+1). 			   dell P6 with EDO DRAM has 1K bounday problem */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|STATIC
name|void
name|en_dmaprobe
parameter_list|(
name|sc
parameter_list|)
name|struct
name|en_softc
modifier|*
name|sc
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|NBURSTS
comment|/* be careful. kernel stack is only 8K */
name|u_int8_t
name|buffer
index|[
name|BOUNDARY
operator|*
literal|2
operator|+
literal|64
operator|*
operator|(
name|NBURSTS
operator|+
literal|1
operator|)
index|]
decl_stmt|;
else|#
directive|else
name|u_int32_t
name|srcbuf
index|[
literal|64
index|]
decl_stmt|,
name|dstbuf
index|[
literal|64
index|]
decl_stmt|;
endif|#
directive|endif
name|u_int8_t
modifier|*
name|sp
decl_stmt|,
modifier|*
name|dp
decl_stmt|;
name|int
name|bestalgn
decl_stmt|,
name|bestnotalgn
decl_stmt|,
name|lcv
decl_stmt|,
name|try
decl_stmt|;
name|sc
operator|->
name|alburst
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|NBURSTS
comment|/* setup src and dst buf at the end of the boundary */
name|sp
operator|=
operator|(
name|u_int8_t
operator|*
operator|)
name|roundup
argument_list|(
operator|(
name|uintptr_t
operator|)
operator|(
name|void
operator|*
operator|)
name|buffer
argument_list|,
literal|64
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
operator|(
name|uintptr_t
operator|)
operator|(
name|void
operator|*
operator|)
name|sp
operator|&
operator|(
name|BOUNDARY
operator|-
literal|1
operator|)
operator|)
operator|!=
operator|(
name|BOUNDARY
operator|-
literal|64
operator|)
condition|)
name|sp
operator|+=
literal|64
expr_stmt|;
name|dp
operator|=
name|sp
operator|+
name|BOUNDARY
expr_stmt|;
comment|/*    * we can't dma across page boundary so that, if buf is at a page    * boundary, move it to the next page.  but still either src or dst    * will be at the boundary, which should be ok.    */
if|if
condition|(
operator|(
operator|(
operator|(
name|uintptr_t
operator|)
operator|(
name|void
operator|*
operator|)
name|sp
operator|+
literal|64
operator|)
operator|&
name|PAGE_MASK
operator|)
operator|==
literal|0
condition|)
name|sp
operator|+=
literal|64
expr_stmt|;
if|if
condition|(
operator|(
operator|(
operator|(
name|uintptr_t
operator|)
operator|(
name|void
operator|*
operator|)
name|dp
operator|+
literal|64
operator|)
operator|&
name|PAGE_MASK
operator|)
operator|==
literal|0
condition|)
name|dp
operator|+=
literal|64
expr_stmt|;
else|#
directive|else
comment|/* !NBURSTS */
name|sp
operator|=
operator|(
name|u_int8_t
operator|*
operator|)
name|srcbuf
expr_stmt|;
while|while
condition|(
operator|(
operator|(
operator|(
name|unsigned
name|long
operator|)
name|sp
operator|)
operator|%
name|MIDDMA_MAXBURST
operator|)
operator|!=
literal|0
condition|)
name|sp
operator|+=
literal|4
expr_stmt|;
name|dp
operator|=
operator|(
name|u_int8_t
operator|*
operator|)
name|dstbuf
expr_stmt|;
while|while
condition|(
operator|(
operator|(
operator|(
name|unsigned
name|long
operator|)
name|dp
operator|)
operator|%
name|MIDDMA_MAXBURST
operator|)
operator|!=
literal|0
condition|)
name|dp
operator|+=
literal|4
expr_stmt|;
endif|#
directive|endif
comment|/* !NBURSTS */
name|bestalgn
operator|=
name|bestnotalgn
operator|=
name|en_dmaprobe_doit
argument_list|(
name|sc
argument_list|,
name|sp
argument_list|,
name|dp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|lcv
operator|=
literal|4
init|;
name|lcv
operator|<
name|MIDDMA_MAXBURST
condition|;
name|lcv
operator|+=
literal|4
control|)
block|{
name|try
operator|=
name|en_dmaprobe_doit
argument_list|(
name|sc
argument_list|,
name|sp
operator|+
name|lcv
argument_list|,
name|dp
operator|+
name|lcv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NBURSTS
if|if
condition|(
name|try
operator|<
name|bestnotalgn
condition|)
block|{
name|bestnotalgn
operator|=
name|try
expr_stmt|;
break|break;
block|}
else|#
directive|else
if|if
condition|(
name|try
operator|<
name|bestnotalgn
condition|)
name|bestnotalgn
operator|=
name|try
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|bestalgn
operator|!=
name|bestnotalgn
condition|)
comment|/* need bursts aligned */
name|sc
operator|->
name|alburst
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|bestburstlen
operator|=
name|bestalgn
expr_stmt|;
name|sc
operator|->
name|bestburstshift
operator|=
name|en_log2
argument_list|(
name|bestalgn
argument_list|)
expr_stmt|;
name|sc
operator|->
name|bestburstmask
operator|=
name|sc
operator|->
name|bestburstlen
operator|-
literal|1
expr_stmt|;
comment|/* must be power of 2 */
name|sc
operator|->
name|bestburstcode
operator|=
name|en_sz2b
argument_list|(
name|bestalgn
argument_list|)
expr_stmt|;
if|#
directive|if
literal|1
comment|/* __FreeBSD__ */
comment|/*    * correct pci chipsets should be able to handle misaligned-64-byte DMA.    * but there are too many broken chipsets around.  we try to work around    * by finding the best workable dma size, but still some broken machines    * exhibit the problem later. so warn it here.    */
if|if
condition|(
name|bestalgn
operator|!=
literal|64
operator|||
name|sc
operator|->
name|alburst
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: WARNING: DMA test detects a broken PCI chipset!\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"     trying to work around the problem...  but if this doesn't\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"     work for you, you'd better switch to a newer motherboard.\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 1 */
return|return;
block|}
end_function

begin_comment
comment|/*  * en_dmaprobe_doit: do actual testing  */
end_comment

begin_function
name|int
name|en_dmaprobe_doit
parameter_list|(
name|sc
parameter_list|,
name|sp
parameter_list|,
name|dp
parameter_list|,
name|wmtry
parameter_list|)
name|struct
name|en_softc
modifier|*
name|sc
decl_stmt|;
name|u_int8_t
modifier|*
name|sp
decl_stmt|,
decl|*
name|dp
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|wmtry
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|lcv
decl_stmt|,
name|retval
init|=
literal|4
decl_stmt|,
name|cnt
decl_stmt|,
name|count
decl_stmt|;
name|u_int32_t
name|reg
decl_stmt|,
name|bcode
decl_stmt|,
name|midvloc
decl_stmt|;
comment|/*    * set up a 1k buffer at MID_BUFOFF    */
if|if
condition|(
name|sc
operator|->
name|en_busreset
condition|)
name|sc
operator|->
name|en_busreset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|EN_WRITE
argument_list|(
name|sc
argument_list|,
name|MID_RESID
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
comment|/* reset card before touching RAM */
name|midvloc
operator|=
operator|(
operator|(
name|MID_BUFOFF
operator|-
name|MID_RAMOFF
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
operator|)
operator|>>
name|MIDV_LOCTOPSHFT
expr_stmt|;
name|EN_WRITE
argument_list|(
name|sc
argument_list|,
name|MIDX_PLACE
argument_list|(
literal|0
argument_list|)
argument_list|,
name|MIDX_MKPLACE
argument_list|(
name|en_k2sz
argument_list|(
literal|1
argument_list|)
argument_list|,
name|midvloc
argument_list|)
argument_list|)
expr_stmt|;
name|EN_WRITE
argument_list|(
name|sc
argument_list|,
name|MID_VC
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|(
name|midvloc
operator|<<
name|MIDV_LOCSHIFT
operator|)
operator||
operator|(
name|en_k2sz
argument_list|(
literal|1
argument_list|)
operator|<<
name|MIDV_SZSHIFT
operator|)
operator||
name|MIDV_TRASH
argument_list|)
expr_stmt|;
name|EN_WRITE
argument_list|(
name|sc
argument_list|,
name|MID_DST_RP
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|EN_WRITE
argument_list|(
name|sc
argument_list|,
name|MID_WP_ST_CNT
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NBURSTS
for|for
control|(
name|lcv
operator|=
literal|0
init|;
name|lcv
operator|<
literal|64
operator|*
name|NBURSTS
condition|;
name|lcv
operator|++
control|)
comment|/* set up sample data */
else|#
directive|else
for|for
control|(
name|lcv
operator|=
literal|0
init|;
name|lcv
operator|<
literal|68
condition|;
name|lcv
operator|++
control|)
comment|/* set up sample data */
endif|#
directive|endif
name|sp
index|[
name|lcv
index|]
operator|=
name|lcv
operator|+
literal|1
expr_stmt|;
name|EN_WRITE
argument_list|(
name|sc
argument_list|,
name|MID_MAST_CSR
argument_list|,
name|MID_MCSR_ENDMA
argument_list|)
expr_stmt|;
comment|/* enable DMA (only) */
name|sc
operator|->
name|drq_chip
operator|=
name|MID_DRQ_REG2A
argument_list|(
name|EN_READ
argument_list|(
name|sc
argument_list|,
name|MID_DMA_RDRX
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|dtq_chip
operator|=
name|MID_DTQ_REG2A
argument_list|(
name|EN_READ
argument_list|(
name|sc
argument_list|,
name|MID_DMA_RDTX
argument_list|)
argument_list|)
expr_stmt|;
comment|/*    * try it now . . .  DMA it out, then DMA it back in and compare    *    * note: in order to get the dma stuff to reverse directions it wants    * the "end" flag set!   since we are not dma'ing valid data we may    * get an ident mismatch interrupt (which we will ignore).    *    * note: we've got two different tests rolled up in the same loop    * if (wmtry)     *   then we are doing a wmaybe test and wmtry is a byte count    *   else we are doing a burst test    */
for|for
control|(
name|lcv
operator|=
literal|8
init|;
name|lcv
operator|<=
name|MIDDMA_MAXBURST
condition|;
name|lcv
operator|=
name|lcv
operator|*
literal|2
control|)
block|{
ifdef|#
directive|ifdef
name|EN_DEBUG
name|printf
argument_list|(
literal|"DMA test lcv=%d, sp=0x%x, dp=0x%x, wmtry=%d\n"
argument_list|,
name|lcv
argument_list|,
name|sp
argument_list|,
name|dp
argument_list|,
name|wmtry
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* zero SRAM and dest buffer */
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
literal|1024
condition|;
name|cnt
operator|+=
literal|4
control|)
name|EN_WRITE
argument_list|(
name|sc
argument_list|,
name|MID_BUFOFF
operator|+
name|cnt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* zero memory */
ifdef|#
directive|ifdef
name|NBURSTS
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
literal|64
operator|*
name|NBURSTS
condition|;
name|cnt
operator|++
control|)
else|#
directive|else
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
literal|68
condition|;
name|cnt
operator|++
control|)
endif|#
directive|endif
name|dp
index|[
name|cnt
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|wmtry
condition|)
block|{
name|count
operator|=
operator|(
name|sc
operator|->
name|bestburstlen
operator|-
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
expr_stmt|;
name|bcode
operator|=
name|en_dmaplan
index|[
name|count
index|]
operator|.
name|bcode
expr_stmt|;
name|count
operator|=
name|wmtry
operator|>>
name|en_dmaplan
index|[
name|count
index|]
operator|.
name|divshift
expr_stmt|;
block|}
else|else
block|{
name|bcode
operator|=
name|en_sz2b
argument_list|(
name|lcv
argument_list|)
expr_stmt|;
name|count
operator|=
literal|1
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|NBURSTS
comment|/* build lcv-byte-DMA x NBURSTS */
if|if
condition|(
name|sc
operator|->
name|is_adaptec
condition|)
name|EN_WRITE
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|dtq_chip
argument_list|,
name|MID_MK_TXQ_ADP
argument_list|(
name|lcv
operator|*
name|NBURSTS
argument_list|,
literal|0
argument_list|,
name|MID_DMA_END
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|EN_WRITE
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|dtq_chip
argument_list|,
name|MID_MK_TXQ_ENI
argument_list|(
name|count
operator|*
name|NBURSTS
argument_list|,
literal|0
argument_list|,
name|MID_DMA_END
argument_list|,
name|bcode
argument_list|)
argument_list|)
expr_stmt|;
name|EN_WRITE
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|dtq_chip
operator|+
literal|4
argument_list|,
name|vtophys
argument_list|(
name|sp
argument_list|)
argument_list|)
expr_stmt|;
name|EN_WRAPADD
argument_list|(
name|MID_DTQOFF
argument_list|,
name|MID_DTQEND
argument_list|,
name|sc
operator|->
name|dtq_chip
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|EN_WRITE
argument_list|(
name|sc
argument_list|,
name|MID_DMA_WRTX
argument_list|,
name|MID_DTQ_A2REG
argument_list|(
name|sc
operator|->
name|dtq_chip
argument_list|)
argument_list|)
expr_stmt|;
name|cnt
operator|=
literal|1000
expr_stmt|;
while|while
condition|(
name|EN_READ
argument_list|(
name|sc
argument_list|,
name|MID_DMA_RDTX
argument_list|)
operator|!=
name|MID_DTQ_A2REG
argument_list|(
name|sc
operator|->
name|dtq_chip
argument_list|)
condition|)
block|{
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|cnt
operator|--
expr_stmt|;
if|if
condition|(
name|cnt
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: unexpected timeout in tx DMA test\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|)
expr_stmt|;
comment|/* 	printf("  alignment=0x%x, burst size=%d, dma addr reg=0x%x\n", 	       (u_long)sp& 63, lcv, EN_READ(sc, MID_DMA_ADDR)); */
return|return
operator|(
name|retval
operator|)
return|;
comment|/* timeout, give up */
block|}
block|}
else|#
directive|else
comment|/* !NBURSTS */
if|if
condition|(
name|sc
operator|->
name|is_adaptec
condition|)
name|EN_WRITE
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|dtq_chip
argument_list|,
name|MID_MK_TXQ_ADP
argument_list|(
name|lcv
argument_list|,
literal|0
argument_list|,
name|MID_DMA_END
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|EN_WRITE
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|dtq_chip
argument_list|,
name|MID_MK_TXQ_ENI
argument_list|(
name|count
argument_list|,
literal|0
argument_list|,
name|MID_DMA_END
argument_list|,
name|bcode
argument_list|)
argument_list|)
expr_stmt|;
name|EN_WRITE
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|dtq_chip
operator|+
literal|4
argument_list|,
name|vtophys
argument_list|(
name|sp
argument_list|)
argument_list|)
expr_stmt|;
name|EN_WRITE
argument_list|(
name|sc
argument_list|,
name|MID_DMA_WRTX
argument_list|,
name|MID_DTQ_A2REG
argument_list|(
name|sc
operator|->
name|dtq_chip
operator|+
literal|8
argument_list|)
argument_list|)
expr_stmt|;
name|cnt
operator|=
literal|1000
expr_stmt|;
while|while
condition|(
name|EN_READ
argument_list|(
name|sc
argument_list|,
name|MID_DMA_RDTX
argument_list|)
operator|==
name|MID_DTQ_A2REG
argument_list|(
name|sc
operator|->
name|dtq_chip
argument_list|)
condition|)
block|{
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|cnt
operator|--
expr_stmt|;
if|if
condition|(
name|cnt
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: unexpected timeout in tx DMA test\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
comment|/* timeout, give up */
block|}
block|}
name|EN_WRAPADD
argument_list|(
name|MID_DTQOFF
argument_list|,
name|MID_DTQEND
argument_list|,
name|sc
operator|->
name|dtq_chip
argument_list|,
literal|8
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !NBURSTS */
name|reg
operator|=
name|EN_READ
argument_list|(
name|sc
argument_list|,
name|MID_INTACK
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|reg
operator|&
name|MID_INT_DMA_TX
operator|)
operator|!=
name|MID_INT_DMA_TX
condition|)
block|{
name|printf
argument_list|(
literal|"%s: unexpected status in tx DMA test: 0x%x\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|reg
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
name|EN_WRITE
argument_list|(
name|sc
argument_list|,
name|MID_MAST_CSR
argument_list|,
name|MID_MCSR_ENDMA
argument_list|)
expr_stmt|;
comment|/* re-enable DMA (only) */
comment|/* "return to sender..."  address is known ... */
ifdef|#
directive|ifdef
name|NBURSTS
comment|/* build lcv-byte-DMA x NBURSTS */
if|if
condition|(
name|sc
operator|->
name|is_adaptec
condition|)
name|EN_WRITE
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|drq_chip
argument_list|,
name|MID_MK_RXQ_ADP
argument_list|(
name|lcv
operator|*
name|NBURSTS
argument_list|,
literal|0
argument_list|,
name|MID_DMA_END
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|EN_WRITE
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|drq_chip
argument_list|,
name|MID_MK_RXQ_ENI
argument_list|(
name|count
operator|*
name|NBURSTS
argument_list|,
literal|0
argument_list|,
name|MID_DMA_END
argument_list|,
name|bcode
argument_list|)
argument_list|)
expr_stmt|;
name|EN_WRITE
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|drq_chip
operator|+
literal|4
argument_list|,
name|vtophys
argument_list|(
name|dp
argument_list|)
argument_list|)
expr_stmt|;
name|EN_WRAPADD
argument_list|(
name|MID_DRQOFF
argument_list|,
name|MID_DRQEND
argument_list|,
name|sc
operator|->
name|drq_chip
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|EN_WRITE
argument_list|(
name|sc
argument_list|,
name|MID_DMA_WRRX
argument_list|,
name|MID_DRQ_A2REG
argument_list|(
name|sc
operator|->
name|drq_chip
argument_list|)
argument_list|)
expr_stmt|;
name|cnt
operator|=
literal|1000
expr_stmt|;
while|while
condition|(
name|EN_READ
argument_list|(
name|sc
argument_list|,
name|MID_DMA_RDRX
argument_list|)
operator|!=
name|MID_DRQ_A2REG
argument_list|(
name|sc
operator|->
name|drq_chip
argument_list|)
condition|)
block|{
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|cnt
operator|--
expr_stmt|;
if|if
condition|(
name|cnt
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: unexpected timeout in rx DMA test\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
comment|/* timeout, give up */
block|}
block|}
else|#
directive|else
comment|/* !NBURSTS */
if|if
condition|(
name|sc
operator|->
name|is_adaptec
condition|)
name|EN_WRITE
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|drq_chip
argument_list|,
name|MID_MK_RXQ_ADP
argument_list|(
name|lcv
argument_list|,
literal|0
argument_list|,
name|MID_DMA_END
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|EN_WRITE
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|drq_chip
argument_list|,
name|MID_MK_RXQ_ENI
argument_list|(
name|count
argument_list|,
literal|0
argument_list|,
name|MID_DMA_END
argument_list|,
name|bcode
argument_list|)
argument_list|)
expr_stmt|;
name|EN_WRITE
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|drq_chip
operator|+
literal|4
argument_list|,
name|vtophys
argument_list|(
name|dp
argument_list|)
argument_list|)
expr_stmt|;
name|EN_WRITE
argument_list|(
name|sc
argument_list|,
name|MID_DMA_WRRX
argument_list|,
name|MID_DRQ_A2REG
argument_list|(
name|sc
operator|->
name|drq_chip
operator|+
literal|8
argument_list|)
argument_list|)
expr_stmt|;
name|cnt
operator|=
literal|1000
expr_stmt|;
while|while
condition|(
name|EN_READ
argument_list|(
name|sc
argument_list|,
name|MID_DMA_RDRX
argument_list|)
operator|==
name|MID_DRQ_A2REG
argument_list|(
name|sc
operator|->
name|drq_chip
argument_list|)
condition|)
block|{
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|cnt
operator|--
expr_stmt|;
if|if
condition|(
name|cnt
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: unexpected timeout in rx DMA test\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
comment|/* timeout, give up */
block|}
block|}
name|EN_WRAPADD
argument_list|(
name|MID_DRQOFF
argument_list|,
name|MID_DRQEND
argument_list|,
name|sc
operator|->
name|drq_chip
argument_list|,
literal|8
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !NBURSTS */
name|reg
operator|=
name|EN_READ
argument_list|(
name|sc
argument_list|,
name|MID_INTACK
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|reg
operator|&
name|MID_INT_DMA_RX
operator|)
operator|!=
name|MID_INT_DMA_RX
condition|)
block|{
name|printf
argument_list|(
literal|"%s: unexpected status in rx DMA test: 0x%x\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|reg
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
name|EN_WRITE
argument_list|(
name|sc
argument_list|,
name|MID_MAST_CSR
argument_list|,
name|MID_MCSR_ENDMA
argument_list|)
expr_stmt|;
comment|/* re-enable DMA (only) */
if|if
condition|(
name|wmtry
condition|)
block|{
return|return
operator|(
name|bcmp
argument_list|(
name|sp
argument_list|,
name|dp
argument_list|,
name|wmtry
argument_list|)
operator|)
return|;
comment|/* wmtry always exits here, no looping */
block|}
ifdef|#
directive|ifdef
name|NBURSTS
if|if
condition|(
name|bcmp
argument_list|(
name|sp
argument_list|,
name|dp
argument_list|,
name|lcv
operator|*
name|NBURSTS
argument_list|)
condition|)
block|{
comment|/*      printf("DMA test failed! lcv=%d, sp=0x%x, dp=0x%x\n", lcv, sp, dp); */
return|return
operator|(
name|retval
operator|)
return|;
comment|/* failed, use last value */
block|}
else|#
directive|else
if|if
condition|(
name|bcmp
argument_list|(
name|sp
argument_list|,
name|dp
argument_list|,
name|lcv
argument_list|)
condition|)
return|return
operator|(
name|retval
operator|)
return|;
comment|/* failed, use last value */
endif|#
directive|endif
name|retval
operator|=
name|lcv
expr_stmt|;
block|}
return|return
operator|(
name|retval
operator|)
return|;
comment|/* studly 64 byte DMA present!  oh baby!! */
block|}
end_block

begin_comment
comment|/***********************************************************************/
end_comment

begin_comment
comment|/*  * en_ioctl: handle ioctl requests  *  * NOTE: if you add an ioctl to set txspeed, you should choose a new  * TX channel/slot.   Choose the one with the lowest sc->txslot[slot].nref  * value, subtract one from sc->txslot[0].nref, add one to the  * sc->txslot[slot].nref, set sc->txvc2slot[vci] = slot, and then set  * txspeed[vci].  */
end_comment

begin_function
name|STATIC
name|int
name|en_ioctl
parameter_list|(
name|ifp
parameter_list|,
name|cmd
parameter_list|,
name|data
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|EN_IOCTL_CMDT
name|cmd
decl_stmt|;
name|caddr_t
name|data
decl_stmt|;
block|{
name|struct
name|en_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|en_softc
operator|*
operator|)
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ifaddr
modifier|*
name|ifa
init|=
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|atm_pseudoioctl
modifier|*
name|api
init|=
operator|(
expr|struct
name|atm_pseudoioctl
operator|*
operator|)
name|data
decl_stmt|;
ifdef|#
directive|ifdef
name|NATM
name|struct
name|atm_rawioctl
modifier|*
name|ario
init|=
operator|(
expr|struct
name|atm_rawioctl
operator|*
operator|)
name|data
decl_stmt|;
name|int
name|slot
decl_stmt|;
endif|#
directive|endif
name|int
name|s
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCATMENA
case|:
comment|/* enable circuit for recv */
name|error
operator|=
name|en_rxctl
argument_list|(
name|sc
argument_list|,
name|api
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCATMDIS
case|:
comment|/* disable circuit for recv */
name|error
operator|=
name|en_rxctl
argument_list|(
name|sc
argument_list|,
name|api
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|NATM
case|case
name|SIOCXRAWATM
case|:
if|if
condition|(
operator|(
name|slot
operator|=
name|sc
operator|->
name|rxvc2slot
index|[
name|ario
operator|->
name|npcb
operator|->
name|npcb_vci
index|]
operator|)
operator|==
name|RX_NONE
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ario
operator|->
name|rawvalue
operator|>
name|EN_RXSZ
operator|*
literal|1024
condition|)
name|ario
operator|->
name|rawvalue
operator|=
name|EN_RXSZ
operator|*
literal|1024
expr_stmt|;
if|if
condition|(
name|ario
operator|->
name|rawvalue
condition|)
block|{
name|sc
operator|->
name|rxslot
index|[
name|slot
index|]
operator|.
name|oth_flags
operator||=
name|ENOTHER_RAW
expr_stmt|;
name|sc
operator|->
name|rxslot
index|[
name|slot
index|]
operator|.
name|raw_threshold
operator|=
name|ario
operator|->
name|rawvalue
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|rxslot
index|[
name|slot
index|]
operator|.
name|oth_flags
operator|&=
operator|(
operator|~
name|ENOTHER_RAW
operator|)
expr_stmt|;
name|sc
operator|->
name|rxslot
index|[
name|slot
index|]
operator|.
name|raw_threshold
operator|=
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|EN_DEBUG
name|printf
argument_list|(
literal|"%s: rxvci%d: turn %s raw (boodi) mode\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|ario
operator|->
name|npcb
operator|->
name|npcb_vci
argument_list|,
operator|(
name|ario
operator|->
name|rawvalue
operator|)
condition|?
literal|"on"
else|:
literal|"off"
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
endif|#
directive|endif
case|case
name|SIOCSIFADDR
case|:
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_UP
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|||
name|defined
argument_list|(
name|INET6
argument_list|)
if|if
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|==
name|AF_INET
operator|||
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|==
name|AF_INET6
condition|)
block|{
name|en_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|en_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifa
operator|->
name|ifa_rtrequest
operator|=
name|atm_rtrequest
expr_stmt|;
comment|/* ??? */
break|break;
block|}
endif|#
directive|endif
comment|/* INET */
comment|/* what to do if not INET? */
name|en_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|en_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCGIFADDR
case|:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
case|case
name|SIOCSIFFLAGS
case|:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
if|#
directive|if
name|defined
argument_list|(
name|SIOCSIFMTU
argument_list|)
comment|/* ??? copied from if_de */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|ifr_mtu
argument_list|)
define|#
directive|define
name|ifr_mtu
value|ifr_metric
endif|#
directive|endif
case|case
name|SIOCSIFMTU
case|:
comment|/* 	     * Set the interface MTU. 	     */
ifdef|#
directive|ifdef
name|notsure
if|if
condition|(
name|ifr
operator|->
name|ifr_mtu
operator|>
name|ATMMTU
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
name|ifp
operator|->
name|if_mtu
operator|=
name|ifr
operator|->
name|ifr_mtu
expr_stmt|;
comment|/* XXXCDC: do we really need to reset on MTU size change? */
name|en_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|en_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* SIOCSIFMTU */
ifdef|#
directive|ifdef
name|ATM_PVCEXT
case|case
name|SIOCSPVCTX
case|:
if|if
condition|(
operator|(
name|error
operator|=
name|suser
argument_list|(
name|curproc
operator|->
name|p_ucred
argument_list|,
operator|&
name|curproc
operator|->
name|p_acflag
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|error
operator|=
name|en_pvctx
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|pvctxreq
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCGPVCTX
case|:
name|error
operator|=
name|en_pvctxget
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|pvctxreq
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSPVCSIF
case|:
do|do
block|{
name|struct
name|ifnet
modifier|*
name|shadow
decl_stmt|;
if|if
condition|(
name|error
operator|=
name|suser
argument_list|(
name|curproc
operator|->
name|p_ucred
argument_list|,
operator|&
name|curproc
operator|->
name|p_acflag
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|(
name|shadow
operator|=
name|pvc_attach
argument_list|(
name|ifp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|sprintf
argument_list|(
name|ifr
operator|->
name|ifr_name
argument_list|,
literal|"%s%d"
argument_list|,
name|shadow
operator|->
name|if_name
argument_list|,
name|shadow
operator|->
name|if_unit
argument_list|)
expr_stmt|;
block|}
else|else
name|error
operator|=
name|ENOBUFS
expr_stmt|;
block|}
do|while
condition|(
literal|0
condition|)
do|;
break|break;
endif|#
directive|endif
comment|/* ATM_PVCEXT */
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * en_rxctl: turn on and off VCs for recv.  */
end_comment

begin_function
name|STATIC
name|int
name|en_rxctl
parameter_list|(
name|sc
parameter_list|,
name|pi
parameter_list|,
name|on
parameter_list|)
name|struct
name|en_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|atm_pseudoioctl
modifier|*
name|pi
decl_stmt|;
name|int
name|on
decl_stmt|;
block|{
name|u_int
name|s
decl_stmt|,
name|vci
decl_stmt|,
name|flags
decl_stmt|,
name|slot
decl_stmt|;
name|u_int32_t
name|oldmode
decl_stmt|,
name|newmode
decl_stmt|;
name|vci
operator|=
name|ATM_PH_VCI
argument_list|(
operator|&
name|pi
operator|->
name|aph
argument_list|)
expr_stmt|;
name|flags
operator|=
name|ATM_PH_FLAGS
argument_list|(
operator|&
name|pi
operator|->
name|aph
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EN_DEBUG
name|printf
argument_list|(
literal|"%s: %s vpi=%d, vci=%d, flags=%d\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
operator|(
name|on
operator|)
condition|?
literal|"enable"
else|:
literal|"disable"
argument_list|,
name|ATM_PH_VPI
argument_list|(
operator|&
name|pi
operator|->
name|aph
argument_list|)
argument_list|,
name|vci
argument_list|,
name|flags
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ATM_PH_VPI
argument_list|(
operator|&
name|pi
operator|->
name|aph
argument_list|)
operator|||
name|vci
operator|>=
name|MID_N_VC
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/*    * turn on VCI!    */
if|if
condition|(
name|on
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|rxvc2slot
index|[
name|vci
index|]
operator|!=
name|RX_NONE
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
for|for
control|(
name|slot
operator|=
literal|0
init|;
name|slot
operator|<
name|sc
operator|->
name|en_nrx
condition|;
name|slot
operator|++
control|)
if|if
condition|(
name|sc
operator|->
name|rxslot
index|[
name|slot
index|]
operator|.
name|oth_flags
operator|&
name|ENOTHER_FREE
condition|)
break|break;
if|if
condition|(
name|slot
operator|==
name|sc
operator|->
name|en_nrx
condition|)
return|return
operator|(
name|ENOSPC
operator|)
return|;
name|sc
operator|->
name|rxvc2slot
index|[
name|vci
index|]
operator|=
name|slot
expr_stmt|;
name|sc
operator|->
name|rxslot
index|[
name|slot
index|]
operator|.
name|rxhand
operator|=
name|NULL
expr_stmt|;
name|oldmode
operator|=
name|sc
operator|->
name|rxslot
index|[
name|slot
index|]
operator|.
name|mode
expr_stmt|;
name|newmode
operator|=
operator|(
name|flags
operator|&
name|ATM_PH_AAL5
operator|)
condition|?
name|MIDV_AAL5
else|:
name|MIDV_NOAAL
expr_stmt|;
name|sc
operator|->
name|rxslot
index|[
name|slot
index|]
operator|.
name|mode
operator|=
name|MIDV_SETMODE
argument_list|(
name|oldmode
argument_list|,
name|newmode
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rxslot
index|[
name|slot
index|]
operator|.
name|atm_vci
operator|=
name|vci
expr_stmt|;
name|sc
operator|->
name|rxslot
index|[
name|slot
index|]
operator|.
name|atm_flags
operator|=
name|flags
expr_stmt|;
name|sc
operator|->
name|rxslot
index|[
name|slot
index|]
operator|.
name|oth_flags
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|rxslot
index|[
name|slot
index|]
operator|.
name|rxhand
operator|=
name|pi
operator|->
name|rxhand
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|rxslot
index|[
name|slot
index|]
operator|.
name|indma
operator|.
name|ifq_head
operator|||
name|sc
operator|->
name|rxslot
index|[
name|slot
index|]
operator|.
name|q
operator|.
name|ifq_head
condition|)
name|panic
argument_list|(
literal|"en_rxctl: left over mbufs on enable"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|txspeed
index|[
name|vci
index|]
operator|=
literal|0
expr_stmt|;
comment|/* full speed to start */
name|sc
operator|->
name|txvc2slot
index|[
name|vci
index|]
operator|=
literal|0
expr_stmt|;
comment|/* init value */
name|sc
operator|->
name|txslot
index|[
literal|0
index|]
operator|.
name|nref
operator|++
expr_stmt|;
comment|/* bump reference count */
name|en_loadvc
argument_list|(
name|sc
argument_list|,
name|vci
argument_list|)
expr_stmt|;
comment|/* does debug printf for us */
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*    * turn off VCI    */
if|if
condition|(
name|sc
operator|->
name|rxvc2slot
index|[
name|vci
index|]
operator|==
name|RX_NONE
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|slot
operator|=
name|sc
operator|->
name|rxvc2slot
index|[
name|vci
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|rxslot
index|[
name|slot
index|]
operator|.
name|oth_flags
operator|&
operator|(
name|ENOTHER_FREE
operator||
name|ENOTHER_DRAIN
operator|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
comment|/* block out enintr() */
name|oldmode
operator|=
name|EN_READ
argument_list|(
name|sc
argument_list|,
name|MID_VC
argument_list|(
name|vci
argument_list|)
argument_list|)
expr_stmt|;
name|newmode
operator|=
name|MIDV_SETMODE
argument_list|(
name|oldmode
argument_list|,
name|MIDV_TRASH
argument_list|)
operator|&
operator|~
name|MIDV_INSERVICE
expr_stmt|;
name|EN_WRITE
argument_list|(
name|sc
argument_list|,
name|MID_VC
argument_list|(
name|vci
argument_list|)
argument_list|,
operator|(
name|newmode
operator||
operator|(
name|oldmode
operator|&
name|MIDV_INSERVICE
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* halt in tracks, be careful to preserve inserivce bit */
name|DELAY
argument_list|(
literal|27
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rxslot
index|[
name|slot
index|]
operator|.
name|rxhand
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|rxslot
index|[
name|slot
index|]
operator|.
name|mode
operator|=
name|newmode
expr_stmt|;
name|sc
operator|->
name|txslot
index|[
name|sc
operator|->
name|txvc2slot
index|[
name|vci
index|]
index|]
operator|.
name|nref
operator|--
expr_stmt|;
name|sc
operator|->
name|txspeed
index|[
name|vci
index|]
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|txvc2slot
index|[
name|vci
index|]
operator|=
literal|0
expr_stmt|;
comment|/* if stuff is still going on we are going to have to drain it out */
if|if
condition|(
name|sc
operator|->
name|rxslot
index|[
name|slot
index|]
operator|.
name|indma
operator|.
name|ifq_head
operator|||
name|sc
operator|->
name|rxslot
index|[
name|slot
index|]
operator|.
name|q
operator|.
name|ifq_head
operator|||
operator|(
name|sc
operator|->
name|rxslot
index|[
name|slot
index|]
operator|.
name|oth_flags
operator|&
name|ENOTHER_SWSL
operator|)
operator|!=
literal|0
condition|)
block|{
name|sc
operator|->
name|rxslot
index|[
name|slot
index|]
operator|.
name|oth_flags
operator||=
name|ENOTHER_DRAIN
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|rxslot
index|[
name|slot
index|]
operator|.
name|oth_flags
operator|=
name|ENOTHER_FREE
expr_stmt|;
name|sc
operator|->
name|rxslot
index|[
name|slot
index|]
operator|.
name|atm_vci
operator|=
name|RX_NONE
expr_stmt|;
name|sc
operator|->
name|rxvc2slot
index|[
name|vci
index|]
operator|=
name|RX_NONE
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* enable enintr() */
ifdef|#
directive|ifdef
name|EN_DEBUG
name|printf
argument_list|(
literal|"%s: rx%d: VCI %d is now %s\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|slot
argument_list|,
name|vci
argument_list|,
operator|(
name|sc
operator|->
name|rxslot
index|[
name|slot
index|]
operator|.
name|oth_flags
operator|&
name|ENOTHER_DRAIN
operator|)
condition|?
literal|"draining"
else|:
literal|"free"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/***********************************************************************/
end_comment

begin_comment
comment|/*  * en_reset: reset the board, throw away work in progress.  * must en_init to recover.  */
end_comment

begin_function
name|void
name|en_reset
parameter_list|(
name|sc
parameter_list|)
name|struct
name|en_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|lcv
decl_stmt|,
name|slot
decl_stmt|;
ifdef|#
directive|ifdef
name|EN_DEBUG
name|printf
argument_list|(
literal|"%s: reset\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sc
operator|->
name|en_busreset
condition|)
name|sc
operator|->
name|en_busreset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|EN_WRITE
argument_list|(
name|sc
argument_list|,
name|MID_RESID
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
comment|/* reset hardware */
comment|/*    * recv: dump any mbufs we are dma'ing into, if DRAINing, then a reset    * will free us!    */
for|for
control|(
name|lcv
operator|=
literal|0
init|;
name|lcv
operator|<
name|MID_N_VC
condition|;
name|lcv
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|rxvc2slot
index|[
name|lcv
index|]
operator|==
name|RX_NONE
condition|)
continue|continue;
name|slot
operator|=
name|sc
operator|->
name|rxvc2slot
index|[
name|lcv
index|]
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|IF_DEQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|rxslot
index|[
name|slot
index|]
operator|.
name|indma
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
break|break;
comment|/*>>> exit 'while(1)' here<<< */
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
literal|1
condition|)
block|{
name|IF_DEQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|rxslot
index|[
name|slot
index|]
operator|.
name|q
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
break|break;
comment|/*>>> exit 'while(1)' here<<< */
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|rxslot
index|[
name|slot
index|]
operator|.
name|oth_flags
operator|&=
operator|~
name|ENOTHER_SWSL
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|rxslot
index|[
name|slot
index|]
operator|.
name|oth_flags
operator|&
name|ENOTHER_DRAIN
condition|)
block|{
name|sc
operator|->
name|rxslot
index|[
name|slot
index|]
operator|.
name|oth_flags
operator|=
name|ENOTHER_FREE
expr_stmt|;
name|sc
operator|->
name|rxvc2slot
index|[
name|lcv
index|]
operator|=
name|RX_NONE
expr_stmt|;
ifdef|#
directive|ifdef
name|EN_DEBUG
name|printf
argument_list|(
literal|"%s: rx%d: VCI %d is now free\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|slot
argument_list|,
name|lcv
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
comment|/*    * xmit: dump everything    */
for|for
control|(
name|lcv
operator|=
literal|0
init|;
name|lcv
operator|<
name|EN_NTX
condition|;
name|lcv
operator|++
control|)
block|{
while|while
condition|(
literal|1
condition|)
block|{
name|IF_DEQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|txslot
index|[
name|lcv
index|]
operator|.
name|indma
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
break|break;
comment|/*>>> exit 'while(1)' here<<< */
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
literal|1
condition|)
block|{
name|IF_DEQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|txslot
index|[
name|lcv
index|]
operator|.
name|q
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
break|break;
comment|/*>>> exit 'while(1)' here<<< */
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|txslot
index|[
name|lcv
index|]
operator|.
name|mbsize
operator|=
literal|0
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/*  * en_init: init board and sync the card with the data in the softc.  */
end_comment

begin_function
name|STATIC
name|void
name|en_init
parameter_list|(
name|sc
parameter_list|)
name|struct
name|en_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|int
name|vc
decl_stmt|,
name|slot
decl_stmt|;
name|u_int32_t
name|loc
decl_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|enif
operator|.
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|EN_DEBUG
name|printf
argument_list|(
literal|"%s: going down\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|en_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* to be safe */
name|sc
operator|->
name|enif
operator|.
name|if_flags
operator|&=
operator|~
name|IFF_RUNNING
expr_stmt|;
comment|/* disable */
return|return;
block|}
ifdef|#
directive|ifdef
name|EN_DEBUG
name|printf
argument_list|(
literal|"%s: going up\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sc
operator|->
name|enif
operator|.
name|if_flags
operator||=
name|IFF_RUNNING
expr_stmt|;
comment|/* enable */
if|if
condition|(
name|sc
operator|->
name|en_busreset
condition|)
name|sc
operator|->
name|en_busreset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|EN_WRITE
argument_list|(
name|sc
argument_list|,
name|MID_RESID
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
comment|/* reset */
comment|/*    * init obmem data structures: vc tab, dma q's, slist.    *    * note that we set drq_free/dtq_free to one less than the total number    * of DTQ/DRQs present.   we do this because the card uses the condition    * (drq_chip == drq_us) to mean "list is empty"... but if you allow the    * circular list to be completely full then (drq_chip == drq_us) [i.e.    * the drq_us pointer will wrap all the way around].   by restricting    * the number of active requests to (N - 1) we prevent the list from    * becoming completely full.    note that the card will sometimes give    * us an interrupt for a DTQ/DRQ we have already processes... this helps    * keep that interrupt from messing us up.    */
for|for
control|(
name|vc
operator|=
literal|0
init|;
name|vc
operator|<
name|MID_N_VC
condition|;
name|vc
operator|++
control|)
name|en_loadvc
argument_list|(
name|sc
argument_list|,
name|vc
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|sc
operator|->
name|drq
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|drq
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|drq_free
operator|=
name|MID_DRQ_N
operator|-
literal|1
expr_stmt|;
comment|/* N - 1 */
name|sc
operator|->
name|drq_chip
operator|=
name|MID_DRQ_REG2A
argument_list|(
name|EN_READ
argument_list|(
name|sc
argument_list|,
name|MID_DMA_RDRX
argument_list|)
argument_list|)
expr_stmt|;
name|EN_WRITE
argument_list|(
name|sc
argument_list|,
name|MID_DMA_WRRX
argument_list|,
name|MID_DRQ_A2REG
argument_list|(
name|sc
operator|->
name|drq_chip
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ensure zero queue */
name|sc
operator|->
name|drq_us
operator|=
name|sc
operator|->
name|drq_chip
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|sc
operator|->
name|dtq
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|dtq
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|dtq_free
operator|=
name|MID_DTQ_N
operator|-
literal|1
expr_stmt|;
comment|/* N - 1 */
name|sc
operator|->
name|dtq_chip
operator|=
name|MID_DTQ_REG2A
argument_list|(
name|EN_READ
argument_list|(
name|sc
argument_list|,
name|MID_DMA_RDTX
argument_list|)
argument_list|)
expr_stmt|;
name|EN_WRITE
argument_list|(
name|sc
argument_list|,
name|MID_DMA_WRTX
argument_list|,
name|MID_DRQ_A2REG
argument_list|(
name|sc
operator|->
name|dtq_chip
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ensure zero queue */
name|sc
operator|->
name|dtq_us
operator|=
name|sc
operator|->
name|dtq_chip
expr_stmt|;
name|sc
operator|->
name|hwslistp
operator|=
name|MID_SL_REG2A
argument_list|(
name|EN_READ
argument_list|(
name|sc
argument_list|,
name|MID_SERV_WRITE
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|swsl_size
operator|=
name|sc
operator|->
name|swsl_head
operator|=
name|sc
operator|->
name|swsl_tail
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|EN_DEBUG
name|printf
argument_list|(
literal|"%s: drq free/chip: %d/0x%x, dtq free/chip: %d/0x%x, hwslist: 0x%x\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|sc
operator|->
name|drq_free
argument_list|,
name|sc
operator|->
name|drq_chip
argument_list|,
name|sc
operator|->
name|dtq_free
argument_list|,
name|sc
operator|->
name|dtq_chip
argument_list|,
name|sc
operator|->
name|hwslistp
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|slot
operator|=
literal|0
init|;
name|slot
operator|<
name|EN_NTX
condition|;
name|slot
operator|++
control|)
block|{
name|sc
operator|->
name|txslot
index|[
name|slot
index|]
operator|.
name|bfree
operator|=
name|EN_TXSZ
operator|*
literal|1024
expr_stmt|;
name|EN_WRITE
argument_list|(
name|sc
argument_list|,
name|MIDX_READPTR
argument_list|(
name|slot
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|EN_WRITE
argument_list|(
name|sc
argument_list|,
name|MIDX_DESCSTART
argument_list|(
name|slot
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|loc
operator|=
name|sc
operator|->
name|txslot
index|[
name|slot
index|]
operator|.
name|cur
operator|=
name|sc
operator|->
name|txslot
index|[
name|slot
index|]
operator|.
name|start
expr_stmt|;
name|loc
operator|=
name|loc
operator|-
name|MID_RAMOFF
expr_stmt|;
name|loc
operator|=
operator|(
name|loc
operator|&
operator|~
operator|(
operator|(
name|EN_TXSZ
operator|*
literal|1024
operator|)
operator|-
literal|1
operator|)
operator|)
operator|>>
literal|2
expr_stmt|;
comment|/* mask, cvt to words */
name|loc
operator|=
name|loc
operator|>>
name|MIDV_LOCTOPSHFT
expr_stmt|;
comment|/* top 11 bits */
name|EN_WRITE
argument_list|(
name|sc
argument_list|,
name|MIDX_PLACE
argument_list|(
name|slot
argument_list|)
argument_list|,
name|MIDX_MKPLACE
argument_list|(
name|en_k2sz
argument_list|(
name|EN_TXSZ
argument_list|)
argument_list|,
name|loc
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EN_DEBUG
name|printf
argument_list|(
literal|"%s: tx%d: place 0x%x\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|slot
argument_list|,
name|EN_READ
argument_list|(
name|sc
argument_list|,
name|MIDX_PLACE
argument_list|(
name|slot
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/*    * enable!    */
name|EN_WRITE
argument_list|(
name|sc
argument_list|,
name|MID_INTENA
argument_list|,
name|MID_INT_TX
operator||
name|MID_INT_DMA_OVR
operator||
name|MID_INT_IDENT
operator||
name|MID_INT_LERR
operator||
name|MID_INT_DMA_ERR
operator||
name|MID_INT_DMA_RX
operator||
name|MID_INT_DMA_TX
operator||
name|MID_INT_SERVICE
operator||
comment|/*>>> MID_INT_SUNI| XXXCDC<<< */
name|MID_INT_STATS
argument_list|)
expr_stmt|;
name|EN_WRITE
argument_list|(
name|sc
argument_list|,
name|MID_MAST_CSR
argument_list|,
name|MID_SETIPL
argument_list|(
name|sc
operator|->
name|ipl
argument_list|)
operator||
name|MID_MCSR_ENDMA
operator||
name|MID_MCSR_ENTX
operator||
name|MID_MCSR_ENRX
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * en_loadvc: load a vc tab entry from a slot  */
end_comment

begin_function
name|STATIC
name|void
name|en_loadvc
parameter_list|(
name|sc
parameter_list|,
name|vc
parameter_list|)
name|struct
name|en_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|vc
decl_stmt|;
block|{
name|int
name|slot
decl_stmt|;
name|u_int32_t
name|reg
init|=
name|EN_READ
argument_list|(
name|sc
argument_list|,
name|MID_VC
argument_list|(
name|vc
argument_list|)
argument_list|)
decl_stmt|;
name|reg
operator|=
name|MIDV_SETMODE
argument_list|(
name|reg
argument_list|,
name|MIDV_TRASH
argument_list|)
expr_stmt|;
name|EN_WRITE
argument_list|(
name|sc
argument_list|,
name|MID_VC
argument_list|(
name|vc
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|27
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|slot
operator|=
name|sc
operator|->
name|rxvc2slot
index|[
name|vc
index|]
operator|)
operator|==
name|RX_NONE
condition|)
return|return;
comment|/* no need to set CRC */
name|EN_WRITE
argument_list|(
name|sc
argument_list|,
name|MID_DST_RP
argument_list|(
name|vc
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* read pointer = 0, desc. start = 0 */
name|EN_WRITE
argument_list|(
name|sc
argument_list|,
name|MID_WP_ST_CNT
argument_list|(
name|vc
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* write pointer = 0 */
name|EN_WRITE
argument_list|(
name|sc
argument_list|,
name|MID_VC
argument_list|(
name|vc
argument_list|)
argument_list|,
name|sc
operator|->
name|rxslot
index|[
name|slot
index|]
operator|.
name|mode
argument_list|)
expr_stmt|;
comment|/* set mode, size, loc */
name|sc
operator|->
name|rxslot
index|[
name|slot
index|]
operator|.
name|cur
operator|=
name|sc
operator|->
name|rxslot
index|[
name|slot
index|]
operator|.
name|start
expr_stmt|;
ifdef|#
directive|ifdef
name|EN_DEBUG
name|printf
argument_list|(
literal|"%s: rx%d: assigned to VCI %d\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|slot
argument_list|,
name|vc
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * en_start: start transmitting the next packet that needs to go out  * if there is one.    note that atm_output() has already splimp()'d us.  */
end_comment

begin_function
name|STATIC
name|void
name|en_start
parameter_list|(
name|ifp
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
block|{
name|struct
name|en_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|en_softc
operator|*
operator|)
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ifqueue
modifier|*
name|ifq
init|=
operator|&
name|ifp
operator|->
name|if_snd
decl_stmt|;
comment|/* if INPUT QUEUE */
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|lastm
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
name|struct
name|atm_pseudohdr
modifier|*
name|ap
decl_stmt|,
modifier|*
name|new_ap
decl_stmt|;
name|int
name|txchan
decl_stmt|,
name|mlen
decl_stmt|,
name|got
decl_stmt|,
name|need
decl_stmt|,
name|toadd
decl_stmt|,
name|cellcnt
decl_stmt|,
name|first
decl_stmt|;
name|u_int32_t
name|atm_vpi
decl_stmt|,
name|atm_vci
decl_stmt|,
name|atm_flags
decl_stmt|,
modifier|*
name|dat
decl_stmt|,
name|aal
decl_stmt|;
name|u_int8_t
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
operator|==
literal|0
condition|)
return|return;
comment|/*      * remove everything from interface queue since we handle all queueing      * locally ...       */
while|while
condition|(
literal|1
condition|)
block|{
name|IF_DEQUEUE
argument_list|(
name|ifq
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return;
comment|/* EMPTY:>>> exit here<<< */
comment|/*        * calculate size of packet (in bytes)        * also, if we are not doing transmit DMA we eliminate all stupid        * (non-word) alignments here using en_mfix().   calls to en_mfix()        * seem to be due to tcp retransmits for the most part.        *        * after this loop mlen total length of mbuf chain (including atm_ph),        * and lastm is a pointer to the last mbuf on the chain.        */
name|lastm
operator|=
name|m
expr_stmt|;
name|mlen
operator|=
literal|0
expr_stmt|;
name|prev
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* no DMA? */
if|if
condition|(
operator|(
operator|!
name|sc
operator|->
name|is_adaptec
operator|&&
name|EN_ENIDMAFIX
operator|)
operator|||
name|EN_NOTXDMA
operator|||
operator|!
name|en_dma
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|uintptr_t
operator|)
name|mtod
argument_list|(
name|lastm
argument_list|,
name|void
operator|*
argument_list|)
operator|%
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
operator|(
name|lastm
operator|->
name|m_len
operator|%
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|lastm
operator|->
name|m_next
operator|)
condition|)
block|{
name|first
operator|=
operator|(
name|lastm
operator|==
name|m
operator|)
expr_stmt|;
if|if
condition|(
name|en_mfix
argument_list|(
name|sc
argument_list|,
operator|&
name|lastm
argument_list|,
name|prev
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* failed? */
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|first
condition|)
name|m
operator|=
name|lastm
expr_stmt|;
comment|/* update */
block|}
name|prev
operator|=
name|lastm
expr_stmt|;
block|}
name|mlen
operator|+=
name|lastm
operator|->
name|m_len
expr_stmt|;
if|if
condition|(
name|lastm
operator|->
name|m_next
operator|==
name|NULL
condition|)
break|break;
name|lastm
operator|=
name|lastm
operator|->
name|m_next
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
comment|/* happens only if mfix fails */
continue|continue;
name|ap
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|atm_pseudohdr
operator|*
argument_list|)
expr_stmt|;
name|atm_vpi
operator|=
name|ATM_PH_VPI
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|atm_vci
operator|=
name|ATM_PH_VCI
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|atm_flags
operator|=
name|ATM_PH_FLAGS
argument_list|(
name|ap
argument_list|)
operator|&
operator|~
operator|(
name|EN_OBHDR
operator||
name|EN_OBTRL
operator|)
expr_stmt|;
name|aal
operator|=
operator|(
operator|(
name|atm_flags
operator|&
name|ATM_PH_AAL5
operator|)
operator|!=
literal|0
operator|)
condition|?
name|MID_TBD_AAL5
else|:
name|MID_TBD_NOAAL5
expr_stmt|;
comment|/*        * check that vpi/vci is one we can use        */
if|if
condition|(
name|atm_vpi
operator|||
name|atm_vci
operator|>
name|MID_N_VC
condition|)
block|{
name|printf
argument_list|(
literal|"%s: output vpi=%d, vci=%d out of card range, dropping...\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|atm_vpi
argument_list|,
name|atm_vci
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/*        * computing how much padding we need on the end of the mbuf, then        * see if we can put the TBD at the front of the mbuf where the        * link header goes (well behaved protocols will reserve room for us).        * last, check if room for PDU tail.        *        * got = number of bytes of data we have        * cellcnt = number of cells in this mbuf        * need = number of bytes of data + padding we need (excludes TBD)        * toadd = number of bytes of data we need to add to end of mbuf,        *	[including AAL5 PDU, if AAL5]        */
name|got
operator|=
name|mlen
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|atm_pseudohdr
operator|*
argument_list|)
expr_stmt|;
name|toadd
operator|=
operator|(
name|aal
operator|==
name|MID_TBD_AAL5
operator|)
condition|?
name|MID_PDU_SIZE
else|:
literal|0
expr_stmt|;
comment|/* PDU */
name|cellcnt
operator|=
operator|(
name|got
operator|+
name|toadd
operator|+
operator|(
name|MID_ATMDATASZ
operator|-
literal|1
operator|)
operator|)
operator|/
name|MID_ATMDATASZ
expr_stmt|;
name|need
operator|=
name|cellcnt
operator|*
name|MID_ATMDATASZ
expr_stmt|;
name|toadd
operator|=
name|need
operator|-
name|got
expr_stmt|;
comment|/* recompute, including zero padding */
ifdef|#
directive|ifdef
name|EN_DEBUG
name|printf
argument_list|(
literal|"%s: txvci%d: mlen=%d, got=%d, need=%d, toadd=%d, cell#=%d\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|atm_vci
argument_list|,
name|mlen
argument_list|,
name|got
argument_list|,
name|need
argument_list|,
name|toadd
argument_list|,
name|cellcnt
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"     leading_space=%d, trailing_space=%d\n"
argument_list|,
name|M_LEADINGSPACE
argument_list|(
name|m
argument_list|)
argument_list|,
name|M_TRAILINGSPACE
argument_list|(
name|lastm
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EN_MBUF_OPT
comment|/*        * note: external storage (M_EXT) can be shared between mbufs        * to avoid copying (see m_copym()).    this means that the same        * data buffer could be shared by several mbufs, and thus it isn't        * a good idea to try and write TBDs or PDUs to M_EXT data areas.        */
if|if
condition|(
name|M_LEADINGSPACE
argument_list|(
name|m
argument_list|)
operator|>=
name|MID_TBD_SIZE
operator|&&
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|==
literal|0
condition|)
block|{
name|m
operator|->
name|m_data
operator|-=
name|MID_TBD_SIZE
expr_stmt|;
name|m
operator|->
name|m_len
operator|+=
name|MID_TBD_SIZE
expr_stmt|;
name|mlen
operator|+=
name|MID_TBD_SIZE
expr_stmt|;
name|new_ap
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|atm_pseudohdr
operator|*
argument_list|)
expr_stmt|;
operator|*
name|new_ap
operator|=
operator|*
name|ap
expr_stmt|;
comment|/* move it back */
name|ap
operator|=
name|new_ap
expr_stmt|;
name|dat
operator|=
operator|(
operator|(
name|u_int32_t
operator|*
operator|)
name|ap
operator|)
operator|+
literal|1
expr_stmt|;
comment|/* make sure the TBD is in proper byte order */
operator|*
name|dat
operator|++
operator|=
name|htonl
argument_list|(
name|MID_TBD_MK1
argument_list|(
name|aal
argument_list|,
name|sc
operator|->
name|txspeed
index|[
name|atm_vci
index|]
argument_list|,
name|cellcnt
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|dat
operator|=
name|htonl
argument_list|(
name|MID_TBD_MK2
argument_list|(
name|atm_vci
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|atm_flags
operator||=
name|EN_OBHDR
expr_stmt|;
block|}
if|if
condition|(
name|toadd
operator|&&
operator|(
name|lastm
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|==
literal|0
operator|&&
name|M_TRAILINGSPACE
argument_list|(
name|lastm
argument_list|)
operator|>=
name|toadd
condition|)
block|{
name|cp
operator|=
name|mtod
argument_list|(
name|lastm
argument_list|,
name|u_int8_t
operator|*
argument_list|)
operator|+
name|lastm
operator|->
name|m_len
expr_stmt|;
name|lastm
operator|->
name|m_len
operator|+=
name|toadd
expr_stmt|;
name|mlen
operator|+=
name|toadd
expr_stmt|;
if|if
condition|(
name|aal
operator|==
name|MID_TBD_AAL5
condition|)
block|{
name|bzero
argument_list|(
name|cp
argument_list|,
name|toadd
operator|-
name|MID_PDU_SIZE
argument_list|)
expr_stmt|;
name|dat
operator|=
operator|(
name|u_int32_t
operator|*
operator|)
operator|(
name|cp
operator|+
name|toadd
operator|-
name|MID_PDU_SIZE
operator|)
expr_stmt|;
comment|/* make sure the PDU is in proper byte order */
operator|*
name|dat
operator|=
name|htonl
argument_list|(
name|MID_PDU_MK1
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|got
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bzero
argument_list|(
name|cp
argument_list|,
name|toadd
argument_list|)
expr_stmt|;
block|}
name|atm_flags
operator||=
name|EN_OBTRL
expr_stmt|;
block|}
name|ATM_PH_FLAGS
argument_list|(
name|ap
argument_list|)
operator|=
name|atm_flags
expr_stmt|;
comment|/* update EN_OBHDR/EN_OBTRL bits */
endif|#
directive|endif
comment|/* EN_MBUF_OPT */
comment|/*        * get assigned channel (will be zero unless txspeed[atm_vci] is set)        */
name|txchan
operator|=
name|sc
operator|->
name|txvc2slot
index|[
name|atm_vci
index|]
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|txslot
index|[
name|txchan
index|]
operator|.
name|mbsize
operator|>
name|EN_TXHIWAT
condition|)
block|{
name|EN_COUNT
argument_list|(
name|sc
operator|->
name|txmbovr
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EN_DEBUG
name|printf
argument_list|(
literal|"%s: tx%d: buffer space shortage\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|txchan
argument_list|)
expr_stmt|;
endif|#
directive|endif
continue|continue;
block|}
name|sc
operator|->
name|txslot
index|[
name|txchan
index|]
operator|.
name|mbsize
operator|+=
name|mlen
expr_stmt|;
ifdef|#
directive|ifdef
name|EN_DEBUG
name|printf
argument_list|(
literal|"%s: tx%d: VPI=%d, VCI=%d, FLAGS=0x%x, speed=0x%x\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|txchan
argument_list|,
name|atm_vpi
argument_list|,
name|atm_vci
argument_list|,
name|atm_flags
argument_list|,
name|sc
operator|->
name|txspeed
index|[
name|atm_vci
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"     adjusted mlen=%d, mbsize=%d\n"
argument_list|,
name|mlen
argument_list|,
name|sc
operator|->
name|txslot
index|[
name|txchan
index|]
operator|.
name|mbsize
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|IF_ENQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|txslot
index|[
name|txchan
index|]
operator|.
name|q
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|en_txdma
argument_list|(
name|sc
argument_list|,
name|txchan
argument_list|)
expr_stmt|;
block|}
comment|/*NOTREACHED*/
block|}
end_function

begin_comment
comment|/*  * en_mfix: fix a stupid mbuf  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__FreeBSD__
end_ifndef

begin_function
name|STATIC
name|int
name|en_mfix
parameter_list|(
name|sc
parameter_list|,
name|mm
parameter_list|,
name|prev
parameter_list|)
name|struct
name|en_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mbuf
modifier|*
modifier|*
name|mm
decl_stmt|,
decl|*
name|prev
decl_stmt|;
end_function

begin_block
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|new
decl_stmt|;
name|u_char
modifier|*
name|d
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|int
name|off
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|nxt
decl_stmt|;
name|m
operator|=
operator|*
name|mm
expr_stmt|;
name|EN_COUNT
argument_list|(
name|sc
operator|->
name|mfix
argument_list|)
expr_stmt|;
comment|/* count # of calls */
ifdef|#
directive|ifdef
name|EN_DEBUG
name|printf
argument_list|(
literal|"%s: mfix mbuf m_data=%p, m_len=%d\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|m
operator|->
name|m_data
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|d
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|u_char
operator|*
argument_list|)
expr_stmt|;
name|off
operator|=
operator|(
operator|(
name|unsigned
name|long
operator|)
name|d
operator|)
operator|%
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|off
condition|)
block|{
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|==
literal|0
condition|)
block|{
name|bcopy
argument_list|(
name|d
argument_list|,
name|d
operator|-
name|off
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
comment|/* ALIGN! (with costly data copy...) */
name|d
operator|-=
name|off
expr_stmt|;
name|m
operator|->
name|m_data
operator|=
operator|(
name|caddr_t
operator|)
name|d
expr_stmt|;
block|}
else|else
block|{
comment|/* can't write to an M_EXT mbuf since it may be shared */
name|MGET
argument_list|(
name|new
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|new
condition|)
block|{
name|EN_COUNT
argument_list|(
name|sc
operator|->
name|mfixfail
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|MCLGET
argument_list|(
name|new
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|new
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|==
literal|0
condition|)
block|{
name|m_free
argument_list|(
name|new
argument_list|)
expr_stmt|;
name|EN_COUNT
argument_list|(
name|sc
operator|->
name|mfixfail
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|bcopy
argument_list|(
name|d
argument_list|,
name|new
operator|->
name|m_data
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
comment|/* ALIGN! (with costly data copy...) */
name|new
operator|->
name|m_len
operator|=
name|m
operator|->
name|m_len
expr_stmt|;
name|new
operator|->
name|m_next
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
if|if
condition|(
name|prev
condition|)
name|prev
operator|->
name|m_next
operator|=
name|new
expr_stmt|;
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
operator|*
name|mm
operator|=
name|m
operator|=
name|new
expr_stmt|;
comment|/* note: 'd' now invalid */
block|}
block|}
name|off
operator|=
name|m
operator|->
name|m_len
operator|%
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|off
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|d
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|u_char
operator|*
argument_list|)
operator|+
name|m
operator|->
name|m_len
expr_stmt|;
name|off
operator|=
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
operator|-
name|off
expr_stmt|;
name|nxt
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
while|while
condition|(
name|off
operator|--
condition|)
block|{
for|for
control|(
init|;
name|nxt
operator|!=
name|NULL
operator|&&
name|nxt
operator|->
name|m_len
operator|==
literal|0
condition|;
name|nxt
operator|=
name|nxt
operator|->
name|m_next
control|)
comment|/*null*/
empty_stmt|;
if|if
condition|(
name|nxt
operator|==
name|NULL
condition|)
block|{
comment|/* out of data, zero fill */
operator|*
name|d
operator|++
operator|=
literal|0
expr_stmt|;
continue|continue;
comment|/* next "off" */
block|}
name|cp
operator|=
name|mtod
argument_list|(
name|nxt
argument_list|,
name|u_char
operator|*
argument_list|)
expr_stmt|;
operator|*
name|d
operator|++
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
name|m
operator|->
name|m_len
operator|++
expr_stmt|;
name|nxt
operator|->
name|m_len
operator|--
expr_stmt|;
name|nxt
operator|->
name|m_data
operator|=
operator|(
name|caddr_t
operator|)
name|cp
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* __FreeBSD__ */
end_comment

begin_function_decl
name|STATIC
name|int
name|en_makeexclusive
parameter_list|(
name|struct
name|en_softc
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|STATIC
name|int
name|en_makeexclusive
parameter_list|(
name|sc
parameter_list|,
name|mm
parameter_list|,
name|prev
parameter_list|)
name|struct
name|en_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mbuf
modifier|*
modifier|*
name|mm
decl_stmt|,
decl|*
name|prev
decl_stmt|;
end_function

begin_block
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|new
decl_stmt|;
name|m
operator|=
operator|*
name|mm
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|m_ext
operator|.
name|ext_free
condition|)
block|{
comment|/* external buffer isn't an ordinary mbuf cluster! */
name|printf
argument_list|(
literal|"%s: mfix: special buffer! can't make a copy!\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|mclrefcnt
index|[
name|mtocl
argument_list|(
name|m
operator|->
name|m_ext
operator|.
name|ext_buf
argument_list|)
index|]
operator|>
literal|1
condition|)
block|{
comment|/* make a real copy of the M_EXT mbuf since it is shared */
name|MGET
argument_list|(
name|new
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|new
condition|)
block|{
name|EN_COUNT
argument_list|(
name|sc
operator|->
name|mfixfail
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_PKTHDR
condition|)
name|M_COPY_PKTHDR
argument_list|(
name|new
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|MCLGET
argument_list|(
name|new
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|new
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|==
literal|0
condition|)
block|{
name|m_free
argument_list|(
name|new
argument_list|)
expr_stmt|;
name|EN_COUNT
argument_list|(
name|sc
operator|->
name|mfixfail
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|bcopy
argument_list|(
name|m
operator|->
name|m_data
argument_list|,
name|new
operator|->
name|m_data
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|new
operator|->
name|m_len
operator|=
name|m
operator|->
name|m_len
expr_stmt|;
name|new
operator|->
name|m_next
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
if|if
condition|(
name|prev
condition|)
name|prev
operator|->
name|m_next
operator|=
name|new
expr_stmt|;
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
operator|*
name|mm
operator|=
name|new
expr_stmt|;
block|}
else|else
block|{
comment|/* the buffer is not shared, align the data offset using 	       this buffer. */
name|u_char
modifier|*
name|d
init|=
name|mtod
argument_list|(
name|m
argument_list|,
name|u_char
operator|*
argument_list|)
decl_stmt|;
name|int
name|off
init|=
operator|(
operator|(
name|uintptr_t
operator|)
operator|(
name|void
operator|*
operator|)
name|d
operator|)
operator|%
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
decl_stmt|;
if|if
condition|(
name|off
operator|>
literal|0
condition|)
block|{
name|bcopy
argument_list|(
name|d
argument_list|,
name|d
operator|-
name|off
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_data
operator|=
operator|(
name|caddr_t
operator|)
name|d
operator|-
name|off
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_function
name|STATIC
name|int
name|en_mfix
parameter_list|(
name|sc
parameter_list|,
name|mm
parameter_list|,
name|prev
parameter_list|)
name|struct
name|en_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mbuf
modifier|*
modifier|*
name|mm
decl_stmt|,
decl|*
name|prev
decl_stmt|;
end_function

begin_block
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|u_char
modifier|*
name|d
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|int
name|off
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|nxt
decl_stmt|;
name|m
operator|=
operator|*
name|mm
expr_stmt|;
name|EN_COUNT
argument_list|(
name|sc
operator|->
name|mfix
argument_list|)
expr_stmt|;
comment|/* count # of calls */
ifdef|#
directive|ifdef
name|EN_DEBUG
name|printf
argument_list|(
literal|"%s: mfix mbuf m_data=0x%x, m_len=%d\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|m
operator|->
name|m_data
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|d
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|u_char
operator|*
argument_list|)
expr_stmt|;
name|off
operator|=
operator|(
operator|(
name|uintptr_t
operator|)
operator|(
name|void
operator|*
operator|)
name|d
operator|)
operator|%
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|off
condition|)
block|{
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|==
literal|0
condition|)
block|{
name|bcopy
argument_list|(
name|d
argument_list|,
name|d
operator|-
name|off
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
comment|/* ALIGN! (with costly data copy...) */
name|d
operator|-=
name|off
expr_stmt|;
name|m
operator|->
name|m_data
operator|=
operator|(
name|caddr_t
operator|)
name|d
expr_stmt|;
block|}
else|else
block|{
comment|/* can't write to an M_EXT mbuf since it may be shared */
if|if
condition|(
name|en_makeexclusive
argument_list|(
name|sc
argument_list|,
operator|&
name|m
argument_list|,
name|prev
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|*
name|mm
operator|=
name|m
expr_stmt|;
comment|/* note: 'd' now invalid */
block|}
block|}
name|off
operator|=
name|m
operator|->
name|m_len
operator|%
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|off
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
condition|)
block|{
comment|/* can't write to an M_EXT mbuf since it may be shared */
if|if
condition|(
name|en_makeexclusive
argument_list|(
name|sc
argument_list|,
operator|&
name|m
argument_list|,
name|prev
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|*
name|mm
operator|=
name|m
expr_stmt|;
comment|/* note: 'd' now invalid */
block|}
name|d
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|u_char
operator|*
argument_list|)
operator|+
name|m
operator|->
name|m_len
expr_stmt|;
name|off
operator|=
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
operator|-
name|off
expr_stmt|;
name|nxt
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
while|while
condition|(
name|off
operator|--
condition|)
block|{
if|if
condition|(
name|nxt
operator|!=
name|NULL
operator|&&
name|nxt
operator|->
name|m_len
operator|==
literal|0
condition|)
block|{
comment|/* remove an empty mbuf.  this avoids odd byte padding to an empty 	   last mbuf.  */
name|m
operator|->
name|m_next
operator|=
name|nxt
operator|=
name|m_free
argument_list|(
name|nxt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nxt
operator|==
name|NULL
condition|)
block|{
comment|/* out of data, zero fill */
operator|*
name|d
operator|++
operator|=
literal|0
expr_stmt|;
continue|continue;
comment|/* next "off" */
block|}
name|cp
operator|=
name|mtod
argument_list|(
name|nxt
argument_list|,
name|u_char
operator|*
argument_list|)
expr_stmt|;
operator|*
name|d
operator|++
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
name|m
operator|->
name|m_len
operator|++
expr_stmt|;
name|nxt
operator|->
name|m_len
operator|--
expr_stmt|;
name|nxt
operator|->
name|m_data
operator|=
operator|(
name|caddr_t
operator|)
name|cp
expr_stmt|;
block|}
if|if
condition|(
name|nxt
operator|!=
name|NULL
operator|&&
name|nxt
operator|->
name|m_len
operator|==
literal|0
condition|)
name|m
operator|->
name|m_next
operator|=
name|m_free
argument_list|(
name|nxt
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __FreeBSD__ */
end_comment

begin_comment
comment|/*  * en_txdma: start trasmit DMA, if possible  */
end_comment

begin_function
name|STATIC
name|void
name|en_txdma
parameter_list|(
name|sc
parameter_list|,
name|chan
parameter_list|)
name|struct
name|en_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|chan
decl_stmt|;
block|{
name|struct
name|mbuf
modifier|*
name|tmp
decl_stmt|;
name|struct
name|atm_pseudohdr
modifier|*
name|ap
decl_stmt|;
name|struct
name|en_launch
name|launch
decl_stmt|;
name|int
name|datalen
init|=
literal|0
decl_stmt|,
name|dtqneed
decl_stmt|,
name|len
decl_stmt|,
name|ncells
decl_stmt|;
name|u_int8_t
modifier|*
name|cp
decl_stmt|;
ifdef|#
directive|ifdef
name|EN_DEBUG
name|printf
argument_list|(
literal|"%s: tx%d: starting...\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|chan
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*    * note: now that txlaunch handles non-word aligned/sized requests    * the only time you can safely set launch.nodma is if you've en_mfix()'d    * the mbuf chain.    this happens only if EN_NOTXDMA || !en_dma.    */
name|launch
operator|.
name|nodma
operator|=
operator|(
name|EN_NOTXDMA
operator|||
operator|!
name|en_dma
operator|)
expr_stmt|;
name|again
label|:
comment|/*    * get an mbuf waiting for DMA    */
name|launch
operator|.
name|t
operator|=
name|sc
operator|->
name|txslot
index|[
name|chan
index|]
operator|.
name|q
operator|.
name|ifq_head
expr_stmt|;
comment|/* peek at head of queue */
if|if
condition|(
name|launch
operator|.
name|t
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|EN_DEBUG
name|printf
argument_list|(
literal|"%s: tx%d: ...done!\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|chan
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
comment|/*>>> exit here if no data waiting for DMA<<< */
block|}
comment|/*    * get flags, vci    *     * note: launch.need = # bytes we need to get on the card    *	   dtqneed = # of DTQs we need for this packet    *       launch.mlen = # of bytes in in mbuf chain (<= launch.need)    */
name|ap
operator|=
name|mtod
argument_list|(
name|launch
operator|.
name|t
argument_list|,
expr|struct
name|atm_pseudohdr
operator|*
argument_list|)
expr_stmt|;
name|launch
operator|.
name|atm_vci
operator|=
name|ATM_PH_VCI
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|launch
operator|.
name|atm_flags
operator|=
name|ATM_PH_FLAGS
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|launch
operator|.
name|aal
operator|=
operator|(
operator|(
name|launch
operator|.
name|atm_flags
operator|&
name|ATM_PH_AAL5
operator|)
operator|!=
literal|0
operator|)
condition|?
name|MID_TBD_AAL5
else|:
name|MID_TBD_NOAAL5
expr_stmt|;
comment|/*    * XXX: have to recompute the length again, even though we already did    * it in en_start().   might as well compute dtqneed here as well, so     * this isn't that bad.    */
if|if
condition|(
operator|(
name|launch
operator|.
name|atm_flags
operator|&
name|EN_OBHDR
operator|)
operator|==
literal|0
condition|)
block|{
name|dtqneed
operator|=
literal|1
expr_stmt|;
comment|/* header still needs to be added */
name|launch
operator|.
name|need
operator|=
name|MID_TBD_SIZE
expr_stmt|;
comment|/* not includeded with mbuf */
block|}
else|else
block|{
name|dtqneed
operator|=
literal|0
expr_stmt|;
comment|/* header on-board, dma with mbuf */
name|launch
operator|.
name|need
operator|=
literal|0
expr_stmt|;
block|}
name|launch
operator|.
name|mlen
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|tmp
operator|=
name|launch
operator|.
name|t
init|;
name|tmp
operator|!=
name|NULL
condition|;
name|tmp
operator|=
name|tmp
operator|->
name|m_next
control|)
block|{
name|len
operator|=
name|tmp
operator|->
name|m_len
expr_stmt|;
name|launch
operator|.
name|mlen
operator|+=
name|len
expr_stmt|;
name|cp
operator|=
name|mtod
argument_list|(
name|tmp
argument_list|,
name|u_int8_t
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
name|launch
operator|.
name|t
condition|)
block|{
name|len
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|atm_pseudohdr
argument_list|)
expr_stmt|;
comment|/* don't count this! */
name|cp
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|atm_pseudohdr
argument_list|)
expr_stmt|;
block|}
name|launch
operator|.
name|need
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
continue|continue;
comment|/* atm_pseudohdr alone in first mbuf */
name|dtqneed
operator|+=
name|en_dqneed
argument_list|(
name|sc
argument_list|,
operator|(
name|caddr_t
operator|)
name|cp
argument_list|,
name|len
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|launch
operator|.
name|need
operator|%
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|dtqneed
operator|++
expr_stmt|;
comment|/* need DTQ to FLUSH internal buffer */
if|if
condition|(
operator|(
name|launch
operator|.
name|atm_flags
operator|&
name|EN_OBTRL
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|launch
operator|.
name|aal
operator|==
name|MID_TBD_AAL5
condition|)
block|{
name|datalen
operator|=
name|launch
operator|.
name|need
operator|-
name|MID_TBD_SIZE
expr_stmt|;
name|launch
operator|.
name|need
operator|+=
name|MID_PDU_SIZE
expr_stmt|;
comment|/* AAL5: need PDU tail */
block|}
name|dtqneed
operator|++
expr_stmt|;
comment|/* need to work on the end a bit */
block|}
comment|/*    * finish calculation of launch.need (need to figure out how much padding    * we will need).   launch.need includes MID_TBD_SIZE, but we need to    * remove that to so we can round off properly.     we have to add     * MID_TBD_SIZE back in after calculating ncells.    */
name|launch
operator|.
name|need
operator|=
name|roundup
argument_list|(
name|launch
operator|.
name|need
operator|-
name|MID_TBD_SIZE
argument_list|,
name|MID_ATMDATASZ
argument_list|)
expr_stmt|;
name|ncells
operator|=
name|launch
operator|.
name|need
operator|/
name|MID_ATMDATASZ
expr_stmt|;
name|launch
operator|.
name|need
operator|+=
name|MID_TBD_SIZE
expr_stmt|;
if|if
condition|(
name|launch
operator|.
name|need
operator|>
name|EN_TXSZ
operator|*
literal|1024
condition|)
block|{
name|printf
argument_list|(
literal|"%s: tx%d: packet larger than xmit buffer (%d> %d)\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|chan
argument_list|,
name|launch
operator|.
name|need
argument_list|,
name|EN_TXSZ
operator|*
literal|1024
argument_list|)
expr_stmt|;
goto|goto
name|dequeue_drop
goto|;
block|}
if|if
condition|(
name|launch
operator|.
name|need
operator|>
name|sc
operator|->
name|txslot
index|[
name|chan
index|]
operator|.
name|bfree
condition|)
block|{
name|EN_COUNT
argument_list|(
name|sc
operator|->
name|txoutspace
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EN_DEBUG
name|printf
argument_list|(
literal|"%s: tx%d: out of transmit space\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|chan
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
comment|/*>>> exit here if out of obmem buffer space<<< */
block|}
comment|/*    * ensure we have enough dtqs to go, if not, wait for more.    */
if|if
condition|(
name|launch
operator|.
name|nodma
condition|)
block|{
name|dtqneed
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|dtqneed
operator|>
name|sc
operator|->
name|dtq_free
condition|)
block|{
name|sc
operator|->
name|need_dtqs
operator|=
literal|1
expr_stmt|;
name|EN_COUNT
argument_list|(
name|sc
operator|->
name|txdtqout
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EN_DEBUG
name|printf
argument_list|(
literal|"%s: tx%d: out of transmit DTQs\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|chan
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
comment|/*>>> exit here if out of dtqs<<< */
block|}
comment|/*    * it is a go, commit!  dequeue mbuf start working on the xfer.    */
name|IF_DEQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|txslot
index|[
name|chan
index|]
operator|.
name|q
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EN_DIAG
if|if
condition|(
name|launch
operator|.
name|t
operator|!=
name|tmp
condition|)
name|panic
argument_list|(
literal|"en dequeue"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* EN_DIAG */
comment|/*    * launch!    */
name|EN_COUNT
argument_list|(
name|sc
operator|->
name|launch
argument_list|)
expr_stmt|;
name|sc
operator|->
name|enif
operator|.
name|if_opackets
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|launch
operator|.
name|atm_flags
operator|&
name|EN_OBHDR
operator|)
operator|==
literal|0
condition|)
block|{
name|EN_COUNT
argument_list|(
name|sc
operator|->
name|lheader
argument_list|)
expr_stmt|;
comment|/* store tbd1/tbd2 in host byte order */
name|launch
operator|.
name|tbd1
operator|=
name|MID_TBD_MK1
argument_list|(
name|launch
operator|.
name|aal
argument_list|,
name|sc
operator|->
name|txspeed
index|[
name|launch
operator|.
name|atm_vci
index|]
argument_list|,
name|ncells
argument_list|)
expr_stmt|;
name|launch
operator|.
name|tbd2
operator|=
name|MID_TBD_MK2
argument_list|(
name|launch
operator|.
name|atm_vci
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|launch
operator|.
name|atm_flags
operator|&
name|EN_OBTRL
operator|)
operator|==
literal|0
operator|&&
name|launch
operator|.
name|aal
operator|==
name|MID_TBD_AAL5
condition|)
block|{
name|EN_COUNT
argument_list|(
name|sc
operator|->
name|ltail
argument_list|)
expr_stmt|;
name|launch
operator|.
name|pdu1
operator|=
name|MID_PDU_MK1
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|datalen
argument_list|)
expr_stmt|;
comment|/* host byte order */
block|}
name|en_txlaunch
argument_list|(
name|sc
argument_list|,
name|chan
argument_list|,
operator|&
name|launch
argument_list|)
expr_stmt|;
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
if|if
condition|(
name|sc
operator|->
name|enif
operator|.
name|if_bpf
condition|)
block|{
comment|/*        * adjust the top of the mbuf to skip the pseudo atm header        * (and TBD, if present) before passing the packet to bpf,        * restore it afterwards.        */
name|int
name|size
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|atm_pseudohdr
argument_list|)
decl_stmt|;
if|if
condition|(
name|launch
operator|.
name|atm_flags
operator|&
name|EN_OBHDR
condition|)
name|size
operator|+=
name|MID_TBD_SIZE
expr_stmt|;
name|launch
operator|.
name|t
operator|->
name|m_data
operator|+=
name|size
expr_stmt|;
name|launch
operator|.
name|t
operator|->
name|m_len
operator|-=
name|size
expr_stmt|;
name|BPF_MTAP
argument_list|(
operator|&
name|sc
operator|->
name|enif
argument_list|,
name|launch
operator|.
name|t
argument_list|)
expr_stmt|;
name|launch
operator|.
name|t
operator|->
name|m_data
operator|-=
name|size
expr_stmt|;
name|launch
operator|.
name|t
operator|->
name|m_len
operator|+=
name|size
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* NBPFILTER> 0 */
comment|/*    * do some housekeeping and get the next packet    */
name|sc
operator|->
name|txslot
index|[
name|chan
index|]
operator|.
name|bfree
operator|-=
name|launch
operator|.
name|need
expr_stmt|;
name|IF_ENQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|txslot
index|[
name|chan
index|]
operator|.
name|indma
argument_list|,
name|launch
operator|.
name|t
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
comment|/*    * END of txdma loop!    */
comment|/*    * error handles    */
name|dequeue_drop
label|:
name|IF_DEQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|txslot
index|[
name|chan
index|]
operator|.
name|q
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|launch
operator|.
name|t
operator|!=
name|tmp
condition|)
name|panic
argument_list|(
literal|"en dequeue drop"
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|launch
operator|.
name|t
argument_list|)
expr_stmt|;
name|sc
operator|->
name|txslot
index|[
name|chan
index|]
operator|.
name|mbsize
operator|-=
name|launch
operator|.
name|mlen
expr_stmt|;
goto|goto
name|again
goto|;
block|}
end_function

begin_comment
comment|/*  * en_txlaunch: launch an mbuf into the dma pool!  */
end_comment

begin_function
name|STATIC
name|void
name|en_txlaunch
parameter_list|(
name|sc
parameter_list|,
name|chan
parameter_list|,
name|l
parameter_list|)
name|struct
name|en_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|chan
decl_stmt|;
name|struct
name|en_launch
modifier|*
name|l
decl_stmt|;
block|{
name|struct
name|mbuf
modifier|*
name|tmp
decl_stmt|;
name|u_int32_t
name|cur
init|=
name|sc
operator|->
name|txslot
index|[
name|chan
index|]
operator|.
name|cur
decl_stmt|,
name|start
init|=
name|sc
operator|->
name|txslot
index|[
name|chan
index|]
operator|.
name|start
decl_stmt|,
name|stop
init|=
name|sc
operator|->
name|txslot
index|[
name|chan
index|]
operator|.
name|stop
decl_stmt|,
name|dma
decl_stmt|,
modifier|*
name|data
decl_stmt|,
modifier|*
name|datastop
decl_stmt|,
name|count
decl_stmt|,
name|bcode
decl_stmt|;
name|int
name|pad
decl_stmt|,
name|addtail
decl_stmt|,
name|need
decl_stmt|,
name|len
decl_stmt|,
name|needalign
decl_stmt|,
name|cnt
decl_stmt|,
name|end
decl_stmt|,
name|mx
decl_stmt|;
comment|/*   * vars:   *   need = # bytes card still needs (decr. to zero)   *   len = # of bytes left in current mbuf   *   cur = our current pointer   *   dma = last place we programmed into the DMA   *   data = pointer into data area of mbuf that needs to go next   *   cnt = # of bytes to transfer in this DTQ   *   bcode/count = DMA burst code, and chip's version of cnt   *   *   a single buffer can require up to 5 DTQs depending on its size   *   and alignment requirements.   the 5 possible requests are:   *   [1] 1, 2, or 3 byte DMA to align src data pointer to word boundary   *   [2] alburst DMA to align src data pointer to bestburstlen   *   [3] 1 or more bestburstlen DMAs   *   [4] clean up burst (to last word boundary)   *   [5] 1, 2, or 3 byte final clean up DMA   */
name|need
operator|=
name|l
operator|->
name|need
expr_stmt|;
name|dma
operator|=
name|cur
expr_stmt|;
name|addtail
operator|=
operator|(
name|l
operator|->
name|atm_flags
operator|&
name|EN_OBTRL
operator|)
operator|==
literal|0
expr_stmt|;
comment|/* add a tail? */
ifdef|#
directive|ifdef
name|EN_DIAG
if|if
condition|(
operator|(
name|need
operator|-
name|MID_TBD_SIZE
operator|)
operator|%
name|MID_ATMDATASZ
condition|)
name|printf
argument_list|(
literal|"%s: tx%d: bogus trasmit needs (%d)\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|chan
argument_list|,
name|need
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EN_DEBUG
name|printf
argument_list|(
literal|"%s: tx%d: launch mbuf %p!   cur=0x%x[%d], need=%d, addtail=%d\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|chan
argument_list|,
name|l
operator|->
name|t
argument_list|,
name|cur
argument_list|,
operator|(
name|cur
operator|-
name|start
operator|)
operator|/
literal|4
argument_list|,
name|need
argument_list|,
name|addtail
argument_list|)
expr_stmt|;
name|count
operator|=
name|EN_READ
argument_list|(
name|sc
argument_list|,
name|MIDX_PLACE
argument_list|(
name|chan
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"     HW: base_address=0x%x, size=%d, read=%d, descstart=%d\n"
argument_list|,
name|MIDX_BASE
argument_list|(
name|count
argument_list|)
argument_list|,
name|MIDX_SZ
argument_list|(
name|count
argument_list|)
argument_list|,
name|EN_READ
argument_list|(
name|sc
argument_list|,
name|MIDX_READPTR
argument_list|(
name|chan
argument_list|)
argument_list|)
argument_list|,
name|EN_READ
argument_list|(
name|sc
argument_list|,
name|MIDX_DESCSTART
argument_list|(
name|chan
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*   * do we need to insert the TBD by hand?   * note that tbd1/tbd2/pdu1 are in host byte order.   */
if|if
condition|(
operator|(
name|l
operator|->
name|atm_flags
operator|&
name|EN_OBHDR
operator|)
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|EN_DEBUG
name|printf
argument_list|(
literal|"%s: tx%d: insert header 0x%x 0x%x\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|chan
argument_list|,
name|l
operator|->
name|tbd1
argument_list|,
name|l
operator|->
name|tbd2
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|EN_WRITE
argument_list|(
name|sc
argument_list|,
name|cur
argument_list|,
name|l
operator|->
name|tbd1
argument_list|)
expr_stmt|;
name|EN_WRAPADD
argument_list|(
name|start
argument_list|,
name|stop
argument_list|,
name|cur
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|EN_WRITE
argument_list|(
name|sc
argument_list|,
name|cur
argument_list|,
name|l
operator|->
name|tbd2
argument_list|)
expr_stmt|;
name|EN_WRAPADD
argument_list|(
name|start
argument_list|,
name|stop
argument_list|,
name|cur
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|need
operator|-=
literal|8
expr_stmt|;
block|}
comment|/*    * now do the mbufs...    */
for|for
control|(
name|tmp
operator|=
name|l
operator|->
name|t
init|;
name|tmp
operator|!=
name|NULL
condition|;
name|tmp
operator|=
name|tmp
operator|->
name|m_next
control|)
block|{
comment|/* get pointer to data and length */
name|data
operator|=
name|mtod
argument_list|(
name|tmp
argument_list|,
name|u_int32_t
operator|*
argument_list|)
expr_stmt|;
name|len
operator|=
name|tmp
operator|->
name|m_len
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
name|l
operator|->
name|t
condition|)
block|{
name|data
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|atm_pseudohdr
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
expr_stmt|;
name|len
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|atm_pseudohdr
argument_list|)
expr_stmt|;
block|}
comment|/* now, determine if we should copy it */
if|if
condition|(
name|l
operator|->
name|nodma
operator|||
operator|(
name|len
operator|<
name|EN_MINDMA
operator|&&
operator|(
name|len
operator|%
literal|4
operator|)
operator|==
literal|0
operator|&&
operator|(
operator|(
name|uintptr_t
operator|)
operator|(
name|void
operator|*
operator|)
name|data
operator|%
literal|4
operator|)
operator|==
literal|0
operator|&&
operator|(
name|cur
operator|%
literal|4
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/*         * roundup len: the only time this will change the value of len        * is when l->nodma is true, tmp is the last mbuf, and there is        * a non-word number of bytes to transmit.   in this case it is        * safe to round up because we've en_mfix'd the mbuf (so the first        * byte is word aligned there must be enough free bytes at the end        * to round off to the next word boundary)...        */
name|len
operator|=
name|roundup
argument_list|(
name|len
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
argument_list|)
expr_stmt|;
name|datastop
operator|=
name|data
operator|+
operator|(
name|len
operator|/
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
operator|)
expr_stmt|;
comment|/* copy loop: preserve byte order!!!  use WRITEDAT */
while|while
condition|(
name|data
operator|!=
name|datastop
condition|)
block|{
name|EN_WRITEDAT
argument_list|(
name|sc
argument_list|,
name|cur
argument_list|,
operator|*
name|data
argument_list|)
expr_stmt|;
name|data
operator|++
expr_stmt|;
name|EN_WRAPADD
argument_list|(
name|start
argument_list|,
name|stop
argument_list|,
name|cur
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
name|need
operator|-=
name|len
expr_stmt|;
ifdef|#
directive|ifdef
name|EN_DEBUG
name|printf
argument_list|(
literal|"%s: tx%d: copied %d bytes (%d left, cur now 0x%x)\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|chan
argument_list|,
name|len
argument_list|,
name|need
argument_list|,
name|cur
argument_list|)
expr_stmt|;
endif|#
directive|endif
continue|continue;
comment|/* continue on to next mbuf */
block|}
comment|/* going to do DMA, first make sure the dtq is in sync. */
if|if
condition|(
name|dma
operator|!=
name|cur
condition|)
block|{
name|EN_DTQADD
argument_list|(
name|sc
argument_list|,
name|WORD_IDX
argument_list|(
name|start
argument_list|,
name|cur
argument_list|)
argument_list|,
name|chan
argument_list|,
name|MIDDMA_JK
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EN_DEBUG
name|printf
argument_list|(
literal|"%s: tx%d: dtq_sync: advance pointer to %d\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|chan
argument_list|,
name|cur
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/*      * if this is the last buffer, and it looks like we are going to need to      * flush the internal buffer, can we extend the length of this mbuf to      * avoid the FLUSH?      */
if|if
condition|(
name|tmp
operator|->
name|m_next
operator|==
name|NULL
condition|)
block|{
name|cnt
operator|=
operator|(
name|need
operator|-
name|len
operator|)
operator|%
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnt
operator|&&
name|M_TRAILINGSPACE
argument_list|(
name|tmp
argument_list|)
operator|>=
name|cnt
condition|)
name|len
operator|+=
name|cnt
expr_stmt|;
comment|/* pad for FLUSH */
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|MIDWAY_ENIONLY
argument_list|)
comment|/*      * the adaptec DMA engine is smart and handles everything for us.      */
if|if
condition|(
name|sc
operator|->
name|is_adaptec
condition|)
block|{
comment|/* need to DMA "len" bytes out to card */
name|need
operator|-=
name|len
expr_stmt|;
name|EN_WRAPADD
argument_list|(
name|start
argument_list|,
name|stop
argument_list|,
name|cur
argument_list|,
name|len
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EN_DEBUG
name|printf
argument_list|(
literal|"%s: tx%d: adp_dma %d bytes (%d left, cur now 0x%x)\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|chan
argument_list|,
name|len
argument_list|,
name|need
argument_list|,
name|cur
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|end
operator|=
operator|(
name|need
operator|==
literal|0
operator|)
condition|?
name|MID_DMA_END
else|:
literal|0
expr_stmt|;
name|EN_DTQADD
argument_list|(
name|sc
argument_list|,
name|len
argument_list|,
name|chan
argument_list|,
literal|0
argument_list|,
name|vtophys
argument_list|(
name|data
argument_list|)
argument_list|,
name|l
operator|->
name|mlen
argument_list|,
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|end
condition|)
goto|goto
name|done
goto|;
name|dma
operator|=
name|cur
expr_stmt|;
comment|/* update dma pointer */
continue|continue;
block|}
endif|#
directive|endif
comment|/* !MIDWAY_ENIONLY */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|MIDWAY_ADPONLY
argument_list|)
comment|/*      * the ENI DMA engine is not so smart and need more help from us      */
comment|/* do we need to do a DMA op to align to word boundary? */
name|needalign
operator|=
operator|(
name|uintptr_t
operator|)
operator|(
name|void
operator|*
operator|)
name|data
operator|%
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|needalign
condition|)
block|{
name|EN_COUNT
argument_list|(
name|sc
operator|->
name|headbyte
argument_list|)
expr_stmt|;
name|cnt
operator|=
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
operator|-
name|needalign
expr_stmt|;
if|if
condition|(
name|cnt
operator|==
literal|2
operator|&&
name|len
operator|>=
name|cnt
condition|)
block|{
name|count
operator|=
literal|1
expr_stmt|;
name|bcode
operator|=
name|MIDDMA_2BYTE
expr_stmt|;
block|}
else|else
block|{
name|cnt
operator|=
name|min
argument_list|(
name|cnt
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* prevent overflow */
name|count
operator|=
name|cnt
expr_stmt|;
name|bcode
operator|=
name|MIDDMA_BYTE
expr_stmt|;
block|}
name|need
operator|-=
name|cnt
expr_stmt|;
name|EN_WRAPADD
argument_list|(
name|start
argument_list|,
name|stop
argument_list|,
name|cur
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EN_DEBUG
name|printf
argument_list|(
literal|"%s: tx%d: small al_dma %d bytes (%d left, cur now 0x%x)\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|chan
argument_list|,
name|cnt
argument_list|,
name|need
argument_list|,
name|cur
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|len
operator|-=
name|cnt
expr_stmt|;
name|end
operator|=
operator|(
name|need
operator|==
literal|0
operator|)
condition|?
name|MID_DMA_END
else|:
literal|0
expr_stmt|;
name|EN_DTQADD
argument_list|(
name|sc
argument_list|,
name|count
argument_list|,
name|chan
argument_list|,
name|bcode
argument_list|,
name|vtophys
argument_list|(
name|data
argument_list|)
argument_list|,
name|l
operator|->
name|mlen
argument_list|,
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|end
condition|)
goto|goto
name|done
goto|;
name|data
operator|=
operator|(
name|u_int32_t
operator|*
operator|)
operator|(
operator|(
name|u_char
operator|*
operator|)
name|data
operator|+
name|cnt
operator|)
expr_stmt|;
block|}
comment|/* do we need to do a DMA op to align? */
if|if
condition|(
name|sc
operator|->
name|alburst
operator|&&
operator|(
name|needalign
operator|=
operator|(
operator|(
operator|(
name|uintptr_t
operator|)
operator|(
name|void
operator|*
operator|)
name|data
operator|)
operator|&
name|sc
operator|->
name|bestburstmask
operator|)
operator|)
operator|!=
literal|0
operator|&&
name|len
operator|>=
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
condition|)
block|{
name|cnt
operator|=
name|sc
operator|->
name|bestburstlen
operator|-
name|needalign
expr_stmt|;
name|mx
operator|=
name|len
operator|&
operator|~
operator|(
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* don't go past end */
if|if
condition|(
name|cnt
operator|>
name|mx
condition|)
block|{
name|cnt
operator|=
name|mx
expr_stmt|;
name|count
operator|=
name|cnt
operator|/
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
expr_stmt|;
name|bcode
operator|=
name|MIDDMA_WORD
expr_stmt|;
block|}
else|else
block|{
name|count
operator|=
name|cnt
operator|/
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
expr_stmt|;
name|bcode
operator|=
name|en_dmaplan
index|[
name|count
index|]
operator|.
name|bcode
expr_stmt|;
name|count
operator|=
name|cnt
operator|>>
name|en_dmaplan
index|[
name|count
index|]
operator|.
name|divshift
expr_stmt|;
block|}
name|need
operator|-=
name|cnt
expr_stmt|;
name|EN_WRAPADD
argument_list|(
name|start
argument_list|,
name|stop
argument_list|,
name|cur
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EN_DEBUG
name|printf
argument_list|(
literal|"%s: tx%d: al_dma %d bytes (%d left, cur now 0x%x)\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|chan
argument_list|,
name|cnt
argument_list|,
name|need
argument_list|,
name|cur
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|len
operator|-=
name|cnt
expr_stmt|;
name|end
operator|=
operator|(
name|need
operator|==
literal|0
operator|)
condition|?
name|MID_DMA_END
else|:
literal|0
expr_stmt|;
name|EN_DTQADD
argument_list|(
name|sc
argument_list|,
name|count
argument_list|,
name|chan
argument_list|,
name|bcode
argument_list|,
name|vtophys
argument_list|(
name|data
argument_list|)
argument_list|,
name|l
operator|->
name|mlen
argument_list|,
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|end
condition|)
goto|goto
name|done
goto|;
name|data
operator|=
operator|(
name|u_int32_t
operator|*
operator|)
operator|(
operator|(
name|u_char
operator|*
operator|)
name|data
operator|+
name|cnt
operator|)
expr_stmt|;
block|}
comment|/* do we need to do a max-sized burst? */
if|if
condition|(
name|len
operator|>=
name|sc
operator|->
name|bestburstlen
condition|)
block|{
name|count
operator|=
name|len
operator|>>
name|sc
operator|->
name|bestburstshift
expr_stmt|;
name|cnt
operator|=
name|count
operator|<<
name|sc
operator|->
name|bestburstshift
expr_stmt|;
name|bcode
operator|=
name|sc
operator|->
name|bestburstcode
expr_stmt|;
name|need
operator|-=
name|cnt
expr_stmt|;
name|EN_WRAPADD
argument_list|(
name|start
argument_list|,
name|stop
argument_list|,
name|cur
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EN_DEBUG
name|printf
argument_list|(
literal|"%s: tx%d: best_dma %d bytes (%d left, cur now 0x%x)\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|chan
argument_list|,
name|cnt
argument_list|,
name|need
argument_list|,
name|cur
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|len
operator|-=
name|cnt
expr_stmt|;
name|end
operator|=
operator|(
name|need
operator|==
literal|0
operator|)
condition|?
name|MID_DMA_END
else|:
literal|0
expr_stmt|;
name|EN_DTQADD
argument_list|(
name|sc
argument_list|,
name|count
argument_list|,
name|chan
argument_list|,
name|bcode
argument_list|,
name|vtophys
argument_list|(
name|data
argument_list|)
argument_list|,
name|l
operator|->
name|mlen
argument_list|,
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|end
condition|)
goto|goto
name|done
goto|;
name|data
operator|=
operator|(
name|u_int32_t
operator|*
operator|)
operator|(
operator|(
name|u_char
operator|*
operator|)
name|data
operator|+
name|cnt
operator|)
expr_stmt|;
block|}
comment|/* do we need to do a cleanup burst? */
name|cnt
operator|=
name|len
operator|&
operator|~
operator|(
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|cnt
condition|)
block|{
name|count
operator|=
name|cnt
operator|/
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
expr_stmt|;
name|bcode
operator|=
name|en_dmaplan
index|[
name|count
index|]
operator|.
name|bcode
expr_stmt|;
name|count
operator|=
name|cnt
operator|>>
name|en_dmaplan
index|[
name|count
index|]
operator|.
name|divshift
expr_stmt|;
name|need
operator|-=
name|cnt
expr_stmt|;
name|EN_WRAPADD
argument_list|(
name|start
argument_list|,
name|stop
argument_list|,
name|cur
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EN_DEBUG
name|printf
argument_list|(
literal|"%s: tx%d: cleanup_dma %d bytes (%d left, cur now 0x%x)\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|chan
argument_list|,
name|cnt
argument_list|,
name|need
argument_list|,
name|cur
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|len
operator|-=
name|cnt
expr_stmt|;
name|end
operator|=
operator|(
name|need
operator|==
literal|0
operator|)
condition|?
name|MID_DMA_END
else|:
literal|0
expr_stmt|;
name|EN_DTQADD
argument_list|(
name|sc
argument_list|,
name|count
argument_list|,
name|chan
argument_list|,
name|bcode
argument_list|,
name|vtophys
argument_list|(
name|data
argument_list|)
argument_list|,
name|l
operator|->
name|mlen
argument_list|,
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|end
condition|)
goto|goto
name|done
goto|;
name|data
operator|=
operator|(
name|u_int32_t
operator|*
operator|)
operator|(
operator|(
name|u_char
operator|*
operator|)
name|data
operator|+
name|cnt
operator|)
expr_stmt|;
block|}
comment|/* any word fragments left? */
if|if
condition|(
name|len
condition|)
block|{
name|EN_COUNT
argument_list|(
name|sc
operator|->
name|tailbyte
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|2
condition|)
block|{
name|count
operator|=
literal|1
expr_stmt|;
name|bcode
operator|=
name|MIDDMA_2BYTE
expr_stmt|;
comment|/* use 2byte mode */
block|}
else|else
block|{
name|count
operator|=
name|len
expr_stmt|;
name|bcode
operator|=
name|MIDDMA_BYTE
expr_stmt|;
comment|/* use 1 byte mode */
block|}
name|need
operator|-=
name|len
expr_stmt|;
name|EN_WRAPADD
argument_list|(
name|start
argument_list|,
name|stop
argument_list|,
name|cur
argument_list|,
name|len
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EN_DEBUG
name|printf
argument_list|(
literal|"%s: tx%d: byte cleanup_dma %d bytes (%d left, cur now 0x%x)\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|chan
argument_list|,
name|len
argument_list|,
name|need
argument_list|,
name|cur
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|end
operator|=
operator|(
name|need
operator|==
literal|0
operator|)
condition|?
name|MID_DMA_END
else|:
literal|0
expr_stmt|;
name|EN_DTQADD
argument_list|(
name|sc
argument_list|,
name|count
argument_list|,
name|chan
argument_list|,
name|bcode
argument_list|,
name|vtophys
argument_list|(
name|data
argument_list|)
argument_list|,
name|l
operator|->
name|mlen
argument_list|,
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|end
condition|)
goto|goto
name|done
goto|;
block|}
name|dma
operator|=
name|cur
expr_stmt|;
comment|/* update dma pointer */
endif|#
directive|endif
comment|/* !MIDWAY_ADPONLY */
block|}
comment|/* next mbuf, please */
comment|/*    * all mbuf data has been copied out to the obmem (or set up to be DMAd).    * if the trailer or padding needs to be put in, do it now.      *    * NOTE: experimental results reveal the following fact:    *   if you DMA "X" bytes to the card, where X is not a multiple of 4,    *   then the card will internally buffer the last (X % 4) bytes (in    *   hopes of getting (4 - (X % 4)) more bytes to make a complete word).    *   it is imporant to make sure we don't leave any important data in    *   this internal buffer because it is discarded on the last (end) DTQ.    *   one way to do this is to DMA in (4 - (X % 4)) more bytes to flush    *   the darn thing out.    */
if|if
condition|(
name|addtail
condition|)
block|{
name|pad
operator|=
name|need
operator|%
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|pad
condition|)
block|{
comment|/*        * FLUSH internal data buffer.  pad out with random data from the front        * of the mbuf chain...        */
name|bcode
operator|=
operator|(
name|sc
operator|->
name|is_adaptec
operator|)
condition|?
literal|0
else|:
name|MIDDMA_BYTE
expr_stmt|;
name|EN_COUNT
argument_list|(
name|sc
operator|->
name|tailflush
argument_list|)
expr_stmt|;
name|EN_WRAPADD
argument_list|(
name|start
argument_list|,
name|stop
argument_list|,
name|cur
argument_list|,
name|pad
argument_list|)
expr_stmt|;
name|EN_DTQADD
argument_list|(
name|sc
argument_list|,
name|pad
argument_list|,
name|chan
argument_list|,
name|bcode
argument_list|,
name|vtophys
argument_list|(
name|l
operator|->
name|t
operator|->
name|m_data
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|need
operator|-=
name|pad
expr_stmt|;
ifdef|#
directive|ifdef
name|EN_DEBUG
name|printf
argument_list|(
literal|"%s: tx%d: pad/FLUSH dma %d bytes (%d left, cur now 0x%x)\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|chan
argument_list|,
name|pad
argument_list|,
name|need
argument_list|,
name|cur
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* copy data */
name|pad
operator|=
name|need
operator|/
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
expr_stmt|;
comment|/* round *down* */
if|if
condition|(
name|l
operator|->
name|aal
operator|==
name|MID_TBD_AAL5
condition|)
name|pad
operator|-=
literal|2
expr_stmt|;
ifdef|#
directive|ifdef
name|EN_DEBUG
name|printf
argument_list|(
literal|"%s: tx%d: padding %d bytes (cur now 0x%x)\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|chan
argument_list|,
name|pad
operator|*
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
argument_list|,
name|cur
argument_list|)
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
name|pad
operator|--
condition|)
block|{
name|EN_WRITEDAT
argument_list|(
name|sc
argument_list|,
name|cur
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* no byte order issues with zero */
name|EN_WRAPADD
argument_list|(
name|start
argument_list|,
name|stop
argument_list|,
name|cur
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|l
operator|->
name|aal
operator|==
name|MID_TBD_AAL5
condition|)
block|{
name|EN_WRITE
argument_list|(
name|sc
argument_list|,
name|cur
argument_list|,
name|l
operator|->
name|pdu1
argument_list|)
expr_stmt|;
comment|/* in host byte order */
name|EN_WRAPADD
argument_list|(
name|start
argument_list|,
name|stop
argument_list|,
name|cur
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|addtail
operator|||
name|dma
operator|!=
name|cur
condition|)
block|{
comment|/* write final descritor  */
name|EN_DTQADD
argument_list|(
name|sc
argument_list|,
name|WORD_IDX
argument_list|(
name|start
argument_list|,
name|cur
argument_list|)
argument_list|,
name|chan
argument_list|,
name|MIDDMA_JK
argument_list|,
literal|0
argument_list|,
name|l
operator|->
name|mlen
argument_list|,
name|MID_DMA_END
argument_list|)
expr_stmt|;
comment|/* dma = cur; */
comment|/* not necessary since we are done */
block|}
name|done
label|:
comment|/* update current pointer */
name|sc
operator|->
name|txslot
index|[
name|chan
index|]
operator|.
name|cur
operator|=
name|cur
expr_stmt|;
ifdef|#
directive|ifdef
name|EN_DEBUG
name|printf
argument_list|(
literal|"%s: tx%d: DONE!   cur now = 0x%x\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|chan
argument_list|,
name|cur
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
end_function

begin_comment
comment|/*  * interrupt handler  */
end_comment

begin_function
name|EN_INTR_TYPE
name|en_intr
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|struct
name|en_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|en_softc
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|atm_pseudohdr
name|ah
decl_stmt|;
name|u_int32_t
name|reg
decl_stmt|,
name|kick
decl_stmt|,
name|val
decl_stmt|,
name|mask
decl_stmt|,
name|chip
decl_stmt|,
name|vci
decl_stmt|,
name|slot
decl_stmt|,
name|dtq
decl_stmt|,
name|drq
decl_stmt|;
name|int
name|lcv
decl_stmt|,
name|idx
decl_stmt|,
name|need_softserv
init|=
literal|0
decl_stmt|;
name|reg
operator|=
name|EN_READ
argument_list|(
name|sc
argument_list|,
name|MID_INTACK
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|reg
operator|&
name|MID_INT_ANY
operator|)
operator|==
literal|0
condition|)
name|EN_INTR_RET
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* not us */
ifdef|#
directive|ifdef
name|EN_DEBUG
name|printf
argument_list|(
literal|"%s: interrupt=0x%b\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|reg
argument_list|,
name|MID_INTBITS
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*    * unexpected errors that need a reset    */
if|if
condition|(
operator|(
name|reg
operator|&
operator|(
name|MID_INT_IDENT
operator||
name|MID_INT_LERR
operator||
name|MID_INT_DMA_ERR
operator||
name|MID_INT_SUNI
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: unexpected interrupt=0x%b, resetting card\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|reg
argument_list|,
name|MID_INTBITS
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EN_DEBUG
ifdef|#
directive|ifdef
name|DDB
name|Debugger
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* DDB */
name|sc
operator|->
name|enif
operator|.
name|if_flags
operator|&=
operator|~
name|IFF_RUNNING
expr_stmt|;
comment|/* FREEZE! */
else|#
directive|else
name|en_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|en_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|EN_INTR_RET
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* for us */
block|}
comment|/*******************    * xmit interrupts *    ******************/
name|kick
operator|=
literal|0
expr_stmt|;
comment|/* bitmask of channels to kick */
if|if
condition|(
name|reg
operator|&
name|MID_INT_TX
condition|)
block|{
comment|/* TX done! */
comment|/*      * check for tx complete, if detected then this means that some space      * has come free on the card.   we must account for it and arrange to      * kick the channel to life (in case it is stalled waiting on the card).      */
for|for
control|(
name|mask
operator|=
literal|1
operator|,
name|lcv
operator|=
literal|0
init|;
name|lcv
operator|<
name|EN_NTX
condition|;
name|lcv
operator|++
operator|,
name|mask
operator|=
name|mask
operator|*
literal|2
control|)
block|{
if|if
condition|(
name|reg
operator|&
name|MID_TXCHAN
argument_list|(
name|lcv
argument_list|)
condition|)
block|{
name|kick
operator|=
name|kick
operator||
name|mask
expr_stmt|;
comment|/* want to kick later */
name|val
operator|=
name|EN_READ
argument_list|(
name|sc
argument_list|,
name|MIDX_READPTR
argument_list|(
name|lcv
argument_list|)
argument_list|)
expr_stmt|;
comment|/* current read pointer */
name|val
operator|=
operator|(
name|val
operator|*
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
operator|)
operator|+
name|sc
operator|->
name|txslot
index|[
name|lcv
index|]
operator|.
name|start
expr_stmt|;
comment|/* convert to offset */
if|if
condition|(
name|val
operator|>
name|sc
operator|->
name|txslot
index|[
name|lcv
index|]
operator|.
name|cur
condition|)
name|sc
operator|->
name|txslot
index|[
name|lcv
index|]
operator|.
name|bfree
operator|=
name|val
operator|-
name|sc
operator|->
name|txslot
index|[
name|lcv
index|]
operator|.
name|cur
expr_stmt|;
else|else
name|sc
operator|->
name|txslot
index|[
name|lcv
index|]
operator|.
name|bfree
operator|=
operator|(
name|val
operator|+
operator|(
name|EN_TXSZ
operator|*
literal|1024
operator|)
operator|)
operator|-
name|sc
operator|->
name|txslot
index|[
name|lcv
index|]
operator|.
name|cur
expr_stmt|;
ifdef|#
directive|ifdef
name|EN_DEBUG
name|printf
argument_list|(
literal|"%s: tx%d: trasmit done.   %d bytes now free in buffer\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|lcv
argument_list|,
name|sc
operator|->
name|txslot
index|[
name|lcv
index|]
operator|.
name|bfree
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
block|}
if|if
condition|(
name|reg
operator|&
name|MID_INT_DMA_TX
condition|)
block|{
comment|/* TX DMA done! */
comment|/*    * check for TX DMA complete, if detected then this means that some DTQs    * are now free.   it also means some indma mbufs can be freed.    * if we needed DTQs, kick all channels.    */
name|val
operator|=
name|EN_READ
argument_list|(
name|sc
argument_list|,
name|MID_DMA_RDTX
argument_list|)
expr_stmt|;
comment|/* chip's current location */
name|idx
operator|=
name|MID_DTQ_A2REG
argument_list|(
name|sc
operator|->
name|dtq_chip
argument_list|)
expr_stmt|;
comment|/* where we last saw chip */
if|if
condition|(
name|sc
operator|->
name|need_dtqs
condition|)
block|{
name|kick
operator|=
name|MID_NTX_CH
operator|-
literal|1
expr_stmt|;
comment|/* assume power of 2, kick all! */
name|sc
operator|->
name|need_dtqs
operator|=
literal|0
expr_stmt|;
comment|/* recalculated in "kick" loop below */
ifdef|#
directive|ifdef
name|EN_DEBUG
name|printf
argument_list|(
literal|"%s: cleared need DTQ condition\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
while|while
condition|(
name|idx
operator|!=
name|val
condition|)
block|{
name|sc
operator|->
name|dtq_free
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|dtq
operator|=
name|sc
operator|->
name|dtq
index|[
name|idx
index|]
operator|)
operator|!=
literal|0
condition|)
block|{
name|sc
operator|->
name|dtq
index|[
name|idx
index|]
operator|=
literal|0
expr_stmt|;
comment|/* don't forget to zero it out when done */
name|slot
operator|=
name|EN_DQ_SLOT
argument_list|(
name|dtq
argument_list|)
expr_stmt|;
name|IF_DEQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|txslot
index|[
name|slot
index|]
operator|.
name|indma
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
name|panic
argument_list|(
literal|"enintr: dtqsync"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|txslot
index|[
name|slot
index|]
operator|.
name|mbsize
operator|-=
name|EN_DQ_LEN
argument_list|(
name|dtq
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EN_DEBUG
name|printf
argument_list|(
literal|"%s: tx%d: free %d dma bytes, mbsize now %d\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|slot
argument_list|,
name|EN_DQ_LEN
argument_list|(
name|dtq
argument_list|)
argument_list|,
name|sc
operator|->
name|txslot
index|[
name|slot
index|]
operator|.
name|mbsize
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
name|EN_WRAPADD
argument_list|(
literal|0
argument_list|,
name|MID_DTQ_N
argument_list|,
name|idx
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
name|sc
operator|->
name|dtq_chip
operator|=
name|MID_DTQ_REG2A
argument_list|(
name|val
argument_list|)
expr_stmt|;
comment|/* sync softc */
block|}
comment|/*    * kick xmit channels as needed    */
if|if
condition|(
name|kick
condition|)
block|{
ifdef|#
directive|ifdef
name|EN_DEBUG
name|printf
argument_list|(
literal|"%s: tx kick mask = 0x%x\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|kick
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|mask
operator|=
literal|1
operator|,
name|lcv
operator|=
literal|0
init|;
name|lcv
operator|<
name|EN_NTX
condition|;
name|lcv
operator|++
operator|,
name|mask
operator|=
name|mask
operator|*
literal|2
control|)
block|{
if|if
condition|(
operator|(
name|kick
operator|&
name|mask
operator|)
operator|&&
name|sc
operator|->
name|txslot
index|[
name|lcv
index|]
operator|.
name|q
operator|.
name|ifq_head
condition|)
block|{
name|en_txdma
argument_list|(
name|sc
argument_list|,
name|lcv
argument_list|)
expr_stmt|;
comment|/* kick it! */
block|}
block|}
comment|/* for each slot */
block|}
comment|/* if kick */
comment|/*******************    * recv interrupts *    ******************/
comment|/*    * check for RX DMA complete, and pass the data "upstairs"    */
if|if
condition|(
name|reg
operator|&
name|MID_INT_DMA_RX
condition|)
block|{
name|val
operator|=
name|EN_READ
argument_list|(
name|sc
argument_list|,
name|MID_DMA_RDRX
argument_list|)
expr_stmt|;
comment|/* chip's current location */
name|idx
operator|=
name|MID_DRQ_A2REG
argument_list|(
name|sc
operator|->
name|drq_chip
argument_list|)
expr_stmt|;
comment|/* where we last saw chip */
while|while
condition|(
name|idx
operator|!=
name|val
condition|)
block|{
name|sc
operator|->
name|drq_free
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|drq
operator|=
name|sc
operator|->
name|drq
index|[
name|idx
index|]
operator|)
operator|!=
literal|0
condition|)
block|{
name|sc
operator|->
name|drq
index|[
name|idx
index|]
operator|=
literal|0
expr_stmt|;
comment|/* don't forget to zero it out when done */
name|slot
operator|=
name|EN_DQ_SLOT
argument_list|(
name|drq
argument_list|)
expr_stmt|;
if|if
condition|(
name|EN_DQ_LEN
argument_list|(
name|drq
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* "JK" trash DMA? */
name|m
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|IF_DEQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|rxslot
index|[
name|slot
index|]
operator|.
name|indma
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
block|{
name|printf
argument_list|(
literal|"%s: lost mbuf in slot %d!\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|slot
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"enintr: drqsync"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* do something with this mbuf */
if|if
condition|(
name|sc
operator|->
name|rxslot
index|[
name|slot
index|]
operator|.
name|oth_flags
operator|&
name|ENOTHER_DRAIN
condition|)
block|{
comment|/* drain? */
if|if
condition|(
name|m
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|vci
operator|=
name|sc
operator|->
name|rxslot
index|[
name|slot
index|]
operator|.
name|atm_vci
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|rxslot
index|[
name|slot
index|]
operator|.
name|indma
operator|.
name|ifq_head
operator|==
name|NULL
operator|&&
name|sc
operator|->
name|rxslot
index|[
name|slot
index|]
operator|.
name|q
operator|.
name|ifq_head
operator|==
name|NULL
operator|&&
operator|(
name|EN_READ
argument_list|(
name|sc
argument_list|,
name|MID_VC
argument_list|(
name|vci
argument_list|)
argument_list|)
operator|&
name|MIDV_INSERVICE
operator|)
operator|==
literal|0
operator|&&
operator|(
name|sc
operator|->
name|rxslot
index|[
name|slot
index|]
operator|.
name|oth_flags
operator|&
name|ENOTHER_SWSL
operator|)
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|rxslot
index|[
name|slot
index|]
operator|.
name|oth_flags
operator|=
name|ENOTHER_FREE
expr_stmt|;
comment|/* done drain */
name|sc
operator|->
name|rxslot
index|[
name|slot
index|]
operator|.
name|atm_vci
operator|=
name|RX_NONE
expr_stmt|;
name|sc
operator|->
name|rxvc2slot
index|[
name|vci
index|]
operator|=
name|RX_NONE
expr_stmt|;
ifdef|#
directive|ifdef
name|EN_DEBUG
name|printf
argument_list|(
literal|"%s: rx%d: VCI %d now free\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|slot
argument_list|,
name|vci
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
elseif|else
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
name|ATM_PH_FLAGS
argument_list|(
operator|&
name|ah
argument_list|)
operator|=
name|sc
operator|->
name|rxslot
index|[
name|slot
index|]
operator|.
name|atm_flags
expr_stmt|;
name|ATM_PH_VPI
argument_list|(
operator|&
name|ah
argument_list|)
operator|=
literal|0
expr_stmt|;
name|ATM_PH_SETVCI
argument_list|(
operator|&
name|ah
argument_list|,
name|sc
operator|->
name|rxslot
index|[
name|slot
index|]
operator|.
name|atm_vci
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EN_DEBUG
name|printf
argument_list|(
literal|"%s: rx%d: rxvci%d: atm_input, mbuf %p, len %d, hand %p\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|slot
argument_list|,
name|sc
operator|->
name|rxslot
index|[
name|slot
index|]
operator|.
name|atm_vci
argument_list|,
name|m
argument_list|,
name|EN_DQ_LEN
argument_list|(
name|drq
argument_list|)
argument_list|,
name|sc
operator|->
name|rxslot
index|[
name|slot
index|]
operator|.
name|rxhand
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
if|if
condition|(
name|sc
operator|->
name|enif
operator|.
name|if_bpf
condition|)
name|BPF_MTAP
argument_list|(
operator|&
name|sc
operator|->
name|enif
argument_list|,
name|m
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* NBPFILTER> 0 */
name|sc
operator|->
name|enif
operator|.
name|if_ipackets
operator|++
expr_stmt|;
name|atm_input
argument_list|(
operator|&
name|sc
operator|->
name|enif
argument_list|,
operator|&
name|ah
argument_list|,
name|m
argument_list|,
name|sc
operator|->
name|rxslot
index|[
name|slot
index|]
operator|.
name|rxhand
argument_list|)
expr_stmt|;
block|}
block|}
name|EN_WRAPADD
argument_list|(
literal|0
argument_list|,
name|MID_DRQ_N
argument_list|,
name|idx
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
name|sc
operator|->
name|drq_chip
operator|=
name|MID_DRQ_REG2A
argument_list|(
name|val
argument_list|)
expr_stmt|;
comment|/* sync softc */
if|if
condition|(
name|sc
operator|->
name|need_drqs
condition|)
block|{
comment|/* true if we had a DRQ shortage */
name|need_softserv
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|need_drqs
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|EN_DEBUG
name|printf
argument_list|(
literal|"%s: cleared need DRQ condition\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
comment|/*    * handle service interrupts    */
if|if
condition|(
name|reg
operator|&
name|MID_INT_SERVICE
condition|)
block|{
name|chip
operator|=
name|MID_SL_REG2A
argument_list|(
name|EN_READ
argument_list|(
name|sc
argument_list|,
name|MID_SERV_WRITE
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|sc
operator|->
name|hwslistp
operator|!=
name|chip
condition|)
block|{
comment|/* fetch and remove it from hardware service list */
name|vci
operator|=
name|EN_READ
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|hwslistp
argument_list|)
expr_stmt|;
name|EN_WRAPADD
argument_list|(
name|MID_SLOFF
argument_list|,
name|MID_SLEND
argument_list|,
name|sc
operator|->
name|hwslistp
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* advance hw ptr */
name|slot
operator|=
name|sc
operator|->
name|rxvc2slot
index|[
name|vci
index|]
expr_stmt|;
if|if
condition|(
name|slot
operator|==
name|RX_NONE
condition|)
block|{
ifdef|#
directive|ifdef
name|EN_DEBUG
name|printf
argument_list|(
literal|"%s: unexpected rx interrupt on VCI %d\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|vci
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|EN_WRITE
argument_list|(
name|sc
argument_list|,
name|MID_VC
argument_list|(
name|vci
argument_list|)
argument_list|,
name|MIDV_TRASH
argument_list|)
expr_stmt|;
comment|/* rx off, damn it! */
continue|continue;
comment|/* next */
block|}
name|EN_WRITE
argument_list|(
name|sc
argument_list|,
name|MID_VC
argument_list|(
name|vci
argument_list|)
argument_list|,
name|sc
operator|->
name|rxslot
index|[
name|slot
index|]
operator|.
name|mode
argument_list|)
expr_stmt|;
comment|/* remove from hwsl */
name|EN_COUNT
argument_list|(
name|sc
operator|->
name|hwpull
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EN_DEBUG
name|printf
argument_list|(
literal|"%s: pulled VCI %d off hwslist\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|vci
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* add it to the software service list (if needed) */
if|if
condition|(
operator|(
name|sc
operator|->
name|rxslot
index|[
name|slot
index|]
operator|.
name|oth_flags
operator|&
name|ENOTHER_SWSL
operator|)
operator|==
literal|0
condition|)
block|{
name|EN_COUNT
argument_list|(
name|sc
operator|->
name|swadd
argument_list|)
expr_stmt|;
name|need_softserv
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|rxslot
index|[
name|slot
index|]
operator|.
name|oth_flags
operator||=
name|ENOTHER_SWSL
expr_stmt|;
name|sc
operator|->
name|swslist
index|[
name|sc
operator|->
name|swsl_tail
index|]
operator|=
name|slot
expr_stmt|;
name|EN_WRAPADD
argument_list|(
literal|0
argument_list|,
name|MID_SL_N
argument_list|,
name|sc
operator|->
name|swsl_tail
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sc
operator|->
name|swsl_size
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|EN_DEBUG
name|printf
argument_list|(
literal|"%s: added VCI %d to swslist\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|vci
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
empty_stmt|;
block|}
comment|/*    * now service (function too big to include here)    */
if|if
condition|(
name|need_softserv
condition|)
name|en_service
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/*    * keep our stats    */
if|if
condition|(
name|reg
operator|&
name|MID_INT_DMA_OVR
condition|)
block|{
name|EN_COUNT
argument_list|(
name|sc
operator|->
name|dmaovr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EN_DEBUG
name|printf
argument_list|(
literal|"%s: MID_INT_DMA_OVR\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|reg
operator|=
name|EN_READ
argument_list|(
name|sc
argument_list|,
name|MID_STAT
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EN_STAT
name|sc
operator|->
name|otrash
operator|+=
name|MID_OTRASH
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|sc
operator|->
name|vtrash
operator|+=
name|MID_VTRASH
argument_list|(
name|reg
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|EN_INTR_RET
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* for us */
block|}
end_function

begin_comment
comment|/*  * en_service: handle a service interrupt  *  * Q: why do we need a software service list?  *  * A: if we remove a VCI from the hardware list and we find that we are  *    out of DRQs we must defer processing until some DRQs become free.  *    so we must remember to look at this RX VCI/slot later, but we can't  *    put it back on the hardware service list (since that isn't allowed).  *    so we instead save it on the software service list.   it would be nice   *    if we could peek at the VCI on top of the hwservice list without removing  *    it, however this leads to a race condition: if we peek at it and  *    decide we are done with it new data could come in before we have a   *    chance to remove it from the hwslist.   by the time we get it out of  *    the list the interrupt for the new data will be lost.   oops!  *  */
end_comment

begin_function
name|STATIC
name|void
name|en_service
parameter_list|(
name|sc
parameter_list|)
name|struct
name|en_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|u_int32_t
name|cur
decl_stmt|,
name|dstart
decl_stmt|,
name|rbd
decl_stmt|,
name|pdu
decl_stmt|,
modifier|*
name|sav
decl_stmt|,
name|dma
decl_stmt|,
name|bcode
decl_stmt|,
name|count
decl_stmt|,
modifier|*
name|data
decl_stmt|,
modifier|*
name|datastop
decl_stmt|;
name|u_int32_t
name|start
decl_stmt|,
name|stop
decl_stmt|,
name|cnt
decl_stmt|,
name|needalign
decl_stmt|;
name|int
name|slot
decl_stmt|,
name|raw
decl_stmt|,
name|aal5
decl_stmt|,
name|llc
decl_stmt|,
name|vci
decl_stmt|,
name|fill
decl_stmt|,
name|mlen
decl_stmt|,
name|tlen
decl_stmt|,
name|drqneed
decl_stmt|,
name|need
decl_stmt|,
name|needfill
decl_stmt|,
name|end
decl_stmt|;
name|aal5
operator|=
literal|0
expr_stmt|;
comment|/* Silence gcc */
name|next_vci
label|:
if|if
condition|(
name|sc
operator|->
name|swsl_size
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|EN_DEBUG
name|printf
argument_list|(
literal|"%s: en_service done\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
comment|/*>>> exit here if swsl now empty<<< */
block|}
comment|/*    * get slot/vci to service    */
name|slot
operator|=
name|sc
operator|->
name|swslist
index|[
name|sc
operator|->
name|swsl_head
index|]
expr_stmt|;
name|vci
operator|=
name|sc
operator|->
name|rxslot
index|[
name|slot
index|]
operator|.
name|atm_vci
expr_stmt|;
ifdef|#
directive|ifdef
name|EN_DIAG
if|if
condition|(
name|sc
operator|->
name|rxvc2slot
index|[
name|vci
index|]
operator|!=
name|slot
condition|)
name|panic
argument_list|(
literal|"en_service rx slot/vci sync"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*    * determine our mode and if we've got any work to do    */
name|raw
operator|=
name|sc
operator|->
name|rxslot
index|[
name|slot
index|]
operator|.
name|oth_flags
operator|&
name|ENOTHER_RAW
expr_stmt|;
name|start
operator|=
name|sc
operator|->
name|rxslot
index|[
name|slot
index|]
operator|.
name|start
expr_stmt|;
name|stop
operator|=
name|sc
operator|->
name|rxslot
index|[
name|slot
index|]
operator|.
name|stop
expr_stmt|;
name|cur
operator|=
name|sc
operator|->
name|rxslot
index|[
name|slot
index|]
operator|.
name|cur
expr_stmt|;
ifdef|#
directive|ifdef
name|EN_DEBUG
name|printf
argument_list|(
literal|"%s: rx%d: service vci=%d raw=%d start/stop/cur=0x%x 0x%x 0x%x\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|slot
argument_list|,
name|vci
argument_list|,
name|raw
argument_list|,
name|start
argument_list|,
name|stop
argument_list|,
name|cur
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|same_vci
label|:
name|dstart
operator|=
name|MIDV_DSTART
argument_list|(
name|EN_READ
argument_list|(
name|sc
argument_list|,
name|MID_DST_RP
argument_list|(
name|vci
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|dstart
operator|=
operator|(
name|dstart
operator|*
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
operator|)
operator|+
name|start
expr_stmt|;
comment|/* check to see if there is any data at all */
if|if
condition|(
name|dstart
operator|==
name|cur
condition|)
block|{
name|defer
label|:
comment|/* defer processing */
name|EN_WRAPADD
argument_list|(
literal|0
argument_list|,
name|MID_SL_N
argument_list|,
name|sc
operator|->
name|swsl_head
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rxslot
index|[
name|slot
index|]
operator|.
name|oth_flags
operator|&=
operator|~
name|ENOTHER_SWSL
expr_stmt|;
name|sc
operator|->
name|swsl_size
operator|--
expr_stmt|;
comment|/*>>> remove from swslist<<< */
ifdef|#
directive|ifdef
name|EN_DEBUG
name|printf
argument_list|(
literal|"%s: rx%d: remove vci %d from swslist\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|slot
argument_list|,
name|vci
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|next_vci
goto|;
block|}
comment|/*    * figure out how many bytes we need    * [mlen = # bytes to go in mbufs, fill = # bytes to dump (MIDDMA_JK)]    */
if|if
condition|(
name|raw
condition|)
block|{
comment|/* raw mode (aka boodi mode) */
name|fill
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dstart
operator|>
name|cur
condition|)
name|mlen
operator|=
name|dstart
operator|-
name|cur
expr_stmt|;
else|else
name|mlen
operator|=
operator|(
name|dstart
operator|+
operator|(
name|EN_RXSZ
operator|*
literal|1024
operator|)
operator|)
operator|-
name|cur
expr_stmt|;
if|if
condition|(
name|mlen
operator|<
name|sc
operator|->
name|rxslot
index|[
name|slot
index|]
operator|.
name|raw_threshold
condition|)
goto|goto
name|defer
goto|;
comment|/* too little data to deal with */
block|}
else|else
block|{
comment|/* normal mode */
name|aal5
operator|=
operator|(
name|sc
operator|->
name|rxslot
index|[
name|slot
index|]
operator|.
name|atm_flags
operator|&
name|ATM_PH_AAL5
operator|)
expr_stmt|;
name|llc
operator|=
operator|(
name|aal5
operator|&&
operator|(
name|sc
operator|->
name|rxslot
index|[
name|slot
index|]
operator|.
name|atm_flags
operator|&
name|ATM_PH_LLCSNAP
operator|)
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|rbd
operator|=
name|EN_READ
argument_list|(
name|sc
argument_list|,
name|cur
argument_list|)
expr_stmt|;
if|if
condition|(
name|MID_RBD_ID
argument_list|(
name|rbd
argument_list|)
operator|!=
name|MID_RBD_STDID
condition|)
name|panic
argument_list|(
literal|"en_service: id mismatch\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rbd
operator|&
name|MID_RBD_T
condition|)
block|{
name|mlen
operator|=
literal|0
expr_stmt|;
comment|/* we've got trash */
name|fill
operator|=
name|MID_RBD_SIZE
expr_stmt|;
name|EN_COUNT
argument_list|(
name|sc
operator|->
name|ttrash
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EN_DEBUG
name|printf
argument_list|(
literal|"RX overflow lost %d cells!\n"
argument_list|,
name|MID_RBD_CNT
argument_list|(
name|rbd
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
operator|!
name|aal5
condition|)
block|{
name|mlen
operator|=
name|MID_RBD_SIZE
operator|+
name|MID_CHDR_SIZE
operator|+
name|MID_ATMDATASZ
expr_stmt|;
comment|/* 1 cell (ick!) */
name|fill
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|tlen
operator|=
operator|(
name|MID_RBD_CNT
argument_list|(
name|rbd
argument_list|)
operator|*
name|MID_ATMDATASZ
operator|)
operator|+
name|MID_RBD_SIZE
expr_stmt|;
name|pdu
operator|=
name|cur
operator|+
name|tlen
operator|-
name|MID_PDU_SIZE
expr_stmt|;
if|if
condition|(
name|pdu
operator|>=
name|stop
condition|)
name|pdu
operator|-=
operator|(
name|EN_RXSZ
operator|*
literal|1024
operator|)
expr_stmt|;
name|pdu
operator|=
name|EN_READ
argument_list|(
name|sc
argument_list|,
name|pdu
argument_list|)
expr_stmt|;
comment|/* get PDU in correct byte order */
name|fill
operator|=
name|tlen
operator|-
name|MID_RBD_SIZE
operator|-
name|MID_PDU_LEN
argument_list|(
name|pdu
argument_list|)
expr_stmt|;
if|if
condition|(
name|fill
operator|<
literal|0
operator|||
operator|(
name|rbd
operator|&
name|MID_RBD_CRCERR
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: %s, dropping frame\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
operator|(
name|rbd
operator|&
name|MID_RBD_CRCERR
operator|)
condition|?
literal|"CRC error"
else|:
literal|"invalid AAL5 PDU length"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: got %d cells (%d bytes), AAL5 len is %d bytes (pdu=0x%x)\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|MID_RBD_CNT
argument_list|(
name|rbd
argument_list|)
argument_list|,
name|tlen
operator|-
name|MID_RBD_SIZE
argument_list|,
name|MID_PDU_LEN
argument_list|(
name|pdu
argument_list|)
argument_list|,
name|pdu
argument_list|)
expr_stmt|;
name|fill
operator|=
name|tlen
expr_stmt|;
block|}
name|mlen
operator|=
name|tlen
operator|-
name|fill
expr_stmt|;
block|}
block|}
comment|/*    * now allocate mbufs for mlen bytes of data, if out of mbufs, trash all    *    * notes:    *  1. it is possible that we've already allocated an mbuf for this pkt    *	 but ran out of DRQs, in which case we saved the allocated mbuf on    *	 "q".    *  2. if we save an mbuf in "q" we store the "cur" (pointer) in the front     *     of the mbuf as an identity (that we can check later), and we also    *     store drqneed (so we don't have to recompute it).    *  3. after this block of code, if m is still NULL then we ran out of mbufs    */
name|m
operator|=
name|sc
operator|->
name|rxslot
index|[
name|slot
index|]
operator|.
name|q
operator|.
name|ifq_head
expr_stmt|;
name|drqneed
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|m
condition|)
block|{
name|sav
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|u_int32_t
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|sav
index|[
literal|0
index|]
operator|!=
name|cur
condition|)
block|{
ifdef|#
directive|ifdef
name|EN_DEBUG
name|printf
argument_list|(
literal|"%s: rx%d: q'ed mbuf %p not ours\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|slot
argument_list|,
name|m
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|m
operator|=
name|NULL
expr_stmt|;
comment|/* wasn't ours */
name|EN_COUNT
argument_list|(
name|sc
operator|->
name|rxqnotus
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|EN_COUNT
argument_list|(
name|sc
operator|->
name|rxqus
argument_list|)
expr_stmt|;
name|IF_DEQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|rxslot
index|[
name|slot
index|]
operator|.
name|q
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|drqneed
operator|=
name|sav
index|[
literal|1
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|EN_DEBUG
name|printf
argument_list|(
literal|"%s: rx%d: recovered q'ed mbuf %p (drqneed=%d)\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|slot
argument_list|,
name|m
argument_list|,
name|drqneed
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
if|if
condition|(
name|mlen
operator|!=
literal|0
operator|&&
name|m
operator|==
name|NULL
condition|)
block|{
name|m
operator|=
name|en_mget
argument_list|(
name|sc
argument_list|,
name|mlen
argument_list|,
operator|&
name|drqneed
argument_list|)
expr_stmt|;
comment|/* allocate! */
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|fill
operator|+=
name|mlen
expr_stmt|;
name|mlen
operator|=
literal|0
expr_stmt|;
name|EN_COUNT
argument_list|(
name|sc
operator|->
name|rxmbufout
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EN_DEBUG
name|printf
argument_list|(
literal|"%s: rx%d: out of mbufs\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|slot
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|EN_DEBUG
name|printf
argument_list|(
literal|"%s: rx%d: allocate mbuf %p, mlen=%d, drqneed=%d\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|slot
argument_list|,
name|m
argument_list|,
name|mlen
argument_list|,
name|drqneed
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|EN_DEBUG
name|printf
argument_list|(
literal|"%s: rx%d: VCI %d, mbuf_chain %p, mlen %d, fill %d\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|slot
argument_list|,
name|vci
argument_list|,
name|m
argument_list|,
name|mlen
argument_list|,
name|fill
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*    * now check to see if we've got the DRQs needed.    if we are out of     * DRQs we must quit (saving our mbuf, if we've got one).    */
name|needfill
operator|=
operator|(
name|fill
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|drqneed
operator|+
name|needfill
operator|>
name|sc
operator|->
name|drq_free
condition|)
block|{
name|sc
operator|->
name|need_drqs
operator|=
literal|1
expr_stmt|;
comment|/* flag condition */
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|EN_COUNT
argument_list|(
name|sc
operator|->
name|rxoutboth
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EN_DEBUG
name|printf
argument_list|(
literal|"%s: rx%d: out of DRQs *and* mbufs!\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|slot
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
comment|/*>>> exit here if out of both mbufs and DRQs<<< */
block|}
name|sav
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|u_int32_t
operator|*
argument_list|)
expr_stmt|;
name|sav
index|[
literal|0
index|]
operator|=
name|cur
expr_stmt|;
name|sav
index|[
literal|1
index|]
operator|=
name|drqneed
expr_stmt|;
name|IF_ENQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|rxslot
index|[
name|slot
index|]
operator|.
name|q
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|EN_COUNT
argument_list|(
name|sc
operator|->
name|rxdrqout
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EN_DEBUG
name|printf
argument_list|(
literal|"%s: rx%d: out of DRQs\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|slot
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
comment|/*>>> exit here if out of DRQs<<< */
block|}
comment|/*    * at this point all resources have been allocated and we are commited     * to servicing this slot.    *    * dma = last location we told chip about    * cur = current location    * mlen = space in the mbuf we want    * need = bytes to xfer in (decrs to zero)    * fill = how much fill we need    * tlen = how much data to transfer to this mbuf    * cnt/bcode/count =<same as xmit>    *    * 'needfill' not used after this point    */
name|dma
operator|=
name|cur
expr_stmt|;
comment|/* dma = last location we told chip about */
name|need
operator|=
name|roundup
argument_list|(
name|mlen
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
argument_list|)
expr_stmt|;
name|fill
operator|=
name|fill
operator|-
operator|(
name|need
operator|-
name|mlen
operator|)
expr_stmt|;
comment|/* note: may invalidate 'needfill' */
for|for
control|(
name|tmp
operator|=
name|m
init|;
name|tmp
operator|!=
name|NULL
operator|&&
name|need
operator|>
literal|0
condition|;
name|tmp
operator|=
name|tmp
operator|->
name|m_next
control|)
block|{
name|tlen
operator|=
name|roundup
argument_list|(
name|tmp
operator|->
name|m_len
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* m_len set by en_mget */
name|data
operator|=
name|mtod
argument_list|(
name|tmp
argument_list|,
name|u_int32_t
operator|*
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EN_DEBUG
name|printf
argument_list|(
literal|"%s: rx%d: load mbuf %p, m_len=%d, m_data=%p, tlen=%d\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|slot
argument_list|,
name|tmp
argument_list|,
name|tmp
operator|->
name|m_len
argument_list|,
name|tmp
operator|->
name|m_data
argument_list|,
name|tlen
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* copy data */
if|if
condition|(
name|EN_NORXDMA
operator|||
operator|!
name|en_dma
operator|||
name|tlen
operator|<
name|EN_MINDMA
condition|)
block|{
name|datastop
operator|=
operator|(
name|u_int32_t
operator|*
operator|)
operator|(
operator|(
name|u_char
operator|*
operator|)
name|data
operator|+
name|tlen
operator|)
expr_stmt|;
comment|/* copy loop: preserve byte order!!!  use READDAT */
while|while
condition|(
name|data
operator|!=
name|datastop
condition|)
block|{
operator|*
name|data
operator|=
name|EN_READDAT
argument_list|(
name|sc
argument_list|,
name|cur
argument_list|)
expr_stmt|;
name|data
operator|++
expr_stmt|;
name|EN_WRAPADD
argument_list|(
name|start
argument_list|,
name|stop
argument_list|,
name|cur
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
name|need
operator|-=
name|tlen
expr_stmt|;
ifdef|#
directive|ifdef
name|EN_DEBUG
name|printf
argument_list|(
literal|"%s: rx%d: vci%d: copied %d bytes (%d left)\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|slot
argument_list|,
name|vci
argument_list|,
name|tlen
argument_list|,
name|need
argument_list|)
expr_stmt|;
endif|#
directive|endif
continue|continue;
block|}
comment|/* DMA data (check to see if we need to sync DRQ first) */
if|if
condition|(
name|dma
operator|!=
name|cur
condition|)
block|{
name|EN_DRQADD
argument_list|(
name|sc
argument_list|,
name|WORD_IDX
argument_list|(
name|start
argument_list|,
name|cur
argument_list|)
argument_list|,
name|vci
argument_list|,
name|MIDDMA_JK
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EN_DEBUG
name|printf
argument_list|(
literal|"%s: rx%d: vci%d: drq_sync: advance pointer to %d\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|slot
argument_list|,
name|vci
argument_list|,
name|cur
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|MIDWAY_ENIONLY
argument_list|)
comment|/*      * the adaptec DMA engine is smart and handles everything for us.      */
if|if
condition|(
name|sc
operator|->
name|is_adaptec
condition|)
block|{
name|need
operator|-=
name|tlen
expr_stmt|;
name|EN_WRAPADD
argument_list|(
name|start
argument_list|,
name|stop
argument_list|,
name|cur
argument_list|,
name|tlen
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EN_DEBUG
name|printf
argument_list|(
literal|"%s: rx%d: vci%d: adp_dma %d bytes (%d left)\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|slot
argument_list|,
name|vci
argument_list|,
name|tlen
argument_list|,
name|need
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|end
operator|=
operator|(
name|need
operator|==
literal|0
operator|&&
operator|!
name|fill
operator|)
condition|?
name|MID_DMA_END
else|:
literal|0
expr_stmt|;
name|EN_DRQADD
argument_list|(
name|sc
argument_list|,
name|tlen
argument_list|,
name|vci
argument_list|,
literal|0
argument_list|,
name|vtophys
argument_list|(
name|data
argument_list|)
argument_list|,
name|mlen
argument_list|,
name|slot
argument_list|,
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|end
condition|)
goto|goto
name|done
goto|;
name|dma
operator|=
name|cur
expr_stmt|;
comment|/* update dma pointer */
continue|continue;
block|}
endif|#
directive|endif
comment|/* !MIDWAY_ENIONLY */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|MIDWAY_ADPONLY
argument_list|)
comment|/*      * the ENI DMA engine is not so smart and need more help from us      */
comment|/* do we need to do a DMA op to align? */
if|if
condition|(
name|sc
operator|->
name|alburst
operator|&&
operator|(
name|needalign
operator|=
operator|(
operator|(
operator|(
name|uintptr_t
operator|)
operator|(
name|void
operator|*
operator|)
name|data
operator|)
operator|&
name|sc
operator|->
name|bestburstmask
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|cnt
operator|=
name|sc
operator|->
name|bestburstlen
operator|-
name|needalign
expr_stmt|;
if|if
condition|(
name|cnt
operator|>
name|tlen
condition|)
block|{
name|cnt
operator|=
name|tlen
expr_stmt|;
name|count
operator|=
name|cnt
operator|/
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
expr_stmt|;
name|bcode
operator|=
name|MIDDMA_WORD
expr_stmt|;
block|}
else|else
block|{
name|count
operator|=
name|cnt
operator|/
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
expr_stmt|;
name|bcode
operator|=
name|en_dmaplan
index|[
name|count
index|]
operator|.
name|bcode
expr_stmt|;
name|count
operator|=
name|cnt
operator|>>
name|en_dmaplan
index|[
name|count
index|]
operator|.
name|divshift
expr_stmt|;
block|}
name|need
operator|-=
name|cnt
expr_stmt|;
name|EN_WRAPADD
argument_list|(
name|start
argument_list|,
name|stop
argument_list|,
name|cur
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EN_DEBUG
name|printf
argument_list|(
literal|"%s: rx%d: vci%d: al_dma %d bytes (%d left)\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|slot
argument_list|,
name|vci
argument_list|,
name|cnt
argument_list|,
name|need
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tlen
operator|-=
name|cnt
expr_stmt|;
name|end
operator|=
operator|(
name|need
operator|==
literal|0
operator|&&
operator|!
name|fill
operator|)
condition|?
name|MID_DMA_END
else|:
literal|0
expr_stmt|;
name|EN_DRQADD
argument_list|(
name|sc
argument_list|,
name|count
argument_list|,
name|vci
argument_list|,
name|bcode
argument_list|,
name|vtophys
argument_list|(
name|data
argument_list|)
argument_list|,
name|mlen
argument_list|,
name|slot
argument_list|,
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|end
condition|)
goto|goto
name|done
goto|;
name|data
operator|=
operator|(
name|u_int32_t
operator|*
operator|)
operator|(
operator|(
name|u_char
operator|*
operator|)
name|data
operator|+
name|cnt
operator|)
expr_stmt|;
block|}
comment|/* do we need a max-sized burst? */
if|if
condition|(
name|tlen
operator|>=
name|sc
operator|->
name|bestburstlen
condition|)
block|{
name|count
operator|=
name|tlen
operator|>>
name|sc
operator|->
name|bestburstshift
expr_stmt|;
name|cnt
operator|=
name|count
operator|<<
name|sc
operator|->
name|bestburstshift
expr_stmt|;
name|bcode
operator|=
name|sc
operator|->
name|bestburstcode
expr_stmt|;
name|need
operator|-=
name|cnt
expr_stmt|;
name|EN_WRAPADD
argument_list|(
name|start
argument_list|,
name|stop
argument_list|,
name|cur
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EN_DEBUG
name|printf
argument_list|(
literal|"%s: rx%d: vci%d: best_dma %d bytes (%d left)\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|slot
argument_list|,
name|vci
argument_list|,
name|cnt
argument_list|,
name|need
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tlen
operator|-=
name|cnt
expr_stmt|;
name|end
operator|=
operator|(
name|need
operator|==
literal|0
operator|&&
operator|!
name|fill
operator|)
condition|?
name|MID_DMA_END
else|:
literal|0
expr_stmt|;
name|EN_DRQADD
argument_list|(
name|sc
argument_list|,
name|count
argument_list|,
name|vci
argument_list|,
name|bcode
argument_list|,
name|vtophys
argument_list|(
name|data
argument_list|)
argument_list|,
name|mlen
argument_list|,
name|slot
argument_list|,
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|end
condition|)
goto|goto
name|done
goto|;
name|data
operator|=
operator|(
name|u_int32_t
operator|*
operator|)
operator|(
operator|(
name|u_char
operator|*
operator|)
name|data
operator|+
name|cnt
operator|)
expr_stmt|;
block|}
comment|/* do we need to do a cleanup burst? */
if|if
condition|(
name|tlen
condition|)
block|{
name|count
operator|=
name|tlen
operator|/
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
expr_stmt|;
name|bcode
operator|=
name|en_dmaplan
index|[
name|count
index|]
operator|.
name|bcode
expr_stmt|;
name|count
operator|=
name|tlen
operator|>>
name|en_dmaplan
index|[
name|count
index|]
operator|.
name|divshift
expr_stmt|;
name|need
operator|-=
name|tlen
expr_stmt|;
name|EN_WRAPADD
argument_list|(
name|start
argument_list|,
name|stop
argument_list|,
name|cur
argument_list|,
name|tlen
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EN_DEBUG
name|printf
argument_list|(
literal|"%s: rx%d: vci%d: cleanup_dma %d bytes (%d left)\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|slot
argument_list|,
name|vci
argument_list|,
name|tlen
argument_list|,
name|need
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|end
operator|=
operator|(
name|need
operator|==
literal|0
operator|&&
operator|!
name|fill
operator|)
condition|?
name|MID_DMA_END
else|:
literal|0
expr_stmt|;
name|EN_DRQADD
argument_list|(
name|sc
argument_list|,
name|count
argument_list|,
name|vci
argument_list|,
name|bcode
argument_list|,
name|vtophys
argument_list|(
name|data
argument_list|)
argument_list|,
name|mlen
argument_list|,
name|slot
argument_list|,
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|end
condition|)
goto|goto
name|done
goto|;
block|}
name|dma
operator|=
name|cur
expr_stmt|;
comment|/* update dma pointer */
endif|#
directive|endif
comment|/* !MIDWAY_ADPONLY */
block|}
comment|/* skip the end */
if|if
condition|(
name|fill
operator|||
name|dma
operator|!=
name|cur
condition|)
block|{
ifdef|#
directive|ifdef
name|EN_DEBUG
if|if
condition|(
name|fill
condition|)
name|printf
argument_list|(
literal|"%s: rx%d: vci%d: skipping %d bytes of fill\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|slot
argument_list|,
name|vci
argument_list|,
name|fill
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%s: rx%d: vci%d: syncing chip from 0x%x to 0x%x [cur]\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|slot
argument_list|,
name|vci
argument_list|,
name|dma
argument_list|,
name|cur
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|EN_WRAPADD
argument_list|(
name|start
argument_list|,
name|stop
argument_list|,
name|cur
argument_list|,
name|fill
argument_list|)
expr_stmt|;
name|EN_DRQADD
argument_list|(
name|sc
argument_list|,
name|WORD_IDX
argument_list|(
name|start
argument_list|,
name|cur
argument_list|)
argument_list|,
name|vci
argument_list|,
name|MIDDMA_JK
argument_list|,
literal|0
argument_list|,
name|mlen
argument_list|,
name|slot
argument_list|,
name|MID_DMA_END
argument_list|)
expr_stmt|;
comment|/* dma = cur; */
comment|/* not necessary since we are done */
block|}
comment|/*    * done, remove stuff we don't want to pass up:    *   raw mode (boodi mode): pass everything up for later processing    *   aal5: remove RBD    *   aal0: remove RBD + cell header    */
name|done
label|:
if|if
condition|(
name|m
condition|)
block|{
if|if
condition|(
operator|!
name|raw
condition|)
block|{
name|cnt
operator|=
name|MID_RBD_SIZE
expr_stmt|;
if|if
condition|(
operator|!
name|aal5
condition|)
name|cnt
operator|+=
name|MID_CHDR_SIZE
expr_stmt|;
name|m
operator|->
name|m_len
operator|-=
name|cnt
expr_stmt|;
comment|/* chop! */
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|-=
name|cnt
expr_stmt|;
name|m
operator|->
name|m_data
operator|+=
name|cnt
expr_stmt|;
block|}
name|IF_ENQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|rxslot
index|[
name|slot
index|]
operator|.
name|indma
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|rxslot
index|[
name|slot
index|]
operator|.
name|cur
operator|=
name|cur
expr_stmt|;
comment|/* update master copy of 'cur' */
ifdef|#
directive|ifdef
name|EN_DEBUG
name|printf
argument_list|(
literal|"%s: rx%d: vci%d: DONE!   cur now =0x%x\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|slot
argument_list|,
name|vci
argument_list|,
name|cur
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|same_vci
goto|;
comment|/* get next packet in this slot */
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|EN_DDBHOOK
end_ifdef

begin_comment
comment|/*  * functions we can call from ddb  */
end_comment

begin_comment
comment|/*  * en_dump: dump the state  */
end_comment

begin_define
define|#
directive|define
name|END_SWSL
value|0x00000040
end_define

begin_comment
comment|/* swsl state */
end_comment

begin_define
define|#
directive|define
name|END_DRQ
value|0x00000020
end_define

begin_comment
comment|/* drq state */
end_comment

begin_define
define|#
directive|define
name|END_DTQ
value|0x00000010
end_define

begin_comment
comment|/* dtq state */
end_comment

begin_define
define|#
directive|define
name|END_RX
value|0x00000008
end_define

begin_comment
comment|/* rx state */
end_comment

begin_define
define|#
directive|define
name|END_TX
value|0x00000004
end_define

begin_comment
comment|/* tx state */
end_comment

begin_define
define|#
directive|define
name|END_MREGS
value|0x00000002
end_define

begin_comment
comment|/* registers */
end_comment

begin_define
define|#
directive|define
name|END_STATS
value|0x00000001
end_define

begin_comment
comment|/* dump stats */
end_comment

begin_define
define|#
directive|define
name|END_BITS
value|"\20\7SWSL\6DRQ\5DTQ\4RX\3TX\2MREGS\1STATS"
end_define

begin_function
name|int
name|en_dump
parameter_list|(
name|unit
parameter_list|,
name|level
parameter_list|)
name|int
name|unit
decl_stmt|,
name|level
decl_stmt|;
block|{
name|struct
name|en_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|lcv
decl_stmt|,
name|cnt
decl_stmt|,
name|slot
decl_stmt|;
name|u_int32_t
name|ptr
decl_stmt|,
name|reg
decl_stmt|;
for|for
control|(
name|lcv
operator|=
literal|0
init|;
name|lcv
operator|<
name|en_cd
operator|.
name|cd_ndevs
condition|;
name|lcv
operator|++
control|)
block|{
name|sc
operator|=
operator|(
expr|struct
name|en_softc
operator|*
operator|)
name|en_cd
operator|.
name|cd_devs
index|[
name|lcv
index|]
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|unit
operator|!=
operator|-
literal|1
operator|&&
name|unit
operator|!=
name|lcv
condition|)
continue|continue;
name|printf
argument_list|(
literal|"dumping device %s at level 0x%b\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|level
argument_list|,
name|END_BITS
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|dtq_us
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"<hasn't been en_init'd yet>\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|level
operator|&
name|END_STATS
condition|)
block|{
name|printf
argument_list|(
literal|"  en_stats:\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    %d mfix (%d failed); %d/%d head/tail byte DMAs, %d flushes\n"
argument_list|,
name|sc
operator|->
name|mfix
argument_list|,
name|sc
operator|->
name|mfixfail
argument_list|,
name|sc
operator|->
name|headbyte
argument_list|,
name|sc
operator|->
name|tailbyte
argument_list|,
name|sc
operator|->
name|tailflush
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    %d rx dma overflow interrupts\n"
argument_list|,
name|sc
operator|->
name|dmaovr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    %d times we ran out of TX space and stalled\n"
argument_list|,
name|sc
operator|->
name|txoutspace
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    %d times we ran out of DTQs\n"
argument_list|,
name|sc
operator|->
name|txdtqout
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    %d times we launched a packet\n"
argument_list|,
name|sc
operator|->
name|launch
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    %d times we launched without on-board header\n"
argument_list|,
name|sc
operator|->
name|lheader
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    %d times we launched without on-board tail\n"
argument_list|,
name|sc
operator|->
name|ltail
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    %d times we pulled the hw service list\n"
argument_list|,
name|sc
operator|->
name|hwpull
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    %d times we pushed a vci on the sw service list\n"
argument_list|,
name|sc
operator|->
name|swadd
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    %d times RX pulled an mbuf from Q that wasn't ours\n"
argument_list|,
name|sc
operator|->
name|rxqnotus
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    %d times RX pulled a good mbuf from Q\n"
argument_list|,
name|sc
operator|->
name|rxqus
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    %d times we ran out of mbufs *and* DRQs\n"
argument_list|,
name|sc
operator|->
name|rxoutboth
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    %d times we ran out of DRQs\n"
argument_list|,
name|sc
operator|->
name|rxdrqout
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    %d trasmit packets dropped due to mbsize\n"
argument_list|,
name|sc
operator|->
name|txmbovr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    %d cells trashed due to turned off rxvc\n"
argument_list|,
name|sc
operator|->
name|vtrash
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    %d cells trashed due to totally full buffer\n"
argument_list|,
name|sc
operator|->
name|otrash
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    %d cells trashed due almost full buffer\n"
argument_list|,
name|sc
operator|->
name|ttrash
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    %d rx mbuf allocation failures\n"
argument_list|,
name|sc
operator|->
name|rxmbufout
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NATM
name|printf
argument_list|(
literal|"    %d drops at natmintrq\n"
argument_list|,
name|natmintrq
operator|.
name|ifq_drops
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NATM_STAT
name|printf
argument_list|(
literal|"    natmintr so_rcv: ok/drop cnt: %d/%d, ok/drop bytes: %d/%d\n"
argument_list|,
name|natm_sookcnt
argument_list|,
name|natm_sodropcnt
argument_list|,
name|natm_sookbytes
argument_list|,
name|natm_sodropbytes
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
block|}
if|if
condition|(
name|level
operator|&
name|END_MREGS
condition|)
block|{
name|printf
argument_list|(
literal|"mregs:\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"resid = 0x%x\n"
argument_list|,
name|EN_READ
argument_list|(
name|sc
argument_list|,
name|MID_RESID
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"interrupt status = 0x%b\n"
argument_list|,
name|EN_READ
argument_list|(
name|sc
argument_list|,
name|MID_INTSTAT
argument_list|)
argument_list|,
name|MID_INTBITS
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"interrupt enable = 0x%b\n"
argument_list|,
name|EN_READ
argument_list|(
name|sc
argument_list|,
name|MID_INTENA
argument_list|)
argument_list|,
name|MID_INTBITS
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"mcsr = 0x%b\n"
argument_list|,
name|EN_READ
argument_list|(
name|sc
argument_list|,
name|MID_MAST_CSR
argument_list|)
argument_list|,
name|MID_MCSRBITS
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"serv_write = [chip=%d] [us=%d]\n"
argument_list|,
name|EN_READ
argument_list|(
name|sc
argument_list|,
name|MID_SERV_WRITE
argument_list|)
argument_list|,
name|MID_SL_A2REG
argument_list|(
name|sc
operator|->
name|hwslistp
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"dma addr = 0x%x\n"
argument_list|,
name|EN_READ
argument_list|(
name|sc
argument_list|,
name|MID_DMA_ADDR
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"DRQ: chip[rd=0x%x,wr=0x%x], sc[chip=0x%x,us=0x%x]\n"
argument_list|,
name|MID_DRQ_REG2A
argument_list|(
name|EN_READ
argument_list|(
name|sc
argument_list|,
name|MID_DMA_RDRX
argument_list|)
argument_list|)
argument_list|,
name|MID_DRQ_REG2A
argument_list|(
name|EN_READ
argument_list|(
name|sc
argument_list|,
name|MID_DMA_WRRX
argument_list|)
argument_list|)
argument_list|,
name|sc
operator|->
name|drq_chip
argument_list|,
name|sc
operator|->
name|drq_us
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"DTQ: chip[rd=0x%x,wr=0x%x], sc[chip=0x%x,us=0x%x]\n"
argument_list|,
name|MID_DTQ_REG2A
argument_list|(
name|EN_READ
argument_list|(
name|sc
argument_list|,
name|MID_DMA_RDTX
argument_list|)
argument_list|)
argument_list|,
name|MID_DTQ_REG2A
argument_list|(
name|EN_READ
argument_list|(
name|sc
argument_list|,
name|MID_DMA_WRTX
argument_list|)
argument_list|)
argument_list|,
name|sc
operator|->
name|dtq_chip
argument_list|,
name|sc
operator|->
name|dtq_us
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  unusal txspeeds: "
argument_list|)
expr_stmt|;
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
name|MID_N_VC
condition|;
name|cnt
operator|++
control|)
if|if
condition|(
name|sc
operator|->
name|txspeed
index|[
name|cnt
index|]
condition|)
name|printf
argument_list|(
literal|" vci%d=0x%x"
argument_list|,
name|cnt
argument_list|,
name|sc
operator|->
name|txspeed
index|[
name|cnt
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  rxvc slot mappings: "
argument_list|)
expr_stmt|;
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
name|MID_N_VC
condition|;
name|cnt
operator|++
control|)
if|if
condition|(
name|sc
operator|->
name|rxvc2slot
index|[
name|cnt
index|]
operator|!=
name|RX_NONE
condition|)
name|printf
argument_list|(
literal|"  %d->%d"
argument_list|,
name|cnt
argument_list|,
name|sc
operator|->
name|rxvc2slot
index|[
name|cnt
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|level
operator|&
name|END_TX
condition|)
block|{
name|printf
argument_list|(
literal|"tx:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|slot
operator|=
literal|0
init|;
name|slot
operator|<
name|EN_NTX
condition|;
name|slot
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"tx%d: start/stop/cur=0x%x/0x%x/0x%x [%d]  "
argument_list|,
name|slot
argument_list|,
name|sc
operator|->
name|txslot
index|[
name|slot
index|]
operator|.
name|start
argument_list|,
name|sc
operator|->
name|txslot
index|[
name|slot
index|]
operator|.
name|stop
argument_list|,
name|sc
operator|->
name|txslot
index|[
name|slot
index|]
operator|.
name|cur
argument_list|,
operator|(
name|sc
operator|->
name|txslot
index|[
name|slot
index|]
operator|.
name|cur
operator|-
name|sc
operator|->
name|txslot
index|[
name|slot
index|]
operator|.
name|start
operator|)
operator|/
literal|4
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"mbsize=%d, bfree=%d\n"
argument_list|,
name|sc
operator|->
name|txslot
index|[
name|slot
index|]
operator|.
name|mbsize
argument_list|,
name|sc
operator|->
name|txslot
index|[
name|slot
index|]
operator|.
name|bfree
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"txhw: base_address=0x%x, size=%d, read=%d, descstart=%d\n"
argument_list|,
name|MIDX_BASE
argument_list|(
name|EN_READ
argument_list|(
name|sc
argument_list|,
name|MIDX_PLACE
argument_list|(
name|slot
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|MIDX_SZ
argument_list|(
name|EN_READ
argument_list|(
name|sc
argument_list|,
name|MIDX_PLACE
argument_list|(
name|slot
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|EN_READ
argument_list|(
name|sc
argument_list|,
name|MIDX_READPTR
argument_list|(
name|slot
argument_list|)
argument_list|)
argument_list|,
name|EN_READ
argument_list|(
name|sc
argument_list|,
name|MIDX_DESCSTART
argument_list|(
name|slot
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|level
operator|&
name|END_RX
condition|)
block|{
name|printf
argument_list|(
literal|"  recv slots:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|slot
operator|=
literal|0
init|;
name|slot
operator|<
name|sc
operator|->
name|en_nrx
condition|;
name|slot
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"rx%d: vci=%d: start/stop/cur=0x%x/0x%x/0x%x "
argument_list|,
name|slot
argument_list|,
name|sc
operator|->
name|rxslot
index|[
name|slot
index|]
operator|.
name|atm_vci
argument_list|,
name|sc
operator|->
name|rxslot
index|[
name|slot
index|]
operator|.
name|start
argument_list|,
name|sc
operator|->
name|rxslot
index|[
name|slot
index|]
operator|.
name|stop
argument_list|,
name|sc
operator|->
name|rxslot
index|[
name|slot
index|]
operator|.
name|cur
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"mode=0x%x, atm_flags=0x%x, oth_flags=0x%x\n"
argument_list|,
name|sc
operator|->
name|rxslot
index|[
name|slot
index|]
operator|.
name|mode
argument_list|,
name|sc
operator|->
name|rxslot
index|[
name|slot
index|]
operator|.
name|atm_flags
argument_list|,
name|sc
operator|->
name|rxslot
index|[
name|slot
index|]
operator|.
name|oth_flags
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"RXHW: mode=0x%x, DST_RP=0x%x, WP_ST_CNT=0x%x\n"
argument_list|,
name|EN_READ
argument_list|(
name|sc
argument_list|,
name|MID_VC
argument_list|(
name|sc
operator|->
name|rxslot
index|[
name|slot
index|]
operator|.
name|atm_vci
argument_list|)
argument_list|)
argument_list|,
name|EN_READ
argument_list|(
name|sc
argument_list|,
name|MID_DST_RP
argument_list|(
name|sc
operator|->
name|rxslot
index|[
name|slot
index|]
operator|.
name|atm_vci
argument_list|)
argument_list|)
argument_list|,
name|EN_READ
argument_list|(
name|sc
argument_list|,
name|MID_WP_ST_CNT
argument_list|(
name|sc
operator|->
name|rxslot
index|[
name|slot
index|]
operator|.
name|atm_vci
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|level
operator|&
name|END_DTQ
condition|)
block|{
name|printf
argument_list|(
literal|"  dtq [need_dtqs=%d,dtq_free=%d]:\n"
argument_list|,
name|sc
operator|->
name|need_dtqs
argument_list|,
name|sc
operator|->
name|dtq_free
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|sc
operator|->
name|dtq_chip
expr_stmt|;
while|while
condition|(
name|ptr
operator|!=
name|sc
operator|->
name|dtq_us
condition|)
block|{
name|reg
operator|=
name|EN_READ
argument_list|(
name|sc
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t0x%x=[cnt=%d, chan=%d, end=%d, type=%d @ 0x%x]\n"
argument_list|,
name|sc
operator|->
name|dtq
index|[
name|MID_DTQ_A2REG
argument_list|(
name|ptr
argument_list|)
index|]
argument_list|,
name|MID_DMA_CNT
argument_list|(
name|reg
argument_list|)
argument_list|,
name|MID_DMA_TXCHAN
argument_list|(
name|reg
argument_list|)
argument_list|,
operator|(
name|reg
operator|&
name|MID_DMA_END
operator|)
operator|!=
literal|0
argument_list|,
name|MID_DMA_TYPE
argument_list|(
name|reg
argument_list|)
argument_list|,
name|EN_READ
argument_list|(
name|sc
argument_list|,
name|ptr
operator|+
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|EN_WRAPADD
argument_list|(
name|MID_DTQOFF
argument_list|,
name|MID_DTQEND
argument_list|,
name|ptr
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|level
operator|&
name|END_DRQ
condition|)
block|{
name|printf
argument_list|(
literal|"  drq [need_drqs=%d,drq_free=%d]:\n"
argument_list|,
name|sc
operator|->
name|need_drqs
argument_list|,
name|sc
operator|->
name|drq_free
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|sc
operator|->
name|drq_chip
expr_stmt|;
while|while
condition|(
name|ptr
operator|!=
name|sc
operator|->
name|drq_us
condition|)
block|{
name|reg
operator|=
name|EN_READ
argument_list|(
name|sc
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t0x%x=[cnt=%d, chan=%d, end=%d, type=%d @ 0x%x]\n"
argument_list|,
name|sc
operator|->
name|drq
index|[
name|MID_DRQ_A2REG
argument_list|(
name|ptr
argument_list|)
index|]
argument_list|,
name|MID_DMA_CNT
argument_list|(
name|reg
argument_list|)
argument_list|,
name|MID_DMA_RXVCI
argument_list|(
name|reg
argument_list|)
argument_list|,
operator|(
name|reg
operator|&
name|MID_DMA_END
operator|)
operator|!=
literal|0
argument_list|,
name|MID_DMA_TYPE
argument_list|(
name|reg
argument_list|)
argument_list|,
name|EN_READ
argument_list|(
name|sc
argument_list|,
name|ptr
operator|+
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|EN_WRAPADD
argument_list|(
name|MID_DRQOFF
argument_list|,
name|MID_DRQEND
argument_list|,
name|ptr
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|level
operator|&
name|END_SWSL
condition|)
block|{
name|printf
argument_list|(
literal|" swslist [size=%d]: "
argument_list|,
name|sc
operator|->
name|swsl_size
argument_list|)
expr_stmt|;
for|for
control|(
name|cnt
operator|=
name|sc
operator|->
name|swsl_head
init|;
name|cnt
operator|!=
name|sc
operator|->
name|swsl_tail
condition|;
name|cnt
operator|=
operator|(
name|cnt
operator|+
literal|1
operator|)
operator|%
name|MID_SL_N
control|)
name|printf
argument_list|(
literal|"0x%x "
argument_list|,
name|sc
operator|->
name|swslist
index|[
name|cnt
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * en_dumpmem: dump the memory  */
end_comment

begin_function
name|int
name|en_dumpmem
parameter_list|(
name|unit
parameter_list|,
name|addr
parameter_list|,
name|len
parameter_list|)
name|int
name|unit
decl_stmt|,
name|addr
decl_stmt|,
name|len
decl_stmt|;
block|{
name|struct
name|en_softc
modifier|*
name|sc
decl_stmt|;
name|u_int32_t
name|reg
decl_stmt|;
if|if
condition|(
name|unit
operator|<
literal|0
operator|||
name|unit
operator|>
name|en_cd
operator|.
name|cd_ndevs
operator|||
operator|(
name|sc
operator|=
operator|(
expr|struct
name|en_softc
operator|*
operator|)
name|en_cd
operator|.
name|cd_devs
index|[
name|unit
index|]
operator|)
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"invalid unit number: %d\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|addr
operator|=
name|addr
operator|&
operator|~
literal|3
expr_stmt|;
if|if
condition|(
name|addr
operator|<
name|MID_RAMOFF
operator|||
name|addr
operator|+
name|len
operator|*
literal|4
operator|>
name|MID_MAXOFF
operator|||
name|len
operator|<=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"invalid addr/len number: %d, %d\n"
argument_list|,
name|addr
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|printf
argument_list|(
literal|"dumping %d words starting at offset 0x%x\n"
argument_list|,
name|len
argument_list|,
name|addr
argument_list|)
expr_stmt|;
while|while
condition|(
name|len
operator|--
condition|)
block|{
name|reg
operator|=
name|EN_READ
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"mem[0x%x] = 0x%x\n"
argument_list|,
name|addr
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|4
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|ATM_PVCEXT
end_ifdef

begin_comment
comment|/*  * ATM PVC extention: shaper control and pvc shadow interfaces  */
end_comment

begin_comment
comment|/* txspeed conversion derived from linux drivers/atm/eni.c    by Werner Almesberger, EPFL LRC */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|int
name|pre_div
index|[]
init|=
block|{
literal|4
block|,
literal|16
block|,
literal|128
block|,
literal|2048
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|en_pcr2txspeed
parameter_list|(
name|pcr
parameter_list|)
name|int
name|pcr
decl_stmt|;
block|{
name|int
name|pre
decl_stmt|,
name|res
decl_stmt|,
name|div
decl_stmt|;
if|if
condition|(
name|pcr
operator|==
literal|0
operator|||
name|pcr
operator|>
literal|347222
condition|)
name|pre
operator|=
name|res
operator|=
literal|0
expr_stmt|;
comment|/* max rate */
else|else
block|{
for|for
control|(
name|pre
operator|=
literal|0
init|;
name|pre
operator|<
literal|3
condition|;
name|pre
operator|++
control|)
if|if
condition|(
literal|25000000
operator|/
name|pre_div
index|[
name|pre
index|]
operator|/
literal|64
operator|<=
name|pcr
condition|)
break|break;
name|div
operator|=
name|pre_div
index|[
name|pre
index|]
operator|*
operator|(
name|pcr
operator|)
expr_stmt|;
if|#
directive|if
literal|1
comment|/* 		 * the shaper value should be rounded down, 		 * instead of rounded up. 		 * (which means "res" should be rounded up.) 		 */
name|res
operator|=
operator|(
literal|25000000
operator|+
name|div
operator|-
literal|1
operator|)
operator|/
name|div
operator|-
literal|1
expr_stmt|;
else|#
directive|else
name|res
operator|=
literal|25000000
operator|/
name|div
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|res
operator|<
literal|0
condition|)
name|res
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|res
operator|>
literal|63
condition|)
name|res
operator|=
literal|63
expr_stmt|;
block|}
return|return
operator|(
operator|(
name|pre
operator|<<
literal|6
operator|)
operator|+
name|res
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|en_txspeed2pcr
parameter_list|(
name|txspeed
parameter_list|)
name|int
name|txspeed
decl_stmt|;
block|{
name|int
name|pre
decl_stmt|,
name|res
decl_stmt|,
name|pcr
decl_stmt|;
name|pre
operator|=
operator|(
name|txspeed
operator|>>
literal|6
operator|)
operator|&
literal|0x3
expr_stmt|;
name|res
operator|=
name|txspeed
operator|&
literal|0x3f
expr_stmt|;
name|pcr
operator|=
literal|25000000
operator|/
name|pre_div
index|[
name|pre
index|]
operator|/
operator|(
name|res
operator|+
literal|1
operator|)
expr_stmt|;
return|return
operator|(
name|pcr
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * en_txctl selects a hardware transmit channel and sets the shaper value.  * en_txctl should be called after enabling the vc by en_rxctl  * since it assumes a transmit channel is already assigned by en_rxctl  * to the vc.  */
end_comment

begin_function
specifier|static
name|int
name|en_txctl
parameter_list|(
name|sc
parameter_list|,
name|vci
parameter_list|,
name|joint_vci
parameter_list|,
name|pcr
parameter_list|)
name|struct
name|en_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|vci
decl_stmt|;
name|int
name|joint_vci
decl_stmt|;
name|int
name|pcr
decl_stmt|;
block|{
name|int
name|txspeed
decl_stmt|,
name|txchan
decl_stmt|,
name|c
decl_stmt|,
name|s
decl_stmt|;
if|if
condition|(
name|pcr
condition|)
name|txspeed
operator|=
name|en_pcr2txspeed
argument_list|(
name|pcr
argument_list|)
expr_stmt|;
else|else
name|txspeed
operator|=
literal|0
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|txchan
operator|=
name|sc
operator|->
name|txvc2slot
index|[
name|vci
index|]
expr_stmt|;
name|sc
operator|->
name|txslot
index|[
name|txchan
index|]
operator|.
name|nref
operator|--
expr_stmt|;
comment|/* select a slot */
if|if
condition|(
name|joint_vci
operator|!=
literal|0
condition|)
comment|/* use the same channel */
name|txchan
operator|=
name|sc
operator|->
name|txvc2slot
index|[
name|joint_vci
index|]
expr_stmt|;
if|if
condition|(
name|pcr
operator|==
literal|0
condition|)
name|txchan
operator|=
literal|0
expr_stmt|;
else|else
block|{
for|for
control|(
name|c
operator|=
literal|1
operator|,
name|txchan
operator|=
literal|1
init|;
name|c
operator|<
name|EN_NTX
condition|;
name|c
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|txslot
index|[
name|c
index|]
operator|.
name|nref
operator|<
name|sc
operator|->
name|txslot
index|[
name|txchan
index|]
operator|.
name|nref
condition|)
name|txchan
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|txslot
index|[
name|txchan
index|]
operator|.
name|nref
operator|==
literal|0
condition|)
break|break;
block|}
block|}
name|sc
operator|->
name|txvc2slot
index|[
name|vci
index|]
operator|=
name|txchan
expr_stmt|;
name|sc
operator|->
name|txslot
index|[
name|txchan
index|]
operator|.
name|nref
operator|++
expr_stmt|;
comment|/* set the shaper parameter */
name|sc
operator|->
name|txspeed
index|[
name|vci
index|]
operator|=
operator|(
name|u_int8_t
operator|)
name|txspeed
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EN_DEBUG
name|printf
argument_list|(
literal|"VCI:%d PCR set to %d, tx channel %d\n"
argument_list|,
name|vci
argument_list|,
name|pcr
argument_list|,
name|txchan
argument_list|)
expr_stmt|;
if|if
condition|(
name|joint_vci
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"  slot shared with VCI:%d\n"
argument_list|,
name|joint_vci
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|en_pvctx
parameter_list|(
name|sc
parameter_list|,
name|pvcreq
parameter_list|)
name|struct
name|en_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|pvctxreq
modifier|*
name|pvcreq
decl_stmt|;
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|atm_pseudoioctl
name|api
decl_stmt|;
name|struct
name|atm_pseudohdr
modifier|*
name|pvc_aph
decl_stmt|,
modifier|*
name|pvc_joint
decl_stmt|;
name|int
name|vci
decl_stmt|,
name|joint_vci
decl_stmt|,
name|pcr
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
comment|/* check vpi:vci values */
name|pvc_aph
operator|=
operator|&
name|pvcreq
operator|->
name|pvc_aph
expr_stmt|;
name|pvc_joint
operator|=
operator|&
name|pvcreq
operator|->
name|pvc_joint
expr_stmt|;
name|vci
operator|=
name|ATM_PH_VCI
argument_list|(
name|pvc_aph
argument_list|)
expr_stmt|;
name|joint_vci
operator|=
name|ATM_PH_VCI
argument_list|(
name|pvc_joint
argument_list|)
expr_stmt|;
name|pcr
operator|=
name|pvcreq
operator|->
name|pvc_pcr
expr_stmt|;
if|if
condition|(
name|ATM_PH_VPI
argument_list|(
name|pvc_aph
argument_list|)
operator|!=
literal|0
operator|||
name|vci
operator|>=
name|MID_N_VC
operator|||
name|ATM_PH_VPI
argument_list|(
name|pvc_joint
argument_list|)
operator|!=
literal|0
operator|||
name|joint_vci
operator|>=
name|MID_N_VC
condition|)
return|return
operator|(
name|EADDRNOTAVAIL
operator|)
return|;
if|if
condition|(
operator|(
name|ifp
operator|=
name|ifunit
argument_list|(
name|pvcreq
operator|->
name|pvc_ifname
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|pcr
operator|<
literal|0
condition|)
block|{
comment|/* negative pcr means disable the vc. */
if|if
condition|(
name|sc
operator|->
name|rxvc2slot
index|[
name|vci
index|]
operator|==
name|RX_NONE
condition|)
comment|/* already disabled */
return|return
literal|0
return|;
name|ATM_PH_FLAGS
argument_list|(
operator|&
name|api
operator|.
name|aph
argument_list|)
operator|=
literal|0
expr_stmt|;
name|ATM_PH_VPI
argument_list|(
operator|&
name|api
operator|.
name|aph
argument_list|)
operator|=
literal|0
expr_stmt|;
name|ATM_PH_SETVCI
argument_list|(
operator|&
name|api
operator|.
name|aph
argument_list|,
name|vci
argument_list|)
expr_stmt|;
name|api
operator|.
name|rxhand
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|en_rxctl
argument_list|(
name|sc
argument_list|,
operator|&
name|api
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
operator|&
name|sc
operator|->
name|enif
operator|!=
name|ifp
condition|)
block|{
comment|/* clear vc info of shadow interface */
name|ATM_PH_SETVCI
argument_list|(
operator|&
name|api
operator|.
name|aph
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pvc_setaph
argument_list|(
name|ifp
argument_list|,
operator|&
name|api
operator|.
name|aph
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
operator|&
name|sc
operator|->
name|enif
operator|==
name|ifp
condition|)
block|{
comment|/* called for an en interface */
if|if
condition|(
name|sc
operator|->
name|rxvc2slot
index|[
name|vci
index|]
operator|==
name|RX_NONE
condition|)
block|{
comment|/* vc is not active */
name|printf
argument_list|(
literal|"%s%d: en_pvctx: rx not active! vci=%d\n"
argument_list|,
name|ifp
operator|->
name|if_name
argument_list|,
name|ifp
operator|->
name|if_unit
argument_list|,
name|vci
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
else|else
block|{
comment|/* called for a shadow interface */
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_POINTOPOINT
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"en_pvctx: if %s is not point-to-point!\n"
argument_list|,
name|pvcreq
operator|->
name|pvc_ifname
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|sprintf
argument_list|(
name|pvcreq
operator|->
name|pvc_ifname
argument_list|,
literal|"%s%d"
argument_list|,
name|sc
operator|->
name|enif
operator|.
name|if_name
argument_list|,
name|sc
operator|->
name|enif
operator|.
name|if_unit
argument_list|)
expr_stmt|;
name|ATM_PH_FLAGS
argument_list|(
operator|&
name|api
operator|.
name|aph
argument_list|)
operator|=
name|ATM_PH_PVCSIF
operator||
operator|(
name|ATM_PH_FLAGS
argument_list|(
name|pvc_aph
argument_list|)
operator|&
operator|(
name|ATM_PH_AAL5
operator||
name|ATM_PH_LLCSNAP
operator|)
operator|)
expr_stmt|;
name|ATM_PH_VPI
argument_list|(
operator|&
name|api
operator|.
name|aph
argument_list|)
operator|=
literal|0
expr_stmt|;
name|ATM_PH_SETVCI
argument_list|(
operator|&
name|api
operator|.
name|aph
argument_list|,
name|vci
argument_list|)
expr_stmt|;
name|api
operator|.
name|rxhand
operator|=
name|ifp
expr_stmt|;
name|pvc_setaph
argument_list|(
name|ifp
argument_list|,
operator|&
name|api
operator|.
name|aph
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|rxvc2slot
index|[
name|vci
index|]
operator|==
name|RX_NONE
condition|)
block|{
comment|/* vc is not active, enable rx */
name|error
operator|=
name|en_rxctl
argument_list|(
name|sc
argument_list|,
operator|&
name|api
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
block|}
else|else
block|{
comment|/* vc is already active, update aph in softc */
name|sc
operator|->
name|rxslot
index|[
name|sc
operator|->
name|rxvc2slot
index|[
name|vci
index|]
index|]
operator|.
name|atm_flags
operator|=
name|ATM_PH_FLAGS
argument_list|(
operator|&
name|api
operator|.
name|aph
argument_list|)
expr_stmt|;
block|}
block|}
name|error
operator|=
name|en_txctl
argument_list|(
name|sc
argument_list|,
name|vci
argument_list|,
name|joint_vci
argument_list|,
name|pcr
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|txspeed
index|[
name|vci
index|]
operator|!=
literal|0
condition|)
name|pvcreq
operator|->
name|pvc_pcr
operator|=
name|en_txspeed2pcr
argument_list|(
name|sc
operator|->
name|txspeed
index|[
name|vci
index|]
argument_list|)
expr_stmt|;
else|else
name|pvcreq
operator|->
name|pvc_pcr
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|en_pvctxget
parameter_list|(
name|sc
parameter_list|,
name|pvcreq
parameter_list|)
name|struct
name|en_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|pvctxreq
modifier|*
name|pvcreq
decl_stmt|;
block|{
name|struct
name|atm_pseudohdr
modifier|*
name|pvc_aph
decl_stmt|;
name|int
name|vci
decl_stmt|,
name|slot
decl_stmt|;
name|pvc_aph
operator|=
operator|&
name|pvcreq
operator|->
name|pvc_aph
expr_stmt|;
name|vci
operator|=
name|ATM_PH_VCI
argument_list|(
name|pvc_aph
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|slot
operator|=
name|sc
operator|->
name|rxvc2slot
index|[
name|vci
index|]
operator|)
operator|==
name|RX_NONE
condition|)
block|{
comment|/* vc is not active */
name|ATM_PH_FLAGS
argument_list|(
name|pvc_aph
argument_list|)
operator|=
literal|0
expr_stmt|;
name|pvcreq
operator|->
name|pvc_pcr
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|ATM_PH_FLAGS
argument_list|(
name|pvc_aph
argument_list|)
operator|=
name|sc
operator|->
name|rxslot
index|[
name|slot
index|]
operator|.
name|atm_flags
expr_stmt|;
name|ATM_PH_VPI
argument_list|(
name|pvc_aph
argument_list|)
operator|=
literal|0
expr_stmt|;
name|ATM_PH_SETVCI
argument_list|(
name|pvc_aph
argument_list|,
name|vci
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|txspeed
index|[
name|vci
index|]
condition|)
name|pvcreq
operator|->
name|pvc_pcr
operator|=
name|en_txspeed2pcr
argument_list|(
name|sc
operator|->
name|txspeed
index|[
name|vci
index|]
argument_list|)
expr_stmt|;
else|else
name|pvcreq
operator|->
name|pvc_pcr
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ATM_PVCEXT */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NEN> 0 || !defined(__FreeBSD__) */
end_comment

end_unit

