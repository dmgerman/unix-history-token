begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: midway.c,v 1.30 1997/09/29 17:40:38 chuck Exp $	*/
end_comment

begin_comment
comment|/*	(sync'd to midway.c 1.68)	*/
end_comment

begin_comment
comment|/*-  * Copyright (c) 1996 Charles D. Cranor and Washington University.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *      This product includes software developed by Charles D. Cranor and  *	Washington University.  * 4. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  *  * m i d w a y . c   e n i 1 5 5   d r i v e r   *  * author: Chuck Cranor<chuck@ccrc.wustl.edu>  * started: spring, 1996 (written from scratch).  *  * notes from the author:  *   Extra special thanks go to Werner Almesberger, EPFL LRC.   Werner's  *   ENI driver was especially useful in figuring out how this card works.  *   I would also like to thank Werner for promptly answering email and being  *   generally helpful.  */
end_comment

begin_define
define|#
directive|define
name|EN_DIAG
end_define

begin_define
define|#
directive|define
name|EN_DDBHOOK
value|1
end_define

begin_comment
comment|/* compile in ddb functions */
end_comment

begin_comment
comment|/*  * Note on EN_ENIDMAFIX: the byte aligner on the ENI version of the card  * appears to be broken.   it works just fine if there is no load... however  * when the card is loaded the data get corrupted.   to see this, one only  * has to use "telnet" over ATM.   do the following command in "telnet":  * 	cat /usr/share/misc/termcap  * "telnet" seems to generate lots of 1023 byte mbufs (which make great  * use of the byte aligner).   watch "netstat -s" for checksum errors.  *   * I further tested this by adding a function that compared the transmit   * data on the card's SRAM with the data in the mbuf chain _after_ the   * "transmit DMA complete" interrupt.   using the "telnet" test I got data  * mismatches where the byte-aligned data should have been.   using ddb  * and en_dumpmem() I verified that the DTQs fed into the card were   * absolutely correct.   thus, we are forced to concluded that the ENI  * hardware is buggy.   note that the Adaptec version of the card works  * just fine with byte DMA.  *  * bottom line: we set EN_ENIDMAFIX to 1 to avoid byte DMAs on the ENI  * card.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DIAGNOSTIC
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|EN_DIAG
argument_list|)
end_if

begin_define
define|#
directive|define
name|EN_DIAG
end_define

begin_comment
comment|/* link in with master DIAG option */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|EN_COUNT
parameter_list|(
name|X
parameter_list|)
value|(X)++
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|EN_DEBUG
end_ifdef

begin_undef
undef|#
directive|undef
name|EN_DDBHOOK
end_undef

begin_define
define|#
directive|define
name|EN_DDBHOOK
value|1
end_define

begin_comment
comment|/*  * This macro removes almost all the EN_DEBUG conditionals in the code that make  * to code a good deal less readable.  */
end_comment

begin_define
define|#
directive|define
name|DBG
parameter_list|(
name|SC
parameter_list|,
name|FL
parameter_list|,
name|PRINT
parameter_list|)
value|do {						\ 	if ((SC)->debug& DBG_##FL) {					\ 		device_printf((SC)->dev, "%s: "#FL": ", __func__);	\ 		printf PRINT;						\ 		printf("\n");						\ 	}								\     } while (0)
end_define

begin_enum
enum|enum
block|{
name|DBG_INIT
init|=
literal|0x0001
block|,
comment|/* debug attach/detach */
name|DBG_TX
init|=
literal|0x0002
block|,
comment|/* debug transmitting */
name|DBG_SERV
init|=
literal|0x0004
block|,
comment|/* debug service interrupts */
name|DBG_IOCTL
init|=
literal|0x0008
block|,
comment|/* debug ioctls */
name|DBG_VC
init|=
literal|0x0010
block|,
comment|/* debug VC handling */
name|DBG_INTR
init|=
literal|0x0020
block|,
comment|/* debug interrupts */
name|DBG_DMA
init|=
literal|0x0040
block|,
comment|/* debug DMA probing */
name|DBG_IPACKETS
init|=
literal|0x0080
block|,
comment|/* print input packets */
name|DBG_REG
init|=
literal|0x0100
block|,
comment|/* print all register access */
name|DBG_LOCK
init|=
literal|0x0200
block|,
comment|/* debug locking */
block|}
enum|;
end_enum

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* EN_DEBUG */
end_comment

begin_define
define|#
directive|define
name|DBG
parameter_list|(
name|SC
parameter_list|,
name|FL
parameter_list|,
name|PRINT
parameter_list|)
value|do { } while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* EN_DEBUG */
end_comment

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_natm.h"
end_include

begin_include
include|#
directive|include
file|"opt_ddb.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DDB
end_ifdef

begin_undef
undef|#
directive|undef
name|EN_DDBHOOK
end_undef

begin_define
define|#
directive|define
name|EN_DDBHOOK
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/stdint.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/condvar.h>
end_include

begin_include
include|#
directive|include
file|<vm/uma.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/if_atm.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NATM
argument_list|)
operator|||
name|defined
argument_list|(
name|INET
argument_list|)
operator|||
name|defined
argument_list|(
name|INET6
argument_list|)
end_if

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|||
name|defined
argument_list|(
name|INET6
argument_list|)
end_if

begin_include
include|#
directive|include
file|<netinet/if_atm.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|NATM
end_ifdef

begin_include
include|#
directive|include
file|<netnatm/natm.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<dev/utopia/utopia.h>
end_include

begin_include
include|#
directive|include
file|<dev/en/midwayreg.h>
end_include

begin_include
include|#
directive|include
file|<dev/en/midwayvar.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_comment
comment|/*  * params  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|EN_TXHIWAT
end_ifndef

begin_define
define|#
directive|define
name|EN_TXHIWAT
value|(64 * 1024)
end_define

begin_comment
comment|/* max 64 KB waiting to be DMAd out */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_hw_atm
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * dma tables  *  * The plan is indexed by the number of words to transfer.  * The maximum index is 15 for 60 words.  */
end_comment

begin_struct
struct|struct
name|en_dmatab
block|{
name|uint8_t
name|bcode
decl_stmt|;
comment|/* code */
name|uint8_t
name|divshift
decl_stmt|;
comment|/* byte divisor */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|en_dmatab
name|en_dmaplan
index|[]
init|=
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/* 0 */
block|{
name|MIDDMA_WORD
block|,
literal|2
block|}
block|,
comment|/* 1 */
block|{
name|MIDDMA_2WORD
block|,
literal|3
block|}
block|,
comment|/* 2 */
block|{
name|MIDDMA_WORD
block|,
literal|2
block|}
block|,
comment|/* 3 */
block|{
name|MIDDMA_4WORD
block|,
literal|4
block|}
block|,
comment|/* 4 */
block|{
name|MIDDMA_WORD
block|,
literal|2
block|}
block|,
comment|/* 5 */
block|{
name|MIDDMA_2WORD
block|,
literal|3
block|}
block|,
comment|/* 6 */
block|{
name|MIDDMA_WORD
block|,
literal|2
block|}
block|,
comment|/* 7 */
block|{
name|MIDDMA_8WORD
block|,
literal|5
block|}
block|,
comment|/* 8 */
block|{
name|MIDDMA_WORD
block|,
literal|2
block|}
block|,
comment|/* 9 */
block|{
name|MIDDMA_2WORD
block|,
literal|3
block|}
block|,
comment|/* 10 */
block|{
name|MIDDMA_WORD
block|,
literal|2
block|}
block|,
comment|/* 11 */
block|{
name|MIDDMA_4WORD
block|,
literal|4
block|}
block|,
comment|/* 12 */
block|{
name|MIDDMA_WORD
block|,
literal|2
block|}
block|,
comment|/* 13 */
block|{
name|MIDDMA_2WORD
block|,
literal|3
block|}
block|,
comment|/* 14 */
block|{
name|MIDDMA_WORD
block|,
literal|2
block|}
block|,
comment|/* 15 */
block|{
name|MIDDMA_16WORD
block|,
literal|6
block|}
block|,
comment|/* 16 */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * prototypes  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|EN_DDBHOOK
end_ifdef

begin_function_decl
name|int
name|en_dump
parameter_list|(
name|int
name|unit
parameter_list|,
name|int
name|level
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|en_dumpmem
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|en_close_finish
parameter_list|(
name|struct
name|en_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|en_vcc
modifier|*
name|vc
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|EN_LOCK
parameter_list|(
name|SC
parameter_list|)
value|do {				\ 	DBG(SC, LOCK, ("ENLOCK %d\n", __LINE__));	\ 	mtx_lock(&sc->en_mtx);				\     } while (0)
end_define

begin_define
define|#
directive|define
name|EN_UNLOCK
parameter_list|(
name|SC
parameter_list|)
value|do {				\ 	DBG(SC, LOCK, ("ENUNLOCK %d\n", __LINE__));	\ 	mtx_unlock(&sc->en_mtx);			\     } while (0)
end_define

begin_define
define|#
directive|define
name|EN_CHECKLOCK
parameter_list|(
name|sc
parameter_list|)
value|mtx_assert(&sc->en_mtx, MA_OWNED)
end_define

begin_comment
comment|/*  * While a transmit mbuf is waiting to get transmit DMA resources we  * need to keep some information with it. We don't want to allocate  * additional memory for this so we stuff it into free fields in the  * mbuf packet header. Neither the checksum fields nor the rcvif field are used  * so use these.  */
end_comment

begin_define
define|#
directive|define
name|TX_AAL5
value|0x1
end_define

begin_comment
comment|/* transmit AAL5 PDU */
end_comment

begin_define
define|#
directive|define
name|TX_HAS_TBD
value|0x2
end_define

begin_comment
comment|/* TBD did fit into mbuf */
end_comment

begin_define
define|#
directive|define
name|TX_HAS_PAD
value|0x4
end_define

begin_comment
comment|/* padding did fit into mbuf */
end_comment

begin_define
define|#
directive|define
name|TX_HAS_PDU
value|0x8
end_define

begin_comment
comment|/* PDU trailer did fit into mbuf */
end_comment

begin_define
define|#
directive|define
name|MBUF_SET_TX
parameter_list|(
name|M
parameter_list|,
name|VCI
parameter_list|,
name|FLAGS
parameter_list|,
name|DATALEN
parameter_list|,
name|PAD
parameter_list|,
name|MAP
parameter_list|)
value|do {		\ 	(M)->m_pkthdr.csum_data = (VCI) | ((FLAGS)<< MID_VCI_BITS);	\ 	(M)->m_pkthdr.csum_flags = ((DATALEN)& 0xffff) |		\ 	    ((PAD& 0x3f)<< 16);					\ 	(M)->m_pkthdr.rcvif = (void *)(MAP);				\     } while (0)
end_define

begin_define
define|#
directive|define
name|MBUF_GET_TX
parameter_list|(
name|M
parameter_list|,
name|VCI
parameter_list|,
name|FLAGS
parameter_list|,
name|DATALEN
parameter_list|,
name|PAD
parameter_list|,
name|MAP
parameter_list|)
value|do {		\ 	(VCI) = (M)->m_pkthdr.csum_data& ((1<< MID_VCI_BITS) - 1);	\ 	(FLAGS) = ((M)->m_pkthdr.csum_data>> MID_VCI_BITS)& 0xf;	\ 	(DATALEN) = (M)->m_pkthdr.csum_flags& 0xffff;			\ 	(PAD) = ((M)->m_pkthdr.csum_flags>> 16)& 0x3f;		\ 	(MAP) = (void *)((M)->m_pkthdr.rcvif);				\     } while (0)
end_define

begin_define
define|#
directive|define
name|EN_WRAPADD
parameter_list|(
name|START
parameter_list|,
name|STOP
parameter_list|,
name|CUR
parameter_list|,
name|VAL
parameter_list|)
value|do {			\ 	(CUR) = (CUR) + (VAL);					\ 	if ((CUR)>= (STOP))					\ 		(CUR) = (START) + ((CUR) - (STOP));		\     } while (0)
end_define

begin_define
define|#
directive|define
name|WORD_IDX
parameter_list|(
name|START
parameter_list|,
name|X
parameter_list|)
value|(((X) - (START)) / sizeof(uint32_t))
end_define

begin_define
define|#
directive|define
name|SETQ_END
parameter_list|(
name|SC
parameter_list|,
name|VAL
parameter_list|)
value|((SC)->is_adaptec ?			\ 	((VAL) | (MID_DMA_END>> 4)) :				\ 	((VAL) | (MID_DMA_END)))
end_define

begin_comment
comment|/*  * The dtq and drq members are set for each END entry in the corresponding  * card queue entry. It is used to find out, when a buffer has been  * finished DMAing and can be freed.  *  * We store sc->dtq and sc->drq data in the following format...  * the 0x80000 ensures we != 0  */
end_comment

begin_define
define|#
directive|define
name|EN_DQ_MK
parameter_list|(
name|SLOT
parameter_list|,
name|LEN
parameter_list|)
value|(((SLOT)<< 20) | (LEN) | (0x80000))
end_define

begin_define
define|#
directive|define
name|EN_DQ_SLOT
parameter_list|(
name|X
parameter_list|)
value|((X)>> 20)
end_define

begin_define
define|#
directive|define
name|EN_DQ_LEN
parameter_list|(
name|X
parameter_list|)
value|((X)& 0x3ffff)
end_define

begin_comment
comment|/*  * Variables  */
end_comment

begin_decl_stmt
specifier|static
name|uma_zone_t
name|en_vcc_zone
decl_stmt|;
end_decl_stmt

begin_comment
comment|/***********************************************************************/
end_comment

begin_comment
comment|/*  * en_read{x}: read a word from the card. These are the only functions  * that read from the card.  */
end_comment

begin_function
specifier|static
name|__inline
name|uint32_t
name|en_readx
parameter_list|(
name|struct
name|en_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|r
parameter_list|)
block|{
name|uint32_t
name|v
decl_stmt|;
ifdef|#
directive|ifdef
name|EN_DIAG
if|if
condition|(
name|r
operator|>
name|MID_MAXOFF
operator|||
operator|(
name|r
operator|%
literal|4
operator|)
condition|)
name|panic
argument_list|(
literal|"en_read out of range, r=0x%x"
argument_list|,
name|r
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|v
operator|=
name|bus_space_read_4
argument_list|(
name|sc
operator|->
name|en_memt
argument_list|,
name|sc
operator|->
name|en_base
argument_list|,
name|r
argument_list|)
expr_stmt|;
return|return
operator|(
name|v
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|uint32_t
name|en_read
parameter_list|(
name|struct
name|en_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|r
parameter_list|)
block|{
name|uint32_t
name|v
decl_stmt|;
ifdef|#
directive|ifdef
name|EN_DIAG
if|if
condition|(
name|r
operator|>
name|MID_MAXOFF
operator|||
operator|(
name|r
operator|%
literal|4
operator|)
condition|)
name|panic
argument_list|(
literal|"en_read out of range, r=0x%x"
argument_list|,
name|r
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|v
operator|=
name|bus_space_read_4
argument_list|(
name|sc
operator|->
name|en_memt
argument_list|,
name|sc
operator|->
name|en_base
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|DBG
argument_list|(
name|sc
argument_list|,
name|REG
argument_list|,
operator|(
literal|"en_read(%#x) -> %08x"
operator|,
name|r
operator|,
name|v
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|v
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * en_write: write a word to the card. This is the only function that  * writes to the card.  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|en_write
parameter_list|(
name|struct
name|en_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|r
parameter_list|,
name|uint32_t
name|v
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|EN_DIAG
if|if
condition|(
name|r
operator|>
name|MID_MAXOFF
operator|||
operator|(
name|r
operator|%
literal|4
operator|)
condition|)
name|panic
argument_list|(
literal|"en_write out of range, r=0x%x"
argument_list|,
name|r
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|DBG
argument_list|(
name|sc
argument_list|,
name|REG
argument_list|,
operator|(
literal|"en_write(%#x)<- %08x"
operator|,
name|r
operator|,
name|v
operator|)
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|sc
operator|->
name|en_memt
argument_list|,
name|sc
operator|->
name|en_base
argument_list|,
name|r
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * en_k2sz: convert KBytes to a size parameter (a log2)  */
end_comment

begin_function
specifier|static
name|__inline
name|int
name|en_k2sz
parameter_list|(
name|int
name|k
parameter_list|)
block|{
switch|switch
condition|(
name|k
condition|)
block|{
case|case
literal|1
case|:
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|2
case|:
return|return
operator|(
literal|1
operator|)
return|;
case|case
literal|4
case|:
return|return
operator|(
literal|2
operator|)
return|;
case|case
literal|8
case|:
return|return
operator|(
literal|3
operator|)
return|;
case|case
literal|16
case|:
return|return
operator|(
literal|4
operator|)
return|;
case|case
literal|32
case|:
return|return
operator|(
literal|5
operator|)
return|;
case|case
literal|64
case|:
return|return
operator|(
literal|6
operator|)
return|;
case|case
literal|128
case|:
return|return
operator|(
literal|7
operator|)
return|;
default|default:
name|panic
argument_list|(
literal|"en_k2sz"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|en_log2
parameter_list|(
name|X
parameter_list|)
value|en_k2sz(X)
end_define

begin_comment
comment|/*  * en_b2sz: convert a DMA burst code to its byte size  */
end_comment

begin_function
specifier|static
name|__inline
name|int
name|en_b2sz
parameter_list|(
name|int
name|b
parameter_list|)
block|{
switch|switch
condition|(
name|b
condition|)
block|{
case|case
name|MIDDMA_WORD
case|:
return|return
operator|(
literal|1
operator|*
literal|4
operator|)
return|;
case|case
name|MIDDMA_2WMAYBE
case|:
case|case
name|MIDDMA_2WORD
case|:
return|return
operator|(
literal|2
operator|*
literal|4
operator|)
return|;
case|case
name|MIDDMA_4WMAYBE
case|:
case|case
name|MIDDMA_4WORD
case|:
return|return
operator|(
literal|4
operator|*
literal|4
operator|)
return|;
case|case
name|MIDDMA_8WMAYBE
case|:
case|case
name|MIDDMA_8WORD
case|:
return|return
operator|(
literal|8
operator|*
literal|4
operator|)
return|;
case|case
name|MIDDMA_16WMAYBE
case|:
case|case
name|MIDDMA_16WORD
case|:
return|return
operator|(
literal|16
operator|*
literal|4
operator|)
return|;
default|default:
name|panic
argument_list|(
literal|"en_b2sz"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * en_sz2b: convert a burst size (bytes) to DMA burst code  */
end_comment

begin_function
specifier|static
name|__inline
name|int
name|en_sz2b
parameter_list|(
name|int
name|sz
parameter_list|)
block|{
switch|switch
condition|(
name|sz
condition|)
block|{
case|case
literal|1
operator|*
literal|4
case|:
return|return
operator|(
name|MIDDMA_WORD
operator|)
return|;
case|case
literal|2
operator|*
literal|4
case|:
return|return
operator|(
name|MIDDMA_2WORD
operator|)
return|;
case|case
literal|4
operator|*
literal|4
case|:
return|return
operator|(
name|MIDDMA_4WORD
operator|)
return|;
case|case
literal|8
operator|*
literal|4
case|:
return|return
operator|(
name|MIDDMA_8WORD
operator|)
return|;
case|case
literal|16
operator|*
literal|4
case|:
return|return
operator|(
name|MIDDMA_16WORD
operator|)
return|;
default|default:
name|panic
argument_list|(
literal|"en_sz2b"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|EN_DEBUG
end_ifdef

begin_comment
comment|/*  * Dump a packet  */
end_comment

begin_function
specifier|static
name|void
name|en_dump_packet
parameter_list|(
name|struct
name|en_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|int
name|plen
init|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
decl_stmt|;
name|u_int
name|pos
init|=
literal|0
decl_stmt|;
name|u_int
name|totlen
init|=
literal|0
decl_stmt|;
name|int
name|len
decl_stmt|;
name|u_char
modifier|*
name|ptr
decl_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"packet len=%d"
argument_list|,
name|plen
argument_list|)
expr_stmt|;
while|while
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
name|totlen
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
name|ptr
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|u_char
operator|*
argument_list|)
expr_stmt|;
for|for
control|(
name|len
operator|=
literal|0
init|;
name|len
operator|<
name|m
operator|->
name|m_len
condition|;
name|len
operator|++
operator|,
name|pos
operator|++
operator|,
name|ptr
operator|++
control|)
block|{
if|if
condition|(
name|pos
operator|%
literal|16
operator|==
literal|8
condition|)
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|%
literal|16
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %02x"
argument_list|,
operator|*
name|ptr
argument_list|)
expr_stmt|;
block|}
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|totlen
operator|!=
name|plen
condition|)
name|printf
argument_list|(
literal|"sum of m_len=%u\n"
argument_list|,
name|totlen
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*********************************************************************/
end_comment

begin_comment
comment|/*  * DMA maps  */
end_comment

begin_comment
comment|/*  * Map constructor for a MAP.  *  * This is called each time when a map is allocated  * from the pool and about to be returned to the user. Here we actually  * allocate the map if there isn't one. The problem is that we may fail  * to allocate the DMA map yet have no means to signal this error. Therefor  * when allocating a map, the call must check that there is a map. An  * additional problem is, that i386 maps will be NULL, yet are ok and must  * be freed so let's use a flag to signal allocation.  *  * Caveat: we have no way to know that we are called from an interrupt context  * here. We rely on the fact, that bus_dmamap_create uses M_NOWAIT in all  * its allocations.  *  * LOCK: any, not needed  */
end_comment

begin_function
specifier|static
name|int
name|en_map_ctor
parameter_list|(
name|void
modifier|*
name|mem
parameter_list|,
name|int
name|size
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|en_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|en_map
modifier|*
name|map
init|=
name|mem
decl_stmt|;
name|int
name|err
decl_stmt|;
name|err
operator|=
name|bus_dmamap_create
argument_list|(
name|sc
operator|->
name|txtag
argument_list|,
literal|0
argument_list|,
operator|&
name|map
operator|->
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"cannot create DMA map %d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
name|map
operator|->
name|flags
operator|=
name|ENMAP_ALLOC
expr_stmt|;
name|map
operator|->
name|sc
operator|=
name|sc
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Map destructor.  *  * Called when a map is disposed into the zone. If the map is loaded, unload  * it.  *  * LOCK: any, not needed  */
end_comment

begin_function
specifier|static
name|void
name|en_map_dtor
parameter_list|(
name|void
modifier|*
name|mem
parameter_list|,
name|int
name|size
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|en_map
modifier|*
name|map
init|=
name|mem
decl_stmt|;
if|if
condition|(
name|map
operator|->
name|flags
operator|&
name|ENMAP_LOADED
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|map
operator|->
name|sc
operator|->
name|txtag
argument_list|,
name|map
operator|->
name|map
argument_list|)
expr_stmt|;
name|map
operator|->
name|flags
operator|&=
operator|~
name|ENMAP_LOADED
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Map finializer.  *  * This is called each time a map is returned from the zone to the system.  * Get rid of the dmamap here.  *  * LOCK: any, not needed  */
end_comment

begin_function
specifier|static
name|void
name|en_map_fini
parameter_list|(
name|void
modifier|*
name|mem
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|struct
name|en_map
modifier|*
name|map
init|=
name|mem
decl_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|map
operator|->
name|sc
operator|->
name|txtag
argument_list|,
name|map
operator|->
name|map
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*********************************************************************/
end_comment

begin_comment
comment|/*  * Transmission  */
end_comment

begin_comment
comment|/*  * Argument structure to load a transmit DMA map  */
end_comment

begin_struct
struct|struct
name|txarg
block|{
name|struct
name|en_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|u_int
name|vci
decl_stmt|;
name|u_int
name|chan
decl_stmt|;
comment|/* transmit channel */
name|u_int
name|datalen
decl_stmt|;
comment|/* length of user data */
name|u_int
name|flags
decl_stmt|;
name|u_int
name|wait
decl_stmt|;
comment|/* return: out of resources */
block|}
struct|;
end_struct

begin_comment
comment|/*  * TX DMA map loader helper. This function is the callback when the map  * is loaded. It should fill the DMA segment descriptors into the hardware.  *  * LOCK: locked, needed  */
end_comment

begin_function
specifier|static
name|void
name|en_txdma_load
parameter_list|(
name|void
modifier|*
name|uarg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|bus_size_t
name|mapsize
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|txarg
modifier|*
name|tx
init|=
name|uarg
decl_stmt|;
name|struct
name|en_softc
modifier|*
name|sc
init|=
name|tx
operator|->
name|sc
decl_stmt|;
name|struct
name|en_txslot
modifier|*
name|slot
init|=
operator|&
name|sc
operator|->
name|txslot
index|[
name|tx
operator|->
name|chan
index|]
decl_stmt|;
name|uint32_t
name|cur
decl_stmt|;
comment|/* on-card buffer position (bytes offset) */
name|uint32_t
name|dtq
decl_stmt|;
comment|/* on-card queue position (byte offset) */
name|uint32_t
name|last_dtq
decl_stmt|;
comment|/* last DTQ we have written */
name|uint32_t
name|tmp
decl_stmt|;
name|u_int
name|free
decl_stmt|;
comment|/* free queue entries on card */
name|u_int
name|needalign
decl_stmt|,
name|cnt
decl_stmt|;
name|bus_size_t
name|rest
decl_stmt|;
comment|/* remaining bytes in current segment */
name|bus_addr_t
name|addr
decl_stmt|;
name|bus_dma_segment_t
modifier|*
name|s
decl_stmt|;
name|uint32_t
name|count
decl_stmt|,
name|bcode
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return;
name|cur
operator|=
name|slot
operator|->
name|cur
expr_stmt|;
name|dtq
operator|=
name|sc
operator|->
name|dtq_us
expr_stmt|;
name|free
operator|=
name|sc
operator|->
name|dtq_free
expr_stmt|;
name|last_dtq
operator|=
literal|0
expr_stmt|;
comment|/* make gcc happy */
comment|/* 	 * Local macro to add an entry to the transmit DMA area. If there 	 * are no entries left, return. Save the byte offset of the entry 	 * in last_dtq for later use. 	 */
define|#
directive|define
name|PUT_DTQ_ENTRY
parameter_list|(
name|ENI
parameter_list|,
name|BCODE
parameter_list|,
name|COUNT
parameter_list|,
name|ADDR
parameter_list|)
define|\
value|if (free == 0) {						\ 		EN_COUNT(sc->stats.txdtqout);				\ 		tx->wait = 1;						\ 		return;							\ 	}								\ 	last_dtq = dtq;							\ 	en_write(sc, dtq + 0, (ENI || !sc->is_adaptec) ?		\ 	    MID_MK_TXQ_ENI(COUNT, tx->chan, 0, BCODE) :			\ 	    MID_MK_TXQ_ADP(COUNT, tx->chan, 0, BCODE));			\ 	en_write(sc, dtq + 4, ADDR);					\ 									\ 	EN_WRAPADD(MID_DTQOFF, MID_DTQEND, dtq, 8);			\ 	free--;
comment|/* 	 * Local macro to generate a DMA entry to DMA cnt bytes. Updates 	 * the current buffer byte offset accordingly. 	 */
define|#
directive|define
name|DO_DTQ
parameter_list|(
name|TYPE
parameter_list|)
value|do {						\ 	rest -= cnt;							\ 	EN_WRAPADD(slot->start, slot->stop, cur, cnt);			\ 	DBG(sc, TX, ("tx%d: "TYPE" %u bytes, %ju left, cur %#x",	\ 	    tx->chan, cnt, (uintmax_t)rest, cur));			\ 									\ 	PUT_DTQ_ENTRY(1, bcode, count, addr);				\ 									\ 	addr += cnt;							\     } while (0)
if|if
condition|(
operator|!
operator|(
name|tx
operator|->
name|flags
operator|&
name|TX_HAS_TBD
operator|)
condition|)
block|{
comment|/* 		 * Prepend the TBD - it did not fit into the first mbuf 		 */
name|tmp
operator|=
name|MID_TBD_MK1
argument_list|(
operator|(
name|tx
operator|->
name|flags
operator|&
name|TX_AAL5
operator|)
condition|?
name|MID_TBD_AAL5
else|:
name|MID_TBD_NOAAL5
argument_list|,
name|sc
operator|->
name|vccs
index|[
name|tx
operator|->
name|vci
index|]
operator|->
name|txspeed
argument_list|,
name|tx
operator|->
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|/
name|MID_ATMDATASZ
argument_list|)
expr_stmt|;
name|en_write
argument_list|(
name|sc
argument_list|,
name|cur
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|EN_WRAPADD
argument_list|(
name|slot
operator|->
name|start
argument_list|,
name|slot
operator|->
name|stop
argument_list|,
name|cur
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|MID_TBD_MK2
argument_list|(
name|tx
operator|->
name|vci
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|en_write
argument_list|(
name|sc
argument_list|,
name|cur
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|EN_WRAPADD
argument_list|(
name|slot
operator|->
name|start
argument_list|,
name|slot
operator|->
name|stop
argument_list|,
name|cur
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* update DMA address */
name|PUT_DTQ_ENTRY
argument_list|(
literal|0
argument_list|,
name|MIDDMA_JK
argument_list|,
name|WORD_IDX
argument_list|(
name|slot
operator|->
name|start
argument_list|,
name|cur
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|s
operator|=
name|segs
init|;
name|i
operator|<
name|nseg
condition|;
name|i
operator|++
operator|,
name|s
operator|++
control|)
block|{
name|rest
operator|=
name|s
operator|->
name|ds_len
expr_stmt|;
name|addr
operator|=
name|s
operator|->
name|ds_addr
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|is_adaptec
condition|)
block|{
comment|/* adaptec card - simple */
comment|/* advance the on-card buffer pointer */
name|EN_WRAPADD
argument_list|(
name|slot
operator|->
name|start
argument_list|,
name|slot
operator|->
name|stop
argument_list|,
name|cur
argument_list|,
name|rest
argument_list|)
expr_stmt|;
name|DBG
argument_list|(
name|sc
argument_list|,
name|TX
argument_list|,
operator|(
literal|"tx%d: adp %ju bytes %#jx (cur now 0x%x)"
operator|,
name|tx
operator|->
name|chan
operator|,
operator|(
name|uintmax_t
operator|)
name|rest
operator|,
operator|(
name|uintmax_t
operator|)
name|addr
operator|,
name|cur
operator|)
argument_list|)
expr_stmt|;
name|PUT_DTQ_ENTRY
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|rest
argument_list|,
name|addr
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * do we need to do a DMA op to align to the maximum 		 * burst? Note, that we are alway 32-bit aligned. 		 */
if|if
condition|(
name|sc
operator|->
name|alburst
operator|&&
operator|(
name|needalign
operator|=
operator|(
name|addr
operator|&
name|sc
operator|->
name|bestburstmask
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* compute number of bytes, words and code */
name|cnt
operator|=
name|sc
operator|->
name|bestburstlen
operator|-
name|needalign
expr_stmt|;
if|if
condition|(
name|cnt
operator|>
name|rest
condition|)
name|cnt
operator|=
name|rest
expr_stmt|;
name|count
operator|=
name|cnt
operator|/
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|noalbursts
condition|)
block|{
name|bcode
operator|=
name|MIDDMA_WORD
expr_stmt|;
block|}
else|else
block|{
name|bcode
operator|=
name|en_dmaplan
index|[
name|count
index|]
operator|.
name|bcode
expr_stmt|;
name|count
operator|=
name|cnt
operator|>>
name|en_dmaplan
index|[
name|count
index|]
operator|.
name|divshift
expr_stmt|;
block|}
name|DO_DTQ
argument_list|(
literal|"al_dma"
argument_list|)
expr_stmt|;
block|}
comment|/* do we need to do a max-sized burst? */
if|if
condition|(
name|rest
operator|>=
name|sc
operator|->
name|bestburstlen
condition|)
block|{
name|count
operator|=
name|rest
operator|>>
name|sc
operator|->
name|bestburstshift
expr_stmt|;
name|cnt
operator|=
name|count
operator|<<
name|sc
operator|->
name|bestburstshift
expr_stmt|;
name|bcode
operator|=
name|sc
operator|->
name|bestburstcode
expr_stmt|;
name|DO_DTQ
argument_list|(
literal|"best_dma"
argument_list|)
expr_stmt|;
block|}
comment|/* do we need to do a cleanup burst? */
if|if
condition|(
name|rest
operator|!=
literal|0
condition|)
block|{
name|cnt
operator|=
name|rest
expr_stmt|;
name|count
operator|=
name|rest
operator|/
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|noalbursts
condition|)
block|{
name|bcode
operator|=
name|MIDDMA_WORD
expr_stmt|;
block|}
else|else
block|{
name|bcode
operator|=
name|en_dmaplan
index|[
name|count
index|]
operator|.
name|bcode
expr_stmt|;
name|count
operator|=
name|cnt
operator|>>
name|en_dmaplan
index|[
name|count
index|]
operator|.
name|divshift
expr_stmt|;
block|}
name|DO_DTQ
argument_list|(
literal|"clean_dma"
argument_list|)
expr_stmt|;
block|}
block|}
name|KASSERT
argument_list|(
name|tx
operator|->
name|flags
operator|&
name|TX_HAS_PAD
argument_list|,
operator|(
literal|"PDU not padded"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tx
operator|->
name|flags
operator|&
name|TX_AAL5
operator|)
operator|&&
operator|!
operator|(
name|tx
operator|->
name|flags
operator|&
name|TX_HAS_PDU
operator|)
condition|)
block|{
comment|/* 		 * Append the AAL5 PDU trailer 		 */
name|tmp
operator|=
name|MID_PDU_MK1
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|tx
operator|->
name|datalen
argument_list|)
expr_stmt|;
name|en_write
argument_list|(
name|sc
argument_list|,
name|cur
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|EN_WRAPADD
argument_list|(
name|slot
operator|->
name|start
argument_list|,
name|slot
operator|->
name|stop
argument_list|,
name|cur
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|en_write
argument_list|(
name|sc
argument_list|,
name|cur
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|EN_WRAPADD
argument_list|(
name|slot
operator|->
name|start
argument_list|,
name|slot
operator|->
name|stop
argument_list|,
name|cur
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* update DMA address */
name|PUT_DTQ_ENTRY
argument_list|(
literal|0
argument_list|,
name|MIDDMA_JK
argument_list|,
name|WORD_IDX
argument_list|(
name|slot
operator|->
name|start
argument_list|,
name|cur
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* record the end for the interrupt routine */
name|sc
operator|->
name|dtq
index|[
name|MID_DTQ_A2REG
argument_list|(
name|last_dtq
argument_list|)
index|]
operator|=
name|EN_DQ_MK
argument_list|(
name|tx
operator|->
name|chan
argument_list|,
name|tx
operator|->
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
comment|/* set the end flag in the last descriptor */
name|en_write
argument_list|(
name|sc
argument_list|,
name|last_dtq
operator|+
literal|0
argument_list|,
name|SETQ_END
argument_list|(
name|sc
argument_list|,
name|en_read
argument_list|(
name|sc
argument_list|,
name|last_dtq
operator|+
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|PUT_DTQ_ENTRY
undef|#
directive|undef
name|DO_DTQ
comment|/* commit */
name|slot
operator|->
name|cur
operator|=
name|cur
expr_stmt|;
name|sc
operator|->
name|dtq_free
operator|=
name|free
expr_stmt|;
name|sc
operator|->
name|dtq_us
operator|=
name|dtq
expr_stmt|;
comment|/* tell card */
name|en_write
argument_list|(
name|sc
argument_list|,
name|MID_DMA_WRTX
argument_list|,
name|MID_DTQ_A2REG
argument_list|(
name|sc
operator|->
name|dtq_us
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * en_txdma: start transmit DMA on the given channel, if possible  *  * This is called from two places: when we got new packets from the upper  * layer or when we found that buffer space has freed up during interrupt  * processing.  *  * LOCK: locked, needed  */
end_comment

begin_function
specifier|static
name|void
name|en_txdma
parameter_list|(
name|struct
name|en_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|en_txslot
modifier|*
name|slot
parameter_list|)
block|{
name|struct
name|en_map
modifier|*
name|map
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|lastm
decl_stmt|;
name|struct
name|txarg
name|tx
decl_stmt|;
name|u_int
name|pad
decl_stmt|;
name|int
name|error
decl_stmt|;
name|DBG
argument_list|(
name|sc
argument_list|,
name|TX
argument_list|,
operator|(
literal|"tx%td: starting ..."
operator|,
name|slot
operator|-
name|sc
operator|->
name|txslot
operator|)
argument_list|)
expr_stmt|;
name|again
label|:
name|bzero
argument_list|(
operator|&
name|tx
argument_list|,
sizeof|sizeof
argument_list|(
name|tx
argument_list|)
argument_list|)
expr_stmt|;
name|tx
operator|.
name|chan
operator|=
name|slot
operator|-
name|sc
operator|->
name|txslot
expr_stmt|;
name|tx
operator|.
name|sc
operator|=
name|sc
expr_stmt|;
comment|/* 	 * get an mbuf waiting for DMA 	 */
name|_IF_DEQUEUE
argument_list|(
operator|&
name|slot
operator|->
name|q
argument_list|,
name|tx
operator|.
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|tx
operator|.
name|m
operator|==
name|NULL
condition|)
block|{
name|DBG
argument_list|(
name|sc
argument_list|,
name|TX
argument_list|,
operator|(
literal|"tx%td: ...done!"
operator|,
name|slot
operator|-
name|sc
operator|->
name|txslot
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|MBUF_GET_TX
argument_list|(
name|tx
operator|.
name|m
argument_list|,
name|tx
operator|.
name|vci
argument_list|,
name|tx
operator|.
name|flags
argument_list|,
name|tx
operator|.
name|datalen
argument_list|,
name|pad
argument_list|,
name|map
argument_list|)
expr_stmt|;
comment|/* 	 * note: don't use the entire buffer space.  if WRTX becomes equal 	 * to RDTX, the transmitter stops assuming the buffer is empty!  --kjc 	 */
if|if
condition|(
name|tx
operator|.
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|>=
name|slot
operator|->
name|bfree
condition|)
block|{
name|EN_COUNT
argument_list|(
name|sc
operator|->
name|stats
operator|.
name|txoutspace
argument_list|)
expr_stmt|;
name|DBG
argument_list|(
name|sc
argument_list|,
name|TX
argument_list|,
operator|(
literal|"tx%td: out of transmit space"
operator|,
name|slot
operator|-
name|sc
operator|->
name|txslot
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|waitres
goto|;
block|}
name|lastm
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tx
operator|.
name|flags
operator|&
name|TX_HAS_PAD
operator|)
condition|)
block|{
if|if
condition|(
name|pad
operator|!=
literal|0
condition|)
block|{
comment|/* Append the padding buffer */
operator|(
name|void
operator|)
name|m_length
argument_list|(
name|tx
operator|.
name|m
argument_list|,
operator|&
name|lastm
argument_list|)
expr_stmt|;
name|lastm
operator|->
name|m_next
operator|=
name|sc
operator|->
name|padbuf
expr_stmt|;
name|sc
operator|->
name|padbuf
operator|->
name|m_len
operator|=
name|pad
expr_stmt|;
block|}
name|tx
operator|.
name|flags
operator||=
name|TX_HAS_PAD
expr_stmt|;
block|}
comment|/* 	 * Try to load that map 	 */
name|error
operator|=
name|bus_dmamap_load_mbuf
argument_list|(
name|sc
operator|->
name|txtag
argument_list|,
name|map
operator|->
name|map
argument_list|,
name|tx
operator|.
name|m
argument_list|,
name|en_txdma_load
argument_list|,
operator|&
name|tx
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|lastm
operator|!=
name|NULL
condition|)
name|lastm
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"loading TX map failed %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|dequeue_drop
goto|;
block|}
name|map
operator|->
name|flags
operator||=
name|ENMAP_LOADED
expr_stmt|;
if|if
condition|(
name|tx
operator|.
name|wait
condition|)
block|{
comment|/* probably not enough space */
name|bus_dmamap_unload
argument_list|(
name|map
operator|->
name|sc
operator|->
name|txtag
argument_list|,
name|map
operator|->
name|map
argument_list|)
expr_stmt|;
name|map
operator|->
name|flags
operator|&=
operator|~
name|ENMAP_LOADED
expr_stmt|;
name|sc
operator|->
name|need_dtqs
operator|=
literal|1
expr_stmt|;
name|DBG
argument_list|(
name|sc
argument_list|,
name|TX
argument_list|,
operator|(
literal|"tx%td: out of transmit DTQs"
operator|,
name|slot
operator|-
name|sc
operator|->
name|txslot
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|waitres
goto|;
block|}
name|EN_COUNT
argument_list|(
name|sc
operator|->
name|stats
operator|.
name|launch
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ifp
operator|->
name|if_opackets
operator|++
expr_stmt|;
name|sc
operator|->
name|vccs
index|[
name|tx
operator|.
name|vci
index|]
operator|->
name|opackets
operator|++
expr_stmt|;
name|sc
operator|->
name|vccs
index|[
name|tx
operator|.
name|vci
index|]
operator|->
name|obytes
operator|+=
name|tx
operator|.
name|datalen
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_BPF
if|if
condition|(
name|bpf_peers_present
argument_list|(
name|sc
operator|->
name|ifp
operator|->
name|if_bpf
argument_list|)
condition|)
block|{
comment|/* 		 * adjust the top of the mbuf to skip the TBD if present 		 * before passing the packet to bpf. 		 * Also remove padding and the PDU trailer. Assume both of 		 * them to be in the same mbuf. pktlen, m_len and m_data 		 * are not needed anymore so we can change them. 		 */
if|if
condition|(
name|tx
operator|.
name|flags
operator|&
name|TX_HAS_TBD
condition|)
block|{
name|tx
operator|.
name|m
operator|->
name|m_data
operator|+=
name|MID_TBD_SIZE
expr_stmt|;
name|tx
operator|.
name|m
operator|->
name|m_len
operator|-=
name|MID_TBD_SIZE
expr_stmt|;
block|}
name|tx
operator|.
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m_length
argument_list|(
name|tx
operator|.
name|m
argument_list|,
operator|&
name|lastm
argument_list|)
expr_stmt|;
if|if
condition|(
name|tx
operator|.
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|>
name|tx
operator|.
name|datalen
condition|)
block|{
name|lastm
operator|->
name|m_len
operator|-=
name|tx
operator|.
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|-
name|tx
operator|.
name|datalen
expr_stmt|;
name|tx
operator|.
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|tx
operator|.
name|datalen
expr_stmt|;
block|}
name|bpf_mtap
argument_list|(
name|sc
operator|->
name|ifp
operator|->
name|if_bpf
argument_list|,
name|tx
operator|.
name|m
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * do some housekeeping and get the next packet 	 */
name|slot
operator|->
name|bfree
operator|-=
name|tx
operator|.
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|_IF_ENQUEUE
argument_list|(
operator|&
name|slot
operator|->
name|indma
argument_list|,
name|tx
operator|.
name|m
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
comment|/* 	 * error handling. This is jumped to when we just want to drop 	 * the packet. Must be unlocked here. 	 */
name|dequeue_drop
label|:
if|if
condition|(
name|map
operator|!=
name|NULL
condition|)
name|uma_zfree
argument_list|(
name|sc
operator|->
name|map_zone
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|slot
operator|->
name|mbsize
operator|-=
name|tx
operator|.
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|m_freem
argument_list|(
name|tx
operator|.
name|m
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
name|waitres
label|:
name|_IF_PREPEND
argument_list|(
operator|&
name|slot
operator|->
name|q
argument_list|,
name|tx
operator|.
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Create a copy of a single mbuf. It can have either internal or  * external data, it may have a packet header. External data is really  * copied, so the new buffer is writeable.  *  * LOCK: any, not needed  */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|copy_mbuf
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|new
decl_stmt|;
name|MGET
argument_list|(
name|new
argument_list|,
name|M_WAITOK
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_PKTHDR
condition|)
block|{
name|M_MOVE_PKTHDR
argument_list|(
name|new
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|>
name|MHLEN
condition|)
name|MCLGET
argument_list|(
name|new
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|m
operator|->
name|m_len
operator|>
name|MLEN
condition|)
name|MCLGET
argument_list|(
name|new
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
block|}
name|bcopy
argument_list|(
name|m
operator|->
name|m_data
argument_list|,
name|new
operator|->
name|m_data
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|new
operator|->
name|m_len
operator|=
name|m
operator|->
name|m_len
expr_stmt|;
name|new
operator|->
name|m_flags
operator|&=
operator|~
name|M_RDONLY
expr_stmt|;
return|return
operator|(
name|new
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This function is called when we have an ENI adapter. It fixes the  * mbuf chain, so that all addresses and lengths are 4 byte aligned.  * The overall length is already padded to multiple of cells plus the  * TBD so this must always succeed. The routine can fail, when it  * needs to copy an mbuf (this may happen if an mbuf is readonly).  *  * We assume here, that aligning the virtual addresses to 4 bytes also  * aligns the physical addresses.  *  * LOCK: locked, needed  */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|en_fix_mchain
parameter_list|(
name|struct
name|en_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|,
name|u_int
modifier|*
name|pad
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
modifier|*
name|prev
init|=
operator|&
name|m0
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
init|=
name|m0
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|new
decl_stmt|;
name|u_char
modifier|*
name|d
decl_stmt|;
name|int
name|off
decl_stmt|;
while|while
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
name|d
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|u_char
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|off
operator|=
operator|(
name|uintptr_t
operator|)
name|d
operator|%
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|EN_COUNT
argument_list|(
name|sc
operator|->
name|stats
operator|.
name|mfixaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|M_WRITABLE
argument_list|(
name|m
argument_list|)
condition|)
block|{
name|bcopy
argument_list|(
name|d
argument_list|,
name|d
operator|-
name|off
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_data
operator|-=
name|off
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|new
operator|=
name|copy_mbuf
argument_list|(
name|m
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|EN_COUNT
argument_list|(
name|sc
operator|->
name|stats
operator|.
name|mfixfail
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|new
operator|->
name|m_next
operator|=
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
operator|*
name|prev
operator|=
name|m
operator|=
name|new
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|off
operator|=
name|m
operator|->
name|m_len
operator|%
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|EN_COUNT
argument_list|(
name|sc
operator|->
name|stats
operator|.
name|mfixlen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|M_WRITABLE
argument_list|(
name|m
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|new
operator|=
name|copy_mbuf
argument_list|(
name|m
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|EN_COUNT
argument_list|(
name|sc
operator|->
name|stats
operator|.
name|mfixfail
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|new
operator|->
name|m_next
operator|=
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
operator|*
name|prev
operator|=
name|m
operator|=
name|new
expr_stmt|;
block|}
name|d
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|u_char
operator|*
argument_list|)
operator|+
name|m
operator|->
name|m_len
expr_stmt|;
name|off
operator|=
literal|4
operator|-
name|off
expr_stmt|;
while|while
condition|(
name|off
condition|)
block|{
while|while
condition|(
name|m
operator|->
name|m_next
operator|&&
name|m
operator|->
name|m_next
operator|->
name|m_len
operator|==
literal|0
condition|)
name|m
operator|->
name|m_next
operator|=
name|m_free
argument_list|(
name|m
operator|->
name|m_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_next
operator|==
name|NULL
condition|)
block|{
operator|*
name|d
operator|++
operator|=
literal|0
expr_stmt|;
name|KASSERT
argument_list|(
operator|*
name|pad
operator|>
literal|0
argument_list|,
operator|(
literal|"no padding space"
operator|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|pad
operator|)
operator|--
expr_stmt|;
block|}
else|else
block|{
operator|*
name|d
operator|++
operator|=
operator|*
name|mtod
argument_list|(
name|m
operator|->
name|m_next
argument_list|,
name|u_char
operator|*
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_next
operator|->
name|m_len
operator|--
expr_stmt|;
name|m
operator|->
name|m_next
operator|->
name|m_data
operator|++
expr_stmt|;
block|}
name|m
operator|->
name|m_len
operator|++
expr_stmt|;
name|off
operator|--
expr_stmt|;
block|}
block|}
name|prev
operator|=
operator|&
name|m
operator|->
name|m_next
expr_stmt|;
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
block|}
return|return
operator|(
name|m0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * en_start: start transmitting the next packet that needs to go out  * if there is one. We take off all packets from the interface's queue and  * put them into the channels queue.  *  * Here we also prepend the transmit packet descriptor and append the padding  * and (for aal5) the PDU trailer. This is different from the original driver:  * we assume, that allocating one or two additional mbufs is actually cheaper  * than all this algorithmic fiddling we would need otherwise.  *  * While the packet is on the channels wait queue we use the csum_* fields  * in the packet header to hold the original datalen, the AAL5 flag and the  * VCI. The packet length field in the header holds the needed buffer space.  * This may actually be more than the length of the current mbuf chain (when  * one or more of TBD, padding and PDU do not fit).  *  * LOCK: unlocked, needed  */
end_comment

begin_function
specifier|static
name|void
name|en_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|en_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|en_softc
operator|*
operator|)
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|lastm
decl_stmt|;
name|struct
name|atm_pseudohdr
modifier|*
name|ap
decl_stmt|;
name|u_int
name|pad
decl_stmt|;
comment|/* 0-bytes to pad at PDU end */
name|u_int
name|datalen
decl_stmt|;
comment|/* length of user data */
name|u_int
name|vci
decl_stmt|;
comment|/* the VCI we are transmitting on */
name|u_int
name|flags
decl_stmt|;
name|uint32_t
name|tbd
index|[
literal|2
index|]
decl_stmt|;
name|uint32_t
name|pdu
index|[
literal|2
index|]
decl_stmt|;
name|struct
name|en_vcc
modifier|*
name|vc
decl_stmt|;
name|struct
name|en_map
modifier|*
name|map
decl_stmt|;
name|struct
name|en_txslot
modifier|*
name|tx
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|IF_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return;
name|flags
operator|=
literal|0
expr_stmt|;
name|ap
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|atm_pseudohdr
operator|*
argument_list|)
expr_stmt|;
name|vci
operator|=
name|ATM_PH_VCI
argument_list|(
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|ATM_PH_VPI
argument_list|(
name|ap
argument_list|)
operator|!=
literal|0
operator|||
name|vci
operator|>=
name|MID_N_VC
operator|||
operator|(
name|vc
operator|=
name|sc
operator|->
name|vccs
index|[
name|vci
index|]
operator|)
operator|==
name|NULL
operator|||
operator|(
name|vc
operator|->
name|vflags
operator|&
name|VCC_CLOSE_RX
operator|)
condition|)
block|{
name|DBG
argument_list|(
name|sc
argument_list|,
name|TX
argument_list|,
operator|(
literal|"output vpi=%u, vci=%u -- drop"
operator|,
name|ATM_PH_VPI
argument_list|(
name|ap
argument_list|)
operator|,
name|vci
operator|)
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|vc
operator|->
name|vcc
operator|.
name|aal
operator|==
name|ATMIO_AAL_5
condition|)
name|flags
operator||=
name|TX_AAL5
expr_stmt|;
name|m_adj
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|atm_pseudohdr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * (re-)calculate size of packet (in bytes) 		 */
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|datalen
operator|=
name|m_length
argument_list|(
name|m
argument_list|,
operator|&
name|lastm
argument_list|)
expr_stmt|;
comment|/* 		 * computing how much padding we need on the end of the mbuf, 		 * then see if we can put the TBD at the front of the mbuf 		 * where the link header goes (well behaved protocols will 		 * reserve room for us). Last, check if room for PDU tail. 		 */
if|if
condition|(
name|flags
operator|&
name|TX_AAL5
condition|)
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
name|MID_PDU_SIZE
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|roundup
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
name|MID_ATMDATASZ
argument_list|)
expr_stmt|;
name|pad
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|-
name|datalen
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|TX_AAL5
condition|)
name|pad
operator|-=
name|MID_PDU_SIZE
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
name|MID_TBD_SIZE
expr_stmt|;
name|DBG
argument_list|(
name|sc
argument_list|,
name|TX
argument_list|,
operator|(
literal|"txvci%d: buflen=%u datalen=%u lead=%d trail=%d"
operator|,
name|vci
operator|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|,
name|datalen
operator|,
operator|(
name|int
operator|)
name|M_LEADINGSPACE
argument_list|(
name|m
argument_list|)
operator|,
operator|(
name|int
operator|)
name|M_TRAILINGSPACE
argument_list|(
name|lastm
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * From here on we need access to sc 		 */
name|EN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 		 * Allocate a map. We do this here rather then in en_txdma, 		 * because en_txdma is also called from the interrupt handler 		 * and we are going to have a locking problem then. We must 		 * use NOWAIT here, because the ip_output path holds various 		 * locks. 		 */
name|map
operator|=
name|uma_zalloc_arg
argument_list|(
name|sc
operator|->
name|map_zone
argument_list|,
name|sc
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|map
operator|==
name|NULL
condition|)
block|{
comment|/* drop that packet */
name|EN_COUNT
argument_list|(
name|sc
operator|->
name|stats
operator|.
name|txnomap
argument_list|)
expr_stmt|;
name|EN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
block|{
name|EN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|sc
operator|->
name|map_zone
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Look, whether we can prepend the TBD (8 byte) 		 */
if|if
condition|(
name|M_WRITABLE
argument_list|(
name|m
argument_list|)
operator|&&
name|M_LEADINGSPACE
argument_list|(
name|m
argument_list|)
operator|>=
name|MID_TBD_SIZE
condition|)
block|{
name|tbd
index|[
literal|0
index|]
operator|=
name|htobe32
argument_list|(
name|MID_TBD_MK1
argument_list|(
operator|(
name|flags
operator|&
name|TX_AAL5
operator|)
condition|?
name|MID_TBD_AAL5
else|:
name|MID_TBD_NOAAL5
argument_list|,
name|vc
operator|->
name|txspeed
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|/
name|MID_ATMDATASZ
argument_list|)
argument_list|)
expr_stmt|;
name|tbd
index|[
literal|1
index|]
operator|=
name|htobe32
argument_list|(
name|MID_TBD_MK2
argument_list|(
name|vci
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_data
operator|-=
name|MID_TBD_SIZE
expr_stmt|;
name|bcopy
argument_list|(
name|tbd
argument_list|,
name|m
operator|->
name|m_data
argument_list|,
name|MID_TBD_SIZE
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|+=
name|MID_TBD_SIZE
expr_stmt|;
name|flags
operator||=
name|TX_HAS_TBD
expr_stmt|;
block|}
comment|/* 		 * Check whether the padding fits (must be writeable - 		 * we pad with zero). 		 */
if|if
condition|(
name|M_WRITABLE
argument_list|(
name|lastm
argument_list|)
operator|&&
name|M_TRAILINGSPACE
argument_list|(
name|lastm
argument_list|)
operator|>=
name|pad
condition|)
block|{
name|bzero
argument_list|(
name|lastm
operator|->
name|m_data
operator|+
name|lastm
operator|->
name|m_len
argument_list|,
name|pad
argument_list|)
expr_stmt|;
name|lastm
operator|->
name|m_len
operator|+=
name|pad
expr_stmt|;
name|flags
operator||=
name|TX_HAS_PAD
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|TX_AAL5
operator|)
operator|&&
name|M_TRAILINGSPACE
argument_list|(
name|lastm
argument_list|)
operator|>
name|MID_PDU_SIZE
condition|)
block|{
name|pdu
index|[
literal|0
index|]
operator|=
name|htobe32
argument_list|(
name|MID_PDU_MK1
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|datalen
argument_list|)
argument_list|)
expr_stmt|;
name|pdu
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|bcopy
argument_list|(
name|pdu
argument_list|,
name|lastm
operator|->
name|m_data
operator|+
name|lastm
operator|->
name|m_len
argument_list|,
name|MID_PDU_SIZE
argument_list|)
expr_stmt|;
name|lastm
operator|->
name|m_len
operator|+=
name|MID_PDU_SIZE
expr_stmt|;
name|flags
operator||=
name|TX_HAS_PDU
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|sc
operator|->
name|is_adaptec
operator|&&
operator|(
name|m
operator|=
name|en_fix_mchain
argument_list|(
name|sc
argument_list|,
name|m
argument_list|,
operator|&
name|pad
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|EN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|sc
operator|->
name|map_zone
argument_list|,
name|map
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * get assigned channel (will be zero unless txspeed is set) 		 */
name|tx
operator|=
name|vc
operator|->
name|txslot
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|>
name|EN_TXSZ
operator|*
literal|1024
condition|)
block|{
name|DBG
argument_list|(
name|sc
argument_list|,
name|TX
argument_list|,
operator|(
literal|"tx%td: packet larger than xmit buffer "
literal|"(%d> %d)\n"
operator|,
name|tx
operator|-
name|sc
operator|->
name|txslot
operator|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|,
name|EN_TXSZ
operator|*
literal|1024
operator|)
argument_list|)
expr_stmt|;
name|EN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|sc
operator|->
name|map_zone
argument_list|,
name|map
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|tx
operator|->
name|mbsize
operator|>
name|EN_TXHIWAT
condition|)
block|{
name|EN_COUNT
argument_list|(
name|sc
operator|->
name|stats
operator|.
name|txmbovr
argument_list|)
expr_stmt|;
name|DBG
argument_list|(
name|sc
argument_list|,
name|TX
argument_list|,
operator|(
literal|"tx%td: buffer space shortage"
operator|,
name|tx
operator|-
name|sc
operator|->
name|txslot
operator|)
argument_list|)
expr_stmt|;
name|EN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|sc
operator|->
name|map_zone
argument_list|,
name|map
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* commit */
name|tx
operator|->
name|mbsize
operator|+=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|DBG
argument_list|(
name|sc
argument_list|,
name|TX
argument_list|,
operator|(
literal|"tx%td: VCI=%d, speed=0x%x, buflen=%d, mbsize=%d"
operator|,
name|tx
operator|-
name|sc
operator|->
name|txslot
operator|,
name|vci
operator|,
name|sc
operator|->
name|vccs
index|[
name|vci
index|]
operator|->
name|txspeed
operator|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|,
name|tx
operator|->
name|mbsize
operator|)
argument_list|)
expr_stmt|;
name|MBUF_SET_TX
argument_list|(
name|m
argument_list|,
name|vci
argument_list|,
name|flags
argument_list|,
name|datalen
argument_list|,
name|pad
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|_IF_ENQUEUE
argument_list|(
operator|&
name|tx
operator|->
name|q
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|en_txdma
argument_list|(
name|sc
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|EN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*********************************************************************/
end_comment

begin_comment
comment|/*  * VCs  */
end_comment

begin_comment
comment|/*  * en_loadvc: load a vc tab entry from a slot  *  * LOCK: locked, needed  */
end_comment

begin_function
specifier|static
name|void
name|en_loadvc
parameter_list|(
name|struct
name|en_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|en_vcc
modifier|*
name|vc
parameter_list|)
block|{
name|uint32_t
name|reg
init|=
name|en_read
argument_list|(
name|sc
argument_list|,
name|MID_VC
argument_list|(
name|vc
operator|->
name|vcc
operator|.
name|vci
argument_list|)
argument_list|)
decl_stmt|;
name|reg
operator|=
name|MIDV_SETMODE
argument_list|(
name|reg
argument_list|,
name|MIDV_TRASH
argument_list|)
expr_stmt|;
name|en_write
argument_list|(
name|sc
argument_list|,
name|MID_VC
argument_list|(
name|vc
operator|->
name|vcc
operator|.
name|vci
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|27
argument_list|)
expr_stmt|;
comment|/* no need to set CRC */
comment|/* read pointer = 0, desc. start = 0 */
name|en_write
argument_list|(
name|sc
argument_list|,
name|MID_DST_RP
argument_list|(
name|vc
operator|->
name|vcc
operator|.
name|vci
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* write pointer = 0 */
name|en_write
argument_list|(
name|sc
argument_list|,
name|MID_WP_ST_CNT
argument_list|(
name|vc
operator|->
name|vcc
operator|.
name|vci
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* set mode, size, loc */
name|en_write
argument_list|(
name|sc
argument_list|,
name|MID_VC
argument_list|(
name|vc
operator|->
name|vcc
operator|.
name|vci
argument_list|)
argument_list|,
name|vc
operator|->
name|rxslot
operator|->
name|mode
argument_list|)
expr_stmt|;
name|vc
operator|->
name|rxslot
operator|->
name|cur
operator|=
name|vc
operator|->
name|rxslot
operator|->
name|start
expr_stmt|;
name|DBG
argument_list|(
name|sc
argument_list|,
name|VC
argument_list|,
operator|(
literal|"rx%td: assigned to VCI %d"
operator|,
name|vc
operator|->
name|rxslot
operator|-
name|sc
operator|->
name|rxslot
operator|,
name|vc
operator|->
name|vcc
operator|.
name|vci
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Open the given vcc.  *  * LOCK: unlocked, needed  */
end_comment

begin_function
specifier|static
name|int
name|en_open_vcc
parameter_list|(
name|struct
name|en_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|atmio_openvcc
modifier|*
name|op
parameter_list|)
block|{
name|uint32_t
name|oldmode
decl_stmt|,
name|newmode
decl_stmt|;
name|struct
name|en_rxslot
modifier|*
name|slot
decl_stmt|;
name|struct
name|en_vcc
modifier|*
name|vc
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|DBG
argument_list|(
name|sc
argument_list|,
name|IOCTL
argument_list|,
operator|(
literal|"enable vpi=%d, vci=%d, flags=%#x"
operator|,
name|op
operator|->
name|param
operator|.
name|vpi
operator|,
name|op
operator|->
name|param
operator|.
name|vci
operator|,
name|op
operator|->
name|param
operator|.
name|flags
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|->
name|param
operator|.
name|vpi
operator|!=
literal|0
operator|||
name|op
operator|->
name|param
operator|.
name|vci
operator|>=
name|MID_N_VC
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|vc
operator|=
name|uma_zalloc
argument_list|(
name|en_vcc_zone
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|vc
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|EN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|vccs
index|[
name|op
operator|->
name|param
operator|.
name|vci
index|]
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* find a free receive slot */
for|for
control|(
name|slot
operator|=
name|sc
operator|->
name|rxslot
init|;
name|slot
operator|<
operator|&
name|sc
operator|->
name|rxslot
index|[
name|sc
operator|->
name|en_nrx
index|]
condition|;
name|slot
operator|++
control|)
if|if
condition|(
name|slot
operator|->
name|vcc
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|slot
operator|==
operator|&
name|sc
operator|->
name|rxslot
index|[
name|sc
operator|->
name|en_nrx
index|]
condition|)
block|{
name|error
operator|=
name|ENOSPC
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|vc
operator|->
name|rxslot
operator|=
name|slot
expr_stmt|;
name|vc
operator|->
name|rxhand
operator|=
name|op
operator|->
name|rxhand
expr_stmt|;
name|vc
operator|->
name|vcc
operator|=
name|op
operator|->
name|param
expr_stmt|;
name|oldmode
operator|=
name|slot
operator|->
name|mode
expr_stmt|;
name|newmode
operator|=
operator|(
name|op
operator|->
name|param
operator|.
name|aal
operator|==
name|ATMIO_AAL_5
operator|)
condition|?
name|MIDV_AAL5
else|:
name|MIDV_NOAAL
expr_stmt|;
name|slot
operator|->
name|mode
operator|=
name|MIDV_SETMODE
argument_list|(
name|oldmode
argument_list|,
name|newmode
argument_list|)
expr_stmt|;
name|slot
operator|->
name|vcc
operator|=
name|vc
expr_stmt|;
name|KASSERT
argument_list|(
name|_IF_QLEN
argument_list|(
operator|&
name|slot
operator|->
name|indma
argument_list|)
operator|==
literal|0
operator|&&
name|_IF_QLEN
argument_list|(
operator|&
name|slot
operator|->
name|q
argument_list|)
operator|==
literal|0
argument_list|,
operator|(
literal|"en_rxctl: left over mbufs on enable slot=%td"
operator|,
name|vc
operator|->
name|rxslot
operator|-
name|sc
operator|->
name|rxslot
operator|)
argument_list|)
expr_stmt|;
name|vc
operator|->
name|txspeed
operator|=
literal|0
expr_stmt|;
name|vc
operator|->
name|txslot
operator|=
name|sc
operator|->
name|txslot
expr_stmt|;
name|vc
operator|->
name|txslot
operator|->
name|nref
operator|++
expr_stmt|;
comment|/* bump reference count */
name|en_loadvc
argument_list|(
name|sc
argument_list|,
name|vc
argument_list|)
expr_stmt|;
comment|/* does debug printf for us */
comment|/* don't free below */
name|sc
operator|->
name|vccs
index|[
name|vc
operator|->
name|vcc
operator|.
name|vci
index|]
operator|=
name|vc
expr_stmt|;
name|vc
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|vccs_open
operator|++
expr_stmt|;
name|done
label|:
if|if
condition|(
name|vc
operator|!=
name|NULL
condition|)
name|uma_zfree
argument_list|(
name|en_vcc_zone
argument_list|,
name|vc
argument_list|)
expr_stmt|;
name|EN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Close finished  */
end_comment

begin_function
specifier|static
name|void
name|en_close_finish
parameter_list|(
name|struct
name|en_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|en_vcc
modifier|*
name|vc
parameter_list|)
block|{
if|if
condition|(
name|vc
operator|->
name|rxslot
operator|!=
name|NULL
condition|)
name|vc
operator|->
name|rxslot
operator|->
name|vcc
operator|=
name|NULL
expr_stmt|;
name|DBG
argument_list|(
name|sc
argument_list|,
name|VC
argument_list|,
operator|(
literal|"vci: %u free (%p)"
operator|,
name|vc
operator|->
name|vcc
operator|.
name|vci
operator|,
name|vc
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|vccs
index|[
name|vc
operator|->
name|vcc
operator|.
name|vci
index|]
operator|=
name|NULL
expr_stmt|;
name|uma_zfree
argument_list|(
name|en_vcc_zone
argument_list|,
name|vc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|vccs_open
operator|--
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * LOCK: unlocked, needed  */
end_comment

begin_function
specifier|static
name|int
name|en_close_vcc
parameter_list|(
name|struct
name|en_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|atmio_closevcc
modifier|*
name|cl
parameter_list|)
block|{
name|uint32_t
name|oldmode
decl_stmt|,
name|newmode
decl_stmt|;
name|struct
name|en_vcc
modifier|*
name|vc
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|DBG
argument_list|(
name|sc
argument_list|,
name|IOCTL
argument_list|,
operator|(
literal|"disable vpi=%d, vci=%d"
operator|,
name|cl
operator|->
name|vpi
operator|,
name|cl
operator|->
name|vci
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cl
operator|->
name|vpi
operator|!=
literal|0
operator|||
name|cl
operator|->
name|vci
operator|>=
name|MID_N_VC
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|EN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|vc
operator|=
name|sc
operator|->
name|vccs
index|[
name|cl
operator|->
name|vci
index|]
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOTCONN
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 	 * turn off VCI 	 */
if|if
condition|(
name|vc
operator|->
name|rxslot
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOTCONN
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|vc
operator|->
name|vflags
operator|&
name|VCC_DRAIN
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|oldmode
operator|=
name|en_read
argument_list|(
name|sc
argument_list|,
name|MID_VC
argument_list|(
name|cl
operator|->
name|vci
argument_list|)
argument_list|)
expr_stmt|;
name|newmode
operator|=
name|MIDV_SETMODE
argument_list|(
name|oldmode
argument_list|,
name|MIDV_TRASH
argument_list|)
operator|&
operator|~
name|MIDV_INSERVICE
expr_stmt|;
name|en_write
argument_list|(
name|sc
argument_list|,
name|MID_VC
argument_list|(
name|cl
operator|->
name|vci
argument_list|)
argument_list|,
operator|(
name|newmode
operator||
operator|(
name|oldmode
operator|&
name|MIDV_INSERVICE
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* halt in tracks, be careful to preserve inservice bit */
name|DELAY
argument_list|(
literal|27
argument_list|)
expr_stmt|;
name|vc
operator|->
name|rxslot
operator|->
name|mode
operator|=
name|newmode
expr_stmt|;
name|vc
operator|->
name|txslot
operator|->
name|nref
operator|--
expr_stmt|;
comment|/* if stuff is still going on we are going to have to drain it out */
if|if
condition|(
name|_IF_QLEN
argument_list|(
operator|&
name|vc
operator|->
name|rxslot
operator|->
name|indma
argument_list|)
operator|==
literal|0
operator|&&
name|_IF_QLEN
argument_list|(
operator|&
name|vc
operator|->
name|rxslot
operator|->
name|q
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|vc
operator|->
name|vflags
operator|&
name|VCC_SWSL
operator|)
operator|==
literal|0
condition|)
block|{
name|en_close_finish
argument_list|(
name|sc
argument_list|,
name|vc
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|vc
operator|->
name|vflags
operator||=
name|VCC_DRAIN
expr_stmt|;
name|DBG
argument_list|(
name|sc
argument_list|,
name|IOCTL
argument_list|,
operator|(
literal|"VCI %u now draining"
operator|,
name|cl
operator|->
name|vci
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|vc
operator|->
name|vcc
operator|.
name|flags
operator|&
name|ATMIO_FLAG_ASYNC
condition|)
goto|goto
name|done
goto|;
name|vc
operator|->
name|vflags
operator||=
name|VCC_CLOSE_RX
expr_stmt|;
while|while
condition|(
operator|(
name|sc
operator|->
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|&&
operator|(
name|vc
operator|->
name|vflags
operator|&
name|VCC_DRAIN
operator|)
condition|)
name|cv_wait
argument_list|(
operator|&
name|sc
operator|->
name|cv_close
argument_list|,
operator|&
name|sc
operator|->
name|en_mtx
argument_list|)
expr_stmt|;
name|en_close_finish
argument_list|(
name|sc
argument_list|,
name|vc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
block|{
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|done
label|:
name|EN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************/
end_comment

begin_comment
comment|/*  * starting/stopping the card  */
end_comment

begin_comment
comment|/*  * en_reset_ul: reset the board, throw away work in progress.  * must en_init to recover.  *  * LOCK: locked, needed  */
end_comment

begin_function
specifier|static
name|void
name|en_reset_ul
parameter_list|(
name|struct
name|en_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|en_map
modifier|*
name|map
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|en_rxslot
modifier|*
name|rx
decl_stmt|;
name|int
name|lcv
decl_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"reset\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_RUNNING
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|en_busreset
condition|)
name|sc
operator|->
name|en_busreset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|en_write
argument_list|(
name|sc
argument_list|,
name|MID_RESID
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
comment|/* reset hardware */
comment|/* 	 * recv: dump any mbufs we are dma'ing into, if DRAINing, then a reset 	 * will free us! Don't release the rxslot from the channel. 	 */
for|for
control|(
name|lcv
operator|=
literal|0
init|;
name|lcv
operator|<
name|MID_N_VC
condition|;
name|lcv
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|vccs
index|[
name|lcv
index|]
operator|==
name|NULL
condition|)
continue|continue;
name|rx
operator|=
name|sc
operator|->
name|vccs
index|[
name|lcv
index|]
operator|->
name|rxslot
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|_IF_DEQUEUE
argument_list|(
operator|&
name|rx
operator|->
name|indma
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
break|break;
name|map
operator|=
operator|(
name|void
operator|*
operator|)
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
expr_stmt|;
name|uma_zfree
argument_list|(
name|sc
operator|->
name|map_zone
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
name|_IF_DEQUEUE
argument_list|(
operator|&
name|rx
operator|->
name|q
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
break|break;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|vccs
index|[
name|lcv
index|]
operator|->
name|vflags
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * xmit: dump everything 	 */
for|for
control|(
name|lcv
operator|=
literal|0
init|;
name|lcv
operator|<
name|EN_NTX
condition|;
name|lcv
operator|++
control|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|_IF_DEQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|txslot
index|[
name|lcv
index|]
operator|.
name|indma
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
break|break;
name|map
operator|=
operator|(
name|void
operator|*
operator|)
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
expr_stmt|;
name|uma_zfree
argument_list|(
name|sc
operator|->
name|map_zone
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
name|_IF_DEQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|txslot
index|[
name|lcv
index|]
operator|.
name|q
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
break|break;
name|map
operator|=
operator|(
name|void
operator|*
operator|)
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
expr_stmt|;
name|uma_zfree
argument_list|(
name|sc
operator|->
name|map_zone
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|txslot
index|[
name|lcv
index|]
operator|.
name|mbsize
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Unstop all waiters 	 */
name|cv_broadcast
argument_list|(
operator|&
name|sc
operator|->
name|cv_close
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * en_reset: reset the board, throw away work in progress.  * must en_init to recover.  *  * LOCK: unlocked, needed  *  * Use en_reset_ul if you alreay have the lock  */
end_comment

begin_function
name|void
name|en_reset
parameter_list|(
name|struct
name|en_softc
modifier|*
name|sc
parameter_list|)
block|{
name|EN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|en_reset_ul
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|EN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * en_init: init board and sync the card with the data in the softc.  *  * LOCK: locked, needed  */
end_comment

begin_function
specifier|static
name|void
name|en_init
parameter_list|(
name|struct
name|en_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|vc
decl_stmt|,
name|slot
decl_stmt|;
name|uint32_t
name|loc
decl_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|==
literal|0
condition|)
block|{
name|DBG
argument_list|(
name|sc
argument_list|,
name|INIT
argument_list|,
operator|(
literal|"going down"
operator|)
argument_list|)
expr_stmt|;
name|en_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* to be safe */
return|return;
block|}
name|DBG
argument_list|(
name|sc
argument_list|,
name|INIT
argument_list|,
operator|(
literal|"going up"
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_RUNNING
expr_stmt|;
comment|/* enable */
if|if
condition|(
name|sc
operator|->
name|en_busreset
condition|)
name|sc
operator|->
name|en_busreset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|en_write
argument_list|(
name|sc
argument_list|,
name|MID_RESID
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
comment|/* reset */
comment|/* zero memory */
name|bus_space_set_region_4
argument_list|(
name|sc
operator|->
name|en_memt
argument_list|,
name|sc
operator|->
name|en_base
argument_list|,
name|MID_RAMOFF
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|en_obmemsz
operator|/
literal|4
argument_list|)
expr_stmt|;
comment|/* 	 * init obmem data structures: vc tab, dma q's, slist. 	 * 	 * note that we set drq_free/dtq_free to one less than the total number 	 * of DTQ/DRQs present.   we do this because the card uses the condition 	 * (drq_chip == drq_us) to mean "list is empty"... but if you allow the 	 * circular list to be completely full then (drq_chip == drq_us) [i.e. 	 * the drq_us pointer will wrap all the way around].   by restricting 	 * the number of active requests to (N - 1) we prevent the list from 	 * becoming completely full.    note that the card will sometimes give 	 * us an interrupt for a DTQ/DRQ we have already processes... this helps 	 * keep that interrupt from messing us up. 	 */
name|bzero
argument_list|(
operator|&
name|sc
operator|->
name|drq
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|drq
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|drq_free
operator|=
name|MID_DRQ_N
operator|-
literal|1
expr_stmt|;
name|sc
operator|->
name|drq_chip
operator|=
name|MID_DRQ_REG2A
argument_list|(
name|en_read
argument_list|(
name|sc
argument_list|,
name|MID_DMA_RDRX
argument_list|)
argument_list|)
expr_stmt|;
name|en_write
argument_list|(
name|sc
argument_list|,
name|MID_DMA_WRRX
argument_list|,
name|MID_DRQ_A2REG
argument_list|(
name|sc
operator|->
name|drq_chip
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|drq_us
operator|=
name|sc
operator|->
name|drq_chip
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|sc
operator|->
name|dtq
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|dtq
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|dtq_free
operator|=
name|MID_DTQ_N
operator|-
literal|1
expr_stmt|;
name|sc
operator|->
name|dtq_chip
operator|=
name|MID_DTQ_REG2A
argument_list|(
name|en_read
argument_list|(
name|sc
argument_list|,
name|MID_DMA_RDTX
argument_list|)
argument_list|)
expr_stmt|;
name|en_write
argument_list|(
name|sc
argument_list|,
name|MID_DMA_WRTX
argument_list|,
name|MID_DRQ_A2REG
argument_list|(
name|sc
operator|->
name|dtq_chip
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|dtq_us
operator|=
name|sc
operator|->
name|dtq_chip
expr_stmt|;
name|sc
operator|->
name|hwslistp
operator|=
name|MID_SL_REG2A
argument_list|(
name|en_read
argument_list|(
name|sc
argument_list|,
name|MID_SERV_WRITE
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|swsl_size
operator|=
name|sc
operator|->
name|swsl_head
operator|=
name|sc
operator|->
name|swsl_tail
operator|=
literal|0
expr_stmt|;
name|DBG
argument_list|(
name|sc
argument_list|,
name|INIT
argument_list|,
operator|(
literal|"drq free/chip: %d/0x%x, dtq free/chip: %d/0x%x, "
literal|"hwslist: 0x%x"
operator|,
name|sc
operator|->
name|drq_free
operator|,
name|sc
operator|->
name|drq_chip
operator|,
name|sc
operator|->
name|dtq_free
operator|,
name|sc
operator|->
name|dtq_chip
operator|,
name|sc
operator|->
name|hwslistp
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|slot
operator|=
literal|0
init|;
name|slot
operator|<
name|EN_NTX
condition|;
name|slot
operator|++
control|)
block|{
name|sc
operator|->
name|txslot
index|[
name|slot
index|]
operator|.
name|bfree
operator|=
name|EN_TXSZ
operator|*
literal|1024
expr_stmt|;
name|en_write
argument_list|(
name|sc
argument_list|,
name|MIDX_READPTR
argument_list|(
name|slot
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|en_write
argument_list|(
name|sc
argument_list|,
name|MIDX_DESCSTART
argument_list|(
name|slot
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|loc
operator|=
name|sc
operator|->
name|txslot
index|[
name|slot
index|]
operator|.
name|cur
operator|=
name|sc
operator|->
name|txslot
index|[
name|slot
index|]
operator|.
name|start
expr_stmt|;
name|loc
operator|=
name|loc
operator|-
name|MID_RAMOFF
expr_stmt|;
comment|/* mask, cvt to words */
name|loc
operator|=
operator|(
name|loc
operator|&
operator|~
operator|(
operator|(
name|EN_TXSZ
operator|*
literal|1024
operator|)
operator|-
literal|1
operator|)
operator|)
operator|>>
literal|2
expr_stmt|;
comment|/* top 11 bits */
name|loc
operator|=
name|loc
operator|>>
name|MIDV_LOCTOPSHFT
expr_stmt|;
name|en_write
argument_list|(
name|sc
argument_list|,
name|MIDX_PLACE
argument_list|(
name|slot
argument_list|)
argument_list|,
name|MIDX_MKPLACE
argument_list|(
name|en_k2sz
argument_list|(
name|EN_TXSZ
argument_list|)
argument_list|,
name|loc
argument_list|)
argument_list|)
expr_stmt|;
name|DBG
argument_list|(
name|sc
argument_list|,
name|INIT
argument_list|,
operator|(
literal|"tx%d: place 0x%x"
operator|,
name|slot
operator|,
operator|(
name|u_int
operator|)
name|en_read
argument_list|(
name|sc
argument_list|,
name|MIDX_PLACE
argument_list|(
name|slot
argument_list|)
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|vc
operator|=
literal|0
init|;
name|vc
operator|<
name|MID_N_VC
condition|;
name|vc
operator|++
control|)
if|if
condition|(
name|sc
operator|->
name|vccs
index|[
name|vc
index|]
operator|!=
name|NULL
condition|)
name|en_loadvc
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|vccs
index|[
name|vc
index|]
argument_list|)
expr_stmt|;
comment|/* 	 * enable! 	 */
name|en_write
argument_list|(
name|sc
argument_list|,
name|MID_INTENA
argument_list|,
name|MID_INT_TX
operator||
name|MID_INT_DMA_OVR
operator||
name|MID_INT_IDENT
operator||
name|MID_INT_LERR
operator||
name|MID_INT_DMA_ERR
operator||
name|MID_INT_DMA_RX
operator||
name|MID_INT_DMA_TX
operator||
name|MID_INT_SERVICE
operator||
name|MID_INT_SUNI
operator||
name|MID_INT_STATS
argument_list|)
expr_stmt|;
name|en_write
argument_list|(
name|sc
argument_list|,
name|MID_MAST_CSR
argument_list|,
name|MID_SETIPL
argument_list|(
name|sc
operator|->
name|ipl
argument_list|)
operator||
name|MID_MCSR_ENDMA
operator||
name|MID_MCSR_ENTX
operator||
name|MID_MCSR_ENRX
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*********************************************************************/
end_comment

begin_comment
comment|/*  * Ioctls  */
end_comment

begin_comment
comment|/*  * en_ioctl: handle ioctl requests  *  * NOTE: if you add an ioctl to set txspeed, you should choose a new  * TX channel/slot.   Choose the one with the lowest sc->txslot[slot].nref  * value, subtract one from sc->txslot[0].nref, add one to the  * sc->txslot[slot].nref, set sc->txvc2slot[vci] = slot, and then set  * txspeed[vci].  *  * LOCK: unlocked, needed  */
end_comment

begin_function
specifier|static
name|int
name|en_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|struct
name|en_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|en_softc
operator|*
operator|)
name|ifp
operator|->
name|if_softc
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|||
name|defined
argument_list|(
name|INET6
argument_list|)
name|struct
name|ifaddr
modifier|*
name|ifa
init|=
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
name|data
decl_stmt|;
endif|#
directive|endif
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|atmio_vcctable
modifier|*
name|vtab
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCSIFADDR
case|:
name|EN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_UP
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|||
name|defined
argument_list|(
name|INET6
argument_list|)
if|if
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|==
name|AF_INET
operator|||
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|==
name|AF_INET6
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
block|{
name|en_reset_ul
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|en_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|ifa
operator|->
name|ifa_rtrequest
operator|=
name|atm_rtrequest
expr_stmt|;
comment|/* ??? */
name|EN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
comment|/* INET */
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
block|{
name|en_reset_ul
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|en_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|EN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFFLAGS
case|:
name|EN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
name|en_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
name|en_reset_ul
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|EN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFMTU
case|:
comment|/* 		 * Set the interface MTU. 		 */
if|if
condition|(
name|ifr
operator|->
name|ifr_mtu
operator|>
name|ATMMTU
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|ifp
operator|->
name|if_mtu
operator|=
name|ifr
operator|->
name|ifr_mtu
expr_stmt|;
break|break;
case|case
name|SIOCSIFMEDIA
case|:
case|case
name|SIOCGIFMEDIA
case|:
name|error
operator|=
name|ifmedia_ioctl
argument_list|(
name|ifp
argument_list|,
name|ifr
argument_list|,
operator|&
name|sc
operator|->
name|media
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCATMOPENVCC
case|:
comment|/* kernel internal use */
name|error
operator|=
name|en_open_vcc
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|atmio_openvcc
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCATMCLOSEVCC
case|:
comment|/* kernel internal use */
name|error
operator|=
name|en_close_vcc
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|atmio_closevcc
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCATMGETVCCS
case|:
comment|/* internal netgraph use */
name|vtab
operator|=
name|atm_getvccs
argument_list|(
operator|(
expr|struct
name|atmio_vcc
operator|*
operator|*
operator|)
name|sc
operator|->
name|vccs
argument_list|,
name|MID_N_VC
argument_list|,
name|sc
operator|->
name|vccs_open
argument_list|,
operator|&
name|sc
operator|->
name|en_mtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|vtab
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
break|break;
block|}
operator|*
operator|(
name|void
operator|*
operator|*
operator|)
name|data
operator|=
name|vtab
expr_stmt|;
break|break;
case|case
name|SIOCATMGVCCS
case|:
comment|/* return vcc table */
name|vtab
operator|=
name|atm_getvccs
argument_list|(
operator|(
expr|struct
name|atmio_vcc
operator|*
operator|*
operator|)
name|sc
operator|->
name|vccs
argument_list|,
name|MID_N_VC
argument_list|,
name|sc
operator|->
name|vccs_open
argument_list|,
operator|&
name|sc
operator|->
name|en_mtx
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
name|vtab
argument_list|,
name|ifr
operator|->
name|ifr_data
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|vtab
argument_list|)
operator|+
name|vtab
operator|->
name|count
operator|*
sizeof|sizeof
argument_list|(
name|vtab
operator|->
name|vccs
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|vtab
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************/
end_comment

begin_comment
comment|/*  * Sysctl's  */
end_comment

begin_comment
comment|/*  * Sysctl handler for internal statistics  *  * LOCK: unlocked, needed  */
end_comment

begin_function
specifier|static
name|int
name|en_sysctl_istats
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|en_softc
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|uint32_t
modifier|*
name|ret
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ret
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|stats
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|EN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|sc
operator|->
name|stats
argument_list|,
name|ret
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|stats
argument_list|)
argument_list|)
expr_stmt|;
name|EN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
name|ret
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|stats
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ret
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************/
end_comment

begin_comment
comment|/*  * Interrupts  */
end_comment

begin_comment
comment|/*  * Transmit interrupt handler  *  * check for tx complete, if detected then this means that some space  * has come free on the card.   we must account for it and arrange to  * kick the channel to life (in case it is stalled waiting on the card).  *  * LOCK: locked, needed  */
end_comment

begin_function
specifier|static
name|uint32_t
name|en_intr_tx
parameter_list|(
name|struct
name|en_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|reg
parameter_list|)
block|{
name|uint32_t
name|kick
decl_stmt|;
name|uint32_t
name|mask
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
name|int
name|chan
decl_stmt|;
name|kick
operator|=
literal|0
expr_stmt|;
comment|/* bitmask of channels to kick */
for|for
control|(
name|mask
operator|=
literal|1
operator|,
name|chan
operator|=
literal|0
init|;
name|chan
operator|<
name|EN_NTX
condition|;
name|chan
operator|++
operator|,
name|mask
operator|*=
literal|2
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|reg
operator|&
name|MID_TXCHAN
argument_list|(
name|chan
argument_list|)
operator|)
condition|)
continue|continue;
name|kick
operator|=
name|kick
operator||
name|mask
expr_stmt|;
comment|/* current read pointer */
name|val
operator|=
name|en_read
argument_list|(
name|sc
argument_list|,
name|MIDX_READPTR
argument_list|(
name|chan
argument_list|)
argument_list|)
expr_stmt|;
comment|/* as offset */
name|val
operator|=
operator|(
name|val
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
operator|+
name|sc
operator|->
name|txslot
index|[
name|chan
index|]
operator|.
name|start
expr_stmt|;
if|if
condition|(
name|val
operator|>
name|sc
operator|->
name|txslot
index|[
name|chan
index|]
operator|.
name|cur
condition|)
name|sc
operator|->
name|txslot
index|[
name|chan
index|]
operator|.
name|bfree
operator|=
name|val
operator|-
name|sc
operator|->
name|txslot
index|[
name|chan
index|]
operator|.
name|cur
expr_stmt|;
else|else
name|sc
operator|->
name|txslot
index|[
name|chan
index|]
operator|.
name|bfree
operator|=
operator|(
name|val
operator|+
operator|(
name|EN_TXSZ
operator|*
literal|1024
operator|)
operator|)
operator|-
name|sc
operator|->
name|txslot
index|[
name|chan
index|]
operator|.
name|cur
expr_stmt|;
name|DBG
argument_list|(
name|sc
argument_list|,
name|INTR
argument_list|,
operator|(
literal|"tx%d: transmit done. %d bytes now free in "
literal|"buffer"
operator|,
name|chan
operator|,
name|sc
operator|->
name|txslot
index|[
name|chan
index|]
operator|.
name|bfree
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|kick
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * TX DMA interrupt  *  * check for TX DMA complete, if detected then this means  * that some DTQs are now free.   it also means some indma  * mbufs can be freed. if we needed DTQs, kick all channels.  *  * LOCK: locked, needed  */
end_comment

begin_function
specifier|static
name|uint32_t
name|en_intr_tx_dma
parameter_list|(
name|struct
name|en_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|kick
init|=
literal|0
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
name|uint32_t
name|idx
decl_stmt|;
name|uint32_t
name|slot
decl_stmt|;
name|uint32_t
name|dtq
decl_stmt|;
name|struct
name|en_map
modifier|*
name|map
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|val
operator|=
name|en_read
argument_list|(
name|sc
argument_list|,
name|MID_DMA_RDTX
argument_list|)
expr_stmt|;
comment|/* chip's current location */
name|idx
operator|=
name|MID_DTQ_A2REG
argument_list|(
name|sc
operator|->
name|dtq_chip
argument_list|)
expr_stmt|;
comment|/* where we last saw chip */
if|if
condition|(
name|sc
operator|->
name|need_dtqs
condition|)
block|{
name|kick
operator|=
name|MID_NTX_CH
operator|-
literal|1
expr_stmt|;
comment|/* assume power of 2, kick all! */
name|sc
operator|->
name|need_dtqs
operator|=
literal|0
expr_stmt|;
comment|/* recalculated in "kick" loop below */
name|DBG
argument_list|(
name|sc
argument_list|,
name|INTR
argument_list|,
operator|(
literal|"cleared need DTQ condition"
operator|)
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|idx
operator|!=
name|val
condition|)
block|{
name|sc
operator|->
name|dtq_free
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|dtq
operator|=
name|sc
operator|->
name|dtq
index|[
name|idx
index|]
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* don't forget to zero it out when done */
name|sc
operator|->
name|dtq
index|[
name|idx
index|]
operator|=
literal|0
expr_stmt|;
name|slot
operator|=
name|EN_DQ_SLOT
argument_list|(
name|dtq
argument_list|)
expr_stmt|;
name|_IF_DEQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|txslot
index|[
name|slot
index|]
operator|.
name|indma
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"enintr: dtqsync"
argument_list|)
expr_stmt|;
name|map
operator|=
operator|(
name|void
operator|*
operator|)
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
expr_stmt|;
name|uma_zfree
argument_list|(
name|sc
operator|->
name|map_zone
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|sc
operator|->
name|txslot
index|[
name|slot
index|]
operator|.
name|mbsize
operator|-=
name|EN_DQ_LEN
argument_list|(
name|dtq
argument_list|)
expr_stmt|;
name|DBG
argument_list|(
name|sc
argument_list|,
name|INTR
argument_list|,
operator|(
literal|"tx%d: free %d dma bytes, mbsize now "
literal|"%d"
operator|,
name|slot
operator|,
name|EN_DQ_LEN
argument_list|(
name|dtq
argument_list|)
operator|,
name|sc
operator|->
name|txslot
index|[
name|slot
index|]
operator|.
name|mbsize
operator|)
argument_list|)
expr_stmt|;
block|}
name|EN_WRAPADD
argument_list|(
literal|0
argument_list|,
name|MID_DTQ_N
argument_list|,
name|idx
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|dtq_chip
operator|=
name|MID_DTQ_REG2A
argument_list|(
name|val
argument_list|)
expr_stmt|;
comment|/* sync softc */
return|return
operator|(
name|kick
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Service interrupt  *  * LOCK: locked, needed  */
end_comment

begin_function
specifier|static
name|int
name|en_intr_service
parameter_list|(
name|struct
name|en_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|chip
decl_stmt|;
name|uint32_t
name|vci
decl_stmt|;
name|int
name|need_softserv
init|=
literal|0
decl_stmt|;
name|struct
name|en_vcc
modifier|*
name|vc
decl_stmt|;
name|chip
operator|=
name|MID_SL_REG2A
argument_list|(
name|en_read
argument_list|(
name|sc
argument_list|,
name|MID_SERV_WRITE
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|sc
operator|->
name|hwslistp
operator|!=
name|chip
condition|)
block|{
comment|/* fetch and remove it from hardware service list */
name|vci
operator|=
name|en_read
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|hwslistp
argument_list|)
expr_stmt|;
name|EN_WRAPADD
argument_list|(
name|MID_SLOFF
argument_list|,
name|MID_SLEND
argument_list|,
name|sc
operator|->
name|hwslistp
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|vc
operator|=
name|sc
operator|->
name|vccs
index|[
name|vci
index|]
operator|)
operator|==
name|NULL
operator|||
operator|(
name|vc
operator|->
name|vcc
operator|.
name|flags
operator|&
name|ATMIO_FLAG_NORX
operator|)
condition|)
block|{
name|DBG
argument_list|(
name|sc
argument_list|,
name|INTR
argument_list|,
operator|(
literal|"unexpected rx interrupt VCI %d"
operator|,
name|vci
operator|)
argument_list|)
expr_stmt|;
name|en_write
argument_list|(
name|sc
argument_list|,
name|MID_VC
argument_list|(
name|vci
argument_list|)
argument_list|,
name|MIDV_TRASH
argument_list|)
expr_stmt|;
comment|/* rx off */
continue|continue;
block|}
comment|/* remove from hwsl */
name|en_write
argument_list|(
name|sc
argument_list|,
name|MID_VC
argument_list|(
name|vci
argument_list|)
argument_list|,
name|vc
operator|->
name|rxslot
operator|->
name|mode
argument_list|)
expr_stmt|;
name|EN_COUNT
argument_list|(
name|sc
operator|->
name|stats
operator|.
name|hwpull
argument_list|)
expr_stmt|;
name|DBG
argument_list|(
name|sc
argument_list|,
name|INTR
argument_list|,
operator|(
literal|"pulled VCI %d off hwslist"
operator|,
name|vci
operator|)
argument_list|)
expr_stmt|;
comment|/* add it to the software service list (if needed) */
if|if
condition|(
operator|(
name|vc
operator|->
name|vflags
operator|&
name|VCC_SWSL
operator|)
operator|==
literal|0
condition|)
block|{
name|EN_COUNT
argument_list|(
name|sc
operator|->
name|stats
operator|.
name|swadd
argument_list|)
expr_stmt|;
name|need_softserv
operator|=
literal|1
expr_stmt|;
name|vc
operator|->
name|vflags
operator||=
name|VCC_SWSL
expr_stmt|;
name|sc
operator|->
name|swslist
index|[
name|sc
operator|->
name|swsl_tail
index|]
operator|=
name|vci
expr_stmt|;
name|EN_WRAPADD
argument_list|(
literal|0
argument_list|,
name|MID_SL_N
argument_list|,
name|sc
operator|->
name|swsl_tail
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sc
operator|->
name|swsl_size
operator|++
expr_stmt|;
name|DBG
argument_list|(
name|sc
argument_list|,
name|INTR
argument_list|,
operator|(
literal|"added VCI %d to swslist"
operator|,
name|vci
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|need_softserv
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Handle a receive DMA completion  */
end_comment

begin_function
specifier|static
name|void
name|en_rx_drain
parameter_list|(
name|struct
name|en_softc
modifier|*
name|sc
parameter_list|,
name|u_int
name|drq
parameter_list|)
block|{
name|struct
name|en_rxslot
modifier|*
name|slot
decl_stmt|;
name|struct
name|en_vcc
modifier|*
name|vc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|atm_pseudohdr
name|ah
decl_stmt|;
name|slot
operator|=
operator|&
name|sc
operator|->
name|rxslot
index|[
name|EN_DQ_SLOT
argument_list|(
name|drq
argument_list|)
index|]
expr_stmt|;
name|m
operator|=
name|NULL
expr_stmt|;
comment|/* assume "JK" trash DMA */
if|if
condition|(
name|EN_DQ_LEN
argument_list|(
name|drq
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|_IF_DEQUEUE
argument_list|(
operator|&
name|slot
operator|->
name|indma
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|m
operator|!=
name|NULL
argument_list|,
operator|(
literal|"drqsync: %s: lost mbuf in slot %td!"
operator|,
name|sc
operator|->
name|ifp
operator|->
name|if_xname
operator|,
name|slot
operator|-
name|sc
operator|->
name|rxslot
operator|)
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|sc
operator|->
name|map_zone
argument_list|,
operator|(
expr|struct
name|en_map
operator|*
operator|)
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|vc
operator|=
name|slot
operator|->
name|vcc
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* ups */
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* do something with this mbuf */
if|if
condition|(
name|vc
operator|->
name|vflags
operator|&
name|VCC_DRAIN
condition|)
block|{
comment|/* drain? */
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|_IF_QLEN
argument_list|(
operator|&
name|slot
operator|->
name|indma
argument_list|)
operator|==
literal|0
operator|&&
name|_IF_QLEN
argument_list|(
operator|&
name|slot
operator|->
name|q
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|en_read
argument_list|(
name|sc
argument_list|,
name|MID_VC
argument_list|(
name|vc
operator|->
name|vcc
operator|.
name|vci
argument_list|)
argument_list|)
operator|&
name|MIDV_INSERVICE
operator|)
operator|==
literal|0
operator|&&
operator|(
name|vc
operator|->
name|vflags
operator|&
name|VCC_SWSL
operator|)
operator|==
literal|0
condition|)
block|{
name|vc
operator|->
name|vflags
operator|&=
operator|~
name|VCC_CLOSE_RX
expr_stmt|;
if|if
condition|(
name|vc
operator|->
name|vcc
operator|.
name|flags
operator|&
name|ATMIO_FLAG_ASYNC
condition|)
name|en_close_finish
argument_list|(
name|sc
argument_list|,
name|vc
argument_list|)
expr_stmt|;
else|else
name|cv_signal
argument_list|(
operator|&
name|sc
operator|->
name|cv_close
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
name|ATM_PH_FLAGS
argument_list|(
operator|&
name|ah
argument_list|)
operator|=
name|vc
operator|->
name|vcc
operator|.
name|flags
expr_stmt|;
name|ATM_PH_VPI
argument_list|(
operator|&
name|ah
argument_list|)
operator|=
literal|0
expr_stmt|;
name|ATM_PH_SETVCI
argument_list|(
operator|&
name|ah
argument_list|,
name|vc
operator|->
name|vcc
operator|.
name|vci
argument_list|)
expr_stmt|;
name|DBG
argument_list|(
name|sc
argument_list|,
name|INTR
argument_list|,
operator|(
literal|"rx%td: rxvci%d: atm_input, mbuf %p, len %d, "
literal|"hand %p"
operator|,
name|slot
operator|-
name|sc
operator|->
name|rxslot
operator|,
name|vc
operator|->
name|vcc
operator|.
name|vci
operator|,
name|m
operator|,
name|EN_DQ_LEN
argument_list|(
name|drq
argument_list|)
operator|,
name|vc
operator|->
name|rxhand
operator|)
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|sc
operator|->
name|ifp
expr_stmt|;
name|sc
operator|->
name|ifp
operator|->
name|if_ipackets
operator|++
expr_stmt|;
name|vc
operator|->
name|ipackets
operator|++
expr_stmt|;
name|vc
operator|->
name|ibytes
operator|+=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
ifdef|#
directive|ifdef
name|EN_DEBUG
if|if
condition|(
name|sc
operator|->
name|debug
operator|&
name|DBG_IPACKETS
condition|)
name|en_dump_packet
argument_list|(
name|sc
argument_list|,
name|m
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ENABLE_BPF
name|BPF_MTAP
argument_list|(
name|sc
operator|->
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|EN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|atm_input
argument_list|(
name|sc
operator|->
name|ifp
argument_list|,
operator|&
name|ah
argument_list|,
name|m
argument_list|,
name|vc
operator|->
name|rxhand
argument_list|)
expr_stmt|;
name|EN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * check for RX DMA complete, and pass the data "upstairs"  *  * LOCK: locked, needed  */
end_comment

begin_function
specifier|static
name|int
name|en_intr_rx_dma
parameter_list|(
name|struct
name|en_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|val
decl_stmt|;
name|uint32_t
name|idx
decl_stmt|;
name|uint32_t
name|drq
decl_stmt|;
name|val
operator|=
name|en_read
argument_list|(
name|sc
argument_list|,
name|MID_DMA_RDRX
argument_list|)
expr_stmt|;
comment|/* chip's current location */
name|idx
operator|=
name|MID_DRQ_A2REG
argument_list|(
name|sc
operator|->
name|drq_chip
argument_list|)
expr_stmt|;
comment|/* where we last saw chip */
while|while
condition|(
name|idx
operator|!=
name|val
condition|)
block|{
name|sc
operator|->
name|drq_free
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|drq
operator|=
name|sc
operator|->
name|drq
index|[
name|idx
index|]
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* don't forget to zero it out when done */
name|sc
operator|->
name|drq
index|[
name|idx
index|]
operator|=
literal|0
expr_stmt|;
name|en_rx_drain
argument_list|(
name|sc
argument_list|,
name|drq
argument_list|)
expr_stmt|;
block|}
name|EN_WRAPADD
argument_list|(
literal|0
argument_list|,
name|MID_DRQ_N
argument_list|,
name|idx
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|drq_chip
operator|=
name|MID_DRQ_REG2A
argument_list|(
name|val
argument_list|)
expr_stmt|;
comment|/* sync softc */
if|if
condition|(
name|sc
operator|->
name|need_drqs
condition|)
block|{
comment|/* true if we had a DRQ shortage */
name|sc
operator|->
name|need_drqs
operator|=
literal|0
expr_stmt|;
name|DBG
argument_list|(
name|sc
argument_list|,
name|INTR
argument_list|,
operator|(
literal|"cleared need DRQ condition"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * en_mget: get an mbuf chain that can hold totlen bytes and return it  * (for recv). For the actual allocation totlen is rounded up to a multiple  * of 4. We also ensure, that each mbuf has a multiple of 4 bytes.  *  * After this call the sum of all the m_len's in the chain will be totlen.  * This is called at interrupt time, so we can't wait here.  *  * LOCK: any, not needed  */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|en_mget
parameter_list|(
name|struct
name|en_softc
modifier|*
name|sc
parameter_list|,
name|u_int
name|pktlen
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|u_int
name|totlen
decl_stmt|,
name|pad
decl_stmt|;
name|totlen
operator|=
name|roundup
argument_list|(
name|pktlen
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
name|pad
operator|=
name|totlen
operator|-
name|pktlen
expr_stmt|;
comment|/* 	 * First get an mbuf with header. Keep space for a couple of 	 * words at the begin. 	 */
comment|/* called from interrupt context */
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|NULL
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|pktlen
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|EN_RX1BUF
expr_stmt|;
name|MH_ALIGN
argument_list|(
name|m
argument_list|,
name|EN_RX1BUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|>=
name|totlen
condition|)
block|{
name|m
operator|->
name|m_len
operator|=
name|totlen
expr_stmt|;
block|}
else|else
block|{
name|totlen
operator|-=
name|m
operator|->
name|m_len
expr_stmt|;
comment|/* called from interrupt context */
name|tmp
operator|=
name|m_getm
argument_list|(
name|m
argument_list|,
name|totlen
argument_list|,
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
name|NULL
condition|)
block|{
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|tmp
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
comment|/* m_getm could do this for us */
while|while
condition|(
name|tmp
operator|!=
name|NULL
condition|)
block|{
name|tmp
operator|->
name|m_len
operator|=
name|min
argument_list|(
name|MCLBYTES
argument_list|,
name|totlen
argument_list|)
expr_stmt|;
name|totlen
operator|-=
name|tmp
operator|->
name|m_len
expr_stmt|;
name|tmp
operator|=
name|tmp
operator|->
name|m_next
expr_stmt|;
block|}
block|}
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Argument for RX DMAMAP loader.  */
end_comment

begin_struct
struct|struct
name|rxarg
block|{
name|struct
name|en_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|u_int
name|pre_skip
decl_stmt|;
comment|/* number of bytes to skip at begin */
name|u_int
name|post_skip
decl_stmt|;
comment|/* number of bytes to skip at end */
name|struct
name|en_vcc
modifier|*
name|vc
decl_stmt|;
comment|/* vc we are receiving on */
name|int
name|wait
decl_stmt|;
comment|/* wait for DRQ entries */
block|}
struct|;
end_struct

begin_comment
comment|/*  * Copy the segment table to the buffer for later use. And compute the  * number of dma queue entries we need.  *  * LOCK: locked, needed  */
end_comment

begin_function
specifier|static
name|void
name|en_rxdma_load
parameter_list|(
name|void
modifier|*
name|uarg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|bus_size_t
name|mapsize
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|rxarg
modifier|*
name|rx
init|=
name|uarg
decl_stmt|;
name|struct
name|en_softc
modifier|*
name|sc
init|=
name|rx
operator|->
name|sc
decl_stmt|;
name|struct
name|en_rxslot
modifier|*
name|slot
init|=
name|rx
operator|->
name|vc
operator|->
name|rxslot
decl_stmt|;
name|u_int
name|free
decl_stmt|;
comment|/* number of free DRQ entries */
name|uint32_t
name|cur
decl_stmt|;
comment|/* current buffer offset */
name|uint32_t
name|drq
decl_stmt|;
comment|/* DRQ entry pointer */
name|uint32_t
name|last_drq
decl_stmt|;
comment|/* where we have written last */
name|u_int
name|needalign
decl_stmt|,
name|cnt
decl_stmt|,
name|count
decl_stmt|,
name|bcode
decl_stmt|;
name|bus_addr_t
name|addr
decl_stmt|;
name|bus_size_t
name|rest
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return;
if|if
condition|(
name|nseg
operator|>
name|EN_MAX_DMASEG
condition|)
name|panic
argument_list|(
literal|"too many DMA segments"
argument_list|)
expr_stmt|;
name|rx
operator|->
name|wait
operator|=
literal|0
expr_stmt|;
name|free
operator|=
name|sc
operator|->
name|drq_free
expr_stmt|;
name|drq
operator|=
name|sc
operator|->
name|drq_us
expr_stmt|;
name|cur
operator|=
name|slot
operator|->
name|cur
expr_stmt|;
name|last_drq
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Local macro to add an entry to the receive DMA area. If there 	 * are no entries left, return. Save the byte offset of the entry 	 * in last_drq for later use. 	 */
define|#
directive|define
name|PUT_DRQ_ENTRY
parameter_list|(
name|ENI
parameter_list|,
name|BCODE
parameter_list|,
name|COUNT
parameter_list|,
name|ADDR
parameter_list|)
define|\
value|if (free == 0) {						\ 		EN_COUNT(sc->stats.rxdrqout);				\ 		rx->wait = 1;						\ 		return;							\ 	}								\ 	last_drq = drq;							\ 	en_write(sc, drq + 0, (ENI || !sc->is_adaptec) ?		\ 	    MID_MK_RXQ_ENI(COUNT, rx->vc->vcc.vci, 0, BCODE) :		\ 	    MID_MK_RXQ_ADP(COUNT, rx->vc->vcc.vci, 0, BCODE));		\ 	en_write(sc, drq + 4, ADDR);					\ 									\ 	EN_WRAPADD(MID_DRQOFF, MID_DRQEND, drq, 8);			\ 	free--;
comment|/* 	 * Local macro to generate a DMA entry to DMA cnt bytes. Updates 	 * the current buffer byte offset accordingly. 	 */
define|#
directive|define
name|DO_DRQ
parameter_list|(
name|TYPE
parameter_list|)
value|do {						\ 	rest -= cnt;							\ 	EN_WRAPADD(slot->start, slot->stop, cur, cnt);			\ 	DBG(sc, SERV, ("rx%td: "TYPE" %u bytes, %ju left, cur %#x",	\ 	    slot - sc->rxslot, cnt, (uintmax_t)rest, cur));		\ 									\ 	PUT_DRQ_ENTRY(1, bcode, count, addr);				\ 									\ 	addr += cnt;							\     } while (0)
comment|/* 	 * Skip the RBD at the beginning 	 */
if|if
condition|(
name|rx
operator|->
name|pre_skip
operator|>
literal|0
condition|)
block|{
comment|/* update DMA address */
name|EN_WRAPADD
argument_list|(
name|slot
operator|->
name|start
argument_list|,
name|slot
operator|->
name|stop
argument_list|,
name|cur
argument_list|,
name|rx
operator|->
name|pre_skip
argument_list|)
expr_stmt|;
name|PUT_DRQ_ENTRY
argument_list|(
literal|0
argument_list|,
name|MIDDMA_JK
argument_list|,
name|WORD_IDX
argument_list|(
name|slot
operator|->
name|start
argument_list|,
name|cur
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nseg
condition|;
name|i
operator|++
operator|,
name|segs
operator|++
control|)
block|{
name|addr
operator|=
name|segs
operator|->
name|ds_addr
expr_stmt|;
name|rest
operator|=
name|segs
operator|->
name|ds_len
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|is_adaptec
condition|)
block|{
comment|/* adaptec card - simple */
comment|/* advance the on-card buffer pointer */
name|EN_WRAPADD
argument_list|(
name|slot
operator|->
name|start
argument_list|,
name|slot
operator|->
name|stop
argument_list|,
name|cur
argument_list|,
name|rest
argument_list|)
expr_stmt|;
name|DBG
argument_list|(
name|sc
argument_list|,
name|SERV
argument_list|,
operator|(
literal|"rx%td: adp %ju bytes %#jx "
literal|"(cur now 0x%x)"
operator|,
name|slot
operator|-
name|sc
operator|->
name|rxslot
operator|,
operator|(
name|uintmax_t
operator|)
name|rest
operator|,
operator|(
name|uintmax_t
operator|)
name|addr
operator|,
name|cur
operator|)
argument_list|)
expr_stmt|;
name|PUT_DRQ_ENTRY
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|rest
argument_list|,
name|addr
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * do we need to do a DMA op to align to the maximum 		 * burst? Note, that we are alway 32-bit aligned. 		 */
if|if
condition|(
name|sc
operator|->
name|alburst
operator|&&
operator|(
name|needalign
operator|=
operator|(
name|addr
operator|&
name|sc
operator|->
name|bestburstmask
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* compute number of bytes, words and code */
name|cnt
operator|=
name|sc
operator|->
name|bestburstlen
operator|-
name|needalign
expr_stmt|;
if|if
condition|(
name|cnt
operator|>
name|rest
condition|)
name|cnt
operator|=
name|rest
expr_stmt|;
name|count
operator|=
name|cnt
operator|/
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|noalbursts
condition|)
block|{
name|bcode
operator|=
name|MIDDMA_WORD
expr_stmt|;
block|}
else|else
block|{
name|bcode
operator|=
name|en_dmaplan
index|[
name|count
index|]
operator|.
name|bcode
expr_stmt|;
name|count
operator|=
name|cnt
operator|>>
name|en_dmaplan
index|[
name|count
index|]
operator|.
name|divshift
expr_stmt|;
block|}
name|DO_DRQ
argument_list|(
literal|"al_dma"
argument_list|)
expr_stmt|;
block|}
comment|/* do we need to do a max-sized burst? */
if|if
condition|(
name|rest
operator|>=
name|sc
operator|->
name|bestburstlen
condition|)
block|{
name|count
operator|=
name|rest
operator|>>
name|sc
operator|->
name|bestburstshift
expr_stmt|;
name|cnt
operator|=
name|count
operator|<<
name|sc
operator|->
name|bestburstshift
expr_stmt|;
name|bcode
operator|=
name|sc
operator|->
name|bestburstcode
expr_stmt|;
name|DO_DRQ
argument_list|(
literal|"best_dma"
argument_list|)
expr_stmt|;
block|}
comment|/* do we need to do a cleanup burst? */
if|if
condition|(
name|rest
operator|!=
literal|0
condition|)
block|{
name|cnt
operator|=
name|rest
expr_stmt|;
name|count
operator|=
name|rest
operator|/
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|noalbursts
condition|)
block|{
name|bcode
operator|=
name|MIDDMA_WORD
expr_stmt|;
block|}
else|else
block|{
name|bcode
operator|=
name|en_dmaplan
index|[
name|count
index|]
operator|.
name|bcode
expr_stmt|;
name|count
operator|=
name|cnt
operator|>>
name|en_dmaplan
index|[
name|count
index|]
operator|.
name|divshift
expr_stmt|;
block|}
name|DO_DRQ
argument_list|(
literal|"clean_dma"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Skip stuff at the end 	 */
if|if
condition|(
name|rx
operator|->
name|post_skip
operator|>
literal|0
condition|)
block|{
comment|/* update DMA address */
name|EN_WRAPADD
argument_list|(
name|slot
operator|->
name|start
argument_list|,
name|slot
operator|->
name|stop
argument_list|,
name|cur
argument_list|,
name|rx
operator|->
name|post_skip
argument_list|)
expr_stmt|;
name|PUT_DRQ_ENTRY
argument_list|(
literal|0
argument_list|,
name|MIDDMA_JK
argument_list|,
name|WORD_IDX
argument_list|(
name|slot
operator|->
name|start
argument_list|,
name|cur
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* record the end for the interrupt routine */
name|sc
operator|->
name|drq
index|[
name|MID_DRQ_A2REG
argument_list|(
name|last_drq
argument_list|)
index|]
operator|=
name|EN_DQ_MK
argument_list|(
name|slot
operator|-
name|sc
operator|->
name|rxslot
argument_list|,
name|rx
operator|->
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
comment|/* set the end flag in the last descriptor */
name|en_write
argument_list|(
name|sc
argument_list|,
name|last_drq
operator|+
literal|0
argument_list|,
name|SETQ_END
argument_list|(
name|sc
argument_list|,
name|en_read
argument_list|(
name|sc
argument_list|,
name|last_drq
operator|+
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|PUT_DRQ_ENTRY
undef|#
directive|undef
name|DO_DRQ
comment|/* commit */
name|slot
operator|->
name|cur
operator|=
name|cur
expr_stmt|;
name|sc
operator|->
name|drq_free
operator|=
name|free
expr_stmt|;
name|sc
operator|->
name|drq_us
operator|=
name|drq
expr_stmt|;
comment|/* signal to card */
name|en_write
argument_list|(
name|sc
argument_list|,
name|MID_DMA_WRRX
argument_list|,
name|MID_DRQ_A2REG
argument_list|(
name|sc
operator|->
name|drq_us
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * en_service: handle a service interrupt  *  * Q: why do we need a software service list?  *  * A: if we remove a VCI from the hardware list and we find that we are  *    out of DRQs we must defer processing until some DRQs become free.  *    so we must remember to look at this RX VCI/slot later, but we can't  *    put it back on the hardware service list (since that isn't allowed).  *    so we instead save it on the software service list.   it would be nice   *    if we could peek at the VCI on top of the hwservice list without removing  *    it, however this leads to a race condition: if we peek at it and  *    decide we are done with it new data could come in before we have a   *    chance to remove it from the hwslist.   by the time we get it out of  *    the list the interrupt for the new data will be lost.   oops!  *  * LOCK: locked, needed  */
end_comment

begin_function
specifier|static
name|void
name|en_service
parameter_list|(
name|struct
name|en_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|lastm
decl_stmt|;
name|struct
name|en_map
modifier|*
name|map
decl_stmt|;
name|struct
name|rxarg
name|rx
decl_stmt|;
name|uint32_t
name|cur
decl_stmt|;
name|uint32_t
name|dstart
decl_stmt|;
comment|/* data start (as reported by card) */
name|uint32_t
name|rbd
decl_stmt|;
comment|/* receive buffer descriptor */
name|uint32_t
name|pdu
decl_stmt|;
comment|/* AAL5 trailer */
name|int
name|mlen
decl_stmt|;
name|int
name|error
decl_stmt|;
name|struct
name|en_rxslot
modifier|*
name|slot
decl_stmt|;
name|struct
name|en_vcc
modifier|*
name|vc
decl_stmt|;
name|rx
operator|.
name|sc
operator|=
name|sc
expr_stmt|;
name|next_vci
label|:
if|if
condition|(
name|sc
operator|->
name|swsl_size
operator|==
literal|0
condition|)
block|{
name|DBG
argument_list|(
name|sc
argument_list|,
name|SERV
argument_list|,
operator|(
literal|"en_service done"
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * get vcc to service 	 */
name|rx
operator|.
name|vc
operator|=
name|vc
operator|=
name|sc
operator|->
name|vccs
index|[
name|sc
operator|->
name|swslist
index|[
name|sc
operator|->
name|swsl_head
index|]
index|]
expr_stmt|;
name|slot
operator|=
name|vc
operator|->
name|rxslot
expr_stmt|;
name|KASSERT
argument_list|(
name|slot
operator|->
name|vcc
operator|->
name|rxslot
operator|==
name|slot
argument_list|,
operator|(
literal|"en_service: rx slot/vci sync"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * determine our mode and if we've got any work to do 	 */
name|DBG
argument_list|(
name|sc
argument_list|,
name|SERV
argument_list|,
operator|(
literal|"rx%td: service vci=%d start/stop/cur=0x%x 0x%x "
literal|"0x%x"
operator|,
name|slot
operator|-
name|sc
operator|->
name|rxslot
operator|,
name|vc
operator|->
name|vcc
operator|.
name|vci
operator|,
name|slot
operator|->
name|start
operator|,
name|slot
operator|->
name|stop
operator|,
name|slot
operator|->
name|cur
operator|)
argument_list|)
expr_stmt|;
name|same_vci
label|:
name|cur
operator|=
name|slot
operator|->
name|cur
expr_stmt|;
name|dstart
operator|=
name|MIDV_DSTART
argument_list|(
name|en_read
argument_list|(
name|sc
argument_list|,
name|MID_DST_RP
argument_list|(
name|vc
operator|->
name|vcc
operator|.
name|vci
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|dstart
operator|=
operator|(
name|dstart
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
operator|+
name|slot
operator|->
name|start
expr_stmt|;
comment|/* check to see if there is any data at all */
if|if
condition|(
name|dstart
operator|==
name|cur
condition|)
block|{
name|EN_WRAPADD
argument_list|(
literal|0
argument_list|,
name|MID_SL_N
argument_list|,
name|sc
operator|->
name|swsl_head
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* remove from swslist */
name|vc
operator|->
name|vflags
operator|&=
operator|~
name|VCC_SWSL
expr_stmt|;
name|sc
operator|->
name|swsl_size
operator|--
expr_stmt|;
name|DBG
argument_list|(
name|sc
argument_list|,
name|SERV
argument_list|,
operator|(
literal|"rx%td: remove vci %d from swslist"
operator|,
name|slot
operator|-
name|sc
operator|->
name|rxslot
operator|,
name|vc
operator|->
name|vcc
operator|.
name|vci
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|next_vci
goto|;
block|}
comment|/* 	 * figure out how many bytes we need 	 * [mlen = # bytes to go in mbufs] 	 */
name|rbd
operator|=
name|en_read
argument_list|(
name|sc
argument_list|,
name|cur
argument_list|)
expr_stmt|;
if|if
condition|(
name|MID_RBD_ID
argument_list|(
name|rbd
argument_list|)
operator|!=
name|MID_RBD_STDID
condition|)
name|panic
argument_list|(
literal|"en_service: id mismatch"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rbd
operator|&
name|MID_RBD_T
condition|)
block|{
name|mlen
operator|=
literal|0
expr_stmt|;
comment|/* we've got trash */
name|rx
operator|.
name|pre_skip
operator|=
name|MID_RBD_SIZE
expr_stmt|;
name|rx
operator|.
name|post_skip
operator|=
literal|0
expr_stmt|;
name|EN_COUNT
argument_list|(
name|sc
operator|->
name|stats
operator|.
name|ttrash
argument_list|)
expr_stmt|;
name|DBG
argument_list|(
name|sc
argument_list|,
name|SERV
argument_list|,
operator|(
literal|"RX overflow lost %d cells!"
operator|,
name|MID_RBD_CNT
argument_list|(
name|rbd
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vc
operator|->
name|vcc
operator|.
name|aal
operator|!=
name|ATMIO_AAL_5
condition|)
block|{
comment|/* 1 cell (ick!) */
name|mlen
operator|=
name|MID_CHDR_SIZE
operator|+
name|MID_ATMDATASZ
expr_stmt|;
name|rx
operator|.
name|pre_skip
operator|=
name|MID_RBD_SIZE
expr_stmt|;
name|rx
operator|.
name|post_skip
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|rx
operator|.
name|pre_skip
operator|=
name|MID_RBD_SIZE
expr_stmt|;
comment|/* get PDU trailer in correct byte order */
name|pdu
operator|=
name|cur
operator|+
name|MID_RBD_CNT
argument_list|(
name|rbd
argument_list|)
operator|*
name|MID_ATMDATASZ
operator|+
name|MID_RBD_SIZE
operator|-
name|MID_PDU_SIZE
expr_stmt|;
if|if
condition|(
name|pdu
operator|>=
name|slot
operator|->
name|stop
condition|)
name|pdu
operator|-=
name|EN_RXSZ
operator|*
literal|1024
expr_stmt|;
name|pdu
operator|=
name|en_read
argument_list|(
name|sc
argument_list|,
name|pdu
argument_list|)
expr_stmt|;
if|if
condition|(
name|MID_RBD_CNT
argument_list|(
name|rbd
argument_list|)
operator|*
name|MID_ATMDATASZ
operator|<
name|MID_PDU_LEN
argument_list|(
name|pdu
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"invalid AAL5 length\n"
argument_list|)
expr_stmt|;
name|rx
operator|.
name|post_skip
operator|=
name|MID_RBD_CNT
argument_list|(
name|rbd
argument_list|)
operator|*
name|MID_ATMDATASZ
expr_stmt|;
name|mlen
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rbd
operator|&
name|MID_RBD_CRCERR
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"CRC error\n"
argument_list|)
expr_stmt|;
name|rx
operator|.
name|post_skip
operator|=
name|MID_RBD_CNT
argument_list|(
name|rbd
argument_list|)
operator|*
name|MID_ATMDATASZ
expr_stmt|;
name|mlen
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
block|}
else|else
block|{
name|mlen
operator|=
name|MID_PDU_LEN
argument_list|(
name|pdu
argument_list|)
expr_stmt|;
name|rx
operator|.
name|post_skip
operator|=
name|MID_RBD_CNT
argument_list|(
name|rbd
argument_list|)
operator|*
name|MID_ATMDATASZ
operator|-
name|mlen
expr_stmt|;
block|}
block|}
comment|/* 	 * now allocate mbufs for mlen bytes of data, if out of mbufs, trash all 	 * 	 * notes: 	 *  1. it is possible that we've already allocated an mbuf for this pkt 	 *     but ran out of DRQs, in which case we saved the allocated mbuf 	 *     on "q". 	 *  2. if we save an buf in "q" we store the "cur" (pointer) in the 	 *     buf as an identity (that we can check later). 	 *  3. after this block of code, if m is still NULL then we ran out of 	 *     mbufs 	 */
name|_IF_DEQUEUE
argument_list|(
operator|&
name|slot
operator|->
name|q
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|!=
name|cur
condition|)
block|{
comment|/* wasn't ours */
name|DBG
argument_list|(
name|sc
argument_list|,
name|SERV
argument_list|,
operator|(
literal|"rx%td: q'ed buf %p not ours"
operator|,
name|slot
operator|-
name|sc
operator|->
name|rxslot
operator|,
name|m
operator|)
argument_list|)
expr_stmt|;
name|_IF_PREPEND
argument_list|(
operator|&
name|slot
operator|->
name|q
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
name|NULL
expr_stmt|;
name|EN_COUNT
argument_list|(
name|sc
operator|->
name|stats
operator|.
name|rxqnotus
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|EN_COUNT
argument_list|(
name|sc
operator|->
name|stats
operator|.
name|rxqus
argument_list|)
expr_stmt|;
name|DBG
argument_list|(
name|sc
argument_list|,
name|SERV
argument_list|,
operator|(
literal|"rx%td: recovered q'ed buf %p"
operator|,
name|slot
operator|-
name|sc
operator|->
name|rxslot
operator|,
name|m
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mlen
operator|==
literal|0
operator|&&
name|m
operator|!=
name|NULL
condition|)
block|{
comment|/* should not happen */
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|mlen
operator|!=
literal|0
operator|&&
name|m
operator|==
name|NULL
condition|)
block|{
name|m
operator|=
name|en_mget
argument_list|(
name|sc
argument_list|,
name|mlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|rx
operator|.
name|post_skip
operator|+=
name|mlen
expr_stmt|;
name|mlen
operator|=
literal|0
expr_stmt|;
name|EN_COUNT
argument_list|(
name|sc
operator|->
name|stats
operator|.
name|rxmbufout
argument_list|)
expr_stmt|;
name|DBG
argument_list|(
name|sc
argument_list|,
name|SERV
argument_list|,
operator|(
literal|"rx%td: out of mbufs"
operator|,
name|slot
operator|-
name|sc
operator|->
name|rxslot
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
name|rx
operator|.
name|post_skip
operator|-=
name|roundup
argument_list|(
name|mlen
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
operator|-
name|mlen
expr_stmt|;
name|DBG
argument_list|(
name|sc
argument_list|,
name|SERV
argument_list|,
operator|(
literal|"rx%td: allocate buf %p, mlen=%d"
operator|,
name|slot
operator|-
name|sc
operator|->
name|rxslot
operator|,
name|m
operator|,
name|mlen
operator|)
argument_list|)
expr_stmt|;
block|}
name|DBG
argument_list|(
name|sc
argument_list|,
name|SERV
argument_list|,
operator|(
literal|"rx%td: VCI %d, rbuf %p, mlen %d, skip %u/%u"
operator|,
name|slot
operator|-
name|sc
operator|->
name|rxslot
operator|,
name|vc
operator|->
name|vcc
operator|.
name|vci
operator|,
name|m
operator|,
name|mlen
operator|,
name|rx
operator|.
name|pre_skip
operator|,
name|rx
operator|.
name|post_skip
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
comment|/* M_NOWAIT - called from interrupt context */
name|map
operator|=
name|uma_zalloc_arg
argument_list|(
name|sc
operator|->
name|map_zone
argument_list|,
name|sc
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|map
operator|==
name|NULL
condition|)
block|{
name|rx
operator|.
name|post_skip
operator|+=
name|mlen
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|DBG
argument_list|(
name|sc
argument_list|,
name|SERV
argument_list|,
operator|(
literal|"rx%td: out of maps"
operator|,
name|slot
operator|-
name|sc
operator|->
name|rxslot
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|skip
goto|;
block|}
name|rx
operator|.
name|m
operator|=
name|m
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load_mbuf
argument_list|(
name|sc
operator|->
name|txtag
argument_list|,
name|map
operator|->
name|map
argument_list|,
name|m
argument_list|,
name|en_rxdma_load
argument_list|,
operator|&
name|rx
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"loading RX map failed "
literal|"%d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|sc
operator|->
name|map_zone
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|rx
operator|.
name|post_skip
operator|+=
name|mlen
expr_stmt|;
goto|goto
name|skip
goto|;
block|}
name|map
operator|->
name|flags
operator||=
name|ENMAP_LOADED
expr_stmt|;
if|if
condition|(
name|rx
operator|.
name|wait
condition|)
block|{
comment|/* out of DRQs - wait */
name|uma_zfree
argument_list|(
name|sc
operator|->
name|map_zone
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|=
name|cur
expr_stmt|;
name|_IF_ENQUEUE
argument_list|(
operator|&
name|slot
operator|->
name|q
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|EN_COUNT
argument_list|(
name|sc
operator|->
name|stats
operator|.
name|rxdrqout
argument_list|)
expr_stmt|;
name|sc
operator|->
name|need_drqs
operator|=
literal|1
expr_stmt|;
comment|/* flag condition */
return|return;
block|}
operator|(
name|void
operator|)
name|m_length
argument_list|(
name|m
argument_list|,
operator|&
name|lastm
argument_list|)
expr_stmt|;
name|lastm
operator|->
name|m_len
operator|-=
name|roundup
argument_list|(
name|mlen
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
operator|-
name|mlen
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
operator|(
name|void
operator|*
operator|)
name|map
expr_stmt|;
name|_IF_ENQUEUE
argument_list|(
operator|&
name|slot
operator|->
name|indma
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* get next packet in this slot */
goto|goto
name|same_vci
goto|;
block|}
name|skip
label|:
comment|/* 	 * Here we end if we should drop the packet from the receive buffer. 	 * The number of bytes to drop is in fill. We can do this with on 	 * JK entry. If we don't even have that one - wait. 	 */
if|if
condition|(
name|sc
operator|->
name|drq_free
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|need_drqs
operator|=
literal|1
expr_stmt|;
comment|/* flag condition */
return|return;
block|}
name|rx
operator|.
name|post_skip
operator|+=
name|rx
operator|.
name|pre_skip
expr_stmt|;
name|DBG
argument_list|(
name|sc
argument_list|,
name|SERV
argument_list|,
operator|(
literal|"rx%td: skipping %u"
operator|,
name|slot
operator|-
name|sc
operator|->
name|rxslot
operator|,
name|rx
operator|.
name|post_skip
operator|)
argument_list|)
expr_stmt|;
comment|/* advance buffer address */
name|EN_WRAPADD
argument_list|(
name|slot
operator|->
name|start
argument_list|,
name|slot
operator|->
name|stop
argument_list|,
name|cur
argument_list|,
name|rx
operator|.
name|post_skip
argument_list|)
expr_stmt|;
comment|/* write DRQ entry */
if|if
condition|(
name|sc
operator|->
name|is_adaptec
condition|)
name|en_write
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|drq_us
argument_list|,
name|MID_MK_RXQ_ADP
argument_list|(
name|WORD_IDX
argument_list|(
name|slot
operator|->
name|start
argument_list|,
name|cur
argument_list|)
argument_list|,
name|vc
operator|->
name|vcc
operator|.
name|vci
argument_list|,
name|MID_DMA_END
argument_list|,
name|MIDDMA_JK
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|en_write
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|drq_us
argument_list|,
name|MID_MK_RXQ_ENI
argument_list|(
name|WORD_IDX
argument_list|(
name|slot
operator|->
name|start
argument_list|,
name|cur
argument_list|)
argument_list|,
name|vc
operator|->
name|vcc
operator|.
name|vci
argument_list|,
name|MID_DMA_END
argument_list|,
name|MIDDMA_JK
argument_list|)
argument_list|)
expr_stmt|;
name|en_write
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|drq_us
operator|+
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|EN_WRAPADD
argument_list|(
name|MID_DRQOFF
argument_list|,
name|MID_DRQEND
argument_list|,
name|sc
operator|->
name|drq_us
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|sc
operator|->
name|drq_free
operator|--
expr_stmt|;
comment|/* signal to RX interrupt */
name|sc
operator|->
name|drq
index|[
name|MID_DRQ_A2REG
argument_list|(
name|sc
operator|->
name|drq_us
argument_list|)
index|]
operator|=
name|EN_DQ_MK
argument_list|(
name|slot
operator|-
name|sc
operator|->
name|rxslot
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|slot
operator|->
name|cur
operator|=
name|cur
expr_stmt|;
comment|/* signal to card */
name|en_write
argument_list|(
name|sc
argument_list|,
name|MID_DMA_WRRX
argument_list|,
name|MID_DRQ_A2REG
argument_list|(
name|sc
operator|->
name|drq_us
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|same_vci
goto|;
block|}
end_function

begin_comment
comment|/*  * interrupt handler  *  * LOCK: unlocked, needed  */
end_comment

begin_function
name|void
name|en_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|en_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|uint32_t
name|reg
decl_stmt|,
name|kick
decl_stmt|,
name|mask
decl_stmt|;
name|int
name|lcv
decl_stmt|,
name|need_softserv
decl_stmt|;
name|EN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|reg
operator|=
name|en_read
argument_list|(
name|sc
argument_list|,
name|MID_INTACK
argument_list|)
expr_stmt|;
name|DBG
argument_list|(
name|sc
argument_list|,
name|INTR
argument_list|,
operator|(
literal|"interrupt=0x%b"
operator|,
name|reg
operator|,
name|MID_INTBITS
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|reg
operator|&
name|MID_INT_ANY
operator|)
operator|==
literal|0
condition|)
block|{
name|EN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * unexpected errors that need a reset 	 */
if|if
condition|(
operator|(
name|reg
operator|&
operator|(
name|MID_INT_IDENT
operator||
name|MID_INT_LERR
operator||
name|MID_INT_DMA_ERR
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"unexpected interrupt=0x%b, "
literal|"resetting\n"
argument_list|,
name|reg
argument_list|,
name|MID_INTBITS
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EN_DEBUG
name|panic
argument_list|(
literal|"en: unexpected error"
argument_list|)
expr_stmt|;
else|#
directive|else
name|en_reset_ul
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|en_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|EN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|reg
operator|&
name|MID_INT_SUNI
condition|)
name|utopia_intr
argument_list|(
operator|&
name|sc
operator|->
name|utopia
argument_list|)
expr_stmt|;
name|kick
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|reg
operator|&
name|MID_INT_TX
condition|)
name|kick
operator||=
name|en_intr_tx
argument_list|(
name|sc
argument_list|,
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|&
name|MID_INT_DMA_TX
condition|)
name|kick
operator||=
name|en_intr_tx_dma
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * kick xmit channels as needed. 	 */
if|if
condition|(
name|kick
condition|)
block|{
name|DBG
argument_list|(
name|sc
argument_list|,
name|INTR
argument_list|,
operator|(
literal|"tx kick mask = 0x%x"
operator|,
name|kick
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|mask
operator|=
literal|1
operator|,
name|lcv
operator|=
literal|0
init|;
name|lcv
operator|<
name|EN_NTX
condition|;
name|lcv
operator|++
operator|,
name|mask
operator|=
name|mask
operator|*
literal|2
control|)
if|if
condition|(
operator|(
name|kick
operator|&
name|mask
operator|)
operator|&&
name|_IF_QLEN
argument_list|(
operator|&
name|sc
operator|->
name|txslot
index|[
name|lcv
index|]
operator|.
name|q
argument_list|)
operator|!=
literal|0
condition|)
name|en_txdma
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|txslot
index|[
name|lcv
index|]
argument_list|)
expr_stmt|;
block|}
name|need_softserv
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|reg
operator|&
name|MID_INT_DMA_RX
condition|)
name|need_softserv
operator||=
name|en_intr_rx_dma
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|&
name|MID_INT_SERVICE
condition|)
name|need_softserv
operator||=
name|en_intr_service
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|need_softserv
condition|)
name|en_service
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * keep our stats 	 */
if|if
condition|(
name|reg
operator|&
name|MID_INT_DMA_OVR
condition|)
block|{
name|EN_COUNT
argument_list|(
name|sc
operator|->
name|stats
operator|.
name|dmaovr
argument_list|)
expr_stmt|;
name|DBG
argument_list|(
name|sc
argument_list|,
name|INTR
argument_list|,
operator|(
literal|"MID_INT_DMA_OVR"
operator|)
argument_list|)
expr_stmt|;
block|}
name|reg
operator|=
name|en_read
argument_list|(
name|sc
argument_list|,
name|MID_STAT
argument_list|)
expr_stmt|;
name|sc
operator|->
name|stats
operator|.
name|otrash
operator|+=
name|MID_OTRASH
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|sc
operator|->
name|stats
operator|.
name|vtrash
operator|+=
name|MID_VTRASH
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|EN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Read at most n SUNI regs starting at reg into val  */
end_comment

begin_function
specifier|static
name|int
name|en_utopia_readregs
parameter_list|(
name|struct
name|ifatm
modifier|*
name|ifatm
parameter_list|,
name|u_int
name|reg
parameter_list|,
name|uint8_t
modifier|*
name|val
parameter_list|,
name|u_int
modifier|*
name|n
parameter_list|)
block|{
name|struct
name|en_softc
modifier|*
name|sc
init|=
name|ifatm
operator|->
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|EN_CHECKLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|>=
name|MID_NSUNI
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|reg
operator|+
operator|*
name|n
operator|>
name|MID_NSUNI
condition|)
operator|*
name|n
operator|=
name|MID_NSUNI
operator|-
name|reg
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|*
name|n
condition|;
name|i
operator|++
control|)
name|val
index|[
name|i
index|]
operator|=
name|en_read
argument_list|(
name|sc
argument_list|,
name|MID_SUNIOFF
operator|+
literal|4
operator|*
operator|(
name|reg
operator|+
name|i
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * change the bits given by mask to them in val in register reg  */
end_comment

begin_function
specifier|static
name|int
name|en_utopia_writereg
parameter_list|(
name|struct
name|ifatm
modifier|*
name|ifatm
parameter_list|,
name|u_int
name|reg
parameter_list|,
name|u_int
name|mask
parameter_list|,
name|u_int
name|val
parameter_list|)
block|{
name|struct
name|en_softc
modifier|*
name|sc
init|=
name|ifatm
operator|->
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|uint32_t
name|regval
decl_stmt|;
name|EN_CHECKLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|>=
name|MID_NSUNI
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|regval
operator|=
name|en_read
argument_list|(
name|sc
argument_list|,
name|MID_SUNIOFF
operator|+
literal|4
operator|*
name|reg
argument_list|)
expr_stmt|;
name|regval
operator|=
operator|(
name|regval
operator|&
operator|~
name|mask
operator|)
operator||
operator|(
name|val
operator|&
name|mask
operator|)
expr_stmt|;
name|en_write
argument_list|(
name|sc
argument_list|,
name|MID_SUNIOFF
operator|+
literal|4
operator|*
name|reg
argument_list|,
name|regval
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|utopia_methods
name|en_utopia_methods
init|=
block|{
name|en_utopia_readregs
block|,
name|en_utopia_writereg
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*********************************************************************/
end_comment

begin_comment
comment|/*  * Probing the DMA brokeness of the card  */
end_comment

begin_comment
comment|/*  * Physical address load helper function for DMA probe  *  * LOCK: unlocked, not needed  */
end_comment

begin_function
specifier|static
name|void
name|en_dmaprobe_load
parameter_list|(
name|void
modifier|*
name|uarg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
if|if
condition|(
name|error
operator|==
literal|0
condition|)
operator|*
operator|(
name|bus_addr_t
operator|*
operator|)
name|uarg
operator|=
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * en_dmaprobe: helper function for en_attach.  *  * see how the card handles DMA by running a few DMA tests.   we need  * to figure out the largest number of bytes we can DMA in one burst  * ("bestburstlen"), and if the starting address for a burst needs to  * be aligned on any sort of boundary or not ("alburst").  *  * Things turn out more complex than that, because on my (harti) brand  * new motherboard (2.4GHz) we can do 64byte aligned DMAs, but everything  * we more than 4 bytes fails (with an RX DMA timeout) for physical  * addresses that end with 0xc. Therefor we search not only the largest  * burst that is supported (hopefully 64) but also check what is the largerst  * unaligned supported size. If that appears to be lesser than 4 words,  * set the noalbursts flag. That will be set only if also alburst is set.  */
end_comment

begin_comment
comment|/*  * en_dmaprobe_doit: do actual testing for the DMA test.  * Cycle through all bursts sizes from 8 up to 64 and try whether it works.  * Return the largest one that works.  *  * LOCK: unlocked, not needed  */
end_comment

begin_function
specifier|static
name|int
name|en_dmaprobe_doit
parameter_list|(
name|struct
name|en_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
modifier|*
name|sp
parameter_list|,
name|bus_addr_t
name|psp
parameter_list|)
block|{
name|uint8_t
modifier|*
name|dp
init|=
name|sp
operator|+
name|MIDDMA_MAXBURST
decl_stmt|;
name|bus_addr_t
name|pdp
init|=
name|psp
operator|+
name|MIDDMA_MAXBURST
decl_stmt|;
name|int
name|lcv
decl_stmt|,
name|retval
init|=
literal|4
decl_stmt|,
name|cnt
decl_stmt|;
name|uint32_t
name|reg
decl_stmt|,
name|bcode
decl_stmt|,
name|midvloc
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|en_busreset
condition|)
name|sc
operator|->
name|en_busreset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|en_write
argument_list|(
name|sc
argument_list|,
name|MID_RESID
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
comment|/* reset card before touching RAM */
comment|/* 	 * set up a 1k buffer at MID_BUFOFF 	 */
name|midvloc
operator|=
operator|(
operator|(
name|MID_BUFOFF
operator|-
name|MID_RAMOFF
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
operator|>>
name|MIDV_LOCTOPSHFT
expr_stmt|;
name|en_write
argument_list|(
name|sc
argument_list|,
name|MIDX_PLACE
argument_list|(
literal|0
argument_list|)
argument_list|,
name|MIDX_MKPLACE
argument_list|(
name|en_k2sz
argument_list|(
literal|1
argument_list|)
argument_list|,
name|midvloc
argument_list|)
argument_list|)
expr_stmt|;
name|en_write
argument_list|(
name|sc
argument_list|,
name|MID_VC
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|(
name|midvloc
operator|<<
name|MIDV_LOCSHIFT
operator|)
operator||
operator|(
name|en_k2sz
argument_list|(
literal|1
argument_list|)
operator|<<
name|MIDV_SZSHIFT
operator|)
operator||
name|MIDV_TRASH
argument_list|)
expr_stmt|;
name|en_write
argument_list|(
name|sc
argument_list|,
name|MID_DST_RP
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|en_write
argument_list|(
name|sc
argument_list|,
name|MID_WP_ST_CNT
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* set up sample data */
for|for
control|(
name|lcv
operator|=
literal|0
init|;
name|lcv
operator|<
name|MIDDMA_MAXBURST
condition|;
name|lcv
operator|++
control|)
name|sp
index|[
name|lcv
index|]
operator|=
name|lcv
operator|+
literal|1
expr_stmt|;
comment|/* enable DMA (only) */
name|en_write
argument_list|(
name|sc
argument_list|,
name|MID_MAST_CSR
argument_list|,
name|MID_MCSR_ENDMA
argument_list|)
expr_stmt|;
name|sc
operator|->
name|drq_chip
operator|=
name|MID_DRQ_REG2A
argument_list|(
name|en_read
argument_list|(
name|sc
argument_list|,
name|MID_DMA_RDRX
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|dtq_chip
operator|=
name|MID_DTQ_REG2A
argument_list|(
name|en_read
argument_list|(
name|sc
argument_list|,
name|MID_DMA_RDTX
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * try it now . . .  DMA it out, then DMA it back in and compare 	 * 	 * note: in order to get the dma stuff to reverse directions it wants 	 * the "end" flag set!   since we are not dma'ing valid data we may 	 * get an ident mismatch interrupt (which we will ignore). 	 */
name|DBG
argument_list|(
name|sc
argument_list|,
name|DMA
argument_list|,
operator|(
literal|"test sp=%p/%#lx, dp=%p/%#lx"
operator|,
name|sp
operator|,
operator|(
name|u_long
operator|)
name|psp
operator|,
name|dp
operator|,
operator|(
name|u_long
operator|)
name|pdp
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|lcv
operator|=
literal|8
init|;
name|lcv
operator|<=
name|MIDDMA_MAXBURST
condition|;
name|lcv
operator|=
name|lcv
operator|*
literal|2
control|)
block|{
name|DBG
argument_list|(
name|sc
argument_list|,
name|DMA
argument_list|,
operator|(
literal|"test lcv=%d"
operator|,
name|lcv
operator|)
argument_list|)
expr_stmt|;
comment|/* zero SRAM and dest buffer */
name|bus_space_set_region_4
argument_list|(
name|sc
operator|->
name|en_memt
argument_list|,
name|sc
operator|->
name|en_base
argument_list|,
name|MID_BUFOFF
argument_list|,
literal|0
argument_list|,
literal|1024
operator|/
literal|4
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|dp
argument_list|,
name|MIDDMA_MAXBURST
argument_list|)
expr_stmt|;
name|bcode
operator|=
name|en_sz2b
argument_list|(
name|lcv
argument_list|)
expr_stmt|;
comment|/* build lcv-byte-DMA x NBURSTS */
if|if
condition|(
name|sc
operator|->
name|is_adaptec
condition|)
name|en_write
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|dtq_chip
argument_list|,
name|MID_MK_TXQ_ADP
argument_list|(
name|lcv
argument_list|,
literal|0
argument_list|,
name|MID_DMA_END
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|en_write
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|dtq_chip
argument_list|,
name|MID_MK_TXQ_ENI
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
name|MID_DMA_END
argument_list|,
name|bcode
argument_list|)
argument_list|)
expr_stmt|;
name|en_write
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|dtq_chip
operator|+
literal|4
argument_list|,
name|psp
argument_list|)
expr_stmt|;
name|EN_WRAPADD
argument_list|(
name|MID_DTQOFF
argument_list|,
name|MID_DTQEND
argument_list|,
name|sc
operator|->
name|dtq_chip
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|en_write
argument_list|(
name|sc
argument_list|,
name|MID_DMA_WRTX
argument_list|,
name|MID_DTQ_A2REG
argument_list|(
name|sc
operator|->
name|dtq_chip
argument_list|)
argument_list|)
expr_stmt|;
name|cnt
operator|=
literal|1000
expr_stmt|;
while|while
condition|(
operator|(
name|reg
operator|=
name|en_readx
argument_list|(
name|sc
argument_list|,
name|MID_DMA_RDTX
argument_list|)
operator|)
operator|!=
name|MID_DTQ_A2REG
argument_list|(
name|sc
operator|->
name|dtq_chip
argument_list|)
condition|)
block|{
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|cnt
operator|==
literal|0
condition|)
block|{
name|DBG
argument_list|(
name|sc
argument_list|,
name|DMA
argument_list|,
operator|(
literal|"unexpected timeout in tx "
literal|"DMA test\n  alignment=0x%lx, burst size=%d"
literal|", dma addr reg=%#x, rdtx=%#x, stat=%#x\n"
operator|,
operator|(
name|u_long
operator|)
name|sp
operator|&
literal|63
operator|,
name|lcv
operator|,
name|en_read
argument_list|(
name|sc
argument_list|,
name|MID_DMA_ADDR
argument_list|)
operator|,
name|reg
operator|,
name|en_read
argument_list|(
name|sc
argument_list|,
name|MID_INTSTAT
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
block|}
name|reg
operator|=
name|en_read
argument_list|(
name|sc
argument_list|,
name|MID_INTACK
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|reg
operator|&
name|MID_INT_DMA_TX
operator|)
operator|!=
name|MID_INT_DMA_TX
condition|)
block|{
name|DBG
argument_list|(
name|sc
argument_list|,
name|DMA
argument_list|,
operator|(
literal|"unexpected status in tx DMA test: %#x\n"
operator|,
name|reg
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
comment|/* re-enable DMA (only) */
name|en_write
argument_list|(
name|sc
argument_list|,
name|MID_MAST_CSR
argument_list|,
name|MID_MCSR_ENDMA
argument_list|)
expr_stmt|;
comment|/* "return to sender..."  address is known ... */
comment|/* build lcv-byte-DMA x NBURSTS */
if|if
condition|(
name|sc
operator|->
name|is_adaptec
condition|)
name|en_write
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|drq_chip
argument_list|,
name|MID_MK_RXQ_ADP
argument_list|(
name|lcv
argument_list|,
literal|0
argument_list|,
name|MID_DMA_END
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|en_write
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|drq_chip
argument_list|,
name|MID_MK_RXQ_ENI
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
name|MID_DMA_END
argument_list|,
name|bcode
argument_list|)
argument_list|)
expr_stmt|;
name|en_write
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|drq_chip
operator|+
literal|4
argument_list|,
name|pdp
argument_list|)
expr_stmt|;
name|EN_WRAPADD
argument_list|(
name|MID_DRQOFF
argument_list|,
name|MID_DRQEND
argument_list|,
name|sc
operator|->
name|drq_chip
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|en_write
argument_list|(
name|sc
argument_list|,
name|MID_DMA_WRRX
argument_list|,
name|MID_DRQ_A2REG
argument_list|(
name|sc
operator|->
name|drq_chip
argument_list|)
argument_list|)
expr_stmt|;
name|cnt
operator|=
literal|1000
expr_stmt|;
while|while
condition|(
operator|(
name|reg
operator|=
name|en_readx
argument_list|(
name|sc
argument_list|,
name|MID_DMA_RDRX
argument_list|)
operator|)
operator|!=
name|MID_DRQ_A2REG
argument_list|(
name|sc
operator|->
name|drq_chip
argument_list|)
condition|)
block|{
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|cnt
operator|--
expr_stmt|;
if|if
condition|(
operator|--
name|cnt
operator|==
literal|0
condition|)
block|{
name|DBG
argument_list|(
name|sc
argument_list|,
name|DMA
argument_list|,
operator|(
literal|"unexpected timeout in rx "
literal|"DMA test, rdrx=%#x\n"
operator|,
name|reg
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
block|}
name|reg
operator|=
name|en_read
argument_list|(
name|sc
argument_list|,
name|MID_INTACK
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|reg
operator|&
name|MID_INT_DMA_RX
operator|)
operator|!=
name|MID_INT_DMA_RX
condition|)
block|{
name|DBG
argument_list|(
name|sc
argument_list|,
name|DMA
argument_list|,
operator|(
literal|"unexpected status in rx DMA "
literal|"test: 0x%x\n"
operator|,
name|reg
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
if|if
condition|(
name|bcmp
argument_list|(
name|sp
argument_list|,
name|dp
argument_list|,
name|lcv
argument_list|)
condition|)
block|{
name|DBG
argument_list|(
name|sc
argument_list|,
name|DMA
argument_list|,
operator|(
literal|"DMA test failed! lcv=%d, sp=%p, "
literal|"dp=%p"
operator|,
name|lcv
operator|,
name|sp
operator|,
name|dp
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
name|retval
operator|=
name|lcv
expr_stmt|;
block|}
return|return
operator|(
name|retval
operator|)
return|;
comment|/* studly 64 byte DMA present!  oh baby!! */
block|}
end_function

begin_comment
comment|/*  * Find the best DMA parameters  *  * LOCK: unlocked, not needed  */
end_comment

begin_function
specifier|static
name|void
name|en_dmaprobe
parameter_list|(
name|struct
name|en_softc
modifier|*
name|sc
parameter_list|)
block|{
name|bus_dma_tag_t
name|tag
decl_stmt|;
name|bus_dmamap_t
name|map
decl_stmt|;
name|int
name|err
decl_stmt|;
name|void
modifier|*
name|buffer
decl_stmt|;
name|int
name|bestalgn
decl_stmt|,
name|lcv
decl_stmt|,
name|try
decl_stmt|,
name|bestnoalgn
decl_stmt|;
name|bus_addr_t
name|phys
decl_stmt|;
name|uint8_t
modifier|*
name|addr
decl_stmt|;
name|sc
operator|->
name|alburst
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|noalbursts
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Allocate some DMA-able memory. 	 * We need 3 times the max burst size aligned to the max burst size. 	 */
name|err
operator|=
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
name|MIDDMA_MAXBURST
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|3
operator|*
name|MIDDMA_MAXBURST
argument_list|,
literal|1
argument_list|,
literal|3
operator|*
name|MIDDMA_MAXBURST
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|panic
argument_list|(
literal|"%s: cannot create test DMA tag %d"
argument_list|,
name|__func__
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|err
operator|=
name|bus_dmamem_alloc
argument_list|(
name|tag
argument_list|,
operator|&
name|buffer
argument_list|,
literal|0
argument_list|,
operator|&
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|panic
argument_list|(
literal|"%s: cannot allocate test DMA memory %d"
argument_list|,
name|__func__
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|err
operator|=
name|bus_dmamap_load
argument_list|(
name|tag
argument_list|,
name|map
argument_list|,
name|buffer
argument_list|,
literal|3
operator|*
name|MIDDMA_MAXBURST
argument_list|,
name|en_dmaprobe_load
argument_list|,
operator|&
name|phys
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|panic
argument_list|(
literal|"%s: cannot load test DMA map %d"
argument_list|,
name|__func__
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|addr
operator|=
name|buffer
expr_stmt|;
name|DBG
argument_list|(
name|sc
argument_list|,
name|DMA
argument_list|,
operator|(
literal|"phys=%#lx addr=%p"
operator|,
operator|(
name|u_long
operator|)
name|phys
operator|,
name|addr
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Now get the best burst size of the aligned case. 	 */
name|bestalgn
operator|=
name|bestnoalgn
operator|=
name|en_dmaprobe_doit
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|,
name|phys
argument_list|)
expr_stmt|;
comment|/* 	 * Now try unaligned.  	 */
for|for
control|(
name|lcv
operator|=
literal|4
init|;
name|lcv
operator|<
name|MIDDMA_MAXBURST
condition|;
name|lcv
operator|+=
literal|4
control|)
block|{
name|try
operator|=
name|en_dmaprobe_doit
argument_list|(
name|sc
argument_list|,
name|addr
operator|+
name|lcv
argument_list|,
name|phys
operator|+
name|lcv
argument_list|)
expr_stmt|;
if|if
condition|(
name|try
operator|<
name|bestnoalgn
condition|)
name|bestnoalgn
operator|=
name|try
expr_stmt|;
block|}
if|if
condition|(
name|bestnoalgn
operator|<
name|bestalgn
condition|)
block|{
name|sc
operator|->
name|alburst
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|bestnoalgn
operator|<
literal|32
condition|)
name|sc
operator|->
name|noalbursts
operator|=
literal|1
expr_stmt|;
block|}
name|sc
operator|->
name|bestburstlen
operator|=
name|bestalgn
expr_stmt|;
name|sc
operator|->
name|bestburstshift
operator|=
name|en_log2
argument_list|(
name|bestalgn
argument_list|)
expr_stmt|;
name|sc
operator|->
name|bestburstmask
operator|=
name|sc
operator|->
name|bestburstlen
operator|-
literal|1
expr_stmt|;
comment|/* must be power of 2 */
name|sc
operator|->
name|bestburstcode
operator|=
name|en_sz2b
argument_list|(
name|bestalgn
argument_list|)
expr_stmt|;
comment|/* 	 * Reset the chip before freeing the buffer. It may still be trying 	 * to DMA. 	 */
if|if
condition|(
name|sc
operator|->
name|en_busreset
condition|)
name|sc
operator|->
name|en_busreset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|en_write
argument_list|(
name|sc
argument_list|,
name|MID_RESID
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
comment|/* reset card before touching RAM */
name|DELAY
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
comment|/* may still do DMA */
comment|/* 	 * Free the DMA stuff 	 */
name|bus_dmamap_unload
argument_list|(
name|tag
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|tag
argument_list|,
name|buffer
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|tag
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*********************************************************************/
end_comment

begin_comment
comment|/*  * Attach/detach.  */
end_comment

begin_comment
comment|/*  * Attach to the card.  *  * LOCK: unlocked, not needed (but initialized)  */
end_comment

begin_function
name|int
name|en_attach
parameter_list|(
name|struct
name|en_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|ifp
decl_stmt|;
name|int
name|sz
decl_stmt|;
name|uint32_t
name|reg
decl_stmt|,
name|lcv
decl_stmt|,
name|check
decl_stmt|,
name|ptr
decl_stmt|,
name|sav
decl_stmt|,
name|midvloc
decl_stmt|;
ifdef|#
directive|ifdef
name|EN_DEBUG
name|sc
operator|->
name|debug
operator|=
name|EN_DEBUG
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Probe card to determine memory size. 	 * 	 * The stupid ENI card always reports to PCI that it needs 4MB of 	 * space (2MB regs and 2MB RAM). If it has less than 2MB RAM the 	 * addresses wrap in the RAM address space (i.e. on a 512KB card 	 * addresses 0x3ffffc, 0x37fffc, and 0x2ffffc are aliases for 	 * 0x27fffc  [note that RAM starts at offset 0x200000]). 	 */
comment|/* reset card before touching RAM */
if|if
condition|(
name|sc
operator|->
name|en_busreset
condition|)
name|sc
operator|->
name|en_busreset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|en_write
argument_list|(
name|sc
argument_list|,
name|MID_RESID
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
for|for
control|(
name|lcv
operator|=
name|MID_PROBEOFF
init|;
name|lcv
operator|<=
name|MID_MAXOFF
condition|;
name|lcv
operator|+=
name|MID_PROBSIZE
control|)
block|{
name|en_write
argument_list|(
name|sc
argument_list|,
name|lcv
argument_list|,
name|lcv
argument_list|)
expr_stmt|;
comment|/* data[address] = address */
for|for
control|(
name|check
operator|=
name|MID_PROBEOFF
init|;
name|check
operator|<
name|lcv
condition|;
name|check
operator|+=
name|MID_PROBSIZE
control|)
block|{
name|reg
operator|=
name|en_read
argument_list|(
name|sc
argument_list|,
name|check
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|!=
name|check
condition|)
comment|/* found an alias! - quit */
goto|goto
name|done_probe
goto|;
block|}
block|}
name|done_probe
label|:
name|lcv
operator|-=
name|MID_PROBSIZE
expr_stmt|;
comment|/* take one step back */
name|sc
operator|->
name|en_obmemsz
operator|=
operator|(
name|lcv
operator|+
literal|4
operator|)
operator|-
name|MID_RAMOFF
expr_stmt|;
comment|/* 	 * determine the largest DMA burst supported 	 */
name|en_dmaprobe
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * "hello world" 	 */
comment|/* reset */
if|if
condition|(
name|sc
operator|->
name|en_busreset
condition|)
name|sc
operator|->
name|en_busreset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|en_write
argument_list|(
name|sc
argument_list|,
name|MID_RESID
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
comment|/* reset */
comment|/* zero memory */
name|bus_space_set_region_4
argument_list|(
name|sc
operator|->
name|en_memt
argument_list|,
name|sc
operator|->
name|en_base
argument_list|,
name|MID_RAMOFF
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|en_obmemsz
operator|/
literal|4
argument_list|)
expr_stmt|;
name|reg
operator|=
name|en_read
argument_list|(
name|sc
argument_list|,
name|MID_RESID
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"ATM midway v%d, board IDs %d.%d, %s%s%s, "
literal|"%ldKB on-board RAM\n"
argument_list|,
name|MID_VER
argument_list|(
name|reg
argument_list|)
argument_list|,
name|MID_MID
argument_list|(
name|reg
argument_list|)
argument_list|,
name|MID_DID
argument_list|(
name|reg
argument_list|)
argument_list|,
operator|(
name|MID_IS_SABRE
argument_list|(
name|reg
argument_list|)
operator|)
condition|?
literal|"sabre controller, "
else|:
literal|""
argument_list|,
operator|(
name|MID_IS_SUNI
argument_list|(
name|reg
argument_list|)
operator|)
condition|?
literal|"SUNI"
else|:
literal|"Utopia"
argument_list|,
operator|(
operator|!
name|MID_IS_SUNI
argument_list|(
name|reg
argument_list|)
operator|&&
name|MID_IS_UPIPE
argument_list|(
name|reg
argument_list|)
operator|)
condition|?
literal|" (pipelined)"
else|:
literal|""
argument_list|,
operator|(
name|long
operator|)
name|sc
operator|->
name|en_obmemsz
operator|/
literal|1024
argument_list|)
expr_stmt|;
comment|/* 	 * fill in common ATM interface stuff 	 */
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|hw_version
operator|=
operator|(
name|MID_VER
argument_list|(
name|reg
argument_list|)
operator|<<
literal|16
operator|)
operator||
operator|(
name|MID_MID
argument_list|(
name|reg
argument_list|)
operator|<<
literal|8
operator|)
operator||
name|MID_DID
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|MID_DID
argument_list|(
name|reg
argument_list|)
operator|&
literal|0x4
condition|)
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|media
operator|=
name|IFM_ATM_UTP_155
expr_stmt|;
else|else
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|media
operator|=
name|IFM_ATM_MM_155
expr_stmt|;
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|pcr
operator|=
name|ATM_RATE_155M
expr_stmt|;
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|vpi_bits
operator|=
literal|0
expr_stmt|;
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|vci_bits
operator|=
name|MID_VCI_BITS
expr_stmt|;
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|max_vccs
operator|=
name|MID_N_VC
expr_stmt|;
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|max_vpcs
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|is_adaptec
condition|)
block|{
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|device
operator|=
name|ATM_DEVICE_ADP155P
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|bestburstlen
operator|==
literal|64
operator|&&
name|sc
operator|->
name|alburst
operator|==
literal|0
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"passed 64 byte DMA test\n"
argument_list|)
expr_stmt|;
else|else
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"FAILED DMA TEST: "
literal|"burst=%d, alburst=%d\n"
argument_list|,
name|sc
operator|->
name|bestburstlen
argument_list|,
name|sc
operator|->
name|alburst
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|device
operator|=
name|ATM_DEVICE_ENI155P
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"maximum DMA burst length = %d "
literal|"bytes%s\n"
argument_list|,
name|sc
operator|->
name|bestburstlen
argument_list|,
name|sc
operator|->
name|alburst
condition|?
name|sc
operator|->
name|noalbursts
condition|?
literal|" (no large bursts)"
else|:
literal|" (must align)"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * link into network subsystem and prepare card 	 */
name|sc
operator|->
name|ifp
operator|->
name|if_softc
operator|=
name|sc
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_SIMPLEX
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|en_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|en_start
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|en_mtx
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
name|MTX_NETWORK_LOCK
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|sc
operator|->
name|cv_close
argument_list|,
literal|"VC close"
argument_list|)
expr_stmt|;
comment|/* 	 * Make the sysctl tree 	 */
name|sysctl_ctx_init
argument_list|(
operator|&
name|sc
operator|->
name|sysctl_ctx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sysctl_tree
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
operator|&
name|sc
operator|->
name|sysctl_ctx
argument_list|,
name|SYSCTL_STATIC_CHILDREN
argument_list|(
name|_hw_atm
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|sc
operator|->
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"istats"
argument_list|,
name|CTLTYPE_OPAQUE
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|en_sysctl_istats
argument_list|,
literal|"S"
argument_list|,
literal|"internal statistics"
argument_list|)
operator|==
name|NULL
condition|)
goto|goto
name|fail
goto|;
ifdef|#
directive|ifdef
name|EN_DEBUG
if|if
condition|(
name|SYSCTL_ADD_UINT
argument_list|(
operator|&
name|sc
operator|->
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"debug"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|debug
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
operator|==
name|NULL
condition|)
goto|goto
name|fail
goto|;
endif|#
directive|endif
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|phy
operator|=
operator|&
name|sc
operator|->
name|utopia
expr_stmt|;
name|utopia_attach
argument_list|(
operator|&
name|sc
operator|->
name|utopia
argument_list|,
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
argument_list|,
operator|&
name|sc
operator|->
name|media
argument_list|,
operator|&
name|sc
operator|->
name|en_mtx
argument_list|,
operator|&
name|sc
operator|->
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|sysctl_tree
argument_list|)
argument_list|,
operator|&
name|en_utopia_methods
argument_list|)
expr_stmt|;
name|utopia_init_media
argument_list|(
operator|&
name|sc
operator|->
name|utopia
argument_list|)
expr_stmt|;
name|MGET
argument_list|(
name|sc
operator|->
name|padbuf
argument_list|,
name|M_WAITOK
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|sc
operator|->
name|padbuf
operator|->
name|m_data
argument_list|,
name|MLEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|EN_TXSZ
operator|*
literal|1024
argument_list|,
name|EN_MAX_DMASEG
argument_list|,
name|EN_TXSZ
operator|*
literal|1024
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|sc
operator|->
name|txtag
argument_list|)
condition|)
goto|goto
name|fail
goto|;
name|sc
operator|->
name|map_zone
operator|=
name|uma_zcreate
argument_list|(
literal|"en dma maps"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|en_map
argument_list|)
argument_list|,
name|en_map_ctor
argument_list|,
name|en_map_dtor
argument_list|,
name|NULL
argument_list|,
name|en_map_fini
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
name|UMA_ZONE_ZINIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|map_zone
operator|==
name|NULL
condition|)
goto|goto
name|fail
goto|;
name|uma_zone_set_max
argument_list|(
name|sc
operator|->
name|map_zone
argument_list|,
name|EN_MAX_MAPS
argument_list|)
expr_stmt|;
comment|/* 	 * init softc 	 */
name|sc
operator|->
name|vccs
operator|=
name|malloc
argument_list|(
name|MID_N_VC
operator|*
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|vccs
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
name|sz
operator|=
name|sc
operator|->
name|en_obmemsz
operator|-
operator|(
name|MID_BUFOFF
operator|-
name|MID_RAMOFF
operator|)
expr_stmt|;
name|ptr
operator|=
name|sav
operator|=
name|MID_BUFOFF
expr_stmt|;
name|ptr
operator|=
name|roundup
argument_list|(
name|ptr
argument_list|,
name|EN_TXSZ
operator|*
literal|1024
argument_list|)
expr_stmt|;
comment|/* align */
name|sz
operator|=
name|sz
operator|-
operator|(
name|ptr
operator|-
name|sav
operator|)
expr_stmt|;
if|if
condition|(
name|EN_TXSZ
operator|*
literal|1024
operator|*
name|EN_NTX
operator|>
name|sz
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"EN_NTX/EN_TXSZ too big\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
for|for
control|(
name|lcv
operator|=
literal|0
init|;
name|lcv
operator|<
name|EN_NTX
condition|;
name|lcv
operator|++
control|)
block|{
name|sc
operator|->
name|txslot
index|[
name|lcv
index|]
operator|.
name|mbsize
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|txslot
index|[
name|lcv
index|]
operator|.
name|start
operator|=
name|ptr
expr_stmt|;
name|ptr
operator|+=
operator|(
name|EN_TXSZ
operator|*
literal|1024
operator|)
expr_stmt|;
name|sz
operator|-=
operator|(
name|EN_TXSZ
operator|*
literal|1024
operator|)
expr_stmt|;
name|sc
operator|->
name|txslot
index|[
name|lcv
index|]
operator|.
name|stop
operator|=
name|ptr
expr_stmt|;
name|sc
operator|->
name|txslot
index|[
name|lcv
index|]
operator|.
name|nref
operator|=
literal|0
expr_stmt|;
name|DBG
argument_list|(
name|sc
argument_list|,
name|INIT
argument_list|,
operator|(
literal|"tx%d: start 0x%x, stop 0x%x"
operator|,
name|lcv
operator|,
name|sc
operator|->
name|txslot
index|[
name|lcv
index|]
operator|.
name|start
operator|,
name|sc
operator|->
name|txslot
index|[
name|lcv
index|]
operator|.
name|stop
operator|)
argument_list|)
expr_stmt|;
block|}
name|sav
operator|=
name|ptr
expr_stmt|;
name|ptr
operator|=
name|roundup
argument_list|(
name|ptr
argument_list|,
name|EN_RXSZ
operator|*
literal|1024
argument_list|)
expr_stmt|;
comment|/* align */
name|sz
operator|=
name|sz
operator|-
operator|(
name|ptr
operator|-
name|sav
operator|)
expr_stmt|;
name|sc
operator|->
name|en_nrx
operator|=
name|sz
operator|/
operator|(
name|EN_RXSZ
operator|*
literal|1024
operator|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|en_nrx
operator|<=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"EN_NTX/EN_TXSZ/EN_RXSZ too big\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/*  	 * ensure that there is always one VC slot on the service list free 	 * so that we can tell the difference between a full and empty list. 	 */
if|if
condition|(
name|sc
operator|->
name|en_nrx
operator|>=
name|MID_N_VC
condition|)
name|sc
operator|->
name|en_nrx
operator|=
name|MID_N_VC
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|lcv
operator|=
literal|0
init|;
name|lcv
operator|<
name|sc
operator|->
name|en_nrx
condition|;
name|lcv
operator|++
control|)
block|{
name|sc
operator|->
name|rxslot
index|[
name|lcv
index|]
operator|.
name|vcc
operator|=
name|NULL
expr_stmt|;
name|midvloc
operator|=
name|sc
operator|->
name|rxslot
index|[
name|lcv
index|]
operator|.
name|start
operator|=
name|ptr
expr_stmt|;
name|ptr
operator|+=
operator|(
name|EN_RXSZ
operator|*
literal|1024
operator|)
expr_stmt|;
name|sz
operator|-=
operator|(
name|EN_RXSZ
operator|*
literal|1024
operator|)
expr_stmt|;
name|sc
operator|->
name|rxslot
index|[
name|lcv
index|]
operator|.
name|stop
operator|=
name|ptr
expr_stmt|;
name|midvloc
operator|=
name|midvloc
operator|-
name|MID_RAMOFF
expr_stmt|;
comment|/* mask, cvt to words */
name|midvloc
operator|=
operator|(
name|midvloc
operator|&
operator|~
operator|(
operator|(
name|EN_RXSZ
operator|*
literal|1024
operator|)
operator|-
literal|1
operator|)
operator|)
operator|>>
literal|2
expr_stmt|;
comment|/* we only want the top 11 bits */
name|midvloc
operator|=
name|midvloc
operator|>>
name|MIDV_LOCTOPSHFT
expr_stmt|;
name|midvloc
operator|=
operator|(
name|midvloc
operator|&
name|MIDV_LOCMASK
operator|)
operator|<<
name|MIDV_LOCSHIFT
expr_stmt|;
name|sc
operator|->
name|rxslot
index|[
name|lcv
index|]
operator|.
name|mode
operator|=
name|midvloc
operator||
operator|(
name|en_k2sz
argument_list|(
name|EN_RXSZ
argument_list|)
operator|<<
name|MIDV_SZSHIFT
operator|)
operator||
name|MIDV_TRASH
expr_stmt|;
name|DBG
argument_list|(
name|sc
argument_list|,
name|INIT
argument_list|,
operator|(
literal|"rx%d: start 0x%x, stop 0x%x, mode 0x%x"
operator|,
name|lcv
operator|,
name|sc
operator|->
name|rxslot
index|[
name|lcv
index|]
operator|.
name|start
operator|,
name|sc
operator|->
name|rxslot
index|[
name|lcv
index|]
operator|.
name|stop
operator|,
name|sc
operator|->
name|rxslot
index|[
name|lcv
index|]
operator|.
name|mode
operator|)
argument_list|)
expr_stmt|;
block|}
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"%d %dKB receive buffers, %d %dKB transmit "
literal|"buffers\n"
argument_list|,
name|sc
operator|->
name|en_nrx
argument_list|,
name|EN_RXSZ
argument_list|,
name|EN_NTX
argument_list|,
name|EN_TXSZ
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"end station identifier (mac address) "
literal|"%6D\n"
argument_list|,
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|esi
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
comment|/* 	 * Start SUNI stuff. This will call our readregs/writeregs 	 * functions and these assume the lock to be held so we must get it 	 * here. 	 */
name|EN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|utopia_start
argument_list|(
operator|&
name|sc
operator|->
name|utopia
argument_list|)
expr_stmt|;
name|utopia_reset
argument_list|(
operator|&
name|sc
operator|->
name|utopia
argument_list|)
expr_stmt|;
name|EN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * final commit 	 */
name|atm_ifattach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_BPF
name|bpfattach
argument_list|(
name|ifp
argument_list|,
name|DLT_ATM_RFC1483
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|atmllc
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
name|fail
label|:
name|en_destroy
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free all internal resources. No access to bus resources here.  * No locking required here (interrupt is already disabled).  *  * LOCK: unlocked, needed (but destroyed)  */
end_comment

begin_function
name|void
name|en_destroy
parameter_list|(
name|struct
name|en_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u_int
name|i
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|utopia
operator|.
name|state
operator|&
name|UTP_ST_ATTACHED
condition|)
block|{
comment|/* these assume the lock to be held */
name|EN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|utopia_stop
argument_list|(
operator|&
name|sc
operator|->
name|utopia
argument_list|)
expr_stmt|;
name|utopia_detach
argument_list|(
operator|&
name|sc
operator|->
name|utopia
argument_list|)
expr_stmt|;
name|EN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|vccs
operator|!=
name|NULL
condition|)
block|{
comment|/* get rid of sticky VCCs */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MID_N_VC
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sc
operator|->
name|vccs
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
name|uma_zfree
argument_list|(
name|en_vcc_zone
argument_list|,
name|sc
operator|->
name|vccs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|vccs
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|padbuf
operator|!=
name|NULL
condition|)
name|m_free
argument_list|(
name|sc
operator|->
name|padbuf
argument_list|)
expr_stmt|;
comment|/* 	 * Destroy the map zone before the tag (the fini function will 	 * destroy the DMA maps using the tag) 	 */
if|if
condition|(
name|sc
operator|->
name|map_zone
operator|!=
name|NULL
condition|)
name|uma_zdestroy
argument_list|(
name|sc
operator|->
name|map_zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|txtag
operator|!=
name|NULL
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|txtag
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sysctl_ctx_free
argument_list|(
operator|&
name|sc
operator|->
name|sysctl_ctx
argument_list|)
expr_stmt|;
name|cv_destroy
argument_list|(
operator|&
name|sc
operator|->
name|cv_close
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|en_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Module loaded/unloaded  */
end_comment

begin_function
name|int
name|en_modevent
parameter_list|(
name|module_t
name|mod
name|__unused
parameter_list|,
name|int
name|event
parameter_list|,
name|void
modifier|*
name|arg
name|__unused
parameter_list|)
block|{
switch|switch
condition|(
name|event
condition|)
block|{
case|case
name|MOD_LOAD
case|:
name|en_vcc_zone
operator|=
name|uma_zcreate
argument_list|(
literal|"EN vccs"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|en_vcc
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|en_vcc_zone
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
break|break;
case|case
name|MOD_UNLOAD
case|:
name|uma_zdestroy
argument_list|(
name|en_vcc_zone
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************/
end_comment

begin_comment
comment|/*  * Debugging support  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|EN_DDBHOOK
end_ifdef

begin_comment
comment|/*  * functions we can call from ddb  */
end_comment

begin_comment
comment|/*  * en_dump: dump the state  */
end_comment

begin_define
define|#
directive|define
name|END_SWSL
value|0x00000040
end_define

begin_comment
comment|/* swsl state */
end_comment

begin_define
define|#
directive|define
name|END_DRQ
value|0x00000020
end_define

begin_comment
comment|/* drq state */
end_comment

begin_define
define|#
directive|define
name|END_DTQ
value|0x00000010
end_define

begin_comment
comment|/* dtq state */
end_comment

begin_define
define|#
directive|define
name|END_RX
value|0x00000008
end_define

begin_comment
comment|/* rx state */
end_comment

begin_define
define|#
directive|define
name|END_TX
value|0x00000004
end_define

begin_comment
comment|/* tx state */
end_comment

begin_define
define|#
directive|define
name|END_MREGS
value|0x00000002
end_define

begin_comment
comment|/* registers */
end_comment

begin_define
define|#
directive|define
name|END_STATS
value|0x00000001
end_define

begin_comment
comment|/* dump stats */
end_comment

begin_define
define|#
directive|define
name|END_BITS
value|"\20\7SWSL\6DRQ\5DTQ\4RX\3TX\2MREGS\1STATS"
end_define

begin_function
specifier|static
name|void
name|en_dump_stats
parameter_list|(
specifier|const
name|struct
name|en_stats
modifier|*
name|s
parameter_list|)
block|{
name|printf
argument_list|(
literal|"en_stats:\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t%d/%d mfix (%d failed)\n"
argument_list|,
name|s
operator|->
name|mfixaddr
argument_list|,
name|s
operator|->
name|mfixlen
argument_list|,
name|s
operator|->
name|mfixfail
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t%d rx dma overflow interrupts\n"
argument_list|,
name|s
operator|->
name|dmaovr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t%d times out of TX space and stalled\n"
argument_list|,
name|s
operator|->
name|txoutspace
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t%d times out of DTQs\n"
argument_list|,
name|s
operator|->
name|txdtqout
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t%d times launched a packet\n"
argument_list|,
name|s
operator|->
name|launch
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t%d times pulled the hw service list\n"
argument_list|,
name|s
operator|->
name|hwpull
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t%d times pushed a vci on the sw service list\n"
argument_list|,
name|s
operator|->
name|swadd
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t%d times RX pulled an mbuf from Q that wasn't ours\n"
argument_list|,
name|s
operator|->
name|rxqnotus
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t%d times RX pulled a good mbuf from Q\n"
argument_list|,
name|s
operator|->
name|rxqus
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t%d times ran out of DRQs\n"
argument_list|,
name|s
operator|->
name|rxdrqout
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t%d transmit packets dropped due to mbsize\n"
argument_list|,
name|s
operator|->
name|txmbovr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t%d cells trashed due to turned off rxvc\n"
argument_list|,
name|s
operator|->
name|vtrash
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t%d cells trashed due to totally full buffer\n"
argument_list|,
name|s
operator|->
name|otrash
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t%d cells trashed due almost full buffer\n"
argument_list|,
name|s
operator|->
name|ttrash
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t%d rx mbuf allocation failures\n"
argument_list|,
name|s
operator|->
name|rxmbufout
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t%d times out of tx maps\n"
argument_list|,
name|s
operator|->
name|txnomap
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NATM
ifdef|#
directive|ifdef
name|NATM_STAT
name|printf
argument_list|(
literal|"\tnatmintr so_rcv: ok/drop cnt: %d/%d, ok/drop bytes: %d/%d\n"
argument_list|,
name|natm_sookcnt
argument_list|,
name|natm_sodropcnt
argument_list|,
name|natm_sookbytes
argument_list|,
name|natm_sodropbytes
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|en_dump_mregs
parameter_list|(
name|struct
name|en_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u_int
name|cnt
decl_stmt|;
name|printf
argument_list|(
literal|"mregs:\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"resid = 0x%x\n"
argument_list|,
name|en_read
argument_list|(
name|sc
argument_list|,
name|MID_RESID
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"interrupt status = 0x%b\n"
argument_list|,
operator|(
name|int
operator|)
name|en_read
argument_list|(
name|sc
argument_list|,
name|MID_INTSTAT
argument_list|)
argument_list|,
name|MID_INTBITS
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"interrupt enable = 0x%b\n"
argument_list|,
operator|(
name|int
operator|)
name|en_read
argument_list|(
name|sc
argument_list|,
name|MID_INTENA
argument_list|)
argument_list|,
name|MID_INTBITS
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"mcsr = 0x%b\n"
argument_list|,
operator|(
name|int
operator|)
name|en_read
argument_list|(
name|sc
argument_list|,
name|MID_MAST_CSR
argument_list|)
argument_list|,
name|MID_MCSRBITS
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"serv_write = [chip=%u] [us=%u]\n"
argument_list|,
name|en_read
argument_list|(
name|sc
argument_list|,
name|MID_SERV_WRITE
argument_list|)
argument_list|,
name|MID_SL_A2REG
argument_list|(
name|sc
operator|->
name|hwslistp
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"dma addr = 0x%x\n"
argument_list|,
name|en_read
argument_list|(
name|sc
argument_list|,
name|MID_DMA_ADDR
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"DRQ: chip[rd=0x%x,wr=0x%x], sc[chip=0x%x,us=0x%x]\n"
argument_list|,
name|MID_DRQ_REG2A
argument_list|(
name|en_read
argument_list|(
name|sc
argument_list|,
name|MID_DMA_RDRX
argument_list|)
argument_list|)
argument_list|,
name|MID_DRQ_REG2A
argument_list|(
name|en_read
argument_list|(
name|sc
argument_list|,
name|MID_DMA_WRRX
argument_list|)
argument_list|)
argument_list|,
name|sc
operator|->
name|drq_chip
argument_list|,
name|sc
operator|->
name|drq_us
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"DTQ: chip[rd=0x%x,wr=0x%x], sc[chip=0x%x,us=0x%x]\n"
argument_list|,
name|MID_DTQ_REG2A
argument_list|(
name|en_read
argument_list|(
name|sc
argument_list|,
name|MID_DMA_RDTX
argument_list|)
argument_list|)
argument_list|,
name|MID_DTQ_REG2A
argument_list|(
name|en_read
argument_list|(
name|sc
argument_list|,
name|MID_DMA_WRTX
argument_list|)
argument_list|)
argument_list|,
name|sc
operator|->
name|dtq_chip
argument_list|,
name|sc
operator|->
name|dtq_us
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  unusal txspeeds:"
argument_list|)
expr_stmt|;
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
name|MID_N_VC
condition|;
name|cnt
operator|++
control|)
if|if
condition|(
name|sc
operator|->
name|vccs
index|[
name|cnt
index|]
operator|->
name|txspeed
condition|)
name|printf
argument_list|(
literal|" vci%d=0x%x"
argument_list|,
name|cnt
argument_list|,
name|sc
operator|->
name|vccs
index|[
name|cnt
index|]
operator|->
name|txspeed
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  rxvc slot mappings:"
argument_list|)
expr_stmt|;
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
name|MID_N_VC
condition|;
name|cnt
operator|++
control|)
if|if
condition|(
name|sc
operator|->
name|vccs
index|[
name|cnt
index|]
operator|->
name|rxslot
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|"  %d->%td"
argument_list|,
name|cnt
argument_list|,
name|sc
operator|->
name|vccs
index|[
name|cnt
index|]
operator|->
name|rxslot
operator|-
name|sc
operator|->
name|rxslot
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|en_dump_tx
parameter_list|(
name|struct
name|en_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u_int
name|slot
decl_stmt|;
name|printf
argument_list|(
literal|"tx:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|slot
operator|=
literal|0
init|;
name|slot
operator|<
name|EN_NTX
condition|;
name|slot
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"tx%d: start/stop/cur=0x%x/0x%x/0x%x [%d]  "
argument_list|,
name|slot
argument_list|,
name|sc
operator|->
name|txslot
index|[
name|slot
index|]
operator|.
name|start
argument_list|,
name|sc
operator|->
name|txslot
index|[
name|slot
index|]
operator|.
name|stop
argument_list|,
name|sc
operator|->
name|txslot
index|[
name|slot
index|]
operator|.
name|cur
argument_list|,
operator|(
name|sc
operator|->
name|txslot
index|[
name|slot
index|]
operator|.
name|cur
operator|-
name|sc
operator|->
name|txslot
index|[
name|slot
index|]
operator|.
name|start
operator|)
operator|/
literal|4
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"mbsize=%d, bfree=%d\n"
argument_list|,
name|sc
operator|->
name|txslot
index|[
name|slot
index|]
operator|.
name|mbsize
argument_list|,
name|sc
operator|->
name|txslot
index|[
name|slot
index|]
operator|.
name|bfree
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"txhw: base_address=0x%x, size=%u, read=%u, "
literal|"descstart=%u\n"
argument_list|,
operator|(
name|u_int
operator|)
name|MIDX_BASE
argument_list|(
name|en_read
argument_list|(
name|sc
argument_list|,
name|MIDX_PLACE
argument_list|(
name|slot
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|MIDX_SZ
argument_list|(
name|en_read
argument_list|(
name|sc
argument_list|,
name|MIDX_PLACE
argument_list|(
name|slot
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|en_read
argument_list|(
name|sc
argument_list|,
name|MIDX_READPTR
argument_list|(
name|slot
argument_list|)
argument_list|)
argument_list|,
name|en_read
argument_list|(
name|sc
argument_list|,
name|MIDX_DESCSTART
argument_list|(
name|slot
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|en_dump_rx
parameter_list|(
name|struct
name|en_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|en_rxslot
modifier|*
name|slot
decl_stmt|;
name|printf
argument_list|(
literal|"  recv slots:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|slot
operator|=
name|sc
operator|->
name|rxslot
init|;
name|slot
operator|<
operator|&
name|sc
operator|->
name|rxslot
index|[
name|sc
operator|->
name|en_nrx
index|]
condition|;
name|slot
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"rx%td: start/stop/cur=0x%x/0x%x/0x%x mode=0x%x "
argument_list|,
name|slot
operator|-
name|sc
operator|->
name|rxslot
argument_list|,
name|slot
operator|->
name|start
argument_list|,
name|slot
operator|->
name|stop
argument_list|,
name|slot
operator|->
name|cur
argument_list|,
name|slot
operator|->
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|slot
operator|->
name|vcc
operator|!=
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"vci=%u\n"
argument_list|,
name|slot
operator|->
name|vcc
operator|->
name|vcc
operator|.
name|vci
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"RXHW: mode=0x%x, DST_RP=0x%x, WP_ST_CNT=0x%x\n"
argument_list|,
name|en_read
argument_list|(
name|sc
argument_list|,
name|MID_VC
argument_list|(
name|slot
operator|->
name|vcc
operator|->
name|vcc
operator|.
name|vci
argument_list|)
argument_list|)
argument_list|,
name|en_read
argument_list|(
name|sc
argument_list|,
name|MID_DST_RP
argument_list|(
name|slot
operator|->
name|vcc
operator|->
name|vcc
operator|.
name|vci
argument_list|)
argument_list|)
argument_list|,
name|en_read
argument_list|(
name|sc
argument_list|,
name|MID_WP_ST_CNT
argument_list|(
name|slot
operator|->
name|vcc
operator|->
name|vcc
operator|.
name|vci
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * This is only correct for non-adaptec adapters  */
end_comment

begin_function
specifier|static
name|void
name|en_dump_dtqs
parameter_list|(
name|struct
name|en_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|ptr
decl_stmt|,
name|reg
decl_stmt|;
name|printf
argument_list|(
literal|"  dtq [need_dtqs=%d,dtq_free=%d]:\n"
argument_list|,
name|sc
operator|->
name|need_dtqs
argument_list|,
name|sc
operator|->
name|dtq_free
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|sc
operator|->
name|dtq_chip
expr_stmt|;
while|while
condition|(
name|ptr
operator|!=
name|sc
operator|->
name|dtq_us
condition|)
block|{
name|reg
operator|=
name|en_read
argument_list|(
name|sc
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t0x%x=[%#x cnt=%d, chan=%d, end=%d, type=%d @ 0x%x]\n"
argument_list|,
name|sc
operator|->
name|dtq
index|[
name|MID_DTQ_A2REG
argument_list|(
name|ptr
argument_list|)
index|]
argument_list|,
name|reg
argument_list|,
name|MID_DMA_CNT
argument_list|(
name|reg
argument_list|)
argument_list|,
name|MID_DMA_TXCHAN
argument_list|(
name|reg
argument_list|)
argument_list|,
operator|(
name|reg
operator|&
name|MID_DMA_END
operator|)
operator|!=
literal|0
argument_list|,
name|MID_DMA_TYPE
argument_list|(
name|reg
argument_list|)
argument_list|,
name|en_read
argument_list|(
name|sc
argument_list|,
name|ptr
operator|+
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|EN_WRAPADD
argument_list|(
name|MID_DTQOFF
argument_list|,
name|MID_DTQEND
argument_list|,
name|ptr
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|en_dump_drqs
parameter_list|(
name|struct
name|en_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|ptr
decl_stmt|,
name|reg
decl_stmt|;
name|printf
argument_list|(
literal|"  drq [need_drqs=%d,drq_free=%d]:\n"
argument_list|,
name|sc
operator|->
name|need_drqs
argument_list|,
name|sc
operator|->
name|drq_free
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|sc
operator|->
name|drq_chip
expr_stmt|;
while|while
condition|(
name|ptr
operator|!=
name|sc
operator|->
name|drq_us
condition|)
block|{
name|reg
operator|=
name|en_read
argument_list|(
name|sc
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t0x%x=[cnt=%d, chan=%d, end=%d, type=%d @ 0x%x]\n"
argument_list|,
name|sc
operator|->
name|drq
index|[
name|MID_DRQ_A2REG
argument_list|(
name|ptr
argument_list|)
index|]
argument_list|,
name|MID_DMA_CNT
argument_list|(
name|reg
argument_list|)
argument_list|,
name|MID_DMA_RXVCI
argument_list|(
name|reg
argument_list|)
argument_list|,
operator|(
name|reg
operator|&
name|MID_DMA_END
operator|)
operator|!=
literal|0
argument_list|,
name|MID_DMA_TYPE
argument_list|(
name|reg
argument_list|)
argument_list|,
name|en_read
argument_list|(
name|sc
argument_list|,
name|ptr
operator|+
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|EN_WRAPADD
argument_list|(
name|MID_DRQOFF
argument_list|,
name|MID_DRQEND
argument_list|,
name|ptr
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Do not staticize - meant for calling from DDB! */
end_comment

begin_function
name|int
name|en_dump
parameter_list|(
name|int
name|unit
parameter_list|,
name|int
name|level
parameter_list|)
block|{
name|struct
name|en_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|lcv
decl_stmt|,
name|cnt
decl_stmt|;
name|devclass_t
name|dc
decl_stmt|;
name|int
name|maxunit
decl_stmt|;
name|dc
operator|=
name|devclass_find
argument_list|(
literal|"en"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dc
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: can't find devclass!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|maxunit
operator|=
name|devclass_get_maxunit
argument_list|(
name|dc
argument_list|)
expr_stmt|;
for|for
control|(
name|lcv
operator|=
literal|0
init|;
name|lcv
operator|<
name|maxunit
condition|;
name|lcv
operator|++
control|)
block|{
name|sc
operator|=
name|devclass_get_softc
argument_list|(
name|dc
argument_list|,
name|lcv
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|unit
operator|!=
operator|-
literal|1
operator|&&
name|unit
operator|!=
name|lcv
condition|)
continue|continue;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"dumping device at level 0x%b\n"
argument_list|,
name|level
argument_list|,
name|END_BITS
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|dtq_us
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"<hasn't been en_init'd yet>\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|level
operator|&
name|END_STATS
condition|)
name|en_dump_stats
argument_list|(
operator|&
name|sc
operator|->
name|stats
argument_list|)
expr_stmt|;
if|if
condition|(
name|level
operator|&
name|END_MREGS
condition|)
name|en_dump_mregs
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|level
operator|&
name|END_TX
condition|)
name|en_dump_tx
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|level
operator|&
name|END_RX
condition|)
name|en_dump_rx
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|level
operator|&
name|END_DTQ
condition|)
name|en_dump_dtqs
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|level
operator|&
name|END_DRQ
condition|)
name|en_dump_drqs
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|level
operator|&
name|END_SWSL
condition|)
block|{
name|printf
argument_list|(
literal|" swslist [size=%d]: "
argument_list|,
name|sc
operator|->
name|swsl_size
argument_list|)
expr_stmt|;
for|for
control|(
name|cnt
operator|=
name|sc
operator|->
name|swsl_head
init|;
name|cnt
operator|!=
name|sc
operator|->
name|swsl_tail
condition|;
name|cnt
operator|=
operator|(
name|cnt
operator|+
literal|1
operator|)
operator|%
name|MID_SL_N
control|)
name|printf
argument_list|(
literal|"0x%x "
argument_list|,
name|sc
operator|->
name|swslist
index|[
name|cnt
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * en_dumpmem: dump the memory  *  * Do not staticize - meant for calling from DDB!  */
end_comment

begin_function
name|int
name|en_dumpmem
parameter_list|(
name|int
name|unit
parameter_list|,
name|int
name|addr
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|struct
name|en_softc
modifier|*
name|sc
decl_stmt|;
name|uint32_t
name|reg
decl_stmt|;
name|devclass_t
name|dc
decl_stmt|;
name|dc
operator|=
name|devclass_find
argument_list|(
literal|"en"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dc
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: can't find devclass\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|sc
operator|=
name|devclass_get_softc
argument_list|(
name|dc
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: invalid unit number: %d\n"
argument_list|,
name|__func__
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|addr
operator|=
name|addr
operator|&
operator|~
literal|3
expr_stmt|;
if|if
condition|(
name|addr
operator|<
name|MID_RAMOFF
operator|||
name|addr
operator|+
name|len
operator|*
literal|4
operator|>
name|MID_MAXOFF
operator|||
name|len
operator|<=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"invalid addr/len number: %d, %d\n"
argument_list|,
name|addr
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|printf
argument_list|(
literal|"dumping %d words starting at offset 0x%x\n"
argument_list|,
name|len
argument_list|,
name|addr
argument_list|)
expr_stmt|;
while|while
condition|(
name|len
operator|--
condition|)
block|{
name|reg
operator|=
name|en_read
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"mem[0x%x] = 0x%x\n"
argument_list|,
name|addr
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|4
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

