begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2009 Yahoo! Inc.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*-  * Copyright (c) 2011 LSI Corp.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * LSI MPT-Fusion Host Adapter FreeBSD  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Communications core for LSI MPT2 */
end_comment

begin_comment
comment|/* TODO Move headers to mpsvar */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/selinfo.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/bio.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<sys/sbuf.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<machine/stdarg.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_ccb.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_xpt.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_debug.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_sim.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_xpt_sim.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_xpt_periph.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_periph.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_all.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_message.h>
end_include

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|900026
end_if

begin_include
include|#
directive|include
file|<cam/scsi/smp_all.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<dev/mps/mpi/mpi2_type.h>
end_include

begin_include
include|#
directive|include
file|<dev/mps/mpi/mpi2.h>
end_include

begin_include
include|#
directive|include
file|<dev/mps/mpi/mpi2_ioc.h>
end_include

begin_include
include|#
directive|include
file|<dev/mps/mpi/mpi2_sas.h>
end_include

begin_include
include|#
directive|include
file|<dev/mps/mpi/mpi2_cnfg.h>
end_include

begin_include
include|#
directive|include
file|<dev/mps/mpi/mpi2_init.h>
end_include

begin_include
include|#
directive|include
file|<dev/mps/mpi/mpi2_tool.h>
end_include

begin_include
include|#
directive|include
file|<dev/mps/mps_ioctl.h>
end_include

begin_include
include|#
directive|include
file|<dev/mps/mpsvar.h>
end_include

begin_include
include|#
directive|include
file|<dev/mps/mps_table.h>
end_include

begin_include
include|#
directive|include
file|<dev/mps/mps_sas.h>
end_include

begin_define
define|#
directive|define
name|MPSSAS_DISCOVERY_TIMEOUT
value|20
end_define

begin_define
define|#
directive|define
name|MPSSAS_MAX_DISCOVERY_TIMEOUTS
value|10
end_define

begin_comment
comment|/* 200 seconds */
end_comment

begin_comment
comment|/*  * static array to check SCSI OpCode for EEDP protection bits  */
end_comment

begin_define
define|#
directive|define
name|PRO_R
value|MPI2_SCSIIO_EEDPFLAGS_CHECK_REMOVE_OP
end_define

begin_define
define|#
directive|define
name|PRO_W
value|MPI2_SCSIIO_EEDPFLAGS_INSERT_OP
end_define

begin_define
define|#
directive|define
name|PRO_V
value|MPI2_SCSIIO_EEDPFLAGS_INSERT_OP
end_define

begin_decl_stmt
specifier|static
name|uint8_t
name|op_code_prot
index|[
literal|256
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|PRO_R
block|,
literal|0
block|,
name|PRO_W
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|PRO_W
block|,
name|PRO_V
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|PRO_W
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|PRO_R
block|,
literal|0
block|,
name|PRO_W
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|PRO_W
block|,
name|PRO_V
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|PRO_W
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|PRO_R
block|,
literal|0
block|,
name|PRO_W
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|PRO_W
block|,
name|PRO_V
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_MPSSAS
argument_list|,
literal|"MPSSAS"
argument_list|,
literal|"MPS SAS memory"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|struct
name|mpssas_target
modifier|*
name|mpssas_find_target_by_handle
parameter_list|(
name|struct
name|mpssas_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|uint16_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mpssas_discovery_timeout
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mpssas_remove_device
parameter_list|(
name|struct
name|mps_softc
modifier|*
parameter_list|,
name|struct
name|mps_command
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mpssas_remove_complete
parameter_list|(
name|struct
name|mps_softc
modifier|*
parameter_list|,
name|struct
name|mps_command
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mpssas_action
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mpssas_poll
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mpssas_scsiio_timeout
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mpssas_abort_complete
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mps_command
modifier|*
name|cm
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mpssas_direct_drive_io
parameter_list|(
name|struct
name|mpssas_softc
modifier|*
name|sassc
parameter_list|,
name|struct
name|mps_command
modifier|*
name|cm
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mpssas_action_scsiio
parameter_list|(
name|struct
name|mpssas_softc
modifier|*
parameter_list|,
name|union
name|ccb
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mpssas_scsiio_complete
parameter_list|(
name|struct
name|mps_softc
modifier|*
parameter_list|,
name|struct
name|mps_command
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mpssas_action_resetdev
parameter_list|(
name|struct
name|mpssas_softc
modifier|*
parameter_list|,
name|union
name|ccb
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|900026
end_if

begin_function_decl
specifier|static
name|void
name|mpssas_smpio_complete
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mps_command
modifier|*
name|cm
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mpssas_send_smpcmd
parameter_list|(
name|struct
name|mpssas_softc
modifier|*
name|sassc
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|uint64_t
name|sasaddr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mpssas_action_smpio
parameter_list|(
name|struct
name|mpssas_softc
modifier|*
name|sassc
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|//FreeBSD_version>= 900026
end_comment

begin_function_decl
specifier|static
name|void
name|mpssas_resetdev_complete
parameter_list|(
name|struct
name|mps_softc
modifier|*
parameter_list|,
name|struct
name|mps_command
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mpssas_send_abort
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mps_command
modifier|*
name|tm
parameter_list|,
name|struct
name|mps_command
modifier|*
name|cm
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mpssas_send_reset
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mps_command
modifier|*
name|tm
parameter_list|,
name|uint8_t
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mpssas_rescan
parameter_list|(
name|struct
name|mpssas_softc
modifier|*
name|sassc
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mpssas_rescan_done
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|union
name|ccb
modifier|*
name|done_ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mpssas_scanner_thread
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|1000006
end_if

begin_function_decl
specifier|static
name|void
name|mpssas_async
parameter_list|(
name|void
modifier|*
name|callback_arg
parameter_list|,
name|uint32_t
name|code
parameter_list|,
name|struct
name|cam_path
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_function_decl
specifier|static
name|void
name|mpssas_check_eedp
parameter_list|(
name|struct
name|mpssas_softc
modifier|*
name|sassc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mpssas_read_cap_done
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|union
name|ccb
modifier|*
name|done_ccb
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|mpssas_send_portenable
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mpssas_portenable_complete
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mps_command
modifier|*
name|cm
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|struct
name|mpssas_target
modifier|*
name|mpssas_find_target_by_handle
parameter_list|(
name|struct
name|mpssas_softc
modifier|*
name|sassc
parameter_list|,
name|int
name|start
parameter_list|,
name|uint16_t
name|handle
parameter_list|)
block|{
name|struct
name|mpssas_target
modifier|*
name|target
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|start
init|;
name|i
operator|<
name|sassc
operator|->
name|sc
operator|->
name|facts
operator|->
name|MaxTargets
condition|;
name|i
operator|++
control|)
block|{
name|target
operator|=
operator|&
name|sassc
operator|->
name|targets
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|target
operator|->
name|handle
operator|==
name|handle
condition|)
return|return
operator|(
name|target
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* we need to freeze the simq during attach and diag reset, to avoid failing  * commands before device handles have been found by discovery.  Since  * discovery involves reading config pages and possibly sending commands,  * discovery actions may continue even after we receive the end of discovery  * event, so refcount discovery actions instead of assuming we can unfreeze  * the simq when we get the event.  */
end_comment

begin_function
name|void
name|mpssas_startup_increment
parameter_list|(
name|struct
name|mpssas_softc
modifier|*
name|sassc
parameter_list|)
block|{
if|if
condition|(
operator|(
name|sassc
operator|->
name|flags
operator|&
name|MPSSAS_IN_STARTUP
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|sassc
operator|->
name|startup_refcount
operator|++
operator|==
literal|0
condition|)
block|{
comment|/* just starting, freeze the simq */
name|mps_dprint
argument_list|(
name|sassc
operator|->
name|sc
argument_list|,
name|MPS_INFO
argument_list|,
literal|"%s freezing simq\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|xpt_freeze_simq
argument_list|(
name|sassc
operator|->
name|sim
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|mps_dprint
argument_list|(
name|sassc
operator|->
name|sc
argument_list|,
name|MPS_TRACE
argument_list|,
literal|"%s refcount %u\n"
argument_list|,
name|__func__
argument_list|,
name|sassc
operator|->
name|startup_refcount
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|mpssas_startup_decrement
parameter_list|(
name|struct
name|mpssas_softc
modifier|*
name|sassc
parameter_list|)
block|{
if|if
condition|(
operator|(
name|sassc
operator|->
name|flags
operator|&
name|MPSSAS_IN_STARTUP
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|--
name|sassc
operator|->
name|startup_refcount
operator|==
literal|0
condition|)
block|{
comment|/* finished all discovery-related actions, release 			 * the simq and rescan for the latest topology. 			 */
name|mps_dprint
argument_list|(
name|sassc
operator|->
name|sc
argument_list|,
name|MPS_INFO
argument_list|,
literal|"%s releasing simq\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|sassc
operator|->
name|flags
operator|&=
operator|~
name|MPSSAS_IN_STARTUP
expr_stmt|;
name|xpt_release_simq
argument_list|(
name|sassc
operator|->
name|sim
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|mpssas_rescan_target
argument_list|(
name|sassc
operator|->
name|sc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|mps_dprint
argument_list|(
name|sassc
operator|->
name|sc
argument_list|,
name|MPS_TRACE
argument_list|,
literal|"%s refcount %u\n"
argument_list|,
name|__func__
argument_list|,
name|sassc
operator|->
name|startup_refcount
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* LSI's firmware requires us to stop sending commands when we're doing task  * management, so refcount the TMs and keep the simq frozen when any are in  * use.  */
end_comment

begin_function
name|struct
name|mps_command
modifier|*
name|mpssas_alloc_tm
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|mps_command
modifier|*
name|tm
decl_stmt|;
name|tm
operator|=
name|mps_alloc_high_priority_command
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|tm
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sassc
operator|->
name|tm_count
operator|++
operator|==
literal|0
condition|)
block|{
name|mps_printf
argument_list|(
name|sc
argument_list|,
literal|"%s freezing simq\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|xpt_freeze_simq
argument_list|(
name|sc
operator|->
name|sassc
operator|->
name|sim
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_TRACE
argument_list|,
literal|"%s tm_count %u\n"
argument_list|,
name|__func__
argument_list|,
name|sc
operator|->
name|sassc
operator|->
name|tm_count
argument_list|)
expr_stmt|;
block|}
return|return
name|tm
return|;
block|}
end_function

begin_function
name|void
name|mpssas_free_tm
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mps_command
modifier|*
name|tm
parameter_list|)
block|{
if|if
condition|(
name|tm
operator|==
name|NULL
condition|)
return|return;
comment|/* if there are no TMs in use, we can release the simq.  We use our 	 * own refcount so that it's easier for a diag reset to cleanup and 	 * release the simq. 	 */
if|if
condition|(
operator|--
name|sc
operator|->
name|sassc
operator|->
name|tm_count
operator|==
literal|0
condition|)
block|{
name|mps_printf
argument_list|(
name|sc
argument_list|,
literal|"%s releasing simq\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|xpt_release_simq
argument_list|(
name|sc
operator|->
name|sassc
operator|->
name|sim
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_TRACE
argument_list|,
literal|"%s tm_count %u\n"
argument_list|,
name|__func__
argument_list|,
name|sc
operator|->
name|sassc
operator|->
name|tm_count
argument_list|)
expr_stmt|;
name|mps_free_high_priority_command
argument_list|(
name|sc
argument_list|,
name|tm
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|mpssas_rescan_target
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mpssas_target
modifier|*
name|targ
parameter_list|)
block|{
name|struct
name|mpssas_softc
modifier|*
name|sassc
init|=
name|sc
operator|->
name|sassc
decl_stmt|;
name|path_id_t
name|pathid
decl_stmt|;
name|target_id_t
name|targetid
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|pathid
operator|=
name|cam_sim_path
argument_list|(
name|sassc
operator|->
name|sim
argument_list|)
expr_stmt|;
if|if
condition|(
name|targ
operator|==
name|NULL
condition|)
name|targetid
operator|=
name|CAM_TARGET_WILDCARD
expr_stmt|;
else|else
name|targetid
operator|=
name|targ
operator|-
name|sassc
operator|->
name|targets
expr_stmt|;
comment|/* 	 * Allocate a CCB and schedule a rescan. 	 */
name|ccb
operator|=
name|xpt_alloc_ccb_nowait
argument_list|()
expr_stmt|;
if|if
condition|(
name|ccb
operator|==
name|NULL
condition|)
block|{
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_FAULT
argument_list|,
literal|"unable to alloc CCB for rescan\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|xpt_create_path
argument_list|(
operator|&
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|xpt_periph
argument_list|,
name|pathid
argument_list|,
name|targetid
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_FAULT
argument_list|,
literal|"unable to create path for rescan\n"
argument_list|)
expr_stmt|;
name|xpt_free_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* XXX Hardwired to scan the bus for now */
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_SCAN_BUS
expr_stmt|;
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_TRACE
argument_list|,
literal|"%s targetid %u\n"
argument_list|,
name|__func__
argument_list|,
name|targetid
argument_list|)
expr_stmt|;
name|mpssas_rescan
argument_list|(
name|sassc
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mpssas_log_command
parameter_list|(
name|struct
name|mps_command
modifier|*
name|cm
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|struct
name|sbuf
name|sb
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|char
name|str
index|[
literal|192
index|]
decl_stmt|;
name|char
name|path_str
index|[
literal|64
index|]
decl_stmt|;
if|if
condition|(
name|cm
operator|==
name|NULL
condition|)
return|return;
name|sbuf_new
argument_list|(
operator|&
name|sb
argument_list|,
name|str
argument_list|,
sizeof|sizeof
argument_list|(
name|str
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|cm
operator|->
name|cm_ccb
operator|!=
name|NULL
condition|)
block|{
name|xpt_path_string
argument_list|(
name|cm
operator|->
name|cm_ccb
operator|->
name|csio
operator|.
name|ccb_h
operator|.
name|path
argument_list|,
name|path_str
argument_list|,
sizeof|sizeof
argument_list|(
name|path_str
argument_list|)
argument_list|)
expr_stmt|;
name|sbuf_cat
argument_list|(
operator|&
name|sb
argument_list|,
name|path_str
argument_list|)
expr_stmt|;
if|if
condition|(
name|cm
operator|->
name|cm_ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_SCSI_IO
condition|)
block|{
name|scsi_command_string
argument_list|(
operator|&
name|cm
operator|->
name|cm_ccb
operator|->
name|csio
argument_list|,
operator|&
name|sb
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"length %d "
argument_list|,
name|cm
operator|->
name|cm_ccb
operator|->
name|csio
operator|.
name|dxfer_len
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|sbuf_printf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"(noperiph:%s%d:%u:%u:%u): "
argument_list|,
name|cam_sim_name
argument_list|(
name|cm
operator|->
name|cm_sc
operator|->
name|sassc
operator|->
name|sim
argument_list|)
argument_list|,
name|cam_sim_unit
argument_list|(
name|cm
operator|->
name|cm_sc
operator|->
name|sassc
operator|->
name|sim
argument_list|)
argument_list|,
name|cam_sim_bus
argument_list|(
name|cm
operator|->
name|cm_sc
operator|->
name|sassc
operator|->
name|sim
argument_list|)
argument_list|,
name|cm
operator|->
name|cm_targ
condition|?
name|cm
operator|->
name|cm_targ
operator|->
name|tid
else|:
literal|0xFFFFFFFF
argument_list|,
name|cm
operator|->
name|cm_lun
argument_list|)
expr_stmt|;
block|}
name|sbuf_printf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"SMID %u "
argument_list|,
name|cm
operator|->
name|cm_desc
operator|.
name|Default
operator|.
name|SMID
argument_list|)
expr_stmt|;
name|sbuf_vprintf
argument_list|(
operator|&
name|sb
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|sbuf_finish
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|sbuf_data
argument_list|(
operator|&
name|sb
argument_list|)
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mpssas_lost_target
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mpssas_target
modifier|*
name|targ
parameter_list|)
block|{
name|struct
name|mpssas_softc
modifier|*
name|sassc
init|=
name|sc
operator|->
name|sassc
decl_stmt|;
name|path_id_t
name|pathid
init|=
name|cam_sim_path
argument_list|(
name|sassc
operator|->
name|sim
argument_list|)
decl_stmt|;
name|struct
name|cam_path
modifier|*
name|path
decl_stmt|;
name|mps_printf
argument_list|(
name|sc
argument_list|,
literal|"%s targetid %u\n"
argument_list|,
name|__func__
argument_list|,
name|targ
operator|->
name|tid
argument_list|)
expr_stmt|;
if|if
condition|(
name|xpt_create_path
argument_list|(
operator|&
name|path
argument_list|,
name|NULL
argument_list|,
name|pathid
argument_list|,
name|targ
operator|->
name|tid
argument_list|,
literal|0
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|mps_printf
argument_list|(
name|sc
argument_list|,
literal|"unable to create path for lost target %d\n"
argument_list|,
name|targ
operator|->
name|tid
argument_list|)
expr_stmt|;
return|return;
block|}
name|xpt_async
argument_list|(
name|AC_LOST_DEVICE
argument_list|,
name|path
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|xpt_free_path
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * The MPT2 firmware performs debounce on the link to avoid transient link  * errors and false removals.  When it does decide that link has been lost  * and a device need to go away, it expects that the host will perform a  * target reset and then an op remove.  The reset has the side-effect of  * aborting any outstanding requests for the device, which is required for  * the op-remove to succeed.  It's not clear if the host should check for  * the device coming back alive after the reset.  */
end_comment

begin_function
name|void
name|mpssas_prepare_remove
parameter_list|(
name|struct
name|mpssas_softc
modifier|*
name|sassc
parameter_list|,
name|uint16_t
name|handle
parameter_list|)
block|{
name|MPI2_SCSI_TASK_MANAGE_REQUEST
modifier|*
name|req
decl_stmt|;
name|struct
name|mps_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mps_command
modifier|*
name|cm
decl_stmt|;
name|struct
name|mpssas_target
modifier|*
name|targ
init|=
name|NULL
decl_stmt|;
name|mps_dprint
argument_list|(
name|sassc
operator|->
name|sc
argument_list|,
name|MPS_TRACE
argument_list|,
literal|"%s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* 	 * If this is a WD controller, determine if the disk should be exposed 	 * to the OS or not.  If disk should be exposed, return from this 	 * function without doing anything. 	 */
name|sc
operator|=
name|sassc
operator|->
name|sc
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|mps_flags
operator|&
name|MPS_FLAGS_WD_AVAILABLE
operator|)
operator|&&
operator|(
name|sc
operator|->
name|WD_hide_expose
operator|==
name|MPS_WD_EXPOSE_ALWAYS
operator|)
condition|)
block|{
return|return;
block|}
name|targ
operator|=
name|mpssas_find_target_by_handle
argument_list|(
name|sassc
argument_list|,
literal|0
argument_list|,
name|handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|targ
operator|==
name|NULL
condition|)
block|{
comment|/* FIXME: what is the action? */
comment|/* We don't know about this device? */
name|printf
argument_list|(
literal|"%s: invalid handle 0x%x \n"
argument_list|,
name|__func__
argument_list|,
name|handle
argument_list|)
expr_stmt|;
return|return;
block|}
name|targ
operator|->
name|flags
operator||=
name|MPSSAS_TARGET_INREMOVAL
expr_stmt|;
name|cm
operator|=
name|mpssas_alloc_tm
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|cm
operator|==
name|NULL
condition|)
block|{
name|mps_printf
argument_list|(
name|sc
argument_list|,
literal|"%s: command alloc failure\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return;
block|}
name|mpssas_lost_target
argument_list|(
name|sc
argument_list|,
name|targ
argument_list|)
expr_stmt|;
name|req
operator|=
operator|(
name|MPI2_SCSI_TASK_MANAGE_REQUEST
operator|*
operator|)
name|cm
operator|->
name|cm_req
expr_stmt|;
name|memset
argument_list|(
name|req
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|req
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|->
name|DevHandle
operator|=
name|targ
operator|->
name|handle
expr_stmt|;
name|req
operator|->
name|Function
operator|=
name|MPI2_FUNCTION_SCSI_TASK_MGMT
expr_stmt|;
name|req
operator|->
name|TaskType
operator|=
name|MPI2_SCSITASKMGMT_TASKTYPE_TARGET_RESET
expr_stmt|;
comment|/* SAS Hard Link Reset / SATA Link Reset */
name|req
operator|->
name|MsgFlags
operator|=
name|MPI2_SCSITASKMGMT_MSGFLAGS_LINK_RESET
expr_stmt|;
name|cm
operator|->
name|cm_targ
operator|=
name|targ
expr_stmt|;
name|cm
operator|->
name|cm_data
operator|=
name|NULL
expr_stmt|;
name|cm
operator|->
name|cm_desc
operator|.
name|HighPriority
operator|.
name|RequestFlags
operator|=
name|MPI2_REQ_DESCRIPT_FLAGS_HIGH_PRIORITY
expr_stmt|;
name|cm
operator|->
name|cm_complete
operator|=
name|mpssas_remove_device
expr_stmt|;
name|cm
operator|->
name|cm_complete_data
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|handle
expr_stmt|;
name|mps_map_command
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mpssas_remove_device
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mps_command
modifier|*
name|tm
parameter_list|)
block|{
name|MPI2_SCSI_TASK_MANAGE_REPLY
modifier|*
name|reply
decl_stmt|;
name|MPI2_SAS_IOUNIT_CONTROL_REQUEST
modifier|*
name|req
decl_stmt|;
name|struct
name|mpssas_target
modifier|*
name|targ
decl_stmt|;
name|struct
name|mps_command
modifier|*
name|next_cm
decl_stmt|;
name|uint16_t
name|handle
decl_stmt|;
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_TRACE
argument_list|,
literal|"%s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|reply
operator|=
operator|(
name|MPI2_SCSI_TASK_MANAGE_REPLY
operator|*
operator|)
name|tm
operator|->
name|cm_reply
expr_stmt|;
name|handle
operator|=
operator|(
name|uint16_t
operator|)
operator|(
name|uintptr_t
operator|)
name|tm
operator|->
name|cm_complete_data
expr_stmt|;
name|targ
operator|=
name|tm
operator|->
name|cm_targ
expr_stmt|;
comment|/* 	 * Currently there should be no way we can hit this case.  It only 	 * happens when we have a failure to allocate chain frames, and 	 * task management commands don't have S/G lists. 	 */
if|if
condition|(
operator|(
name|tm
operator|->
name|cm_flags
operator|&
name|MPS_CM_FLAGS_ERROR_MASK
operator|)
operator|!=
literal|0
condition|)
block|{
name|mps_printf
argument_list|(
name|sc
argument_list|,
literal|"%s: cm_flags = %#x for remove of handle %#04x! "
literal|"This should not happen!\n"
argument_list|,
name|__func__
argument_list|,
name|tm
operator|->
name|cm_flags
argument_list|,
name|handle
argument_list|)
expr_stmt|;
name|mpssas_free_tm
argument_list|(
name|sc
argument_list|,
name|tm
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|reply
operator|==
name|NULL
condition|)
block|{
comment|/* XXX retry the remove after the diag reset completes? */
name|mps_printf
argument_list|(
name|sc
argument_list|,
literal|"%s NULL reply reseting device 0x%04x\n"
argument_list|,
name|__func__
argument_list|,
name|handle
argument_list|)
expr_stmt|;
name|mpssas_free_tm
argument_list|(
name|sc
argument_list|,
name|tm
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|reply
operator|->
name|IOCStatus
operator|!=
name|MPI2_IOCSTATUS_SUCCESS
condition|)
block|{
name|mps_printf
argument_list|(
name|sc
argument_list|,
literal|"IOCStatus = 0x%x while resetting device 0x%x\n"
argument_list|,
name|reply
operator|->
name|IOCStatus
argument_list|,
name|handle
argument_list|)
expr_stmt|;
name|mpssas_free_tm
argument_list|(
name|sc
argument_list|,
name|tm
argument_list|)
expr_stmt|;
return|return;
block|}
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_INFO
argument_list|,
literal|"Reset aborted %u commands\n"
argument_list|,
name|reply
operator|->
name|TerminationCount
argument_list|)
expr_stmt|;
name|mps_free_reply
argument_list|(
name|sc
argument_list|,
name|tm
operator|->
name|cm_reply_data
argument_list|)
expr_stmt|;
name|tm
operator|->
name|cm_reply
operator|=
name|NULL
expr_stmt|;
comment|/* Ensures the the reply won't get re-freed */
comment|/* Reuse the existing command */
name|req
operator|=
operator|(
name|MPI2_SAS_IOUNIT_CONTROL_REQUEST
operator|*
operator|)
name|tm
operator|->
name|cm_req
expr_stmt|;
name|memset
argument_list|(
name|req
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|req
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|->
name|Function
operator|=
name|MPI2_FUNCTION_SAS_IO_UNIT_CONTROL
expr_stmt|;
name|req
operator|->
name|Operation
operator|=
name|MPI2_SAS_OP_REMOVE_DEVICE
expr_stmt|;
name|req
operator|->
name|DevHandle
operator|=
name|handle
expr_stmt|;
name|tm
operator|->
name|cm_data
operator|=
name|NULL
expr_stmt|;
name|tm
operator|->
name|cm_desc
operator|.
name|Default
operator|.
name|RequestFlags
operator|=
name|MPI2_REQ_DESCRIPT_FLAGS_DEFAULT_TYPE
expr_stmt|;
name|tm
operator|->
name|cm_complete
operator|=
name|mpssas_remove_complete
expr_stmt|;
name|tm
operator|->
name|cm_complete_data
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|handle
expr_stmt|;
name|mps_map_command
argument_list|(
name|sc
argument_list|,
name|tm
argument_list|)
expr_stmt|;
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_INFO
argument_list|,
literal|"clearing target %u handle 0x%04x\n"
argument_list|,
name|targ
operator|->
name|tid
argument_list|,
name|handle
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|tm
argument_list|,
argument|&targ->commands
argument_list|,
argument|cm_link
argument_list|,
argument|next_cm
argument_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_INFO
argument_list|,
literal|"Completing missed command %p\n"
argument_list|,
name|tm
argument_list|)
expr_stmt|;
name|ccb
operator|=
name|tm
operator|->
name|cm_complete_data
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_DEV_NOT_THERE
expr_stmt|;
name|mpssas_scsiio_complete
argument_list|(
name|sc
argument_list|,
name|tm
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|mpssas_remove_complete
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mps_command
modifier|*
name|tm
parameter_list|)
block|{
name|MPI2_SAS_IOUNIT_CONTROL_REPLY
modifier|*
name|reply
decl_stmt|;
name|uint16_t
name|handle
decl_stmt|;
name|struct
name|mpssas_target
modifier|*
name|targ
decl_stmt|;
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_TRACE
argument_list|,
literal|"%s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|reply
operator|=
operator|(
name|MPI2_SAS_IOUNIT_CONTROL_REPLY
operator|*
operator|)
name|tm
operator|->
name|cm_reply
expr_stmt|;
name|handle
operator|=
operator|(
name|uint16_t
operator|)
operator|(
name|uintptr_t
operator|)
name|tm
operator|->
name|cm_complete_data
expr_stmt|;
comment|/* 	 * Currently there should be no way we can hit this case.  It only 	 * happens when we have a failure to allocate chain frames, and 	 * task management commands don't have S/G lists. 	 */
if|if
condition|(
operator|(
name|tm
operator|->
name|cm_flags
operator|&
name|MPS_CM_FLAGS_ERROR_MASK
operator|)
operator|!=
literal|0
condition|)
block|{
name|mps_printf
argument_list|(
name|sc
argument_list|,
literal|"%s: cm_flags = %#x for remove of handle %#04x! "
literal|"This should not happen!\n"
argument_list|,
name|__func__
argument_list|,
name|tm
operator|->
name|cm_flags
argument_list|,
name|handle
argument_list|)
expr_stmt|;
name|mpssas_free_tm
argument_list|(
name|sc
argument_list|,
name|tm
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|reply
operator|==
name|NULL
condition|)
block|{
comment|/* most likely a chip reset */
name|mps_printf
argument_list|(
name|sc
argument_list|,
literal|"%s NULL reply removing device 0x%04x\n"
argument_list|,
name|__func__
argument_list|,
name|handle
argument_list|)
expr_stmt|;
name|mpssas_free_tm
argument_list|(
name|sc
argument_list|,
name|tm
argument_list|)
expr_stmt|;
return|return;
block|}
name|mps_printf
argument_list|(
name|sc
argument_list|,
literal|"%s on handle 0x%04x, IOCStatus= 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|handle
argument_list|,
name|reply
operator|->
name|IOCStatus
argument_list|)
expr_stmt|;
comment|/* 	 * Don't clear target if remove fails because things will get confusing. 	 * Leave the devname and sasaddr intact so that we know to avoid reusing 	 * this target id if possible, and so we can assign the same target id 	 * to this device if it comes back in the future. 	 */
if|if
condition|(
name|reply
operator|->
name|IOCStatus
operator|==
name|MPI2_IOCSTATUS_SUCCESS
condition|)
block|{
name|targ
operator|=
name|tm
operator|->
name|cm_targ
expr_stmt|;
name|targ
operator|->
name|handle
operator|=
literal|0x0
expr_stmt|;
name|targ
operator|->
name|encl_handle
operator|=
literal|0x0
expr_stmt|;
name|targ
operator|->
name|encl_slot
operator|=
literal|0x0
expr_stmt|;
name|targ
operator|->
name|exp_dev_handle
operator|=
literal|0x0
expr_stmt|;
name|targ
operator|->
name|phy_num
operator|=
literal|0x0
expr_stmt|;
name|targ
operator|->
name|linkrate
operator|=
literal|0x0
expr_stmt|;
name|targ
operator|->
name|devinfo
operator|=
literal|0x0
expr_stmt|;
block|}
name|mpssas_free_tm
argument_list|(
name|sc
argument_list|,
name|tm
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|mpssas_register_events
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint8_t
name|events
index|[
literal|16
index|]
decl_stmt|;
name|bzero
argument_list|(
name|events
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|setbit
argument_list|(
name|events
argument_list|,
name|MPI2_EVENT_SAS_DEVICE_STATUS_CHANGE
argument_list|)
expr_stmt|;
name|setbit
argument_list|(
name|events
argument_list|,
name|MPI2_EVENT_SAS_DISCOVERY
argument_list|)
expr_stmt|;
name|setbit
argument_list|(
name|events
argument_list|,
name|MPI2_EVENT_SAS_BROADCAST_PRIMITIVE
argument_list|)
expr_stmt|;
name|setbit
argument_list|(
name|events
argument_list|,
name|MPI2_EVENT_SAS_INIT_DEVICE_STATUS_CHANGE
argument_list|)
expr_stmt|;
name|setbit
argument_list|(
name|events
argument_list|,
name|MPI2_EVENT_SAS_INIT_TABLE_OVERFLOW
argument_list|)
expr_stmt|;
name|setbit
argument_list|(
name|events
argument_list|,
name|MPI2_EVENT_SAS_TOPOLOGY_CHANGE_LIST
argument_list|)
expr_stmt|;
name|setbit
argument_list|(
name|events
argument_list|,
name|MPI2_EVENT_SAS_ENCL_DEVICE_STATUS_CHANGE
argument_list|)
expr_stmt|;
name|setbit
argument_list|(
name|events
argument_list|,
name|MPI2_EVENT_IR_CONFIGURATION_CHANGE_LIST
argument_list|)
expr_stmt|;
name|setbit
argument_list|(
name|events
argument_list|,
name|MPI2_EVENT_IR_VOLUME
argument_list|)
expr_stmt|;
name|setbit
argument_list|(
name|events
argument_list|,
name|MPI2_EVENT_IR_PHYSICAL_DISK
argument_list|)
expr_stmt|;
name|setbit
argument_list|(
name|events
argument_list|,
name|MPI2_EVENT_IR_OPERATION_STATUS
argument_list|)
expr_stmt|;
name|setbit
argument_list|(
name|events
argument_list|,
name|MPI2_EVENT_LOG_ENTRY_ADDED
argument_list|)
expr_stmt|;
name|mps_register_events
argument_list|(
name|sc
argument_list|,
name|events
argument_list|,
name|mpssas_evt_handler
argument_list|,
name|NULL
argument_list|,
operator|&
name|sc
operator|->
name|sassc
operator|->
name|mpssas_eh
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|mps_attach_sas
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|mpssas_softc
modifier|*
name|sassc
decl_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|1000006
name|cam_status
name|status
decl_stmt|;
endif|#
directive|endif
name|int
name|unit
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_TRACE
argument_list|,
literal|"%s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|sassc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|mpssas_softc
argument_list|)
argument_list|,
name|M_MPT2
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|sassc
operator|->
name|targets
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|mpssas_target
argument_list|)
operator|*
name|sc
operator|->
name|facts
operator|->
name|MaxTargets
argument_list|,
name|M_MPT2
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sassc
operator|=
name|sassc
expr_stmt|;
name|sassc
operator|->
name|sc
operator|=
name|sc
expr_stmt|;
if|if
condition|(
operator|(
name|sassc
operator|->
name|devq
operator|=
name|cam_simq_alloc
argument_list|(
name|sc
operator|->
name|num_reqs
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_FAULT
argument_list|,
literal|"Cannot allocate SIMQ\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|unit
operator|=
name|device_get_unit
argument_list|(
name|sc
operator|->
name|mps_dev
argument_list|)
expr_stmt|;
name|sassc
operator|->
name|sim
operator|=
name|cam_sim_alloc
argument_list|(
name|mpssas_action
argument_list|,
name|mpssas_poll
argument_list|,
literal|"mps"
argument_list|,
name|sassc
argument_list|,
name|unit
argument_list|,
operator|&
name|sc
operator|->
name|mps_mtx
argument_list|,
name|sc
operator|->
name|num_reqs
argument_list|,
name|sc
operator|->
name|num_reqs
argument_list|,
name|sassc
operator|->
name|devq
argument_list|)
expr_stmt|;
if|if
condition|(
name|sassc
operator|->
name|sim
operator|==
name|NULL
condition|)
block|{
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_FAULT
argument_list|,
literal|"Cannot allocate SIM\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|TAILQ_INIT
argument_list|(
operator|&
name|sassc
operator|->
name|ev_queue
argument_list|)
expr_stmt|;
comment|/* Initialize taskqueue for Event Handling */
name|TASK_INIT
argument_list|(
operator|&
name|sassc
operator|->
name|ev_task
argument_list|,
literal|0
argument_list|,
name|mpssas_firmware_event_work
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|sassc
operator|->
name|ev_tq
operator|=
name|taskqueue_create
argument_list|(
literal|"mps_taskq"
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|,
name|taskqueue_thread_enqueue
argument_list|,
operator|&
name|sassc
operator|->
name|ev_tq
argument_list|)
expr_stmt|;
comment|/* Run the task queue with lowest priority */
name|taskqueue_start_threads
argument_list|(
operator|&
name|sassc
operator|->
name|ev_tq
argument_list|,
literal|1
argument_list|,
literal|255
argument_list|,
literal|"%s taskq"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|mps_dev
argument_list|)
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|sassc
operator|->
name|ccb_scanq
argument_list|)
expr_stmt|;
name|error
operator|=
name|mps_kproc_create
argument_list|(
name|mpssas_scanner_thread
argument_list|,
name|sassc
argument_list|,
operator|&
name|sassc
operator|->
name|rescan_thread
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"mps_scan%d"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|mps_printf
argument_list|(
name|sc
argument_list|,
literal|"Error %d starting rescan thread\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|mps_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sassc
operator|->
name|flags
operator||=
name|MPSSAS_SCANTHREAD
expr_stmt|;
comment|/* 	 * XXX There should be a bus for every port on the adapter, but since 	 * we're just going to fake the topology for now, we'll pretend that 	 * everything is just a target on a single bus. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|xpt_bus_register
argument_list|(
name|sassc
operator|->
name|sim
argument_list|,
name|sc
operator|->
name|mps_dev
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_FAULT
argument_list|,
literal|"Error %d registering SCSI bus\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|mps_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * Assume that discovery events will start right away.  Freezing 	 * the simq will prevent the CAM boottime scanner from running 	 * before discovery is complete. 	 */
name|sassc
operator|->
name|flags
operator||=
name|MPSSAS_IN_STARTUP
operator||
name|MPSSAS_IN_DISCOVERY
expr_stmt|;
name|xpt_freeze_simq
argument_list|(
name|sassc
operator|->
name|sim
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sassc
operator|->
name|startup_refcount
operator|=
literal|0
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|sassc
operator|->
name|discovery_callout
argument_list|,
literal|1
comment|/*mpsafe*/
argument_list|)
expr_stmt|;
name|sassc
operator|->
name|discovery_timeouts
operator|=
literal|0
expr_stmt|;
name|sassc
operator|->
name|tm_count
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|1000006
name|status
operator|=
name|xpt_register_async
argument_list|(
name|AC_ADVINFO_CHANGED
argument_list|,
name|mpssas_async
argument_list|,
name|sc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|mps_printf
argument_list|(
name|sc
argument_list|,
literal|"Error %#x registering async handler for "
literal|"AC_ADVINFO_CHANGED events\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|mps_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mpssas_register_events
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|error
condition|)
name|mps_detach_sas
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|mps_detach_sas
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|mpssas_softc
modifier|*
name|sassc
decl_stmt|;
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_TRACE
argument_list|,
literal|"%s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sassc
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|sassc
operator|=
name|sc
operator|->
name|sassc
expr_stmt|;
name|mps_deregister_events
argument_list|(
name|sc
argument_list|,
name|sassc
operator|->
name|mpssas_eh
argument_list|)
expr_stmt|;
comment|/* 	 * Drain and free the event handling taskqueue with the lock 	 * unheld so that any parallel processing tasks drain properly 	 * without deadlocking. 	 */
if|if
condition|(
name|sassc
operator|->
name|ev_tq
operator|!=
name|NULL
condition|)
name|taskqueue_free
argument_list|(
name|sassc
operator|->
name|ev_tq
argument_list|)
expr_stmt|;
comment|/* Make sure CAM doesn't wedge if we had to bail out early. */
name|mps_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Deregister our async handler */
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|1000006
name|xpt_register_async
argument_list|(
literal|0
argument_list|,
name|mpssas_async
argument_list|,
name|sc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sassc
operator|->
name|flags
operator|&
name|MPSSAS_IN_STARTUP
condition|)
name|xpt_release_simq
argument_list|(
name|sassc
operator|->
name|sim
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sassc
operator|->
name|sim
operator|!=
name|NULL
condition|)
block|{
name|xpt_bus_deregister
argument_list|(
name|cam_sim_path
argument_list|(
name|sassc
operator|->
name|sim
argument_list|)
argument_list|)
expr_stmt|;
name|cam_sim_free
argument_list|(
name|sassc
operator|->
name|sim
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sassc
operator|->
name|flags
operator|&
name|MPSSAS_SCANTHREAD
condition|)
block|{
name|sassc
operator|->
name|flags
operator||=
name|MPSSAS_SHUTDOWN
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|sassc
operator|->
name|ccb_scanq
argument_list|)
expr_stmt|;
if|if
condition|(
name|sassc
operator|->
name|flags
operator|&
name|MPSSAS_SCANTHREAD
condition|)
block|{
name|msleep
argument_list|(
operator|&
name|sassc
operator|->
name|flags
argument_list|,
operator|&
name|sc
operator|->
name|mps_mtx
argument_list|,
name|PRIBIO
argument_list|,
literal|"mps_shutdown"
argument_list|,
literal|30
operator|*
name|hz
argument_list|)
expr_stmt|;
block|}
block|}
name|mps_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sassc
operator|->
name|devq
operator|!=
name|NULL
condition|)
name|cam_simq_free
argument_list|(
name|sassc
operator|->
name|devq
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sassc
operator|->
name|targets
argument_list|,
name|M_MPT2
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sassc
argument_list|,
name|M_MPT2
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sassc
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|mpssas_discovery_end
parameter_list|(
name|struct
name|mpssas_softc
modifier|*
name|sassc
parameter_list|)
block|{
name|struct
name|mps_softc
modifier|*
name|sc
init|=
name|sassc
operator|->
name|sc
decl_stmt|;
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_TRACE
argument_list|,
literal|"%s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|sassc
operator|->
name|flags
operator|&
name|MPSSAS_DISCOVERY_TIMEOUT_PENDING
condition|)
name|callout_stop
argument_list|(
operator|&
name|sassc
operator|->
name|discovery_callout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mpssas_discovery_timeout
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|mpssas_softc
modifier|*
name|sassc
init|=
name|data
decl_stmt|;
name|struct
name|mps_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|sassc
operator|->
name|sc
expr_stmt|;
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_TRACE
argument_list|,
literal|"%s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|mps_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mps_printf
argument_list|(
name|sc
argument_list|,
literal|"Timeout waiting for discovery, interrupts may not be working!\n"
argument_list|)
expr_stmt|;
name|sassc
operator|->
name|flags
operator|&=
operator|~
name|MPSSAS_DISCOVERY_TIMEOUT_PENDING
expr_stmt|;
comment|/* Poll the hardware for events in case interrupts aren't working */
name|mps_intr_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mps_printf
argument_list|(
name|sassc
operator|->
name|sc
argument_list|,
literal|"Finished polling after discovery timeout at %d\n"
argument_list|,
name|ticks
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sassc
operator|->
name|flags
operator|&
name|MPSSAS_IN_DISCOVERY
operator|)
operator|==
literal|0
condition|)
block|{
name|mpssas_discovery_end
argument_list|(
name|sassc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|sassc
operator|->
name|discovery_timeouts
operator|<
name|MPSSAS_MAX_DISCOVERY_TIMEOUTS
condition|)
block|{
name|sassc
operator|->
name|flags
operator||=
name|MPSSAS_DISCOVERY_TIMEOUT_PENDING
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sassc
operator|->
name|discovery_callout
argument_list|,
name|MPSSAS_DISCOVERY_TIMEOUT
operator|*
name|hz
argument_list|,
name|mpssas_discovery_timeout
argument_list|,
name|sassc
argument_list|)
expr_stmt|;
name|sassc
operator|->
name|discovery_timeouts
operator|++
expr_stmt|;
block|}
else|else
block|{
name|mps_dprint
argument_list|(
name|sassc
operator|->
name|sc
argument_list|,
name|MPS_FAULT
argument_list|,
literal|"Discovery timed out, continuing.\n"
argument_list|)
expr_stmt|;
name|sassc
operator|->
name|flags
operator|&=
operator|~
name|MPSSAS_IN_DISCOVERY
expr_stmt|;
name|mpssas_discovery_end
argument_list|(
name|sassc
argument_list|)
expr_stmt|;
block|}
block|}
name|mps_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mpssas_action
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|struct
name|mpssas_softc
modifier|*
name|sassc
decl_stmt|;
name|sassc
operator|=
name|cam_sim_softc
argument_list|(
name|sim
argument_list|)
expr_stmt|;
name|mps_dprint
argument_list|(
name|sassc
operator|->
name|sc
argument_list|,
name|MPS_TRACE
argument_list|,
literal|"%s func 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sassc
operator|->
name|sc
operator|->
name|mps_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
condition|)
block|{
case|case
name|XPT_PATH_INQ
case|:
block|{
name|struct
name|ccb_pathinq
modifier|*
name|cpi
init|=
operator|&
name|ccb
operator|->
name|cpi
decl_stmt|;
name|cpi
operator|->
name|version_num
operator|=
literal|1
expr_stmt|;
name|cpi
operator|->
name|hba_inquiry
operator|=
name|PI_SDTR_ABLE
operator||
name|PI_TAG_ABLE
operator||
name|PI_WIDE_16
expr_stmt|;
name|cpi
operator|->
name|target_sprt
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|hba_misc
operator|=
name|PIM_NOBUSRESET
expr_stmt|;
name|cpi
operator|->
name|hba_eng_cnt
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|max_target
operator|=
name|sassc
operator|->
name|sc
operator|->
name|facts
operator|->
name|MaxTargets
operator|-
literal|1
expr_stmt|;
name|cpi
operator|->
name|max_lun
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|initiator_id
operator|=
literal|255
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|sim_vid
argument_list|,
literal|"FreeBSD"
argument_list|,
name|SIM_IDLEN
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|hba_vid
argument_list|,
literal|"LSILogic"
argument_list|,
name|HBA_IDLEN
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|dev_name
argument_list|,
name|cam_sim_name
argument_list|(
name|sim
argument_list|)
argument_list|,
name|DEV_IDLEN
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|unit_number
operator|=
name|cam_sim_unit
argument_list|(
name|sim
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|bus_id
operator|=
name|cam_sim_bus
argument_list|(
name|sim
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|base_transfer_speed
operator|=
literal|150000
expr_stmt|;
name|cpi
operator|->
name|transport
operator|=
name|XPORT_SAS
expr_stmt|;
name|cpi
operator|->
name|transport_version
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|protocol
operator|=
name|PROTO_SCSI
expr_stmt|;
name|cpi
operator|->
name|protocol_version
operator|=
name|SCSI_REV_SPC
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|800001
comment|/* 		 * XXX KDM where does this number come from? 		 */
name|cpi
operator|->
name|maxio
operator|=
literal|256
operator|*
literal|1024
expr_stmt|;
endif|#
directive|endif
name|cpi
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
break|break;
block|}
case|case
name|XPT_GET_TRAN_SETTINGS
case|:
block|{
name|struct
name|ccb_trans_settings
modifier|*
name|cts
decl_stmt|;
name|struct
name|ccb_trans_settings_sas
modifier|*
name|sas
decl_stmt|;
name|struct
name|ccb_trans_settings_scsi
modifier|*
name|scsi
decl_stmt|;
name|struct
name|mpssas_target
modifier|*
name|targ
decl_stmt|;
name|cts
operator|=
operator|&
name|ccb
operator|->
name|cts
expr_stmt|;
name|sas
operator|=
operator|&
name|cts
operator|->
name|xport_specific
operator|.
name|sas
expr_stmt|;
name|scsi
operator|=
operator|&
name|cts
operator|->
name|proto_specific
operator|.
name|scsi
expr_stmt|;
name|targ
operator|=
operator|&
name|sassc
operator|->
name|targets
index|[
name|cts
operator|->
name|ccb_h
operator|.
name|target_id
index|]
expr_stmt|;
if|if
condition|(
name|targ
operator|->
name|handle
operator|==
literal|0x0
condition|)
block|{
name|cts
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_TID_INVALID
expr_stmt|;
break|break;
block|}
name|cts
operator|->
name|protocol_version
operator|=
name|SCSI_REV_SPC2
expr_stmt|;
name|cts
operator|->
name|transport
operator|=
name|XPORT_SAS
expr_stmt|;
name|cts
operator|->
name|transport_version
operator|=
literal|0
expr_stmt|;
name|sas
operator|->
name|valid
operator|=
name|CTS_SAS_VALID_SPEED
expr_stmt|;
switch|switch
condition|(
name|targ
operator|->
name|linkrate
condition|)
block|{
case|case
literal|0x08
case|:
name|sas
operator|->
name|bitrate
operator|=
literal|150000
expr_stmt|;
break|break;
case|case
literal|0x09
case|:
name|sas
operator|->
name|bitrate
operator|=
literal|300000
expr_stmt|;
break|break;
case|case
literal|0x0a
case|:
name|sas
operator|->
name|bitrate
operator|=
literal|600000
expr_stmt|;
break|break;
default|default:
name|sas
operator|->
name|valid
operator|=
literal|0
expr_stmt|;
block|}
name|cts
operator|->
name|protocol
operator|=
name|PROTO_SCSI
expr_stmt|;
name|scsi
operator|->
name|valid
operator|=
name|CTS_SCSI_VALID_TQ
expr_stmt|;
name|scsi
operator|->
name|flags
operator|=
name|CTS_SCSI_FLAGS_TAG_ENB
expr_stmt|;
name|cts
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
break|break;
block|}
case|case
name|XPT_CALC_GEOMETRY
case|:
name|cam_calc_geometry
argument_list|(
operator|&
name|ccb
operator|->
name|ccg
argument_list|,
comment|/*extended*/
literal|1
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
break|break;
case|case
name|XPT_RESET_DEV
case|:
name|mps_printf
argument_list|(
name|sassc
operator|->
name|sc
argument_list|,
literal|"mpssas_action XPT_RESET_DEV\n"
argument_list|)
expr_stmt|;
name|mpssas_action_resetdev
argument_list|(
name|sassc
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
return|return;
case|case
name|XPT_RESET_BUS
case|:
case|case
name|XPT_ABORT
case|:
case|case
name|XPT_TERM_IO
case|:
name|mps_printf
argument_list|(
name|sassc
operator|->
name|sc
argument_list|,
literal|"mpssas_action faking success for "
literal|"abort or reset\n"
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
break|break;
case|case
name|XPT_SCSI_IO
case|:
name|mpssas_action_scsiio
argument_list|(
name|sassc
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
return|return;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|900026
case|case
name|XPT_SMP_IO
case|:
name|mpssas_action_smpio
argument_list|(
name|sassc
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
return|return;
endif|#
directive|endif
default|default:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_FUNC_NOTAVAIL
expr_stmt|;
break|break;
block|}
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mpssas_announce_reset
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|ac_code
parameter_list|,
name|target_id_t
name|target_id
parameter_list|,
name|lun_id_t
name|lun_id
parameter_list|)
block|{
name|path_id_t
name|path_id
init|=
name|cam_sim_path
argument_list|(
name|sc
operator|->
name|sassc
operator|->
name|sim
argument_list|)
decl_stmt|;
name|struct
name|cam_path
modifier|*
name|path
decl_stmt|;
name|mps_printf
argument_list|(
name|sc
argument_list|,
literal|"%s code %x target %d lun %d\n"
argument_list|,
name|__func__
argument_list|,
name|ac_code
argument_list|,
name|target_id
argument_list|,
name|lun_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|xpt_create_path
argument_list|(
operator|&
name|path
argument_list|,
name|NULL
argument_list|,
name|path_id
argument_list|,
name|target_id
argument_list|,
name|lun_id
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|mps_printf
argument_list|(
name|sc
argument_list|,
literal|"unable to create path for reset "
literal|"notification\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|xpt_async
argument_list|(
name|ac_code
argument_list|,
name|path
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|xpt_free_path
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mpssas_complete_all_commands
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|mps_command
modifier|*
name|cm
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|completed
decl_stmt|;
name|mps_printf
argument_list|(
name|sc
argument_list|,
literal|"%s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sc
operator|->
name|mps_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* complete all commands with a NULL reply */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|sc
operator|->
name|num_reqs
condition|;
name|i
operator|++
control|)
block|{
name|cm
operator|=
operator|&
name|sc
operator|->
name|commands
index|[
name|i
index|]
expr_stmt|;
name|cm
operator|->
name|cm_reply
operator|=
name|NULL
expr_stmt|;
name|completed
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cm
operator|->
name|cm_flags
operator|&
name|MPS_CM_FLAGS_POLLED
condition|)
name|cm
operator|->
name|cm_flags
operator||=
name|MPS_CM_FLAGS_COMPLETE
expr_stmt|;
if|if
condition|(
name|cm
operator|->
name|cm_complete
operator|!=
name|NULL
condition|)
block|{
name|mpssas_log_command
argument_list|(
name|cm
argument_list|,
literal|"completing cm %p state %x ccb %p for diag reset\n"
argument_list|,
name|cm
argument_list|,
name|cm
operator|->
name|cm_state
argument_list|,
name|cm
operator|->
name|cm_ccb
argument_list|)
expr_stmt|;
name|cm
operator|->
name|cm_complete
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
name|completed
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|cm
operator|->
name|cm_flags
operator|&
name|MPS_CM_FLAGS_WAKEUP
condition|)
block|{
name|mpssas_log_command
argument_list|(
name|cm
argument_list|,
literal|"waking up cm %p state %x ccb %p for diag reset\n"
argument_list|,
name|cm
argument_list|,
name|cm
operator|->
name|cm_state
argument_list|,
name|cm
operator|->
name|cm_ccb
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|cm
argument_list|)
expr_stmt|;
name|completed
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|completed
operator|==
literal|0
operator|)
operator|&&
operator|(
name|cm
operator|->
name|cm_state
operator|!=
name|MPS_CM_STATE_FREE
operator|)
condition|)
block|{
comment|/* this should never happen, but if it does, log */
name|mpssas_log_command
argument_list|(
name|cm
argument_list|,
literal|"cm %p state %x flags 0x%x ccb %p during diag "
literal|"reset\n"
argument_list|,
name|cm
argument_list|,
name|cm
operator|->
name|cm_state
argument_list|,
name|cm
operator|->
name|cm_flags
argument_list|,
name|cm
operator|->
name|cm_ccb
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|mpssas_handle_reinit
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* Go back into startup mode and freeze the simq, so that CAM 	 * doesn't send any commands until after we've rediscovered all 	 * targets and found the proper device handles for them. 	 * 	 * After the reset, portenable will trigger discovery, and after all 	 * discovery-related activities have finished, the simq will be 	 * released. 	 */
name|mps_printf
argument_list|(
name|sc
argument_list|,
literal|"%s startup\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sassc
operator|->
name|flags
operator||=
name|MPSSAS_IN_STARTUP
expr_stmt|;
name|sc
operator|->
name|sassc
operator|->
name|flags
operator||=
name|MPSSAS_IN_DISCOVERY
expr_stmt|;
name|xpt_freeze_simq
argument_list|(
name|sc
operator|->
name|sassc
operator|->
name|sim
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* notify CAM of a bus reset */
name|mpssas_announce_reset
argument_list|(
name|sc
argument_list|,
name|AC_BUS_RESET
argument_list|,
name|CAM_TARGET_WILDCARD
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|)
expr_stmt|;
comment|/* complete and cleanup after all outstanding commands */
name|mpssas_complete_all_commands
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mps_printf
argument_list|(
name|sc
argument_list|,
literal|"%s startup %u tm %u after command completion\n"
argument_list|,
name|__func__
argument_list|,
name|sc
operator|->
name|sassc
operator|->
name|startup_refcount
argument_list|,
name|sc
operator|->
name|sassc
operator|->
name|tm_count
argument_list|)
expr_stmt|;
comment|/* 	 * The simq was explicitly frozen above, so set the refcount to 0. 	 * The simq will be explicitly released after port enable completes. 	 */
name|sc
operator|->
name|sassc
operator|->
name|startup_refcount
operator|=
literal|0
expr_stmt|;
comment|/* zero all the target handles, since they may change after the 	 * reset, and we have to rediscover all the targets and use the new 	 * handles.   	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|facts
operator|->
name|MaxTargets
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|sassc
operator|->
name|targets
index|[
name|i
index|]
operator|.
name|outstanding
operator|!=
literal|0
condition|)
name|mps_printf
argument_list|(
name|sc
argument_list|,
literal|"target %u outstanding %u\n"
argument_list|,
name|i
argument_list|,
name|sc
operator|->
name|sassc
operator|->
name|targets
index|[
name|i
index|]
operator|.
name|outstanding
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sassc
operator|->
name|targets
index|[
name|i
index|]
operator|.
name|handle
operator|=
literal|0x0
expr_stmt|;
name|sc
operator|->
name|sassc
operator|->
name|targets
index|[
name|i
index|]
operator|.
name|exp_dev_handle
operator|=
literal|0x0
expr_stmt|;
name|sc
operator|->
name|sassc
operator|->
name|targets
index|[
name|i
index|]
operator|.
name|outstanding
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sassc
operator|->
name|targets
index|[
name|i
index|]
operator|.
name|flags
operator|=
name|MPSSAS_TARGET_INDIAGRESET
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|mpssas_tm_timeout
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|mps_command
modifier|*
name|tm
init|=
name|data
decl_stmt|;
name|struct
name|mps_softc
modifier|*
name|sc
init|=
name|tm
operator|->
name|cm_sc
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sc
operator|->
name|mps_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|mpssas_log_command
argument_list|(
name|tm
argument_list|,
literal|"task mgmt %p timed out\n"
argument_list|,
name|tm
argument_list|)
expr_stmt|;
name|mps_reinit
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mpssas_logical_unit_reset_complete
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mps_command
modifier|*
name|tm
parameter_list|)
block|{
name|MPI2_SCSI_TASK_MANAGE_REPLY
modifier|*
name|reply
decl_stmt|;
name|MPI2_SCSI_TASK_MANAGE_REQUEST
modifier|*
name|req
decl_stmt|;
name|unsigned
name|int
name|cm_count
init|=
literal|0
decl_stmt|;
name|struct
name|mps_command
modifier|*
name|cm
decl_stmt|;
name|struct
name|mpssas_target
modifier|*
name|targ
decl_stmt|;
name|callout_stop
argument_list|(
operator|&
name|tm
operator|->
name|cm_callout
argument_list|)
expr_stmt|;
name|req
operator|=
operator|(
name|MPI2_SCSI_TASK_MANAGE_REQUEST
operator|*
operator|)
name|tm
operator|->
name|cm_req
expr_stmt|;
name|reply
operator|=
operator|(
name|MPI2_SCSI_TASK_MANAGE_REPLY
operator|*
operator|)
name|tm
operator|->
name|cm_reply
expr_stmt|;
name|targ
operator|=
name|tm
operator|->
name|cm_targ
expr_stmt|;
comment|/* 	 * Currently there should be no way we can hit this case.  It only 	 * happens when we have a failure to allocate chain frames, and 	 * task management commands don't have S/G lists. 	 */
if|if
condition|(
operator|(
name|tm
operator|->
name|cm_flags
operator|&
name|MPS_CM_FLAGS_ERROR_MASK
operator|)
operator|!=
literal|0
condition|)
block|{
name|mps_printf
argument_list|(
name|sc
argument_list|,
literal|"%s: cm_flags = %#x for LUN reset! "
literal|"This should not happen!\n"
argument_list|,
name|__func__
argument_list|,
name|tm
operator|->
name|cm_flags
argument_list|)
expr_stmt|;
name|mpssas_free_tm
argument_list|(
name|sc
argument_list|,
name|tm
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|reply
operator|==
name|NULL
condition|)
block|{
name|mpssas_log_command
argument_list|(
name|tm
argument_list|,
literal|"NULL reset reply for tm %p\n"
argument_list|,
name|tm
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|mps_flags
operator|&
name|MPS_FLAGS_DIAGRESET
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* this completion was due to a reset, just cleanup */
name|targ
operator|->
name|flags
operator|&=
operator|~
name|MPSSAS_TARGET_INRESET
expr_stmt|;
name|targ
operator|->
name|tm
operator|=
name|NULL
expr_stmt|;
name|mpssas_free_tm
argument_list|(
name|sc
argument_list|,
name|tm
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* we should have gotten a reply. */
name|mps_reinit
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|mpssas_log_command
argument_list|(
name|tm
argument_list|,
literal|"logical unit reset status 0x%x code 0x%x count %u\n"
argument_list|,
name|reply
operator|->
name|IOCStatus
argument_list|,
name|reply
operator|->
name|ResponseCode
argument_list|,
name|reply
operator|->
name|TerminationCount
argument_list|)
expr_stmt|;
comment|/* See if there are any outstanding commands for this LUN. 	 * This could be made more efficient by using a per-LU data 	 * structure of some sort. 	 */
name|TAILQ_FOREACH
argument_list|(
argument|cm
argument_list|,
argument|&targ->commands
argument_list|,
argument|cm_link
argument_list|)
block|{
if|if
condition|(
name|cm
operator|->
name|cm_lun
operator|==
name|tm
operator|->
name|cm_lun
condition|)
name|cm_count
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|cm_count
operator|==
literal|0
condition|)
block|{
name|mpssas_log_command
argument_list|(
name|tm
argument_list|,
literal|"logical unit %u finished recovery after reset\n"
argument_list|,
name|tm
operator|->
name|cm_lun
argument_list|,
name|tm
argument_list|)
expr_stmt|;
name|mpssas_announce_reset
argument_list|(
name|sc
argument_list|,
name|AC_SENT_BDR
argument_list|,
name|tm
operator|->
name|cm_targ
operator|->
name|tid
argument_list|,
name|tm
operator|->
name|cm_lun
argument_list|)
expr_stmt|;
comment|/* we've finished recovery for this logical unit.  check and 		 * see if some other logical unit has a timedout command 		 * that needs to be processed. 		 */
name|cm
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|targ
operator|->
name|timedout_commands
argument_list|)
expr_stmt|;
if|if
condition|(
name|cm
condition|)
block|{
name|mpssas_send_abort
argument_list|(
name|sc
argument_list|,
name|tm
argument_list|,
name|cm
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|targ
operator|->
name|tm
operator|=
name|NULL
expr_stmt|;
name|mpssas_free_tm
argument_list|(
name|sc
argument_list|,
name|tm
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* if we still have commands for this LUN, the reset 		 * effectively failed, regardless of the status reported. 		 * Escalate to a target reset. 		 */
name|mpssas_log_command
argument_list|(
name|tm
argument_list|,
literal|"logical unit reset complete for tm %p, but still have %u command(s)\n"
argument_list|,
name|tm
argument_list|,
name|cm_count
argument_list|)
expr_stmt|;
name|mpssas_send_reset
argument_list|(
name|sc
argument_list|,
name|tm
argument_list|,
name|MPI2_SCSITASKMGMT_TASKTYPE_TARGET_RESET
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|mpssas_target_reset_complete
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mps_command
modifier|*
name|tm
parameter_list|)
block|{
name|MPI2_SCSI_TASK_MANAGE_REPLY
modifier|*
name|reply
decl_stmt|;
name|MPI2_SCSI_TASK_MANAGE_REQUEST
modifier|*
name|req
decl_stmt|;
name|struct
name|mpssas_target
modifier|*
name|targ
decl_stmt|;
name|callout_stop
argument_list|(
operator|&
name|tm
operator|->
name|cm_callout
argument_list|)
expr_stmt|;
name|req
operator|=
operator|(
name|MPI2_SCSI_TASK_MANAGE_REQUEST
operator|*
operator|)
name|tm
operator|->
name|cm_req
expr_stmt|;
name|reply
operator|=
operator|(
name|MPI2_SCSI_TASK_MANAGE_REPLY
operator|*
operator|)
name|tm
operator|->
name|cm_reply
expr_stmt|;
name|targ
operator|=
name|tm
operator|->
name|cm_targ
expr_stmt|;
comment|/* 	 * Currently there should be no way we can hit this case.  It only 	 * happens when we have a failure to allocate chain frames, and 	 * task management commands don't have S/G lists. 	 */
if|if
condition|(
operator|(
name|tm
operator|->
name|cm_flags
operator|&
name|MPS_CM_FLAGS_ERROR_MASK
operator|)
operator|!=
literal|0
condition|)
block|{
name|mps_printf
argument_list|(
name|sc
argument_list|,
literal|"%s: cm_flags = %#x for target reset! "
literal|"This should not happen!\n"
argument_list|,
name|__func__
argument_list|,
name|tm
operator|->
name|cm_flags
argument_list|)
expr_stmt|;
name|mpssas_free_tm
argument_list|(
name|sc
argument_list|,
name|tm
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|reply
operator|==
name|NULL
condition|)
block|{
name|mpssas_log_command
argument_list|(
name|tm
argument_list|,
literal|"NULL reset reply for tm %p\n"
argument_list|,
name|tm
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|mps_flags
operator|&
name|MPS_FLAGS_DIAGRESET
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* this completion was due to a reset, just cleanup */
name|targ
operator|->
name|flags
operator|&=
operator|~
name|MPSSAS_TARGET_INRESET
expr_stmt|;
name|targ
operator|->
name|tm
operator|=
name|NULL
expr_stmt|;
name|mpssas_free_tm
argument_list|(
name|sc
argument_list|,
name|tm
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* we should have gotten a reply. */
name|mps_reinit
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|mpssas_log_command
argument_list|(
name|tm
argument_list|,
literal|"target reset status 0x%x code 0x%x count %u\n"
argument_list|,
name|reply
operator|->
name|IOCStatus
argument_list|,
name|reply
operator|->
name|ResponseCode
argument_list|,
name|reply
operator|->
name|TerminationCount
argument_list|)
expr_stmt|;
name|targ
operator|->
name|flags
operator|&=
operator|~
name|MPSSAS_TARGET_INRESET
expr_stmt|;
if|if
condition|(
name|targ
operator|->
name|outstanding
operator|==
literal|0
condition|)
block|{
comment|/* we've finished recovery for this target and all 		 * of its logical units. 		 */
name|mpssas_log_command
argument_list|(
name|tm
argument_list|,
literal|"recovery finished after target reset\n"
argument_list|)
expr_stmt|;
name|mpssas_announce_reset
argument_list|(
name|sc
argument_list|,
name|AC_SENT_BDR
argument_list|,
name|tm
operator|->
name|cm_targ
operator|->
name|tid
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|)
expr_stmt|;
name|targ
operator|->
name|tm
operator|=
name|NULL
expr_stmt|;
name|mpssas_free_tm
argument_list|(
name|sc
argument_list|,
name|tm
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* after a target reset, if this target still has 		 * outstanding commands, the reset effectively failed, 		 * regardless of the status reported.  escalate. 		 */
name|mpssas_log_command
argument_list|(
name|tm
argument_list|,
literal|"target reset complete for tm %p, but still have %u command(s)\n"
argument_list|,
name|tm
argument_list|,
name|targ
operator|->
name|outstanding
argument_list|)
expr_stmt|;
name|mps_reinit
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|MPS_RESET_TIMEOUT
value|30
end_define

begin_function
specifier|static
name|int
name|mpssas_send_reset
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mps_command
modifier|*
name|tm
parameter_list|,
name|uint8_t
name|type
parameter_list|)
block|{
name|MPI2_SCSI_TASK_MANAGE_REQUEST
modifier|*
name|req
decl_stmt|;
name|struct
name|mpssas_target
modifier|*
name|target
decl_stmt|;
name|int
name|err
decl_stmt|;
name|target
operator|=
name|tm
operator|->
name|cm_targ
expr_stmt|;
if|if
condition|(
name|target
operator|->
name|handle
operator|==
literal|0
condition|)
block|{
name|mps_printf
argument_list|(
name|sc
argument_list|,
literal|"%s null devhandle for target_id %d\n"
argument_list|,
name|__func__
argument_list|,
name|target
operator|->
name|tid
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|req
operator|=
operator|(
name|MPI2_SCSI_TASK_MANAGE_REQUEST
operator|*
operator|)
name|tm
operator|->
name|cm_req
expr_stmt|;
name|req
operator|->
name|DevHandle
operator|=
name|target
operator|->
name|handle
expr_stmt|;
name|req
operator|->
name|Function
operator|=
name|MPI2_FUNCTION_SCSI_TASK_MGMT
expr_stmt|;
name|req
operator|->
name|TaskType
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|MPI2_SCSITASKMGMT_TASKTYPE_LOGICAL_UNIT_RESET
condition|)
block|{
comment|/* XXX Need to handle invalid LUNs */
name|MPS_SET_LUN
argument_list|(
name|req
operator|->
name|LUN
argument_list|,
name|tm
operator|->
name|cm_lun
argument_list|)
expr_stmt|;
name|tm
operator|->
name|cm_targ
operator|->
name|logical_unit_resets
operator|++
expr_stmt|;
name|mpssas_log_command
argument_list|(
name|tm
argument_list|,
literal|"sending logical unit reset\n"
argument_list|)
expr_stmt|;
name|tm
operator|->
name|cm_complete
operator|=
name|mpssas_logical_unit_reset_complete
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|MPI2_SCSITASKMGMT_TASKTYPE_TARGET_RESET
condition|)
block|{
comment|/* Target reset method =  SAS Hard Link Reset / SATA Link Reset */
name|req
operator|->
name|MsgFlags
operator|=
name|MPI2_SCSITASKMGMT_MSGFLAGS_LINK_RESET
expr_stmt|;
name|tm
operator|->
name|cm_targ
operator|->
name|target_resets
operator|++
expr_stmt|;
name|tm
operator|->
name|cm_targ
operator|->
name|flags
operator||=
name|MPSSAS_TARGET_INRESET
expr_stmt|;
name|mpssas_log_command
argument_list|(
name|tm
argument_list|,
literal|"sending target reset\n"
argument_list|)
expr_stmt|;
name|tm
operator|->
name|cm_complete
operator|=
name|mpssas_target_reset_complete
expr_stmt|;
block|}
else|else
block|{
name|mps_printf
argument_list|(
name|sc
argument_list|,
literal|"unexpected reset type 0x%x\n"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|tm
operator|->
name|cm_data
operator|=
name|NULL
expr_stmt|;
name|tm
operator|->
name|cm_desc
operator|.
name|HighPriority
operator|.
name|RequestFlags
operator|=
name|MPI2_REQ_DESCRIPT_FLAGS_HIGH_PRIORITY
expr_stmt|;
name|tm
operator|->
name|cm_complete_data
operator|=
operator|(
name|void
operator|*
operator|)
name|tm
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|tm
operator|->
name|cm_callout
argument_list|,
name|MPS_RESET_TIMEOUT
operator|*
name|hz
argument_list|,
name|mpssas_tm_timeout
argument_list|,
name|tm
argument_list|)
expr_stmt|;
name|err
operator|=
name|mps_map_command
argument_list|(
name|sc
argument_list|,
name|tm
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|mpssas_log_command
argument_list|(
name|tm
argument_list|,
literal|"error %d sending reset type %u\n"
argument_list|,
name|err
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mpssas_abort_complete
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mps_command
modifier|*
name|tm
parameter_list|)
block|{
name|struct
name|mps_command
modifier|*
name|cm
decl_stmt|;
name|MPI2_SCSI_TASK_MANAGE_REPLY
modifier|*
name|reply
decl_stmt|;
name|MPI2_SCSI_TASK_MANAGE_REQUEST
modifier|*
name|req
decl_stmt|;
name|struct
name|mpssas_target
modifier|*
name|targ
decl_stmt|;
name|callout_stop
argument_list|(
operator|&
name|tm
operator|->
name|cm_callout
argument_list|)
expr_stmt|;
name|req
operator|=
operator|(
name|MPI2_SCSI_TASK_MANAGE_REQUEST
operator|*
operator|)
name|tm
operator|->
name|cm_req
expr_stmt|;
name|reply
operator|=
operator|(
name|MPI2_SCSI_TASK_MANAGE_REPLY
operator|*
operator|)
name|tm
operator|->
name|cm_reply
expr_stmt|;
name|targ
operator|=
name|tm
operator|->
name|cm_targ
expr_stmt|;
comment|/* 	 * Currently there should be no way we can hit this case.  It only 	 * happens when we have a failure to allocate chain frames, and 	 * task management commands don't have S/G lists. 	 */
if|if
condition|(
operator|(
name|tm
operator|->
name|cm_flags
operator|&
name|MPS_CM_FLAGS_ERROR_MASK
operator|)
operator|!=
literal|0
condition|)
block|{
name|mpssas_log_command
argument_list|(
name|tm
argument_list|,
literal|"cm_flags = %#x for abort %p TaskMID %u!\n"
argument_list|,
name|tm
operator|->
name|cm_flags
argument_list|,
name|tm
argument_list|,
name|req
operator|->
name|TaskMID
argument_list|)
expr_stmt|;
name|mpssas_free_tm
argument_list|(
name|sc
argument_list|,
name|tm
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|reply
operator|==
name|NULL
condition|)
block|{
name|mpssas_log_command
argument_list|(
name|tm
argument_list|,
literal|"NULL abort reply for tm %p TaskMID %u\n"
argument_list|,
name|tm
argument_list|,
name|req
operator|->
name|TaskMID
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|mps_flags
operator|&
name|MPS_FLAGS_DIAGRESET
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* this completion was due to a reset, just cleanup */
name|targ
operator|->
name|tm
operator|=
name|NULL
expr_stmt|;
name|mpssas_free_tm
argument_list|(
name|sc
argument_list|,
name|tm
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* we should have gotten a reply. */
name|mps_reinit
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|mpssas_log_command
argument_list|(
name|tm
argument_list|,
literal|"abort TaskMID %u status 0x%x code 0x%x count %u\n"
argument_list|,
name|req
operator|->
name|TaskMID
argument_list|,
name|reply
operator|->
name|IOCStatus
argument_list|,
name|reply
operator|->
name|ResponseCode
argument_list|,
name|reply
operator|->
name|TerminationCount
argument_list|)
expr_stmt|;
name|cm
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|tm
operator|->
name|cm_targ
operator|->
name|timedout_commands
argument_list|)
expr_stmt|;
if|if
condition|(
name|cm
operator|==
name|NULL
condition|)
block|{
comment|/* if there are no more timedout commands, we're done with 		 * error recovery for this target. 		 */
name|mpssas_log_command
argument_list|(
name|tm
argument_list|,
literal|"finished recovery after aborting TaskMID %u\n"
argument_list|,
name|req
operator|->
name|TaskMID
argument_list|)
expr_stmt|;
name|targ
operator|->
name|tm
operator|=
name|NULL
expr_stmt|;
name|mpssas_free_tm
argument_list|(
name|sc
argument_list|,
name|tm
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|req
operator|->
name|TaskMID
operator|!=
name|cm
operator|->
name|cm_desc
operator|.
name|Default
operator|.
name|SMID
condition|)
block|{
comment|/* abort success, but we have more timedout commands to abort */
name|mpssas_log_command
argument_list|(
name|tm
argument_list|,
literal|"continuing recovery after aborting TaskMID %u\n"
argument_list|,
name|req
operator|->
name|TaskMID
argument_list|)
expr_stmt|;
name|mpssas_send_abort
argument_list|(
name|sc
argument_list|,
name|tm
argument_list|,
name|cm
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* we didn't get a command completion, so the abort 		 * failed as far as we're concerned.  escalate. 		 */
name|mpssas_log_command
argument_list|(
name|tm
argument_list|,
literal|"abort failed for TaskMID %u tm %p\n"
argument_list|,
name|req
operator|->
name|TaskMID
argument_list|,
name|tm
argument_list|)
expr_stmt|;
name|mpssas_send_reset
argument_list|(
name|sc
argument_list|,
name|tm
argument_list|,
name|MPI2_SCSITASKMGMT_TASKTYPE_LOGICAL_UNIT_RESET
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|MPS_ABORT_TIMEOUT
value|5
end_define

begin_function
specifier|static
name|int
name|mpssas_send_abort
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mps_command
modifier|*
name|tm
parameter_list|,
name|struct
name|mps_command
modifier|*
name|cm
parameter_list|)
block|{
name|MPI2_SCSI_TASK_MANAGE_REQUEST
modifier|*
name|req
decl_stmt|;
name|struct
name|mpssas_target
modifier|*
name|targ
decl_stmt|;
name|int
name|err
decl_stmt|;
name|targ
operator|=
name|cm
operator|->
name|cm_targ
expr_stmt|;
if|if
condition|(
name|targ
operator|->
name|handle
operator|==
literal|0
condition|)
block|{
name|mps_printf
argument_list|(
name|sc
argument_list|,
literal|"%s null devhandle for target_id %d\n"
argument_list|,
name|__func__
argument_list|,
name|cm
operator|->
name|cm_ccb
operator|->
name|ccb_h
operator|.
name|target_id
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|req
operator|=
operator|(
name|MPI2_SCSI_TASK_MANAGE_REQUEST
operator|*
operator|)
name|tm
operator|->
name|cm_req
expr_stmt|;
name|req
operator|->
name|DevHandle
operator|=
name|targ
operator|->
name|handle
expr_stmt|;
name|req
operator|->
name|Function
operator|=
name|MPI2_FUNCTION_SCSI_TASK_MGMT
expr_stmt|;
name|req
operator|->
name|TaskType
operator|=
name|MPI2_SCSITASKMGMT_TASKTYPE_ABORT_TASK
expr_stmt|;
comment|/* XXX Need to handle invalid LUNs */
name|MPS_SET_LUN
argument_list|(
name|req
operator|->
name|LUN
argument_list|,
name|cm
operator|->
name|cm_ccb
operator|->
name|ccb_h
operator|.
name|target_lun
argument_list|)
expr_stmt|;
name|req
operator|->
name|TaskMID
operator|=
name|cm
operator|->
name|cm_desc
operator|.
name|Default
operator|.
name|SMID
expr_stmt|;
name|tm
operator|->
name|cm_data
operator|=
name|NULL
expr_stmt|;
name|tm
operator|->
name|cm_desc
operator|.
name|HighPriority
operator|.
name|RequestFlags
operator|=
name|MPI2_REQ_DESCRIPT_FLAGS_HIGH_PRIORITY
expr_stmt|;
name|tm
operator|->
name|cm_complete
operator|=
name|mpssas_abort_complete
expr_stmt|;
name|tm
operator|->
name|cm_complete_data
operator|=
operator|(
name|void
operator|*
operator|)
name|tm
expr_stmt|;
name|tm
operator|->
name|cm_targ
operator|=
name|cm
operator|->
name|cm_targ
expr_stmt|;
name|tm
operator|->
name|cm_lun
operator|=
name|cm
operator|->
name|cm_lun
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|tm
operator|->
name|cm_callout
argument_list|,
name|MPS_ABORT_TIMEOUT
operator|*
name|hz
argument_list|,
name|mpssas_tm_timeout
argument_list|,
name|tm
argument_list|)
expr_stmt|;
name|targ
operator|->
name|aborts
operator|++
expr_stmt|;
name|err
operator|=
name|mps_map_command
argument_list|(
name|sc
argument_list|,
name|tm
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|mpssas_log_command
argument_list|(
name|tm
argument_list|,
literal|"error %d sending abort for cm %p SMID %u\n"
argument_list|,
name|err
argument_list|,
name|cm
argument_list|,
name|req
operator|->
name|TaskMID
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mpssas_scsiio_timeout
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|mps_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mps_command
modifier|*
name|cm
decl_stmt|;
name|struct
name|mpssas_target
modifier|*
name|targ
decl_stmt|;
name|cm
operator|=
operator|(
expr|struct
name|mps_command
operator|*
operator|)
name|data
expr_stmt|;
name|sc
operator|=
name|cm
operator|->
name|cm_sc
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sc
operator|->
name|mps_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|mps_printf
argument_list|(
name|sc
argument_list|,
literal|"%s checking sc %p cm %p\n"
argument_list|,
name|__func__
argument_list|,
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
comment|/* 	 * Run the interrupt handler to make sure it's not pending.  This 	 * isn't perfect because the command could have already completed 	 * and been re-used, though this is unlikely. 	 */
name|mps_intr_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|cm
operator|->
name|cm_state
operator|==
name|MPS_CM_STATE_FREE
condition|)
block|{
name|mps_printf
argument_list|(
name|sc
argument_list|,
literal|"SCSI command %p sc %p almost timed out\n"
argument_list|,
name|cm
argument_list|,
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|cm
operator|->
name|cm_ccb
operator|==
name|NULL
condition|)
block|{
name|mps_printf
argument_list|(
name|sc
argument_list|,
literal|"command timeout with NULL ccb\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|mpssas_log_command
argument_list|(
name|cm
argument_list|,
literal|"command timeout cm %p ccb %p\n"
argument_list|,
name|cm
argument_list|,
name|cm
operator|->
name|cm_ccb
argument_list|)
expr_stmt|;
name|targ
operator|=
name|cm
operator|->
name|cm_targ
expr_stmt|;
name|targ
operator|->
name|timeouts
operator|++
expr_stmt|;
comment|/* XXX first, check the firmware state, to see if it's still 	 * operational.  if not, do a diag reset. 	 */
name|cm
operator|->
name|cm_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_CMD_TIMEOUT
expr_stmt|;
name|cm
operator|->
name|cm_state
operator|=
name|MPS_CM_STATE_TIMEDOUT
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|targ
operator|->
name|timedout_commands
argument_list|,
name|cm
argument_list|,
name|cm_recovery
argument_list|)
expr_stmt|;
if|if
condition|(
name|targ
operator|->
name|tm
operator|!=
name|NULL
condition|)
block|{
comment|/* target already in recovery, just queue up another 		 * timedout command to be processed later. 		 */
name|mps_printf
argument_list|(
name|sc
argument_list|,
literal|"queued timedout cm %p for processing by tm %p\n"
argument_list|,
name|cm
argument_list|,
name|targ
operator|->
name|tm
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|targ
operator|->
name|tm
operator|=
name|mpssas_alloc_tm
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|mps_printf
argument_list|(
name|sc
argument_list|,
literal|"timedout cm %p allocated tm %p\n"
argument_list|,
name|cm
argument_list|,
name|targ
operator|->
name|tm
argument_list|)
expr_stmt|;
comment|/* start recovery by aborting the first timedout command */
name|mpssas_send_abort
argument_list|(
name|sc
argument_list|,
name|targ
operator|->
name|tm
argument_list|,
name|cm
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* XXX queue this target up for recovery once a TM becomes 		 * available.  The firmware only has a limited number of 		 * HighPriority credits for the high priority requests used 		 * for task management, and we ran out. 		 *  		 * Isilon: don't worry about this for now, since we have 		 * more credits than disks in an enclosure, and limit 		 * ourselves to one TM per target for recovery. 		 */
name|mps_printf
argument_list|(
name|sc
argument_list|,
literal|"timedout cm %p failed to allocate a tm\n"
argument_list|,
name|cm
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|mpssas_action_scsiio
parameter_list|(
name|struct
name|mpssas_softc
modifier|*
name|sassc
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|MPI2_SCSI_IO_REQUEST
modifier|*
name|req
decl_stmt|;
name|struct
name|ccb_scsiio
modifier|*
name|csio
decl_stmt|;
name|struct
name|mps_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mpssas_target
modifier|*
name|targ
decl_stmt|;
name|struct
name|mpssas_lun
modifier|*
name|lun
decl_stmt|;
name|struct
name|mps_command
modifier|*
name|cm
decl_stmt|;
name|uint8_t
name|i
decl_stmt|,
name|lba_byte
decl_stmt|,
modifier|*
name|ref_tag_addr
decl_stmt|;
name|uint16_t
name|eedp_flags
decl_stmt|;
name|sc
operator|=
name|sassc
operator|->
name|sc
expr_stmt|;
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_TRACE
argument_list|,
literal|"%s ccb %p\n"
argument_list|,
name|__func__
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sc
operator|->
name|mps_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|csio
operator|=
operator|&
name|ccb
operator|->
name|csio
expr_stmt|;
name|targ
operator|=
operator|&
name|sassc
operator|->
name|targets
index|[
name|csio
operator|->
name|ccb_h
operator|.
name|target_id
index|]
expr_stmt|;
if|if
condition|(
name|targ
operator|->
name|handle
operator|==
literal|0x0
condition|)
block|{
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_TRACE
argument_list|,
literal|"%s NULL handle for target %u\n"
argument_list|,
name|__func__
argument_list|,
name|csio
operator|->
name|ccb_h
operator|.
name|target_id
argument_list|)
expr_stmt|;
name|csio
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_TID_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * If devinfo is 0 this will be a volume.  In that case don't tell CAM 	 * that the volume has timed out.  We want volumes to be enumerated 	 * until they are deleted/removed, not just failed. 	 */
if|if
condition|(
name|targ
operator|->
name|flags
operator|&
name|MPSSAS_TARGET_INREMOVAL
condition|)
block|{
if|if
condition|(
name|targ
operator|->
name|devinfo
operator|==
literal|0
condition|)
name|csio
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
else|else
name|csio
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_SEL_TIMEOUT
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|sc
operator|->
name|mps_flags
operator|&
name|MPS_FLAGS_SHUTDOWN
operator|)
operator|!=
literal|0
condition|)
block|{
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_TRACE
argument_list|,
literal|"%s shutting down\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|csio
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_TID_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
name|cm
operator|=
name|mps_alloc_command
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|cm
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|sassc
operator|->
name|flags
operator|&
name|MPSSAS_QUEUE_FROZEN
operator|)
operator|==
literal|0
condition|)
block|{
name|xpt_freeze_simq
argument_list|(
name|sassc
operator|->
name|sim
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sassc
operator|->
name|flags
operator||=
name|MPSSAS_QUEUE_FROZEN
expr_stmt|;
block|}
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&=
operator|~
name|CAM_SIM_QUEUED
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQUEUE_REQ
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
name|req
operator|=
operator|(
name|MPI2_SCSI_IO_REQUEST
operator|*
operator|)
name|cm
operator|->
name|cm_req
expr_stmt|;
name|bzero
argument_list|(
name|req
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|req
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|->
name|DevHandle
operator|=
name|targ
operator|->
name|handle
expr_stmt|;
name|req
operator|->
name|Function
operator|=
name|MPI2_FUNCTION_SCSI_IO_REQUEST
expr_stmt|;
name|req
operator|->
name|MsgFlags
operator|=
literal|0
expr_stmt|;
name|req
operator|->
name|SenseBufferLowAddress
operator|=
name|cm
operator|->
name|cm_sense_busaddr
expr_stmt|;
name|req
operator|->
name|SenseBufferLength
operator|=
name|MPS_SENSE_LEN
expr_stmt|;
name|req
operator|->
name|SGLFlags
operator|=
literal|0
expr_stmt|;
name|req
operator|->
name|ChainOffset
operator|=
literal|0
expr_stmt|;
name|req
operator|->
name|SGLOffset0
operator|=
literal|24
expr_stmt|;
comment|/* 32bit word offset to the SGL */
name|req
operator|->
name|SGLOffset1
operator|=
literal|0
expr_stmt|;
name|req
operator|->
name|SGLOffset2
operator|=
literal|0
expr_stmt|;
name|req
operator|->
name|SGLOffset3
operator|=
literal|0
expr_stmt|;
name|req
operator|->
name|SkipCount
operator|=
literal|0
expr_stmt|;
name|req
operator|->
name|DataLength
operator|=
name|csio
operator|->
name|dxfer_len
expr_stmt|;
name|req
operator|->
name|BidirectionalDataLength
operator|=
literal|0
expr_stmt|;
name|req
operator|->
name|IoFlags
operator|=
name|csio
operator|->
name|cdb_len
expr_stmt|;
name|req
operator|->
name|EEDPFlags
operator|=
literal|0
expr_stmt|;
comment|/* Note: BiDirectional transfers are not supported */
switch|switch
condition|(
name|csio
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
condition|)
block|{
case|case
name|CAM_DIR_IN
case|:
name|req
operator|->
name|Control
operator|=
name|MPI2_SCSIIO_CONTROL_READ
expr_stmt|;
name|cm
operator|->
name|cm_flags
operator||=
name|MPS_CM_FLAGS_DATAIN
expr_stmt|;
break|break;
case|case
name|CAM_DIR_OUT
case|:
name|req
operator|->
name|Control
operator|=
name|MPI2_SCSIIO_CONTROL_WRITE
expr_stmt|;
name|cm
operator|->
name|cm_flags
operator||=
name|MPS_CM_FLAGS_DATAOUT
expr_stmt|;
break|break;
case|case
name|CAM_DIR_NONE
case|:
default|default:
name|req
operator|->
name|Control
operator|=
name|MPI2_SCSIIO_CONTROL_NODATATRANSFER
expr_stmt|;
break|break;
block|}
comment|/* 	 * It looks like the hardware doesn't require an explicit tag 	 * number for each transaction.  SAM Task Management not supported 	 * at the moment. 	 */
switch|switch
condition|(
name|csio
operator|->
name|tag_action
condition|)
block|{
case|case
name|MSG_HEAD_OF_Q_TAG
case|:
name|req
operator|->
name|Control
operator||=
name|MPI2_SCSIIO_CONTROL_HEADOFQ
expr_stmt|;
break|break;
case|case
name|MSG_ORDERED_Q_TAG
case|:
name|req
operator|->
name|Control
operator||=
name|MPI2_SCSIIO_CONTROL_ORDEREDQ
expr_stmt|;
break|break;
case|case
name|MSG_ACA_TASK
case|:
name|req
operator|->
name|Control
operator||=
name|MPI2_SCSIIO_CONTROL_ACAQ
expr_stmt|;
break|break;
case|case
name|CAM_TAG_ACTION_NONE
case|:
case|case
name|MSG_SIMPLE_Q_TAG
case|:
default|default:
name|req
operator|->
name|Control
operator||=
name|MPI2_SCSIIO_CONTROL_SIMPLEQ
expr_stmt|;
break|break;
block|}
name|req
operator|->
name|Control
operator||=
name|sc
operator|->
name|mapping_table
index|[
name|csio
operator|->
name|ccb_h
operator|.
name|target_id
index|]
operator|.
name|TLR_bits
expr_stmt|;
if|if
condition|(
name|MPS_SET_LUN
argument_list|(
name|req
operator|->
name|LUN
argument_list|,
name|csio
operator|->
name|ccb_h
operator|.
name|target_lun
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|mps_free_command
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_LUN_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|csio
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_CDB_POINTER
condition|)
name|bcopy
argument_list|(
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_ptr
argument_list|,
operator|&
name|req
operator|->
name|CDB
operator|.
name|CDB32
index|[
literal|0
index|]
argument_list|,
name|csio
operator|->
name|cdb_len
argument_list|)
expr_stmt|;
else|else
name|bcopy
argument_list|(
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
argument_list|,
operator|&
name|req
operator|->
name|CDB
operator|.
name|CDB32
index|[
literal|0
index|]
argument_list|,
name|csio
operator|->
name|cdb_len
argument_list|)
expr_stmt|;
name|req
operator|->
name|IoFlags
operator|=
name|csio
operator|->
name|cdb_len
expr_stmt|;
comment|/* 	 * Check if EEDP is supported and enabled.  If it is then check if the 	 * SCSI opcode could be using EEDP.  If so, make sure the LUN exists and 	 * is formatted for EEDP support.  If all of this is true, set CDB up 	 * for EEDP transfer. 	 */
name|eedp_flags
operator|=
name|op_code_prot
index|[
name|req
operator|->
name|CDB
operator|.
name|CDB32
index|[
literal|0
index|]
index|]
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|eedp_enabled
operator|&&
name|eedp_flags
condition|)
block|{
name|SLIST_FOREACH
argument_list|(
argument|lun
argument_list|,
argument|&targ->luns
argument_list|,
argument|lun_link
argument_list|)
block|{
if|if
condition|(
name|lun
operator|->
name|lun_id
operator|==
name|csio
operator|->
name|ccb_h
operator|.
name|target_lun
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
operator|(
name|lun
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|lun
operator|->
name|eedp_formatted
operator|)
condition|)
block|{
name|req
operator|->
name|EEDPBlockSize
operator|=
name|lun
operator|->
name|eedp_block_size
expr_stmt|;
name|eedp_flags
operator||=
operator|(
name|MPI2_SCSIIO_EEDPFLAGS_INC_PRI_REFTAG
operator||
name|MPI2_SCSIIO_EEDPFLAGS_CHECK_REFTAG
operator||
name|MPI2_SCSIIO_EEDPFLAGS_CHECK_GUARD
operator|)
expr_stmt|;
name|req
operator|->
name|EEDPFlags
operator|=
name|eedp_flags
expr_stmt|;
comment|/* 			 * If CDB less than 32, fill in Primary Ref Tag with 			 * low 4 bytes of LBA.  If CDB is 32, tag stuff is 			 * already there.  Also, set protection bit.  FreeBSD 			 * currently does not support CDBs bigger than 16, but 			 * the code doesn't hurt, and will be here for the 			 * future. 			 */
if|if
condition|(
name|csio
operator|->
name|cdb_len
operator|!=
literal|32
condition|)
block|{
name|lba_byte
operator|=
operator|(
name|csio
operator|->
name|cdb_len
operator|==
literal|16
operator|)
condition|?
literal|6
else|:
literal|2
expr_stmt|;
name|ref_tag_addr
operator|=
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|req
operator|->
name|CDB
operator|.
name|EEDP32
operator|.
name|PrimaryReferenceTag
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|ref_tag_addr
operator|=
name|req
operator|->
name|CDB
operator|.
name|CDB32
index|[
name|lba_byte
operator|+
name|i
index|]
expr_stmt|;
name|ref_tag_addr
operator|++
expr_stmt|;
block|}
name|req
operator|->
name|CDB
operator|.
name|EEDP32
operator|.
name|PrimaryApplicationTagMask
operator|=
literal|0xFFFF
expr_stmt|;
name|req
operator|->
name|CDB
operator|.
name|CDB32
index|[
literal|1
index|]
operator|=
operator|(
name|req
operator|->
name|CDB
operator|.
name|CDB32
index|[
literal|1
index|]
operator|&
literal|0x1F
operator|)
operator||
literal|0x20
expr_stmt|;
block|}
else|else
block|{
name|eedp_flags
operator||=
name|MPI2_SCSIIO_EEDPFLAGS_INC_PRI_APPTAG
expr_stmt|;
name|req
operator|->
name|EEDPFlags
operator|=
name|eedp_flags
expr_stmt|;
name|req
operator|->
name|CDB
operator|.
name|CDB32
index|[
literal|10
index|]
operator|=
operator|(
name|req
operator|->
name|CDB
operator|.
name|CDB32
index|[
literal|10
index|]
operator|&
literal|0x1F
operator|)
operator||
literal|0x20
expr_stmt|;
block|}
block|}
block|}
name|cm
operator|->
name|cm_data
operator|=
name|csio
operator|->
name|data_ptr
expr_stmt|;
name|cm
operator|->
name|cm_length
operator|=
name|csio
operator|->
name|dxfer_len
expr_stmt|;
name|cm
operator|->
name|cm_sge
operator|=
operator|&
name|req
operator|->
name|SGL
expr_stmt|;
name|cm
operator|->
name|cm_sglsize
operator|=
operator|(
literal|32
operator|-
literal|24
operator|)
operator|*
literal|4
expr_stmt|;
name|cm
operator|->
name|cm_desc
operator|.
name|SCSIIO
operator|.
name|RequestFlags
operator|=
name|MPI2_REQ_DESCRIPT_FLAGS_SCSI_IO
expr_stmt|;
name|cm
operator|->
name|cm_desc
operator|.
name|SCSIIO
operator|.
name|DevHandle
operator|=
name|targ
operator|->
name|handle
expr_stmt|;
name|cm
operator|->
name|cm_complete
operator|=
name|mpssas_scsiio_complete
expr_stmt|;
name|cm
operator|->
name|cm_complete_data
operator|=
name|ccb
expr_stmt|;
name|cm
operator|->
name|cm_targ
operator|=
name|targ
expr_stmt|;
name|cm
operator|->
name|cm_lun
operator|=
name|csio
operator|->
name|ccb_h
operator|.
name|target_lun
expr_stmt|;
name|cm
operator|->
name|cm_ccb
operator|=
name|ccb
expr_stmt|;
comment|/* 	 * If HBA is a WD and the command is not for a retry, try to build a 	 * direct I/O message. If failed, or the command is for a retry, send 	 * the I/O to the IR volume itself. 	 */
if|if
condition|(
name|sc
operator|->
name|WD_valid_config
condition|)
block|{
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|!=
name|MPS_WD_RETRY
condition|)
block|{
name|mpssas_direct_drive_io
argument_list|(
name|sassc
argument_list|,
name|cm
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INPROG
expr_stmt|;
block|}
block|}
name|callout_reset
argument_list|(
operator|&
name|cm
operator|->
name|cm_callout
argument_list|,
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout
operator|*
name|hz
operator|)
operator|/
literal|1000
argument_list|,
name|mpssas_scsiio_timeout
argument_list|,
name|cm
argument_list|)
expr_stmt|;
name|targ
operator|->
name|issued
operator|++
expr_stmt|;
name|targ
operator|->
name|outstanding
operator|++
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|targ
operator|->
name|commands
argument_list|,
name|cm
argument_list|,
name|cm_link
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|mps_debug
operator|&
name|MPS_TRACE
operator|)
operator|!=
literal|0
condition|)
name|mpssas_log_command
argument_list|(
name|cm
argument_list|,
literal|"%s cm %p ccb %p outstanding %u\n"
argument_list|,
name|__func__
argument_list|,
name|cm
argument_list|,
name|ccb
argument_list|,
name|targ
operator|->
name|outstanding
argument_list|)
expr_stmt|;
name|mps_map_command
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|mpssas_scsiio_complete
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mps_command
modifier|*
name|cm
parameter_list|)
block|{
name|MPI2_SCSI_IO_REPLY
modifier|*
name|rep
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|struct
name|ccb_scsiio
modifier|*
name|csio
decl_stmt|;
name|struct
name|mpssas_softc
modifier|*
name|sassc
decl_stmt|;
name|struct
name|scsi_vpd_supported_page_list
modifier|*
name|vpd_list
init|=
name|NULL
decl_stmt|;
name|u8
modifier|*
name|TLR_bits
decl_stmt|,
name|TLR_on
decl_stmt|;
name|int
name|dir
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|;
name|u16
name|alloc_len
decl_stmt|;
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_TRACE
argument_list|,
literal|"%s cm %p SMID %u ccb %p reply %p outstanding %u\n"
argument_list|,
name|__func__
argument_list|,
name|cm
argument_list|,
name|cm
operator|->
name|cm_desc
operator|.
name|Default
operator|.
name|SMID
argument_list|,
name|cm
operator|->
name|cm_ccb
argument_list|,
name|cm
operator|->
name|cm_reply
argument_list|,
name|cm
operator|->
name|cm_targ
operator|->
name|outstanding
argument_list|)
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|cm
operator|->
name|cm_callout
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sc
operator|->
name|mps_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|sassc
operator|=
name|sc
operator|->
name|sassc
expr_stmt|;
name|ccb
operator|=
name|cm
operator|->
name|cm_complete_data
expr_stmt|;
name|csio
operator|=
operator|&
name|ccb
operator|->
name|csio
expr_stmt|;
name|rep
operator|=
operator|(
name|MPI2_SCSI_IO_REPLY
operator|*
operator|)
name|cm
operator|->
name|cm_reply
expr_stmt|;
comment|/* 	 * XXX KDM if the chain allocation fails, does it matter if we do 	 * the sync and unload here?  It is simpler to do it in every case, 	 * assuming it doesn't cause problems. 	 */
if|if
condition|(
name|cm
operator|->
name|cm_data
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|cm
operator|->
name|cm_flags
operator|&
name|MPS_CM_FLAGS_DATAIN
condition|)
name|dir
operator|=
name|BUS_DMASYNC_POSTREAD
expr_stmt|;
elseif|else
if|if
condition|(
name|cm
operator|->
name|cm_flags
operator|&
name|MPS_CM_FLAGS_DATAOUT
condition|)
name|dir
operator|=
name|BUS_DMASYNC_POSTWRITE
expr_stmt|;
empty_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|buffer_dmat
argument_list|,
name|cm
operator|->
name|cm_dmamap
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|buffer_dmat
argument_list|,
name|cm
operator|->
name|cm_dmamap
argument_list|)
expr_stmt|;
block|}
name|cm
operator|->
name|cm_targ
operator|->
name|completed
operator|++
expr_stmt|;
name|cm
operator|->
name|cm_targ
operator|->
name|outstanding
operator|--
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|cm
operator|->
name|cm_targ
operator|->
name|commands
argument_list|,
name|cm
argument_list|,
name|cm_link
argument_list|)
expr_stmt|;
if|if
condition|(
name|cm
operator|->
name|cm_state
operator|==
name|MPS_CM_STATE_TIMEDOUT
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|cm
operator|->
name|cm_targ
operator|->
name|timedout_commands
argument_list|,
name|cm
argument_list|,
name|cm_recovery
argument_list|)
expr_stmt|;
if|if
condition|(
name|cm
operator|->
name|cm_reply
operator|!=
name|NULL
condition|)
name|mpssas_log_command
argument_list|(
name|cm
argument_list|,
literal|"completed timedout cm %p ccb %p during recovery "
literal|"ioc %x scsi %x state %x xfer %u\n"
argument_list|,
name|cm
argument_list|,
name|cm
operator|->
name|cm_ccb
argument_list|,
name|rep
operator|->
name|IOCStatus
argument_list|,
name|rep
operator|->
name|SCSIStatus
argument_list|,
name|rep
operator|->
name|SCSIState
argument_list|,
name|rep
operator|->
name|TransferCount
argument_list|)
expr_stmt|;
else|else
name|mpssas_log_command
argument_list|(
name|cm
argument_list|,
literal|"completed timedout cm %p ccb %p during recovery\n"
argument_list|,
name|cm
argument_list|,
name|cm
operator|->
name|cm_ccb
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cm
operator|->
name|cm_targ
operator|->
name|tm
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|cm
operator|->
name|cm_reply
operator|!=
name|NULL
condition|)
name|mpssas_log_command
argument_list|(
name|cm
argument_list|,
literal|"completed cm %p ccb %p during recovery "
literal|"ioc %x scsi %x state %x xfer %u\n"
argument_list|,
name|cm
argument_list|,
name|cm
operator|->
name|cm_ccb
argument_list|,
name|rep
operator|->
name|IOCStatus
argument_list|,
name|rep
operator|->
name|SCSIStatus
argument_list|,
name|rep
operator|->
name|SCSIState
argument_list|,
name|rep
operator|->
name|TransferCount
argument_list|)
expr_stmt|;
else|else
name|mpssas_log_command
argument_list|(
name|cm
argument_list|,
literal|"completed cm %p ccb %p during recovery\n"
argument_list|,
name|cm
argument_list|,
name|cm
operator|->
name|cm_ccb
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|sc
operator|->
name|mps_flags
operator|&
name|MPS_FLAGS_DIAGRESET
operator|)
operator|!=
literal|0
condition|)
block|{
name|mpssas_log_command
argument_list|(
name|cm
argument_list|,
literal|"reset completed cm %p ccb %p\n"
argument_list|,
name|cm
argument_list|,
name|cm
operator|->
name|cm_ccb
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|cm
operator|->
name|cm_flags
operator|&
name|MPS_CM_FLAGS_ERROR_MASK
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * We ran into an error after we tried to map the command, 		 * so we're getting a callback without queueing the command 		 * to the hardware.  So we set the status here, and it will 		 * be retained below.  We'll go through the "fast path", 		 * because there can be no reply when we haven't actually 		 * gone out to the hardware. 		 */
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQUEUE_REQ
expr_stmt|;
comment|/* 		 * Currently the only error included in the mask is 		 * MPS_CM_FLAGS_CHAIN_FAILED, which means we're out of 		 * chain frames.  We need to freeze the queue until we get 		 * a command that completed without this error, which will 		 * hopefully have some chain frames attached that we can 		 * use.  If we wanted to get smarter about it, we would 		 * only unfreeze the queue in this condition when we're 		 * sure that we're getting some chain frames back.  That's 		 * probably unnecessary. 		 */
if|if
condition|(
operator|(
name|sassc
operator|->
name|flags
operator|&
name|MPSSAS_QUEUE_FROZEN
operator|)
operator|==
literal|0
condition|)
block|{
name|xpt_freeze_simq
argument_list|(
name|sassc
operator|->
name|sim
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sassc
operator|->
name|flags
operator||=
name|MPSSAS_QUEUE_FROZEN
expr_stmt|;
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_INFO
argument_list|,
literal|"Error sending command, "
literal|"freezing SIM queue\n"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Take the fast path to completion */
if|if
condition|(
name|cm
operator|->
name|cm_reply
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|==
name|CAM_REQ_INPROG
condition|)
block|{
if|if
condition|(
operator|(
name|sc
operator|->
name|mps_flags
operator|&
name|MPS_FLAGS_DIAGRESET
operator|)
operator|!=
literal|0
condition|)
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_SCSI_BUS_RESET
expr_stmt|;
else|else
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|ccb
operator|->
name|csio
operator|.
name|scsi_status
operator|=
name|SCSI_STATUS_OK
expr_stmt|;
block|}
if|if
condition|(
name|sassc
operator|->
name|flags
operator|&
name|MPSSAS_QUEUE_FROZEN
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_RELEASE_SIMQ
expr_stmt|;
name|sassc
operator|->
name|flags
operator|&=
operator|~
name|MPSSAS_QUEUE_FROZEN
expr_stmt|;
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_INFO
argument_list|,
literal|"Unfreezing SIM queue\n"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 		 * There are two scenarios where the status won't be 		 * CAM_REQ_CMP.  The first is if MPS_CM_FLAGS_ERROR_MASK is 		 * set, the second is in the MPS_FLAGS_DIAGRESET above. 		 */
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
comment|/* 			 * Freeze the dev queue so that commands are 			 * executed in the correct order with after error 			 * recovery. 			 */
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_DEV_QFRZN
expr_stmt|;
name|xpt_freeze_devq
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
comment|/*count*/
literal|1
argument_list|)
expr_stmt|;
block|}
name|mps_free_command
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|sc
operator|->
name|mps_debug
operator|&
name|MPS_TRACE
condition|)
name|mpssas_log_command
argument_list|(
name|cm
argument_list|,
literal|"ioc %x scsi %x state %x xfer %u\n"
argument_list|,
name|rep
operator|->
name|IOCStatus
argument_list|,
name|rep
operator|->
name|SCSIStatus
argument_list|,
name|rep
operator|->
name|SCSIState
argument_list|,
name|rep
operator|->
name|TransferCount
argument_list|)
expr_stmt|;
comment|/* 	 * If this is a Direct Drive I/O, reissue the I/O to the original IR 	 * Volume if an error occurred (normal I/O retry).  Use the original 	 * CCB, but set a flag that this will be a retry so that it's sent to 	 * the original volume.  Free the command but reuse the CCB. 	 */
if|if
condition|(
name|cm
operator|->
name|cm_flags
operator|&
name|MPS_CM_FLAGS_DD_IO
condition|)
block|{
name|mps_free_command
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|MPS_WD_RETRY
expr_stmt|;
name|mpssas_action_scsiio
argument_list|(
name|sassc
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|rep
operator|->
name|IOCStatus
operator|&
name|MPI2_IOCSTATUS_MASK
condition|)
block|{
case|case
name|MPI2_IOCSTATUS_SCSI_DATA_UNDERRUN
case|:
name|csio
operator|->
name|resid
operator|=
name|cm
operator|->
name|cm_length
operator|-
name|rep
operator|->
name|TransferCount
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|MPI2_IOCSTATUS_SUCCESS
case|:
case|case
name|MPI2_IOCSTATUS_SCSI_RECOVERED_ERROR
case|:
if|if
condition|(
operator|(
name|rep
operator|->
name|IOCStatus
operator|&
name|MPI2_IOCSTATUS_MASK
operator|)
operator|==
name|MPI2_IOCSTATUS_SCSI_RECOVERED_ERROR
condition|)
name|mpssas_log_command
argument_list|(
name|cm
argument_list|,
literal|"recovered error\n"
argument_list|)
expr_stmt|;
comment|/* Completion failed at the transport level. */
if|if
condition|(
name|rep
operator|->
name|SCSIState
operator|&
operator|(
name|MPI2_SCSI_STATE_NO_SCSI_STATUS
operator||
name|MPI2_SCSI_STATE_TERMINATED
operator|)
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP_ERR
expr_stmt|;
break|break;
block|}
comment|/* In a modern packetized environment, an autosense failure 		 * implies that there's not much else that can be done to 		 * recover the command. 		 */
if|if
condition|(
name|rep
operator|->
name|SCSIState
operator|&
name|MPI2_SCSI_STATE_AUTOSENSE_FAILED
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_AUTOSENSE_FAIL
expr_stmt|;
break|break;
block|}
comment|/* 		 * CAM doesn't care about SAS Response Info data, but if this is 		 * the state check if TLR should be done.  If not, clear the 		 * TLR_bits for the target. 		 */
if|if
condition|(
operator|(
name|rep
operator|->
name|SCSIState
operator|&
name|MPI2_SCSI_STATE_RESPONSE_INFO_VALID
operator|)
operator|&&
operator|(
operator|(
name|rep
operator|->
name|ResponseInfo
operator|&
name|MPI2_SCSI_RI_MASK_REASONCODE
operator|)
operator|==
name|MPS_SCSI_RI_INVALID_FRAME
operator|)
condition|)
block|{
name|sc
operator|->
name|mapping_table
index|[
name|csio
operator|->
name|ccb_h
operator|.
name|target_id
index|]
operator|.
name|TLR_bits
operator|=
operator|(
name|u8
operator|)
name|MPI2_SCSIIO_CONTROL_NO_TLR
expr_stmt|;
block|}
comment|/* 		 * Intentionally override the normal SCSI status reporting 		 * for these two cases.  These are likely to happen in a 		 * multi-initiator environment, and we want to make sure that 		 * CAM retries these commands rather than fail them. 		 */
if|if
condition|(
operator|(
name|rep
operator|->
name|SCSIStatus
operator|==
name|MPI2_SCSI_STATUS_COMMAND_TERMINATED
operator|)
operator|||
operator|(
name|rep
operator|->
name|SCSIStatus
operator|==
name|MPI2_SCSI_STATUS_TASK_ABORTED
operator|)
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_ABORTED
expr_stmt|;
break|break;
block|}
comment|/* Handle normal status and sense */
name|csio
operator|->
name|scsi_status
operator|=
name|rep
operator|->
name|SCSIStatus
expr_stmt|;
if|if
condition|(
name|rep
operator|->
name|SCSIStatus
operator|==
name|MPI2_SCSI_STATUS_GOOD
condition|)
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
else|else
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_SCSI_STATUS_ERROR
expr_stmt|;
if|if
condition|(
name|rep
operator|->
name|SCSIState
operator|&
name|MPI2_SCSI_STATE_AUTOSENSE_VALID
condition|)
block|{
name|int
name|sense_len
decl_stmt|,
name|returned_sense_len
decl_stmt|;
name|returned_sense_len
operator|=
name|min
argument_list|(
name|rep
operator|->
name|SenseCount
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_sense_data
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|returned_sense_len
operator|<
name|ccb
operator|->
name|csio
operator|.
name|sense_len
condition|)
name|ccb
operator|->
name|csio
operator|.
name|sense_resid
operator|=
name|ccb
operator|->
name|csio
operator|.
name|sense_len
operator|-
name|returned_sense_len
expr_stmt|;
else|else
name|ccb
operator|->
name|csio
operator|.
name|sense_resid
operator|=
literal|0
expr_stmt|;
name|sense_len
operator|=
name|min
argument_list|(
name|returned_sense_len
argument_list|,
name|ccb
operator|->
name|csio
operator|.
name|sense_len
operator|-
name|ccb
operator|->
name|csio
operator|.
name|sense_resid
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|ccb
operator|->
name|csio
operator|.
name|sense_data
argument_list|,
sizeof|sizeof
argument_list|(
operator|&
name|ccb
operator|->
name|csio
operator|.
name|sense_data
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|cm
operator|->
name|cm_sense
argument_list|,
operator|&
name|ccb
operator|->
name|csio
operator|.
name|sense_data
argument_list|,
name|sense_len
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_AUTOSNS_VALID
expr_stmt|;
block|}
comment|/* 		 * Check if this is an INQUIRY command.  If it's a VPD inquiry, 		 * and it's page code 0 (Supported Page List), and there is 		 * inquiry data, and this is for a sequential access device, and 		 * the device is an SSP target, and TLR is supported by the 		 * controller, turn the TLR_bits value ON if page 0x90 is 		 * supported. 		 */
if|if
condition|(
operator|(
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|0
index|]
operator|==
name|INQUIRY
operator|)
operator|&&
operator|(
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|1
index|]
operator|&
name|SI_EVPD
operator|)
operator|&&
operator|(
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|2
index|]
operator|==
name|SVPD_SUPPORTED_PAGE_LIST
operator|)
operator|&&
operator|(
name|csio
operator|->
name|data_ptr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|cm
operator|->
name|cm_data
operator|)
index|[
literal|0
index|]
operator|==
name|T_SEQUENTIAL
operator|)
operator|&&
operator|(
name|sc
operator|->
name|control_TLR
operator|)
operator|&&
operator|(
name|sc
operator|->
name|mapping_table
index|[
name|csio
operator|->
name|ccb_h
operator|.
name|target_id
index|]
operator|.
name|device_info
operator|&
name|MPI2_SAS_DEVICE_INFO_SSP_TARGET
operator|)
condition|)
block|{
name|vpd_list
operator|=
operator|(
expr|struct
name|scsi_vpd_supported_page_list
operator|*
operator|)
name|csio
operator|->
name|data_ptr
expr_stmt|;
name|TLR_bits
operator|=
operator|&
name|sc
operator|->
name|mapping_table
index|[
name|csio
operator|->
name|ccb_h
operator|.
name|target_id
index|]
operator|.
name|TLR_bits
expr_stmt|;
operator|*
name|TLR_bits
operator|=
operator|(
name|u8
operator|)
name|MPI2_SCSIIO_CONTROL_NO_TLR
expr_stmt|;
name|TLR_on
operator|=
operator|(
name|u8
operator|)
name|MPI2_SCSIIO_CONTROL_TLR_ON
expr_stmt|;
name|alloc_len
operator|=
operator|(
operator|(
name|u16
operator|)
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|3
index|]
operator|<<
literal|8
operator|)
operator|+
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|4
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MIN
argument_list|(
name|vpd_list
operator|->
name|length
argument_list|,
name|alloc_len
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|vpd_list
operator|->
name|list
index|[
name|i
index|]
operator|==
literal|0x90
condition|)
block|{
operator|*
name|TLR_bits
operator|=
name|TLR_on
expr_stmt|;
break|break;
block|}
block|}
block|}
break|break;
case|case
name|MPI2_IOCSTATUS_SCSI_INVALID_DEVHANDLE
case|:
case|case
name|MPI2_IOCSTATUS_SCSI_DEVICE_NOT_THERE
case|:
comment|/* 		 * If devinfo is 0 this will be a volume.  In that case don't 		 * tell CAM that the volume is not there.  We want volumes to 		 * be enumerated until they are deleted/removed, not just 		 * failed. 		 */
if|if
condition|(
name|cm
operator|->
name|cm_targ
operator|->
name|devinfo
operator|==
literal|0
condition|)
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
else|else
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_DEV_NOT_THERE
expr_stmt|;
break|break;
case|case
name|MPI2_IOCSTATUS_INVALID_SGL
case|:
name|mps_print_scsiio_cmd
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_UNREC_HBA_ERROR
expr_stmt|;
break|break;
case|case
name|MPI2_IOCSTATUS_SCSI_TASK_TERMINATED
case|:
comment|/* 		 * This is one of the responses that comes back when an I/O 		 * has been aborted.  If it is because of a timeout that we 		 * initiated, just set the status to CAM_CMD_TIMEOUT. 		 * Otherwise set it to CAM_REQ_ABORTED.  The effect on the 		 * command is the same (it gets retried, subject to the 		 * retry counter), the only difference is what gets printed 		 * on the console. 		 */
if|if
condition|(
name|cm
operator|->
name|cm_state
operator|==
name|MPS_CM_STATE_TIMEDOUT
condition|)
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_CMD_TIMEOUT
expr_stmt|;
else|else
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_ABORTED
expr_stmt|;
break|break;
case|case
name|MPI2_IOCSTATUS_SCSI_DATA_OVERRUN
case|:
comment|/* resid is ignored for this condition */
name|csio
operator|->
name|resid
operator|=
literal|0
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_DATA_RUN_ERR
expr_stmt|;
break|break;
case|case
name|MPI2_IOCSTATUS_SCSI_IOC_TERMINATED
case|:
case|case
name|MPI2_IOCSTATUS_SCSI_EXT_TERMINATED
case|:
comment|/* 		 * Since these are generally external (i.e. hopefully 		 * transient transport-related) errors, retry these without 		 * decrementing the retry count. 		 */
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQUEUE_REQ
expr_stmt|;
name|mpssas_log_command
argument_list|(
name|cm
argument_list|,
literal|"terminated ioc %x scsi %x state %x xfer %u\n"
argument_list|,
name|rep
operator|->
name|IOCStatus
argument_list|,
name|rep
operator|->
name|SCSIStatus
argument_list|,
name|rep
operator|->
name|SCSIState
argument_list|,
name|rep
operator|->
name|TransferCount
argument_list|)
expr_stmt|;
break|break;
case|case
name|MPI2_IOCSTATUS_INVALID_FUNCTION
case|:
case|case
name|MPI2_IOCSTATUS_INTERNAL_ERROR
case|:
case|case
name|MPI2_IOCSTATUS_INVALID_VPID
case|:
case|case
name|MPI2_IOCSTATUS_INVALID_FIELD
case|:
case|case
name|MPI2_IOCSTATUS_INVALID_STATE
case|:
case|case
name|MPI2_IOCSTATUS_OP_STATE_NOT_SUPPORTED
case|:
case|case
name|MPI2_IOCSTATUS_SCSI_IO_DATA_ERROR
case|:
case|case
name|MPI2_IOCSTATUS_SCSI_PROTOCOL_ERROR
case|:
case|case
name|MPI2_IOCSTATUS_SCSI_RESIDUAL_MISMATCH
case|:
case|case
name|MPI2_IOCSTATUS_SCSI_TASK_MGMT_FAILED
case|:
default|default:
name|mpssas_log_command
argument_list|(
name|cm
argument_list|,
literal|"completed ioc %x scsi %x state %x xfer %u\n"
argument_list|,
name|rep
operator|->
name|IOCStatus
argument_list|,
name|rep
operator|->
name|SCSIStatus
argument_list|,
name|rep
operator|->
name|SCSIState
argument_list|,
name|rep
operator|->
name|TransferCount
argument_list|)
expr_stmt|;
name|csio
operator|->
name|resid
operator|=
name|cm
operator|->
name|cm_length
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP_ERR
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|sassc
operator|->
name|flags
operator|&
name|MPSSAS_QUEUE_FROZEN
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_RELEASE_SIMQ
expr_stmt|;
name|sassc
operator|->
name|flags
operator|&=
operator|~
name|MPSSAS_QUEUE_FROZEN
expr_stmt|;
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_INFO
argument_list|,
literal|"Command completed, "
literal|"unfreezing SIM queue\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_DEV_QFRZN
expr_stmt|;
name|xpt_freeze_devq
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
comment|/*count*/
literal|1
argument_list|)
expr_stmt|;
block|}
name|mps_free_command
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mpssas_direct_drive_io
parameter_list|(
name|struct
name|mpssas_softc
modifier|*
name|sassc
parameter_list|,
name|struct
name|mps_command
modifier|*
name|cm
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|pMpi2SCSIIORequest_t
name|pIO_req
decl_stmt|;
name|struct
name|mps_softc
modifier|*
name|sc
init|=
name|sassc
operator|->
name|sc
decl_stmt|;
name|uint64_t
name|virtLBA
decl_stmt|;
name|uint32_t
name|physLBA
decl_stmt|,
name|stripe_offset
decl_stmt|,
name|stripe_unit
decl_stmt|;
name|uint32_t
name|io_size
decl_stmt|,
name|column
decl_stmt|;
name|uint8_t
modifier|*
name|ptrLBA
decl_stmt|,
name|lba_idx
decl_stmt|,
name|physLBA_byte
decl_stmt|,
modifier|*
name|CDB
decl_stmt|;
comment|/* 	 * If this is a valid SCSI command (Read6, Read10, Read16, Write6, 	 * Write10, or Write16), build a direct I/O message.  Otherwise, the I/O 	 * will be sent to the IR volume itself.  Since Read6 and Write6 are a 	 * bit different than the 10/16 CDBs, handle them separately. 	 */
name|pIO_req
operator|=
operator|(
name|pMpi2SCSIIORequest_t
operator|)
name|cm
operator|->
name|cm_req
expr_stmt|;
name|CDB
operator|=
name|pIO_req
operator|->
name|CDB
operator|.
name|CDB32
expr_stmt|;
comment|/* 	 * Handle 6 byte CDBs. 	 */
if|if
condition|(
operator|(
name|pIO_req
operator|->
name|DevHandle
operator|==
name|sc
operator|->
name|DD_dev_handle
operator|)
operator|&&
operator|(
operator|(
name|CDB
index|[
literal|0
index|]
operator|==
name|READ_6
operator|)
operator|||
operator|(
name|CDB
index|[
literal|0
index|]
operator|==
name|WRITE_6
operator|)
operator|)
condition|)
block|{
comment|/* 		 * Get the transfer size in blocks. 		 */
name|io_size
operator|=
operator|(
name|cm
operator|->
name|cm_length
operator|>>
name|sc
operator|->
name|DD_block_exponent
operator|)
expr_stmt|;
comment|/* 		 * Get virtual LBA given in the CDB. 		 */
name|virtLBA
operator|=
operator|(
call|(
name|uint64_t
call|)
argument_list|(
name|CDB
index|[
literal|1
index|]
operator|&
literal|0x1F
argument_list|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|uint64_t
operator|)
name|CDB
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|uint64_t
operator|)
name|CDB
index|[
literal|3
index|]
expr_stmt|;
comment|/* 		 * Check that LBA range for I/O does not exceed volume's 		 * MaxLBA. 		 */
if|if
condition|(
operator|(
name|virtLBA
operator|+
operator|(
name|uint64_t
operator|)
name|io_size
operator|-
literal|1
operator|)
operator|<=
name|sc
operator|->
name|DD_max_lba
condition|)
block|{
comment|/* 			 * Check if the I/O crosses a stripe boundary.  If not, 			 * translate the virtual LBA to a physical LBA and set 			 * the DevHandle for the PhysDisk to be used.  If it 			 * does cross a boundry, do normal I/O.  To get the 			 * right DevHandle to use, get the map number for the 			 * column, then use that map number to look up the 			 * DevHandle of the PhysDisk. 			 */
name|stripe_offset
operator|=
operator|(
name|uint32_t
operator|)
name|virtLBA
operator|&
operator|(
name|sc
operator|->
name|DD_stripe_size
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|stripe_offset
operator|+
name|io_size
operator|)
operator|<=
name|sc
operator|->
name|DD_stripe_size
condition|)
block|{
name|physLBA
operator|=
operator|(
name|uint32_t
operator|)
name|virtLBA
operator|>>
name|sc
operator|->
name|DD_stripe_exponent
expr_stmt|;
name|stripe_unit
operator|=
name|physLBA
operator|/
name|sc
operator|->
name|DD_num_phys_disks
expr_stmt|;
name|column
operator|=
name|physLBA
operator|%
name|sc
operator|->
name|DD_num_phys_disks
expr_stmt|;
name|pIO_req
operator|->
name|DevHandle
operator|=
name|sc
operator|->
name|DD_column_map
index|[
name|column
index|]
operator|.
name|dev_handle
expr_stmt|;
name|cm
operator|->
name|cm_desc
operator|.
name|SCSIIO
operator|.
name|DevHandle
operator|=
name|pIO_req
operator|->
name|DevHandle
expr_stmt|;
name|physLBA
operator|=
operator|(
name|stripe_unit
operator|<<
name|sc
operator|->
name|DD_stripe_exponent
operator|)
operator|+
name|stripe_offset
expr_stmt|;
name|ptrLBA
operator|=
operator|&
name|pIO_req
operator|->
name|CDB
operator|.
name|CDB32
index|[
literal|1
index|]
expr_stmt|;
name|physLBA_byte
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|physLBA
operator|>>
literal|16
argument_list|)
expr_stmt|;
operator|*
name|ptrLBA
operator|=
name|physLBA_byte
expr_stmt|;
name|ptrLBA
operator|=
operator|&
name|pIO_req
operator|->
name|CDB
operator|.
name|CDB32
index|[
literal|2
index|]
expr_stmt|;
name|physLBA_byte
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|physLBA
operator|>>
literal|8
argument_list|)
expr_stmt|;
operator|*
name|ptrLBA
operator|=
name|physLBA_byte
expr_stmt|;
name|ptrLBA
operator|=
operator|&
name|pIO_req
operator|->
name|CDB
operator|.
name|CDB32
index|[
literal|3
index|]
expr_stmt|;
name|physLBA_byte
operator|=
operator|(
name|uint8_t
operator|)
name|physLBA
expr_stmt|;
operator|*
name|ptrLBA
operator|=
name|physLBA_byte
expr_stmt|;
comment|/* 				 * Set flag that Direct Drive I/O is 				 * being done. 				 */
name|cm
operator|->
name|cm_flags
operator||=
name|MPS_CM_FLAGS_DD_IO
expr_stmt|;
block|}
block|}
return|return;
block|}
comment|/* 	 * Handle 10 or 16 byte CDBs. 	 */
if|if
condition|(
operator|(
name|pIO_req
operator|->
name|DevHandle
operator|==
name|sc
operator|->
name|DD_dev_handle
operator|)
operator|&&
operator|(
operator|(
name|CDB
index|[
literal|0
index|]
operator|==
name|READ_10
operator|)
operator|||
operator|(
name|CDB
index|[
literal|0
index|]
operator|==
name|WRITE_10
operator|)
operator|||
operator|(
name|CDB
index|[
literal|0
index|]
operator|==
name|READ_16
operator|)
operator|||
operator|(
name|CDB
index|[
literal|0
index|]
operator|==
name|WRITE_16
operator|)
operator|)
condition|)
block|{
comment|/* 		 * For 16-byte CDB's, verify that the upper 4 bytes of the CDB 		 * are 0.  If not, this is accessing beyond 2TB so handle it in 		 * the else section.  10-byte CDB's are OK. 		 */
if|if
condition|(
operator|(
name|CDB
index|[
literal|0
index|]
operator|<
name|READ_16
operator|)
operator|||
operator|!
operator|(
name|CDB
index|[
literal|2
index|]
operator||
name|CDB
index|[
literal|3
index|]
operator||
name|CDB
index|[
literal|4
index|]
operator||
name|CDB
index|[
literal|5
index|]
operator|)
condition|)
block|{
comment|/* 			 * Get the transfer size in blocks. 			 */
name|io_size
operator|=
operator|(
name|cm
operator|->
name|cm_length
operator|>>
name|sc
operator|->
name|DD_block_exponent
operator|)
expr_stmt|;
comment|/* 			 * Get virtual LBA.  Point to correct lower 4 bytes of 			 * LBA in the CDB depending on command. 			 */
name|lba_idx
operator|=
operator|(
name|CDB
index|[
literal|0
index|]
operator|<
name|READ_16
operator|)
condition|?
literal|2
else|:
literal|6
expr_stmt|;
name|virtLBA
operator|=
operator|(
operator|(
name|uint64_t
operator|)
name|CDB
index|[
name|lba_idx
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
name|uint64_t
operator|)
name|CDB
index|[
name|lba_idx
operator|+
literal|1
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|uint64_t
operator|)
name|CDB
index|[
name|lba_idx
operator|+
literal|2
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|uint64_t
operator|)
name|CDB
index|[
name|lba_idx
operator|+
literal|3
index|]
expr_stmt|;
comment|/* 			 * Check that LBA range for I/O does not exceed volume's 			 * MaxLBA. 			 */
if|if
condition|(
operator|(
name|virtLBA
operator|+
operator|(
name|uint64_t
operator|)
name|io_size
operator|-
literal|1
operator|)
operator|<=
name|sc
operator|->
name|DD_max_lba
condition|)
block|{
comment|/* 				 * Check if the I/O crosses a stripe boundary. 				 * If not, translate the virtual LBA to a 				 * physical LBA and set the DevHandle for the 				 * PhysDisk to be used.  If it does cross a 				 * boundry, do normal I/O.  To get the right 				 * DevHandle to use, get the map number for the 				 * column, then use that map number to look up 				 * the DevHandle of the PhysDisk. 				 */
name|stripe_offset
operator|=
operator|(
name|uint32_t
operator|)
name|virtLBA
operator|&
operator|(
name|sc
operator|->
name|DD_stripe_size
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|stripe_offset
operator|+
name|io_size
operator|)
operator|<=
name|sc
operator|->
name|DD_stripe_size
condition|)
block|{
name|physLBA
operator|=
operator|(
name|uint32_t
operator|)
name|virtLBA
operator|>>
name|sc
operator|->
name|DD_stripe_exponent
expr_stmt|;
name|stripe_unit
operator|=
name|physLBA
operator|/
name|sc
operator|->
name|DD_num_phys_disks
expr_stmt|;
name|column
operator|=
name|physLBA
operator|%
name|sc
operator|->
name|DD_num_phys_disks
expr_stmt|;
name|pIO_req
operator|->
name|DevHandle
operator|=
name|sc
operator|->
name|DD_column_map
index|[
name|column
index|]
operator|.
name|dev_handle
expr_stmt|;
name|cm
operator|->
name|cm_desc
operator|.
name|SCSIIO
operator|.
name|DevHandle
operator|=
name|pIO_req
operator|->
name|DevHandle
expr_stmt|;
name|physLBA
operator|=
operator|(
name|stripe_unit
operator|<<
name|sc
operator|->
name|DD_stripe_exponent
operator|)
operator|+
name|stripe_offset
expr_stmt|;
name|ptrLBA
operator|=
operator|&
name|pIO_req
operator|->
name|CDB
operator|.
name|CDB32
index|[
name|lba_idx
index|]
expr_stmt|;
name|physLBA_byte
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|physLBA
operator|>>
literal|24
argument_list|)
expr_stmt|;
operator|*
name|ptrLBA
operator|=
name|physLBA_byte
expr_stmt|;
name|ptrLBA
operator|=
operator|&
name|pIO_req
operator|->
name|CDB
operator|.
name|CDB32
index|[
name|lba_idx
operator|+
literal|1
index|]
expr_stmt|;
name|physLBA_byte
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|physLBA
operator|>>
literal|16
argument_list|)
expr_stmt|;
operator|*
name|ptrLBA
operator|=
name|physLBA_byte
expr_stmt|;
name|ptrLBA
operator|=
operator|&
name|pIO_req
operator|->
name|CDB
operator|.
name|CDB32
index|[
name|lba_idx
operator|+
literal|2
index|]
expr_stmt|;
name|physLBA_byte
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|physLBA
operator|>>
literal|8
argument_list|)
expr_stmt|;
operator|*
name|ptrLBA
operator|=
name|physLBA_byte
expr_stmt|;
name|ptrLBA
operator|=
operator|&
name|pIO_req
operator|->
name|CDB
operator|.
name|CDB32
index|[
name|lba_idx
operator|+
literal|3
index|]
expr_stmt|;
name|physLBA_byte
operator|=
operator|(
name|uint8_t
operator|)
name|physLBA
expr_stmt|;
operator|*
name|ptrLBA
operator|=
name|physLBA_byte
expr_stmt|;
comment|/* 					 * Set flag that Direct Drive I/O is 					 * being done. 					 */
name|cm
operator|->
name|cm_flags
operator||=
name|MPS_CM_FLAGS_DD_IO
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* 			 * 16-byte CDB and the upper 4 bytes of the CDB are not 			 * 0.  Get the transfer size in blocks. 			 */
name|io_size
operator|=
operator|(
name|cm
operator|->
name|cm_length
operator|>>
name|sc
operator|->
name|DD_block_exponent
operator|)
expr_stmt|;
comment|/* 			 * Get virtual LBA. 			 */
name|virtLBA
operator|=
operator|(
operator|(
name|uint64_t
operator|)
name|CDB
index|[
literal|2
index|]
operator|<<
literal|54
operator|)
operator||
operator|(
operator|(
name|uint64_t
operator|)
name|CDB
index|[
literal|3
index|]
operator|<<
literal|48
operator|)
operator||
operator|(
operator|(
name|uint64_t
operator|)
name|CDB
index|[
literal|4
index|]
operator|<<
literal|40
operator|)
operator||
operator|(
operator|(
name|uint64_t
operator|)
name|CDB
index|[
literal|5
index|]
operator|<<
literal|32
operator|)
operator||
operator|(
operator|(
name|uint64_t
operator|)
name|CDB
index|[
literal|6
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
name|uint64_t
operator|)
name|CDB
index|[
literal|7
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|uint64_t
operator|)
name|CDB
index|[
literal|8
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|uint64_t
operator|)
name|CDB
index|[
literal|9
index|]
expr_stmt|;
comment|/* 			 * Check that LBA range for I/O does not exceed volume's 			 * MaxLBA. 			 */
if|if
condition|(
operator|(
name|virtLBA
operator|+
operator|(
name|uint64_t
operator|)
name|io_size
operator|-
literal|1
operator|)
operator|<=
name|sc
operator|->
name|DD_max_lba
condition|)
block|{
comment|/* 				 * Check if the I/O crosses a stripe boundary. 				 * If not, translate the virtual LBA to a 				 * physical LBA and set the DevHandle for the 				 * PhysDisk to be used.  If it does cross a 				 * boundry, do normal I/O.  To get the right 				 * DevHandle to use, get the map number for the 				 * column, then use that map number to look up 				 * the DevHandle of the PhysDisk. 				 */
name|stripe_offset
operator|=
operator|(
name|uint32_t
operator|)
name|virtLBA
operator|&
operator|(
name|sc
operator|->
name|DD_stripe_size
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|stripe_offset
operator|+
name|io_size
operator|)
operator|<=
name|sc
operator|->
name|DD_stripe_size
condition|)
block|{
name|physLBA
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|virtLBA
operator|>>
name|sc
operator|->
name|DD_stripe_exponent
argument_list|)
expr_stmt|;
name|stripe_unit
operator|=
name|physLBA
operator|/
name|sc
operator|->
name|DD_num_phys_disks
expr_stmt|;
name|column
operator|=
name|physLBA
operator|%
name|sc
operator|->
name|DD_num_phys_disks
expr_stmt|;
name|pIO_req
operator|->
name|DevHandle
operator|=
name|sc
operator|->
name|DD_column_map
index|[
name|column
index|]
operator|.
name|dev_handle
expr_stmt|;
name|cm
operator|->
name|cm_desc
operator|.
name|SCSIIO
operator|.
name|DevHandle
operator|=
name|pIO_req
operator|->
name|DevHandle
expr_stmt|;
name|physLBA
operator|=
operator|(
name|stripe_unit
operator|<<
name|sc
operator|->
name|DD_stripe_exponent
operator|)
operator|+
name|stripe_offset
expr_stmt|;
comment|/* 					 * Set upper 4 bytes of LBA to 0.  We 					 * assume that the phys disks are less 					 * than 2 TB's in size.  Then, set the 					 * lower 4 bytes. 					 */
name|pIO_req
operator|->
name|CDB
operator|.
name|CDB32
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|pIO_req
operator|->
name|CDB
operator|.
name|CDB32
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|pIO_req
operator|->
name|CDB
operator|.
name|CDB32
index|[
literal|4
index|]
operator|=
literal|0
expr_stmt|;
name|pIO_req
operator|->
name|CDB
operator|.
name|CDB32
index|[
literal|5
index|]
operator|=
literal|0
expr_stmt|;
name|ptrLBA
operator|=
operator|&
name|pIO_req
operator|->
name|CDB
operator|.
name|CDB32
index|[
literal|6
index|]
expr_stmt|;
name|physLBA_byte
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|physLBA
operator|>>
literal|24
argument_list|)
expr_stmt|;
operator|*
name|ptrLBA
operator|=
name|physLBA_byte
expr_stmt|;
name|ptrLBA
operator|=
operator|&
name|pIO_req
operator|->
name|CDB
operator|.
name|CDB32
index|[
literal|7
index|]
expr_stmt|;
name|physLBA_byte
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|physLBA
operator|>>
literal|16
argument_list|)
expr_stmt|;
operator|*
name|ptrLBA
operator|=
name|physLBA_byte
expr_stmt|;
name|ptrLBA
operator|=
operator|&
name|pIO_req
operator|->
name|CDB
operator|.
name|CDB32
index|[
literal|8
index|]
expr_stmt|;
name|physLBA_byte
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|physLBA
operator|>>
literal|8
argument_list|)
expr_stmt|;
operator|*
name|ptrLBA
operator|=
name|physLBA_byte
expr_stmt|;
name|ptrLBA
operator|=
operator|&
name|pIO_req
operator|->
name|CDB
operator|.
name|CDB32
index|[
literal|9
index|]
expr_stmt|;
name|physLBA_byte
operator|=
operator|(
name|uint8_t
operator|)
name|physLBA
expr_stmt|;
operator|*
name|ptrLBA
operator|=
name|physLBA_byte
expr_stmt|;
comment|/* 					 * Set flag that Direct Drive I/O is 					 * being done. 					 */
name|cm
operator|->
name|cm_flags
operator||=
name|MPS_CM_FLAGS_DD_IO
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|900026
end_if

begin_function
specifier|static
name|void
name|mpssas_smpio_complete
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mps_command
modifier|*
name|cm
parameter_list|)
block|{
name|MPI2_SMP_PASSTHROUGH_REPLY
modifier|*
name|rpl
decl_stmt|;
name|MPI2_SMP_PASSTHROUGH_REQUEST
modifier|*
name|req
decl_stmt|;
name|uint64_t
name|sasaddr
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|ccb
operator|=
name|cm
operator|->
name|cm_complete_data
expr_stmt|;
comment|/* 	 * Currently there should be no way we can hit this case.  It only 	 * happens when we have a failure to allocate chain frames, and SMP 	 * commands require two S/G elements only.  That should be handled 	 * in the standard request size. 	 */
if|if
condition|(
operator|(
name|cm
operator|->
name|cm_flags
operator|&
name|MPS_CM_FLAGS_ERROR_MASK
operator|)
operator|!=
literal|0
condition|)
block|{
name|mps_printf
argument_list|(
name|sc
argument_list|,
literal|"%s: cm_flags = %#x on SMP request!\n"
argument_list|,
name|__func__
argument_list|,
name|cm
operator|->
name|cm_flags
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP_ERR
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|rpl
operator|=
operator|(
name|MPI2_SMP_PASSTHROUGH_REPLY
operator|*
operator|)
name|cm
operator|->
name|cm_reply
expr_stmt|;
if|if
condition|(
name|rpl
operator|==
name|NULL
condition|)
block|{
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_INFO
argument_list|,
literal|"%s: NULL cm_reply!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP_ERR
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|req
operator|=
operator|(
name|MPI2_SMP_PASSTHROUGH_REQUEST
operator|*
operator|)
name|cm
operator|->
name|cm_req
expr_stmt|;
name|sasaddr
operator|=
name|le32toh
argument_list|(
name|req
operator|->
name|SASAddress
operator|.
name|Low
argument_list|)
expr_stmt|;
name|sasaddr
operator||=
operator|(
call|(
name|uint64_t
call|)
argument_list|(
name|le32toh
argument_list|(
name|req
operator|->
name|SASAddress
operator|.
name|High
argument_list|)
argument_list|)
operator|)
operator|<<
literal|32
expr_stmt|;
if|if
condition|(
operator|(
name|rpl
operator|->
name|IOCStatus
operator|&
name|MPI2_IOCSTATUS_MASK
operator|)
operator|!=
name|MPI2_IOCSTATUS_SUCCESS
operator|||
name|rpl
operator|->
name|SASStatus
operator|!=
name|MPI2_SASSTATUS_SUCCESS
condition|)
block|{
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_INFO
argument_list|,
literal|"%s: IOCStatus %04x SASStatus %02x\n"
argument_list|,
name|__func__
argument_list|,
name|rpl
operator|->
name|IOCStatus
argument_list|,
name|rpl
operator|->
name|SASStatus
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP_ERR
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_INFO
argument_list|,
literal|"%s: SMP request to SAS address "
literal|"%#jx completed successfully\n"
argument_list|,
name|__func__
argument_list|,
operator|(
name|uintmax_t
operator|)
name|sasaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|smpio
operator|.
name|smp_response
index|[
literal|2
index|]
operator|==
name|SMP_FR_ACCEPTED
condition|)
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
else|else
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_SMP_STATUS_ERROR
expr_stmt|;
name|bailout
label|:
comment|/* 	 * We sync in both directions because we had DMAs in the S/G list 	 * in both directions. 	 */
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|buffer_dmat
argument_list|,
name|cm
operator|->
name|cm_dmamap
argument_list|,
name|BUS_DMASYNC_POSTREAD
operator||
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|buffer_dmat
argument_list|,
name|cm
operator|->
name|cm_dmamap
argument_list|)
expr_stmt|;
name|mps_free_command
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mpssas_send_smpcmd
parameter_list|(
name|struct
name|mpssas_softc
modifier|*
name|sassc
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|uint64_t
name|sasaddr
parameter_list|)
block|{
name|struct
name|mps_command
modifier|*
name|cm
decl_stmt|;
name|uint8_t
modifier|*
name|request
decl_stmt|,
modifier|*
name|response
decl_stmt|;
name|MPI2_SMP_PASSTHROUGH_REQUEST
modifier|*
name|req
decl_stmt|;
name|struct
name|mps_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|sglist
modifier|*
name|sg
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
name|sassc
operator|->
name|sc
expr_stmt|;
name|sg
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
comment|/* 	 * XXX We don't yet support physical addresses here. 	 */
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
operator|(
name|CAM_DATA_PHYS
operator||
name|CAM_SG_LIST_PHYS
operator|)
condition|)
block|{
name|mps_printf
argument_list|(
name|sc
argument_list|,
literal|"%s: physical addresses not supported\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * If the user wants to send an S/G list, check to make sure they 	 * have single buffers. 	 */
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_SCATTER_VALID
condition|)
block|{
comment|/* 		 * The chip does not support more than one buffer for the 		 * request or response. 		 */
if|if
condition|(
operator|(
name|ccb
operator|->
name|smpio
operator|.
name|smp_request_sglist_cnt
operator|>
literal|1
operator|)
operator|||
operator|(
name|ccb
operator|->
name|smpio
operator|.
name|smp_response_sglist_cnt
operator|>
literal|1
operator|)
condition|)
block|{
name|mps_printf
argument_list|(
name|sc
argument_list|,
literal|"%s: multiple request or response "
literal|"buffer segments not supported for SMP\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 		 * The CAM_SCATTER_VALID flag was originally implemented 		 * for the XPT_SCSI_IO CCB, which only has one data pointer. 		 * We have two.  So, just take that flag to mean that we 		 * might have S/G lists, and look at the S/G segment count 		 * to figure out whether that is the case for each individual 		 * buffer. 		 */
if|if
condition|(
name|ccb
operator|->
name|smpio
operator|.
name|smp_request_sglist_cnt
operator|!=
literal|0
condition|)
block|{
name|bus_dma_segment_t
modifier|*
name|req_sg
decl_stmt|;
name|req_sg
operator|=
operator|(
name|bus_dma_segment_t
operator|*
operator|)
name|ccb
operator|->
name|smpio
operator|.
name|smp_request
expr_stmt|;
name|request
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|req_sg
index|[
literal|0
index|]
operator|.
name|ds_addr
expr_stmt|;
block|}
else|else
name|request
operator|=
name|ccb
operator|->
name|smpio
operator|.
name|smp_request
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|smpio
operator|.
name|smp_response_sglist_cnt
operator|!=
literal|0
condition|)
block|{
name|bus_dma_segment_t
modifier|*
name|rsp_sg
decl_stmt|;
name|rsp_sg
operator|=
operator|(
name|bus_dma_segment_t
operator|*
operator|)
name|ccb
operator|->
name|smpio
operator|.
name|smp_response
expr_stmt|;
name|response
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|rsp_sg
index|[
literal|0
index|]
operator|.
name|ds_addr
expr_stmt|;
block|}
else|else
name|response
operator|=
name|ccb
operator|->
name|smpio
operator|.
name|smp_response
expr_stmt|;
block|}
else|else
block|{
name|request
operator|=
name|ccb
operator|->
name|smpio
operator|.
name|smp_request
expr_stmt|;
name|response
operator|=
name|ccb
operator|->
name|smpio
operator|.
name|smp_response
expr_stmt|;
block|}
name|cm
operator|=
name|mps_alloc_command
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|cm
operator|==
name|NULL
condition|)
block|{
name|mps_printf
argument_list|(
name|sc
argument_list|,
literal|"%s: cannot allocate command\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_RESRC_UNAVAIL
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
name|req
operator|=
operator|(
name|MPI2_SMP_PASSTHROUGH_REQUEST
operator|*
operator|)
name|cm
operator|->
name|cm_req
expr_stmt|;
name|bzero
argument_list|(
name|req
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|req
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|->
name|Function
operator|=
name|MPI2_FUNCTION_SMP_PASSTHROUGH
expr_stmt|;
comment|/* Allow the chip to use any route to this SAS address. */
name|req
operator|->
name|PhysicalPort
operator|=
literal|0xff
expr_stmt|;
name|req
operator|->
name|RequestDataLength
operator|=
name|ccb
operator|->
name|smpio
operator|.
name|smp_request_len
expr_stmt|;
name|req
operator|->
name|SGLFlags
operator|=
name|MPI2_SGLFLAGS_SYSTEM_ADDRESS_SPACE
operator||
name|MPI2_SGLFLAGS_SGL_TYPE_MPI
expr_stmt|;
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_INFO
argument_list|,
literal|"%s: sending SMP request to SAS "
literal|"address %#jx\n"
argument_list|,
name|__func__
argument_list|,
operator|(
name|uintmax_t
operator|)
name|sasaddr
argument_list|)
expr_stmt|;
name|mpi_init_sge
argument_list|(
name|cm
argument_list|,
name|req
argument_list|,
operator|&
name|req
operator|->
name|SGL
argument_list|)
expr_stmt|;
comment|/* 	 * Set up a uio to pass into mps_map_command().  This allows us to 	 * do one map command, and one busdma call in there. 	 */
name|cm
operator|->
name|cm_uio
operator|.
name|uio_iov
operator|=
name|cm
operator|->
name|cm_iovec
expr_stmt|;
name|cm
operator|->
name|cm_uio
operator|.
name|uio_iovcnt
operator|=
literal|2
expr_stmt|;
name|cm
operator|->
name|cm_uio
operator|.
name|uio_segflg
operator|=
name|UIO_SYSSPACE
expr_stmt|;
comment|/* 	 * The read/write flag isn't used by busdma, but set it just in 	 * case.  This isn't exactly accurate, either, since we're going in 	 * both directions. 	 */
name|cm
operator|->
name|cm_uio
operator|.
name|uio_rw
operator|=
name|UIO_WRITE
expr_stmt|;
name|cm
operator|->
name|cm_iovec
index|[
literal|0
index|]
operator|.
name|iov_base
operator|=
name|request
expr_stmt|;
name|cm
operator|->
name|cm_iovec
index|[
literal|0
index|]
operator|.
name|iov_len
operator|=
name|req
operator|->
name|RequestDataLength
expr_stmt|;
name|cm
operator|->
name|cm_iovec
index|[
literal|1
index|]
operator|.
name|iov_base
operator|=
name|response
expr_stmt|;
name|cm
operator|->
name|cm_iovec
index|[
literal|1
index|]
operator|.
name|iov_len
operator|=
name|ccb
operator|->
name|smpio
operator|.
name|smp_response_len
expr_stmt|;
name|cm
operator|->
name|cm_uio
operator|.
name|uio_resid
operator|=
name|cm
operator|->
name|cm_iovec
index|[
literal|0
index|]
operator|.
name|iov_len
operator|+
name|cm
operator|->
name|cm_iovec
index|[
literal|1
index|]
operator|.
name|iov_len
expr_stmt|;
comment|/* 	 * Trigger a warning message in mps_data_cb() for the user if we 	 * wind up exceeding two S/G segments.  The chip expects one 	 * segment for the request and another for the response. 	 */
name|cm
operator|->
name|cm_max_segs
operator|=
literal|2
expr_stmt|;
name|cm
operator|->
name|cm_desc
operator|.
name|Default
operator|.
name|RequestFlags
operator|=
name|MPI2_REQ_DESCRIPT_FLAGS_DEFAULT_TYPE
expr_stmt|;
name|cm
operator|->
name|cm_complete
operator|=
name|mpssas_smpio_complete
expr_stmt|;
name|cm
operator|->
name|cm_complete_data
operator|=
name|ccb
expr_stmt|;
comment|/* 	 * Tell the mapping code that we're using a uio, and that this is 	 * an SMP passthrough request.  There is a little special-case 	 * logic there (in mps_data_cb()) to handle the bidirectional 	 * transfer.   	 */
name|cm
operator|->
name|cm_flags
operator||=
name|MPS_CM_FLAGS_USE_UIO
operator||
name|MPS_CM_FLAGS_SMP_PASS
operator||
name|MPS_CM_FLAGS_DATAIN
operator||
name|MPS_CM_FLAGS_DATAOUT
expr_stmt|;
comment|/* The chip data format is little endian. */
name|req
operator|->
name|SASAddress
operator|.
name|High
operator|=
name|htole32
argument_list|(
name|sasaddr
operator|>>
literal|32
argument_list|)
expr_stmt|;
name|req
operator|->
name|SASAddress
operator|.
name|Low
operator|=
name|htole32
argument_list|(
name|sasaddr
argument_list|)
expr_stmt|;
comment|/* 	 * XXX Note that we don't have a timeout/abort mechanism here. 	 * From the manual, it looks like task management requests only 	 * work for SCSI IO and SATA passthrough requests.  We may need to 	 * have a mechanism to retry requests in the event of a chip reset 	 * at least.  Hopefully the chip will insure that any errors short 	 * of that are relayed back to the driver. 	 */
name|error
operator|=
name|mps_map_command
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|error
operator|!=
name|EINPROGRESS
operator|)
condition|)
block|{
name|mps_printf
argument_list|(
name|sc
argument_list|,
literal|"%s: error %d returned from mps_map_command()\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|bailout_error
goto|;
block|}
return|return;
name|bailout_error
label|:
name|mps_free_command
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_RESRC_UNAVAIL
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|mpssas_action_smpio
parameter_list|(
name|struct
name|mpssas_softc
modifier|*
name|sassc
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|struct
name|mps_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mpssas_target
modifier|*
name|targ
decl_stmt|;
name|uint64_t
name|sasaddr
init|=
literal|0
decl_stmt|;
name|sc
operator|=
name|sassc
operator|->
name|sc
expr_stmt|;
comment|/* 	 * Make sure the target exists. 	 */
name|targ
operator|=
operator|&
name|sassc
operator|->
name|targets
index|[
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
index|]
expr_stmt|;
if|if
condition|(
name|targ
operator|->
name|handle
operator|==
literal|0x0
condition|)
block|{
name|mps_printf
argument_list|(
name|sc
argument_list|,
literal|"%s: target %d does not exist!\n"
argument_list|,
name|__func__
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_SEL_TIMEOUT
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * If this device has an embedded SMP target, we'll talk to it 	 * directly. 	 * figure out what the expander's address is. 	 */
if|if
condition|(
operator|(
name|targ
operator|->
name|devinfo
operator|&
name|MPI2_SAS_DEVICE_INFO_SMP_TARGET
operator|)
operator|!=
literal|0
condition|)
name|sasaddr
operator|=
name|targ
operator|->
name|sasaddr
expr_stmt|;
comment|/* 	 * If we don't have a SAS address for the expander yet, try 	 * grabbing it from the page 0x83 information cached in the 	 * transport layer for this target.  LSI expanders report the 	 * expander SAS address as the port-associated SAS address in 	 * Inquiry VPD page 0x83.  Maxim expanders don't report it in page 	 * 0x83. 	 * 	 * XXX KDM disable this for now, but leave it commented out so that 	 * it is obvious that this is another possible way to get the SAS 	 * address. 	 * 	 * The parent handle method below is a little more reliable, and 	 * the other benefit is that it works for devices other than SES 	 * devices.  So you can send a SMP request to a da(4) device and it 	 * will get routed to the expander that device is attached to. 	 * (Assuming the da(4) device doesn't contain an SMP target...) 	 */
if|#
directive|if
literal|0
block|if (sasaddr == 0) 		sasaddr = xpt_path_sas_addr(ccb->ccb_h.path);
endif|#
directive|endif
comment|/* 	 * If we still don't have a SAS address for the expander, look for 	 * the parent device of this device, which is probably the expander. 	 */
if|if
condition|(
name|sasaddr
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|OLD_MPS_PROBE
name|struct
name|mpssas_target
modifier|*
name|parent_target
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|targ
operator|->
name|parent_handle
operator|==
literal|0x0
condition|)
block|{
name|mps_printf
argument_list|(
name|sc
argument_list|,
literal|"%s: handle %d does not have a valid "
literal|"parent handle!\n"
argument_list|,
name|__func__
argument_list|,
name|targ
operator|->
name|handle
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
ifdef|#
directive|ifdef
name|OLD_MPS_PROBE
name|parent_target
operator|=
name|mpssas_find_target_by_handle
argument_list|(
name|sassc
argument_list|,
literal|0
argument_list|,
name|targ
operator|->
name|parent_handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|parent_target
operator|==
name|NULL
condition|)
block|{
name|mps_printf
argument_list|(
name|sc
argument_list|,
literal|"%s: handle %d does not have a valid "
literal|"parent target!\n"
argument_list|,
name|__func__
argument_list|,
name|targ
operator|->
name|handle
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
if|if
condition|(
operator|(
name|parent_target
operator|->
name|devinfo
operator|&
name|MPI2_SAS_DEVICE_INFO_SMP_TARGET
operator|)
operator|==
literal|0
condition|)
block|{
name|mps_printf
argument_list|(
name|sc
argument_list|,
literal|"%s: handle %d parent %d does not "
literal|"have an SMP target!\n"
argument_list|,
name|__func__
argument_list|,
name|targ
operator|->
name|handle
argument_list|,
name|parent_target
operator|->
name|handle
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|sasaddr
operator|=
name|parent_target
operator|->
name|sasaddr
expr_stmt|;
else|#
directive|else
comment|/* OLD_MPS_PROBE */
if|if
condition|(
operator|(
name|targ
operator|->
name|parent_devinfo
operator|&
name|MPI2_SAS_DEVICE_INFO_SMP_TARGET
operator|)
operator|==
literal|0
condition|)
block|{
name|mps_printf
argument_list|(
name|sc
argument_list|,
literal|"%s: handle %d parent %d does not "
literal|"have an SMP target!\n"
argument_list|,
name|__func__
argument_list|,
name|targ
operator|->
name|handle
argument_list|,
name|targ
operator|->
name|parent_handle
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
if|if
condition|(
name|targ
operator|->
name|parent_sasaddr
operator|==
literal|0x0
condition|)
block|{
name|mps_printf
argument_list|(
name|sc
argument_list|,
literal|"%s: handle %d parent handle %d does "
literal|"not have a valid SAS address!\n"
argument_list|,
name|__func__
argument_list|,
name|targ
operator|->
name|handle
argument_list|,
name|targ
operator|->
name|parent_handle
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|sasaddr
operator|=
name|targ
operator|->
name|parent_sasaddr
expr_stmt|;
endif|#
directive|endif
comment|/* OLD_MPS_PROBE */
block|}
if|if
condition|(
name|sasaddr
operator|==
literal|0
condition|)
block|{
name|mps_printf
argument_list|(
name|sc
argument_list|,
literal|"%s: unable to find SAS address for handle %d\n"
argument_list|,
name|__func__
argument_list|,
name|targ
operator|->
name|handle
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|mpssas_send_smpcmd
argument_list|(
name|sassc
argument_list|,
name|ccb
argument_list|,
name|sasaddr
argument_list|)
expr_stmt|;
return|return;
name|bailout
label|:
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|//__FreeBSD_version>= 900026
end_comment

begin_function
specifier|static
name|void
name|mpssas_action_resetdev
parameter_list|(
name|struct
name|mpssas_softc
modifier|*
name|sassc
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|MPI2_SCSI_TASK_MANAGE_REQUEST
modifier|*
name|req
decl_stmt|;
name|struct
name|mps_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mps_command
modifier|*
name|tm
decl_stmt|;
name|struct
name|mpssas_target
modifier|*
name|targ
decl_stmt|;
name|mps_dprint
argument_list|(
name|sassc
operator|->
name|sc
argument_list|,
name|MPS_TRACE
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sassc
operator|->
name|sc
operator|->
name|mps_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|sc
operator|=
name|sassc
operator|->
name|sc
expr_stmt|;
name|tm
operator|=
name|mps_alloc_command
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|tm
operator|==
name|NULL
condition|)
block|{
name|mps_printf
argument_list|(
name|sc
argument_list|,
literal|"comand alloc failure in mpssas_action_resetdev\n"
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_RESRC_UNAVAIL
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
name|targ
operator|=
operator|&
name|sassc
operator|->
name|targets
index|[
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
index|]
expr_stmt|;
name|req
operator|=
operator|(
name|MPI2_SCSI_TASK_MANAGE_REQUEST
operator|*
operator|)
name|tm
operator|->
name|cm_req
expr_stmt|;
name|req
operator|->
name|DevHandle
operator|=
name|targ
operator|->
name|handle
expr_stmt|;
name|req
operator|->
name|Function
operator|=
name|MPI2_FUNCTION_SCSI_TASK_MGMT
expr_stmt|;
name|req
operator|->
name|TaskType
operator|=
name|MPI2_SCSITASKMGMT_TASKTYPE_TARGET_RESET
expr_stmt|;
comment|/* SAS Hard Link Reset / SATA Link Reset */
name|req
operator|->
name|MsgFlags
operator|=
name|MPI2_SCSITASKMGMT_MSGFLAGS_LINK_RESET
expr_stmt|;
name|tm
operator|->
name|cm_data
operator|=
name|NULL
expr_stmt|;
name|tm
operator|->
name|cm_desc
operator|.
name|HighPriority
operator|.
name|RequestFlags
operator|=
name|MPI2_REQ_DESCRIPT_FLAGS_HIGH_PRIORITY
expr_stmt|;
name|tm
operator|->
name|cm_complete
operator|=
name|mpssas_resetdev_complete
expr_stmt|;
name|tm
operator|->
name|cm_complete_data
operator|=
name|ccb
expr_stmt|;
name|mps_map_command
argument_list|(
name|sc
argument_list|,
name|tm
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mpssas_resetdev_complete
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mps_command
modifier|*
name|tm
parameter_list|)
block|{
name|MPI2_SCSI_TASK_MANAGE_REPLY
modifier|*
name|resp
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_TRACE
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sc
operator|->
name|mps_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|resp
operator|=
operator|(
name|MPI2_SCSI_TASK_MANAGE_REPLY
operator|*
operator|)
name|tm
operator|->
name|cm_reply
expr_stmt|;
name|ccb
operator|=
name|tm
operator|->
name|cm_complete_data
expr_stmt|;
comment|/* 	 * Currently there should be no way we can hit this case.  It only 	 * happens when we have a failure to allocate chain frames, and 	 * task management commands don't have S/G lists. 	 */
if|if
condition|(
operator|(
name|tm
operator|->
name|cm_flags
operator|&
name|MPS_CM_FLAGS_ERROR_MASK
operator|)
operator|!=
literal|0
condition|)
block|{
name|MPI2_SCSI_TASK_MANAGE_REQUEST
modifier|*
name|req
decl_stmt|;
name|req
operator|=
operator|(
name|MPI2_SCSI_TASK_MANAGE_REQUEST
operator|*
operator|)
name|tm
operator|->
name|cm_req
expr_stmt|;
name|mps_printf
argument_list|(
name|sc
argument_list|,
literal|"%s: cm_flags = %#x for reset of handle %#04x! "
literal|"This should not happen!\n"
argument_list|,
name|__func__
argument_list|,
name|tm
operator|->
name|cm_flags
argument_list|,
name|req
operator|->
name|DevHandle
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP_ERR
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|printf
argument_list|(
literal|"%s: IOCStatus = 0x%x ResponseCode = 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|resp
operator|->
name|IOCStatus
argument_list|,
name|resp
operator|->
name|ResponseCode
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
operator|->
name|ResponseCode
operator|==
name|MPI2_SCSITASKMGMT_RSP_TM_COMPLETE
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|mpssas_announce_reset
argument_list|(
name|sc
argument_list|,
name|AC_SENT_BDR
argument_list|,
name|tm
operator|->
name|cm_targ
operator|->
name|tid
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|)
expr_stmt|;
block|}
else|else
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP_ERR
expr_stmt|;
name|bailout
label|:
name|mpssas_free_tm
argument_list|(
name|sc
argument_list|,
name|tm
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mpssas_poll
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|)
block|{
name|struct
name|mpssas_softc
modifier|*
name|sassc
decl_stmt|;
name|sassc
operator|=
name|cam_sim_softc
argument_list|(
name|sim
argument_list|)
expr_stmt|;
if|if
condition|(
name|sassc
operator|->
name|sc
operator|->
name|mps_debug
operator|&
name|MPS_TRACE
condition|)
block|{
comment|/* frequent debug messages during a panic just slow 		 * everything down too much. 		 */
name|mps_printf
argument_list|(
name|sassc
operator|->
name|sc
argument_list|,
literal|"%s clearing MPS_TRACE\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|sassc
operator|->
name|sc
operator|->
name|mps_debug
operator|&=
operator|~
name|MPS_TRACE
expr_stmt|;
block|}
name|mps_intr_locked
argument_list|(
name|sassc
operator|->
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mpssas_rescan_done
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|union
name|ccb
modifier|*
name|done_ccb
parameter_list|)
block|{
name|struct
name|mpssas_softc
modifier|*
name|sassc
decl_stmt|;
name|char
name|path_str
index|[
literal|64
index|]
decl_stmt|;
if|if
condition|(
name|done_ccb
operator|==
name|NULL
condition|)
return|return;
name|sassc
operator|=
operator|(
expr|struct
name|mpssas_softc
operator|*
operator|)
name|done_ccb
operator|->
name|ccb_h
operator|.
name|ppriv_ptr1
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sassc
operator|->
name|sc
operator|->
name|mps_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|xpt_path_string
argument_list|(
name|done_ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|path_str
argument_list|,
sizeof|sizeof
argument_list|(
name|path_str
argument_list|)
argument_list|)
expr_stmt|;
name|mps_dprint
argument_list|(
name|sassc
operator|->
name|sc
argument_list|,
name|MPS_INFO
argument_list|,
literal|"Completing rescan for %s\n"
argument_list|,
name|path_str
argument_list|)
expr_stmt|;
name|xpt_free_path
argument_list|(
name|done_ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|xpt_free_ccb
argument_list|(
name|done_ccb
argument_list|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|1000006
comment|/* 	 * Before completing scan, get EEDP stuff for all of the existing 	 * targets. 	 */
name|mpssas_check_eedp
argument_list|(
name|sassc
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* thread to handle bus rescans */
end_comment

begin_function
specifier|static
name|void
name|mpssas_scanner_thread
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|mpssas_softc
modifier|*
name|sassc
decl_stmt|;
name|struct
name|mps_softc
modifier|*
name|sc
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|sassc
operator|=
operator|(
expr|struct
name|mpssas_softc
operator|*
operator|)
name|arg
expr_stmt|;
name|sc
operator|=
name|sassc
operator|->
name|sc
expr_stmt|;
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_TRACE
argument_list|,
literal|"%s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|mps_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|msleep
argument_list|(
operator|&
name|sassc
operator|->
name|ccb_scanq
argument_list|,
operator|&
name|sc
operator|->
name|mps_mtx
argument_list|,
name|PRIBIO
argument_list|,
literal|"mps_scanq"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sassc
operator|->
name|flags
operator|&
name|MPSSAS_SHUTDOWN
condition|)
block|{
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_TRACE
argument_list|,
literal|"Scanner shutting down\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|ccb
operator|=
operator|(
expr|union
name|ccb
operator|*
operator|)
name|TAILQ_FIRST
argument_list|(
operator|&
name|sassc
operator|->
name|ccb_scanq
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb
operator|==
name|NULL
condition|)
continue|continue;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sassc
operator|->
name|ccb_scanq
argument_list|,
operator|&
name|ccb
operator|->
name|ccb_h
argument_list|,
name|sim_links
operator|.
name|tqe
argument_list|)
expr_stmt|;
name|xpt_action
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
block|}
name|sassc
operator|->
name|flags
operator|&=
operator|~
name|MPSSAS_SCANTHREAD
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|sassc
operator|->
name|flags
argument_list|)
expr_stmt|;
name|mps_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_TRACE
argument_list|,
literal|"Scanner exiting\n"
argument_list|)
expr_stmt|;
name|mps_kproc_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mpssas_rescan
parameter_list|(
name|struct
name|mpssas_softc
modifier|*
name|sassc
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|char
name|path_str
index|[
literal|64
index|]
decl_stmt|;
name|mps_dprint
argument_list|(
name|sassc
operator|->
name|sc
argument_list|,
name|MPS_TRACE
argument_list|,
literal|"%s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sassc
operator|->
name|sc
operator|->
name|mps_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb
operator|==
name|NULL
condition|)
return|return;
name|xpt_path_string
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|path_str
argument_list|,
sizeof|sizeof
argument_list|(
name|path_str
argument_list|)
argument_list|)
expr_stmt|;
name|mps_dprint
argument_list|(
name|sassc
operator|->
name|sc
argument_list|,
name|MPS_INFO
argument_list|,
literal|"Queueing rescan for %s\n"
argument_list|,
name|path_str
argument_list|)
expr_stmt|;
comment|/* Prepare request */
name|ccb
operator|->
name|ccb_h
operator|.
name|ppriv_ptr1
operator|=
name|sassc
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|cbfcnp
operator|=
name|mpssas_rescan_done
expr_stmt|;
name|xpt_setup_ccb
argument_list|(
operator|&
name|ccb
operator|->
name|ccb_h
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|MPS_PRIORITY_XPT
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sassc
operator|->
name|ccb_scanq
argument_list|,
operator|&
name|ccb
operator|->
name|ccb_h
argument_list|,
name|sim_links
operator|.
name|tqe
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|sassc
operator|->
name|ccb_scanq
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|1000006
end_if

begin_function
specifier|static
name|void
name|mpssas_async
parameter_list|(
name|void
modifier|*
name|callback_arg
parameter_list|,
name|uint32_t
name|code
parameter_list|,
name|struct
name|cam_path
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|mps_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|mps_softc
operator|*
operator|)
name|callback_arg
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|AC_ADVINFO_CHANGED
case|:
block|{
name|struct
name|mpssas_target
modifier|*
name|target
decl_stmt|;
name|struct
name|mpssas_softc
modifier|*
name|sassc
decl_stmt|;
name|struct
name|scsi_read_capacity_data_long
name|rcap_buf
decl_stmt|;
name|struct
name|ccb_dev_advinfo
name|cdai
decl_stmt|;
name|struct
name|mpssas_lun
modifier|*
name|lun
decl_stmt|;
name|lun_id_t
name|lunid
decl_stmt|;
name|int
name|found_lun
decl_stmt|;
name|uintptr_t
name|buftype
decl_stmt|;
name|buftype
operator|=
operator|(
name|uintptr_t
operator|)
name|arg
expr_stmt|;
name|found_lun
operator|=
literal|0
expr_stmt|;
name|sassc
operator|=
name|sc
operator|->
name|sassc
expr_stmt|;
comment|/* 		 * We're only interested in read capacity data changes. 		 */
if|if
condition|(
name|buftype
operator|!=
name|CDAI_TYPE_RCAPLONG
condition|)
break|break;
comment|/* 		 * We're only interested in devices that are attached to 		 * this controller. 		 */
if|if
condition|(
name|xpt_path_path_id
argument_list|(
name|path
argument_list|)
operator|!=
name|sassc
operator|->
name|sim
operator|->
name|path_id
condition|)
break|break;
comment|/* 		 * We should have a handle for this, but check to make sure. 		 */
name|target
operator|=
operator|&
name|sassc
operator|->
name|targets
index|[
name|xpt_path_target_id
argument_list|(
name|path
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|target
operator|->
name|handle
operator|==
literal|0
condition|)
break|break;
name|lunid
operator|=
name|xpt_path_lun_id
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|lun
argument_list|,
argument|&target->luns
argument_list|,
argument|lun_link
argument_list|)
block|{
if|if
condition|(
name|lun
operator|->
name|lun_id
operator|==
name|lunid
condition|)
block|{
name|found_lun
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|found_lun
operator|==
literal|0
condition|)
block|{
name|lun
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|mpssas_lun
argument_list|)
argument_list|,
name|M_MPT2
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|lun
operator|==
name|NULL
condition|)
block|{
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_FAULT
argument_list|,
literal|"Unable to alloc "
literal|"LUN for EEDP support.\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|lun
operator|->
name|lun_id
operator|=
name|lunid
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|target
operator|->
name|luns
argument_list|,
name|lun
argument_list|,
name|lun_link
argument_list|)
expr_stmt|;
block|}
name|bzero
argument_list|(
operator|&
name|rcap_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|rcap_buf
argument_list|)
argument_list|)
expr_stmt|;
name|xpt_setup_ccb
argument_list|(
operator|&
name|cdai
operator|.
name|ccb_h
argument_list|,
name|path
argument_list|,
name|CAM_PRIORITY_NORMAL
argument_list|)
expr_stmt|;
name|cdai
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_DEV_ADVINFO
expr_stmt|;
name|cdai
operator|.
name|ccb_h
operator|.
name|flags
operator|=
name|CAM_DIR_IN
expr_stmt|;
name|cdai
operator|.
name|buftype
operator|=
name|CDAI_TYPE_RCAPLONG
expr_stmt|;
name|cdai
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|cdai
operator|.
name|bufsiz
operator|=
sizeof|sizeof
argument_list|(
name|rcap_buf
argument_list|)
expr_stmt|;
name|cdai
operator|.
name|buf
operator|=
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|rcap_buf
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
operator|&
name|cdai
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cdai
operator|.
name|ccb_h
operator|.
name|status
operator|&
name|CAM_DEV_QFRZN
operator|)
operator|!=
literal|0
condition|)
name|cam_release_devq
argument_list|(
name|cdai
operator|.
name|ccb_h
operator|.
name|path
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|cdai
operator|.
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|==
name|CAM_REQ_CMP
operator|)
operator|&&
operator|(
name|rcap_buf
operator|.
name|prot
operator|&
name|SRC16_PROT_EN
operator|)
condition|)
block|{
name|lun
operator|->
name|eedp_formatted
operator|=
name|TRUE
expr_stmt|;
name|lun
operator|->
name|eedp_block_size
operator|=
name|scsi_4btoul
argument_list|(
name|rcap_buf
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lun
operator|->
name|eedp_formatted
operator|=
name|FALSE
expr_stmt|;
name|lun
operator|->
name|eedp_block_size
operator|=
literal|0
expr_stmt|;
block|}
break|break;
block|}
default|default:
break|break;
block|}
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* __FreeBSD_version>= 1000006 */
end_comment

begin_function
specifier|static
name|void
name|mpssas_check_eedp
parameter_list|(
name|struct
name|mpssas_softc
modifier|*
name|sassc
parameter_list|)
block|{
name|struct
name|mps_softc
modifier|*
name|sc
init|=
name|sassc
operator|->
name|sc
decl_stmt|;
name|struct
name|ccb_scsiio
modifier|*
name|csio
decl_stmt|;
name|struct
name|scsi_read_capacity_16
modifier|*
name|scsi_cmd
decl_stmt|;
name|struct
name|scsi_read_capacity_eedp
modifier|*
name|rcap_buf
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|path_id_t
name|pathid
init|=
name|cam_sim_path
argument_list|(
name|sassc
operator|->
name|sim
argument_list|)
decl_stmt|;
name|target_id_t
name|targetid
decl_stmt|;
name|lun_id_t
name|lunid
decl_stmt|;
name|struct
name|cam_periph
modifier|*
name|found_periph
decl_stmt|;
name|struct
name|mpssas_target
modifier|*
name|target
decl_stmt|;
name|struct
name|mpssas_lun
modifier|*
name|lun
decl_stmt|;
name|uint8_t
name|found_lun
decl_stmt|;
comment|/* 	 * Issue a READ CAPACITY 16 command to each LUN of each target.  This 	 * info is used to determine if the LUN is formatted for EEDP support. 	 */
for|for
control|(
name|targetid
operator|=
literal|0
init|;
name|targetid
operator|<
name|sc
operator|->
name|facts
operator|->
name|MaxTargets
condition|;
name|targetid
operator|++
control|)
block|{
name|target
operator|=
operator|&
name|sassc
operator|->
name|targets
index|[
name|targetid
index|]
expr_stmt|;
if|if
condition|(
name|target
operator|->
name|handle
operator|==
literal|0x0
condition|)
block|{
continue|continue;
block|}
name|lunid
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|rcap_buf
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_read_capacity_eedp
argument_list|)
argument_list|,
name|M_MPT2
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcap_buf
operator|==
name|NULL
condition|)
block|{
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_FAULT
argument_list|,
literal|"Unable to alloc read "
literal|"capacity buffer for EEDP support.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|ccb
operator|=
name|xpt_alloc_ccb_nowait
argument_list|()
expr_stmt|;
if|if
condition|(
name|ccb
operator|==
name|NULL
condition|)
block|{
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_FAULT
argument_list|,
literal|"Unable to alloc CCB "
literal|"for EEDP support.\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rcap_buf
argument_list|,
name|M_MPT2
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|xpt_create_path
argument_list|(
operator|&
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|xpt_periph
argument_list|,
name|pathid
argument_list|,
name|targetid
argument_list|,
name|lunid
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_FAULT
argument_list|,
literal|"Unable to create "
literal|"path for EEDP support\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rcap_buf
argument_list|,
name|M_MPT2
argument_list|)
expr_stmt|;
name|xpt_free_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 			 * If a periph is returned, the LUN exists.  Create an 			 * entry in the target's LUN list. 			 */
if|if
condition|(
operator|(
name|found_periph
operator|=
name|cam_periph_find
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* 				 * If LUN is already in list, don't create a new 				 * one. 				 */
name|found_lun
operator|=
name|FALSE
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|lun
argument_list|,
argument|&target->luns
argument_list|,
argument|lun_link
argument_list|)
block|{
if|if
condition|(
name|lun
operator|->
name|lun_id
operator|==
name|lunid
condition|)
block|{
name|found_lun
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|found_lun
condition|)
block|{
name|lun
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|mpssas_lun
argument_list|)
argument_list|,
name|M_MPT2
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|lun
operator|==
name|NULL
condition|)
block|{
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_FAULT
argument_list|,
literal|"Unable to alloc LUN for "
literal|"EEDP support.\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rcap_buf
argument_list|,
name|M_MPT2
argument_list|)
expr_stmt|;
name|xpt_free_path
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|xpt_free_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
name|lun
operator|->
name|lun_id
operator|=
name|lunid
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|target
operator|->
name|luns
argument_list|,
name|lun
argument_list|,
name|lun_link
argument_list|)
expr_stmt|;
block|}
name|lunid
operator|++
expr_stmt|;
comment|/* 				 * Issue a READ CAPACITY 16 command for the LUN. 				 * The mpssas_read_cap_done function will load 				 * the read cap info into the LUN struct. 				 */
name|csio
operator|=
operator|&
name|ccb
operator|->
name|csio
expr_stmt|;
name|csio
operator|->
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_SCSI_IO
expr_stmt|;
name|csio
operator|->
name|ccb_h
operator|.
name|flags
operator|=
name|CAM_DIR_IN
expr_stmt|;
name|csio
operator|->
name|ccb_h
operator|.
name|retry_count
operator|=
literal|4
expr_stmt|;
name|csio
operator|->
name|ccb_h
operator|.
name|cbfcnp
operator|=
name|mpssas_read_cap_done
expr_stmt|;
name|csio
operator|->
name|ccb_h
operator|.
name|timeout
operator|=
literal|60000
expr_stmt|;
name|csio
operator|->
name|data_ptr
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|rcap_buf
expr_stmt|;
name|csio
operator|->
name|dxfer_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_read_capacity_eedp
argument_list|)
expr_stmt|;
name|csio
operator|->
name|sense_len
operator|=
name|MPS_SENSE_LEN
expr_stmt|;
name|csio
operator|->
name|cdb_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
expr_stmt|;
name|csio
operator|->
name|tag_action
operator|=
name|MSG_SIMPLE_Q_TAG
expr_stmt|;
name|scsi_cmd
operator|=
operator|(
expr|struct
name|scsi_read_capacity_16
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|bzero
argument_list|(
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|opcode
operator|=
literal|0x9E
expr_stmt|;
name|scsi_cmd
operator|->
name|service_action
operator|=
name|SRC16_SERVICE_ACTION
expr_stmt|;
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|scsi_cmd
operator|)
index|[
literal|13
index|]
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_read_capacity_eedp
argument_list|)
expr_stmt|;
comment|/* 				 * Set the path, target and lun IDs for the READ 				 * CAPACITY request. 				 */
name|ccb
operator|->
name|ccb_h
operator|.
name|path_id
operator|=
name|xpt_path_path_id
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
operator|=
name|xpt_path_target_id
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
operator|=
name|xpt_path_lun_id
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|ppriv_ptr1
operator|=
name|sassc
expr_stmt|;
name|xpt_action
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|free
argument_list|(
name|rcap_buf
argument_list|,
name|M_MPT2
argument_list|)
expr_stmt|;
name|xpt_free_path
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|xpt_free_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|found_periph
condition|)
do|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|mpssas_read_cap_done
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|union
name|ccb
modifier|*
name|done_ccb
parameter_list|)
block|{
name|struct
name|mpssas_softc
modifier|*
name|sassc
decl_stmt|;
name|struct
name|mpssas_target
modifier|*
name|target
decl_stmt|;
name|struct
name|mpssas_lun
modifier|*
name|lun
decl_stmt|;
name|struct
name|scsi_read_capacity_eedp
modifier|*
name|rcap_buf
decl_stmt|;
if|if
condition|(
name|done_ccb
operator|==
name|NULL
condition|)
return|return;
name|rcap_buf
operator|=
operator|(
expr|struct
name|scsi_read_capacity_eedp
operator|*
operator|)
name|done_ccb
operator|->
name|csio
operator|.
name|data_ptr
expr_stmt|;
comment|/* 	 * Get the LUN ID for the path and look it up in the LUN list for the 	 * target. 	 */
name|sassc
operator|=
operator|(
expr|struct
name|mpssas_softc
operator|*
operator|)
name|done_ccb
operator|->
name|ccb_h
operator|.
name|ppriv_ptr1
expr_stmt|;
name|target
operator|=
operator|&
name|sassc
operator|->
name|targets
index|[
name|done_ccb
operator|->
name|ccb_h
operator|.
name|target_id
index|]
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|lun
argument_list|,
argument|&target->luns
argument_list|,
argument|lun_link
argument_list|)
block|{
if|if
condition|(
name|lun
operator|->
name|lun_id
operator|!=
name|done_ccb
operator|->
name|ccb_h
operator|.
name|target_lun
condition|)
continue|continue;
comment|/* 		 * Got the LUN in the target's LUN list.  Fill it in 		 * with EEDP info.  If the READ CAP 16 command had some 		 * SCSI error (common if command is not supported), mark 		 * the lun as not supporting EEDP and set the block size 		 * to 0. 		 */
if|if
condition|(
operator|(
operator|(
name|done_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_CMP
operator|)
operator|||
operator|(
name|done_ccb
operator|->
name|csio
operator|.
name|scsi_status
operator|!=
name|SCSI_STATUS_OK
operator|)
condition|)
block|{
name|lun
operator|->
name|eedp_formatted
operator|=
name|FALSE
expr_stmt|;
name|lun
operator|->
name|eedp_block_size
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|rcap_buf
operator|->
name|protect
operator|&
literal|0x01
condition|)
block|{
name|lun
operator|->
name|eedp_formatted
operator|=
name|TRUE
expr_stmt|;
name|lun
operator|->
name|eedp_block_size
operator|=
name|scsi_4btoul
argument_list|(
name|rcap_buf
operator|->
name|length
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
comment|// Finished with this CCB and path.
name|free
argument_list|(
name|rcap_buf
argument_list|,
name|M_MPT2
argument_list|)
expr_stmt|;
name|xpt_free_path
argument_list|(
name|done_ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|xpt_free_ccb
argument_list|(
name|done_ccb
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __FreeBSD_version>= 1000006 */
end_comment

begin_function
name|int
name|mpssas_startup
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|mpssas_softc
modifier|*
name|sassc
decl_stmt|;
comment|/* 	 * Send the port enable message and set the wait_for_port_enable flag. 	 * This flag helps to keep the simq frozen until all discovery events 	 * are processed. 	 */
name|sassc
operator|=
name|sc
operator|->
name|sassc
expr_stmt|;
name|mpssas_startup_increment
argument_list|(
name|sassc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|wait_for_port_enable
operator|=
literal|1
expr_stmt|;
name|mpssas_send_portenable
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mpssas_send_portenable
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|)
block|{
name|MPI2_PORT_ENABLE_REQUEST
modifier|*
name|request
decl_stmt|;
name|struct
name|mps_command
modifier|*
name|cm
decl_stmt|;
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_TRACE
argument_list|,
literal|"%s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cm
operator|=
name|mps_alloc_command
argument_list|(
name|sc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|request
operator|=
operator|(
name|MPI2_PORT_ENABLE_REQUEST
operator|*
operator|)
name|cm
operator|->
name|cm_req
expr_stmt|;
name|request
operator|->
name|Function
operator|=
name|MPI2_FUNCTION_PORT_ENABLE
expr_stmt|;
name|request
operator|->
name|MsgFlags
operator|=
literal|0
expr_stmt|;
name|request
operator|->
name|VP_ID
operator|=
literal|0
expr_stmt|;
name|cm
operator|->
name|cm_desc
operator|.
name|Default
operator|.
name|RequestFlags
operator|=
name|MPI2_REQ_DESCRIPT_FLAGS_DEFAULT_TYPE
expr_stmt|;
name|cm
operator|->
name|cm_complete
operator|=
name|mpssas_portenable_complete
expr_stmt|;
name|cm
operator|->
name|cm_data
operator|=
name|NULL
expr_stmt|;
name|cm
operator|->
name|cm_sge
operator|=
name|NULL
expr_stmt|;
name|mps_map_command
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_TRACE
argument_list|,
literal|"mps_send_portenable finished cm %p req %p complete %p\n"
argument_list|,
name|cm
argument_list|,
name|cm
operator|->
name|cm_req
argument_list|,
name|cm
operator|->
name|cm_complete
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mpssas_portenable_complete
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mps_command
modifier|*
name|cm
parameter_list|)
block|{
name|MPI2_PORT_ENABLE_REPLY
modifier|*
name|reply
decl_stmt|;
name|struct
name|mpssas_softc
modifier|*
name|sassc
decl_stmt|;
name|struct
name|mpssas_target
modifier|*
name|target
decl_stmt|;
name|int
name|i
decl_stmt|;
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_TRACE
argument_list|,
literal|"%s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|sassc
operator|=
name|sc
operator|->
name|sassc
expr_stmt|;
comment|/* 	 * Currently there should be no way we can hit this case.  It only 	 * happens when we have a failure to allocate chain frames, and 	 * port enable commands don't have S/G lists. 	 */
if|if
condition|(
operator|(
name|cm
operator|->
name|cm_flags
operator|&
name|MPS_CM_FLAGS_ERROR_MASK
operator|)
operator|!=
literal|0
condition|)
block|{
name|mps_printf
argument_list|(
name|sc
argument_list|,
literal|"%s: cm_flags = %#x for port enable! "
literal|"This should not happen!\n"
argument_list|,
name|__func__
argument_list|,
name|cm
operator|->
name|cm_flags
argument_list|)
expr_stmt|;
block|}
name|reply
operator|=
operator|(
name|MPI2_PORT_ENABLE_REPLY
operator|*
operator|)
name|cm
operator|->
name|cm_reply
expr_stmt|;
if|if
condition|(
name|reply
operator|==
name|NULL
condition|)
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_FAULT
argument_list|,
literal|"Portenable NULL reply\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|reply
operator|->
name|IOCStatus
operator|&
name|MPI2_IOCSTATUS_MASK
operator|)
operator|!=
name|MPI2_IOCSTATUS_SUCCESS
condition|)
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_FAULT
argument_list|,
literal|"Portenable failed\n"
argument_list|)
expr_stmt|;
name|mps_free_command
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mps_ich
operator|.
name|ich_arg
operator|!=
name|NULL
condition|)
block|{
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_INFO
argument_list|,
literal|"disestablish config intrhook\n"
argument_list|)
expr_stmt|;
name|config_intrhook_disestablish
argument_list|(
operator|&
name|sc
operator|->
name|mps_ich
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mps_ich
operator|.
name|ich_arg
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * Get WarpDrive info after discovery is complete but before the scan 	 * starts.  At this point, all devices are ready to be exposed to the 	 * OS.  If devices should be hidden instead, take them out of the 	 * 'targets' array before the scan.  The devinfo for a disk will have 	 * some info and a volume's will be 0.  Use that to remove disks. 	 */
name|mps_wd_config_pages
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|sc
operator|->
name|mps_flags
operator|&
name|MPS_FLAGS_WD_AVAILABLE
operator|)
operator|&&
operator|(
name|sc
operator|->
name|WD_hide_expose
operator|==
name|MPS_WD_HIDE_ALWAYS
operator|)
operator|)
operator|||
operator|(
name|sc
operator|->
name|WD_valid_config
operator|&&
operator|(
name|sc
operator|->
name|WD_hide_expose
operator|==
name|MPS_WD_HIDE_IF_VOLUME
operator|)
operator|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sassc
operator|->
name|sc
operator|->
name|facts
operator|->
name|MaxTargets
condition|;
name|i
operator|++
control|)
block|{
name|target
operator|=
operator|&
name|sassc
operator|->
name|targets
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|target
operator|->
name|devinfo
condition|)
block|{
name|target
operator|->
name|devinfo
operator|=
literal|0x0
expr_stmt|;
name|target
operator|->
name|encl_handle
operator|=
literal|0x0
expr_stmt|;
name|target
operator|->
name|encl_slot
operator|=
literal|0x0
expr_stmt|;
name|target
operator|->
name|handle
operator|=
literal|0x0
expr_stmt|;
name|target
operator|->
name|tid
operator|=
literal|0x0
expr_stmt|;
name|target
operator|->
name|linkrate
operator|=
literal|0x0
expr_stmt|;
name|target
operator|->
name|flags
operator|=
literal|0x0
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * Done waiting for port enable to complete.  Decrement the refcount. 	 * If refcount is 0, discovery is complete and a rescan of the bus can 	 * take place.  Since the simq was explicitly frozen before port 	 * enable, it must be explicitly released here to keep the 	 * freeze/release count in sync. 	 */
name|sc
operator|->
name|wait_for_port_enable
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|port_enable_complete
operator|=
literal|1
expr_stmt|;
name|mpssas_startup_decrement
argument_list|(
name|sassc
argument_list|)
expr_stmt|;
name|xpt_release_simq
argument_list|(
name|sassc
operator|->
name|sim
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

