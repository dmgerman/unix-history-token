begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2009 Yahoo! Inc.  * Copyright (c) 2011-2015 LSI Corp.  * Copyright (c) 2013-2015 Avago Technologies  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * Avago Technologies (LSI) MPT-Fusion Host Adapter FreeBSD  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Communications core for Avago Technologies (LSI) MPT2 */
end_comment

begin_comment
comment|/* TODO Move headers to mpsvar */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/selinfo.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/bio.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/eventhandler.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_all.h>
end_include

begin_include
include|#
directive|include
file|<dev/mps/mpi/mpi2_type.h>
end_include

begin_include
include|#
directive|include
file|<dev/mps/mpi/mpi2.h>
end_include

begin_include
include|#
directive|include
file|<dev/mps/mpi/mpi2_ioc.h>
end_include

begin_include
include|#
directive|include
file|<dev/mps/mpi/mpi2_sas.h>
end_include

begin_include
include|#
directive|include
file|<dev/mps/mpi/mpi2_cnfg.h>
end_include

begin_include
include|#
directive|include
file|<dev/mps/mpi/mpi2_init.h>
end_include

begin_include
include|#
directive|include
file|<dev/mps/mpi/mpi2_tool.h>
end_include

begin_include
include|#
directive|include
file|<dev/mps/mps_ioctl.h>
end_include

begin_include
include|#
directive|include
file|<dev/mps/mpsvar.h>
end_include

begin_include
include|#
directive|include
file|<dev/mps/mps_table.h>
end_include

begin_function_decl
specifier|static
name|int
name|mps_diag_reset
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|int
name|sleep_flag
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mps_init_queues
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mps_message_unit_reset
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|int
name|sleep_flag
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mps_transition_operational
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mps_iocfacts_allocate
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|attaching
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mps_iocfacts_free
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mps_startup
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mps_send_iocinit
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mps_alloc_queues
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mps_alloc_replies
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mps_alloc_requests
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mps_attach_log
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|mps_complete_command
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mps_command
modifier|*
name|cm
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mps_dispatch_event
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|uintptr_t
name|data
parameter_list|,
name|MPI2_EVENT_NOTIFICATION_REPLY
modifier|*
name|reply
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mps_config_complete
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mps_command
modifier|*
name|cm
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mps_periodic
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mps_reregister_events
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mps_enqueue_request
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mps_command
modifier|*
name|cm
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mps_get_iocfacts
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|MPI2_IOC_FACTS_REPLY
modifier|*
name|facts
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mps_wait_db_ack
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|int
name|timeout
parameter_list|,
name|int
name|sleep_flag
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_hw
argument_list|,
name|OID_AUTO
argument_list|,
name|mps
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"MPS Driver Parameters"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_MPT2
argument_list|,
literal|"mps"
argument_list|,
literal|"mpt2 driver memory"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Do a "Diagnostic Reset" aka a hard reset.  This should get the chip out of  * any state and back to its initialization state machine.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|mpt2_reset_magic
index|[]
init|=
block|{
literal|0x00
block|,
literal|0x0f
block|,
literal|0x04
block|,
literal|0x0b
block|,
literal|0x02
block|,
literal|0x07
block|,
literal|0x0d
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Added this union to smoothly convert le64toh cm->cm_desc.Words.  * Compiler only support unint64_t to be passed as argument.  * Otherwise it will through below error  * "aggregate value used where an integer was expected"  */
end_comment

begin_typedef
typedef|typedef
union|union
name|_reply_descriptor
block|{
name|u64
name|word
decl_stmt|;
struct|struct
block|{
name|u32
name|low
decl_stmt|;
name|u32
name|high
decl_stmt|;
block|}
name|u
struct|;
block|}
name|reply_descriptor
operator|,
name|address_descriptor
typedef|;
end_typedef

begin_comment
comment|/* Rate limit chain-fail messages to 1 per minute */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|timeval
name|mps_chainfail_interval
init|=
block|{
literal|60
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*   * sleep_flag can be either CAN_SLEEP or NO_SLEEP.  * If this function is called from process context, it can sleep  * and there is no harm to sleep, in case if this fuction is called  * from Interrupt handler, we can not sleep and need NO_SLEEP flag set.  * based on sleep flags driver will call either msleep, pause or DELAY.  * msleep and pause are of same variant, but pause is used when mps_mtx  * is not hold by driver.  *  */
end_comment

begin_function
specifier|static
name|int
name|mps_diag_reset
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|int
name|sleep_flag
parameter_list|)
block|{
name|uint32_t
name|reg
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|,
name|tries
init|=
literal|0
decl_stmt|;
name|uint8_t
name|first_wait_done
init|=
name|FALSE
decl_stmt|;
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_TRACE
argument_list|,
literal|"%s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* Clear any pending interrupts */
name|mps_regwrite
argument_list|(
name|sc
argument_list|,
name|MPI2_HOST_INTERRUPT_STATUS_OFFSET
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
comment|/*Force NO_SLEEP for threads prohibited to sleep  	* e.a Thread from interrupt handler are prohibited to sleep.  	*/
if|if
condition|(
name|curthread
operator|->
name|td_no_sleeping
operator|!=
literal|0
condition|)
name|sleep_flag
operator|=
name|NO_SLEEP
expr_stmt|;
comment|/* Push the magic sequence */
name|error
operator|=
name|ETIMEDOUT
expr_stmt|;
while|while
condition|(
name|tries
operator|++
operator|<
literal|20
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|mpt2_reset_magic
argument_list|)
condition|;
name|i
operator|++
control|)
name|mps_regwrite
argument_list|(
name|sc
argument_list|,
name|MPI2_WRITE_SEQUENCE_OFFSET
argument_list|,
name|mpt2_reset_magic
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* wait 100 msec */
if|if
condition|(
name|mtx_owned
argument_list|(
operator|&
name|sc
operator|->
name|mps_mtx
argument_list|)
operator|&&
name|sleep_flag
operator|==
name|CAN_SLEEP
condition|)
name|msleep
argument_list|(
operator|&
name|sc
operator|->
name|msleep_fake_chan
argument_list|,
operator|&
name|sc
operator|->
name|mps_mtx
argument_list|,
literal|0
argument_list|,
literal|"mpsdiag"
argument_list|,
name|hz
operator|/
literal|10
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sleep_flag
operator|==
name|CAN_SLEEP
condition|)
name|pause
argument_list|(
literal|"mpsdiag"
argument_list|,
name|hz
operator|/
literal|10
argument_list|)
expr_stmt|;
else|else
name|DELAY
argument_list|(
literal|100
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|reg
operator|=
name|mps_regread
argument_list|(
name|sc
argument_list|,
name|MPI2_HOST_DIAGNOSTIC_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|&
name|MPI2_DIAG_DIAG_WRITE_ENABLE
condition|)
block|{
name|error
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Send the actual reset.  XXX need to refresh the reg? */
name|mps_regwrite
argument_list|(
name|sc
argument_list|,
name|MPI2_HOST_DIAGNOSTIC_OFFSET
argument_list|,
name|reg
operator||
name|MPI2_DIAG_RESET_ADAPTER
argument_list|)
expr_stmt|;
comment|/* Wait up to 300 seconds in 50ms intervals */
name|error
operator|=
name|ETIMEDOUT
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6000
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		 * Wait 50 msec. If this is the first time through, wait 256 		 * msec to satisfy Diag Reset timing requirements. 		 */
if|if
condition|(
name|first_wait_done
condition|)
block|{
if|if
condition|(
name|mtx_owned
argument_list|(
operator|&
name|sc
operator|->
name|mps_mtx
argument_list|)
operator|&&
name|sleep_flag
operator|==
name|CAN_SLEEP
condition|)
name|msleep
argument_list|(
operator|&
name|sc
operator|->
name|msleep_fake_chan
argument_list|,
operator|&
name|sc
operator|->
name|mps_mtx
argument_list|,
literal|0
argument_list|,
literal|"mpsdiag"
argument_list|,
name|hz
operator|/
literal|20
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sleep_flag
operator|==
name|CAN_SLEEP
condition|)
name|pause
argument_list|(
literal|"mpsdiag"
argument_list|,
name|hz
operator|/
literal|20
argument_list|)
expr_stmt|;
else|else
name|DELAY
argument_list|(
literal|50
operator|*
literal|1000
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DELAY
argument_list|(
literal|256
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|first_wait_done
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* 		 * Check for the RESET_ADAPTER bit to be cleared first, then 		 * wait for the RESET state to be cleared, which takes a little 		 * longer. 		 */
name|reg
operator|=
name|mps_regread
argument_list|(
name|sc
argument_list|,
name|MPI2_HOST_DIAGNOSTIC_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|&
name|MPI2_DIAG_RESET_ADAPTER
condition|)
block|{
continue|continue;
block|}
name|reg
operator|=
name|mps_regread
argument_list|(
name|sc
argument_list|,
name|MPI2_DOORBELL_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|reg
operator|&
name|MPI2_IOC_STATE_MASK
operator|)
operator|!=
name|MPI2_IOC_STATE_RESET
condition|)
block|{
name|error
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|mps_regwrite
argument_list|(
name|sc
argument_list|,
name|MPI2_WRITE_SEQUENCE_OFFSET
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mps_message_unit_reset
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|int
name|sleep_flag
parameter_list|)
block|{
name|MPS_FUNCTRACE
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mps_regwrite
argument_list|(
name|sc
argument_list|,
name|MPI2_DOORBELL_OFFSET
argument_list|,
name|MPI2_FUNCTION_IOC_MESSAGE_UNIT_RESET
operator|<<
name|MPI2_DOORBELL_FUNCTION_SHIFT
argument_list|)
expr_stmt|;
if|if
condition|(
name|mps_wait_db_ack
argument_list|(
name|sc
argument_list|,
literal|5
argument_list|,
name|sleep_flag
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_FAULT
argument_list|,
literal|"Doorbell handshake failed :<%s>\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|ETIMEDOUT
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mps_transition_ready
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|reg
decl_stmt|,
name|state
decl_stmt|;
name|int
name|error
decl_stmt|,
name|tries
init|=
literal|0
decl_stmt|;
name|int
name|sleep_flags
decl_stmt|;
name|MPS_FUNCTRACE
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* If we are in attach call, do not sleep */
name|sleep_flags
operator|=
operator|(
name|sc
operator|->
name|mps_flags
operator|&
name|MPS_FLAGS_ATTACH_DONE
operator|)
condition|?
name|CAN_SLEEP
else|:
name|NO_SLEEP
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|tries
operator|++
operator|<
literal|1200
condition|)
block|{
name|reg
operator|=
name|mps_regread
argument_list|(
name|sc
argument_list|,
name|MPI2_DOORBELL_OFFSET
argument_list|)
expr_stmt|;
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_INIT
argument_list|,
literal|"Doorbell= 0x%x\n"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* 		 * Ensure the IOC is ready to talk.  If it's not, try 		 * resetting it. 		 */
if|if
condition|(
name|reg
operator|&
name|MPI2_DOORBELL_USED
condition|)
block|{
name|mps_diag_reset
argument_list|(
name|sc
argument_list|,
name|sleep_flags
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|50000
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Is the adapter owned by another peer? */
if|if
condition|(
operator|(
name|reg
operator|&
name|MPI2_DOORBELL_WHO_INIT_MASK
operator|)
operator|==
operator|(
name|MPI2_WHOINIT_PCI_PEER
operator|<<
name|MPI2_DOORBELL_WHO_INIT_SHIFT
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mps_dev
argument_list|,
literal|"IOC is under the control "
literal|"of another peer host, aborting initialization.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|state
operator|=
name|reg
operator|&
name|MPI2_IOC_STATE_MASK
expr_stmt|;
if|if
condition|(
name|state
operator|==
name|MPI2_IOC_STATE_READY
condition|)
block|{
comment|/* Ready to go! */
name|error
operator|=
literal|0
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|state
operator|==
name|MPI2_IOC_STATE_FAULT
condition|)
block|{
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_FAULT
argument_list|,
literal|"IOC in fault state 0x%x, resetting\n"
argument_list|,
name|state
operator|&
name|MPI2_DOORBELL_FAULT_CODE_MASK
argument_list|)
expr_stmt|;
name|mps_diag_reset
argument_list|(
name|sc
argument_list|,
name|sleep_flags
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|state
operator|==
name|MPI2_IOC_STATE_OPERATIONAL
condition|)
block|{
comment|/* Need to take ownership */
name|mps_message_unit_reset
argument_list|(
name|sc
argument_list|,
name|sleep_flags
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|state
operator|==
name|MPI2_IOC_STATE_RESET
condition|)
block|{
comment|/* Wait a bit, IOC might be in transition */
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_FAULT
argument_list|,
literal|"IOC in unexpected reset state\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_FAULT
argument_list|,
literal|"IOC in unknown state 0x%x\n"
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
comment|/* Wait 50ms for things to settle down. */
name|DELAY
argument_list|(
literal|50000
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|mps_dev
argument_list|,
literal|"Cannot transition IOC to ready\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mps_transition_operational
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|reg
decl_stmt|,
name|state
decl_stmt|;
name|int
name|error
decl_stmt|;
name|MPS_FUNCTRACE
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|reg
operator|=
name|mps_regread
argument_list|(
name|sc
argument_list|,
name|MPI2_DOORBELL_OFFSET
argument_list|)
expr_stmt|;
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_INIT
argument_list|,
literal|"Doorbell= 0x%x\n"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|state
operator|=
name|reg
operator|&
name|MPI2_IOC_STATE_MASK
expr_stmt|;
if|if
condition|(
name|state
operator|!=
name|MPI2_IOC_STATE_READY
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|mps_transition_ready
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_FAULT
argument_list|,
literal|"%s failed to transition ready\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
name|error
operator|=
name|mps_send_iocinit
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This is called during attach and when re-initializing due to a Diag Reset.  * IOC Facts is used to allocate many of the structures needed by the driver.  * If called from attach, de-allocation is not required because the driver has  * not allocated any structures yet, but if called from a Diag Reset, previously  * allocated structures based on IOC Facts will need to be freed and re-  * allocated bases on the latest IOC Facts.  */
end_comment

begin_function
specifier|static
name|int
name|mps_iocfacts_allocate
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|attaching
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|Mpi2IOCFactsReply_t
name|saved_facts
decl_stmt|;
name|uint8_t
name|saved_mode
decl_stmt|,
name|reallocating
decl_stmt|;
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_TRACE
argument_list|,
literal|"%s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* Save old IOC Facts and then only reallocate if Facts have changed */
if|if
condition|(
operator|!
name|attaching
condition|)
block|{
name|bcopy
argument_list|(
name|sc
operator|->
name|facts
argument_list|,
operator|&
name|saved_facts
argument_list|,
sizeof|sizeof
argument_list|(
name|MPI2_IOC_FACTS_REPLY
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Get IOC Facts.  In all cases throughout this function, panic if doing 	 * a re-initialization and only return the error if attaching so the OS 	 * can handle it. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|mps_get_iocfacts
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|facts
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|attaching
condition|)
block|{
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_FAULT
argument_list|,
literal|"%s failed to get IOC Facts "
literal|"with error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
else|else
block|{
name|panic
argument_list|(
literal|"%s failed to get IOC Facts with error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
block|}
name|mps_print_iocfacts
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|facts
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|sc
operator|->
name|fw_version
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|fw_version
argument_list|)
argument_list|,
literal|"%02d.%02d.%02d.%02d"
argument_list|,
name|sc
operator|->
name|facts
operator|->
name|FWVersion
operator|.
name|Struct
operator|.
name|Major
argument_list|,
name|sc
operator|->
name|facts
operator|->
name|FWVersion
operator|.
name|Struct
operator|.
name|Minor
argument_list|,
name|sc
operator|->
name|facts
operator|->
name|FWVersion
operator|.
name|Struct
operator|.
name|Unit
argument_list|,
name|sc
operator|->
name|facts
operator|->
name|FWVersion
operator|.
name|Struct
operator|.
name|Dev
argument_list|)
expr_stmt|;
name|mps_printf
argument_list|(
name|sc
argument_list|,
literal|"Firmware: %s, Driver: %s\n"
argument_list|,
name|sc
operator|->
name|fw_version
argument_list|,
name|MPS_DRIVER_VERSION
argument_list|)
expr_stmt|;
name|mps_printf
argument_list|(
name|sc
argument_list|,
literal|"IOCCapabilities: %b\n"
argument_list|,
name|sc
operator|->
name|facts
operator|->
name|IOCCapabilities
argument_list|,
literal|"\20"
literal|"\3ScsiTaskFull"
literal|"\4DiagTrace"
literal|"\5SnapBuf"
literal|"\6ExtBuf"
literal|"\7EEDP"
literal|"\10BiDirTarg"
literal|"\11Multicast"
literal|"\14TransRetry"
literal|"\15IR"
literal|"\16EventReplay"
literal|"\17RaidAccel"
literal|"\20MSIXIndex"
literal|"\21HostDisc"
argument_list|)
expr_stmt|;
comment|/* 	 * If the chip doesn't support event replay then a hard reset will be 	 * required to trigger a full discovery.  Do the reset here then 	 * retransition to Ready.  A hard reset might have already been done, 	 * but it doesn't hurt to do it again.  Only do this if attaching, not 	 * for a Diag Reset. 	 */
if|if
condition|(
name|attaching
condition|)
block|{
if|if
condition|(
operator|(
name|sc
operator|->
name|facts
operator|->
name|IOCCapabilities
operator|&
name|MPI2_IOCFACTS_CAPABILITY_EVENT_REPLAY
operator|)
operator|==
literal|0
condition|)
block|{
name|mps_diag_reset
argument_list|(
name|sc
argument_list|,
name|NO_SLEEP
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|mps_transition_ready
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_FAULT
argument_list|,
literal|"%s failed to "
literal|"transition to ready with error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
block|}
comment|/* 	 * Set flag if IR Firmware is loaded.  If the RAID Capability has 	 * changed from the previous IOC Facts, log a warning, but only if 	 * checking this after a Diag Reset and not during attach. 	 */
name|saved_mode
operator|=
name|sc
operator|->
name|ir_firmware
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|facts
operator|->
name|IOCCapabilities
operator|&
name|MPI2_IOCFACTS_CAPABILITY_INTEGRATED_RAID
condition|)
name|sc
operator|->
name|ir_firmware
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|attaching
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|ir_firmware
operator|!=
name|saved_mode
condition|)
block|{
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_FAULT
argument_list|,
literal|"%s new IR/IT mode in IOC "
literal|"Facts does not match previous mode\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Only deallocate and reallocate if relevant IOC Facts have changed */
name|reallocating
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|attaching
operator|)
operator|&&
operator|(
operator|(
name|saved_facts
operator|.
name|MsgVersion
operator|!=
name|sc
operator|->
name|facts
operator|->
name|MsgVersion
operator|)
operator|||
operator|(
name|saved_facts
operator|.
name|HeaderVersion
operator|!=
name|sc
operator|->
name|facts
operator|->
name|HeaderVersion
operator|)
operator|||
operator|(
name|saved_facts
operator|.
name|MaxChainDepth
operator|!=
name|sc
operator|->
name|facts
operator|->
name|MaxChainDepth
operator|)
operator|||
operator|(
name|saved_facts
operator|.
name|RequestCredit
operator|!=
name|sc
operator|->
name|facts
operator|->
name|RequestCredit
operator|)
operator|||
operator|(
name|saved_facts
operator|.
name|ProductID
operator|!=
name|sc
operator|->
name|facts
operator|->
name|ProductID
operator|)
operator|||
operator|(
name|saved_facts
operator|.
name|IOCCapabilities
operator|!=
name|sc
operator|->
name|facts
operator|->
name|IOCCapabilities
operator|)
operator|||
operator|(
name|saved_facts
operator|.
name|IOCRequestFrameSize
operator|!=
name|sc
operator|->
name|facts
operator|->
name|IOCRequestFrameSize
operator|)
operator|||
operator|(
name|saved_facts
operator|.
name|MaxTargets
operator|!=
name|sc
operator|->
name|facts
operator|->
name|MaxTargets
operator|)
operator|||
operator|(
name|saved_facts
operator|.
name|MaxSasExpanders
operator|!=
name|sc
operator|->
name|facts
operator|->
name|MaxSasExpanders
operator|)
operator|||
operator|(
name|saved_facts
operator|.
name|MaxEnclosures
operator|!=
name|sc
operator|->
name|facts
operator|->
name|MaxEnclosures
operator|)
operator|||
operator|(
name|saved_facts
operator|.
name|HighPriorityCredit
operator|!=
name|sc
operator|->
name|facts
operator|->
name|HighPriorityCredit
operator|)
operator|||
operator|(
name|saved_facts
operator|.
name|MaxReplyDescriptorPostQueueDepth
operator|!=
name|sc
operator|->
name|facts
operator|->
name|MaxReplyDescriptorPostQueueDepth
operator|)
operator|||
operator|(
name|saved_facts
operator|.
name|ReplyFrameSize
operator|!=
name|sc
operator|->
name|facts
operator|->
name|ReplyFrameSize
operator|)
operator|||
operator|(
name|saved_facts
operator|.
name|MaxVolumes
operator|!=
name|sc
operator|->
name|facts
operator|->
name|MaxVolumes
operator|)
operator|||
operator|(
name|saved_facts
operator|.
name|MaxPersistentEntries
operator|!=
name|sc
operator|->
name|facts
operator|->
name|MaxPersistentEntries
operator|)
operator|)
condition|)
block|{
name|reallocating
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* 	 * Some things should be done if attaching or re-allocating after a Diag 	 * Reset, but are not needed after a Diag Reset if the FW has not 	 * changed. 	 */
if|if
condition|(
name|attaching
operator|||
name|reallocating
condition|)
block|{
comment|/* 		 * Check if controller supports FW diag buffers and set flag to 		 * enable each type. 		 */
if|if
condition|(
name|sc
operator|->
name|facts
operator|->
name|IOCCapabilities
operator|&
name|MPI2_IOCFACTS_CAPABILITY_DIAG_TRACE_BUFFER
condition|)
name|sc
operator|->
name|fw_diag_buffer_list
index|[
name|MPI2_DIAG_BUF_TYPE_TRACE
index|]
operator|.
name|enabled
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|facts
operator|->
name|IOCCapabilities
operator|&
name|MPI2_IOCFACTS_CAPABILITY_SNAPSHOT_BUFFER
condition|)
name|sc
operator|->
name|fw_diag_buffer_list
index|[
name|MPI2_DIAG_BUF_TYPE_SNAPSHOT
index|]
operator|.
name|enabled
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|facts
operator|->
name|IOCCapabilities
operator|&
name|MPI2_IOCFACTS_CAPABILITY_EXTENDED_BUFFER
condition|)
name|sc
operator|->
name|fw_diag_buffer_list
index|[
name|MPI2_DIAG_BUF_TYPE_EXTENDED
index|]
operator|.
name|enabled
operator|=
name|TRUE
expr_stmt|;
comment|/* 		 * Set flag if EEDP is supported and if TLR is supported. 		 */
if|if
condition|(
name|sc
operator|->
name|facts
operator|->
name|IOCCapabilities
operator|&
name|MPI2_IOCFACTS_CAPABILITY_EEDP
condition|)
name|sc
operator|->
name|eedp_enabled
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|facts
operator|->
name|IOCCapabilities
operator|&
name|MPI2_IOCFACTS_CAPABILITY_TLR
condition|)
name|sc
operator|->
name|control_TLR
operator|=
name|TRUE
expr_stmt|;
comment|/* 		 * Size the queues. Since the reply queues always need one free 		 * entry, we'll just deduct one reply message here. 		 */
name|sc
operator|->
name|num_reqs
operator|=
name|MIN
argument_list|(
name|MPS_REQ_FRAMES
argument_list|,
name|sc
operator|->
name|facts
operator|->
name|RequestCredit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|num_replies
operator|=
name|MIN
argument_list|(
name|MPS_REPLY_FRAMES
operator|+
name|MPS_EVT_REPLY_FRAMES
argument_list|,
name|sc
operator|->
name|facts
operator|->
name|MaxReplyDescriptorPostQueueDepth
argument_list|)
operator|-
literal|1
expr_stmt|;
comment|/* 		 * Initialize all Tail Queues 		 */
name|TAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|req_list
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|high_priority_req_list
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|chain_list
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|tm_list
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If doing a Diag Reset and the FW is significantly different 	 * (reallocating will be set above in IOC Facts comparison), then all 	 * buffers based on the IOC Facts will need to be freed before they are 	 * reallocated. 	 */
if|if
condition|(
name|reallocating
condition|)
block|{
name|mps_iocfacts_free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mpssas_realloc_targets
argument_list|(
name|sc
argument_list|,
name|saved_facts
operator|.
name|MaxTargets
operator|+
name|saved_facts
operator|.
name|MaxVolumes
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Any deallocation has been completed.  Now start reallocating 	 * if needed.  Will only need to reallocate if attaching or if the new 	 * IOC Facts are different from the previous IOC Facts after a Diag 	 * Reset. Targets have already been allocated above if needed. 	 */
if|if
condition|(
name|attaching
operator|||
name|reallocating
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|error
operator|=
name|mps_alloc_queues
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
operator|(
name|error
operator|=
name|mps_alloc_replies
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
operator|(
name|error
operator|=
name|mps_alloc_requests
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|attaching
condition|)
block|{
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_FAULT
argument_list|,
literal|"%s failed to alloc "
literal|"queues with error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|mps_free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
else|else
block|{
name|panic
argument_list|(
literal|"%s failed to alloc queues with error "
literal|"%d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Always initialize the queues */
name|bzero
argument_list|(
name|sc
operator|->
name|free_queue
argument_list|,
name|sc
operator|->
name|fqdepth
operator|*
literal|4
argument_list|)
expr_stmt|;
name|mps_init_queues
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Always get the chip out of the reset state, but only panic if not 	 * attaching.  If attaching and there is an error, that is handled by 	 * the OS. 	 */
name|error
operator|=
name|mps_transition_operational
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|attaching
condition|)
block|{
name|mps_printf
argument_list|(
name|sc
argument_list|,
literal|"%s failed to transition to operational "
literal|"with error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|mps_free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
else|else
block|{
name|panic
argument_list|(
literal|"%s failed to transition to operational with "
literal|"error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Finish the queue initialization. 	 * These are set here instead of in mps_init_queues() because the 	 * IOC resets these values during the state transition in 	 * mps_transition_operational().  The free index is set to 1 	 * because the corresponding index in the IOC is set to 0, and the 	 * IOC treats the queues as full if both are set to the same value. 	 * Hence the reason that the queue can't hold all of the possible 	 * replies. 	 */
name|sc
operator|->
name|replypostindex
operator|=
literal|0
expr_stmt|;
name|mps_regwrite
argument_list|(
name|sc
argument_list|,
name|MPI2_REPLY_FREE_HOST_INDEX_OFFSET
argument_list|,
name|sc
operator|->
name|replyfreeindex
argument_list|)
expr_stmt|;
name|mps_regwrite
argument_list|(
name|sc
argument_list|,
name|MPI2_REPLY_POST_HOST_INDEX_OFFSET
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Attach the subsystems so they can prepare their event masks. 	 */
comment|/* XXX Should be dynamic so that IM/IR and user modules can attach */
if|if
condition|(
name|attaching
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|error
operator|=
name|mps_attach_log
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
operator|(
name|error
operator|=
name|mps_attach_sas
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
operator|(
name|error
operator|=
name|mps_attach_user
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|mps_printf
argument_list|(
name|sc
argument_list|,
literal|"%s failed to attach all subsystems: "
literal|"error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|mps_free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|mps_pci_setup_interrupts
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|mps_printf
argument_list|(
name|sc
argument_list|,
literal|"%s failed to setup interrupts\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|mps_free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
comment|/* 	 * Set flag if this is a WD controller.  This shouldn't ever change, but 	 * reset it after a Diag Reset, just in case. 	 */
name|sc
operator|->
name|WD_available
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|pci_get_device
argument_list|(
name|sc
operator|->
name|mps_dev
argument_list|)
operator|==
name|MPI2_MFGPAGE_DEVID_SSS6200
condition|)
name|sc
operator|->
name|WD_available
operator|=
name|TRUE
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This is called if memory is being free (during detach for example) and when  * buffers need to be reallocated due to a Diag Reset.  */
end_comment

begin_function
specifier|static
name|void
name|mps_iocfacts_free
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|mps_command
modifier|*
name|cm
decl_stmt|;
name|int
name|i
decl_stmt|;
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_TRACE
argument_list|,
literal|"%s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|free_busaddr
operator|!=
literal|0
condition|)
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|queues_dmat
argument_list|,
name|sc
operator|->
name|queues_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|free_queue
operator|!=
name|NULL
condition|)
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|queues_dmat
argument_list|,
name|sc
operator|->
name|free_queue
argument_list|,
name|sc
operator|->
name|queues_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|queues_dmat
operator|!=
name|NULL
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|queues_dmat
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|chain_busaddr
operator|!=
literal|0
condition|)
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|chain_dmat
argument_list|,
name|sc
operator|->
name|chain_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|chain_frames
operator|!=
name|NULL
condition|)
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|chain_dmat
argument_list|,
name|sc
operator|->
name|chain_frames
argument_list|,
name|sc
operator|->
name|chain_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|chain_dmat
operator|!=
name|NULL
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|chain_dmat
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sense_busaddr
operator|!=
literal|0
condition|)
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sense_dmat
argument_list|,
name|sc
operator|->
name|sense_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sense_frames
operator|!=
name|NULL
condition|)
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|sense_dmat
argument_list|,
name|sc
operator|->
name|sense_frames
argument_list|,
name|sc
operator|->
name|sense_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sense_dmat
operator|!=
name|NULL
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|sense_dmat
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|reply_busaddr
operator|!=
literal|0
condition|)
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|reply_dmat
argument_list|,
name|sc
operator|->
name|reply_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|reply_frames
operator|!=
name|NULL
condition|)
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|reply_dmat
argument_list|,
name|sc
operator|->
name|reply_frames
argument_list|,
name|sc
operator|->
name|reply_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|reply_dmat
operator|!=
name|NULL
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|reply_dmat
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|req_busaddr
operator|!=
literal|0
condition|)
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|req_dmat
argument_list|,
name|sc
operator|->
name|req_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|req_frames
operator|!=
name|NULL
condition|)
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|req_dmat
argument_list|,
name|sc
operator|->
name|req_frames
argument_list|,
name|sc
operator|->
name|req_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|req_dmat
operator|!=
name|NULL
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|req_dmat
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|chains
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|sc
operator|->
name|chains
argument_list|,
name|M_MPT2
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|commands
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|sc
operator|->
name|num_reqs
condition|;
name|i
operator|++
control|)
block|{
name|cm
operator|=
operator|&
name|sc
operator|->
name|commands
index|[
name|i
index|]
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|buffer_dmat
argument_list|,
name|cm
operator|->
name|cm_dmamap
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|sc
operator|->
name|commands
argument_list|,
name|M_MPT2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|buffer_dmat
operator|!=
name|NULL
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|buffer_dmat
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*   * The terms diag reset and hard reset are used interchangeably in the MPI  * docs to mean resetting the controller chip.  In this code diag reset  * cleans everything up, and the hard reset function just sends the reset  * sequence to the chip.  This should probably be refactored so that every  * subsystem gets a reset notification of some sort, and can clean up  * appropriately.  */
end_comment

begin_function
name|int
name|mps_reinit
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|mpssas_softc
modifier|*
name|sassc
decl_stmt|;
name|sassc
operator|=
name|sc
operator|->
name|sassc
expr_stmt|;
name|MPS_FUNCTRACE
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sc
operator|->
name|mps_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mps_flags
operator|&
name|MPS_FLAGS_DIAGRESET
condition|)
block|{
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_INIT
argument_list|,
literal|"%s reset already in progress\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_INFO
argument_list|,
literal|"Reinitializing controller,\n"
argument_list|)
expr_stmt|;
comment|/* make sure the completion callbacks can recognize they're getting 	 * a NULL cm_reply due to a reset. 	 */
name|sc
operator|->
name|mps_flags
operator||=
name|MPS_FLAGS_DIAGRESET
expr_stmt|;
comment|/* 	 * Mask interrupts here. 	 */
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_INIT
argument_list|,
literal|"%s mask interrupts\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|mps_mask_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
name|mps_diag_reset
argument_list|(
name|sc
argument_list|,
name|CAN_SLEEP
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
comment|/* XXXSL No need to panic here */
name|panic
argument_list|(
literal|"%s hard reset failed with error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
comment|/* Restore the PCI state, including the MSI-X registers */
name|mps_pci_restore
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Give the I/O subsystem special priority to get itself prepared */
name|mpssas_handle_reinit
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Get IOC Facts and allocate all structures based on this information. 	 * The attach function will also call mps_iocfacts_allocate at startup. 	 * If relevant values have changed in IOC Facts, this function will free 	 * all of the memory based on IOC Facts and reallocate that memory. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|mps_iocfacts_allocate
argument_list|(
name|sc
argument_list|,
name|FALSE
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|panic
argument_list|(
literal|"%s IOC Facts based allocation failed with error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Mapping structures will be re-allocated after getting IOC Page8, so 	 * free these structures here. 	 */
name|mps_mapping_exit
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * The static page function currently read is IOC Page8.  Others can be 	 * added in future.  It's possible that the values in IOC Page8 have 	 * changed after a Diag Reset due to user modification, so always read 	 * these.  Interrupts are masked, so unmask them before getting config 	 * pages. 	 */
name|mps_unmask_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mps_flags
operator|&=
operator|~
name|MPS_FLAGS_DIAGRESET
expr_stmt|;
name|mps_base_static_config_pages
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Some mapping info is based in IOC Page8 data, so re-initialize the 	 * mapping tables. 	 */
name|mps_mapping_initialize
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Restart will reload the event masks clobbered by the reset, and 	 * then enable the port. 	 */
name|mps_reregister_events
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* the end of discovery will release the simq, so we're done. */
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_INFO
argument_list|,
literal|"%s finished sc %p post %u free %u\n"
argument_list|,
name|__func__
argument_list|,
name|sc
argument_list|,
name|sc
operator|->
name|replypostindex
argument_list|,
name|sc
operator|->
name|replyfreeindex
argument_list|)
expr_stmt|;
name|mpssas_release_simq_reinit
argument_list|(
name|sassc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Wait for the chip to ACK a word that we've put into its FIFO   * Wait for<timeout> seconds. In single loop wait for busy loop  * for 500 microseconds.  * Total is [ 0.5 * (2000 *<timeout>) ] in miliseconds.  * */
end_comment

begin_function
specifier|static
name|int
name|mps_wait_db_ack
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|int
name|timeout
parameter_list|,
name|int
name|sleep_flag
parameter_list|)
block|{
name|u32
name|cntdn
decl_stmt|,
name|count
decl_stmt|;
name|u32
name|int_status
decl_stmt|;
name|u32
name|doorbell
decl_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|cntdn
operator|=
operator|(
name|sleep_flag
operator|==
name|CAN_SLEEP
operator|)
condition|?
literal|1000
operator|*
name|timeout
else|:
literal|2000
operator|*
name|timeout
expr_stmt|;
do|do
block|{
name|int_status
operator|=
name|mps_regread
argument_list|(
name|sc
argument_list|,
name|MPI2_HOST_INTERRUPT_STATUS_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|int_status
operator|&
name|MPI2_HIS_SYS2IOC_DB_STATUS
operator|)
condition|)
block|{
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_INIT
argument_list|,
literal|"%s: successfull count(%d), timeout(%d)\n"
argument_list|,
name|__func__
argument_list|,
name|count
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|int_status
operator|&
name|MPI2_HIS_IOC2SYS_DB_STATUS
condition|)
block|{
name|doorbell
operator|=
name|mps_regread
argument_list|(
name|sc
argument_list|,
name|MPI2_DOORBELL_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|doorbell
operator|&
name|MPI2_IOC_STATE_MASK
operator|)
operator|==
name|MPI2_IOC_STATE_FAULT
condition|)
block|{
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_FAULT
argument_list|,
literal|"fault_state(0x%04x)!\n"
argument_list|,
name|doorbell
argument_list|)
expr_stmt|;
return|return
operator|(
name|EFAULT
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|int_status
operator|==
literal|0xFFFFFFFF
condition|)
goto|goto
name|out
goto|;
comment|/* If it can sleep, sleep for 1 milisecond, else busy loop for  		* 0.5 milisecond */
if|if
condition|(
name|mtx_owned
argument_list|(
operator|&
name|sc
operator|->
name|mps_mtx
argument_list|)
operator|&&
name|sleep_flag
operator|==
name|CAN_SLEEP
condition|)
name|msleep
argument_list|(
operator|&
name|sc
operator|->
name|msleep_fake_chan
argument_list|,
operator|&
name|sc
operator|->
name|mps_mtx
argument_list|,
literal|0
argument_list|,
literal|"mpsdba"
argument_list|,
name|hz
operator|/
literal|1000
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sleep_flag
operator|==
name|CAN_SLEEP
condition|)
name|pause
argument_list|(
literal|"mpsdba"
argument_list|,
name|hz
operator|/
literal|1000
argument_list|)
expr_stmt|;
else|else
name|DELAY
argument_list|(
literal|500
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|cntdn
condition|)
do|;
name|out
label|:
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_FAULT
argument_list|,
literal|"%s: failed due to timeout count(%d), "
literal|"int_status(%x)!\n"
argument_list|,
name|__func__
argument_list|,
name|count
argument_list|,
name|int_status
argument_list|)
expr_stmt|;
return|return
operator|(
name|ETIMEDOUT
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Wait for the chip to signal that the next word in its FIFO can be fetched */
end_comment

begin_function
specifier|static
name|int
name|mps_wait_db_int
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|retry
decl_stmt|;
for|for
control|(
name|retry
operator|=
literal|0
init|;
name|retry
operator|<
name|MPS_DB_MAX_WAIT
condition|;
name|retry
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|mps_regread
argument_list|(
name|sc
argument_list|,
name|MPI2_HOST_INTERRUPT_STATUS_OFFSET
argument_list|)
operator|&
name|MPI2_HIS_IOC2SYS_DB_STATUS
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|DELAY
argument_list|(
literal|2000
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ETIMEDOUT
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Step through the synchronous command state machine, i.e. "Doorbell mode" */
end_comment

begin_function
specifier|static
name|int
name|mps_request_sync
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|req
parameter_list|,
name|MPI2_DEFAULT_REPLY
modifier|*
name|reply
parameter_list|,
name|int
name|req_sz
parameter_list|,
name|int
name|reply_sz
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
name|uint32_t
modifier|*
name|data32
decl_stmt|;
name|uint16_t
modifier|*
name|data16
decl_stmt|;
name|int
name|i
decl_stmt|,
name|count
decl_stmt|,
name|ioc_sz
decl_stmt|,
name|residual
decl_stmt|;
name|int
name|sleep_flags
init|=
name|CAN_SLEEP
decl_stmt|;
if|if
condition|(
name|curthread
operator|->
name|td_no_sleeping
operator|!=
literal|0
condition|)
name|sleep_flags
operator|=
name|NO_SLEEP
expr_stmt|;
comment|/* Step 1 */
name|mps_regwrite
argument_list|(
name|sc
argument_list|,
name|MPI2_HOST_INTERRUPT_STATUS_OFFSET
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
comment|/* Step 2 */
if|if
condition|(
name|mps_regread
argument_list|(
name|sc
argument_list|,
name|MPI2_DOORBELL_OFFSET
argument_list|)
operator|&
name|MPI2_DOORBELL_USED
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
comment|/* Step 3 	 * Announce that a message is coming through the doorbell.  Messages 	 * are pushed at 32bit words, so round up if needed. 	 */
name|count
operator|=
operator|(
name|req_sz
operator|+
literal|3
operator|)
operator|/
literal|4
expr_stmt|;
name|mps_regwrite
argument_list|(
name|sc
argument_list|,
name|MPI2_DOORBELL_OFFSET
argument_list|,
operator|(
name|MPI2_FUNCTION_HANDSHAKE
operator|<<
name|MPI2_DOORBELL_FUNCTION_SHIFT
operator|)
operator||
operator|(
name|count
operator|<<
name|MPI2_DOORBELL_ADD_DWORDS_SHIFT
operator|)
argument_list|)
expr_stmt|;
comment|/* Step 4 */
if|if
condition|(
name|mps_wait_db_int
argument_list|(
name|sc
argument_list|)
operator|||
operator|(
name|mps_regread
argument_list|(
name|sc
argument_list|,
name|MPI2_DOORBELL_OFFSET
argument_list|)
operator|&
name|MPI2_DOORBELL_USED
operator|)
operator|==
literal|0
condition|)
block|{
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_FAULT
argument_list|,
literal|"Doorbell failed to activate\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|mps_regwrite
argument_list|(
name|sc
argument_list|,
name|MPI2_HOST_INTERRUPT_STATUS_OFFSET
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mps_wait_db_ack
argument_list|(
name|sc
argument_list|,
literal|5
argument_list|,
name|sleep_flags
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_FAULT
argument_list|,
literal|"Doorbell handshake failed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Step 5 */
comment|/* Clock out the message data synchronously in 32-bit dwords*/
name|data32
operator|=
operator|(
name|uint32_t
operator|*
operator|)
name|req
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|mps_regwrite
argument_list|(
name|sc
argument_list|,
name|MPI2_DOORBELL_OFFSET
argument_list|,
name|htole32
argument_list|(
name|data32
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mps_wait_db_ack
argument_list|(
name|sc
argument_list|,
literal|5
argument_list|,
name|sleep_flags
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_FAULT
argument_list|,
literal|"Timeout while writing doorbell\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
block|}
comment|/* Step 6 */
comment|/* Clock in the reply in 16-bit words.  The total length of the 	 * message is always in the 4th byte, so clock out the first 2 words 	 * manually, then loop the rest. 	 */
name|data16
operator|=
operator|(
name|uint16_t
operator|*
operator|)
name|reply
expr_stmt|;
if|if
condition|(
name|mps_wait_db_int
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_FAULT
argument_list|,
literal|"Timeout reading doorbell 0\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|data16
index|[
literal|0
index|]
operator|=
name|mps_regread
argument_list|(
name|sc
argument_list|,
name|MPI2_DOORBELL_OFFSET
argument_list|)
operator|&
name|MPI2_DOORBELL_DATA_MASK
expr_stmt|;
name|mps_regwrite
argument_list|(
name|sc
argument_list|,
name|MPI2_HOST_INTERRUPT_STATUS_OFFSET
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mps_wait_db_int
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_FAULT
argument_list|,
literal|"Timeout reading doorbell 1\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|data16
index|[
literal|1
index|]
operator|=
name|mps_regread
argument_list|(
name|sc
argument_list|,
name|MPI2_DOORBELL_OFFSET
argument_list|)
operator|&
name|MPI2_DOORBELL_DATA_MASK
expr_stmt|;
name|mps_regwrite
argument_list|(
name|sc
argument_list|,
name|MPI2_HOST_INTERRUPT_STATUS_OFFSET
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
comment|/* Number of 32bit words in the message */
name|ioc_sz
operator|=
name|reply
operator|->
name|MsgLength
expr_stmt|;
comment|/* 	 * Figure out how many 16bit words to clock in without overrunning. 	 * The precision loss with dividing reply_sz can safely be 	 * ignored because the messages can only be multiples of 32bits. 	 */
name|residual
operator|=
literal|0
expr_stmt|;
name|count
operator|=
name|MIN
argument_list|(
operator|(
name|reply_sz
operator|/
literal|4
operator|)
argument_list|,
name|ioc_sz
argument_list|)
operator|*
literal|2
expr_stmt|;
if|if
condition|(
name|count
operator|<
name|ioc_sz
operator|*
literal|2
condition|)
block|{
name|residual
operator|=
name|ioc_sz
operator|*
literal|2
operator|-
name|count
expr_stmt|;
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_ERROR
argument_list|,
literal|"Driver error, throwing away %d "
literal|"residual message words\n"
argument_list|,
name|residual
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|mps_wait_db_int
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_FAULT
argument_list|,
literal|"Timeout reading doorbell %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|data16
index|[
name|i
index|]
operator|=
name|mps_regread
argument_list|(
name|sc
argument_list|,
name|MPI2_DOORBELL_OFFSET
argument_list|)
operator|&
name|MPI2_DOORBELL_DATA_MASK
expr_stmt|;
name|mps_regwrite
argument_list|(
name|sc
argument_list|,
name|MPI2_HOST_INTERRUPT_STATUS_OFFSET
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Pull out residual words that won't fit into the provided buffer. 	 * This keeps the chip from hanging due to a driver programming 	 * error. 	 */
while|while
condition|(
name|residual
operator|--
condition|)
block|{
if|if
condition|(
name|mps_wait_db_int
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_FAULT
argument_list|,
literal|"Timeout reading doorbell\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|mps_regread
argument_list|(
name|sc
argument_list|,
name|MPI2_DOORBELL_OFFSET
argument_list|)
expr_stmt|;
name|mps_regwrite
argument_list|(
name|sc
argument_list|,
name|MPI2_HOST_INTERRUPT_STATUS_OFFSET
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
block|}
comment|/* Step 7 */
if|if
condition|(
name|mps_wait_db_int
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_FAULT
argument_list|,
literal|"Timeout waiting to exit doorbell\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
name|mps_regread
argument_list|(
name|sc
argument_list|,
name|MPI2_DOORBELL_OFFSET
argument_list|)
operator|&
name|MPI2_DOORBELL_USED
condition|)
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_FAULT
argument_list|,
literal|"Warning, doorbell still active\n"
argument_list|)
expr_stmt|;
name|mps_regwrite
argument_list|(
name|sc
argument_list|,
name|MPI2_HOST_INTERRUPT_STATUS_OFFSET
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mps_enqueue_request
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mps_command
modifier|*
name|cm
parameter_list|)
block|{
name|reply_descriptor
name|rd
decl_stmt|;
name|MPS_FUNCTRACE
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_TRACE
argument_list|,
literal|"SMID %u cm %p ccb %p\n"
argument_list|,
name|cm
operator|->
name|cm_desc
operator|.
name|Default
operator|.
name|SMID
argument_list|,
name|cm
argument_list|,
name|cm
operator|->
name|cm_ccb
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mps_flags
operator|&
name|MPS_FLAGS_ATTACH_DONE
operator|&&
operator|!
operator|(
name|sc
operator|->
name|mps_flags
operator|&
name|MPS_FLAGS_SHUTDOWN
operator|)
condition|)
name|mtx_assert
argument_list|(
operator|&
name|sc
operator|->
name|mps_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|sc
operator|->
name|io_cmds_active
operator|>
name|sc
operator|->
name|io_cmds_highwater
condition|)
name|sc
operator|->
name|io_cmds_highwater
operator|++
expr_stmt|;
name|rd
operator|.
name|u
operator|.
name|low
operator|=
name|cm
operator|->
name|cm_desc
operator|.
name|Words
operator|.
name|Low
expr_stmt|;
name|rd
operator|.
name|u
operator|.
name|high
operator|=
name|cm
operator|->
name|cm_desc
operator|.
name|Words
operator|.
name|High
expr_stmt|;
name|rd
operator|.
name|word
operator|=
name|htole64
argument_list|(
name|rd
operator|.
name|word
argument_list|)
expr_stmt|;
comment|/* TODO-We may need to make below regwrite atomic */
name|mps_regwrite
argument_list|(
name|sc
argument_list|,
name|MPI2_REQUEST_DESCRIPTOR_POST_LOW_OFFSET
argument_list|,
name|rd
operator|.
name|u
operator|.
name|low
argument_list|)
expr_stmt|;
name|mps_regwrite
argument_list|(
name|sc
argument_list|,
name|MPI2_REQUEST_DESCRIPTOR_POST_HIGH_OFFSET
argument_list|,
name|rd
operator|.
name|u
operator|.
name|high
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Just the FACTS, ma'am.  */
end_comment

begin_function
specifier|static
name|int
name|mps_get_iocfacts
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|MPI2_IOC_FACTS_REPLY
modifier|*
name|facts
parameter_list|)
block|{
name|MPI2_DEFAULT_REPLY
modifier|*
name|reply
decl_stmt|;
name|MPI2_IOC_FACTS_REQUEST
name|request
decl_stmt|;
name|int
name|error
decl_stmt|,
name|req_sz
decl_stmt|,
name|reply_sz
decl_stmt|;
name|MPS_FUNCTRACE
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|req_sz
operator|=
sizeof|sizeof
argument_list|(
name|MPI2_IOC_FACTS_REQUEST
argument_list|)
expr_stmt|;
name|reply_sz
operator|=
sizeof|sizeof
argument_list|(
name|MPI2_IOC_FACTS_REPLY
argument_list|)
expr_stmt|;
name|reply
operator|=
operator|(
name|MPI2_DEFAULT_REPLY
operator|*
operator|)
name|facts
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|request
argument_list|,
name|req_sz
argument_list|)
expr_stmt|;
name|request
operator|.
name|Function
operator|=
name|MPI2_FUNCTION_IOC_FACTS
expr_stmt|;
name|error
operator|=
name|mps_request_sync
argument_list|(
name|sc
argument_list|,
operator|&
name|request
argument_list|,
name|reply
argument_list|,
name|req_sz
argument_list|,
name|reply_sz
argument_list|,
literal|5
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mps_send_iocinit
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|)
block|{
name|MPI2_IOC_INIT_REQUEST
name|init
decl_stmt|;
name|MPI2_DEFAULT_REPLY
name|reply
decl_stmt|;
name|int
name|req_sz
decl_stmt|,
name|reply_sz
decl_stmt|,
name|error
decl_stmt|;
name|struct
name|timeval
name|now
decl_stmt|;
name|uint64_t
name|time_in_msec
decl_stmt|;
name|MPS_FUNCTRACE
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|req_sz
operator|=
sizeof|sizeof
argument_list|(
name|MPI2_IOC_INIT_REQUEST
argument_list|)
expr_stmt|;
name|reply_sz
operator|=
sizeof|sizeof
argument_list|(
name|MPI2_IOC_INIT_REPLY
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|init
argument_list|,
name|req_sz
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|reply
argument_list|,
name|reply_sz
argument_list|)
expr_stmt|;
comment|/* 	 * Fill in the init block.  Note that most addresses are 	 * deliberately in the lower 32bits of memory.  This is a micro- 	 * optimzation for PCI/PCIX, though it's not clear if it helps PCIe. 	 */
name|init
operator|.
name|Function
operator|=
name|MPI2_FUNCTION_IOC_INIT
expr_stmt|;
name|init
operator|.
name|WhoInit
operator|=
name|MPI2_WHOINIT_HOST_DRIVER
expr_stmt|;
name|init
operator|.
name|MsgVersion
operator|=
name|htole16
argument_list|(
name|MPI2_VERSION
argument_list|)
expr_stmt|;
name|init
operator|.
name|HeaderVersion
operator|=
name|htole16
argument_list|(
name|MPI2_HEADER_VERSION
argument_list|)
expr_stmt|;
name|init
operator|.
name|SystemRequestFrameSize
operator|=
name|htole16
argument_list|(
name|sc
operator|->
name|facts
operator|->
name|IOCRequestFrameSize
argument_list|)
expr_stmt|;
name|init
operator|.
name|ReplyDescriptorPostQueueDepth
operator|=
name|htole16
argument_list|(
name|sc
operator|->
name|pqdepth
argument_list|)
expr_stmt|;
name|init
operator|.
name|ReplyFreeQueueDepth
operator|=
name|htole16
argument_list|(
name|sc
operator|->
name|fqdepth
argument_list|)
expr_stmt|;
name|init
operator|.
name|SenseBufferAddressHigh
operator|=
literal|0
expr_stmt|;
name|init
operator|.
name|SystemReplyAddressHigh
operator|=
literal|0
expr_stmt|;
name|init
operator|.
name|SystemRequestFrameBaseAddress
operator|.
name|High
operator|=
literal|0
expr_stmt|;
name|init
operator|.
name|SystemRequestFrameBaseAddress
operator|.
name|Low
operator|=
name|htole32
argument_list|(
operator|(
name|uint32_t
operator|)
name|sc
operator|->
name|req_busaddr
argument_list|)
expr_stmt|;
name|init
operator|.
name|ReplyDescriptorPostQueueAddress
operator|.
name|High
operator|=
literal|0
expr_stmt|;
name|init
operator|.
name|ReplyDescriptorPostQueueAddress
operator|.
name|Low
operator|=
name|htole32
argument_list|(
operator|(
name|uint32_t
operator|)
name|sc
operator|->
name|post_busaddr
argument_list|)
expr_stmt|;
name|init
operator|.
name|ReplyFreeQueueAddress
operator|.
name|High
operator|=
literal|0
expr_stmt|;
name|init
operator|.
name|ReplyFreeQueueAddress
operator|.
name|Low
operator|=
name|htole32
argument_list|(
operator|(
name|uint32_t
operator|)
name|sc
operator|->
name|free_busaddr
argument_list|)
expr_stmt|;
name|getmicrotime
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|time_in_msec
operator|=
operator|(
name|now
operator|.
name|tv_sec
operator|*
literal|1000
operator|+
name|now
operator|.
name|tv_usec
operator|/
literal|1000
operator|)
expr_stmt|;
name|init
operator|.
name|TimeStamp
operator|.
name|High
operator|=
name|htole32
argument_list|(
operator|(
name|time_in_msec
operator|>>
literal|32
operator|)
operator|&
literal|0xFFFFFFFF
argument_list|)
expr_stmt|;
name|init
operator|.
name|TimeStamp
operator|.
name|Low
operator|=
name|htole32
argument_list|(
name|time_in_msec
operator|&
literal|0xFFFFFFFF
argument_list|)
expr_stmt|;
name|error
operator|=
name|mps_request_sync
argument_list|(
name|sc
argument_list|,
operator|&
name|init
argument_list|,
operator|&
name|reply
argument_list|,
name|req_sz
argument_list|,
name|reply_sz
argument_list|,
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|reply
operator|.
name|IOCStatus
operator|&
name|MPI2_IOCSTATUS_MASK
operator|)
operator|!=
name|MPI2_IOCSTATUS_SUCCESS
condition|)
name|error
operator|=
name|ENXIO
expr_stmt|;
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_INIT
argument_list|,
literal|"IOCInit status= 0x%x\n"
argument_list|,
name|reply
operator|.
name|IOCStatus
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|void
name|mps_memaddr_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nsegs
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|bus_addr_t
modifier|*
name|addr
decl_stmt|;
name|addr
operator|=
name|arg
expr_stmt|;
operator|*
name|addr
operator|=
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|mps_alloc_queues
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|)
block|{
name|bus_addr_t
name|queues_busaddr
decl_stmt|;
name|uint8_t
modifier|*
name|queues
decl_stmt|;
name|int
name|qsize
decl_stmt|,
name|fqsize
decl_stmt|,
name|pqsize
decl_stmt|;
comment|/* 	 * The reply free queue contains 4 byte entries in multiples of 16 and 	 * aligned on a 16 byte boundary. There must always be an unused entry. 	 * This queue supplies fresh reply frames for the firmware to use. 	 * 	 * The reply descriptor post queue contains 8 byte entries in 	 * multiples of 16 and aligned on a 16 byte boundary.  This queue 	 * contains filled-in reply frames sent from the firmware to the host. 	 * 	 * These two queues are allocated together for simplicity. 	 */
name|sc
operator|->
name|fqdepth
operator|=
name|roundup2
argument_list|(
operator|(
name|sc
operator|->
name|num_replies
operator|+
literal|1
operator|)
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|sc
operator|->
name|pqdepth
operator|=
name|roundup2
argument_list|(
operator|(
name|sc
operator|->
name|num_replies
operator|+
literal|1
operator|)
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|fqsize
operator|=
name|sc
operator|->
name|fqdepth
operator|*
literal|4
expr_stmt|;
name|pqsize
operator|=
name|sc
operator|->
name|pqdepth
operator|*
literal|8
expr_stmt|;
name|qsize
operator|=
name|fqsize
operator|+
name|pqsize
expr_stmt|;
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|mps_parent_dmat
argument_list|,
comment|/* parent */
literal|16
argument_list|,
literal|0
argument_list|,
comment|/* algnmnt, boundary */
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|qsize
argument_list|,
comment|/* maxsize */
literal|1
argument_list|,
comment|/* nsegments */
name|qsize
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* lockfunc, lockarg */
operator|&
name|sc
operator|->
name|queues_dmat
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mps_dev
argument_list|,
literal|"Cannot allocate queues DMA tag\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|sc
operator|->
name|queues_dmat
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|queues
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|sc
operator|->
name|queues_map
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mps_dev
argument_list|,
literal|"Cannot allocate queues memory\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|bzero
argument_list|(
name|queues
argument_list|,
name|qsize
argument_list|)
expr_stmt|;
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|queues_dmat
argument_list|,
name|sc
operator|->
name|queues_map
argument_list|,
name|queues
argument_list|,
name|qsize
argument_list|,
name|mps_memaddr_cb
argument_list|,
operator|&
name|queues_busaddr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|free_queue
operator|=
operator|(
name|uint32_t
operator|*
operator|)
name|queues
expr_stmt|;
name|sc
operator|->
name|free_busaddr
operator|=
name|queues_busaddr
expr_stmt|;
name|sc
operator|->
name|post_queue
operator|=
operator|(
name|MPI2_REPLY_DESCRIPTORS_UNION
operator|*
operator|)
operator|(
name|queues
operator|+
name|fqsize
operator|)
expr_stmt|;
name|sc
operator|->
name|post_busaddr
operator|=
name|queues_busaddr
operator|+
name|fqsize
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mps_alloc_replies
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|rsize
decl_stmt|,
name|num_replies
decl_stmt|;
comment|/* 	 * sc->num_replies should be one less than sc->fqdepth.  We need to 	 * allocate space for sc->fqdepth replies, but only sc->num_replies 	 * replies can be used at once. 	 */
name|num_replies
operator|=
name|max
argument_list|(
name|sc
operator|->
name|fqdepth
argument_list|,
name|sc
operator|->
name|num_replies
argument_list|)
expr_stmt|;
name|rsize
operator|=
name|sc
operator|->
name|facts
operator|->
name|ReplyFrameSize
operator|*
name|num_replies
operator|*
literal|4
expr_stmt|;
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|mps_parent_dmat
argument_list|,
comment|/* parent */
literal|4
argument_list|,
literal|0
argument_list|,
comment|/* algnmnt, boundary */
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|rsize
argument_list|,
comment|/* maxsize */
literal|1
argument_list|,
comment|/* nsegments */
name|rsize
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* lockfunc, lockarg */
operator|&
name|sc
operator|->
name|reply_dmat
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mps_dev
argument_list|,
literal|"Cannot allocate replies DMA tag\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|sc
operator|->
name|reply_dmat
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|sc
operator|->
name|reply_frames
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|sc
operator|->
name|reply_map
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mps_dev
argument_list|,
literal|"Cannot allocate replies memory\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|bzero
argument_list|(
name|sc
operator|->
name|reply_frames
argument_list|,
name|rsize
argument_list|)
expr_stmt|;
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|reply_dmat
argument_list|,
name|sc
operator|->
name|reply_map
argument_list|,
name|sc
operator|->
name|reply_frames
argument_list|,
name|rsize
argument_list|,
name|mps_memaddr_cb
argument_list|,
operator|&
name|sc
operator|->
name|reply_busaddr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mps_alloc_requests
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|mps_command
modifier|*
name|cm
decl_stmt|;
name|struct
name|mps_chain
modifier|*
name|chain
decl_stmt|;
name|int
name|i
decl_stmt|,
name|rsize
decl_stmt|,
name|nsegs
decl_stmt|;
name|rsize
operator|=
name|sc
operator|->
name|facts
operator|->
name|IOCRequestFrameSize
operator|*
name|sc
operator|->
name|num_reqs
operator|*
literal|4
expr_stmt|;
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|mps_parent_dmat
argument_list|,
comment|/* parent */
literal|16
argument_list|,
literal|0
argument_list|,
comment|/* algnmnt, boundary */
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|rsize
argument_list|,
comment|/* maxsize */
literal|1
argument_list|,
comment|/* nsegments */
name|rsize
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* lockfunc, lockarg */
operator|&
name|sc
operator|->
name|req_dmat
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mps_dev
argument_list|,
literal|"Cannot allocate request DMA tag\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|sc
operator|->
name|req_dmat
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|sc
operator|->
name|req_frames
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|sc
operator|->
name|req_map
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mps_dev
argument_list|,
literal|"Cannot allocate request memory\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|bzero
argument_list|(
name|sc
operator|->
name|req_frames
argument_list|,
name|rsize
argument_list|)
expr_stmt|;
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|req_dmat
argument_list|,
name|sc
operator|->
name|req_map
argument_list|,
name|sc
operator|->
name|req_frames
argument_list|,
name|rsize
argument_list|,
name|mps_memaddr_cb
argument_list|,
operator|&
name|sc
operator|->
name|req_busaddr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rsize
operator|=
name|sc
operator|->
name|facts
operator|->
name|IOCRequestFrameSize
operator|*
name|sc
operator|->
name|max_chains
operator|*
literal|4
expr_stmt|;
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|mps_parent_dmat
argument_list|,
comment|/* parent */
literal|16
argument_list|,
literal|0
argument_list|,
comment|/* algnmnt, boundary */
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|rsize
argument_list|,
comment|/* maxsize */
literal|1
argument_list|,
comment|/* nsegments */
name|rsize
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* lockfunc, lockarg */
operator|&
name|sc
operator|->
name|chain_dmat
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mps_dev
argument_list|,
literal|"Cannot allocate chain DMA tag\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|sc
operator|->
name|chain_dmat
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|sc
operator|->
name|chain_frames
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|sc
operator|->
name|chain_map
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mps_dev
argument_list|,
literal|"Cannot allocate chain memory\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|bzero
argument_list|(
name|sc
operator|->
name|chain_frames
argument_list|,
name|rsize
argument_list|)
expr_stmt|;
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|chain_dmat
argument_list|,
name|sc
operator|->
name|chain_map
argument_list|,
name|sc
operator|->
name|chain_frames
argument_list|,
name|rsize
argument_list|,
name|mps_memaddr_cb
argument_list|,
operator|&
name|sc
operator|->
name|chain_busaddr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rsize
operator|=
name|MPS_SENSE_LEN
operator|*
name|sc
operator|->
name|num_reqs
expr_stmt|;
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|mps_parent_dmat
argument_list|,
comment|/* parent */
literal|1
argument_list|,
literal|0
argument_list|,
comment|/* algnmnt, boundary */
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|rsize
argument_list|,
comment|/* maxsize */
literal|1
argument_list|,
comment|/* nsegments */
name|rsize
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* lockfunc, lockarg */
operator|&
name|sc
operator|->
name|sense_dmat
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mps_dev
argument_list|,
literal|"Cannot allocate sense DMA tag\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|sc
operator|->
name|sense_dmat
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|sc
operator|->
name|sense_frames
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|sc
operator|->
name|sense_map
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mps_dev
argument_list|,
literal|"Cannot allocate sense memory\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|bzero
argument_list|(
name|sc
operator|->
name|sense_frames
argument_list|,
name|rsize
argument_list|)
expr_stmt|;
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|sense_dmat
argument_list|,
name|sc
operator|->
name|sense_map
argument_list|,
name|sc
operator|->
name|sense_frames
argument_list|,
name|rsize
argument_list|,
name|mps_memaddr_cb
argument_list|,
operator|&
name|sc
operator|->
name|sense_busaddr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|chains
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|mps_chain
argument_list|)
operator|*
name|sc
operator|->
name|max_chains
argument_list|,
name|M_MPT2
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|chains
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mps_dev
argument_list|,
literal|"Cannot allocate chains memory %s %d\n"
argument_list|,
name|__func__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|max_chains
condition|;
name|i
operator|++
control|)
block|{
name|chain
operator|=
operator|&
name|sc
operator|->
name|chains
index|[
name|i
index|]
expr_stmt|;
name|chain
operator|->
name|chain
operator|=
operator|(
name|MPI2_SGE_IO_UNION
operator|*
operator|)
operator|(
name|sc
operator|->
name|chain_frames
operator|+
name|i
operator|*
name|sc
operator|->
name|facts
operator|->
name|IOCRequestFrameSize
operator|*
literal|4
operator|)
expr_stmt|;
name|chain
operator|->
name|chain_busaddr
operator|=
name|sc
operator|->
name|chain_busaddr
operator|+
name|i
operator|*
name|sc
operator|->
name|facts
operator|->
name|IOCRequestFrameSize
operator|*
literal|4
expr_stmt|;
name|mps_free_chain
argument_list|(
name|sc
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|sc
operator|->
name|chain_free_lowwater
operator|++
expr_stmt|;
block|}
comment|/* XXX Need to pick a more precise value */
name|nsegs
operator|=
operator|(
name|MAXPHYS
operator|/
name|PAGE_SIZE
operator|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|mps_parent_dmat
argument_list|,
comment|/* parent */
literal|1
argument_list|,
literal|0
argument_list|,
comment|/* algnmnt, boundary */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
comment|/* maxsize */
name|nsegs
argument_list|,
comment|/* nsegments */
name|BUS_SPACE_MAXSIZE_24BIT
argument_list|,
comment|/* maxsegsize */
name|BUS_DMA_ALLOCNOW
argument_list|,
comment|/* flags */
name|busdma_lock_mutex
argument_list|,
comment|/* lockfunc */
operator|&
name|sc
operator|->
name|mps_mtx
argument_list|,
comment|/* lockarg */
operator|&
name|sc
operator|->
name|buffer_dmat
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mps_dev
argument_list|,
literal|"Cannot allocate buffer DMA tag\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/* 	 * SMID 0 cannot be used as a free command per the firmware spec. 	 * Just drop that command instead of risking accounting bugs. 	 */
name|sc
operator|->
name|commands
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|mps_command
argument_list|)
operator|*
name|sc
operator|->
name|num_reqs
argument_list|,
name|M_MPT2
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|commands
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mps_dev
argument_list|,
literal|"Cannot allocate memory %s %d\n"
argument_list|,
name|__func__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|sc
operator|->
name|num_reqs
condition|;
name|i
operator|++
control|)
block|{
name|cm
operator|=
operator|&
name|sc
operator|->
name|commands
index|[
name|i
index|]
expr_stmt|;
name|cm
operator|->
name|cm_req
operator|=
name|sc
operator|->
name|req_frames
operator|+
name|i
operator|*
name|sc
operator|->
name|facts
operator|->
name|IOCRequestFrameSize
operator|*
literal|4
expr_stmt|;
name|cm
operator|->
name|cm_req_busaddr
operator|=
name|sc
operator|->
name|req_busaddr
operator|+
name|i
operator|*
name|sc
operator|->
name|facts
operator|->
name|IOCRequestFrameSize
operator|*
literal|4
expr_stmt|;
name|cm
operator|->
name|cm_sense
operator|=
operator|&
name|sc
operator|->
name|sense_frames
index|[
name|i
index|]
expr_stmt|;
name|cm
operator|->
name|cm_sense_busaddr
operator|=
name|sc
operator|->
name|sense_busaddr
operator|+
name|i
operator|*
name|MPS_SENSE_LEN
expr_stmt|;
name|cm
operator|->
name|cm_desc
operator|.
name|Default
operator|.
name|SMID
operator|=
name|i
expr_stmt|;
name|cm
operator|->
name|cm_sc
operator|=
name|sc
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|cm
operator|->
name|cm_chain_list
argument_list|)
expr_stmt|;
name|callout_init_mtx
argument_list|(
operator|&
name|cm
operator|->
name|cm_callout
argument_list|,
operator|&
name|sc
operator|->
name|mps_mtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* XXX Is a failure here a critical problem? */
if|if
condition|(
name|bus_dmamap_create
argument_list|(
name|sc
operator|->
name|buffer_dmat
argument_list|,
literal|0
argument_list|,
operator|&
name|cm
operator|->
name|cm_dmamap
argument_list|)
operator|==
literal|0
condition|)
if|if
condition|(
name|i
operator|<=
name|sc
operator|->
name|facts
operator|->
name|HighPriorityCredit
condition|)
name|mps_free_high_priority_command
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
else|else
name|mps_free_command
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
else|else
block|{
name|panic
argument_list|(
literal|"failed to allocate command %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|sc
operator|->
name|num_reqs
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mps_init_queues
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|memset
argument_list|(
operator|(
name|uint8_t
operator|*
operator|)
name|sc
operator|->
name|post_queue
argument_list|,
literal|0xff
argument_list|,
name|sc
operator|->
name|pqdepth
operator|*
literal|8
argument_list|)
expr_stmt|;
comment|/* 	 * According to the spec, we need to use one less reply than we 	 * have space for on the queue.  So sc->num_replies (the number we 	 * use) should be less than sc->fqdepth (allocated size). 	 */
if|if
condition|(
name|sc
operator|->
name|num_replies
operator|>=
name|sc
operator|->
name|fqdepth
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 	 * Initialize all of the free queue entries. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|fqdepth
condition|;
name|i
operator|++
control|)
name|sc
operator|->
name|free_queue
index|[
name|i
index|]
operator|=
name|sc
operator|->
name|reply_busaddr
operator|+
operator|(
name|i
operator|*
name|sc
operator|->
name|facts
operator|->
name|ReplyFrameSize
operator|*
literal|4
operator|)
expr_stmt|;
name|sc
operator|->
name|replyfreeindex
operator|=
name|sc
operator|->
name|num_replies
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Get the driver parameter tunables.  Lowest priority are the driver defaults.  * Next are the global settings, if they exist.  Highest are the per-unit  * settings, if they exist.  */
end_comment

begin_function
specifier|static
name|void
name|mps_get_tunables
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|)
block|{
name|char
name|tmpstr
index|[
literal|80
index|]
decl_stmt|;
comment|/* XXX default to some debugging for now */
name|sc
operator|->
name|mps_debug
operator|=
name|MPS_INFO
operator||
name|MPS_FAULT
expr_stmt|;
name|sc
operator|->
name|disable_msix
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|disable_msi
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|max_chains
operator|=
name|MPS_CHAIN_FRAMES
expr_stmt|;
name|sc
operator|->
name|max_io_pages
operator|=
name|MPS_MAXIO_PAGES
expr_stmt|;
name|sc
operator|->
name|enable_ssu
operator|=
name|MPS_SSU_ENABLE_SSD_DISABLE_HDD
expr_stmt|;
name|sc
operator|->
name|spinup_wait_time
operator|=
name|DEFAULT_SPINUP_WAIT
expr_stmt|;
name|sc
operator|->
name|use_phynum
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Grab the global variables. 	 */
name|TUNABLE_INT_FETCH
argument_list|(
literal|"hw.mps.debug_level"
argument_list|,
operator|&
name|sc
operator|->
name|mps_debug
argument_list|)
expr_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
literal|"hw.mps.disable_msix"
argument_list|,
operator|&
name|sc
operator|->
name|disable_msix
argument_list|)
expr_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
literal|"hw.mps.disable_msi"
argument_list|,
operator|&
name|sc
operator|->
name|disable_msi
argument_list|)
expr_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
literal|"hw.mps.max_chains"
argument_list|,
operator|&
name|sc
operator|->
name|max_chains
argument_list|)
expr_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
literal|"hw.mps.max_io_pages"
argument_list|,
operator|&
name|sc
operator|->
name|max_io_pages
argument_list|)
expr_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
literal|"hw.mps.enable_ssu"
argument_list|,
operator|&
name|sc
operator|->
name|enable_ssu
argument_list|)
expr_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
literal|"hw.mps.spinup_wait_time"
argument_list|,
operator|&
name|sc
operator|->
name|spinup_wait_time
argument_list|)
expr_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
literal|"hw.mps.use_phy_num"
argument_list|,
operator|&
name|sc
operator|->
name|use_phynum
argument_list|)
expr_stmt|;
comment|/* Grab the unit-instance variables */
name|snprintf
argument_list|(
name|tmpstr
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpstr
argument_list|)
argument_list|,
literal|"dev.mps.%d.debug_level"
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|mps_dev
argument_list|)
argument_list|)
expr_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
name|tmpstr
argument_list|,
operator|&
name|sc
operator|->
name|mps_debug
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|tmpstr
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpstr
argument_list|)
argument_list|,
literal|"dev.mps.%d.disable_msix"
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|mps_dev
argument_list|)
argument_list|)
expr_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
name|tmpstr
argument_list|,
operator|&
name|sc
operator|->
name|disable_msix
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|tmpstr
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpstr
argument_list|)
argument_list|,
literal|"dev.mps.%d.disable_msi"
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|mps_dev
argument_list|)
argument_list|)
expr_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
name|tmpstr
argument_list|,
operator|&
name|sc
operator|->
name|disable_msi
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|tmpstr
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpstr
argument_list|)
argument_list|,
literal|"dev.mps.%d.max_chains"
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|mps_dev
argument_list|)
argument_list|)
expr_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
name|tmpstr
argument_list|,
operator|&
name|sc
operator|->
name|max_chains
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|tmpstr
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpstr
argument_list|)
argument_list|,
literal|"dev.mps.%d.max_io_pages"
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|mps_dev
argument_list|)
argument_list|)
expr_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
name|tmpstr
argument_list|,
operator|&
name|sc
operator|->
name|max_io_pages
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|sc
operator|->
name|exclude_ids
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|exclude_ids
argument_list|)
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|tmpstr
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpstr
argument_list|)
argument_list|,
literal|"dev.mps.%d.exclude_ids"
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|mps_dev
argument_list|)
argument_list|)
expr_stmt|;
name|TUNABLE_STR_FETCH
argument_list|(
name|tmpstr
argument_list|,
name|sc
operator|->
name|exclude_ids
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|exclude_ids
argument_list|)
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|tmpstr
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpstr
argument_list|)
argument_list|,
literal|"dev.mps.%d.enable_ssu"
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|mps_dev
argument_list|)
argument_list|)
expr_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
name|tmpstr
argument_list|,
operator|&
name|sc
operator|->
name|enable_ssu
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|tmpstr
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpstr
argument_list|)
argument_list|,
literal|"dev.mps.%d.spinup_wait_time"
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|mps_dev
argument_list|)
argument_list|)
expr_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
name|tmpstr
argument_list|,
operator|&
name|sc
operator|->
name|spinup_wait_time
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|tmpstr
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpstr
argument_list|)
argument_list|,
literal|"dev.mps.%d.use_phy_num"
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|mps_dev
argument_list|)
argument_list|)
expr_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
name|tmpstr
argument_list|,
operator|&
name|sc
operator|->
name|use_phynum
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mps_setup_sysctl
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|sysctl_ctx_list
modifier|*
name|sysctl_ctx
init|=
name|NULL
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|sysctl_tree
init|=
name|NULL
decl_stmt|;
name|char
name|tmpstr
index|[
literal|80
index|]
decl_stmt|,
name|tmpstr2
index|[
literal|80
index|]
decl_stmt|;
comment|/* 	 * Setup the sysctl variable so the user can change the debug level 	 * on the fly. 	 */
name|snprintf
argument_list|(
name|tmpstr
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpstr
argument_list|)
argument_list|,
literal|"MPS controller %d"
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|mps_dev
argument_list|)
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|tmpstr2
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpstr2
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|mps_dev
argument_list|)
argument_list|)
expr_stmt|;
name|sysctl_ctx
operator|=
name|device_get_sysctl_ctx
argument_list|(
name|sc
operator|->
name|mps_dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|sysctl_ctx
operator|!=
name|NULL
condition|)
name|sysctl_tree
operator|=
name|device_get_sysctl_tree
argument_list|(
name|sc
operator|->
name|mps_dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|sysctl_tree
operator|==
name|NULL
condition|)
block|{
name|sysctl_ctx_init
argument_list|(
operator|&
name|sc
operator|->
name|sysctl_ctx
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sysctl_tree
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
operator|&
name|sc
operator|->
name|sysctl_ctx
argument_list|,
name|SYSCTL_STATIC_CHILDREN
argument_list|(
name|_hw_mps
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
name|tmpstr2
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
name|tmpstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sysctl_tree
operator|==
name|NULL
condition|)
return|return;
name|sysctl_ctx
operator|=
operator|&
name|sc
operator|->
name|sysctl_ctx
expr_stmt|;
name|sysctl_tree
operator|=
name|sc
operator|->
name|sysctl_tree
expr_stmt|;
block|}
name|SYSCTL_ADD_INT
argument_list|(
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"debug_level"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|mps_debug
argument_list|,
literal|0
argument_list|,
literal|"mps debug level"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"disable_msix"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|disable_msix
argument_list|,
literal|0
argument_list|,
literal|"Disable the use of MSI-X interrupts"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"disable_msi"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|disable_msi
argument_list|,
literal|0
argument_list|,
literal|"Disable the use of MSI interrupts"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_STRING
argument_list|(
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"firmware_version"
argument_list|,
name|CTLFLAG_RW
argument_list|,
name|sc
operator|->
name|fw_version
argument_list|,
name|strlen
argument_list|(
name|sc
operator|->
name|fw_version
argument_list|)
argument_list|,
literal|"firmware version"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_STRING
argument_list|(
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"driver_version"
argument_list|,
name|CTLFLAG_RW
argument_list|,
name|MPS_DRIVER_VERSION
argument_list|,
name|strlen
argument_list|(
name|MPS_DRIVER_VERSION
argument_list|)
argument_list|,
literal|"driver version"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"io_cmds_active"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|io_cmds_active
argument_list|,
literal|0
argument_list|,
literal|"number of currently active commands"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"io_cmds_highwater"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|io_cmds_highwater
argument_list|,
literal|0
argument_list|,
literal|"maximum active commands seen"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"chain_free"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|chain_free
argument_list|,
literal|0
argument_list|,
literal|"number of free chain elements"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"chain_free_lowwater"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|chain_free_lowwater
argument_list|,
literal|0
argument_list|,
literal|"lowest number of free chain elements"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"max_chains"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|max_chains
argument_list|,
literal|0
argument_list|,
literal|"maximum chain frames that will be allocated"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"max_io_pages"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|max_io_pages
argument_list|,
literal|0
argument_list|,
literal|"maximum pages to allow per I/O (if<1 use "
literal|"IOCFacts)"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"enable_ssu"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|enable_ssu
argument_list|,
literal|0
argument_list|,
literal|"enable SSU to SATA SSD/HDD at shutdown"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"chain_alloc_fail"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|chain_alloc_fail
argument_list|,
literal|"chain allocation failures"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"spinup_wait_time"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|spinup_wait_time
argument_list|,
name|DEFAULT_SPINUP_WAIT
argument_list|,
literal|"seconds to wait for "
literal|"spinup after SATA ID error"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"mapping_table_dump"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|mps_mapping_dump
argument_list|,
literal|"A"
argument_list|,
literal|"Mapping Table Dump"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"encl_table_dump"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|mps_mapping_encl_dump
argument_list|,
literal|"A"
argument_list|,
literal|"Enclosure Table Dump"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"use_phy_num"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|use_phynum
argument_list|,
literal|0
argument_list|,
literal|"Use the phy number for enumeration"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|mps_attach
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|mps_get_tunables
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|MPS_FUNCTRACE
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|mps_mtx
argument_list|,
literal|"MPT2SAS lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|callout_init_mtx
argument_list|(
operator|&
name|sc
operator|->
name|periodic
argument_list|,
operator|&
name|sc
operator|->
name|mps_mtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|callout_init_mtx
argument_list|(
operator|&
name|sc
operator|->
name|device_check_callout
argument_list|,
operator|&
name|sc
operator|->
name|mps_mtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|event_list
argument_list|)
expr_stmt|;
name|timevalclear
argument_list|(
operator|&
name|sc
operator|->
name|lastfail
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|mps_transition_ready
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|mps_printf
argument_list|(
name|sc
argument_list|,
literal|"%s failed to transition ready\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|sc
operator|->
name|facts
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|MPI2_IOC_FACTS_REPLY
argument_list|)
argument_list|,
name|M_MPT2
argument_list|,
name|M_ZERO
operator||
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|facts
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mps_dev
argument_list|,
literal|"Cannot allocate memory %s %d\n"
argument_list|,
name|__func__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/* 	 * Get IOC Facts and allocate all structures based on this information. 	 * A Diag Reset will also call mps_iocfacts_allocate and re-read the IOC 	 * Facts. If relevant values have changed in IOC Facts, this function 	 * will free all of the memory based on IOC Facts and reallocate that 	 * memory.  If this fails, any allocated memory should already be freed. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|mps_iocfacts_allocate
argument_list|(
name|sc
argument_list|,
name|TRUE
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_FAULT
argument_list|,
literal|"%s IOC Facts based allocation "
literal|"failed with error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* Start the periodic watchdog check on the IOC Doorbell */
name|mps_periodic
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * The portenable will kick off discovery events that will drive the 	 * rest of the initialization process.  The CAM/SAS module will 	 * hold up the boot sequence until discovery is complete. 	 */
name|sc
operator|->
name|mps_ich
operator|.
name|ich_func
operator|=
name|mps_startup
expr_stmt|;
name|sc
operator|->
name|mps_ich
operator|.
name|ich_arg
operator|=
name|sc
expr_stmt|;
if|if
condition|(
name|config_intrhook_establish
argument_list|(
operator|&
name|sc
operator|->
name|mps_ich
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_ERROR
argument_list|,
literal|"Cannot establish MPS config hook\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
comment|/* 	 * Allow IR to shutdown gracefully when shutdown occurs. 	 */
name|sc
operator|->
name|shutdown_eh
operator|=
name|EVENTHANDLER_REGISTER
argument_list|(
name|shutdown_final
argument_list|,
name|mpssas_ir_shutdown
argument_list|,
name|sc
argument_list|,
name|SHUTDOWN_PRI_DEFAULT
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|shutdown_eh
operator|==
name|NULL
condition|)
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_ERROR
argument_list|,
literal|"shutdown event registration "
literal|"failed\n"
argument_list|)
expr_stmt|;
name|mps_setup_sysctl
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mps_flags
operator||=
name|MPS_FLAGS_ATTACH_DONE
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Run through any late-start handlers. */
end_comment

begin_function
specifier|static
name|void
name|mps_startup
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|mps_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|mps_softc
operator|*
operator|)
name|arg
expr_stmt|;
name|mps_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mps_unmask_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* initialize device mapping tables */
name|mps_base_static_config_pages
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mps_mapping_initialize
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mpssas_startup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mps_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Periodic watchdog.  Is called with the driver lock already held. */
end_comment

begin_function
specifier|static
name|void
name|mps_periodic
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|mps_softc
modifier|*
name|sc
decl_stmt|;
name|uint32_t
name|db
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|mps_softc
operator|*
operator|)
name|arg
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mps_flags
operator|&
name|MPS_FLAGS_SHUTDOWN
condition|)
return|return;
name|db
operator|=
name|mps_regread
argument_list|(
name|sc
argument_list|,
name|MPI2_DOORBELL_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|db
operator|&
name|MPI2_IOC_STATE_MASK
operator|)
operator|==
name|MPI2_IOC_STATE_FAULT
condition|)
block|{
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_FAULT
argument_list|,
literal|"IOC Fault 0x%08x, Resetting\n"
argument_list|,
name|db
argument_list|)
expr_stmt|;
name|mps_reinit
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|periodic
argument_list|,
name|MPS_PERIODIC_DELAY
operator|*
name|hz
argument_list|,
name|mps_periodic
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mps_log_evt_handler
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|uintptr_t
name|data
parameter_list|,
name|MPI2_EVENT_NOTIFICATION_REPLY
modifier|*
name|event
parameter_list|)
block|{
name|MPI2_EVENT_DATA_LOG_ENTRY_ADDED
modifier|*
name|entry
decl_stmt|;
name|mps_print_event
argument_list|(
name|sc
argument_list|,
name|event
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|event
operator|->
name|Event
condition|)
block|{
case|case
name|MPI2_EVENT_LOG_DATA
case|:
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_EVENT
argument_list|,
literal|"MPI2_EVENT_LOG_DATA:\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mps_debug
operator|&
name|MPS_EVENT
condition|)
name|hexdump
argument_list|(
name|event
operator|->
name|EventData
argument_list|,
name|event
operator|->
name|EventDataLength
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|MPI2_EVENT_LOG_ENTRY_ADDED
case|:
name|entry
operator|=
operator|(
name|MPI2_EVENT_DATA_LOG_ENTRY_ADDED
operator|*
operator|)
name|event
operator|->
name|EventData
expr_stmt|;
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_EVENT
argument_list|,
literal|"MPI2_EVENT_LOG_ENTRY_ADDED event "
literal|"0x%x Sequence %d:\n"
argument_list|,
name|entry
operator|->
name|LogEntryQualifier
argument_list|,
name|entry
operator|->
name|LogSequence
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|mps_attach_log
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u32
name|events
index|[
name|MPI2_EVENT_NOTIFY_EVENTMASK_WORDS
index|]
decl_stmt|;
name|bzero
argument_list|(
name|events
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|setbit
argument_list|(
name|events
argument_list|,
name|MPI2_EVENT_LOG_DATA
argument_list|)
expr_stmt|;
name|setbit
argument_list|(
name|events
argument_list|,
name|MPI2_EVENT_LOG_ENTRY_ADDED
argument_list|)
expr_stmt|;
name|mps_register_events
argument_list|(
name|sc
argument_list|,
name|events
argument_list|,
name|mps_log_evt_handler
argument_list|,
name|NULL
argument_list|,
operator|&
name|sc
operator|->
name|mps_log_eh
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mps_detach_log
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|)
block|{
if|if
condition|(
name|sc
operator|->
name|mps_log_eh
operator|!=
name|NULL
condition|)
name|mps_deregister_events
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mps_log_eh
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free all of the driver resources and detach submodules.  Should be called  * without the lock held.  */
end_comment

begin_function
name|int
name|mps_free
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
comment|/* Turn off the watchdog */
name|mps_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mps_flags
operator||=
name|MPS_FLAGS_SHUTDOWN
expr_stmt|;
name|mps_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Lock must not be held for this */
name|callout_drain
argument_list|(
operator|&
name|sc
operator|->
name|periodic
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|sc
operator|->
name|device_check_callout
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|error
operator|=
name|mps_detach_log
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
operator|(
name|error
operator|=
name|mps_detach_sas
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|mps_detach_user
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Put the IOC back in the READY state. */
name|mps_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|mps_transition_ready
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|mps_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|mps_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|facts
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|sc
operator|->
name|facts
argument_list|,
name|M_MPT2
argument_list|)
expr_stmt|;
comment|/* 	 * Free all buffers that are based on IOC Facts.  A Diag Reset may need 	 * to free these buffers too. 	 */
name|mps_iocfacts_free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sysctl_tree
operator|!=
name|NULL
condition|)
name|sysctl_ctx_free
argument_list|(
operator|&
name|sc
operator|->
name|sysctl_ctx
argument_list|)
expr_stmt|;
comment|/* Deregister the shutdown function */
if|if
condition|(
name|sc
operator|->
name|shutdown_eh
operator|!=
name|NULL
condition|)
name|EVENTHANDLER_DEREGISTER
argument_list|(
name|shutdown_final
argument_list|,
name|sc
operator|->
name|shutdown_eh
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|mps_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|mps_complete_command
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mps_command
modifier|*
name|cm
parameter_list|)
block|{
name|MPS_FUNCTRACE
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|cm
operator|==
name|NULL
condition|)
block|{
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_ERROR
argument_list|,
literal|"Completing NULL command\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|cm
operator|->
name|cm_flags
operator|&
name|MPS_CM_FLAGS_POLLED
condition|)
name|cm
operator|->
name|cm_flags
operator||=
name|MPS_CM_FLAGS_COMPLETE
expr_stmt|;
if|if
condition|(
name|cm
operator|->
name|cm_complete
operator|!=
name|NULL
condition|)
block|{
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_TRACE
argument_list|,
literal|"%s cm %p calling cm_complete %p data %p reply %p\n"
argument_list|,
name|__func__
argument_list|,
name|cm
argument_list|,
name|cm
operator|->
name|cm_complete
argument_list|,
name|cm
operator|->
name|cm_complete_data
argument_list|,
name|cm
operator|->
name|cm_reply
argument_list|)
expr_stmt|;
name|cm
operator|->
name|cm_complete
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cm
operator|->
name|cm_flags
operator|&
name|MPS_CM_FLAGS_WAKEUP
condition|)
block|{
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_TRACE
argument_list|,
literal|"waking up %p\n"
argument_list|,
name|cm
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|cm
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cm
operator|->
name|cm_sc
operator|->
name|io_cmds_active
operator|!=
literal|0
condition|)
block|{
name|cm
operator|->
name|cm_sc
operator|->
name|io_cmds_active
operator|--
expr_stmt|;
block|}
else|else
block|{
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_ERROR
argument_list|,
literal|"Warning: io_cmds_active is "
literal|"out of sync - resynching to 0\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|mps_sas_log_info
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|u32
name|log_info
parameter_list|)
block|{
union|union
name|loginfo_type
block|{
name|u32
name|loginfo
decl_stmt|;
struct|struct
block|{
name|u32
name|subcode
range|:
literal|16
decl_stmt|;
name|u32
name|code
range|:
literal|8
decl_stmt|;
name|u32
name|originator
range|:
literal|4
decl_stmt|;
name|u32
name|bus_type
range|:
literal|4
decl_stmt|;
block|}
name|dw
struct|;
block|}
union|;
name|union
name|loginfo_type
name|sas_loginfo
decl_stmt|;
name|char
modifier|*
name|originator_str
init|=
name|NULL
decl_stmt|;
name|sas_loginfo
operator|.
name|loginfo
operator|=
name|log_info
expr_stmt|;
if|if
condition|(
name|sas_loginfo
operator|.
name|dw
operator|.
name|bus_type
operator|!=
literal|3
comment|/*SAS*/
condition|)
return|return;
comment|/* each nexus loss loginfo */
if|if
condition|(
name|log_info
operator|==
literal|0x31170000
condition|)
return|return;
comment|/* eat the loginfos associated with task aborts */
if|if
condition|(
operator|(
name|log_info
operator|==
literal|30050000
operator|||
name|log_info
operator|==
literal|0x31140000
operator|||
name|log_info
operator|==
literal|0x31130000
operator|)
condition|)
return|return;
switch|switch
condition|(
name|sas_loginfo
operator|.
name|dw
operator|.
name|originator
condition|)
block|{
case|case
literal|0
case|:
name|originator_str
operator|=
literal|"IOP"
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|originator_str
operator|=
literal|"PL"
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|originator_str
operator|=
literal|"IR"
expr_stmt|;
break|break;
block|}
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_LOG
argument_list|,
literal|"log_info(0x%08x): originator(%s), "
literal|"code(0x%02x), sub_code(0x%04x)\n"
argument_list|,
name|log_info
argument_list|,
name|originator_str
argument_list|,
name|sas_loginfo
operator|.
name|dw
operator|.
name|code
argument_list|,
name|sas_loginfo
operator|.
name|dw
operator|.
name|subcode
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mps_display_reply_info
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
modifier|*
name|reply
parameter_list|)
block|{
name|MPI2DefaultReply_t
modifier|*
name|mpi_reply
decl_stmt|;
name|u16
name|sc_status
decl_stmt|;
name|mpi_reply
operator|=
operator|(
name|MPI2DefaultReply_t
operator|*
operator|)
name|reply
expr_stmt|;
name|sc_status
operator|=
name|le16toh
argument_list|(
name|mpi_reply
operator|->
name|IOCStatus
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc_status
operator|&
name|MPI2_IOCSTATUS_FLAG_LOG_INFO_AVAILABLE
condition|)
name|mps_sas_log_info
argument_list|(
name|sc
argument_list|,
name|le32toh
argument_list|(
name|mpi_reply
operator|->
name|IOCLogInfo
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|mps_intr
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|mps_softc
modifier|*
name|sc
decl_stmt|;
name|uint32_t
name|status
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|mps_softc
operator|*
operator|)
name|data
expr_stmt|;
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_TRACE
argument_list|,
literal|"%s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* 	 * Check interrupt status register to flush the bus.  This is 	 * needed for both INTx interrupts and driver-driven polling 	 */
name|status
operator|=
name|mps_regread
argument_list|(
name|sc
argument_list|,
name|MPI2_HOST_INTERRUPT_STATUS_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|MPI2_HIS_REPLY_DESCRIPTOR_INTERRUPT
operator|)
operator|==
literal|0
condition|)
return|return;
name|mps_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mps_intr_locked
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|mps_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * In theory, MSI/MSIX interrupts shouldn't need to read any registers on the  * chip.  Hopefully this theory is correct.  */
end_comment

begin_function
name|void
name|mps_intr_msi
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|mps_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|mps_softc
operator|*
operator|)
name|data
expr_stmt|;
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_TRACE
argument_list|,
literal|"%s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|mps_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mps_intr_locked
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|mps_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * The locking is overly broad and simplistic, but easy to deal with for now.  */
end_comment

begin_function
name|void
name|mps_intr_locked
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|MPI2_REPLY_DESCRIPTORS_UNION
modifier|*
name|desc
decl_stmt|;
name|struct
name|mps_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mps_command
modifier|*
name|cm
init|=
name|NULL
decl_stmt|;
name|uint8_t
name|flags
decl_stmt|;
name|u_int
name|pq
decl_stmt|;
name|MPI2_DIAG_RELEASE_REPLY
modifier|*
name|rel_rep
decl_stmt|;
name|mps_fw_diagnostic_buffer_t
modifier|*
name|pBuffer
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|mps_softc
operator|*
operator|)
name|data
expr_stmt|;
name|pq
operator|=
name|sc
operator|->
name|replypostindex
expr_stmt|;
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_TRACE
argument_list|,
literal|"%s sc %p starting with replypostindex %u\n"
argument_list|,
name|__func__
argument_list|,
name|sc
argument_list|,
name|sc
operator|->
name|replypostindex
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|cm
operator|=
name|NULL
expr_stmt|;
name|desc
operator|=
operator|&
name|sc
operator|->
name|post_queue
index|[
name|sc
operator|->
name|replypostindex
index|]
expr_stmt|;
name|flags
operator|=
name|desc
operator|->
name|Default
operator|.
name|ReplyFlags
operator|&
name|MPI2_RPY_DESCRIPT_FLAGS_TYPE_MASK
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|==
name|MPI2_RPY_DESCRIPT_FLAGS_UNUSED
operator|)
operator|||
operator|(
name|le32toh
argument_list|(
name|desc
operator|->
name|Words
operator|.
name|High
argument_list|)
operator|==
literal|0xffffffff
operator|)
condition|)
break|break;
comment|/* increment the replypostindex now, so that event handlers 		 * and cm completion handlers which decide to do a diag 		 * reset can zero it without it getting incremented again 		 * afterwards, and we break out of this loop on the next 		 * iteration since the reply post queue has been cleared to 		 * 0xFF and all descriptors look unused (which they are). 		 */
if|if
condition|(
operator|++
name|sc
operator|->
name|replypostindex
operator|>=
name|sc
operator|->
name|pqdepth
condition|)
name|sc
operator|->
name|replypostindex
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|flags
condition|)
block|{
case|case
name|MPI2_RPY_DESCRIPT_FLAGS_SCSI_IO_SUCCESS
case|:
name|cm
operator|=
operator|&
name|sc
operator|->
name|commands
index|[
name|le16toh
argument_list|(
name|desc
operator|->
name|SCSIIOSuccess
operator|.
name|SMID
argument_list|)
index|]
expr_stmt|;
name|cm
operator|->
name|cm_reply
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|MPI2_RPY_DESCRIPT_FLAGS_ADDRESS_REPLY
case|:
block|{
name|uint32_t
name|baddr
decl_stmt|;
name|uint8_t
modifier|*
name|reply
decl_stmt|;
comment|/* 			 * Re-compose the reply address from the address 			 * sent back from the chip.  The ReplyFrameAddress 			 * is the lower 32 bits of the physical address of 			 * particular reply frame.  Convert that address to 			 * host format, and then use that to provide the 			 * offset against the virtual address base 			 * (sc->reply_frames). 			 */
name|baddr
operator|=
name|le32toh
argument_list|(
name|desc
operator|->
name|AddressReply
operator|.
name|ReplyFrameAddress
argument_list|)
expr_stmt|;
name|reply
operator|=
name|sc
operator|->
name|reply_frames
operator|+
operator|(
name|baddr
operator|-
operator|(
operator|(
name|uint32_t
operator|)
name|sc
operator|->
name|reply_busaddr
operator|)
operator|)
expr_stmt|;
comment|/* 			 * Make sure the reply we got back is in a valid 			 * range.  If not, go ahead and panic here, since 			 * we'll probably panic as soon as we deference the 			 * reply pointer anyway. 			 */
if|if
condition|(
operator|(
name|reply
operator|<
name|sc
operator|->
name|reply_frames
operator|)
operator|||
operator|(
name|reply
operator|>
operator|(
name|sc
operator|->
name|reply_frames
operator|+
operator|(
name|sc
operator|->
name|fqdepth
operator|*
name|sc
operator|->
name|facts
operator|->
name|ReplyFrameSize
operator|*
literal|4
operator|)
operator|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s: WARNING: reply %p out of range!\n"
argument_list|,
name|__func__
argument_list|,
name|reply
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: reply_frames %p, fqdepth %d, "
literal|"frame size %d\n"
argument_list|,
name|__func__
argument_list|,
name|sc
operator|->
name|reply_frames
argument_list|,
name|sc
operator|->
name|fqdepth
argument_list|,
name|sc
operator|->
name|facts
operator|->
name|ReplyFrameSize
operator|*
literal|4
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: baddr %#x,\n"
argument_list|,
name|__func__
argument_list|,
name|baddr
argument_list|)
expr_stmt|;
comment|/* LSI-TODO. See Linux Code. Need Gracefull exit*/
name|panic
argument_list|(
literal|"Reply address out of range"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|le16toh
argument_list|(
name|desc
operator|->
name|AddressReply
operator|.
name|SMID
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|MPI2_DEFAULT_REPLY
operator|*
operator|)
name|reply
operator|)
operator|->
name|Function
operator|==
name|MPI2_FUNCTION_DIAG_BUFFER_POST
condition|)
block|{
comment|/* 					 * If SMID is 0 for Diag Buffer Post, 					 * this implies that the reply is due to 					 * a release function with a status that 					 * the buffer has been released.  Set 					 * the buffer flags accordingly. 					 */
name|rel_rep
operator|=
operator|(
name|MPI2_DIAG_RELEASE_REPLY
operator|*
operator|)
name|reply
expr_stmt|;
if|if
condition|(
operator|(
name|le16toh
argument_list|(
name|rel_rep
operator|->
name|IOCStatus
argument_list|)
operator|&
name|MPI2_IOCSTATUS_MASK
operator|)
operator|==
name|MPI2_IOCSTATUS_DIAGNOSTIC_RELEASED
condition|)
block|{
name|pBuffer
operator|=
operator|&
name|sc
operator|->
name|fw_diag_buffer_list
index|[
name|rel_rep
operator|->
name|BufferType
index|]
expr_stmt|;
name|pBuffer
operator|->
name|valid_data
operator|=
name|TRUE
expr_stmt|;
name|pBuffer
operator|->
name|owned_by_firmware
operator|=
name|FALSE
expr_stmt|;
name|pBuffer
operator|->
name|immediate
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
else|else
name|mps_dispatch_event
argument_list|(
name|sc
argument_list|,
name|baddr
argument_list|,
operator|(
name|MPI2_EVENT_NOTIFICATION_REPLY
operator|*
operator|)
name|reply
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cm
operator|=
operator|&
name|sc
operator|->
name|commands
index|[
name|le16toh
argument_list|(
name|desc
operator|->
name|AddressReply
operator|.
name|SMID
argument_list|)
index|]
expr_stmt|;
name|cm
operator|->
name|cm_reply
operator|=
name|reply
expr_stmt|;
name|cm
operator|->
name|cm_reply_data
operator|=
name|le32toh
argument_list|(
name|desc
operator|->
name|AddressReply
operator|.
name|ReplyFrameAddress
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|MPI2_RPY_DESCRIPT_FLAGS_TARGETASSIST_SUCCESS
case|:
case|case
name|MPI2_RPY_DESCRIPT_FLAGS_TARGET_COMMAND_BUFFER
case|:
case|case
name|MPI2_RPY_DESCRIPT_FLAGS_RAID_ACCELERATOR_SUCCESS
case|:
default|default:
comment|/* Unhandled */
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_ERROR
argument_list|,
literal|"Unhandled reply 0x%x\n"
argument_list|,
name|desc
operator|->
name|Default
operator|.
name|ReplyFlags
argument_list|)
expr_stmt|;
name|cm
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|cm
operator|!=
name|NULL
condition|)
block|{
comment|// Print Error reply frame
if|if
condition|(
name|cm
operator|->
name|cm_reply
condition|)
name|mps_display_reply_info
argument_list|(
name|sc
argument_list|,
name|cm
operator|->
name|cm_reply
argument_list|)
expr_stmt|;
name|mps_complete_command
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
block|}
name|desc
operator|->
name|Words
operator|.
name|Low
operator|=
literal|0xffffffff
expr_stmt|;
name|desc
operator|->
name|Words
operator|.
name|High
operator|=
literal|0xffffffff
expr_stmt|;
block|}
if|if
condition|(
name|pq
operator|!=
name|sc
operator|->
name|replypostindex
condition|)
block|{
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_TRACE
argument_list|,
literal|"%s sc %p writing postindex %d\n"
argument_list|,
name|__func__
argument_list|,
name|sc
argument_list|,
name|sc
operator|->
name|replypostindex
argument_list|)
expr_stmt|;
name|mps_regwrite
argument_list|(
name|sc
argument_list|,
name|MPI2_REPLY_POST_HOST_INDEX_OFFSET
argument_list|,
name|sc
operator|->
name|replypostindex
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|mps_dispatch_event
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|uintptr_t
name|data
parameter_list|,
name|MPI2_EVENT_NOTIFICATION_REPLY
modifier|*
name|reply
parameter_list|)
block|{
name|struct
name|mps_event_handle
modifier|*
name|eh
decl_stmt|;
name|int
name|event
decl_stmt|,
name|handled
init|=
literal|0
decl_stmt|;
name|event
operator|=
name|le16toh
argument_list|(
name|reply
operator|->
name|Event
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|eh
argument_list|,
argument|&sc->event_list
argument_list|,
argument|eh_list
argument_list|)
block|{
if|if
condition|(
name|isset
argument_list|(
name|eh
operator|->
name|mask
argument_list|,
name|event
argument_list|)
condition|)
block|{
name|eh
operator|->
name|callback
argument_list|(
name|sc
argument_list|,
name|data
argument_list|,
name|reply
argument_list|)
expr_stmt|;
name|handled
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|handled
operator|==
literal|0
condition|)
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_EVENT
argument_list|,
literal|"Unhandled event 0x%x\n"
argument_list|,
name|le16toh
argument_list|(
name|event
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * This is the only place that the event/reply should be freed. 	 * Anything wanting to hold onto the event data should have 	 * already copied it into their own storage. 	 */
name|mps_free_reply
argument_list|(
name|sc
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mps_reregister_events_complete
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mps_command
modifier|*
name|cm
parameter_list|)
block|{
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_TRACE
argument_list|,
literal|"%s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|cm
operator|->
name|cm_reply
condition|)
name|mps_print_event
argument_list|(
name|sc
argument_list|,
operator|(
name|MPI2_EVENT_NOTIFICATION_REPLY
operator|*
operator|)
name|cm
operator|->
name|cm_reply
argument_list|)
expr_stmt|;
name|mps_free_command
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
comment|/* next, send a port enable */
name|mpssas_startup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * For both register_events and update_events, the caller supplies a bitmap  * of events that it _wants_.  These functions then turn that into a bitmask  * suitable for the controller.  */
end_comment

begin_function
name|int
name|mps_register_events
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|u32
modifier|*
name|mask
parameter_list|,
name|mps_evt_callback_t
modifier|*
name|cb
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|mps_event_handle
modifier|*
modifier|*
name|handle
parameter_list|)
block|{
name|struct
name|mps_event_handle
modifier|*
name|eh
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|eh
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|mps_event_handle
argument_list|)
argument_list|,
name|M_MPT2
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|eh
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mps_dev
argument_list|,
literal|"Cannot allocate memory %s %d\n"
argument_list|,
name|__func__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|eh
operator|->
name|callback
operator|=
name|cb
expr_stmt|;
name|eh
operator|->
name|data
operator|=
name|data
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|event_list
argument_list|,
name|eh
argument_list|,
name|eh_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
operator|!=
name|NULL
condition|)
name|error
operator|=
name|mps_update_events
argument_list|(
name|sc
argument_list|,
name|eh
argument_list|,
name|mask
argument_list|)
expr_stmt|;
operator|*
name|handle
operator|=
name|eh
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|mps_update_events
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mps_event_handle
modifier|*
name|handle
parameter_list|,
name|u32
modifier|*
name|mask
parameter_list|)
block|{
name|MPI2_EVENT_NOTIFICATION_REQUEST
modifier|*
name|evtreq
decl_stmt|;
name|MPI2_EVENT_NOTIFICATION_REPLY
modifier|*
name|reply
decl_stmt|;
name|struct
name|mps_command
modifier|*
name|cm
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_TRACE
argument_list|,
literal|"%s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mask
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|handle
operator|!=
name|NULL
operator|)
condition|)
name|bcopy
argument_list|(
name|mask
argument_list|,
operator|&
name|handle
operator|->
name|mask
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
operator|*
name|MPI2_EVENT_NOTIFY_EVENTMASK_WORDS
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MPI2_EVENT_NOTIFY_EVENTMASK_WORDS
condition|;
name|i
operator|++
control|)
name|sc
operator|->
name|event_mask
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MPI2_EVENT_NOTIFY_EVENTMASK_WORDS
condition|;
name|i
operator|++
control|)
name|sc
operator|->
name|event_mask
index|[
name|i
index|]
operator|&=
operator|~
name|handle
operator|->
name|mask
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|cm
operator|=
name|mps_alloc_command
argument_list|(
name|sc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|evtreq
operator|=
operator|(
name|MPI2_EVENT_NOTIFICATION_REQUEST
operator|*
operator|)
name|cm
operator|->
name|cm_req
expr_stmt|;
name|evtreq
operator|->
name|Function
operator|=
name|MPI2_FUNCTION_EVENT_NOTIFICATION
expr_stmt|;
name|evtreq
operator|->
name|MsgFlags
operator|=
literal|0
expr_stmt|;
name|evtreq
operator|->
name|SASBroadcastPrimitiveMasks
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|MPS_DEBUG_ALL_EVENTS
block|{
name|u_char
name|fullmask
index|[
literal|16
index|]
decl_stmt|;
name|memset
argument_list|(
name|fullmask
argument_list|,
literal|0x00
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|fullmask
argument_list|,
operator|&
name|evtreq
operator|->
name|EventMasks
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
operator|*
name|MPI2_EVENT_NOTIFY_EVENTMASK_WORDS
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MPI2_EVENT_NOTIFY_EVENTMASK_WORDS
condition|;
name|i
operator|++
control|)
name|evtreq
operator|->
name|EventMasks
index|[
name|i
index|]
operator|=
name|htole32
argument_list|(
name|sc
operator|->
name|event_mask
index|[
name|i
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cm
operator|->
name|cm_desc
operator|.
name|Default
operator|.
name|RequestFlags
operator|=
name|MPI2_REQ_DESCRIPT_FLAGS_DEFAULT_TYPE
expr_stmt|;
name|cm
operator|->
name|cm_data
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|mps_wait_command
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|,
literal|60
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|reply
operator|=
operator|(
name|MPI2_EVENT_NOTIFICATION_REPLY
operator|*
operator|)
name|cm
operator|->
name|cm_reply
expr_stmt|;
if|if
condition|(
operator|(
name|reply
operator|==
name|NULL
operator|)
operator|||
operator|(
name|reply
operator|->
name|IOCStatus
operator|&
name|MPI2_IOCSTATUS_MASK
operator|)
operator|!=
name|MPI2_IOCSTATUS_SUCCESS
condition|)
name|error
operator|=
name|ENXIO
expr_stmt|;
name|mps_print_event
argument_list|(
name|sc
argument_list|,
name|reply
argument_list|)
expr_stmt|;
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_TRACE
argument_list|,
literal|"%s finished error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|mps_free_command
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mps_reregister_events
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|)
block|{
name|MPI2_EVENT_NOTIFICATION_REQUEST
modifier|*
name|evtreq
decl_stmt|;
name|struct
name|mps_command
modifier|*
name|cm
decl_stmt|;
name|struct
name|mps_event_handle
modifier|*
name|eh
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_TRACE
argument_list|,
literal|"%s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* first, reregister events */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MPI2_EVENT_NOTIFY_EVENTMASK_WORDS
condition|;
name|i
operator|++
control|)
name|sc
operator|->
name|event_mask
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|eh
argument_list|,
argument|&sc->event_list
argument_list|,
argument|eh_list
argument_list|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MPI2_EVENT_NOTIFY_EVENTMASK_WORDS
condition|;
name|i
operator|++
control|)
name|sc
operator|->
name|event_mask
index|[
name|i
index|]
operator|&=
operator|~
name|eh
operator|->
name|mask
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|cm
operator|=
name|mps_alloc_command
argument_list|(
name|sc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|evtreq
operator|=
operator|(
name|MPI2_EVENT_NOTIFICATION_REQUEST
operator|*
operator|)
name|cm
operator|->
name|cm_req
expr_stmt|;
name|evtreq
operator|->
name|Function
operator|=
name|MPI2_FUNCTION_EVENT_NOTIFICATION
expr_stmt|;
name|evtreq
operator|->
name|MsgFlags
operator|=
literal|0
expr_stmt|;
name|evtreq
operator|->
name|SASBroadcastPrimitiveMasks
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|MPS_DEBUG_ALL_EVENTS
block|{
name|u_char
name|fullmask
index|[
literal|16
index|]
decl_stmt|;
name|memset
argument_list|(
name|fullmask
argument_list|,
literal|0x00
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|fullmask
argument_list|,
operator|&
name|evtreq
operator|->
name|EventMasks
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
operator|*
name|MPI2_EVENT_NOTIFY_EVENTMASK_WORDS
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MPI2_EVENT_NOTIFY_EVENTMASK_WORDS
condition|;
name|i
operator|++
control|)
name|evtreq
operator|->
name|EventMasks
index|[
name|i
index|]
operator|=
name|htole32
argument_list|(
name|sc
operator|->
name|event_mask
index|[
name|i
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cm
operator|->
name|cm_desc
operator|.
name|Default
operator|.
name|RequestFlags
operator|=
name|MPI2_REQ_DESCRIPT_FLAGS_DEFAULT_TYPE
expr_stmt|;
name|cm
operator|->
name|cm_data
operator|=
name|NULL
expr_stmt|;
name|cm
operator|->
name|cm_complete
operator|=
name|mps_reregister_events_complete
expr_stmt|;
name|error
operator|=
name|mps_map_command
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_TRACE
argument_list|,
literal|"%s finished with error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|void
name|mps_deregister_events
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mps_event_handle
modifier|*
name|handle
parameter_list|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|event_list
argument_list|,
name|handle
argument_list|,
name|eh_list
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|handle
argument_list|,
name|M_MPT2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Add a chain element as the next SGE for the specified command.  * Reset cm_sge and cm_sgesize to indicate all the available space.  */
end_comment

begin_function
specifier|static
name|int
name|mps_add_chain
parameter_list|(
name|struct
name|mps_command
modifier|*
name|cm
parameter_list|)
block|{
name|MPI2_SGE_CHAIN32
modifier|*
name|sgc
decl_stmt|;
name|struct
name|mps_chain
modifier|*
name|chain
decl_stmt|;
name|int
name|space
decl_stmt|;
if|if
condition|(
name|cm
operator|->
name|cm_sglsize
operator|<
name|MPS_SGC_SIZE
condition|)
name|panic
argument_list|(
literal|"MPS: Need SGE Error Code\n"
argument_list|)
expr_stmt|;
name|chain
operator|=
name|mps_alloc_chain
argument_list|(
name|cm
operator|->
name|cm_sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|chain
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
name|space
operator|=
operator|(
name|int
operator|)
name|cm
operator|->
name|cm_sc
operator|->
name|facts
operator|->
name|IOCRequestFrameSize
operator|*
literal|4
expr_stmt|;
comment|/* 	 * Note: a double-linked list is used to make it easier to 	 * walk for debugging. 	 */
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|cm
operator|->
name|cm_chain_list
argument_list|,
name|chain
argument_list|,
name|chain_link
argument_list|)
expr_stmt|;
name|sgc
operator|=
operator|(
name|MPI2_SGE_CHAIN32
operator|*
operator|)
operator|&
name|cm
operator|->
name|cm_sge
operator|->
name|MpiChain
expr_stmt|;
name|sgc
operator|->
name|Length
operator|=
name|htole16
argument_list|(
name|space
argument_list|)
expr_stmt|;
name|sgc
operator|->
name|NextChainOffset
operator|=
literal|0
expr_stmt|;
comment|/* TODO Looks like bug in Setting sgc->Flags.  	 *	sgc->Flags = ( MPI2_SGE_FLAGS_CHAIN_ELEMENT | MPI2_SGE_FLAGS_64_BIT_ADDRESSING | 	 *	            MPI2_SGE_FLAGS_SYSTEM_ADDRESS)<< MPI2_SGE_FLAGS_SHIFT 	 *	This is fine.. because we are not using simple element. In case of  	 *	MPI2_SGE_CHAIN32, we have seperate Length and Flags feild.  	 */
name|sgc
operator|->
name|Flags
operator|=
name|MPI2_SGE_FLAGS_CHAIN_ELEMENT
expr_stmt|;
name|sgc
operator|->
name|Address
operator|=
name|htole32
argument_list|(
name|chain
operator|->
name|chain_busaddr
argument_list|)
expr_stmt|;
name|cm
operator|->
name|cm_sge
operator|=
operator|(
name|MPI2_SGE_IO_UNION
operator|*
operator|)
operator|&
name|chain
operator|->
name|chain
operator|->
name|MpiSimple
expr_stmt|;
name|cm
operator|->
name|cm_sglsize
operator|=
name|space
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add one scatter-gather element (chain, simple, transaction context)  * to the scatter-gather list for a command.  Maintain cm_sglsize and  * cm_sge as the remaining size and pointer to the next SGE to fill  * in, respectively.  */
end_comment

begin_function
name|int
name|mps_push_sge
parameter_list|(
name|struct
name|mps_command
modifier|*
name|cm
parameter_list|,
name|void
modifier|*
name|sgep
parameter_list|,
name|size_t
name|len
parameter_list|,
name|int
name|segsleft
parameter_list|)
block|{
name|MPI2_SGE_TRANSACTION_UNION
modifier|*
name|tc
init|=
name|sgep
decl_stmt|;
name|MPI2_SGE_SIMPLE64
modifier|*
name|sge
init|=
name|sgep
decl_stmt|;
name|int
name|error
decl_stmt|,
name|type
decl_stmt|;
name|uint32_t
name|saved_buf_len
decl_stmt|,
name|saved_address_low
decl_stmt|,
name|saved_address_high
decl_stmt|;
name|type
operator|=
operator|(
name|tc
operator|->
name|Flags
operator|&
name|MPI2_SGE_FLAGS_ELEMENT_MASK
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|MPI2_SGE_FLAGS_TRANSACTION_ELEMENT
case|:
block|{
if|if
condition|(
name|len
operator|!=
name|tc
operator|->
name|DetailsLength
operator|+
literal|4
condition|)
name|panic
argument_list|(
literal|"TC %p length %u or %zu?"
argument_list|,
name|tc
argument_list|,
name|tc
operator|->
name|DetailsLength
operator|+
literal|4
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|MPI2_SGE_FLAGS_CHAIN_ELEMENT
case|:
comment|/* Driver only uses 32-bit chain elements */
if|if
condition|(
name|len
operator|!=
name|MPS_SGC_SIZE
condition|)
name|panic
argument_list|(
literal|"CHAIN %p length %u or %zu?"
argument_list|,
name|sgep
argument_list|,
name|MPS_SGC_SIZE
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|MPI2_SGE_FLAGS_SIMPLE_ELEMENT
case|:
comment|/* Driver only uses 64-bit SGE simple elements */
if|if
condition|(
name|len
operator|!=
name|MPS_SGE64_SIZE
condition|)
name|panic
argument_list|(
literal|"SGE simple %p length %u or %zu?"
argument_list|,
name|sge
argument_list|,
name|MPS_SGE64_SIZE
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|le32toh
argument_list|(
name|sge
operator|->
name|FlagsLength
argument_list|)
operator|>>
name|MPI2_SGE_FLAGS_SHIFT
operator|)
operator|&
name|MPI2_SGE_FLAGS_ADDRESS_SIZE
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"SGE simple %p not marked 64-bit?"
argument_list|,
name|sge
argument_list|)
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"Unexpected SGE %p, flags %02x"
argument_list|,
name|tc
argument_list|,
name|tc
operator|->
name|Flags
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * case 1: 1 more segment, enough room for it 	 * case 2: 2 more segments, enough room for both 	 * case 3:>=2 more segments, only enough room for 1 and a chain 	 * case 4:>=1 more segment, enough room for only a chain 	 * case 5:>=1 more segment, no room for anything (error)          */
comment|/* 	 * There should be room for at least a chain element, or this 	 * code is buggy.  Case (5). 	 */
if|if
condition|(
name|cm
operator|->
name|cm_sglsize
operator|<
name|MPS_SGC_SIZE
condition|)
name|panic
argument_list|(
literal|"MPS: Need SGE Error Code\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|segsleft
operator|>=
literal|2
operator|&&
name|cm
operator|->
name|cm_sglsize
operator|<
name|len
operator|+
name|MPS_SGC_SIZE
operator|+
name|MPS_SGE64_SIZE
condition|)
block|{
comment|/* 		 * There are 2 or more segments left to add, and only 		 * enough room for 1 and a chain.  Case (3). 		 * 		 * Mark as last element in this chain if necessary. 		 */
if|if
condition|(
name|type
operator|==
name|MPI2_SGE_FLAGS_SIMPLE_ELEMENT
condition|)
block|{
name|sge
operator|->
name|FlagsLength
operator||=
name|htole32
argument_list|(
name|MPI2_SGE_FLAGS_LAST_ELEMENT
operator|<<
name|MPI2_SGE_FLAGS_SHIFT
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Add the item then a chain.  Do the chain now, 		 * rather than on the next iteration, to simplify 		 * understanding the code. 		 */
name|cm
operator|->
name|cm_sglsize
operator|-=
name|len
expr_stmt|;
name|bcopy
argument_list|(
name|sgep
argument_list|,
name|cm
operator|->
name|cm_sge
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|cm
operator|->
name|cm_sge
operator|=
operator|(
name|MPI2_SGE_IO_UNION
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|cm
operator|->
name|cm_sge
operator|+
name|len
operator|)
expr_stmt|;
return|return
operator|(
name|mps_add_chain
argument_list|(
name|cm
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|segsleft
operator|>=
literal|1
operator|&&
name|cm
operator|->
name|cm_sglsize
operator|<
name|len
operator|+
name|MPS_SGC_SIZE
condition|)
block|{
comment|/* 		 * 1 or more segment, enough room for only a chain. 		 * Hope the previous element wasn't a Simple entry 		 * that needed to be marked with 		 * MPI2_SGE_FLAGS_LAST_ELEMENT.  Case (4). 		 */
if|if
condition|(
operator|(
name|error
operator|=
name|mps_add_chain
argument_list|(
name|cm
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|INVARIANTS
comment|/* Case 1: 1 more segment, enough room for it. */
if|if
condition|(
name|segsleft
operator|==
literal|1
operator|&&
name|cm
operator|->
name|cm_sglsize
operator|<
name|len
condition|)
name|panic
argument_list|(
literal|"1 seg left and no room? %u versus %zu"
argument_list|,
name|cm
operator|->
name|cm_sglsize
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* Case 2: 2 more segments, enough room for both */
if|if
condition|(
name|segsleft
operator|==
literal|2
operator|&&
name|cm
operator|->
name|cm_sglsize
operator|<
name|len
operator|+
name|MPS_SGE64_SIZE
condition|)
name|panic
argument_list|(
literal|"2 segs left and no room? %u versus %zu"
argument_list|,
name|cm
operator|->
name|cm_sglsize
argument_list|,
name|len
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|segsleft
operator|==
literal|1
operator|&&
name|type
operator|==
name|MPI2_SGE_FLAGS_SIMPLE_ELEMENT
condition|)
block|{
comment|/* 		 * If this is a bi-directional request, need to account for that 		 * here.  Save the pre-filled sge values.  These will be used 		 * either for the 2nd SGL or for a single direction SGL.  If 		 * cm_out_len is non-zero, this is a bi-directional request, so 		 * fill in the OUT SGL first, then the IN SGL, otherwise just 		 * fill in the IN SGL.  Note that at this time, when filling in 		 * 2 SGL's for a bi-directional request, they both use the same 		 * DMA buffer (same cm command). 		 */
name|saved_buf_len
operator|=
name|le32toh
argument_list|(
name|sge
operator|->
name|FlagsLength
argument_list|)
operator|&
literal|0x00FFFFFF
expr_stmt|;
name|saved_address_low
operator|=
name|sge
operator|->
name|Address
operator|.
name|Low
expr_stmt|;
name|saved_address_high
operator|=
name|sge
operator|->
name|Address
operator|.
name|High
expr_stmt|;
if|if
condition|(
name|cm
operator|->
name|cm_out_len
condition|)
block|{
name|sge
operator|->
name|FlagsLength
operator|=
name|htole32
argument_list|(
name|cm
operator|->
name|cm_out_len
operator||
operator|(
call|(
name|uint32_t
call|)
argument_list|(
name|MPI2_SGE_FLAGS_SIMPLE_ELEMENT
operator||
name|MPI2_SGE_FLAGS_END_OF_BUFFER
operator||
name|MPI2_SGE_FLAGS_HOST_TO_IOC
operator||
name|MPI2_SGE_FLAGS_64_BIT_ADDRESSING
argument_list|)
operator|<<
name|MPI2_SGE_FLAGS_SHIFT
operator|)
argument_list|)
expr_stmt|;
name|cm
operator|->
name|cm_sglsize
operator|-=
name|len
expr_stmt|;
name|bcopy
argument_list|(
name|sgep
argument_list|,
name|cm
operator|->
name|cm_sge
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|cm
operator|->
name|cm_sge
operator|=
operator|(
name|MPI2_SGE_IO_UNION
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|cm
operator|->
name|cm_sge
operator|+
name|len
operator|)
expr_stmt|;
block|}
name|saved_buf_len
operator||=
operator|(
call|(
name|uint32_t
call|)
argument_list|(
name|MPI2_SGE_FLAGS_SIMPLE_ELEMENT
operator||
name|MPI2_SGE_FLAGS_END_OF_BUFFER
operator||
name|MPI2_SGE_FLAGS_LAST_ELEMENT
operator||
name|MPI2_SGE_FLAGS_END_OF_LIST
operator||
name|MPI2_SGE_FLAGS_64_BIT_ADDRESSING
argument_list|)
operator|<<
name|MPI2_SGE_FLAGS_SHIFT
operator|)
expr_stmt|;
if|if
condition|(
name|cm
operator|->
name|cm_flags
operator|&
name|MPS_CM_FLAGS_DATAIN
condition|)
block|{
name|saved_buf_len
operator||=
operator|(
call|(
name|uint32_t
call|)
argument_list|(
name|MPI2_SGE_FLAGS_IOC_TO_HOST
argument_list|)
operator|<<
name|MPI2_SGE_FLAGS_SHIFT
operator|)
expr_stmt|;
block|}
else|else
block|{
name|saved_buf_len
operator||=
operator|(
call|(
name|uint32_t
call|)
argument_list|(
name|MPI2_SGE_FLAGS_HOST_TO_IOC
argument_list|)
operator|<<
name|MPI2_SGE_FLAGS_SHIFT
operator|)
expr_stmt|;
block|}
name|sge
operator|->
name|FlagsLength
operator|=
name|htole32
argument_list|(
name|saved_buf_len
argument_list|)
expr_stmt|;
name|sge
operator|->
name|Address
operator|.
name|Low
operator|=
name|saved_address_low
expr_stmt|;
name|sge
operator|->
name|Address
operator|.
name|High
operator|=
name|saved_address_high
expr_stmt|;
block|}
name|cm
operator|->
name|cm_sglsize
operator|-=
name|len
expr_stmt|;
name|bcopy
argument_list|(
name|sgep
argument_list|,
name|cm
operator|->
name|cm_sge
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|cm
operator|->
name|cm_sge
operator|=
operator|(
name|MPI2_SGE_IO_UNION
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|cm
operator|->
name|cm_sge
operator|+
name|len
operator|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add one dma segment to the scatter-gather list for a command.  */
end_comment

begin_function
name|int
name|mps_add_dmaseg
parameter_list|(
name|struct
name|mps_command
modifier|*
name|cm
parameter_list|,
name|vm_paddr_t
name|pa
parameter_list|,
name|size_t
name|len
parameter_list|,
name|u_int
name|flags
parameter_list|,
name|int
name|segsleft
parameter_list|)
block|{
name|MPI2_SGE_SIMPLE64
name|sge
decl_stmt|;
comment|/* 	 * This driver always uses 64-bit address elements for simplicity. 	 */
name|bzero
argument_list|(
operator|&
name|sge
argument_list|,
sizeof|sizeof
argument_list|(
name|sge
argument_list|)
argument_list|)
expr_stmt|;
name|flags
operator||=
name|MPI2_SGE_FLAGS_SIMPLE_ELEMENT
operator||
name|MPI2_SGE_FLAGS_64_BIT_ADDRESSING
expr_stmt|;
name|sge
operator|.
name|FlagsLength
operator|=
name|htole32
argument_list|(
name|len
operator||
operator|(
name|flags
operator|<<
name|MPI2_SGE_FLAGS_SHIFT
operator|)
argument_list|)
expr_stmt|;
name|mps_from_u64
argument_list|(
name|pa
argument_list|,
operator|&
name|sge
operator|.
name|Address
argument_list|)
expr_stmt|;
return|return
operator|(
name|mps_push_sge
argument_list|(
name|cm
argument_list|,
operator|&
name|sge
argument_list|,
sizeof|sizeof
name|sge
argument_list|,
name|segsleft
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mps_data_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nsegs
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|mps_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mps_command
modifier|*
name|cm
decl_stmt|;
name|u_int
name|i
decl_stmt|,
name|dir
decl_stmt|,
name|sflags
decl_stmt|;
name|cm
operator|=
operator|(
expr|struct
name|mps_command
operator|*
operator|)
name|arg
expr_stmt|;
name|sc
operator|=
name|cm
operator|->
name|cm_sc
expr_stmt|;
comment|/* 	 * In this case, just print out a warning and let the chip tell the 	 * user they did the wrong thing. 	 */
if|if
condition|(
operator|(
name|cm
operator|->
name|cm_max_segs
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|nsegs
operator|>
name|cm
operator|->
name|cm_max_segs
operator|)
condition|)
block|{
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_ERROR
argument_list|,
literal|"%s: warning: busdma returned %d segments, "
literal|"more than the %d allowed\n"
argument_list|,
name|__func__
argument_list|,
name|nsegs
argument_list|,
name|cm
operator|->
name|cm_max_segs
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Set up DMA direction flags.  Bi-directional requests are also handled 	 * here.  In that case, both direction flags will be set. 	 */
name|sflags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cm
operator|->
name|cm_flags
operator|&
name|MPS_CM_FLAGS_SMP_PASS
condition|)
block|{
comment|/* 		 * We have to add a special case for SMP passthrough, there 		 * is no easy way to generically handle it.  The first 		 * S/G element is used for the command (therefore the 		 * direction bit needs to be set).  The second one is used 		 * for the reply.  We'll leave it to the caller to make 		 * sure we only have two buffers. 		 */
comment|/* 		 * Even though the busdma man page says it doesn't make 		 * sense to have both direction flags, it does in this case. 		 * We have one s/g element being accessed in each direction. 		 */
name|dir
operator|=
name|BUS_DMASYNC_PREWRITE
operator||
name|BUS_DMASYNC_PREREAD
expr_stmt|;
comment|/* 		 * Set the direction flag on the first buffer in the SMP 		 * passthrough request.  We'll clear it for the second one. 		 */
name|sflags
operator||=
name|MPI2_SGE_FLAGS_DIRECTION
operator||
name|MPI2_SGE_FLAGS_END_OF_BUFFER
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cm
operator|->
name|cm_flags
operator|&
name|MPS_CM_FLAGS_DATAOUT
condition|)
block|{
name|sflags
operator||=
name|MPI2_SGE_FLAGS_HOST_TO_IOC
expr_stmt|;
name|dir
operator|=
name|BUS_DMASYNC_PREWRITE
expr_stmt|;
block|}
else|else
name|dir
operator|=
name|BUS_DMASYNC_PREREAD
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsegs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|cm
operator|->
name|cm_flags
operator|&
name|MPS_CM_FLAGS_SMP_PASS
operator|)
operator|&&
operator|(
name|i
operator|!=
literal|0
operator|)
condition|)
block|{
name|sflags
operator|&=
operator|~
name|MPI2_SGE_FLAGS_DIRECTION
expr_stmt|;
block|}
name|error
operator|=
name|mps_add_dmaseg
argument_list|(
name|cm
argument_list|,
name|segs
index|[
name|i
index|]
operator|.
name|ds_addr
argument_list|,
name|segs
index|[
name|i
index|]
operator|.
name|ds_len
argument_list|,
name|sflags
argument_list|,
name|nsegs
operator|-
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
comment|/* Resource shortage, roll back! */
if|if
condition|(
name|ratecheck
argument_list|(
operator|&
name|sc
operator|->
name|lastfail
argument_list|,
operator|&
name|mps_chainfail_interval
argument_list|)
condition|)
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_INFO
argument_list|,
literal|"Out of chain frames, "
literal|"consider increasing hw.mps.max_chains.\n"
argument_list|)
expr_stmt|;
name|cm
operator|->
name|cm_flags
operator||=
name|MPS_CM_FLAGS_CHAIN_FAILED
expr_stmt|;
name|mps_complete_command
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|buffer_dmat
argument_list|,
name|cm
operator|->
name|cm_dmamap
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|mps_enqueue_request
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|mps_data_cb2
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nsegs
parameter_list|,
name|bus_size_t
name|mapsize
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|mps_data_cb
argument_list|(
name|arg
argument_list|,
name|segs
argument_list|,
name|nsegs
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This is the routine to enqueue commands ansynchronously.  * Note that the only error path here is from bus_dmamap_load(), which can  * return EINPROGRESS if it is waiting for resources.  Other than this, it's  * assumed that if you have a command in-hand, then you have enough credits  * to use it.  */
end_comment

begin_function
name|int
name|mps_map_command
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mps_command
modifier|*
name|cm
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|cm
operator|->
name|cm_flags
operator|&
name|MPS_CM_FLAGS_USE_UIO
condition|)
block|{
name|error
operator|=
name|bus_dmamap_load_uio
argument_list|(
name|sc
operator|->
name|buffer_dmat
argument_list|,
name|cm
operator|->
name|cm_dmamap
argument_list|,
operator|&
name|cm
operator|->
name|cm_uio
argument_list|,
name|mps_data_cb2
argument_list|,
name|cm
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cm
operator|->
name|cm_flags
operator|&
name|MPS_CM_FLAGS_USE_CCB
condition|)
block|{
name|error
operator|=
name|bus_dmamap_load_ccb
argument_list|(
name|sc
operator|->
name|buffer_dmat
argument_list|,
name|cm
operator|->
name|cm_dmamap
argument_list|,
name|cm
operator|->
name|cm_data
argument_list|,
name|mps_data_cb
argument_list|,
name|cm
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|cm
operator|->
name|cm_data
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|cm
operator|->
name|cm_length
operator|!=
literal|0
operator|)
condition|)
block|{
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|buffer_dmat
argument_list|,
name|cm
operator|->
name|cm_dmamap
argument_list|,
name|cm
operator|->
name|cm_data
argument_list|,
name|cm
operator|->
name|cm_length
argument_list|,
name|mps_data_cb
argument_list|,
name|cm
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Add a zero-length element as needed */
if|if
condition|(
name|cm
operator|->
name|cm_sge
operator|!=
name|NULL
condition|)
name|mps_add_dmaseg
argument_list|(
name|cm
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|mps_enqueue_request
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This is the routine to enqueue commands synchronously.  An error of  * EINPROGRESS from mps_map_command() is ignored since the command will  * be executed and enqueued automatically.  Other errors come from msleep().  */
end_comment

begin_function
name|int
name|mps_wait_command
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mps_command
modifier|*
name|cm
parameter_list|,
name|int
name|timeout
parameter_list|,
name|int
name|sleep_flag
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|rc
decl_stmt|;
name|struct
name|timeval
name|cur_time
decl_stmt|,
name|start_time
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|mps_flags
operator|&
name|MPS_FLAGS_DIAGRESET
condition|)
return|return
name|EBUSY
return|;
name|cm
operator|->
name|cm_complete
operator|=
name|NULL
expr_stmt|;
name|cm
operator|->
name|cm_flags
operator||=
name|MPS_CM_FLAGS_POLLED
expr_stmt|;
name|error
operator|=
name|mps_map_command
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|error
operator|!=
name|EINPROGRESS
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 	 * Check for context and wait for 50 mSec at a time until time has 	 * expired or the command has finished.  If msleep can't be used, need 	 * to poll. 	 */
if|if
condition|(
name|curthread
operator|->
name|td_no_sleeping
operator|!=
literal|0
condition|)
name|sleep_flag
operator|=
name|NO_SLEEP
expr_stmt|;
name|getmicrotime
argument_list|(
operator|&
name|start_time
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtx_owned
argument_list|(
operator|&
name|sc
operator|->
name|mps_mtx
argument_list|)
operator|&&
name|sleep_flag
operator|==
name|CAN_SLEEP
condition|)
block|{
name|cm
operator|->
name|cm_flags
operator||=
name|MPS_CM_FLAGS_WAKEUP
expr_stmt|;
name|error
operator|=
name|msleep
argument_list|(
name|cm
argument_list|,
operator|&
name|sc
operator|->
name|mps_mtx
argument_list|,
literal|0
argument_list|,
literal|"mpswait"
argument_list|,
name|timeout
operator|*
name|hz
argument_list|)
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
operator|(
name|cm
operator|->
name|cm_flags
operator|&
name|MPS_CM_FLAGS_COMPLETE
operator|)
operator|==
literal|0
condition|)
block|{
name|mps_intr_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sleep_flag
operator|==
name|CAN_SLEEP
condition|)
name|pause
argument_list|(
literal|"mpswait"
argument_list|,
name|hz
operator|/
literal|20
argument_list|)
expr_stmt|;
else|else
name|DELAY
argument_list|(
literal|50000
argument_list|)
expr_stmt|;
name|getmicrotime
argument_list|(
operator|&
name|cur_time
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cur_time
operator|.
name|tv_sec
operator|-
name|start_time
operator|.
name|tv_sec
operator|)
operator|>
name|timeout
condition|)
block|{
name|error
operator|=
name|EWOULDBLOCK
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|error
operator|==
name|EWOULDBLOCK
condition|)
block|{
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_FAULT
argument_list|,
literal|"Calling Reinit from %s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|rc
operator|=
name|mps_reinit
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_FAULT
argument_list|,
literal|"Reinit %s\n"
argument_list|,
operator|(
name|rc
operator|==
literal|0
operator|)
condition|?
literal|"success"
else|:
literal|"failed"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ETIMEDOUT
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The MPT driver had a verbose interface for config pages.  In this driver,  * reduce it to much simplier terms, similar to the Linux driver.  */
end_comment

begin_function
name|int
name|mps_read_config_page
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mps_config_params
modifier|*
name|params
parameter_list|)
block|{
name|MPI2_CONFIG_REQUEST
modifier|*
name|req
decl_stmt|;
name|struct
name|mps_command
modifier|*
name|cm
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|mps_flags
operator|&
name|MPS_FLAGS_BUSY
condition|)
block|{
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
name|cm
operator|=
name|mps_alloc_command
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|cm
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
name|req
operator|=
operator|(
name|MPI2_CONFIG_REQUEST
operator|*
operator|)
name|cm
operator|->
name|cm_req
expr_stmt|;
name|req
operator|->
name|Function
operator|=
name|MPI2_FUNCTION_CONFIG
expr_stmt|;
name|req
operator|->
name|Action
operator|=
name|params
operator|->
name|action
expr_stmt|;
name|req
operator|->
name|SGLFlags
operator|=
literal|0
expr_stmt|;
name|req
operator|->
name|ChainOffset
operator|=
literal|0
expr_stmt|;
name|req
operator|->
name|PageAddress
operator|=
name|params
operator|->
name|page_address
expr_stmt|;
if|if
condition|(
name|params
operator|->
name|hdr
operator|.
name|Struct
operator|.
name|PageType
operator|==
name|MPI2_CONFIG_PAGETYPE_EXTENDED
condition|)
block|{
name|MPI2_CONFIG_EXTENDED_PAGE_HEADER
modifier|*
name|hdr
decl_stmt|;
name|hdr
operator|=
operator|&
name|params
operator|->
name|hdr
operator|.
name|Ext
expr_stmt|;
name|req
operator|->
name|ExtPageType
operator|=
name|hdr
operator|->
name|ExtPageType
expr_stmt|;
name|req
operator|->
name|ExtPageLength
operator|=
name|hdr
operator|->
name|ExtPageLength
expr_stmt|;
name|req
operator|->
name|Header
operator|.
name|PageType
operator|=
name|MPI2_CONFIG_PAGETYPE_EXTENDED
expr_stmt|;
name|req
operator|->
name|Header
operator|.
name|PageLength
operator|=
literal|0
expr_stmt|;
comment|/* Must be set to zero */
name|req
operator|->
name|Header
operator|.
name|PageNumber
operator|=
name|hdr
operator|->
name|PageNumber
expr_stmt|;
name|req
operator|->
name|Header
operator|.
name|PageVersion
operator|=
name|hdr
operator|->
name|PageVersion
expr_stmt|;
block|}
else|else
block|{
name|MPI2_CONFIG_PAGE_HEADER
modifier|*
name|hdr
decl_stmt|;
name|hdr
operator|=
operator|&
name|params
operator|->
name|hdr
operator|.
name|Struct
expr_stmt|;
name|req
operator|->
name|Header
operator|.
name|PageType
operator|=
name|hdr
operator|->
name|PageType
expr_stmt|;
name|req
operator|->
name|Header
operator|.
name|PageNumber
operator|=
name|hdr
operator|->
name|PageNumber
expr_stmt|;
name|req
operator|->
name|Header
operator|.
name|PageLength
operator|=
name|hdr
operator|->
name|PageLength
expr_stmt|;
name|req
operator|->
name|Header
operator|.
name|PageVersion
operator|=
name|hdr
operator|->
name|PageVersion
expr_stmt|;
block|}
name|cm
operator|->
name|cm_data
operator|=
name|params
operator|->
name|buffer
expr_stmt|;
name|cm
operator|->
name|cm_length
operator|=
name|params
operator|->
name|length
expr_stmt|;
if|if
condition|(
name|cm
operator|->
name|cm_data
operator|!=
name|NULL
condition|)
block|{
name|cm
operator|->
name|cm_sge
operator|=
operator|&
name|req
operator|->
name|PageBufferSGE
expr_stmt|;
name|cm
operator|->
name|cm_sglsize
operator|=
sizeof|sizeof
argument_list|(
name|MPI2_SGE_IO_UNION
argument_list|)
expr_stmt|;
name|cm
operator|->
name|cm_flags
operator|=
name|MPS_CM_FLAGS_SGE_SIMPLE
operator||
name|MPS_CM_FLAGS_DATAIN
expr_stmt|;
block|}
else|else
name|cm
operator|->
name|cm_sge
operator|=
name|NULL
expr_stmt|;
name|cm
operator|->
name|cm_desc
operator|.
name|Default
operator|.
name|RequestFlags
operator|=
name|MPI2_REQ_DESCRIPT_FLAGS_DEFAULT_TYPE
expr_stmt|;
name|cm
operator|->
name|cm_complete_data
operator|=
name|params
expr_stmt|;
if|if
condition|(
name|params
operator|->
name|callback
operator|!=
name|NULL
condition|)
block|{
name|cm
operator|->
name|cm_complete
operator|=
name|mps_config_complete
expr_stmt|;
return|return
operator|(
name|mps_map_command
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
operator|)
return|;
block|}
else|else
block|{
name|error
operator|=
name|mps_wait_command
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|,
literal|0
argument_list|,
name|CAN_SLEEP
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_FAULT
argument_list|,
literal|"Error %d reading config page\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|mps_free_command
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|mps_config_complete
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|mps_write_config_page
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mps_config_params
modifier|*
name|params
parameter_list|)
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mps_config_complete
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mps_command
modifier|*
name|cm
parameter_list|)
block|{
name|MPI2_CONFIG_REPLY
modifier|*
name|reply
decl_stmt|;
name|struct
name|mps_config_params
modifier|*
name|params
decl_stmt|;
name|MPS_FUNCTRACE
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|params
operator|=
name|cm
operator|->
name|cm_complete_data
expr_stmt|;
if|if
condition|(
name|cm
operator|->
name|cm_data
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|buffer_dmat
argument_list|,
name|cm
operator|->
name|cm_dmamap
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|buffer_dmat
argument_list|,
name|cm
operator|->
name|cm_dmamap
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * XXX KDM need to do more error recovery?  This results in the 	 * device in question not getting probed. 	 */
if|if
condition|(
operator|(
name|cm
operator|->
name|cm_flags
operator|&
name|MPS_CM_FLAGS_ERROR_MASK
operator|)
operator|!=
literal|0
condition|)
block|{
name|params
operator|->
name|status
operator|=
name|MPI2_IOCSTATUS_BUSY
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|reply
operator|=
operator|(
name|MPI2_CONFIG_REPLY
operator|*
operator|)
name|cm
operator|->
name|cm_reply
expr_stmt|;
if|if
condition|(
name|reply
operator|==
name|NULL
condition|)
block|{
name|params
operator|->
name|status
operator|=
name|MPI2_IOCSTATUS_BUSY
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|params
operator|->
name|status
operator|=
name|reply
operator|->
name|IOCStatus
expr_stmt|;
if|if
condition|(
name|params
operator|->
name|hdr
operator|.
name|Struct
operator|.
name|PageType
operator|==
name|MPI2_CONFIG_PAGETYPE_EXTENDED
condition|)
block|{
name|params
operator|->
name|hdr
operator|.
name|Ext
operator|.
name|ExtPageType
operator|=
name|reply
operator|->
name|ExtPageType
expr_stmt|;
name|params
operator|->
name|hdr
operator|.
name|Ext
operator|.
name|ExtPageLength
operator|=
name|reply
operator|->
name|ExtPageLength
expr_stmt|;
name|params
operator|->
name|hdr
operator|.
name|Ext
operator|.
name|PageType
operator|=
name|reply
operator|->
name|Header
operator|.
name|PageType
expr_stmt|;
name|params
operator|->
name|hdr
operator|.
name|Ext
operator|.
name|PageNumber
operator|=
name|reply
operator|->
name|Header
operator|.
name|PageNumber
expr_stmt|;
name|params
operator|->
name|hdr
operator|.
name|Ext
operator|.
name|PageVersion
operator|=
name|reply
operator|->
name|Header
operator|.
name|PageVersion
expr_stmt|;
block|}
else|else
block|{
name|params
operator|->
name|hdr
operator|.
name|Struct
operator|.
name|PageType
operator|=
name|reply
operator|->
name|Header
operator|.
name|PageType
expr_stmt|;
name|params
operator|->
name|hdr
operator|.
name|Struct
operator|.
name|PageNumber
operator|=
name|reply
operator|->
name|Header
operator|.
name|PageNumber
expr_stmt|;
name|params
operator|->
name|hdr
operator|.
name|Struct
operator|.
name|PageLength
operator|=
name|reply
operator|->
name|Header
operator|.
name|PageLength
expr_stmt|;
name|params
operator|->
name|hdr
operator|.
name|Struct
operator|.
name|PageVersion
operator|=
name|reply
operator|->
name|Header
operator|.
name|PageVersion
expr_stmt|;
block|}
name|done
label|:
name|mps_free_command
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
if|if
condition|(
name|params
operator|->
name|callback
operator|!=
name|NULL
condition|)
name|params
operator|->
name|callback
argument_list|(
name|sc
argument_list|,
name|params
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

end_unit

