begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2009 Yahoo! Inc.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Communications core for LSI MPT2 */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/selinfo.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/bio.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_all.h>
end_include

begin_include
include|#
directive|include
file|<dev/mps/mpi/mpi2_type.h>
end_include

begin_include
include|#
directive|include
file|<dev/mps/mpi/mpi2.h>
end_include

begin_include
include|#
directive|include
file|<dev/mps/mpi/mpi2_ioc.h>
end_include

begin_include
include|#
directive|include
file|<dev/mps/mpi/mpi2_cnfg.h>
end_include

begin_include
include|#
directive|include
file|<dev/mps/mpsvar.h>
end_include

begin_include
include|#
directive|include
file|<dev/mps/mps_table.h>
end_include

begin_function_decl
specifier|static
name|void
name|mps_startup
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mps_startup_complete
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mps_command
modifier|*
name|cm
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mps_send_iocinit
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mps_attach_log
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mps_dispatch_event
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|uintptr_t
name|data
parameter_list|,
name|MPI2_EVENT_NOTIFICATION_REPLY
modifier|*
name|reply
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mps_config_complete
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mps_command
modifier|*
name|cm
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mps_periodic
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_hw
argument_list|,
name|OID_AUTO
argument_list|,
name|mps
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"MPS Driver Parameters"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_MPT2
argument_list|,
literal|"mps"
argument_list|,
literal|"mpt2 driver memory"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Do a "Diagnostic Reset" aka a hard reset.  This should get the chip out of  * any state and back to its initialization state machine.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|mpt2_reset_magic
index|[]
init|=
block|{
literal|0x00
block|,
literal|0x0f
block|,
literal|0x04
block|,
literal|0x0b
block|,
literal|0x02
block|,
literal|0x07
block|,
literal|0x0d
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|mps_hard_reset
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|reg
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|,
name|tries
init|=
literal|0
decl_stmt|;
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_TRACE
argument_list|,
literal|"%s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* Clear any pending interrupts */
name|mps_regwrite
argument_list|(
name|sc
argument_list|,
name|MPI2_HOST_INTERRUPT_STATUS_OFFSET
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
comment|/* Push the magic sequence */
name|error
operator|=
name|ETIMEDOUT
expr_stmt|;
while|while
condition|(
name|tries
operator|++
operator|<
literal|20
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|mpt2_reset_magic
argument_list|)
condition|;
name|i
operator|++
control|)
name|mps_regwrite
argument_list|(
name|sc
argument_list|,
name|MPI2_WRITE_SEQUENCE_OFFSET
argument_list|,
name|mpt2_reset_magic
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|reg
operator|=
name|mps_regread
argument_list|(
name|sc
argument_list|,
name|MPI2_HOST_DIAGNOSTIC_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|&
name|MPI2_DIAG_DIAG_WRITE_ENABLE
condition|)
block|{
name|error
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Send the actual reset.  XXX need to refresh the reg? */
name|mps_regwrite
argument_list|(
name|sc
argument_list|,
name|MPI2_HOST_DIAGNOSTIC_OFFSET
argument_list|,
name|reg
operator||
name|MPI2_DIAG_RESET_ADAPTER
argument_list|)
expr_stmt|;
comment|/* Wait up to 300 seconds in 50ms intervals */
name|error
operator|=
name|ETIMEDOUT
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|60000
condition|;
name|i
operator|++
control|)
block|{
name|DELAY
argument_list|(
literal|50000
argument_list|)
expr_stmt|;
name|reg
operator|=
name|mps_regread
argument_list|(
name|sc
argument_list|,
name|MPI2_DOORBELL_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|reg
operator|&
name|MPI2_IOC_STATE_MASK
operator|)
operator|!=
name|MPI2_IOC_STATE_RESET
condition|)
block|{
name|error
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|mps_regwrite
argument_list|(
name|sc
argument_list|,
name|MPI2_WRITE_SEQUENCE_OFFSET
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mps_soft_reset
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|)
block|{
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_TRACE
argument_list|,
literal|"%s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|mps_regwrite
argument_list|(
name|sc
argument_list|,
name|MPI2_DOORBELL_OFFSET
argument_list|,
name|MPI2_FUNCTION_IOC_MESSAGE_UNIT_RESET
operator|<<
name|MPI2_DOORBELL_FUNCTION_SHIFT
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|50000
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mps_transition_ready
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|reg
decl_stmt|,
name|state
decl_stmt|;
name|int
name|error
decl_stmt|,
name|tries
init|=
literal|0
decl_stmt|;
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_TRACE
argument_list|,
literal|"%s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|tries
operator|++
operator|<
literal|5
condition|)
block|{
name|reg
operator|=
name|mps_regread
argument_list|(
name|sc
argument_list|,
name|MPI2_DOORBELL_OFFSET
argument_list|)
expr_stmt|;
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_INFO
argument_list|,
literal|"Doorbell= 0x%x\n"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* 		 * Ensure the IOC is ready to talk.  If it's not, try 		 * resetting it. 		 */
if|if
condition|(
name|reg
operator|&
name|MPI2_DOORBELL_USED
condition|)
block|{
name|mps_hard_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|50000
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Is the adapter owned by another peer? */
if|if
condition|(
operator|(
name|reg
operator|&
name|MPI2_DOORBELL_WHO_INIT_MASK
operator|)
operator|==
operator|(
name|MPI2_WHOINIT_PCI_PEER
operator|<<
name|MPI2_DOORBELL_WHO_INIT_SHIFT
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mps_dev
argument_list|,
literal|"IOC is under the control "
literal|"of another peer host, aborting initialization.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|state
operator|=
name|reg
operator|&
name|MPI2_IOC_STATE_MASK
expr_stmt|;
if|if
condition|(
name|state
operator|==
name|MPI2_IOC_STATE_READY
condition|)
block|{
comment|/* Ready to go! */
name|error
operator|=
literal|0
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|state
operator|==
name|MPI2_IOC_STATE_FAULT
condition|)
block|{
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_INFO
argument_list|,
literal|"IOC in fault state 0x%x\n"
argument_list|,
name|state
operator|&
name|MPI2_DOORBELL_FAULT_CODE_MASK
argument_list|)
expr_stmt|;
name|mps_hard_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|state
operator|==
name|MPI2_IOC_STATE_OPERATIONAL
condition|)
block|{
comment|/* Need to take ownership */
name|mps_soft_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|state
operator|==
name|MPI2_IOC_STATE_RESET
condition|)
block|{
comment|/* Wait a bit, IOC might be in transition */
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_FAULT
argument_list|,
literal|"IOC in unexpected reset state\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_FAULT
argument_list|,
literal|"IOC in unknown state 0x%x\n"
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
comment|/* Wait 50ms for things to settle down. */
name|DELAY
argument_list|(
literal|50000
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|mps_dev
argument_list|,
literal|"Cannot transition IOC to ready\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mps_transition_operational
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|reg
decl_stmt|,
name|state
decl_stmt|;
name|int
name|error
decl_stmt|;
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_TRACE
argument_list|,
literal|"%s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|reg
operator|=
name|mps_regread
argument_list|(
name|sc
argument_list|,
name|MPI2_DOORBELL_OFFSET
argument_list|)
expr_stmt|;
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_INFO
argument_list|,
literal|"Doorbell= 0x%x\n"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|state
operator|=
name|reg
operator|&
name|MPI2_IOC_STATE_MASK
expr_stmt|;
if|if
condition|(
name|state
operator|!=
name|MPI2_IOC_STATE_READY
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|mps_transition_ready
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
name|mps_send_iocinit
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Wait for the chip to ACK a word that we've put into its FIFO */
end_comment

begin_function
specifier|static
name|int
name|mps_wait_db_ack
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|retry
decl_stmt|;
for|for
control|(
name|retry
operator|=
literal|0
init|;
name|retry
operator|<
name|MPS_DB_MAX_WAIT
condition|;
name|retry
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|mps_regread
argument_list|(
name|sc
argument_list|,
name|MPI2_HOST_INTERRUPT_STATUS_OFFSET
argument_list|)
operator|&
name|MPI2_HIS_SYS2IOC_DB_STATUS
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|DELAY
argument_list|(
literal|2000
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ETIMEDOUT
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Wait for the chip to signal that the next word in its FIFO can be fetched */
end_comment

begin_function
specifier|static
name|int
name|mps_wait_db_int
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|retry
decl_stmt|;
for|for
control|(
name|retry
operator|=
literal|0
init|;
name|retry
operator|<
name|MPS_DB_MAX_WAIT
condition|;
name|retry
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|mps_regread
argument_list|(
name|sc
argument_list|,
name|MPI2_HOST_INTERRUPT_STATUS_OFFSET
argument_list|)
operator|&
name|MPI2_HIS_IOC2SYS_DB_STATUS
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|DELAY
argument_list|(
literal|2000
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ETIMEDOUT
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Step through the synchronous command state machine, i.e. "Doorbell mode" */
end_comment

begin_function
specifier|static
name|int
name|mps_request_sync
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|req
parameter_list|,
name|MPI2_DEFAULT_REPLY
modifier|*
name|reply
parameter_list|,
name|int
name|req_sz
parameter_list|,
name|int
name|reply_sz
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
name|uint32_t
modifier|*
name|data32
decl_stmt|;
name|uint16_t
modifier|*
name|data16
decl_stmt|;
name|int
name|i
decl_stmt|,
name|count
decl_stmt|,
name|ioc_sz
decl_stmt|,
name|residual
decl_stmt|;
comment|/* Step 1 */
name|mps_regwrite
argument_list|(
name|sc
argument_list|,
name|MPI2_HOST_INTERRUPT_STATUS_OFFSET
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
comment|/* Step 2 */
if|if
condition|(
name|mps_regread
argument_list|(
name|sc
argument_list|,
name|MPI2_DOORBELL_OFFSET
argument_list|)
operator|&
name|MPI2_DOORBELL_USED
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
comment|/* Step 3 	 * Announce that a message is coming through the doorbell.  Messages 	 * are pushed at 32bit words, so round up if needed. 	 */
name|count
operator|=
operator|(
name|req_sz
operator|+
literal|3
operator|)
operator|/
literal|4
expr_stmt|;
name|mps_regwrite
argument_list|(
name|sc
argument_list|,
name|MPI2_DOORBELL_OFFSET
argument_list|,
operator|(
name|MPI2_FUNCTION_HANDSHAKE
operator|<<
name|MPI2_DOORBELL_FUNCTION_SHIFT
operator|)
operator||
operator|(
name|count
operator|<<
name|MPI2_DOORBELL_ADD_DWORDS_SHIFT
operator|)
argument_list|)
expr_stmt|;
comment|/* Step 4 */
if|if
condition|(
name|mps_wait_db_int
argument_list|(
name|sc
argument_list|)
operator|||
operator|(
name|mps_regread
argument_list|(
name|sc
argument_list|,
name|MPI2_DOORBELL_OFFSET
argument_list|)
operator|&
name|MPI2_DOORBELL_USED
operator|)
operator|==
literal|0
condition|)
block|{
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_FAULT
argument_list|,
literal|"Doorbell failed to activate\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|mps_regwrite
argument_list|(
name|sc
argument_list|,
name|MPI2_HOST_INTERRUPT_STATUS_OFFSET
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mps_wait_db_ack
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_FAULT
argument_list|,
literal|"Doorbell handshake failed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Step 5 */
comment|/* Clock out the message data synchronously in 32-bit dwords*/
name|data32
operator|=
operator|(
name|uint32_t
operator|*
operator|)
name|req
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|mps_regwrite
argument_list|(
name|sc
argument_list|,
name|MPI2_DOORBELL_OFFSET
argument_list|,
name|data32
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|mps_wait_db_ack
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_FAULT
argument_list|,
literal|"Timeout while writing doorbell\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
block|}
comment|/* Step 6 */
comment|/* Clock in the reply in 16-bit words.  The total length of the 	 * message is always in the 4th byte, so clock out the first 2 words 	 * manually, then loop the rest. 	 */
name|data16
operator|=
operator|(
name|uint16_t
operator|*
operator|)
name|reply
expr_stmt|;
if|if
condition|(
name|mps_wait_db_int
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_FAULT
argument_list|,
literal|"Timeout reading doorbell 0\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|data16
index|[
literal|0
index|]
operator|=
name|mps_regread
argument_list|(
name|sc
argument_list|,
name|MPI2_DOORBELL_OFFSET
argument_list|)
operator|&
name|MPI2_DOORBELL_DATA_MASK
expr_stmt|;
name|mps_regwrite
argument_list|(
name|sc
argument_list|,
name|MPI2_HOST_INTERRUPT_STATUS_OFFSET
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mps_wait_db_int
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_FAULT
argument_list|,
literal|"Timeout reading doorbell 1\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|data16
index|[
literal|1
index|]
operator|=
name|mps_regread
argument_list|(
name|sc
argument_list|,
name|MPI2_DOORBELL_OFFSET
argument_list|)
operator|&
name|MPI2_DOORBELL_DATA_MASK
expr_stmt|;
name|mps_regwrite
argument_list|(
name|sc
argument_list|,
name|MPI2_HOST_INTERRUPT_STATUS_OFFSET
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
comment|/* Number of 32bit words in the message */
name|ioc_sz
operator|=
name|reply
operator|->
name|MsgLength
expr_stmt|;
comment|/* 	 * Figure out how many 16bit words to clock in without overrunning. 	 * The precision loss with dividing reply_sz can safely be 	 * ignored because the messages can only be multiples of 32bits. 	 */
name|residual
operator|=
literal|0
expr_stmt|;
name|count
operator|=
name|MIN
argument_list|(
operator|(
name|reply_sz
operator|/
literal|4
operator|)
argument_list|,
name|ioc_sz
argument_list|)
operator|*
literal|2
expr_stmt|;
if|if
condition|(
name|count
operator|<
name|ioc_sz
operator|*
literal|2
condition|)
block|{
name|residual
operator|=
name|ioc_sz
operator|*
literal|2
operator|-
name|count
expr_stmt|;
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_FAULT
argument_list|,
literal|"Driver error, throwing away %d "
literal|"residual message words\n"
argument_list|,
name|residual
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|mps_wait_db_int
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_FAULT
argument_list|,
literal|"Timeout reading doorbell %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|data16
index|[
name|i
index|]
operator|=
name|mps_regread
argument_list|(
name|sc
argument_list|,
name|MPI2_DOORBELL_OFFSET
argument_list|)
operator|&
name|MPI2_DOORBELL_DATA_MASK
expr_stmt|;
name|mps_regwrite
argument_list|(
name|sc
argument_list|,
name|MPI2_HOST_INTERRUPT_STATUS_OFFSET
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Pull out residual words that won't fit into the provided buffer. 	 * This keeps the chip from hanging due to a driver programming 	 * error. 	 */
while|while
condition|(
name|residual
operator|--
condition|)
block|{
if|if
condition|(
name|mps_wait_db_int
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_FAULT
argument_list|,
literal|"Timeout reading doorbell\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|mps_regread
argument_list|(
name|sc
argument_list|,
name|MPI2_DOORBELL_OFFSET
argument_list|)
expr_stmt|;
name|mps_regwrite
argument_list|(
name|sc
argument_list|,
name|MPI2_HOST_INTERRUPT_STATUS_OFFSET
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
block|}
comment|/* Step 7 */
if|if
condition|(
name|mps_wait_db_int
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_FAULT
argument_list|,
literal|"Timeout waiting to exit doorbell\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
name|mps_regread
argument_list|(
name|sc
argument_list|,
name|MPI2_DOORBELL_OFFSET
argument_list|)
operator|&
name|MPI2_DOORBELL_USED
condition|)
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_FAULT
argument_list|,
literal|"Warning, doorbell still active\n"
argument_list|)
expr_stmt|;
name|mps_regwrite
argument_list|(
name|sc
argument_list|,
name|MPI2_HOST_INTERRUPT_STATUS_OFFSET
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|mps_enqueue_request
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mps_command
modifier|*
name|cm
parameter_list|)
block|{
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_TRACE
argument_list|,
literal|"%s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|mps_regwrite
argument_list|(
name|sc
argument_list|,
name|MPI2_REQUEST_DESCRIPTOR_POST_LOW_OFFSET
argument_list|,
name|cm
operator|->
name|cm_desc
operator|.
name|Words
operator|.
name|Low
argument_list|)
expr_stmt|;
name|mps_regwrite
argument_list|(
name|sc
argument_list|,
name|MPI2_REQUEST_DESCRIPTOR_POST_HIGH_OFFSET
argument_list|,
name|cm
operator|->
name|cm_desc
operator|.
name|Words
operator|.
name|High
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|mps_request_polled
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mps_command
modifier|*
name|cm
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|timeout
init|=
literal|0
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|cm
operator|->
name|cm_flags
operator||=
name|MPS_CM_FLAGS_POLLED
expr_stmt|;
name|cm
operator|->
name|cm_complete
operator|=
name|NULL
expr_stmt|;
name|mps_map_command
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|cm
operator|->
name|cm_flags
operator|&
name|MPS_CM_FLAGS_COMPLETE
operator|)
operator|==
literal|0
condition|)
block|{
name|mps_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|50
operator|*
literal|1000
argument_list|)
expr_stmt|;
if|if
condition|(
name|timeout
operator|++
operator|>
literal|1000
condition|)
block|{
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_FAULT
argument_list|,
literal|"polling failed\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ETIMEDOUT
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Just the FACTS, ma'am.  */
end_comment

begin_function
specifier|static
name|int
name|mps_get_iocfacts
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|MPI2_IOC_FACTS_REPLY
modifier|*
name|facts
parameter_list|)
block|{
name|MPI2_DEFAULT_REPLY
modifier|*
name|reply
decl_stmt|;
name|MPI2_IOC_FACTS_REQUEST
name|request
decl_stmt|;
name|int
name|error
decl_stmt|,
name|req_sz
decl_stmt|,
name|reply_sz
decl_stmt|;
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_TRACE
argument_list|,
literal|"%s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|req_sz
operator|=
sizeof|sizeof
argument_list|(
name|MPI2_IOC_FACTS_REQUEST
argument_list|)
expr_stmt|;
name|reply_sz
operator|=
sizeof|sizeof
argument_list|(
name|MPI2_IOC_FACTS_REPLY
argument_list|)
expr_stmt|;
name|reply
operator|=
operator|(
name|MPI2_DEFAULT_REPLY
operator|*
operator|)
name|facts
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|request
argument_list|,
name|req_sz
argument_list|)
expr_stmt|;
name|request
operator|.
name|Function
operator|=
name|MPI2_FUNCTION_IOC_FACTS
expr_stmt|;
name|error
operator|=
name|mps_request_sync
argument_list|(
name|sc
argument_list|,
operator|&
name|request
argument_list|,
name|reply
argument_list|,
name|req_sz
argument_list|,
name|reply_sz
argument_list|,
literal|5
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mps_get_portfacts
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|MPI2_PORT_FACTS_REPLY
modifier|*
name|facts
parameter_list|,
name|int
name|port
parameter_list|)
block|{
name|MPI2_PORT_FACTS_REQUEST
modifier|*
name|request
decl_stmt|;
name|MPI2_PORT_FACTS_REPLY
modifier|*
name|reply
decl_stmt|;
name|struct
name|mps_command
modifier|*
name|cm
decl_stmt|;
name|int
name|error
decl_stmt|;
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_TRACE
argument_list|,
literal|"%s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cm
operator|=
name|mps_alloc_command
argument_list|(
name|sc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|request
operator|=
operator|(
name|MPI2_PORT_FACTS_REQUEST
operator|*
operator|)
name|cm
operator|->
name|cm_req
expr_stmt|;
name|request
operator|->
name|Function
operator|=
name|MPI2_FUNCTION_PORT_FACTS
expr_stmt|;
name|request
operator|->
name|PortNumber
operator|=
name|port
expr_stmt|;
name|cm
operator|->
name|cm_desc
operator|.
name|Default
operator|.
name|RequestFlags
operator|=
name|MPI2_REQ_DESCRIPT_FLAGS_DEFAULT_TYPE
expr_stmt|;
name|cm
operator|->
name|cm_data
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|mps_request_polled
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
name|reply
operator|=
operator|(
name|MPI2_PORT_FACTS_REPLY
operator|*
operator|)
name|cm
operator|->
name|cm_reply
expr_stmt|;
if|if
condition|(
operator|(
name|reply
operator|->
name|IOCStatus
operator|&
name|MPI2_IOCSTATUS_MASK
operator|)
operator|!=
name|MPI2_IOCSTATUS_SUCCESS
condition|)
name|error
operator|=
name|ENXIO
expr_stmt|;
name|bcopy
argument_list|(
name|reply
argument_list|,
name|facts
argument_list|,
sizeof|sizeof
argument_list|(
name|MPI2_PORT_FACTS_REPLY
argument_list|)
argument_list|)
expr_stmt|;
name|mps_free_command
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mps_send_iocinit
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|)
block|{
name|MPI2_IOC_INIT_REQUEST
name|init
decl_stmt|;
name|MPI2_DEFAULT_REPLY
name|reply
decl_stmt|;
name|int
name|req_sz
decl_stmt|,
name|reply_sz
decl_stmt|,
name|error
decl_stmt|;
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_TRACE
argument_list|,
literal|"%s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|req_sz
operator|=
sizeof|sizeof
argument_list|(
name|MPI2_IOC_INIT_REQUEST
argument_list|)
expr_stmt|;
name|reply_sz
operator|=
sizeof|sizeof
argument_list|(
name|MPI2_IOC_INIT_REPLY
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|init
argument_list|,
name|req_sz
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|reply
argument_list|,
name|reply_sz
argument_list|)
expr_stmt|;
comment|/* 	 * Fill in the init block.  Note that most addresses are 	 * deliberately in the lower 32bits of memory.  This is a micro- 	 * optimzation for PCI/PCIX, though it's not clear if it helps PCIe. 	 */
name|init
operator|.
name|Function
operator|=
name|MPI2_FUNCTION_IOC_INIT
expr_stmt|;
name|init
operator|.
name|WhoInit
operator|=
name|MPI2_WHOINIT_HOST_DRIVER
expr_stmt|;
name|init
operator|.
name|MsgVersion
operator|=
name|MPI2_VERSION
expr_stmt|;
name|init
operator|.
name|HeaderVersion
operator|=
name|MPI2_HEADER_VERSION
expr_stmt|;
name|init
operator|.
name|SystemRequestFrameSize
operator|=
name|sc
operator|->
name|facts
operator|->
name|IOCRequestFrameSize
expr_stmt|;
name|init
operator|.
name|ReplyDescriptorPostQueueDepth
operator|=
name|sc
operator|->
name|pqdepth
expr_stmt|;
name|init
operator|.
name|ReplyFreeQueueDepth
operator|=
name|sc
operator|->
name|fqdepth
expr_stmt|;
name|init
operator|.
name|SenseBufferAddressHigh
operator|=
literal|0
expr_stmt|;
name|init
operator|.
name|SystemReplyAddressHigh
operator|=
literal|0
expr_stmt|;
name|init
operator|.
name|SystemRequestFrameBaseAddress
operator|.
name|High
operator|=
literal|0
expr_stmt|;
name|init
operator|.
name|SystemRequestFrameBaseAddress
operator|.
name|Low
operator|=
operator|(
name|uint32_t
operator|)
name|sc
operator|->
name|req_busaddr
expr_stmt|;
name|init
operator|.
name|ReplyDescriptorPostQueueAddress
operator|.
name|High
operator|=
literal|0
expr_stmt|;
name|init
operator|.
name|ReplyDescriptorPostQueueAddress
operator|.
name|Low
operator|=
operator|(
name|uint32_t
operator|)
name|sc
operator|->
name|post_busaddr
expr_stmt|;
name|init
operator|.
name|ReplyFreeQueueAddress
operator|.
name|High
operator|=
literal|0
expr_stmt|;
name|init
operator|.
name|ReplyFreeQueueAddress
operator|.
name|Low
operator|=
operator|(
name|uint32_t
operator|)
name|sc
operator|->
name|free_busaddr
expr_stmt|;
name|init
operator|.
name|TimeStamp
operator|.
name|High
operator|=
literal|0
expr_stmt|;
name|init
operator|.
name|TimeStamp
operator|.
name|Low
operator|=
operator|(
name|uint32_t
operator|)
name|time_uptime
expr_stmt|;
name|error
operator|=
name|mps_request_sync
argument_list|(
name|sc
argument_list|,
operator|&
name|init
argument_list|,
operator|&
name|reply
argument_list|,
name|req_sz
argument_list|,
name|reply_sz
argument_list|,
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|reply
operator|.
name|IOCStatus
operator|&
name|MPI2_IOCSTATUS_MASK
operator|)
operator|!=
name|MPI2_IOCSTATUS_SUCCESS
condition|)
name|error
operator|=
name|ENXIO
expr_stmt|;
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_INFO
argument_list|,
literal|"IOCInit status= 0x%x\n"
argument_list|,
name|reply
operator|.
name|IOCStatus
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mps_send_portenable
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|)
block|{
name|MPI2_PORT_ENABLE_REQUEST
modifier|*
name|request
decl_stmt|;
name|struct
name|mps_command
modifier|*
name|cm
decl_stmt|;
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_TRACE
argument_list|,
literal|"%s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cm
operator|=
name|mps_alloc_command
argument_list|(
name|sc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|request
operator|=
operator|(
name|MPI2_PORT_ENABLE_REQUEST
operator|*
operator|)
name|cm
operator|->
name|cm_req
expr_stmt|;
name|request
operator|->
name|Function
operator|=
name|MPI2_FUNCTION_PORT_ENABLE
expr_stmt|;
name|request
operator|->
name|MsgFlags
operator|=
literal|0
expr_stmt|;
name|request
operator|->
name|VP_ID
operator|=
literal|0
expr_stmt|;
name|cm
operator|->
name|cm_desc
operator|.
name|Default
operator|.
name|RequestFlags
operator|=
name|MPI2_REQ_DESCRIPT_FLAGS_DEFAULT_TYPE
expr_stmt|;
name|cm
operator|->
name|cm_complete
operator|=
name|mps_startup_complete
expr_stmt|;
name|mps_enqueue_request
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mps_send_mur
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* Placeholder */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|mps_memaddr_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nsegs
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|bus_addr_t
modifier|*
name|addr
decl_stmt|;
name|addr
operator|=
name|arg
expr_stmt|;
operator|*
name|addr
operator|=
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|mps_alloc_queues
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|)
block|{
name|bus_addr_t
name|queues_busaddr
decl_stmt|;
name|uint8_t
modifier|*
name|queues
decl_stmt|;
name|int
name|qsize
decl_stmt|,
name|fqsize
decl_stmt|,
name|pqsize
decl_stmt|;
comment|/* 	 * The reply free queue contains 4 byte entries in multiples of 16 and 	 * aligned on a 16 byte boundary. There must always be an unused entry. 	 * This queue supplies fresh reply frames for the firmware to use. 	 * 	 * The reply descriptor post queue contains 8 byte entries in 	 * multiples of 16 and aligned on a 16 byte boundary.  This queue 	 * contains filled-in reply frames sent from the firmware to the host. 	 * 	 * These two queues are allocated together for simplicity. 	 */
name|sc
operator|->
name|fqdepth
operator|=
name|roundup2
argument_list|(
operator|(
name|sc
operator|->
name|num_replies
operator|+
literal|1
operator|)
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|sc
operator|->
name|pqdepth
operator|=
name|roundup2
argument_list|(
operator|(
name|sc
operator|->
name|num_replies
operator|+
literal|1
operator|)
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|fqsize
operator|=
name|sc
operator|->
name|fqdepth
operator|*
literal|4
expr_stmt|;
name|pqsize
operator|=
name|sc
operator|->
name|pqdepth
operator|*
literal|8
expr_stmt|;
name|qsize
operator|=
name|fqsize
operator|+
name|pqsize
expr_stmt|;
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|mps_parent_dmat
argument_list|,
comment|/* parent */
literal|16
argument_list|,
literal|0
argument_list|,
comment|/* algnmnt, boundary */
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|qsize
argument_list|,
comment|/* maxsize */
literal|1
argument_list|,
comment|/* nsegments */
name|qsize
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* lockfunc, lockarg */
operator|&
name|sc
operator|->
name|queues_dmat
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mps_dev
argument_list|,
literal|"Cannot allocate queues DMA tag\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|sc
operator|->
name|queues_dmat
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|queues
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|sc
operator|->
name|queues_map
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mps_dev
argument_list|,
literal|"Cannot allocate queues memory\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|bzero
argument_list|(
name|queues
argument_list|,
name|qsize
argument_list|)
expr_stmt|;
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|queues_dmat
argument_list|,
name|sc
operator|->
name|queues_map
argument_list|,
name|queues
argument_list|,
name|qsize
argument_list|,
name|mps_memaddr_cb
argument_list|,
operator|&
name|queues_busaddr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|free_queue
operator|=
operator|(
name|uint32_t
operator|*
operator|)
name|queues
expr_stmt|;
name|sc
operator|->
name|free_busaddr
operator|=
name|queues_busaddr
expr_stmt|;
name|sc
operator|->
name|post_queue
operator|=
operator|(
name|MPI2_REPLY_DESCRIPTORS_UNION
operator|*
operator|)
operator|(
name|queues
operator|+
name|fqsize
operator|)
expr_stmt|;
name|sc
operator|->
name|post_busaddr
operator|=
name|queues_busaddr
operator|+
name|fqsize
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mps_alloc_replies
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|rsize
decl_stmt|,
name|num_replies
decl_stmt|;
comment|/* 	 * sc->num_replies should be one less than sc->fqdepth.  We need to 	 * allocate space for sc->fqdepth replies, but only sc->num_replies 	 * replies can be used at once. 	 */
name|num_replies
operator|=
name|max
argument_list|(
name|sc
operator|->
name|fqdepth
argument_list|,
name|sc
operator|->
name|num_replies
argument_list|)
expr_stmt|;
name|rsize
operator|=
name|sc
operator|->
name|facts
operator|->
name|ReplyFrameSize
operator|*
name|num_replies
operator|*
literal|4
expr_stmt|;
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|mps_parent_dmat
argument_list|,
comment|/* parent */
literal|4
argument_list|,
literal|0
argument_list|,
comment|/* algnmnt, boundary */
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|rsize
argument_list|,
comment|/* maxsize */
literal|1
argument_list|,
comment|/* nsegments */
name|rsize
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* lockfunc, lockarg */
operator|&
name|sc
operator|->
name|reply_dmat
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mps_dev
argument_list|,
literal|"Cannot allocate replies DMA tag\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|sc
operator|->
name|reply_dmat
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|sc
operator|->
name|reply_frames
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|sc
operator|->
name|reply_map
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mps_dev
argument_list|,
literal|"Cannot allocate replies memory\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|bzero
argument_list|(
name|sc
operator|->
name|reply_frames
argument_list|,
name|rsize
argument_list|)
expr_stmt|;
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|reply_dmat
argument_list|,
name|sc
operator|->
name|reply_map
argument_list|,
name|sc
operator|->
name|reply_frames
argument_list|,
name|rsize
argument_list|,
name|mps_memaddr_cb
argument_list|,
operator|&
name|sc
operator|->
name|reply_busaddr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mps_alloc_requests
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|mps_command
modifier|*
name|cm
decl_stmt|;
name|struct
name|mps_chain
modifier|*
name|chain
decl_stmt|;
name|int
name|i
decl_stmt|,
name|rsize
decl_stmt|,
name|nsegs
decl_stmt|;
name|rsize
operator|=
name|sc
operator|->
name|facts
operator|->
name|IOCRequestFrameSize
operator|*
name|sc
operator|->
name|num_reqs
operator|*
literal|4
expr_stmt|;
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|mps_parent_dmat
argument_list|,
comment|/* parent */
literal|16
argument_list|,
literal|0
argument_list|,
comment|/* algnmnt, boundary */
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|rsize
argument_list|,
comment|/* maxsize */
literal|1
argument_list|,
comment|/* nsegments */
name|rsize
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* lockfunc, lockarg */
operator|&
name|sc
operator|->
name|req_dmat
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mps_dev
argument_list|,
literal|"Cannot allocate request DMA tag\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|sc
operator|->
name|req_dmat
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|sc
operator|->
name|req_frames
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|sc
operator|->
name|req_map
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mps_dev
argument_list|,
literal|"Cannot allocate request memory\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|bzero
argument_list|(
name|sc
operator|->
name|req_frames
argument_list|,
name|rsize
argument_list|)
expr_stmt|;
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|req_dmat
argument_list|,
name|sc
operator|->
name|req_map
argument_list|,
name|sc
operator|->
name|req_frames
argument_list|,
name|rsize
argument_list|,
name|mps_memaddr_cb
argument_list|,
operator|&
name|sc
operator|->
name|req_busaddr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rsize
operator|=
name|sc
operator|->
name|facts
operator|->
name|IOCRequestFrameSize
operator|*
name|MPS_CHAIN_FRAMES
operator|*
literal|4
expr_stmt|;
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|mps_parent_dmat
argument_list|,
comment|/* parent */
literal|16
argument_list|,
literal|0
argument_list|,
comment|/* algnmnt, boundary */
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|rsize
argument_list|,
comment|/* maxsize */
literal|1
argument_list|,
comment|/* nsegments */
name|rsize
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* lockfunc, lockarg */
operator|&
name|sc
operator|->
name|chain_dmat
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mps_dev
argument_list|,
literal|"Cannot allocate chain DMA tag\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|sc
operator|->
name|chain_dmat
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|sc
operator|->
name|chain_frames
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|sc
operator|->
name|chain_map
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mps_dev
argument_list|,
literal|"Cannot allocate chain memory\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|bzero
argument_list|(
name|sc
operator|->
name|chain_frames
argument_list|,
name|rsize
argument_list|)
expr_stmt|;
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|chain_dmat
argument_list|,
name|sc
operator|->
name|chain_map
argument_list|,
name|sc
operator|->
name|chain_frames
argument_list|,
name|rsize
argument_list|,
name|mps_memaddr_cb
argument_list|,
operator|&
name|sc
operator|->
name|chain_busaddr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rsize
operator|=
name|MPS_SENSE_LEN
operator|*
name|sc
operator|->
name|num_reqs
expr_stmt|;
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|mps_parent_dmat
argument_list|,
comment|/* parent */
literal|1
argument_list|,
literal|0
argument_list|,
comment|/* algnmnt, boundary */
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|rsize
argument_list|,
comment|/* maxsize */
literal|1
argument_list|,
comment|/* nsegments */
name|rsize
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* lockfunc, lockarg */
operator|&
name|sc
operator|->
name|sense_dmat
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mps_dev
argument_list|,
literal|"Cannot allocate sense DMA tag\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|sc
operator|->
name|sense_dmat
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|sc
operator|->
name|sense_frames
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|sc
operator|->
name|sense_map
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mps_dev
argument_list|,
literal|"Cannot allocate sense memory\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|bzero
argument_list|(
name|sc
operator|->
name|sense_frames
argument_list|,
name|rsize
argument_list|)
expr_stmt|;
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|sense_dmat
argument_list|,
name|sc
operator|->
name|sense_map
argument_list|,
name|sc
operator|->
name|sense_frames
argument_list|,
name|rsize
argument_list|,
name|mps_memaddr_cb
argument_list|,
operator|&
name|sc
operator|->
name|sense_busaddr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|chains
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|mps_chain
argument_list|)
operator|*
name|MPS_CHAIN_FRAMES
argument_list|,
name|M_MPT2
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MPS_CHAIN_FRAMES
condition|;
name|i
operator|++
control|)
block|{
name|chain
operator|=
operator|&
name|sc
operator|->
name|chains
index|[
name|i
index|]
expr_stmt|;
name|chain
operator|->
name|chain
operator|=
operator|(
name|MPI2_SGE_IO_UNION
operator|*
operator|)
operator|(
name|sc
operator|->
name|chain_frames
operator|+
name|i
operator|*
name|sc
operator|->
name|facts
operator|->
name|IOCRequestFrameSize
operator|*
literal|4
operator|)
expr_stmt|;
name|chain
operator|->
name|chain_busaddr
operator|=
name|sc
operator|->
name|chain_busaddr
operator|+
name|i
operator|*
name|sc
operator|->
name|facts
operator|->
name|IOCRequestFrameSize
operator|*
literal|4
expr_stmt|;
name|mps_free_chain
argument_list|(
name|sc
argument_list|,
name|chain
argument_list|)
expr_stmt|;
block|}
comment|/* XXX Need to pick a more precise value */
name|nsegs
operator|=
operator|(
name|MAXPHYS
operator|/
name|PAGE_SIZE
operator|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|mps_parent_dmat
argument_list|,
comment|/* parent */
literal|1
argument_list|,
literal|0
argument_list|,
comment|/* algnmnt, boundary */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
comment|/* maxsize */
name|nsegs
argument_list|,
comment|/* nsegments */
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
comment|/* maxsegsize */
name|BUS_DMA_ALLOCNOW
argument_list|,
comment|/* flags */
name|busdma_lock_mutex
argument_list|,
comment|/* lockfunc */
operator|&
name|sc
operator|->
name|mps_mtx
argument_list|,
comment|/* lockarg */
operator|&
name|sc
operator|->
name|buffer_dmat
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mps_dev
argument_list|,
literal|"Cannot allocate sense DMA tag\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/* 	 * SMID 0 cannot be used as a free command per the firmware spec. 	 * Just drop that command instead of risking accounting bugs. 	 */
name|sc
operator|->
name|commands
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|mps_command
argument_list|)
operator|*
name|sc
operator|->
name|num_reqs
argument_list|,
name|M_MPT2
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|sc
operator|->
name|num_reqs
condition|;
name|i
operator|++
control|)
block|{
name|cm
operator|=
operator|&
name|sc
operator|->
name|commands
index|[
name|i
index|]
expr_stmt|;
name|cm
operator|->
name|cm_req
operator|=
name|sc
operator|->
name|req_frames
operator|+
name|i
operator|*
name|sc
operator|->
name|facts
operator|->
name|IOCRequestFrameSize
operator|*
literal|4
expr_stmt|;
name|cm
operator|->
name|cm_req_busaddr
operator|=
name|sc
operator|->
name|req_busaddr
operator|+
name|i
operator|*
name|sc
operator|->
name|facts
operator|->
name|IOCRequestFrameSize
operator|*
literal|4
expr_stmt|;
name|cm
operator|->
name|cm_sense
operator|=
operator|&
name|sc
operator|->
name|sense_frames
index|[
name|i
index|]
expr_stmt|;
name|cm
operator|->
name|cm_sense_busaddr
operator|=
name|sc
operator|->
name|sense_busaddr
operator|+
name|i
operator|*
name|MPS_SENSE_LEN
expr_stmt|;
name|cm
operator|->
name|cm_desc
operator|.
name|Default
operator|.
name|SMID
operator|=
name|i
expr_stmt|;
name|cm
operator|->
name|cm_sc
operator|=
name|sc
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|cm
operator|->
name|cm_chain_list
argument_list|)
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|cm
operator|->
name|cm_callout
argument_list|,
literal|1
comment|/*MPSAFE*/
argument_list|)
expr_stmt|;
comment|/* XXX Is a failure here a critical problem? */
if|if
condition|(
name|bus_dmamap_create
argument_list|(
name|sc
operator|->
name|buffer_dmat
argument_list|,
literal|0
argument_list|,
operator|&
name|cm
operator|->
name|cm_dmamap
argument_list|)
operator|==
literal|0
condition|)
name|mps_free_command
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
else|else
block|{
name|sc
operator|->
name|num_reqs
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mps_init_queues
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|memset
argument_list|(
operator|(
name|uint8_t
operator|*
operator|)
name|sc
operator|->
name|post_queue
argument_list|,
literal|0xff
argument_list|,
name|sc
operator|->
name|pqdepth
operator|*
literal|8
argument_list|)
expr_stmt|;
comment|/* 	 * According to the spec, we need to use one less reply than we 	 * have space for on the queue.  So sc->num_replies (the number we 	 * use) should be less than sc->fqdepth (allocated size). 	 */
if|if
condition|(
name|sc
operator|->
name|num_replies
operator|>=
name|sc
operator|->
name|fqdepth
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 	 * Initialize all of the free queue entries. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|fqdepth
condition|;
name|i
operator|++
control|)
name|sc
operator|->
name|free_queue
index|[
name|i
index|]
operator|=
name|sc
operator|->
name|reply_busaddr
operator|+
operator|(
name|i
operator|*
name|sc
operator|->
name|facts
operator|->
name|ReplyFrameSize
operator|*
literal|4
operator|)
expr_stmt|;
name|sc
operator|->
name|replyfreeindex
operator|=
name|sc
operator|->
name|num_replies
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|mps_attach
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|error
decl_stmt|;
name|char
name|tmpstr
index|[
literal|80
index|]
decl_stmt|,
name|tmpstr2
index|[
literal|80
index|]
decl_stmt|;
comment|/* 	 * Grab any tunable-set debug level so that tracing works as early 	 * as possible. 	 */
name|snprintf
argument_list|(
name|tmpstr
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpstr
argument_list|)
argument_list|,
literal|"hw.mps.%d.debug_level"
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|mps_dev
argument_list|)
argument_list|)
expr_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
name|tmpstr
argument_list|,
operator|&
name|sc
operator|->
name|mps_debug
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|tmpstr
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpstr
argument_list|)
argument_list|,
literal|"hw.mps.%d.allow_multiple_tm_cmds"
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|mps_dev
argument_list|)
argument_list|)
expr_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
name|tmpstr
argument_list|,
operator|&
name|sc
operator|->
name|allow_multiple_tm_cmds
argument_list|)
expr_stmt|;
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_TRACE
argument_list|,
literal|"%s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|mps_mtx
argument_list|,
literal|"MPT2SAS lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|callout_init_mtx
argument_list|(
operator|&
name|sc
operator|->
name|periodic
argument_list|,
operator|&
name|sc
operator|->
name|mps_mtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|event_list
argument_list|)
expr_stmt|;
comment|/* 	 * Setup the sysctl variable so the user can change the debug level 	 * on the fly. 	 */
name|snprintf
argument_list|(
name|tmpstr
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpstr
argument_list|)
argument_list|,
literal|"MPS controller %d"
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|mps_dev
argument_list|)
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|tmpstr2
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpstr2
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|mps_dev
argument_list|)
argument_list|)
expr_stmt|;
name|sysctl_ctx_init
argument_list|(
operator|&
name|sc
operator|->
name|sysctl_ctx
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sysctl_tree
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
operator|&
name|sc
operator|->
name|sysctl_ctx
argument_list|,
name|SYSCTL_STATIC_CHILDREN
argument_list|(
name|_hw_mps
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
name|tmpstr2
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
name|tmpstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sysctl_tree
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|SYSCTL_ADD_INT
argument_list|(
operator|&
name|sc
operator|->
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"debug_level"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|mps_debug
argument_list|,
literal|0
argument_list|,
literal|"mps debug level"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
operator|&
name|sc
operator|->
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"allow_multiple_tm_cmds"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|allow_multiple_tm_cmds
argument_list|,
literal|0
argument_list|,
literal|"allow multiple simultaneous task management cmds"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|mps_transition_ready
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|sc
operator|->
name|facts
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|MPI2_IOC_FACTS_REPLY
argument_list|)
argument_list|,
name|M_MPT2
argument_list|,
name|M_ZERO
operator||
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|mps_get_iocfacts
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|facts
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|mps_print_iocfacts
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|facts
argument_list|)
expr_stmt|;
name|mps_printf
argument_list|(
name|sc
argument_list|,
literal|"Firmware: %02d.%02d.%02d.%02d\n"
argument_list|,
name|sc
operator|->
name|facts
operator|->
name|FWVersion
operator|.
name|Struct
operator|.
name|Major
argument_list|,
name|sc
operator|->
name|facts
operator|->
name|FWVersion
operator|.
name|Struct
operator|.
name|Minor
argument_list|,
name|sc
operator|->
name|facts
operator|->
name|FWVersion
operator|.
name|Struct
operator|.
name|Unit
argument_list|,
name|sc
operator|->
name|facts
operator|->
name|FWVersion
operator|.
name|Struct
operator|.
name|Dev
argument_list|)
expr_stmt|;
name|mps_printf
argument_list|(
name|sc
argument_list|,
literal|"IOCCapabilities: %b\n"
argument_list|,
name|sc
operator|->
name|facts
operator|->
name|IOCCapabilities
argument_list|,
literal|"\20"
literal|"\3ScsiTaskFull"
literal|"\4DiagTrace"
literal|"\5SnapBuf"
literal|"\6ExtBuf"
literal|"\7EEDP"
literal|"\10BiDirTarg"
literal|"\11Multicast"
literal|"\14TransRetry"
literal|"\15IR"
literal|"\16EventReplay"
literal|"\17RaidAccel"
literal|"\20MSIXIndex"
literal|"\21HostDisc"
argument_list|)
expr_stmt|;
comment|/* 	 * If the chip doesn't support event replay then a hard reset will be 	 * required to trigger a full discovery.  Do the reset here then 	 * retransition to Ready.  A hard reset might have already been done, 	 * but it doesn't hurt to do it again. 	 */
if|if
condition|(
operator|(
name|sc
operator|->
name|facts
operator|->
name|IOCCapabilities
operator|&
name|MPI2_IOCFACTS_CAPABILITY_EVENT_REPLAY
operator|)
operator|==
literal|0
condition|)
block|{
name|mps_hard_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|mps_transition_ready
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * Size the queues. Since the reply queues always need one free entry, 	 * we'll just deduct one reply message here. 	 */
name|sc
operator|->
name|num_reqs
operator|=
name|MIN
argument_list|(
name|MPS_REQ_FRAMES
argument_list|,
name|sc
operator|->
name|facts
operator|->
name|RequestCredit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|num_replies
operator|=
name|MIN
argument_list|(
name|MPS_REPLY_FRAMES
operator|+
name|MPS_EVT_REPLY_FRAMES
argument_list|,
name|sc
operator|->
name|facts
operator|->
name|MaxReplyDescriptorPostQueueDepth
argument_list|)
operator|-
literal|1
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|req_list
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|chain_list
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|tm_list
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|io_list
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|error
operator|=
name|mps_alloc_queues
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
operator|(
name|error
operator|=
name|mps_alloc_replies
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
operator|(
name|error
operator|=
name|mps_alloc_requests
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|mps_free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
operator|(
operator|(
name|error
operator|=
name|mps_init_queues
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
operator|(
name|error
operator|=
name|mps_transition_operational
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|mps_free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * Finish the queue initialization. 	 * These are set here instead of in mps_init_queues() because the 	 * IOC resets these values during the state transition in 	 * mps_transition_operational().  The free index is set to 1 	 * because the corresponding index in the IOC is set to 0, and the 	 * IOC treats the queues as full if both are set to the same value. 	 * Hence the reason that the queue can't hold all of the possible 	 * replies. 	 */
name|sc
operator|->
name|replypostindex
operator|=
literal|0
expr_stmt|;
name|mps_regwrite
argument_list|(
name|sc
argument_list|,
name|MPI2_REPLY_FREE_HOST_INDEX_OFFSET
argument_list|,
name|sc
operator|->
name|replyfreeindex
argument_list|)
expr_stmt|;
name|mps_regwrite
argument_list|(
name|sc
argument_list|,
name|MPI2_REPLY_POST_HOST_INDEX_OFFSET
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|pfacts
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|MPI2_PORT_FACTS_REPLY
argument_list|)
operator|*
name|sc
operator|->
name|facts
operator|->
name|NumberOfPorts
argument_list|,
name|M_MPT2
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|facts
operator|->
name|NumberOfPorts
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|mps_get_portfacts
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|pfacts
index|[
name|i
index|]
argument_list|,
name|i
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|mps_free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|mps_print_portfacts
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|pfacts
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Attach the subsystems so they can prepare their event masks. */
comment|/* XXX Should be dynamic so that IM/IR and user modules can attach */
if|if
condition|(
operator|(
operator|(
name|error
operator|=
name|mps_attach_log
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
operator|(
name|error
operator|=
name|mps_attach_sas
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
operator|(
name|error
operator|=
name|mps_attach_user
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|mps_printf
argument_list|(
name|sc
argument_list|,
literal|"%s failed to attach all subsystems: error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|mps_free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|mps_pci_setup_interrupts
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|mps_free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* Start the periodic watchdog check on the IOC Doorbell */
name|mps_periodic
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * The portenable will kick off discovery events that will drive the 	 * rest of the initialization process.  The CAM/SAS module will 	 * hold up the boot sequence until discovery is complete. 	 */
name|sc
operator|->
name|mps_ich
operator|.
name|ich_func
operator|=
name|mps_startup
expr_stmt|;
name|sc
operator|->
name|mps_ich
operator|.
name|ich_arg
operator|=
name|sc
expr_stmt|;
if|if
condition|(
name|config_intrhook_establish
argument_list|(
operator|&
name|sc
operator|->
name|mps_ich
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_FAULT
argument_list|,
literal|"Cannot establish MPS config hook\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mps_startup
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|mps_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|mps_softc
operator|*
operator|)
name|arg
expr_stmt|;
name|mps_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mps_unmask_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mps_send_portenable
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mps_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Periodic watchdog.  Is called with the driver lock already held. */
end_comment

begin_function
specifier|static
name|void
name|mps_periodic
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|mps_softc
modifier|*
name|sc
decl_stmt|;
name|uint32_t
name|db
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|mps_softc
operator|*
operator|)
name|arg
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mps_flags
operator|&
name|MPS_FLAGS_SHUTDOWN
condition|)
return|return;
name|db
operator|=
name|mps_regread
argument_list|(
name|sc
argument_list|,
name|MPI2_DOORBELL_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|db
operator|&
name|MPI2_IOC_STATE_MASK
operator|)
operator|==
name|MPI2_IOC_STATE_FAULT
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mps_dev
argument_list|,
literal|"IOC Fault 0x%08x, Resetting\n"
argument_list|,
name|db
argument_list|)
expr_stmt|;
comment|/* XXX Need to broaden this to re-initialize the chip */
name|mps_hard_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|db
operator|=
name|mps_regread
argument_list|(
name|sc
argument_list|,
name|MPI2_DOORBELL_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|db
operator|&
name|MPI2_IOC_STATE_MASK
operator|)
operator|==
name|MPI2_IOC_STATE_FAULT
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mps_dev
argument_list|,
literal|"Second IOC Fault 0x%08x, "
literal|"Giving up!\n"
argument_list|,
name|db
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|periodic
argument_list|,
name|MPS_PERIODIC_DELAY
operator|*
name|hz
argument_list|,
name|mps_periodic
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mps_startup_complete
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mps_command
modifier|*
name|cm
parameter_list|)
block|{
name|MPI2_PORT_ENABLE_REPLY
modifier|*
name|reply
decl_stmt|;
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_TRACE
argument_list|,
literal|"%s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|reply
operator|=
operator|(
name|MPI2_PORT_ENABLE_REPLY
operator|*
operator|)
name|cm
operator|->
name|cm_reply
expr_stmt|;
if|if
condition|(
operator|(
name|reply
operator|->
name|IOCStatus
operator|&
name|MPI2_IOCSTATUS_MASK
operator|)
operator|!=
name|MPI2_IOCSTATUS_SUCCESS
condition|)
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_FAULT
argument_list|,
literal|"Portenable failed\n"
argument_list|)
expr_stmt|;
name|mps_free_command
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
name|config_intrhook_disestablish
argument_list|(
operator|&
name|sc
operator|->
name|mps_ich
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mps_log_evt_handler
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|uintptr_t
name|data
parameter_list|,
name|MPI2_EVENT_NOTIFICATION_REPLY
modifier|*
name|event
parameter_list|)
block|{
name|MPI2_EVENT_DATA_LOG_ENTRY_ADDED
modifier|*
name|entry
decl_stmt|;
name|mps_print_event
argument_list|(
name|sc
argument_list|,
name|event
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|event
operator|->
name|Event
condition|)
block|{
case|case
name|MPI2_EVENT_LOG_DATA
case|:
name|device_printf
argument_list|(
name|sc
operator|->
name|mps_dev
argument_list|,
literal|"MPI2_EVENT_LOG_DATA:\n"
argument_list|)
expr_stmt|;
name|hexdump
argument_list|(
name|event
operator|->
name|EventData
argument_list|,
name|event
operator|->
name|EventDataLength
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|MPI2_EVENT_LOG_ENTRY_ADDED
case|:
name|entry
operator|=
operator|(
name|MPI2_EVENT_DATA_LOG_ENTRY_ADDED
operator|*
operator|)
name|event
operator|->
name|EventData
expr_stmt|;
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_INFO
argument_list|,
literal|"MPI2_EVENT_LOG_ENTRY_ADDED event "
literal|"0x%x Sequence %d:\n"
argument_list|,
name|entry
operator|->
name|LogEntryQualifier
argument_list|,
name|entry
operator|->
name|LogSequence
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|mps_attach_log
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint8_t
name|events
index|[
literal|16
index|]
decl_stmt|;
name|bzero
argument_list|(
name|events
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|setbit
argument_list|(
name|events
argument_list|,
name|MPI2_EVENT_LOG_DATA
argument_list|)
expr_stmt|;
name|setbit
argument_list|(
name|events
argument_list|,
name|MPI2_EVENT_LOG_ENTRY_ADDED
argument_list|)
expr_stmt|;
name|mps_register_events
argument_list|(
name|sc
argument_list|,
name|events
argument_list|,
name|mps_log_evt_handler
argument_list|,
name|NULL
argument_list|,
operator|&
name|sc
operator|->
name|mps_log_eh
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mps_detach_log
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|)
block|{
if|if
condition|(
name|sc
operator|->
name|mps_log_eh
operator|!=
name|NULL
condition|)
name|mps_deregister_events
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mps_log_eh
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free all of the driver resources and detach submodules.  Should be called  * without the lock held.  */
end_comment

begin_function
name|int
name|mps_free
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|mps_command
modifier|*
name|cm
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|;
comment|/* Turn off the watchdog */
name|mps_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mps_flags
operator||=
name|MPS_FLAGS_SHUTDOWN
expr_stmt|;
name|mps_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Lock must not be held for this */
name|callout_drain
argument_list|(
operator|&
name|sc
operator|->
name|periodic
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|error
operator|=
name|mps_detach_log
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
operator|(
name|error
operator|=
name|mps_detach_sas
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Put the IOC back in the READY state. */
name|mps_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|mps_send_mur
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|mps_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|mps_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|facts
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|sc
operator|->
name|facts
argument_list|,
name|M_MPT2
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|pfacts
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|sc
operator|->
name|pfacts
argument_list|,
name|M_MPT2
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|post_busaddr
operator|!=
literal|0
condition|)
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|queues_dmat
argument_list|,
name|sc
operator|->
name|queues_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|post_queue
operator|!=
name|NULL
condition|)
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|queues_dmat
argument_list|,
name|sc
operator|->
name|post_queue
argument_list|,
name|sc
operator|->
name|queues_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|queues_dmat
operator|!=
name|NULL
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|queues_dmat
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|chain_busaddr
operator|!=
literal|0
condition|)
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|chain_dmat
argument_list|,
name|sc
operator|->
name|chain_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|chain_frames
operator|!=
name|NULL
condition|)
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|chain_dmat
argument_list|,
name|sc
operator|->
name|chain_frames
argument_list|,
name|sc
operator|->
name|chain_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|chain_dmat
operator|!=
name|NULL
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|chain_dmat
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sense_busaddr
operator|!=
literal|0
condition|)
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sense_dmat
argument_list|,
name|sc
operator|->
name|sense_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sense_frames
operator|!=
name|NULL
condition|)
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|sense_dmat
argument_list|,
name|sc
operator|->
name|sense_frames
argument_list|,
name|sc
operator|->
name|sense_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sense_dmat
operator|!=
name|NULL
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|sense_dmat
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|reply_busaddr
operator|!=
literal|0
condition|)
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|reply_dmat
argument_list|,
name|sc
operator|->
name|reply_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|reply_frames
operator|!=
name|NULL
condition|)
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|reply_dmat
argument_list|,
name|sc
operator|->
name|reply_frames
argument_list|,
name|sc
operator|->
name|reply_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|reply_dmat
operator|!=
name|NULL
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|reply_dmat
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|req_busaddr
operator|!=
literal|0
condition|)
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|req_dmat
argument_list|,
name|sc
operator|->
name|req_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|req_frames
operator|!=
name|NULL
condition|)
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|req_dmat
argument_list|,
name|sc
operator|->
name|req_frames
argument_list|,
name|sc
operator|->
name|req_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|req_dmat
operator|!=
name|NULL
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|req_dmat
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|chains
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|sc
operator|->
name|chains
argument_list|,
name|M_MPT2
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|commands
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|sc
operator|->
name|num_reqs
condition|;
name|i
operator|++
control|)
block|{
name|cm
operator|=
operator|&
name|sc
operator|->
name|commands
index|[
name|i
index|]
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|buffer_dmat
argument_list|,
name|cm
operator|->
name|cm_dmamap
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|sc
operator|->
name|commands
argument_list|,
name|M_MPT2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|buffer_dmat
operator|!=
name|NULL
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|buffer_dmat
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sysctl_tree
operator|!=
name|NULL
condition|)
name|sysctl_ctx_free
argument_list|(
operator|&
name|sc
operator|->
name|sysctl_ctx
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|mps_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|mps_intr
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|mps_softc
modifier|*
name|sc
decl_stmt|;
name|uint32_t
name|status
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|mps_softc
operator|*
operator|)
name|data
expr_stmt|;
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_TRACE
argument_list|,
literal|"%s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* 	 * Check interrupt status register to flush the bus.  This is 	 * needed for both INTx interrupts and driver-driven polling 	 */
name|status
operator|=
name|mps_regread
argument_list|(
name|sc
argument_list|,
name|MPI2_HOST_INTERRUPT_STATUS_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|MPI2_HIS_REPLY_DESCRIPTOR_INTERRUPT
operator|)
operator|==
literal|0
condition|)
return|return;
name|mps_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mps_intr_locked
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|mps_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * In theory, MSI/MSIX interrupts shouldn't need to read any registers on the  * chip.  Hopefully this theory is correct.  */
end_comment

begin_function
name|void
name|mps_intr_msi
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|mps_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|mps_softc
operator|*
operator|)
name|data
expr_stmt|;
name|mps_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mps_intr_locked
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|mps_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * The locking is overly broad and simplistic, but easy to deal with for now.  */
end_comment

begin_function
name|void
name|mps_intr_locked
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|MPI2_REPLY_DESCRIPTORS_UNION
modifier|*
name|desc
decl_stmt|;
name|struct
name|mps_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mps_command
modifier|*
name|cm
init|=
name|NULL
decl_stmt|;
name|uint8_t
name|flags
decl_stmt|;
name|u_int
name|pq
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|mps_softc
operator|*
operator|)
name|data
expr_stmt|;
name|pq
operator|=
name|sc
operator|->
name|replypostindex
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|cm
operator|=
name|NULL
expr_stmt|;
name|desc
operator|=
operator|&
name|sc
operator|->
name|post_queue
index|[
name|pq
index|]
expr_stmt|;
name|flags
operator|=
name|desc
operator|->
name|Default
operator|.
name|ReplyFlags
operator|&
name|MPI2_RPY_DESCRIPT_FLAGS_TYPE_MASK
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|==
name|MPI2_RPY_DESCRIPT_FLAGS_UNUSED
operator|)
operator|||
operator|(
name|desc
operator|->
name|Words
operator|.
name|High
operator|==
literal|0xffffffff
operator|)
condition|)
break|break;
switch|switch
condition|(
name|flags
condition|)
block|{
case|case
name|MPI2_RPY_DESCRIPT_FLAGS_SCSI_IO_SUCCESS
case|:
name|cm
operator|=
operator|&
name|sc
operator|->
name|commands
index|[
name|desc
operator|->
name|SCSIIOSuccess
operator|.
name|SMID
index|]
expr_stmt|;
name|cm
operator|->
name|cm_reply
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|MPI2_RPY_DESCRIPT_FLAGS_ADDRESS_REPLY
case|:
block|{
name|uint32_t
name|baddr
decl_stmt|;
name|uint8_t
modifier|*
name|reply
decl_stmt|;
comment|/* 			 * Re-compose the reply address from the address 			 * sent back from the chip.  The ReplyFrameAddress 			 * is the lower 32 bits of the physical address of 			 * particular reply frame.  Convert that address to 			 * host format, and then use that to provide the 			 * offset against the virtual address base 			 * (sc->reply_frames). 			 */
name|baddr
operator|=
name|le32toh
argument_list|(
name|desc
operator|->
name|AddressReply
operator|.
name|ReplyFrameAddress
argument_list|)
expr_stmt|;
name|reply
operator|=
name|sc
operator|->
name|reply_frames
operator|+
operator|(
name|baddr
operator|-
operator|(
operator|(
name|uint32_t
operator|)
name|sc
operator|->
name|reply_busaddr
operator|)
operator|)
expr_stmt|;
comment|/* 			 * Make sure the reply we got back is in a valid 			 * range.  If not, go ahead and panic here, since 			 * we'll probably panic as soon as we deference the 			 * reply pointer anyway. 			 */
if|if
condition|(
operator|(
name|reply
operator|<
name|sc
operator|->
name|reply_frames
operator|)
operator|||
operator|(
name|reply
operator|>
operator|(
name|sc
operator|->
name|reply_frames
operator|+
operator|(
name|sc
operator|->
name|fqdepth
operator|*
name|sc
operator|->
name|facts
operator|->
name|ReplyFrameSize
operator|*
literal|4
operator|)
operator|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s: WARNING: reply %p out of range!\n"
argument_list|,
name|__func__
argument_list|,
name|reply
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: reply_frames %p, fqdepth %d, "
literal|"frame size %d\n"
argument_list|,
name|__func__
argument_list|,
name|sc
operator|->
name|reply_frames
argument_list|,
name|sc
operator|->
name|fqdepth
argument_list|,
name|sc
operator|->
name|facts
operator|->
name|ReplyFrameSize
operator|*
literal|4
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: baddr %#x,\n"
argument_list|,
name|__func__
argument_list|,
name|baddr
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"Reply address out of range"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|desc
operator|->
name|AddressReply
operator|.
name|SMID
operator|==
literal|0
condition|)
block|{
name|mps_dispatch_event
argument_list|(
name|sc
argument_list|,
name|baddr
argument_list|,
operator|(
name|MPI2_EVENT_NOTIFICATION_REPLY
operator|*
operator|)
name|reply
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cm
operator|=
operator|&
name|sc
operator|->
name|commands
index|[
name|desc
operator|->
name|AddressReply
operator|.
name|SMID
index|]
expr_stmt|;
name|cm
operator|->
name|cm_reply
operator|=
name|reply
expr_stmt|;
name|cm
operator|->
name|cm_reply_data
operator|=
name|desc
operator|->
name|AddressReply
operator|.
name|ReplyFrameAddress
expr_stmt|;
block|}
break|break;
block|}
case|case
name|MPI2_RPY_DESCRIPT_FLAGS_TARGETASSIST_SUCCESS
case|:
case|case
name|MPI2_RPY_DESCRIPT_FLAGS_TARGET_COMMAND_BUFFER
case|:
case|case
name|MPI2_RPY_DESCRIPT_FLAGS_RAID_ACCELERATOR_SUCCESS
case|:
default|default:
comment|/* Unhandled */
name|device_printf
argument_list|(
name|sc
operator|->
name|mps_dev
argument_list|,
literal|"Unhandled reply 0x%x\n"
argument_list|,
name|desc
operator|->
name|Default
operator|.
name|ReplyFlags
argument_list|)
expr_stmt|;
name|cm
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|cm
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|cm
operator|->
name|cm_flags
operator|&
name|MPS_CM_FLAGS_POLLED
condition|)
name|cm
operator|->
name|cm_flags
operator||=
name|MPS_CM_FLAGS_COMPLETE
expr_stmt|;
if|if
condition|(
name|cm
operator|->
name|cm_complete
operator|!=
name|NULL
condition|)
name|cm
operator|->
name|cm_complete
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
if|if
condition|(
name|cm
operator|->
name|cm_flags
operator|&
name|MPS_CM_FLAGS_WAKEUP
condition|)
name|wakeup
argument_list|(
name|cm
argument_list|)
expr_stmt|;
block|}
name|desc
operator|->
name|Words
operator|.
name|Low
operator|=
literal|0xffffffff
expr_stmt|;
name|desc
operator|->
name|Words
operator|.
name|High
operator|=
literal|0xffffffff
expr_stmt|;
if|if
condition|(
operator|++
name|pq
operator|>=
name|sc
operator|->
name|pqdepth
condition|)
name|pq
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|pq
operator|!=
name|sc
operator|->
name|replypostindex
condition|)
block|{
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_INFO
argument_list|,
literal|"writing postindex %d\n"
argument_list|,
name|pq
argument_list|)
expr_stmt|;
name|mps_regwrite
argument_list|(
name|sc
argument_list|,
name|MPI2_REPLY_POST_HOST_INDEX_OFFSET
argument_list|,
name|pq
argument_list|)
expr_stmt|;
name|sc
operator|->
name|replypostindex
operator|=
name|pq
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|mps_dispatch_event
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|uintptr_t
name|data
parameter_list|,
name|MPI2_EVENT_NOTIFICATION_REPLY
modifier|*
name|reply
parameter_list|)
block|{
name|struct
name|mps_event_handle
modifier|*
name|eh
decl_stmt|;
name|int
name|event
decl_stmt|,
name|handled
init|=
literal|0
decl_stmt|;
name|event
operator|=
name|reply
operator|->
name|Event
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|eh
argument_list|,
argument|&sc->event_list
argument_list|,
argument|eh_list
argument_list|)
block|{
if|if
condition|(
name|isset
argument_list|(
name|eh
operator|->
name|mask
argument_list|,
name|event
argument_list|)
condition|)
block|{
name|eh
operator|->
name|callback
argument_list|(
name|sc
argument_list|,
name|data
argument_list|,
name|reply
argument_list|)
expr_stmt|;
name|handled
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|handled
operator|==
literal|0
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|mps_dev
argument_list|,
literal|"Unhandled event 0x%x\n"
argument_list|,
name|event
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * For both register_events and update_events, the caller supplies a bitmap  * of events that it _wants_.  These functions then turn that into a bitmask  * suitable for the controller.  */
end_comment

begin_function
name|int
name|mps_register_events
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
modifier|*
name|mask
parameter_list|,
name|mps_evt_callback_t
modifier|*
name|cb
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|mps_event_handle
modifier|*
modifier|*
name|handle
parameter_list|)
block|{
name|struct
name|mps_event_handle
modifier|*
name|eh
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|eh
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|mps_event_handle
argument_list|)
argument_list|,
name|M_MPT2
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|eh
operator|->
name|callback
operator|=
name|cb
expr_stmt|;
name|eh
operator|->
name|data
operator|=
name|data
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|event_list
argument_list|,
name|eh
argument_list|,
name|eh_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
operator|!=
name|NULL
condition|)
name|error
operator|=
name|mps_update_events
argument_list|(
name|sc
argument_list|,
name|eh
argument_list|,
name|mask
argument_list|)
expr_stmt|;
operator|*
name|handle
operator|=
name|eh
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|mps_update_events
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mps_event_handle
modifier|*
name|handle
parameter_list|,
name|uint8_t
modifier|*
name|mask
parameter_list|)
block|{
name|MPI2_EVENT_NOTIFICATION_REQUEST
modifier|*
name|evtreq
decl_stmt|;
name|MPI2_EVENT_NOTIFICATION_REPLY
modifier|*
name|reply
decl_stmt|;
name|struct
name|mps_command
modifier|*
name|cm
decl_stmt|;
name|struct
name|mps_event_handle
modifier|*
name|eh
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_TRACE
argument_list|,
literal|"%s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mask
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|handle
operator|!=
name|NULL
operator|)
condition|)
name|bcopy
argument_list|(
name|mask
argument_list|,
operator|&
name|handle
operator|->
name|mask
index|[
literal|0
index|]
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|sc
operator|->
name|event_mask
argument_list|,
literal|0xff
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|eh
argument_list|,
argument|&sc->event_list
argument_list|,
argument|eh_list
argument_list|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
name|sc
operator|->
name|event_mask
index|[
name|i
index|]
operator|&=
operator|~
name|eh
operator|->
name|mask
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|cm
operator|=
name|mps_alloc_command
argument_list|(
name|sc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|evtreq
operator|=
operator|(
name|MPI2_EVENT_NOTIFICATION_REQUEST
operator|*
operator|)
name|cm
operator|->
name|cm_req
expr_stmt|;
name|evtreq
operator|->
name|Function
operator|=
name|MPI2_FUNCTION_EVENT_NOTIFICATION
expr_stmt|;
name|evtreq
operator|->
name|MsgFlags
operator|=
literal|0
expr_stmt|;
name|evtreq
operator|->
name|SASBroadcastPrimitiveMasks
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|MPS_DEBUG_ALL_EVENTS
block|{
name|u_char
name|fullmask
index|[
literal|16
index|]
decl_stmt|;
name|memset
argument_list|(
name|fullmask
argument_list|,
literal|0x00
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|fullmask
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|evtreq
operator|->
name|EventMasks
argument_list|,
literal|16
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|bcopy
argument_list|(
name|sc
operator|->
name|event_mask
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|evtreq
operator|->
name|EventMasks
argument_list|,
literal|16
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cm
operator|->
name|cm_desc
operator|.
name|Default
operator|.
name|RequestFlags
operator|=
name|MPI2_REQ_DESCRIPT_FLAGS_DEFAULT_TYPE
expr_stmt|;
name|cm
operator|->
name|cm_data
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|mps_request_polled
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
name|reply
operator|=
operator|(
name|MPI2_EVENT_NOTIFICATION_REPLY
operator|*
operator|)
name|cm
operator|->
name|cm_reply
expr_stmt|;
if|if
condition|(
operator|(
name|reply
operator|->
name|IOCStatus
operator|&
name|MPI2_IOCSTATUS_MASK
operator|)
operator|!=
name|MPI2_IOCSTATUS_SUCCESS
condition|)
name|error
operator|=
name|ENXIO
expr_stmt|;
name|mps_print_event
argument_list|(
name|sc
argument_list|,
name|reply
argument_list|)
expr_stmt|;
name|mps_free_command
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|mps_deregister_events
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mps_event_handle
modifier|*
name|handle
parameter_list|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|event_list
argument_list|,
name|handle
argument_list|,
name|eh_list
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|handle
argument_list|,
name|M_MPT2
argument_list|)
expr_stmt|;
return|return
operator|(
name|mps_update_events
argument_list|(
name|sc
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add a chain element as the next SGE for the specified command.  * Reset cm_sge and cm_sgesize to indicate all the available space.  */
end_comment

begin_function
specifier|static
name|int
name|mps_add_chain
parameter_list|(
name|struct
name|mps_command
modifier|*
name|cm
parameter_list|)
block|{
name|MPI2_SGE_CHAIN32
modifier|*
name|sgc
decl_stmt|;
name|struct
name|mps_chain
modifier|*
name|chain
decl_stmt|;
name|int
name|space
decl_stmt|;
if|if
condition|(
name|cm
operator|->
name|cm_sglsize
operator|<
name|MPS_SGC_SIZE
condition|)
name|panic
argument_list|(
literal|"MPS: Need SGE Error Code\n"
argument_list|)
expr_stmt|;
name|chain
operator|=
name|mps_alloc_chain
argument_list|(
name|cm
operator|->
name|cm_sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|chain
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
name|space
operator|=
operator|(
name|int
operator|)
name|cm
operator|->
name|cm_sc
operator|->
name|facts
operator|->
name|IOCRequestFrameSize
operator|*
literal|4
expr_stmt|;
comment|/* 	 * Note: a double-linked list is used to make it easier to 	 * walk for debugging. 	 */
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|cm
operator|->
name|cm_chain_list
argument_list|,
name|chain
argument_list|,
name|chain_link
argument_list|)
expr_stmt|;
name|sgc
operator|=
operator|(
name|MPI2_SGE_CHAIN32
operator|*
operator|)
operator|&
name|cm
operator|->
name|cm_sge
operator|->
name|MpiChain
expr_stmt|;
name|sgc
operator|->
name|Length
operator|=
name|space
expr_stmt|;
name|sgc
operator|->
name|NextChainOffset
operator|=
literal|0
expr_stmt|;
name|sgc
operator|->
name|Flags
operator|=
name|MPI2_SGE_FLAGS_CHAIN_ELEMENT
expr_stmt|;
name|sgc
operator|->
name|Address
operator|=
name|chain
operator|->
name|chain_busaddr
expr_stmt|;
name|cm
operator|->
name|cm_sge
operator|=
operator|(
name|MPI2_SGE_IO_UNION
operator|*
operator|)
operator|&
name|chain
operator|->
name|chain
operator|->
name|MpiSimple
expr_stmt|;
name|cm
operator|->
name|cm_sglsize
operator|=
name|space
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add one scatter-gather element (chain, simple, transaction context)  * to the scatter-gather list for a command.  Maintain cm_sglsize and  * cm_sge as the remaining size and pointer to the next SGE to fill  * in, respectively.  */
end_comment

begin_function
name|int
name|mps_push_sge
parameter_list|(
name|struct
name|mps_command
modifier|*
name|cm
parameter_list|,
name|void
modifier|*
name|sgep
parameter_list|,
name|size_t
name|len
parameter_list|,
name|int
name|segsleft
parameter_list|)
block|{
name|MPI2_SGE_TRANSACTION_UNION
modifier|*
name|tc
init|=
name|sgep
decl_stmt|;
name|MPI2_SGE_SIMPLE64
modifier|*
name|sge
init|=
name|sgep
decl_stmt|;
name|int
name|error
decl_stmt|,
name|type
decl_stmt|;
name|type
operator|=
operator|(
name|tc
operator|->
name|Flags
operator|&
name|MPI2_SGE_FLAGS_ELEMENT_MASK
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|MPI2_SGE_FLAGS_TRANSACTION_ELEMENT
case|:
block|{
if|if
condition|(
name|len
operator|!=
name|tc
operator|->
name|DetailsLength
operator|+
literal|4
condition|)
name|panic
argument_list|(
literal|"TC %p length %u or %zu?"
argument_list|,
name|tc
argument_list|,
name|tc
operator|->
name|DetailsLength
operator|+
literal|4
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|MPI2_SGE_FLAGS_CHAIN_ELEMENT
case|:
comment|/* Driver only uses 32-bit chain elements */
if|if
condition|(
name|len
operator|!=
name|MPS_SGC_SIZE
condition|)
name|panic
argument_list|(
literal|"CHAIN %p length %u or %zu?"
argument_list|,
name|sgep
argument_list|,
name|MPS_SGC_SIZE
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|MPI2_SGE_FLAGS_SIMPLE_ELEMENT
case|:
comment|/* Driver only uses 64-bit SGE simple elements */
name|sge
operator|=
name|sgep
expr_stmt|;
if|if
condition|(
name|len
operator|!=
name|MPS_SGE64_SIZE
condition|)
name|panic
argument_list|(
literal|"SGE simple %p length %u or %zu?"
argument_list|,
name|sge
argument_list|,
name|MPS_SGE64_SIZE
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|sge
operator|->
name|FlagsLength
operator|>>
name|MPI2_SGE_FLAGS_SHIFT
operator|)
operator|&
name|MPI2_SGE_FLAGS_ADDRESS_SIZE
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"SGE simple %p flags %02x not marked 64-bit?"
argument_list|,
name|sge
argument_list|,
name|sge
operator|->
name|FlagsLength
operator|>>
name|MPI2_SGE_FLAGS_SHIFT
argument_list|)
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"Unexpected SGE %p, flags %02x"
argument_list|,
name|tc
argument_list|,
name|tc
operator|->
name|Flags
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * case 1: 1 more segment, enough room for it 	 * case 2: 2 more segments, enough room for both 	 * case 3:>=2 more segments, only enough room for 1 and a chain 	 * case 4:>=1 more segment, enough room for only a chain 	 * case 5:>=1 more segment, no room for anything (error)          */
comment|/* 	 * There should be room for at least a chain element, or this 	 * code is buggy.  Case (5). 	 */
if|if
condition|(
name|cm
operator|->
name|cm_sglsize
operator|<
name|MPS_SGC_SIZE
condition|)
name|panic
argument_list|(
literal|"MPS: Need SGE Error Code\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|segsleft
operator|>=
literal|2
operator|&&
name|cm
operator|->
name|cm_sglsize
operator|<
name|len
operator|+
name|MPS_SGC_SIZE
operator|+
name|MPS_SGE64_SIZE
condition|)
block|{
comment|/* 		 * There are 2 or more segments left to add, and only 		 * enough room for 1 and a chain.  Case (3). 		 * 		 * Mark as last element in this chain if necessary. 		 */
if|if
condition|(
name|type
operator|==
name|MPI2_SGE_FLAGS_SIMPLE_ELEMENT
condition|)
block|{
name|sge
operator|->
name|FlagsLength
operator||=
operator|(
name|MPI2_SGE_FLAGS_LAST_ELEMENT
operator|<<
name|MPI2_SGE_FLAGS_SHIFT
operator|)
expr_stmt|;
block|}
comment|/* 		 * Add the item then a chain.  Do the chain now, 		 * rather than on the next iteration, to simplify 		 * understanding the code. 		 */
name|cm
operator|->
name|cm_sglsize
operator|-=
name|len
expr_stmt|;
name|bcopy
argument_list|(
name|sgep
argument_list|,
name|cm
operator|->
name|cm_sge
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|cm
operator|->
name|cm_sge
operator|=
operator|(
name|MPI2_SGE_IO_UNION
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|cm
operator|->
name|cm_sge
operator|+
name|len
operator|)
expr_stmt|;
return|return
operator|(
name|mps_add_chain
argument_list|(
name|cm
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|segsleft
operator|>=
literal|1
operator|&&
name|cm
operator|->
name|cm_sglsize
operator|<
name|len
operator|+
name|MPS_SGC_SIZE
condition|)
block|{
comment|/* 		 * 1 or more segment, enough room for only a chain. 		 * Hope the previous element wasn't a Simple entry 		 * that needed to be marked with 		 * MPI2_SGE_FLAGS_LAST_ELEMENT.  Case (4). 		 */
if|if
condition|(
operator|(
name|error
operator|=
name|mps_add_chain
argument_list|(
name|cm
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|INVARIANTS
comment|/* Case 1: 1 more segment, enough room for it. */
if|if
condition|(
name|segsleft
operator|==
literal|1
operator|&&
name|cm
operator|->
name|cm_sglsize
operator|<
name|len
condition|)
name|panic
argument_list|(
literal|"1 seg left and no room? %u versus %zu"
argument_list|,
name|cm
operator|->
name|cm_sglsize
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* Case 2: 2 more segments, enough room for both */
if|if
condition|(
name|segsleft
operator|==
literal|2
operator|&&
name|cm
operator|->
name|cm_sglsize
operator|<
name|len
operator|+
name|MPS_SGE64_SIZE
condition|)
name|panic
argument_list|(
literal|"2 segs left and no room? %u versus %zu"
argument_list|,
name|cm
operator|->
name|cm_sglsize
argument_list|,
name|len
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|segsleft
operator|==
literal|1
operator|&&
name|type
operator|==
name|MPI2_SGE_FLAGS_SIMPLE_ELEMENT
condition|)
block|{
comment|/* 		 * Last element of the last segment of the entire 		 * buffer. 		 */
name|sge
operator|->
name|FlagsLength
operator||=
operator|(
operator|(
name|MPI2_SGE_FLAGS_LAST_ELEMENT
operator||
name|MPI2_SGE_FLAGS_END_OF_BUFFER
operator||
name|MPI2_SGE_FLAGS_END_OF_LIST
operator|)
operator|<<
name|MPI2_SGE_FLAGS_SHIFT
operator|)
expr_stmt|;
block|}
name|cm
operator|->
name|cm_sglsize
operator|-=
name|len
expr_stmt|;
name|bcopy
argument_list|(
name|sgep
argument_list|,
name|cm
operator|->
name|cm_sge
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|cm
operator|->
name|cm_sge
operator|=
operator|(
name|MPI2_SGE_IO_UNION
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|cm
operator|->
name|cm_sge
operator|+
name|len
operator|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add one dma segment to the scatter-gather list for a command.  */
end_comment

begin_function
name|int
name|mps_add_dmaseg
parameter_list|(
name|struct
name|mps_command
modifier|*
name|cm
parameter_list|,
name|vm_paddr_t
name|pa
parameter_list|,
name|size_t
name|len
parameter_list|,
name|u_int
name|flags
parameter_list|,
name|int
name|segsleft
parameter_list|)
block|{
name|MPI2_SGE_SIMPLE64
name|sge
decl_stmt|;
comment|/* 	 * This driver always uses 64-bit address elements for 	 * simplicity. 	 */
name|flags
operator||=
name|MPI2_SGE_FLAGS_SIMPLE_ELEMENT
operator||
name|MPI2_SGE_FLAGS_ADDRESS_SIZE
expr_stmt|;
name|sge
operator|.
name|FlagsLength
operator|=
name|len
operator||
operator|(
name|flags
operator|<<
name|MPI2_SGE_FLAGS_SHIFT
operator|)
expr_stmt|;
name|mps_from_u64
argument_list|(
name|pa
argument_list|,
operator|&
name|sge
operator|.
name|Address
argument_list|)
expr_stmt|;
return|return
operator|(
name|mps_push_sge
argument_list|(
name|cm
argument_list|,
operator|&
name|sge
argument_list|,
sizeof|sizeof
name|sge
argument_list|,
name|segsleft
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mps_data_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nsegs
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|mps_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mps_command
modifier|*
name|cm
decl_stmt|;
name|u_int
name|i
decl_stmt|,
name|dir
decl_stmt|,
name|sflags
decl_stmt|;
name|cm
operator|=
operator|(
expr|struct
name|mps_command
operator|*
operator|)
name|arg
expr_stmt|;
name|sc
operator|=
name|cm
operator|->
name|cm_sc
expr_stmt|;
comment|/* 	 * In this case, just print out a warning and let the chip tell the 	 * user they did the wrong thing. 	 */
if|if
condition|(
operator|(
name|cm
operator|->
name|cm_max_segs
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|nsegs
operator|>
name|cm
operator|->
name|cm_max_segs
operator|)
condition|)
block|{
name|mps_printf
argument_list|(
name|sc
argument_list|,
literal|"%s: warning: busdma returned %d segments, "
literal|"more than the %d allowed\n"
argument_list|,
name|__func__
argument_list|,
name|nsegs
argument_list|,
name|cm
operator|->
name|cm_max_segs
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Set up DMA direction flags.  Note that we don't support 	 * bi-directional transfers, with the exception of SMP passthrough. 	 */
name|sflags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cm
operator|->
name|cm_flags
operator|&
name|MPS_CM_FLAGS_SMP_PASS
condition|)
block|{
comment|/* 		 * We have to add a special case for SMP passthrough, there 		 * is no easy way to generically handle it.  The first 		 * S/G element is used for the command (therefore the 		 * direction bit needs to be set).  The second one is used 		 * for the reply.  We'll leave it to the caller to make 		 * sure we only have two buffers. 		 */
comment|/* 		 * Even though the busdma man page says it doesn't make 		 * sense to have both direction flags, it does in this case. 		 * We have one s/g element being accessed in each direction. 		 */
name|dir
operator|=
name|BUS_DMASYNC_PREWRITE
operator||
name|BUS_DMASYNC_PREREAD
expr_stmt|;
comment|/* 		 * Set the direction flag on the first buffer in the SMP 		 * passthrough request.  We'll clear it for the second one. 		 */
name|sflags
operator||=
name|MPI2_SGE_FLAGS_DIRECTION
operator||
name|MPI2_SGE_FLAGS_END_OF_BUFFER
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cm
operator|->
name|cm_flags
operator|&
name|MPS_CM_FLAGS_DATAOUT
condition|)
block|{
name|sflags
operator||=
name|MPI2_SGE_FLAGS_DIRECTION
expr_stmt|;
name|dir
operator|=
name|BUS_DMASYNC_PREWRITE
expr_stmt|;
block|}
else|else
name|dir
operator|=
name|BUS_DMASYNC_PREREAD
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsegs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|cm
operator|->
name|cm_flags
operator|&
name|MPS_CM_FLAGS_SMP_PASS
operator|)
operator|&&
operator|(
name|i
operator|!=
literal|0
operator|)
condition|)
block|{
name|sflags
operator|&=
operator|~
name|MPI2_SGE_FLAGS_DIRECTION
expr_stmt|;
block|}
name|error
operator|=
name|mps_add_dmaseg
argument_list|(
name|cm
argument_list|,
name|segs
index|[
name|i
index|]
operator|.
name|ds_addr
argument_list|,
name|segs
index|[
name|i
index|]
operator|.
name|ds_len
argument_list|,
name|sflags
argument_list|,
name|nsegs
operator|-
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
comment|/* Resource shortage, roll back! */
name|mps_printf
argument_list|(
name|sc
argument_list|,
literal|"out of chain frames\n"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|buffer_dmat
argument_list|,
name|cm
operator|->
name|cm_dmamap
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|mps_enqueue_request
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|mps_data_cb2
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nsegs
parameter_list|,
name|bus_size_t
name|mapsize
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|mps_data_cb
argument_list|(
name|arg
argument_list|,
name|segs
argument_list|,
name|nsegs
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Note that the only error path here is from bus_dmamap_load(), which can  * return EINPROGRESS if it is waiting for resources.  */
end_comment

begin_function
name|int
name|mps_map_command
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mps_command
modifier|*
name|cm
parameter_list|)
block|{
name|MPI2_SGE_SIMPLE32
modifier|*
name|sge
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|cm
operator|->
name|cm_flags
operator|&
name|MPS_CM_FLAGS_USE_UIO
condition|)
block|{
name|error
operator|=
name|bus_dmamap_load_uio
argument_list|(
name|sc
operator|->
name|buffer_dmat
argument_list|,
name|cm
operator|->
name|cm_dmamap
argument_list|,
operator|&
name|cm
operator|->
name|cm_uio
argument_list|,
name|mps_data_cb2
argument_list|,
name|cm
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|cm
operator|->
name|cm_data
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|cm
operator|->
name|cm_length
operator|!=
literal|0
operator|)
condition|)
block|{
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|buffer_dmat
argument_list|,
name|cm
operator|->
name|cm_dmamap
argument_list|,
name|cm
operator|->
name|cm_data
argument_list|,
name|cm
operator|->
name|cm_length
argument_list|,
name|mps_data_cb
argument_list|,
name|cm
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Add a zero-length element as needed */
if|if
condition|(
name|cm
operator|->
name|cm_sge
operator|!=
name|NULL
condition|)
block|{
name|sge
operator|=
operator|(
name|MPI2_SGE_SIMPLE32
operator|*
operator|)
name|cm
operator|->
name|cm_sge
expr_stmt|;
name|sge
operator|->
name|FlagsLength
operator|=
operator|(
name|MPI2_SGE_FLAGS_LAST_ELEMENT
operator||
name|MPI2_SGE_FLAGS_END_OF_BUFFER
operator||
name|MPI2_SGE_FLAGS_END_OF_LIST
operator||
name|MPI2_SGE_FLAGS_SIMPLE_ELEMENT
operator|)
operator|<<
name|MPI2_SGE_FLAGS_SHIFT
expr_stmt|;
name|sge
operator|->
name|Address
operator|=
literal|0
expr_stmt|;
block|}
name|mps_enqueue_request
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The MPT driver had a verbose interface for config pages.  In this driver,  * reduce it to much simplier terms, similar to the Linux driver.  */
end_comment

begin_function
name|int
name|mps_read_config_page
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mps_config_params
modifier|*
name|params
parameter_list|)
block|{
name|MPI2_CONFIG_REQUEST
modifier|*
name|req
decl_stmt|;
name|struct
name|mps_command
modifier|*
name|cm
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|mps_flags
operator|&
name|MPS_FLAGS_BUSY
condition|)
block|{
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
name|cm
operator|=
name|mps_alloc_command
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|cm
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
name|req
operator|=
operator|(
name|MPI2_CONFIG_REQUEST
operator|*
operator|)
name|cm
operator|->
name|cm_req
expr_stmt|;
name|req
operator|->
name|Function
operator|=
name|MPI2_FUNCTION_CONFIG
expr_stmt|;
name|req
operator|->
name|Action
operator|=
name|params
operator|->
name|action
expr_stmt|;
name|req
operator|->
name|SGLFlags
operator|=
literal|0
expr_stmt|;
name|req
operator|->
name|ChainOffset
operator|=
literal|0
expr_stmt|;
name|req
operator|->
name|PageAddress
operator|=
name|params
operator|->
name|page_address
expr_stmt|;
if|if
condition|(
name|params
operator|->
name|hdr
operator|.
name|Ext
operator|.
name|ExtPageType
operator|!=
literal|0
condition|)
block|{
name|MPI2_CONFIG_EXTENDED_PAGE_HEADER
modifier|*
name|hdr
decl_stmt|;
name|hdr
operator|=
operator|&
name|params
operator|->
name|hdr
operator|.
name|Ext
expr_stmt|;
name|req
operator|->
name|ExtPageType
operator|=
name|hdr
operator|->
name|ExtPageType
expr_stmt|;
name|req
operator|->
name|ExtPageLength
operator|=
name|hdr
operator|->
name|ExtPageLength
expr_stmt|;
name|req
operator|->
name|Header
operator|.
name|PageType
operator|=
name|MPI2_CONFIG_PAGETYPE_EXTENDED
expr_stmt|;
name|req
operator|->
name|Header
operator|.
name|PageLength
operator|=
literal|0
expr_stmt|;
comment|/* Must be set to zero */
name|req
operator|->
name|Header
operator|.
name|PageNumber
operator|=
name|hdr
operator|->
name|PageNumber
expr_stmt|;
name|req
operator|->
name|Header
operator|.
name|PageVersion
operator|=
name|hdr
operator|->
name|PageVersion
expr_stmt|;
block|}
else|else
block|{
name|MPI2_CONFIG_PAGE_HEADER
modifier|*
name|hdr
decl_stmt|;
name|hdr
operator|=
operator|&
name|params
operator|->
name|hdr
operator|.
name|Struct
expr_stmt|;
name|req
operator|->
name|Header
operator|.
name|PageType
operator|=
name|hdr
operator|->
name|PageType
expr_stmt|;
name|req
operator|->
name|Header
operator|.
name|PageNumber
operator|=
name|hdr
operator|->
name|PageNumber
expr_stmt|;
name|req
operator|->
name|Header
operator|.
name|PageLength
operator|=
name|hdr
operator|->
name|PageLength
expr_stmt|;
name|req
operator|->
name|Header
operator|.
name|PageVersion
operator|=
name|hdr
operator|->
name|PageVersion
expr_stmt|;
block|}
name|cm
operator|->
name|cm_data
operator|=
name|params
operator|->
name|buffer
expr_stmt|;
name|cm
operator|->
name|cm_length
operator|=
name|params
operator|->
name|length
expr_stmt|;
name|cm
operator|->
name|cm_sge
operator|=
operator|&
name|req
operator|->
name|PageBufferSGE
expr_stmt|;
name|cm
operator|->
name|cm_sglsize
operator|=
sizeof|sizeof
argument_list|(
name|MPI2_SGE_IO_UNION
argument_list|)
expr_stmt|;
name|cm
operator|->
name|cm_flags
operator|=
name|MPS_CM_FLAGS_SGE_SIMPLE
operator||
name|MPS_CM_FLAGS_DATAIN
expr_stmt|;
name|cm
operator|->
name|cm_desc
operator|.
name|Default
operator|.
name|RequestFlags
operator|=
name|MPI2_REQ_DESCRIPT_FLAGS_DEFAULT_TYPE
expr_stmt|;
name|cm
operator|->
name|cm_complete_data
operator|=
name|params
expr_stmt|;
if|if
condition|(
name|params
operator|->
name|callback
operator|!=
name|NULL
condition|)
block|{
name|cm
operator|->
name|cm_complete
operator|=
name|mps_config_complete
expr_stmt|;
return|return
operator|(
name|mps_map_command
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
operator|)
return|;
block|}
else|else
block|{
name|cm
operator|->
name|cm_complete
operator|=
name|NULL
expr_stmt|;
name|cm
operator|->
name|cm_flags
operator||=
name|MPS_CM_FLAGS_WAKEUP
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|mps_map_command
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|msleep
argument_list|(
name|cm
argument_list|,
operator|&
name|sc
operator|->
name|mps_mtx
argument_list|,
literal|0
argument_list|,
literal|"mpswait"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mps_config_complete
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|mps_write_config_page
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mps_config_params
modifier|*
name|params
parameter_list|)
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mps_config_complete
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mps_command
modifier|*
name|cm
parameter_list|)
block|{
name|MPI2_CONFIG_REPLY
modifier|*
name|reply
decl_stmt|;
name|struct
name|mps_config_params
modifier|*
name|params
decl_stmt|;
name|params
operator|=
name|cm
operator|->
name|cm_complete_data
expr_stmt|;
if|if
condition|(
name|cm
operator|->
name|cm_data
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|buffer_dmat
argument_list|,
name|cm
operator|->
name|cm_dmamap
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|buffer_dmat
argument_list|,
name|cm
operator|->
name|cm_dmamap
argument_list|)
expr_stmt|;
block|}
name|reply
operator|=
operator|(
name|MPI2_CONFIG_REPLY
operator|*
operator|)
name|cm
operator|->
name|cm_reply
expr_stmt|;
name|params
operator|->
name|status
operator|=
name|reply
operator|->
name|IOCStatus
expr_stmt|;
if|if
condition|(
name|params
operator|->
name|hdr
operator|.
name|Ext
operator|.
name|ExtPageType
operator|!=
literal|0
condition|)
block|{
name|params
operator|->
name|hdr
operator|.
name|Ext
operator|.
name|ExtPageType
operator|=
name|reply
operator|->
name|ExtPageType
expr_stmt|;
name|params
operator|->
name|hdr
operator|.
name|Ext
operator|.
name|ExtPageLength
operator|=
name|reply
operator|->
name|ExtPageLength
expr_stmt|;
block|}
else|else
block|{
name|params
operator|->
name|hdr
operator|.
name|Struct
operator|.
name|PageType
operator|=
name|reply
operator|->
name|Header
operator|.
name|PageType
expr_stmt|;
name|params
operator|->
name|hdr
operator|.
name|Struct
operator|.
name|PageNumber
operator|=
name|reply
operator|->
name|Header
operator|.
name|PageNumber
expr_stmt|;
name|params
operator|->
name|hdr
operator|.
name|Struct
operator|.
name|PageLength
operator|=
name|reply
operator|->
name|Header
operator|.
name|PageLength
expr_stmt|;
name|params
operator|->
name|hdr
operator|.
name|Struct
operator|.
name|PageVersion
operator|=
name|reply
operator|->
name|Header
operator|.
name|PageVersion
expr_stmt|;
block|}
name|mps_free_command
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
if|if
condition|(
name|params
operator|->
name|callback
operator|!=
name|NULL
condition|)
name|params
operator|->
name|callback
argument_list|(
name|sc
argument_list|,
name|params
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

end_unit

