begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2011-2015 LSI Corp.  * Copyright (c) 2013-2015 Avago Technologies  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * Avago Technologies (LSI) MPT-Fusion Host Adapter FreeBSD  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* TODO Move headers to mpsvar */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/sbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/eventhandler.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<dev/mps/mpi/mpi2_type.h>
end_include

begin_include
include|#
directive|include
file|<dev/mps/mpi/mpi2.h>
end_include

begin_include
include|#
directive|include
file|<dev/mps/mpi/mpi2_ioc.h>
end_include

begin_include
include|#
directive|include
file|<dev/mps/mpi/mpi2_sas.h>
end_include

begin_include
include|#
directive|include
file|<dev/mps/mpi/mpi2_cnfg.h>
end_include

begin_include
include|#
directive|include
file|<dev/mps/mpi/mpi2_init.h>
end_include

begin_include
include|#
directive|include
file|<dev/mps/mpi/mpi2_tool.h>
end_include

begin_include
include|#
directive|include
file|<dev/mps/mps_ioctl.h>
end_include

begin_include
include|#
directive|include
file|<dev/mps/mpsvar.h>
end_include

begin_include
include|#
directive|include
file|<dev/mps/mps_mapping.h>
end_include

begin_comment
comment|/**  * _mapping_clear_entry - Clear a particular mapping entry.  * @map_entry: map table entry  *  * Returns nothing.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|_mapping_clear_map_entry
parameter_list|(
name|struct
name|dev_mapping_table
modifier|*
name|map_entry
parameter_list|)
block|{
name|map_entry
operator|->
name|physical_id
operator|=
literal|0
expr_stmt|;
name|map_entry
operator|->
name|device_info
operator|=
literal|0
expr_stmt|;
name|map_entry
operator|->
name|phy_bits
operator|=
literal|0
expr_stmt|;
name|map_entry
operator|->
name|dpm_entry_num
operator|=
name|MPS_DPM_BAD_IDX
expr_stmt|;
name|map_entry
operator|->
name|dev_handle
operator|=
literal|0
expr_stmt|;
name|map_entry
operator|->
name|channel
operator|=
operator|-
literal|1
expr_stmt|;
name|map_entry
operator|->
name|id
operator|=
operator|-
literal|1
expr_stmt|;
name|map_entry
operator|->
name|missing_count
operator|=
literal|0
expr_stmt|;
name|map_entry
operator|->
name|init_complete
operator|=
literal|0
expr_stmt|;
name|map_entry
operator|->
name|TLR_bits
operator|=
operator|(
name|u8
operator|)
name|MPI2_SCSIIO_CONTROL_NO_TLR
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * _mapping_clear_enc_entry - Clear a particular enclosure table entry.  * @enc_entry: enclosure table entry  *  * Returns nothing.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|_mapping_clear_enc_entry
parameter_list|(
name|struct
name|enc_mapping_table
modifier|*
name|enc_entry
parameter_list|)
block|{
name|enc_entry
operator|->
name|enclosure_id
operator|=
literal|0
expr_stmt|;
name|enc_entry
operator|->
name|start_index
operator|=
name|MPS_MAPTABLE_BAD_IDX
expr_stmt|;
name|enc_entry
operator|->
name|phy_bits
operator|=
literal|0
expr_stmt|;
name|enc_entry
operator|->
name|dpm_entry_num
operator|=
name|MPS_DPM_BAD_IDX
expr_stmt|;
name|enc_entry
operator|->
name|enc_handle
operator|=
literal|0
expr_stmt|;
name|enc_entry
operator|->
name|num_slots
operator|=
literal|0
expr_stmt|;
name|enc_entry
operator|->
name|start_slot
operator|=
literal|0
expr_stmt|;
name|enc_entry
operator|->
name|missing_count
operator|=
literal|0
expr_stmt|;
name|enc_entry
operator|->
name|removal_flag
operator|=
literal|0
expr_stmt|;
name|enc_entry
operator|->
name|skip_search
operator|=
literal|0
expr_stmt|;
name|enc_entry
operator|->
name|init_complete
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * _mapping_commit_enc_entry - write a particular enc entry in DPM page0.  * @sc: per adapter object  * @enc_entry: enclosure table entry  *  * Returns 0 for success, non-zero for failure.  */
end_comment

begin_function
specifier|static
name|int
name|_mapping_commit_enc_entry
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|enc_mapping_table
modifier|*
name|et_entry
parameter_list|)
block|{
name|Mpi2DriverMap0Entry_t
modifier|*
name|dpm_entry
decl_stmt|;
name|struct
name|dev_mapping_table
modifier|*
name|mt_entry
decl_stmt|;
name|Mpi2ConfigReply_t
name|mpi_reply
decl_stmt|;
name|Mpi2DriverMappingPage0_t
name|config_page
decl_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|is_dpm_enable
condition|)
return|return
literal|0
return|;
name|memset
argument_list|(
operator|&
name|config_page
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|Mpi2DriverMappingPage0_t
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|config_page
operator|.
name|Header
argument_list|,
operator|(
name|u8
operator|*
operator|)
name|sc
operator|->
name|dpm_pg0
argument_list|,
sizeof|sizeof
argument_list|(
name|MPI2_CONFIG_EXTENDED_PAGE_HEADER
argument_list|)
argument_list|)
expr_stmt|;
name|dpm_entry
operator|=
operator|(
name|Mpi2DriverMap0Entry_t
operator|*
operator|)
operator|(
operator|(
name|u8
operator|*
operator|)
name|sc
operator|->
name|dpm_pg0
operator|+
sizeof|sizeof
argument_list|(
name|MPI2_CONFIG_EXTENDED_PAGE_HEADER
argument_list|)
operator|)
expr_stmt|;
name|dpm_entry
operator|+=
name|et_entry
operator|->
name|dpm_entry_num
expr_stmt|;
name|dpm_entry
operator|->
name|PhysicalIdentifier
operator|.
name|Low
operator|=
operator|(
literal|0xFFFFFFFF
operator|&
name|et_entry
operator|->
name|enclosure_id
operator|)
expr_stmt|;
name|dpm_entry
operator|->
name|PhysicalIdentifier
operator|.
name|High
operator|=
operator|(
name|et_entry
operator|->
name|enclosure_id
operator|>>
literal|32
operator|)
expr_stmt|;
name|mt_entry
operator|=
operator|&
name|sc
operator|->
name|mapping_table
index|[
name|et_entry
operator|->
name|start_index
index|]
expr_stmt|;
name|dpm_entry
operator|->
name|DeviceIndex
operator|=
name|htole16
argument_list|(
name|mt_entry
operator|->
name|id
argument_list|)
expr_stmt|;
name|dpm_entry
operator|->
name|MappingInformation
operator|=
name|et_entry
operator|->
name|num_slots
expr_stmt|;
name|dpm_entry
operator|->
name|MappingInformation
operator|<<=
name|MPI2_DRVMAP0_MAPINFO_SLOT_SHIFT
expr_stmt|;
name|dpm_entry
operator|->
name|MappingInformation
operator||=
name|et_entry
operator|->
name|missing_count
expr_stmt|;
name|dpm_entry
operator|->
name|MappingInformation
operator|=
name|htole16
argument_list|(
name|dpm_entry
operator|->
name|MappingInformation
argument_list|)
expr_stmt|;
name|dpm_entry
operator|->
name|PhysicalBitsMapping
operator|=
name|htole32
argument_list|(
name|et_entry
operator|->
name|phy_bits
argument_list|)
expr_stmt|;
name|dpm_entry
operator|->
name|Reserved1
operator|=
literal|0
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|config_page
operator|.
name|Entry
argument_list|,
operator|(
name|u8
operator|*
operator|)
name|dpm_entry
argument_list|,
sizeof|sizeof
argument_list|(
name|Mpi2DriverMap0Entry_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mps_config_set_dpm_pg0
argument_list|(
name|sc
argument_list|,
operator|&
name|mpi_reply
argument_list|,
operator|&
name|config_page
argument_list|,
name|et_entry
operator|->
name|dpm_entry_num
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s: write of dpm entry %d for enclosure failed\n"
argument_list|,
name|__func__
argument_list|,
name|et_entry
operator|->
name|dpm_entry_num
argument_list|)
expr_stmt|;
name|dpm_entry
operator|->
name|MappingInformation
operator|=
name|le16toh
argument_list|(
name|dpm_entry
operator|->
name|MappingInformation
argument_list|)
expr_stmt|;
name|dpm_entry
operator|->
name|DeviceIndex
operator|=
name|le16toh
argument_list|(
name|dpm_entry
operator|->
name|DeviceIndex
argument_list|)
expr_stmt|;
name|dpm_entry
operator|->
name|PhysicalBitsMapping
operator|=
name|le32toh
argument_list|(
name|dpm_entry
operator|->
name|PhysicalBitsMapping
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|dpm_entry
operator|->
name|MappingInformation
operator|=
name|le16toh
argument_list|(
name|dpm_entry
operator|->
name|MappingInformation
argument_list|)
expr_stmt|;
name|dpm_entry
operator|->
name|DeviceIndex
operator|=
name|le16toh
argument_list|(
name|dpm_entry
operator|->
name|DeviceIndex
argument_list|)
expr_stmt|;
name|dpm_entry
operator|->
name|PhysicalBitsMapping
operator|=
name|le32toh
argument_list|(
name|dpm_entry
operator|->
name|PhysicalBitsMapping
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * _mapping_commit_map_entry - write a particular map table entry in DPM page0.  * @sc: per adapter object  * @enc_entry: enclosure table entry  *  * Returns 0 for success, non-zero for failure.  */
end_comment

begin_function
specifier|static
name|int
name|_mapping_commit_map_entry
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|dev_mapping_table
modifier|*
name|mt_entry
parameter_list|)
block|{
name|Mpi2DriverMap0Entry_t
modifier|*
name|dpm_entry
decl_stmt|;
name|Mpi2ConfigReply_t
name|mpi_reply
decl_stmt|;
name|Mpi2DriverMappingPage0_t
name|config_page
decl_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|is_dpm_enable
condition|)
return|return
literal|0
return|;
name|memset
argument_list|(
operator|&
name|config_page
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|Mpi2DriverMappingPage0_t
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|config_page
operator|.
name|Header
argument_list|,
operator|(
name|u8
operator|*
operator|)
name|sc
operator|->
name|dpm_pg0
argument_list|,
sizeof|sizeof
argument_list|(
name|MPI2_CONFIG_EXTENDED_PAGE_HEADER
argument_list|)
argument_list|)
expr_stmt|;
name|dpm_entry
operator|=
operator|(
name|Mpi2DriverMap0Entry_t
operator|*
operator|)
operator|(
operator|(
name|u8
operator|*
operator|)
name|sc
operator|->
name|dpm_pg0
operator|+
sizeof|sizeof
argument_list|(
name|MPI2_CONFIG_EXTENDED_PAGE_HEADER
argument_list|)
operator|)
expr_stmt|;
name|dpm_entry
operator|=
name|dpm_entry
operator|+
name|mt_entry
operator|->
name|dpm_entry_num
expr_stmt|;
name|dpm_entry
operator|->
name|PhysicalIdentifier
operator|.
name|Low
operator|=
operator|(
literal|0xFFFFFFFF
operator|&
name|mt_entry
operator|->
name|physical_id
operator|)
expr_stmt|;
name|dpm_entry
operator|->
name|PhysicalIdentifier
operator|.
name|High
operator|=
operator|(
name|mt_entry
operator|->
name|physical_id
operator|>>
literal|32
operator|)
expr_stmt|;
name|dpm_entry
operator|->
name|DeviceIndex
operator|=
name|htole16
argument_list|(
name|mt_entry
operator|->
name|id
argument_list|)
expr_stmt|;
name|dpm_entry
operator|->
name|MappingInformation
operator|=
name|htole16
argument_list|(
name|mt_entry
operator|->
name|missing_count
argument_list|)
expr_stmt|;
name|dpm_entry
operator|->
name|PhysicalBitsMapping
operator|=
literal|0
expr_stmt|;
name|dpm_entry
operator|->
name|Reserved1
operator|=
literal|0
expr_stmt|;
name|dpm_entry
operator|->
name|MappingInformation
operator|=
name|htole16
argument_list|(
name|dpm_entry
operator|->
name|MappingInformation
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|config_page
operator|.
name|Entry
argument_list|,
operator|(
name|u8
operator|*
operator|)
name|dpm_entry
argument_list|,
sizeof|sizeof
argument_list|(
name|Mpi2DriverMap0Entry_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mps_config_set_dpm_pg0
argument_list|(
name|sc
argument_list|,
operator|&
name|mpi_reply
argument_list|,
operator|&
name|config_page
argument_list|,
name|mt_entry
operator|->
name|dpm_entry_num
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s: write of dpm entry %d for device failed\n"
argument_list|,
name|__func__
argument_list|,
name|mt_entry
operator|->
name|dpm_entry_num
argument_list|)
expr_stmt|;
name|dpm_entry
operator|->
name|MappingInformation
operator|=
name|le16toh
argument_list|(
name|dpm_entry
operator|->
name|MappingInformation
argument_list|)
expr_stmt|;
name|dpm_entry
operator|->
name|DeviceIndex
operator|=
name|le16toh
argument_list|(
name|dpm_entry
operator|->
name|DeviceIndex
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|dpm_entry
operator|->
name|MappingInformation
operator|=
name|le16toh
argument_list|(
name|dpm_entry
operator|->
name|MappingInformation
argument_list|)
expr_stmt|;
name|dpm_entry
operator|->
name|DeviceIndex
operator|=
name|le16toh
argument_list|(
name|dpm_entry
operator|->
name|DeviceIndex
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * _mapping_get_ir_maprange - get start and end index for IR map range.  * @sc: per adapter object  * @start_idx: place holder for start index  * @end_idx: place holder for end index  *  * The IR volumes can be mapped either at start or end of the mapping table  * this function gets the detail of where IR volume mapping starts and ends  * in the device mapping table  *  * Returns nothing.  */
end_comment

begin_function
specifier|static
name|void
name|_mapping_get_ir_maprange
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|u32
modifier|*
name|start_idx
parameter_list|,
name|u32
modifier|*
name|end_idx
parameter_list|)
block|{
name|u16
name|volume_mapping_flags
decl_stmt|;
name|u16
name|ioc_pg8_flags
init|=
name|le16toh
argument_list|(
name|sc
operator|->
name|ioc_pg8
operator|.
name|Flags
argument_list|)
decl_stmt|;
name|volume_mapping_flags
operator|=
name|le16toh
argument_list|(
name|sc
operator|->
name|ioc_pg8
operator|.
name|IRVolumeMappingFlags
argument_list|)
operator|&
name|MPI2_IOCPAGE8_IRFLAGS_MASK_VOLUME_MAPPING_MODE
expr_stmt|;
if|if
condition|(
name|volume_mapping_flags
operator|==
name|MPI2_IOCPAGE8_IRFLAGS_LOW_VOLUME_MAPPING
condition|)
block|{
operator|*
name|start_idx
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ioc_pg8_flags
operator|&
name|MPI2_IOCPAGE8_FLAGS_RESERVED_TARGETID_0
condition|)
operator|*
name|start_idx
operator|=
literal|1
expr_stmt|;
block|}
else|else
operator|*
name|start_idx
operator|=
name|sc
operator|->
name|max_devices
operator|-
name|sc
operator|->
name|max_volumes
expr_stmt|;
operator|*
name|end_idx
operator|=
operator|*
name|start_idx
operator|+
name|sc
operator|->
name|max_volumes
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * _mapping_get_enc_idx_from_id - get enclosure index from enclosure ID  * @sc: per adapter object  * @enc_id: enclosure logical identifier  *  * Returns the index of enclosure entry on success or bad index.  */
end_comment

begin_function
specifier|static
name|u8
name|_mapping_get_enc_idx_from_id
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|u64
name|enc_id
parameter_list|,
name|u64
name|phy_bits
parameter_list|)
block|{
name|struct
name|enc_mapping_table
modifier|*
name|et_entry
decl_stmt|;
name|u8
name|enc_idx
init|=
literal|0
decl_stmt|;
for|for
control|(
name|enc_idx
operator|=
literal|0
init|;
name|enc_idx
operator|<
name|sc
operator|->
name|num_enc_table_entries
condition|;
name|enc_idx
operator|++
control|)
block|{
name|et_entry
operator|=
operator|&
name|sc
operator|->
name|enclosure_table
index|[
name|enc_idx
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|et_entry
operator|->
name|enclosure_id
operator|==
name|le64toh
argument_list|(
name|enc_id
argument_list|)
operator|)
operator|&&
operator|(
operator|!
name|et_entry
operator|->
name|phy_bits
operator|||
operator|(
name|et_entry
operator|->
name|phy_bits
operator|&
name|le32toh
argument_list|(
name|phy_bits
argument_list|)
operator|)
operator|)
condition|)
return|return
name|enc_idx
return|;
block|}
return|return
name|MPS_ENCTABLE_BAD_IDX
return|;
block|}
end_function

begin_comment
comment|/**  * _mapping_get_enc_idx_from_handle - get enclosure index from handle  * @sc: per adapter object  * @enc_id: enclosure handle  *  * Returns the index of enclosure entry on success or bad index.  */
end_comment

begin_function
specifier|static
name|u8
name|_mapping_get_enc_idx_from_handle
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|u16
name|handle
parameter_list|)
block|{
name|struct
name|enc_mapping_table
modifier|*
name|et_entry
decl_stmt|;
name|u8
name|enc_idx
init|=
literal|0
decl_stmt|;
for|for
control|(
name|enc_idx
operator|=
literal|0
init|;
name|enc_idx
operator|<
name|sc
operator|->
name|num_enc_table_entries
condition|;
name|enc_idx
operator|++
control|)
block|{
name|et_entry
operator|=
operator|&
name|sc
operator|->
name|enclosure_table
index|[
name|enc_idx
index|]
expr_stmt|;
if|if
condition|(
name|et_entry
operator|->
name|missing_count
condition|)
continue|continue;
if|if
condition|(
name|et_entry
operator|->
name|enc_handle
operator|==
name|handle
condition|)
return|return
name|enc_idx
return|;
block|}
return|return
name|MPS_ENCTABLE_BAD_IDX
return|;
block|}
end_function

begin_comment
comment|/**  * _mapping_get_high_missing_et_idx - get missing enclosure index  * @sc: per adapter object  *  * Search through the enclosure table and identifies the enclosure entry  * with high missing count and returns it's index  *  * Returns the index of enclosure entry on success or bad index.  */
end_comment

begin_function
specifier|static
name|u8
name|_mapping_get_high_missing_et_idx
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|enc_mapping_table
modifier|*
name|et_entry
decl_stmt|;
name|u8
name|high_missing_count
init|=
literal|0
decl_stmt|;
name|u8
name|enc_idx
decl_stmt|,
name|high_idx
init|=
name|MPS_ENCTABLE_BAD_IDX
decl_stmt|;
for|for
control|(
name|enc_idx
operator|=
literal|0
init|;
name|enc_idx
operator|<
name|sc
operator|->
name|num_enc_table_entries
condition|;
name|enc_idx
operator|++
control|)
block|{
name|et_entry
operator|=
operator|&
name|sc
operator|->
name|enclosure_table
index|[
name|enc_idx
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|et_entry
operator|->
name|missing_count
operator|>
name|high_missing_count
operator|)
operator|&&
operator|!
name|et_entry
operator|->
name|skip_search
condition|)
block|{
name|high_missing_count
operator|=
name|et_entry
operator|->
name|missing_count
expr_stmt|;
name|high_idx
operator|=
name|enc_idx
expr_stmt|;
block|}
block|}
return|return
name|high_idx
return|;
block|}
end_function

begin_comment
comment|/**  * _mapping_get_high_missing_mt_idx - get missing map table index  * @sc: per adapter object  *  * Search through the map table and identifies the device entry  * with high missing count and returns it's index  *  * Returns the index of map table entry on success or bad index.  */
end_comment

begin_function
specifier|static
name|u32
name|_mapping_get_high_missing_mt_idx
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u32
name|map_idx
decl_stmt|,
name|high_idx
init|=
name|MPS_ENCTABLE_BAD_IDX
decl_stmt|;
name|u8
name|high_missing_count
init|=
literal|0
decl_stmt|;
name|u32
name|start_idx
decl_stmt|,
name|end_idx
decl_stmt|,
name|start_idx_ir
decl_stmt|,
name|end_idx_ir
decl_stmt|;
name|struct
name|dev_mapping_table
modifier|*
name|mt_entry
decl_stmt|;
name|u16
name|ioc_pg8_flags
init|=
name|le16toh
argument_list|(
name|sc
operator|->
name|ioc_pg8
operator|.
name|Flags
argument_list|)
decl_stmt|;
name|start_idx
operator|=
literal|0
expr_stmt|;
name|start_idx_ir
operator|=
literal|0
expr_stmt|;
name|end_idx_ir
operator|=
literal|0
expr_stmt|;
name|end_idx
operator|=
name|sc
operator|->
name|max_devices
expr_stmt|;
if|if
condition|(
name|ioc_pg8_flags
operator|&
name|MPI2_IOCPAGE8_FLAGS_RESERVED_TARGETID_0
condition|)
name|start_idx
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ir_firmware
condition|)
block|{
name|_mapping_get_ir_maprange
argument_list|(
name|sc
argument_list|,
operator|&
name|start_idx_ir
argument_list|,
operator|&
name|end_idx_ir
argument_list|)
expr_stmt|;
if|if
condition|(
name|start_idx
operator|==
name|start_idx_ir
condition|)
name|start_idx
operator|=
name|end_idx_ir
operator|+
literal|1
expr_stmt|;
else|else
name|end_idx
operator|=
name|start_idx_ir
expr_stmt|;
block|}
name|mt_entry
operator|=
operator|&
name|sc
operator|->
name|mapping_table
index|[
name|start_idx
index|]
expr_stmt|;
for|for
control|(
name|map_idx
operator|=
name|start_idx
init|;
name|map_idx
operator|<
name|end_idx
condition|;
name|map_idx
operator|++
operator|,
name|mt_entry
operator|++
control|)
block|{
if|if
condition|(
name|mt_entry
operator|->
name|missing_count
operator|>
name|high_missing_count
condition|)
block|{
name|high_missing_count
operator|=
name|mt_entry
operator|->
name|missing_count
expr_stmt|;
name|high_idx
operator|=
name|map_idx
expr_stmt|;
block|}
block|}
return|return
name|high_idx
return|;
block|}
end_function

begin_comment
comment|/**  * _mapping_get_ir_mt_idx_from_wwid - get map table index from volume WWID  * @sc: per adapter object  * @wwid: world wide unique ID of the volume  *  * Returns the index of map table entry on success or bad index.  */
end_comment

begin_function
specifier|static
name|u32
name|_mapping_get_ir_mt_idx_from_wwid
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|u64
name|wwid
parameter_list|)
block|{
name|u32
name|start_idx
decl_stmt|,
name|end_idx
decl_stmt|,
name|map_idx
decl_stmt|;
name|struct
name|dev_mapping_table
modifier|*
name|mt_entry
decl_stmt|;
name|_mapping_get_ir_maprange
argument_list|(
name|sc
argument_list|,
operator|&
name|start_idx
argument_list|,
operator|&
name|end_idx
argument_list|)
expr_stmt|;
name|mt_entry
operator|=
operator|&
name|sc
operator|->
name|mapping_table
index|[
name|start_idx
index|]
expr_stmt|;
for|for
control|(
name|map_idx
operator|=
name|start_idx
init|;
name|map_idx
operator|<=
name|end_idx
condition|;
name|map_idx
operator|++
operator|,
name|mt_entry
operator|++
control|)
if|if
condition|(
name|mt_entry
operator|->
name|physical_id
operator|==
name|wwid
condition|)
return|return
name|map_idx
return|;
return|return
name|MPS_MAPTABLE_BAD_IDX
return|;
block|}
end_function

begin_comment
comment|/**  * _mapping_get_mt_idx_from_id - get map table index from a device ID  * @sc: per adapter object  * @dev_id: device identifer (SAS Address)  *  * Returns the index of map table entry on success or bad index.  */
end_comment

begin_function
specifier|static
name|u32
name|_mapping_get_mt_idx_from_id
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|u64
name|dev_id
parameter_list|)
block|{
name|u32
name|map_idx
decl_stmt|;
name|struct
name|dev_mapping_table
modifier|*
name|mt_entry
decl_stmt|;
for|for
control|(
name|map_idx
operator|=
literal|0
init|;
name|map_idx
operator|<
name|sc
operator|->
name|max_devices
condition|;
name|map_idx
operator|++
control|)
block|{
name|mt_entry
operator|=
operator|&
name|sc
operator|->
name|mapping_table
index|[
name|map_idx
index|]
expr_stmt|;
if|if
condition|(
name|mt_entry
operator|->
name|physical_id
operator|==
name|dev_id
condition|)
return|return
name|map_idx
return|;
block|}
return|return
name|MPS_MAPTABLE_BAD_IDX
return|;
block|}
end_function

begin_comment
comment|/**  * _mapping_get_ir_mt_idx_from_handle - get map table index from volume handle  * @sc: per adapter object  * @wwid: volume device handle  *  * Returns the index of map table entry on success or bad index.  */
end_comment

begin_function
specifier|static
name|u32
name|_mapping_get_ir_mt_idx_from_handle
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|u16
name|volHandle
parameter_list|)
block|{
name|u32
name|start_idx
decl_stmt|,
name|end_idx
decl_stmt|,
name|map_idx
decl_stmt|;
name|struct
name|dev_mapping_table
modifier|*
name|mt_entry
decl_stmt|;
name|_mapping_get_ir_maprange
argument_list|(
name|sc
argument_list|,
operator|&
name|start_idx
argument_list|,
operator|&
name|end_idx
argument_list|)
expr_stmt|;
name|mt_entry
operator|=
operator|&
name|sc
operator|->
name|mapping_table
index|[
name|start_idx
index|]
expr_stmt|;
for|for
control|(
name|map_idx
operator|=
name|start_idx
init|;
name|map_idx
operator|<=
name|end_idx
condition|;
name|map_idx
operator|++
operator|,
name|mt_entry
operator|++
control|)
if|if
condition|(
name|mt_entry
operator|->
name|dev_handle
operator|==
name|volHandle
condition|)
return|return
name|map_idx
return|;
return|return
name|MPS_MAPTABLE_BAD_IDX
return|;
block|}
end_function

begin_comment
comment|/**  * _mapping_get_mt_idx_from_handle - get map table index from handle  * @sc: per adapter object  * @dev_id: device handle  *  * Returns the index of map table entry on success or bad index.  */
end_comment

begin_function
specifier|static
name|u32
name|_mapping_get_mt_idx_from_handle
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|u16
name|handle
parameter_list|)
block|{
name|u32
name|map_idx
decl_stmt|;
name|struct
name|dev_mapping_table
modifier|*
name|mt_entry
decl_stmt|;
for|for
control|(
name|map_idx
operator|=
literal|0
init|;
name|map_idx
operator|<
name|sc
operator|->
name|max_devices
condition|;
name|map_idx
operator|++
control|)
block|{
name|mt_entry
operator|=
operator|&
name|sc
operator|->
name|mapping_table
index|[
name|map_idx
index|]
expr_stmt|;
if|if
condition|(
name|mt_entry
operator|->
name|dev_handle
operator|==
name|handle
condition|)
return|return
name|map_idx
return|;
block|}
return|return
name|MPS_MAPTABLE_BAD_IDX
return|;
block|}
end_function

begin_comment
comment|/**  * _mapping_get_free_ir_mt_idx - get first free index for a volume  * @sc: per adapter object  *  * Search through mapping table for free index for a volume and if no free  * index then looks for a volume with high mapping index  *  * Returns the index of map table entry on success or bad index.  */
end_comment

begin_function
specifier|static
name|u32
name|_mapping_get_free_ir_mt_idx
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u8
name|high_missing_count
init|=
literal|0
decl_stmt|;
name|u32
name|start_idx
decl_stmt|,
name|end_idx
decl_stmt|,
name|map_idx
decl_stmt|;
name|u32
name|high_idx
init|=
name|MPS_MAPTABLE_BAD_IDX
decl_stmt|;
name|struct
name|dev_mapping_table
modifier|*
name|mt_entry
decl_stmt|;
name|_mapping_get_ir_maprange
argument_list|(
name|sc
argument_list|,
operator|&
name|start_idx
argument_list|,
operator|&
name|end_idx
argument_list|)
expr_stmt|;
name|mt_entry
operator|=
operator|&
name|sc
operator|->
name|mapping_table
index|[
name|start_idx
index|]
expr_stmt|;
for|for
control|(
name|map_idx
operator|=
name|start_idx
init|;
name|map_idx
operator|<=
name|end_idx
condition|;
name|map_idx
operator|++
operator|,
name|mt_entry
operator|++
control|)
if|if
condition|(
operator|!
operator|(
name|mt_entry
operator|->
name|device_info
operator|&
name|MPS_MAP_IN_USE
operator|)
condition|)
return|return
name|map_idx
return|;
name|mt_entry
operator|=
operator|&
name|sc
operator|->
name|mapping_table
index|[
name|start_idx
index|]
expr_stmt|;
for|for
control|(
name|map_idx
operator|=
name|start_idx
init|;
name|map_idx
operator|<=
name|end_idx
condition|;
name|map_idx
operator|++
operator|,
name|mt_entry
operator|++
control|)
block|{
if|if
condition|(
name|mt_entry
operator|->
name|missing_count
operator|>
name|high_missing_count
condition|)
block|{
name|high_missing_count
operator|=
name|mt_entry
operator|->
name|missing_count
expr_stmt|;
name|high_idx
operator|=
name|map_idx
expr_stmt|;
block|}
block|}
return|return
name|high_idx
return|;
block|}
end_function

begin_comment
comment|/**  * _mapping_get_free_mt_idx - get first free index for a device  * @sc: per adapter object  * @start_idx: offset in the table to start search  *  * Returns the index of map table entry on success or bad index.  */
end_comment

begin_function
specifier|static
name|u32
name|_mapping_get_free_mt_idx
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|u32
name|start_idx
parameter_list|)
block|{
name|u32
name|map_idx
decl_stmt|,
name|max_idx
init|=
name|sc
operator|->
name|max_devices
decl_stmt|;
name|struct
name|dev_mapping_table
modifier|*
name|mt_entry
init|=
operator|&
name|sc
operator|->
name|mapping_table
index|[
name|start_idx
index|]
decl_stmt|;
name|u16
name|volume_mapping_flags
decl_stmt|;
name|volume_mapping_flags
operator|=
name|le16toh
argument_list|(
name|sc
operator|->
name|ioc_pg8
operator|.
name|IRVolumeMappingFlags
argument_list|)
operator|&
name|MPI2_IOCPAGE8_IRFLAGS_MASK_VOLUME_MAPPING_MODE
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ir_firmware
operator|&&
operator|(
name|volume_mapping_flags
operator|==
name|MPI2_IOCPAGE8_IRFLAGS_HIGH_VOLUME_MAPPING
operator|)
condition|)
name|max_idx
operator|-=
name|sc
operator|->
name|max_volumes
expr_stmt|;
for|for
control|(
name|map_idx
operator|=
name|start_idx
init|;
name|map_idx
operator|<
name|max_idx
condition|;
name|map_idx
operator|++
operator|,
name|mt_entry
operator|++
control|)
if|if
condition|(
operator|!
operator|(
name|mt_entry
operator|->
name|device_info
operator|&
operator|(
name|MPS_MAP_IN_USE
operator||
name|MPS_DEV_RESERVED
operator|)
operator|)
condition|)
return|return
name|map_idx
return|;
return|return
name|MPS_MAPTABLE_BAD_IDX
return|;
block|}
end_function

begin_comment
comment|/**  * _mapping_get_dpm_idx_from_id - get DPM index from ID  * @sc: per adapter object  * @id: volume WWID or enclosure ID or device ID  *  * Returns the index of DPM entry on success or bad index.  */
end_comment

begin_function
specifier|static
name|u16
name|_mapping_get_dpm_idx_from_id
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|u64
name|id
parameter_list|,
name|u32
name|phy_bits
parameter_list|)
block|{
name|u16
name|entry_num
decl_stmt|;
name|uint64_t
name|PhysicalIdentifier
decl_stmt|;
name|Mpi2DriverMap0Entry_t
modifier|*
name|dpm_entry
decl_stmt|;
name|dpm_entry
operator|=
operator|(
name|Mpi2DriverMap0Entry_t
operator|*
operator|)
operator|(
operator|(
name|u8
operator|*
operator|)
name|sc
operator|->
name|dpm_pg0
operator|+
sizeof|sizeof
argument_list|(
name|MPI2_CONFIG_EXTENDED_PAGE_HEADER
argument_list|)
operator|)
expr_stmt|;
name|PhysicalIdentifier
operator|=
name|dpm_entry
operator|->
name|PhysicalIdentifier
operator|.
name|High
expr_stmt|;
name|PhysicalIdentifier
operator|=
operator|(
name|PhysicalIdentifier
operator|<<
literal|32
operator|)
operator||
name|dpm_entry
operator|->
name|PhysicalIdentifier
operator|.
name|Low
expr_stmt|;
for|for
control|(
name|entry_num
operator|=
literal|0
init|;
name|entry_num
operator|<
name|sc
operator|->
name|max_dpm_entries
condition|;
name|entry_num
operator|++
operator|,
name|dpm_entry
operator|++
control|)
if|if
condition|(
operator|(
name|id
operator|==
name|PhysicalIdentifier
operator|)
operator|&&
operator|(
operator|!
name|phy_bits
operator|||
operator|!
name|dpm_entry
operator|->
name|PhysicalBitsMapping
operator|||
operator|(
name|phy_bits
operator|&
name|dpm_entry
operator|->
name|PhysicalBitsMapping
operator|)
operator|)
condition|)
return|return
name|entry_num
return|;
return|return
name|MPS_DPM_BAD_IDX
return|;
block|}
end_function

begin_comment
comment|/**  * _mapping_get_free_dpm_idx - get first available DPM index  * @sc: per adapter object  *  * Returns the index of DPM entry on success or bad index.  */
end_comment

begin_function
specifier|static
name|u32
name|_mapping_get_free_dpm_idx
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u16
name|entry_num
decl_stmt|;
for|for
control|(
name|entry_num
operator|=
literal|0
init|;
name|entry_num
operator|<
name|sc
operator|->
name|max_dpm_entries
condition|;
name|entry_num
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|sc
operator|->
name|dpm_entry_used
index|[
name|entry_num
index|]
condition|)
return|return
name|entry_num
return|;
block|}
return|return
name|MPS_DPM_BAD_IDX
return|;
block|}
end_function

begin_comment
comment|/**  * _mapping_update_ir_missing_cnt - Updates missing count for a volume  * @sc: per adapter object  * @map_idx: map table index of the volume  * @element: IR configuration change element  * @wwid: IR volume ID.  *  * Updates the missing count in the map table and in the DPM entry for a volume  *  * Returns nothing.  */
end_comment

begin_function
specifier|static
name|void
name|_mapping_update_ir_missing_cnt
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|u32
name|map_idx
parameter_list|,
name|Mpi2EventIrConfigElement_t
modifier|*
name|element
parameter_list|,
name|u64
name|wwid
parameter_list|)
block|{
name|struct
name|dev_mapping_table
modifier|*
name|mt_entry
decl_stmt|;
name|u8
name|missing_cnt
decl_stmt|,
name|reason
init|=
name|element
operator|->
name|ReasonCode
decl_stmt|;
name|u16
name|dpm_idx
decl_stmt|;
name|Mpi2DriverMap0Entry_t
modifier|*
name|dpm_entry
decl_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|is_dpm_enable
condition|)
return|return;
name|mt_entry
operator|=
operator|&
name|sc
operator|->
name|mapping_table
index|[
name|map_idx
index|]
expr_stmt|;
if|if
condition|(
name|reason
operator|==
name|MPI2_EVENT_IR_CHANGE_RC_ADDED
condition|)
block|{
name|mt_entry
operator|->
name|missing_count
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|reason
operator|==
name|MPI2_EVENT_IR_CHANGE_RC_VOLUME_CREATED
condition|)
block|{
name|mt_entry
operator|->
name|missing_count
operator|=
literal|0
expr_stmt|;
name|mt_entry
operator|->
name|init_complete
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|reason
operator|==
name|MPI2_EVENT_IR_CHANGE_RC_REMOVED
operator|)
operator|||
operator|(
name|reason
operator|==
name|MPI2_EVENT_IR_CHANGE_RC_VOLUME_DELETED
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|mt_entry
operator|->
name|init_complete
condition|)
block|{
if|if
condition|(
name|mt_entry
operator|->
name|missing_count
operator|<
name|MPS_MAX_MISSING_COUNT
condition|)
name|mt_entry
operator|->
name|missing_count
operator|++
expr_stmt|;
else|else
name|mt_entry
operator|->
name|init_complete
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|mt_entry
operator|->
name|missing_count
condition|)
name|mt_entry
operator|->
name|missing_count
operator|++
expr_stmt|;
name|mt_entry
operator|->
name|dev_handle
operator|=
literal|0
expr_stmt|;
block|}
name|dpm_idx
operator|=
name|mt_entry
operator|->
name|dpm_entry_num
expr_stmt|;
if|if
condition|(
name|dpm_idx
operator|==
name|MPS_DPM_BAD_IDX
condition|)
block|{
if|if
condition|(
operator|(
name|reason
operator|==
name|MPI2_EVENT_IR_CHANGE_RC_ADDED
operator|)
operator|||
operator|(
name|reason
operator|==
name|MPI2_EVENT_IR_CHANGE_RC_REMOVED
operator|)
condition|)
name|dpm_idx
operator|=
name|_mapping_get_dpm_idx_from_id
argument_list|(
name|sc
argument_list|,
name|mt_entry
operator|->
name|physical_id
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|reason
operator|==
name|MPI2_EVENT_IR_CHANGE_RC_VOLUME_DELETED
condition|)
return|return;
block|}
if|if
condition|(
name|dpm_idx
operator|!=
name|MPS_DPM_BAD_IDX
condition|)
block|{
name|dpm_entry
operator|=
operator|(
name|Mpi2DriverMap0Entry_t
operator|*
operator|)
operator|(
operator|(
name|u8
operator|*
operator|)
name|sc
operator|->
name|dpm_pg0
operator|+
sizeof|sizeof
argument_list|(
name|MPI2_CONFIG_EXTENDED_PAGE_HEADER
argument_list|)
operator|)
expr_stmt|;
name|dpm_entry
operator|+=
name|dpm_idx
expr_stmt|;
name|missing_cnt
operator|=
name|dpm_entry
operator|->
name|MappingInformation
operator|&
name|MPI2_DRVMAP0_MAPINFO_MISSING_MASK
expr_stmt|;
if|if
condition|(
operator|(
name|mt_entry
operator|->
name|physical_id
operator|==
name|le64toh
argument_list|(
operator|(
name|u64
operator|)
name|dpm_entry
operator|->
name|PhysicalIdentifier
operator|.
name|High
operator||
name|dpm_entry
operator|->
name|PhysicalIdentifier
operator|.
name|Low
argument_list|)
operator|)
operator|&&
operator|(
name|missing_cnt
operator|==
name|mt_entry
operator|->
name|missing_count
operator|)
condition|)
name|mt_entry
operator|->
name|init_complete
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|dpm_idx
operator|=
name|_mapping_get_free_dpm_idx
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mt_entry
operator|->
name|init_complete
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|dpm_idx
operator|!=
name|MPS_DPM_BAD_IDX
operator|)
operator|&&
operator|!
name|mt_entry
operator|->
name|init_complete
condition|)
block|{
name|mt_entry
operator|->
name|init_complete
operator|=
literal|1
expr_stmt|;
name|mt_entry
operator|->
name|dpm_entry_num
operator|=
name|dpm_idx
expr_stmt|;
name|dpm_entry
operator|=
operator|(
name|Mpi2DriverMap0Entry_t
operator|*
operator|)
operator|(
operator|(
name|u8
operator|*
operator|)
name|sc
operator|->
name|dpm_pg0
operator|+
sizeof|sizeof
argument_list|(
name|MPI2_CONFIG_EXTENDED_PAGE_HEADER
argument_list|)
operator|)
expr_stmt|;
name|dpm_entry
operator|+=
name|dpm_idx
expr_stmt|;
name|dpm_entry
operator|->
name|PhysicalIdentifier
operator|.
name|Low
operator|=
operator|(
literal|0xFFFFFFFF
operator|&
name|mt_entry
operator|->
name|physical_id
operator|)
expr_stmt|;
name|dpm_entry
operator|->
name|PhysicalIdentifier
operator|.
name|High
operator|=
operator|(
name|mt_entry
operator|->
name|physical_id
operator|>>
literal|32
operator|)
expr_stmt|;
name|dpm_entry
operator|->
name|DeviceIndex
operator|=
name|map_idx
expr_stmt|;
name|dpm_entry
operator|->
name|MappingInformation
operator|=
name|mt_entry
operator|->
name|missing_count
expr_stmt|;
name|dpm_entry
operator|->
name|PhysicalBitsMapping
operator|=
literal|0
expr_stmt|;
name|dpm_entry
operator|->
name|Reserved1
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|dpm_flush_entry
index|[
name|dpm_idx
index|]
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|dpm_entry_used
index|[
name|dpm_idx
index|]
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dpm_idx
operator|==
name|MPS_DPM_BAD_IDX
condition|)
block|{
name|printf
argument_list|(
literal|"%s: no space to add entry in DPM table\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|mt_entry
operator|->
name|init_complete
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * _mapping_add_to_removal_table - mark an entry for removal  * @sc: per adapter object  * @handle: Handle of enclosures/device/volume  *  * Adds the handle or DPM entry number in removal table.  *  * Returns nothing.  */
end_comment

begin_function
specifier|static
name|void
name|_mapping_add_to_removal_table
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|u16
name|handle
parameter_list|,
name|u16
name|dpm_idx
parameter_list|)
block|{
name|struct
name|map_removal_table
modifier|*
name|remove_entry
decl_stmt|;
name|u32
name|i
decl_stmt|;
name|u16
name|ioc_pg8_flags
init|=
name|le16toh
argument_list|(
name|sc
operator|->
name|ioc_pg8
operator|.
name|Flags
argument_list|)
decl_stmt|;
name|remove_entry
operator|=
name|sc
operator|->
name|removal_table
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|max_devices
condition|;
name|i
operator|++
operator|,
name|remove_entry
operator|++
control|)
block|{
if|if
condition|(
name|remove_entry
operator|->
name|dev_handle
operator|||
name|remove_entry
operator|->
name|dpm_entry_num
operator|!=
name|MPS_DPM_BAD_IDX
condition|)
continue|continue;
if|if
condition|(
operator|(
name|ioc_pg8_flags
operator|&
name|MPI2_IOCPAGE8_FLAGS_MASK_MAPPING_MODE
operator|)
operator|==
name|MPI2_IOCPAGE8_FLAGS_ENCLOSURE_SLOT_MAPPING
condition|)
block|{
if|if
condition|(
name|dpm_idx
condition|)
name|remove_entry
operator|->
name|dpm_entry_num
operator|=
name|dpm_idx
expr_stmt|;
if|if
condition|(
name|remove_entry
operator|->
name|dpm_entry_num
operator|==
name|MPS_DPM_BAD_IDX
condition|)
name|remove_entry
operator|->
name|dev_handle
operator|=
name|handle
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ioc_pg8_flags
operator|&
name|MPI2_IOCPAGE8_FLAGS_MASK_MAPPING_MODE
operator|)
operator|==
name|MPI2_IOCPAGE8_FLAGS_DEVICE_PERSISTENCE_MAPPING
condition|)
name|remove_entry
operator|->
name|dev_handle
operator|=
name|handle
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/**  * _mapping_update_missing_count - Update missing count for a device  * @sc: per adapter object  * @topo_change: Topology change event entry  *  * Search through the topology change list and if any device is found not  * responding it's associated map table entry and DPM entry is updated  *  * Returns nothing.  */
end_comment

begin_function
specifier|static
name|void
name|_mapping_update_missing_count
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|_map_topology_change
modifier|*
name|topo_change
parameter_list|)
block|{
name|u16
name|ioc_pg8_flags
init|=
name|le16toh
argument_list|(
name|sc
operator|->
name|ioc_pg8
operator|.
name|Flags
argument_list|)
decl_stmt|;
name|u8
name|entry
decl_stmt|;
name|struct
name|_map_phy_change
modifier|*
name|phy_change
decl_stmt|;
name|u32
name|map_idx
decl_stmt|;
name|struct
name|dev_mapping_table
modifier|*
name|mt_entry
decl_stmt|;
name|Mpi2DriverMap0Entry_t
modifier|*
name|dpm_entry
decl_stmt|;
for|for
control|(
name|entry
operator|=
literal|0
init|;
name|entry
operator|<
name|topo_change
operator|->
name|num_entries
condition|;
name|entry
operator|++
control|)
block|{
name|phy_change
operator|=
operator|&
name|topo_change
operator|->
name|phy_details
index|[
name|entry
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|phy_change
operator|->
name|dev_handle
operator|||
operator|(
name|phy_change
operator|->
name|reason
operator|!=
name|MPI2_EVENT_SAS_TOPO_RC_TARG_NOT_RESPONDING
operator|)
condition|)
continue|continue;
name|map_idx
operator|=
name|_mapping_get_mt_idx_from_handle
argument_list|(
name|sc
argument_list|,
name|phy_change
operator|->
name|dev_handle
argument_list|)
expr_stmt|;
name|phy_change
operator|->
name|is_processed
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|map_idx
operator|==
name|MPS_MAPTABLE_BAD_IDX
condition|)
block|{
name|printf
argument_list|(
literal|"%s: device is already removed from mapping "
literal|"table\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|mt_entry
operator|=
operator|&
name|sc
operator|->
name|mapping_table
index|[
name|map_idx
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|mt_entry
operator|->
name|init_complete
condition|)
block|{
if|if
condition|(
name|mt_entry
operator|->
name|missing_count
operator|<
name|MPS_MAX_MISSING_COUNT
condition|)
name|mt_entry
operator|->
name|missing_count
operator|++
expr_stmt|;
else|else
name|mt_entry
operator|->
name|init_complete
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|mt_entry
operator|->
name|missing_count
condition|)
name|mt_entry
operator|->
name|missing_count
operator|++
expr_stmt|;
name|_mapping_add_to_removal_table
argument_list|(
name|sc
argument_list|,
name|mt_entry
operator|->
name|dev_handle
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mt_entry
operator|->
name|dev_handle
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|ioc_pg8_flags
operator|&
name|MPI2_IOCPAGE8_FLAGS_MASK_MAPPING_MODE
operator|)
operator|==
name|MPI2_IOCPAGE8_FLAGS_DEVICE_PERSISTENCE_MAPPING
operator|)
operator|&&
name|sc
operator|->
name|is_dpm_enable
operator|&&
operator|!
name|mt_entry
operator|->
name|init_complete
operator|&&
name|mt_entry
operator|->
name|dpm_entry_num
operator|!=
name|MPS_DPM_BAD_IDX
condition|)
block|{
name|dpm_entry
operator|=
operator|(
name|Mpi2DriverMap0Entry_t
operator|*
operator|)
operator|(
operator|(
name|u8
operator|*
operator|)
name|sc
operator|->
name|dpm_pg0
operator|+
sizeof|sizeof
argument_list|(
name|MPI2_CONFIG_EXTENDED_PAGE_HEADER
argument_list|)
operator|)
expr_stmt|;
name|dpm_entry
operator|+=
name|mt_entry
operator|->
name|dpm_entry_num
expr_stmt|;
name|dpm_entry
operator|->
name|MappingInformation
operator|=
name|mt_entry
operator|->
name|missing_count
expr_stmt|;
name|sc
operator|->
name|dpm_flush_entry
index|[
name|mt_entry
operator|->
name|dpm_entry_num
index|]
operator|=
literal|1
expr_stmt|;
block|}
name|mt_entry
operator|->
name|init_complete
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * _mapping_find_enc_map_space -find map table entries for enclosure  * @sc: per adapter object  * @et_entry: enclosure entry  *  * Search through the mapping table defragment it and provide contiguous  * space in map table for a particular enclosure entry  *  * Returns start index in map table or bad index.  */
end_comment

begin_function
specifier|static
name|u32
name|_mapping_find_enc_map_space
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|enc_mapping_table
modifier|*
name|et_entry
parameter_list|)
block|{
name|u16
name|vol_mapping_flags
decl_stmt|;
name|u32
name|skip_count
decl_stmt|,
name|end_of_table
decl_stmt|,
name|map_idx
decl_stmt|,
name|enc_idx
decl_stmt|;
name|u16
name|num_found
decl_stmt|;
name|u32
name|start_idx
init|=
name|MPS_MAPTABLE_BAD_IDX
decl_stmt|;
name|struct
name|dev_mapping_table
modifier|*
name|mt_entry
decl_stmt|;
name|struct
name|enc_mapping_table
modifier|*
name|enc_entry
decl_stmt|;
name|unsigned
name|char
name|done_flag
init|=
literal|0
decl_stmt|,
name|found_space
decl_stmt|;
name|u16
name|max_num_phy_ids
init|=
name|le16toh
argument_list|(
name|sc
operator|->
name|ioc_pg8
operator|.
name|MaxNumPhysicalMappedIDs
argument_list|)
decl_stmt|;
name|skip_count
operator|=
name|sc
operator|->
name|num_rsvd_entries
expr_stmt|;
name|num_found
operator|=
literal|0
expr_stmt|;
name|vol_mapping_flags
operator|=
name|le16toh
argument_list|(
name|sc
operator|->
name|ioc_pg8
operator|.
name|IRVolumeMappingFlags
argument_list|)
operator|&
name|MPI2_IOCPAGE8_IRFLAGS_MASK_VOLUME_MAPPING_MODE
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|ir_firmware
condition|)
name|end_of_table
operator|=
name|sc
operator|->
name|max_devices
expr_stmt|;
elseif|else
if|if
condition|(
name|vol_mapping_flags
operator|==
name|MPI2_IOCPAGE8_IRFLAGS_LOW_VOLUME_MAPPING
condition|)
name|end_of_table
operator|=
name|sc
operator|->
name|max_devices
expr_stmt|;
else|else
name|end_of_table
operator|=
name|sc
operator|->
name|max_devices
operator|-
name|sc
operator|->
name|max_volumes
expr_stmt|;
for|for
control|(
name|map_idx
operator|=
operator|(
name|max_num_phy_ids
operator|+
name|skip_count
operator|)
init|;
name|map_idx
operator|<
name|end_of_table
condition|;
name|map_idx
operator|++
control|)
block|{
name|mt_entry
operator|=
operator|&
name|sc
operator|->
name|mapping_table
index|[
name|map_idx
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|et_entry
operator|->
name|enclosure_id
operator|==
name|mt_entry
operator|->
name|physical_id
operator|)
operator|&&
operator|(
operator|!
name|mt_entry
operator|->
name|phy_bits
operator|||
operator|(
name|mt_entry
operator|->
name|phy_bits
operator|&
name|et_entry
operator|->
name|phy_bits
operator|)
operator|)
condition|)
block|{
name|num_found
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|num_found
operator|==
name|et_entry
operator|->
name|num_slots
condition|)
block|{
name|start_idx
operator|=
operator|(
name|map_idx
operator|-
name|num_found
operator|)
operator|+
literal|1
expr_stmt|;
return|return
name|start_idx
return|;
block|}
block|}
else|else
name|num_found
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|map_idx
operator|=
operator|(
name|max_num_phy_ids
operator|+
name|skip_count
operator|)
init|;
name|map_idx
operator|<
name|end_of_table
condition|;
name|map_idx
operator|++
control|)
block|{
name|mt_entry
operator|=
operator|&
name|sc
operator|->
name|mapping_table
index|[
name|map_idx
index|]
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|mt_entry
operator|->
name|device_info
operator|&
name|MPS_DEV_RESERVED
operator|)
condition|)
block|{
name|num_found
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|num_found
operator|==
name|et_entry
operator|->
name|num_slots
condition|)
block|{
name|start_idx
operator|=
operator|(
name|map_idx
operator|-
name|num_found
operator|)
operator|+
literal|1
expr_stmt|;
return|return
name|start_idx
return|;
block|}
block|}
else|else
name|num_found
operator|=
literal|0
expr_stmt|;
block|}
while|while
condition|(
operator|!
name|done_flag
condition|)
block|{
name|enc_idx
operator|=
name|_mapping_get_high_missing_et_idx
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|enc_idx
operator|==
name|MPS_ENCTABLE_BAD_IDX
condition|)
return|return
name|MPS_MAPTABLE_BAD_IDX
return|;
name|enc_entry
operator|=
operator|&
name|sc
operator|->
name|enclosure_table
index|[
name|enc_idx
index|]
expr_stmt|;
comment|/*VSP FIXME*/
name|enc_entry
operator|->
name|skip_search
operator|=
literal|1
expr_stmt|;
name|mt_entry
operator|=
operator|&
name|sc
operator|->
name|mapping_table
index|[
name|enc_entry
operator|->
name|start_index
index|]
expr_stmt|;
for|for
control|(
name|map_idx
operator|=
name|enc_entry
operator|->
name|start_index
init|;
name|map_idx
operator|<
operator|(
name|enc_entry
operator|->
name|start_index
operator|+
name|enc_entry
operator|->
name|num_slots
operator|)
condition|;
name|map_idx
operator|++
operator|,
name|mt_entry
operator|++
control|)
name|mt_entry
operator|->
name|device_info
operator|&=
operator|~
name|MPS_DEV_RESERVED
expr_stmt|;
name|found_space
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|map_idx
operator|=
operator|(
name|max_num_phy_ids
operator|+
name|skip_count
operator|)
init|;
name|map_idx
operator|<
name|end_of_table
condition|;
name|map_idx
operator|++
control|)
block|{
name|mt_entry
operator|=
operator|&
name|sc
operator|->
name|mapping_table
index|[
name|map_idx
index|]
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|mt_entry
operator|->
name|device_info
operator|&
name|MPS_DEV_RESERVED
operator|)
condition|)
block|{
name|num_found
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|num_found
operator|==
name|et_entry
operator|->
name|num_slots
condition|)
block|{
name|start_idx
operator|=
operator|(
name|map_idx
operator|-
name|num_found
operator|)
operator|+
literal|1
expr_stmt|;
name|found_space
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
name|num_found
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|found_space
condition|)
continue|continue;
for|for
control|(
name|map_idx
operator|=
name|start_idx
init|;
name|map_idx
operator|<
operator|(
name|start_idx
operator|+
name|num_found
operator|)
condition|;
name|map_idx
operator|++
control|)
block|{
name|enc_entry
operator|=
name|sc
operator|->
name|enclosure_table
expr_stmt|;
for|for
control|(
name|enc_idx
operator|=
literal|0
init|;
name|enc_idx
operator|<
name|sc
operator|->
name|num_enc_table_entries
condition|;
name|enc_idx
operator|++
operator|,
name|enc_entry
operator|++
control|)
block|{
if|if
condition|(
name|map_idx
operator|<
name|enc_entry
operator|->
name|start_index
operator|||
name|map_idx
operator|>
operator|(
name|enc_entry
operator|->
name|start_index
operator|+
name|enc_entry
operator|->
name|num_slots
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|enc_entry
operator|->
name|removal_flag
condition|)
block|{
name|enc_entry
operator|->
name|removal_flag
operator|=
literal|1
expr_stmt|;
name|_mapping_add_to_removal_table
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|enc_entry
operator|->
name|dpm_entry_num
argument_list|)
expr_stmt|;
block|}
name|mt_entry
operator|=
operator|&
name|sc
operator|->
name|mapping_table
index|[
name|map_idx
index|]
expr_stmt|;
if|if
condition|(
name|mt_entry
operator|->
name|device_info
operator|&
name|MPS_MAP_IN_USE
condition|)
block|{
name|_mapping_add_to_removal_table
argument_list|(
name|sc
argument_list|,
name|mt_entry
operator|->
name|dev_handle
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|_mapping_clear_map_entry
argument_list|(
name|mt_entry
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|map_idx
operator|==
operator|(
name|enc_entry
operator|->
name|start_index
operator|+
name|enc_entry
operator|->
name|num_slots
operator|-
literal|1
operator|)
condition|)
name|_mapping_clear_enc_entry
argument_list|(
name|et_entry
argument_list|)
expr_stmt|;
block|}
block|}
name|enc_entry
operator|=
name|sc
operator|->
name|enclosure_table
expr_stmt|;
for|for
control|(
name|enc_idx
operator|=
literal|0
init|;
name|enc_idx
operator|<
name|sc
operator|->
name|num_enc_table_entries
condition|;
name|enc_idx
operator|++
operator|,
name|enc_entry
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|enc_entry
operator|->
name|removal_flag
condition|)
block|{
name|mt_entry
operator|=
operator|&
name|sc
operator|->
name|mapping_table
index|[
name|enc_entry
operator|->
name|start_index
index|]
expr_stmt|;
for|for
control|(
name|map_idx
operator|=
name|enc_entry
operator|->
name|start_index
init|;
name|map_idx
operator|<
operator|(
name|enc_entry
operator|->
name|start_index
operator|+
name|enc_entry
operator|->
name|num_slots
operator|)
condition|;
name|map_idx
operator|++
operator|,
name|mt_entry
operator|++
control|)
name|mt_entry
operator|->
name|device_info
operator||=
name|MPS_DEV_RESERVED
expr_stmt|;
name|et_entry
operator|->
name|skip_search
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|done_flag
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|start_idx
return|;
block|}
end_function

begin_comment
comment|/**  * _mapping_get_dev_info -get information about newly added devices  * @sc: per adapter object  * @topo_change: Topology change event entry  *  * Search through the topology change event list and issues sas device pg0  * requests for the newly added device and reserved entries in tables  *  * Returns nothing  */
end_comment

begin_function
specifier|static
name|void
name|_mapping_get_dev_info
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|_map_topology_change
modifier|*
name|topo_change
parameter_list|)
block|{
name|u16
name|ioc_pg8_flags
init|=
name|le16toh
argument_list|(
name|sc
operator|->
name|ioc_pg8
operator|.
name|Flags
argument_list|)
decl_stmt|;
name|Mpi2ConfigReply_t
name|mpi_reply
decl_stmt|;
name|Mpi2SasDevicePage0_t
name|sas_device_pg0
decl_stmt|;
name|u8
name|entry
decl_stmt|,
name|enc_idx
decl_stmt|,
name|phy_idx
decl_stmt|;
name|u32
name|map_idx
decl_stmt|,
name|index
decl_stmt|,
name|device_info
decl_stmt|;
name|struct
name|_map_phy_change
modifier|*
name|phy_change
decl_stmt|,
modifier|*
name|tmp_phy_change
decl_stmt|;
name|uint64_t
name|sas_address
decl_stmt|;
name|struct
name|enc_mapping_table
modifier|*
name|et_entry
decl_stmt|;
name|struct
name|dev_mapping_table
modifier|*
name|mt_entry
decl_stmt|;
name|u8
name|add_code
init|=
name|MPI2_EVENT_SAS_TOPO_RC_TARG_ADDED
decl_stmt|;
name|int
name|rc
init|=
literal|1
decl_stmt|;
for|for
control|(
name|entry
operator|=
literal|0
init|;
name|entry
operator|<
name|topo_change
operator|->
name|num_entries
condition|;
name|entry
operator|++
control|)
block|{
name|phy_change
operator|=
operator|&
name|topo_change
operator|->
name|phy_details
index|[
name|entry
index|]
expr_stmt|;
if|if
condition|(
name|phy_change
operator|->
name|is_processed
operator|||
operator|!
name|phy_change
operator|->
name|dev_handle
operator|||
name|phy_change
operator|->
name|reason
operator|!=
name|MPI2_EVENT_SAS_TOPO_RC_TARG_ADDED
condition|)
continue|continue;
if|if
condition|(
name|mps_config_get_sas_device_pg0
argument_list|(
name|sc
argument_list|,
operator|&
name|mpi_reply
argument_list|,
operator|&
name|sas_device_pg0
argument_list|,
name|MPI2_SAS_DEVICE_PGAD_FORM_HANDLE
argument_list|,
name|phy_change
operator|->
name|dev_handle
argument_list|)
condition|)
block|{
name|phy_change
operator|->
name|is_processed
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Always get SATA Identify information because this is used 		 * to determine if Start/Stop Unit should be sent to the drive 		 * when the system is shutdown. 		 */
name|device_info
operator|=
name|le32toh
argument_list|(
name|sas_device_pg0
operator|.
name|DeviceInfo
argument_list|)
expr_stmt|;
name|sas_address
operator|=
name|sas_device_pg0
operator|.
name|SASAddress
operator|.
name|High
expr_stmt|;
name|sas_address
operator|=
operator|(
name|sas_address
operator|<<
literal|32
operator|)
operator||
name|sas_device_pg0
operator|.
name|SASAddress
operator|.
name|Low
expr_stmt|;
if|if
condition|(
operator|(
name|device_info
operator|&
name|MPI2_SAS_DEVICE_INFO_END_DEVICE
operator|)
operator|&&
operator|(
name|device_info
operator|&
name|MPI2_SAS_DEVICE_INFO_SATA_DEVICE
operator|)
condition|)
block|{
name|rc
operator|=
name|mpssas_get_sas_address_for_sata_disk
argument_list|(
name|sc
argument_list|,
operator|&
name|sas_address
argument_list|,
name|phy_change
operator|->
name|dev_handle
argument_list|,
name|device_info
argument_list|,
operator|&
name|phy_change
operator|->
name|is_SATA_SSD
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_ERROR
argument_list|,
literal|"%s: failed to get "
literal|"disk type (SSD or HDD) and SAS Address "
literal|"for SATA device with handle 0x%04x\n"
argument_list|,
name|__func__
argument_list|,
name|phy_change
operator|->
name|dev_handle
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_INFO
argument_list|,
literal|"SAS Address for SATA "
literal|"device = %jx\n"
argument_list|,
name|sas_address
argument_list|)
expr_stmt|;
block|}
block|}
name|phy_change
operator|->
name|physical_id
operator|=
name|sas_address
expr_stmt|;
name|phy_change
operator|->
name|slot
operator|=
name|le16toh
argument_list|(
name|sas_device_pg0
operator|.
name|Slot
argument_list|)
expr_stmt|;
name|phy_change
operator|->
name|device_info
operator|=
name|le32toh
argument_list|(
name|sas_device_pg0
operator|.
name|DeviceInfo
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ioc_pg8_flags
operator|&
name|MPI2_IOCPAGE8_FLAGS_MASK_MAPPING_MODE
operator|)
operator|==
name|MPI2_IOCPAGE8_FLAGS_ENCLOSURE_SLOT_MAPPING
condition|)
block|{
name|enc_idx
operator|=
name|_mapping_get_enc_idx_from_handle
argument_list|(
name|sc
argument_list|,
name|topo_change
operator|->
name|enc_handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|enc_idx
operator|==
name|MPS_ENCTABLE_BAD_IDX
condition|)
block|{
name|phy_change
operator|->
name|is_processed
operator|=
literal|1
expr_stmt|;
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_MAPPING
argument_list|,
literal|"%s: failed to add "
literal|"the device with handle 0x%04x because the "
literal|"enclosure is not in the mapping table\n"
argument_list|,
name|__func__
argument_list|,
name|phy_change
operator|->
name|dev_handle
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
operator|(
operator|(
name|phy_change
operator|->
name|device_info
operator|&
name|MPI2_SAS_DEVICE_INFO_END_DEVICE
operator|)
operator|&&
operator|(
name|phy_change
operator|->
name|device_info
operator|&
operator|(
name|MPI2_SAS_DEVICE_INFO_SSP_TARGET
operator||
name|MPI2_SAS_DEVICE_INFO_STP_TARGET
operator||
name|MPI2_SAS_DEVICE_INFO_SATA_DEVICE
operator|)
operator|)
operator|)
condition|)
block|{
name|phy_change
operator|->
name|is_processed
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
name|et_entry
operator|=
operator|&
name|sc
operator|->
name|enclosure_table
index|[
name|enc_idx
index|]
expr_stmt|;
if|if
condition|(
name|et_entry
operator|->
name|start_index
operator|!=
name|MPS_MAPTABLE_BAD_IDX
condition|)
continue|continue;
if|if
condition|(
operator|!
name|topo_change
operator|->
name|exp_handle
condition|)
block|{
name|map_idx
operator|=
name|sc
operator|->
name|num_rsvd_entries
expr_stmt|;
name|et_entry
operator|->
name|start_index
operator|=
name|map_idx
expr_stmt|;
block|}
else|else
block|{
name|map_idx
operator|=
name|_mapping_find_enc_map_space
argument_list|(
name|sc
argument_list|,
name|et_entry
argument_list|)
expr_stmt|;
name|et_entry
operator|->
name|start_index
operator|=
name|map_idx
expr_stmt|;
if|if
condition|(
name|et_entry
operator|->
name|start_index
operator|==
name|MPS_MAPTABLE_BAD_IDX
condition|)
block|{
name|phy_change
operator|->
name|is_processed
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|phy_idx
operator|=
literal|0
init|;
name|phy_idx
operator|<
name|topo_change
operator|->
name|num_entries
condition|;
name|phy_idx
operator|++
control|)
block|{
name|tmp_phy_change
operator|=
operator|&
name|topo_change
operator|->
name|phy_details
index|[
name|phy_idx
index|]
expr_stmt|;
if|if
condition|(
name|tmp_phy_change
operator|->
name|reason
operator|==
name|add_code
condition|)
name|tmp_phy_change
operator|->
name|is_processed
operator|=
literal|1
expr_stmt|;
block|}
break|break;
block|}
block|}
name|mt_entry
operator|=
operator|&
name|sc
operator|->
name|mapping_table
index|[
name|map_idx
index|]
expr_stmt|;
for|for
control|(
name|index
operator|=
name|map_idx
init|;
name|index
operator|<
operator|(
name|et_entry
operator|->
name|num_slots
operator|+
name|map_idx
operator|)
condition|;
name|index
operator|++
operator|,
name|mt_entry
operator|++
control|)
block|{
name|mt_entry
operator|->
name|device_info
operator|=
name|MPS_DEV_RESERVED
expr_stmt|;
name|mt_entry
operator|->
name|physical_id
operator|=
name|et_entry
operator|->
name|enclosure_id
expr_stmt|;
name|mt_entry
operator|->
name|phy_bits
operator|=
name|et_entry
operator|->
name|phy_bits
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/**  * _mapping_set_mid_to_eid -set map table data from enclosure table  * @sc: per adapter object  * @et_entry: enclosure entry  *  * Returns nothing  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|_mapping_set_mid_to_eid
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|enc_mapping_table
modifier|*
name|et_entry
parameter_list|)
block|{
name|struct
name|dev_mapping_table
modifier|*
name|mt_entry
decl_stmt|;
name|u16
name|slots
init|=
name|et_entry
operator|->
name|num_slots
decl_stmt|,
name|map_idx
decl_stmt|;
name|u32
name|start_idx
init|=
name|et_entry
operator|->
name|start_index
decl_stmt|;
if|if
condition|(
name|start_idx
operator|!=
name|MPS_MAPTABLE_BAD_IDX
condition|)
block|{
name|mt_entry
operator|=
operator|&
name|sc
operator|->
name|mapping_table
index|[
name|start_idx
index|]
expr_stmt|;
for|for
control|(
name|map_idx
operator|=
literal|0
init|;
name|map_idx
operator|<
name|slots
condition|;
name|map_idx
operator|++
operator|,
name|mt_entry
operator|++
control|)
name|mt_entry
operator|->
name|physical_id
operator|=
name|et_entry
operator|->
name|enclosure_id
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * _mapping_clear_removed_entries - mark the entries to be cleared  * @sc: per adapter object  *  * Search through the removal table and mark the entries which needs to be  * flushed to DPM and also updates the map table and enclosure table by  * clearing the corresponding entries.  *  * Returns nothing  */
end_comment

begin_function
specifier|static
name|void
name|_mapping_clear_removed_entries
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u32
name|remove_idx
decl_stmt|;
name|struct
name|map_removal_table
modifier|*
name|remove_entry
decl_stmt|;
name|Mpi2DriverMap0Entry_t
modifier|*
name|dpm_entry
decl_stmt|;
name|u8
name|done_flag
init|=
literal|0
decl_stmt|,
name|num_entries
decl_stmt|,
name|m
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|enc_mapping_table
modifier|*
name|et_entry
decl_stmt|,
modifier|*
name|from
decl_stmt|,
modifier|*
name|to
decl_stmt|;
name|u16
name|ioc_pg8_flags
init|=
name|le16toh
argument_list|(
name|sc
operator|->
name|ioc_pg8
operator|.
name|Flags
argument_list|)
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|is_dpm_enable
condition|)
block|{
name|remove_entry
operator|=
name|sc
operator|->
name|removal_table
expr_stmt|;
for|for
control|(
name|remove_idx
operator|=
literal|0
init|;
name|remove_idx
operator|<
name|sc
operator|->
name|max_devices
condition|;
name|remove_idx
operator|++
operator|,
name|remove_entry
operator|++
control|)
block|{
if|if
condition|(
name|remove_entry
operator|->
name|dpm_entry_num
operator|!=
name|MPS_DPM_BAD_IDX
condition|)
block|{
name|dpm_entry
operator|=
operator|(
name|Mpi2DriverMap0Entry_t
operator|*
operator|)
operator|(
operator|(
name|u8
operator|*
operator|)
name|sc
operator|->
name|dpm_pg0
operator|+
sizeof|sizeof
argument_list|(
name|MPI2_CONFIG_EXTENDED_PAGE_HEADER
argument_list|)
operator|)
expr_stmt|;
name|dpm_entry
operator|+=
name|remove_entry
operator|->
name|dpm_entry_num
expr_stmt|;
name|dpm_entry
operator|->
name|PhysicalIdentifier
operator|.
name|Low
operator|=
literal|0
expr_stmt|;
name|dpm_entry
operator|->
name|PhysicalIdentifier
operator|.
name|High
operator|=
literal|0
expr_stmt|;
name|dpm_entry
operator|->
name|DeviceIndex
operator|=
literal|0
expr_stmt|;
name|dpm_entry
operator|->
name|MappingInformation
operator|=
literal|0
expr_stmt|;
name|dpm_entry
operator|->
name|PhysicalBitsMapping
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|dpm_flush_entry
index|[
name|remove_entry
operator|->
name|dpm_entry_num
index|]
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|dpm_entry_used
index|[
name|remove_entry
operator|->
name|dpm_entry_num
index|]
operator|=
literal|0
expr_stmt|;
name|remove_entry
operator|->
name|dpm_entry_num
operator|=
name|MPS_DPM_BAD_IDX
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|(
name|ioc_pg8_flags
operator|&
name|MPI2_IOCPAGE8_FLAGS_MASK_MAPPING_MODE
operator|)
operator|==
name|MPI2_IOCPAGE8_FLAGS_ENCLOSURE_SLOT_MAPPING
condition|)
block|{
name|num_entries
operator|=
name|sc
operator|->
name|num_enc_table_entries
expr_stmt|;
while|while
condition|(
operator|!
name|done_flag
condition|)
block|{
name|done_flag
operator|=
literal|1
expr_stmt|;
name|et_entry
operator|=
name|sc
operator|->
name|enclosure_table
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_entries
condition|;
name|i
operator|++
operator|,
name|et_entry
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|et_entry
operator|->
name|enc_handle
operator|&&
name|et_entry
operator|->
name|init_complete
condition|)
block|{
name|done_flag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|i
operator|!=
operator|(
name|num_entries
operator|-
literal|1
operator|)
condition|)
block|{
name|from
operator|=
operator|&
name|sc
operator|->
name|enclosure_table
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|to
operator|=
operator|&
name|sc
operator|->
name|enclosure_table
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|m
operator|=
name|i
init|;
name|m
operator|<
operator|(
name|num_entries
operator|-
literal|1
operator|)
condition|;
name|m
operator|++
operator|,
name|from
operator|++
operator|,
name|to
operator|++
control|)
block|{
name|_mapping_set_mid_to_eid
argument_list|(
name|sc
argument_list|,
name|to
argument_list|)
expr_stmt|;
operator|*
name|to
operator|=
operator|*
name|from
expr_stmt|;
block|}
name|_mapping_clear_enc_entry
argument_list|(
name|to
argument_list|)
expr_stmt|;
name|sc
operator|->
name|num_enc_table_entries
operator|--
expr_stmt|;
name|num_entries
operator|=
name|sc
operator|->
name|num_enc_table_entries
expr_stmt|;
block|}
else|else
block|{
name|_mapping_clear_enc_entry
argument_list|(
name|et_entry
argument_list|)
expr_stmt|;
name|sc
operator|->
name|num_enc_table_entries
operator|--
expr_stmt|;
name|num_entries
operator|=
name|sc
operator|->
name|num_enc_table_entries
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/**  * _mapping_add_new_device -Add the new device into mapping table  * @sc: per adapter object  * @topo_change: Topology change event entry  *  * Search through the topology change event list and updates map table,  * enclosure table and DPM pages for for the newly added devices.  *  * Returns nothing  */
end_comment

begin_function
specifier|static
name|void
name|_mapping_add_new_device
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|_map_topology_change
modifier|*
name|topo_change
parameter_list|)
block|{
name|u8
name|enc_idx
decl_stmt|,
name|missing_cnt
decl_stmt|,
name|is_removed
init|=
literal|0
decl_stmt|;
name|u16
name|dpm_idx
decl_stmt|;
name|u32
name|search_idx
decl_stmt|,
name|map_idx
decl_stmt|;
name|u32
name|entry
decl_stmt|;
name|struct
name|dev_mapping_table
modifier|*
name|mt_entry
decl_stmt|;
name|struct
name|enc_mapping_table
modifier|*
name|et_entry
decl_stmt|;
name|struct
name|_map_phy_change
modifier|*
name|phy_change
decl_stmt|;
name|u16
name|ioc_pg8_flags
init|=
name|le16toh
argument_list|(
name|sc
operator|->
name|ioc_pg8
operator|.
name|Flags
argument_list|)
decl_stmt|;
name|Mpi2DriverMap0Entry_t
modifier|*
name|dpm_entry
decl_stmt|;
name|uint64_t
name|temp64_var
decl_stmt|;
name|u8
name|map_shift
init|=
name|MPI2_DRVMAP0_MAPINFO_SLOT_SHIFT
decl_stmt|;
name|u8
name|hdr_sz
init|=
sizeof|sizeof
argument_list|(
name|MPI2_CONFIG_EXTENDED_PAGE_HEADER
argument_list|)
decl_stmt|;
name|u16
name|max_num_phy_ids
init|=
name|le16toh
argument_list|(
name|sc
operator|->
name|ioc_pg8
operator|.
name|MaxNumPhysicalMappedIDs
argument_list|)
decl_stmt|;
for|for
control|(
name|entry
operator|=
literal|0
init|;
name|entry
operator|<
name|topo_change
operator|->
name|num_entries
condition|;
name|entry
operator|++
control|)
block|{
name|phy_change
operator|=
operator|&
name|topo_change
operator|->
name|phy_details
index|[
name|entry
index|]
expr_stmt|;
if|if
condition|(
name|phy_change
operator|->
name|is_processed
condition|)
continue|continue;
if|if
condition|(
name|phy_change
operator|->
name|reason
operator|!=
name|MPI2_EVENT_SAS_TOPO_RC_TARG_ADDED
operator|||
operator|!
name|phy_change
operator|->
name|dev_handle
condition|)
block|{
name|phy_change
operator|->
name|is_processed
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|ioc_pg8_flags
operator|&
name|MPI2_IOCPAGE8_FLAGS_MASK_MAPPING_MODE
operator|)
operator|==
name|MPI2_IOCPAGE8_FLAGS_ENCLOSURE_SLOT_MAPPING
condition|)
block|{
name|enc_idx
operator|=
name|_mapping_get_enc_idx_from_handle
argument_list|(
name|sc
argument_list|,
name|topo_change
operator|->
name|enc_handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|enc_idx
operator|==
name|MPS_ENCTABLE_BAD_IDX
condition|)
block|{
name|phy_change
operator|->
name|is_processed
operator|=
literal|1
expr_stmt|;
name|printf
argument_list|(
literal|"%s: failed to add the device with "
literal|"handle 0x%04x because the enclosure is "
literal|"not in the mapping table\n"
argument_list|,
name|__func__
argument_list|,
name|phy_change
operator|->
name|dev_handle
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|et_entry
operator|=
operator|&
name|sc
operator|->
name|enclosure_table
index|[
name|enc_idx
index|]
expr_stmt|;
if|if
condition|(
name|et_entry
operator|->
name|start_index
operator|==
name|MPS_MAPTABLE_BAD_IDX
condition|)
block|{
name|phy_change
operator|->
name|is_processed
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|mt_full_retry
condition|)
block|{
name|sc
operator|->
name|mt_add_device_failed
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
name|printf
argument_list|(
literal|"%s: failed to add the device with "
literal|"handle 0x%04x because there is no free "
literal|"space available in the mapping table\n"
argument_list|,
name|__func__
argument_list|,
name|phy_change
operator|->
name|dev_handle
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|map_idx
operator|=
name|et_entry
operator|->
name|start_index
operator|+
name|phy_change
operator|->
name|slot
operator|-
name|et_entry
operator|->
name|start_slot
expr_stmt|;
name|mt_entry
operator|=
operator|&
name|sc
operator|->
name|mapping_table
index|[
name|map_idx
index|]
expr_stmt|;
name|mt_entry
operator|->
name|physical_id
operator|=
name|phy_change
operator|->
name|physical_id
expr_stmt|;
name|mt_entry
operator|->
name|channel
operator|=
literal|0
expr_stmt|;
name|mt_entry
operator|->
name|id
operator|=
name|map_idx
expr_stmt|;
name|mt_entry
operator|->
name|dev_handle
operator|=
name|phy_change
operator|->
name|dev_handle
expr_stmt|;
name|mt_entry
operator|->
name|missing_count
operator|=
literal|0
expr_stmt|;
name|mt_entry
operator|->
name|dpm_entry_num
operator|=
name|et_entry
operator|->
name|dpm_entry_num
expr_stmt|;
name|mt_entry
operator|->
name|device_info
operator|=
name|phy_change
operator|->
name|device_info
operator||
operator|(
name|MPS_DEV_RESERVED
operator||
name|MPS_MAP_IN_USE
operator|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|is_dpm_enable
condition|)
block|{
name|dpm_idx
operator|=
name|et_entry
operator|->
name|dpm_entry_num
expr_stmt|;
if|if
condition|(
name|dpm_idx
operator|==
name|MPS_DPM_BAD_IDX
condition|)
name|dpm_idx
operator|=
name|_mapping_get_dpm_idx_from_id
argument_list|(
name|sc
argument_list|,
name|et_entry
operator|->
name|enclosure_id
argument_list|,
name|et_entry
operator|->
name|phy_bits
argument_list|)
expr_stmt|;
if|if
condition|(
name|dpm_idx
operator|==
name|MPS_DPM_BAD_IDX
condition|)
block|{
name|dpm_idx
operator|=
name|_mapping_get_free_dpm_idx
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|dpm_idx
operator|!=
name|MPS_DPM_BAD_IDX
condition|)
block|{
name|dpm_entry
operator|=
operator|(
name|Mpi2DriverMap0Entry_t
operator|*
operator|)
operator|(
operator|(
name|u8
operator|*
operator|)
name|sc
operator|->
name|dpm_pg0
operator|+
name|hdr_sz
operator|)
expr_stmt|;
name|dpm_entry
operator|+=
name|dpm_idx
expr_stmt|;
name|dpm_entry
operator|->
name|PhysicalIdentifier
operator|.
name|Low
operator|=
operator|(
literal|0xFFFFFFFF
operator|&
name|et_entry
operator|->
name|enclosure_id
operator|)
expr_stmt|;
name|dpm_entry
operator|->
name|PhysicalIdentifier
operator|.
name|High
operator|=
operator|(
name|et_entry
operator|->
name|enclosure_id
operator|>>
literal|32
operator|)
expr_stmt|;
name|dpm_entry
operator|->
name|DeviceIndex
operator|=
operator|(
name|U16
operator|)
name|et_entry
operator|->
name|start_index
expr_stmt|;
name|dpm_entry
operator|->
name|MappingInformation
operator|=
name|et_entry
operator|->
name|num_slots
expr_stmt|;
name|dpm_entry
operator|->
name|MappingInformation
operator|<<=
name|map_shift
expr_stmt|;
name|dpm_entry
operator|->
name|PhysicalBitsMapping
operator|=
name|et_entry
operator|->
name|phy_bits
expr_stmt|;
name|et_entry
operator|->
name|dpm_entry_num
operator|=
name|dpm_idx
expr_stmt|;
comment|/* FIXME Do I need to set the dpm_idxin mt_entry too */
name|sc
operator|->
name|dpm_entry_used
index|[
name|dpm_idx
index|]
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|dpm_flush_entry
index|[
name|dpm_idx
index|]
operator|=
literal|1
expr_stmt|;
name|phy_change
operator|->
name|is_processed
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|phy_change
operator|->
name|is_processed
operator|=
literal|1
expr_stmt|;
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_INFO
argument_list|,
literal|"%s: "
literal|"failed to add the device "
literal|"with handle 0x%04x to "
literal|"persistent table because "
literal|"there is no free space "
literal|"available\n"
argument_list|,
name|__func__
argument_list|,
name|phy_change
operator|->
name|dev_handle
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|et_entry
operator|->
name|dpm_entry_num
operator|=
name|dpm_idx
expr_stmt|;
name|mt_entry
operator|->
name|dpm_entry_num
operator|=
name|dpm_idx
expr_stmt|;
block|}
block|}
comment|/* FIXME Why not mt_entry too? */
name|et_entry
operator|->
name|init_complete
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ioc_pg8_flags
operator|&
name|MPI2_IOCPAGE8_FLAGS_MASK_MAPPING_MODE
operator|)
operator|==
name|MPI2_IOCPAGE8_FLAGS_DEVICE_PERSISTENCE_MAPPING
condition|)
block|{
name|map_idx
operator|=
name|_mapping_get_mt_idx_from_id
argument_list|(
name|sc
argument_list|,
name|phy_change
operator|->
name|physical_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|map_idx
operator|==
name|MPS_MAPTABLE_BAD_IDX
condition|)
block|{
name|search_idx
operator|=
name|sc
operator|->
name|num_rsvd_entries
expr_stmt|;
if|if
condition|(
name|topo_change
operator|->
name|exp_handle
condition|)
name|search_idx
operator|+=
name|max_num_phy_ids
expr_stmt|;
name|map_idx
operator|=
name|_mapping_get_free_mt_idx
argument_list|(
name|sc
argument_list|,
name|search_idx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|map_idx
operator|==
name|MPS_MAPTABLE_BAD_IDX
condition|)
block|{
name|map_idx
operator|=
name|_mapping_get_high_missing_mt_idx
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|map_idx
operator|!=
name|MPS_MAPTABLE_BAD_IDX
condition|)
block|{
name|mt_entry
operator|=
operator|&
name|sc
operator|->
name|mapping_table
index|[
name|map_idx
index|]
expr_stmt|;
if|if
condition|(
name|mt_entry
operator|->
name|dev_handle
condition|)
block|{
name|_mapping_add_to_removal_table
argument_list|(
name|sc
argument_list|,
name|mt_entry
operator|->
name|dev_handle
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|is_removed
operator|=
literal|1
expr_stmt|;
block|}
name|mt_entry
operator|->
name|init_complete
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|map_idx
operator|!=
name|MPS_MAPTABLE_BAD_IDX
condition|)
block|{
name|mt_entry
operator|=
operator|&
name|sc
operator|->
name|mapping_table
index|[
name|map_idx
index|]
expr_stmt|;
name|mt_entry
operator|->
name|physical_id
operator|=
name|phy_change
operator|->
name|physical_id
expr_stmt|;
name|mt_entry
operator|->
name|channel
operator|=
literal|0
expr_stmt|;
name|mt_entry
operator|->
name|id
operator|=
name|map_idx
expr_stmt|;
name|mt_entry
operator|->
name|dev_handle
operator|=
name|phy_change
operator|->
name|dev_handle
expr_stmt|;
name|mt_entry
operator|->
name|missing_count
operator|=
literal|0
expr_stmt|;
name|mt_entry
operator|->
name|device_info
operator|=
name|phy_change
operator|->
name|device_info
operator||
operator|(
name|MPS_DEV_RESERVED
operator||
name|MPS_MAP_IN_USE
operator|)
expr_stmt|;
block|}
else|else
block|{
name|phy_change
operator|->
name|is_processed
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|mt_full_retry
condition|)
block|{
name|sc
operator|->
name|mt_add_device_failed
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
name|printf
argument_list|(
literal|"%s: failed to add the device with "
literal|"handle 0x%04x because there is no free "
literal|"space available in the mapping table\n"
argument_list|,
name|__func__
argument_list|,
name|phy_change
operator|->
name|dev_handle
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|sc
operator|->
name|is_dpm_enable
condition|)
block|{
if|if
condition|(
name|mt_entry
operator|->
name|dpm_entry_num
operator|!=
name|MPS_DPM_BAD_IDX
condition|)
block|{
name|dpm_idx
operator|=
name|mt_entry
operator|->
name|dpm_entry_num
expr_stmt|;
name|dpm_entry
operator|=
operator|(
name|Mpi2DriverMap0Entry_t
operator|*
operator|)
operator|(
operator|(
name|u8
operator|*
operator|)
name|sc
operator|->
name|dpm_pg0
operator|+
name|hdr_sz
operator|)
expr_stmt|;
name|dpm_entry
operator|+=
name|dpm_idx
expr_stmt|;
name|missing_cnt
operator|=
name|dpm_entry
operator|->
name|MappingInformation
operator|&
name|MPI2_DRVMAP0_MAPINFO_MISSING_MASK
expr_stmt|;
name|temp64_var
operator|=
name|dpm_entry
operator|->
name|PhysicalIdentifier
operator|.
name|High
expr_stmt|;
name|temp64_var
operator|=
operator|(
name|temp64_var
operator|<<
literal|32
operator|)
operator||
name|dpm_entry
operator|->
name|PhysicalIdentifier
operator|.
name|Low
expr_stmt|;
if|if
condition|(
operator|(
name|mt_entry
operator|->
name|physical_id
operator|==
name|temp64_var
operator|)
operator|&&
operator|!
name|missing_cnt
condition|)
name|mt_entry
operator|->
name|init_complete
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|dpm_idx
operator|=
name|_mapping_get_free_dpm_idx
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mt_entry
operator|->
name|init_complete
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|dpm_idx
operator|!=
name|MPS_DPM_BAD_IDX
operator|&&
operator|!
name|mt_entry
operator|->
name|init_complete
condition|)
block|{
name|mt_entry
operator|->
name|init_complete
operator|=
literal|1
expr_stmt|;
name|mt_entry
operator|->
name|dpm_entry_num
operator|=
name|dpm_idx
expr_stmt|;
name|dpm_entry
operator|=
operator|(
name|Mpi2DriverMap0Entry_t
operator|*
operator|)
operator|(
operator|(
name|u8
operator|*
operator|)
name|sc
operator|->
name|dpm_pg0
operator|+
name|hdr_sz
operator|)
expr_stmt|;
name|dpm_entry
operator|+=
name|dpm_idx
expr_stmt|;
name|dpm_entry
operator|->
name|PhysicalIdentifier
operator|.
name|Low
operator|=
operator|(
literal|0xFFFFFFFF
operator|&
name|mt_entry
operator|->
name|physical_id
operator|)
expr_stmt|;
name|dpm_entry
operator|->
name|PhysicalIdentifier
operator|.
name|High
operator|=
operator|(
name|mt_entry
operator|->
name|physical_id
operator|>>
literal|32
operator|)
expr_stmt|;
name|dpm_entry
operator|->
name|DeviceIndex
operator|=
operator|(
name|U16
operator|)
name|map_idx
expr_stmt|;
name|dpm_entry
operator|->
name|MappingInformation
operator|=
literal|0
expr_stmt|;
name|dpm_entry
operator|->
name|PhysicalBitsMapping
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|dpm_entry_used
index|[
name|dpm_idx
index|]
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|dpm_flush_entry
index|[
name|dpm_idx
index|]
operator|=
literal|1
expr_stmt|;
name|phy_change
operator|->
name|is_processed
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dpm_idx
operator|==
name|MPS_DPM_BAD_IDX
condition|)
block|{
name|phy_change
operator|->
name|is_processed
operator|=
literal|1
expr_stmt|;
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_INFO
argument_list|,
literal|"%s: "
literal|"failed to add the device "
literal|"with handle 0x%04x to "
literal|"persistent table because "
literal|"there is no free space "
literal|"available\n"
argument_list|,
name|__func__
argument_list|,
name|phy_change
operator|->
name|dev_handle
argument_list|)
expr_stmt|;
block|}
block|}
name|mt_entry
operator|->
name|init_complete
operator|=
literal|1
expr_stmt|;
block|}
name|phy_change
operator|->
name|is_processed
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|is_removed
condition|)
name|_mapping_clear_removed_entries
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * _mapping_flush_dpm_pages -Flush the DPM pages to NVRAM  * @sc: per adapter object  *  * Returns nothing  */
end_comment

begin_function
specifier|static
name|void
name|_mapping_flush_dpm_pages
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|)
block|{
name|Mpi2DriverMap0Entry_t
modifier|*
name|dpm_entry
decl_stmt|;
name|Mpi2ConfigReply_t
name|mpi_reply
decl_stmt|;
name|Mpi2DriverMappingPage0_t
name|config_page
decl_stmt|;
name|u16
name|entry_num
decl_stmt|;
for|for
control|(
name|entry_num
operator|=
literal|0
init|;
name|entry_num
operator|<
name|sc
operator|->
name|max_dpm_entries
condition|;
name|entry_num
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|sc
operator|->
name|dpm_flush_entry
index|[
name|entry_num
index|]
condition|)
continue|continue;
name|memset
argument_list|(
operator|&
name|config_page
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|Mpi2DriverMappingPage0_t
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|config_page
operator|.
name|Header
argument_list|,
operator|(
name|u8
operator|*
operator|)
name|sc
operator|->
name|dpm_pg0
argument_list|,
sizeof|sizeof
argument_list|(
name|MPI2_CONFIG_EXTENDED_PAGE_HEADER
argument_list|)
argument_list|)
expr_stmt|;
name|dpm_entry
operator|=
operator|(
name|Mpi2DriverMap0Entry_t
operator|*
operator|)
operator|(
operator|(
name|u8
operator|*
operator|)
name|sc
operator|->
name|dpm_pg0
operator|+
sizeof|sizeof
argument_list|(
name|MPI2_CONFIG_EXTENDED_PAGE_HEADER
argument_list|)
operator|)
expr_stmt|;
name|dpm_entry
operator|+=
name|entry_num
expr_stmt|;
name|dpm_entry
operator|->
name|MappingInformation
operator|=
name|htole16
argument_list|(
name|dpm_entry
operator|->
name|MappingInformation
argument_list|)
expr_stmt|;
name|dpm_entry
operator|->
name|DeviceIndex
operator|=
name|htole16
argument_list|(
name|dpm_entry
operator|->
name|DeviceIndex
argument_list|)
expr_stmt|;
name|dpm_entry
operator|->
name|PhysicalBitsMapping
operator|=
name|htole32
argument_list|(
name|dpm_entry
operator|->
name|PhysicalBitsMapping
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|config_page
operator|.
name|Entry
argument_list|,
operator|(
name|u8
operator|*
operator|)
name|dpm_entry
argument_list|,
sizeof|sizeof
argument_list|(
name|Mpi2DriverMap0Entry_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* TODO-How to handle failed writes? */
if|if
condition|(
name|mps_config_set_dpm_pg0
argument_list|(
name|sc
argument_list|,
operator|&
name|mpi_reply
argument_list|,
operator|&
name|config_page
argument_list|,
name|entry_num
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s: write of dpm entry %d for device failed\n"
argument_list|,
name|__func__
argument_list|,
name|entry_num
argument_list|)
expr_stmt|;
block|}
else|else
name|sc
operator|->
name|dpm_flush_entry
index|[
name|entry_num
index|]
operator|=
literal|0
expr_stmt|;
name|dpm_entry
operator|->
name|MappingInformation
operator|=
name|le16toh
argument_list|(
name|dpm_entry
operator|->
name|MappingInformation
argument_list|)
expr_stmt|;
name|dpm_entry
operator|->
name|DeviceIndex
operator|=
name|le16toh
argument_list|(
name|dpm_entry
operator|->
name|DeviceIndex
argument_list|)
expr_stmt|;
name|dpm_entry
operator|->
name|PhysicalBitsMapping
operator|=
name|le32toh
argument_list|(
name|dpm_entry
operator|->
name|PhysicalBitsMapping
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * _mapping_allocate_memory- allocates the memory required for mapping tables  * @sc: per adapter object  *  * Allocates the memory for all the tables required for host mapping  *  * Return 0 on success or non-zero on failure.  */
end_comment

begin_function
name|int
name|mps_mapping_allocate_memory
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|dpm_pg0_sz
decl_stmt|;
name|sc
operator|->
name|mapping_table
operator|=
name|malloc
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|dev_mapping_table
argument_list|)
operator|*
name|sc
operator|->
name|max_devices
operator|)
argument_list|,
name|M_MPT2
argument_list|,
name|M_ZERO
operator||
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|mapping_table
condition|)
goto|goto
name|free_resources
goto|;
name|sc
operator|->
name|removal_table
operator|=
name|malloc
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|map_removal_table
argument_list|)
operator|*
name|sc
operator|->
name|max_devices
operator|)
argument_list|,
name|M_MPT2
argument_list|,
name|M_ZERO
operator||
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|removal_table
condition|)
goto|goto
name|free_resources
goto|;
name|sc
operator|->
name|enclosure_table
operator|=
name|malloc
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|enc_mapping_table
argument_list|)
operator|*
name|sc
operator|->
name|max_enclosures
operator|)
argument_list|,
name|M_MPT2
argument_list|,
name|M_ZERO
operator||
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|enclosure_table
condition|)
goto|goto
name|free_resources
goto|;
name|sc
operator|->
name|dpm_entry_used
operator|=
name|malloc
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
name|u8
argument_list|)
operator|*
name|sc
operator|->
name|max_dpm_entries
operator|)
argument_list|,
name|M_MPT2
argument_list|,
name|M_ZERO
operator||
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|dpm_entry_used
condition|)
goto|goto
name|free_resources
goto|;
name|sc
operator|->
name|dpm_flush_entry
operator|=
name|malloc
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
name|u8
argument_list|)
operator|*
name|sc
operator|->
name|max_dpm_entries
operator|)
argument_list|,
name|M_MPT2
argument_list|,
name|M_ZERO
operator||
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|dpm_flush_entry
condition|)
goto|goto
name|free_resources
goto|;
name|dpm_pg0_sz
operator|=
sizeof|sizeof
argument_list|(
name|MPI2_CONFIG_EXTENDED_PAGE_HEADER
argument_list|)
operator|+
operator|(
name|sc
operator|->
name|max_dpm_entries
operator|*
sizeof|sizeof
argument_list|(
name|MPI2_CONFIG_PAGE_DRIVER_MAP0_ENTRY
argument_list|)
operator|)
expr_stmt|;
name|sc
operator|->
name|dpm_pg0
operator|=
name|malloc
argument_list|(
name|dpm_pg0_sz
argument_list|,
name|M_MPT2
argument_list|,
name|M_ZERO
operator||
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|dpm_pg0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: memory alloc failed for dpm page; disabling dpm\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|sc
operator|->
name|is_dpm_enable
operator|=
literal|0
expr_stmt|;
block|}
return|return
literal|0
return|;
name|free_resources
label|:
name|free
argument_list|(
name|sc
operator|->
name|mapping_table
argument_list|,
name|M_MPT2
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|removal_table
argument_list|,
name|M_MPT2
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|enclosure_table
argument_list|,
name|M_MPT2
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|dpm_entry_used
argument_list|,
name|M_MPT2
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|dpm_flush_entry
argument_list|,
name|M_MPT2
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|dpm_pg0
argument_list|,
name|M_MPT2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: device initialization failed due to failure in mapping "
literal|"table memory allocation\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  * mps_mapping_free_memory- frees the memory allocated for mapping tables  * @sc: per adapter object  *  * Returns nothing.  */
end_comment

begin_function
name|void
name|mps_mapping_free_memory
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|)
block|{
name|free
argument_list|(
name|sc
operator|->
name|mapping_table
argument_list|,
name|M_MPT2
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|removal_table
argument_list|,
name|M_MPT2
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|enclosure_table
argument_list|,
name|M_MPT2
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|dpm_entry_used
argument_list|,
name|M_MPT2
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|dpm_flush_entry
argument_list|,
name|M_MPT2
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|dpm_pg0
argument_list|,
name|M_MPT2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|_mapping_process_dpm_pg0
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u8
name|missing_cnt
decl_stmt|,
name|enc_idx
decl_stmt|;
name|u16
name|slot_id
decl_stmt|,
name|entry_num
decl_stmt|,
name|num_slots
decl_stmt|;
name|u32
name|map_idx
decl_stmt|,
name|dev_idx
decl_stmt|,
name|start_idx
decl_stmt|,
name|end_idx
decl_stmt|;
name|struct
name|dev_mapping_table
modifier|*
name|mt_entry
decl_stmt|;
name|Mpi2DriverMap0Entry_t
modifier|*
name|dpm_entry
decl_stmt|;
name|u16
name|ioc_pg8_flags
init|=
name|le16toh
argument_list|(
name|sc
operator|->
name|ioc_pg8
operator|.
name|Flags
argument_list|)
decl_stmt|;
name|u16
name|max_num_phy_ids
init|=
name|le16toh
argument_list|(
name|sc
operator|->
name|ioc_pg8
operator|.
name|MaxNumPhysicalMappedIDs
argument_list|)
decl_stmt|;
name|struct
name|enc_mapping_table
modifier|*
name|et_entry
decl_stmt|;
name|u64
name|physical_id
decl_stmt|;
name|u32
name|phy_bits
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|ir_firmware
condition|)
name|_mapping_get_ir_maprange
argument_list|(
name|sc
argument_list|,
operator|&
name|start_idx
argument_list|,
operator|&
name|end_idx
argument_list|)
expr_stmt|;
name|dpm_entry
operator|=
operator|(
name|Mpi2DriverMap0Entry_t
operator|*
operator|)
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|sc
operator|->
name|dpm_pg0
operator|+
sizeof|sizeof
argument_list|(
name|MPI2_CONFIG_EXTENDED_PAGE_HEADER
argument_list|)
operator|)
expr_stmt|;
for|for
control|(
name|entry_num
operator|=
literal|0
init|;
name|entry_num
operator|<
name|sc
operator|->
name|max_dpm_entries
condition|;
name|entry_num
operator|++
operator|,
name|dpm_entry
operator|++
control|)
block|{
name|physical_id
operator|=
name|dpm_entry
operator|->
name|PhysicalIdentifier
operator|.
name|High
expr_stmt|;
name|physical_id
operator|=
operator|(
name|physical_id
operator|<<
literal|32
operator|)
operator||
name|dpm_entry
operator|->
name|PhysicalIdentifier
operator|.
name|Low
expr_stmt|;
if|if
condition|(
operator|!
name|physical_id
condition|)
block|{
name|sc
operator|->
name|dpm_entry_used
index|[
name|entry_num
index|]
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
name|sc
operator|->
name|dpm_entry_used
index|[
name|entry_num
index|]
operator|=
literal|1
expr_stmt|;
name|dpm_entry
operator|->
name|MappingInformation
operator|=
name|le16toh
argument_list|(
name|dpm_entry
operator|->
name|MappingInformation
argument_list|)
expr_stmt|;
name|missing_cnt
operator|=
name|dpm_entry
operator|->
name|MappingInformation
operator|&
name|MPI2_DRVMAP0_MAPINFO_MISSING_MASK
expr_stmt|;
name|dev_idx
operator|=
name|le16toh
argument_list|(
name|dpm_entry
operator|->
name|DeviceIndex
argument_list|)
expr_stmt|;
name|phy_bits
operator|=
name|le32toh
argument_list|(
name|dpm_entry
operator|->
name|PhysicalBitsMapping
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ir_firmware
operator|&&
operator|(
name|dev_idx
operator|>=
name|start_idx
operator|)
operator|&&
operator|(
name|dev_idx
operator|<=
name|end_idx
operator|)
condition|)
block|{
name|mt_entry
operator|=
operator|&
name|sc
operator|->
name|mapping_table
index|[
name|dev_idx
index|]
expr_stmt|;
name|mt_entry
operator|->
name|physical_id
operator|=
name|dpm_entry
operator|->
name|PhysicalIdentifier
operator|.
name|High
expr_stmt|;
name|mt_entry
operator|->
name|physical_id
operator|=
operator|(
name|mt_entry
operator|->
name|physical_id
operator|<<
literal|32
operator|)
operator||
name|dpm_entry
operator|->
name|PhysicalIdentifier
operator|.
name|Low
expr_stmt|;
name|mt_entry
operator|->
name|channel
operator|=
name|MPS_RAID_CHANNEL
expr_stmt|;
name|mt_entry
operator|->
name|id
operator|=
name|dev_idx
expr_stmt|;
name|mt_entry
operator|->
name|missing_count
operator|=
name|missing_cnt
expr_stmt|;
name|mt_entry
operator|->
name|dpm_entry_num
operator|=
name|entry_num
expr_stmt|;
name|mt_entry
operator|->
name|device_info
operator|=
name|MPS_DEV_RESERVED
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|ioc_pg8_flags
operator|&
name|MPI2_IOCPAGE8_FLAGS_MASK_MAPPING_MODE
operator|)
operator|==
name|MPI2_IOCPAGE8_FLAGS_ENCLOSURE_SLOT_MAPPING
condition|)
block|{
if|if
condition|(
name|dev_idx
operator|<
operator|(
name|sc
operator|->
name|num_rsvd_entries
operator|+
name|max_num_phy_ids
operator|)
condition|)
block|{
name|slot_id
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ioc_pg8_flags
operator|&
name|MPI2_IOCPAGE8_FLAGS_DA_START_SLOT_1
condition|)
name|slot_id
operator|=
literal|1
expr_stmt|;
name|num_slots
operator|=
name|max_num_phy_ids
expr_stmt|;
block|}
else|else
block|{
name|slot_id
operator|=
literal|0
expr_stmt|;
name|num_slots
operator|=
name|dpm_entry
operator|->
name|MappingInformation
operator|&
name|MPI2_DRVMAP0_MAPINFO_SLOT_MASK
expr_stmt|;
name|num_slots
operator|>>=
name|MPI2_DRVMAP0_MAPINFO_SLOT_SHIFT
expr_stmt|;
block|}
name|enc_idx
operator|=
name|sc
operator|->
name|num_enc_table_entries
expr_stmt|;
if|if
condition|(
name|enc_idx
operator|>=
name|sc
operator|->
name|max_enclosures
condition|)
block|{
name|printf
argument_list|(
literal|"%s: enclosure entries exceed max "
literal|"enclosures of %d\n"
argument_list|,
name|__func__
argument_list|,
name|sc
operator|->
name|max_enclosures
argument_list|)
expr_stmt|;
break|break;
block|}
name|sc
operator|->
name|num_enc_table_entries
operator|++
expr_stmt|;
name|et_entry
operator|=
operator|&
name|sc
operator|->
name|enclosure_table
index|[
name|enc_idx
index|]
expr_stmt|;
name|physical_id
operator|=
name|dpm_entry
operator|->
name|PhysicalIdentifier
operator|.
name|High
expr_stmt|;
name|et_entry
operator|->
name|enclosure_id
operator|=
operator|(
name|physical_id
operator|<<
literal|32
operator|)
operator||
name|dpm_entry
operator|->
name|PhysicalIdentifier
operator|.
name|Low
expr_stmt|;
name|et_entry
operator|->
name|start_index
operator|=
name|dev_idx
expr_stmt|;
name|et_entry
operator|->
name|dpm_entry_num
operator|=
name|entry_num
expr_stmt|;
name|et_entry
operator|->
name|num_slots
operator|=
name|num_slots
expr_stmt|;
name|et_entry
operator|->
name|start_slot
operator|=
name|slot_id
expr_stmt|;
name|et_entry
operator|->
name|missing_count
operator|=
name|missing_cnt
expr_stmt|;
name|et_entry
operator|->
name|phy_bits
operator|=
name|phy_bits
expr_stmt|;
name|mt_entry
operator|=
operator|&
name|sc
operator|->
name|mapping_table
index|[
name|dev_idx
index|]
expr_stmt|;
for|for
control|(
name|map_idx
operator|=
name|dev_idx
init|;
name|map_idx
operator|<
operator|(
name|dev_idx
operator|+
name|num_slots
operator|)
condition|;
name|map_idx
operator|++
operator|,
name|mt_entry
operator|++
control|)
block|{
if|if
condition|(
name|mt_entry
operator|->
name|dpm_entry_num
operator|!=
name|MPS_DPM_BAD_IDX
condition|)
block|{
name|printf
argument_list|(
literal|"%s: conflict in mapping table "
literal|"for enclosure %d\n"
argument_list|,
name|__func__
argument_list|,
name|enc_idx
argument_list|)
expr_stmt|;
break|break;
block|}
name|physical_id
operator|=
name|dpm_entry
operator|->
name|PhysicalIdentifier
operator|.
name|High
expr_stmt|;
name|mt_entry
operator|->
name|physical_id
operator|=
operator|(
name|physical_id
operator|<<
literal|32
operator|)
operator||
name|dpm_entry
operator|->
name|PhysicalIdentifier
operator|.
name|Low
expr_stmt|;
name|mt_entry
operator|->
name|phy_bits
operator|=
name|phy_bits
expr_stmt|;
name|mt_entry
operator|->
name|channel
operator|=
literal|0
expr_stmt|;
name|mt_entry
operator|->
name|id
operator|=
name|dev_idx
expr_stmt|;
name|mt_entry
operator|->
name|dpm_entry_num
operator|=
name|entry_num
expr_stmt|;
name|mt_entry
operator|->
name|missing_count
operator|=
name|missing_cnt
expr_stmt|;
name|mt_entry
operator|->
name|device_info
operator|=
name|MPS_DEV_RESERVED
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|ioc_pg8_flags
operator|&
name|MPI2_IOCPAGE8_FLAGS_MASK_MAPPING_MODE
operator|)
operator|==
name|MPI2_IOCPAGE8_FLAGS_DEVICE_PERSISTENCE_MAPPING
condition|)
block|{
name|map_idx
operator|=
name|dev_idx
expr_stmt|;
name|mt_entry
operator|=
operator|&
name|sc
operator|->
name|mapping_table
index|[
name|map_idx
index|]
expr_stmt|;
if|if
condition|(
name|mt_entry
operator|->
name|dpm_entry_num
operator|!=
name|MPS_DPM_BAD_IDX
condition|)
block|{
name|printf
argument_list|(
literal|"%s: conflict in mapping table for "
literal|"device %d\n"
argument_list|,
name|__func__
argument_list|,
name|map_idx
argument_list|)
expr_stmt|;
break|break;
block|}
name|physical_id
operator|=
name|dpm_entry
operator|->
name|PhysicalIdentifier
operator|.
name|High
expr_stmt|;
name|mt_entry
operator|->
name|physical_id
operator|=
operator|(
name|physical_id
operator|<<
literal|32
operator|)
operator||
name|dpm_entry
operator|->
name|PhysicalIdentifier
operator|.
name|Low
expr_stmt|;
name|mt_entry
operator|->
name|phy_bits
operator|=
name|phy_bits
expr_stmt|;
name|mt_entry
operator|->
name|channel
operator|=
literal|0
expr_stmt|;
name|mt_entry
operator|->
name|id
operator|=
name|dev_idx
expr_stmt|;
name|mt_entry
operator|->
name|missing_count
operator|=
name|missing_cnt
expr_stmt|;
name|mt_entry
operator|->
name|dpm_entry_num
operator|=
name|entry_num
expr_stmt|;
name|mt_entry
operator|->
name|device_info
operator|=
name|MPS_DEV_RESERVED
expr_stmt|;
block|}
block|}
comment|/*close the loop for DPM table */
block|}
end_function

begin_comment
comment|/*  * mps_mapping_check_devices - start of the day check for device availabilty  * @sc: per adapter object  * @sleep_flag: Flag indicating whether this function can sleep or not  *  * Returns nothing.  */
end_comment

begin_function
name|void
name|mps_mapping_check_devices
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|int
name|sleep_flag
parameter_list|)
block|{
name|u32
name|i
decl_stmt|;
comment|/*	u32 cntdn, i; 	u32 timeout = 60;*/
name|struct
name|dev_mapping_table
modifier|*
name|mt_entry
decl_stmt|;
name|u16
name|ioc_pg8_flags
init|=
name|le16toh
argument_list|(
name|sc
operator|->
name|ioc_pg8
operator|.
name|Flags
argument_list|)
decl_stmt|;
name|struct
name|enc_mapping_table
modifier|*
name|et_entry
decl_stmt|;
name|u32
name|start_idx
decl_stmt|,
name|end_idx
decl_stmt|;
comment|/* We need to ucomment this when this function is called 	 * from the port enable complete */
if|#
directive|if
literal|0
block|sc->track_mapping_events = 0; 	cntdn = (sleep_flag == CAN_SLEEP) ? 1000*timeout : 2000*timeout; 	do { 		if (!sc->pending_map_events) 			break; 		if (sleep_flag == CAN_SLEEP) 			pause("mps_pause", (hz/1000));
comment|/* 1msec sleep */
block|else 			DELAY(500);
comment|/* 500 useconds delay */
block|} while (--cntdn);   	if (!cntdn) 		printf("%s: there are %d" 		    " pending events after %d seconds of delay\n", 		    __func__, sc->pending_map_events, timeout);
endif|#
directive|endif
name|sc
operator|->
name|pending_map_events
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|ioc_pg8_flags
operator|&
name|MPI2_IOCPAGE8_FLAGS_MASK_MAPPING_MODE
operator|)
operator|==
name|MPI2_IOCPAGE8_FLAGS_ENCLOSURE_SLOT_MAPPING
condition|)
block|{
name|et_entry
operator|=
name|sc
operator|->
name|enclosure_table
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_enc_table_entries
condition|;
name|i
operator|++
operator|,
name|et_entry
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|et_entry
operator|->
name|init_complete
condition|)
block|{
if|if
condition|(
name|et_entry
operator|->
name|missing_count
operator|<
name|MPS_MAX_MISSING_COUNT
condition|)
block|{
name|et_entry
operator|->
name|missing_count
operator|++
expr_stmt|;
if|if
condition|(
name|et_entry
operator|->
name|dpm_entry_num
operator|!=
name|MPS_DPM_BAD_IDX
condition|)
name|_mapping_commit_enc_entry
argument_list|(
name|sc
argument_list|,
name|et_entry
argument_list|)
expr_stmt|;
block|}
name|et_entry
operator|->
name|init_complete
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|sc
operator|->
name|ir_firmware
condition|)
return|return;
name|_mapping_get_ir_maprange
argument_list|(
name|sc
argument_list|,
operator|&
name|start_idx
argument_list|,
operator|&
name|end_idx
argument_list|)
expr_stmt|;
name|mt_entry
operator|=
operator|&
name|sc
operator|->
name|mapping_table
index|[
name|start_idx
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
name|start_idx
init|;
name|i
operator|<
operator|(
name|end_idx
operator|+
literal|1
operator|)
condition|;
name|i
operator|++
operator|,
name|mt_entry
operator|++
control|)
block|{
if|if
condition|(
name|mt_entry
operator|->
name|device_info
operator|&
name|MPS_DEV_RESERVED
operator|&&
operator|!
name|mt_entry
operator|->
name|physical_id
condition|)
name|mt_entry
operator|->
name|init_complete
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|mt_entry
operator|->
name|device_info
operator|&
name|MPS_DEV_RESERVED
condition|)
block|{
if|if
condition|(
operator|!
name|mt_entry
operator|->
name|init_complete
condition|)
block|{
if|if
condition|(
name|mt_entry
operator|->
name|missing_count
operator|<
name|MPS_MAX_MISSING_COUNT
condition|)
block|{
name|mt_entry
operator|->
name|missing_count
operator|++
expr_stmt|;
if|if
condition|(
name|mt_entry
operator|->
name|dpm_entry_num
operator|!=
name|MPS_DPM_BAD_IDX
condition|)
name|_mapping_commit_map_entry
argument_list|(
name|sc
argument_list|,
name|mt_entry
argument_list|)
expr_stmt|;
block|}
name|mt_entry
operator|->
name|init_complete
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|ioc_pg8_flags
operator|&
name|MPI2_IOCPAGE8_FLAGS_MASK_MAPPING_MODE
operator|)
operator|==
name|MPI2_IOCPAGE8_FLAGS_DEVICE_PERSISTENCE_MAPPING
condition|)
block|{
name|mt_entry
operator|=
name|sc
operator|->
name|mapping_table
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|max_devices
condition|;
name|i
operator|++
operator|,
name|mt_entry
operator|++
control|)
block|{
if|if
condition|(
name|mt_entry
operator|->
name|device_info
operator|&
name|MPS_DEV_RESERVED
operator|&&
operator|!
name|mt_entry
operator|->
name|physical_id
condition|)
name|mt_entry
operator|->
name|init_complete
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|mt_entry
operator|->
name|device_info
operator|&
name|MPS_DEV_RESERVED
condition|)
block|{
if|if
condition|(
operator|!
name|mt_entry
operator|->
name|init_complete
condition|)
block|{
if|if
condition|(
name|mt_entry
operator|->
name|missing_count
operator|<
name|MPS_MAX_MISSING_COUNT
condition|)
block|{
name|mt_entry
operator|->
name|missing_count
operator|++
expr_stmt|;
if|if
condition|(
name|mt_entry
operator|->
name|dpm_entry_num
operator|!=
name|MPS_DPM_BAD_IDX
condition|)
name|_mapping_commit_map_entry
argument_list|(
name|sc
argument_list|,
name|mt_entry
argument_list|)
expr_stmt|;
block|}
name|mt_entry
operator|->
name|init_complete
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/**  * mps_mapping_is_reinit_required - check whether event replay required  * @sc: per adapter object  *  * Checks the per ioc flags and decide whether reinit of events required  *  * Returns 1 for reinit of ioc 0 for not.  */
end_comment

begin_function
name|int
name|mps_mapping_is_reinit_required
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|)
block|{
if|if
condition|(
operator|!
name|sc
operator|->
name|mt_full_retry
operator|&&
name|sc
operator|->
name|mt_add_device_failed
condition|)
block|{
name|sc
operator|->
name|mt_full_retry
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|mt_add_device_failed
operator|=
literal|0
expr_stmt|;
name|_mapping_flush_dpm_pages
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|sc
operator|->
name|mt_full_retry
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * mps_mapping_initialize - initialize mapping tables  * @sc: per adapter object  *  * Read controller persitant mapping tables into internal data area.  *  * Return 0 for success or non-zero for failure.  */
end_comment

begin_function
name|int
name|mps_mapping_initialize
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint16_t
name|volume_mapping_flags
decl_stmt|,
name|dpm_pg0_sz
decl_stmt|;
name|uint32_t
name|i
decl_stmt|;
name|Mpi2ConfigReply_t
name|mpi_reply
decl_stmt|;
name|int
name|error
decl_stmt|;
name|uint8_t
name|retry_count
decl_stmt|;
name|uint16_t
name|ioc_pg8_flags
init|=
name|le16toh
argument_list|(
name|sc
operator|->
name|ioc_pg8
operator|.
name|Flags
argument_list|)
decl_stmt|;
comment|/* The additional 1 accounts for the virtual enclosure 	 * created for the controller 	 */
name|sc
operator|->
name|max_enclosures
operator|=
name|sc
operator|->
name|facts
operator|->
name|MaxEnclosures
operator|+
literal|1
expr_stmt|;
name|sc
operator|->
name|max_expanders
operator|=
name|sc
operator|->
name|facts
operator|->
name|MaxSasExpanders
expr_stmt|;
name|sc
operator|->
name|max_volumes
operator|=
name|sc
operator|->
name|facts
operator|->
name|MaxVolumes
expr_stmt|;
name|sc
operator|->
name|max_devices
operator|=
name|sc
operator|->
name|facts
operator|->
name|MaxTargets
operator|+
name|sc
operator|->
name|max_volumes
expr_stmt|;
name|sc
operator|->
name|pending_map_events
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|num_enc_table_entries
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|num_rsvd_entries
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|num_channels
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|max_dpm_entries
operator|=
name|sc
operator|->
name|ioc_pg8
operator|.
name|MaxPersistentEntries
expr_stmt|;
name|sc
operator|->
name|is_dpm_enable
operator|=
operator|(
name|sc
operator|->
name|max_dpm_entries
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|sc
operator|->
name|track_mapping_events
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ioc_pg8_flags
operator|&
name|MPI2_IOCPAGE8_FLAGS_DISABLE_PERSISTENT_MAPPING
condition|)
name|sc
operator|->
name|is_dpm_enable
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ioc_pg8_flags
operator|&
name|MPI2_IOCPAGE8_FLAGS_RESERVED_TARGETID_0
condition|)
name|sc
operator|->
name|num_rsvd_entries
operator|=
literal|1
expr_stmt|;
name|volume_mapping_flags
operator|=
name|sc
operator|->
name|ioc_pg8
operator|.
name|IRVolumeMappingFlags
operator|&
name|MPI2_IOCPAGE8_IRFLAGS_MASK_VOLUME_MAPPING_MODE
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ir_firmware
operator|&&
operator|(
name|volume_mapping_flags
operator|==
name|MPI2_IOCPAGE8_IRFLAGS_LOW_VOLUME_MAPPING
operator|)
condition|)
name|sc
operator|->
name|num_rsvd_entries
operator|+=
name|sc
operator|->
name|max_volumes
expr_stmt|;
name|error
operator|=
name|mps_mapping_allocate_memory
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|max_devices
condition|;
name|i
operator|++
control|)
name|_mapping_clear_map_entry
argument_list|(
name|sc
operator|->
name|mapping_table
operator|+
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|max_enclosures
condition|;
name|i
operator|++
control|)
name|_mapping_clear_enc_entry
argument_list|(
name|sc
operator|->
name|enclosure_table
operator|+
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|max_devices
condition|;
name|i
operator|++
control|)
block|{
name|sc
operator|->
name|removal_table
index|[
name|i
index|]
operator|.
name|dev_handle
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|removal_table
index|[
name|i
index|]
operator|.
name|dpm_entry_num
operator|=
name|MPS_DPM_BAD_IDX
expr_stmt|;
block|}
name|memset
argument_list|(
name|sc
operator|->
name|dpm_entry_used
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|max_dpm_entries
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|sc
operator|->
name|dpm_flush_entry
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|max_dpm_entries
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|is_dpm_enable
condition|)
block|{
name|dpm_pg0_sz
operator|=
sizeof|sizeof
argument_list|(
name|MPI2_CONFIG_EXTENDED_PAGE_HEADER
argument_list|)
operator|+
operator|(
name|sc
operator|->
name|max_dpm_entries
operator|*
sizeof|sizeof
argument_list|(
name|MPI2_CONFIG_PAGE_DRIVER_MAP0_ENTRY
argument_list|)
operator|)
expr_stmt|;
name|retry_count
operator|=
literal|0
expr_stmt|;
name|retry_read_dpm
label|:
if|if
condition|(
name|mps_config_get_dpm_pg0
argument_list|(
name|sc
argument_list|,
operator|&
name|mpi_reply
argument_list|,
name|sc
operator|->
name|dpm_pg0
argument_list|,
name|dpm_pg0_sz
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s: dpm page read failed; disabling dpm\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|retry_count
operator|<
literal|3
condition|)
block|{
name|retry_count
operator|++
expr_stmt|;
goto|goto
name|retry_read_dpm
goto|;
block|}
name|sc
operator|->
name|is_dpm_enable
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sc
operator|->
name|is_dpm_enable
condition|)
name|_mapping_process_dpm_pg0
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|track_mapping_events
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * mps_mapping_exit - clear mapping table and associated memory  * @sc: per adapter object  *  * Returns nothing.  */
end_comment

begin_function
name|void
name|mps_mapping_exit
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|)
block|{
name|_mapping_flush_dpm_pages
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mps_mapping_free_memory
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * mps_mapping_get_sas_id - assign a target id for sas device  * @sc: per adapter object  * @sas_address: sas address of the device  * @handle: device handle  *  * Returns valid ID on success or BAD_ID.  */
end_comment

begin_function
name|unsigned
name|int
name|mps_mapping_get_sas_id
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|uint64_t
name|sas_address
parameter_list|,
name|u16
name|handle
parameter_list|)
block|{
name|u32
name|map_idx
decl_stmt|;
name|struct
name|dev_mapping_table
modifier|*
name|mt_entry
decl_stmt|;
for|for
control|(
name|map_idx
operator|=
literal|0
init|;
name|map_idx
operator|<
name|sc
operator|->
name|max_devices
condition|;
name|map_idx
operator|++
control|)
block|{
name|mt_entry
operator|=
operator|&
name|sc
operator|->
name|mapping_table
index|[
name|map_idx
index|]
expr_stmt|;
if|if
condition|(
name|mt_entry
operator|->
name|dev_handle
operator|==
name|handle
operator|&&
name|mt_entry
operator|->
name|physical_id
operator|==
name|sas_address
condition|)
return|return
name|mt_entry
operator|->
name|id
return|;
block|}
return|return
name|MPS_MAP_BAD_ID
return|;
block|}
end_function

begin_comment
comment|/**  * mps_mapping_get_sas_id_from_handle - find a target id in mapping table using  * only the dev handle.  This is just a wrapper function for the local function  * _mapping_get_mt_idx_from_handle.  * @sc: per adapter object  * @handle: device handle  *  * Returns valid ID on success or BAD_ID.  */
end_comment

begin_function
name|unsigned
name|int
name|mps_mapping_get_sas_id_from_handle
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|u16
name|handle
parameter_list|)
block|{
return|return
operator|(
name|_mapping_get_mt_idx_from_handle
argument_list|(
name|sc
argument_list|,
name|handle
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * mps_mapping_get_raid_id - assign a target id for raid device  * @sc: per adapter object  * @wwid: world wide identifier for raid volume  * @handle: device handle  *  * Returns valid ID on success or BAD_ID.  */
end_comment

begin_function
name|unsigned
name|int
name|mps_mapping_get_raid_id
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|u64
name|wwid
parameter_list|,
name|u16
name|handle
parameter_list|)
block|{
name|u32
name|map_idx
decl_stmt|;
name|struct
name|dev_mapping_table
modifier|*
name|mt_entry
decl_stmt|;
for|for
control|(
name|map_idx
operator|=
literal|0
init|;
name|map_idx
operator|<
name|sc
operator|->
name|max_devices
condition|;
name|map_idx
operator|++
control|)
block|{
name|mt_entry
operator|=
operator|&
name|sc
operator|->
name|mapping_table
index|[
name|map_idx
index|]
expr_stmt|;
if|if
condition|(
name|mt_entry
operator|->
name|dev_handle
operator|==
name|handle
operator|&&
name|mt_entry
operator|->
name|physical_id
operator|==
name|wwid
condition|)
return|return
name|mt_entry
operator|->
name|id
return|;
block|}
return|return
name|MPS_MAP_BAD_ID
return|;
block|}
end_function

begin_comment
comment|/**  * mps_mapping_get_raid_id_from_handle - find raid device in mapping table  * using only the volume dev handle.  This is just a wrapper function for the  * local function _mapping_get_ir_mt_idx_from_handle.  * @sc: per adapter object  * @volHandle: volume device handle  *  * Returns valid ID on success or BAD_ID.  */
end_comment

begin_function
name|unsigned
name|int
name|mps_mapping_get_raid_id_from_handle
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|u16
name|volHandle
parameter_list|)
block|{
return|return
operator|(
name|_mapping_get_ir_mt_idx_from_handle
argument_list|(
name|sc
argument_list|,
name|volHandle
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * mps_mapping_enclosure_dev_status_change_event - handle enclosure events  * @sc: per adapter object  * @event_data: event data payload  *  * Return nothing.  */
end_comment

begin_function
name|void
name|mps_mapping_enclosure_dev_status_change_event
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|Mpi2EventDataSasEnclDevStatusChange_t
modifier|*
name|event_data
parameter_list|)
block|{
name|u8
name|enc_idx
decl_stmt|,
name|missing_count
decl_stmt|;
name|struct
name|enc_mapping_table
modifier|*
name|et_entry
decl_stmt|;
name|Mpi2DriverMap0Entry_t
modifier|*
name|dpm_entry
decl_stmt|;
name|u16
name|ioc_pg8_flags
init|=
name|le16toh
argument_list|(
name|sc
operator|->
name|ioc_pg8
operator|.
name|Flags
argument_list|)
decl_stmt|;
name|u8
name|map_shift
init|=
name|MPI2_DRVMAP0_MAPINFO_SLOT_SHIFT
decl_stmt|;
name|u8
name|update_phy_bits
init|=
literal|0
decl_stmt|;
name|u32
name|saved_phy_bits
decl_stmt|;
name|uint64_t
name|temp64_var
decl_stmt|;
if|if
condition|(
operator|(
name|ioc_pg8_flags
operator|&
name|MPI2_IOCPAGE8_FLAGS_MASK_MAPPING_MODE
operator|)
operator|!=
name|MPI2_IOCPAGE8_FLAGS_ENCLOSURE_SLOT_MAPPING
condition|)
goto|goto
name|out
goto|;
name|dpm_entry
operator|=
operator|(
name|Mpi2DriverMap0Entry_t
operator|*
operator|)
operator|(
operator|(
name|u8
operator|*
operator|)
name|sc
operator|->
name|dpm_pg0
operator|+
sizeof|sizeof
argument_list|(
name|MPI2_CONFIG_EXTENDED_PAGE_HEADER
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|event_data
operator|->
name|ReasonCode
operator|==
name|MPI2_EVENT_SAS_ENCL_RC_ADDED
condition|)
block|{
if|if
condition|(
operator|!
name|event_data
operator|->
name|NumSlots
condition|)
block|{
name|printf
argument_list|(
literal|"%s: enclosure with handle = 0x%x reported 0 "
literal|"slots\n"
argument_list|,
name|__func__
argument_list|,
name|le16toh
argument_list|(
name|event_data
operator|->
name|EnclosureHandle
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|temp64_var
operator|=
name|event_data
operator|->
name|EnclosureLogicalID
operator|.
name|High
expr_stmt|;
name|temp64_var
operator|=
operator|(
name|temp64_var
operator|<<
literal|32
operator|)
operator||
name|event_data
operator|->
name|EnclosureLogicalID
operator|.
name|Low
expr_stmt|;
name|enc_idx
operator|=
name|_mapping_get_enc_idx_from_id
argument_list|(
name|sc
argument_list|,
name|temp64_var
argument_list|,
name|event_data
operator|->
name|PhyBits
argument_list|)
expr_stmt|;
if|if
condition|(
name|enc_idx
operator|!=
name|MPS_ENCTABLE_BAD_IDX
condition|)
block|{
name|et_entry
operator|=
operator|&
name|sc
operator|->
name|enclosure_table
index|[
name|enc_idx
index|]
expr_stmt|;
if|if
condition|(
name|et_entry
operator|->
name|init_complete
operator|&&
operator|!
name|et_entry
operator|->
name|missing_count
condition|)
block|{
name|printf
argument_list|(
literal|"%s: enclosure %d is already present "
literal|"with handle = 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|enc_idx
argument_list|,
name|et_entry
operator|->
name|enc_handle
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|et_entry
operator|->
name|enc_handle
operator|=
name|le16toh
argument_list|(
name|event_data
operator|->
name|EnclosureHandle
argument_list|)
expr_stmt|;
name|et_entry
operator|->
name|start_slot
operator|=
name|le16toh
argument_list|(
name|event_data
operator|->
name|StartSlot
argument_list|)
expr_stmt|;
name|saved_phy_bits
operator|=
name|et_entry
operator|->
name|phy_bits
expr_stmt|;
name|et_entry
operator|->
name|phy_bits
operator||=
name|le32toh
argument_list|(
name|event_data
operator|->
name|PhyBits
argument_list|)
expr_stmt|;
if|if
condition|(
name|saved_phy_bits
operator|!=
name|et_entry
operator|->
name|phy_bits
condition|)
name|update_phy_bits
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|et_entry
operator|->
name|missing_count
operator|||
name|update_phy_bits
condition|)
block|{
name|et_entry
operator|->
name|missing_count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|is_dpm_enable
operator|&&
name|et_entry
operator|->
name|dpm_entry_num
operator|!=
name|MPS_DPM_BAD_IDX
condition|)
block|{
name|dpm_entry
operator|+=
name|et_entry
operator|->
name|dpm_entry_num
expr_stmt|;
name|missing_count
operator|=
call|(
name|u8
call|)
argument_list|(
name|dpm_entry
operator|->
name|MappingInformation
operator|&
name|MPI2_DRVMAP0_MAPINFO_MISSING_MASK
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|et_entry
operator|->
name|init_complete
operator|&&
operator|(
name|missing_count
operator|||
name|update_phy_bits
operator|)
condition|)
block|{
name|dpm_entry
operator|->
name|MappingInformation
operator|=
name|et_entry
operator|->
name|num_slots
expr_stmt|;
name|dpm_entry
operator|->
name|MappingInformation
operator|<<=
name|map_shift
expr_stmt|;
name|dpm_entry
operator|->
name|PhysicalBitsMapping
operator|=
name|et_entry
operator|->
name|phy_bits
expr_stmt|;
name|sc
operator|->
name|dpm_flush_entry
index|[
name|et_entry
operator|->
name|dpm_entry_num
index|]
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
name|enc_idx
operator|=
name|sc
operator|->
name|num_enc_table_entries
expr_stmt|;
if|if
condition|(
name|enc_idx
operator|>=
name|sc
operator|->
name|max_enclosures
condition|)
block|{
name|printf
argument_list|(
literal|"%s: enclosure can not be added; "
literal|"mapping table is full\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|sc
operator|->
name|num_enc_table_entries
operator|++
expr_stmt|;
name|et_entry
operator|=
operator|&
name|sc
operator|->
name|enclosure_table
index|[
name|enc_idx
index|]
expr_stmt|;
name|et_entry
operator|->
name|enc_handle
operator|=
name|le16toh
argument_list|(
name|event_data
operator|->
name|EnclosureHandle
argument_list|)
expr_stmt|;
name|et_entry
operator|->
name|enclosure_id
operator|=
name|event_data
operator|->
name|EnclosureLogicalID
operator|.
name|High
expr_stmt|;
name|et_entry
operator|->
name|enclosure_id
operator|=
operator|(
name|et_entry
operator|->
name|enclosure_id
operator|<<
literal|32
operator|)
operator||
name|event_data
operator|->
name|EnclosureLogicalID
operator|.
name|Low
expr_stmt|;
name|et_entry
operator|->
name|start_index
operator|=
name|MPS_MAPTABLE_BAD_IDX
expr_stmt|;
name|et_entry
operator|->
name|dpm_entry_num
operator|=
name|MPS_DPM_BAD_IDX
expr_stmt|;
name|et_entry
operator|->
name|num_slots
operator|=
name|le16toh
argument_list|(
name|event_data
operator|->
name|NumSlots
argument_list|)
expr_stmt|;
name|et_entry
operator|->
name|start_slot
operator|=
name|le16toh
argument_list|(
name|event_data
operator|->
name|StartSlot
argument_list|)
expr_stmt|;
name|et_entry
operator|->
name|phy_bits
operator|=
name|le32toh
argument_list|(
name|event_data
operator|->
name|PhyBits
argument_list|)
expr_stmt|;
block|}
name|et_entry
operator|->
name|init_complete
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|event_data
operator|->
name|ReasonCode
operator|==
name|MPI2_EVENT_SAS_ENCL_RC_NOT_RESPONDING
condition|)
block|{
name|enc_idx
operator|=
name|_mapping_get_enc_idx_from_handle
argument_list|(
name|sc
argument_list|,
name|le16toh
argument_list|(
name|event_data
operator|->
name|EnclosureHandle
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|enc_idx
operator|==
name|MPS_ENCTABLE_BAD_IDX
condition|)
block|{
name|printf
argument_list|(
literal|"%s: cannot unmap enclosure %d because it has "
literal|"already been deleted"
argument_list|,
name|__func__
argument_list|,
name|enc_idx
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|et_entry
operator|=
operator|&
name|sc
operator|->
name|enclosure_table
index|[
name|enc_idx
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|et_entry
operator|->
name|init_complete
condition|)
block|{
if|if
condition|(
name|et_entry
operator|->
name|missing_count
operator|<
name|MPS_MAX_MISSING_COUNT
condition|)
name|et_entry
operator|->
name|missing_count
operator|++
expr_stmt|;
else|else
name|et_entry
operator|->
name|init_complete
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|et_entry
operator|->
name|missing_count
condition|)
name|et_entry
operator|->
name|missing_count
operator|++
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|is_dpm_enable
operator|&&
operator|!
name|et_entry
operator|->
name|init_complete
operator|&&
name|et_entry
operator|->
name|dpm_entry_num
operator|!=
name|MPS_DPM_BAD_IDX
condition|)
block|{
name|dpm_entry
operator|+=
name|et_entry
operator|->
name|dpm_entry_num
expr_stmt|;
name|dpm_entry
operator|->
name|MappingInformation
operator|=
name|et_entry
operator|->
name|num_slots
expr_stmt|;
name|dpm_entry
operator|->
name|MappingInformation
operator|<<=
name|map_shift
expr_stmt|;
name|dpm_entry
operator|->
name|MappingInformation
operator||=
name|et_entry
operator|->
name|missing_count
expr_stmt|;
name|sc
operator|->
name|dpm_flush_entry
index|[
name|et_entry
operator|->
name|dpm_entry_num
index|]
operator|=
literal|1
expr_stmt|;
block|}
name|et_entry
operator|->
name|init_complete
operator|=
literal|1
expr_stmt|;
block|}
name|out
label|:
name|_mapping_flush_dpm_pages
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|pending_map_events
condition|)
name|sc
operator|->
name|pending_map_events
operator|--
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * mps_mapping_topology_change_event - handle topology change events  * @sc: per adapter object  * @event_data: event data payload  *  * Returns nothing.  */
end_comment

begin_function
name|void
name|mps_mapping_topology_change_event
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|Mpi2EventDataSasTopologyChangeList_t
modifier|*
name|event_data
parameter_list|)
block|{
name|struct
name|_map_topology_change
name|topo_change
decl_stmt|;
name|struct
name|_map_phy_change
modifier|*
name|phy_change
decl_stmt|;
name|Mpi2EventSasTopoPhyEntry_t
modifier|*
name|event_phy_change
decl_stmt|;
name|u8
name|i
decl_stmt|,
name|num_entries
decl_stmt|;
name|topo_change
operator|.
name|enc_handle
operator|=
name|le16toh
argument_list|(
name|event_data
operator|->
name|EnclosureHandle
argument_list|)
expr_stmt|;
name|topo_change
operator|.
name|exp_handle
operator|=
name|le16toh
argument_list|(
name|event_data
operator|->
name|ExpanderDevHandle
argument_list|)
expr_stmt|;
name|num_entries
operator|=
name|event_data
operator|->
name|NumEntries
expr_stmt|;
name|topo_change
operator|.
name|num_entries
operator|=
name|num_entries
expr_stmt|;
name|topo_change
operator|.
name|start_phy_num
operator|=
name|event_data
operator|->
name|StartPhyNum
expr_stmt|;
name|topo_change
operator|.
name|num_phys
operator|=
name|event_data
operator|->
name|NumPhys
expr_stmt|;
name|topo_change
operator|.
name|exp_status
operator|=
name|event_data
operator|->
name|ExpStatus
expr_stmt|;
name|event_phy_change
operator|=
name|event_data
operator|->
name|PHY
expr_stmt|;
name|topo_change
operator|.
name|phy_details
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|num_entries
condition|)
goto|goto
name|out
goto|;
name|phy_change
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|_map_phy_change
argument_list|)
operator|*
name|num_entries
argument_list|,
name|M_MPT2
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|topo_change
operator|.
name|phy_details
operator|=
name|phy_change
expr_stmt|;
if|if
condition|(
operator|!
name|phy_change
condition|)
goto|goto
name|out
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_entries
condition|;
name|i
operator|++
operator|,
name|event_phy_change
operator|++
operator|,
name|phy_change
operator|++
control|)
block|{
name|phy_change
operator|->
name|dev_handle
operator|=
name|le16toh
argument_list|(
name|event_phy_change
operator|->
name|AttachedDevHandle
argument_list|)
expr_stmt|;
name|phy_change
operator|->
name|reason
operator|=
name|event_phy_change
operator|->
name|PhyStatus
operator|&
name|MPI2_EVENT_SAS_TOPO_RC_MASK
expr_stmt|;
block|}
name|_mapping_update_missing_count
argument_list|(
name|sc
argument_list|,
operator|&
name|topo_change
argument_list|)
expr_stmt|;
name|_mapping_get_dev_info
argument_list|(
name|sc
argument_list|,
operator|&
name|topo_change
argument_list|)
expr_stmt|;
name|_mapping_clear_removed_entries
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|_mapping_add_new_device
argument_list|(
name|sc
argument_list|,
operator|&
name|topo_change
argument_list|)
expr_stmt|;
name|out
label|:
name|free
argument_list|(
name|topo_change
operator|.
name|phy_details
argument_list|,
name|M_MPT2
argument_list|)
expr_stmt|;
name|_mapping_flush_dpm_pages
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|pending_map_events
condition|)
name|sc
operator|->
name|pending_map_events
operator|--
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * _mapping_check_update_ir_mt_idx - Check and update IR map table index  * @sc: per adapter object  * @event_data: event data payload  * @evt_idx: current event index  * @map_idx: current index and the place holder for new map table index  * @wwid_table: world wide name for volumes in the element table  *  * pass through IR events and find whether any events matches and if so  * tries to find new index if not returns failure  *  * Returns 0 on success and 1 on failure  */
end_comment

begin_function
specifier|static
name|int
name|_mapping_check_update_ir_mt_idx
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|Mpi2EventDataIrConfigChangeList_t
modifier|*
name|event_data
parameter_list|,
name|int
name|evt_idx
parameter_list|,
name|u32
modifier|*
name|map_idx
parameter_list|,
name|u64
modifier|*
name|wwid_table
parameter_list|)
block|{
name|struct
name|dev_mapping_table
modifier|*
name|mt_entry
decl_stmt|;
name|u32
name|st_idx
decl_stmt|,
name|end_idx
decl_stmt|,
name|mt_idx
init|=
operator|*
name|map_idx
decl_stmt|;
name|u8
name|match
init|=
literal|0
decl_stmt|;
name|Mpi2EventIrConfigElement_t
modifier|*
name|element
decl_stmt|;
name|u16
name|element_flags
decl_stmt|;
name|int
name|i
decl_stmt|;
name|mt_entry
operator|=
operator|&
name|sc
operator|->
name|mapping_table
index|[
name|mt_idx
index|]
expr_stmt|;
name|_mapping_get_ir_maprange
argument_list|(
name|sc
argument_list|,
operator|&
name|st_idx
argument_list|,
operator|&
name|end_idx
argument_list|)
expr_stmt|;
name|search_again
label|:
name|match
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|evt_idx
operator|+
literal|1
init|;
name|i
operator|<
name|event_data
operator|->
name|NumElements
condition|;
name|i
operator|++
control|)
block|{
name|element
operator|=
operator|(
name|Mpi2EventIrConfigElement_t
operator|*
operator|)
operator|&
name|event_data
operator|->
name|ConfigElement
index|[
name|i
index|]
expr_stmt|;
name|element_flags
operator|=
name|le16toh
argument_list|(
name|element
operator|->
name|ElementFlags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|element_flags
operator|&
name|MPI2_EVENT_IR_CHANGE_EFLAGS_ELEMENT_TYPE_MASK
operator|)
operator|!=
name|MPI2_EVENT_IR_CHANGE_EFLAGS_VOLUME_ELEMENT
condition|)
continue|continue;
if|if
condition|(
name|element
operator|->
name|ReasonCode
operator|==
name|MPI2_EVENT_IR_CHANGE_RC_ADDED
operator|||
name|element
operator|->
name|ReasonCode
operator|==
name|MPI2_EVENT_IR_CHANGE_RC_VOLUME_CREATED
condition|)
block|{
if|if
condition|(
name|mt_entry
operator|->
name|physical_id
operator|==
name|wwid_table
index|[
name|i
index|]
condition|)
block|{
name|match
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|match
condition|)
block|{
do|do
block|{
name|mt_idx
operator|++
expr_stmt|;
if|if
condition|(
name|mt_idx
operator|>
name|end_idx
condition|)
return|return
literal|1
return|;
name|mt_entry
operator|=
operator|&
name|sc
operator|->
name|mapping_table
index|[
name|mt_idx
index|]
expr_stmt|;
block|}
do|while
condition|(
name|mt_entry
operator|->
name|device_info
operator|&
name|MPS_MAP_IN_USE
condition|)
do|;
goto|goto
name|search_again
goto|;
block|}
operator|*
name|map_idx
operator|=
name|mt_idx
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * mps_mapping_ir_config_change_event - handle IR config change list events  * @sc: per adapter object  * @event_data: event data payload  *  * Returns nothing.  */
end_comment

begin_function
name|void
name|mps_mapping_ir_config_change_event
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|Mpi2EventDataIrConfigChangeList_t
modifier|*
name|event_data
parameter_list|)
block|{
name|Mpi2EventIrConfigElement_t
modifier|*
name|element
decl_stmt|;
name|int
name|i
decl_stmt|;
name|u64
modifier|*
name|wwid_table
decl_stmt|;
name|u32
name|map_idx
decl_stmt|,
name|flags
decl_stmt|;
name|struct
name|dev_mapping_table
modifier|*
name|mt_entry
decl_stmt|;
name|u16
name|element_flags
decl_stmt|;
name|u8
name|log_full_error
init|=
literal|0
decl_stmt|;
name|wwid_table
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|u64
argument_list|)
operator|*
name|event_data
operator|->
name|NumElements
argument_list|,
name|M_MPT2
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|wwid_table
condition|)
goto|goto
name|out
goto|;
name|element
operator|=
operator|(
name|Mpi2EventIrConfigElement_t
operator|*
operator|)
operator|&
name|event_data
operator|->
name|ConfigElement
index|[
literal|0
index|]
expr_stmt|;
name|flags
operator|=
name|le32toh
argument_list|(
name|event_data
operator|->
name|Flags
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|event_data
operator|->
name|NumElements
condition|;
name|i
operator|++
operator|,
name|element
operator|++
control|)
block|{
name|element_flags
operator|=
name|le16toh
argument_list|(
name|element
operator|->
name|ElementFlags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|element
operator|->
name|ReasonCode
operator|!=
name|MPI2_EVENT_IR_CHANGE_RC_ADDED
operator|)
operator|&&
operator|(
name|element
operator|->
name|ReasonCode
operator|!=
name|MPI2_EVENT_IR_CHANGE_RC_REMOVED
operator|)
operator|&&
operator|(
name|element
operator|->
name|ReasonCode
operator|!=
name|MPI2_EVENT_IR_CHANGE_RC_NO_CHANGE
operator|)
operator|&&
operator|(
name|element
operator|->
name|ReasonCode
operator|!=
name|MPI2_EVENT_IR_CHANGE_RC_VOLUME_CREATED
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
name|element_flags
operator|&
name|MPI2_EVENT_IR_CHANGE_EFLAGS_ELEMENT_TYPE_MASK
operator|)
operator|==
name|MPI2_EVENT_IR_CHANGE_EFLAGS_VOLUME_ELEMENT
condition|)
block|{
name|mps_config_get_volume_wwid
argument_list|(
name|sc
argument_list|,
name|le16toh
argument_list|(
name|element
operator|->
name|VolDevHandle
argument_list|)
argument_list|,
operator|&
name|wwid_table
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|map_idx
operator|=
name|_mapping_get_ir_mt_idx_from_wwid
argument_list|(
name|sc
argument_list|,
name|wwid_table
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|map_idx
operator|!=
name|MPS_MAPTABLE_BAD_IDX
condition|)
block|{
name|mt_entry
operator|=
operator|&
name|sc
operator|->
name|mapping_table
index|[
name|map_idx
index|]
expr_stmt|;
name|mt_entry
operator|->
name|device_info
operator||=
name|MPS_MAP_IN_USE
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|flags
operator|==
name|MPI2_EVENT_IR_CHANGE_FLAGS_FOREIGN_CONFIG
condition|)
goto|goto
name|out
goto|;
else|else
block|{
name|element
operator|=
operator|(
name|Mpi2EventIrConfigElement_t
operator|*
operator|)
operator|&
name|event_data
operator|->
name|ConfigElement
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|event_data
operator|->
name|NumElements
condition|;
name|i
operator|++
operator|,
name|element
operator|++
control|)
block|{
if|if
condition|(
name|element
operator|->
name|ReasonCode
operator|==
name|MPI2_EVENT_IR_CHANGE_RC_ADDED
operator|||
name|element
operator|->
name|ReasonCode
operator|==
name|MPI2_EVENT_IR_CHANGE_RC_VOLUME_CREATED
condition|)
block|{
name|map_idx
operator|=
name|_mapping_get_ir_mt_idx_from_wwid
argument_list|(
name|sc
argument_list|,
name|wwid_table
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|map_idx
operator|!=
name|MPS_MAPTABLE_BAD_IDX
condition|)
block|{
name|mt_entry
operator|=
operator|&
name|sc
operator|->
name|mapping_table
index|[
name|map_idx
index|]
expr_stmt|;
name|mt_entry
operator|->
name|channel
operator|=
name|MPS_RAID_CHANNEL
expr_stmt|;
name|mt_entry
operator|->
name|id
operator|=
name|map_idx
expr_stmt|;
name|mt_entry
operator|->
name|dev_handle
operator|=
name|le16toh
argument_list|(
name|element
operator|->
name|VolDevHandle
argument_list|)
expr_stmt|;
name|mt_entry
operator|->
name|device_info
operator|=
name|MPS_DEV_RESERVED
operator||
name|MPS_MAP_IN_USE
expr_stmt|;
name|_mapping_update_ir_missing_cnt
argument_list|(
name|sc
argument_list|,
name|map_idx
argument_list|,
name|element
argument_list|,
name|wwid_table
index|[
name|i
index|]
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|map_idx
operator|=
name|_mapping_get_free_ir_mt_idx
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|map_idx
operator|==
name|MPS_MAPTABLE_BAD_IDX
condition|)
name|log_full_error
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|<
operator|(
name|event_data
operator|->
name|NumElements
operator|-
literal|1
operator|)
condition|)
block|{
name|log_full_error
operator|=
name|_mapping_check_update_ir_mt_idx
argument_list|(
name|sc
argument_list|,
name|event_data
argument_list|,
name|i
argument_list|,
operator|&
name|map_idx
argument_list|,
name|wwid_table
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|log_full_error
condition|)
block|{
name|printf
argument_list|(
literal|"%s: no space to add the RAID "
literal|"volume with handle 0x%04x in "
literal|"mapping table\n"
argument_list|,
name|__func__
argument_list|,
name|le16toh
argument_list|(
name|element
operator|->
name|VolDevHandle
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|mt_entry
operator|=
operator|&
name|sc
operator|->
name|mapping_table
index|[
name|map_idx
index|]
expr_stmt|;
name|mt_entry
operator|->
name|physical_id
operator|=
name|wwid_table
index|[
name|i
index|]
expr_stmt|;
name|mt_entry
operator|->
name|channel
operator|=
name|MPS_RAID_CHANNEL
expr_stmt|;
name|mt_entry
operator|->
name|id
operator|=
name|map_idx
expr_stmt|;
name|mt_entry
operator|->
name|dev_handle
operator|=
name|le16toh
argument_list|(
name|element
operator|->
name|VolDevHandle
argument_list|)
expr_stmt|;
name|mt_entry
operator|->
name|device_info
operator|=
name|MPS_DEV_RESERVED
operator||
name|MPS_MAP_IN_USE
expr_stmt|;
name|mt_entry
operator|->
name|init_complete
operator|=
literal|0
expr_stmt|;
name|_mapping_update_ir_missing_cnt
argument_list|(
name|sc
argument_list|,
name|map_idx
argument_list|,
name|element
argument_list|,
name|wwid_table
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|element
operator|->
name|ReasonCode
operator|==
name|MPI2_EVENT_IR_CHANGE_RC_REMOVED
condition|)
block|{
name|map_idx
operator|=
name|_mapping_get_ir_mt_idx_from_wwid
argument_list|(
name|sc
argument_list|,
name|wwid_table
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|map_idx
operator|==
name|MPS_MAPTABLE_BAD_IDX
condition|)
block|{
name|printf
argument_list|(
literal|"%s: failed to remove a volume "
literal|"because it has already been "
literal|"removed\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|_mapping_update_ir_missing_cnt
argument_list|(
name|sc
argument_list|,
name|map_idx
argument_list|,
name|element
argument_list|,
name|wwid_table
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|element
operator|->
name|ReasonCode
operator|==
name|MPI2_EVENT_IR_CHANGE_RC_VOLUME_DELETED
condition|)
block|{
name|map_idx
operator|=
name|_mapping_get_mt_idx_from_handle
argument_list|(
name|sc
argument_list|,
name|le16toh
argument_list|(
name|element
operator|->
name|VolDevHandle
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|map_idx
operator|==
name|MPS_MAPTABLE_BAD_IDX
condition|)
block|{
name|printf
argument_list|(
literal|"%s: failed to remove volume "
literal|"with handle 0x%04x because it has "
literal|"already been removed\n"
argument_list|,
name|__func__
argument_list|,
name|le16toh
argument_list|(
name|element
operator|->
name|VolDevHandle
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|mt_entry
operator|=
operator|&
name|sc
operator|->
name|mapping_table
index|[
name|map_idx
index|]
expr_stmt|;
name|_mapping_update_ir_missing_cnt
argument_list|(
name|sc
argument_list|,
name|map_idx
argument_list|,
name|element
argument_list|,
name|mt_entry
operator|->
name|physical_id
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|out
label|:
name|_mapping_flush_dpm_pages
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|wwid_table
argument_list|,
name|M_MPT2
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|pending_map_events
condition|)
name|sc
operator|->
name|pending_map_events
operator|--
expr_stmt|;
block|}
end_function

begin_function
name|int
name|mps_mapping_dump
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|mps_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|dev_mapping_table
modifier|*
name|mt_entry
decl_stmt|;
name|struct
name|sbuf
name|sbuf
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|mps_softc
operator|*
operator|)
name|arg1
expr_stmt|;
name|error
operator|=
name|sysctl_wire_old_buffer
argument_list|(
name|req
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|sbuf_new_for_sysctl
argument_list|(
operator|&
name|sbuf
argument_list|,
name|NULL
argument_list|,
literal|128
argument_list|,
name|req
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
operator|&
name|sbuf
argument_list|,
literal|"\nindex physical_id       handle id\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|max_devices
condition|;
name|i
operator|++
control|)
block|{
name|mt_entry
operator|=
operator|&
name|sc
operator|->
name|mapping_table
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|mt_entry
operator|->
name|physical_id
operator|==
literal|0
condition|)
continue|continue;
name|sbuf_printf
argument_list|(
operator|&
name|sbuf
argument_list|,
literal|"%4d  %jx  %04x   %hd\n"
argument_list|,
name|i
argument_list|,
name|mt_entry
operator|->
name|physical_id
argument_list|,
name|mt_entry
operator|->
name|dev_handle
argument_list|,
name|mt_entry
operator|->
name|id
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|sbuf_finish
argument_list|(
operator|&
name|sbuf
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
operator|&
name|sbuf
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|mps_mapping_encl_dump
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|mps_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|enc_mapping_table
modifier|*
name|enc_entry
decl_stmt|;
name|struct
name|sbuf
name|sbuf
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|mps_softc
operator|*
operator|)
name|arg1
expr_stmt|;
name|error
operator|=
name|sysctl_wire_old_buffer
argument_list|(
name|req
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|sbuf_new_for_sysctl
argument_list|(
operator|&
name|sbuf
argument_list|,
name|NULL
argument_list|,
literal|128
argument_list|,
name|req
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
operator|&
name|sbuf
argument_list|,
literal|"\nindex enclosure_id      handle map_index\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|max_enclosures
condition|;
name|i
operator|++
control|)
block|{
name|enc_entry
operator|=
operator|&
name|sc
operator|->
name|enclosure_table
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|enc_entry
operator|->
name|enclosure_id
operator|==
literal|0
condition|)
continue|continue;
name|sbuf_printf
argument_list|(
operator|&
name|sbuf
argument_list|,
literal|"%4d  %jx  %04x   %d\n"
argument_list|,
name|i
argument_list|,
name|enc_entry
operator|->
name|enclosure_id
argument_list|,
name|enc_entry
operator|->
name|enc_handle
argument_list|,
name|enc_entry
operator|->
name|start_index
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|sbuf_finish
argument_list|(
operator|&
name|sbuf
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
operator|&
name|sbuf
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

end_unit

