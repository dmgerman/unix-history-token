begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2011-2015 LSI Corp.  * Copyright (c) 2013-2015 Avago Technologies  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * Avago Technologies (LSI) MPT-Fusion Host Adapter FreeBSD  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* TODO Move headers to mpsvar */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/sbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/eventhandler.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<dev/mps/mpi/mpi2_type.h>
end_include

begin_include
include|#
directive|include
file|<dev/mps/mpi/mpi2.h>
end_include

begin_include
include|#
directive|include
file|<dev/mps/mpi/mpi2_ioc.h>
end_include

begin_include
include|#
directive|include
file|<dev/mps/mpi/mpi2_sas.h>
end_include

begin_include
include|#
directive|include
file|<dev/mps/mpi/mpi2_cnfg.h>
end_include

begin_include
include|#
directive|include
file|<dev/mps/mpi/mpi2_init.h>
end_include

begin_include
include|#
directive|include
file|<dev/mps/mpi/mpi2_tool.h>
end_include

begin_include
include|#
directive|include
file|<dev/mps/mps_ioctl.h>
end_include

begin_include
include|#
directive|include
file|<dev/mps/mpsvar.h>
end_include

begin_include
include|#
directive|include
file|<dev/mps/mps_mapping.h>
end_include

begin_comment
comment|/**  * _mapping_clear_map_entry - Clear a particular mapping entry.  * @map_entry: map table entry  *  * Returns nothing.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|_mapping_clear_map_entry
parameter_list|(
name|struct
name|dev_mapping_table
modifier|*
name|map_entry
parameter_list|)
block|{
name|map_entry
operator|->
name|physical_id
operator|=
literal|0
expr_stmt|;
name|map_entry
operator|->
name|device_info
operator|=
literal|0
expr_stmt|;
name|map_entry
operator|->
name|phy_bits
operator|=
literal|0
expr_stmt|;
name|map_entry
operator|->
name|dpm_entry_num
operator|=
name|MPS_DPM_BAD_IDX
expr_stmt|;
name|map_entry
operator|->
name|dev_handle
operator|=
literal|0
expr_stmt|;
name|map_entry
operator|->
name|id
operator|=
operator|-
literal|1
expr_stmt|;
name|map_entry
operator|->
name|missing_count
operator|=
literal|0
expr_stmt|;
name|map_entry
operator|->
name|init_complete
operator|=
literal|0
expr_stmt|;
name|map_entry
operator|->
name|TLR_bits
operator|=
operator|(
name|u8
operator|)
name|MPI2_SCSIIO_CONTROL_NO_TLR
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * _mapping_clear_enc_entry - Clear a particular enclosure table entry.  * @enc_entry: enclosure table entry  *  * Returns nothing.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|_mapping_clear_enc_entry
parameter_list|(
name|struct
name|enc_mapping_table
modifier|*
name|enc_entry
parameter_list|)
block|{
name|enc_entry
operator|->
name|enclosure_id
operator|=
literal|0
expr_stmt|;
name|enc_entry
operator|->
name|start_index
operator|=
name|MPS_MAPTABLE_BAD_IDX
expr_stmt|;
name|enc_entry
operator|->
name|phy_bits
operator|=
literal|0
expr_stmt|;
name|enc_entry
operator|->
name|dpm_entry_num
operator|=
name|MPS_DPM_BAD_IDX
expr_stmt|;
name|enc_entry
operator|->
name|enc_handle
operator|=
literal|0
expr_stmt|;
name|enc_entry
operator|->
name|num_slots
operator|=
literal|0
expr_stmt|;
name|enc_entry
operator|->
name|start_slot
operator|=
literal|0
expr_stmt|;
name|enc_entry
operator|->
name|missing_count
operator|=
literal|0
expr_stmt|;
name|enc_entry
operator|->
name|removal_flag
operator|=
literal|0
expr_stmt|;
name|enc_entry
operator|->
name|skip_search
operator|=
literal|0
expr_stmt|;
name|enc_entry
operator|->
name|init_complete
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * _mapping_commit_enc_entry - write a particular enc entry in DPM page0.  * @sc: per adapter object  * @enc_entry: enclosure table entry  *  * Returns 0 for success, non-zero for failure.  */
end_comment

begin_function
specifier|static
name|int
name|_mapping_commit_enc_entry
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|enc_mapping_table
modifier|*
name|et_entry
parameter_list|)
block|{
name|Mpi2DriverMap0Entry_t
modifier|*
name|dpm_entry
decl_stmt|;
name|struct
name|dev_mapping_table
modifier|*
name|mt_entry
decl_stmt|;
name|Mpi2ConfigReply_t
name|mpi_reply
decl_stmt|;
name|Mpi2DriverMappingPage0_t
name|config_page
decl_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|is_dpm_enable
condition|)
return|return
literal|0
return|;
name|memset
argument_list|(
operator|&
name|config_page
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|Mpi2DriverMappingPage0_t
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|config_page
operator|.
name|Header
argument_list|,
operator|(
name|u8
operator|*
operator|)
name|sc
operator|->
name|dpm_pg0
argument_list|,
sizeof|sizeof
argument_list|(
name|MPI2_CONFIG_EXTENDED_PAGE_HEADER
argument_list|)
argument_list|)
expr_stmt|;
name|dpm_entry
operator|=
operator|(
name|Mpi2DriverMap0Entry_t
operator|*
operator|)
operator|(
operator|(
name|u8
operator|*
operator|)
name|sc
operator|->
name|dpm_pg0
operator|+
sizeof|sizeof
argument_list|(
name|MPI2_CONFIG_EXTENDED_PAGE_HEADER
argument_list|)
operator|)
expr_stmt|;
name|dpm_entry
operator|+=
name|et_entry
operator|->
name|dpm_entry_num
expr_stmt|;
name|dpm_entry
operator|->
name|PhysicalIdentifier
operator|.
name|Low
operator|=
operator|(
literal|0xFFFFFFFF
operator|&
name|et_entry
operator|->
name|enclosure_id
operator|)
expr_stmt|;
name|dpm_entry
operator|->
name|PhysicalIdentifier
operator|.
name|High
operator|=
operator|(
name|et_entry
operator|->
name|enclosure_id
operator|>>
literal|32
operator|)
expr_stmt|;
name|mt_entry
operator|=
operator|&
name|sc
operator|->
name|mapping_table
index|[
name|et_entry
operator|->
name|start_index
index|]
expr_stmt|;
name|dpm_entry
operator|->
name|DeviceIndex
operator|=
name|htole16
argument_list|(
name|mt_entry
operator|->
name|id
argument_list|)
expr_stmt|;
name|dpm_entry
operator|->
name|MappingInformation
operator|=
name|et_entry
operator|->
name|num_slots
expr_stmt|;
name|dpm_entry
operator|->
name|MappingInformation
operator|<<=
name|MPI2_DRVMAP0_MAPINFO_SLOT_SHIFT
expr_stmt|;
name|dpm_entry
operator|->
name|MappingInformation
operator||=
name|et_entry
operator|->
name|missing_count
expr_stmt|;
name|dpm_entry
operator|->
name|MappingInformation
operator|=
name|htole16
argument_list|(
name|dpm_entry
operator|->
name|MappingInformation
argument_list|)
expr_stmt|;
name|dpm_entry
operator|->
name|PhysicalBitsMapping
operator|=
name|htole32
argument_list|(
name|et_entry
operator|->
name|phy_bits
argument_list|)
expr_stmt|;
name|dpm_entry
operator|->
name|Reserved1
operator|=
literal|0
expr_stmt|;
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_MAPPING
argument_list|,
literal|"%s: Writing DPM entry %d for enclosure.\n"
argument_list|,
name|__func__
argument_list|,
name|et_entry
operator|->
name|dpm_entry_num
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|config_page
operator|.
name|Entry
argument_list|,
operator|(
name|u8
operator|*
operator|)
name|dpm_entry
argument_list|,
sizeof|sizeof
argument_list|(
name|Mpi2DriverMap0Entry_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mps_config_set_dpm_pg0
argument_list|(
name|sc
argument_list|,
operator|&
name|mpi_reply
argument_list|,
operator|&
name|config_page
argument_list|,
name|et_entry
operator|->
name|dpm_entry_num
argument_list|)
condition|)
block|{
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_ERROR
operator||
name|MPS_MAPPING
argument_list|,
literal|"%s: Write of DPM "
literal|"entry %d for enclosure failed.\n"
argument_list|,
name|__func__
argument_list|,
name|et_entry
operator|->
name|dpm_entry_num
argument_list|)
expr_stmt|;
name|dpm_entry
operator|->
name|MappingInformation
operator|=
name|le16toh
argument_list|(
name|dpm_entry
operator|->
name|MappingInformation
argument_list|)
expr_stmt|;
name|dpm_entry
operator|->
name|DeviceIndex
operator|=
name|le16toh
argument_list|(
name|dpm_entry
operator|->
name|DeviceIndex
argument_list|)
expr_stmt|;
name|dpm_entry
operator|->
name|PhysicalBitsMapping
operator|=
name|le32toh
argument_list|(
name|dpm_entry
operator|->
name|PhysicalBitsMapping
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|dpm_entry
operator|->
name|MappingInformation
operator|=
name|le16toh
argument_list|(
name|dpm_entry
operator|->
name|MappingInformation
argument_list|)
expr_stmt|;
name|dpm_entry
operator|->
name|DeviceIndex
operator|=
name|le16toh
argument_list|(
name|dpm_entry
operator|->
name|DeviceIndex
argument_list|)
expr_stmt|;
name|dpm_entry
operator|->
name|PhysicalBitsMapping
operator|=
name|le32toh
argument_list|(
name|dpm_entry
operator|->
name|PhysicalBitsMapping
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * _mapping_commit_map_entry - write a particular map table entry in DPM page0.  * @sc: per adapter object  * @mt_entry: mapping table entry  *  * Returns 0 for success, non-zero for failure.  */
end_comment

begin_function
specifier|static
name|int
name|_mapping_commit_map_entry
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|dev_mapping_table
modifier|*
name|mt_entry
parameter_list|)
block|{
name|Mpi2DriverMap0Entry_t
modifier|*
name|dpm_entry
decl_stmt|;
name|Mpi2ConfigReply_t
name|mpi_reply
decl_stmt|;
name|Mpi2DriverMappingPage0_t
name|config_page
decl_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|is_dpm_enable
condition|)
return|return
literal|0
return|;
comment|/* 	 * It's possible that this Map Entry points to a BAD DPM index. This 	 * can happen if the Map Entry is a for a missing device and the DPM 	 * entry that was being used by this device is now being used by some 	 * new device. So, check for a BAD DPM index and just return if so. 	 */
if|if
condition|(
name|mt_entry
operator|->
name|dpm_entry_num
operator|==
name|MPS_DPM_BAD_IDX
condition|)
block|{
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_MAPPING
argument_list|,
literal|"%s: DPM entry location for target "
literal|"%d is invalid. DPM will not be written.\n"
argument_list|,
name|__func__
argument_list|,
name|mt_entry
operator|->
name|id
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|memset
argument_list|(
operator|&
name|config_page
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|Mpi2DriverMappingPage0_t
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|config_page
operator|.
name|Header
argument_list|,
operator|(
name|u8
operator|*
operator|)
name|sc
operator|->
name|dpm_pg0
argument_list|,
sizeof|sizeof
argument_list|(
name|MPI2_CONFIG_EXTENDED_PAGE_HEADER
argument_list|)
argument_list|)
expr_stmt|;
name|dpm_entry
operator|=
operator|(
name|Mpi2DriverMap0Entry_t
operator|*
operator|)
operator|(
operator|(
name|u8
operator|*
operator|)
name|sc
operator|->
name|dpm_pg0
operator|+
sizeof|sizeof
argument_list|(
name|MPI2_CONFIG_EXTENDED_PAGE_HEADER
argument_list|)
operator|)
expr_stmt|;
name|dpm_entry
operator|=
name|dpm_entry
operator|+
name|mt_entry
operator|->
name|dpm_entry_num
expr_stmt|;
name|dpm_entry
operator|->
name|PhysicalIdentifier
operator|.
name|Low
operator|=
operator|(
literal|0xFFFFFFFF
operator|&
name|mt_entry
operator|->
name|physical_id
operator|)
expr_stmt|;
name|dpm_entry
operator|->
name|PhysicalIdentifier
operator|.
name|High
operator|=
operator|(
name|mt_entry
operator|->
name|physical_id
operator|>>
literal|32
operator|)
expr_stmt|;
name|dpm_entry
operator|->
name|DeviceIndex
operator|=
name|htole16
argument_list|(
name|mt_entry
operator|->
name|id
argument_list|)
expr_stmt|;
name|dpm_entry
operator|->
name|MappingInformation
operator|=
name|htole16
argument_list|(
name|mt_entry
operator|->
name|missing_count
argument_list|)
expr_stmt|;
name|dpm_entry
operator|->
name|PhysicalBitsMapping
operator|=
literal|0
expr_stmt|;
name|dpm_entry
operator|->
name|Reserved1
operator|=
literal|0
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|config_page
operator|.
name|Entry
argument_list|,
operator|(
name|u8
operator|*
operator|)
name|dpm_entry
argument_list|,
sizeof|sizeof
argument_list|(
name|Mpi2DriverMap0Entry_t
argument_list|)
argument_list|)
expr_stmt|;
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_MAPPING
argument_list|,
literal|"%s: Writing DPM entry %d for target %d.\n"
argument_list|,
name|__func__
argument_list|,
name|mt_entry
operator|->
name|dpm_entry_num
argument_list|,
name|mt_entry
operator|->
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|mps_config_set_dpm_pg0
argument_list|(
name|sc
argument_list|,
operator|&
name|mpi_reply
argument_list|,
operator|&
name|config_page
argument_list|,
name|mt_entry
operator|->
name|dpm_entry_num
argument_list|)
condition|)
block|{
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_ERROR
operator||
name|MPS_MAPPING
argument_list|,
literal|"%s: Write of DPM "
literal|"entry %d for target %d failed.\n"
argument_list|,
name|__func__
argument_list|,
name|mt_entry
operator|->
name|dpm_entry_num
argument_list|,
name|mt_entry
operator|->
name|id
argument_list|)
expr_stmt|;
name|dpm_entry
operator|->
name|MappingInformation
operator|=
name|le16toh
argument_list|(
name|dpm_entry
operator|->
name|MappingInformation
argument_list|)
expr_stmt|;
name|dpm_entry
operator|->
name|DeviceIndex
operator|=
name|le16toh
argument_list|(
name|dpm_entry
operator|->
name|DeviceIndex
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|dpm_entry
operator|->
name|MappingInformation
operator|=
name|le16toh
argument_list|(
name|dpm_entry
operator|->
name|MappingInformation
argument_list|)
expr_stmt|;
name|dpm_entry
operator|->
name|DeviceIndex
operator|=
name|le16toh
argument_list|(
name|dpm_entry
operator|->
name|DeviceIndex
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * _mapping_get_ir_maprange - get start and end index for IR map range.  * @sc: per adapter object  * @start_idx: place holder for start index  * @end_idx: place holder for end index  *  * The IR volumes can be mapped either at start or end of the mapping table  * this function gets the detail of where IR volume mapping starts and ends  * in the device mapping table  *  * Returns nothing.  */
end_comment

begin_function
specifier|static
name|void
name|_mapping_get_ir_maprange
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|u32
modifier|*
name|start_idx
parameter_list|,
name|u32
modifier|*
name|end_idx
parameter_list|)
block|{
name|u16
name|volume_mapping_flags
decl_stmt|;
name|u16
name|ioc_pg8_flags
init|=
name|le16toh
argument_list|(
name|sc
operator|->
name|ioc_pg8
operator|.
name|Flags
argument_list|)
decl_stmt|;
name|volume_mapping_flags
operator|=
name|le16toh
argument_list|(
name|sc
operator|->
name|ioc_pg8
operator|.
name|IRVolumeMappingFlags
argument_list|)
operator|&
name|MPI2_IOCPAGE8_IRFLAGS_MASK_VOLUME_MAPPING_MODE
expr_stmt|;
if|if
condition|(
name|volume_mapping_flags
operator|==
name|MPI2_IOCPAGE8_IRFLAGS_LOW_VOLUME_MAPPING
condition|)
block|{
operator|*
name|start_idx
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ioc_pg8_flags
operator|&
name|MPI2_IOCPAGE8_FLAGS_RESERVED_TARGETID_0
condition|)
operator|*
name|start_idx
operator|=
literal|1
expr_stmt|;
block|}
else|else
operator|*
name|start_idx
operator|=
name|sc
operator|->
name|max_devices
operator|-
name|sc
operator|->
name|max_volumes
expr_stmt|;
operator|*
name|end_idx
operator|=
operator|*
name|start_idx
operator|+
name|sc
operator|->
name|max_volumes
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * _mapping_get_enc_idx_from_id - get enclosure index from enclosure ID  * @sc: per adapter object  * @enc_id: enclosure logical identifier  *  * Returns the index of enclosure entry on success or bad index.  */
end_comment

begin_function
specifier|static
name|u8
name|_mapping_get_enc_idx_from_id
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|u64
name|enc_id
parameter_list|,
name|u64
name|phy_bits
parameter_list|)
block|{
name|struct
name|enc_mapping_table
modifier|*
name|et_entry
decl_stmt|;
name|u8
name|enc_idx
init|=
literal|0
decl_stmt|;
for|for
control|(
name|enc_idx
operator|=
literal|0
init|;
name|enc_idx
operator|<
name|sc
operator|->
name|num_enc_table_entries
condition|;
name|enc_idx
operator|++
control|)
block|{
name|et_entry
operator|=
operator|&
name|sc
operator|->
name|enclosure_table
index|[
name|enc_idx
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|et_entry
operator|->
name|enclosure_id
operator|==
name|le64toh
argument_list|(
name|enc_id
argument_list|)
operator|)
operator|&&
operator|(
operator|!
name|et_entry
operator|->
name|phy_bits
operator|||
operator|(
name|et_entry
operator|->
name|phy_bits
operator|&
name|le32toh
argument_list|(
name|phy_bits
argument_list|)
operator|)
operator|)
condition|)
return|return
name|enc_idx
return|;
block|}
return|return
name|MPS_ENCTABLE_BAD_IDX
return|;
block|}
end_function

begin_comment
comment|/**  * _mapping_get_enc_idx_from_handle - get enclosure index from handle  * @sc: per adapter object  * @enc_id: enclosure handle  *  * Returns the index of enclosure entry on success or bad index.  */
end_comment

begin_function
specifier|static
name|u8
name|_mapping_get_enc_idx_from_handle
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|u16
name|handle
parameter_list|)
block|{
name|struct
name|enc_mapping_table
modifier|*
name|et_entry
decl_stmt|;
name|u8
name|enc_idx
init|=
literal|0
decl_stmt|;
for|for
control|(
name|enc_idx
operator|=
literal|0
init|;
name|enc_idx
operator|<
name|sc
operator|->
name|num_enc_table_entries
condition|;
name|enc_idx
operator|++
control|)
block|{
name|et_entry
operator|=
operator|&
name|sc
operator|->
name|enclosure_table
index|[
name|enc_idx
index|]
expr_stmt|;
if|if
condition|(
name|et_entry
operator|->
name|missing_count
condition|)
continue|continue;
if|if
condition|(
name|et_entry
operator|->
name|enc_handle
operator|==
name|handle
condition|)
return|return
name|enc_idx
return|;
block|}
return|return
name|MPS_ENCTABLE_BAD_IDX
return|;
block|}
end_function

begin_comment
comment|/**  * _mapping_get_high_missing_et_idx - get missing enclosure index  * @sc: per adapter object  *  * Search through the enclosure table and identifies the enclosure entry  * with high missing count and returns it's index  *  * Returns the index of enclosure entry on success or bad index.  */
end_comment

begin_function
specifier|static
name|u8
name|_mapping_get_high_missing_et_idx
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|enc_mapping_table
modifier|*
name|et_entry
decl_stmt|;
name|u8
name|high_missing_count
init|=
literal|0
decl_stmt|;
name|u8
name|enc_idx
decl_stmt|,
name|high_idx
init|=
name|MPS_ENCTABLE_BAD_IDX
decl_stmt|;
for|for
control|(
name|enc_idx
operator|=
literal|0
init|;
name|enc_idx
operator|<
name|sc
operator|->
name|num_enc_table_entries
condition|;
name|enc_idx
operator|++
control|)
block|{
name|et_entry
operator|=
operator|&
name|sc
operator|->
name|enclosure_table
index|[
name|enc_idx
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|et_entry
operator|->
name|missing_count
operator|>
name|high_missing_count
operator|)
operator|&&
operator|!
name|et_entry
operator|->
name|skip_search
condition|)
block|{
name|high_missing_count
operator|=
name|et_entry
operator|->
name|missing_count
expr_stmt|;
name|high_idx
operator|=
name|enc_idx
expr_stmt|;
block|}
block|}
return|return
name|high_idx
return|;
block|}
end_function

begin_comment
comment|/**  * _mapping_get_high_missing_mt_idx - get missing map table index  * @sc: per adapter object  *  * Search through the map table and identifies the device entry  * with high missing count and returns it's index  *  * Returns the index of map table entry on success or bad index.  */
end_comment

begin_function
specifier|static
name|u32
name|_mapping_get_high_missing_mt_idx
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u32
name|map_idx
decl_stmt|,
name|high_idx
init|=
name|MPS_MAPTABLE_BAD_IDX
decl_stmt|;
name|u8
name|high_missing_count
init|=
literal|0
decl_stmt|;
name|u32
name|start_idx
decl_stmt|,
name|end_idx
decl_stmt|,
name|start_idx_ir
decl_stmt|,
name|end_idx_ir
decl_stmt|;
name|struct
name|dev_mapping_table
modifier|*
name|mt_entry
decl_stmt|;
name|u16
name|ioc_pg8_flags
init|=
name|le16toh
argument_list|(
name|sc
operator|->
name|ioc_pg8
operator|.
name|Flags
argument_list|)
decl_stmt|;
name|start_idx
operator|=
literal|0
expr_stmt|;
name|start_idx_ir
operator|=
literal|0
expr_stmt|;
name|end_idx_ir
operator|=
literal|0
expr_stmt|;
name|end_idx
operator|=
name|sc
operator|->
name|max_devices
expr_stmt|;
if|if
condition|(
name|ioc_pg8_flags
operator|&
name|MPI2_IOCPAGE8_FLAGS_RESERVED_TARGETID_0
condition|)
name|start_idx
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ir_firmware
condition|)
block|{
name|_mapping_get_ir_maprange
argument_list|(
name|sc
argument_list|,
operator|&
name|start_idx_ir
argument_list|,
operator|&
name|end_idx_ir
argument_list|)
expr_stmt|;
if|if
condition|(
name|start_idx
operator|==
name|start_idx_ir
condition|)
name|start_idx
operator|=
name|end_idx_ir
operator|+
literal|1
expr_stmt|;
else|else
name|end_idx
operator|=
name|start_idx_ir
expr_stmt|;
block|}
name|mt_entry
operator|=
operator|&
name|sc
operator|->
name|mapping_table
index|[
name|start_idx
index|]
expr_stmt|;
for|for
control|(
name|map_idx
operator|=
name|start_idx
init|;
name|map_idx
operator|<
name|end_idx
condition|;
name|map_idx
operator|++
operator|,
name|mt_entry
operator|++
control|)
block|{
if|if
condition|(
name|mt_entry
operator|->
name|missing_count
operator|>
name|high_missing_count
condition|)
block|{
name|high_missing_count
operator|=
name|mt_entry
operator|->
name|missing_count
expr_stmt|;
name|high_idx
operator|=
name|map_idx
expr_stmt|;
block|}
block|}
return|return
name|high_idx
return|;
block|}
end_function

begin_comment
comment|/**  * _mapping_get_ir_mt_idx_from_wwid - get map table index from volume WWID  * @sc: per adapter object  * @wwid: world wide unique ID of the volume  *  * Returns the index of map table entry on success or bad index.  */
end_comment

begin_function
specifier|static
name|u32
name|_mapping_get_ir_mt_idx_from_wwid
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|u64
name|wwid
parameter_list|)
block|{
name|u32
name|start_idx
decl_stmt|,
name|end_idx
decl_stmt|,
name|map_idx
decl_stmt|;
name|struct
name|dev_mapping_table
modifier|*
name|mt_entry
decl_stmt|;
name|_mapping_get_ir_maprange
argument_list|(
name|sc
argument_list|,
operator|&
name|start_idx
argument_list|,
operator|&
name|end_idx
argument_list|)
expr_stmt|;
name|mt_entry
operator|=
operator|&
name|sc
operator|->
name|mapping_table
index|[
name|start_idx
index|]
expr_stmt|;
for|for
control|(
name|map_idx
operator|=
name|start_idx
init|;
name|map_idx
operator|<=
name|end_idx
condition|;
name|map_idx
operator|++
operator|,
name|mt_entry
operator|++
control|)
if|if
condition|(
name|mt_entry
operator|->
name|physical_id
operator|==
name|wwid
condition|)
return|return
name|map_idx
return|;
return|return
name|MPS_MAPTABLE_BAD_IDX
return|;
block|}
end_function

begin_comment
comment|/**  * _mapping_get_mt_idx_from_id - get map table index from a device ID  * @sc: per adapter object  * @dev_id: device identifer (SAS Address)  *  * Returns the index of map table entry on success or bad index.  */
end_comment

begin_function
specifier|static
name|u32
name|_mapping_get_mt_idx_from_id
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|u64
name|dev_id
parameter_list|)
block|{
name|u32
name|map_idx
decl_stmt|;
name|struct
name|dev_mapping_table
modifier|*
name|mt_entry
decl_stmt|;
for|for
control|(
name|map_idx
operator|=
literal|0
init|;
name|map_idx
operator|<
name|sc
operator|->
name|max_devices
condition|;
name|map_idx
operator|++
control|)
block|{
name|mt_entry
operator|=
operator|&
name|sc
operator|->
name|mapping_table
index|[
name|map_idx
index|]
expr_stmt|;
if|if
condition|(
name|mt_entry
operator|->
name|physical_id
operator|==
name|dev_id
condition|)
return|return
name|map_idx
return|;
block|}
return|return
name|MPS_MAPTABLE_BAD_IDX
return|;
block|}
end_function

begin_comment
comment|/**  * _mapping_get_ir_mt_idx_from_handle - get map table index from volume handle  * @sc: per adapter object  * @wwid: volume device handle  *  * Returns the index of map table entry on success or bad index.  */
end_comment

begin_function
specifier|static
name|u32
name|_mapping_get_ir_mt_idx_from_handle
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|u16
name|volHandle
parameter_list|)
block|{
name|u32
name|start_idx
decl_stmt|,
name|end_idx
decl_stmt|,
name|map_idx
decl_stmt|;
name|struct
name|dev_mapping_table
modifier|*
name|mt_entry
decl_stmt|;
name|_mapping_get_ir_maprange
argument_list|(
name|sc
argument_list|,
operator|&
name|start_idx
argument_list|,
operator|&
name|end_idx
argument_list|)
expr_stmt|;
name|mt_entry
operator|=
operator|&
name|sc
operator|->
name|mapping_table
index|[
name|start_idx
index|]
expr_stmt|;
for|for
control|(
name|map_idx
operator|=
name|start_idx
init|;
name|map_idx
operator|<=
name|end_idx
condition|;
name|map_idx
operator|++
operator|,
name|mt_entry
operator|++
control|)
if|if
condition|(
name|mt_entry
operator|->
name|dev_handle
operator|==
name|volHandle
condition|)
return|return
name|map_idx
return|;
return|return
name|MPS_MAPTABLE_BAD_IDX
return|;
block|}
end_function

begin_comment
comment|/**  * _mapping_get_mt_idx_from_handle - get map table index from handle  * @sc: per adapter object  * @dev_id: device handle  *  * Returns the index of map table entry on success or bad index.  */
end_comment

begin_function
specifier|static
name|u32
name|_mapping_get_mt_idx_from_handle
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|u16
name|handle
parameter_list|)
block|{
name|u32
name|map_idx
decl_stmt|;
name|struct
name|dev_mapping_table
modifier|*
name|mt_entry
decl_stmt|;
for|for
control|(
name|map_idx
operator|=
literal|0
init|;
name|map_idx
operator|<
name|sc
operator|->
name|max_devices
condition|;
name|map_idx
operator|++
control|)
block|{
name|mt_entry
operator|=
operator|&
name|sc
operator|->
name|mapping_table
index|[
name|map_idx
index|]
expr_stmt|;
if|if
condition|(
name|mt_entry
operator|->
name|dev_handle
operator|==
name|handle
condition|)
return|return
name|map_idx
return|;
block|}
return|return
name|MPS_MAPTABLE_BAD_IDX
return|;
block|}
end_function

begin_comment
comment|/**  * _mapping_get_free_ir_mt_idx - get first free index for a volume  * @sc: per adapter object  *  * Search through mapping table for free index for a volume and if no free  * index then looks for a volume with high mapping index  *  * Returns the index of map table entry on success or bad index.  */
end_comment

begin_function
specifier|static
name|u32
name|_mapping_get_free_ir_mt_idx
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u8
name|high_missing_count
init|=
literal|0
decl_stmt|;
name|u32
name|start_idx
decl_stmt|,
name|end_idx
decl_stmt|,
name|map_idx
decl_stmt|;
name|u32
name|high_idx
init|=
name|MPS_MAPTABLE_BAD_IDX
decl_stmt|;
name|struct
name|dev_mapping_table
modifier|*
name|mt_entry
decl_stmt|;
comment|/* 	 * The IN_USE flag should be clear if the entry is available to use. 	 * This flag is cleared on initialization and and when a volume is 	 * deleted. All other times this flag should be set. If, for some 	 * reason, a free entry cannot be found, look for the entry with the 	 * highest missing count just in case there is one. 	 */
name|_mapping_get_ir_maprange
argument_list|(
name|sc
argument_list|,
operator|&
name|start_idx
argument_list|,
operator|&
name|end_idx
argument_list|)
expr_stmt|;
name|mt_entry
operator|=
operator|&
name|sc
operator|->
name|mapping_table
index|[
name|start_idx
index|]
expr_stmt|;
for|for
control|(
name|map_idx
operator|=
name|start_idx
init|;
name|map_idx
operator|<=
name|end_idx
condition|;
name|map_idx
operator|++
operator|,
name|mt_entry
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|mt_entry
operator|->
name|device_info
operator|&
name|MPS_MAP_IN_USE
operator|)
condition|)
return|return
name|map_idx
return|;
if|if
condition|(
name|mt_entry
operator|->
name|missing_count
operator|>
name|high_missing_count
condition|)
block|{
name|high_missing_count
operator|=
name|mt_entry
operator|->
name|missing_count
expr_stmt|;
name|high_idx
operator|=
name|map_idx
expr_stmt|;
block|}
block|}
if|if
condition|(
name|high_idx
operator|==
name|MPS_MAPTABLE_BAD_IDX
condition|)
block|{
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_ERROR
operator||
name|MPS_MAPPING
argument_list|,
literal|"%s: Could not find a "
literal|"free entry in the mapping table for a Volume. The mapping "
literal|"table is probably corrupt.\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
return|return
name|high_idx
return|;
block|}
end_function

begin_comment
comment|/**  * _mapping_get_free_mt_idx - get first free index for a device  * @sc: per adapter object  * @start_idx: offset in the table to start search  *  * Returns the index of map table entry on success or bad index.  */
end_comment

begin_function
specifier|static
name|u32
name|_mapping_get_free_mt_idx
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|u32
name|start_idx
parameter_list|)
block|{
name|u32
name|map_idx
decl_stmt|,
name|max_idx
init|=
name|sc
operator|->
name|max_devices
decl_stmt|;
name|struct
name|dev_mapping_table
modifier|*
name|mt_entry
init|=
operator|&
name|sc
operator|->
name|mapping_table
index|[
name|start_idx
index|]
decl_stmt|;
name|u16
name|volume_mapping_flags
decl_stmt|;
name|volume_mapping_flags
operator|=
name|le16toh
argument_list|(
name|sc
operator|->
name|ioc_pg8
operator|.
name|IRVolumeMappingFlags
argument_list|)
operator|&
name|MPI2_IOCPAGE8_IRFLAGS_MASK_VOLUME_MAPPING_MODE
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ir_firmware
operator|&&
operator|(
name|volume_mapping_flags
operator|==
name|MPI2_IOCPAGE8_IRFLAGS_HIGH_VOLUME_MAPPING
operator|)
condition|)
name|max_idx
operator|-=
name|sc
operator|->
name|max_volumes
expr_stmt|;
for|for
control|(
name|map_idx
operator|=
name|start_idx
init|;
name|map_idx
operator|<
name|max_idx
condition|;
name|map_idx
operator|++
operator|,
name|mt_entry
operator|++
control|)
if|if
condition|(
operator|!
operator|(
name|mt_entry
operator|->
name|device_info
operator|&
operator|(
name|MPS_MAP_IN_USE
operator||
name|MPS_DEV_RESERVED
operator|)
operator|)
condition|)
return|return
name|map_idx
return|;
return|return
name|MPS_MAPTABLE_BAD_IDX
return|;
block|}
end_function

begin_comment
comment|/**  * _mapping_get_dpm_idx_from_id - get DPM index from ID  * @sc: per adapter object  * @id: volume WWID or enclosure ID or device ID  *  * Returns the index of DPM entry on success or bad index.  */
end_comment

begin_function
specifier|static
name|u16
name|_mapping_get_dpm_idx_from_id
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|u64
name|id
parameter_list|,
name|u32
name|phy_bits
parameter_list|)
block|{
name|u16
name|entry_num
decl_stmt|;
name|uint64_t
name|PhysicalIdentifier
decl_stmt|;
name|Mpi2DriverMap0Entry_t
modifier|*
name|dpm_entry
decl_stmt|;
name|dpm_entry
operator|=
operator|(
name|Mpi2DriverMap0Entry_t
operator|*
operator|)
operator|(
operator|(
name|u8
operator|*
operator|)
name|sc
operator|->
name|dpm_pg0
operator|+
sizeof|sizeof
argument_list|(
name|MPI2_CONFIG_EXTENDED_PAGE_HEADER
argument_list|)
operator|)
expr_stmt|;
name|PhysicalIdentifier
operator|=
name|dpm_entry
operator|->
name|PhysicalIdentifier
operator|.
name|High
expr_stmt|;
name|PhysicalIdentifier
operator|=
operator|(
name|PhysicalIdentifier
operator|<<
literal|32
operator|)
operator||
name|dpm_entry
operator|->
name|PhysicalIdentifier
operator|.
name|Low
expr_stmt|;
for|for
control|(
name|entry_num
operator|=
literal|0
init|;
name|entry_num
operator|<
name|sc
operator|->
name|max_dpm_entries
condition|;
name|entry_num
operator|++
operator|,
name|dpm_entry
operator|++
control|)
if|if
condition|(
operator|(
name|id
operator|==
name|PhysicalIdentifier
operator|)
operator|&&
operator|(
operator|!
name|phy_bits
operator|||
operator|!
name|dpm_entry
operator|->
name|PhysicalBitsMapping
operator|||
operator|(
name|phy_bits
operator|&
name|dpm_entry
operator|->
name|PhysicalBitsMapping
operator|)
operator|)
condition|)
return|return
name|entry_num
return|;
return|return
name|MPS_DPM_BAD_IDX
return|;
block|}
end_function

begin_comment
comment|/**  * _mapping_get_free_dpm_idx - get first available DPM index  * @sc: per adapter object  *  * Returns the index of DPM entry on success or bad index.  */
end_comment

begin_function
specifier|static
name|u32
name|_mapping_get_free_dpm_idx
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u16
name|entry_num
decl_stmt|;
name|Mpi2DriverMap0Entry_t
modifier|*
name|dpm_entry
decl_stmt|;
name|u16
name|current_entry
init|=
name|MPS_DPM_BAD_IDX
decl_stmt|,
name|missing_cnt
decl_stmt|,
name|high_missing_cnt
init|=
literal|0
decl_stmt|;
name|u64
name|physical_id
decl_stmt|;
name|struct
name|dev_mapping_table
modifier|*
name|mt_entry
decl_stmt|;
name|u32
name|map_idx
decl_stmt|;
for|for
control|(
name|entry_num
operator|=
literal|0
init|;
name|entry_num
operator|<
name|sc
operator|->
name|max_dpm_entries
condition|;
name|entry_num
operator|++
control|)
block|{
name|dpm_entry
operator|=
operator|(
name|Mpi2DriverMap0Entry_t
operator|*
operator|)
operator|(
operator|(
name|u8
operator|*
operator|)
name|sc
operator|->
name|dpm_pg0
operator|+
sizeof|sizeof
argument_list|(
name|MPI2_CONFIG_EXTENDED_PAGE_HEADER
argument_list|)
operator|)
expr_stmt|;
name|dpm_entry
operator|+=
name|entry_num
expr_stmt|;
name|missing_cnt
operator|=
name|dpm_entry
operator|->
name|MappingInformation
operator|&
name|MPI2_DRVMAP0_MAPINFO_MISSING_MASK
expr_stmt|;
comment|/* 		 * If entry is used and not missing, then this entry can't be 		 * used. Look at next one. 		 */
if|if
condition|(
name|sc
operator|->
name|dpm_entry_used
index|[
name|entry_num
index|]
operator|&&
operator|!
name|missing_cnt
condition|)
continue|continue;
comment|/* 		 * If this entry is not used at all, then the missing count 		 * doesn't matter. Just use this one. Otherwise, keep looking 		 * and make sure the entry with the highest missing count is 		 * used. 		 */
if|if
condition|(
operator|!
name|sc
operator|->
name|dpm_entry_used
index|[
name|entry_num
index|]
condition|)
block|{
name|current_entry
operator|=
name|entry_num
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|current_entry
operator|==
name|MPS_DPM_BAD_IDX
operator|)
operator|||
operator|(
name|missing_cnt
operator|>
name|high_missing_cnt
operator|)
condition|)
block|{
name|current_entry
operator|=
name|entry_num
expr_stmt|;
name|high_missing_cnt
operator|=
name|missing_cnt
expr_stmt|;
block|}
block|}
comment|/* 	 * If an entry has been found to use and it's already marked as used 	 * it means that some device was already using this entry but it's 	 * missing, and that means that the connection between the missing 	 * device's DPM entry and the mapping table needs to be cleared. To do 	 * this, use the Physical ID of the old device still in the DPM entry 	 * to find its mapping table entry, then mark its DPM entry as BAD. 	 */
if|if
condition|(
operator|(
name|current_entry
operator|!=
name|MPS_DPM_BAD_IDX
operator|)
operator|&&
name|sc
operator|->
name|dpm_entry_used
index|[
name|current_entry
index|]
condition|)
block|{
name|dpm_entry
operator|=
operator|(
name|Mpi2DriverMap0Entry_t
operator|*
operator|)
operator|(
operator|(
name|u8
operator|*
operator|)
name|sc
operator|->
name|dpm_pg0
operator|+
sizeof|sizeof
argument_list|(
name|MPI2_CONFIG_EXTENDED_PAGE_HEADER
argument_list|)
operator|)
expr_stmt|;
name|dpm_entry
operator|+=
name|current_entry
expr_stmt|;
name|physical_id
operator|=
name|dpm_entry
operator|->
name|PhysicalIdentifier
operator|.
name|High
expr_stmt|;
name|physical_id
operator|=
operator|(
name|physical_id
operator|<<
literal|32
operator|)
operator||
name|dpm_entry
operator|->
name|PhysicalIdentifier
operator|.
name|Low
expr_stmt|;
name|map_idx
operator|=
name|_mapping_get_mt_idx_from_id
argument_list|(
name|sc
argument_list|,
name|physical_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|map_idx
operator|!=
name|MPS_MAPTABLE_BAD_IDX
condition|)
block|{
name|mt_entry
operator|=
operator|&
name|sc
operator|->
name|mapping_table
index|[
name|map_idx
index|]
expr_stmt|;
name|mt_entry
operator|->
name|dpm_entry_num
operator|=
name|MPS_DPM_BAD_IDX
expr_stmt|;
block|}
block|}
return|return
name|current_entry
return|;
block|}
end_function

begin_comment
comment|/**  * _mapping_update_ir_missing_cnt - Updates missing count for a volume  * @sc: per adapter object  * @map_idx: map table index of the volume  * @element: IR configuration change element  * @wwid: IR volume ID.  *  * Updates the missing count in the map table and in the DPM entry for a volume  *  * Returns nothing.  */
end_comment

begin_function
specifier|static
name|void
name|_mapping_update_ir_missing_cnt
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|u32
name|map_idx
parameter_list|,
name|Mpi2EventIrConfigElement_t
modifier|*
name|element
parameter_list|,
name|u64
name|wwid
parameter_list|)
block|{
name|struct
name|dev_mapping_table
modifier|*
name|mt_entry
decl_stmt|;
name|u8
name|missing_cnt
decl_stmt|,
name|reason
init|=
name|element
operator|->
name|ReasonCode
decl_stmt|,
name|update_dpm
init|=
literal|1
decl_stmt|;
name|u16
name|dpm_idx
decl_stmt|;
name|Mpi2DriverMap0Entry_t
modifier|*
name|dpm_entry
decl_stmt|;
comment|/* 	 * Depending on the reason code, update the missing count. Always set 	 * the init_complete flag when here, so just do it first. That flag is 	 * used for volumes to make sure that the DPM entry has been updated. 	 * When a volume is deleted, clear the map entry's IN_USE flag so that 	 * the entry can be used again if another volume is created. Also clear 	 * its dev_handle entry so that other functions can't find this volume 	 * by the handle, since it's not defined any longer. 	 */
name|mt_entry
operator|=
operator|&
name|sc
operator|->
name|mapping_table
index|[
name|map_idx
index|]
expr_stmt|;
name|mt_entry
operator|->
name|init_complete
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|reason
operator|==
name|MPI2_EVENT_IR_CHANGE_RC_ADDED
operator|)
operator|||
operator|(
name|reason
operator|==
name|MPI2_EVENT_IR_CHANGE_RC_VOLUME_CREATED
operator|)
condition|)
block|{
name|mt_entry
operator|->
name|missing_count
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|reason
operator|==
name|MPI2_EVENT_IR_CHANGE_RC_VOLUME_DELETED
condition|)
block|{
if|if
condition|(
name|mt_entry
operator|->
name|missing_count
operator|<
name|MPS_MAX_MISSING_COUNT
condition|)
name|mt_entry
operator|->
name|missing_count
operator|++
expr_stmt|;
name|mt_entry
operator|->
name|device_info
operator|&=
operator|~
name|MPS_MAP_IN_USE
expr_stmt|;
name|mt_entry
operator|->
name|dev_handle
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * If persistent mapping is enabled, update the DPM with the new missing 	 * count for the volume. If the DPM index is bad, get a free one. If 	 * it's bad for a volume that's being deleted do nothing because that 	 * volume doesn't have a DPM entry.  	 */
if|if
condition|(
operator|!
name|sc
operator|->
name|is_dpm_enable
condition|)
return|return;
name|dpm_idx
operator|=
name|mt_entry
operator|->
name|dpm_entry_num
expr_stmt|;
if|if
condition|(
name|dpm_idx
operator|==
name|MPS_DPM_BAD_IDX
condition|)
block|{
if|if
condition|(
name|reason
operator|==
name|MPI2_EVENT_IR_CHANGE_RC_VOLUME_DELETED
condition|)
block|{
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_MAPPING
argument_list|,
literal|"%s: Volume being deleted "
literal|"is not in DPM so DPM missing count will not be "
literal|"updated.\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|dpm_idx
operator|==
name|MPS_DPM_BAD_IDX
condition|)
name|dpm_idx
operator|=
name|_mapping_get_free_dpm_idx
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Got the DPM entry for the volume or found a free DPM entry if this is 	 * a new volume. Check if the current information is outdated. 	 */
if|if
condition|(
name|dpm_idx
operator|!=
name|MPS_DPM_BAD_IDX
condition|)
block|{
name|dpm_entry
operator|=
operator|(
name|Mpi2DriverMap0Entry_t
operator|*
operator|)
operator|(
operator|(
name|u8
operator|*
operator|)
name|sc
operator|->
name|dpm_pg0
operator|+
sizeof|sizeof
argument_list|(
name|MPI2_CONFIG_EXTENDED_PAGE_HEADER
argument_list|)
operator|)
expr_stmt|;
name|dpm_entry
operator|+=
name|dpm_idx
expr_stmt|;
name|missing_cnt
operator|=
name|dpm_entry
operator|->
name|MappingInformation
operator|&
name|MPI2_DRVMAP0_MAPINFO_MISSING_MASK
expr_stmt|;
if|if
condition|(
operator|(
name|mt_entry
operator|->
name|physical_id
operator|==
name|le64toh
argument_list|(
operator|(
operator|(
name|u64
operator|)
name|dpm_entry
operator|->
name|PhysicalIdentifier
operator|.
name|High
operator|<<
literal|32
operator|)
operator||
operator|(
name|u64
operator|)
name|dpm_entry
operator|->
name|PhysicalIdentifier
operator|.
name|Low
argument_list|)
operator|)
operator|&&
operator|(
name|missing_cnt
operator|==
name|mt_entry
operator|->
name|missing_count
operator|)
condition|)
block|{
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_MAPPING
argument_list|,
literal|"%s: DPM entry for volume "
literal|"with target ID %d does not require an update.\n"
argument_list|,
name|__func__
argument_list|,
name|mt_entry
operator|->
name|id
argument_list|)
expr_stmt|;
name|update_dpm
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* 	 * Update the volume's persistent info if it's new or the ID or missing 	 * count has changed. If a good DPM index has not been found by now, 	 * there is no space left in the DPM table. 	 */
if|if
condition|(
operator|(
name|dpm_idx
operator|!=
name|MPS_DPM_BAD_IDX
operator|)
operator|&&
name|update_dpm
condition|)
block|{
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_MAPPING
argument_list|,
literal|"%s: Update DPM entry for volume "
literal|"with target ID %d.\n"
argument_list|,
name|__func__
argument_list|,
name|mt_entry
operator|->
name|id
argument_list|)
expr_stmt|;
name|mt_entry
operator|->
name|dpm_entry_num
operator|=
name|dpm_idx
expr_stmt|;
name|dpm_entry
operator|=
operator|(
name|Mpi2DriverMap0Entry_t
operator|*
operator|)
operator|(
operator|(
name|u8
operator|*
operator|)
name|sc
operator|->
name|dpm_pg0
operator|+
sizeof|sizeof
argument_list|(
name|MPI2_CONFIG_EXTENDED_PAGE_HEADER
argument_list|)
operator|)
expr_stmt|;
name|dpm_entry
operator|+=
name|dpm_idx
expr_stmt|;
name|dpm_entry
operator|->
name|PhysicalIdentifier
operator|.
name|Low
operator|=
operator|(
literal|0xFFFFFFFF
operator|&
name|mt_entry
operator|->
name|physical_id
operator|)
expr_stmt|;
name|dpm_entry
operator|->
name|PhysicalIdentifier
operator|.
name|High
operator|=
operator|(
name|mt_entry
operator|->
name|physical_id
operator|>>
literal|32
operator|)
expr_stmt|;
name|dpm_entry
operator|->
name|DeviceIndex
operator|=
name|map_idx
expr_stmt|;
name|dpm_entry
operator|->
name|MappingInformation
operator|=
name|mt_entry
operator|->
name|missing_count
expr_stmt|;
name|dpm_entry
operator|->
name|PhysicalBitsMapping
operator|=
literal|0
expr_stmt|;
name|dpm_entry
operator|->
name|Reserved1
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|dpm_flush_entry
index|[
name|dpm_idx
index|]
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|dpm_entry_used
index|[
name|dpm_idx
index|]
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dpm_idx
operator|==
name|MPS_DPM_BAD_IDX
condition|)
block|{
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_INFO
operator||
name|MPS_MAPPING
argument_list|,
literal|"%s: No space to add an "
literal|"entry in the DPM table for volume with target ID %d.\n"
argument_list|,
name|__func__
argument_list|,
name|mt_entry
operator|->
name|id
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * _mapping_add_to_removal_table - add DPM index to the removal table  * @sc: per adapter object  * @dpm_idx: Index of DPM entry to remove  *  * Adds a DPM entry number to the removal table.  *  * Returns nothing.  */
end_comment

begin_function
specifier|static
name|void
name|_mapping_add_to_removal_table
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|u16
name|dpm_idx
parameter_list|)
block|{
name|struct
name|map_removal_table
modifier|*
name|remove_entry
decl_stmt|;
name|u32
name|i
decl_stmt|;
comment|/* 	 * This is only used to remove entries from the DPM in the controller. 	 * If DPM is not enabled, just return. 	 */
if|if
condition|(
operator|!
name|sc
operator|->
name|is_dpm_enable
condition|)
return|return;
comment|/* 	 * Find the first available removal_table entry and add the new entry 	 * there. 	 */
name|remove_entry
operator|=
name|sc
operator|->
name|removal_table
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|max_devices
condition|;
name|i
operator|++
operator|,
name|remove_entry
operator|++
control|)
block|{
if|if
condition|(
name|remove_entry
operator|->
name|dpm_entry_num
operator|!=
name|MPS_DPM_BAD_IDX
condition|)
continue|continue;
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_MAPPING
argument_list|,
literal|"%s: Adding DPM entry %d to table "
literal|"for removal.\n"
argument_list|,
name|__func__
argument_list|,
name|dpm_idx
argument_list|)
expr_stmt|;
name|remove_entry
operator|->
name|dpm_entry_num
operator|=
name|dpm_idx
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/**  * _mapping_update_missing_count - Update missing count for a device  * @sc: per adapter object  * @topo_change: Topology change event entry  *  * Increment the missing count in the mapping table for a device that is not  * responding. If Persitent Mapping is used, increment the DPM entry as well.  * Currently, this function only increments the missing count if the device   * goes missing, so after initialization has completed. This means that the  * missing count can only go from 0 to 1 here. The missing count is incremented  * during initialization as well, so that's where a target's missing count can  * go past 1.  *  * Returns nothing.  */
end_comment

begin_function
specifier|static
name|void
name|_mapping_update_missing_count
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|_map_topology_change
modifier|*
name|topo_change
parameter_list|)
block|{
name|u16
name|ioc_pg8_flags
init|=
name|le16toh
argument_list|(
name|sc
operator|->
name|ioc_pg8
operator|.
name|Flags
argument_list|)
decl_stmt|;
name|u8
name|entry
decl_stmt|;
name|struct
name|_map_phy_change
modifier|*
name|phy_change
decl_stmt|;
name|u32
name|map_idx
decl_stmt|;
name|struct
name|dev_mapping_table
modifier|*
name|mt_entry
decl_stmt|;
name|Mpi2DriverMap0Entry_t
modifier|*
name|dpm_entry
decl_stmt|;
for|for
control|(
name|entry
operator|=
literal|0
init|;
name|entry
operator|<
name|topo_change
operator|->
name|num_entries
condition|;
name|entry
operator|++
control|)
block|{
name|phy_change
operator|=
operator|&
name|topo_change
operator|->
name|phy_details
index|[
name|entry
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|phy_change
operator|->
name|dev_handle
operator|||
operator|(
name|phy_change
operator|->
name|reason
operator|!=
name|MPI2_EVENT_SAS_TOPO_RC_TARG_NOT_RESPONDING
operator|)
condition|)
continue|continue;
name|map_idx
operator|=
name|_mapping_get_mt_idx_from_handle
argument_list|(
name|sc
argument_list|,
name|phy_change
operator|->
name|dev_handle
argument_list|)
expr_stmt|;
name|phy_change
operator|->
name|is_processed
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|map_idx
operator|==
name|MPS_MAPTABLE_BAD_IDX
condition|)
block|{
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_INFO
operator||
name|MPS_MAPPING
argument_list|,
literal|"%s: device is "
literal|"already removed from mapping table\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|mt_entry
operator|=
operator|&
name|sc
operator|->
name|mapping_table
index|[
name|map_idx
index|]
expr_stmt|;
if|if
condition|(
name|mt_entry
operator|->
name|missing_count
operator|<
name|MPS_MAX_MISSING_COUNT
condition|)
name|mt_entry
operator|->
name|missing_count
operator|++
expr_stmt|;
comment|/* 		 * When using Enc/Slot mapping, when a device is removed, it's 		 * mapping table information should be cleared. Otherwise, the 		 * target ID will be incorrect if this same device is re-added 		 * to a different slot. 		 */
if|if
condition|(
operator|(
name|ioc_pg8_flags
operator|&
name|MPI2_IOCPAGE8_FLAGS_MASK_MAPPING_MODE
operator|)
operator|==
name|MPI2_IOCPAGE8_FLAGS_ENCLOSURE_SLOT_MAPPING
condition|)
block|{
name|_mapping_clear_map_entry
argument_list|(
name|mt_entry
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * When using device mapping, update the missing count in the 		 * DPM entry, but only if the missing count has changed. 		 */
if|if
condition|(
operator|(
operator|(
name|ioc_pg8_flags
operator|&
name|MPI2_IOCPAGE8_FLAGS_MASK_MAPPING_MODE
operator|)
operator|==
name|MPI2_IOCPAGE8_FLAGS_DEVICE_PERSISTENCE_MAPPING
operator|)
operator|&&
name|sc
operator|->
name|is_dpm_enable
operator|&&
name|mt_entry
operator|->
name|dpm_entry_num
operator|!=
name|MPS_DPM_BAD_IDX
condition|)
block|{
name|dpm_entry
operator|=
operator|(
name|Mpi2DriverMap0Entry_t
operator|*
operator|)
operator|(
operator|(
name|u8
operator|*
operator|)
name|sc
operator|->
name|dpm_pg0
operator|+
sizeof|sizeof
argument_list|(
name|MPI2_CONFIG_EXTENDED_PAGE_HEADER
argument_list|)
operator|)
expr_stmt|;
name|dpm_entry
operator|+=
name|mt_entry
operator|->
name|dpm_entry_num
expr_stmt|;
if|if
condition|(
name|dpm_entry
operator|->
name|MappingInformation
operator|!=
name|mt_entry
operator|->
name|missing_count
condition|)
block|{
name|dpm_entry
operator|->
name|MappingInformation
operator|=
name|mt_entry
operator|->
name|missing_count
expr_stmt|;
name|sc
operator|->
name|dpm_flush_entry
index|[
name|mt_entry
operator|->
name|dpm_entry_num
index|]
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/**  * _mapping_find_enc_map_space -find map table entries for enclosure  * @sc: per adapter object  * @et_entry: enclosure entry  *  * Search through the mapping table defragment it and provide contiguous  * space in map table for a particular enclosure entry  *  * Returns start index in map table or bad index.  */
end_comment

begin_function
specifier|static
name|u32
name|_mapping_find_enc_map_space
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|enc_mapping_table
modifier|*
name|et_entry
parameter_list|)
block|{
name|u16
name|vol_mapping_flags
decl_stmt|;
name|u32
name|skip_count
decl_stmt|,
name|end_of_table
decl_stmt|,
name|map_idx
decl_stmt|,
name|enc_idx
decl_stmt|;
name|u16
name|num_found
decl_stmt|;
name|u32
name|start_idx
init|=
name|MPS_MAPTABLE_BAD_IDX
decl_stmt|;
name|struct
name|dev_mapping_table
modifier|*
name|mt_entry
decl_stmt|;
name|struct
name|enc_mapping_table
modifier|*
name|enc_entry
decl_stmt|;
name|unsigned
name|char
name|done_flag
init|=
literal|0
decl_stmt|,
name|found_space
decl_stmt|;
name|u16
name|max_num_phy_ids
init|=
name|le16toh
argument_list|(
name|sc
operator|->
name|ioc_pg8
operator|.
name|MaxNumPhysicalMappedIDs
argument_list|)
decl_stmt|;
name|skip_count
operator|=
name|sc
operator|->
name|num_rsvd_entries
expr_stmt|;
name|num_found
operator|=
literal|0
expr_stmt|;
name|vol_mapping_flags
operator|=
name|le16toh
argument_list|(
name|sc
operator|->
name|ioc_pg8
operator|.
name|IRVolumeMappingFlags
argument_list|)
operator|&
name|MPI2_IOCPAGE8_IRFLAGS_MASK_VOLUME_MAPPING_MODE
expr_stmt|;
comment|/* 	 * The end of the mapping table depends on where volumes are kept, if 	 * IR is enabled. 	 */
if|if
condition|(
operator|!
name|sc
operator|->
name|ir_firmware
condition|)
name|end_of_table
operator|=
name|sc
operator|->
name|max_devices
expr_stmt|;
elseif|else
if|if
condition|(
name|vol_mapping_flags
operator|==
name|MPI2_IOCPAGE8_IRFLAGS_LOW_VOLUME_MAPPING
condition|)
name|end_of_table
operator|=
name|sc
operator|->
name|max_devices
expr_stmt|;
else|else
name|end_of_table
operator|=
name|sc
operator|->
name|max_devices
operator|-
name|sc
operator|->
name|max_volumes
expr_stmt|;
comment|/* 	 * The skip_count is the number of entries that are reserved at the 	 * beginning of the mapping table. But, it does not include the number 	 * of Physical IDs that are reserved for direct attached devices. Look 	 * through the mapping table after these reserved entries to see if  	 * the devices for this enclosure are already mapped. The PHY bit check 	 * is used to make sure that at least one PHY bit is common between the 	 * enclosure and the device that is already mapped. 	 */
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_MAPPING
argument_list|,
literal|"%s: Looking for space in the mapping "
literal|"table for added enclosure.\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
for|for
control|(
name|map_idx
operator|=
operator|(
name|max_num_phy_ids
operator|+
name|skip_count
operator|)
init|;
name|map_idx
operator|<
name|end_of_table
condition|;
name|map_idx
operator|++
control|)
block|{
name|mt_entry
operator|=
operator|&
name|sc
operator|->
name|mapping_table
index|[
name|map_idx
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|et_entry
operator|->
name|enclosure_id
operator|==
name|mt_entry
operator|->
name|physical_id
operator|)
operator|&&
operator|(
operator|!
name|mt_entry
operator|->
name|phy_bits
operator|||
operator|(
name|mt_entry
operator|->
name|phy_bits
operator|&
name|et_entry
operator|->
name|phy_bits
operator|)
operator|)
condition|)
block|{
name|num_found
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|num_found
operator|==
name|et_entry
operator|->
name|num_slots
condition|)
block|{
name|start_idx
operator|=
operator|(
name|map_idx
operator|-
name|num_found
operator|)
operator|+
literal|1
expr_stmt|;
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_MAPPING
argument_list|,
literal|"%s: Found space "
literal|"in the mapping for enclosure at map index "
literal|"%d.\n"
argument_list|,
name|__func__
argument_list|,
name|start_idx
argument_list|)
expr_stmt|;
return|return
name|start_idx
return|;
block|}
block|}
else|else
name|num_found
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * If the enclosure's devices are not mapped already, look for 	 * contiguous entries in the mapping table that are not reserved. If 	 * enough entries are found, return the starting index for that space. 	 */
name|num_found
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|map_idx
operator|=
operator|(
name|max_num_phy_ids
operator|+
name|skip_count
operator|)
init|;
name|map_idx
operator|<
name|end_of_table
condition|;
name|map_idx
operator|++
control|)
block|{
name|mt_entry
operator|=
operator|&
name|sc
operator|->
name|mapping_table
index|[
name|map_idx
index|]
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|mt_entry
operator|->
name|device_info
operator|&
name|MPS_DEV_RESERVED
operator|)
condition|)
block|{
name|num_found
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|num_found
operator|==
name|et_entry
operator|->
name|num_slots
condition|)
block|{
name|start_idx
operator|=
operator|(
name|map_idx
operator|-
name|num_found
operator|)
operator|+
literal|1
expr_stmt|;
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_MAPPING
argument_list|,
literal|"%s: Found space "
literal|"in the mapping for enclosure at map index "
literal|"%d.\n"
argument_list|,
name|__func__
argument_list|,
name|start_idx
argument_list|)
expr_stmt|;
return|return
name|start_idx
return|;
block|}
block|}
else|else
name|num_found
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * If here, it means that not enough space in the mapping table was 	 * found to support this enclosure, so go through the enclosure table to 	 * see if any enclosure entries have a missing count. If so, get the 	 * enclosure with the highest missing count and check it to see if there 	 * is enough space for the new enclosure. 	 */
while|while
condition|(
operator|!
name|done_flag
condition|)
block|{
name|enc_idx
operator|=
name|_mapping_get_high_missing_et_idx
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|enc_idx
operator|==
name|MPS_ENCTABLE_BAD_IDX
condition|)
block|{
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_MAPPING
argument_list|,
literal|"%s: Not enough space was "
literal|"found in the mapping for the added enclosure.\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|MPS_MAPTABLE_BAD_IDX
return|;
block|}
comment|/* 		 * Found a missing enclosure. Set the skip_search flag so this 		 * enclosure is not checked again for a high missing count if 		 * the loop continues. This way, all missing enclosures can 		 * have their space added together to find enough space in the 		 * mapping table for the added enclosure. The space must be 		 * contiguous. 		 */
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_MAPPING
argument_list|,
literal|"%s: Space from a missing "
literal|"enclosure was found.\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|enc_entry
operator|=
operator|&
name|sc
operator|->
name|enclosure_table
index|[
name|enc_idx
index|]
expr_stmt|;
name|enc_entry
operator|->
name|skip_search
operator|=
literal|1
expr_stmt|;
comment|/* 		 * Unmark all of the missing enclosure's device's reserved 		 * space. These will be remarked as reserved if this missing 		 * enclosure's space is not used. 		 */
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_MAPPING
argument_list|,
literal|"%s: Clear the reserved flag for "
literal|"all of the map entries for the enclosure.\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|mt_entry
operator|=
operator|&
name|sc
operator|->
name|mapping_table
index|[
name|enc_entry
operator|->
name|start_index
index|]
expr_stmt|;
for|for
control|(
name|map_idx
operator|=
name|enc_entry
operator|->
name|start_index
init|;
name|map_idx
operator|<
operator|(
name|enc_entry
operator|->
name|start_index
operator|+
name|enc_entry
operator|->
name|num_slots
operator|)
condition|;
name|map_idx
operator|++
operator|,
name|mt_entry
operator|++
control|)
name|mt_entry
operator|->
name|device_info
operator|&=
operator|~
name|MPS_DEV_RESERVED
expr_stmt|;
comment|/* 		 * Now that space has been unreserved, check again to see if 		 * enough space is available for the new enclosure. 		 */
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_MAPPING
argument_list|,
literal|"%s: Check if new mapping space is "
literal|"enough for the new enclosure.\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|found_space
operator|=
literal|0
expr_stmt|;
name|num_found
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|map_idx
operator|=
operator|(
name|max_num_phy_ids
operator|+
name|skip_count
operator|)
init|;
name|map_idx
operator|<
name|end_of_table
condition|;
name|map_idx
operator|++
control|)
block|{
name|mt_entry
operator|=
operator|&
name|sc
operator|->
name|mapping_table
index|[
name|map_idx
index|]
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|mt_entry
operator|->
name|device_info
operator|&
name|MPS_DEV_RESERVED
operator|)
condition|)
block|{
name|num_found
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|num_found
operator|==
name|et_entry
operator|->
name|num_slots
condition|)
block|{
name|start_idx
operator|=
operator|(
name|map_idx
operator|-
name|num_found
operator|)
operator|+
literal|1
expr_stmt|;
name|found_space
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
else|else
name|num_found
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|found_space
condition|)
continue|continue;
comment|/* 		 * If enough space was found, all of the missing enclosures that 		 * will be used for the new enclosure must be added to the 		 * removal table. Then all mappings for the enclosure's devices 		 * and for the enclosure itself need to be cleared. There may be 		 * more than one enclosure to add to the removal table and 		 * clear. 		 */
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_MAPPING
argument_list|,
literal|"%s: Found space in the mapping "
literal|"for enclosure at map index %d.\n"
argument_list|,
name|__func__
argument_list|,
name|start_idx
argument_list|)
expr_stmt|;
for|for
control|(
name|map_idx
operator|=
name|start_idx
init|;
name|map_idx
operator|<
operator|(
name|start_idx
operator|+
name|num_found
operator|)
condition|;
name|map_idx
operator|++
control|)
block|{
name|enc_entry
operator|=
name|sc
operator|->
name|enclosure_table
expr_stmt|;
for|for
control|(
name|enc_idx
operator|=
literal|0
init|;
name|enc_idx
operator|<
name|sc
operator|->
name|num_enc_table_entries
condition|;
name|enc_idx
operator|++
operator|,
name|enc_entry
operator|++
control|)
block|{
if|if
condition|(
name|map_idx
operator|<
name|enc_entry
operator|->
name|start_index
operator|||
name|map_idx
operator|>
operator|(
name|enc_entry
operator|->
name|start_index
operator|+
name|enc_entry
operator|->
name|num_slots
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|enc_entry
operator|->
name|removal_flag
condition|)
block|{
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_MAPPING
argument_list|,
literal|"%s: "
literal|"Enclosure %d will be removed from "
literal|"the mapping table.\n"
argument_list|,
name|__func__
argument_list|,
name|enc_idx
argument_list|)
expr_stmt|;
name|enc_entry
operator|->
name|removal_flag
operator|=
literal|1
expr_stmt|;
name|_mapping_add_to_removal_table
argument_list|(
name|sc
argument_list|,
name|enc_entry
operator|->
name|dpm_entry_num
argument_list|)
expr_stmt|;
block|}
name|mt_entry
operator|=
operator|&
name|sc
operator|->
name|mapping_table
index|[
name|map_idx
index|]
expr_stmt|;
name|_mapping_clear_map_entry
argument_list|(
name|mt_entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|map_idx
operator|==
operator|(
name|enc_entry
operator|->
name|start_index
operator|+
name|enc_entry
operator|->
name|num_slots
operator|-
literal|1
operator|)
condition|)
name|_mapping_clear_enc_entry
argument_list|(
name|et_entry
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 		 * During the search for space for this enclosure, some entries 		 * in the mapping table may have been unreserved. Go back and 		 * change all of these to reserved again. Only the enclosures 		 * with the removal_flag set should be left as unreserved. The 		 * skip_search flag needs to be cleared as well so that the 		 * enclosure's space will be looked at the next time space is 		 * needed. 		 */
name|enc_entry
operator|=
name|sc
operator|->
name|enclosure_table
expr_stmt|;
for|for
control|(
name|enc_idx
operator|=
literal|0
init|;
name|enc_idx
operator|<
name|sc
operator|->
name|num_enc_table_entries
condition|;
name|enc_idx
operator|++
operator|,
name|enc_entry
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|enc_entry
operator|->
name|removal_flag
condition|)
block|{
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_MAPPING
argument_list|,
literal|"%s: Reset the "
literal|"reserved flag for all of the map entries "
literal|"for enclosure %d.\n"
argument_list|,
name|__func__
argument_list|,
name|enc_idx
argument_list|)
expr_stmt|;
name|mt_entry
operator|=
operator|&
name|sc
operator|->
name|mapping_table
index|[
name|enc_entry
operator|->
name|start_index
index|]
expr_stmt|;
for|for
control|(
name|map_idx
operator|=
name|enc_entry
operator|->
name|start_index
init|;
name|map_idx
operator|<
operator|(
name|enc_entry
operator|->
name|start_index
operator|+
name|enc_entry
operator|->
name|num_slots
operator|)
condition|;
name|map_idx
operator|++
operator|,
name|mt_entry
operator|++
control|)
name|mt_entry
operator|->
name|device_info
operator||=
name|MPS_DEV_RESERVED
expr_stmt|;
name|et_entry
operator|->
name|skip_search
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|done_flag
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|start_idx
return|;
block|}
end_function

begin_comment
comment|/**  * _mapping_get_dev_info -get information about newly added devices  * @sc: per adapter object  * @topo_change: Topology change event entry  *  * Search through the topology change event list and issues sas device pg0  * requests for the newly added device and reserved entries in tables  *  * Returns nothing  */
end_comment

begin_function
specifier|static
name|void
name|_mapping_get_dev_info
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|_map_topology_change
modifier|*
name|topo_change
parameter_list|)
block|{
name|u16
name|ioc_pg8_flags
init|=
name|le16toh
argument_list|(
name|sc
operator|->
name|ioc_pg8
operator|.
name|Flags
argument_list|)
decl_stmt|;
name|Mpi2ConfigReply_t
name|mpi_reply
decl_stmt|;
name|Mpi2SasDevicePage0_t
name|sas_device_pg0
decl_stmt|;
name|u8
name|entry
decl_stmt|,
name|enc_idx
decl_stmt|,
name|phy_idx
decl_stmt|;
name|u32
name|map_idx
decl_stmt|,
name|index
decl_stmt|,
name|device_info
decl_stmt|;
name|struct
name|_map_phy_change
modifier|*
name|phy_change
decl_stmt|,
modifier|*
name|tmp_phy_change
decl_stmt|;
name|uint64_t
name|sas_address
decl_stmt|;
name|struct
name|enc_mapping_table
modifier|*
name|et_entry
decl_stmt|;
name|struct
name|dev_mapping_table
modifier|*
name|mt_entry
decl_stmt|;
name|u8
name|add_code
init|=
name|MPI2_EVENT_SAS_TOPO_RC_TARG_ADDED
decl_stmt|;
name|int
name|rc
init|=
literal|1
decl_stmt|;
for|for
control|(
name|entry
operator|=
literal|0
init|;
name|entry
operator|<
name|topo_change
operator|->
name|num_entries
condition|;
name|entry
operator|++
control|)
block|{
name|phy_change
operator|=
operator|&
name|topo_change
operator|->
name|phy_details
index|[
name|entry
index|]
expr_stmt|;
if|if
condition|(
name|phy_change
operator|->
name|is_processed
operator|||
operator|!
name|phy_change
operator|->
name|dev_handle
operator|||
name|phy_change
operator|->
name|reason
operator|!=
name|MPI2_EVENT_SAS_TOPO_RC_TARG_ADDED
condition|)
continue|continue;
if|if
condition|(
name|mps_config_get_sas_device_pg0
argument_list|(
name|sc
argument_list|,
operator|&
name|mpi_reply
argument_list|,
operator|&
name|sas_device_pg0
argument_list|,
name|MPI2_SAS_DEVICE_PGAD_FORM_HANDLE
argument_list|,
name|phy_change
operator|->
name|dev_handle
argument_list|)
condition|)
block|{
name|phy_change
operator|->
name|is_processed
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Always get SATA Identify information because this is used 		 * to determine if Start/Stop Unit should be sent to the drive 		 * when the system is shutdown. 		 */
name|device_info
operator|=
name|le32toh
argument_list|(
name|sas_device_pg0
operator|.
name|DeviceInfo
argument_list|)
expr_stmt|;
name|sas_address
operator|=
name|le32toh
argument_list|(
name|sas_device_pg0
operator|.
name|SASAddress
operator|.
name|High
argument_list|)
expr_stmt|;
name|sas_address
operator|=
operator|(
name|sas_address
operator|<<
literal|32
operator|)
operator||
name|le32toh
argument_list|(
name|sas_device_pg0
operator|.
name|SASAddress
operator|.
name|Low
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|device_info
operator|&
name|MPI2_SAS_DEVICE_INFO_END_DEVICE
operator|)
operator|&&
operator|(
name|device_info
operator|&
name|MPI2_SAS_DEVICE_INFO_SATA_DEVICE
operator|)
condition|)
block|{
name|rc
operator|=
name|mpssas_get_sas_address_for_sata_disk
argument_list|(
name|sc
argument_list|,
operator|&
name|sas_address
argument_list|,
name|phy_change
operator|->
name|dev_handle
argument_list|,
name|device_info
argument_list|,
operator|&
name|phy_change
operator|->
name|is_SATA_SSD
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_ERROR
argument_list|,
literal|"%s: failed to get "
literal|"disk type (SSD or HDD) and SAS Address "
literal|"for SATA device with handle 0x%04x\n"
argument_list|,
name|__func__
argument_list|,
name|phy_change
operator|->
name|dev_handle
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_INFO
argument_list|,
literal|"SAS Address for SATA "
literal|"device = %jx\n"
argument_list|,
name|sas_address
argument_list|)
expr_stmt|;
block|}
block|}
name|phy_change
operator|->
name|physical_id
operator|=
name|sas_address
expr_stmt|;
name|phy_change
operator|->
name|slot
operator|=
name|le16toh
argument_list|(
name|sas_device_pg0
operator|.
name|Slot
argument_list|)
expr_stmt|;
name|phy_change
operator|->
name|device_info
operator|=
name|device_info
expr_stmt|;
comment|/* 		 * When using Enc/Slot mapping, if this device is an enclosure 		 * make sure that all of its slots can fit into the mapping 		 * table. 		 */
if|if
condition|(
operator|(
name|ioc_pg8_flags
operator|&
name|MPI2_IOCPAGE8_FLAGS_MASK_MAPPING_MODE
operator|)
operator|==
name|MPI2_IOCPAGE8_FLAGS_ENCLOSURE_SLOT_MAPPING
condition|)
block|{
comment|/* 			 * The enclosure should already be in the enclosure 			 * table due to the Enclosure Add event. If not, just 			 * continue, nothing can be done. 			 */
name|enc_idx
operator|=
name|_mapping_get_enc_idx_from_handle
argument_list|(
name|sc
argument_list|,
name|topo_change
operator|->
name|enc_handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|enc_idx
operator|==
name|MPS_ENCTABLE_BAD_IDX
condition|)
block|{
name|phy_change
operator|->
name|is_processed
operator|=
literal|1
expr_stmt|;
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_ERROR
operator||
name|MPS_MAPPING
argument_list|,
literal|"%s: "
literal|"failed to add the device with handle "
literal|"0x%04x because the enclosure is not in "
literal|"the mapping table\n"
argument_list|,
name|__func__
argument_list|,
name|phy_change
operator|->
name|dev_handle
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
operator|(
operator|(
name|phy_change
operator|->
name|device_info
operator|&
name|MPI2_SAS_DEVICE_INFO_END_DEVICE
operator|)
operator|&&
operator|(
name|phy_change
operator|->
name|device_info
operator|&
operator|(
name|MPI2_SAS_DEVICE_INFO_SSP_TARGET
operator||
name|MPI2_SAS_DEVICE_INFO_STP_TARGET
operator||
name|MPI2_SAS_DEVICE_INFO_SATA_DEVICE
operator|)
operator|)
operator|)
condition|)
block|{
name|phy_change
operator|->
name|is_processed
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
name|et_entry
operator|=
operator|&
name|sc
operator|->
name|enclosure_table
index|[
name|enc_idx
index|]
expr_stmt|;
comment|/* 			 * If the enclosure already has a start_index, it's been 			 * mapped, so go to the next Topo change. 			 */
if|if
condition|(
name|et_entry
operator|->
name|start_index
operator|!=
name|MPS_MAPTABLE_BAD_IDX
condition|)
continue|continue;
comment|/* 			 * If the Expander Handle is 0, the devices are direct 			 * attached. In that case, the start_index must be just  			 * after the reserved entries. Otherwise, find space in 			 * the mapping table for the enclosure's devices. 			 */
if|if
condition|(
operator|!
name|topo_change
operator|->
name|exp_handle
condition|)
block|{
name|map_idx
operator|=
name|sc
operator|->
name|num_rsvd_entries
expr_stmt|;
name|et_entry
operator|->
name|start_index
operator|=
name|map_idx
expr_stmt|;
block|}
else|else
block|{
name|map_idx
operator|=
name|_mapping_find_enc_map_space
argument_list|(
name|sc
argument_list|,
name|et_entry
argument_list|)
expr_stmt|;
name|et_entry
operator|->
name|start_index
operator|=
name|map_idx
expr_stmt|;
comment|/* 				 * If space cannot be found to hold all of the 				 * enclosure's devices in the mapping table, 				 * there's no need to continue checking the 				 * other devices in this event. Set all of the 				 * phy_details for this event (if the change is 				 * for an add) as already processed because none 				 * of these devices can be added to the mapping 				 * table. 				 */
if|if
condition|(
name|et_entry
operator|->
name|start_index
operator|==
name|MPS_MAPTABLE_BAD_IDX
condition|)
block|{
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_ERROR
operator||
name|MPS_MAPPING
argument_list|,
literal|"%s: failed to add the enclosure "
literal|"with ID 0x%016jx because there is "
literal|"no free space available in the "
literal|"mapping table for all of the "
literal|"enclosure's devices.\n"
argument_list|,
name|__func__
argument_list|,
operator|(
name|uintmax_t
operator|)
name|et_entry
operator|->
name|enclosure_id
argument_list|)
expr_stmt|;
name|phy_change
operator|->
name|is_processed
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|phy_idx
operator|=
literal|0
init|;
name|phy_idx
operator|<
name|topo_change
operator|->
name|num_entries
condition|;
name|phy_idx
operator|++
control|)
block|{
name|tmp_phy_change
operator|=
operator|&
name|topo_change
operator|->
name|phy_details
index|[
name|phy_idx
index|]
expr_stmt|;
if|if
condition|(
name|tmp_phy_change
operator|->
name|reason
operator|==
name|add_code
condition|)
name|tmp_phy_change
operator|->
name|is_processed
operator|=
literal|1
expr_stmt|;
block|}
break|break;
block|}
block|}
comment|/* 			 * Found space in the mapping table for this enclosure. 			 * Initialize each mapping table entry for the 			 * enclosure. 			 */
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_MAPPING
argument_list|,
literal|"%s: Initialize %d map "
literal|"entries for the enclosure, starting at map index "
literal|" %d.\n"
argument_list|,
name|__func__
argument_list|,
name|et_entry
operator|->
name|num_slots
argument_list|,
name|map_idx
argument_list|)
expr_stmt|;
name|mt_entry
operator|=
operator|&
name|sc
operator|->
name|mapping_table
index|[
name|map_idx
index|]
expr_stmt|;
for|for
control|(
name|index
operator|=
name|map_idx
init|;
name|index
operator|<
operator|(
name|et_entry
operator|->
name|num_slots
operator|+
name|map_idx
operator|)
condition|;
name|index
operator|++
operator|,
name|mt_entry
operator|++
control|)
block|{
name|mt_entry
operator|->
name|device_info
operator|=
name|MPS_DEV_RESERVED
expr_stmt|;
name|mt_entry
operator|->
name|physical_id
operator|=
name|et_entry
operator|->
name|enclosure_id
expr_stmt|;
name|mt_entry
operator|->
name|phy_bits
operator|=
name|et_entry
operator|->
name|phy_bits
expr_stmt|;
name|mt_entry
operator|->
name|missing_count
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/**  * _mapping_set_mid_to_eid -set map table data from enclosure table  * @sc: per adapter object  * @et_entry: enclosure entry  *  * Returns nothing  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|_mapping_set_mid_to_eid
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|enc_mapping_table
modifier|*
name|et_entry
parameter_list|)
block|{
name|struct
name|dev_mapping_table
modifier|*
name|mt_entry
decl_stmt|;
name|u16
name|slots
init|=
name|et_entry
operator|->
name|num_slots
decl_stmt|,
name|map_idx
decl_stmt|;
name|u32
name|start_idx
init|=
name|et_entry
operator|->
name|start_index
decl_stmt|;
if|if
condition|(
name|start_idx
operator|!=
name|MPS_MAPTABLE_BAD_IDX
condition|)
block|{
name|mt_entry
operator|=
operator|&
name|sc
operator|->
name|mapping_table
index|[
name|start_idx
index|]
expr_stmt|;
for|for
control|(
name|map_idx
operator|=
literal|0
init|;
name|map_idx
operator|<
name|slots
condition|;
name|map_idx
operator|++
operator|,
name|mt_entry
operator|++
control|)
name|mt_entry
operator|->
name|physical_id
operator|=
name|et_entry
operator|->
name|enclosure_id
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * _mapping_clear_removed_entries - mark the entries to be cleared  * @sc: per adapter object  *  * Search through the removal table and mark the entries which needs to be  * flushed to DPM and also updates the map table and enclosure table by  * clearing the corresponding entries.  *  * Returns nothing  */
end_comment

begin_function
specifier|static
name|void
name|_mapping_clear_removed_entries
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u32
name|remove_idx
decl_stmt|;
name|struct
name|map_removal_table
modifier|*
name|remove_entry
decl_stmt|;
name|Mpi2DriverMap0Entry_t
modifier|*
name|dpm_entry
decl_stmt|;
name|u8
name|done_flag
init|=
literal|0
decl_stmt|,
name|num_entries
decl_stmt|,
name|m
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|enc_mapping_table
modifier|*
name|et_entry
decl_stmt|,
modifier|*
name|from
decl_stmt|,
modifier|*
name|to
decl_stmt|;
name|u16
name|ioc_pg8_flags
init|=
name|le16toh
argument_list|(
name|sc
operator|->
name|ioc_pg8
operator|.
name|Flags
argument_list|)
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|is_dpm_enable
condition|)
block|{
name|remove_entry
operator|=
name|sc
operator|->
name|removal_table
expr_stmt|;
for|for
control|(
name|remove_idx
operator|=
literal|0
init|;
name|remove_idx
operator|<
name|sc
operator|->
name|max_devices
condition|;
name|remove_idx
operator|++
operator|,
name|remove_entry
operator|++
control|)
block|{
if|if
condition|(
name|remove_entry
operator|->
name|dpm_entry_num
operator|!=
name|MPS_DPM_BAD_IDX
condition|)
block|{
name|dpm_entry
operator|=
operator|(
name|Mpi2DriverMap0Entry_t
operator|*
operator|)
operator|(
operator|(
name|u8
operator|*
operator|)
name|sc
operator|->
name|dpm_pg0
operator|+
sizeof|sizeof
argument_list|(
name|MPI2_CONFIG_EXTENDED_PAGE_HEADER
argument_list|)
operator|)
expr_stmt|;
name|dpm_entry
operator|+=
name|remove_entry
operator|->
name|dpm_entry_num
expr_stmt|;
name|dpm_entry
operator|->
name|PhysicalIdentifier
operator|.
name|Low
operator|=
literal|0
expr_stmt|;
name|dpm_entry
operator|->
name|PhysicalIdentifier
operator|.
name|High
operator|=
literal|0
expr_stmt|;
name|dpm_entry
operator|->
name|DeviceIndex
operator|=
literal|0
expr_stmt|;
name|dpm_entry
operator|->
name|MappingInformation
operator|=
literal|0
expr_stmt|;
name|dpm_entry
operator|->
name|PhysicalBitsMapping
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|dpm_flush_entry
index|[
name|remove_entry
operator|->
name|dpm_entry_num
index|]
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|dpm_entry_used
index|[
name|remove_entry
operator|->
name|dpm_entry_num
index|]
operator|=
literal|0
expr_stmt|;
name|remove_entry
operator|->
name|dpm_entry_num
operator|=
name|MPS_DPM_BAD_IDX
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * When using Enc/Slot mapping, if a new enclosure was added and old 	 * enclosure space was needed, the enclosure table may now have gaps 	 * that need to be closed. All enclosure mappings need to be contiguous 	 * so that space can be reused correctly if available. 	 */
if|if
condition|(
operator|(
name|ioc_pg8_flags
operator|&
name|MPI2_IOCPAGE8_FLAGS_MASK_MAPPING_MODE
operator|)
operator|==
name|MPI2_IOCPAGE8_FLAGS_ENCLOSURE_SLOT_MAPPING
condition|)
block|{
name|num_entries
operator|=
name|sc
operator|->
name|num_enc_table_entries
expr_stmt|;
while|while
condition|(
operator|!
name|done_flag
condition|)
block|{
name|done_flag
operator|=
literal|1
expr_stmt|;
name|et_entry
operator|=
name|sc
operator|->
name|enclosure_table
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_entries
condition|;
name|i
operator|++
operator|,
name|et_entry
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|et_entry
operator|->
name|enc_handle
operator|&&
name|et_entry
operator|->
name|init_complete
condition|)
block|{
name|done_flag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|i
operator|!=
operator|(
name|num_entries
operator|-
literal|1
operator|)
condition|)
block|{
name|from
operator|=
operator|&
name|sc
operator|->
name|enclosure_table
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|to
operator|=
operator|&
name|sc
operator|->
name|enclosure_table
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|m
operator|=
name|i
init|;
name|m
operator|<
operator|(
name|num_entries
operator|-
literal|1
operator|)
condition|;
name|m
operator|++
operator|,
name|from
operator|++
operator|,
name|to
operator|++
control|)
block|{
name|_mapping_set_mid_to_eid
argument_list|(
name|sc
argument_list|,
name|to
argument_list|)
expr_stmt|;
operator|*
name|to
operator|=
operator|*
name|from
expr_stmt|;
block|}
name|_mapping_clear_enc_entry
argument_list|(
name|to
argument_list|)
expr_stmt|;
name|sc
operator|->
name|num_enc_table_entries
operator|--
expr_stmt|;
name|num_entries
operator|=
name|sc
operator|->
name|num_enc_table_entries
expr_stmt|;
block|}
else|else
block|{
name|_mapping_clear_enc_entry
argument_list|(
name|et_entry
argument_list|)
expr_stmt|;
name|sc
operator|->
name|num_enc_table_entries
operator|--
expr_stmt|;
name|num_entries
operator|=
name|sc
operator|->
name|num_enc_table_entries
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/**  * _mapping_add_new_device -Add the new device into mapping table  * @sc: per adapter object  * @topo_change: Topology change event entry  *  * Search through the topology change event list and update map table,  * enclosure table and DPM pages for the newly added devices.  *  * Returns nothing  */
end_comment

begin_function
specifier|static
name|void
name|_mapping_add_new_device
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|_map_topology_change
modifier|*
name|topo_change
parameter_list|)
block|{
name|u8
name|enc_idx
decl_stmt|,
name|missing_cnt
decl_stmt|,
name|is_removed
init|=
literal|0
decl_stmt|;
name|u16
name|dpm_idx
decl_stmt|;
name|u32
name|search_idx
decl_stmt|,
name|map_idx
decl_stmt|;
name|u32
name|entry
decl_stmt|;
name|struct
name|dev_mapping_table
modifier|*
name|mt_entry
decl_stmt|;
name|struct
name|enc_mapping_table
modifier|*
name|et_entry
decl_stmt|;
name|struct
name|_map_phy_change
modifier|*
name|phy_change
decl_stmt|;
name|u16
name|ioc_pg8_flags
init|=
name|le16toh
argument_list|(
name|sc
operator|->
name|ioc_pg8
operator|.
name|Flags
argument_list|)
decl_stmt|;
name|Mpi2DriverMap0Entry_t
modifier|*
name|dpm_entry
decl_stmt|;
name|uint64_t
name|temp64_var
decl_stmt|;
name|u8
name|map_shift
init|=
name|MPI2_DRVMAP0_MAPINFO_SLOT_SHIFT
decl_stmt|;
name|u8
name|hdr_sz
init|=
sizeof|sizeof
argument_list|(
name|MPI2_CONFIG_EXTENDED_PAGE_HEADER
argument_list|)
decl_stmt|;
name|u16
name|max_num_phy_ids
init|=
name|le16toh
argument_list|(
name|sc
operator|->
name|ioc_pg8
operator|.
name|MaxNumPhysicalMappedIDs
argument_list|)
decl_stmt|;
for|for
control|(
name|entry
operator|=
literal|0
init|;
name|entry
operator|<
name|topo_change
operator|->
name|num_entries
condition|;
name|entry
operator|++
control|)
block|{
name|phy_change
operator|=
operator|&
name|topo_change
operator|->
name|phy_details
index|[
name|entry
index|]
expr_stmt|;
if|if
condition|(
name|phy_change
operator|->
name|is_processed
condition|)
continue|continue;
if|if
condition|(
name|phy_change
operator|->
name|reason
operator|!=
name|MPI2_EVENT_SAS_TOPO_RC_TARG_ADDED
operator|||
operator|!
name|phy_change
operator|->
name|dev_handle
condition|)
block|{
name|phy_change
operator|->
name|is_processed
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|ioc_pg8_flags
operator|&
name|MPI2_IOCPAGE8_FLAGS_MASK_MAPPING_MODE
operator|)
operator|==
name|MPI2_IOCPAGE8_FLAGS_ENCLOSURE_SLOT_MAPPING
condition|)
block|{
name|enc_idx
operator|=
name|_mapping_get_enc_idx_from_handle
argument_list|(
name|sc
argument_list|,
name|topo_change
operator|->
name|enc_handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|enc_idx
operator|==
name|MPS_ENCTABLE_BAD_IDX
condition|)
block|{
name|phy_change
operator|->
name|is_processed
operator|=
literal|1
expr_stmt|;
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_ERROR
operator||
name|MPS_MAPPING
argument_list|,
literal|"%s: "
literal|"failed to add the device with handle "
literal|"0x%04x because the enclosure is not in "
literal|"the mapping table\n"
argument_list|,
name|__func__
argument_list|,
name|phy_change
operator|->
name|dev_handle
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 			 * If the enclosure's start_index is BAD here, it means 			 * that there is no room in the mapping table to cover 			 * all of the devices that could be in the enclosure. 			 * There's no reason to process any of the devices for 			 * this enclosure since they can't be mapped. 			 */
name|et_entry
operator|=
operator|&
name|sc
operator|->
name|enclosure_table
index|[
name|enc_idx
index|]
expr_stmt|;
if|if
condition|(
name|et_entry
operator|->
name|start_index
operator|==
name|MPS_MAPTABLE_BAD_IDX
condition|)
block|{
name|phy_change
operator|->
name|is_processed
operator|=
literal|1
expr_stmt|;
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_ERROR
operator||
name|MPS_MAPPING
argument_list|,
literal|"%s: "
literal|"failed to add the device with handle "
literal|"0x%04x because there is no free space "
literal|"available in the mapping table\n"
argument_list|,
name|__func__
argument_list|,
name|phy_change
operator|->
name|dev_handle
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 			 * Add this device to the mapping table at the correct 			 * offset where space was found to map the enclosure. 			 * Then setup the DPM entry information if being used. 			 */
name|map_idx
operator|=
name|et_entry
operator|->
name|start_index
operator|+
name|phy_change
operator|->
name|slot
operator|-
name|et_entry
operator|->
name|start_slot
expr_stmt|;
name|mt_entry
operator|=
operator|&
name|sc
operator|->
name|mapping_table
index|[
name|map_idx
index|]
expr_stmt|;
name|mt_entry
operator|->
name|physical_id
operator|=
name|phy_change
operator|->
name|physical_id
expr_stmt|;
name|mt_entry
operator|->
name|id
operator|=
name|map_idx
expr_stmt|;
name|mt_entry
operator|->
name|dev_handle
operator|=
name|phy_change
operator|->
name|dev_handle
expr_stmt|;
name|mt_entry
operator|->
name|missing_count
operator|=
literal|0
expr_stmt|;
name|mt_entry
operator|->
name|dpm_entry_num
operator|=
name|et_entry
operator|->
name|dpm_entry_num
expr_stmt|;
name|mt_entry
operator|->
name|device_info
operator|=
name|phy_change
operator|->
name|device_info
operator||
operator|(
name|MPS_DEV_RESERVED
operator||
name|MPS_MAP_IN_USE
operator|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|is_dpm_enable
condition|)
block|{
name|dpm_idx
operator|=
name|et_entry
operator|->
name|dpm_entry_num
expr_stmt|;
if|if
condition|(
name|dpm_idx
operator|==
name|MPS_DPM_BAD_IDX
condition|)
name|dpm_idx
operator|=
name|_mapping_get_dpm_idx_from_id
argument_list|(
name|sc
argument_list|,
name|et_entry
operator|->
name|enclosure_id
argument_list|,
name|et_entry
operator|->
name|phy_bits
argument_list|)
expr_stmt|;
if|if
condition|(
name|dpm_idx
operator|==
name|MPS_DPM_BAD_IDX
condition|)
block|{
name|dpm_idx
operator|=
name|_mapping_get_free_dpm_idx
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|dpm_idx
operator|!=
name|MPS_DPM_BAD_IDX
condition|)
block|{
name|dpm_entry
operator|=
operator|(
name|Mpi2DriverMap0Entry_t
operator|*
operator|)
operator|(
operator|(
name|u8
operator|*
operator|)
name|sc
operator|->
name|dpm_pg0
operator|+
name|hdr_sz
operator|)
expr_stmt|;
name|dpm_entry
operator|+=
name|dpm_idx
expr_stmt|;
name|dpm_entry
operator|->
name|PhysicalIdentifier
operator|.
name|Low
operator|=
operator|(
literal|0xFFFFFFFF
operator|&
name|et_entry
operator|->
name|enclosure_id
operator|)
expr_stmt|;
name|dpm_entry
operator|->
name|PhysicalIdentifier
operator|.
name|High
operator|=
operator|(
name|et_entry
operator|->
name|enclosure_id
operator|>>
literal|32
operator|)
expr_stmt|;
name|dpm_entry
operator|->
name|DeviceIndex
operator|=
operator|(
name|U16
operator|)
name|et_entry
operator|->
name|start_index
expr_stmt|;
name|dpm_entry
operator|->
name|MappingInformation
operator|=
name|et_entry
operator|->
name|num_slots
expr_stmt|;
name|dpm_entry
operator|->
name|MappingInformation
operator|<<=
name|map_shift
expr_stmt|;
name|dpm_entry
operator|->
name|PhysicalBitsMapping
operator|=
name|et_entry
operator|->
name|phy_bits
expr_stmt|;
name|et_entry
operator|->
name|dpm_entry_num
operator|=
name|dpm_idx
expr_stmt|;
name|sc
operator|->
name|dpm_entry_used
index|[
name|dpm_idx
index|]
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|dpm_flush_entry
index|[
name|dpm_idx
index|]
operator|=
literal|1
expr_stmt|;
name|phy_change
operator|->
name|is_processed
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|phy_change
operator|->
name|is_processed
operator|=
literal|1
expr_stmt|;
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_ERROR
operator||
name|MPS_MAPPING
argument_list|,
literal|"%s: failed "
literal|"to add the device with "
literal|"handle 0x%04x to "
literal|"persistent table because "
literal|"there is no free space "
literal|"available\n"
argument_list|,
name|__func__
argument_list|,
name|phy_change
operator|->
name|dev_handle
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|et_entry
operator|->
name|dpm_entry_num
operator|=
name|dpm_idx
expr_stmt|;
name|mt_entry
operator|->
name|dpm_entry_num
operator|=
name|dpm_idx
expr_stmt|;
block|}
block|}
name|et_entry
operator|->
name|init_complete
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ioc_pg8_flags
operator|&
name|MPI2_IOCPAGE8_FLAGS_MASK_MAPPING_MODE
operator|)
operator|==
name|MPI2_IOCPAGE8_FLAGS_DEVICE_PERSISTENCE_MAPPING
condition|)
block|{
comment|/* 			 * Get the mapping table index for this device. If it's 			 * not in the mapping table yet, find a free entry if 			 * one is available. If there are no free entries, look 			 * for the entry that has the highest missing count. If 			 * none of that works to find an entry in the mapping 			 * table, there is a problem. Log a message and just 			 * continue on. 			 */
name|map_idx
operator|=
name|_mapping_get_mt_idx_from_id
argument_list|(
name|sc
argument_list|,
name|phy_change
operator|->
name|physical_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|map_idx
operator|==
name|MPS_MAPTABLE_BAD_IDX
condition|)
block|{
name|search_idx
operator|=
name|sc
operator|->
name|num_rsvd_entries
expr_stmt|;
if|if
condition|(
name|topo_change
operator|->
name|exp_handle
condition|)
name|search_idx
operator|+=
name|max_num_phy_ids
expr_stmt|;
name|map_idx
operator|=
name|_mapping_get_free_mt_idx
argument_list|(
name|sc
argument_list|,
name|search_idx
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * If an entry will be used that has a missing device, 			 * clear its entry from  the DPM in the controller. 			 */
if|if
condition|(
name|map_idx
operator|==
name|MPS_MAPTABLE_BAD_IDX
condition|)
block|{
name|map_idx
operator|=
name|_mapping_get_high_missing_mt_idx
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|map_idx
operator|!=
name|MPS_MAPTABLE_BAD_IDX
condition|)
block|{
name|mt_entry
operator|=
operator|&
name|sc
operator|->
name|mapping_table
index|[
name|map_idx
index|]
expr_stmt|;
name|_mapping_add_to_removal_table
argument_list|(
name|sc
argument_list|,
name|mt_entry
operator|->
name|dpm_entry_num
argument_list|)
expr_stmt|;
name|is_removed
operator|=
literal|1
expr_stmt|;
name|mt_entry
operator|->
name|init_complete
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|map_idx
operator|!=
name|MPS_MAPTABLE_BAD_IDX
condition|)
block|{
name|mt_entry
operator|=
operator|&
name|sc
operator|->
name|mapping_table
index|[
name|map_idx
index|]
expr_stmt|;
name|mt_entry
operator|->
name|physical_id
operator|=
name|phy_change
operator|->
name|physical_id
expr_stmt|;
name|mt_entry
operator|->
name|id
operator|=
name|map_idx
expr_stmt|;
name|mt_entry
operator|->
name|dev_handle
operator|=
name|phy_change
operator|->
name|dev_handle
expr_stmt|;
name|mt_entry
operator|->
name|missing_count
operator|=
literal|0
expr_stmt|;
name|mt_entry
operator|->
name|device_info
operator|=
name|phy_change
operator|->
name|device_info
operator||
operator|(
name|MPS_DEV_RESERVED
operator||
name|MPS_MAP_IN_USE
operator|)
expr_stmt|;
block|}
else|else
block|{
name|phy_change
operator|->
name|is_processed
operator|=
literal|1
expr_stmt|;
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_ERROR
operator||
name|MPS_MAPPING
argument_list|,
literal|"%s: "
literal|"failed to add the device with handle "
literal|"0x%04x because there is no free space "
literal|"available in the mapping table\n"
argument_list|,
name|__func__
argument_list|,
name|phy_change
operator|->
name|dev_handle
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|sc
operator|->
name|is_dpm_enable
condition|)
block|{
if|if
condition|(
name|mt_entry
operator|->
name|dpm_entry_num
operator|!=
name|MPS_DPM_BAD_IDX
condition|)
block|{
name|dpm_idx
operator|=
name|mt_entry
operator|->
name|dpm_entry_num
expr_stmt|;
name|dpm_entry
operator|=
operator|(
name|Mpi2DriverMap0Entry_t
operator|*
operator|)
operator|(
operator|(
name|u8
operator|*
operator|)
name|sc
operator|->
name|dpm_pg0
operator|+
name|hdr_sz
operator|)
expr_stmt|;
name|dpm_entry
operator|+=
name|dpm_idx
expr_stmt|;
name|missing_cnt
operator|=
name|dpm_entry
operator|->
name|MappingInformation
operator|&
name|MPI2_DRVMAP0_MAPINFO_MISSING_MASK
expr_stmt|;
name|temp64_var
operator|=
name|dpm_entry
operator|->
name|PhysicalIdentifier
operator|.
name|High
expr_stmt|;
name|temp64_var
operator|=
operator|(
name|temp64_var
operator|<<
literal|32
operator|)
operator||
name|dpm_entry
operator|->
name|PhysicalIdentifier
operator|.
name|Low
expr_stmt|;
comment|/* 					 * If the Mapping Table's info is not 					 * the same as the DPM entry, clear the 					 * init_complete flag so that it's 					 * updated. 					 */
if|if
condition|(
operator|(
name|mt_entry
operator|->
name|physical_id
operator|==
name|temp64_var
operator|)
operator|&&
operator|!
name|missing_cnt
condition|)
name|mt_entry
operator|->
name|init_complete
operator|=
literal|1
expr_stmt|;
else|else
name|mt_entry
operator|->
name|init_complete
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|dpm_idx
operator|=
name|_mapping_get_free_dpm_idx
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mt_entry
operator|->
name|init_complete
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|dpm_idx
operator|!=
name|MPS_DPM_BAD_IDX
operator|&&
operator|!
name|mt_entry
operator|->
name|init_complete
condition|)
block|{
name|mt_entry
operator|->
name|dpm_entry_num
operator|=
name|dpm_idx
expr_stmt|;
name|dpm_entry
operator|=
operator|(
name|Mpi2DriverMap0Entry_t
operator|*
operator|)
operator|(
operator|(
name|u8
operator|*
operator|)
name|sc
operator|->
name|dpm_pg0
operator|+
name|hdr_sz
operator|)
expr_stmt|;
name|dpm_entry
operator|+=
name|dpm_idx
expr_stmt|;
name|dpm_entry
operator|->
name|PhysicalIdentifier
operator|.
name|Low
operator|=
operator|(
literal|0xFFFFFFFF
operator|&
name|mt_entry
operator|->
name|physical_id
operator|)
expr_stmt|;
name|dpm_entry
operator|->
name|PhysicalIdentifier
operator|.
name|High
operator|=
operator|(
name|mt_entry
operator|->
name|physical_id
operator|>>
literal|32
operator|)
expr_stmt|;
name|dpm_entry
operator|->
name|DeviceIndex
operator|=
operator|(
name|U16
operator|)
name|map_idx
expr_stmt|;
name|dpm_entry
operator|->
name|MappingInformation
operator|=
literal|0
expr_stmt|;
name|dpm_entry
operator|->
name|PhysicalBitsMapping
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|dpm_entry_used
index|[
name|dpm_idx
index|]
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|dpm_flush_entry
index|[
name|dpm_idx
index|]
operator|=
literal|1
expr_stmt|;
name|phy_change
operator|->
name|is_processed
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dpm_idx
operator|==
name|MPS_DPM_BAD_IDX
condition|)
block|{
name|phy_change
operator|->
name|is_processed
operator|=
literal|1
expr_stmt|;
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_ERROR
operator||
name|MPS_MAPPING
argument_list|,
literal|"%s: failed to add the device with "
literal|"handle 0x%04x to persistent table "
literal|"because there is no free space "
literal|"available\n"
argument_list|,
name|__func__
argument_list|,
name|phy_change
operator|->
name|dev_handle
argument_list|)
expr_stmt|;
block|}
block|}
name|mt_entry
operator|->
name|init_complete
operator|=
literal|1
expr_stmt|;
block|}
name|phy_change
operator|->
name|is_processed
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|is_removed
condition|)
name|_mapping_clear_removed_entries
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * _mapping_flush_dpm_pages -Flush the DPM pages to NVRAM  * @sc: per adapter object  *  * Returns nothing  */
end_comment

begin_function
specifier|static
name|void
name|_mapping_flush_dpm_pages
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|)
block|{
name|Mpi2DriverMap0Entry_t
modifier|*
name|dpm_entry
decl_stmt|;
name|Mpi2ConfigReply_t
name|mpi_reply
decl_stmt|;
name|Mpi2DriverMappingPage0_t
name|config_page
decl_stmt|;
name|u16
name|entry_num
decl_stmt|;
for|for
control|(
name|entry_num
operator|=
literal|0
init|;
name|entry_num
operator|<
name|sc
operator|->
name|max_dpm_entries
condition|;
name|entry_num
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|sc
operator|->
name|dpm_flush_entry
index|[
name|entry_num
index|]
condition|)
continue|continue;
name|memset
argument_list|(
operator|&
name|config_page
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|Mpi2DriverMappingPage0_t
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|config_page
operator|.
name|Header
argument_list|,
operator|(
name|u8
operator|*
operator|)
name|sc
operator|->
name|dpm_pg0
argument_list|,
sizeof|sizeof
argument_list|(
name|MPI2_CONFIG_EXTENDED_PAGE_HEADER
argument_list|)
argument_list|)
expr_stmt|;
name|dpm_entry
operator|=
operator|(
name|Mpi2DriverMap0Entry_t
operator|*
operator|)
operator|(
operator|(
name|u8
operator|*
operator|)
name|sc
operator|->
name|dpm_pg0
operator|+
sizeof|sizeof
argument_list|(
name|MPI2_CONFIG_EXTENDED_PAGE_HEADER
argument_list|)
operator|)
expr_stmt|;
name|dpm_entry
operator|+=
name|entry_num
expr_stmt|;
name|dpm_entry
operator|->
name|MappingInformation
operator|=
name|htole16
argument_list|(
name|dpm_entry
operator|->
name|MappingInformation
argument_list|)
expr_stmt|;
name|dpm_entry
operator|->
name|DeviceIndex
operator|=
name|htole16
argument_list|(
name|dpm_entry
operator|->
name|DeviceIndex
argument_list|)
expr_stmt|;
name|dpm_entry
operator|->
name|PhysicalBitsMapping
operator|=
name|htole32
argument_list|(
name|dpm_entry
operator|->
name|PhysicalBitsMapping
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|config_page
operator|.
name|Entry
argument_list|,
operator|(
name|u8
operator|*
operator|)
name|dpm_entry
argument_list|,
sizeof|sizeof
argument_list|(
name|Mpi2DriverMap0Entry_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* TODO-How to handle failed writes? */
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_MAPPING
argument_list|,
literal|"%s: Flushing DPM entry %d.\n"
argument_list|,
name|__func__
argument_list|,
name|entry_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|mps_config_set_dpm_pg0
argument_list|(
name|sc
argument_list|,
operator|&
name|mpi_reply
argument_list|,
operator|&
name|config_page
argument_list|,
name|entry_num
argument_list|)
condition|)
block|{
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_ERROR
operator||
name|MPS_MAPPING
argument_list|,
literal|"%s: Flush of "
literal|"DPM entry %d for device failed\n"
argument_list|,
name|__func__
argument_list|,
name|entry_num
argument_list|)
expr_stmt|;
block|}
else|else
name|sc
operator|->
name|dpm_flush_entry
index|[
name|entry_num
index|]
operator|=
literal|0
expr_stmt|;
name|dpm_entry
operator|->
name|MappingInformation
operator|=
name|le16toh
argument_list|(
name|dpm_entry
operator|->
name|MappingInformation
argument_list|)
expr_stmt|;
name|dpm_entry
operator|->
name|DeviceIndex
operator|=
name|le16toh
argument_list|(
name|dpm_entry
operator|->
name|DeviceIndex
argument_list|)
expr_stmt|;
name|dpm_entry
operator|->
name|PhysicalBitsMapping
operator|=
name|le32toh
argument_list|(
name|dpm_entry
operator|->
name|PhysicalBitsMapping
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * _mapping_allocate_memory- allocates the memory required for mapping tables  * @sc: per adapter object  *  * Allocates the memory for all the tables required for host mapping  *  * Return 0 on success or non-zero on failure.  */
end_comment

begin_function
name|int
name|mps_mapping_allocate_memory
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|dpm_pg0_sz
decl_stmt|;
name|sc
operator|->
name|mapping_table
operator|=
name|malloc
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|dev_mapping_table
argument_list|)
operator|*
name|sc
operator|->
name|max_devices
operator|)
argument_list|,
name|M_MPT2
argument_list|,
name|M_ZERO
operator||
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|mapping_table
condition|)
goto|goto
name|free_resources
goto|;
name|sc
operator|->
name|removal_table
operator|=
name|malloc
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|map_removal_table
argument_list|)
operator|*
name|sc
operator|->
name|max_devices
operator|)
argument_list|,
name|M_MPT2
argument_list|,
name|M_ZERO
operator||
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|removal_table
condition|)
goto|goto
name|free_resources
goto|;
name|sc
operator|->
name|enclosure_table
operator|=
name|malloc
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|enc_mapping_table
argument_list|)
operator|*
name|sc
operator|->
name|max_enclosures
operator|)
argument_list|,
name|M_MPT2
argument_list|,
name|M_ZERO
operator||
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|enclosure_table
condition|)
goto|goto
name|free_resources
goto|;
name|sc
operator|->
name|dpm_entry_used
operator|=
name|malloc
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
name|u8
argument_list|)
operator|*
name|sc
operator|->
name|max_dpm_entries
operator|)
argument_list|,
name|M_MPT2
argument_list|,
name|M_ZERO
operator||
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|dpm_entry_used
condition|)
goto|goto
name|free_resources
goto|;
name|sc
operator|->
name|dpm_flush_entry
operator|=
name|malloc
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
name|u8
argument_list|)
operator|*
name|sc
operator|->
name|max_dpm_entries
operator|)
argument_list|,
name|M_MPT2
argument_list|,
name|M_ZERO
operator||
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|dpm_flush_entry
condition|)
goto|goto
name|free_resources
goto|;
name|dpm_pg0_sz
operator|=
sizeof|sizeof
argument_list|(
name|MPI2_CONFIG_EXTENDED_PAGE_HEADER
argument_list|)
operator|+
operator|(
name|sc
operator|->
name|max_dpm_entries
operator|*
sizeof|sizeof
argument_list|(
name|MPI2_CONFIG_PAGE_DRIVER_MAP0_ENTRY
argument_list|)
operator|)
expr_stmt|;
name|sc
operator|->
name|dpm_pg0
operator|=
name|malloc
argument_list|(
name|dpm_pg0_sz
argument_list|,
name|M_MPT2
argument_list|,
name|M_ZERO
operator||
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|dpm_pg0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: memory alloc failed for dpm page; disabling dpm\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|sc
operator|->
name|is_dpm_enable
operator|=
literal|0
expr_stmt|;
block|}
return|return
literal|0
return|;
name|free_resources
label|:
name|free
argument_list|(
name|sc
operator|->
name|mapping_table
argument_list|,
name|M_MPT2
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|removal_table
argument_list|,
name|M_MPT2
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|enclosure_table
argument_list|,
name|M_MPT2
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|dpm_entry_used
argument_list|,
name|M_MPT2
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|dpm_flush_entry
argument_list|,
name|M_MPT2
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|dpm_pg0
argument_list|,
name|M_MPT2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: device initialization failed due to failure in mapping "
literal|"table memory allocation\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  * mps_mapping_free_memory- frees the memory allocated for mapping tables  * @sc: per adapter object  *  * Returns nothing.  */
end_comment

begin_function
name|void
name|mps_mapping_free_memory
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|)
block|{
name|free
argument_list|(
name|sc
operator|->
name|mapping_table
argument_list|,
name|M_MPT2
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|removal_table
argument_list|,
name|M_MPT2
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|enclosure_table
argument_list|,
name|M_MPT2
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|dpm_entry_used
argument_list|,
name|M_MPT2
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|dpm_flush_entry
argument_list|,
name|M_MPT2
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|dpm_pg0
argument_list|,
name|M_MPT2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|_mapping_process_dpm_pg0
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u8
name|missing_cnt
decl_stmt|,
name|enc_idx
decl_stmt|;
name|u16
name|slot_id
decl_stmt|,
name|entry_num
decl_stmt|,
name|num_slots
decl_stmt|;
name|u32
name|map_idx
decl_stmt|,
name|dev_idx
decl_stmt|,
name|start_idx
decl_stmt|,
name|end_idx
decl_stmt|;
name|struct
name|dev_mapping_table
modifier|*
name|mt_entry
decl_stmt|;
name|Mpi2DriverMap0Entry_t
modifier|*
name|dpm_entry
decl_stmt|;
name|u16
name|ioc_pg8_flags
init|=
name|le16toh
argument_list|(
name|sc
operator|->
name|ioc_pg8
operator|.
name|Flags
argument_list|)
decl_stmt|;
name|u16
name|max_num_phy_ids
init|=
name|le16toh
argument_list|(
name|sc
operator|->
name|ioc_pg8
operator|.
name|MaxNumPhysicalMappedIDs
argument_list|)
decl_stmt|;
name|struct
name|enc_mapping_table
modifier|*
name|et_entry
decl_stmt|;
name|u64
name|physical_id
decl_stmt|;
name|u32
name|phy_bits
init|=
literal|0
decl_stmt|;
comment|/* 	 * start_idx and end_idx are only used for IR. 	 */
if|if
condition|(
name|sc
operator|->
name|ir_firmware
condition|)
name|_mapping_get_ir_maprange
argument_list|(
name|sc
argument_list|,
operator|&
name|start_idx
argument_list|,
operator|&
name|end_idx
argument_list|)
expr_stmt|;
comment|/* 	 * Look through all of the DPM entries that were read from the 	 * controller and copy them over to the driver's internal table if they 	 * have a non-zero ID. At this point, any ID with a value of 0 would be 	 * invalid, so don't copy it. 	 */
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_MAPPING
argument_list|,
literal|"%s: Start copy of %d DPM entries into the "
literal|"mapping table.\n"
argument_list|,
name|__func__
argument_list|,
name|sc
operator|->
name|max_dpm_entries
argument_list|)
expr_stmt|;
name|dpm_entry
operator|=
operator|(
name|Mpi2DriverMap0Entry_t
operator|*
operator|)
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|sc
operator|->
name|dpm_pg0
operator|+
sizeof|sizeof
argument_list|(
name|MPI2_CONFIG_EXTENDED_PAGE_HEADER
argument_list|)
operator|)
expr_stmt|;
for|for
control|(
name|entry_num
operator|=
literal|0
init|;
name|entry_num
operator|<
name|sc
operator|->
name|max_dpm_entries
condition|;
name|entry_num
operator|++
operator|,
name|dpm_entry
operator|++
control|)
block|{
name|physical_id
operator|=
name|dpm_entry
operator|->
name|PhysicalIdentifier
operator|.
name|High
expr_stmt|;
name|physical_id
operator|=
operator|(
name|physical_id
operator|<<
literal|32
operator|)
operator||
name|dpm_entry
operator|->
name|PhysicalIdentifier
operator|.
name|Low
expr_stmt|;
if|if
condition|(
operator|!
name|physical_id
condition|)
block|{
name|sc
operator|->
name|dpm_entry_used
index|[
name|entry_num
index|]
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
name|sc
operator|->
name|dpm_entry_used
index|[
name|entry_num
index|]
operator|=
literal|1
expr_stmt|;
name|dpm_entry
operator|->
name|MappingInformation
operator|=
name|le16toh
argument_list|(
name|dpm_entry
operator|->
name|MappingInformation
argument_list|)
expr_stmt|;
name|missing_cnt
operator|=
name|dpm_entry
operator|->
name|MappingInformation
operator|&
name|MPI2_DRVMAP0_MAPINFO_MISSING_MASK
expr_stmt|;
name|dev_idx
operator|=
name|le16toh
argument_list|(
name|dpm_entry
operator|->
name|DeviceIndex
argument_list|)
expr_stmt|;
name|phy_bits
operator|=
name|le32toh
argument_list|(
name|dpm_entry
operator|->
name|PhysicalBitsMapping
argument_list|)
expr_stmt|;
comment|/* 		 * Volumes are at special locations in the mapping table so 		 * account for that. Volume mapping table entries do not depend 		 * on the type of mapping, so continue the loop after adding 		 * volumes to the mapping table. 		 */
if|if
condition|(
name|sc
operator|->
name|ir_firmware
operator|&&
operator|(
name|dev_idx
operator|>=
name|start_idx
operator|)
operator|&&
operator|(
name|dev_idx
operator|<=
name|end_idx
operator|)
condition|)
block|{
name|mt_entry
operator|=
operator|&
name|sc
operator|->
name|mapping_table
index|[
name|dev_idx
index|]
expr_stmt|;
name|mt_entry
operator|->
name|physical_id
operator|=
name|dpm_entry
operator|->
name|PhysicalIdentifier
operator|.
name|High
expr_stmt|;
name|mt_entry
operator|->
name|physical_id
operator|=
operator|(
name|mt_entry
operator|->
name|physical_id
operator|<<
literal|32
operator|)
operator||
name|dpm_entry
operator|->
name|PhysicalIdentifier
operator|.
name|Low
expr_stmt|;
name|mt_entry
operator|->
name|id
operator|=
name|dev_idx
expr_stmt|;
name|mt_entry
operator|->
name|missing_count
operator|=
name|missing_cnt
expr_stmt|;
name|mt_entry
operator|->
name|dpm_entry_num
operator|=
name|entry_num
expr_stmt|;
name|mt_entry
operator|->
name|device_info
operator|=
name|MPS_DEV_RESERVED
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|ioc_pg8_flags
operator|&
name|MPI2_IOCPAGE8_FLAGS_MASK_MAPPING_MODE
operator|)
operator|==
name|MPI2_IOCPAGE8_FLAGS_ENCLOSURE_SLOT_MAPPING
condition|)
block|{
comment|/* 			 * The dev_idx for an enclosure is the start index. If 			 * the start index is within the controller's default 			 * enclosure area, set the number of slots for this 			 * enclosure to the max allowed. Otherwise, it should be 			 * a normal enclosure and the number of slots is in the 			 * DPM entry's Mapping Information. 			 */
if|if
condition|(
name|dev_idx
operator|<
operator|(
name|sc
operator|->
name|num_rsvd_entries
operator|+
name|max_num_phy_ids
operator|)
condition|)
block|{
name|slot_id
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ioc_pg8_flags
operator|&
name|MPI2_IOCPAGE8_FLAGS_DA_START_SLOT_1
condition|)
name|slot_id
operator|=
literal|1
expr_stmt|;
name|num_slots
operator|=
name|max_num_phy_ids
expr_stmt|;
block|}
else|else
block|{
name|slot_id
operator|=
literal|0
expr_stmt|;
name|num_slots
operator|=
name|dpm_entry
operator|->
name|MappingInformation
operator|&
name|MPI2_DRVMAP0_MAPINFO_SLOT_MASK
expr_stmt|;
name|num_slots
operator|>>=
name|MPI2_DRVMAP0_MAPINFO_SLOT_SHIFT
expr_stmt|;
block|}
name|enc_idx
operator|=
name|sc
operator|->
name|num_enc_table_entries
expr_stmt|;
if|if
condition|(
name|enc_idx
operator|>=
name|sc
operator|->
name|max_enclosures
condition|)
block|{
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_ERROR
operator||
name|MPS_MAPPING
argument_list|,
literal|"%s: "
literal|"Number of enclosure entries in DPM exceed "
literal|"the max allowed of %d.\n"
argument_list|,
name|__func__
argument_list|,
name|sc
operator|->
name|max_enclosures
argument_list|)
expr_stmt|;
break|break;
block|}
name|sc
operator|->
name|num_enc_table_entries
operator|++
expr_stmt|;
name|et_entry
operator|=
operator|&
name|sc
operator|->
name|enclosure_table
index|[
name|enc_idx
index|]
expr_stmt|;
name|physical_id
operator|=
name|dpm_entry
operator|->
name|PhysicalIdentifier
operator|.
name|High
expr_stmt|;
name|et_entry
operator|->
name|enclosure_id
operator|=
operator|(
name|physical_id
operator|<<
literal|32
operator|)
operator||
name|dpm_entry
operator|->
name|PhysicalIdentifier
operator|.
name|Low
expr_stmt|;
name|et_entry
operator|->
name|start_index
operator|=
name|dev_idx
expr_stmt|;
name|et_entry
operator|->
name|dpm_entry_num
operator|=
name|entry_num
expr_stmt|;
name|et_entry
operator|->
name|num_slots
operator|=
name|num_slots
expr_stmt|;
name|et_entry
operator|->
name|start_slot
operator|=
name|slot_id
expr_stmt|;
name|et_entry
operator|->
name|missing_count
operator|=
name|missing_cnt
expr_stmt|;
name|et_entry
operator|->
name|phy_bits
operator|=
name|phy_bits
expr_stmt|;
comment|/* 			 * Initialize all entries for this enclosure in the 			 * mapping table and mark them as reserved. The actual 			 * devices have not been processed yet but when they are 			 * they will use these entries. If an entry is found 			 * that already has a valid DPM index, the mapping table 			 * is corrupt. This can happen if the mapping type is 			 * changed without clearing all of the DPM entries in 			 * the controller. 			 */
name|mt_entry
operator|=
operator|&
name|sc
operator|->
name|mapping_table
index|[
name|dev_idx
index|]
expr_stmt|;
for|for
control|(
name|map_idx
operator|=
name|dev_idx
init|;
name|map_idx
operator|<
operator|(
name|dev_idx
operator|+
name|num_slots
operator|)
condition|;
name|map_idx
operator|++
operator|,
name|mt_entry
operator|++
control|)
block|{
if|if
condition|(
name|mt_entry
operator|->
name|dpm_entry_num
operator|!=
name|MPS_DPM_BAD_IDX
condition|)
block|{
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_ERROR
operator||
name|MPS_MAPPING
argument_list|,
literal|"%s: Conflict in mapping table for "
literal|" enclosure %d\n"
argument_list|,
name|__func__
argument_list|,
name|enc_idx
argument_list|)
expr_stmt|;
break|break;
block|}
name|physical_id
operator|=
name|dpm_entry
operator|->
name|PhysicalIdentifier
operator|.
name|High
expr_stmt|;
name|mt_entry
operator|->
name|physical_id
operator|=
operator|(
name|physical_id
operator|<<
literal|32
operator|)
operator||
name|dpm_entry
operator|->
name|PhysicalIdentifier
operator|.
name|Low
expr_stmt|;
name|mt_entry
operator|->
name|phy_bits
operator|=
name|phy_bits
expr_stmt|;
name|mt_entry
operator|->
name|id
operator|=
name|dev_idx
expr_stmt|;
name|mt_entry
operator|->
name|dpm_entry_num
operator|=
name|entry_num
expr_stmt|;
name|mt_entry
operator|->
name|missing_count
operator|=
name|missing_cnt
expr_stmt|;
name|mt_entry
operator|->
name|device_info
operator|=
name|MPS_DEV_RESERVED
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|ioc_pg8_flags
operator|&
name|MPI2_IOCPAGE8_FLAGS_MASK_MAPPING_MODE
operator|)
operator|==
name|MPI2_IOCPAGE8_FLAGS_DEVICE_PERSISTENCE_MAPPING
condition|)
block|{
comment|/* 			 * Device mapping, so simply copy the DPM entries to the 			 * mapping table, but check for a corrupt mapping table 			 * (as described above in Enc/Slot mapping). 			 */
name|map_idx
operator|=
name|dev_idx
expr_stmt|;
name|mt_entry
operator|=
operator|&
name|sc
operator|->
name|mapping_table
index|[
name|map_idx
index|]
expr_stmt|;
if|if
condition|(
name|mt_entry
operator|->
name|dpm_entry_num
operator|!=
name|MPS_DPM_BAD_IDX
condition|)
block|{
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_ERROR
operator||
name|MPS_MAPPING
argument_list|,
literal|"%s: "
literal|"Conflict in mapping table for device %d\n"
argument_list|,
name|__func__
argument_list|,
name|map_idx
argument_list|)
expr_stmt|;
break|break;
block|}
name|physical_id
operator|=
name|dpm_entry
operator|->
name|PhysicalIdentifier
operator|.
name|High
expr_stmt|;
name|mt_entry
operator|->
name|physical_id
operator|=
operator|(
name|physical_id
operator|<<
literal|32
operator|)
operator||
name|dpm_entry
operator|->
name|PhysicalIdentifier
operator|.
name|Low
expr_stmt|;
name|mt_entry
operator|->
name|phy_bits
operator|=
name|phy_bits
expr_stmt|;
name|mt_entry
operator|->
name|id
operator|=
name|dev_idx
expr_stmt|;
name|mt_entry
operator|->
name|missing_count
operator|=
name|missing_cnt
expr_stmt|;
name|mt_entry
operator|->
name|dpm_entry_num
operator|=
name|entry_num
expr_stmt|;
name|mt_entry
operator|->
name|device_info
operator|=
name|MPS_DEV_RESERVED
expr_stmt|;
block|}
block|}
comment|/*close the loop for DPM table */
block|}
end_function

begin_comment
comment|/*  * mps_mapping_check_devices - start of the day check for device availabilty  * @sc: per adapter object  *  * Returns nothing.  */
end_comment

begin_function
name|void
name|mps_mapping_check_devices
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|u32
name|i
decl_stmt|;
name|struct
name|dev_mapping_table
modifier|*
name|mt_entry
decl_stmt|;
name|struct
name|mps_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|mps_softc
operator|*
operator|)
name|data
decl_stmt|;
name|u16
name|ioc_pg8_flags
init|=
name|le16toh
argument_list|(
name|sc
operator|->
name|ioc_pg8
operator|.
name|Flags
argument_list|)
decl_stmt|;
name|struct
name|enc_mapping_table
modifier|*
name|et_entry
decl_stmt|;
name|u32
name|start_idx
init|=
literal|0
decl_stmt|,
name|end_idx
init|=
literal|0
decl_stmt|;
name|u8
name|stop_device_checks
init|=
literal|0
decl_stmt|;
name|MPS_FUNCTRACE
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Clear this flag so that this function is never called again except 	 * within this function if the check needs to be done again. The 	 * purpose is to check for missing devices that are currently in the 	 * mapping table so do this only at driver init after discovery. 	 */
name|sc
operator|->
name|track_mapping_events
operator|=
literal|0
expr_stmt|;
comment|/* 	 * callout synchronization 	 * This is used to prevent race conditions for the callout.  	 */
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_MAPPING
argument_list|,
literal|"%s: Start check for missing devices.\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sc
operator|->
name|mps_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|callout_pending
argument_list|(
operator|&
name|sc
operator|->
name|device_check_callout
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|callout_active
argument_list|(
operator|&
name|sc
operator|->
name|device_check_callout
argument_list|)
operator|)
condition|)
block|{
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_MAPPING
argument_list|,
literal|"%s: Device Check Callout is "
literal|"already pending or not active.\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return;
block|}
name|callout_deactivate
argument_list|(
operator|&
name|sc
operator|->
name|device_check_callout
argument_list|)
expr_stmt|;
comment|/* 	 * Use callout to check if any devices in the mapping table have been 	 * processed yet. If ALL devices are marked as not init_complete, no 	 * devices have been processed and mapped. Until devices are mapped 	 * there's no reason to mark them as missing. Continue resetting this 	 * callout until devices have been mapped. 	 */
if|if
condition|(
operator|(
name|ioc_pg8_flags
operator|&
name|MPI2_IOCPAGE8_FLAGS_MASK_MAPPING_MODE
operator|)
operator|==
name|MPI2_IOCPAGE8_FLAGS_ENCLOSURE_SLOT_MAPPING
condition|)
block|{
name|et_entry
operator|=
name|sc
operator|->
name|enclosure_table
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_enc_table_entries
condition|;
name|i
operator|++
operator|,
name|et_entry
operator|++
control|)
block|{
if|if
condition|(
name|et_entry
operator|->
name|init_complete
condition|)
block|{
name|stop_device_checks
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|ioc_pg8_flags
operator|&
name|MPI2_IOCPAGE8_FLAGS_MASK_MAPPING_MODE
operator|)
operator|==
name|MPI2_IOCPAGE8_FLAGS_DEVICE_PERSISTENCE_MAPPING
condition|)
block|{
name|mt_entry
operator|=
name|sc
operator|->
name|mapping_table
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|max_devices
condition|;
name|i
operator|++
operator|,
name|mt_entry
operator|++
control|)
block|{
if|if
condition|(
name|mt_entry
operator|->
name|init_complete
condition|)
block|{
name|stop_device_checks
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* 	 * Setup another callout check after a delay. Keep doing this until 	 * devices are mapped. 	 */
if|if
condition|(
operator|!
name|stop_device_checks
condition|)
block|{
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_MAPPING
argument_list|,
literal|"%s: No devices have been mapped. "
literal|"Reset callout to check again after a %d second delay.\n"
argument_list|,
name|__func__
argument_list|,
name|MPS_MISSING_CHECK_DELAY
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|device_check_callout
argument_list|,
name|MPS_MISSING_CHECK_DELAY
operator|*
name|hz
argument_list|,
name|mps_mapping_check_devices
argument_list|,
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_MAPPING
argument_list|,
literal|"%s: Device check complete.\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* 	 * Depending on the mapping type, check if devices have been processed 	 * and update their missing counts if not processed. 	 */
if|if
condition|(
operator|(
name|ioc_pg8_flags
operator|&
name|MPI2_IOCPAGE8_FLAGS_MASK_MAPPING_MODE
operator|)
operator|==
name|MPI2_IOCPAGE8_FLAGS_ENCLOSURE_SLOT_MAPPING
condition|)
block|{
name|et_entry
operator|=
name|sc
operator|->
name|enclosure_table
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_enc_table_entries
condition|;
name|i
operator|++
operator|,
name|et_entry
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|et_entry
operator|->
name|init_complete
condition|)
block|{
if|if
condition|(
name|et_entry
operator|->
name|missing_count
operator|<
name|MPS_MAX_MISSING_COUNT
condition|)
block|{
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_MAPPING
argument_list|,
literal|"%s: "
literal|"Enclosure %d is missing from the "
literal|"topology. Update its missing "
literal|"count.\n"
argument_list|,
name|__func__
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|et_entry
operator|->
name|missing_count
operator|++
expr_stmt|;
if|if
condition|(
name|et_entry
operator|->
name|dpm_entry_num
operator|!=
name|MPS_DPM_BAD_IDX
condition|)
block|{
name|_mapping_commit_enc_entry
argument_list|(
name|sc
argument_list|,
name|et_entry
argument_list|)
expr_stmt|;
block|}
block|}
name|et_entry
operator|->
name|init_complete
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|sc
operator|->
name|ir_firmware
condition|)
return|return;
name|_mapping_get_ir_maprange
argument_list|(
name|sc
argument_list|,
operator|&
name|start_idx
argument_list|,
operator|&
name|end_idx
argument_list|)
expr_stmt|;
name|mt_entry
operator|=
operator|&
name|sc
operator|->
name|mapping_table
index|[
name|start_idx
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ioc_pg8_flags
operator|&
name|MPI2_IOCPAGE8_FLAGS_MASK_MAPPING_MODE
operator|)
operator|==
name|MPI2_IOCPAGE8_FLAGS_DEVICE_PERSISTENCE_MAPPING
condition|)
block|{
name|start_idx
operator|=
literal|0
expr_stmt|;
name|end_idx
operator|=
name|sc
operator|->
name|max_devices
operator|-
literal|1
expr_stmt|;
name|mt_entry
operator|=
name|sc
operator|->
name|mapping_table
expr_stmt|;
block|}
comment|/* 	 * The start and end indices have been set above according to the 	 * mapping type. Go through these mappings and update any entries that 	 * do not have the init_complete flag set, which means they are missing. 	 */
if|if
condition|(
name|end_idx
operator|==
literal|0
condition|)
return|return;
for|for
control|(
name|i
operator|=
name|start_idx
init|;
name|i
operator|<
operator|(
name|end_idx
operator|+
literal|1
operator|)
condition|;
name|i
operator|++
operator|,
name|mt_entry
operator|++
control|)
block|{
if|if
condition|(
name|mt_entry
operator|->
name|device_info
operator|&
name|MPS_DEV_RESERVED
operator|&&
operator|!
name|mt_entry
operator|->
name|physical_id
condition|)
name|mt_entry
operator|->
name|init_complete
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|mt_entry
operator|->
name|device_info
operator|&
name|MPS_DEV_RESERVED
condition|)
block|{
if|if
condition|(
operator|!
name|mt_entry
operator|->
name|init_complete
condition|)
block|{
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_MAPPING
argument_list|,
literal|"%s: Device in "
literal|"mapping table at index %d is missing from "
literal|"topology. Update its missing count.\n"
argument_list|,
name|__func__
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|mt_entry
operator|->
name|missing_count
operator|<
name|MPS_MAX_MISSING_COUNT
condition|)
block|{
name|mt_entry
operator|->
name|missing_count
operator|++
expr_stmt|;
if|if
condition|(
name|mt_entry
operator|->
name|dpm_entry_num
operator|!=
name|MPS_DPM_BAD_IDX
condition|)
block|{
name|_mapping_commit_map_entry
argument_list|(
name|sc
argument_list|,
name|mt_entry
argument_list|)
expr_stmt|;
block|}
block|}
name|mt_entry
operator|->
name|init_complete
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/**  * mps_mapping_initialize - initialize mapping tables  * @sc: per adapter object  *  * Read controller persitant mapping tables into internal data area.  *  * Return 0 for success or non-zero for failure.  */
end_comment

begin_function
name|int
name|mps_mapping_initialize
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint16_t
name|volume_mapping_flags
decl_stmt|,
name|dpm_pg0_sz
decl_stmt|;
name|uint32_t
name|i
decl_stmt|;
name|Mpi2ConfigReply_t
name|mpi_reply
decl_stmt|;
name|int
name|error
decl_stmt|;
name|uint8_t
name|retry_count
decl_stmt|;
name|uint16_t
name|ioc_pg8_flags
init|=
name|le16toh
argument_list|(
name|sc
operator|->
name|ioc_pg8
operator|.
name|Flags
argument_list|)
decl_stmt|;
comment|/* The additional 1 accounts for the virtual enclosure 	 * created for the controller 	 */
name|sc
operator|->
name|max_enclosures
operator|=
name|sc
operator|->
name|facts
operator|->
name|MaxEnclosures
operator|+
literal|1
expr_stmt|;
name|sc
operator|->
name|max_expanders
operator|=
name|sc
operator|->
name|facts
operator|->
name|MaxSasExpanders
expr_stmt|;
name|sc
operator|->
name|max_volumes
operator|=
name|sc
operator|->
name|facts
operator|->
name|MaxVolumes
expr_stmt|;
name|sc
operator|->
name|max_devices
operator|=
name|sc
operator|->
name|facts
operator|->
name|MaxTargets
operator|+
name|sc
operator|->
name|max_volumes
expr_stmt|;
name|sc
operator|->
name|pending_map_events
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|num_enc_table_entries
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|num_rsvd_entries
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|max_dpm_entries
operator|=
name|sc
operator|->
name|ioc_pg8
operator|.
name|MaxPersistentEntries
expr_stmt|;
name|sc
operator|->
name|is_dpm_enable
operator|=
operator|(
name|sc
operator|->
name|max_dpm_entries
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|sc
operator|->
name|track_mapping_events
operator|=
literal|0
expr_stmt|;
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_MAPPING
argument_list|,
literal|"%s: Mapping table has a max of %d entries "
literal|"and DPM has a max of %d entries.\n"
argument_list|,
name|__func__
argument_list|,
name|sc
operator|->
name|max_devices
argument_list|,
name|sc
operator|->
name|max_dpm_entries
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioc_pg8_flags
operator|&
name|MPI2_IOCPAGE8_FLAGS_DISABLE_PERSISTENT_MAPPING
condition|)
name|sc
operator|->
name|is_dpm_enable
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ioc_pg8_flags
operator|&
name|MPI2_IOCPAGE8_FLAGS_RESERVED_TARGETID_0
condition|)
name|sc
operator|->
name|num_rsvd_entries
operator|=
literal|1
expr_stmt|;
name|volume_mapping_flags
operator|=
name|sc
operator|->
name|ioc_pg8
operator|.
name|IRVolumeMappingFlags
operator|&
name|MPI2_IOCPAGE8_IRFLAGS_MASK_VOLUME_MAPPING_MODE
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ir_firmware
operator|&&
operator|(
name|volume_mapping_flags
operator|==
name|MPI2_IOCPAGE8_IRFLAGS_LOW_VOLUME_MAPPING
operator|)
condition|)
name|sc
operator|->
name|num_rsvd_entries
operator|+=
name|sc
operator|->
name|max_volumes
expr_stmt|;
name|error
operator|=
name|mps_mapping_allocate_memory
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|max_devices
condition|;
name|i
operator|++
control|)
name|_mapping_clear_map_entry
argument_list|(
name|sc
operator|->
name|mapping_table
operator|+
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|max_enclosures
condition|;
name|i
operator|++
control|)
name|_mapping_clear_enc_entry
argument_list|(
name|sc
operator|->
name|enclosure_table
operator|+
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|max_devices
condition|;
name|i
operator|++
control|)
block|{
name|sc
operator|->
name|removal_table
index|[
name|i
index|]
operator|.
name|dev_handle
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|removal_table
index|[
name|i
index|]
operator|.
name|dpm_entry_num
operator|=
name|MPS_DPM_BAD_IDX
expr_stmt|;
block|}
name|memset
argument_list|(
name|sc
operator|->
name|dpm_entry_used
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|max_dpm_entries
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|sc
operator|->
name|dpm_flush_entry
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|max_dpm_entries
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|is_dpm_enable
condition|)
block|{
name|dpm_pg0_sz
operator|=
sizeof|sizeof
argument_list|(
name|MPI2_CONFIG_EXTENDED_PAGE_HEADER
argument_list|)
operator|+
operator|(
name|sc
operator|->
name|max_dpm_entries
operator|*
sizeof|sizeof
argument_list|(
name|MPI2_CONFIG_PAGE_DRIVER_MAP0_ENTRY
argument_list|)
operator|)
expr_stmt|;
name|retry_count
operator|=
literal|0
expr_stmt|;
name|retry_read_dpm
label|:
if|if
condition|(
name|mps_config_get_dpm_pg0
argument_list|(
name|sc
argument_list|,
operator|&
name|mpi_reply
argument_list|,
name|sc
operator|->
name|dpm_pg0
argument_list|,
name|dpm_pg0_sz
argument_list|)
condition|)
block|{
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_ERROR
operator||
name|MPS_MAPPING
argument_list|,
literal|"%s: DPM page "
literal|"read failed.\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|retry_count
operator|<
literal|3
condition|)
block|{
name|retry_count
operator|++
expr_stmt|;
goto|goto
name|retry_read_dpm
goto|;
block|}
name|sc
operator|->
name|is_dpm_enable
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sc
operator|->
name|is_dpm_enable
condition|)
name|_mapping_process_dpm_pg0
argument_list|(
name|sc
argument_list|)
expr_stmt|;
else|else
block|{
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_MAPPING
argument_list|,
literal|"%s: DPM processing is disabled. "
literal|"Device mappings will not persist across reboots or "
literal|"resets.\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|track_mapping_events
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * mps_mapping_exit - clear mapping table and associated memory  * @sc: per adapter object  *  * Returns nothing.  */
end_comment

begin_function
name|void
name|mps_mapping_exit
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|)
block|{
name|_mapping_flush_dpm_pages
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mps_mapping_free_memory
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * mps_mapping_get_tid - return the target id for sas device and handle  * @sc: per adapter object  * @sas_address: sas address of the device  * @handle: device handle  *  * Returns valid target ID on success or BAD_ID.  */
end_comment

begin_function
name|unsigned
name|int
name|mps_mapping_get_tid
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|uint64_t
name|sas_address
parameter_list|,
name|u16
name|handle
parameter_list|)
block|{
name|u32
name|map_idx
decl_stmt|;
name|struct
name|dev_mapping_table
modifier|*
name|mt_entry
decl_stmt|;
for|for
control|(
name|map_idx
operator|=
literal|0
init|;
name|map_idx
operator|<
name|sc
operator|->
name|max_devices
condition|;
name|map_idx
operator|++
control|)
block|{
name|mt_entry
operator|=
operator|&
name|sc
operator|->
name|mapping_table
index|[
name|map_idx
index|]
expr_stmt|;
if|if
condition|(
name|mt_entry
operator|->
name|dev_handle
operator|==
name|handle
operator|&&
name|mt_entry
operator|->
name|physical_id
operator|==
name|sas_address
condition|)
return|return
name|mt_entry
operator|->
name|id
return|;
block|}
return|return
name|MPS_MAP_BAD_ID
return|;
block|}
end_function

begin_comment
comment|/**  * mps_mapping_get_tid_from_handle - find a target id in mapping table using  * only the dev handle.  This is just a wrapper function for the local function  * _mapping_get_mt_idx_from_handle.  * @sc: per adapter object  * @handle: device handle  *  * Returns valid target ID on success or BAD_ID.  */
end_comment

begin_function
name|unsigned
name|int
name|mps_mapping_get_tid_from_handle
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|u16
name|handle
parameter_list|)
block|{
return|return
operator|(
name|_mapping_get_mt_idx_from_handle
argument_list|(
name|sc
argument_list|,
name|handle
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * mps_mapping_get_raid_tid - return the target id for raid device  * @sc: per adapter object  * @wwid: world wide identifier for raid volume  * @volHandle: volume device handle  *  * Returns valid target ID on success or BAD_ID.  */
end_comment

begin_function
name|unsigned
name|int
name|mps_mapping_get_raid_tid
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|u64
name|wwid
parameter_list|,
name|u16
name|volHandle
parameter_list|)
block|{
name|u32
name|start_idx
decl_stmt|,
name|end_idx
decl_stmt|,
name|map_idx
decl_stmt|;
name|struct
name|dev_mapping_table
modifier|*
name|mt_entry
decl_stmt|;
name|_mapping_get_ir_maprange
argument_list|(
name|sc
argument_list|,
operator|&
name|start_idx
argument_list|,
operator|&
name|end_idx
argument_list|)
expr_stmt|;
name|mt_entry
operator|=
operator|&
name|sc
operator|->
name|mapping_table
index|[
name|start_idx
index|]
expr_stmt|;
for|for
control|(
name|map_idx
operator|=
name|start_idx
init|;
name|map_idx
operator|<=
name|end_idx
condition|;
name|map_idx
operator|++
operator|,
name|mt_entry
operator|++
control|)
block|{
if|if
condition|(
name|mt_entry
operator|->
name|dev_handle
operator|==
name|volHandle
operator|&&
name|mt_entry
operator|->
name|physical_id
operator|==
name|wwid
condition|)
return|return
name|mt_entry
operator|->
name|id
return|;
block|}
return|return
name|MPS_MAP_BAD_ID
return|;
block|}
end_function

begin_comment
comment|/**  * mps_mapping_get_raid_tid_from_handle - find raid device in mapping table  * using only the volume dev handle.  This is just a wrapper function for the  * local function _mapping_get_ir_mt_idx_from_handle.  * @sc: per adapter object  * @volHandle: volume device handle  *  * Returns valid target ID on success or BAD_ID.  */
end_comment

begin_function
name|unsigned
name|int
name|mps_mapping_get_raid_tid_from_handle
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|u16
name|volHandle
parameter_list|)
block|{
return|return
operator|(
name|_mapping_get_ir_mt_idx_from_handle
argument_list|(
name|sc
argument_list|,
name|volHandle
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * mps_mapping_enclosure_dev_status_change_event - handle enclosure events  * @sc: per adapter object  * @event_data: event data payload  *  * Return nothing.  */
end_comment

begin_function
name|void
name|mps_mapping_enclosure_dev_status_change_event
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|Mpi2EventDataSasEnclDevStatusChange_t
modifier|*
name|event_data
parameter_list|)
block|{
name|u8
name|enc_idx
decl_stmt|,
name|missing_count
decl_stmt|;
name|struct
name|enc_mapping_table
modifier|*
name|et_entry
decl_stmt|;
name|Mpi2DriverMap0Entry_t
modifier|*
name|dpm_entry
decl_stmt|;
name|u16
name|ioc_pg8_flags
init|=
name|le16toh
argument_list|(
name|sc
operator|->
name|ioc_pg8
operator|.
name|Flags
argument_list|)
decl_stmt|;
name|u8
name|map_shift
init|=
name|MPI2_DRVMAP0_MAPINFO_SLOT_SHIFT
decl_stmt|;
name|u8
name|update_phy_bits
init|=
literal|0
decl_stmt|;
name|u32
name|saved_phy_bits
decl_stmt|;
name|uint64_t
name|temp64_var
decl_stmt|;
if|if
condition|(
operator|(
name|ioc_pg8_flags
operator|&
name|MPI2_IOCPAGE8_FLAGS_MASK_MAPPING_MODE
operator|)
operator|!=
name|MPI2_IOCPAGE8_FLAGS_ENCLOSURE_SLOT_MAPPING
condition|)
goto|goto
name|out
goto|;
name|dpm_entry
operator|=
operator|(
name|Mpi2DriverMap0Entry_t
operator|*
operator|)
operator|(
operator|(
name|u8
operator|*
operator|)
name|sc
operator|->
name|dpm_pg0
operator|+
sizeof|sizeof
argument_list|(
name|MPI2_CONFIG_EXTENDED_PAGE_HEADER
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|event_data
operator|->
name|ReasonCode
operator|==
name|MPI2_EVENT_SAS_ENCL_RC_ADDED
condition|)
block|{
if|if
condition|(
operator|!
name|event_data
operator|->
name|NumSlots
condition|)
block|{
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_ERROR
operator||
name|MPS_MAPPING
argument_list|,
literal|"%s: Enclosure "
literal|"with handle = 0x%x reported 0 slots.\n"
argument_list|,
name|__func__
argument_list|,
name|le16toh
argument_list|(
name|event_data
operator|->
name|EnclosureHandle
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|temp64_var
operator|=
name|event_data
operator|->
name|EnclosureLogicalID
operator|.
name|High
expr_stmt|;
name|temp64_var
operator|=
operator|(
name|temp64_var
operator|<<
literal|32
operator|)
operator||
name|event_data
operator|->
name|EnclosureLogicalID
operator|.
name|Low
expr_stmt|;
name|enc_idx
operator|=
name|_mapping_get_enc_idx_from_id
argument_list|(
name|sc
argument_list|,
name|temp64_var
argument_list|,
name|event_data
operator|->
name|PhyBits
argument_list|)
expr_stmt|;
comment|/* 		 * If the Added enclosure is already in the Enclosure Table, 		 * make sure that all the the enclosure info is up to date. If 		 * the enclosure was missing and has just been added back, or if 		 * the enclosure's Phy Bits have changed, clear the missing 		 * count and update the Phy Bits in the mapping table and in the 		 * DPM, if it's being used. 		 */
if|if
condition|(
name|enc_idx
operator|!=
name|MPS_ENCTABLE_BAD_IDX
condition|)
block|{
name|et_entry
operator|=
operator|&
name|sc
operator|->
name|enclosure_table
index|[
name|enc_idx
index|]
expr_stmt|;
if|if
condition|(
name|et_entry
operator|->
name|init_complete
operator|&&
operator|!
name|et_entry
operator|->
name|missing_count
condition|)
block|{
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_MAPPING
argument_list|,
literal|"%s: Enclosure %d "
literal|"is already present with handle = 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|enc_idx
argument_list|,
name|et_entry
operator|->
name|enc_handle
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|et_entry
operator|->
name|enc_handle
operator|=
name|le16toh
argument_list|(
name|event_data
operator|->
name|EnclosureHandle
argument_list|)
expr_stmt|;
name|et_entry
operator|->
name|start_slot
operator|=
name|le16toh
argument_list|(
name|event_data
operator|->
name|StartSlot
argument_list|)
expr_stmt|;
name|saved_phy_bits
operator|=
name|et_entry
operator|->
name|phy_bits
expr_stmt|;
name|et_entry
operator|->
name|phy_bits
operator||=
name|le32toh
argument_list|(
name|event_data
operator|->
name|PhyBits
argument_list|)
expr_stmt|;
if|if
condition|(
name|saved_phy_bits
operator|!=
name|et_entry
operator|->
name|phy_bits
condition|)
name|update_phy_bits
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|et_entry
operator|->
name|missing_count
operator|||
name|update_phy_bits
condition|)
block|{
name|et_entry
operator|->
name|missing_count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|is_dpm_enable
operator|&&
name|et_entry
operator|->
name|dpm_entry_num
operator|!=
name|MPS_DPM_BAD_IDX
condition|)
block|{
name|dpm_entry
operator|+=
name|et_entry
operator|->
name|dpm_entry_num
expr_stmt|;
name|missing_count
operator|=
call|(
name|u8
call|)
argument_list|(
name|dpm_entry
operator|->
name|MappingInformation
operator|&
name|MPI2_DRVMAP0_MAPINFO_MISSING_MASK
argument_list|)
expr_stmt|;
if|if
condition|(
name|missing_count
operator|||
name|update_phy_bits
condition|)
block|{
name|dpm_entry
operator|->
name|MappingInformation
operator|=
name|et_entry
operator|->
name|num_slots
expr_stmt|;
name|dpm_entry
operator|->
name|MappingInformation
operator|<<=
name|map_shift
expr_stmt|;
name|dpm_entry
operator|->
name|PhysicalBitsMapping
operator|=
name|et_entry
operator|->
name|phy_bits
expr_stmt|;
name|sc
operator|->
name|dpm_flush_entry
index|[
name|et_entry
operator|->
name|dpm_entry_num
index|]
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
comment|/* 			 * This is a new enclosure that is being added. 			 * Initialize the Enclosure Table entry. It will be 			 * finalized when a device is added for the enclosure 			 * and the enclosure has enough space in the Mapping 			 * Table to map its devices. 			 */
name|enc_idx
operator|=
name|sc
operator|->
name|num_enc_table_entries
expr_stmt|;
if|if
condition|(
name|enc_idx
operator|>=
name|sc
operator|->
name|max_enclosures
condition|)
block|{
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_ERROR
operator||
name|MPS_MAPPING
argument_list|,
literal|"%s: "
literal|"Enclosure cannot be added to mapping "
literal|"table because it's full.\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|sc
operator|->
name|num_enc_table_entries
operator|++
expr_stmt|;
name|et_entry
operator|=
operator|&
name|sc
operator|->
name|enclosure_table
index|[
name|enc_idx
index|]
expr_stmt|;
name|et_entry
operator|->
name|enc_handle
operator|=
name|le16toh
argument_list|(
name|event_data
operator|->
name|EnclosureHandle
argument_list|)
expr_stmt|;
name|et_entry
operator|->
name|enclosure_id
operator|=
name|le64toh
argument_list|(
name|event_data
operator|->
name|EnclosureLogicalID
operator|.
name|High
argument_list|)
expr_stmt|;
name|et_entry
operator|->
name|enclosure_id
operator|=
operator|(
operator|(
name|et_entry
operator|->
name|enclosure_id
operator|<<
literal|32
operator|)
operator||
name|le64toh
argument_list|(
name|event_data
operator|->
name|EnclosureLogicalID
operator|.
name|Low
argument_list|)
operator|)
expr_stmt|;
name|et_entry
operator|->
name|start_index
operator|=
name|MPS_MAPTABLE_BAD_IDX
expr_stmt|;
name|et_entry
operator|->
name|dpm_entry_num
operator|=
name|MPS_DPM_BAD_IDX
expr_stmt|;
name|et_entry
operator|->
name|num_slots
operator|=
name|le16toh
argument_list|(
name|event_data
operator|->
name|NumSlots
argument_list|)
expr_stmt|;
name|et_entry
operator|->
name|start_slot
operator|=
name|le16toh
argument_list|(
name|event_data
operator|->
name|StartSlot
argument_list|)
expr_stmt|;
name|et_entry
operator|->
name|phy_bits
operator|=
name|le32toh
argument_list|(
name|event_data
operator|->
name|PhyBits
argument_list|)
expr_stmt|;
block|}
name|et_entry
operator|->
name|init_complete
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|event_data
operator|->
name|ReasonCode
operator|==
name|MPI2_EVENT_SAS_ENCL_RC_NOT_RESPONDING
condition|)
block|{
comment|/* 		 * An enclosure was removed. Update its missing count and then 		 * update the DPM entry with the new missing count for the 		 * enclosure. 		 */
name|enc_idx
operator|=
name|_mapping_get_enc_idx_from_handle
argument_list|(
name|sc
argument_list|,
name|le16toh
argument_list|(
name|event_data
operator|->
name|EnclosureHandle
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|enc_idx
operator|==
name|MPS_ENCTABLE_BAD_IDX
condition|)
block|{
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_ERROR
operator||
name|MPS_MAPPING
argument_list|,
literal|"%s: Cannot "
literal|"unmap enclosure %d because it has already been "
literal|"deleted.\n"
argument_list|,
name|__func__
argument_list|,
name|enc_idx
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|et_entry
operator|=
operator|&
name|sc
operator|->
name|enclosure_table
index|[
name|enc_idx
index|]
expr_stmt|;
if|if
condition|(
name|et_entry
operator|->
name|missing_count
operator|<
name|MPS_MAX_MISSING_COUNT
condition|)
name|et_entry
operator|->
name|missing_count
operator|++
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|is_dpm_enable
operator|&&
name|et_entry
operator|->
name|dpm_entry_num
operator|!=
name|MPS_DPM_BAD_IDX
condition|)
block|{
name|dpm_entry
operator|+=
name|et_entry
operator|->
name|dpm_entry_num
expr_stmt|;
name|dpm_entry
operator|->
name|MappingInformation
operator|=
name|et_entry
operator|->
name|num_slots
expr_stmt|;
name|dpm_entry
operator|->
name|MappingInformation
operator|<<=
name|map_shift
expr_stmt|;
name|dpm_entry
operator|->
name|MappingInformation
operator||=
name|et_entry
operator|->
name|missing_count
expr_stmt|;
name|sc
operator|->
name|dpm_flush_entry
index|[
name|et_entry
operator|->
name|dpm_entry_num
index|]
operator|=
literal|1
expr_stmt|;
block|}
name|et_entry
operator|->
name|init_complete
operator|=
literal|1
expr_stmt|;
block|}
name|out
label|:
name|_mapping_flush_dpm_pages
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|pending_map_events
condition|)
name|sc
operator|->
name|pending_map_events
operator|--
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * mps_mapping_topology_change_event - handle topology change events  * @sc: per adapter object  * @event_data: event data payload  *  * Returns nothing.  */
end_comment

begin_function
name|void
name|mps_mapping_topology_change_event
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|Mpi2EventDataSasTopologyChangeList_t
modifier|*
name|event_data
parameter_list|)
block|{
name|struct
name|_map_topology_change
name|topo_change
decl_stmt|;
name|struct
name|_map_phy_change
modifier|*
name|phy_change
decl_stmt|;
name|Mpi2EventSasTopoPhyEntry_t
modifier|*
name|event_phy_change
decl_stmt|;
name|u8
name|i
decl_stmt|,
name|num_entries
decl_stmt|;
name|topo_change
operator|.
name|enc_handle
operator|=
name|le16toh
argument_list|(
name|event_data
operator|->
name|EnclosureHandle
argument_list|)
expr_stmt|;
name|topo_change
operator|.
name|exp_handle
operator|=
name|le16toh
argument_list|(
name|event_data
operator|->
name|ExpanderDevHandle
argument_list|)
expr_stmt|;
name|num_entries
operator|=
name|event_data
operator|->
name|NumEntries
expr_stmt|;
name|topo_change
operator|.
name|num_entries
operator|=
name|num_entries
expr_stmt|;
name|topo_change
operator|.
name|start_phy_num
operator|=
name|event_data
operator|->
name|StartPhyNum
expr_stmt|;
name|topo_change
operator|.
name|num_phys
operator|=
name|event_data
operator|->
name|NumPhys
expr_stmt|;
name|topo_change
operator|.
name|exp_status
operator|=
name|event_data
operator|->
name|ExpStatus
expr_stmt|;
name|event_phy_change
operator|=
name|event_data
operator|->
name|PHY
expr_stmt|;
name|topo_change
operator|.
name|phy_details
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|num_entries
condition|)
goto|goto
name|out
goto|;
name|phy_change
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|_map_phy_change
argument_list|)
operator|*
name|num_entries
argument_list|,
name|M_MPT2
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|topo_change
operator|.
name|phy_details
operator|=
name|phy_change
expr_stmt|;
if|if
condition|(
operator|!
name|phy_change
condition|)
goto|goto
name|out
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_entries
condition|;
name|i
operator|++
operator|,
name|event_phy_change
operator|++
operator|,
name|phy_change
operator|++
control|)
block|{
name|phy_change
operator|->
name|dev_handle
operator|=
name|le16toh
argument_list|(
name|event_phy_change
operator|->
name|AttachedDevHandle
argument_list|)
expr_stmt|;
name|phy_change
operator|->
name|reason
operator|=
name|event_phy_change
operator|->
name|PhyStatus
operator|&
name|MPI2_EVENT_SAS_TOPO_RC_MASK
expr_stmt|;
block|}
name|_mapping_update_missing_count
argument_list|(
name|sc
argument_list|,
operator|&
name|topo_change
argument_list|)
expr_stmt|;
name|_mapping_get_dev_info
argument_list|(
name|sc
argument_list|,
operator|&
name|topo_change
argument_list|)
expr_stmt|;
name|_mapping_clear_removed_entries
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|_mapping_add_new_device
argument_list|(
name|sc
argument_list|,
operator|&
name|topo_change
argument_list|)
expr_stmt|;
name|out
label|:
name|free
argument_list|(
name|topo_change
operator|.
name|phy_details
argument_list|,
name|M_MPT2
argument_list|)
expr_stmt|;
name|_mapping_flush_dpm_pages
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|pending_map_events
condition|)
name|sc
operator|->
name|pending_map_events
operator|--
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * mps_mapping_ir_config_change_event - handle IR config change list events  * @sc: per adapter object  * @event_data: event data payload  *  * Returns nothing.  */
end_comment

begin_function
name|void
name|mps_mapping_ir_config_change_event
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|Mpi2EventDataIrConfigChangeList_t
modifier|*
name|event_data
parameter_list|)
block|{
name|Mpi2EventIrConfigElement_t
modifier|*
name|element
decl_stmt|;
name|int
name|i
decl_stmt|;
name|u64
modifier|*
name|wwid_table
decl_stmt|;
name|u32
name|map_idx
decl_stmt|,
name|flags
decl_stmt|;
name|struct
name|dev_mapping_table
modifier|*
name|mt_entry
decl_stmt|;
name|u16
name|element_flags
decl_stmt|;
name|wwid_table
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|u64
argument_list|)
operator|*
name|event_data
operator|->
name|NumElements
argument_list|,
name|M_MPT2
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|wwid_table
condition|)
goto|goto
name|out
goto|;
name|element
operator|=
operator|(
name|Mpi2EventIrConfigElement_t
operator|*
operator|)
operator|&
name|event_data
operator|->
name|ConfigElement
index|[
literal|0
index|]
expr_stmt|;
name|flags
operator|=
name|le32toh
argument_list|(
name|event_data
operator|->
name|Flags
argument_list|)
expr_stmt|;
comment|/* 	 * For volume changes, get the WWID for the volume and put it in a 	 * table to be used in the processing of the IR change event. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|event_data
operator|->
name|NumElements
condition|;
name|i
operator|++
operator|,
name|element
operator|++
control|)
block|{
name|element_flags
operator|=
name|le16toh
argument_list|(
name|element
operator|->
name|ElementFlags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|element
operator|->
name|ReasonCode
operator|!=
name|MPI2_EVENT_IR_CHANGE_RC_ADDED
operator|)
operator|&&
operator|(
name|element
operator|->
name|ReasonCode
operator|!=
name|MPI2_EVENT_IR_CHANGE_RC_REMOVED
operator|)
operator|&&
operator|(
name|element
operator|->
name|ReasonCode
operator|!=
name|MPI2_EVENT_IR_CHANGE_RC_NO_CHANGE
operator|)
operator|&&
operator|(
name|element
operator|->
name|ReasonCode
operator|!=
name|MPI2_EVENT_IR_CHANGE_RC_VOLUME_CREATED
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
name|element_flags
operator|&
name|MPI2_EVENT_IR_CHANGE_EFLAGS_ELEMENT_TYPE_MASK
operator|)
operator|==
name|MPI2_EVENT_IR_CHANGE_EFLAGS_VOLUME_ELEMENT
condition|)
block|{
name|mps_config_get_volume_wwid
argument_list|(
name|sc
argument_list|,
name|le16toh
argument_list|(
name|element
operator|->
name|VolDevHandle
argument_list|)
argument_list|,
operator|&
name|wwid_table
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Check the ReasonCode for each element in the IR event and Add/Remove 	 * Volumes or Physical Disks of Volumes to/from the mapping table. Use 	 * the WWIDs gotten above in wwid_table. 	 */
if|if
condition|(
name|flags
operator|==
name|MPI2_EVENT_IR_CHANGE_FLAGS_FOREIGN_CONFIG
condition|)
goto|goto
name|out
goto|;
else|else
block|{
name|element
operator|=
operator|(
name|Mpi2EventIrConfigElement_t
operator|*
operator|)
operator|&
name|event_data
operator|->
name|ConfigElement
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|event_data
operator|->
name|NumElements
condition|;
name|i
operator|++
operator|,
name|element
operator|++
control|)
block|{
if|if
condition|(
name|element
operator|->
name|ReasonCode
operator|==
name|MPI2_EVENT_IR_CHANGE_RC_ADDED
operator|||
name|element
operator|->
name|ReasonCode
operator|==
name|MPI2_EVENT_IR_CHANGE_RC_VOLUME_CREATED
condition|)
block|{
name|map_idx
operator|=
name|_mapping_get_ir_mt_idx_from_wwid
argument_list|(
name|sc
argument_list|,
name|wwid_table
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|map_idx
operator|!=
name|MPS_MAPTABLE_BAD_IDX
condition|)
block|{
comment|/* 					 * The volume is already in the mapping 					 * table. Just update it's info. 					 */
name|mt_entry
operator|=
operator|&
name|sc
operator|->
name|mapping_table
index|[
name|map_idx
index|]
expr_stmt|;
name|mt_entry
operator|->
name|id
operator|=
name|map_idx
expr_stmt|;
name|mt_entry
operator|->
name|dev_handle
operator|=
name|le16toh
argument_list|(
name|element
operator|->
name|VolDevHandle
argument_list|)
expr_stmt|;
name|mt_entry
operator|->
name|device_info
operator|=
name|MPS_DEV_RESERVED
operator||
name|MPS_MAP_IN_USE
expr_stmt|;
name|_mapping_update_ir_missing_cnt
argument_list|(
name|sc
argument_list|,
name|map_idx
argument_list|,
name|element
argument_list|,
name|wwid_table
index|[
name|i
index|]
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 				 * Volume is not in mapping table yet. Find a 				 * free entry in the mapping table at the 				 * volume mapping locations. If no entries are 				 * available, this is an error because it means 				 * there are more volumes than can be mapped 				 * and that should never happen for volumes. 				 */
name|map_idx
operator|=
name|_mapping_get_free_ir_mt_idx
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|map_idx
operator|==
name|MPS_MAPTABLE_BAD_IDX
condition|)
block|{
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_ERROR
operator||
name|MPS_MAPPING
argument_list|,
literal|"%s: failed to add the volume with "
literal|"handle 0x%04x because there is no "
literal|"free space available in the "
literal|"mapping table\n"
argument_list|,
name|__func__
argument_list|,
name|le16toh
argument_list|(
name|element
operator|->
name|VolDevHandle
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|mt_entry
operator|=
operator|&
name|sc
operator|->
name|mapping_table
index|[
name|map_idx
index|]
expr_stmt|;
name|mt_entry
operator|->
name|physical_id
operator|=
name|wwid_table
index|[
name|i
index|]
expr_stmt|;
name|mt_entry
operator|->
name|id
operator|=
name|map_idx
expr_stmt|;
name|mt_entry
operator|->
name|dev_handle
operator|=
name|le16toh
argument_list|(
name|element
operator|->
name|VolDevHandle
argument_list|)
expr_stmt|;
name|mt_entry
operator|->
name|device_info
operator|=
name|MPS_DEV_RESERVED
operator||
name|MPS_MAP_IN_USE
expr_stmt|;
name|_mapping_update_ir_missing_cnt
argument_list|(
name|sc
argument_list|,
name|map_idx
argument_list|,
name|element
argument_list|,
name|wwid_table
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|element
operator|->
name|ReasonCode
operator|==
name|MPI2_EVENT_IR_CHANGE_RC_REMOVED
condition|)
block|{
name|map_idx
operator|=
name|_mapping_get_ir_mt_idx_from_wwid
argument_list|(
name|sc
argument_list|,
name|wwid_table
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|map_idx
operator|==
name|MPS_MAPTABLE_BAD_IDX
condition|)
block|{
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_MAPPING
argument_list|,
literal|"%s: Failed "
literal|"to remove a volume because it has "
literal|"already been removed.\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|_mapping_update_ir_missing_cnt
argument_list|(
name|sc
argument_list|,
name|map_idx
argument_list|,
name|element
argument_list|,
name|wwid_table
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|element
operator|->
name|ReasonCode
operator|==
name|MPI2_EVENT_IR_CHANGE_RC_VOLUME_DELETED
condition|)
block|{
name|map_idx
operator|=
name|_mapping_get_mt_idx_from_handle
argument_list|(
name|sc
argument_list|,
name|le16toh
argument_list|(
name|element
operator|->
name|VolDevHandle
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|map_idx
operator|==
name|MPS_MAPTABLE_BAD_IDX
condition|)
block|{
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_MAPPING
argument_list|,
literal|"%s: Failed "
literal|"to remove volume with handle "
literal|"0x%04x because it has already "
literal|"been removed.\n"
argument_list|,
name|__func__
argument_list|,
name|le16toh
argument_list|(
name|element
operator|->
name|VolDevHandle
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|mt_entry
operator|=
operator|&
name|sc
operator|->
name|mapping_table
index|[
name|map_idx
index|]
expr_stmt|;
name|_mapping_update_ir_missing_cnt
argument_list|(
name|sc
argument_list|,
name|map_idx
argument_list|,
name|element
argument_list|,
name|mt_entry
operator|->
name|physical_id
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|out
label|:
name|_mapping_flush_dpm_pages
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|wwid_table
argument_list|,
name|M_MPT2
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|pending_map_events
condition|)
name|sc
operator|->
name|pending_map_events
operator|--
expr_stmt|;
block|}
end_function

begin_function
name|int
name|mps_mapping_dump
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|mps_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|dev_mapping_table
modifier|*
name|mt_entry
decl_stmt|;
name|struct
name|sbuf
name|sbuf
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|mps_softc
operator|*
operator|)
name|arg1
expr_stmt|;
name|error
operator|=
name|sysctl_wire_old_buffer
argument_list|(
name|req
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|sbuf_new_for_sysctl
argument_list|(
operator|&
name|sbuf
argument_list|,
name|NULL
argument_list|,
literal|128
argument_list|,
name|req
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
operator|&
name|sbuf
argument_list|,
literal|"\nindex physical_id       handle id\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|max_devices
condition|;
name|i
operator|++
control|)
block|{
name|mt_entry
operator|=
operator|&
name|sc
operator|->
name|mapping_table
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|mt_entry
operator|->
name|physical_id
operator|==
literal|0
condition|)
continue|continue;
name|sbuf_printf
argument_list|(
operator|&
name|sbuf
argument_list|,
literal|"%4d  %jx  %04x   %hd\n"
argument_list|,
name|i
argument_list|,
name|mt_entry
operator|->
name|physical_id
argument_list|,
name|mt_entry
operator|->
name|dev_handle
argument_list|,
name|mt_entry
operator|->
name|id
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|sbuf_finish
argument_list|(
operator|&
name|sbuf
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
operator|&
name|sbuf
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|mps_mapping_encl_dump
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|mps_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|enc_mapping_table
modifier|*
name|enc_entry
decl_stmt|;
name|struct
name|sbuf
name|sbuf
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|mps_softc
operator|*
operator|)
name|arg1
expr_stmt|;
name|error
operator|=
name|sysctl_wire_old_buffer
argument_list|(
name|req
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|sbuf_new_for_sysctl
argument_list|(
operator|&
name|sbuf
argument_list|,
name|NULL
argument_list|,
literal|128
argument_list|,
name|req
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
operator|&
name|sbuf
argument_list|,
literal|"\nindex enclosure_id      handle map_index\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|max_enclosures
condition|;
name|i
operator|++
control|)
block|{
name|enc_entry
operator|=
operator|&
name|sc
operator|->
name|enclosure_table
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|enc_entry
operator|->
name|enclosure_id
operator|==
literal|0
condition|)
continue|continue;
name|sbuf_printf
argument_list|(
operator|&
name|sbuf
argument_list|,
literal|"%4d  %jx  %04x   %d\n"
argument_list|,
name|i
argument_list|,
name|enc_entry
operator|->
name|enclosure_id
argument_list|,
name|enc_entry
operator|->
name|enc_handle
argument_list|,
name|enc_entry
operator|->
name|start_index
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|sbuf_finish
argument_list|(
operator|&
name|sbuf
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
operator|&
name|sbuf
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

end_unit

