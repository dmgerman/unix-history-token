begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2011-2015 LSI Corp.  * Copyright (c) 2013-2015 Avago Technologies  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * Avago Technologies (LSI) MPT-Fusion Host Adapter FreeBSD  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* TODO Move headers to mpsvar */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/eventhandler.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<dev/mps/mpi/mpi2_type.h>
end_include

begin_include
include|#
directive|include
file|<dev/mps/mpi/mpi2.h>
end_include

begin_include
include|#
directive|include
file|<dev/mps/mpi/mpi2_ioc.h>
end_include

begin_include
include|#
directive|include
file|<dev/mps/mpi/mpi2_sas.h>
end_include

begin_include
include|#
directive|include
file|<dev/mps/mpi/mpi2_cnfg.h>
end_include

begin_include
include|#
directive|include
file|<dev/mps/mpi/mpi2_init.h>
end_include

begin_include
include|#
directive|include
file|<dev/mps/mpi/mpi2_tool.h>
end_include

begin_include
include|#
directive|include
file|<dev/mps/mps_ioctl.h>
end_include

begin_include
include|#
directive|include
file|<dev/mps/mpsvar.h>
end_include

begin_comment
comment|/**  * mps_config_get_ioc_pg8 - obtain ioc page 8  * @sc: per adapter object  * @mpi_reply: reply mf payload returned from firmware  * @config_page: contents of the config page  * Context: sleep.  *  * Returns 0 for success, non-zero for failure.  */
end_comment

begin_function
name|int
name|mps_config_get_ioc_pg8
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|Mpi2ConfigReply_t
modifier|*
name|mpi_reply
parameter_list|,
name|Mpi2IOCPage8_t
modifier|*
name|config_page
parameter_list|)
block|{
name|MPI2_CONFIG_REQUEST
modifier|*
name|request
decl_stmt|;
name|MPI2_CONFIG_REPLY
modifier|*
name|reply
decl_stmt|;
name|struct
name|mps_command
modifier|*
name|cm
decl_stmt|;
name|MPI2_CONFIG_PAGE_IOC_8
modifier|*
name|page
init|=
name|NULL
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|u16
name|ioc_status
decl_stmt|;
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_TRACE
argument_list|,
literal|"%s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cm
operator|=
name|mps_alloc_command
argument_list|(
name|sc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: command alloc failed @ line %d\n"
argument_list|,
name|__func__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|error
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|request
operator|=
operator|(
name|MPI2_CONFIG_REQUEST
operator|*
operator|)
name|cm
operator|->
name|cm_req
expr_stmt|;
name|bzero
argument_list|(
name|request
argument_list|,
sizeof|sizeof
argument_list|(
name|MPI2_CONFIG_REQUEST
argument_list|)
argument_list|)
expr_stmt|;
name|request
operator|->
name|Function
operator|=
name|MPI2_FUNCTION_CONFIG
expr_stmt|;
name|request
operator|->
name|Action
operator|=
name|MPI2_CONFIG_ACTION_PAGE_HEADER
expr_stmt|;
name|request
operator|->
name|Header
operator|.
name|PageType
operator|=
name|MPI2_CONFIG_PAGETYPE_IOC
expr_stmt|;
name|request
operator|->
name|Header
operator|.
name|PageNumber
operator|=
literal|8
expr_stmt|;
name|request
operator|->
name|Header
operator|.
name|PageVersion
operator|=
name|MPI2_IOCPAGE8_PAGEVERSION
expr_stmt|;
name|cm
operator|->
name|cm_desc
operator|.
name|Default
operator|.
name|RequestFlags
operator|=
name|MPI2_REQ_DESCRIPT_FLAGS_DEFAULT_TYPE
expr_stmt|;
name|cm
operator|->
name|cm_data
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|mps_wait_command
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|,
literal|60
argument_list|,
name|CAN_SLEEP
argument_list|)
expr_stmt|;
name|reply
operator|=
operator|(
name|MPI2_CONFIG_REPLY
operator|*
operator|)
name|cm
operator|->
name|cm_reply
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|(
name|reply
operator|==
name|NULL
operator|)
condition|)
block|{
comment|/* FIXME */
comment|/* 		 * If the request returns an error then we need to do a diag 		 * reset 		 */
name|printf
argument_list|(
literal|"%s: request for header completed with error %d"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ioc_status
operator|=
name|le16toh
argument_list|(
name|reply
operator|->
name|IOCStatus
argument_list|)
operator|&
name|MPI2_IOCSTATUS_MASK
expr_stmt|;
name|bcopy
argument_list|(
name|reply
argument_list|,
name|mpi_reply
argument_list|,
sizeof|sizeof
argument_list|(
name|MPI2_CONFIG_REPLY
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioc_status
operator|!=
name|MPI2_IOCSTATUS_SUCCESS
condition|)
block|{
comment|/* FIXME */
comment|/* 		 * If the request returns an error then we need to do a diag 		 * reset 		 */
name|printf
argument_list|(
literal|"%s: header read with error; iocstatus = 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|ioc_status
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* We have to do free and alloc for the reply-free and reply-post 	 * counters to match - Need to review the reply FIFO handling. 	 */
name|mps_free_command
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cm
operator|=
name|mps_alloc_command
argument_list|(
name|sc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: command alloc failed @ line %d\n"
argument_list|,
name|__func__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|error
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|request
operator|=
operator|(
name|MPI2_CONFIG_REQUEST
operator|*
operator|)
name|cm
operator|->
name|cm_req
expr_stmt|;
name|bzero
argument_list|(
name|request
argument_list|,
sizeof|sizeof
argument_list|(
name|MPI2_CONFIG_REQUEST
argument_list|)
argument_list|)
expr_stmt|;
name|request
operator|->
name|Function
operator|=
name|MPI2_FUNCTION_CONFIG
expr_stmt|;
name|request
operator|->
name|Action
operator|=
name|MPI2_CONFIG_ACTION_PAGE_READ_CURRENT
expr_stmt|;
name|request
operator|->
name|Header
operator|.
name|PageType
operator|=
name|MPI2_CONFIG_PAGETYPE_IOC
expr_stmt|;
name|request
operator|->
name|Header
operator|.
name|PageNumber
operator|=
literal|8
expr_stmt|;
name|request
operator|->
name|Header
operator|.
name|PageVersion
operator|=
name|MPI2_IOCPAGE8_PAGEVERSION
expr_stmt|;
name|request
operator|->
name|Header
operator|.
name|PageLength
operator|=
name|mpi_reply
operator|->
name|Header
operator|.
name|PageLength
expr_stmt|;
name|cm
operator|->
name|cm_length
operator|=
name|le16toh
argument_list|(
name|mpi_reply
operator|->
name|Header
operator|.
name|PageLength
argument_list|)
operator|*
literal|4
expr_stmt|;
name|cm
operator|->
name|cm_sge
operator|=
operator|&
name|request
operator|->
name|PageBufferSGE
expr_stmt|;
name|cm
operator|->
name|cm_sglsize
operator|=
sizeof|sizeof
argument_list|(
name|MPI2_SGE_IO_UNION
argument_list|)
expr_stmt|;
name|cm
operator|->
name|cm_flags
operator|=
name|MPS_CM_FLAGS_SGE_SIMPLE
operator||
name|MPS_CM_FLAGS_DATAIN
expr_stmt|;
name|cm
operator|->
name|cm_desc
operator|.
name|Default
operator|.
name|RequestFlags
operator|=
name|MPI2_REQ_DESCRIPT_FLAGS_DEFAULT_TYPE
expr_stmt|;
name|page
operator|=
name|malloc
argument_list|(
operator|(
name|cm
operator|->
name|cm_length
operator|)
argument_list|,
name|M_MPT2
argument_list|,
name|M_ZERO
operator||
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|page
condition|)
block|{
name|printf
argument_list|(
literal|"%s: page alloc failed\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|cm
operator|->
name|cm_data
operator|=
name|page
expr_stmt|;
name|error
operator|=
name|mps_wait_command
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|,
literal|60
argument_list|,
name|CAN_SLEEP
argument_list|)
expr_stmt|;
name|reply
operator|=
operator|(
name|MPI2_CONFIG_REPLY
operator|*
operator|)
name|cm
operator|->
name|cm_reply
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|(
name|reply
operator|==
name|NULL
operator|)
condition|)
block|{
comment|/* FIXME */
comment|/* 		 * If the request returns an error then we need to do a diag 		 * reset 		 */
name|printf
argument_list|(
literal|"%s: request for page completed with error %d"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ioc_status
operator|=
name|le16toh
argument_list|(
name|reply
operator|->
name|IOCStatus
argument_list|)
operator|&
name|MPI2_IOCSTATUS_MASK
expr_stmt|;
name|bcopy
argument_list|(
name|reply
argument_list|,
name|mpi_reply
argument_list|,
sizeof|sizeof
argument_list|(
name|MPI2_CONFIG_REPLY
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioc_status
operator|!=
name|MPI2_IOCSTATUS_SUCCESS
condition|)
block|{
comment|/* FIXME */
comment|/* 		 * If the request returns an error then we need to do a diag 		 * reset 		 */
name|printf
argument_list|(
literal|"%s: page read with error; iocstatus = 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|ioc_status
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|bcopy
argument_list|(
name|page
argument_list|,
name|config_page
argument_list|,
name|MIN
argument_list|(
name|cm
operator|->
name|cm_length
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
name|Mpi2IOCPage8_t
argument_list|)
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|out
label|:
name|free
argument_list|(
name|page
argument_list|,
name|M_MPT2
argument_list|)
expr_stmt|;
if|if
condition|(
name|cm
condition|)
name|mps_free_command
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * mps_config_get_man_pg10 - obtain Manufacturing Page 10 data and set flags  *   accordingly.  Currently, this page does not need to return to caller.  * @sc: per adapter object  * @mpi_reply: reply mf payload returned from firmware  * Context: sleep.  *  * Returns 0 for success, non-zero for failure.  */
end_comment

begin_function
name|int
name|mps_config_get_man_pg10
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|Mpi2ConfigReply_t
modifier|*
name|mpi_reply
parameter_list|)
block|{
name|MPI2_CONFIG_REQUEST
modifier|*
name|request
decl_stmt|;
name|MPI2_CONFIG_REPLY
modifier|*
name|reply
decl_stmt|;
name|struct
name|mps_command
modifier|*
name|cm
decl_stmt|;
name|pMpi2ManufacturingPagePS_t
name|page
init|=
name|NULL
decl_stmt|;
name|uint32_t
modifier|*
name|pPS_info
decl_stmt|;
name|uint8_t
name|OEM_Value
init|=
literal|0
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|u16
name|ioc_status
decl_stmt|;
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_TRACE
argument_list|,
literal|"%s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cm
operator|=
name|mps_alloc_command
argument_list|(
name|sc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: command alloc failed @ line %d\n"
argument_list|,
name|__func__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|error
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|request
operator|=
operator|(
name|MPI2_CONFIG_REQUEST
operator|*
operator|)
name|cm
operator|->
name|cm_req
expr_stmt|;
name|bzero
argument_list|(
name|request
argument_list|,
sizeof|sizeof
argument_list|(
name|MPI2_CONFIG_REQUEST
argument_list|)
argument_list|)
expr_stmt|;
name|request
operator|->
name|Function
operator|=
name|MPI2_FUNCTION_CONFIG
expr_stmt|;
name|request
operator|->
name|Action
operator|=
name|MPI2_CONFIG_ACTION_PAGE_HEADER
expr_stmt|;
name|request
operator|->
name|Header
operator|.
name|PageType
operator|=
name|MPI2_CONFIG_PAGETYPE_MANUFACTURING
expr_stmt|;
name|request
operator|->
name|Header
operator|.
name|PageNumber
operator|=
literal|10
expr_stmt|;
name|request
operator|->
name|Header
operator|.
name|PageVersion
operator|=
name|MPI2_MANUFACTURING10_PAGEVERSION
expr_stmt|;
name|cm
operator|->
name|cm_desc
operator|.
name|Default
operator|.
name|RequestFlags
operator|=
name|MPI2_REQ_DESCRIPT_FLAGS_DEFAULT_TYPE
expr_stmt|;
name|cm
operator|->
name|cm_data
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * This page must be polled because the IOC isn't ready yet when this 	 * page is needed. 	 */
name|error
operator|=
name|mps_wait_command
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|,
literal|60
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|reply
operator|=
operator|(
name|MPI2_CONFIG_REPLY
operator|*
operator|)
name|cm
operator|->
name|cm_reply
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|(
name|reply
operator|==
name|NULL
operator|)
condition|)
block|{
comment|/* FIXME */
comment|/* If the poll returns error then we need to do diag reset */
name|printf
argument_list|(
literal|"%s: poll for header completed with error %d"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ioc_status
operator|=
name|le16toh
argument_list|(
name|reply
operator|->
name|IOCStatus
argument_list|)
operator|&
name|MPI2_IOCSTATUS_MASK
expr_stmt|;
name|bcopy
argument_list|(
name|reply
argument_list|,
name|mpi_reply
argument_list|,
sizeof|sizeof
argument_list|(
name|MPI2_CONFIG_REPLY
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioc_status
operator|!=
name|MPI2_IOCSTATUS_SUCCESS
condition|)
block|{
comment|/* FIXME */
comment|/* If the poll returns error then we need to do diag reset */
name|printf
argument_list|(
literal|"%s: header read with error; iocstatus = 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|ioc_status
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* We have to do free and alloc for the reply-free and reply-post 	 * counters to match - Need to review the reply FIFO handling. 	 */
name|mps_free_command
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cm
operator|=
name|mps_alloc_command
argument_list|(
name|sc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: command alloc failed @ line %d\n"
argument_list|,
name|__func__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|error
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|request
operator|=
operator|(
name|MPI2_CONFIG_REQUEST
operator|*
operator|)
name|cm
operator|->
name|cm_req
expr_stmt|;
name|bzero
argument_list|(
name|request
argument_list|,
sizeof|sizeof
argument_list|(
name|MPI2_CONFIG_REQUEST
argument_list|)
argument_list|)
expr_stmt|;
name|request
operator|->
name|Function
operator|=
name|MPI2_FUNCTION_CONFIG
expr_stmt|;
name|request
operator|->
name|Action
operator|=
name|MPI2_CONFIG_ACTION_PAGE_READ_CURRENT
expr_stmt|;
name|request
operator|->
name|Header
operator|.
name|PageType
operator|=
name|MPI2_CONFIG_PAGETYPE_MANUFACTURING
expr_stmt|;
name|request
operator|->
name|Header
operator|.
name|PageNumber
operator|=
literal|10
expr_stmt|;
name|request
operator|->
name|Header
operator|.
name|PageVersion
operator|=
name|MPI2_MANUFACTURING10_PAGEVERSION
expr_stmt|;
name|request
operator|->
name|Header
operator|.
name|PageLength
operator|=
name|mpi_reply
operator|->
name|Header
operator|.
name|PageLength
expr_stmt|;
name|cm
operator|->
name|cm_length
operator|=
name|le16toh
argument_list|(
name|mpi_reply
operator|->
name|Header
operator|.
name|PageLength
argument_list|)
operator|*
literal|4
expr_stmt|;
name|cm
operator|->
name|cm_sge
operator|=
operator|&
name|request
operator|->
name|PageBufferSGE
expr_stmt|;
name|cm
operator|->
name|cm_sglsize
operator|=
sizeof|sizeof
argument_list|(
name|MPI2_SGE_IO_UNION
argument_list|)
expr_stmt|;
name|cm
operator|->
name|cm_flags
operator|=
name|MPS_CM_FLAGS_SGE_SIMPLE
operator||
name|MPS_CM_FLAGS_DATAIN
expr_stmt|;
name|cm
operator|->
name|cm_desc
operator|.
name|Default
operator|.
name|RequestFlags
operator|=
name|MPI2_REQ_DESCRIPT_FLAGS_DEFAULT_TYPE
expr_stmt|;
name|page
operator|=
name|malloc
argument_list|(
name|MPS_MAN_PAGE10_SIZE
argument_list|,
name|M_MPT2
argument_list|,
name|M_ZERO
operator||
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|page
condition|)
block|{
name|printf
argument_list|(
literal|"%s: page alloc failed\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|cm
operator|->
name|cm_data
operator|=
name|page
expr_stmt|;
comment|/* 	 * This page must be polled because the IOC isn't ready yet when this 	 * page is needed. 	 */
name|error
operator|=
name|mps_wait_command
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|,
literal|60
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|reply
operator|=
operator|(
name|MPI2_CONFIG_REPLY
operator|*
operator|)
name|cm
operator|->
name|cm_reply
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|(
name|reply
operator|==
name|NULL
operator|)
condition|)
block|{
comment|/* FIXME */
comment|/* If the poll returns error then we need to do diag reset */
name|printf
argument_list|(
literal|"%s: poll for page completed with error %d"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ioc_status
operator|=
name|le16toh
argument_list|(
name|reply
operator|->
name|IOCStatus
argument_list|)
operator|&
name|MPI2_IOCSTATUS_MASK
expr_stmt|;
name|bcopy
argument_list|(
name|reply
argument_list|,
name|mpi_reply
argument_list|,
sizeof|sizeof
argument_list|(
name|MPI2_CONFIG_REPLY
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioc_status
operator|!=
name|MPI2_IOCSTATUS_SUCCESS
condition|)
block|{
comment|/* FIXME */
comment|/* If the poll returns error then we need to do diag reset */
name|printf
argument_list|(
literal|"%s: page read with error; iocstatus = 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|ioc_status
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * If OEM ID is unknown, fail the request. 	 */
name|sc
operator|->
name|WD_hide_expose
operator|=
name|MPS_WD_HIDE_ALWAYS
expr_stmt|;
name|OEM_Value
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|page
operator|->
name|ProductSpecificInfo
operator|&
literal|0x000000FF
argument_list|)
expr_stmt|;
if|if
condition|(
name|OEM_Value
operator|!=
name|MPS_WD_LSI_OEM
condition|)
block|{
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_FAULT
argument_list|,
literal|"Unknown OEM value for WarpDrive "
literal|"(0x%x)\n"
argument_list|,
name|OEM_Value
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * Set the phys disks hide/expose value. 	 */
name|pPS_info
operator|=
operator|&
name|page
operator|->
name|ProductSpecificInfo
expr_stmt|;
name|sc
operator|->
name|WD_hide_expose
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|pPS_info
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|WD_hide_expose
operator|&=
name|MPS_WD_HIDE_EXPOSE_MASK
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|WD_hide_expose
operator|!=
name|MPS_WD_HIDE_ALWAYS
operator|)
operator|&&
operator|(
name|sc
operator|->
name|WD_hide_expose
operator|!=
name|MPS_WD_EXPOSE_ALWAYS
operator|)
operator|&&
operator|(
name|sc
operator|->
name|WD_hide_expose
operator|!=
name|MPS_WD_HIDE_IF_VOLUME
operator|)
condition|)
block|{
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_FAULT
argument_list|,
literal|"Unknown value for WarpDrive "
literal|"hide/expose: 0x%x\n"
argument_list|,
name|sc
operator|->
name|WD_hide_expose
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|out
label|:
name|free
argument_list|(
name|page
argument_list|,
name|M_MPT2
argument_list|)
expr_stmt|;
if|if
condition|(
name|cm
condition|)
name|mps_free_command
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * mps_base_static_config_pages - static start of day config pages.  * @sc: per adapter object  *  * Return nothing.  */
end_comment

begin_function
name|void
name|mps_base_static_config_pages
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|)
block|{
name|Mpi2ConfigReply_t
name|mpi_reply
decl_stmt|;
name|int
name|retry
decl_stmt|;
name|retry
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|mps_config_get_ioc_pg8
argument_list|(
name|sc
argument_list|,
operator|&
name|mpi_reply
argument_list|,
operator|&
name|sc
operator|->
name|ioc_pg8
argument_list|)
condition|)
block|{
name|retry
operator|++
expr_stmt|;
if|if
condition|(
name|retry
operator|>
literal|5
condition|)
block|{
comment|/* We need to Handle this situation */
comment|/*FIXME*/
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/**  * mps_wd_config_pages - get info required to support WarpDrive.  This needs to  *    be called after discovery is complete to guarantee that IR info is there.  * @sc: per adapter object  *  * Return nothing.  */
end_comment

begin_function
name|void
name|mps_wd_config_pages
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|)
block|{
name|Mpi2ConfigReply_t
name|mpi_reply
decl_stmt|;
name|pMpi2RaidVolPage0_t
name|raid_vol_pg0
init|=
name|NULL
decl_stmt|;
name|Mpi2RaidPhysDiskPage0_t
name|phys_disk_pg0
decl_stmt|;
name|pMpi2RaidVol0PhysDisk_t
name|pRVPD
decl_stmt|;
name|uint32_t
name|stripe_size
decl_stmt|,
name|phys_disk_page_address
decl_stmt|;
name|uint16_t
name|block_size
decl_stmt|;
name|uint8_t
name|index
decl_stmt|,
name|stripe_exp
init|=
literal|0
decl_stmt|,
name|block_exp
init|=
literal|0
decl_stmt|;
comment|/* 	 * Get the WD settings from manufacturing page 10 if using a WD HBA. 	 * This will be used to determine if phys disks should always be 	 * hidden, hidden only if part of a WD volume, or never hidden.  Also, 	 * get the WD RAID Volume info and fail if volume does not exist or if 	 * volume does not meet the requirements for a WD volume.  No retry 	 * here.  Just default to HIDE ALWAYS if man Page10 fails, or clear WD 	 * Valid flag if Volume info fails. 	 */
name|sc
operator|->
name|WD_valid_config
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mps_flags
operator|&
name|MPS_FLAGS_WD_AVAILABLE
condition|)
block|{
if|if
condition|(
name|mps_config_get_man_pg10
argument_list|(
name|sc
argument_list|,
operator|&
name|mpi_reply
argument_list|)
condition|)
block|{
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_FAULT
argument_list|,
literal|"mps_config_get_man_pg10 failed! Using 0 (Hide "
literal|"Always) for WarpDrive hide/expose value.\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|WD_hide_expose
operator|=
name|MPS_WD_HIDE_ALWAYS
expr_stmt|;
block|}
comment|/* 		 * Get first RAID Volume Page0 using GET_NEXT_HANDLE. 		 */
name|raid_vol_pg0
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Mpi2RaidVolPage0_t
argument_list|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|Mpi2RaidVol0PhysDisk_t
argument_list|)
operator|*
name|MPS_MAX_DISKS_IN_VOL
operator|)
argument_list|,
name|M_MPT2
argument_list|,
name|M_ZERO
operator||
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|raid_vol_pg0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: page alloc failed\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|mps_config_get_raid_volume_pg0
argument_list|(
name|sc
argument_list|,
operator|&
name|mpi_reply
argument_list|,
name|raid_vol_pg0
argument_list|,
literal|0x0000FFFF
argument_list|)
condition|)
block|{
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_INFO
argument_list|,
literal|"mps_config_get_raid_volume_pg0 failed! Assuming "
literal|"WarpDrive IT mode.\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 		 * Check for valid WD configuration: 		 *   volume type is RAID0 		 *   number of phys disks in the volume is no more than 8 		 */
if|if
condition|(
operator|(
name|raid_vol_pg0
operator|->
name|VolumeType
operator|!=
name|MPI2_RAID_VOL_TYPE_RAID0
operator|)
operator|||
operator|(
name|raid_vol_pg0
operator|->
name|NumPhysDisks
operator|>
literal|8
operator|)
condition|)
block|{
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_FAULT
argument_list|,
literal|"Invalid WarpDrive configuration. Direct Drive I/O "
literal|"will not be used.\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 		 * Save the WD RAID data to be used during WD I/O. 		 */
name|sc
operator|->
name|DD_max_lba
operator|=
name|le64toh
argument_list|(
operator|(
name|uint64_t
operator|)
name|raid_vol_pg0
operator|->
name|MaxLBA
operator|.
name|High
operator|<<
literal|32
operator||
operator|(
name|uint64_t
operator|)
name|raid_vol_pg0
operator|->
name|MaxLBA
operator|.
name|Low
argument_list|)
expr_stmt|;
name|sc
operator|->
name|DD_num_phys_disks
operator|=
name|raid_vol_pg0
operator|->
name|NumPhysDisks
expr_stmt|;
name|sc
operator|->
name|DD_dev_handle
operator|=
name|raid_vol_pg0
operator|->
name|DevHandle
expr_stmt|;
name|sc
operator|->
name|DD_stripe_size
operator|=
name|raid_vol_pg0
operator|->
name|StripeSize
expr_stmt|;
name|sc
operator|->
name|DD_block_size
operator|=
name|raid_vol_pg0
operator|->
name|BlockSize
expr_stmt|;
comment|/* 		 * Find power of 2 of stripe size and set this as the exponent. 		 * Fail if stripe size is 0. 		 */
name|stripe_size
operator|=
name|raid_vol_pg0
operator|->
name|StripeSize
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
literal|32
condition|;
name|index
operator|++
control|)
block|{
if|if
condition|(
name|stripe_size
operator|&
literal|1
condition|)
break|break;
name|stripe_exp
operator|++
expr_stmt|;
name|stripe_size
operator|>>=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|index
operator|==
literal|32
condition|)
block|{
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_FAULT
argument_list|,
literal|"RAID Volume's stripe size is 0. Direct Drive I/O "
literal|"will not be used.\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|sc
operator|->
name|DD_stripe_exponent
operator|=
name|stripe_exp
expr_stmt|;
comment|/* 		 * Find power of 2 of block size and set this as the exponent. 		 * Fail if block size is 0. 		 */
name|block_size
operator|=
name|raid_vol_pg0
operator|->
name|BlockSize
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
literal|16
condition|;
name|index
operator|++
control|)
block|{
if|if
condition|(
name|block_size
operator|&
literal|1
condition|)
break|break;
name|block_exp
operator|++
expr_stmt|;
name|block_size
operator|>>=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|index
operator|==
literal|16
condition|)
block|{
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_FAULT
argument_list|,
literal|"RAID Volume's block size is 0. Direct Drive I/O "
literal|"will not be used.\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|sc
operator|->
name|DD_block_exponent
operator|=
name|block_exp
expr_stmt|;
comment|/* 		 * Loop through all of the volume's Phys Disks to map the phys 		 * disk number into the columm map.  This is used during Direct 		 * Drive I/O to send the request to the correct SSD. 		 */
name|pRVPD
operator|=
operator|(
name|pMpi2RaidVol0PhysDisk_t
operator|)
operator|&
name|raid_vol_pg0
operator|->
name|PhysDisk
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|raid_vol_pg0
operator|->
name|NumPhysDisks
condition|;
name|index
operator|++
control|)
block|{
name|sc
operator|->
name|DD_column_map
index|[
name|pRVPD
operator|->
name|PhysDiskMap
index|]
operator|.
name|phys_disk_num
operator|=
name|pRVPD
operator|->
name|PhysDiskNum
expr_stmt|;
name|pRVPD
operator|++
expr_stmt|;
block|}
comment|/* 		 * Get second RAID Volume Page0 using previous handle.  This 		 * page should not exist.  If it does, must not proceed with WD 		 * handling. 		 */
if|if
condition|(
name|mps_config_get_raid_volume_pg0
argument_list|(
name|sc
argument_list|,
operator|&
name|mpi_reply
argument_list|,
name|raid_vol_pg0
argument_list|,
operator|(
name|u32
operator|)
name|raid_vol_pg0
operator|->
name|DevHandle
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|le16toh
argument_list|(
name|mpi_reply
operator|.
name|IOCStatus
argument_list|)
operator|&
name|MPI2_IOCSTATUS_MASK
operator|)
operator|!=
name|MPI2_IOCSTATUS_CONFIG_INVALID_PAGE
condition|)
block|{
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_FAULT
argument_list|,
literal|"Multiple RAID Volume Page0! Direct Drive "
literal|"I/O will not be used.\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
else|else
block|{
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_FAULT
argument_list|,
literal|"Multiple volumes! Direct Drive I/O will not be "
literal|"used.\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 		 * Get RAID Volume Phys Disk Page 0 for all SSDs in the volume. 		 */
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|raid_vol_pg0
operator|->
name|NumPhysDisks
condition|;
name|index
operator|++
control|)
block|{
name|phys_disk_page_address
operator|=
name|MPI2_PHYSDISK_PGAD_FORM_PHYSDISKNUM
operator|+
name|sc
operator|->
name|DD_column_map
index|[
name|index
index|]
operator|.
name|phys_disk_num
expr_stmt|;
if|if
condition|(
name|mps_config_get_raid_pd_pg0
argument_list|(
name|sc
argument_list|,
operator|&
name|mpi_reply
argument_list|,
operator|&
name|phys_disk_pg0
argument_list|,
name|phys_disk_page_address
argument_list|)
condition|)
block|{
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_FAULT
argument_list|,
literal|"mps_config_get_raid_pd_pg0 failed! Direct "
literal|"Drive I/O will not be used.\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|phys_disk_pg0
operator|.
name|DevHandle
operator|==
literal|0xFFFF
condition|)
block|{
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_FAULT
argument_list|,
literal|"Invalid Phys Disk DevHandle! Direct Drive "
literal|"I/O will not be used.\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|sc
operator|->
name|DD_column_map
index|[
name|index
index|]
operator|.
name|dev_handle
operator|=
name|phys_disk_pg0
operator|.
name|DevHandle
expr_stmt|;
block|}
name|sc
operator|->
name|WD_valid_config
operator|=
name|TRUE
expr_stmt|;
name|out
label|:
if|if
condition|(
name|raid_vol_pg0
condition|)
name|free
argument_list|(
name|raid_vol_pg0
argument_list|,
name|M_MPT2
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * mps_config_get_dpm_pg0 - obtain driver persistent mapping page0  * @sc: per adapter object  * @mpi_reply: reply mf payload returned from firmware  * @config_page: contents of the config page  * @sz: size of buffer passed in config_page  * Context: sleep.  *  * Returns 0 for success, non-zero for failure.  */
end_comment

begin_function
name|int
name|mps_config_get_dpm_pg0
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|Mpi2ConfigReply_t
modifier|*
name|mpi_reply
parameter_list|,
name|Mpi2DriverMappingPage0_t
modifier|*
name|config_page
parameter_list|,
name|u16
name|sz
parameter_list|)
block|{
name|MPI2_CONFIG_REQUEST
modifier|*
name|request
decl_stmt|;
name|MPI2_CONFIG_REPLY
modifier|*
name|reply
decl_stmt|;
name|struct
name|mps_command
modifier|*
name|cm
decl_stmt|;
name|Mpi2DriverMappingPage0_t
modifier|*
name|page
init|=
name|NULL
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|u16
name|ioc_status
decl_stmt|;
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_TRACE
argument_list|,
literal|"%s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|config_page
argument_list|,
literal|0
argument_list|,
name|sz
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cm
operator|=
name|mps_alloc_command
argument_list|(
name|sc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: command alloc failed @ line %d\n"
argument_list|,
name|__func__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|error
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|request
operator|=
operator|(
name|MPI2_CONFIG_REQUEST
operator|*
operator|)
name|cm
operator|->
name|cm_req
expr_stmt|;
name|bzero
argument_list|(
name|request
argument_list|,
sizeof|sizeof
argument_list|(
name|MPI2_CONFIG_REQUEST
argument_list|)
argument_list|)
expr_stmt|;
name|request
operator|->
name|Function
operator|=
name|MPI2_FUNCTION_CONFIG
expr_stmt|;
name|request
operator|->
name|Action
operator|=
name|MPI2_CONFIG_ACTION_PAGE_HEADER
expr_stmt|;
name|request
operator|->
name|Header
operator|.
name|PageType
operator|=
name|MPI2_CONFIG_PAGETYPE_EXTENDED
expr_stmt|;
name|request
operator|->
name|ExtPageType
operator|=
name|MPI2_CONFIG_EXTPAGETYPE_DRIVER_MAPPING
expr_stmt|;
name|request
operator|->
name|Header
operator|.
name|PageNumber
operator|=
literal|0
expr_stmt|;
name|request
operator|->
name|Header
operator|.
name|PageVersion
operator|=
name|MPI2_DRIVERMAPPING0_PAGEVERSION
expr_stmt|;
name|request
operator|->
name|PageAddress
operator|=
name|sc
operator|->
name|max_dpm_entries
operator|<<
name|MPI2_DPM_PGAD_ENTRY_COUNT_SHIFT
expr_stmt|;
name|cm
operator|->
name|cm_desc
operator|.
name|Default
operator|.
name|RequestFlags
operator|=
name|MPI2_REQ_DESCRIPT_FLAGS_DEFAULT_TYPE
expr_stmt|;
name|cm
operator|->
name|cm_data
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|mps_wait_command
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|,
literal|60
argument_list|,
name|CAN_SLEEP
argument_list|)
expr_stmt|;
name|reply
operator|=
operator|(
name|MPI2_CONFIG_REPLY
operator|*
operator|)
name|cm
operator|->
name|cm_reply
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|(
name|reply
operator|==
name|NULL
operator|)
condition|)
block|{
comment|/* FIXME */
comment|/* 		 * If the request returns an error then we need to do a diag 		 * reset 		 */
name|printf
argument_list|(
literal|"%s: request for header completed with error %d"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ioc_status
operator|=
name|le16toh
argument_list|(
name|reply
operator|->
name|IOCStatus
argument_list|)
operator|&
name|MPI2_IOCSTATUS_MASK
expr_stmt|;
name|bcopy
argument_list|(
name|reply
argument_list|,
name|mpi_reply
argument_list|,
sizeof|sizeof
argument_list|(
name|MPI2_CONFIG_REPLY
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioc_status
operator|!=
name|MPI2_IOCSTATUS_SUCCESS
condition|)
block|{
comment|/* FIXME */
comment|/* 		 * If the request returns an error then we need to do a diag 		 * reset 		 */
name|printf
argument_list|(
literal|"%s: header read with error; iocstatus = 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|ioc_status
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* We have to do free and alloc for the reply-free and reply-post 	 * counters to match - Need to review the reply FIFO handling. 	 */
name|mps_free_command
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cm
operator|=
name|mps_alloc_command
argument_list|(
name|sc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: command alloc failed @ line %d\n"
argument_list|,
name|__func__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|error
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|request
operator|=
operator|(
name|MPI2_CONFIG_REQUEST
operator|*
operator|)
name|cm
operator|->
name|cm_req
expr_stmt|;
name|bzero
argument_list|(
name|request
argument_list|,
sizeof|sizeof
argument_list|(
name|MPI2_CONFIG_REQUEST
argument_list|)
argument_list|)
expr_stmt|;
name|request
operator|->
name|Function
operator|=
name|MPI2_FUNCTION_CONFIG
expr_stmt|;
name|request
operator|->
name|Action
operator|=
name|MPI2_CONFIG_ACTION_PAGE_READ_NVRAM
expr_stmt|;
name|request
operator|->
name|Header
operator|.
name|PageType
operator|=
name|MPI2_CONFIG_PAGETYPE_EXTENDED
expr_stmt|;
name|request
operator|->
name|ExtPageType
operator|=
name|MPI2_CONFIG_EXTPAGETYPE_DRIVER_MAPPING
expr_stmt|;
name|request
operator|->
name|Header
operator|.
name|PageNumber
operator|=
literal|0
expr_stmt|;
name|request
operator|->
name|Header
operator|.
name|PageVersion
operator|=
name|MPI2_DRIVERMAPPING0_PAGEVERSION
expr_stmt|;
name|request
operator|->
name|PageAddress
operator|=
name|sc
operator|->
name|max_dpm_entries
operator|<<
name|MPI2_DPM_PGAD_ENTRY_COUNT_SHIFT
expr_stmt|;
name|request
operator|->
name|ExtPageLength
operator|=
name|mpi_reply
operator|->
name|ExtPageLength
expr_stmt|;
name|cm
operator|->
name|cm_length
operator|=
name|le16toh
argument_list|(
name|request
operator|->
name|ExtPageLength
argument_list|)
operator|*
literal|4
expr_stmt|;
name|cm
operator|->
name|cm_sge
operator|=
operator|&
name|request
operator|->
name|PageBufferSGE
expr_stmt|;
name|cm
operator|->
name|cm_sglsize
operator|=
sizeof|sizeof
argument_list|(
name|MPI2_SGE_IO_UNION
argument_list|)
expr_stmt|;
name|cm
operator|->
name|cm_flags
operator|=
name|MPS_CM_FLAGS_SGE_SIMPLE
operator||
name|MPS_CM_FLAGS_DATAIN
expr_stmt|;
name|cm
operator|->
name|cm_desc
operator|.
name|Default
operator|.
name|RequestFlags
operator|=
name|MPI2_REQ_DESCRIPT_FLAGS_DEFAULT_TYPE
expr_stmt|;
name|page
operator|=
name|malloc
argument_list|(
name|cm
operator|->
name|cm_length
argument_list|,
name|M_MPT2
argument_list|,
name|M_ZERO
operator||
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|page
condition|)
block|{
name|printf
argument_list|(
literal|"%s: page alloc failed\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|cm
operator|->
name|cm_data
operator|=
name|page
expr_stmt|;
name|error
operator|=
name|mps_wait_command
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|,
literal|60
argument_list|,
name|CAN_SLEEP
argument_list|)
expr_stmt|;
name|reply
operator|=
operator|(
name|MPI2_CONFIG_REPLY
operator|*
operator|)
name|cm
operator|->
name|cm_reply
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|(
name|reply
operator|==
name|NULL
operator|)
condition|)
block|{
comment|/* FIXME */
comment|/* 		 * If the request returns an error then we need to do a diag 		 * reset 		 */
name|printf
argument_list|(
literal|"%s: request for page completed with error %d"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ioc_status
operator|=
name|le16toh
argument_list|(
name|reply
operator|->
name|IOCStatus
argument_list|)
operator|&
name|MPI2_IOCSTATUS_MASK
expr_stmt|;
name|bcopy
argument_list|(
name|reply
argument_list|,
name|mpi_reply
argument_list|,
sizeof|sizeof
argument_list|(
name|MPI2_CONFIG_REPLY
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioc_status
operator|!=
name|MPI2_IOCSTATUS_SUCCESS
condition|)
block|{
comment|/* FIXME */
comment|/* 		 * If the request returns an error then we need to do a diag 		 * reset 		 */
name|printf
argument_list|(
literal|"%s: page read with error; iocstatus = 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|ioc_status
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|bcopy
argument_list|(
name|page
argument_list|,
name|config_page
argument_list|,
name|MIN
argument_list|(
name|cm
operator|->
name|cm_length
argument_list|,
name|sz
argument_list|)
argument_list|)
expr_stmt|;
name|out
label|:
name|free
argument_list|(
name|page
argument_list|,
name|M_MPT2
argument_list|)
expr_stmt|;
if|if
condition|(
name|cm
condition|)
name|mps_free_command
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * mps_config_set_dpm_pg0 - write an entry in driver persistent mapping page0  * @sc: per adapter object  * @mpi_reply: reply mf payload returned from firmware  * @config_page: contents of the config page  * @entry_idx: entry index in DPM Page0 to be modified  * Context: sleep.  *  * Returns 0 for success, non-zero for failure.  */
end_comment

begin_function
name|int
name|mps_config_set_dpm_pg0
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|Mpi2ConfigReply_t
modifier|*
name|mpi_reply
parameter_list|,
name|Mpi2DriverMappingPage0_t
modifier|*
name|config_page
parameter_list|,
name|u16
name|entry_idx
parameter_list|)
block|{
name|MPI2_CONFIG_REQUEST
modifier|*
name|request
decl_stmt|;
name|MPI2_CONFIG_REPLY
modifier|*
name|reply
decl_stmt|;
name|struct
name|mps_command
modifier|*
name|cm
decl_stmt|;
name|MPI2_CONFIG_PAGE_DRIVER_MAPPING_0
modifier|*
name|page
init|=
name|NULL
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|u16
name|ioc_status
decl_stmt|;
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_TRACE
argument_list|,
literal|"%s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cm
operator|=
name|mps_alloc_command
argument_list|(
name|sc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: command alloc failed @ line %d\n"
argument_list|,
name|__func__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|error
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|request
operator|=
operator|(
name|MPI2_CONFIG_REQUEST
operator|*
operator|)
name|cm
operator|->
name|cm_req
expr_stmt|;
name|bzero
argument_list|(
name|request
argument_list|,
sizeof|sizeof
argument_list|(
name|MPI2_CONFIG_REQUEST
argument_list|)
argument_list|)
expr_stmt|;
name|request
operator|->
name|Function
operator|=
name|MPI2_FUNCTION_CONFIG
expr_stmt|;
name|request
operator|->
name|Action
operator|=
name|MPI2_CONFIG_ACTION_PAGE_HEADER
expr_stmt|;
name|request
operator|->
name|Header
operator|.
name|PageType
operator|=
name|MPI2_CONFIG_PAGETYPE_EXTENDED
expr_stmt|;
name|request
operator|->
name|ExtPageType
operator|=
name|MPI2_CONFIG_EXTPAGETYPE_DRIVER_MAPPING
expr_stmt|;
name|request
operator|->
name|Header
operator|.
name|PageNumber
operator|=
literal|0
expr_stmt|;
name|request
operator|->
name|Header
operator|.
name|PageVersion
operator|=
name|MPI2_DRIVERMAPPING0_PAGEVERSION
expr_stmt|;
comment|/* We can remove below two lines ????*/
name|request
operator|->
name|PageAddress
operator|=
literal|1
operator|<<
name|MPI2_DPM_PGAD_ENTRY_COUNT_SHIFT
expr_stmt|;
name|request
operator|->
name|PageAddress
operator||=
name|htole16
argument_list|(
name|entry_idx
argument_list|)
expr_stmt|;
name|cm
operator|->
name|cm_desc
operator|.
name|Default
operator|.
name|RequestFlags
operator|=
name|MPI2_REQ_DESCRIPT_FLAGS_DEFAULT_TYPE
expr_stmt|;
name|cm
operator|->
name|cm_data
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|mps_wait_command
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|,
literal|60
argument_list|,
name|CAN_SLEEP
argument_list|)
expr_stmt|;
name|reply
operator|=
operator|(
name|MPI2_CONFIG_REPLY
operator|*
operator|)
name|cm
operator|->
name|cm_reply
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|(
name|reply
operator|==
name|NULL
operator|)
condition|)
block|{
comment|/* FIXME */
comment|/* 		 * If the request returns an error then we need to do a diag 		 * reset 		 */
name|printf
argument_list|(
literal|"%s: request for header completed with error %d"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ioc_status
operator|=
name|le16toh
argument_list|(
name|reply
operator|->
name|IOCStatus
argument_list|)
operator|&
name|MPI2_IOCSTATUS_MASK
expr_stmt|;
name|bcopy
argument_list|(
name|reply
argument_list|,
name|mpi_reply
argument_list|,
sizeof|sizeof
argument_list|(
name|MPI2_CONFIG_REPLY
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioc_status
operator|!=
name|MPI2_IOCSTATUS_SUCCESS
condition|)
block|{
comment|/* FIXME */
comment|/* 		 * If the request returns an error then we need to do a diag 		 * reset 		 */
name|printf
argument_list|(
literal|"%s: header read with error; iocstatus = 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|ioc_status
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* We have to do free and alloc for the reply-free and reply-post 	 * counters to match - Need to review the reply FIFO handling. 	 */
name|mps_free_command
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cm
operator|=
name|mps_alloc_command
argument_list|(
name|sc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: command alloc failed @ line %d\n"
argument_list|,
name|__func__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|error
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|request
operator|=
operator|(
name|MPI2_CONFIG_REQUEST
operator|*
operator|)
name|cm
operator|->
name|cm_req
expr_stmt|;
name|bzero
argument_list|(
name|request
argument_list|,
sizeof|sizeof
argument_list|(
name|MPI2_CONFIG_REQUEST
argument_list|)
argument_list|)
expr_stmt|;
name|request
operator|->
name|Function
operator|=
name|MPI2_FUNCTION_CONFIG
expr_stmt|;
name|request
operator|->
name|Action
operator|=
name|MPI2_CONFIG_ACTION_PAGE_WRITE_NVRAM
expr_stmt|;
name|request
operator|->
name|Header
operator|.
name|PageType
operator|=
name|MPI2_CONFIG_PAGETYPE_EXTENDED
expr_stmt|;
name|request
operator|->
name|ExtPageType
operator|=
name|MPI2_CONFIG_EXTPAGETYPE_DRIVER_MAPPING
expr_stmt|;
name|request
operator|->
name|Header
operator|.
name|PageNumber
operator|=
literal|0
expr_stmt|;
name|request
operator|->
name|Header
operator|.
name|PageVersion
operator|=
name|MPI2_DRIVERMAPPING0_PAGEVERSION
expr_stmt|;
name|request
operator|->
name|ExtPageLength
operator|=
name|mpi_reply
operator|->
name|ExtPageLength
expr_stmt|;
name|request
operator|->
name|PageAddress
operator|=
literal|1
operator|<<
name|MPI2_DPM_PGAD_ENTRY_COUNT_SHIFT
expr_stmt|;
name|request
operator|->
name|PageAddress
operator||=
name|htole16
argument_list|(
name|entry_idx
argument_list|)
expr_stmt|;
name|cm
operator|->
name|cm_length
operator|=
name|le16toh
argument_list|(
name|mpi_reply
operator|->
name|ExtPageLength
argument_list|)
operator|*
literal|4
expr_stmt|;
name|cm
operator|->
name|cm_sge
operator|=
operator|&
name|request
operator|->
name|PageBufferSGE
expr_stmt|;
name|cm
operator|->
name|cm_sglsize
operator|=
sizeof|sizeof
argument_list|(
name|MPI2_SGE_IO_UNION
argument_list|)
expr_stmt|;
name|cm
operator|->
name|cm_flags
operator|=
name|MPS_CM_FLAGS_SGE_SIMPLE
operator||
name|MPS_CM_FLAGS_DATAOUT
expr_stmt|;
name|cm
operator|->
name|cm_desc
operator|.
name|Default
operator|.
name|RequestFlags
operator|=
name|MPI2_REQ_DESCRIPT_FLAGS_DEFAULT_TYPE
expr_stmt|;
name|page
operator|=
name|malloc
argument_list|(
name|cm
operator|->
name|cm_length
argument_list|,
name|M_MPT2
argument_list|,
name|M_ZERO
operator||
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|page
condition|)
block|{
name|printf
argument_list|(
literal|"%s: page alloc failed\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|bcopy
argument_list|(
name|config_page
argument_list|,
name|page
argument_list|,
name|MIN
argument_list|(
name|cm
operator|->
name|cm_length
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
name|Mpi2DriverMappingPage0_t
argument_list|)
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|cm
operator|->
name|cm_data
operator|=
name|page
expr_stmt|;
name|error
operator|=
name|mps_wait_command
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|,
literal|60
argument_list|,
name|CAN_SLEEP
argument_list|)
expr_stmt|;
name|reply
operator|=
operator|(
name|MPI2_CONFIG_REPLY
operator|*
operator|)
name|cm
operator|->
name|cm_reply
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|(
name|reply
operator|==
name|NULL
operator|)
condition|)
block|{
comment|/* FIXME */
comment|/* 		 * If the request returns an error then we need to do a diag 		 * reset 		 */
name|printf
argument_list|(
literal|"%s: request to write page completed with error %d"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ioc_status
operator|=
name|le16toh
argument_list|(
name|reply
operator|->
name|IOCStatus
argument_list|)
operator|&
name|MPI2_IOCSTATUS_MASK
expr_stmt|;
name|bcopy
argument_list|(
name|reply
argument_list|,
name|mpi_reply
argument_list|,
sizeof|sizeof
argument_list|(
name|MPI2_CONFIG_REPLY
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioc_status
operator|!=
name|MPI2_IOCSTATUS_SUCCESS
condition|)
block|{
comment|/* FIXME */
comment|/* 		 * If the request returns an error then we need to do a diag 		 * reset 		 */
name|printf
argument_list|(
literal|"%s: page written with error; iocstatus = 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|ioc_status
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|out
label|:
name|free
argument_list|(
name|page
argument_list|,
name|M_MPT2
argument_list|)
expr_stmt|;
if|if
condition|(
name|cm
condition|)
name|mps_free_command
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * mps_config_get_sas_device_pg0 - obtain sas device page 0  * @sc: per adapter object  * @mpi_reply: reply mf payload returned from firmware  * @config_page: contents of the config page  * @form: GET_NEXT_HANDLE or HANDLE  * @handle: device handle  * Context: sleep.  *  * Returns 0 for success, non-zero for failure.  */
end_comment

begin_function
name|int
name|mps_config_get_sas_device_pg0
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|Mpi2ConfigReply_t
modifier|*
name|mpi_reply
parameter_list|,
name|Mpi2SasDevicePage0_t
modifier|*
name|config_page
parameter_list|,
name|u32
name|form
parameter_list|,
name|u16
name|handle
parameter_list|)
block|{
name|MPI2_CONFIG_REQUEST
modifier|*
name|request
decl_stmt|;
name|MPI2_CONFIG_REPLY
modifier|*
name|reply
decl_stmt|;
name|struct
name|mps_command
modifier|*
name|cm
decl_stmt|;
name|Mpi2SasDevicePage0_t
modifier|*
name|page
init|=
name|NULL
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|u16
name|ioc_status
decl_stmt|;
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_TRACE
argument_list|,
literal|"%s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cm
operator|=
name|mps_alloc_command
argument_list|(
name|sc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: command alloc failed @ line %d\n"
argument_list|,
name|__func__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|error
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|request
operator|=
operator|(
name|MPI2_CONFIG_REQUEST
operator|*
operator|)
name|cm
operator|->
name|cm_req
expr_stmt|;
name|bzero
argument_list|(
name|request
argument_list|,
sizeof|sizeof
argument_list|(
name|MPI2_CONFIG_REQUEST
argument_list|)
argument_list|)
expr_stmt|;
name|request
operator|->
name|Function
operator|=
name|MPI2_FUNCTION_CONFIG
expr_stmt|;
name|request
operator|->
name|Action
operator|=
name|MPI2_CONFIG_ACTION_PAGE_HEADER
expr_stmt|;
name|request
operator|->
name|Header
operator|.
name|PageType
operator|=
name|MPI2_CONFIG_PAGETYPE_EXTENDED
expr_stmt|;
name|request
operator|->
name|ExtPageType
operator|=
name|MPI2_CONFIG_EXTPAGETYPE_SAS_DEVICE
expr_stmt|;
name|request
operator|->
name|Header
operator|.
name|PageNumber
operator|=
literal|0
expr_stmt|;
name|request
operator|->
name|Header
operator|.
name|PageVersion
operator|=
name|MPI2_SASDEVICE0_PAGEVERSION
expr_stmt|;
name|cm
operator|->
name|cm_desc
operator|.
name|Default
operator|.
name|RequestFlags
operator|=
name|MPI2_REQ_DESCRIPT_FLAGS_DEFAULT_TYPE
expr_stmt|;
name|cm
operator|->
name|cm_data
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|mps_wait_command
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|,
literal|60
argument_list|,
name|CAN_SLEEP
argument_list|)
expr_stmt|;
name|reply
operator|=
operator|(
name|MPI2_CONFIG_REPLY
operator|*
operator|)
name|cm
operator|->
name|cm_reply
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|(
name|reply
operator|==
name|NULL
operator|)
condition|)
block|{
comment|/* FIXME */
comment|/* 		 * If the request returns an error then we need to do a diag 		 * reset 		 */
name|printf
argument_list|(
literal|"%s: request for header completed with error %d"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ioc_status
operator|=
name|le16toh
argument_list|(
name|reply
operator|->
name|IOCStatus
argument_list|)
operator|&
name|MPI2_IOCSTATUS_MASK
expr_stmt|;
name|bcopy
argument_list|(
name|reply
argument_list|,
name|mpi_reply
argument_list|,
sizeof|sizeof
argument_list|(
name|MPI2_CONFIG_REPLY
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioc_status
operator|!=
name|MPI2_IOCSTATUS_SUCCESS
condition|)
block|{
comment|/* FIXME */
comment|/* 		 * If the request returns an error then we need to do a diag 		 * reset 		 */
name|printf
argument_list|(
literal|"%s: header read with error; iocstatus = 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|ioc_status
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* We have to do free and alloc for the reply-free and reply-post 	 * counters to match - Need to review the reply FIFO handling. 	 */
name|mps_free_command
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cm
operator|=
name|mps_alloc_command
argument_list|(
name|sc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: command alloc failed @ line %d\n"
argument_list|,
name|__func__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|error
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|request
operator|=
operator|(
name|MPI2_CONFIG_REQUEST
operator|*
operator|)
name|cm
operator|->
name|cm_req
expr_stmt|;
name|bzero
argument_list|(
name|request
argument_list|,
sizeof|sizeof
argument_list|(
name|MPI2_CONFIG_REQUEST
argument_list|)
argument_list|)
expr_stmt|;
name|request
operator|->
name|Function
operator|=
name|MPI2_FUNCTION_CONFIG
expr_stmt|;
name|request
operator|->
name|Action
operator|=
name|MPI2_CONFIG_ACTION_PAGE_READ_CURRENT
expr_stmt|;
name|request
operator|->
name|Header
operator|.
name|PageType
operator|=
name|MPI2_CONFIG_PAGETYPE_EXTENDED
expr_stmt|;
name|request
operator|->
name|ExtPageType
operator|=
name|MPI2_CONFIG_EXTPAGETYPE_SAS_DEVICE
expr_stmt|;
name|request
operator|->
name|Header
operator|.
name|PageNumber
operator|=
literal|0
expr_stmt|;
name|request
operator|->
name|Header
operator|.
name|PageVersion
operator|=
name|MPI2_SASDEVICE0_PAGEVERSION
expr_stmt|;
name|request
operator|->
name|ExtPageLength
operator|=
name|mpi_reply
operator|->
name|ExtPageLength
expr_stmt|;
name|request
operator|->
name|PageAddress
operator|=
name|htole32
argument_list|(
name|form
operator||
name|handle
argument_list|)
expr_stmt|;
name|cm
operator|->
name|cm_length
operator|=
name|le16toh
argument_list|(
name|mpi_reply
operator|->
name|ExtPageLength
argument_list|)
operator|*
literal|4
expr_stmt|;
name|cm
operator|->
name|cm_sge
operator|=
operator|&
name|request
operator|->
name|PageBufferSGE
expr_stmt|;
name|cm
operator|->
name|cm_sglsize
operator|=
sizeof|sizeof
argument_list|(
name|MPI2_SGE_IO_UNION
argument_list|)
expr_stmt|;
name|cm
operator|->
name|cm_flags
operator|=
name|MPS_CM_FLAGS_SGE_SIMPLE
operator||
name|MPS_CM_FLAGS_DATAIN
expr_stmt|;
name|cm
operator|->
name|cm_desc
operator|.
name|Default
operator|.
name|RequestFlags
operator|=
name|MPI2_REQ_DESCRIPT_FLAGS_DEFAULT_TYPE
expr_stmt|;
name|page
operator|=
name|malloc
argument_list|(
name|cm
operator|->
name|cm_length
argument_list|,
name|M_MPT2
argument_list|,
name|M_ZERO
operator||
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|page
condition|)
block|{
name|printf
argument_list|(
literal|"%s: page alloc failed\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|cm
operator|->
name|cm_data
operator|=
name|page
expr_stmt|;
name|error
operator|=
name|mps_wait_command
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|,
literal|60
argument_list|,
name|CAN_SLEEP
argument_list|)
expr_stmt|;
name|reply
operator|=
operator|(
name|MPI2_CONFIG_REPLY
operator|*
operator|)
name|cm
operator|->
name|cm_reply
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|(
name|reply
operator|==
name|NULL
operator|)
condition|)
block|{
comment|/* FIXME */
comment|/* 		 * If the request returns an error then we need to do a diag 		 * reset 		 */
name|printf
argument_list|(
literal|"%s: request for page completed with error %d"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ioc_status
operator|=
name|le16toh
argument_list|(
name|reply
operator|->
name|IOCStatus
argument_list|)
operator|&
name|MPI2_IOCSTATUS_MASK
expr_stmt|;
name|bcopy
argument_list|(
name|reply
argument_list|,
name|mpi_reply
argument_list|,
sizeof|sizeof
argument_list|(
name|MPI2_CONFIG_REPLY
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioc_status
operator|!=
name|MPI2_IOCSTATUS_SUCCESS
condition|)
block|{
comment|/* FIXME */
comment|/* 		 * If the request returns an error then we need to do a diag 		 * reset 		 */
name|printf
argument_list|(
literal|"%s: page read with error; iocstatus = 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|ioc_status
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|bcopy
argument_list|(
name|page
argument_list|,
name|config_page
argument_list|,
name|MIN
argument_list|(
name|cm
operator|->
name|cm_length
argument_list|,
sizeof|sizeof
argument_list|(
name|Mpi2SasDevicePage0_t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|out
label|:
name|free
argument_list|(
name|page
argument_list|,
name|M_MPT2
argument_list|)
expr_stmt|;
if|if
condition|(
name|cm
condition|)
name|mps_free_command
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * mps_config_get_bios_pg3 - obtain BIOS page 3  * @sc: per adapter object  * @mpi_reply: reply mf payload returned from firmware  * @config_page: contents of the config page  * Context: sleep.  *  * Returns 0 for success, non-zero for failure.  */
end_comment

begin_function
name|int
name|mps_config_get_bios_pg3
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|Mpi2ConfigReply_t
modifier|*
name|mpi_reply
parameter_list|,
name|Mpi2BiosPage3_t
modifier|*
name|config_page
parameter_list|)
block|{
name|MPI2_CONFIG_REQUEST
modifier|*
name|request
decl_stmt|;
name|MPI2_CONFIG_REPLY
modifier|*
name|reply
decl_stmt|;
name|struct
name|mps_command
modifier|*
name|cm
decl_stmt|;
name|Mpi2BiosPage3_t
modifier|*
name|page
init|=
name|NULL
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|u16
name|ioc_status
decl_stmt|;
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_TRACE
argument_list|,
literal|"%s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cm
operator|=
name|mps_alloc_command
argument_list|(
name|sc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: command alloc failed @ line %d\n"
argument_list|,
name|__func__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|error
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|request
operator|=
operator|(
name|MPI2_CONFIG_REQUEST
operator|*
operator|)
name|cm
operator|->
name|cm_req
expr_stmt|;
name|bzero
argument_list|(
name|request
argument_list|,
sizeof|sizeof
argument_list|(
name|MPI2_CONFIG_REQUEST
argument_list|)
argument_list|)
expr_stmt|;
name|request
operator|->
name|Function
operator|=
name|MPI2_FUNCTION_CONFIG
expr_stmt|;
name|request
operator|->
name|Action
operator|=
name|MPI2_CONFIG_ACTION_PAGE_HEADER
expr_stmt|;
name|request
operator|->
name|Header
operator|.
name|PageType
operator|=
name|MPI2_CONFIG_PAGETYPE_BIOS
expr_stmt|;
name|request
operator|->
name|Header
operator|.
name|PageNumber
operator|=
literal|3
expr_stmt|;
name|request
operator|->
name|Header
operator|.
name|PageVersion
operator|=
name|MPI2_BIOSPAGE3_PAGEVERSION
expr_stmt|;
name|cm
operator|->
name|cm_desc
operator|.
name|Default
operator|.
name|RequestFlags
operator|=
name|MPI2_REQ_DESCRIPT_FLAGS_DEFAULT_TYPE
expr_stmt|;
name|cm
operator|->
name|cm_data
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|mps_wait_command
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|,
literal|60
argument_list|,
name|CAN_SLEEP
argument_list|)
expr_stmt|;
name|reply
operator|=
operator|(
name|MPI2_CONFIG_REPLY
operator|*
operator|)
name|cm
operator|->
name|cm_reply
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|(
name|reply
operator|==
name|NULL
operator|)
condition|)
block|{
comment|/* FIXME */
comment|/* 		 * If the request returns an error then we need to do a diag 		 * reset 		 */
name|printf
argument_list|(
literal|"%s: request for header completed with error %d"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ioc_status
operator|=
name|le16toh
argument_list|(
name|reply
operator|->
name|IOCStatus
argument_list|)
operator|&
name|MPI2_IOCSTATUS_MASK
expr_stmt|;
name|bcopy
argument_list|(
name|reply
argument_list|,
name|mpi_reply
argument_list|,
sizeof|sizeof
argument_list|(
name|MPI2_CONFIG_REPLY
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioc_status
operator|!=
name|MPI2_IOCSTATUS_SUCCESS
condition|)
block|{
comment|/* FIXME */
comment|/* 		 * If the request returns an error then we need to do a diag 		 * reset 		 */
name|printf
argument_list|(
literal|"%s: header read with error; iocstatus = 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|ioc_status
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* We have to do free and alloc for the reply-free and reply-post 	 * counters to match - Need to review the reply FIFO handling. 	 */
name|mps_free_command
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cm
operator|=
name|mps_alloc_command
argument_list|(
name|sc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: command alloc failed @ line %d\n"
argument_list|,
name|__func__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|error
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|request
operator|=
operator|(
name|MPI2_CONFIG_REQUEST
operator|*
operator|)
name|cm
operator|->
name|cm_req
expr_stmt|;
name|bzero
argument_list|(
name|request
argument_list|,
sizeof|sizeof
argument_list|(
name|MPI2_CONFIG_REQUEST
argument_list|)
argument_list|)
expr_stmt|;
name|request
operator|->
name|Function
operator|=
name|MPI2_FUNCTION_CONFIG
expr_stmt|;
name|request
operator|->
name|Action
operator|=
name|MPI2_CONFIG_ACTION_PAGE_READ_CURRENT
expr_stmt|;
name|request
operator|->
name|Header
operator|.
name|PageType
operator|=
name|MPI2_CONFIG_PAGETYPE_BIOS
expr_stmt|;
name|request
operator|->
name|Header
operator|.
name|PageNumber
operator|=
literal|3
expr_stmt|;
name|request
operator|->
name|Header
operator|.
name|PageVersion
operator|=
name|MPI2_BIOSPAGE3_PAGEVERSION
expr_stmt|;
name|request
operator|->
name|Header
operator|.
name|PageLength
operator|=
name|mpi_reply
operator|->
name|Header
operator|.
name|PageLength
expr_stmt|;
name|cm
operator|->
name|cm_length
operator|=
name|le16toh
argument_list|(
name|mpi_reply
operator|->
name|Header
operator|.
name|PageLength
argument_list|)
operator|*
literal|4
expr_stmt|;
name|cm
operator|->
name|cm_sge
operator|=
operator|&
name|request
operator|->
name|PageBufferSGE
expr_stmt|;
name|cm
operator|->
name|cm_sglsize
operator|=
sizeof|sizeof
argument_list|(
name|MPI2_SGE_IO_UNION
argument_list|)
expr_stmt|;
name|cm
operator|->
name|cm_flags
operator|=
name|MPS_CM_FLAGS_SGE_SIMPLE
operator||
name|MPS_CM_FLAGS_DATAIN
expr_stmt|;
name|cm
operator|->
name|cm_desc
operator|.
name|Default
operator|.
name|RequestFlags
operator|=
name|MPI2_REQ_DESCRIPT_FLAGS_DEFAULT_TYPE
expr_stmt|;
name|page
operator|=
name|malloc
argument_list|(
name|cm
operator|->
name|cm_length
argument_list|,
name|M_MPT2
argument_list|,
name|M_ZERO
operator||
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|page
condition|)
block|{
name|printf
argument_list|(
literal|"%s: page alloc failed\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|cm
operator|->
name|cm_data
operator|=
name|page
expr_stmt|;
name|error
operator|=
name|mps_wait_command
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|,
literal|60
argument_list|,
name|CAN_SLEEP
argument_list|)
expr_stmt|;
name|reply
operator|=
operator|(
name|MPI2_CONFIG_REPLY
operator|*
operator|)
name|cm
operator|->
name|cm_reply
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|(
name|reply
operator|==
name|NULL
operator|)
condition|)
block|{
comment|/* FIXME */
comment|/* 		 * If the request returns an error then we need to do a diag 		 * reset 		 */
name|printf
argument_list|(
literal|"%s: request for page completed with error %d"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ioc_status
operator|=
name|le16toh
argument_list|(
name|reply
operator|->
name|IOCStatus
argument_list|)
operator|&
name|MPI2_IOCSTATUS_MASK
expr_stmt|;
name|bcopy
argument_list|(
name|reply
argument_list|,
name|mpi_reply
argument_list|,
sizeof|sizeof
argument_list|(
name|MPI2_CONFIG_REPLY
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioc_status
operator|!=
name|MPI2_IOCSTATUS_SUCCESS
condition|)
block|{
comment|/* FIXME */
comment|/* 		 * If the request returns an error then we need to do a diag 		 * reset 		 */
name|printf
argument_list|(
literal|"%s: page read with error; iocstatus = 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|ioc_status
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|bcopy
argument_list|(
name|page
argument_list|,
name|config_page
argument_list|,
name|MIN
argument_list|(
name|cm
operator|->
name|cm_length
argument_list|,
sizeof|sizeof
argument_list|(
name|Mpi2BiosPage3_t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|out
label|:
name|free
argument_list|(
name|page
argument_list|,
name|M_MPT2
argument_list|)
expr_stmt|;
if|if
condition|(
name|cm
condition|)
name|mps_free_command
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * mps_config_get_raid_volume_pg0 - obtain raid volume page 0  * @sc: per adapter object  * @mpi_reply: reply mf payload returned from firmware  * @config_page: contents of the config page  * @page_address: form and handle value used to get page  * Context: sleep.  *  * Returns 0 for success, non-zero for failure.  */
end_comment

begin_function
name|int
name|mps_config_get_raid_volume_pg0
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|Mpi2ConfigReply_t
modifier|*
name|mpi_reply
parameter_list|,
name|Mpi2RaidVolPage0_t
modifier|*
name|config_page
parameter_list|,
name|u32
name|page_address
parameter_list|)
block|{
name|MPI2_CONFIG_REQUEST
modifier|*
name|request
decl_stmt|;
name|MPI2_CONFIG_REPLY
modifier|*
name|reply
decl_stmt|;
name|struct
name|mps_command
modifier|*
name|cm
decl_stmt|;
name|Mpi2RaidVolPage0_t
modifier|*
name|page
init|=
name|NULL
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|u16
name|ioc_status
decl_stmt|;
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_TRACE
argument_list|,
literal|"%s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cm
operator|=
name|mps_alloc_command
argument_list|(
name|sc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: command alloc failed @ line %d\n"
argument_list|,
name|__func__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|error
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|request
operator|=
operator|(
name|MPI2_CONFIG_REQUEST
operator|*
operator|)
name|cm
operator|->
name|cm_req
expr_stmt|;
name|bzero
argument_list|(
name|request
argument_list|,
sizeof|sizeof
argument_list|(
name|MPI2_CONFIG_REQUEST
argument_list|)
argument_list|)
expr_stmt|;
name|request
operator|->
name|Function
operator|=
name|MPI2_FUNCTION_CONFIG
expr_stmt|;
name|request
operator|->
name|Action
operator|=
name|MPI2_CONFIG_ACTION_PAGE_HEADER
expr_stmt|;
name|request
operator|->
name|Header
operator|.
name|PageType
operator|=
name|MPI2_CONFIG_PAGETYPE_RAID_VOLUME
expr_stmt|;
name|request
operator|->
name|Header
operator|.
name|PageNumber
operator|=
literal|0
expr_stmt|;
name|request
operator|->
name|Header
operator|.
name|PageVersion
operator|=
name|MPI2_RAIDVOLPAGE0_PAGEVERSION
expr_stmt|;
name|cm
operator|->
name|cm_desc
operator|.
name|Default
operator|.
name|RequestFlags
operator|=
name|MPI2_REQ_DESCRIPT_FLAGS_DEFAULT_TYPE
expr_stmt|;
name|cm
operator|->
name|cm_data
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * This page must be polled because the IOC isn't ready yet when this 	 * page is needed. 	 */
name|error
operator|=
name|mps_wait_command
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|,
literal|60
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|reply
operator|=
operator|(
name|MPI2_CONFIG_REPLY
operator|*
operator|)
name|cm
operator|->
name|cm_reply
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|(
name|reply
operator|==
name|NULL
operator|)
condition|)
block|{
comment|/* FIXME */
comment|/* If the poll returns error then we need to do diag reset */
name|printf
argument_list|(
literal|"%s: poll for header completed with error %d"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ioc_status
operator|=
name|le16toh
argument_list|(
name|reply
operator|->
name|IOCStatus
argument_list|)
operator|&
name|MPI2_IOCSTATUS_MASK
expr_stmt|;
name|bcopy
argument_list|(
name|reply
argument_list|,
name|mpi_reply
argument_list|,
sizeof|sizeof
argument_list|(
name|MPI2_CONFIG_REPLY
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioc_status
operator|!=
name|MPI2_IOCSTATUS_SUCCESS
condition|)
block|{
comment|/* FIXME */
comment|/* If the poll returns error then we need to do diag reset */
name|printf
argument_list|(
literal|"%s: header read with error; iocstatus = 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|ioc_status
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* We have to do free and alloc for the reply-free and reply-post 	 * counters to match - Need to review the reply FIFO handling. 	 */
name|mps_free_command
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cm
operator|=
name|mps_alloc_command
argument_list|(
name|sc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: command alloc failed @ line %d\n"
argument_list|,
name|__func__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|error
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|request
operator|=
operator|(
name|MPI2_CONFIG_REQUEST
operator|*
operator|)
name|cm
operator|->
name|cm_req
expr_stmt|;
name|bzero
argument_list|(
name|request
argument_list|,
sizeof|sizeof
argument_list|(
name|MPI2_CONFIG_REQUEST
argument_list|)
argument_list|)
expr_stmt|;
name|request
operator|->
name|Function
operator|=
name|MPI2_FUNCTION_CONFIG
expr_stmt|;
name|request
operator|->
name|Action
operator|=
name|MPI2_CONFIG_ACTION_PAGE_READ_CURRENT
expr_stmt|;
name|request
operator|->
name|Header
operator|.
name|PageType
operator|=
name|MPI2_CONFIG_PAGETYPE_RAID_VOLUME
expr_stmt|;
name|request
operator|->
name|Header
operator|.
name|PageNumber
operator|=
literal|0
expr_stmt|;
name|request
operator|->
name|Header
operator|.
name|PageLength
operator|=
name|mpi_reply
operator|->
name|Header
operator|.
name|PageLength
expr_stmt|;
name|request
operator|->
name|Header
operator|.
name|PageVersion
operator|=
name|mpi_reply
operator|->
name|Header
operator|.
name|PageVersion
expr_stmt|;
name|request
operator|->
name|PageAddress
operator|=
name|page_address
expr_stmt|;
name|cm
operator|->
name|cm_length
operator|=
name|le16toh
argument_list|(
name|mpi_reply
operator|->
name|Header
operator|.
name|PageLength
argument_list|)
operator|*
literal|4
expr_stmt|;
name|cm
operator|->
name|cm_sge
operator|=
operator|&
name|request
operator|->
name|PageBufferSGE
expr_stmt|;
name|cm
operator|->
name|cm_sglsize
operator|=
sizeof|sizeof
argument_list|(
name|MPI2_SGE_IO_UNION
argument_list|)
expr_stmt|;
name|cm
operator|->
name|cm_flags
operator|=
name|MPS_CM_FLAGS_SGE_SIMPLE
operator||
name|MPS_CM_FLAGS_DATAIN
expr_stmt|;
name|cm
operator|->
name|cm_desc
operator|.
name|Default
operator|.
name|RequestFlags
operator|=
name|MPI2_REQ_DESCRIPT_FLAGS_DEFAULT_TYPE
expr_stmt|;
name|page
operator|=
name|malloc
argument_list|(
name|cm
operator|->
name|cm_length
argument_list|,
name|M_MPT2
argument_list|,
name|M_ZERO
operator||
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|page
condition|)
block|{
name|printf
argument_list|(
literal|"%s: page alloc failed\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|cm
operator|->
name|cm_data
operator|=
name|page
expr_stmt|;
comment|/* 	 * This page must be polled because the IOC isn't ready yet when this 	 * page is needed. 	 */
name|error
operator|=
name|mps_wait_command
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|,
literal|60
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|reply
operator|=
operator|(
name|MPI2_CONFIG_REPLY
operator|*
operator|)
name|cm
operator|->
name|cm_reply
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|(
name|reply
operator|==
name|NULL
operator|)
condition|)
block|{
comment|/* FIXME */
comment|/* If the poll returns error then we need to do diag reset */
name|printf
argument_list|(
literal|"%s: poll for page completed with error %d"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ioc_status
operator|=
name|le16toh
argument_list|(
name|reply
operator|->
name|IOCStatus
argument_list|)
operator|&
name|MPI2_IOCSTATUS_MASK
expr_stmt|;
name|bcopy
argument_list|(
name|reply
argument_list|,
name|mpi_reply
argument_list|,
sizeof|sizeof
argument_list|(
name|MPI2_CONFIG_REPLY
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioc_status
operator|!=
name|MPI2_IOCSTATUS_SUCCESS
condition|)
block|{
comment|/* FIXME */
comment|/* If the poll returns error then we need to do diag reset */
name|printf
argument_list|(
literal|"%s: page read with error; iocstatus = 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|ioc_status
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|bcopy
argument_list|(
name|page
argument_list|,
name|config_page
argument_list|,
name|cm
operator|->
name|cm_length
argument_list|)
expr_stmt|;
name|out
label|:
name|free
argument_list|(
name|page
argument_list|,
name|M_MPT2
argument_list|)
expr_stmt|;
if|if
condition|(
name|cm
condition|)
name|mps_free_command
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * mps_config_get_raid_volume_pg1 - obtain raid volume page 1  * @sc: per adapter object  * @mpi_reply: reply mf payload returned from firmware  * @config_page: contents of the config page  * @form: GET_NEXT_HANDLE or HANDLE  * @handle: volume handle  * Context: sleep.  *  * Returns 0 for success, non-zero for failure.  */
end_comment

begin_function
name|int
name|mps_config_get_raid_volume_pg1
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|Mpi2ConfigReply_t
modifier|*
name|mpi_reply
parameter_list|,
name|Mpi2RaidVolPage1_t
modifier|*
name|config_page
parameter_list|,
name|u32
name|form
parameter_list|,
name|u16
name|handle
parameter_list|)
block|{
name|MPI2_CONFIG_REQUEST
modifier|*
name|request
decl_stmt|;
name|MPI2_CONFIG_REPLY
modifier|*
name|reply
decl_stmt|;
name|struct
name|mps_command
modifier|*
name|cm
decl_stmt|;
name|Mpi2RaidVolPage1_t
modifier|*
name|page
init|=
name|NULL
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|u16
name|ioc_status
decl_stmt|;
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_TRACE
argument_list|,
literal|"%s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cm
operator|=
name|mps_alloc_command
argument_list|(
name|sc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: command alloc failed @ line %d\n"
argument_list|,
name|__func__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|error
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|request
operator|=
operator|(
name|MPI2_CONFIG_REQUEST
operator|*
operator|)
name|cm
operator|->
name|cm_req
expr_stmt|;
name|bzero
argument_list|(
name|request
argument_list|,
sizeof|sizeof
argument_list|(
name|MPI2_CONFIG_REQUEST
argument_list|)
argument_list|)
expr_stmt|;
name|request
operator|->
name|Function
operator|=
name|MPI2_FUNCTION_CONFIG
expr_stmt|;
name|request
operator|->
name|Action
operator|=
name|MPI2_CONFIG_ACTION_PAGE_HEADER
expr_stmt|;
name|request
operator|->
name|Header
operator|.
name|PageType
operator|=
name|MPI2_CONFIG_PAGETYPE_RAID_VOLUME
expr_stmt|;
name|request
operator|->
name|Header
operator|.
name|PageNumber
operator|=
literal|1
expr_stmt|;
name|request
operator|->
name|Header
operator|.
name|PageVersion
operator|=
name|MPI2_RAIDVOLPAGE1_PAGEVERSION
expr_stmt|;
name|cm
operator|->
name|cm_desc
operator|.
name|Default
operator|.
name|RequestFlags
operator|=
name|MPI2_REQ_DESCRIPT_FLAGS_DEFAULT_TYPE
expr_stmt|;
name|cm
operator|->
name|cm_data
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|mps_wait_command
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|,
literal|60
argument_list|,
name|CAN_SLEEP
argument_list|)
expr_stmt|;
name|reply
operator|=
operator|(
name|MPI2_CONFIG_REPLY
operator|*
operator|)
name|cm
operator|->
name|cm_reply
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|(
name|reply
operator|==
name|NULL
operator|)
condition|)
block|{
comment|/* FIXME */
comment|/* 		 * If the request returns an error then we need to do a diag 		 * reset 		 */
name|printf
argument_list|(
literal|"%s: request for header completed with error %d"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ioc_status
operator|=
name|le16toh
argument_list|(
name|reply
operator|->
name|IOCStatus
argument_list|)
operator|&
name|MPI2_IOCSTATUS_MASK
expr_stmt|;
name|bcopy
argument_list|(
name|reply
argument_list|,
name|mpi_reply
argument_list|,
sizeof|sizeof
argument_list|(
name|MPI2_CONFIG_REPLY
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioc_status
operator|!=
name|MPI2_IOCSTATUS_SUCCESS
condition|)
block|{
comment|/* FIXME */
comment|/* 		 * If the request returns an error then we need to do a diag 		 * reset 		 */
name|printf
argument_list|(
literal|"%s: header read with error; iocstatus = 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|ioc_status
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* We have to do free and alloc for the reply-free and reply-post 	 * counters to match - Need to review the reply FIFO handling. 	 */
name|mps_free_command
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cm
operator|=
name|mps_alloc_command
argument_list|(
name|sc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: command alloc failed @ line %d\n"
argument_list|,
name|__func__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|error
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|request
operator|=
operator|(
name|MPI2_CONFIG_REQUEST
operator|*
operator|)
name|cm
operator|->
name|cm_req
expr_stmt|;
name|bzero
argument_list|(
name|request
argument_list|,
sizeof|sizeof
argument_list|(
name|MPI2_CONFIG_REQUEST
argument_list|)
argument_list|)
expr_stmt|;
name|request
operator|->
name|Function
operator|=
name|MPI2_FUNCTION_CONFIG
expr_stmt|;
name|request
operator|->
name|Action
operator|=
name|MPI2_CONFIG_ACTION_PAGE_READ_CURRENT
expr_stmt|;
name|request
operator|->
name|Header
operator|.
name|PageType
operator|=
name|MPI2_CONFIG_PAGETYPE_RAID_VOLUME
expr_stmt|;
name|request
operator|->
name|Header
operator|.
name|PageNumber
operator|=
literal|1
expr_stmt|;
name|request
operator|->
name|Header
operator|.
name|PageLength
operator|=
name|mpi_reply
operator|->
name|Header
operator|.
name|PageLength
expr_stmt|;
name|request
operator|->
name|Header
operator|.
name|PageVersion
operator|=
name|mpi_reply
operator|->
name|Header
operator|.
name|PageVersion
expr_stmt|;
name|request
operator|->
name|PageAddress
operator|=
name|htole32
argument_list|(
name|form
operator||
name|handle
argument_list|)
expr_stmt|;
name|cm
operator|->
name|cm_length
operator|=
name|le16toh
argument_list|(
name|mpi_reply
operator|->
name|Header
operator|.
name|PageLength
argument_list|)
operator|*
literal|4
expr_stmt|;
name|cm
operator|->
name|cm_sge
operator|=
operator|&
name|request
operator|->
name|PageBufferSGE
expr_stmt|;
name|cm
operator|->
name|cm_sglsize
operator|=
sizeof|sizeof
argument_list|(
name|MPI2_SGE_IO_UNION
argument_list|)
expr_stmt|;
name|cm
operator|->
name|cm_flags
operator|=
name|MPS_CM_FLAGS_SGE_SIMPLE
operator||
name|MPS_CM_FLAGS_DATAIN
expr_stmt|;
name|cm
operator|->
name|cm_desc
operator|.
name|Default
operator|.
name|RequestFlags
operator|=
name|MPI2_REQ_DESCRIPT_FLAGS_DEFAULT_TYPE
expr_stmt|;
name|page
operator|=
name|malloc
argument_list|(
name|cm
operator|->
name|cm_length
argument_list|,
name|M_MPT2
argument_list|,
name|M_ZERO
operator||
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|page
condition|)
block|{
name|printf
argument_list|(
literal|"%s: page alloc failed\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|cm
operator|->
name|cm_data
operator|=
name|page
expr_stmt|;
name|error
operator|=
name|mps_wait_command
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|,
literal|60
argument_list|,
name|CAN_SLEEP
argument_list|)
expr_stmt|;
name|reply
operator|=
operator|(
name|MPI2_CONFIG_REPLY
operator|*
operator|)
name|cm
operator|->
name|cm_reply
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|(
name|reply
operator|==
name|NULL
operator|)
condition|)
block|{
comment|/* FIXME */
comment|/* 		 * If the request returns an error then we need to do a diag 		 * reset 		 */
name|printf
argument_list|(
literal|"%s: request for page completed with error %d"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ioc_status
operator|=
name|le16toh
argument_list|(
name|reply
operator|->
name|IOCStatus
argument_list|)
operator|&
name|MPI2_IOCSTATUS_MASK
expr_stmt|;
name|bcopy
argument_list|(
name|reply
argument_list|,
name|mpi_reply
argument_list|,
sizeof|sizeof
argument_list|(
name|MPI2_CONFIG_REPLY
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioc_status
operator|!=
name|MPI2_IOCSTATUS_SUCCESS
condition|)
block|{
comment|/* FIXME */
comment|/* 		 * If the request returns an error then we need to do a diag 		 * reset 		 */
name|printf
argument_list|(
literal|"%s: page read with error; iocstatus = 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|ioc_status
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|bcopy
argument_list|(
name|page
argument_list|,
name|config_page
argument_list|,
name|MIN
argument_list|(
name|cm
operator|->
name|cm_length
argument_list|,
sizeof|sizeof
argument_list|(
name|Mpi2RaidVolPage1_t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|out
label|:
name|free
argument_list|(
name|page
argument_list|,
name|M_MPT2
argument_list|)
expr_stmt|;
if|if
condition|(
name|cm
condition|)
name|mps_free_command
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * mps_config_get_volume_wwid - returns wwid given the volume handle  * @sc: per adapter object  * @volume_handle: volume handle  * @wwid: volume wwid  * Context: sleep.  *  * Returns 0 for success, non-zero for failure.  */
end_comment

begin_function
name|int
name|mps_config_get_volume_wwid
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|u16
name|volume_handle
parameter_list|,
name|u64
modifier|*
name|wwid
parameter_list|)
block|{
name|Mpi2ConfigReply_t
name|mpi_reply
decl_stmt|;
name|Mpi2RaidVolPage1_t
name|raid_vol_pg1
decl_stmt|;
operator|*
name|wwid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|mps_config_get_raid_volume_pg1
argument_list|(
name|sc
argument_list|,
operator|&
name|mpi_reply
argument_list|,
operator|&
name|raid_vol_pg1
argument_list|,
name|MPI2_RAID_VOLUME_PGAD_FORM_HANDLE
argument_list|,
name|volume_handle
argument_list|)
operator|)
condition|)
block|{
operator|*
name|wwid
operator|=
name|le64toh
argument_list|(
operator|(
name|u64
operator|)
name|raid_vol_pg1
operator|.
name|WWID
operator|.
name|High
operator|<<
literal|32
operator||
name|raid_vol_pg1
operator|.
name|WWID
operator|.
name|Low
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  * mps_config_get_pd_pg0 - obtain raid phys disk page 0  * @sc: per adapter object  * @mpi_reply: reply mf payload returned from firmware  * @config_page: contents of the config page  * @page_address: form and handle value used to get page  * Context: sleep.  *  * Returns 0 for success, non-zero for failure.  */
end_comment

begin_function
name|int
name|mps_config_get_raid_pd_pg0
parameter_list|(
name|struct
name|mps_softc
modifier|*
name|sc
parameter_list|,
name|Mpi2ConfigReply_t
modifier|*
name|mpi_reply
parameter_list|,
name|Mpi2RaidPhysDiskPage0_t
modifier|*
name|config_page
parameter_list|,
name|u32
name|page_address
parameter_list|)
block|{
name|MPI2_CONFIG_REQUEST
modifier|*
name|request
decl_stmt|;
name|MPI2_CONFIG_REPLY
modifier|*
name|reply
decl_stmt|;
name|struct
name|mps_command
modifier|*
name|cm
decl_stmt|;
name|Mpi2RaidPhysDiskPage0_t
modifier|*
name|page
init|=
name|NULL
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|u16
name|ioc_status
decl_stmt|;
name|mps_dprint
argument_list|(
name|sc
argument_list|,
name|MPS_TRACE
argument_list|,
literal|"%s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cm
operator|=
name|mps_alloc_command
argument_list|(
name|sc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: command alloc failed @ line %d\n"
argument_list|,
name|__func__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|error
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|request
operator|=
operator|(
name|MPI2_CONFIG_REQUEST
operator|*
operator|)
name|cm
operator|->
name|cm_req
expr_stmt|;
name|bzero
argument_list|(
name|request
argument_list|,
sizeof|sizeof
argument_list|(
name|MPI2_CONFIG_REQUEST
argument_list|)
argument_list|)
expr_stmt|;
name|request
operator|->
name|Function
operator|=
name|MPI2_FUNCTION_CONFIG
expr_stmt|;
name|request
operator|->
name|Action
operator|=
name|MPI2_CONFIG_ACTION_PAGE_HEADER
expr_stmt|;
name|request
operator|->
name|Header
operator|.
name|PageType
operator|=
name|MPI2_CONFIG_PAGETYPE_RAID_PHYSDISK
expr_stmt|;
name|request
operator|->
name|Header
operator|.
name|PageNumber
operator|=
literal|0
expr_stmt|;
name|request
operator|->
name|Header
operator|.
name|PageVersion
operator|=
name|MPI2_RAIDPHYSDISKPAGE0_PAGEVERSION
expr_stmt|;
name|cm
operator|->
name|cm_desc
operator|.
name|Default
operator|.
name|RequestFlags
operator|=
name|MPI2_REQ_DESCRIPT_FLAGS_DEFAULT_TYPE
expr_stmt|;
name|cm
operator|->
name|cm_data
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * This page must be polled because the IOC isn't ready yet when this 	 * page is needed. 	 */
name|error
operator|=
name|mps_wait_command
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|,
literal|60
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|reply
operator|=
operator|(
name|MPI2_CONFIG_REPLY
operator|*
operator|)
name|cm
operator|->
name|cm_reply
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|(
name|reply
operator|==
name|NULL
operator|)
condition|)
block|{
comment|/* FIXME */
comment|/* If the poll returns error then we need to do diag reset */
name|printf
argument_list|(
literal|"%s: poll for header completed with error %d"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ioc_status
operator|=
name|le16toh
argument_list|(
name|reply
operator|->
name|IOCStatus
argument_list|)
operator|&
name|MPI2_IOCSTATUS_MASK
expr_stmt|;
name|bcopy
argument_list|(
name|reply
argument_list|,
name|mpi_reply
argument_list|,
sizeof|sizeof
argument_list|(
name|MPI2_CONFIG_REPLY
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioc_status
operator|!=
name|MPI2_IOCSTATUS_SUCCESS
condition|)
block|{
comment|/* FIXME */
comment|/* If the poll returns error then we need to do diag reset */
name|printf
argument_list|(
literal|"%s: header read with error; iocstatus = 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|ioc_status
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* We have to do free and alloc for the reply-free and reply-post 	 * counters to match - Need to review the reply FIFO handling. 	 */
name|mps_free_command
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cm
operator|=
name|mps_alloc_command
argument_list|(
name|sc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: command alloc failed @ line %d\n"
argument_list|,
name|__func__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|error
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|request
operator|=
operator|(
name|MPI2_CONFIG_REQUEST
operator|*
operator|)
name|cm
operator|->
name|cm_req
expr_stmt|;
name|bzero
argument_list|(
name|request
argument_list|,
sizeof|sizeof
argument_list|(
name|MPI2_CONFIG_REQUEST
argument_list|)
argument_list|)
expr_stmt|;
name|request
operator|->
name|Function
operator|=
name|MPI2_FUNCTION_CONFIG
expr_stmt|;
name|request
operator|->
name|Action
operator|=
name|MPI2_CONFIG_ACTION_PAGE_READ_CURRENT
expr_stmt|;
name|request
operator|->
name|Header
operator|.
name|PageType
operator|=
name|MPI2_CONFIG_PAGETYPE_RAID_PHYSDISK
expr_stmt|;
name|request
operator|->
name|Header
operator|.
name|PageNumber
operator|=
literal|0
expr_stmt|;
name|request
operator|->
name|Header
operator|.
name|PageLength
operator|=
name|mpi_reply
operator|->
name|Header
operator|.
name|PageLength
expr_stmt|;
name|request
operator|->
name|Header
operator|.
name|PageVersion
operator|=
name|mpi_reply
operator|->
name|Header
operator|.
name|PageVersion
expr_stmt|;
name|request
operator|->
name|PageAddress
operator|=
name|page_address
expr_stmt|;
name|cm
operator|->
name|cm_length
operator|=
name|le16toh
argument_list|(
name|mpi_reply
operator|->
name|Header
operator|.
name|PageLength
argument_list|)
operator|*
literal|4
expr_stmt|;
name|cm
operator|->
name|cm_sge
operator|=
operator|&
name|request
operator|->
name|PageBufferSGE
expr_stmt|;
name|cm
operator|->
name|cm_sglsize
operator|=
sizeof|sizeof
argument_list|(
name|MPI2_SGE_IO_UNION
argument_list|)
expr_stmt|;
name|cm
operator|->
name|cm_flags
operator|=
name|MPS_CM_FLAGS_SGE_SIMPLE
operator||
name|MPS_CM_FLAGS_DATAIN
expr_stmt|;
name|cm
operator|->
name|cm_desc
operator|.
name|Default
operator|.
name|RequestFlags
operator|=
name|MPI2_REQ_DESCRIPT_FLAGS_DEFAULT_TYPE
expr_stmt|;
name|page
operator|=
name|malloc
argument_list|(
name|cm
operator|->
name|cm_length
argument_list|,
name|M_MPT2
argument_list|,
name|M_ZERO
operator||
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|page
condition|)
block|{
name|printf
argument_list|(
literal|"%s: page alloc failed\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|cm
operator|->
name|cm_data
operator|=
name|page
expr_stmt|;
comment|/* 	 * This page must be polled because the IOC isn't ready yet when this 	 * page is needed. 	 */
name|error
operator|=
name|mps_wait_command
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|,
literal|60
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|reply
operator|=
operator|(
name|MPI2_CONFIG_REPLY
operator|*
operator|)
name|cm
operator|->
name|cm_reply
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|(
name|reply
operator|==
name|NULL
operator|)
condition|)
block|{
comment|/* FIXME */
comment|/* If the poll returns error then we need to do diag reset */
name|printf
argument_list|(
literal|"%s: poll for page completed with error %d"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ioc_status
operator|=
name|le16toh
argument_list|(
name|reply
operator|->
name|IOCStatus
argument_list|)
operator|&
name|MPI2_IOCSTATUS_MASK
expr_stmt|;
name|bcopy
argument_list|(
name|reply
argument_list|,
name|mpi_reply
argument_list|,
sizeof|sizeof
argument_list|(
name|MPI2_CONFIG_REPLY
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioc_status
operator|!=
name|MPI2_IOCSTATUS_SUCCESS
condition|)
block|{
comment|/* FIXME */
comment|/* If the poll returns error then we need to do diag reset */
name|printf
argument_list|(
literal|"%s: page read with error; iocstatus = 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|ioc_status
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|bcopy
argument_list|(
name|page
argument_list|,
name|config_page
argument_list|,
name|MIN
argument_list|(
name|cm
operator|->
name|cm_length
argument_list|,
sizeof|sizeof
argument_list|(
name|Mpi2RaidPhysDiskPage0_t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|out
label|:
name|free
argument_list|(
name|page
argument_list|,
name|M_MPT2
argument_list|)
expr_stmt|;
if|if
condition|(
name|cm
condition|)
name|mps_free_command
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

end_unit

