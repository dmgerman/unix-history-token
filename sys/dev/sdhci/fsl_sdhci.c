begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2013 Ian Lepore<ian@freebsd.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * SDHCI driver glue for Freescale i.MX SoC and QorIQ families.  *  * This supports both eSDHC (earlier SoCs) and uSDHC (more recent SoCs).  */
end_comment

begin_include
include|#
directive|include
file|"opt_mmccam.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/callout.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/libkern.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__arm__
end_ifdef

begin_include
include|#
directive|include
file|<machine/intr.h>
end_include

begin_include
include|#
directive|include
file|<arm/freescale/imx/imx_ccmvar.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__powerpc__
end_ifdef

begin_include
include|#
directive|include
file|<powerpc/mpc85xx/mpc85xx.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<dev/gpio/gpiobusvar.h>
end_include

begin_include
include|#
directive|include
file|<dev/ofw/ofw_bus.h>
end_include

begin_include
include|#
directive|include
file|<dev/ofw/ofw_bus_subr.h>
end_include

begin_include
include|#
directive|include
file|<dev/mmc/bridge.h>
end_include

begin_include
include|#
directive|include
file|<dev/sdhci/sdhci.h>
end_include

begin_include
include|#
directive|include
file|<dev/sdhci/sdhci_fdt_gpio.h>
end_include

begin_include
include|#
directive|include
file|"mmcbr_if.h"
end_include

begin_include
include|#
directive|include
file|"sdhci_if.h"
end_include

begin_struct
struct|struct
name|fsl_sdhci_softc
block|{
name|device_t
name|dev
decl_stmt|;
name|struct
name|resource
modifier|*
name|mem_res
decl_stmt|;
name|struct
name|resource
modifier|*
name|irq_res
decl_stmt|;
name|void
modifier|*
name|intr_cookie
decl_stmt|;
name|struct
name|sdhci_slot
name|slot
decl_stmt|;
name|struct
name|callout
name|r1bfix_callout
decl_stmt|;
name|sbintime_t
name|r1bfix_timeout_at
decl_stmt|;
name|struct
name|sdhci_fdt_gpio
modifier|*
name|gpio
decl_stmt|;
name|uint32_t
name|baseclk_hz
decl_stmt|;
name|uint32_t
name|cmd_and_mode
decl_stmt|;
name|uint32_t
name|r1bfix_intmask
decl_stmt|;
name|uint16_t
name|sdclockreg_freq_bits
decl_stmt|;
name|uint8_t
name|r1bfix_type
decl_stmt|;
name|uint8_t
name|hwtype
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|R1BFIX_NONE
value|0
end_define

begin_comment
comment|/* No fix needed at next interrupt. */
end_comment

begin_define
define|#
directive|define
name|R1BFIX_NODATA
value|1
end_define

begin_comment
comment|/* Synthesize DATA_END for R1B w/o data. */
end_comment

begin_define
define|#
directive|define
name|R1BFIX_AC12
value|2
end_define

begin_comment
comment|/* Wait for busy after auto command 12. */
end_comment

begin_define
define|#
directive|define
name|HWTYPE_NONE
value|0
end_define

begin_comment
comment|/* Hardware not recognized/supported. */
end_comment

begin_define
define|#
directive|define
name|HWTYPE_ESDHC
value|1
end_define

begin_comment
comment|/* fsl5x and earlier. */
end_comment

begin_define
define|#
directive|define
name|HWTYPE_USDHC
value|2
end_define

begin_comment
comment|/* fsl6. */
end_comment

begin_comment
comment|/*  * Freescale-specific registers, or in some cases the layout of bits within the  * sdhci-defined register is different on Freescale.  These names all begin with  * SDHC_ (not SDHCI_).  */
end_comment

begin_define
define|#
directive|define
name|SDHC_WTMK_LVL
value|0x44
end_define

begin_comment
comment|/* Watermark Level register. */
end_comment

begin_define
define|#
directive|define
name|USDHC_MIX_CONTROL
value|0x48
end_define

begin_comment
comment|/* Mix(ed) Control register. */
end_comment

begin_define
define|#
directive|define
name|SDHC_VEND_SPEC
value|0xC0
end_define

begin_comment
comment|/* Vendor-specific register. */
end_comment

begin_define
define|#
directive|define
name|SDHC_VEND_FRC_SDCLK_ON
value|(1<<  8)
end_define

begin_define
define|#
directive|define
name|SDHC_VEND_IPGEN
value|(1<< 11)
end_define

begin_define
define|#
directive|define
name|SDHC_VEND_HCKEN
value|(1<< 12)
end_define

begin_define
define|#
directive|define
name|SDHC_VEND_PEREN
value|(1<< 13)
end_define

begin_define
define|#
directive|define
name|SDHC_PRES_STATE
value|0x24
end_define

begin_define
define|#
directive|define
name|SDHC_PRES_CIHB
value|(1<<  0)
end_define

begin_define
define|#
directive|define
name|SDHC_PRES_CDIHB
value|(1<<  1)
end_define

begin_define
define|#
directive|define
name|SDHC_PRES_DLA
value|(1<<  2)
end_define

begin_define
define|#
directive|define
name|SDHC_PRES_SDSTB
value|(1<<  3)
end_define

begin_define
define|#
directive|define
name|SDHC_PRES_IPGOFF
value|(1<<  4)
end_define

begin_define
define|#
directive|define
name|SDHC_PRES_HCKOFF
value|(1<<  5)
end_define

begin_define
define|#
directive|define
name|SDHC_PRES_PEROFF
value|(1<<  6)
end_define

begin_define
define|#
directive|define
name|SDHC_PRES_SDOFF
value|(1<<  7)
end_define

begin_define
define|#
directive|define
name|SDHC_PRES_WTA
value|(1<<  8)
end_define

begin_define
define|#
directive|define
name|SDHC_PRES_RTA
value|(1<<  9)
end_define

begin_define
define|#
directive|define
name|SDHC_PRES_BWEN
value|(1<< 10)
end_define

begin_define
define|#
directive|define
name|SDHC_PRES_BREN
value|(1<< 11)
end_define

begin_define
define|#
directive|define
name|SDHC_PRES_RTR
value|(1<< 12)
end_define

begin_define
define|#
directive|define
name|SDHC_PRES_CINST
value|(1<< 16)
end_define

begin_define
define|#
directive|define
name|SDHC_PRES_CDPL
value|(1<< 18)
end_define

begin_define
define|#
directive|define
name|SDHC_PRES_WPSPL
value|(1<< 19)
end_define

begin_define
define|#
directive|define
name|SDHC_PRES_CLSL
value|(1<< 23)
end_define

begin_define
define|#
directive|define
name|SDHC_PRES_DLSL_SHIFT
value|24
end_define

begin_define
define|#
directive|define
name|SDHC_PRES_DLSL_MASK
value|(0xffU<< SDHC_PRES_DLSL_SHIFT)
end_define

begin_define
define|#
directive|define
name|SDHC_PROT_CTRL
value|0x28
end_define

begin_define
define|#
directive|define
name|SDHC_PROT_LED
value|(1<< 0)
end_define

begin_define
define|#
directive|define
name|SDHC_PROT_WIDTH_1BIT
value|(0<< 1)
end_define

begin_define
define|#
directive|define
name|SDHC_PROT_WIDTH_4BIT
value|(1<< 1)
end_define

begin_define
define|#
directive|define
name|SDHC_PROT_WIDTH_8BIT
value|(2<< 1)
end_define

begin_define
define|#
directive|define
name|SDHC_PROT_WIDTH_MASK
value|(3<< 1)
end_define

begin_define
define|#
directive|define
name|SDHC_PROT_D3CD
value|(1<< 3)
end_define

begin_define
define|#
directive|define
name|SDHC_PROT_EMODE_BIG
value|(0<< 4)
end_define

begin_define
define|#
directive|define
name|SDHC_PROT_EMODE_HALF
value|(1<< 4)
end_define

begin_define
define|#
directive|define
name|SDHC_PROT_EMODE_LITTLE
value|(2<< 4)
end_define

begin_define
define|#
directive|define
name|SDHC_PROT_EMODE_MASK
value|(3<< 4)
end_define

begin_define
define|#
directive|define
name|SDHC_PROT_SDMA
value|(0<< 8)
end_define

begin_define
define|#
directive|define
name|SDHC_PROT_ADMA1
value|(1<< 8)
end_define

begin_define
define|#
directive|define
name|SDHC_PROT_ADMA2
value|(2<< 8)
end_define

begin_define
define|#
directive|define
name|SDHC_PROT_ADMA264
value|(3<< 8)
end_define

begin_define
define|#
directive|define
name|SDHC_PROT_DMA_MASK
value|(3<< 8)
end_define

begin_define
define|#
directive|define
name|SDHC_PROT_CDTL
value|(1<< 6)
end_define

begin_define
define|#
directive|define
name|SDHC_PROT_CDSS
value|(1<< 7)
end_define

begin_define
define|#
directive|define
name|SDHC_SYS_CTRL
value|0x2c
end_define

begin_comment
comment|/*  * The clock enable bits exist in different registers for ESDHC vs USDHC, but  * they are the same bits in both cases.  The divisor values go into the  * standard sdhci clock register, but in different bit positions and meanings    than the sdhci spec values.  */
end_comment

begin_define
define|#
directive|define
name|SDHC_CLK_IPGEN
value|(1<< 0)
end_define

begin_define
define|#
directive|define
name|SDHC_CLK_HCKEN
value|(1<< 1)
end_define

begin_define
define|#
directive|define
name|SDHC_CLK_PEREN
value|(1<< 2)
end_define

begin_define
define|#
directive|define
name|SDHC_CLK_SDCLKEN
value|(1<< 3)
end_define

begin_define
define|#
directive|define
name|SDHC_CLK_ENABLE_MASK
value|0x0000000f
end_define

begin_define
define|#
directive|define
name|SDHC_CLK_DIVISOR_MASK
value|0x000000f0
end_define

begin_define
define|#
directive|define
name|SDHC_CLK_DIVISOR_SHIFT
value|4
end_define

begin_define
define|#
directive|define
name|SDHC_CLK_PRESCALE_MASK
value|0x0000ff00
end_define

begin_define
define|#
directive|define
name|SDHC_CLK_PRESCALE_SHIFT
value|8
end_define

begin_decl_stmt
specifier|static
name|struct
name|ofw_compat_data
name|compat_data
index|[]
init|=
block|{
block|{
literal|"fsl,imx6q-usdhc"
block|,
name|HWTYPE_USDHC
block|}
block|,
block|{
literal|"fsl,imx6sl-usdhc"
block|,
name|HWTYPE_USDHC
block|}
block|,
block|{
literal|"fsl,imx53-esdhc"
block|,
name|HWTYPE_ESDHC
block|}
block|,
block|{
literal|"fsl,imx51-esdhc"
block|,
name|HWTYPE_ESDHC
block|}
block|,
block|{
literal|"fsl,esdhc"
block|,
name|HWTYPE_ESDHC
block|}
block|,
block|{
name|NULL
block|,
name|HWTYPE_NONE
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|uint16_t
name|fsl_sdhc_get_clock
parameter_list|(
name|struct
name|fsl_sdhci_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fsl_sdhc_set_clock
parameter_list|(
name|struct
name|fsl_sdhci_softc
modifier|*
name|sc
parameter_list|,
name|uint16_t
name|val
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fsl_sdhci_r1bfix_func
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
specifier|inline
name|uint32_t
name|RD4
parameter_list|(
name|struct
name|fsl_sdhci_softc
modifier|*
name|sc
parameter_list|,
name|bus_size_t
name|off
parameter_list|)
block|{
return|return
operator|(
name|bus_read_4
argument_list|(
name|sc
operator|->
name|mem_res
argument_list|,
name|off
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|WR4
parameter_list|(
name|struct
name|fsl_sdhci_softc
modifier|*
name|sc
parameter_list|,
name|bus_size_t
name|off
parameter_list|,
name|uint32_t
name|val
parameter_list|)
block|{
name|bus_write_4
argument_list|(
name|sc
operator|->
name|mem_res
argument_list|,
name|off
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uint8_t
name|fsl_sdhci_read_1
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|sdhci_slot
modifier|*
name|slot
parameter_list|,
name|bus_size_t
name|off
parameter_list|)
block|{
name|struct
name|fsl_sdhci_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|uint32_t
name|val32
decl_stmt|,
name|wrk32
decl_stmt|;
comment|/* 	 * Most of the things in the standard host control register are in the 	 * hardware's wider protocol control register, but some of the bits are 	 * moved around. 	 */
if|if
condition|(
name|off
operator|==
name|SDHCI_HOST_CONTROL
condition|)
block|{
name|wrk32
operator|=
name|RD4
argument_list|(
name|sc
argument_list|,
name|SDHC_PROT_CTRL
argument_list|)
expr_stmt|;
name|val32
operator|=
name|wrk32
operator|&
operator|(
name|SDHCI_CTRL_LED
operator||
name|SDHCI_CTRL_CARD_DET
operator||
name|SDHCI_CTRL_FORCE_CARD
operator|)
expr_stmt|;
switch|switch
condition|(
name|wrk32
operator|&
name|SDHC_PROT_WIDTH_MASK
condition|)
block|{
case|case
name|SDHC_PROT_WIDTH_1BIT
case|:
comment|/* Value is already 0. */
break|break;
case|case
name|SDHC_PROT_WIDTH_4BIT
case|:
name|val32
operator||=
name|SDHCI_CTRL_4BITBUS
expr_stmt|;
break|break;
case|case
name|SDHC_PROT_WIDTH_8BIT
case|:
name|val32
operator||=
name|SDHCI_CTRL_8BITBUS
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|wrk32
operator|&
name|SDHC_PROT_DMA_MASK
condition|)
block|{
case|case
name|SDHC_PROT_SDMA
case|:
comment|/* Value is already 0. */
break|break;
case|case
name|SDHC_PROT_ADMA1
case|:
comment|/* This value is deprecated, should never appear. */
break|break;
case|case
name|SDHC_PROT_ADMA2
case|:
name|val32
operator||=
name|SDHCI_CTRL_ADMA2
expr_stmt|;
break|break;
case|case
name|SDHC_PROT_ADMA264
case|:
name|val32
operator||=
name|SDHCI_CTRL_ADMA264
expr_stmt|;
break|break;
block|}
return|return
name|val32
return|;
block|}
comment|/* 	 * XXX can't find the bus power on/off knob.  For now we have to say the 	 * power is always on and always set to the same voltage. 	 */
if|if
condition|(
name|off
operator|==
name|SDHCI_POWER_CONTROL
condition|)
block|{
return|return
operator|(
name|SDHCI_POWER_ON
operator||
name|SDHCI_POWER_300
operator|)
return|;
block|}
return|return
operator|(
operator|(
name|RD4
argument_list|(
name|sc
argument_list|,
name|off
operator|&
operator|~
literal|3
argument_list|)
operator|>>
operator|(
name|off
operator|&
literal|3
operator|)
operator|*
literal|8
operator|)
operator|&
literal|0xff
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint16_t
name|fsl_sdhci_read_2
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|sdhci_slot
modifier|*
name|slot
parameter_list|,
name|bus_size_t
name|off
parameter_list|)
block|{
name|struct
name|fsl_sdhci_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|uint32_t
name|val32
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|hwtype
operator|==
name|HWTYPE_USDHC
condition|)
block|{
comment|/* 		 * The USDHC hardware has nothing in the version register, but 		 * it's v3 compatible with all our translation code. 		 */
if|if
condition|(
name|off
operator|==
name|SDHCI_HOST_VERSION
condition|)
block|{
return|return
operator|(
name|SDHCI_SPEC_300
operator|<<
name|SDHCI_SPEC_VER_SHIFT
operator|)
return|;
block|}
comment|/* 		 * The USDHC hardware moved the transfer mode bits to the mixed 		 * control register, fetch them from there. 		 */
if|if
condition|(
name|off
operator|==
name|SDHCI_TRANSFER_MODE
condition|)
return|return
operator|(
name|RD4
argument_list|(
name|sc
argument_list|,
name|USDHC_MIX_CONTROL
argument_list|)
operator|&
literal|0x37
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|hwtype
operator|==
name|HWTYPE_ESDHC
condition|)
block|{
comment|/* 		 * The ESDHC hardware has the typical 32-bit combined "command 		 * and mode" register that we have to cache so that command 		 * isn't written until after mode.  On a read, just retrieve the 		 * cached values last written. 		 */
if|if
condition|(
name|off
operator|==
name|SDHCI_TRANSFER_MODE
condition|)
block|{
return|return
operator|(
name|sc
operator|->
name|cmd_and_mode
operator|&
literal|0x0000ffff
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|off
operator|==
name|SDHCI_COMMAND_FLAGS
condition|)
block|{
return|return
operator|(
name|sc
operator|->
name|cmd_and_mode
operator|>>
literal|16
operator|)
return|;
block|}
block|}
comment|/* 	 * This hardware only manages one slot.  Synthesize a slot interrupt 	 * status register... if there are any enabled interrupts active they 	 * must be coming from our one and only slot. 	 */
if|if
condition|(
name|off
operator|==
name|SDHCI_SLOT_INT_STATUS
condition|)
block|{
name|val32
operator|=
name|RD4
argument_list|(
name|sc
argument_list|,
name|SDHCI_INT_STATUS
argument_list|)
expr_stmt|;
name|val32
operator|&=
name|RD4
argument_list|(
name|sc
argument_list|,
name|SDHCI_SIGNAL_ENABLE
argument_list|)
expr_stmt|;
return|return
operator|(
name|val32
condition|?
literal|1
else|:
literal|0
operator|)
return|;
block|}
comment|/* 	 * Clock bits are scattered into various registers which differ by 	 * hardware type, complex enough to have their own function. 	 */
if|if
condition|(
name|off
operator|==
name|SDHCI_CLOCK_CONTROL
condition|)
block|{
return|return
operator|(
name|fsl_sdhc_get_clock
argument_list|(
name|sc
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
operator|(
name|RD4
argument_list|(
name|sc
argument_list|,
name|off
operator|&
operator|~
literal|3
argument_list|)
operator|>>
operator|(
name|off
operator|&
literal|3
operator|)
operator|*
literal|8
operator|)
operator|&
literal|0xffff
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|fsl_sdhci_read_4
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|sdhci_slot
modifier|*
name|slot
parameter_list|,
name|bus_size_t
name|off
parameter_list|)
block|{
name|struct
name|fsl_sdhci_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|uint32_t
name|val32
decl_stmt|,
name|wrk32
decl_stmt|;
name|val32
operator|=
name|RD4
argument_list|(
name|sc
argument_list|,
name|off
argument_list|)
expr_stmt|;
comment|/* 	 * The hardware leaves the base clock frequency out of the capabilities 	 * register, but we filled it in by setting slot->max_clk at attach time 	 * rather than here, because we can't represent frequencies above 63MHz 	 * in an sdhci 2.0 capabliities register.  The timeout clock is the same 	 * as the active output sdclock; we indicate that with a quirk setting 	 * so don't populate the timeout frequency bits. 	 * 	 * XXX Turn off (for now) features the hardware can do but this driver 	 * doesn't yet handle (1.8v, suspend/resume, etc). 	 */
if|if
condition|(
name|off
operator|==
name|SDHCI_CAPABILITIES
condition|)
block|{
name|val32
operator|&=
operator|~
name|SDHCI_CAN_VDD_180
expr_stmt|;
name|val32
operator|&=
operator|~
name|SDHCI_CAN_DO_SUSPEND
expr_stmt|;
name|val32
operator||=
name|SDHCI_CAN_DO_8BITBUS
expr_stmt|;
return|return
operator|(
name|val32
operator|)
return|;
block|}
comment|/* 	 * The hardware moves bits around in the present state register to make 	 * room for all 8 data line state bits.  To translate, mask out all the 	 * bits which are not in the same position in both registers (this also 	 * masks out some Freescale-specific bits in locations defined as 	 * reserved by sdhci), then shift the data line and retune request bits 	 * down to their standard locations. 	 */
if|if
condition|(
name|off
operator|==
name|SDHCI_PRESENT_STATE
condition|)
block|{
name|wrk32
operator|=
name|val32
expr_stmt|;
name|val32
operator|&=
literal|0x000F0F07
expr_stmt|;
name|val32
operator||=
operator|(
name|wrk32
operator|>>
literal|4
operator|)
operator|&
name|SDHCI_STATE_DAT_MASK
expr_stmt|;
name|val32
operator||=
operator|(
name|wrk32
operator|>>
literal|9
operator|)
operator|&
name|SDHCI_RETUNE_REQUEST
expr_stmt|;
return|return
operator|(
name|val32
operator|)
return|;
block|}
comment|/* 	 * fsl_sdhci_intr() can synthesize a DATA_END interrupt following a 	 * command with an R1B response, mix it into the hardware status. 	 */
if|if
condition|(
name|off
operator|==
name|SDHCI_INT_STATUS
condition|)
block|{
return|return
operator|(
name|val32
operator||
name|sc
operator|->
name|r1bfix_intmask
operator|)
return|;
block|}
return|return
name|val32
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fsl_sdhci_read_multi_4
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|sdhci_slot
modifier|*
name|slot
parameter_list|,
name|bus_size_t
name|off
parameter_list|,
name|uint32_t
modifier|*
name|data
parameter_list|,
name|bus_size_t
name|count
parameter_list|)
block|{
name|struct
name|fsl_sdhci_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|bus_read_multi_4
argument_list|(
name|sc
operator|->
name|mem_res
argument_list|,
name|off
argument_list|,
name|data
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fsl_sdhci_write_1
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|sdhci_slot
modifier|*
name|slot
parameter_list|,
name|bus_size_t
name|off
parameter_list|,
name|uint8_t
name|val
parameter_list|)
block|{
name|struct
name|fsl_sdhci_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|uint32_t
name|val32
decl_stmt|;
comment|/* 	 * Most of the things in the standard host control register are in the 	 * hardware's wider protocol control register, but some of the bits are 	 * moved around. 	 */
if|if
condition|(
name|off
operator|==
name|SDHCI_HOST_CONTROL
condition|)
block|{
name|val32
operator|=
name|RD4
argument_list|(
name|sc
argument_list|,
name|SDHC_PROT_CTRL
argument_list|)
expr_stmt|;
name|val32
operator|&=
operator|~
operator|(
name|SDHC_PROT_LED
operator||
name|SDHC_PROT_DMA_MASK
operator||
name|SDHC_PROT_WIDTH_MASK
operator||
name|SDHC_PROT_CDTL
operator||
name|SDHC_PROT_CDSS
operator|)
expr_stmt|;
name|val32
operator||=
operator|(
name|val
operator|&
name|SDHCI_CTRL_LED
operator|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
name|SDHCI_CTRL_8BITBUS
condition|)
name|val32
operator||=
name|SDHC_PROT_WIDTH_8BIT
expr_stmt|;
else|else
name|val32
operator||=
operator|(
name|val
operator|&
name|SDHCI_CTRL_4BITBUS
operator|)
expr_stmt|;
name|val32
operator||=
operator|(
name|val
operator|&
operator|(
name|SDHCI_CTRL_SDMA
operator||
name|SDHCI_CTRL_ADMA2
operator|)
operator|)
operator|<<
literal|4
expr_stmt|;
name|val32
operator||=
operator|(
name|val
operator|&
operator|(
name|SDHCI_CTRL_CARD_DET
operator||
name|SDHCI_CTRL_FORCE_CARD
operator|)
operator|)
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|SDHC_PROT_CTRL
argument_list|,
name|val32
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* XXX I can't find the bus power on/off knob; do nothing. */
if|if
condition|(
name|off
operator|==
name|SDHCI_POWER_CONTROL
condition|)
block|{
return|return;
block|}
ifdef|#
directive|ifdef
name|__powerpc__
comment|/* XXX Reset doesn't seem to work as expected.  Do nothing for now. */
if|if
condition|(
name|off
operator|==
name|SDHCI_SOFTWARE_RESET
condition|)
return|return;
endif|#
directive|endif
name|val32
operator|=
name|RD4
argument_list|(
name|sc
argument_list|,
name|off
operator|&
operator|~
literal|3
argument_list|)
expr_stmt|;
name|val32
operator|&=
operator|~
operator|(
literal|0xff
operator|<<
operator|(
name|off
operator|&
literal|3
operator|)
operator|*
literal|8
operator|)
expr_stmt|;
name|val32
operator||=
operator|(
name|val
operator|<<
operator|(
name|off
operator|&
literal|3
operator|)
operator|*
literal|8
operator|)
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|off
operator|&
operator|~
literal|3
argument_list|,
name|val32
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fsl_sdhci_write_2
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|sdhci_slot
modifier|*
name|slot
parameter_list|,
name|bus_size_t
name|off
parameter_list|,
name|uint16_t
name|val
parameter_list|)
block|{
name|struct
name|fsl_sdhci_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|uint32_t
name|val32
decl_stmt|;
comment|/* 	 * The clock control stuff is complex enough to have its own function 	 * that can handle the ESDHC versus USDHC differences. 	 */
if|if
condition|(
name|off
operator|==
name|SDHCI_CLOCK_CONTROL
condition|)
block|{
name|fsl_sdhc_set_clock
argument_list|(
name|sc
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Figure out whether we need to check the DAT0 line for busy status at 	 * interrupt time.  The controller should be doing this, but for some 	 * reason it doesn't.  There are two cases: 	 *  - R1B response with no data transfer should generate a DATA_END (aka 	 *    TRANSFER_COMPLETE) interrupt after waiting for busy, but if 	 *    there's no data transfer there's no DATA_END interrupt.  This is 	 *    documented; they seem to think it's a feature. 	 *  - R1B response after Auto-CMD12 appears to not work, even though 	 *    there's a control bit for it (bit 3) in the vendor register. 	 * When we're starting a command that needs a manual DAT0 line check at 	 * interrupt time, we leave ourselves a note in r1bfix_type so that we 	 * can do the extra work in fsl_sdhci_intr(). 	 */
if|if
condition|(
name|off
operator|==
name|SDHCI_COMMAND_FLAGS
condition|)
block|{
if|if
condition|(
name|val
operator|&
name|SDHCI_CMD_DATA
condition|)
block|{
specifier|const
name|uint32_t
name|MBAUTOCMD
init|=
name|SDHCI_TRNS_ACMD12
operator||
name|SDHCI_TRNS_MULTI
decl_stmt|;
name|val32
operator|=
name|RD4
argument_list|(
name|sc
argument_list|,
name|USDHC_MIX_CONTROL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|val32
operator|&
name|MBAUTOCMD
operator|)
operator|==
name|MBAUTOCMD
condition|)
name|sc
operator|->
name|r1bfix_type
operator|=
name|R1BFIX_AC12
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|val
operator|&
name|SDHCI_CMD_RESP_MASK
operator|)
operator|==
name|SDHCI_CMD_RESP_SHORT_BUSY
condition|)
block|{
name|WR4
argument_list|(
name|sc
argument_list|,
name|SDHCI_INT_ENABLE
argument_list|,
name|slot
operator|->
name|intmask
operator||
name|SDHCI_INT_RESPONSE
argument_list|)
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|SDHCI_SIGNAL_ENABLE
argument_list|,
name|slot
operator|->
name|intmask
operator||
name|SDHCI_INT_RESPONSE
argument_list|)
expr_stmt|;
name|sc
operator|->
name|r1bfix_type
operator|=
name|R1BFIX_NODATA
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * The USDHC hardware moved the transfer mode bits to mixed control; we 	 * just write them there and we're done.  The ESDHC hardware has the 	 * typical combined cmd-and-mode register that allows only 32-bit 	 * access, so when writing the mode bits just save them, then later when 	 * writing the command bits, add in the saved mode bits. 	 */
if|if
condition|(
name|sc
operator|->
name|hwtype
operator|==
name|HWTYPE_USDHC
condition|)
block|{
if|if
condition|(
name|off
operator|==
name|SDHCI_TRANSFER_MODE
condition|)
block|{
name|val32
operator|=
name|RD4
argument_list|(
name|sc
argument_list|,
name|USDHC_MIX_CONTROL
argument_list|)
expr_stmt|;
name|val32
operator|&=
operator|~
literal|0x3f
expr_stmt|;
name|val32
operator||=
name|val
operator|&
literal|0x37
expr_stmt|;
comment|// XXX acmd23 not supported here (or by sdhci driver)
name|WR4
argument_list|(
name|sc
argument_list|,
name|USDHC_MIX_CONTROL
argument_list|,
name|val32
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|hwtype
operator|==
name|HWTYPE_ESDHC
condition|)
block|{
if|if
condition|(
name|off
operator|==
name|SDHCI_TRANSFER_MODE
condition|)
block|{
name|sc
operator|->
name|cmd_and_mode
operator|=
operator|(
name|sc
operator|->
name|cmd_and_mode
operator|&
literal|0xffff0000
operator|)
operator||
name|val
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|off
operator|==
name|SDHCI_COMMAND_FLAGS
condition|)
block|{
name|sc
operator|->
name|cmd_and_mode
operator|=
operator|(
name|sc
operator|->
name|cmd_and_mode
operator|&
literal|0xffff
operator|)
operator||
operator|(
name|val
operator|<<
literal|16
operator|)
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|SDHCI_TRANSFER_MODE
argument_list|,
name|sc
operator|->
name|cmd_and_mode
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|val32
operator|=
name|RD4
argument_list|(
name|sc
argument_list|,
name|off
operator|&
operator|~
literal|3
argument_list|)
expr_stmt|;
name|val32
operator|&=
operator|~
operator|(
literal|0xffff
operator|<<
operator|(
name|off
operator|&
literal|3
operator|)
operator|*
literal|8
operator|)
expr_stmt|;
name|val32
operator||=
operator|(
operator|(
name|val
operator|&
literal|0xffff
operator|)
operator|<<
operator|(
name|off
operator|&
literal|3
operator|)
operator|*
literal|8
operator|)
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|off
operator|&
operator|~
literal|3
argument_list|,
name|val32
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fsl_sdhci_write_4
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|sdhci_slot
modifier|*
name|slot
parameter_list|,
name|bus_size_t
name|off
parameter_list|,
name|uint32_t
name|val
parameter_list|)
block|{
name|struct
name|fsl_sdhci_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
comment|/* Clear synthesized interrupts, then pass the value to the hardware. */
if|if
condition|(
name|off
operator|==
name|SDHCI_INT_STATUS
condition|)
block|{
name|sc
operator|->
name|r1bfix_intmask
operator|&=
operator|~
name|val
expr_stmt|;
block|}
name|WR4
argument_list|(
name|sc
argument_list|,
name|off
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fsl_sdhci_write_multi_4
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|sdhci_slot
modifier|*
name|slot
parameter_list|,
name|bus_size_t
name|off
parameter_list|,
name|uint32_t
modifier|*
name|data
parameter_list|,
name|bus_size_t
name|count
parameter_list|)
block|{
name|struct
name|fsl_sdhci_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|bus_write_multi_4
argument_list|(
name|sc
operator|->
name|mem_res
argument_list|,
name|off
argument_list|,
name|data
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uint16_t
name|fsl_sdhc_get_clock
parameter_list|(
name|struct
name|fsl_sdhci_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint16_t
name|val
decl_stmt|;
comment|/* 	 * Whenever the sdhci driver writes the clock register we save a 	 * snapshot of just the frequency bits, so that we can play them back 	 * here on a register read without recalculating the frequency from the 	 * prescalar and divisor bits in the real register.  We'll start with 	 * those bits, and mix in the clock status and enable bits that come 	 * from different places depending on which hardware we've got. 	 */
name|val
operator|=
name|sc
operator|->
name|sdclockreg_freq_bits
expr_stmt|;
comment|/* 	 * The internal clock is always enabled (actually, the hardware manages 	 * it).  Whether the internal clock is stable yet after a frequency 	 * change comes from the present-state register on both hardware types. 	 */
name|val
operator||=
name|SDHCI_CLOCK_INT_EN
expr_stmt|;
if|if
condition|(
name|RD4
argument_list|(
name|sc
argument_list|,
name|SDHC_PRES_STATE
argument_list|)
operator|&
name|SDHC_PRES_SDSTB
condition|)
name|val
operator||=
name|SDHCI_CLOCK_INT_STABLE
expr_stmt|;
comment|/* 	 * On i.MX ESDHC hardware the card bus clock enable is in the usual 	 * sdhci register but it's a different bit, so transcribe it (note the 	 * difference between standard SDHCI_ and Freescale SDHC_ prefixes 	 * here). On USDHC and QorIQ ESDHC hardware there is a force-on bit, but 	 * no force-off for the card bus clock (the hardware runs the clock when 	 * transfers are active no matter what), so we always say the clock is 	 * on. 	 * XXX Maybe we should say it's in whatever state the sdhci driver last 	 * set it to. 	 */
if|if
condition|(
name|sc
operator|->
name|hwtype
operator|==
name|HWTYPE_ESDHC
condition|)
block|{
ifdef|#
directive|ifdef
name|__arm__
if|if
condition|(
name|RD4
argument_list|(
name|sc
argument_list|,
name|SDHC_SYS_CTRL
argument_list|)
operator|&
name|SDHC_CLK_SDCLKEN
condition|)
endif|#
directive|endif
name|val
operator||=
name|SDHCI_CLOCK_CARD_EN
expr_stmt|;
block|}
else|else
block|{
name|val
operator||=
name|SDHCI_CLOCK_CARD_EN
expr_stmt|;
block|}
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fsl_sdhc_set_clock
parameter_list|(
name|struct
name|fsl_sdhci_softc
modifier|*
name|sc
parameter_list|,
name|uint16_t
name|val
parameter_list|)
block|{
name|uint32_t
name|divisor
decl_stmt|,
name|freq
decl_stmt|,
name|prescale
decl_stmt|,
name|val32
decl_stmt|;
name|val32
operator|=
name|RD4
argument_list|(
name|sc
argument_list|,
name|SDHCI_CLOCK_CONTROL
argument_list|)
expr_stmt|;
comment|/* 	 * Save the frequency-setting bits in SDHCI format so that we can play 	 * them back in get_clock without complex decoding of hardware regs, 	 * then deal with the freqency part of the value based on hardware type. 	 */
name|sc
operator|->
name|sdclockreg_freq_bits
operator|=
name|val
operator|&
name|SDHCI_DIVIDERS_MASK
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|hwtype
operator|==
name|HWTYPE_ESDHC
condition|)
block|{
comment|/* 		 * The i.MX5 ESDHC hardware requires the driver to manually 		 * start and stop the sd bus clock.  If the enable bit is not 		 * set, turn off the clock in hardware and we're done, otherwise 		 * decode the requested frequency.  ESDHC hardware is sdhci 2.0; 		 * the sdhci driver will use the original 8-bit divisor field 		 * and the "base / 2^N" divisor scheme. 		 */
if|if
condition|(
operator|(
name|val
operator|&
name|SDHCI_CLOCK_CARD_EN
operator|)
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|__arm__
comment|/* On QorIQ, this is a reserved bit. */
name|WR4
argument_list|(
name|sc
argument_list|,
name|SDHCI_CLOCK_CONTROL
argument_list|,
name|val32
operator|&
operator|~
name|SDHC_CLK_SDCLKEN
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
name|divisor
operator|=
operator|(
name|val
operator|>>
name|SDHCI_DIVIDER_SHIFT
operator|)
operator|&
name|SDHCI_DIVIDER_MASK
expr_stmt|;
name|freq
operator|=
name|sc
operator|->
name|baseclk_hz
operator|>>
name|ffs
argument_list|(
name|divisor
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * The USDHC hardware provides only "force always on" control 		 * over the sd bus clock, but no way to turn it off.  (If a cmd 		 * or data transfer is in progress the clock is on, otherwise it 		 * is off.)  If the clock is being disabled, we can just return 		 * now, otherwise we decode the requested frequency.  USDHC 		 * hardware is sdhci 3.0; the sdhci driver will use a 10-bit 		 * divisor using the "base / 2*N" divisor scheme. 		 */
if|if
condition|(
operator|(
name|val
operator|&
name|SDHCI_CLOCK_CARD_EN
operator|)
operator|==
literal|0
condition|)
return|return;
name|divisor
operator|=
operator|(
operator|(
name|val
operator|>>
name|SDHCI_DIVIDER_SHIFT
operator|)
operator|&
name|SDHCI_DIVIDER_MASK
operator|)
operator||
operator|(
operator|(
name|val
operator|>>
name|SDHCI_DIVIDER_HI_SHIFT
operator|)
operator|&
name|SDHCI_DIVIDER_HI_MASK
operator|)
operator|<<
name|SDHCI_DIVIDER_MASK_LEN
expr_stmt|;
if|if
condition|(
name|divisor
operator|==
literal|0
condition|)
name|freq
operator|=
name|sc
operator|->
name|baseclk_hz
expr_stmt|;
else|else
name|freq
operator|=
name|sc
operator|->
name|baseclk_hz
operator|/
operator|(
literal|2
operator|*
name|divisor
operator|)
expr_stmt|;
block|}
comment|/* 	 * Get a prescaler and final divisor to achieve the desired frequency. 	 */
for|for
control|(
name|prescale
operator|=
literal|2
init|;
name|freq
operator|<
name|sc
operator|->
name|baseclk_hz
operator|/
operator|(
name|prescale
operator|*
literal|16
operator|)
condition|;
control|)
name|prescale
operator|<<=
literal|1
expr_stmt|;
for|for
control|(
name|divisor
operator|=
literal|1
init|;
name|freq
operator|<
name|sc
operator|->
name|baseclk_hz
operator|/
operator|(
name|prescale
operator|*
name|divisor
operator|)
condition|;
control|)
operator|++
name|divisor
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"desired SD freq: %d, actual: %d; base %d prescale %d divisor %d\n"
argument_list|,
name|freq
argument_list|,
name|sc
operator|->
name|baseclk_hz
operator|/
operator|(
name|prescale
operator|*
name|divisor
operator|)
argument_list|,
name|sc
operator|->
name|baseclk_hz
argument_list|,
name|prescale
argument_list|,
name|divisor
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Adjust to zero-based values, and store them to the hardware. 	 */
name|prescale
operator|>>=
literal|1
expr_stmt|;
name|divisor
operator|-=
literal|1
expr_stmt|;
name|val32
operator|&=
operator|~
operator|(
name|SDHC_CLK_DIVISOR_MASK
operator||
name|SDHC_CLK_PRESCALE_MASK
operator|)
expr_stmt|;
name|val32
operator||=
name|divisor
operator|<<
name|SDHC_CLK_DIVISOR_SHIFT
expr_stmt|;
name|val32
operator||=
name|prescale
operator|<<
name|SDHC_CLK_PRESCALE_SHIFT
expr_stmt|;
name|val32
operator||=
name|SDHC_CLK_IPGEN
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|SDHCI_CLOCK_CONTROL
argument_list|,
name|val32
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|boolean_t
name|fsl_sdhci_r1bfix_is_wait_done
parameter_list|(
name|struct
name|fsl_sdhci_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|inhibit
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sc
operator|->
name|slot
operator|.
name|mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* 	 * Check the DAT0 line status using both the DLA (data line active) and 	 * CDIHB (data inhibit) bits in the present state register.  In theory 	 * just DLA should do the trick,  but in practice it takes both.  If the 	 * DAT0 line is still being held and we're not yet beyond the timeout 	 * point, just schedule another callout to check again later. 	 */
name|inhibit
operator|=
name|RD4
argument_list|(
name|sc
argument_list|,
name|SDHC_PRES_STATE
argument_list|)
operator|&
operator|(
name|SDHC_PRES_DLA
operator||
name|SDHC_PRES_CDIHB
operator|)
expr_stmt|;
if|if
condition|(
name|inhibit
operator|&&
name|getsbinuptime
argument_list|()
operator|<
name|sc
operator|->
name|r1bfix_timeout_at
condition|)
block|{
name|callout_reset_sbt
argument_list|(
operator|&
name|sc
operator|->
name|r1bfix_callout
argument_list|,
name|SBT_1MS
argument_list|,
literal|0
argument_list|,
name|fsl_sdhci_r1bfix_func
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|false
operator|)
return|;
block|}
comment|/* 	 * If we reach this point with the inhibit bits still set, we've got a 	 * timeout, synthesize a DATA_TIMEOUT interrupt.  Otherwise the DAT0 	 * line has been released, and we synthesize a DATA_END, and if the type 	 * of fix needed was on a command-without-data we also now add in the 	 * original INT_RESPONSE that we suppressed earlier. 	 */
if|if
condition|(
name|inhibit
condition|)
name|sc
operator|->
name|r1bfix_intmask
operator||=
name|SDHCI_INT_DATA_TIMEOUT
expr_stmt|;
else|else
block|{
name|sc
operator|->
name|r1bfix_intmask
operator||=
name|SDHCI_INT_DATA_END
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|r1bfix_type
operator|==
name|R1BFIX_NODATA
condition|)
name|sc
operator|->
name|r1bfix_intmask
operator||=
name|SDHCI_INT_RESPONSE
expr_stmt|;
block|}
name|sc
operator|->
name|r1bfix_type
operator|=
name|R1BFIX_NONE
expr_stmt|;
return|return
operator|(
name|true
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fsl_sdhci_r1bfix_func
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|fsl_sdhci_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|boolean_t
name|r1bwait_done
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|slot
operator|.
name|mtx
argument_list|)
expr_stmt|;
name|r1bwait_done
operator|=
name|fsl_sdhci_r1bfix_is_wait_done
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|slot
operator|.
name|mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|r1bwait_done
condition|)
name|sdhci_generic_intr
argument_list|(
operator|&
name|sc
operator|->
name|slot
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fsl_sdhci_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|fsl_sdhci_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|uint32_t
name|intmask
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|slot
operator|.
name|mtx
argument_list|)
expr_stmt|;
comment|/* 	 * Manually check the DAT0 line for R1B response types that the 	 * controller fails to handle properly.  The controller asserts the done 	 * interrupt while the card is still asserting busy with the DAT0 line. 	 * 	 * We check DAT0 immediately because most of the time, especially on a 	 * read, the card will actually be done by time we get here.  If it's 	 * not, then the wait_done routine will schedule a callout to re-check 	 * periodically until it is done.  In that case we clear the interrupt 	 * out of the hardware now so that we can present it later when the DAT0 	 * line is released. 	 * 	 * If we need to wait for the DAT0 line to be released, we set up a 	 * timeout point 250ms in the future.  This number comes from the SD 	 * spec, which allows a command to take that long.  In the real world, 	 * cards tend to take 10-20ms for a long-running command such as a write 	 * or erase that spans two pages. 	 */
switch|switch
condition|(
name|sc
operator|->
name|r1bfix_type
condition|)
block|{
case|case
name|R1BFIX_NODATA
case|:
name|intmask
operator|=
name|RD4
argument_list|(
name|sc
argument_list|,
name|SDHCI_INT_STATUS
argument_list|)
operator|&
name|SDHCI_INT_RESPONSE
expr_stmt|;
break|break;
case|case
name|R1BFIX_AC12
case|:
name|intmask
operator|=
name|RD4
argument_list|(
name|sc
argument_list|,
name|SDHCI_INT_STATUS
argument_list|)
operator|&
name|SDHCI_INT_DATA_END
expr_stmt|;
break|break;
default|default:
name|intmask
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|intmask
condition|)
block|{
name|sc
operator|->
name|r1bfix_timeout_at
operator|=
name|getsbinuptime
argument_list|()
operator|+
literal|250
operator|*
name|SBT_1MS
expr_stmt|;
if|if
condition|(
operator|!
name|fsl_sdhci_r1bfix_is_wait_done
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|WR4
argument_list|(
name|sc
argument_list|,
name|SDHCI_INT_STATUS
argument_list|,
name|intmask
argument_list|)
expr_stmt|;
name|bus_barrier
argument_list|(
name|sc
operator|->
name|mem_res
argument_list|,
name|SDHCI_INT_STATUS
argument_list|,
literal|4
argument_list|,
name|BUS_SPACE_BARRIER_WRITE
argument_list|)
expr_stmt|;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|slot
operator|.
name|mtx
argument_list|)
expr_stmt|;
name|sdhci_generic_intr
argument_list|(
operator|&
name|sc
operator|->
name|slot
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|fsl_sdhci_get_ro
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
name|struct
name|fsl_sdhci_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|bus
argument_list|)
decl_stmt|;
return|return
operator|(
name|sdhci_fdt_gpio_get_readonly
argument_list|(
name|sc
operator|->
name|gpio
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|fsl_sdhci_get_card_present
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|sdhci_slot
modifier|*
name|slot
parameter_list|)
block|{
name|struct
name|fsl_sdhci_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
return|return
operator|(
name|sdhci_fdt_gpio_get_present
argument_list|(
name|sc
operator|->
name|gpio
argument_list|)
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|__powerpc__
end_ifdef

begin_function
specifier|static
name|uint32_t
name|fsl_sdhci_get_platform_clock
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|phandle_t
name|node
decl_stmt|;
name|uint32_t
name|clock
decl_stmt|;
name|node
operator|=
name|ofw_bus_get_node
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Get sdhci node properties */
if|if
condition|(
operator|(
name|OF_getprop
argument_list|(
name|node
argument_list|,
literal|"clock-frequency"
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|clock
argument_list|,
sizeof|sizeof
argument_list|(
name|clock
argument_list|)
argument_list|)
operator|<=
literal|0
operator|)
operator|||
operator|(
name|clock
operator|==
literal|0
operator|)
condition|)
block|{
name|clock
operator|=
name|mpc85xx_get_system_clock
argument_list|()
expr_stmt|;
if|if
condition|(
name|clock
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Cannot acquire correct sdhci "
literal|"frequency from DTS.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Acquired clock: %d from DTS\n"
argument_list|,
name|clock
argument_list|)
expr_stmt|;
return|return
operator|(
name|clock
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|fsl_sdhci_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
comment|/* sdhci_fdt_gpio_teardown(sc->gpio); */
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fsl_sdhci_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|fsl_sdhci_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|rid
decl_stmt|,
name|err
decl_stmt|;
ifdef|#
directive|ifdef
name|__powerpc__
name|phandle_t
name|node
decl_stmt|;
name|uint32_t
name|protctl
decl_stmt|;
endif|#
directive|endif
name|sc
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|sc
operator|->
name|hwtype
operator|=
name|ofw_bus_search_compatible
argument_list|(
name|dev
argument_list|,
name|compat_data
argument_list|)
operator|->
name|ocd_data
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|hwtype
operator|==
name|HWTYPE_NONE
condition|)
name|panic
argument_list|(
literal|"Impossible: not compatible in fsl_sdhci_attach()"
argument_list|)
expr_stmt|;
name|rid
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|mem_res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|mem_res
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot allocate memory window\n"
argument_list|)
expr_stmt|;
name|err
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|rid
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|irq_res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|irq_res
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot allocate interrupt\n"
argument_list|)
expr_stmt|;
name|err
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|irq_res
argument_list|,
name|INTR_TYPE_BIO
operator||
name|INTR_MPSAFE
argument_list|,
name|NULL
argument_list|,
name|fsl_sdhci_intr
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|intr_cookie
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot setup interrupt handler\n"
argument_list|)
expr_stmt|;
name|err
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|sc
operator|->
name|slot
operator|.
name|quirks
operator||=
name|SDHCI_QUIRK_DATA_TIMEOUT_USES_SDCLK
expr_stmt|;
comment|/* 	 * DMA is not really broken, I just haven't implemented it yet. 	 */
name|sc
operator|->
name|slot
operator|.
name|quirks
operator||=
name|SDHCI_QUIRK_BROKEN_DMA
expr_stmt|;
comment|/* 	 * Set the buffer watermark level to 128 words (512 bytes) for both read 	 * and write.  The hardware has a restriction that when the read or 	 * write ready status is asserted, that means you can read exactly the 	 * number of words set in the watermark register before you have to 	 * re-check the status and potentially wait for more data.  The main 	 * sdhci driver provides no hook for doing status checking on less than 	 * a full block boundary, so we set the watermark level to be a full 	 * block.  Reads and writes where the block size is less than the 	 * watermark size will work correctly too, no need to change the 	 * watermark for different size blocks.  However, 128 is the maximum 	 * allowed for the watermark, so PIO is limitted to 512 byte blocks 	 * (which works fine for SD cards, may be a problem for SDIO some day). 	 * 	 * XXX need named constants for this stuff. 	 */
comment|/* P1022 has the '*_BRST_LEN' fields as reserved, always reading 0x10 */
if|if
condition|(
name|ofw_bus_is_compatible
argument_list|(
name|dev
argument_list|,
literal|"fsl,p1022-esdhc"
argument_list|)
condition|)
name|WR4
argument_list|(
name|sc
argument_list|,
name|SDHC_WTMK_LVL
argument_list|,
literal|0x10801080
argument_list|)
expr_stmt|;
else|else
name|WR4
argument_list|(
name|sc
argument_list|,
name|SDHC_WTMK_LVL
argument_list|,
literal|0x08800880
argument_list|)
expr_stmt|;
comment|/* 	 * We read in native byte order in the main driver, but the register 	 * defaults to little endian. 	 */
ifdef|#
directive|ifdef
name|__powerpc__
name|sc
operator|->
name|baseclk_hz
operator|=
name|fsl_sdhci_get_platform_clock
argument_list|(
name|dev
argument_list|)
expr_stmt|;
else|#
directive|else
name|sc
operator|->
name|baseclk_hz
operator|=
name|imx_ccm_sdhci_hz
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|sc
operator|->
name|slot
operator|.
name|max_clk
operator|=
name|sc
operator|->
name|baseclk_hz
expr_stmt|;
comment|/* 	 * Set up any gpio pin handling described in the FDT data. This cannot 	 * fail; see comments in sdhci_fdt_gpio.h for details. 	 */
name|sc
operator|->
name|gpio
operator|=
name|sdhci_fdt_gpio_setup
argument_list|(
name|dev
argument_list|,
operator|&
name|sc
operator|->
name|slot
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__powerpc__
name|node
operator|=
name|ofw_bus_get_node
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Default to big-endian on powerpc */
name|protctl
operator|=
name|RD4
argument_list|(
name|sc
argument_list|,
name|SDHC_PROT_CTRL
argument_list|)
expr_stmt|;
name|protctl
operator|&=
operator|~
name|SDHC_PROT_EMODE_MASK
expr_stmt|;
if|if
condition|(
name|OF_hasprop
argument_list|(
name|node
argument_list|,
literal|"little-endian"
argument_list|)
condition|)
name|protctl
operator||=
name|SDHC_PROT_EMODE_LITTLE
expr_stmt|;
else|else
name|protctl
operator||=
name|SDHC_PROT_EMODE_BIG
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|SDHC_PROT_CTRL
argument_list|,
name|protctl
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|callout_init
argument_list|(
operator|&
name|sc
operator|->
name|r1bfix_callout
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sdhci_init_slot
argument_list|(
name|dev
argument_list|,
operator|&
name|sc
operator|->
name|slot
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bus_generic_probe
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|bus_generic_attach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MMCCAM
name|sdhci_cam_start_slot
argument_list|(
operator|&
name|sc
operator|->
name|slot
argument_list|)
expr_stmt|;
else|#
directive|else
name|sdhci_start_slot
argument_list|(
operator|&
name|sc
operator|->
name|slot
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
name|fail
label|:
if|if
condition|(
name|sc
operator|->
name|intr_cookie
condition|)
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|irq_res
argument_list|,
name|sc
operator|->
name|intr_cookie
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|irq_res
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|irq_res
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mem_res
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|mem_res
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fsl_sdhci_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ofw_bus_status_okay
argument_list|(
name|dev
argument_list|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
switch|switch
condition|(
name|ofw_bus_search_compatible
argument_list|(
name|dev
argument_list|,
name|compat_data
argument_list|)
operator|->
name|ocd_data
condition|)
block|{
case|case
name|HWTYPE_ESDHC
case|:
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Freescale eSDHC controller"
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
case|case
name|HWTYPE_USDHC
case|:
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Freescale uSDHC controller"
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
default|default:
break|break;
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|fsl_sdhci_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|fsl_sdhci_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|fsl_sdhci_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|fsl_sdhci_detach
argument_list|)
block|,
comment|/* Bus interface */
name|DEVMETHOD
argument_list|(
name|bus_read_ivar
argument_list|,
name|sdhci_generic_read_ivar
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_write_ivar
argument_list|,
name|sdhci_generic_write_ivar
argument_list|)
block|,
comment|/* MMC bridge interface */
name|DEVMETHOD
argument_list|(
name|mmcbr_update_ios
argument_list|,
name|sdhci_generic_update_ios
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|mmcbr_request
argument_list|,
name|sdhci_generic_request
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|mmcbr_get_ro
argument_list|,
name|fsl_sdhci_get_ro
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|mmcbr_acquire_host
argument_list|,
name|sdhci_generic_acquire_host
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|mmcbr_release_host
argument_list|,
name|sdhci_generic_release_host
argument_list|)
block|,
comment|/* SDHCI accessors */
name|DEVMETHOD
argument_list|(
name|sdhci_read_1
argument_list|,
name|fsl_sdhci_read_1
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|sdhci_read_2
argument_list|,
name|fsl_sdhci_read_2
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|sdhci_read_4
argument_list|,
name|fsl_sdhci_read_4
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|sdhci_read_multi_4
argument_list|,
name|fsl_sdhci_read_multi_4
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|sdhci_write_1
argument_list|,
name|fsl_sdhci_write_1
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|sdhci_write_2
argument_list|,
name|fsl_sdhci_write_2
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|sdhci_write_4
argument_list|,
name|fsl_sdhci_write_4
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|sdhci_write_multi_4
argument_list|,
name|fsl_sdhci_write_multi_4
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|sdhci_get_card_present
argument_list|,
name|fsl_sdhci_get_card_present
argument_list|)
block|,
name|DEVMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|fsl_sdhci_devclass
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|fsl_sdhci_driver
init|=
block|{
literal|"sdhci_fsl"
block|,
name|fsl_sdhci_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|fsl_sdhci_softc
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|sdhci_fsl
argument_list|,
name|simplebus
argument_list|,
name|fsl_sdhci_driver
argument_list|,
name|fsl_sdhci_devclass
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|sdhci_fsl
argument_list|,
name|sdhci
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|MMCCAM
end_ifndef

begin_expr_stmt
name|MMC_DECLARE_BRIDGE
argument_list|(
name|sdhci_fsl
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

end_unit

