begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2008 Alexander Motin<mav@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<machine/stdarg.h>
end_include

begin_include
include|#
directive|include
file|<dev/mmc/bridge.h>
end_include

begin_include
include|#
directive|include
file|<dev/mmc/mmcreg.h>
end_include

begin_include
include|#
directive|include
file|<dev/mmc/mmcbrvar.h>
end_include

begin_include
include|#
directive|include
file|"mmcbr_if.h"
end_include

begin_include
include|#
directive|include
file|"sdhci.h"
end_include

begin_define
define|#
directive|define
name|DMA_BLOCK_SIZE
value|4096
end_define

begin_define
define|#
directive|define
name|DMA_BOUNDARY
value|0
end_define

begin_comment
comment|/* DMA reload every 4K */
end_comment

begin_comment
comment|/* Controller doesn't honor resets unless we touch the clock register */
end_comment

begin_define
define|#
directive|define
name|SDHCI_QUIRK_CLOCK_BEFORE_RESET
value|(1<<0)
end_define

begin_comment
comment|/* Controller really supports DMA */
end_comment

begin_define
define|#
directive|define
name|SDHCI_QUIRK_FORCE_DMA
value|(1<<1)
end_define

begin_comment
comment|/* Controller has unusable DMA engine */
end_comment

begin_define
define|#
directive|define
name|SDHCI_QUIRK_BROKEN_DMA
value|(1<<2)
end_define

begin_comment
comment|/* Controller doesn't like to be reset when there is no card inserted. */
end_comment

begin_define
define|#
directive|define
name|SDHCI_QUIRK_NO_CARD_NO_RESET
value|(1<<3)
end_define

begin_comment
comment|/* Controller has flaky internal state so reset it on each ios change */
end_comment

begin_define
define|#
directive|define
name|SDHCI_QUIRK_RESET_ON_IOS
value|(1<<4)
end_define

begin_comment
comment|/* Controller can only DMA chunk sizes that are a multiple of 32 bits */
end_comment

begin_define
define|#
directive|define
name|SDHCI_QUIRK_32BIT_DMA_SIZE
value|(1<<5)
end_define

begin_comment
comment|/* Controller needs to be reset after each request to stay stable */
end_comment

begin_define
define|#
directive|define
name|SDHCI_QUIRK_RESET_AFTER_REQUEST
value|(1<<6)
end_define

begin_comment
comment|/* Controller has an off-by-one issue with timeout value */
end_comment

begin_define
define|#
directive|define
name|SDHCI_QUIRK_INCR_TIMEOUT_CONTROL
value|(1<<7)
end_define

begin_comment
comment|/* Controller has broken read timings */
end_comment

begin_define
define|#
directive|define
name|SDHCI_QUIRK_BROKEN_TIMINGS
value|(1<<8)
end_define

begin_struct
specifier|static
specifier|const
struct|struct
name|sdhci_device
block|{
name|uint32_t
name|model
decl_stmt|;
name|uint16_t
name|subvendor
decl_stmt|;
name|char
modifier|*
name|desc
decl_stmt|;
name|u_int
name|quirks
decl_stmt|;
block|}
name|sdhci_devices
index|[]
init|=
block|{
block|{
literal|0x08221180
block|,
literal|0xffff
block|,
literal|"RICOH R5C822 SD"
block|,
name|SDHCI_QUIRK_FORCE_DMA
block|}
block|,
block|{
literal|0x8034104c
block|,
literal|0xffff
block|,
literal|"TI XX21/XX11 SD"
block|,
name|SDHCI_QUIRK_FORCE_DMA
block|}
block|,
block|{
literal|0x05501524
block|,
literal|0xffff
block|,
literal|"ENE CB712 SD"
block|,
name|SDHCI_QUIRK_BROKEN_TIMINGS
block|}
block|,
block|{
literal|0x05511524
block|,
literal|0xffff
block|,
literal|"ENE CB712 SD 2"
block|,
name|SDHCI_QUIRK_BROKEN_TIMINGS
block|}
block|,
block|{
literal|0x07501524
block|,
literal|0xffff
block|,
literal|"ENE CB714 SD"
block|,
name|SDHCI_QUIRK_RESET_ON_IOS
operator||
name|SDHCI_QUIRK_BROKEN_TIMINGS
block|}
block|,
block|{
literal|0x07511524
block|,
literal|0xffff
block|,
literal|"ENE CB714 SD 2"
block|,
name|SDHCI_QUIRK_RESET_ON_IOS
operator||
name|SDHCI_QUIRK_BROKEN_TIMINGS
block|}
block|,
block|{
literal|0x410111ab
block|,
literal|0xffff
block|,
literal|"Marvell CaFe SD"
block|,
name|SDHCI_QUIRK_INCR_TIMEOUT_CONTROL
block|}
block|,
block|{
literal|0x2381197B
block|,
literal|0xffff
block|,
literal|"JMicron JMB38X SD"
block|,
name|SDHCI_QUIRK_32BIT_DMA_SIZE
operator||
name|SDHCI_QUIRK_RESET_AFTER_REQUEST
block|}
block|,
block|{
literal|0
block|,
literal|0xffff
block|,
name|NULL
block|,
literal|0
block|}
block|}
struct|;
end_struct

begin_struct_decl
struct_decl|struct
name|sdhci_softc
struct_decl|;
end_struct_decl

begin_struct
struct|struct
name|sdhci_slot
block|{
name|struct
name|sdhci_softc
modifier|*
name|sc
decl_stmt|;
name|device_t
name|dev
decl_stmt|;
comment|/* Slot device */
name|u_char
name|num
decl_stmt|;
comment|/* Slot number */
name|u_char
name|opt
decl_stmt|;
comment|/* Slot options */
define|#
directive|define
name|SDHCI_HAVE_DMA
value|1
name|uint32_t
name|max_clk
decl_stmt|;
comment|/* Max possible freq */
name|uint32_t
name|timeout_clk
decl_stmt|;
comment|/* Timeout freq */
name|struct
name|resource
modifier|*
name|mem_res
decl_stmt|;
comment|/* Memory resource */
name|int
name|mem_rid
decl_stmt|;
name|bus_dma_tag_t
name|dmatag
decl_stmt|;
name|bus_dmamap_t
name|dmamap
decl_stmt|;
name|u_char
modifier|*
name|dmamem
decl_stmt|;
name|bus_addr_t
name|paddr
decl_stmt|;
comment|/* DMA buffer address */
name|struct
name|task
name|card_task
decl_stmt|;
comment|/* Card presence check task */
name|struct
name|callout
name|card_callout
decl_stmt|;
comment|/* Card insert delay callout */
name|struct
name|mmc_host
name|host
decl_stmt|;
comment|/* Host parameters */
name|struct
name|mmc_request
modifier|*
name|req
decl_stmt|;
comment|/* Current request */
name|struct
name|mmc_command
modifier|*
name|curcmd
decl_stmt|;
comment|/* Current command of current request */
name|uint32_t
name|intmask
decl_stmt|;
comment|/* Current interrupt mask */
name|uint32_t
name|clock
decl_stmt|;
comment|/* Current clock freq. */
name|size_t
name|offset
decl_stmt|;
comment|/* Data buffer offset */
name|uint8_t
name|hostctrl
decl_stmt|;
comment|/* Current host control register */
name|u_char
name|power
decl_stmt|;
comment|/* Current power */
name|u_char
name|bus_busy
decl_stmt|;
comment|/* Bus busy status */
name|u_char
name|cmd_done
decl_stmt|;
comment|/* CMD command part done flag */
name|u_char
name|data_done
decl_stmt|;
comment|/* DAT command part done flag */
name|u_char
name|flags
decl_stmt|;
comment|/* Request execution flags */
define|#
directive|define
name|CMD_STARTED
value|1
define|#
directive|define
name|STOP_STARTED
value|2
define|#
directive|define
name|SDHCI_USE_DMA
value|4
comment|/* Use DMA for this req. */
name|struct
name|mtx
name|mtx
decl_stmt|;
comment|/* Slot mutex */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|sdhci_softc
block|{
name|device_t
name|dev
decl_stmt|;
comment|/* Controller device */
name|u_int
name|quirks
decl_stmt|;
comment|/* Chip specific quirks */
name|struct
name|resource
modifier|*
name|irq_res
decl_stmt|;
comment|/* IRQ resource */
name|int
name|irq_rid
decl_stmt|;
name|void
modifier|*
name|intrhand
decl_stmt|;
comment|/* Interrupt handle */
name|int
name|num_slots
decl_stmt|;
comment|/* Number of slots on this controller */
name|struct
name|sdhci_slot
name|slots
index|[
literal|6
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_hw
argument_list|,
name|OID_AUTO
argument_list|,
name|sdhci
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"sdhci driver"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|sdhci_debug
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.sdhci.debug"
argument_list|,
operator|&
name|sdhci_debug
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_sdhci
argument_list|,
name|OID_AUTO
argument_list|,
name|debug
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|sdhci_debug
argument_list|,
literal|0
argument_list|,
literal|"Debug level"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
specifier|inline
name|uint8_t
name|RD1
parameter_list|(
name|struct
name|sdhci_slot
modifier|*
name|slot
parameter_list|,
name|bus_size_t
name|off
parameter_list|)
block|{
name|bus_barrier
argument_list|(
name|slot
operator|->
name|mem_res
argument_list|,
literal|0
argument_list|,
literal|0xFF
argument_list|,
name|BUS_SPACE_BARRIER_READ
operator||
name|BUS_SPACE_BARRIER_WRITE
argument_list|)
expr_stmt|;
return|return
name|bus_read_1
argument_list|(
name|slot
operator|->
name|mem_res
argument_list|,
name|off
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|WR1
parameter_list|(
name|struct
name|sdhci_slot
modifier|*
name|slot
parameter_list|,
name|bus_size_t
name|off
parameter_list|,
name|uint8_t
name|val
parameter_list|)
block|{
name|bus_barrier
argument_list|(
name|slot
operator|->
name|mem_res
argument_list|,
literal|0
argument_list|,
literal|0xFF
argument_list|,
name|BUS_SPACE_BARRIER_READ
operator||
name|BUS_SPACE_BARRIER_WRITE
argument_list|)
expr_stmt|;
name|bus_write_1
argument_list|(
name|slot
operator|->
name|mem_res
argument_list|,
name|off
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint16_t
name|RD2
parameter_list|(
name|struct
name|sdhci_slot
modifier|*
name|slot
parameter_list|,
name|bus_size_t
name|off
parameter_list|)
block|{
name|bus_barrier
argument_list|(
name|slot
operator|->
name|mem_res
argument_list|,
literal|0
argument_list|,
literal|0xFF
argument_list|,
name|BUS_SPACE_BARRIER_READ
operator||
name|BUS_SPACE_BARRIER_WRITE
argument_list|)
expr_stmt|;
return|return
name|bus_read_2
argument_list|(
name|slot
operator|->
name|mem_res
argument_list|,
name|off
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|WR2
parameter_list|(
name|struct
name|sdhci_slot
modifier|*
name|slot
parameter_list|,
name|bus_size_t
name|off
parameter_list|,
name|uint16_t
name|val
parameter_list|)
block|{
name|bus_barrier
argument_list|(
name|slot
operator|->
name|mem_res
argument_list|,
literal|0
argument_list|,
literal|0xFF
argument_list|,
name|BUS_SPACE_BARRIER_READ
operator||
name|BUS_SPACE_BARRIER_WRITE
argument_list|)
expr_stmt|;
name|bus_write_2
argument_list|(
name|slot
operator|->
name|mem_res
argument_list|,
name|off
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint32_t
name|RD4
parameter_list|(
name|struct
name|sdhci_slot
modifier|*
name|slot
parameter_list|,
name|bus_size_t
name|off
parameter_list|)
block|{
name|bus_barrier
argument_list|(
name|slot
operator|->
name|mem_res
argument_list|,
literal|0
argument_list|,
literal|0xFF
argument_list|,
name|BUS_SPACE_BARRIER_READ
operator||
name|BUS_SPACE_BARRIER_WRITE
argument_list|)
expr_stmt|;
return|return
name|bus_read_4
argument_list|(
name|slot
operator|->
name|mem_res
argument_list|,
name|off
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|WR4
parameter_list|(
name|struct
name|sdhci_slot
modifier|*
name|slot
parameter_list|,
name|bus_size_t
name|off
parameter_list|,
name|uint32_t
name|val
parameter_list|)
block|{
name|bus_barrier
argument_list|(
name|slot
operator|->
name|mem_res
argument_list|,
literal|0
argument_list|,
literal|0xFF
argument_list|,
name|BUS_SPACE_BARRIER_READ
operator||
name|BUS_SPACE_BARRIER_WRITE
argument_list|)
expr_stmt|;
name|bus_write_4
argument_list|(
name|slot
operator|->
name|mem_res
argument_list|,
name|off
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* bus entry points */
end_comment

begin_function_decl
specifier|static
name|int
name|sdhci_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sdhci_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sdhci_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sdhci_intr
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sdhci_set_clock
parameter_list|(
name|struct
name|sdhci_slot
modifier|*
name|slot
parameter_list|,
name|uint32_t
name|clock
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sdhci_start
parameter_list|(
name|struct
name|sdhci_slot
modifier|*
name|slot
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sdhci_start_data
parameter_list|(
name|struct
name|sdhci_slot
modifier|*
name|slot
parameter_list|,
name|struct
name|mmc_data
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sdhci_card_task
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* helper routines */
end_comment

begin_define
define|#
directive|define
name|SDHCI_LOCK
parameter_list|(
name|_slot
parameter_list|)
value|mtx_lock(&(_slot)->mtx)
end_define

begin_define
define|#
directive|define
name|SDHCI_UNLOCK
parameter_list|(
name|_slot
parameter_list|)
value|mtx_unlock(&(_slot)->mtx)
end_define

begin_define
define|#
directive|define
name|SDHCI_LOCK_INIT
parameter_list|(
name|_slot
parameter_list|)
define|\
value|mtx_init(&_slot->mtx, "SD slot mtx", "sdhci", MTX_DEF)
end_define

begin_define
define|#
directive|define
name|SDHCI_LOCK_DESTROY
parameter_list|(
name|_slot
parameter_list|)
value|mtx_destroy(&_slot->mtx);
end_define

begin_define
define|#
directive|define
name|SDHCI_ASSERT_LOCKED
parameter_list|(
name|_slot
parameter_list|)
value|mtx_assert(&_slot->mtx, MA_OWNED);
end_define

begin_define
define|#
directive|define
name|SDHCI_ASSERT_UNLOCKED
parameter_list|(
name|_slot
parameter_list|)
value|mtx_assert(&_slot->mtx, MA_NOTOWNED);
end_define

begin_function
specifier|static
name|int
name|slot_printf
parameter_list|(
name|struct
name|sdhci_slot
modifier|*
name|slot
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|retval
operator|=
name|printf
argument_list|(
literal|"%s-slot%d: "
argument_list|,
name|device_get_nameunit
argument_list|(
name|slot
operator|->
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
name|slot
operator|->
name|num
argument_list|)
expr_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|retval
operator|+=
name|vprintf
argument_list|(
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sdhci_getaddr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nsegs
parameter_list|,
name|int
name|error
parameter_list|)
block|{
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"getaddr: error %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return;
block|}
operator|*
operator|(
name|bus_addr_t
operator|*
operator|)
name|arg
operator|=
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sdhci_dumpregs
parameter_list|(
name|struct
name|sdhci_slot
modifier|*
name|slot
parameter_list|)
block|{
name|slot_printf
argument_list|(
name|slot
argument_list|,
literal|"============== REGISTER DUMP ==============\n"
argument_list|)
expr_stmt|;
name|slot_printf
argument_list|(
name|slot
argument_list|,
literal|"Sys addr: 0x%08x | Version:  0x%08x\n"
argument_list|,
name|RD4
argument_list|(
name|slot
argument_list|,
name|SDHCI_DMA_ADDRESS
argument_list|)
argument_list|,
name|RD2
argument_list|(
name|slot
argument_list|,
name|SDHCI_HOST_VERSION
argument_list|)
argument_list|)
expr_stmt|;
name|slot_printf
argument_list|(
name|slot
argument_list|,
literal|"Blk size: 0x%08x | Blk cnt:  0x%08x\n"
argument_list|,
name|RD2
argument_list|(
name|slot
argument_list|,
name|SDHCI_BLOCK_SIZE
argument_list|)
argument_list|,
name|RD2
argument_list|(
name|slot
argument_list|,
name|SDHCI_BLOCK_COUNT
argument_list|)
argument_list|)
expr_stmt|;
name|slot_printf
argument_list|(
name|slot
argument_list|,
literal|"Argument: 0x%08x | Trn mode: 0x%08x\n"
argument_list|,
name|RD4
argument_list|(
name|slot
argument_list|,
name|SDHCI_ARGUMENT
argument_list|)
argument_list|,
name|RD2
argument_list|(
name|slot
argument_list|,
name|SDHCI_TRANSFER_MODE
argument_list|)
argument_list|)
expr_stmt|;
name|slot_printf
argument_list|(
name|slot
argument_list|,
literal|"Present:  0x%08x | Host ctl: 0x%08x\n"
argument_list|,
name|RD4
argument_list|(
name|slot
argument_list|,
name|SDHCI_PRESENT_STATE
argument_list|)
argument_list|,
name|RD1
argument_list|(
name|slot
argument_list|,
name|SDHCI_HOST_CONTROL
argument_list|)
argument_list|)
expr_stmt|;
name|slot_printf
argument_list|(
name|slot
argument_list|,
literal|"Power:    0x%08x | Blk gap:  0x%08x\n"
argument_list|,
name|RD1
argument_list|(
name|slot
argument_list|,
name|SDHCI_POWER_CONTROL
argument_list|)
argument_list|,
name|RD1
argument_list|(
name|slot
argument_list|,
name|SDHCI_BLOCK_GAP_CONTROL
argument_list|)
argument_list|)
expr_stmt|;
name|slot_printf
argument_list|(
name|slot
argument_list|,
literal|"Wake-up:  0x%08x | Clock:    0x%08x\n"
argument_list|,
name|RD1
argument_list|(
name|slot
argument_list|,
name|SDHCI_WAKE_UP_CONTROL
argument_list|)
argument_list|,
name|RD2
argument_list|(
name|slot
argument_list|,
name|SDHCI_CLOCK_CONTROL
argument_list|)
argument_list|)
expr_stmt|;
name|slot_printf
argument_list|(
name|slot
argument_list|,
literal|"Timeout:  0x%08x | Int stat: 0x%08x\n"
argument_list|,
name|RD1
argument_list|(
name|slot
argument_list|,
name|SDHCI_TIMEOUT_CONTROL
argument_list|)
argument_list|,
name|RD4
argument_list|(
name|slot
argument_list|,
name|SDHCI_INT_STATUS
argument_list|)
argument_list|)
expr_stmt|;
name|slot_printf
argument_list|(
name|slot
argument_list|,
literal|"Int enab: 0x%08x | Sig enab: 0x%08x\n"
argument_list|,
name|RD4
argument_list|(
name|slot
argument_list|,
name|SDHCI_INT_ENABLE
argument_list|)
argument_list|,
name|RD4
argument_list|(
name|slot
argument_list|,
name|SDHCI_SIGNAL_ENABLE
argument_list|)
argument_list|)
expr_stmt|;
name|slot_printf
argument_list|(
name|slot
argument_list|,
literal|"AC12 err: 0x%08x | Slot int: 0x%08x\n"
argument_list|,
name|RD2
argument_list|(
name|slot
argument_list|,
name|SDHCI_ACMD12_ERR
argument_list|)
argument_list|,
name|RD2
argument_list|(
name|slot
argument_list|,
name|SDHCI_SLOT_INT_STATUS
argument_list|)
argument_list|)
expr_stmt|;
name|slot_printf
argument_list|(
name|slot
argument_list|,
literal|"Caps:     0x%08x | Max curr: 0x%08x\n"
argument_list|,
name|RD4
argument_list|(
name|slot
argument_list|,
name|SDHCI_CAPABILITIES
argument_list|)
argument_list|,
name|RD4
argument_list|(
name|slot
argument_list|,
name|SDHCI_MAX_CURRENT
argument_list|)
argument_list|)
expr_stmt|;
name|slot_printf
argument_list|(
name|slot
argument_list|,
literal|"===========================================\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sdhci_reset
parameter_list|(
name|struct
name|sdhci_slot
modifier|*
name|slot
parameter_list|,
name|uint8_t
name|mask
parameter_list|)
block|{
name|int
name|timeout
decl_stmt|;
name|uint8_t
name|res
decl_stmt|;
if|if
condition|(
name|slot
operator|->
name|sc
operator|->
name|quirks
operator|&
name|SDHCI_QUIRK_NO_CARD_NO_RESET
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|RD4
argument_list|(
name|slot
argument_list|,
name|SDHCI_PRESENT_STATE
argument_list|)
operator|&
name|SDHCI_CARD_PRESENT
operator|)
condition|)
return|return;
block|}
comment|/* Some controllers need this kick or reset won't work. */
if|if
condition|(
operator|(
name|mask
operator|&
name|SDHCI_RESET_ALL
operator|)
operator|==
literal|0
operator|&&
operator|(
name|slot
operator|->
name|sc
operator|->
name|quirks
operator|&
name|SDHCI_QUIRK_CLOCK_BEFORE_RESET
operator|)
condition|)
block|{
name|uint32_t
name|clock
decl_stmt|;
comment|/* This is to force an update */
name|clock
operator|=
name|slot
operator|->
name|clock
expr_stmt|;
name|slot
operator|->
name|clock
operator|=
literal|0
expr_stmt|;
name|sdhci_set_clock
argument_list|(
name|slot
argument_list|,
name|clock
argument_list|)
expr_stmt|;
block|}
name|WR1
argument_list|(
name|slot
argument_list|,
name|SDHCI_SOFTWARE_RESET
argument_list|,
name|mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|SDHCI_RESET_ALL
condition|)
block|{
name|slot
operator|->
name|clock
operator|=
literal|0
expr_stmt|;
name|slot
operator|->
name|power
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Wait max 100 ms */
name|timeout
operator|=
literal|100
expr_stmt|;
comment|/* Controller clears the bits when it's done */
while|while
condition|(
operator|(
name|res
operator|=
name|RD1
argument_list|(
name|slot
argument_list|,
name|SDHCI_SOFTWARE_RESET
argument_list|)
operator|)
operator|&
name|mask
condition|)
block|{
if|if
condition|(
name|timeout
operator|==
literal|0
condition|)
block|{
name|slot_printf
argument_list|(
name|slot
argument_list|,
literal|"Reset 0x%x never completed - 0x%x.\n"
argument_list|,
operator|(
name|int
operator|)
name|mask
argument_list|,
operator|(
name|int
operator|)
name|res
argument_list|)
expr_stmt|;
name|sdhci_dumpregs
argument_list|(
name|slot
argument_list|)
expr_stmt|;
return|return;
block|}
name|timeout
operator|--
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|sdhci_init
parameter_list|(
name|struct
name|sdhci_slot
modifier|*
name|slot
parameter_list|)
block|{
name|sdhci_reset
argument_list|(
name|slot
argument_list|,
name|SDHCI_RESET_ALL
argument_list|)
expr_stmt|;
comment|/* Enable interrupts. */
name|slot
operator|->
name|intmask
operator|=
name|SDHCI_INT_BUS_POWER
operator||
name|SDHCI_INT_DATA_END_BIT
operator||
name|SDHCI_INT_DATA_CRC
operator||
name|SDHCI_INT_DATA_TIMEOUT
operator||
name|SDHCI_INT_INDEX
operator||
name|SDHCI_INT_END_BIT
operator||
name|SDHCI_INT_CRC
operator||
name|SDHCI_INT_TIMEOUT
operator||
name|SDHCI_INT_CARD_REMOVE
operator||
name|SDHCI_INT_CARD_INSERT
operator||
name|SDHCI_INT_DATA_AVAIL
operator||
name|SDHCI_INT_SPACE_AVAIL
operator||
name|SDHCI_INT_DMA_END
operator||
name|SDHCI_INT_DATA_END
operator||
name|SDHCI_INT_RESPONSE
operator||
name|SDHCI_INT_ACMD12ERR
expr_stmt|;
name|WR4
argument_list|(
name|slot
argument_list|,
name|SDHCI_INT_ENABLE
argument_list|,
name|slot
operator|->
name|intmask
argument_list|)
expr_stmt|;
name|WR4
argument_list|(
name|slot
argument_list|,
name|SDHCI_SIGNAL_ENABLE
argument_list|,
name|slot
operator|->
name|intmask
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sdhci_set_clock
parameter_list|(
name|struct
name|sdhci_slot
modifier|*
name|slot
parameter_list|,
name|uint32_t
name|clock
parameter_list|)
block|{
name|uint32_t
name|res
decl_stmt|;
name|uint16_t
name|clk
decl_stmt|;
name|int
name|timeout
decl_stmt|;
if|if
condition|(
name|clock
operator|==
name|slot
operator|->
name|clock
condition|)
return|return;
name|slot
operator|->
name|clock
operator|=
name|clock
expr_stmt|;
comment|/* Turn off the clock. */
name|WR2
argument_list|(
name|slot
argument_list|,
name|SDHCI_CLOCK_CONTROL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If no clock requested - left it so. */
if|if
condition|(
name|clock
operator|==
literal|0
condition|)
return|return;
comment|/* Looking for highest freq<= clock. */
name|res
operator|=
name|slot
operator|->
name|max_clk
expr_stmt|;
for|for
control|(
name|clk
operator|=
literal|1
init|;
name|clk
operator|<
literal|256
condition|;
name|clk
operator|<<=
literal|1
control|)
block|{
if|if
condition|(
name|res
operator|<=
name|clock
condition|)
break|break;
name|res
operator|>>=
literal|1
expr_stmt|;
block|}
comment|/* Divider 1:1 is 0x00, 2:1 is 0x01, 256:1 is 0x80 ... */
name|clk
operator|>>=
literal|1
expr_stmt|;
comment|/* Now we have got divider, set it. */
name|clk
operator|<<=
name|SDHCI_DIVIDER_SHIFT
expr_stmt|;
name|WR2
argument_list|(
name|slot
argument_list|,
name|SDHCI_CLOCK_CONTROL
argument_list|,
name|clk
argument_list|)
expr_stmt|;
comment|/* Enable clock. */
name|clk
operator||=
name|SDHCI_CLOCK_INT_EN
expr_stmt|;
name|WR2
argument_list|(
name|slot
argument_list|,
name|SDHCI_CLOCK_CONTROL
argument_list|,
name|clk
argument_list|)
expr_stmt|;
comment|/* Wait up to 10 ms until it stabilize. */
name|timeout
operator|=
literal|10
expr_stmt|;
while|while
condition|(
operator|!
operator|(
operator|(
name|clk
operator|=
name|RD2
argument_list|(
name|slot
argument_list|,
name|SDHCI_CLOCK_CONTROL
argument_list|)
operator|)
operator|&
name|SDHCI_CLOCK_INT_STABLE
operator|)
condition|)
block|{
if|if
condition|(
name|timeout
operator|==
literal|0
condition|)
block|{
name|slot_printf
argument_list|(
name|slot
argument_list|,
literal|"Internal clock never stabilised.\n"
argument_list|)
expr_stmt|;
name|sdhci_dumpregs
argument_list|(
name|slot
argument_list|)
expr_stmt|;
return|return;
block|}
name|timeout
operator|--
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
comment|/* Pass clock signal to the bus. */
name|clk
operator||=
name|SDHCI_CLOCK_CARD_EN
expr_stmt|;
name|WR2
argument_list|(
name|slot
argument_list|,
name|SDHCI_CLOCK_CONTROL
argument_list|,
name|clk
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sdhci_set_power
parameter_list|(
name|struct
name|sdhci_slot
modifier|*
name|slot
parameter_list|,
name|u_char
name|power
parameter_list|)
block|{
name|uint8_t
name|pwr
decl_stmt|;
if|if
condition|(
name|slot
operator|->
name|power
operator|==
name|power
condition|)
return|return;
name|slot
operator|->
name|power
operator|=
name|power
expr_stmt|;
comment|/* Turn off the power. */
name|pwr
operator|=
literal|0
expr_stmt|;
name|WR1
argument_list|(
name|slot
argument_list|,
name|SDHCI_POWER_CONTROL
argument_list|,
name|pwr
argument_list|)
expr_stmt|;
comment|/* If power down requested - left it so. */
if|if
condition|(
name|power
operator|==
literal|0
condition|)
return|return;
comment|/* Set voltage. */
switch|switch
condition|(
literal|1
operator|<<
name|power
condition|)
block|{
case|case
name|MMC_OCR_LOW_VOLTAGE
case|:
name|pwr
operator||=
name|SDHCI_POWER_180
expr_stmt|;
break|break;
case|case
name|MMC_OCR_290_300
case|:
case|case
name|MMC_OCR_300_310
case|:
name|pwr
operator||=
name|SDHCI_POWER_300
expr_stmt|;
break|break;
case|case
name|MMC_OCR_320_330
case|:
case|case
name|MMC_OCR_330_340
case|:
name|pwr
operator||=
name|SDHCI_POWER_330
expr_stmt|;
break|break;
block|}
name|WR1
argument_list|(
name|slot
argument_list|,
name|SDHCI_POWER_CONTROL
argument_list|,
name|pwr
argument_list|)
expr_stmt|;
comment|/* Turn on the power. */
name|pwr
operator||=
name|SDHCI_POWER_ON
expr_stmt|;
name|WR1
argument_list|(
name|slot
argument_list|,
name|SDHCI_POWER_CONTROL
argument_list|,
name|pwr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sdhci_read_block_pio
parameter_list|(
name|struct
name|sdhci_slot
modifier|*
name|slot
parameter_list|)
block|{
name|uint32_t
name|data
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
name|size_t
name|left
decl_stmt|;
name|buffer
operator|=
name|slot
operator|->
name|curcmd
operator|->
name|data
operator|->
name|data
expr_stmt|;
name|buffer
operator|+=
name|slot
operator|->
name|offset
expr_stmt|;
comment|/* Transfer one block at a time. */
name|left
operator|=
name|min
argument_list|(
literal|512
argument_list|,
name|slot
operator|->
name|curcmd
operator|->
name|data
operator|->
name|len
operator|-
name|slot
operator|->
name|offset
argument_list|)
expr_stmt|;
name|slot
operator|->
name|offset
operator|+=
name|left
expr_stmt|;
comment|/* If we are too fast, broken controllers return zeroes. */
if|if
condition|(
name|slot
operator|->
name|sc
operator|->
name|quirks
operator|&
name|SDHCI_QUIRK_BROKEN_TIMINGS
condition|)
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
comment|/* Handle unalligned and alligned buffer cases. */
if|if
condition|(
operator|(
name|intptr_t
operator|)
name|buffer
operator|&
literal|3
condition|)
block|{
while|while
condition|(
name|left
operator|>
literal|3
condition|)
block|{
name|data
operator|=
name|RD4
argument_list|(
name|slot
argument_list|,
name|SDHCI_BUFFER
argument_list|)
expr_stmt|;
name|buffer
index|[
literal|0
index|]
operator|=
name|data
expr_stmt|;
name|buffer
index|[
literal|1
index|]
operator|=
operator|(
name|data
operator|>>
literal|8
operator|)
expr_stmt|;
name|buffer
index|[
literal|2
index|]
operator|=
operator|(
name|data
operator|>>
literal|16
operator|)
expr_stmt|;
name|buffer
index|[
literal|3
index|]
operator|=
operator|(
name|data
operator|>>
literal|24
operator|)
expr_stmt|;
name|buffer
operator|+=
literal|4
expr_stmt|;
name|left
operator|-=
literal|4
expr_stmt|;
block|}
block|}
else|else
block|{
name|bus_read_multi_stream_4
argument_list|(
name|slot
operator|->
name|mem_res
argument_list|,
name|SDHCI_BUFFER
argument_list|,
operator|(
name|uint32_t
operator|*
operator|)
name|buffer
argument_list|,
name|left
operator|>>
literal|2
argument_list|)
expr_stmt|;
name|left
operator|&=
literal|3
expr_stmt|;
block|}
comment|/* Handle uneven size case. */
if|if
condition|(
name|left
operator|>
literal|0
condition|)
block|{
name|data
operator|=
name|RD4
argument_list|(
name|slot
argument_list|,
name|SDHCI_BUFFER
argument_list|)
expr_stmt|;
while|while
condition|(
name|left
operator|>
literal|0
condition|)
block|{
operator|*
operator|(
name|buffer
operator|++
operator|)
operator|=
name|data
expr_stmt|;
name|data
operator|>>=
literal|8
expr_stmt|;
name|left
operator|--
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|sdhci_write_block_pio
parameter_list|(
name|struct
name|sdhci_slot
modifier|*
name|slot
parameter_list|)
block|{
name|uint32_t
name|data
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
name|size_t
name|left
decl_stmt|;
name|buffer
operator|=
name|slot
operator|->
name|curcmd
operator|->
name|data
operator|->
name|data
expr_stmt|;
name|buffer
operator|+=
name|slot
operator|->
name|offset
expr_stmt|;
comment|/* Transfer one block at a time. */
name|left
operator|=
name|min
argument_list|(
literal|512
argument_list|,
name|slot
operator|->
name|curcmd
operator|->
name|data
operator|->
name|len
operator|-
name|slot
operator|->
name|offset
argument_list|)
expr_stmt|;
name|slot
operator|->
name|offset
operator|+=
name|left
expr_stmt|;
comment|/* Handle unalligned and alligned buffer cases. */
if|if
condition|(
operator|(
name|intptr_t
operator|)
name|buffer
operator|&
literal|3
condition|)
block|{
while|while
condition|(
name|left
operator|>
literal|3
condition|)
block|{
name|data
operator|=
name|buffer
index|[
literal|0
index|]
operator|+
operator|(
name|buffer
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator|+
operator|(
name|buffer
index|[
literal|2
index|]
operator|<<
literal|16
operator|)
operator|+
operator|(
name|buffer
index|[
literal|3
index|]
operator|<<
literal|24
operator|)
expr_stmt|;
name|left
operator|-=
literal|4
expr_stmt|;
name|buffer
operator|+=
literal|4
expr_stmt|;
name|WR4
argument_list|(
name|slot
argument_list|,
name|SDHCI_BUFFER
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|bus_write_multi_stream_4
argument_list|(
name|slot
operator|->
name|mem_res
argument_list|,
name|SDHCI_BUFFER
argument_list|,
operator|(
name|uint32_t
operator|*
operator|)
name|buffer
argument_list|,
name|left
operator|>>
literal|2
argument_list|)
expr_stmt|;
name|left
operator|&=
literal|3
expr_stmt|;
block|}
comment|/* Handle uneven size case. */
if|if
condition|(
name|left
operator|>
literal|0
condition|)
block|{
while|while
condition|(
name|left
operator|>
literal|0
condition|)
block|{
name|data
operator|<<=
literal|8
expr_stmt|;
name|data
operator|+=
operator|*
operator|(
name|buffer
operator|++
operator|)
expr_stmt|;
name|left
operator|--
expr_stmt|;
block|}
name|WR4
argument_list|(
name|slot
argument_list|,
name|SDHCI_BUFFER
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|sdhci_transfer_pio
parameter_list|(
name|struct
name|sdhci_slot
modifier|*
name|slot
parameter_list|)
block|{
comment|/* Read as many blocks as possible. */
if|if
condition|(
name|slot
operator|->
name|curcmd
operator|->
name|data
operator|->
name|flags
operator|&
name|MMC_DATA_READ
condition|)
block|{
while|while
condition|(
name|RD4
argument_list|(
name|slot
argument_list|,
name|SDHCI_PRESENT_STATE
argument_list|)
operator|&
name|SDHCI_DATA_AVAILABLE
condition|)
block|{
name|sdhci_read_block_pio
argument_list|(
name|slot
argument_list|)
expr_stmt|;
if|if
condition|(
name|slot
operator|->
name|offset
operator|>=
name|slot
operator|->
name|curcmd
operator|->
name|data
operator|->
name|len
condition|)
break|break;
block|}
block|}
else|else
block|{
while|while
condition|(
name|RD4
argument_list|(
name|slot
argument_list|,
name|SDHCI_PRESENT_STATE
argument_list|)
operator|&
name|SDHCI_SPACE_AVAILABLE
condition|)
block|{
name|sdhci_write_block_pio
argument_list|(
name|slot
argument_list|)
expr_stmt|;
if|if
condition|(
name|slot
operator|->
name|offset
operator|>=
name|slot
operator|->
name|curcmd
operator|->
name|data
operator|->
name|len
condition|)
break|break;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|sdhci_card_delay
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|sdhci_slot
modifier|*
name|slot
init|=
name|arg
decl_stmt|;
name|taskqueue_enqueue
argument_list|(
name|taskqueue_swi_giant
argument_list|,
operator|&
name|slot
operator|->
name|card_task
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sdhci_card_task
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|sdhci_slot
modifier|*
name|slot
init|=
name|arg
decl_stmt|;
name|SDHCI_LOCK
argument_list|(
name|slot
argument_list|)
expr_stmt|;
if|if
condition|(
name|RD4
argument_list|(
name|slot
argument_list|,
name|SDHCI_PRESENT_STATE
argument_list|)
operator|&
name|SDHCI_CARD_PRESENT
condition|)
block|{
if|if
condition|(
name|slot
operator|->
name|dev
operator|==
name|NULL
condition|)
block|{
comment|/* If card is present - attach mmc bus. */
name|slot
operator|->
name|dev
operator|=
name|device_add_child
argument_list|(
name|slot
operator|->
name|sc
operator|->
name|dev
argument_list|,
literal|"mmc"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|device_set_ivars
argument_list|(
name|slot
operator|->
name|dev
argument_list|,
name|slot
argument_list|)
expr_stmt|;
name|SDHCI_UNLOCK
argument_list|(
name|slot
argument_list|)
expr_stmt|;
name|device_probe_and_attach
argument_list|(
name|slot
operator|->
name|dev
argument_list|)
expr_stmt|;
block|}
else|else
name|SDHCI_UNLOCK
argument_list|(
name|slot
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|slot
operator|->
name|dev
operator|!=
name|NULL
condition|)
block|{
comment|/* If no card present - detach mmc bus. */
name|device_t
name|d
init|=
name|slot
operator|->
name|dev
decl_stmt|;
name|slot
operator|->
name|dev
operator|=
name|NULL
expr_stmt|;
name|SDHCI_UNLOCK
argument_list|(
name|slot
argument_list|)
expr_stmt|;
name|device_delete_child
argument_list|(
name|slot
operator|->
name|sc
operator|->
name|dev
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
else|else
name|SDHCI_UNLOCK
argument_list|(
name|slot
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|sdhci_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|uint32_t
name|model
decl_stmt|;
name|uint16_t
name|subvendor
decl_stmt|;
name|uint8_t
name|class
decl_stmt|,
name|subclass
decl_stmt|;
name|int
name|i
decl_stmt|,
name|result
decl_stmt|;
name|model
operator|=
operator|(
name|uint32_t
operator|)
name|pci_get_device
argument_list|(
name|dev
argument_list|)
operator|<<
literal|16
expr_stmt|;
name|model
operator||=
operator|(
name|uint32_t
operator|)
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
operator|&
literal|0x0000ffff
expr_stmt|;
name|subvendor
operator|=
name|pci_get_subvendor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|class
operator|=
name|pci_get_class
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|subclass
operator|=
name|pci_get_subclass
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|result
operator|=
name|ENXIO
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|sdhci_devices
index|[
name|i
index|]
operator|.
name|model
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sdhci_devices
index|[
name|i
index|]
operator|.
name|model
operator|==
name|model
operator|&&
operator|(
name|sdhci_devices
index|[
name|i
index|]
operator|.
name|subvendor
operator|==
literal|0xffff
operator|||
name|sdhci_devices
index|[
name|i
index|]
operator|.
name|subvendor
operator|==
name|subvendor
operator|)
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
name|sdhci_devices
index|[
name|i
index|]
operator|.
name|desc
argument_list|)
expr_stmt|;
name|result
operator|=
name|BUS_PROBE_DEFAULT
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|result
operator|==
name|ENXIO
operator|&&
name|class
operator|==
name|PCIC_BASEPERIPH
operator|&&
name|subclass
operator|==
name|PCIS_BASEPERIPH_SDHC
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Generic SD HCI"
argument_list|)
expr_stmt|;
name|result
operator|=
name|BUS_PROBE_GENERIC
expr_stmt|;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sdhci_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|sdhci_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|uint32_t
name|model
decl_stmt|;
name|uint16_t
name|subvendor
decl_stmt|;
name|uint8_t
name|class
decl_stmt|,
name|subclass
decl_stmt|,
name|progif
decl_stmt|;
name|int
name|err
decl_stmt|,
name|slots
decl_stmt|,
name|bar
decl_stmt|,
name|i
decl_stmt|;
name|sc
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|model
operator|=
operator|(
name|uint32_t
operator|)
name|pci_get_device
argument_list|(
name|dev
argument_list|)
operator|<<
literal|16
expr_stmt|;
name|model
operator||=
operator|(
name|uint32_t
operator|)
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
operator|&
literal|0x0000ffff
expr_stmt|;
name|subvendor
operator|=
name|pci_get_subvendor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|class
operator|=
name|pci_get_class
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|subclass
operator|=
name|pci_get_subclass
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|progif
operator|=
name|pci_get_progif
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Apply chip specific quirks. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|sdhci_devices
index|[
name|i
index|]
operator|.
name|model
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sdhci_devices
index|[
name|i
index|]
operator|.
name|model
operator|==
name|model
operator|&&
operator|(
name|sdhci_devices
index|[
name|i
index|]
operator|.
name|subvendor
operator|==
literal|0xffff
operator|||
name|sdhci_devices
index|[
name|i
index|]
operator|.
name|subvendor
operator|==
name|subvendor
operator|)
condition|)
block|{
name|sc
operator|->
name|quirks
operator|=
name|sdhci_devices
index|[
name|i
index|]
operator|.
name|quirks
expr_stmt|;
break|break;
block|}
block|}
comment|/* Read slots info from PCI registers. */
name|slots
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCI_SLOT_INFO
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|bar
operator|=
name|PCI_SLOT_INFO_FIRST_BAR
argument_list|(
name|slots
argument_list|)
expr_stmt|;
name|slots
operator|=
name|PCI_SLOT_INFO_SLOTS
argument_list|(
name|slots
argument_list|)
expr_stmt|;
if|if
condition|(
name|slots
operator|>
literal|6
operator|||
name|bar
operator|>
literal|5
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Incorrect slots information (%d, %d).\n"
argument_list|,
name|slots
argument_list|,
name|bar
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Allocate IRQ. */
name|sc
operator|->
name|irq_rid
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|irq_res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|sc
operator|->
name|irq_rid
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|irq_res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Can't allocate IRQ\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/* Scan all slots. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|slots
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|sdhci_slot
modifier|*
name|slot
init|=
operator|&
name|sc
operator|->
name|slots
index|[
name|sc
operator|->
name|num_slots
index|]
decl_stmt|;
name|uint32_t
name|caps
decl_stmt|;
name|SDHCI_LOCK_INIT
argument_list|(
name|slot
argument_list|)
expr_stmt|;
name|slot
operator|->
name|sc
operator|=
name|sc
expr_stmt|;
name|slot
operator|->
name|num
operator|=
name|sc
operator|->
name|num_slots
expr_stmt|;
comment|/* Allocate memory. */
name|slot
operator|->
name|mem_rid
operator|=
name|PCIR_BAR
argument_list|(
name|bar
operator|+
name|i
argument_list|)
expr_stmt|;
name|slot
operator|->
name|mem_res
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|slot
operator|->
name|mem_rid
argument_list|,
literal|0ul
argument_list|,
operator|~
literal|0ul
argument_list|,
literal|0x100
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|slot
operator|->
name|mem_res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Can't allocate memory\n"
argument_list|)
expr_stmt|;
name|SDHCI_LOCK_DESTROY
argument_list|(
name|slot
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Allocate DMA tag. */
name|err
operator|=
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|dev
argument_list|)
argument_list|,
name|DMA_BLOCK_SIZE
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|DMA_BLOCK_SIZE
argument_list|,
literal|1
argument_list|,
name|DMA_BLOCK_SIZE
argument_list|,
name|BUS_DMA_ALLOCNOW
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|slot
operator|->
name|dmatag
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Can't create DMA tag\n"
argument_list|)
expr_stmt|;
name|SDHCI_LOCK_DESTROY
argument_list|(
name|slot
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Allocate DMA memory. */
name|err
operator|=
name|bus_dmamem_alloc
argument_list|(
name|slot
operator|->
name|dmatag
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|slot
operator|->
name|dmamem
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|slot
operator|->
name|dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Can't alloc DMA memory\n"
argument_list|)
expr_stmt|;
name|SDHCI_LOCK_DESTROY
argument_list|(
name|slot
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Map the memory. */
name|err
operator|=
name|bus_dmamap_load
argument_list|(
name|slot
operator|->
name|dmatag
argument_list|,
name|slot
operator|->
name|dmamap
argument_list|,
operator|(
name|void
operator|*
operator|)
name|slot
operator|->
name|dmamem
argument_list|,
name|DMA_BLOCK_SIZE
argument_list|,
name|sdhci_getaddr
argument_list|,
operator|&
name|slot
operator|->
name|paddr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
operator|||
name|slot
operator|->
name|paddr
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Can't load DMA memory\n"
argument_list|)
expr_stmt|;
name|SDHCI_LOCK_DESTROY
argument_list|(
name|slot
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Initialize slot. */
name|sdhci_init
argument_list|(
name|slot
argument_list|)
expr_stmt|;
name|caps
operator|=
name|RD4
argument_list|(
name|slot
argument_list|,
name|SDHCI_CAPABILITIES
argument_list|)
expr_stmt|;
comment|/* Calculate base clock frequency. */
name|slot
operator|->
name|max_clk
operator|=
operator|(
name|caps
operator|&
name|SDHCI_CLOCK_BASE_MASK
operator|)
operator|>>
name|SDHCI_CLOCK_BASE_SHIFT
expr_stmt|;
if|if
condition|(
name|slot
operator|->
name|max_clk
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Hardware doesn't specify base clock "
literal|"frequency.\n"
argument_list|)
expr_stmt|;
block|}
name|slot
operator|->
name|max_clk
operator|*=
literal|1000000
expr_stmt|;
comment|/* Calculate timeout clock frequency. */
name|slot
operator|->
name|timeout_clk
operator|=
operator|(
name|caps
operator|&
name|SDHCI_TIMEOUT_CLK_MASK
operator|)
operator|>>
name|SDHCI_TIMEOUT_CLK_SHIFT
expr_stmt|;
if|if
condition|(
name|slot
operator|->
name|timeout_clk
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Hardware doesn't specify timeout clock "
literal|"frequency.\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|caps
operator|&
name|SDHCI_TIMEOUT_CLK_UNIT
condition|)
name|slot
operator|->
name|timeout_clk
operator|*=
literal|1000
expr_stmt|;
name|slot
operator|->
name|host
operator|.
name|f_min
operator|=
name|slot
operator|->
name|max_clk
operator|/
literal|256
expr_stmt|;
name|slot
operator|->
name|host
operator|.
name|f_max
operator|=
name|slot
operator|->
name|max_clk
expr_stmt|;
name|slot
operator|->
name|host
operator|.
name|host_ocr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|caps
operator|&
name|SDHCI_CAN_VDD_330
condition|)
name|slot
operator|->
name|host
operator|.
name|host_ocr
operator||=
name|MMC_OCR_320_330
operator||
name|MMC_OCR_330_340
expr_stmt|;
if|if
condition|(
name|caps
operator|&
name|SDHCI_CAN_VDD_300
condition|)
name|slot
operator|->
name|host
operator|.
name|host_ocr
operator||=
name|MMC_OCR_290_300
operator||
name|MMC_OCR_300_310
expr_stmt|;
if|if
condition|(
name|caps
operator|&
name|SDHCI_CAN_VDD_180
condition|)
name|slot
operator|->
name|host
operator|.
name|host_ocr
operator||=
name|MMC_OCR_LOW_VOLTAGE
expr_stmt|;
if|if
condition|(
name|slot
operator|->
name|host
operator|.
name|host_ocr
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Hardware doesn't report any "
literal|"support voltages.\n"
argument_list|)
expr_stmt|;
block|}
name|slot
operator|->
name|host
operator|.
name|caps
operator|=
name|MMC_CAP_4_BIT_DATA
expr_stmt|;
if|if
condition|(
name|caps
operator|&
name|SDHCI_CAN_DO_HISPD
condition|)
name|slot
operator|->
name|host
operator|.
name|caps
operator||=
name|MMC_CAP_HSPEED
expr_stmt|;
comment|/* Decide if we have usable DMA. */
if|if
condition|(
name|caps
operator|&
name|SDHCI_CAN_DO_DMA
condition|)
name|slot
operator|->
name|opt
operator||=
name|SDHCI_HAVE_DMA
expr_stmt|;
if|if
condition|(
name|class
operator|==
name|PCIC_BASEPERIPH
operator|&&
name|subclass
operator|==
name|PCIS_BASEPERIPH_SDHC
operator|&&
name|progif
operator|!=
name|PCI_SDHCI_IFDMA
condition|)
name|slot
operator|->
name|opt
operator|&=
operator|~
name|SDHCI_HAVE_DMA
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|quirks
operator|&
name|SDHCI_QUIRK_BROKEN_DMA
condition|)
name|slot
operator|->
name|opt
operator|&=
operator|~
name|SDHCI_HAVE_DMA
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|quirks
operator|&
name|SDHCI_QUIRK_FORCE_DMA
condition|)
name|slot
operator|->
name|opt
operator||=
name|SDHCI_HAVE_DMA
expr_stmt|;
if|if
condition|(
name|bootverbose
operator|||
name|sdhci_debug
condition|)
block|{
name|slot_printf
argument_list|(
name|slot
argument_list|,
literal|"%uMHz%s 4bits%s%s%s %s\n"
argument_list|,
name|slot
operator|->
name|max_clk
operator|/
literal|1000000
argument_list|,
operator|(
name|caps
operator|&
name|SDHCI_CAN_DO_HISPD
operator|)
condition|?
literal|" HS"
else|:
literal|""
argument_list|,
operator|(
name|caps
operator|&
name|SDHCI_CAN_VDD_330
operator|)
condition|?
literal|" 3.3V"
else|:
literal|""
argument_list|,
operator|(
name|caps
operator|&
name|SDHCI_CAN_VDD_300
operator|)
condition|?
literal|" 3.0V"
else|:
literal|""
argument_list|,
operator|(
name|caps
operator|&
name|SDHCI_CAN_VDD_180
operator|)
condition|?
literal|" 1.8V"
else|:
literal|""
argument_list|,
operator|(
name|slot
operator|->
name|opt
operator|&
name|SDHCI_HAVE_DMA
operator|)
condition|?
literal|"DMA"
else|:
literal|"PIO"
argument_list|)
expr_stmt|;
name|sdhci_dumpregs
argument_list|(
name|slot
argument_list|)
expr_stmt|;
block|}
name|TASK_INIT
argument_list|(
operator|&
name|slot
operator|->
name|card_task
argument_list|,
literal|0
argument_list|,
name|sdhci_card_task
argument_list|,
name|slot
argument_list|)
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|slot
operator|->
name|card_callout
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sc
operator|->
name|num_slots
operator|++
expr_stmt|;
block|}
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%d slot(s) allocated\n"
argument_list|,
name|sc
operator|->
name|num_slots
argument_list|)
expr_stmt|;
comment|/* Activate the interrupt */
name|err
operator|=
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|irq_res
argument_list|,
name|INTR_TYPE_MISC
operator||
name|INTR_MPSAFE
argument_list|,
name|NULL
argument_list|,
name|sdhci_intr
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|intrhand
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Can't setup IRQ\n"
argument_list|)
expr_stmt|;
name|pci_enable_busmaster
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Process cards detection. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_slots
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|sdhci_slot
modifier|*
name|slot
init|=
operator|&
name|sc
operator|->
name|slots
index|[
name|i
index|]
decl_stmt|;
name|sdhci_card_task
argument_list|(
name|slot
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sdhci_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|sdhci_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|irq_res
argument_list|,
name|sc
operator|->
name|intrhand
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|sc
operator|->
name|irq_rid
argument_list|,
name|sc
operator|->
name|irq_res
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_slots
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|sdhci_slot
modifier|*
name|slot
init|=
operator|&
name|sc
operator|->
name|slots
index|[
name|i
index|]
decl_stmt|;
name|device_t
name|d
decl_stmt|;
name|callout_drain
argument_list|(
operator|&
name|slot
operator|->
name|card_callout
argument_list|)
expr_stmt|;
name|taskqueue_drain
argument_list|(
name|taskqueue_swi_giant
argument_list|,
operator|&
name|slot
operator|->
name|card_task
argument_list|)
expr_stmt|;
name|SDHCI_LOCK
argument_list|(
name|slot
argument_list|)
expr_stmt|;
name|d
operator|=
name|slot
operator|->
name|dev
expr_stmt|;
name|slot
operator|->
name|dev
operator|=
name|NULL
expr_stmt|;
name|SDHCI_UNLOCK
argument_list|(
name|slot
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|!=
name|NULL
condition|)
name|device_delete_child
argument_list|(
name|dev
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|SDHCI_LOCK
argument_list|(
name|slot
argument_list|)
expr_stmt|;
name|sdhci_reset
argument_list|(
name|slot
argument_list|,
name|SDHCI_RESET_ALL
argument_list|)
expr_stmt|;
name|SDHCI_UNLOCK
argument_list|(
name|slot
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|slot
operator|->
name|dmatag
argument_list|,
name|slot
operator|->
name|dmamap
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|slot
operator|->
name|dmatag
argument_list|,
name|slot
operator|->
name|dmamem
argument_list|,
name|slot
operator|->
name|dmamap
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|slot
operator|->
name|dmatag
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|slot
operator|->
name|mem_rid
argument_list|,
name|slot
operator|->
name|mem_res
argument_list|)
expr_stmt|;
name|SDHCI_LOCK_DESTROY
argument_list|(
name|slot
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sdhci_suspend
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|sdhci_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|err
decl_stmt|;
name|err
operator|=
name|bus_generic_suspend
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_slots
condition|;
name|i
operator|++
control|)
name|sdhci_reset
argument_list|(
operator|&
name|sc
operator|->
name|slots
index|[
name|i
index|]
argument_list|,
name|SDHCI_RESET_ALL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sdhci_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|sdhci_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_slots
condition|;
name|i
operator|++
control|)
name|sdhci_init
argument_list|(
operator|&
name|sc
operator|->
name|slots
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|bus_generic_resume
argument_list|(
name|dev
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sdhci_update_ios
parameter_list|(
name|device_t
name|brdev
parameter_list|,
name|device_t
name|reqdev
parameter_list|)
block|{
name|struct
name|sdhci_slot
modifier|*
name|slot
init|=
name|device_get_ivars
argument_list|(
name|reqdev
argument_list|)
decl_stmt|;
name|struct
name|mmc_ios
modifier|*
name|ios
init|=
operator|&
name|slot
operator|->
name|host
operator|.
name|ios
decl_stmt|;
name|SDHCI_LOCK
argument_list|(
name|slot
argument_list|)
expr_stmt|;
comment|/* Do full reset on bus power down to clear from any state. */
if|if
condition|(
name|ios
operator|->
name|power_mode
operator|==
name|power_off
condition|)
block|{
name|WR4
argument_list|(
name|slot
argument_list|,
name|SDHCI_SIGNAL_ENABLE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sdhci_init
argument_list|(
name|slot
argument_list|)
expr_stmt|;
block|}
comment|/* Configure the bus. */
name|sdhci_set_clock
argument_list|(
name|slot
argument_list|,
name|ios
operator|->
name|clock
argument_list|)
expr_stmt|;
name|sdhci_set_power
argument_list|(
name|slot
argument_list|,
operator|(
name|ios
operator|->
name|power_mode
operator|==
name|power_off
operator|)
condition|?
literal|0
else|:
name|ios
operator|->
name|vdd
argument_list|)
expr_stmt|;
if|if
condition|(
name|ios
operator|->
name|bus_width
operator|==
name|bus_width_4
condition|)
name|slot
operator|->
name|hostctrl
operator||=
name|SDHCI_CTRL_4BITBUS
expr_stmt|;
else|else
name|slot
operator|->
name|hostctrl
operator|&=
operator|~
name|SDHCI_CTRL_4BITBUS
expr_stmt|;
if|if
condition|(
name|ios
operator|->
name|timing
operator|==
name|bus_timing_hs
condition|)
name|slot
operator|->
name|hostctrl
operator||=
name|SDHCI_CTRL_HISPD
expr_stmt|;
else|else
name|slot
operator|->
name|hostctrl
operator|&=
operator|~
name|SDHCI_CTRL_HISPD
expr_stmt|;
name|WR1
argument_list|(
name|slot
argument_list|,
name|SDHCI_HOST_CONTROL
argument_list|,
name|slot
operator|->
name|hostctrl
argument_list|)
expr_stmt|;
comment|/* Some controllers like reset after bus changes. */
if|if
condition|(
name|slot
operator|->
name|sc
operator|->
name|quirks
operator|&
name|SDHCI_QUIRK_RESET_ON_IOS
condition|)
name|sdhci_reset
argument_list|(
name|slot
argument_list|,
name|SDHCI_RESET_CMD
operator||
name|SDHCI_RESET_DATA
argument_list|)
expr_stmt|;
name|SDHCI_UNLOCK
argument_list|(
name|slot
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sdhci_set_transfer_mode
parameter_list|(
name|struct
name|sdhci_slot
modifier|*
name|slot
parameter_list|,
name|struct
name|mmc_data
modifier|*
name|data
parameter_list|)
block|{
name|uint16_t
name|mode
decl_stmt|;
if|if
condition|(
name|data
operator|==
name|NULL
condition|)
return|return;
name|mode
operator|=
name|SDHCI_TRNS_BLK_CNT_EN
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|len
operator|>
literal|512
condition|)
name|mode
operator||=
name|SDHCI_TRNS_MULTI
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|flags
operator|&
name|MMC_DATA_READ
condition|)
name|mode
operator||=
name|SDHCI_TRNS_READ
expr_stmt|;
if|if
condition|(
name|slot
operator|->
name|req
operator|->
name|stop
condition|)
name|mode
operator||=
name|SDHCI_TRNS_ACMD12
expr_stmt|;
if|if
condition|(
name|slot
operator|->
name|flags
operator|&
name|SDHCI_USE_DMA
condition|)
name|mode
operator||=
name|SDHCI_TRNS_DMA
expr_stmt|;
name|WR2
argument_list|(
name|slot
argument_list|,
name|SDHCI_TRANSFER_MODE
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sdhci_start_command
parameter_list|(
name|struct
name|sdhci_slot
modifier|*
name|slot
parameter_list|,
name|struct
name|mmc_command
modifier|*
name|cmd
parameter_list|)
block|{
name|struct
name|mmc_request
modifier|*
name|req
init|=
name|slot
operator|->
name|req
decl_stmt|;
name|int
name|flags
decl_stmt|,
name|timeout
decl_stmt|;
name|uint32_t
name|mask
decl_stmt|,
name|state
decl_stmt|;
name|slot
operator|->
name|curcmd
operator|=
name|cmd
expr_stmt|;
name|slot
operator|->
name|cmd_done
operator|=
literal|0
expr_stmt|;
name|cmd
operator|->
name|error
operator|=
name|MMC_ERR_NONE
expr_stmt|;
comment|/* This flags combination is not supported by controller. */
if|if
condition|(
operator|(
name|cmd
operator|->
name|flags
operator|&
name|MMC_RSP_136
operator|)
operator|&&
operator|(
name|cmd
operator|->
name|flags
operator|&
name|MMC_RSP_BUSY
operator|)
condition|)
block|{
name|slot_printf
argument_list|(
name|slot
argument_list|,
literal|"Unsupported response type!\n"
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|error
operator|=
name|MMC_ERR_FAILED
expr_stmt|;
name|slot
operator|->
name|req
operator|=
name|NULL
expr_stmt|;
name|slot
operator|->
name|curcmd
operator|=
name|NULL
expr_stmt|;
name|req
operator|->
name|done
argument_list|(
name|req
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Read controller present state. */
name|state
operator|=
name|RD4
argument_list|(
name|slot
argument_list|,
name|SDHCI_PRESENT_STATE
argument_list|)
expr_stmt|;
comment|/* Do not issue command if there is no card, clock or power. 	 * Controller will not detect timeout without clock active. */
if|if
condition|(
operator|(
name|state
operator|&
name|SDHCI_CARD_PRESENT
operator|)
operator|==
literal|0
operator|||
name|slot
operator|->
name|power
operator|==
literal|0
operator|||
name|slot
operator|->
name|clock
operator|==
literal|0
condition|)
block|{
name|cmd
operator|->
name|error
operator|=
name|MMC_ERR_FAILED
expr_stmt|;
name|slot
operator|->
name|req
operator|=
name|NULL
expr_stmt|;
name|slot
operator|->
name|curcmd
operator|=
name|NULL
expr_stmt|;
name|req
operator|->
name|done
argument_list|(
name|req
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Always wait for free CMD bus. */
name|mask
operator|=
name|SDHCI_CMD_INHIBIT
expr_stmt|;
comment|/* Wait for free DAT if we have data or busy signal. */
if|if
condition|(
name|cmd
operator|->
name|data
operator|||
operator|(
name|cmd
operator|->
name|flags
operator|&
name|MMC_RSP_BUSY
operator|)
condition|)
name|mask
operator||=
name|SDHCI_DAT_INHIBIT
expr_stmt|;
comment|/* We shouldn't wait for DAT for stop commands. */
if|if
condition|(
name|cmd
operator|==
name|slot
operator|->
name|req
operator|->
name|stop
condition|)
name|mask
operator|&=
operator|~
name|SDHCI_DAT_INHIBIT
expr_stmt|;
comment|/* Wait for bus no more then 10 ms. */
name|timeout
operator|=
literal|10
expr_stmt|;
while|while
condition|(
name|state
operator|&
name|mask
condition|)
block|{
if|if
condition|(
name|timeout
operator|==
literal|0
condition|)
block|{
name|slot_printf
argument_list|(
name|slot
argument_list|,
literal|"Controller never released "
literal|"inhibit bit(s).\n"
argument_list|)
expr_stmt|;
name|sdhci_dumpregs
argument_list|(
name|slot
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|error
operator|=
name|MMC_ERR_FAILED
expr_stmt|;
name|slot
operator|->
name|req
operator|=
name|NULL
expr_stmt|;
name|slot
operator|->
name|curcmd
operator|=
name|NULL
expr_stmt|;
name|req
operator|->
name|done
argument_list|(
name|req
argument_list|)
expr_stmt|;
return|return;
block|}
name|timeout
operator|--
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|state
operator|=
name|RD4
argument_list|(
name|slot
argument_list|,
name|SDHCI_PRESENT_STATE
argument_list|)
expr_stmt|;
block|}
comment|/* Prepare command flags. */
if|if
condition|(
operator|!
operator|(
name|cmd
operator|->
name|flags
operator|&
name|MMC_RSP_PRESENT
operator|)
condition|)
name|flags
operator|=
name|SDHCI_CMD_RESP_NONE
expr_stmt|;
elseif|else
if|if
condition|(
name|cmd
operator|->
name|flags
operator|&
name|MMC_RSP_136
condition|)
name|flags
operator|=
name|SDHCI_CMD_RESP_LONG
expr_stmt|;
elseif|else
if|if
condition|(
name|cmd
operator|->
name|flags
operator|&
name|MMC_RSP_BUSY
condition|)
name|flags
operator|=
name|SDHCI_CMD_RESP_SHORT_BUSY
expr_stmt|;
else|else
name|flags
operator|=
name|SDHCI_CMD_RESP_SHORT
expr_stmt|;
if|if
condition|(
name|cmd
operator|->
name|flags
operator|&
name|MMC_RSP_CRC
condition|)
name|flags
operator||=
name|SDHCI_CMD_CRC
expr_stmt|;
if|if
condition|(
name|cmd
operator|->
name|flags
operator|&
name|MMC_RSP_OPCODE
condition|)
name|flags
operator||=
name|SDHCI_CMD_INDEX
expr_stmt|;
if|if
condition|(
name|cmd
operator|->
name|data
condition|)
name|flags
operator||=
name|SDHCI_CMD_DATA
expr_stmt|;
if|if
condition|(
name|cmd
operator|->
name|opcode
operator|==
name|MMC_STOP_TRANSMISSION
condition|)
name|flags
operator||=
name|SDHCI_CMD_TYPE_ABORT
expr_stmt|;
comment|/* Prepare data. */
name|sdhci_start_data
argument_list|(
name|slot
argument_list|,
name|cmd
operator|->
name|data
argument_list|)
expr_stmt|;
comment|/*  	 * Interrupt aggregation: To reduce total number of interrupts 	 * group response interrupt with data interrupt when possible. 	 * If there going to be data interrupt, mask response one. 	 */
if|if
condition|(
name|slot
operator|->
name|data_done
operator|==
literal|0
condition|)
block|{
name|WR4
argument_list|(
name|slot
argument_list|,
name|SDHCI_SIGNAL_ENABLE
argument_list|,
name|slot
operator|->
name|intmask
operator|&=
operator|~
name|SDHCI_INT_RESPONSE
argument_list|)
expr_stmt|;
block|}
comment|/* Set command argument. */
name|WR4
argument_list|(
name|slot
argument_list|,
name|SDHCI_ARGUMENT
argument_list|,
name|cmd
operator|->
name|arg
argument_list|)
expr_stmt|;
comment|/* Set data transfer mode. */
name|sdhci_set_transfer_mode
argument_list|(
name|slot
argument_list|,
name|cmd
operator|->
name|data
argument_list|)
expr_stmt|;
comment|/* Set command flags. */
name|WR1
argument_list|(
name|slot
argument_list|,
name|SDHCI_COMMAND_FLAGS
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* Start command. */
name|WR1
argument_list|(
name|slot
argument_list|,
name|SDHCI_COMMAND
argument_list|,
name|cmd
operator|->
name|opcode
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sdhci_finish_command
parameter_list|(
name|struct
name|sdhci_slot
modifier|*
name|slot
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|slot
operator|->
name|cmd_done
operator|=
literal|1
expr_stmt|;
comment|/* Interrupt aggregation: Restore command interrupt. 	 * Main restore point for the case when command interrupt 	 * happened first. */
name|WR4
argument_list|(
name|slot
argument_list|,
name|SDHCI_SIGNAL_ENABLE
argument_list|,
name|slot
operator|->
name|intmask
operator||=
name|SDHCI_INT_RESPONSE
argument_list|)
expr_stmt|;
comment|/* In case of error - reset host and return. */
if|if
condition|(
name|slot
operator|->
name|curcmd
operator|->
name|error
condition|)
block|{
name|sdhci_reset
argument_list|(
name|slot
argument_list|,
name|SDHCI_RESET_CMD
argument_list|)
expr_stmt|;
name|sdhci_reset
argument_list|(
name|slot
argument_list|,
name|SDHCI_RESET_DATA
argument_list|)
expr_stmt|;
name|sdhci_start
argument_list|(
name|slot
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If command has response - fetch it. */
if|if
condition|(
name|slot
operator|->
name|curcmd
operator|->
name|flags
operator|&
name|MMC_RSP_PRESENT
condition|)
block|{
if|if
condition|(
name|slot
operator|->
name|curcmd
operator|->
name|flags
operator|&
name|MMC_RSP_136
condition|)
block|{
comment|/* CRC is stripped so we need one byte shift. */
name|uint8_t
name|extra
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|uint32_t
name|val
init|=
name|RD4
argument_list|(
name|slot
argument_list|,
name|SDHCI_RESPONSE
operator|+
name|i
operator|*
literal|4
argument_list|)
decl_stmt|;
name|slot
operator|->
name|curcmd
operator|->
name|resp
index|[
literal|3
operator|-
name|i
index|]
operator|=
operator|(
name|val
operator|<<
literal|8
operator|)
operator|+
name|extra
expr_stmt|;
name|extra
operator|=
name|val
operator|>>
literal|24
expr_stmt|;
block|}
block|}
else|else
name|slot
operator|->
name|curcmd
operator|->
name|resp
index|[
literal|0
index|]
operator|=
name|RD4
argument_list|(
name|slot
argument_list|,
name|SDHCI_RESPONSE
argument_list|)
expr_stmt|;
block|}
comment|/* If data ready - finish. */
if|if
condition|(
name|slot
operator|->
name|data_done
condition|)
name|sdhci_start
argument_list|(
name|slot
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sdhci_start_data
parameter_list|(
name|struct
name|sdhci_slot
modifier|*
name|slot
parameter_list|,
name|struct
name|mmc_data
modifier|*
name|data
parameter_list|)
block|{
name|uint32_t
name|target_timeout
decl_stmt|,
name|current_timeout
decl_stmt|;
name|uint8_t
name|div
decl_stmt|;
if|if
condition|(
name|data
operator|==
name|NULL
operator|&&
operator|(
name|slot
operator|->
name|curcmd
operator|->
name|flags
operator|&
name|MMC_RSP_BUSY
operator|)
operator|==
literal|0
condition|)
block|{
name|slot
operator|->
name|data_done
operator|=
literal|1
expr_stmt|;
return|return;
block|}
name|slot
operator|->
name|data_done
operator|=
literal|0
expr_stmt|;
comment|/* Calculate and set data timeout.*/
comment|/* XXX: We should have this from mmc layer, now assume 1 sec. */
name|target_timeout
operator|=
literal|1000000
expr_stmt|;
name|div
operator|=
literal|0
expr_stmt|;
name|current_timeout
operator|=
operator|(
literal|1
operator|<<
literal|13
operator|)
operator|*
literal|1000
operator|/
name|slot
operator|->
name|timeout_clk
expr_stmt|;
while|while
condition|(
name|current_timeout
operator|<
name|target_timeout
condition|)
block|{
name|div
operator|++
expr_stmt|;
name|current_timeout
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
name|div
operator|>=
literal|0xF
condition|)
break|break;
block|}
comment|/* Compensate for an off-by-one error in the CaFe chip.*/
if|if
condition|(
name|slot
operator|->
name|sc
operator|->
name|quirks
operator|&
name|SDHCI_QUIRK_INCR_TIMEOUT_CONTROL
condition|)
name|div
operator|++
expr_stmt|;
if|if
condition|(
name|div
operator|>=
literal|0xF
condition|)
block|{
name|slot_printf
argument_list|(
name|slot
argument_list|,
literal|"Timeout too large!\n"
argument_list|)
expr_stmt|;
name|div
operator|=
literal|0xE
expr_stmt|;
block|}
name|WR1
argument_list|(
name|slot
argument_list|,
name|SDHCI_TIMEOUT_CONTROL
argument_list|,
name|div
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|==
name|NULL
condition|)
return|return;
comment|/* Use DMA if possible. */
if|if
condition|(
operator|(
name|slot
operator|->
name|opt
operator|&
name|SDHCI_HAVE_DMA
operator|)
condition|)
name|slot
operator|->
name|flags
operator||=
name|SDHCI_USE_DMA
expr_stmt|;
comment|/* If data is small, broken DMA may return zeroes instead of data, */
if|if
condition|(
operator|(
name|slot
operator|->
name|sc
operator|->
name|quirks
operator|&
name|SDHCI_QUIRK_BROKEN_TIMINGS
operator|)
operator|&&
operator|(
name|data
operator|->
name|len
operator|<=
literal|512
operator|)
condition|)
name|slot
operator|->
name|flags
operator|&=
operator|~
name|SDHCI_USE_DMA
expr_stmt|;
comment|/* Some controllers require even block sizes. */
if|if
condition|(
operator|(
name|slot
operator|->
name|sc
operator|->
name|quirks
operator|&
name|SDHCI_QUIRK_32BIT_DMA_SIZE
operator|)
operator|&&
operator|(
operator|(
name|data
operator|->
name|len
operator|)
operator|&
literal|0x3
operator|)
condition|)
name|slot
operator|->
name|flags
operator|&=
operator|~
name|SDHCI_USE_DMA
expr_stmt|;
comment|/* Load DMA buffer. */
if|if
condition|(
name|slot
operator|->
name|flags
operator|&
name|SDHCI_USE_DMA
condition|)
block|{
if|if
condition|(
name|data
operator|->
name|flags
operator|&
name|MMC_DATA_READ
condition|)
name|bus_dmamap_sync
argument_list|(
name|slot
operator|->
name|dmatag
argument_list|,
name|slot
operator|->
name|dmamap
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
else|else
block|{
name|memcpy
argument_list|(
name|slot
operator|->
name|dmamem
argument_list|,
name|data
operator|->
name|data
argument_list|,
operator|(
name|data
operator|->
name|len
operator|<
name|DMA_BLOCK_SIZE
operator|)
condition|?
name|data
operator|->
name|len
else|:
name|DMA_BLOCK_SIZE
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|slot
operator|->
name|dmatag
argument_list|,
name|slot
operator|->
name|dmamap
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
block|}
name|WR4
argument_list|(
name|slot
argument_list|,
name|SDHCI_DMA_ADDRESS
argument_list|,
name|slot
operator|->
name|paddr
argument_list|)
expr_stmt|;
comment|/* Interrupt aggregation: Mask border interrupt 		 * for the last page and unmask else. */
if|if
condition|(
name|data
operator|->
name|len
operator|==
name|DMA_BLOCK_SIZE
condition|)
name|slot
operator|->
name|intmask
operator|&=
operator|~
name|SDHCI_INT_DMA_END
expr_stmt|;
else|else
name|slot
operator|->
name|intmask
operator||=
name|SDHCI_INT_DMA_END
expr_stmt|;
name|WR4
argument_list|(
name|slot
argument_list|,
name|SDHCI_SIGNAL_ENABLE
argument_list|,
name|slot
operator|->
name|intmask
argument_list|)
expr_stmt|;
block|}
comment|/* Current data offset for both PIO and DMA. */
name|slot
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
comment|/* Set block size and request IRQ on 4K border. */
name|WR2
argument_list|(
name|slot
argument_list|,
name|SDHCI_BLOCK_SIZE
argument_list|,
name|SDHCI_MAKE_BLKSZ
argument_list|(
name|DMA_BOUNDARY
argument_list|,
operator|(
name|data
operator|->
name|len
operator|<
literal|512
operator|)
condition|?
name|data
operator|->
name|len
else|:
literal|512
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set block count. */
name|WR2
argument_list|(
name|slot
argument_list|,
name|SDHCI_BLOCK_COUNT
argument_list|,
operator|(
name|data
operator|->
name|len
operator|+
literal|511
operator|)
operator|/
literal|512
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sdhci_finish_data
parameter_list|(
name|struct
name|sdhci_slot
modifier|*
name|slot
parameter_list|)
block|{
name|struct
name|mmc_data
modifier|*
name|data
init|=
name|slot
operator|->
name|curcmd
operator|->
name|data
decl_stmt|;
name|slot
operator|->
name|data_done
operator|=
literal|1
expr_stmt|;
comment|/* Interrupt aggregation: Restore command interrupt. 	 * Auxillary restore point for the case when data interrupt 	 * happened first. */
if|if
condition|(
operator|!
name|slot
operator|->
name|cmd_done
condition|)
block|{
name|WR4
argument_list|(
name|slot
argument_list|,
name|SDHCI_SIGNAL_ENABLE
argument_list|,
name|slot
operator|->
name|intmask
operator||=
name|SDHCI_INT_RESPONSE
argument_list|)
expr_stmt|;
block|}
comment|/* Unload rest of data from DMA buffer. */
if|if
condition|(
name|slot
operator|->
name|flags
operator|&
name|SDHCI_USE_DMA
condition|)
block|{
if|if
condition|(
name|data
operator|->
name|flags
operator|&
name|MMC_DATA_READ
condition|)
block|{
name|size_t
name|left
init|=
name|data
operator|->
name|len
operator|-
name|slot
operator|->
name|offset
decl_stmt|;
name|bus_dmamap_sync
argument_list|(
name|slot
operator|->
name|dmatag
argument_list|,
name|slot
operator|->
name|dmamap
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|data
operator|->
name|data
operator|+
name|slot
operator|->
name|offset
argument_list|,
name|slot
operator|->
name|dmamem
argument_list|,
operator|(
name|left
operator|<
name|DMA_BLOCK_SIZE
operator|)
condition|?
name|left
else|:
name|DMA_BLOCK_SIZE
argument_list|)
expr_stmt|;
block|}
else|else
name|bus_dmamap_sync
argument_list|(
name|slot
operator|->
name|dmatag
argument_list|,
name|slot
operator|->
name|dmamap
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
block|}
comment|/* If there was error - reset the host. */
if|if
condition|(
name|slot
operator|->
name|curcmd
operator|->
name|error
condition|)
block|{
name|sdhci_reset
argument_list|(
name|slot
argument_list|,
name|SDHCI_RESET_CMD
argument_list|)
expr_stmt|;
name|sdhci_reset
argument_list|(
name|slot
argument_list|,
name|SDHCI_RESET_DATA
argument_list|)
expr_stmt|;
name|sdhci_start
argument_list|(
name|slot
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If we already have command response - finish. */
if|if
condition|(
name|slot
operator|->
name|cmd_done
condition|)
name|sdhci_start
argument_list|(
name|slot
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sdhci_start
parameter_list|(
name|struct
name|sdhci_slot
modifier|*
name|slot
parameter_list|)
block|{
name|struct
name|mmc_request
modifier|*
name|req
decl_stmt|;
name|req
operator|=
name|slot
operator|->
name|req
expr_stmt|;
if|if
condition|(
name|req
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
operator|!
operator|(
name|slot
operator|->
name|flags
operator|&
name|CMD_STARTED
operator|)
condition|)
block|{
name|slot
operator|->
name|flags
operator||=
name|CMD_STARTED
expr_stmt|;
name|sdhci_start_command
argument_list|(
name|slot
argument_list|,
name|req
operator|->
name|cmd
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	We don't need this until using Auto-CMD12 feature 	if (!(slot->flags& STOP_STARTED)&& req->stop) { 		slot->flags |= STOP_STARTED; 		sdhci_start_command(slot, req->stop); 		return; 	} */
if|if
condition|(
name|sdhci_debug
operator|>
literal|1
condition|)
name|slot_printf
argument_list|(
name|slot
argument_list|,
literal|"result: %d\n"
argument_list|,
name|req
operator|->
name|cmd
operator|->
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|req
operator|->
name|cmd
operator|->
name|error
operator|&&
operator|(
name|slot
operator|->
name|sc
operator|->
name|quirks
operator|&
name|SDHCI_QUIRK_RESET_AFTER_REQUEST
operator|)
condition|)
block|{
name|sdhci_reset
argument_list|(
name|slot
argument_list|,
name|SDHCI_RESET_CMD
argument_list|)
expr_stmt|;
name|sdhci_reset
argument_list|(
name|slot
argument_list|,
name|SDHCI_RESET_DATA
argument_list|)
expr_stmt|;
block|}
comment|/* We must be done -- bad idea to do this while locked? */
name|slot
operator|->
name|req
operator|=
name|NULL
expr_stmt|;
name|slot
operator|->
name|curcmd
operator|=
name|NULL
expr_stmt|;
name|req
operator|->
name|done
argument_list|(
name|req
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|sdhci_request
parameter_list|(
name|device_t
name|brdev
parameter_list|,
name|device_t
name|reqdev
parameter_list|,
name|struct
name|mmc_request
modifier|*
name|req
parameter_list|)
block|{
name|struct
name|sdhci_slot
modifier|*
name|slot
init|=
name|device_get_ivars
argument_list|(
name|reqdev
argument_list|)
decl_stmt|;
name|SDHCI_LOCK
argument_list|(
name|slot
argument_list|)
expr_stmt|;
if|if
condition|(
name|slot
operator|->
name|req
operator|!=
name|NULL
condition|)
block|{
name|SDHCI_UNLOCK
argument_list|(
name|slot
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
if|if
condition|(
name|sdhci_debug
operator|>
literal|1
condition|)
block|{
name|slot_printf
argument_list|(
name|slot
argument_list|,
literal|"CMD%u arg %#x flags %#x dlen %u dflags %#x\n"
argument_list|,
name|req
operator|->
name|cmd
operator|->
name|opcode
argument_list|,
name|req
operator|->
name|cmd
operator|->
name|arg
argument_list|,
name|req
operator|->
name|cmd
operator|->
name|flags
argument_list|,
operator|(
name|req
operator|->
name|cmd
operator|->
name|data
operator|)
condition|?
operator|(
name|u_int
operator|)
name|req
operator|->
name|cmd
operator|->
name|data
operator|->
name|len
else|:
literal|0
argument_list|,
operator|(
name|req
operator|->
name|cmd
operator|->
name|data
operator|)
condition|?
name|req
operator|->
name|cmd
operator|->
name|data
operator|->
name|flags
else|:
literal|0
argument_list|)
expr_stmt|;
block|}
name|slot
operator|->
name|req
operator|=
name|req
expr_stmt|;
name|slot
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|sdhci_start
argument_list|(
name|slot
argument_list|)
expr_stmt|;
name|SDHCI_UNLOCK
argument_list|(
name|slot
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sdhci_get_ro
parameter_list|(
name|device_t
name|brdev
parameter_list|,
name|device_t
name|reqdev
parameter_list|)
block|{
name|struct
name|sdhci_slot
modifier|*
name|slot
init|=
name|device_get_ivars
argument_list|(
name|reqdev
argument_list|)
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
name|SDHCI_LOCK
argument_list|(
name|slot
argument_list|)
expr_stmt|;
name|val
operator|=
name|RD4
argument_list|(
name|slot
argument_list|,
name|SDHCI_PRESENT_STATE
argument_list|)
expr_stmt|;
name|SDHCI_UNLOCK
argument_list|(
name|slot
argument_list|)
expr_stmt|;
return|return
operator|(
operator|!
operator|(
name|val
operator|&
name|SDHCI_WRITE_PROTECT
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sdhci_acquire_host
parameter_list|(
name|device_t
name|brdev
parameter_list|,
name|device_t
name|reqdev
parameter_list|)
block|{
name|struct
name|sdhci_slot
modifier|*
name|slot
init|=
name|device_get_ivars
argument_list|(
name|reqdev
argument_list|)
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|SDHCI_LOCK
argument_list|(
name|slot
argument_list|)
expr_stmt|;
while|while
condition|(
name|slot
operator|->
name|bus_busy
condition|)
name|msleep
argument_list|(
name|slot
argument_list|,
operator|&
name|slot
operator|->
name|mtx
argument_list|,
literal|0
argument_list|,
literal|"sdhciah"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|slot
operator|->
name|bus_busy
operator|++
expr_stmt|;
comment|/* Activate led. */
name|WR1
argument_list|(
name|slot
argument_list|,
name|SDHCI_HOST_CONTROL
argument_list|,
name|slot
operator|->
name|hostctrl
operator||=
name|SDHCI_CTRL_LED
argument_list|)
expr_stmt|;
name|SDHCI_UNLOCK
argument_list|(
name|slot
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sdhci_release_host
parameter_list|(
name|device_t
name|brdev
parameter_list|,
name|device_t
name|reqdev
parameter_list|)
block|{
name|struct
name|sdhci_slot
modifier|*
name|slot
init|=
name|device_get_ivars
argument_list|(
name|reqdev
argument_list|)
decl_stmt|;
name|SDHCI_LOCK
argument_list|(
name|slot
argument_list|)
expr_stmt|;
comment|/* Deactivate led. */
name|WR1
argument_list|(
name|slot
argument_list|,
name|SDHCI_HOST_CONTROL
argument_list|,
name|slot
operator|->
name|hostctrl
operator|&=
operator|~
name|SDHCI_CTRL_LED
argument_list|)
expr_stmt|;
name|slot
operator|->
name|bus_busy
operator|--
expr_stmt|;
name|SDHCI_UNLOCK
argument_list|(
name|slot
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|slot
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sdhci_cmd_irq
parameter_list|(
name|struct
name|sdhci_slot
modifier|*
name|slot
parameter_list|,
name|uint32_t
name|intmask
parameter_list|)
block|{
if|if
condition|(
operator|!
name|slot
operator|->
name|curcmd
condition|)
block|{
name|slot_printf
argument_list|(
name|slot
argument_list|,
literal|"Got command interrupt 0x%08x, but "
literal|"there is no active command.\n"
argument_list|,
name|intmask
argument_list|)
expr_stmt|;
name|sdhci_dumpregs
argument_list|(
name|slot
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|intmask
operator|&
name|SDHCI_INT_TIMEOUT
condition|)
name|slot
operator|->
name|curcmd
operator|->
name|error
operator|=
name|MMC_ERR_TIMEOUT
expr_stmt|;
elseif|else
if|if
condition|(
name|intmask
operator|&
name|SDHCI_INT_CRC
condition|)
name|slot
operator|->
name|curcmd
operator|->
name|error
operator|=
name|MMC_ERR_BADCRC
expr_stmt|;
elseif|else
if|if
condition|(
name|intmask
operator|&
operator|(
name|SDHCI_INT_END_BIT
operator||
name|SDHCI_INT_INDEX
operator|)
condition|)
name|slot
operator|->
name|curcmd
operator|->
name|error
operator|=
name|MMC_ERR_FIFO
expr_stmt|;
name|sdhci_finish_command
argument_list|(
name|slot
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sdhci_data_irq
parameter_list|(
name|struct
name|sdhci_slot
modifier|*
name|slot
parameter_list|,
name|uint32_t
name|intmask
parameter_list|)
block|{
if|if
condition|(
operator|!
name|slot
operator|->
name|curcmd
condition|)
block|{
name|slot_printf
argument_list|(
name|slot
argument_list|,
literal|"Got data interrupt 0x%08x, but "
literal|"there is no active command.\n"
argument_list|,
name|intmask
argument_list|)
expr_stmt|;
name|sdhci_dumpregs
argument_list|(
name|slot
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|slot
operator|->
name|curcmd
operator|->
name|data
operator|==
name|NULL
operator|&&
operator|(
name|slot
operator|->
name|curcmd
operator|->
name|flags
operator|&
name|MMC_RSP_BUSY
operator|)
operator|==
literal|0
condition|)
block|{
name|slot_printf
argument_list|(
name|slot
argument_list|,
literal|"Got data interrupt 0x%08x, but "
literal|"there is no active data operation.\n"
argument_list|,
name|intmask
argument_list|)
expr_stmt|;
name|sdhci_dumpregs
argument_list|(
name|slot
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|intmask
operator|&
name|SDHCI_INT_DATA_TIMEOUT
condition|)
name|slot
operator|->
name|curcmd
operator|->
name|error
operator|=
name|MMC_ERR_TIMEOUT
expr_stmt|;
elseif|else
if|if
condition|(
name|intmask
operator|&
operator|(
name|SDHCI_INT_DATA_CRC
operator||
name|SDHCI_INT_DATA_END_BIT
operator|)
condition|)
name|slot
operator|->
name|curcmd
operator|->
name|error
operator|=
name|MMC_ERR_BADCRC
expr_stmt|;
if|if
condition|(
name|slot
operator|->
name|curcmd
operator|->
name|data
operator|==
name|NULL
operator|&&
operator|(
name|intmask
operator|&
operator|(
name|SDHCI_INT_DATA_AVAIL
operator||
name|SDHCI_INT_SPACE_AVAIL
operator||
name|SDHCI_INT_DMA_END
operator|)
operator|)
condition|)
block|{
name|slot_printf
argument_list|(
name|slot
argument_list|,
literal|"Got data interrupt 0x%08x, but "
literal|"there is busy-only command.\n"
argument_list|,
name|intmask
argument_list|)
expr_stmt|;
name|sdhci_dumpregs
argument_list|(
name|slot
argument_list|)
expr_stmt|;
name|slot
operator|->
name|curcmd
operator|->
name|error
operator|=
name|MMC_ERR_INVALID
expr_stmt|;
block|}
if|if
condition|(
name|slot
operator|->
name|curcmd
operator|->
name|error
condition|)
block|{
comment|/* No need to continue after any error. */
name|sdhci_finish_data
argument_list|(
name|slot
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Handle PIO interrupt. */
if|if
condition|(
name|intmask
operator|&
operator|(
name|SDHCI_INT_DATA_AVAIL
operator||
name|SDHCI_INT_SPACE_AVAIL
operator|)
condition|)
name|sdhci_transfer_pio
argument_list|(
name|slot
argument_list|)
expr_stmt|;
comment|/* Handle DMA border. */
if|if
condition|(
name|intmask
operator|&
name|SDHCI_INT_DMA_END
condition|)
block|{
name|struct
name|mmc_data
modifier|*
name|data
init|=
name|slot
operator|->
name|curcmd
operator|->
name|data
decl_stmt|;
name|size_t
name|left
decl_stmt|;
comment|/* Unload DMA buffer... */
name|left
operator|=
name|data
operator|->
name|len
operator|-
name|slot
operator|->
name|offset
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|flags
operator|&
name|MMC_DATA_READ
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|slot
operator|->
name|dmatag
argument_list|,
name|slot
operator|->
name|dmamap
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|data
operator|->
name|data
operator|+
name|slot
operator|->
name|offset
argument_list|,
name|slot
operator|->
name|dmamem
argument_list|,
operator|(
name|left
operator|<
name|DMA_BLOCK_SIZE
operator|)
condition|?
name|left
else|:
name|DMA_BLOCK_SIZE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bus_dmamap_sync
argument_list|(
name|slot
operator|->
name|dmatag
argument_list|,
name|slot
operator|->
name|dmamap
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
block|}
comment|/* ... and reload it again. */
name|slot
operator|->
name|offset
operator|+=
name|DMA_BLOCK_SIZE
expr_stmt|;
name|left
operator|=
name|data
operator|->
name|len
operator|-
name|slot
operator|->
name|offset
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|flags
operator|&
name|MMC_DATA_READ
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|slot
operator|->
name|dmatag
argument_list|,
name|slot
operator|->
name|dmamap
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|memcpy
argument_list|(
name|slot
operator|->
name|dmamem
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|data
operator|->
name|data
operator|+
name|slot
operator|->
name|offset
argument_list|,
operator|(
name|left
operator|<
name|DMA_BLOCK_SIZE
operator|)
condition|?
name|left
else|:
name|DMA_BLOCK_SIZE
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|slot
operator|->
name|dmatag
argument_list|,
name|slot
operator|->
name|dmamap
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
block|}
comment|/* Interrupt aggregation: Mask border interrupt 		 * for the last page. */
if|if
condition|(
name|left
operator|==
name|DMA_BLOCK_SIZE
condition|)
block|{
name|slot
operator|->
name|intmask
operator|&=
operator|~
name|SDHCI_INT_DMA_END
expr_stmt|;
name|WR4
argument_list|(
name|slot
argument_list|,
name|SDHCI_SIGNAL_ENABLE
argument_list|,
name|slot
operator|->
name|intmask
argument_list|)
expr_stmt|;
block|}
comment|/* Restart DMA. */
name|WR4
argument_list|(
name|slot
argument_list|,
name|SDHCI_DMA_ADDRESS
argument_list|,
name|slot
operator|->
name|paddr
argument_list|)
expr_stmt|;
block|}
comment|/* We have got all data. */
if|if
condition|(
name|intmask
operator|&
name|SDHCI_INT_DATA_END
condition|)
name|sdhci_finish_data
argument_list|(
name|slot
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sdhci_acmd_irq
parameter_list|(
name|struct
name|sdhci_slot
modifier|*
name|slot
parameter_list|)
block|{
name|uint16_t
name|err
decl_stmt|;
name|err
operator|=
name|RD4
argument_list|(
name|slot
argument_list|,
name|SDHCI_ACMD12_ERR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|slot
operator|->
name|curcmd
condition|)
block|{
name|slot_printf
argument_list|(
name|slot
argument_list|,
literal|"Got AutoCMD12 error 0x%04x, but "
literal|"there is no active command.\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|sdhci_dumpregs
argument_list|(
name|slot
argument_list|)
expr_stmt|;
return|return;
block|}
name|slot_printf
argument_list|(
name|slot
argument_list|,
literal|"Got AutoCMD12 error 0x%04x\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|sdhci_reset
argument_list|(
name|slot
argument_list|,
name|SDHCI_RESET_CMD
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sdhci_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|sdhci_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|sdhci_softc
operator|*
operator|)
name|arg
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_slots
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|sdhci_slot
modifier|*
name|slot
init|=
operator|&
name|sc
operator|->
name|slots
index|[
name|i
index|]
decl_stmt|;
name|uint32_t
name|intmask
decl_stmt|;
name|SDHCI_LOCK
argument_list|(
name|slot
argument_list|)
expr_stmt|;
comment|/* Read slot interrupt status. */
name|intmask
operator|=
name|RD4
argument_list|(
name|slot
argument_list|,
name|SDHCI_INT_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
name|intmask
operator|==
literal|0
operator|||
name|intmask
operator|==
literal|0xffffffff
condition|)
block|{
name|SDHCI_UNLOCK
argument_list|(
name|slot
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|sdhci_debug
operator|>
literal|2
condition|)
name|slot_printf
argument_list|(
name|slot
argument_list|,
literal|"Interrupt %#x\n"
argument_list|,
name|intmask
argument_list|)
expr_stmt|;
comment|/* Handle card presence interrupts. */
if|if
condition|(
name|intmask
operator|&
operator|(
name|SDHCI_INT_CARD_INSERT
operator||
name|SDHCI_INT_CARD_REMOVE
operator|)
condition|)
block|{
name|WR4
argument_list|(
name|slot
argument_list|,
name|SDHCI_INT_STATUS
argument_list|,
name|intmask
operator|&
operator|(
name|SDHCI_INT_CARD_INSERT
operator||
name|SDHCI_INT_CARD_REMOVE
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|intmask
operator|&
name|SDHCI_INT_CARD_REMOVE
condition|)
block|{
if|if
condition|(
name|bootverbose
operator|||
name|sdhci_debug
condition|)
name|slot_printf
argument_list|(
name|slot
argument_list|,
literal|"Card removed\n"
argument_list|)
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|slot
operator|->
name|card_callout
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|taskqueue_swi_giant
argument_list|,
operator|&
name|slot
operator|->
name|card_task
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|intmask
operator|&
name|SDHCI_INT_CARD_INSERT
condition|)
block|{
if|if
condition|(
name|bootverbose
operator|||
name|sdhci_debug
condition|)
name|slot_printf
argument_list|(
name|slot
argument_list|,
literal|"Card inserted\n"
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|slot
operator|->
name|card_callout
argument_list|,
name|hz
operator|/
literal|2
argument_list|,
name|sdhci_card_delay
argument_list|,
name|slot
argument_list|)
expr_stmt|;
block|}
name|intmask
operator|&=
operator|~
operator|(
name|SDHCI_INT_CARD_INSERT
operator||
name|SDHCI_INT_CARD_REMOVE
operator|)
expr_stmt|;
block|}
comment|/* Handle command interrupts. */
if|if
condition|(
name|intmask
operator|&
name|SDHCI_INT_CMD_MASK
condition|)
block|{
name|WR4
argument_list|(
name|slot
argument_list|,
name|SDHCI_INT_STATUS
argument_list|,
name|intmask
operator|&
name|SDHCI_INT_CMD_MASK
argument_list|)
expr_stmt|;
name|sdhci_cmd_irq
argument_list|(
name|slot
argument_list|,
name|intmask
operator|&
name|SDHCI_INT_CMD_MASK
argument_list|)
expr_stmt|;
block|}
comment|/* Handle data interrupts. */
if|if
condition|(
name|intmask
operator|&
name|SDHCI_INT_DATA_MASK
condition|)
block|{
name|WR4
argument_list|(
name|slot
argument_list|,
name|SDHCI_INT_STATUS
argument_list|,
name|intmask
operator|&
name|SDHCI_INT_DATA_MASK
argument_list|)
expr_stmt|;
name|sdhci_data_irq
argument_list|(
name|slot
argument_list|,
name|intmask
operator|&
name|SDHCI_INT_DATA_MASK
argument_list|)
expr_stmt|;
block|}
comment|/* Handle AutoCMD12 error interrupt. */
if|if
condition|(
name|intmask
operator|&
name|SDHCI_INT_ACMD12ERR
condition|)
block|{
name|WR4
argument_list|(
name|slot
argument_list|,
name|SDHCI_INT_STATUS
argument_list|,
name|SDHCI_INT_ACMD12ERR
argument_list|)
expr_stmt|;
name|sdhci_acmd_irq
argument_list|(
name|slot
argument_list|)
expr_stmt|;
block|}
name|intmask
operator|&=
operator|~
operator|(
name|SDHCI_INT_CMD_MASK
operator||
name|SDHCI_INT_DATA_MASK
operator|)
expr_stmt|;
name|intmask
operator|&=
operator|~
name|SDHCI_INT_ACMD12ERR
expr_stmt|;
name|intmask
operator|&=
operator|~
name|SDHCI_INT_ERROR
expr_stmt|;
comment|/* Handle bus power interrupt. */
if|if
condition|(
name|intmask
operator|&
name|SDHCI_INT_BUS_POWER
condition|)
block|{
name|WR4
argument_list|(
name|slot
argument_list|,
name|SDHCI_INT_STATUS
argument_list|,
name|SDHCI_INT_BUS_POWER
argument_list|)
expr_stmt|;
name|slot_printf
argument_list|(
name|slot
argument_list|,
literal|"Card is consuming too much power!\n"
argument_list|)
expr_stmt|;
name|intmask
operator|&=
operator|~
name|SDHCI_INT_BUS_POWER
expr_stmt|;
block|}
comment|/* The rest is unknown. */
if|if
condition|(
name|intmask
condition|)
block|{
name|WR4
argument_list|(
name|slot
argument_list|,
name|SDHCI_INT_STATUS
argument_list|,
name|intmask
argument_list|)
expr_stmt|;
name|slot_printf
argument_list|(
name|slot
argument_list|,
literal|"Unexpected interrupt 0x%08x.\n"
argument_list|,
name|intmask
argument_list|)
expr_stmt|;
name|sdhci_dumpregs
argument_list|(
name|slot
argument_list|)
expr_stmt|;
block|}
name|SDHCI_UNLOCK
argument_list|(
name|slot
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|sdhci_read_ivar
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|which
parameter_list|,
name|u_char
modifier|*
name|result
parameter_list|)
block|{
name|struct
name|sdhci_slot
modifier|*
name|slot
init|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|which
condition|)
block|{
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
case|case
name|MMCBR_IVAR_BUS_MODE
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|result
operator|=
name|slot
operator|->
name|host
operator|.
name|ios
operator|.
name|bus_mode
expr_stmt|;
break|break;
case|case
name|MMCBR_IVAR_BUS_WIDTH
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|result
operator|=
name|slot
operator|->
name|host
operator|.
name|ios
operator|.
name|bus_width
expr_stmt|;
break|break;
case|case
name|MMCBR_IVAR_CHIP_SELECT
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|result
operator|=
name|slot
operator|->
name|host
operator|.
name|ios
operator|.
name|chip_select
expr_stmt|;
break|break;
case|case
name|MMCBR_IVAR_CLOCK
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|result
operator|=
name|slot
operator|->
name|host
operator|.
name|ios
operator|.
name|clock
expr_stmt|;
break|break;
case|case
name|MMCBR_IVAR_F_MIN
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|result
operator|=
name|slot
operator|->
name|host
operator|.
name|f_min
expr_stmt|;
break|break;
case|case
name|MMCBR_IVAR_F_MAX
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|result
operator|=
name|slot
operator|->
name|host
operator|.
name|f_max
expr_stmt|;
break|break;
case|case
name|MMCBR_IVAR_HOST_OCR
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|result
operator|=
name|slot
operator|->
name|host
operator|.
name|host_ocr
expr_stmt|;
break|break;
case|case
name|MMCBR_IVAR_MODE
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|result
operator|=
name|slot
operator|->
name|host
operator|.
name|mode
expr_stmt|;
break|break;
case|case
name|MMCBR_IVAR_OCR
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|result
operator|=
name|slot
operator|->
name|host
operator|.
name|ocr
expr_stmt|;
break|break;
case|case
name|MMCBR_IVAR_POWER_MODE
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|result
operator|=
name|slot
operator|->
name|host
operator|.
name|ios
operator|.
name|power_mode
expr_stmt|;
break|break;
case|case
name|MMCBR_IVAR_VDD
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|result
operator|=
name|slot
operator|->
name|host
operator|.
name|ios
operator|.
name|vdd
expr_stmt|;
break|break;
case|case
name|MMCBR_IVAR_CAPS
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|result
operator|=
name|slot
operator|->
name|host
operator|.
name|caps
expr_stmt|;
break|break;
case|case
name|MMCBR_IVAR_TIMING
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|result
operator|=
name|slot
operator|->
name|host
operator|.
name|ios
operator|.
name|timing
expr_stmt|;
break|break;
case|case
name|MMCBR_IVAR_MAX_DATA
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|result
operator|=
literal|65535
expr_stmt|;
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sdhci_write_ivar
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|which
parameter_list|,
name|uintptr_t
name|value
parameter_list|)
block|{
name|struct
name|sdhci_slot
modifier|*
name|slot
init|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|which
condition|)
block|{
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
case|case
name|MMCBR_IVAR_BUS_MODE
case|:
name|slot
operator|->
name|host
operator|.
name|ios
operator|.
name|bus_mode
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|MMCBR_IVAR_BUS_WIDTH
case|:
name|slot
operator|->
name|host
operator|.
name|ios
operator|.
name|bus_width
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|MMCBR_IVAR_CHIP_SELECT
case|:
name|slot
operator|->
name|host
operator|.
name|ios
operator|.
name|chip_select
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|MMCBR_IVAR_CLOCK
case|:
if|if
condition|(
name|value
operator|>
literal|0
condition|)
block|{
name|uint32_t
name|clock
init|=
name|slot
operator|->
name|max_clk
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|clock
operator|<=
name|value
condition|)
break|break;
name|clock
operator|>>=
literal|1
expr_stmt|;
block|}
name|slot
operator|->
name|host
operator|.
name|ios
operator|.
name|clock
operator|=
name|clock
expr_stmt|;
block|}
else|else
name|slot
operator|->
name|host
operator|.
name|ios
operator|.
name|clock
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|MMCBR_IVAR_MODE
case|:
name|slot
operator|->
name|host
operator|.
name|mode
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|MMCBR_IVAR_OCR
case|:
name|slot
operator|->
name|host
operator|.
name|ocr
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|MMCBR_IVAR_POWER_MODE
case|:
name|slot
operator|->
name|host
operator|.
name|ios
operator|.
name|power_mode
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|MMCBR_IVAR_VDD
case|:
name|slot
operator|->
name|host
operator|.
name|ios
operator|.
name|vdd
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|MMCBR_IVAR_TIMING
case|:
name|slot
operator|->
name|host
operator|.
name|ios
operator|.
name|timing
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|MMCBR_IVAR_CAPS
case|:
case|case
name|MMCBR_IVAR_HOST_OCR
case|:
case|case
name|MMCBR_IVAR_F_MIN
case|:
case|case
name|MMCBR_IVAR_F_MAX
case|:
case|case
name|MMCBR_IVAR_MAX_DATA
case|:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|sdhci_methods
index|[]
init|=
block|{
comment|/* device_if */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|sdhci_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|sdhci_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|sdhci_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|sdhci_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|sdhci_resume
argument_list|)
block|,
comment|/* Bus interface */
name|DEVMETHOD
argument_list|(
name|bus_read_ivar
argument_list|,
name|sdhci_read_ivar
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_write_ivar
argument_list|,
name|sdhci_write_ivar
argument_list|)
block|,
comment|/* mmcbr_if */
name|DEVMETHOD
argument_list|(
name|mmcbr_update_ios
argument_list|,
name|sdhci_update_ios
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|mmcbr_request
argument_list|,
name|sdhci_request
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|mmcbr_get_ro
argument_list|,
name|sdhci_get_ro
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|mmcbr_acquire_host
argument_list|,
name|sdhci_acquire_host
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|mmcbr_release_host
argument_list|,
name|sdhci_release_host
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|sdhci_driver
init|=
block|{
literal|"sdhci"
block|,
name|sdhci_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|sdhci_softc
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|sdhci_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|sdhci
argument_list|,
name|pci
argument_list|,
name|sdhci_driver
argument_list|,
name|sdhci_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

