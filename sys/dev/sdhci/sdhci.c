begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2008 Alexander Motin<mav@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/callout.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<machine/stdarg.h>
end_include

begin_include
include|#
directive|include
file|<dev/mmc/bridge.h>
end_include

begin_include
include|#
directive|include
file|<dev/mmc/mmcreg.h>
end_include

begin_include
include|#
directive|include
file|<dev/mmc/mmcbrvar.h>
end_include

begin_include
include|#
directive|include
file|"mmcbr_if.h"
end_include

begin_include
include|#
directive|include
file|"sdhci.h"
end_include

begin_include
include|#
directive|include
file|"sdhci_if.h"
end_include

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_hw
argument_list|,
name|OID_AUTO
argument_list|,
name|sdhci
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"sdhci driver"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|sdhci_debug
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.sdhci.debug"
argument_list|,
operator|&
name|sdhci_debug
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_sdhci
argument_list|,
name|OID_AUTO
argument_list|,
name|debug
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|sdhci_debug
argument_list|,
literal|0
argument_list|,
literal|"Debug level"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|u_int
name|sdhci_quirk_clear
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_sdhci
argument_list|,
name|OID_AUTO
argument_list|,
name|quirk_clear
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|sdhci_quirk_clear
argument_list|,
literal|0
argument_list|,
literal|"Mask of quirks to clear"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|u_int
name|sdhci_quirk_set
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_sdhci
argument_list|,
name|OID_AUTO
argument_list|,
name|quirk_set
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|sdhci_quirk_set
argument_list|,
literal|0
argument_list|,
literal|"Mask of quirks to set"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|RD1
parameter_list|(
name|slot
parameter_list|,
name|off
parameter_list|)
value|SDHCI_READ_1((slot)->bus, (slot), (off))
end_define

begin_define
define|#
directive|define
name|RD2
parameter_list|(
name|slot
parameter_list|,
name|off
parameter_list|)
value|SDHCI_READ_2((slot)->bus, (slot), (off))
end_define

begin_define
define|#
directive|define
name|RD4
parameter_list|(
name|slot
parameter_list|,
name|off
parameter_list|)
value|SDHCI_READ_4((slot)->bus, (slot), (off))
end_define

begin_define
define|#
directive|define
name|RD_MULTI_4
parameter_list|(
name|slot
parameter_list|,
name|off
parameter_list|,
name|ptr
parameter_list|,
name|count
parameter_list|)
define|\
value|SDHCI_READ_MULTI_4((slot)->bus, (slot), (off), (ptr), (count))
end_define

begin_define
define|#
directive|define
name|WR1
parameter_list|(
name|slot
parameter_list|,
name|off
parameter_list|,
name|val
parameter_list|)
value|SDHCI_WRITE_1((slot)->bus, (slot), (off), (val))
end_define

begin_define
define|#
directive|define
name|WR2
parameter_list|(
name|slot
parameter_list|,
name|off
parameter_list|,
name|val
parameter_list|)
value|SDHCI_WRITE_2((slot)->bus, (slot), (off), (val))
end_define

begin_define
define|#
directive|define
name|WR4
parameter_list|(
name|slot
parameter_list|,
name|off
parameter_list|,
name|val
parameter_list|)
value|SDHCI_WRITE_4((slot)->bus, (slot), (off), (val))
end_define

begin_define
define|#
directive|define
name|WR_MULTI_4
parameter_list|(
name|slot
parameter_list|,
name|off
parameter_list|,
name|ptr
parameter_list|,
name|count
parameter_list|)
define|\
value|SDHCI_WRITE_MULTI_4((slot)->bus, (slot), (off), (ptr), (count))
end_define

begin_function_decl
specifier|static
name|void
name|sdhci_set_clock
parameter_list|(
name|struct
name|sdhci_slot
modifier|*
name|slot
parameter_list|,
name|uint32_t
name|clock
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sdhci_start
parameter_list|(
name|struct
name|sdhci_slot
modifier|*
name|slot
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sdhci_start_data
parameter_list|(
name|struct
name|sdhci_slot
modifier|*
name|slot
parameter_list|,
name|struct
name|mmc_data
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sdhci_card_poll
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sdhci_card_task
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* helper routines */
end_comment

begin_function_decl
specifier|static
name|void
name|sdhci_dumpregs
parameter_list|(
name|struct
name|sdhci_slot
modifier|*
name|slot
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|slot_printf
parameter_list|(
name|struct
name|sdhci_slot
modifier|*
name|slot
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
function_decl|__printflike
parameter_list|(
function_decl|2
operator|,
function_decl|3
end_function_decl

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_define
define|#
directive|define
name|SDHCI_LOCK
parameter_list|(
name|_slot
parameter_list|)
value|mtx_lock(&(_slot)->mtx)
end_define

begin_define
define|#
directive|define
name|SDHCI_UNLOCK
parameter_list|(
name|_slot
parameter_list|)
value|mtx_unlock(&(_slot)->mtx)
end_define

begin_define
define|#
directive|define
name|SDHCI_LOCK_INIT
parameter_list|(
name|_slot
parameter_list|)
define|\
value|mtx_init(&_slot->mtx, "SD slot mtx", "sdhci", MTX_DEF)
end_define

begin_define
define|#
directive|define
name|SDHCI_LOCK_DESTROY
parameter_list|(
name|_slot
parameter_list|)
value|mtx_destroy(&_slot->mtx);
end_define

begin_define
define|#
directive|define
name|SDHCI_ASSERT_LOCKED
parameter_list|(
name|_slot
parameter_list|)
value|mtx_assert(&_slot->mtx, MA_OWNED);
end_define

begin_define
define|#
directive|define
name|SDHCI_ASSERT_UNLOCKED
parameter_list|(
name|_slot
parameter_list|)
value|mtx_assert(&_slot->mtx, MA_NOTOWNED);
end_define

begin_define
define|#
directive|define
name|SDHCI_DEFAULT_MAX_FREQ
value|50
end_define

begin_define
define|#
directive|define
name|SDHCI_200_MAX_DIVIDER
value|256
end_define

begin_define
define|#
directive|define
name|SDHCI_300_MAX_DIVIDER
value|2046
end_define

begin_define
define|#
directive|define
name|SDHCI_CARD_PRESENT_TICKS
value|(hz / 5)
end_define

begin_define
define|#
directive|define
name|SDHCI_INSERT_DELAY_TICKS
value|(hz / 2)
end_define

begin_comment
comment|/*  * Broadcom BCM577xx Controller Constants  */
end_comment

begin_comment
comment|/* Maximum divider supported by the default clock source. */
end_comment

begin_define
define|#
directive|define
name|BCM577XX_DEFAULT_MAX_DIVIDER
value|256
end_define

begin_comment
comment|/* Alternative clock's base frequency. */
end_comment

begin_define
define|#
directive|define
name|BCM577XX_ALT_CLOCK_BASE
value|63000000
end_define

begin_define
define|#
directive|define
name|BCM577XX_HOST_CONTROL
value|0x198
end_define

begin_define
define|#
directive|define
name|BCM577XX_CTRL_CLKSEL_MASK
value|0xFFFFCFFF
end_define

begin_define
define|#
directive|define
name|BCM577XX_CTRL_CLKSEL_SHIFT
value|12
end_define

begin_define
define|#
directive|define
name|BCM577XX_CTRL_CLKSEL_DEFAULT
value|0x0
end_define

begin_define
define|#
directive|define
name|BCM577XX_CTRL_CLKSEL_64MHZ
value|0x3
end_define

begin_function
specifier|static
name|void
name|sdhci_getaddr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nsegs
parameter_list|,
name|int
name|error
parameter_list|)
block|{
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"getaddr: error %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return;
block|}
operator|*
operator|(
name|bus_addr_t
operator|*
operator|)
name|arg
operator|=
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|slot_printf
parameter_list|(
name|struct
name|sdhci_slot
modifier|*
name|slot
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|retval
operator|=
name|printf
argument_list|(
literal|"%s-slot%d: "
argument_list|,
name|device_get_nameunit
argument_list|(
name|slot
operator|->
name|bus
argument_list|)
argument_list|,
name|slot
operator|->
name|num
argument_list|)
expr_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|retval
operator|+=
name|vprintf
argument_list|(
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sdhci_dumpregs
parameter_list|(
name|struct
name|sdhci_slot
modifier|*
name|slot
parameter_list|)
block|{
name|slot_printf
argument_list|(
name|slot
argument_list|,
literal|"============== REGISTER DUMP ==============\n"
argument_list|)
expr_stmt|;
name|slot_printf
argument_list|(
name|slot
argument_list|,
literal|"Sys addr: 0x%08x | Version:  0x%08x\n"
argument_list|,
name|RD4
argument_list|(
name|slot
argument_list|,
name|SDHCI_DMA_ADDRESS
argument_list|)
argument_list|,
name|RD2
argument_list|(
name|slot
argument_list|,
name|SDHCI_HOST_VERSION
argument_list|)
argument_list|)
expr_stmt|;
name|slot_printf
argument_list|(
name|slot
argument_list|,
literal|"Blk size: 0x%08x | Blk cnt:  0x%08x\n"
argument_list|,
name|RD2
argument_list|(
name|slot
argument_list|,
name|SDHCI_BLOCK_SIZE
argument_list|)
argument_list|,
name|RD2
argument_list|(
name|slot
argument_list|,
name|SDHCI_BLOCK_COUNT
argument_list|)
argument_list|)
expr_stmt|;
name|slot_printf
argument_list|(
name|slot
argument_list|,
literal|"Argument: 0x%08x | Trn mode: 0x%08x\n"
argument_list|,
name|RD4
argument_list|(
name|slot
argument_list|,
name|SDHCI_ARGUMENT
argument_list|)
argument_list|,
name|RD2
argument_list|(
name|slot
argument_list|,
name|SDHCI_TRANSFER_MODE
argument_list|)
argument_list|)
expr_stmt|;
name|slot_printf
argument_list|(
name|slot
argument_list|,
literal|"Present:  0x%08x | Host ctl: 0x%08x\n"
argument_list|,
name|RD4
argument_list|(
name|slot
argument_list|,
name|SDHCI_PRESENT_STATE
argument_list|)
argument_list|,
name|RD1
argument_list|(
name|slot
argument_list|,
name|SDHCI_HOST_CONTROL
argument_list|)
argument_list|)
expr_stmt|;
name|slot_printf
argument_list|(
name|slot
argument_list|,
literal|"Power:    0x%08x | Blk gap:  0x%08x\n"
argument_list|,
name|RD1
argument_list|(
name|slot
argument_list|,
name|SDHCI_POWER_CONTROL
argument_list|)
argument_list|,
name|RD1
argument_list|(
name|slot
argument_list|,
name|SDHCI_BLOCK_GAP_CONTROL
argument_list|)
argument_list|)
expr_stmt|;
name|slot_printf
argument_list|(
name|slot
argument_list|,
literal|"Wake-up:  0x%08x | Clock:    0x%08x\n"
argument_list|,
name|RD1
argument_list|(
name|slot
argument_list|,
name|SDHCI_WAKE_UP_CONTROL
argument_list|)
argument_list|,
name|RD2
argument_list|(
name|slot
argument_list|,
name|SDHCI_CLOCK_CONTROL
argument_list|)
argument_list|)
expr_stmt|;
name|slot_printf
argument_list|(
name|slot
argument_list|,
literal|"Timeout:  0x%08x | Int stat: 0x%08x\n"
argument_list|,
name|RD1
argument_list|(
name|slot
argument_list|,
name|SDHCI_TIMEOUT_CONTROL
argument_list|)
argument_list|,
name|RD4
argument_list|(
name|slot
argument_list|,
name|SDHCI_INT_STATUS
argument_list|)
argument_list|)
expr_stmt|;
name|slot_printf
argument_list|(
name|slot
argument_list|,
literal|"Int enab: 0x%08x | Sig enab: 0x%08x\n"
argument_list|,
name|RD4
argument_list|(
name|slot
argument_list|,
name|SDHCI_INT_ENABLE
argument_list|)
argument_list|,
name|RD4
argument_list|(
name|slot
argument_list|,
name|SDHCI_SIGNAL_ENABLE
argument_list|)
argument_list|)
expr_stmt|;
name|slot_printf
argument_list|(
name|slot
argument_list|,
literal|"AC12 err: 0x%08x | Host ctl2: 0x%08x\n"
argument_list|,
name|RD2
argument_list|(
name|slot
argument_list|,
name|SDHCI_ACMD12_ERR
argument_list|)
argument_list|,
name|RD2
argument_list|(
name|slot
argument_list|,
name|SDHCI_HOST_CONTROL2
argument_list|)
argument_list|)
expr_stmt|;
name|slot_printf
argument_list|(
name|slot
argument_list|,
literal|"Caps:     0x%08x | Caps2:    0x%08x\n"
argument_list|,
name|RD4
argument_list|(
name|slot
argument_list|,
name|SDHCI_CAPABILITIES
argument_list|)
argument_list|,
name|RD4
argument_list|(
name|slot
argument_list|,
name|SDHCI_CAPABILITIES2
argument_list|)
argument_list|)
expr_stmt|;
name|slot_printf
argument_list|(
name|slot
argument_list|,
literal|"Max curr: 0x%08x | ADMA err: 0x%08x\n"
argument_list|,
name|RD4
argument_list|(
name|slot
argument_list|,
name|SDHCI_MAX_CURRENT
argument_list|)
argument_list|,
name|RD1
argument_list|(
name|slot
argument_list|,
name|SDHCI_ADMA_ERR
argument_list|)
argument_list|)
expr_stmt|;
name|slot_printf
argument_list|(
name|slot
argument_list|,
literal|"ADMA addr: 0x%08x | Slot int: 0x%08x\n"
argument_list|,
name|RD4
argument_list|(
name|slot
argument_list|,
name|SDHCI_ADMA_ADDRESS_LO
argument_list|)
argument_list|,
name|RD2
argument_list|(
name|slot
argument_list|,
name|SDHCI_SLOT_INT_STATUS
argument_list|)
argument_list|)
expr_stmt|;
name|slot_printf
argument_list|(
name|slot
argument_list|,
literal|"===========================================\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sdhci_reset
parameter_list|(
name|struct
name|sdhci_slot
modifier|*
name|slot
parameter_list|,
name|uint8_t
name|mask
parameter_list|)
block|{
name|int
name|timeout
decl_stmt|;
name|uint32_t
name|clock
decl_stmt|;
if|if
condition|(
name|slot
operator|->
name|quirks
operator|&
name|SDHCI_QUIRK_NO_CARD_NO_RESET
condition|)
block|{
if|if
condition|(
operator|!
name|SDHCI_GET_CARD_PRESENT
argument_list|(
name|slot
operator|->
name|bus
argument_list|,
name|slot
argument_list|)
condition|)
return|return;
block|}
comment|/* Some controllers need this kick or reset won't work. */
if|if
condition|(
operator|(
name|mask
operator|&
name|SDHCI_RESET_ALL
operator|)
operator|==
literal|0
operator|&&
operator|(
name|slot
operator|->
name|quirks
operator|&
name|SDHCI_QUIRK_CLOCK_BEFORE_RESET
operator|)
condition|)
block|{
comment|/* This is to force an update */
name|clock
operator|=
name|slot
operator|->
name|clock
expr_stmt|;
name|slot
operator|->
name|clock
operator|=
literal|0
expr_stmt|;
name|sdhci_set_clock
argument_list|(
name|slot
argument_list|,
name|clock
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mask
operator|&
name|SDHCI_RESET_ALL
condition|)
block|{
name|slot
operator|->
name|clock
operator|=
literal|0
expr_stmt|;
name|slot
operator|->
name|power
operator|=
literal|0
expr_stmt|;
block|}
name|WR1
argument_list|(
name|slot
argument_list|,
name|SDHCI_SOFTWARE_RESET
argument_list|,
name|mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|slot
operator|->
name|quirks
operator|&
name|SDHCI_QUIRK_WAITFOR_RESET_ASSERTED
condition|)
block|{
comment|/* 		 * Resets on TI OMAPs and AM335x are incompatible with SDHCI 		 * specification.  The reset bit has internal propagation delay, 		 * so a fast read after write returns 0 even if reset process is 		 * in progress.  The workaround is to poll for 1 before polling 		 * for 0.  In the worst case, if we miss seeing it asserted the 		 * time we spent waiting is enough to ensure the reset finishes. 		 */
name|timeout
operator|=
literal|10000
expr_stmt|;
while|while
condition|(
operator|(
name|RD1
argument_list|(
name|slot
argument_list|,
name|SDHCI_SOFTWARE_RESET
argument_list|)
operator|&
name|mask
operator|)
operator|!=
name|mask
condition|)
block|{
if|if
condition|(
name|timeout
operator|<=
literal|0
condition|)
break|break;
name|timeout
operator|--
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Wait max 100 ms */
name|timeout
operator|=
literal|10000
expr_stmt|;
comment|/* Controller clears the bits when it's done */
while|while
condition|(
name|RD1
argument_list|(
name|slot
argument_list|,
name|SDHCI_SOFTWARE_RESET
argument_list|)
operator|&
name|mask
condition|)
block|{
if|if
condition|(
name|timeout
operator|<=
literal|0
condition|)
block|{
name|slot_printf
argument_list|(
name|slot
argument_list|,
literal|"Reset 0x%x never completed.\n"
argument_list|,
name|mask
argument_list|)
expr_stmt|;
name|sdhci_dumpregs
argument_list|(
name|slot
argument_list|)
expr_stmt|;
return|return;
block|}
name|timeout
operator|--
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|sdhci_init
parameter_list|(
name|struct
name|sdhci_slot
modifier|*
name|slot
parameter_list|)
block|{
name|sdhci_reset
argument_list|(
name|slot
argument_list|,
name|SDHCI_RESET_ALL
argument_list|)
expr_stmt|;
comment|/* Enable interrupts. */
name|slot
operator|->
name|intmask
operator|=
name|SDHCI_INT_BUS_POWER
operator||
name|SDHCI_INT_DATA_END_BIT
operator||
name|SDHCI_INT_DATA_CRC
operator||
name|SDHCI_INT_DATA_TIMEOUT
operator||
name|SDHCI_INT_INDEX
operator||
name|SDHCI_INT_END_BIT
operator||
name|SDHCI_INT_CRC
operator||
name|SDHCI_INT_TIMEOUT
operator||
name|SDHCI_INT_DATA_AVAIL
operator||
name|SDHCI_INT_SPACE_AVAIL
operator||
name|SDHCI_INT_DMA_END
operator||
name|SDHCI_INT_DATA_END
operator||
name|SDHCI_INT_RESPONSE
operator||
name|SDHCI_INT_ACMD12ERR
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|slot
operator|->
name|quirks
operator|&
name|SDHCI_QUIRK_POLL_CARD_PRESENT
operator|)
operator|&&
operator|!
operator|(
name|slot
operator|->
name|opt
operator|&
name|SDHCI_NON_REMOVABLE
operator|)
condition|)
block|{
name|slot
operator|->
name|intmask
operator||=
name|SDHCI_INT_CARD_REMOVE
operator||
name|SDHCI_INT_CARD_INSERT
expr_stmt|;
block|}
name|WR4
argument_list|(
name|slot
argument_list|,
name|SDHCI_INT_ENABLE
argument_list|,
name|slot
operator|->
name|intmask
argument_list|)
expr_stmt|;
name|WR4
argument_list|(
name|slot
argument_list|,
name|SDHCI_SIGNAL_ENABLE
argument_list|,
name|slot
operator|->
name|intmask
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sdhci_set_clock
parameter_list|(
name|struct
name|sdhci_slot
modifier|*
name|slot
parameter_list|,
name|uint32_t
name|clock
parameter_list|)
block|{
name|uint32_t
name|clk_base
decl_stmt|;
name|uint32_t
name|clk_sel
decl_stmt|;
name|uint32_t
name|res
decl_stmt|;
name|uint16_t
name|clk
decl_stmt|;
name|uint16_t
name|div
decl_stmt|;
name|int
name|timeout
decl_stmt|;
if|if
condition|(
name|clock
operator|==
name|slot
operator|->
name|clock
condition|)
return|return;
name|slot
operator|->
name|clock
operator|=
name|clock
expr_stmt|;
comment|/* Turn off the clock. */
name|clk
operator|=
name|RD2
argument_list|(
name|slot
argument_list|,
name|SDHCI_CLOCK_CONTROL
argument_list|)
expr_stmt|;
name|WR2
argument_list|(
name|slot
argument_list|,
name|SDHCI_CLOCK_CONTROL
argument_list|,
name|clk
operator|&
operator|~
name|SDHCI_CLOCK_CARD_EN
argument_list|)
expr_stmt|;
comment|/* If no clock requested - leave it so. */
if|if
condition|(
name|clock
operator|==
literal|0
condition|)
return|return;
comment|/* Determine the clock base frequency */
name|clk_base
operator|=
name|slot
operator|->
name|max_clk
expr_stmt|;
if|if
condition|(
name|slot
operator|->
name|quirks
operator|&
name|SDHCI_QUIRK_BCM577XX_400KHZ_CLKSRC
condition|)
block|{
name|clk_sel
operator|=
name|RD2
argument_list|(
name|slot
argument_list|,
name|BCM577XX_HOST_CONTROL
argument_list|)
operator|&
name|BCM577XX_CTRL_CLKSEL_MASK
expr_stmt|;
comment|/* 		 * Select clock source appropriate for the requested frequency. 		 */
if|if
condition|(
operator|(
name|clk_base
operator|/
name|BCM577XX_DEFAULT_MAX_DIVIDER
operator|)
operator|>
name|clock
condition|)
block|{
name|clk_base
operator|=
name|BCM577XX_ALT_CLOCK_BASE
expr_stmt|;
name|clk_sel
operator||=
operator|(
name|BCM577XX_CTRL_CLKSEL_64MHZ
operator|<<
name|BCM577XX_CTRL_CLKSEL_SHIFT
operator|)
expr_stmt|;
block|}
else|else
block|{
name|clk_sel
operator||=
operator|(
name|BCM577XX_CTRL_CLKSEL_DEFAULT
operator|<<
name|BCM577XX_CTRL_CLKSEL_SHIFT
operator|)
expr_stmt|;
block|}
name|WR2
argument_list|(
name|slot
argument_list|,
name|BCM577XX_HOST_CONTROL
argument_list|,
name|clk_sel
argument_list|)
expr_stmt|;
block|}
comment|/* Recalculate timeout clock frequency based on the new sd clock. */
if|if
condition|(
name|slot
operator|->
name|quirks
operator|&
name|SDHCI_QUIRK_DATA_TIMEOUT_USES_SDCLK
condition|)
name|slot
operator|->
name|timeout_clk
operator|=
name|slot
operator|->
name|clock
operator|/
literal|1000
expr_stmt|;
if|if
condition|(
name|slot
operator|->
name|version
operator|<
name|SDHCI_SPEC_300
condition|)
block|{
comment|/* Looking for highest freq<= clock. */
name|res
operator|=
name|clk_base
expr_stmt|;
for|for
control|(
name|div
operator|=
literal|1
init|;
name|div
operator|<
name|SDHCI_200_MAX_DIVIDER
condition|;
name|div
operator|<<=
literal|1
control|)
block|{
if|if
condition|(
name|res
operator|<=
name|clock
condition|)
break|break;
name|res
operator|>>=
literal|1
expr_stmt|;
block|}
comment|/* Divider 1:1 is 0x00, 2:1 is 0x01, 256:1 is 0x80 ... */
name|div
operator|>>=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* Version 3.0 divisors are multiples of two up to 1023 * 2 */
if|if
condition|(
name|clock
operator|>=
name|clk_base
condition|)
name|div
operator|=
literal|0
expr_stmt|;
else|else
block|{
for|for
control|(
name|div
operator|=
literal|2
init|;
name|div
operator|<
name|SDHCI_300_MAX_DIVIDER
condition|;
name|div
operator|+=
literal|2
control|)
block|{
if|if
condition|(
operator|(
name|clk_base
operator|/
name|div
operator|)
operator|<=
name|clock
condition|)
break|break;
block|}
block|}
name|div
operator|>>=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|bootverbose
operator|||
name|sdhci_debug
condition|)
name|slot_printf
argument_list|(
name|slot
argument_list|,
literal|"Divider %d for freq %d (base %d)\n"
argument_list|,
name|div
argument_list|,
name|clock
argument_list|,
name|clk_base
argument_list|)
expr_stmt|;
comment|/* Now we have got divider, set it. */
name|clk
operator|=
operator|(
name|div
operator|&
name|SDHCI_DIVIDER_MASK
operator|)
operator|<<
name|SDHCI_DIVIDER_SHIFT
expr_stmt|;
name|clk
operator||=
operator|(
operator|(
name|div
operator|>>
name|SDHCI_DIVIDER_MASK_LEN
operator|)
operator|&
name|SDHCI_DIVIDER_HI_MASK
operator|)
operator|<<
name|SDHCI_DIVIDER_HI_SHIFT
expr_stmt|;
name|WR2
argument_list|(
name|slot
argument_list|,
name|SDHCI_CLOCK_CONTROL
argument_list|,
name|clk
argument_list|)
expr_stmt|;
comment|/* Enable clock. */
name|clk
operator||=
name|SDHCI_CLOCK_INT_EN
expr_stmt|;
name|WR2
argument_list|(
name|slot
argument_list|,
name|SDHCI_CLOCK_CONTROL
argument_list|,
name|clk
argument_list|)
expr_stmt|;
comment|/* Wait up to 10 ms until it stabilize. */
name|timeout
operator|=
literal|10
expr_stmt|;
while|while
condition|(
operator|!
operator|(
operator|(
name|clk
operator|=
name|RD2
argument_list|(
name|slot
argument_list|,
name|SDHCI_CLOCK_CONTROL
argument_list|)
operator|)
operator|&
name|SDHCI_CLOCK_INT_STABLE
operator|)
condition|)
block|{
if|if
condition|(
name|timeout
operator|==
literal|0
condition|)
block|{
name|slot_printf
argument_list|(
name|slot
argument_list|,
literal|"Internal clock never stabilised.\n"
argument_list|)
expr_stmt|;
name|sdhci_dumpregs
argument_list|(
name|slot
argument_list|)
expr_stmt|;
return|return;
block|}
name|timeout
operator|--
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
comment|/* Pass clock signal to the bus. */
name|clk
operator||=
name|SDHCI_CLOCK_CARD_EN
expr_stmt|;
name|WR2
argument_list|(
name|slot
argument_list|,
name|SDHCI_CLOCK_CONTROL
argument_list|,
name|clk
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sdhci_set_power
parameter_list|(
name|struct
name|sdhci_slot
modifier|*
name|slot
parameter_list|,
name|u_char
name|power
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|uint8_t
name|pwr
decl_stmt|;
if|if
condition|(
name|slot
operator|->
name|power
operator|==
name|power
condition|)
return|return;
name|slot
operator|->
name|power
operator|=
name|power
expr_stmt|;
comment|/* Turn off the power. */
name|pwr
operator|=
literal|0
expr_stmt|;
name|WR1
argument_list|(
name|slot
argument_list|,
name|SDHCI_POWER_CONTROL
argument_list|,
name|pwr
argument_list|)
expr_stmt|;
comment|/* If power down requested - leave it so. */
if|if
condition|(
name|power
operator|==
literal|0
condition|)
return|return;
comment|/* Set voltage. */
switch|switch
condition|(
literal|1
operator|<<
name|power
condition|)
block|{
case|case
name|MMC_OCR_LOW_VOLTAGE
case|:
name|pwr
operator||=
name|SDHCI_POWER_180
expr_stmt|;
break|break;
case|case
name|MMC_OCR_290_300
case|:
case|case
name|MMC_OCR_300_310
case|:
name|pwr
operator||=
name|SDHCI_POWER_300
expr_stmt|;
break|break;
case|case
name|MMC_OCR_320_330
case|:
case|case
name|MMC_OCR_330_340
case|:
name|pwr
operator||=
name|SDHCI_POWER_330
expr_stmt|;
break|break;
block|}
name|WR1
argument_list|(
name|slot
argument_list|,
name|SDHCI_POWER_CONTROL
argument_list|,
name|pwr
argument_list|)
expr_stmt|;
comment|/* 	 * Turn on VDD1 power.  Note that at least some Intel controllers can 	 * fail to enable bus power on the first try after transiting from D3 	 * to D0, so we give them up to 20 ms. 	 */
name|pwr
operator||=
name|SDHCI_POWER_ON
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|20
condition|;
name|i
operator|++
control|)
block|{
name|WR1
argument_list|(
name|slot
argument_list|,
name|SDHCI_POWER_CONTROL
argument_list|,
name|pwr
argument_list|)
expr_stmt|;
if|if
condition|(
name|RD1
argument_list|(
name|slot
argument_list|,
name|SDHCI_POWER_CONTROL
argument_list|)
operator|&
name|SDHCI_POWER_ON
condition|)
break|break;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|RD1
argument_list|(
name|slot
argument_list|,
name|SDHCI_POWER_CONTROL
argument_list|)
operator|&
name|SDHCI_POWER_ON
operator|)
condition|)
name|slot_printf
argument_list|(
name|slot
argument_list|,
literal|"Bus power failed to enable"
argument_list|)
expr_stmt|;
if|if
condition|(
name|slot
operator|->
name|quirks
operator|&
name|SDHCI_QUIRK_INTEL_POWER_UP_RESET
condition|)
block|{
name|WR1
argument_list|(
name|slot
argument_list|,
name|SDHCI_POWER_CONTROL
argument_list|,
name|pwr
operator||
literal|0x10
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|WR1
argument_list|(
name|slot
argument_list|,
name|SDHCI_POWER_CONTROL
argument_list|,
name|pwr
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|300
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|sdhci_read_block_pio
parameter_list|(
name|struct
name|sdhci_slot
modifier|*
name|slot
parameter_list|)
block|{
name|uint32_t
name|data
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
name|size_t
name|left
decl_stmt|;
name|buffer
operator|=
name|slot
operator|->
name|curcmd
operator|->
name|data
operator|->
name|data
expr_stmt|;
name|buffer
operator|+=
name|slot
operator|->
name|offset
expr_stmt|;
comment|/* Transfer one block at a time. */
name|left
operator|=
name|min
argument_list|(
literal|512
argument_list|,
name|slot
operator|->
name|curcmd
operator|->
name|data
operator|->
name|len
operator|-
name|slot
operator|->
name|offset
argument_list|)
expr_stmt|;
name|slot
operator|->
name|offset
operator|+=
name|left
expr_stmt|;
comment|/* If we are too fast, broken controllers return zeroes. */
if|if
condition|(
name|slot
operator|->
name|quirks
operator|&
name|SDHCI_QUIRK_BROKEN_TIMINGS
condition|)
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
comment|/* Handle unaligned and aligned buffer cases. */
if|if
condition|(
operator|(
name|intptr_t
operator|)
name|buffer
operator|&
literal|3
condition|)
block|{
while|while
condition|(
name|left
operator|>
literal|3
condition|)
block|{
name|data
operator|=
name|RD4
argument_list|(
name|slot
argument_list|,
name|SDHCI_BUFFER
argument_list|)
expr_stmt|;
name|buffer
index|[
literal|0
index|]
operator|=
name|data
expr_stmt|;
name|buffer
index|[
literal|1
index|]
operator|=
operator|(
name|data
operator|>>
literal|8
operator|)
expr_stmt|;
name|buffer
index|[
literal|2
index|]
operator|=
operator|(
name|data
operator|>>
literal|16
operator|)
expr_stmt|;
name|buffer
index|[
literal|3
index|]
operator|=
operator|(
name|data
operator|>>
literal|24
operator|)
expr_stmt|;
name|buffer
operator|+=
literal|4
expr_stmt|;
name|left
operator|-=
literal|4
expr_stmt|;
block|}
block|}
else|else
block|{
name|RD_MULTI_4
argument_list|(
name|slot
argument_list|,
name|SDHCI_BUFFER
argument_list|,
operator|(
name|uint32_t
operator|*
operator|)
name|buffer
argument_list|,
name|left
operator|>>
literal|2
argument_list|)
expr_stmt|;
name|left
operator|&=
literal|3
expr_stmt|;
block|}
comment|/* Handle uneven size case. */
if|if
condition|(
name|left
operator|>
literal|0
condition|)
block|{
name|data
operator|=
name|RD4
argument_list|(
name|slot
argument_list|,
name|SDHCI_BUFFER
argument_list|)
expr_stmt|;
while|while
condition|(
name|left
operator|>
literal|0
condition|)
block|{
operator|*
operator|(
name|buffer
operator|++
operator|)
operator|=
name|data
expr_stmt|;
name|data
operator|>>=
literal|8
expr_stmt|;
name|left
operator|--
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|sdhci_write_block_pio
parameter_list|(
name|struct
name|sdhci_slot
modifier|*
name|slot
parameter_list|)
block|{
name|uint32_t
name|data
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
name|size_t
name|left
decl_stmt|;
name|buffer
operator|=
name|slot
operator|->
name|curcmd
operator|->
name|data
operator|->
name|data
expr_stmt|;
name|buffer
operator|+=
name|slot
operator|->
name|offset
expr_stmt|;
comment|/* Transfer one block at a time. */
name|left
operator|=
name|min
argument_list|(
literal|512
argument_list|,
name|slot
operator|->
name|curcmd
operator|->
name|data
operator|->
name|len
operator|-
name|slot
operator|->
name|offset
argument_list|)
expr_stmt|;
name|slot
operator|->
name|offset
operator|+=
name|left
expr_stmt|;
comment|/* Handle unaligned and aligned buffer cases. */
if|if
condition|(
operator|(
name|intptr_t
operator|)
name|buffer
operator|&
literal|3
condition|)
block|{
while|while
condition|(
name|left
operator|>
literal|3
condition|)
block|{
name|data
operator|=
name|buffer
index|[
literal|0
index|]
operator|+
operator|(
name|buffer
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator|+
operator|(
name|buffer
index|[
literal|2
index|]
operator|<<
literal|16
operator|)
operator|+
operator|(
name|buffer
index|[
literal|3
index|]
operator|<<
literal|24
operator|)
expr_stmt|;
name|left
operator|-=
literal|4
expr_stmt|;
name|buffer
operator|+=
literal|4
expr_stmt|;
name|WR4
argument_list|(
name|slot
argument_list|,
name|SDHCI_BUFFER
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|WR_MULTI_4
argument_list|(
name|slot
argument_list|,
name|SDHCI_BUFFER
argument_list|,
operator|(
name|uint32_t
operator|*
operator|)
name|buffer
argument_list|,
name|left
operator|>>
literal|2
argument_list|)
expr_stmt|;
name|left
operator|&=
literal|3
expr_stmt|;
block|}
comment|/* Handle uneven size case. */
if|if
condition|(
name|left
operator|>
literal|0
condition|)
block|{
while|while
condition|(
name|left
operator|>
literal|0
condition|)
block|{
name|data
operator|<<=
literal|8
expr_stmt|;
name|data
operator|+=
operator|*
operator|(
name|buffer
operator|++
operator|)
expr_stmt|;
name|left
operator|--
expr_stmt|;
block|}
name|WR4
argument_list|(
name|slot
argument_list|,
name|SDHCI_BUFFER
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|sdhci_transfer_pio
parameter_list|(
name|struct
name|sdhci_slot
modifier|*
name|slot
parameter_list|)
block|{
comment|/* Read as many blocks as possible. */
if|if
condition|(
name|slot
operator|->
name|curcmd
operator|->
name|data
operator|->
name|flags
operator|&
name|MMC_DATA_READ
condition|)
block|{
while|while
condition|(
name|RD4
argument_list|(
name|slot
argument_list|,
name|SDHCI_PRESENT_STATE
argument_list|)
operator|&
name|SDHCI_DATA_AVAILABLE
condition|)
block|{
name|sdhci_read_block_pio
argument_list|(
name|slot
argument_list|)
expr_stmt|;
if|if
condition|(
name|slot
operator|->
name|offset
operator|>=
name|slot
operator|->
name|curcmd
operator|->
name|data
operator|->
name|len
condition|)
break|break;
block|}
block|}
else|else
block|{
while|while
condition|(
name|RD4
argument_list|(
name|slot
argument_list|,
name|SDHCI_PRESENT_STATE
argument_list|)
operator|&
name|SDHCI_SPACE_AVAILABLE
condition|)
block|{
name|sdhci_write_block_pio
argument_list|(
name|slot
argument_list|)
expr_stmt|;
if|if
condition|(
name|slot
operator|->
name|offset
operator|>=
name|slot
operator|->
name|curcmd
operator|->
name|data
operator|->
name|len
condition|)
break|break;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|sdhci_card_task
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
name|__unused
parameter_list|)
block|{
name|struct
name|sdhci_slot
modifier|*
name|slot
init|=
name|arg
decl_stmt|;
name|device_t
name|d
decl_stmt|;
name|SDHCI_LOCK
argument_list|(
name|slot
argument_list|)
expr_stmt|;
if|if
condition|(
name|SDHCI_GET_CARD_PRESENT
argument_list|(
name|slot
operator|->
name|bus
argument_list|,
name|slot
argument_list|)
condition|)
block|{
if|if
condition|(
name|slot
operator|->
name|dev
operator|==
name|NULL
condition|)
block|{
comment|/* If card is present - attach mmc bus. */
if|if
condition|(
name|bootverbose
operator|||
name|sdhci_debug
condition|)
name|slot_printf
argument_list|(
name|slot
argument_list|,
literal|"Card inserted\n"
argument_list|)
expr_stmt|;
name|slot
operator|->
name|dev
operator|=
name|device_add_child
argument_list|(
name|slot
operator|->
name|bus
argument_list|,
literal|"mmc"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|device_set_ivars
argument_list|(
name|slot
operator|->
name|dev
argument_list|,
name|slot
argument_list|)
expr_stmt|;
name|SDHCI_UNLOCK
argument_list|(
name|slot
argument_list|)
expr_stmt|;
name|device_probe_and_attach
argument_list|(
name|slot
operator|->
name|dev
argument_list|)
expr_stmt|;
block|}
else|else
name|SDHCI_UNLOCK
argument_list|(
name|slot
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|slot
operator|->
name|dev
operator|!=
name|NULL
condition|)
block|{
comment|/* If no card present - detach mmc bus. */
if|if
condition|(
name|bootverbose
operator|||
name|sdhci_debug
condition|)
name|slot_printf
argument_list|(
name|slot
argument_list|,
literal|"Card removed\n"
argument_list|)
expr_stmt|;
name|d
operator|=
name|slot
operator|->
name|dev
expr_stmt|;
name|slot
operator|->
name|dev
operator|=
name|NULL
expr_stmt|;
name|SDHCI_UNLOCK
argument_list|(
name|slot
argument_list|)
expr_stmt|;
name|device_delete_child
argument_list|(
name|slot
operator|->
name|bus
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
else|else
name|SDHCI_UNLOCK
argument_list|(
name|slot
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|sdhci_handle_card_present_locked
parameter_list|(
name|struct
name|sdhci_slot
modifier|*
name|slot
parameter_list|,
name|bool
name|is_present
parameter_list|)
block|{
name|bool
name|was_present
decl_stmt|;
comment|/* 	 * If there was no card and now there is one, schedule the task to 	 * create the child device after a short delay.  The delay is to 	 * debounce the card insert (sometimes the card detect pin stabilizes 	 * before the other pins have made good contact). 	 * 	 * If there was a card present and now it's gone, immediately schedule 	 * the task to delete the child device.  No debouncing -- gone is gone, 	 * because once power is removed, a full card re-init is needed, and 	 * that happens by deleting and recreating the child device. 	 */
name|was_present
operator|=
name|slot
operator|->
name|dev
operator|!=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|was_present
operator|&&
name|is_present
condition|)
block|{
name|taskqueue_enqueue_timeout
argument_list|(
name|taskqueue_swi_giant
argument_list|,
operator|&
name|slot
operator|->
name|card_delayed_task
argument_list|,
operator|-
name|SDHCI_INSERT_DELAY_TICKS
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|was_present
operator|&&
operator|!
name|is_present
condition|)
block|{
name|taskqueue_enqueue
argument_list|(
name|taskqueue_swi_giant
argument_list|,
operator|&
name|slot
operator|->
name|card_task
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|sdhci_handle_card_present
parameter_list|(
name|struct
name|sdhci_slot
modifier|*
name|slot
parameter_list|,
name|bool
name|is_present
parameter_list|)
block|{
name|SDHCI_LOCK
argument_list|(
name|slot
argument_list|)
expr_stmt|;
name|sdhci_handle_card_present_locked
argument_list|(
name|slot
argument_list|,
name|is_present
argument_list|)
expr_stmt|;
name|SDHCI_UNLOCK
argument_list|(
name|slot
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sdhci_card_poll
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|sdhci_slot
modifier|*
name|slot
init|=
name|arg
decl_stmt|;
name|sdhci_handle_card_present
argument_list|(
name|slot
argument_list|,
name|SDHCI_GET_CARD_PRESENT
argument_list|(
name|slot
operator|->
name|bus
argument_list|,
name|slot
argument_list|)
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|slot
operator|->
name|card_poll_callout
argument_list|,
name|SDHCI_CARD_PRESENT_TICKS
argument_list|,
name|sdhci_card_poll
argument_list|,
name|slot
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|sdhci_init_slot
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|sdhci_slot
modifier|*
name|slot
parameter_list|,
name|int
name|num
parameter_list|)
block|{
name|uint32_t
name|caps
decl_stmt|,
name|caps2
decl_stmt|,
name|freq
decl_stmt|,
name|host_caps
decl_stmt|;
name|int
name|err
decl_stmt|;
name|SDHCI_LOCK_INIT
argument_list|(
name|slot
argument_list|)
expr_stmt|;
name|slot
operator|->
name|num
operator|=
name|num
expr_stmt|;
name|slot
operator|->
name|bus
operator|=
name|dev
expr_stmt|;
comment|/* Allocate DMA tag. */
name|err
operator|=
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|dev
argument_list|)
argument_list|,
name|DMA_BLOCK_SIZE
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|DMA_BLOCK_SIZE
argument_list|,
literal|1
argument_list|,
name|DMA_BLOCK_SIZE
argument_list|,
name|BUS_DMA_ALLOCNOW
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|slot
operator|->
name|dmatag
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Can't create DMA tag\n"
argument_list|)
expr_stmt|;
name|SDHCI_LOCK_DESTROY
argument_list|(
name|slot
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
comment|/* Allocate DMA memory. */
name|err
operator|=
name|bus_dmamem_alloc
argument_list|(
name|slot
operator|->
name|dmatag
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|slot
operator|->
name|dmamem
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|slot
operator|->
name|dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Can't alloc DMA memory\n"
argument_list|)
expr_stmt|;
name|SDHCI_LOCK_DESTROY
argument_list|(
name|slot
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
comment|/* Map the memory. */
name|err
operator|=
name|bus_dmamap_load
argument_list|(
name|slot
operator|->
name|dmatag
argument_list|,
name|slot
operator|->
name|dmamap
argument_list|,
operator|(
name|void
operator|*
operator|)
name|slot
operator|->
name|dmamem
argument_list|,
name|DMA_BLOCK_SIZE
argument_list|,
name|sdhci_getaddr
argument_list|,
operator|&
name|slot
operator|->
name|paddr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
operator|||
name|slot
operator|->
name|paddr
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Can't load DMA memory\n"
argument_list|)
expr_stmt|;
name|SDHCI_LOCK_DESTROY
argument_list|(
name|slot
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
else|else
return|return
operator|(
name|EFAULT
operator|)
return|;
block|}
comment|/* Initialize slot. */
name|sdhci_init
argument_list|(
name|slot
argument_list|)
expr_stmt|;
name|slot
operator|->
name|version
operator|=
operator|(
name|RD2
argument_list|(
name|slot
argument_list|,
name|SDHCI_HOST_VERSION
argument_list|)
operator|>>
name|SDHCI_SPEC_VER_SHIFT
operator|)
operator|&
name|SDHCI_SPEC_VER_MASK
expr_stmt|;
if|if
condition|(
name|slot
operator|->
name|quirks
operator|&
name|SDHCI_QUIRK_MISSING_CAPS
condition|)
block|{
name|caps
operator|=
name|slot
operator|->
name|caps
expr_stmt|;
name|caps2
operator|=
name|slot
operator|->
name|caps2
expr_stmt|;
block|}
else|else
block|{
name|caps
operator|=
name|RD4
argument_list|(
name|slot
argument_list|,
name|SDHCI_CAPABILITIES
argument_list|)
expr_stmt|;
if|if
condition|(
name|slot
operator|->
name|version
operator|>=
name|SDHCI_SPEC_300
condition|)
name|caps2
operator|=
name|RD4
argument_list|(
name|slot
argument_list|,
name|SDHCI_CAPABILITIES2
argument_list|)
expr_stmt|;
else|else
name|caps2
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Calculate base clock frequency. */
if|if
condition|(
name|slot
operator|->
name|version
operator|>=
name|SDHCI_SPEC_300
condition|)
name|freq
operator|=
operator|(
name|caps
operator|&
name|SDHCI_CLOCK_V3_BASE_MASK
operator|)
operator|>>
name|SDHCI_CLOCK_BASE_SHIFT
expr_stmt|;
else|else
name|freq
operator|=
operator|(
name|caps
operator|&
name|SDHCI_CLOCK_BASE_MASK
operator|)
operator|>>
name|SDHCI_CLOCK_BASE_SHIFT
expr_stmt|;
if|if
condition|(
name|freq
operator|!=
literal|0
condition|)
name|slot
operator|->
name|max_clk
operator|=
name|freq
operator|*
literal|1000000
expr_stmt|;
comment|/* 	 * If the frequency wasn't in the capabilities and the hardware driver 	 * hasn't already set max_clk we're probably not going to work right 	 * with an assumption, so complain about it. 	 */
if|if
condition|(
name|slot
operator|->
name|max_clk
operator|==
literal|0
condition|)
block|{
name|slot
operator|->
name|max_clk
operator|=
name|SDHCI_DEFAULT_MAX_FREQ
operator|*
literal|1000000
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Hardware doesn't specify base clock "
literal|"frequency, using %dMHz as default.\n"
argument_list|,
name|SDHCI_DEFAULT_MAX_FREQ
argument_list|)
expr_stmt|;
block|}
comment|/* Calculate/set timeout clock frequency. */
if|if
condition|(
name|slot
operator|->
name|quirks
operator|&
name|SDHCI_QUIRK_DATA_TIMEOUT_USES_SDCLK
condition|)
block|{
name|slot
operator|->
name|timeout_clk
operator|=
name|slot
operator|->
name|max_clk
operator|/
literal|1000
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|slot
operator|->
name|quirks
operator|&
name|SDHCI_QUIRK_DATA_TIMEOUT_1MHZ
condition|)
block|{
name|slot
operator|->
name|timeout_clk
operator|=
literal|1000
expr_stmt|;
block|}
else|else
block|{
name|slot
operator|->
name|timeout_clk
operator|=
operator|(
name|caps
operator|&
name|SDHCI_TIMEOUT_CLK_MASK
operator|)
operator|>>
name|SDHCI_TIMEOUT_CLK_SHIFT
expr_stmt|;
if|if
condition|(
name|caps
operator|&
name|SDHCI_TIMEOUT_CLK_UNIT
condition|)
name|slot
operator|->
name|timeout_clk
operator|*=
literal|1000
expr_stmt|;
block|}
comment|/* 	 * If the frequency wasn't in the capabilities and the hardware driver 	 * hasn't already set timeout_clk we'll probably work okay using the 	 * max timeout, but still mention it. 	 */
if|if
condition|(
name|slot
operator|->
name|timeout_clk
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Hardware doesn't specify timeout clock "
literal|"frequency, setting BROKEN_TIMEOUT quirk.\n"
argument_list|)
expr_stmt|;
name|slot
operator|->
name|quirks
operator||=
name|SDHCI_QUIRK_BROKEN_TIMEOUT_VAL
expr_stmt|;
block|}
name|slot
operator|->
name|host
operator|.
name|f_min
operator|=
name|SDHCI_MIN_FREQ
argument_list|(
name|slot
operator|->
name|bus
argument_list|,
name|slot
argument_list|)
expr_stmt|;
name|slot
operator|->
name|host
operator|.
name|f_max
operator|=
name|slot
operator|->
name|max_clk
expr_stmt|;
name|slot
operator|->
name|host
operator|.
name|host_ocr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|caps
operator|&
name|SDHCI_CAN_VDD_330
condition|)
name|slot
operator|->
name|host
operator|.
name|host_ocr
operator||=
name|MMC_OCR_320_330
operator||
name|MMC_OCR_330_340
expr_stmt|;
if|if
condition|(
name|caps
operator|&
name|SDHCI_CAN_VDD_300
condition|)
name|slot
operator|->
name|host
operator|.
name|host_ocr
operator||=
name|MMC_OCR_290_300
operator||
name|MMC_OCR_300_310
expr_stmt|;
if|if
condition|(
name|caps
operator|&
name|SDHCI_CAN_VDD_180
condition|)
name|slot
operator|->
name|host
operator|.
name|host_ocr
operator||=
name|MMC_OCR_LOW_VOLTAGE
expr_stmt|;
if|if
condition|(
name|slot
operator|->
name|host
operator|.
name|host_ocr
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Hardware doesn't report any "
literal|"support voltages.\n"
argument_list|)
expr_stmt|;
block|}
name|host_caps
operator|=
name|MMC_CAP_4_BIT_DATA
expr_stmt|;
if|if
condition|(
name|caps
operator|&
name|SDHCI_CAN_DO_8BITBUS
condition|)
name|host_caps
operator||=
name|MMC_CAP_8_BIT_DATA
expr_stmt|;
if|if
condition|(
name|caps
operator|&
name|SDHCI_CAN_DO_HISPD
condition|)
name|host_caps
operator||=
name|MMC_CAP_HSPEED
expr_stmt|;
if|if
condition|(
name|slot
operator|->
name|quirks
operator|&
name|SDHCI_QUIRK_BOOT_NOACC
condition|)
name|host_caps
operator||=
name|MMC_CAP_BOOT_NOACC
expr_stmt|;
if|if
condition|(
name|slot
operator|->
name|quirks
operator|&
name|SDHCI_QUIRK_WAIT_WHILE_BUSY
condition|)
name|host_caps
operator||=
name|MMC_CAP_WAIT_WHILE_BUSY
expr_stmt|;
if|if
condition|(
name|caps2
operator|&
operator|(
name|SDHCI_CAN_SDR50
operator||
name|SDHCI_CAN_SDR104
operator||
name|SDHCI_CAN_DDR50
operator|)
condition|)
name|host_caps
operator||=
name|MMC_CAP_UHS_SDR12
operator||
name|MMC_CAP_UHS_SDR25
expr_stmt|;
if|if
condition|(
name|caps2
operator|&
name|SDHCI_CAN_SDR104
condition|)
block|{
name|host_caps
operator||=
name|MMC_CAP_UHS_SDR104
operator||
name|MMC_CAP_UHS_SDR50
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|slot
operator|->
name|quirks
operator|&
name|SDHCI_QUIRK_BROKEN_MMC_HS200
operator|)
condition|)
name|host_caps
operator||=
name|MMC_CAP_MMC_HS200
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|caps2
operator|&
name|SDHCI_CAN_SDR50
condition|)
name|host_caps
operator||=
name|MMC_CAP_UHS_SDR50
expr_stmt|;
if|if
condition|(
name|caps2
operator|&
name|SDHCI_CAN_DDR50
operator|&&
operator|!
operator|(
name|slot
operator|->
name|quirks
operator|&
name|SDHCI_QUIRK_BROKEN_UHS_DDR50
operator|)
condition|)
name|host_caps
operator||=
name|MMC_CAP_UHS_DDR50
expr_stmt|;
if|if
condition|(
name|slot
operator|->
name|quirks
operator|&
name|SDHCI_QUIRK_MMC_DDR52
condition|)
name|host_caps
operator||=
name|MMC_CAP_MMC_DDR52
expr_stmt|;
if|if
condition|(
name|slot
operator|->
name|quirks
operator|&
name|SDHCI_QUIRK_CAPS_BIT63_FOR_MMC_HS400
operator|&&
name|caps2
operator|&
name|SDHCI_CAN_MMC_HS400
condition|)
name|host_caps
operator||=
name|MMC_CAP_MMC_HS400
expr_stmt|;
name|host_caps
operator||=
name|MMC_CAP_SIGNALING_330
expr_stmt|;
if|if
condition|(
name|host_caps
operator|&
operator|(
name|MMC_CAP_UHS_SDR12
operator||
name|MMC_CAP_UHS_SDR25
operator||
name|MMC_CAP_UHS_SDR50
operator||
name|MMC_CAP_UHS_SDR104
operator||
name|MMC_CAP_UHS_DDR50
operator||
name|MMC_CAP_MMC_DDR52_180
operator||
name|MMC_CAP_MMC_HS200_180
operator||
name|MMC_CAP_MMC_HS400_180
operator|)
condition|)
name|host_caps
operator||=
name|MMC_CAP_SIGNALING_180
expr_stmt|;
if|if
condition|(
name|caps
operator|&
name|SDHCI_CTRL2_DRIVER_TYPE_A
condition|)
name|host_caps
operator||=
name|MMC_CAP_DRIVER_TYPE_A
expr_stmt|;
if|if
condition|(
name|caps
operator|&
name|SDHCI_CTRL2_DRIVER_TYPE_C
condition|)
name|host_caps
operator||=
name|MMC_CAP_DRIVER_TYPE_C
expr_stmt|;
if|if
condition|(
name|caps
operator|&
name|SDHCI_CTRL2_DRIVER_TYPE_D
condition|)
name|host_caps
operator||=
name|MMC_CAP_DRIVER_TYPE_D
expr_stmt|;
name|slot
operator|->
name|host
operator|.
name|caps
operator|=
name|host_caps
expr_stmt|;
comment|/* Decide if we have usable DMA. */
if|if
condition|(
name|caps
operator|&
name|SDHCI_CAN_DO_DMA
condition|)
name|slot
operator|->
name|opt
operator||=
name|SDHCI_HAVE_DMA
expr_stmt|;
if|if
condition|(
name|slot
operator|->
name|quirks
operator|&
name|SDHCI_QUIRK_BROKEN_DMA
condition|)
name|slot
operator|->
name|opt
operator|&=
operator|~
name|SDHCI_HAVE_DMA
expr_stmt|;
if|if
condition|(
name|slot
operator|->
name|quirks
operator|&
name|SDHCI_QUIRK_FORCE_DMA
condition|)
name|slot
operator|->
name|opt
operator||=
name|SDHCI_HAVE_DMA
expr_stmt|;
if|if
condition|(
name|slot
operator|->
name|quirks
operator|&
name|SDHCI_QUIRK_ALL_SLOTS_NON_REMOVABLE
condition|)
name|slot
operator|->
name|opt
operator||=
name|SDHCI_NON_REMOVABLE
expr_stmt|;
comment|/* 	 * Use platform-provided transfer backend 	 * with PIO as a fallback mechanism 	 */
if|if
condition|(
name|slot
operator|->
name|opt
operator|&
name|SDHCI_PLATFORM_TRANSFER
condition|)
name|slot
operator|->
name|opt
operator|&=
operator|~
name|SDHCI_HAVE_DMA
expr_stmt|;
if|if
condition|(
name|bootverbose
operator|||
name|sdhci_debug
condition|)
block|{
name|slot_printf
argument_list|(
name|slot
argument_list|,
literal|"%uMHz%s %s VDD:%s%s%s VCCQ: 3.3V%s%s DRV: B%s%s%s %s\n"
argument_list|,
name|slot
operator|->
name|max_clk
operator|/
literal|1000000
argument_list|,
operator|(
name|caps
operator|&
name|SDHCI_CAN_DO_HISPD
operator|)
condition|?
literal|" HS"
else|:
literal|""
argument_list|,
operator|(
name|host_caps
operator|&
name|MMC_CAP_8_BIT_DATA
operator|)
condition|?
literal|"8bits"
else|:
operator|(
operator|(
name|host_caps
operator|&
name|MMC_CAP_4_BIT_DATA
operator|)
condition|?
literal|"4bits"
else|:
literal|"1bit"
operator|)
argument_list|,
operator|(
name|caps
operator|&
name|SDHCI_CAN_VDD_330
operator|)
condition|?
literal|" 3.3V"
else|:
literal|""
argument_list|,
operator|(
name|caps
operator|&
name|SDHCI_CAN_VDD_300
operator|)
condition|?
literal|" 3.0V"
else|:
literal|""
argument_list|,
operator|(
name|caps
operator|&
name|SDHCI_CAN_VDD_180
operator|)
condition|?
literal|" 1.8V"
else|:
literal|""
argument_list|,
operator|(
name|host_caps
operator|&
name|MMC_CAP_SIGNALING_180
operator|)
condition|?
literal|" 1.8V"
else|:
literal|""
argument_list|,
operator|(
name|host_caps
operator|&
name|MMC_CAP_SIGNALING_120
operator|)
condition|?
literal|" 1.2V"
else|:
literal|""
argument_list|,
operator|(
name|caps
operator|&
name|SDHCI_CTRL2_DRIVER_TYPE_A
operator|)
condition|?
literal|"A"
else|:
literal|""
argument_list|,
operator|(
name|caps
operator|&
name|SDHCI_CTRL2_DRIVER_TYPE_C
operator|)
condition|?
literal|"C"
else|:
literal|""
argument_list|,
operator|(
name|caps
operator|&
name|SDHCI_CTRL2_DRIVER_TYPE_D
operator|)
condition|?
literal|"D"
else|:
literal|""
argument_list|,
operator|(
name|slot
operator|->
name|opt
operator|&
name|SDHCI_HAVE_DMA
operator|)
condition|?
literal|"DMA"
else|:
literal|"PIO"
argument_list|)
expr_stmt|;
if|if
condition|(
name|host_caps
operator|&
operator|(
name|MMC_CAP_MMC_DDR52
operator||
name|MMC_CAP_MMC_HS200
operator||
name|MMC_CAP_MMC_HS400
operator||
name|MMC_CAP_MMC_ENH_STROBE
operator|)
condition|)
name|slot_printf
argument_list|(
name|slot
argument_list|,
literal|"eMMC:%s%s%s%s\n"
argument_list|,
operator|(
name|host_caps
operator|&
name|MMC_CAP_MMC_DDR52
operator|)
condition|?
literal|" DDR52"
else|:
literal|""
argument_list|,
operator|(
name|host_caps
operator|&
name|MMC_CAP_MMC_HS200
operator|)
condition|?
literal|" HS200"
else|:
literal|""
argument_list|,
operator|(
name|host_caps
operator|&
name|MMC_CAP_MMC_HS400
operator|)
condition|?
literal|" HS400"
else|:
literal|""
argument_list|,
operator|(
operator|(
name|host_caps
operator|&
operator|(
name|MMC_CAP_MMC_HS400
operator||
name|MMC_CAP_MMC_ENH_STROBE
operator|)
operator|)
operator|==
operator|(
name|MMC_CAP_MMC_HS400
operator||
name|MMC_CAP_MMC_ENH_STROBE
operator|)
operator|)
condition|?
literal|" HS400ES"
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|host_caps
operator|&
operator|(
name|MMC_CAP_UHS_SDR12
operator||
name|MMC_CAP_UHS_SDR25
operator||
name|MMC_CAP_UHS_SDR50
operator||
name|MMC_CAP_UHS_SDR104
operator|)
condition|)
name|slot_printf
argument_list|(
name|slot
argument_list|,
literal|"UHS-I:%s%s%s%s%s\n"
argument_list|,
operator|(
name|host_caps
operator|&
name|MMC_CAP_UHS_SDR12
operator|)
condition|?
literal|" SDR12"
else|:
literal|""
argument_list|,
operator|(
name|host_caps
operator|&
name|MMC_CAP_UHS_SDR25
operator|)
condition|?
literal|" SDR25"
else|:
literal|""
argument_list|,
operator|(
name|host_caps
operator|&
name|MMC_CAP_UHS_SDR50
operator|)
condition|?
literal|" SDR50"
else|:
literal|""
argument_list|,
operator|(
name|host_caps
operator|&
name|MMC_CAP_UHS_SDR104
operator|)
condition|?
literal|" SDR104"
else|:
literal|""
argument_list|,
operator|(
name|host_caps
operator|&
name|MMC_CAP_UHS_DDR50
operator|)
condition|?
literal|" DDR50"
else|:
literal|""
argument_list|)
expr_stmt|;
name|sdhci_dumpregs
argument_list|(
name|slot
argument_list|)
expr_stmt|;
block|}
name|slot
operator|->
name|timeout
operator|=
literal|10
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|slot
operator|->
name|bus
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|slot
operator|->
name|bus
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"timeout"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|slot
operator|->
name|timeout
argument_list|,
literal|0
argument_list|,
literal|"Maximum timeout for SDHCI transfers (in secs)"
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|slot
operator|->
name|card_task
argument_list|,
literal|0
argument_list|,
name|sdhci_card_task
argument_list|,
name|slot
argument_list|)
expr_stmt|;
name|TIMEOUT_TASK_INIT
argument_list|(
name|taskqueue_swi_giant
argument_list|,
operator|&
name|slot
operator|->
name|card_delayed_task
argument_list|,
literal|0
argument_list|,
name|sdhci_card_task
argument_list|,
name|slot
argument_list|)
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|slot
operator|->
name|card_poll_callout
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|callout_init_mtx
argument_list|(
operator|&
name|slot
operator|->
name|timeout_callout
argument_list|,
operator|&
name|slot
operator|->
name|mtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|slot
operator|->
name|quirks
operator|&
name|SDHCI_QUIRK_POLL_CARD_PRESENT
operator|)
operator|&&
operator|!
operator|(
name|slot
operator|->
name|opt
operator|&
name|SDHCI_NON_REMOVABLE
operator|)
condition|)
block|{
name|callout_reset
argument_list|(
operator|&
name|slot
operator|->
name|card_poll_callout
argument_list|,
name|SDHCI_CARD_PRESENT_TICKS
argument_list|,
name|sdhci_card_poll
argument_list|,
name|slot
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|sdhci_start_slot
parameter_list|(
name|struct
name|sdhci_slot
modifier|*
name|slot
parameter_list|)
block|{
name|sdhci_card_task
argument_list|(
name|slot
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|sdhci_cleanup_slot
parameter_list|(
name|struct
name|sdhci_slot
modifier|*
name|slot
parameter_list|)
block|{
name|device_t
name|d
decl_stmt|;
name|callout_drain
argument_list|(
operator|&
name|slot
operator|->
name|timeout_callout
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|slot
operator|->
name|card_poll_callout
argument_list|)
expr_stmt|;
name|taskqueue_drain
argument_list|(
name|taskqueue_swi_giant
argument_list|,
operator|&
name|slot
operator|->
name|card_task
argument_list|)
expr_stmt|;
name|taskqueue_drain_timeout
argument_list|(
name|taskqueue_swi_giant
argument_list|,
operator|&
name|slot
operator|->
name|card_delayed_task
argument_list|)
expr_stmt|;
name|SDHCI_LOCK
argument_list|(
name|slot
argument_list|)
expr_stmt|;
name|d
operator|=
name|slot
operator|->
name|dev
expr_stmt|;
name|slot
operator|->
name|dev
operator|=
name|NULL
expr_stmt|;
name|SDHCI_UNLOCK
argument_list|(
name|slot
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|!=
name|NULL
condition|)
name|device_delete_child
argument_list|(
name|slot
operator|->
name|bus
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|SDHCI_LOCK
argument_list|(
name|slot
argument_list|)
expr_stmt|;
name|sdhci_reset
argument_list|(
name|slot
argument_list|,
name|SDHCI_RESET_ALL
argument_list|)
expr_stmt|;
name|SDHCI_UNLOCK
argument_list|(
name|slot
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|slot
operator|->
name|dmatag
argument_list|,
name|slot
operator|->
name|dmamap
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|slot
operator|->
name|dmatag
argument_list|,
name|slot
operator|->
name|dmamem
argument_list|,
name|slot
operator|->
name|dmamap
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|slot
operator|->
name|dmatag
argument_list|)
expr_stmt|;
name|SDHCI_LOCK_DESTROY
argument_list|(
name|slot
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sdhci_generic_suspend
parameter_list|(
name|struct
name|sdhci_slot
modifier|*
name|slot
parameter_list|)
block|{
name|sdhci_reset
argument_list|(
name|slot
argument_list|,
name|SDHCI_RESET_ALL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sdhci_generic_resume
parameter_list|(
name|struct
name|sdhci_slot
modifier|*
name|slot
parameter_list|)
block|{
name|sdhci_init
argument_list|(
name|slot
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|uint32_t
name|sdhci_generic_min_freq
parameter_list|(
name|device_t
name|brdev
name|__unused
parameter_list|,
name|struct
name|sdhci_slot
modifier|*
name|slot
parameter_list|)
block|{
if|if
condition|(
name|slot
operator|->
name|version
operator|>=
name|SDHCI_SPEC_300
condition|)
return|return
operator|(
name|slot
operator|->
name|max_clk
operator|/
name|SDHCI_300_MAX_DIVIDER
operator|)
return|;
else|else
return|return
operator|(
name|slot
operator|->
name|max_clk
operator|/
name|SDHCI_200_MAX_DIVIDER
operator|)
return|;
block|}
end_function

begin_function
name|bool
name|sdhci_generic_get_card_present
parameter_list|(
name|device_t
name|brdev
name|__unused
parameter_list|,
name|struct
name|sdhci_slot
modifier|*
name|slot
parameter_list|)
block|{
if|if
condition|(
name|slot
operator|->
name|opt
operator|&
name|SDHCI_NON_REMOVABLE
condition|)
return|return
name|true
return|;
return|return
operator|(
name|RD4
argument_list|(
name|slot
argument_list|,
name|SDHCI_PRESENT_STATE
argument_list|)
operator|&
name|SDHCI_CARD_PRESENT
operator|)
return|;
block|}
end_function

begin_function
name|void
name|sdhci_generic_set_uhs_timing
parameter_list|(
name|device_t
name|brdev
name|__unused
parameter_list|,
name|struct
name|sdhci_slot
modifier|*
name|slot
parameter_list|)
block|{
name|struct
name|mmc_ios
modifier|*
name|ios
decl_stmt|;
name|uint16_t
name|hostctrl2
decl_stmt|;
if|if
condition|(
name|slot
operator|->
name|version
operator|<
name|SDHCI_SPEC_300
condition|)
return|return;
name|ios
operator|=
operator|&
name|slot
operator|->
name|host
operator|.
name|ios
expr_stmt|;
name|sdhci_set_clock
argument_list|(
name|slot
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|hostctrl2
operator|=
name|RD2
argument_list|(
name|slot
argument_list|,
name|SDHCI_HOST_CONTROL2
argument_list|)
expr_stmt|;
name|hostctrl2
operator|&=
operator|~
name|SDHCI_CTRL2_UHS_MASK
expr_stmt|;
if|if
condition|(
name|ios
operator|->
name|timing
operator|==
name|bus_timing_mmc_hs400
operator|||
name|ios
operator|->
name|timing
operator|==
name|bus_timing_mmc_hs400es
condition|)
name|hostctrl2
operator||=
name|SDHCI_CTRL2_MMC_HS400
expr_stmt|;
elseif|else
if|if
condition|(
name|ios
operator|->
name|clock
operator|>
name|SD_SDR50_MAX
condition|)
name|hostctrl2
operator||=
name|SDHCI_CTRL2_UHS_SDR104
expr_stmt|;
elseif|else
if|if
condition|(
name|ios
operator|->
name|clock
operator|>
name|SD_SDR25_MAX
condition|)
name|hostctrl2
operator||=
name|SDHCI_CTRL2_UHS_SDR50
expr_stmt|;
elseif|else
if|if
condition|(
name|ios
operator|->
name|clock
operator|>
name|SD_SDR12_MAX
condition|)
block|{
if|if
condition|(
name|ios
operator|->
name|timing
operator|==
name|bus_timing_uhs_ddr50
operator|||
name|ios
operator|->
name|timing
operator|==
name|bus_timing_mmc_ddr52
condition|)
name|hostctrl2
operator||=
name|SDHCI_CTRL2_UHS_DDR50
expr_stmt|;
else|else
name|hostctrl2
operator||=
name|SDHCI_CTRL2_UHS_SDR25
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ios
operator|->
name|clock
operator|>
name|SD_MMC_CARD_ID_FREQUENCY
condition|)
name|hostctrl2
operator||=
name|SDHCI_CTRL2_UHS_SDR12
expr_stmt|;
name|WR2
argument_list|(
name|slot
argument_list|,
name|SDHCI_HOST_CONTROL2
argument_list|,
name|hostctrl2
argument_list|)
expr_stmt|;
name|sdhci_set_clock
argument_list|(
name|slot
argument_list|,
name|ios
operator|->
name|clock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|sdhci_generic_update_ios
parameter_list|(
name|device_t
name|brdev
parameter_list|,
name|device_t
name|reqdev
parameter_list|)
block|{
name|struct
name|sdhci_slot
modifier|*
name|slot
init|=
name|device_get_ivars
argument_list|(
name|reqdev
argument_list|)
decl_stmt|;
name|struct
name|mmc_ios
modifier|*
name|ios
init|=
operator|&
name|slot
operator|->
name|host
operator|.
name|ios
decl_stmt|;
name|SDHCI_LOCK
argument_list|(
name|slot
argument_list|)
expr_stmt|;
comment|/* Do full reset on bus power down to clear from any state. */
if|if
condition|(
name|ios
operator|->
name|power_mode
operator|==
name|power_off
condition|)
block|{
name|WR4
argument_list|(
name|slot
argument_list|,
name|SDHCI_SIGNAL_ENABLE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sdhci_init
argument_list|(
name|slot
argument_list|)
expr_stmt|;
block|}
comment|/* Configure the bus. */
name|sdhci_set_clock
argument_list|(
name|slot
argument_list|,
name|ios
operator|->
name|clock
argument_list|)
expr_stmt|;
name|sdhci_set_power
argument_list|(
name|slot
argument_list|,
operator|(
name|ios
operator|->
name|power_mode
operator|==
name|power_off
operator|)
condition|?
literal|0
else|:
name|ios
operator|->
name|vdd
argument_list|)
expr_stmt|;
if|if
condition|(
name|ios
operator|->
name|bus_width
operator|==
name|bus_width_8
condition|)
block|{
name|slot
operator|->
name|hostctrl
operator||=
name|SDHCI_CTRL_8BITBUS
expr_stmt|;
name|slot
operator|->
name|hostctrl
operator|&=
operator|~
name|SDHCI_CTRL_4BITBUS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ios
operator|->
name|bus_width
operator|==
name|bus_width_4
condition|)
block|{
name|slot
operator|->
name|hostctrl
operator|&=
operator|~
name|SDHCI_CTRL_8BITBUS
expr_stmt|;
name|slot
operator|->
name|hostctrl
operator||=
name|SDHCI_CTRL_4BITBUS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ios
operator|->
name|bus_width
operator|==
name|bus_width_1
condition|)
block|{
name|slot
operator|->
name|hostctrl
operator|&=
operator|~
name|SDHCI_CTRL_8BITBUS
expr_stmt|;
name|slot
operator|->
name|hostctrl
operator|&=
operator|~
name|SDHCI_CTRL_4BITBUS
expr_stmt|;
block|}
else|else
block|{
name|panic
argument_list|(
literal|"Invalid bus width: %d"
argument_list|,
name|ios
operator|->
name|bus_width
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ios
operator|->
name|clock
operator|>
name|SD_SDR12_MAX
operator|&&
operator|!
operator|(
name|slot
operator|->
name|quirks
operator|&
name|SDHCI_QUIRK_DONT_SET_HISPD_BIT
operator|)
condition|)
name|slot
operator|->
name|hostctrl
operator||=
name|SDHCI_CTRL_HISPD
expr_stmt|;
else|else
name|slot
operator|->
name|hostctrl
operator|&=
operator|~
name|SDHCI_CTRL_HISPD
expr_stmt|;
name|WR1
argument_list|(
name|slot
argument_list|,
name|SDHCI_HOST_CONTROL
argument_list|,
name|slot
operator|->
name|hostctrl
argument_list|)
expr_stmt|;
name|SDHCI_SET_UHS_TIMING
argument_list|(
name|brdev
argument_list|,
name|slot
argument_list|)
expr_stmt|;
comment|/* Some controllers like reset after bus changes. */
if|if
condition|(
name|slot
operator|->
name|quirks
operator|&
name|SDHCI_QUIRK_RESET_ON_IOS
condition|)
name|sdhci_reset
argument_list|(
name|slot
argument_list|,
name|SDHCI_RESET_CMD
operator||
name|SDHCI_RESET_DATA
argument_list|)
expr_stmt|;
name|SDHCI_UNLOCK
argument_list|(
name|slot
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sdhci_generic_switch_vccq
parameter_list|(
name|device_t
name|brdev
name|__unused
parameter_list|,
name|device_t
name|reqdev
parameter_list|)
block|{
name|struct
name|sdhci_slot
modifier|*
name|slot
init|=
name|device_get_ivars
argument_list|(
name|reqdev
argument_list|)
decl_stmt|;
name|enum
name|mmc_vccq
name|vccq
decl_stmt|;
name|int
name|err
decl_stmt|;
name|uint16_t
name|hostctrl2
decl_stmt|;
if|if
condition|(
name|slot
operator|->
name|version
operator|<
name|SDHCI_SPEC_300
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|err
operator|=
literal|0
expr_stmt|;
name|vccq
operator|=
name|slot
operator|->
name|host
operator|.
name|ios
operator|.
name|vccq
expr_stmt|;
name|SDHCI_LOCK
argument_list|(
name|slot
argument_list|)
expr_stmt|;
name|sdhci_set_clock
argument_list|(
name|slot
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|hostctrl2
operator|=
name|RD2
argument_list|(
name|slot
argument_list|,
name|SDHCI_HOST_CONTROL2
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|vccq
condition|)
block|{
case|case
name|vccq_330
case|:
if|if
condition|(
operator|!
operator|(
name|hostctrl2
operator|&
name|SDHCI_CTRL2_S18_ENABLE
operator|)
condition|)
goto|goto
name|done
goto|;
name|hostctrl2
operator|&=
operator|~
name|SDHCI_CTRL2_S18_ENABLE
expr_stmt|;
name|WR2
argument_list|(
name|slot
argument_list|,
name|SDHCI_HOST_CONTROL2
argument_list|,
name|hostctrl2
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|5000
argument_list|)
expr_stmt|;
name|hostctrl2
operator|=
name|RD2
argument_list|(
name|slot
argument_list|,
name|SDHCI_HOST_CONTROL2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|hostctrl2
operator|&
name|SDHCI_CTRL2_S18_ENABLE
operator|)
condition|)
goto|goto
name|done
goto|;
name|err
operator|=
name|EAGAIN
expr_stmt|;
break|break;
case|case
name|vccq_180
case|:
if|if
condition|(
operator|!
operator|(
name|slot
operator|->
name|host
operator|.
name|caps
operator|&
name|MMC_CAP_SIGNALING_180
operator|)
condition|)
block|{
name|err
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|hostctrl2
operator|&
name|SDHCI_CTRL2_S18_ENABLE
condition|)
goto|goto
name|done
goto|;
name|hostctrl2
operator||=
name|SDHCI_CTRL2_S18_ENABLE
expr_stmt|;
name|WR2
argument_list|(
name|slot
argument_list|,
name|SDHCI_HOST_CONTROL2
argument_list|,
name|hostctrl2
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|5000
argument_list|)
expr_stmt|;
name|hostctrl2
operator|=
name|RD2
argument_list|(
name|slot
argument_list|,
name|SDHCI_HOST_CONTROL2
argument_list|)
expr_stmt|;
if|if
condition|(
name|hostctrl2
operator|&
name|SDHCI_CTRL2_S18_ENABLE
condition|)
goto|goto
name|done
goto|;
name|err
operator|=
name|EAGAIN
expr_stmt|;
break|break;
default|default:
name|slot_printf
argument_list|(
name|slot
argument_list|,
literal|"Attempt to set unsupported signaling voltage\n"
argument_list|)
expr_stmt|;
name|err
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|done
label|:
name|sdhci_set_clock
argument_list|(
name|slot
argument_list|,
name|slot
operator|->
name|host
operator|.
name|ios
operator|.
name|clock
argument_list|)
expr_stmt|;
name|SDHCI_UNLOCK
argument_list|(
name|slot
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sdhci_req_done
parameter_list|(
name|struct
name|sdhci_slot
modifier|*
name|slot
parameter_list|)
block|{
name|struct
name|mmc_request
modifier|*
name|req
decl_stmt|;
if|if
condition|(
name|slot
operator|->
name|req
operator|!=
name|NULL
operator|&&
name|slot
operator|->
name|curcmd
operator|!=
name|NULL
condition|)
block|{
name|callout_stop
argument_list|(
operator|&
name|slot
operator|->
name|timeout_callout
argument_list|)
expr_stmt|;
name|req
operator|=
name|slot
operator|->
name|req
expr_stmt|;
name|slot
operator|->
name|req
operator|=
name|NULL
expr_stmt|;
name|slot
operator|->
name|curcmd
operator|=
name|NULL
expr_stmt|;
name|req
operator|->
name|done
argument_list|(
name|req
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|sdhci_timeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|sdhci_slot
modifier|*
name|slot
init|=
name|arg
decl_stmt|;
if|if
condition|(
name|slot
operator|->
name|curcmd
operator|!=
name|NULL
condition|)
block|{
name|slot_printf
argument_list|(
name|slot
argument_list|,
literal|" Controller timeout\n"
argument_list|)
expr_stmt|;
name|sdhci_dumpregs
argument_list|(
name|slot
argument_list|)
expr_stmt|;
name|sdhci_reset
argument_list|(
name|slot
argument_list|,
name|SDHCI_RESET_CMD
operator||
name|SDHCI_RESET_DATA
argument_list|)
expr_stmt|;
name|slot
operator|->
name|curcmd
operator|->
name|error
operator|=
name|MMC_ERR_TIMEOUT
expr_stmt|;
name|sdhci_req_done
argument_list|(
name|slot
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|slot_printf
argument_list|(
name|slot
argument_list|,
literal|" Spurious timeout - no active command\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|sdhci_set_transfer_mode
parameter_list|(
name|struct
name|sdhci_slot
modifier|*
name|slot
parameter_list|,
name|struct
name|mmc_data
modifier|*
name|data
parameter_list|)
block|{
name|uint16_t
name|mode
decl_stmt|;
if|if
condition|(
name|data
operator|==
name|NULL
condition|)
return|return;
name|mode
operator|=
name|SDHCI_TRNS_BLK_CNT_EN
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|len
operator|>
literal|512
condition|)
name|mode
operator||=
name|SDHCI_TRNS_MULTI
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|flags
operator|&
name|MMC_DATA_READ
condition|)
name|mode
operator||=
name|SDHCI_TRNS_READ
expr_stmt|;
if|if
condition|(
name|slot
operator|->
name|req
operator|->
name|stop
condition|)
name|mode
operator||=
name|SDHCI_TRNS_ACMD12
expr_stmt|;
if|if
condition|(
name|slot
operator|->
name|flags
operator|&
name|SDHCI_USE_DMA
condition|)
name|mode
operator||=
name|SDHCI_TRNS_DMA
expr_stmt|;
name|WR2
argument_list|(
name|slot
argument_list|,
name|SDHCI_TRANSFER_MODE
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sdhci_start_command
parameter_list|(
name|struct
name|sdhci_slot
modifier|*
name|slot
parameter_list|,
name|struct
name|mmc_command
modifier|*
name|cmd
parameter_list|)
block|{
name|int
name|flags
decl_stmt|,
name|timeout
decl_stmt|;
name|uint32_t
name|mask
decl_stmt|;
name|slot
operator|->
name|curcmd
operator|=
name|cmd
expr_stmt|;
name|slot
operator|->
name|cmd_done
operator|=
literal|0
expr_stmt|;
name|cmd
operator|->
name|error
operator|=
name|MMC_ERR_NONE
expr_stmt|;
comment|/* This flags combination is not supported by controller. */
if|if
condition|(
operator|(
name|cmd
operator|->
name|flags
operator|&
name|MMC_RSP_136
operator|)
operator|&&
operator|(
name|cmd
operator|->
name|flags
operator|&
name|MMC_RSP_BUSY
operator|)
condition|)
block|{
name|slot_printf
argument_list|(
name|slot
argument_list|,
literal|"Unsupported response type!\n"
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|error
operator|=
name|MMC_ERR_FAILED
expr_stmt|;
name|sdhci_req_done
argument_list|(
name|slot
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Do not issue command if there is no card, clock or power. 	 * Controller will not detect timeout without clock active. 	 */
if|if
condition|(
operator|!
name|SDHCI_GET_CARD_PRESENT
argument_list|(
name|slot
operator|->
name|bus
argument_list|,
name|slot
argument_list|)
operator|||
name|slot
operator|->
name|power
operator|==
literal|0
operator|||
name|slot
operator|->
name|clock
operator|==
literal|0
condition|)
block|{
name|cmd
operator|->
name|error
operator|=
name|MMC_ERR_FAILED
expr_stmt|;
name|sdhci_req_done
argument_list|(
name|slot
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Always wait for free CMD bus. */
name|mask
operator|=
name|SDHCI_CMD_INHIBIT
expr_stmt|;
comment|/* Wait for free DAT if we have data or busy signal. */
if|if
condition|(
name|cmd
operator|->
name|data
operator|||
operator|(
name|cmd
operator|->
name|flags
operator|&
name|MMC_RSP_BUSY
operator|)
condition|)
name|mask
operator||=
name|SDHCI_DAT_INHIBIT
expr_stmt|;
comment|/* We shouldn't wait for DAT for stop commands. */
if|if
condition|(
name|cmd
operator|==
name|slot
operator|->
name|req
operator|->
name|stop
condition|)
name|mask
operator|&=
operator|~
name|SDHCI_DAT_INHIBIT
expr_stmt|;
comment|/* 	 *  Wait for bus no more then 250 ms.  Typically there will be no wait 	 *  here at all, but when writing a crash dump we may be bypassing the 	 *  host platform's interrupt handler, and in some cases that handler 	 *  may be working around hardware quirks such as not respecting r1b 	 *  busy indications.  In those cases, this wait-loop serves the purpose 	 *  of waiting for the prior command and data transfers to be done, and 	 *  SD cards are allowed to take up to 250ms for write and erase ops. 	 *  (It's usually more like 20-30ms in the real world.) 	 */
name|timeout
operator|=
literal|250
expr_stmt|;
while|while
condition|(
name|mask
operator|&
name|RD4
argument_list|(
name|slot
argument_list|,
name|SDHCI_PRESENT_STATE
argument_list|)
condition|)
block|{
if|if
condition|(
name|timeout
operator|==
literal|0
condition|)
block|{
name|slot_printf
argument_list|(
name|slot
argument_list|,
literal|"Controller never released "
literal|"inhibit bit(s).\n"
argument_list|)
expr_stmt|;
name|sdhci_dumpregs
argument_list|(
name|slot
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|error
operator|=
name|MMC_ERR_FAILED
expr_stmt|;
name|sdhci_req_done
argument_list|(
name|slot
argument_list|)
expr_stmt|;
return|return;
block|}
name|timeout
operator|--
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
comment|/* Prepare command flags. */
if|if
condition|(
operator|!
operator|(
name|cmd
operator|->
name|flags
operator|&
name|MMC_RSP_PRESENT
operator|)
condition|)
name|flags
operator|=
name|SDHCI_CMD_RESP_NONE
expr_stmt|;
elseif|else
if|if
condition|(
name|cmd
operator|->
name|flags
operator|&
name|MMC_RSP_136
condition|)
name|flags
operator|=
name|SDHCI_CMD_RESP_LONG
expr_stmt|;
elseif|else
if|if
condition|(
name|cmd
operator|->
name|flags
operator|&
name|MMC_RSP_BUSY
condition|)
name|flags
operator|=
name|SDHCI_CMD_RESP_SHORT_BUSY
expr_stmt|;
else|else
name|flags
operator|=
name|SDHCI_CMD_RESP_SHORT
expr_stmt|;
if|if
condition|(
name|cmd
operator|->
name|flags
operator|&
name|MMC_RSP_CRC
condition|)
name|flags
operator||=
name|SDHCI_CMD_CRC
expr_stmt|;
if|if
condition|(
name|cmd
operator|->
name|flags
operator|&
name|MMC_RSP_OPCODE
condition|)
name|flags
operator||=
name|SDHCI_CMD_INDEX
expr_stmt|;
if|if
condition|(
name|cmd
operator|->
name|data
condition|)
name|flags
operator||=
name|SDHCI_CMD_DATA
expr_stmt|;
if|if
condition|(
name|cmd
operator|->
name|opcode
operator|==
name|MMC_STOP_TRANSMISSION
condition|)
name|flags
operator||=
name|SDHCI_CMD_TYPE_ABORT
expr_stmt|;
comment|/* Prepare data. */
name|sdhci_start_data
argument_list|(
name|slot
argument_list|,
name|cmd
operator|->
name|data
argument_list|)
expr_stmt|;
comment|/* 	 * Interrupt aggregation: To reduce total number of interrupts 	 * group response interrupt with data interrupt when possible. 	 * If there going to be data interrupt, mask response one. 	 */
if|if
condition|(
name|slot
operator|->
name|data_done
operator|==
literal|0
condition|)
block|{
name|WR4
argument_list|(
name|slot
argument_list|,
name|SDHCI_SIGNAL_ENABLE
argument_list|,
name|slot
operator|->
name|intmask
operator|&=
operator|~
name|SDHCI_INT_RESPONSE
argument_list|)
expr_stmt|;
block|}
comment|/* Set command argument. */
name|WR4
argument_list|(
name|slot
argument_list|,
name|SDHCI_ARGUMENT
argument_list|,
name|cmd
operator|->
name|arg
argument_list|)
expr_stmt|;
comment|/* Set data transfer mode. */
name|sdhci_set_transfer_mode
argument_list|(
name|slot
argument_list|,
name|cmd
operator|->
name|data
argument_list|)
expr_stmt|;
comment|/* Start command. */
name|WR2
argument_list|(
name|slot
argument_list|,
name|SDHCI_COMMAND_FLAGS
argument_list|,
operator|(
name|cmd
operator|->
name|opcode
operator|<<
literal|8
operator|)
operator||
operator|(
name|flags
operator|&
literal|0xff
operator|)
argument_list|)
expr_stmt|;
comment|/* Start timeout callout. */
name|callout_reset
argument_list|(
operator|&
name|slot
operator|->
name|timeout_callout
argument_list|,
name|slot
operator|->
name|timeout
operator|*
name|hz
argument_list|,
name|sdhci_timeout
argument_list|,
name|slot
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sdhci_finish_command
parameter_list|(
name|struct
name|sdhci_slot
modifier|*
name|slot
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
name|uint8_t
name|extra
decl_stmt|;
name|slot
operator|->
name|cmd_done
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Interrupt aggregation: Restore command interrupt. 	 * Main restore point for the case when command interrupt 	 * happened first. 	 */
name|WR4
argument_list|(
name|slot
argument_list|,
name|SDHCI_SIGNAL_ENABLE
argument_list|,
name|slot
operator|->
name|intmask
operator||=
name|SDHCI_INT_RESPONSE
argument_list|)
expr_stmt|;
comment|/* In case of error - reset host and return. */
if|if
condition|(
name|slot
operator|->
name|curcmd
operator|->
name|error
condition|)
block|{
name|sdhci_reset
argument_list|(
name|slot
argument_list|,
name|SDHCI_RESET_CMD
argument_list|)
expr_stmt|;
name|sdhci_reset
argument_list|(
name|slot
argument_list|,
name|SDHCI_RESET_DATA
argument_list|)
expr_stmt|;
name|sdhci_start
argument_list|(
name|slot
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If command has response - fetch it. */
if|if
condition|(
name|slot
operator|->
name|curcmd
operator|->
name|flags
operator|&
name|MMC_RSP_PRESENT
condition|)
block|{
if|if
condition|(
name|slot
operator|->
name|curcmd
operator|->
name|flags
operator|&
name|MMC_RSP_136
condition|)
block|{
comment|/* CRC is stripped so we need one byte shift. */
name|extra
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|val
operator|=
name|RD4
argument_list|(
name|slot
argument_list|,
name|SDHCI_RESPONSE
operator|+
name|i
operator|*
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|slot
operator|->
name|quirks
operator|&
name|SDHCI_QUIRK_DONT_SHIFT_RESPONSE
condition|)
name|slot
operator|->
name|curcmd
operator|->
name|resp
index|[
literal|3
operator|-
name|i
index|]
operator|=
name|val
expr_stmt|;
else|else
block|{
name|slot
operator|->
name|curcmd
operator|->
name|resp
index|[
literal|3
operator|-
name|i
index|]
operator|=
operator|(
name|val
operator|<<
literal|8
operator|)
operator||
name|extra
expr_stmt|;
name|extra
operator|=
name|val
operator|>>
literal|24
expr_stmt|;
block|}
block|}
block|}
else|else
name|slot
operator|->
name|curcmd
operator|->
name|resp
index|[
literal|0
index|]
operator|=
name|RD4
argument_list|(
name|slot
argument_list|,
name|SDHCI_RESPONSE
argument_list|)
expr_stmt|;
block|}
comment|/* If data ready - finish. */
if|if
condition|(
name|slot
operator|->
name|data_done
condition|)
name|sdhci_start
argument_list|(
name|slot
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sdhci_start_data
parameter_list|(
name|struct
name|sdhci_slot
modifier|*
name|slot
parameter_list|,
name|struct
name|mmc_data
modifier|*
name|data
parameter_list|)
block|{
name|uint32_t
name|target_timeout
decl_stmt|,
name|current_timeout
decl_stmt|;
name|uint8_t
name|div
decl_stmt|;
if|if
condition|(
name|data
operator|==
name|NULL
operator|&&
operator|(
name|slot
operator|->
name|curcmd
operator|->
name|flags
operator|&
name|MMC_RSP_BUSY
operator|)
operator|==
literal|0
condition|)
block|{
name|slot
operator|->
name|data_done
operator|=
literal|1
expr_stmt|;
return|return;
block|}
name|slot
operator|->
name|data_done
operator|=
literal|0
expr_stmt|;
comment|/* Calculate and set data timeout.*/
comment|/* XXX: We should have this from mmc layer, now assume 1 sec. */
if|if
condition|(
name|slot
operator|->
name|quirks
operator|&
name|SDHCI_QUIRK_BROKEN_TIMEOUT_VAL
condition|)
block|{
name|div
operator|=
literal|0xE
expr_stmt|;
block|}
else|else
block|{
name|target_timeout
operator|=
literal|1000000
expr_stmt|;
name|div
operator|=
literal|0
expr_stmt|;
name|current_timeout
operator|=
operator|(
literal|1
operator|<<
literal|13
operator|)
operator|*
literal|1000
operator|/
name|slot
operator|->
name|timeout_clk
expr_stmt|;
while|while
condition|(
name|current_timeout
operator|<
name|target_timeout
operator|&&
name|div
operator|<
literal|0xE
condition|)
block|{
operator|++
name|div
expr_stmt|;
name|current_timeout
operator|<<=
literal|1
expr_stmt|;
block|}
comment|/* Compensate for an off-by-one error in the CaFe chip.*/
if|if
condition|(
name|div
operator|<
literal|0xE
operator|&&
operator|(
name|slot
operator|->
name|quirks
operator|&
name|SDHCI_QUIRK_INCR_TIMEOUT_CONTROL
operator|)
condition|)
block|{
operator|++
name|div
expr_stmt|;
block|}
block|}
name|WR1
argument_list|(
name|slot
argument_list|,
name|SDHCI_TIMEOUT_CONTROL
argument_list|,
name|div
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|==
name|NULL
condition|)
return|return;
comment|/* Use DMA if possible. */
if|if
condition|(
operator|(
name|slot
operator|->
name|opt
operator|&
name|SDHCI_HAVE_DMA
operator|)
condition|)
name|slot
operator|->
name|flags
operator||=
name|SDHCI_USE_DMA
expr_stmt|;
comment|/* If data is small, broken DMA may return zeroes instead of data, */
if|if
condition|(
operator|(
name|slot
operator|->
name|quirks
operator|&
name|SDHCI_QUIRK_BROKEN_TIMINGS
operator|)
operator|&&
operator|(
name|data
operator|->
name|len
operator|<=
literal|512
operator|)
condition|)
name|slot
operator|->
name|flags
operator|&=
operator|~
name|SDHCI_USE_DMA
expr_stmt|;
comment|/* Some controllers require even block sizes. */
if|if
condition|(
operator|(
name|slot
operator|->
name|quirks
operator|&
name|SDHCI_QUIRK_32BIT_DMA_SIZE
operator|)
operator|&&
operator|(
operator|(
name|data
operator|->
name|len
operator|)
operator|&
literal|0x3
operator|)
condition|)
name|slot
operator|->
name|flags
operator|&=
operator|~
name|SDHCI_USE_DMA
expr_stmt|;
comment|/* Load DMA buffer. */
if|if
condition|(
name|slot
operator|->
name|flags
operator|&
name|SDHCI_USE_DMA
condition|)
block|{
if|if
condition|(
name|data
operator|->
name|flags
operator|&
name|MMC_DATA_READ
condition|)
name|bus_dmamap_sync
argument_list|(
name|slot
operator|->
name|dmatag
argument_list|,
name|slot
operator|->
name|dmamap
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
else|else
block|{
name|memcpy
argument_list|(
name|slot
operator|->
name|dmamem
argument_list|,
name|data
operator|->
name|data
argument_list|,
operator|(
name|data
operator|->
name|len
operator|<
name|DMA_BLOCK_SIZE
operator|)
condition|?
name|data
operator|->
name|len
else|:
name|DMA_BLOCK_SIZE
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|slot
operator|->
name|dmatag
argument_list|,
name|slot
operator|->
name|dmamap
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
block|}
name|WR4
argument_list|(
name|slot
argument_list|,
name|SDHCI_DMA_ADDRESS
argument_list|,
name|slot
operator|->
name|paddr
argument_list|)
expr_stmt|;
comment|/* Interrupt aggregation: Mask border interrupt 		 * for the last page and unmask else. */
if|if
condition|(
name|data
operator|->
name|len
operator|==
name|DMA_BLOCK_SIZE
condition|)
name|slot
operator|->
name|intmask
operator|&=
operator|~
name|SDHCI_INT_DMA_END
expr_stmt|;
else|else
name|slot
operator|->
name|intmask
operator||=
name|SDHCI_INT_DMA_END
expr_stmt|;
name|WR4
argument_list|(
name|slot
argument_list|,
name|SDHCI_SIGNAL_ENABLE
argument_list|,
name|slot
operator|->
name|intmask
argument_list|)
expr_stmt|;
block|}
comment|/* Current data offset for both PIO and DMA. */
name|slot
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
comment|/* Set block size and request IRQ on 4K border. */
name|WR2
argument_list|(
name|slot
argument_list|,
name|SDHCI_BLOCK_SIZE
argument_list|,
name|SDHCI_MAKE_BLKSZ
argument_list|(
name|DMA_BOUNDARY
argument_list|,
operator|(
name|data
operator|->
name|len
operator|<
literal|512
operator|)
condition|?
name|data
operator|->
name|len
else|:
literal|512
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set block count. */
name|WR2
argument_list|(
name|slot
argument_list|,
name|SDHCI_BLOCK_COUNT
argument_list|,
operator|(
name|data
operator|->
name|len
operator|+
literal|511
operator|)
operator|/
literal|512
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sdhci_finish_data
parameter_list|(
name|struct
name|sdhci_slot
modifier|*
name|slot
parameter_list|)
block|{
name|struct
name|mmc_data
modifier|*
name|data
init|=
name|slot
operator|->
name|curcmd
operator|->
name|data
decl_stmt|;
name|size_t
name|left
decl_stmt|;
comment|/* Interrupt aggregation: Restore command interrupt. 	 * Auxiliary restore point for the case when data interrupt 	 * happened first. */
if|if
condition|(
operator|!
name|slot
operator|->
name|cmd_done
condition|)
block|{
name|WR4
argument_list|(
name|slot
argument_list|,
name|SDHCI_SIGNAL_ENABLE
argument_list|,
name|slot
operator|->
name|intmask
operator||=
name|SDHCI_INT_RESPONSE
argument_list|)
expr_stmt|;
block|}
comment|/* Unload rest of data from DMA buffer. */
if|if
condition|(
operator|!
name|slot
operator|->
name|data_done
operator|&&
operator|(
name|slot
operator|->
name|flags
operator|&
name|SDHCI_USE_DMA
operator|)
condition|)
block|{
if|if
condition|(
name|data
operator|->
name|flags
operator|&
name|MMC_DATA_READ
condition|)
block|{
name|left
operator|=
name|data
operator|->
name|len
operator|-
name|slot
operator|->
name|offset
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|slot
operator|->
name|dmatag
argument_list|,
name|slot
operator|->
name|dmamap
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|data
operator|->
name|data
operator|+
name|slot
operator|->
name|offset
argument_list|,
name|slot
operator|->
name|dmamem
argument_list|,
operator|(
name|left
operator|<
name|DMA_BLOCK_SIZE
operator|)
condition|?
name|left
else|:
name|DMA_BLOCK_SIZE
argument_list|)
expr_stmt|;
block|}
else|else
name|bus_dmamap_sync
argument_list|(
name|slot
operator|->
name|dmatag
argument_list|,
name|slot
operator|->
name|dmamap
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
block|}
name|slot
operator|->
name|data_done
operator|=
literal|1
expr_stmt|;
comment|/* If there was error - reset the host. */
if|if
condition|(
name|slot
operator|->
name|curcmd
operator|->
name|error
condition|)
block|{
name|sdhci_reset
argument_list|(
name|slot
argument_list|,
name|SDHCI_RESET_CMD
argument_list|)
expr_stmt|;
name|sdhci_reset
argument_list|(
name|slot
argument_list|,
name|SDHCI_RESET_DATA
argument_list|)
expr_stmt|;
name|sdhci_start
argument_list|(
name|slot
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If we already have command response - finish. */
if|if
condition|(
name|slot
operator|->
name|cmd_done
condition|)
name|sdhci_start
argument_list|(
name|slot
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sdhci_start
parameter_list|(
name|struct
name|sdhci_slot
modifier|*
name|slot
parameter_list|)
block|{
name|struct
name|mmc_request
modifier|*
name|req
decl_stmt|;
name|req
operator|=
name|slot
operator|->
name|req
expr_stmt|;
if|if
condition|(
name|req
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
operator|!
operator|(
name|slot
operator|->
name|flags
operator|&
name|CMD_STARTED
operator|)
condition|)
block|{
name|slot
operator|->
name|flags
operator||=
name|CMD_STARTED
expr_stmt|;
name|sdhci_start_command
argument_list|(
name|slot
argument_list|,
name|req
operator|->
name|cmd
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	We don't need this until using Auto-CMD12 feature 	if (!(slot->flags& STOP_STARTED)&& req->stop) { 		slot->flags |= STOP_STARTED; 		sdhci_start_command(slot, req->stop); 		return; 	} */
if|if
condition|(
name|sdhci_debug
operator|>
literal|1
condition|)
name|slot_printf
argument_list|(
name|slot
argument_list|,
literal|"result: %d\n"
argument_list|,
name|req
operator|->
name|cmd
operator|->
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|req
operator|->
name|cmd
operator|->
name|error
operator|&&
operator|(
name|slot
operator|->
name|quirks
operator|&
name|SDHCI_QUIRK_RESET_AFTER_REQUEST
operator|)
condition|)
block|{
name|sdhci_reset
argument_list|(
name|slot
argument_list|,
name|SDHCI_RESET_CMD
argument_list|)
expr_stmt|;
name|sdhci_reset
argument_list|(
name|slot
argument_list|,
name|SDHCI_RESET_DATA
argument_list|)
expr_stmt|;
block|}
name|sdhci_req_done
argument_list|(
name|slot
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|sdhci_generic_request
parameter_list|(
name|device_t
name|brdev
name|__unused
parameter_list|,
name|device_t
name|reqdev
parameter_list|,
name|struct
name|mmc_request
modifier|*
name|req
parameter_list|)
block|{
name|struct
name|sdhci_slot
modifier|*
name|slot
init|=
name|device_get_ivars
argument_list|(
name|reqdev
argument_list|)
decl_stmt|;
name|SDHCI_LOCK
argument_list|(
name|slot
argument_list|)
expr_stmt|;
if|if
condition|(
name|slot
operator|->
name|req
operator|!=
name|NULL
condition|)
block|{
name|SDHCI_UNLOCK
argument_list|(
name|slot
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
if|if
condition|(
name|sdhci_debug
operator|>
literal|1
condition|)
block|{
name|slot_printf
argument_list|(
name|slot
argument_list|,
literal|"CMD%u arg %#x flags %#x dlen %u dflags %#x\n"
argument_list|,
name|req
operator|->
name|cmd
operator|->
name|opcode
argument_list|,
name|req
operator|->
name|cmd
operator|->
name|arg
argument_list|,
name|req
operator|->
name|cmd
operator|->
name|flags
argument_list|,
operator|(
name|req
operator|->
name|cmd
operator|->
name|data
operator|)
condition|?
operator|(
name|u_int
operator|)
name|req
operator|->
name|cmd
operator|->
name|data
operator|->
name|len
else|:
literal|0
argument_list|,
operator|(
name|req
operator|->
name|cmd
operator|->
name|data
operator|)
condition|?
name|req
operator|->
name|cmd
operator|->
name|data
operator|->
name|flags
else|:
literal|0
argument_list|)
expr_stmt|;
block|}
name|slot
operator|->
name|req
operator|=
name|req
expr_stmt|;
name|slot
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|sdhci_start
argument_list|(
name|slot
argument_list|)
expr_stmt|;
name|SDHCI_UNLOCK
argument_list|(
name|slot
argument_list|)
expr_stmt|;
if|if
condition|(
name|dumping
condition|)
block|{
while|while
condition|(
name|slot
operator|->
name|req
operator|!=
name|NULL
condition|)
block|{
name|sdhci_generic_intr
argument_list|(
name|slot
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sdhci_generic_get_ro
parameter_list|(
name|device_t
name|brdev
name|__unused
parameter_list|,
name|device_t
name|reqdev
parameter_list|)
block|{
name|struct
name|sdhci_slot
modifier|*
name|slot
init|=
name|device_get_ivars
argument_list|(
name|reqdev
argument_list|)
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
name|SDHCI_LOCK
argument_list|(
name|slot
argument_list|)
expr_stmt|;
name|val
operator|=
name|RD4
argument_list|(
name|slot
argument_list|,
name|SDHCI_PRESENT_STATE
argument_list|)
expr_stmt|;
name|SDHCI_UNLOCK
argument_list|(
name|slot
argument_list|)
expr_stmt|;
return|return
operator|(
operator|!
operator|(
name|val
operator|&
name|SDHCI_WRITE_PROTECT
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sdhci_generic_acquire_host
parameter_list|(
name|device_t
name|brdev
name|__unused
parameter_list|,
name|device_t
name|reqdev
parameter_list|)
block|{
name|struct
name|sdhci_slot
modifier|*
name|slot
init|=
name|device_get_ivars
argument_list|(
name|reqdev
argument_list|)
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|SDHCI_LOCK
argument_list|(
name|slot
argument_list|)
expr_stmt|;
while|while
condition|(
name|slot
operator|->
name|bus_busy
condition|)
name|msleep
argument_list|(
name|slot
argument_list|,
operator|&
name|slot
operator|->
name|mtx
argument_list|,
literal|0
argument_list|,
literal|"sdhciah"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|slot
operator|->
name|bus_busy
operator|++
expr_stmt|;
comment|/* Activate led. */
name|WR1
argument_list|(
name|slot
argument_list|,
name|SDHCI_HOST_CONTROL
argument_list|,
name|slot
operator|->
name|hostctrl
operator||=
name|SDHCI_CTRL_LED
argument_list|)
expr_stmt|;
name|SDHCI_UNLOCK
argument_list|(
name|slot
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sdhci_generic_release_host
parameter_list|(
name|device_t
name|brdev
name|__unused
parameter_list|,
name|device_t
name|reqdev
parameter_list|)
block|{
name|struct
name|sdhci_slot
modifier|*
name|slot
init|=
name|device_get_ivars
argument_list|(
name|reqdev
argument_list|)
decl_stmt|;
name|SDHCI_LOCK
argument_list|(
name|slot
argument_list|)
expr_stmt|;
comment|/* Deactivate led. */
name|WR1
argument_list|(
name|slot
argument_list|,
name|SDHCI_HOST_CONTROL
argument_list|,
name|slot
operator|->
name|hostctrl
operator|&=
operator|~
name|SDHCI_CTRL_LED
argument_list|)
expr_stmt|;
name|slot
operator|->
name|bus_busy
operator|--
expr_stmt|;
name|SDHCI_UNLOCK
argument_list|(
name|slot
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|slot
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sdhci_cmd_irq
parameter_list|(
name|struct
name|sdhci_slot
modifier|*
name|slot
parameter_list|,
name|uint32_t
name|intmask
parameter_list|)
block|{
if|if
condition|(
operator|!
name|slot
operator|->
name|curcmd
condition|)
block|{
name|slot_printf
argument_list|(
name|slot
argument_list|,
literal|"Got command interrupt 0x%08x, but "
literal|"there is no active command.\n"
argument_list|,
name|intmask
argument_list|)
expr_stmt|;
name|sdhci_dumpregs
argument_list|(
name|slot
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|intmask
operator|&
name|SDHCI_INT_TIMEOUT
condition|)
name|slot
operator|->
name|curcmd
operator|->
name|error
operator|=
name|MMC_ERR_TIMEOUT
expr_stmt|;
elseif|else
if|if
condition|(
name|intmask
operator|&
name|SDHCI_INT_CRC
condition|)
name|slot
operator|->
name|curcmd
operator|->
name|error
operator|=
name|MMC_ERR_BADCRC
expr_stmt|;
elseif|else
if|if
condition|(
name|intmask
operator|&
operator|(
name|SDHCI_INT_END_BIT
operator||
name|SDHCI_INT_INDEX
operator|)
condition|)
name|slot
operator|->
name|curcmd
operator|->
name|error
operator|=
name|MMC_ERR_FIFO
expr_stmt|;
name|sdhci_finish_command
argument_list|(
name|slot
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sdhci_data_irq
parameter_list|(
name|struct
name|sdhci_slot
modifier|*
name|slot
parameter_list|,
name|uint32_t
name|intmask
parameter_list|)
block|{
name|struct
name|mmc_data
modifier|*
name|data
decl_stmt|;
name|size_t
name|left
decl_stmt|;
if|if
condition|(
operator|!
name|slot
operator|->
name|curcmd
condition|)
block|{
name|slot_printf
argument_list|(
name|slot
argument_list|,
literal|"Got data interrupt 0x%08x, but "
literal|"there is no active command.\n"
argument_list|,
name|intmask
argument_list|)
expr_stmt|;
name|sdhci_dumpregs
argument_list|(
name|slot
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|slot
operator|->
name|curcmd
operator|->
name|data
operator|==
name|NULL
operator|&&
operator|(
name|slot
operator|->
name|curcmd
operator|->
name|flags
operator|&
name|MMC_RSP_BUSY
operator|)
operator|==
literal|0
condition|)
block|{
name|slot_printf
argument_list|(
name|slot
argument_list|,
literal|"Got data interrupt 0x%08x, but "
literal|"there is no active data operation.\n"
argument_list|,
name|intmask
argument_list|)
expr_stmt|;
name|sdhci_dumpregs
argument_list|(
name|slot
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|intmask
operator|&
name|SDHCI_INT_DATA_TIMEOUT
condition|)
name|slot
operator|->
name|curcmd
operator|->
name|error
operator|=
name|MMC_ERR_TIMEOUT
expr_stmt|;
elseif|else
if|if
condition|(
name|intmask
operator|&
operator|(
name|SDHCI_INT_DATA_CRC
operator||
name|SDHCI_INT_DATA_END_BIT
operator|)
condition|)
name|slot
operator|->
name|curcmd
operator|->
name|error
operator|=
name|MMC_ERR_BADCRC
expr_stmt|;
if|if
condition|(
name|slot
operator|->
name|curcmd
operator|->
name|data
operator|==
name|NULL
operator|&&
operator|(
name|intmask
operator|&
operator|(
name|SDHCI_INT_DATA_AVAIL
operator||
name|SDHCI_INT_SPACE_AVAIL
operator||
name|SDHCI_INT_DMA_END
operator|)
operator|)
condition|)
block|{
name|slot_printf
argument_list|(
name|slot
argument_list|,
literal|"Got data interrupt 0x%08x, but "
literal|"there is busy-only command.\n"
argument_list|,
name|intmask
argument_list|)
expr_stmt|;
name|sdhci_dumpregs
argument_list|(
name|slot
argument_list|)
expr_stmt|;
name|slot
operator|->
name|curcmd
operator|->
name|error
operator|=
name|MMC_ERR_INVALID
expr_stmt|;
block|}
if|if
condition|(
name|slot
operator|->
name|curcmd
operator|->
name|error
condition|)
block|{
comment|/* No need to continue after any error. */
goto|goto
name|done
goto|;
block|}
comment|/* Handle PIO interrupt. */
if|if
condition|(
name|intmask
operator|&
operator|(
name|SDHCI_INT_DATA_AVAIL
operator||
name|SDHCI_INT_SPACE_AVAIL
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|slot
operator|->
name|opt
operator|&
name|SDHCI_PLATFORM_TRANSFER
operator|)
operator|&&
name|SDHCI_PLATFORM_WILL_HANDLE
argument_list|(
name|slot
operator|->
name|bus
argument_list|,
name|slot
argument_list|)
condition|)
block|{
name|SDHCI_PLATFORM_START_TRANSFER
argument_list|(
name|slot
operator|->
name|bus
argument_list|,
name|slot
argument_list|,
operator|&
name|intmask
argument_list|)
expr_stmt|;
name|slot
operator|->
name|flags
operator||=
name|PLATFORM_DATA_STARTED
expr_stmt|;
block|}
else|else
name|sdhci_transfer_pio
argument_list|(
name|slot
argument_list|)
expr_stmt|;
block|}
comment|/* Handle DMA border. */
if|if
condition|(
name|intmask
operator|&
name|SDHCI_INT_DMA_END
condition|)
block|{
name|data
operator|=
name|slot
operator|->
name|curcmd
operator|->
name|data
expr_stmt|;
comment|/* Unload DMA buffer ... */
name|left
operator|=
name|data
operator|->
name|len
operator|-
name|slot
operator|->
name|offset
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|flags
operator|&
name|MMC_DATA_READ
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|slot
operator|->
name|dmatag
argument_list|,
name|slot
operator|->
name|dmamap
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|data
operator|->
name|data
operator|+
name|slot
operator|->
name|offset
argument_list|,
name|slot
operator|->
name|dmamem
argument_list|,
operator|(
name|left
operator|<
name|DMA_BLOCK_SIZE
operator|)
condition|?
name|left
else|:
name|DMA_BLOCK_SIZE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bus_dmamap_sync
argument_list|(
name|slot
operator|->
name|dmatag
argument_list|,
name|slot
operator|->
name|dmamap
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
block|}
comment|/* ... and reload it again. */
name|slot
operator|->
name|offset
operator|+=
name|DMA_BLOCK_SIZE
expr_stmt|;
name|left
operator|=
name|data
operator|->
name|len
operator|-
name|slot
operator|->
name|offset
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|flags
operator|&
name|MMC_DATA_READ
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|slot
operator|->
name|dmatag
argument_list|,
name|slot
operator|->
name|dmamap
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|memcpy
argument_list|(
name|slot
operator|->
name|dmamem
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|data
operator|->
name|data
operator|+
name|slot
operator|->
name|offset
argument_list|,
operator|(
name|left
operator|<
name|DMA_BLOCK_SIZE
operator|)
condition|?
name|left
else|:
name|DMA_BLOCK_SIZE
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|slot
operator|->
name|dmatag
argument_list|,
name|slot
operator|->
name|dmamap
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
block|}
comment|/* Interrupt aggregation: Mask border interrupt 		 * for the last page. */
if|if
condition|(
name|left
operator|==
name|DMA_BLOCK_SIZE
condition|)
block|{
name|slot
operator|->
name|intmask
operator|&=
operator|~
name|SDHCI_INT_DMA_END
expr_stmt|;
name|WR4
argument_list|(
name|slot
argument_list|,
name|SDHCI_SIGNAL_ENABLE
argument_list|,
name|slot
operator|->
name|intmask
argument_list|)
expr_stmt|;
block|}
comment|/* Restart DMA. */
name|WR4
argument_list|(
name|slot
argument_list|,
name|SDHCI_DMA_ADDRESS
argument_list|,
name|slot
operator|->
name|paddr
argument_list|)
expr_stmt|;
block|}
comment|/* We have got all data. */
if|if
condition|(
name|intmask
operator|&
name|SDHCI_INT_DATA_END
condition|)
block|{
if|if
condition|(
name|slot
operator|->
name|flags
operator|&
name|PLATFORM_DATA_STARTED
condition|)
block|{
name|slot
operator|->
name|flags
operator|&=
operator|~
name|PLATFORM_DATA_STARTED
expr_stmt|;
name|SDHCI_PLATFORM_FINISH_TRANSFER
argument_list|(
name|slot
operator|->
name|bus
argument_list|,
name|slot
argument_list|)
expr_stmt|;
block|}
else|else
name|sdhci_finish_data
argument_list|(
name|slot
argument_list|)
expr_stmt|;
block|}
name|done
label|:
if|if
condition|(
name|slot
operator|->
name|curcmd
operator|!=
name|NULL
operator|&&
name|slot
operator|->
name|curcmd
operator|->
name|error
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|slot
operator|->
name|flags
operator|&
name|PLATFORM_DATA_STARTED
condition|)
block|{
name|slot
operator|->
name|flags
operator|&=
operator|~
name|PLATFORM_DATA_STARTED
expr_stmt|;
name|SDHCI_PLATFORM_FINISH_TRANSFER
argument_list|(
name|slot
operator|->
name|bus
argument_list|,
name|slot
argument_list|)
expr_stmt|;
block|}
else|else
name|sdhci_finish_data
argument_list|(
name|slot
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|sdhci_acmd_irq
parameter_list|(
name|struct
name|sdhci_slot
modifier|*
name|slot
parameter_list|)
block|{
name|uint16_t
name|err
decl_stmt|;
name|err
operator|=
name|RD4
argument_list|(
name|slot
argument_list|,
name|SDHCI_ACMD12_ERR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|slot
operator|->
name|curcmd
condition|)
block|{
name|slot_printf
argument_list|(
name|slot
argument_list|,
literal|"Got AutoCMD12 error 0x%04x, but "
literal|"there is no active command.\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|sdhci_dumpregs
argument_list|(
name|slot
argument_list|)
expr_stmt|;
return|return;
block|}
name|slot_printf
argument_list|(
name|slot
argument_list|,
literal|"Got AutoCMD12 error 0x%04x\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|sdhci_reset
argument_list|(
name|slot
argument_list|,
name|SDHCI_RESET_CMD
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sdhci_generic_intr
parameter_list|(
name|struct
name|sdhci_slot
modifier|*
name|slot
parameter_list|)
block|{
name|uint32_t
name|intmask
decl_stmt|,
name|present
decl_stmt|;
name|SDHCI_LOCK
argument_list|(
name|slot
argument_list|)
expr_stmt|;
comment|/* Read slot interrupt status. */
name|intmask
operator|=
name|RD4
argument_list|(
name|slot
argument_list|,
name|SDHCI_INT_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
name|intmask
operator|==
literal|0
operator|||
name|intmask
operator|==
literal|0xffffffff
condition|)
block|{
name|SDHCI_UNLOCK
argument_list|(
name|slot
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|sdhci_debug
operator|>
literal|2
condition|)
name|slot_printf
argument_list|(
name|slot
argument_list|,
literal|"Interrupt %#x\n"
argument_list|,
name|intmask
argument_list|)
expr_stmt|;
comment|/* Handle card presence interrupts. */
if|if
condition|(
name|intmask
operator|&
operator|(
name|SDHCI_INT_CARD_INSERT
operator||
name|SDHCI_INT_CARD_REMOVE
operator|)
condition|)
block|{
name|present
operator|=
operator|(
name|intmask
operator|&
name|SDHCI_INT_CARD_INSERT
operator|)
operator|!=
literal|0
expr_stmt|;
name|slot
operator|->
name|intmask
operator|&=
operator|~
operator|(
name|SDHCI_INT_CARD_INSERT
operator||
name|SDHCI_INT_CARD_REMOVE
operator|)
expr_stmt|;
name|slot
operator|->
name|intmask
operator||=
name|present
condition|?
name|SDHCI_INT_CARD_REMOVE
else|:
name|SDHCI_INT_CARD_INSERT
expr_stmt|;
name|WR4
argument_list|(
name|slot
argument_list|,
name|SDHCI_INT_ENABLE
argument_list|,
name|slot
operator|->
name|intmask
argument_list|)
expr_stmt|;
name|WR4
argument_list|(
name|slot
argument_list|,
name|SDHCI_SIGNAL_ENABLE
argument_list|,
name|slot
operator|->
name|intmask
argument_list|)
expr_stmt|;
name|WR4
argument_list|(
name|slot
argument_list|,
name|SDHCI_INT_STATUS
argument_list|,
name|intmask
operator|&
operator|(
name|SDHCI_INT_CARD_INSERT
operator||
name|SDHCI_INT_CARD_REMOVE
operator|)
argument_list|)
expr_stmt|;
name|sdhci_handle_card_present_locked
argument_list|(
name|slot
argument_list|,
name|present
argument_list|)
expr_stmt|;
name|intmask
operator|&=
operator|~
operator|(
name|SDHCI_INT_CARD_INSERT
operator||
name|SDHCI_INT_CARD_REMOVE
operator|)
expr_stmt|;
block|}
comment|/* Handle command interrupts. */
if|if
condition|(
name|intmask
operator|&
name|SDHCI_INT_CMD_MASK
condition|)
block|{
name|WR4
argument_list|(
name|slot
argument_list|,
name|SDHCI_INT_STATUS
argument_list|,
name|intmask
operator|&
name|SDHCI_INT_CMD_MASK
argument_list|)
expr_stmt|;
name|sdhci_cmd_irq
argument_list|(
name|slot
argument_list|,
name|intmask
operator|&
name|SDHCI_INT_CMD_MASK
argument_list|)
expr_stmt|;
block|}
comment|/* Handle data interrupts. */
if|if
condition|(
name|intmask
operator|&
name|SDHCI_INT_DATA_MASK
condition|)
block|{
name|WR4
argument_list|(
name|slot
argument_list|,
name|SDHCI_INT_STATUS
argument_list|,
name|intmask
operator|&
name|SDHCI_INT_DATA_MASK
argument_list|)
expr_stmt|;
comment|/* Don't call data_irq in case of errored command. */
if|if
condition|(
operator|(
name|intmask
operator|&
name|SDHCI_INT_CMD_ERROR_MASK
operator|)
operator|==
literal|0
condition|)
name|sdhci_data_irq
argument_list|(
name|slot
argument_list|,
name|intmask
operator|&
name|SDHCI_INT_DATA_MASK
argument_list|)
expr_stmt|;
block|}
comment|/* Handle AutoCMD12 error interrupt. */
if|if
condition|(
name|intmask
operator|&
name|SDHCI_INT_ACMD12ERR
condition|)
block|{
name|WR4
argument_list|(
name|slot
argument_list|,
name|SDHCI_INT_STATUS
argument_list|,
name|SDHCI_INT_ACMD12ERR
argument_list|)
expr_stmt|;
name|sdhci_acmd_irq
argument_list|(
name|slot
argument_list|)
expr_stmt|;
block|}
name|intmask
operator|&=
operator|~
operator|(
name|SDHCI_INT_CMD_MASK
operator||
name|SDHCI_INT_DATA_MASK
operator|)
expr_stmt|;
name|intmask
operator|&=
operator|~
name|SDHCI_INT_ACMD12ERR
expr_stmt|;
name|intmask
operator|&=
operator|~
name|SDHCI_INT_ERROR
expr_stmt|;
comment|/* Handle bus power interrupt. */
if|if
condition|(
name|intmask
operator|&
name|SDHCI_INT_BUS_POWER
condition|)
block|{
name|WR4
argument_list|(
name|slot
argument_list|,
name|SDHCI_INT_STATUS
argument_list|,
name|SDHCI_INT_BUS_POWER
argument_list|)
expr_stmt|;
name|slot_printf
argument_list|(
name|slot
argument_list|,
literal|"Card is consuming too much power!\n"
argument_list|)
expr_stmt|;
name|intmask
operator|&=
operator|~
name|SDHCI_INT_BUS_POWER
expr_stmt|;
block|}
comment|/* The rest is unknown. */
if|if
condition|(
name|intmask
condition|)
block|{
name|WR4
argument_list|(
name|slot
argument_list|,
name|SDHCI_INT_STATUS
argument_list|,
name|intmask
argument_list|)
expr_stmt|;
name|slot_printf
argument_list|(
name|slot
argument_list|,
literal|"Unexpected interrupt 0x%08x.\n"
argument_list|,
name|intmask
argument_list|)
expr_stmt|;
name|sdhci_dumpregs
argument_list|(
name|slot
argument_list|)
expr_stmt|;
block|}
name|SDHCI_UNLOCK
argument_list|(
name|slot
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|sdhci_generic_read_ivar
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|which
parameter_list|,
name|uintptr_t
modifier|*
name|result
parameter_list|)
block|{
name|struct
name|sdhci_slot
modifier|*
name|slot
init|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|which
condition|)
block|{
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
case|case
name|MMCBR_IVAR_BUS_MODE
case|:
operator|*
name|result
operator|=
name|slot
operator|->
name|host
operator|.
name|ios
operator|.
name|bus_mode
expr_stmt|;
break|break;
case|case
name|MMCBR_IVAR_BUS_WIDTH
case|:
operator|*
name|result
operator|=
name|slot
operator|->
name|host
operator|.
name|ios
operator|.
name|bus_width
expr_stmt|;
break|break;
case|case
name|MMCBR_IVAR_CHIP_SELECT
case|:
operator|*
name|result
operator|=
name|slot
operator|->
name|host
operator|.
name|ios
operator|.
name|chip_select
expr_stmt|;
break|break;
case|case
name|MMCBR_IVAR_CLOCK
case|:
operator|*
name|result
operator|=
name|slot
operator|->
name|host
operator|.
name|ios
operator|.
name|clock
expr_stmt|;
break|break;
case|case
name|MMCBR_IVAR_F_MIN
case|:
operator|*
name|result
operator|=
name|slot
operator|->
name|host
operator|.
name|f_min
expr_stmt|;
break|break;
case|case
name|MMCBR_IVAR_F_MAX
case|:
operator|*
name|result
operator|=
name|slot
operator|->
name|host
operator|.
name|f_max
expr_stmt|;
break|break;
case|case
name|MMCBR_IVAR_HOST_OCR
case|:
operator|*
name|result
operator|=
name|slot
operator|->
name|host
operator|.
name|host_ocr
expr_stmt|;
break|break;
case|case
name|MMCBR_IVAR_MODE
case|:
operator|*
name|result
operator|=
name|slot
operator|->
name|host
operator|.
name|mode
expr_stmt|;
break|break;
case|case
name|MMCBR_IVAR_OCR
case|:
operator|*
name|result
operator|=
name|slot
operator|->
name|host
operator|.
name|ocr
expr_stmt|;
break|break;
case|case
name|MMCBR_IVAR_POWER_MODE
case|:
operator|*
name|result
operator|=
name|slot
operator|->
name|host
operator|.
name|ios
operator|.
name|power_mode
expr_stmt|;
break|break;
case|case
name|MMCBR_IVAR_VDD
case|:
operator|*
name|result
operator|=
name|slot
operator|->
name|host
operator|.
name|ios
operator|.
name|vdd
expr_stmt|;
break|break;
case|case
name|MMCBR_IVAR_VCCQ
case|:
operator|*
name|result
operator|=
name|slot
operator|->
name|host
operator|.
name|ios
operator|.
name|vccq
expr_stmt|;
break|break;
case|case
name|MMCBR_IVAR_CAPS
case|:
operator|*
name|result
operator|=
name|slot
operator|->
name|host
operator|.
name|caps
expr_stmt|;
break|break;
case|case
name|MMCBR_IVAR_TIMING
case|:
operator|*
name|result
operator|=
name|slot
operator|->
name|host
operator|.
name|ios
operator|.
name|timing
expr_stmt|;
break|break;
case|case
name|MMCBR_IVAR_MAX_DATA
case|:
operator|*
name|result
operator|=
literal|65535
expr_stmt|;
break|break;
case|case
name|MMCBR_IVAR_MAX_BUSY_TIMEOUT
case|:
comment|/* 		 * Currently, sdhci_start_data() hardcodes 1 s for all CMDs. 		 */
operator|*
name|result
operator|=
literal|1000000
expr_stmt|;
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sdhci_generic_write_ivar
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|which
parameter_list|,
name|uintptr_t
name|value
parameter_list|)
block|{
name|struct
name|sdhci_slot
modifier|*
name|slot
init|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|uint32_t
name|clock
decl_stmt|,
name|max_clock
decl_stmt|;
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|which
condition|)
block|{
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
case|case
name|MMCBR_IVAR_BUS_MODE
case|:
name|slot
operator|->
name|host
operator|.
name|ios
operator|.
name|bus_mode
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|MMCBR_IVAR_BUS_WIDTH
case|:
name|slot
operator|->
name|host
operator|.
name|ios
operator|.
name|bus_width
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|MMCBR_IVAR_CHIP_SELECT
case|:
name|slot
operator|->
name|host
operator|.
name|ios
operator|.
name|chip_select
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|MMCBR_IVAR_CLOCK
case|:
if|if
condition|(
name|value
operator|>
literal|0
condition|)
block|{
name|max_clock
operator|=
name|slot
operator|->
name|max_clk
expr_stmt|;
name|clock
operator|=
name|max_clock
expr_stmt|;
if|if
condition|(
name|slot
operator|->
name|version
operator|<
name|SDHCI_SPEC_300
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SDHCI_200_MAX_DIVIDER
condition|;
name|i
operator|<<=
literal|1
control|)
block|{
if|if
condition|(
name|clock
operator|<=
name|value
condition|)
break|break;
name|clock
operator|>>=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SDHCI_300_MAX_DIVIDER
condition|;
name|i
operator|+=
literal|2
control|)
block|{
if|if
condition|(
name|clock
operator|<=
name|value
condition|)
break|break;
name|clock
operator|=
name|max_clock
operator|/
operator|(
name|i
operator|+
literal|2
operator|)
expr_stmt|;
block|}
block|}
name|slot
operator|->
name|host
operator|.
name|ios
operator|.
name|clock
operator|=
name|clock
expr_stmt|;
block|}
else|else
name|slot
operator|->
name|host
operator|.
name|ios
operator|.
name|clock
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|MMCBR_IVAR_MODE
case|:
name|slot
operator|->
name|host
operator|.
name|mode
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|MMCBR_IVAR_OCR
case|:
name|slot
operator|->
name|host
operator|.
name|ocr
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|MMCBR_IVAR_POWER_MODE
case|:
name|slot
operator|->
name|host
operator|.
name|ios
operator|.
name|power_mode
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|MMCBR_IVAR_VDD
case|:
name|slot
operator|->
name|host
operator|.
name|ios
operator|.
name|vdd
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|MMCBR_IVAR_VCCQ
case|:
name|slot
operator|->
name|host
operator|.
name|ios
operator|.
name|vccq
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|MMCBR_IVAR_TIMING
case|:
name|slot
operator|->
name|host
operator|.
name|ios
operator|.
name|timing
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|MMCBR_IVAR_CAPS
case|:
case|case
name|MMCBR_IVAR_HOST_OCR
case|:
case|case
name|MMCBR_IVAR_F_MIN
case|:
case|case
name|MMCBR_IVAR_F_MAX
case|:
case|case
name|MMCBR_IVAR_MAX_DATA
case|:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|sdhci
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

