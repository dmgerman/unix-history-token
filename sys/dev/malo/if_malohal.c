begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2007 Marvell Semiconductor, Inc.  * Copyright (c) 2007 Sam Leffler, Errno Consulting  * Copyright (c) 2008 Weongyo Jeong<weongyo@freebsd.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer,  *    without modification.  * 2. Redistributions in binary form must reproduce at minimum a disclaimer  *    similar to the "NO WARRANTY" disclaimer below ("Disclaimer") and any  *    redistribution must be conditioned upon including a substantially  *    similar Disclaimer requirement for further binary redistribution.  *  * NO WARRANTY  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF NONINFRINGEMENT, MERCHANTIBILITY  * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL  * THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY,  * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER  * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  * THE POSSIBILITY OF SUCH DAMAGES.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/firmware.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_var.h>
end_include

begin_include
include|#
directive|include
file|<dev/malo/if_malo.h>
end_include

begin_define
define|#
directive|define
name|MALO_WAITOK
value|1
end_define

begin_define
define|#
directive|define
name|MALO_NOWAIT
value|0
end_define

begin_define
define|#
directive|define
name|_CMD_SETUP
parameter_list|(
name|pCmd
parameter_list|,
name|_type
parameter_list|,
name|_cmd
parameter_list|)
value|do {				\ 	pCmd = (_type *)&mh->mh_cmdbuf[0];				\ 	memset(pCmd, 0, sizeof(_type));					\ 	pCmd->cmdhdr.cmd = htole16(_cmd);				\ 	pCmd->cmdhdr.length = htole16(sizeof(_type));			\ } while (0)
end_define

begin_function
specifier|static
name|__inline
name|uint32_t
name|malo_hal_read4
parameter_list|(
name|struct
name|malo_hal
modifier|*
name|mh
parameter_list|,
name|bus_size_t
name|off
parameter_list|)
block|{
return|return
name|bus_space_read_4
argument_list|(
name|mh
operator|->
name|mh_iot
argument_list|,
name|mh
operator|->
name|mh_ioh
argument_list|,
name|off
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|malo_hal_write4
parameter_list|(
name|struct
name|malo_hal
modifier|*
name|mh
parameter_list|,
name|bus_size_t
name|off
parameter_list|,
name|uint32_t
name|val
parameter_list|)
block|{
name|bus_space_write_4
argument_list|(
name|mh
operator|->
name|mh_iot
argument_list|,
name|mh
operator|->
name|mh_ioh
argument_list|,
name|off
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|malo_hal_load_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nsegs
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|bus_addr_t
modifier|*
name|paddr
init|=
operator|(
name|bus_addr_t
operator|*
operator|)
name|arg
decl_stmt|;
name|KASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|,
operator|(
literal|"error %u on bus_dma callback"
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
operator|*
name|paddr
operator|=
name|segs
operator|->
name|ds_addr
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Setup for communication with the device.  We allocate  * a command buffer and map it for bus dma use.  The pci  * device id is used to identify whether the device has  * SRAM on it (in which case f/w download must include a  * memory controller reset).  All bus i/o operations happen  * in BAR 1; the driver passes in the tag and handle we need.  */
end_comment

begin_function
name|struct
name|malo_hal
modifier|*
name|malo_hal_attach
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|uint16_t
name|devid
parameter_list|,
name|bus_space_handle_t
name|ioh
parameter_list|,
name|bus_space_tag_t
name|iot
parameter_list|,
name|bus_dma_tag_t
name|tag
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|malo_hal
modifier|*
name|mh
decl_stmt|;
name|mh
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|malo_hal
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|mh
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|mh
operator|->
name|mh_dev
operator|=
name|dev
expr_stmt|;
name|mh
operator|->
name|mh_ioh
operator|=
name|ioh
expr_stmt|;
name|mh
operator|->
name|mh_iot
operator|=
name|iot
expr_stmt|;
name|snprintf
argument_list|(
name|mh
operator|->
name|mh_mtxname
argument_list|,
sizeof|sizeof
argument_list|(
name|mh
operator|->
name|mh_mtxname
argument_list|)
argument_list|,
literal|"%s_hal"
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|mh
operator|->
name|mh_mtx
argument_list|,
name|mh
operator|->
name|mh_mtxname
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate the command buffer and map into the address 	 * space of the h/w.  We request "coherent" memory which 	 * will be uncached on some architectures. 	 */
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|tag
argument_list|,
comment|/* parent */
name|PAGE_SIZE
argument_list|,
literal|0
argument_list|,
comment|/* alignment, bounds */
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|MALO_CMDBUF_SIZE
argument_list|,
comment|/* maxsize */
literal|1
argument_list|,
comment|/* nsegments */
name|MALO_CMDBUF_SIZE
argument_list|,
comment|/* maxsegsize */
name|BUS_DMA_ALLOCNOW
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
comment|/* lockfunc */
name|NULL
argument_list|,
comment|/* lockarg */
operator|&
name|mh
operator|->
name|mh_dmat
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"unable to allocate memory for cmd tag, "
literal|"error %u\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* allocate descriptors */
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|mh
operator|->
name|mh_dmat
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|mh
operator|->
name|mh_dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"unable to create dmamap for cmd buffers, "
literal|"error %u\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|error
operator|=
name|bus_dmamem_alloc
argument_list|(
name|mh
operator|->
name|mh_dmat
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|mh
operator|->
name|mh_cmdbuf
argument_list|,
name|BUS_DMA_NOWAIT
operator||
name|BUS_DMA_COHERENT
argument_list|,
operator|&
name|mh
operator|->
name|mh_dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"unable to allocate memory for cmd buffer, "
literal|"error %u\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|mh
operator|->
name|mh_dmat
argument_list|,
name|mh
operator|->
name|mh_dmamap
argument_list|,
name|mh
operator|->
name|mh_cmdbuf
argument_list|,
name|MALO_CMDBUF_SIZE
argument_list|,
name|malo_hal_load_cb
argument_list|,
operator|&
name|mh
operator|->
name|mh_cmdaddr
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"unable to load cmd buffer, error %u\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
return|return
operator|(
name|mh
operator|)
return|;
name|fail
label|:
if|if
condition|(
name|mh
operator|->
name|mh_dmamap
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|mh
operator|->
name|mh_dmat
argument_list|,
name|mh
operator|->
name|mh_dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|mh
operator|->
name|mh_cmdbuf
operator|!=
name|NULL
condition|)
name|bus_dmamem_free
argument_list|(
name|mh
operator|->
name|mh_dmat
argument_list|,
name|mh
operator|->
name|mh_cmdbuf
argument_list|,
name|mh
operator|->
name|mh_dmamap
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|mh
operator|->
name|mh_dmat
argument_list|,
name|mh
operator|->
name|mh_dmamap
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mh
operator|->
name|mh_dmat
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|mh
operator|->
name|mh_dmat
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mh
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Low level firmware cmd block handshake support.  */
end_comment

begin_function
specifier|static
name|void
name|malo_hal_send_cmd
parameter_list|(
name|struct
name|malo_hal
modifier|*
name|mh
parameter_list|)
block|{
name|uint32_t
name|dummy
decl_stmt|;
name|bus_dmamap_sync
argument_list|(
name|mh
operator|->
name|mh_dmat
argument_list|,
name|mh
operator|->
name|mh_dmamap
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|malo_hal_write4
argument_list|(
name|mh
argument_list|,
name|MALO_REG_GEN_PTR
argument_list|,
name|mh
operator|->
name|mh_cmdaddr
argument_list|)
expr_stmt|;
name|dummy
operator|=
name|malo_hal_read4
argument_list|(
name|mh
argument_list|,
name|MALO_REG_INT_CODE
argument_list|)
expr_stmt|;
name|malo_hal_write4
argument_list|(
name|mh
argument_list|,
name|MALO_REG_H2A_INTERRUPT_EVENTS
argument_list|,
name|MALO_H2ARIC_BIT_DOOR_BELL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|malo_hal_waitforcmd
parameter_list|(
name|struct
name|malo_hal
modifier|*
name|mh
parameter_list|,
name|uint16_t
name|cmd
parameter_list|)
block|{
define|#
directive|define
name|MAX_WAIT_FW_COMPLETE_ITERATIONS
value|10000
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_WAIT_FW_COMPLETE_ITERATIONS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|mh
operator|->
name|mh_cmdbuf
index|[
literal|0
index|]
operator|==
name|le16toh
argument_list|(
name|cmd
argument_list|)
condition|)
return|return
literal|1
return|;
name|DELAY
argument_list|(
literal|1
operator|*
literal|1000
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
undef|#
directive|undef
name|MAX_WAIT_FW_COMPLETE_ITERATIONS
block|}
end_function

begin_function
specifier|static
name|int
name|malo_hal_execute_cmd
parameter_list|(
name|struct
name|malo_hal
modifier|*
name|mh
parameter_list|,
name|unsigned
name|short
name|cmd
parameter_list|)
block|{
name|MALO_HAL_LOCK_ASSERT
argument_list|(
name|mh
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mh
operator|->
name|mh_flags
operator|&
name|MHF_FWHANG
operator|)
operator|&&
operator|(
name|mh
operator|->
name|mh_debug
operator|&
name|MALO_HAL_DEBUG_IGNHANG
operator|)
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|mh
operator|->
name|mh_dev
argument_list|,
literal|"firmware hung, skipping cmd 0x%x\n"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
if|if
condition|(
name|malo_hal_read4
argument_list|(
name|mh
argument_list|,
name|MALO_REG_INT_CODE
argument_list|)
operator|==
literal|0xffffffff
condition|)
block|{
name|device_printf
argument_list|(
name|mh
operator|->
name|mh_dev
argument_list|,
literal|"%s: device not present!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
block|}
name|malo_hal_send_cmd
argument_list|(
name|mh
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|malo_hal_waitforcmd
argument_list|(
name|mh
argument_list|,
name|cmd
operator||
literal|0x8000
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|mh
operator|->
name|mh_dev
argument_list|,
literal|"timeout waiting for f/w cmd 0x%x\n"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|mh
operator|->
name|mh_flags
operator||=
name|MHF_FWHANG
expr_stmt|;
return|return
name|ETIMEDOUT
return|;
block|}
name|bus_dmamap_sync
argument_list|(
name|mh
operator|->
name|mh_dmat
argument_list|,
name|mh
operator|->
name|mh_dmamap
argument_list|,
name|BUS_DMASYNC_POSTREAD
operator||
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|malo_hal_get_cal_table
parameter_list|(
name|struct
name|malo_hal
modifier|*
name|mh
parameter_list|,
name|uint8_t
name|annex
parameter_list|,
name|uint8_t
name|index
parameter_list|)
block|{
name|struct
name|malo_cmd_caltable
modifier|*
name|cmd
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|MALO_HAL_LOCK_ASSERT
argument_list|(
name|mh
argument_list|)
expr_stmt|;
name|_CMD_SETUP
argument_list|(
name|cmd
argument_list|,
expr|struct
name|malo_cmd_caltable
argument_list|,
name|MALO_HOSTCMD_GET_CALTABLE
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|annex
operator|=
name|annex
expr_stmt|;
name|cmd
operator|->
name|index
operator|=
name|index
expr_stmt|;
name|ret
operator|=
name|malo_hal_execute_cmd
argument_list|(
name|mh
argument_list|,
name|MALO_HOSTCMD_GET_CALTABLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
operator|&&
name|cmd
operator|->
name|caltbl
index|[
literal|0
index|]
operator|!=
name|annex
operator|&&
name|annex
operator|!=
literal|0
operator|&&
name|annex
operator|!=
literal|255
condition|)
name|ret
operator|=
name|EIO
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|malo_hal_get_pwrcal_table
parameter_list|(
name|struct
name|malo_hal
modifier|*
name|mh
parameter_list|,
name|struct
name|malo_hal_caldata
modifier|*
name|cal
parameter_list|)
block|{
specifier|const
name|uint8_t
modifier|*
name|data
decl_stmt|;
name|int
name|len
decl_stmt|;
name|MALO_HAL_LOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
comment|/* NB: we hold the lock so it's ok to use cmdbuf */
name|data
operator|=
operator|(
operator|(
specifier|const
expr|struct
name|malo_cmd_caltable
operator|*
operator|)
name|mh
operator|->
name|mh_cmdbuf
operator|)
operator|->
name|caltbl
expr_stmt|;
if|if
condition|(
name|malo_hal_get_cal_table
argument_list|(
name|mh
argument_list|,
literal|33
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
name|len
operator|=
operator|(
name|data
index|[
literal|2
index|]
operator||
operator|(
name|data
index|[
literal|3
index|]
operator|<<
literal|8
operator|)
operator|)
operator|-
literal|12
expr_stmt|;
comment|/* XXX validate len */
name|memcpy
argument_list|(
name|cal
operator|->
name|pt_ratetable_20m
argument_list|,
operator|&
name|data
index|[
literal|12
index|]
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
name|mh
operator|->
name|mh_flags
operator||=
name|MHF_CALDATA
expr_stmt|;
name|MALO_HAL_UNLOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Reset internal state after a firmware download.  */
end_comment

begin_function
specifier|static
name|int
name|malo_hal_resetstate
parameter_list|(
name|struct
name|malo_hal
modifier|*
name|mh
parameter_list|)
block|{
comment|/* 	 * Fetch cal data for later use. 	 * XXX may want to fetch other stuff too. 	 */
if|if
condition|(
operator|(
name|mh
operator|->
name|mh_flags
operator|&
name|MHF_CALDATA
operator|)
operator|==
literal|0
condition|)
name|malo_hal_get_pwrcal_table
argument_list|(
name|mh
argument_list|,
operator|&
name|mh
operator|->
name|mh_caldata
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|malo_hal_fw_reset
parameter_list|(
name|struct
name|malo_hal
modifier|*
name|mh
parameter_list|)
block|{
if|if
condition|(
name|malo_hal_read4
argument_list|(
name|mh
argument_list|,
name|MALO_REG_INT_CODE
argument_list|)
operator|==
literal|0xffffffff
condition|)
block|{
name|device_printf
argument_list|(
name|mh
operator|->
name|mh_dev
argument_list|,
literal|"%s: device not present!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return;
block|}
name|malo_hal_write4
argument_list|(
name|mh
argument_list|,
name|MALO_REG_H2A_INTERRUPT_EVENTS
argument_list|,
name|MALO_ISR_RESET
argument_list|)
expr_stmt|;
name|mh
operator|->
name|mh_flags
operator|&=
operator|~
name|MHF_FWHANG
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|malo_hal_trigger_pcicmd
parameter_list|(
name|struct
name|malo_hal
modifier|*
name|mh
parameter_list|)
block|{
name|uint32_t
name|dummy
decl_stmt|;
name|bus_dmamap_sync
argument_list|(
name|mh
operator|->
name|mh_dmat
argument_list|,
name|mh
operator|->
name|mh_dmamap
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|malo_hal_write4
argument_list|(
name|mh
argument_list|,
name|MALO_REG_GEN_PTR
argument_list|,
name|mh
operator|->
name|mh_cmdaddr
argument_list|)
expr_stmt|;
name|dummy
operator|=
name|malo_hal_read4
argument_list|(
name|mh
argument_list|,
name|MALO_REG_INT_CODE
argument_list|)
expr_stmt|;
name|malo_hal_write4
argument_list|(
name|mh
argument_list|,
name|MALO_REG_INT_CODE
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|dummy
operator|=
name|malo_hal_read4
argument_list|(
name|mh
argument_list|,
name|MALO_REG_INT_CODE
argument_list|)
expr_stmt|;
name|malo_hal_write4
argument_list|(
name|mh
argument_list|,
name|MALO_REG_H2A_INTERRUPT_EVENTS
argument_list|,
name|MALO_H2ARIC_BIT_DOOR_BELL
argument_list|)
expr_stmt|;
name|dummy
operator|=
name|malo_hal_read4
argument_list|(
name|mh
argument_list|,
name|MALO_REG_INT_CODE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|malo_hal_waitfor
parameter_list|(
name|struct
name|malo_hal
modifier|*
name|mh
parameter_list|,
name|uint32_t
name|val
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MALO_FW_MAX_NUM_CHECKS
condition|;
name|i
operator|++
control|)
block|{
name|DELAY
argument_list|(
name|MALO_FW_CHECK_USECS
argument_list|)
expr_stmt|;
if|if
condition|(
name|malo_hal_read4
argument_list|(
name|mh
argument_list|,
name|MALO_REG_INT_CODE
argument_list|)
operator|==
name|val
condition|)
return|return
literal|0
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Firmware block xmit when talking to the boot-rom.  */
end_comment

begin_function
specifier|static
name|int
name|malo_hal_send_helper
parameter_list|(
name|struct
name|malo_hal
modifier|*
name|mh
parameter_list|,
name|int
name|bsize
parameter_list|,
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|size_t
name|dsize
parameter_list|,
name|int
name|waitfor
parameter_list|)
block|{
name|mh
operator|->
name|mh_cmdbuf
index|[
literal|0
index|]
operator|=
name|htole16
argument_list|(
name|MALO_HOSTCMD_CODE_DNLD
argument_list|)
expr_stmt|;
name|mh
operator|->
name|mh_cmdbuf
index|[
literal|1
index|]
operator|=
name|htole16
argument_list|(
name|bsize
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|mh
operator|->
name|mh_cmdbuf
index|[
literal|4
index|]
argument_list|,
name|data
argument_list|,
name|dsize
argument_list|)
expr_stmt|;
name|malo_hal_trigger_pcicmd
argument_list|(
name|mh
argument_list|)
expr_stmt|;
if|if
condition|(
name|waitfor
operator|==
name|MALO_NOWAIT
condition|)
goto|goto
name|pass
goto|;
comment|/* XXX 2000 vs 200 */
if|if
condition|(
name|malo_hal_waitfor
argument_list|(
name|mh
argument_list|,
name|MALO_INT_CODE_CMD_FINISHED
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|mh
operator|->
name|mh_dev
argument_list|,
literal|"%s: timeout waiting for CMD_FINISHED, INT_CODE 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|malo_hal_read4
argument_list|(
name|mh
argument_list|,
name|MALO_REG_INT_CODE
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ETIMEDOUT
return|;
block|}
name|pass
label|:
name|malo_hal_write4
argument_list|(
name|mh
argument_list|,
name|MALO_REG_INT_CODE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|malo_hal_fwload_helper
parameter_list|(
name|struct
name|malo_hal
modifier|*
name|mh
parameter_list|,
name|char
modifier|*
name|helper
parameter_list|)
block|{
specifier|const
name|struct
name|firmware
modifier|*
name|fw
decl_stmt|;
name|int
name|error
decl_stmt|;
name|fw
operator|=
name|firmware_get
argument_list|(
name|helper
argument_list|)
expr_stmt|;
if|if
condition|(
name|fw
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|mh
operator|->
name|mh_dev
argument_list|,
literal|"could not read microcode %s!\n"
argument_list|,
name|helper
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|device_printf
argument_list|(
name|mh
operator|->
name|mh_dev
argument_list|,
literal|"load %s firmware image (%zu bytes)\n"
argument_list|,
name|helper
argument_list|,
name|fw
operator|->
name|datasize
argument_list|)
expr_stmt|;
name|error
operator|=
name|malo_hal_send_helper
argument_list|(
name|mh
argument_list|,
name|fw
operator|->
name|datasize
argument_list|,
name|fw
operator|->
name|data
argument_list|,
name|fw
operator|->
name|datasize
argument_list|,
name|MALO_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
comment|/* tell the card we're done and... */
name|error
operator|=
name|malo_hal_send_helper
argument_list|(
name|mh
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|MALO_NOWAIT
argument_list|)
expr_stmt|;
name|fail
label|:
name|firmware_put
argument_list|(
name|fw
argument_list|,
name|FIRMWARE_UNLOAD
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Firmware block xmit when talking to the 1st-stage loader.  */
end_comment

begin_function
specifier|static
name|int
name|malo_hal_send_main
parameter_list|(
name|struct
name|malo_hal
modifier|*
name|mh
parameter_list|,
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|size_t
name|dsize
parameter_list|,
name|uint16_t
name|seqnum
parameter_list|,
name|int
name|waitfor
parameter_list|)
block|{
name|mh
operator|->
name|mh_cmdbuf
index|[
literal|0
index|]
operator|=
name|htole16
argument_list|(
name|MALO_HOSTCMD_CODE_DNLD
argument_list|)
expr_stmt|;
name|mh
operator|->
name|mh_cmdbuf
index|[
literal|1
index|]
operator|=
name|htole16
argument_list|(
name|dsize
argument_list|)
expr_stmt|;
name|mh
operator|->
name|mh_cmdbuf
index|[
literal|2
index|]
operator|=
name|htole16
argument_list|(
name|seqnum
argument_list|)
expr_stmt|;
name|mh
operator|->
name|mh_cmdbuf
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|mh
operator|->
name|mh_cmdbuf
index|[
literal|4
index|]
argument_list|,
name|data
argument_list|,
name|dsize
argument_list|)
expr_stmt|;
name|malo_hal_trigger_pcicmd
argument_list|(
name|mh
argument_list|)
expr_stmt|;
if|if
condition|(
name|waitfor
operator|==
name|MALO_NOWAIT
condition|)
goto|goto
name|pass
goto|;
if|if
condition|(
name|malo_hal_waitfor
argument_list|(
name|mh
argument_list|,
name|MALO_INT_CODE_CMD_FINISHED
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|mh
operator|->
name|mh_dev
argument_list|,
literal|"%s: timeout waiting for CMD_FINISHED, INT_CODE 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|malo_hal_read4
argument_list|(
name|mh
argument_list|,
name|MALO_REG_INT_CODE
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ETIMEDOUT
return|;
block|}
name|pass
label|:
name|malo_hal_write4
argument_list|(
name|mh
argument_list|,
name|MALO_REG_INT_CODE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|malo_hal_fwload_main
parameter_list|(
name|struct
name|malo_hal
modifier|*
name|mh
parameter_list|,
name|char
modifier|*
name|firmware
parameter_list|)
block|{
specifier|const
name|struct
name|firmware
modifier|*
name|fw
decl_stmt|;
specifier|const
name|uint8_t
modifier|*
name|fp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|size_t
name|count
decl_stmt|;
name|uint16_t
name|seqnum
decl_stmt|;
name|uint32_t
name|blocksize
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|fw
operator|=
name|firmware_get
argument_list|(
name|firmware
argument_list|)
expr_stmt|;
if|if
condition|(
name|fw
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|mh
operator|->
name|mh_dev
argument_list|,
literal|"could not read firmware %s!\n"
argument_list|,
name|firmware
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|device_printf
argument_list|(
name|mh
operator|->
name|mh_dev
argument_list|,
literal|"load %s firmware image (%zu bytes)\n"
argument_list|,
name|firmware
argument_list|,
name|fw
operator|->
name|datasize
argument_list|)
expr_stmt|;
name|seqnum
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|fw
operator|->
name|datasize
condition|;
name|count
operator|+=
name|blocksize
control|)
block|{
name|blocksize
operator|=
name|MIN
argument_list|(
literal|256
argument_list|,
name|fw
operator|->
name|datasize
operator|-
name|count
argument_list|)
expr_stmt|;
name|fp
operator|=
operator|(
specifier|const
name|uint8_t
operator|*
operator|)
name|fw
operator|->
name|data
operator|+
name|count
expr_stmt|;
name|error
operator|=
name|malo_hal_send_main
argument_list|(
name|mh
argument_list|,
name|fp
argument_list|,
name|blocksize
argument_list|,
name|seqnum
operator|++
argument_list|,
name|MALO_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
name|DELAY
argument_list|(
literal|500
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * send a command with size 0 to tell that the firmware has been 	 * uploaded 	 */
name|error
operator|=
name|malo_hal_send_main
argument_list|(
name|mh
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|seqnum
operator|++
argument_list|,
name|MALO_NOWAIT
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|fail
label|:
name|firmware_put
argument_list|(
name|fw
argument_list|,
name|FIRMWARE_UNLOAD
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|malo_hal_fwload
parameter_list|(
name|struct
name|malo_hal
modifier|*
name|mh
parameter_list|,
name|char
modifier|*
name|helper
parameter_list|,
name|char
modifier|*
name|firmware
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
name|uint32_t
name|fwreadysig
decl_stmt|,
name|opmode
decl_stmt|;
comment|/* 	 * NB: now malo(4) supports only STA mode.  It will be better if it 	 * supports AP mode. 	 */
name|fwreadysig
operator|=
name|MALO_HOSTCMD_STA_FWRDY_SIGNATURE
expr_stmt|;
name|opmode
operator|=
name|MALO_HOSTCMD_STA_MODE
expr_stmt|;
name|malo_hal_fw_reset
argument_list|(
name|mh
argument_list|)
expr_stmt|;
name|malo_hal_write4
argument_list|(
name|mh
argument_list|,
name|MALO_REG_A2H_INTERRUPT_CLEAR_SEL
argument_list|,
name|MALO_A2HRIC_BIT_MASK
argument_list|)
expr_stmt|;
name|malo_hal_write4
argument_list|(
name|mh
argument_list|,
name|MALO_REG_A2H_INTERRUPT_CAUSE
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|malo_hal_write4
argument_list|(
name|mh
argument_list|,
name|MALO_REG_A2H_INTERRUPT_MASK
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|malo_hal_write4
argument_list|(
name|mh
argument_list|,
name|MALO_REG_A2H_INTERRUPT_STATUS_MASK
argument_list|,
name|MALO_A2HRIC_BIT_MASK
argument_list|)
expr_stmt|;
name|error
operator|=
name|malo_hal_fwload_helper
argument_list|(
name|mh
argument_list|,
name|helper
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|mh
operator|->
name|mh_dev
argument_list|,
literal|"failed to load bootrom loader.\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|DELAY
argument_list|(
literal|200
operator|*
name|MALO_FW_CHECK_USECS
argument_list|)
expr_stmt|;
name|error
operator|=
name|malo_hal_fwload_main
argument_list|(
name|mh
argument_list|,
name|firmware
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|mh
operator|->
name|mh_dev
argument_list|,
literal|"failed to load firmware.\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* 	 * Wait for firmware to startup; we monitor the INT_CODE register 	 * waiting for a signature to written back indicating it's ready to go. 	 */
name|mh
operator|->
name|mh_cmdbuf
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|opmode
operator|!=
name|MALO_HOSTCMD_STA_MODE
condition|)
name|malo_hal_trigger_pcicmd
argument_list|(
name|mh
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MALO_FW_MAX_NUM_CHECKS
condition|;
name|i
operator|++
control|)
block|{
name|malo_hal_write4
argument_list|(
name|mh
argument_list|,
name|MALO_REG_GEN_PTR
argument_list|,
name|opmode
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|MALO_FW_CHECK_USECS
argument_list|)
expr_stmt|;
if|if
condition|(
name|malo_hal_read4
argument_list|(
name|mh
argument_list|,
name|MALO_REG_INT_CODE
argument_list|)
operator|==
name|fwreadysig
condition|)
block|{
name|malo_hal_write4
argument_list|(
name|mh
argument_list|,
name|MALO_REG_INT_CODE
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
return|return
name|malo_hal_resetstate
argument_list|(
name|mh
argument_list|)
return|;
block|}
block|}
return|return
name|ETIMEDOUT
return|;
name|fail
label|:
name|malo_hal_fw_reset
argument_list|(
name|mh
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return "hw specs".  Note this must be the first cmd MUST be done after  * a firmware download or the f/w will lockup.  */
end_comment

begin_function
name|int
name|malo_hal_gethwspecs
parameter_list|(
name|struct
name|malo_hal
modifier|*
name|mh
parameter_list|,
name|struct
name|malo_hal_hwspec
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|malo_cmd_get_hwspec
modifier|*
name|cmd
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|MALO_HAL_LOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
name|_CMD_SETUP
argument_list|(
name|cmd
argument_list|,
expr|struct
name|malo_cmd_get_hwspec
argument_list|,
name|MALO_HOSTCMD_GET_HW_SPEC
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|cmd
operator|->
name|permaddr
index|[
literal|0
index|]
argument_list|,
literal|0xff
argument_list|,
name|IEEE80211_ADDR_LEN
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|ul_fw_awakecookie
operator|=
name|htole32
argument_list|(
operator|(
name|unsigned
name|int
operator|)
name|mh
operator|->
name|mh_cmdaddr
operator|+
literal|2048
argument_list|)
expr_stmt|;
name|ret
operator|=
name|malo_hal_execute_cmd
argument_list|(
name|mh
argument_list|,
name|MALO_HOSTCMD_GET_HW_SPEC
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
name|IEEE80211_ADDR_COPY
argument_list|(
name|hw
operator|->
name|macaddr
argument_list|,
name|cmd
operator|->
name|permaddr
argument_list|)
expr_stmt|;
name|hw
operator|->
name|wcbbase
index|[
literal|0
index|]
operator|=
name|le32toh
argument_list|(
name|cmd
operator|->
name|wcbbase0
argument_list|)
operator|&
literal|0x0000ffff
expr_stmt|;
name|hw
operator|->
name|wcbbase
index|[
literal|1
index|]
operator|=
name|le32toh
argument_list|(
name|cmd
operator|->
name|wcbbase1
argument_list|)
operator|&
literal|0x0000ffff
expr_stmt|;
name|hw
operator|->
name|wcbbase
index|[
literal|2
index|]
operator|=
name|le32toh
argument_list|(
name|cmd
operator|->
name|wcbbase2
argument_list|)
operator|&
literal|0x0000ffff
expr_stmt|;
name|hw
operator|->
name|wcbbase
index|[
literal|3
index|]
operator|=
name|le32toh
argument_list|(
name|cmd
operator|->
name|wcbbase3
argument_list|)
operator|&
literal|0x0000ffff
expr_stmt|;
name|hw
operator|->
name|rxdesc_read
operator|=
name|le32toh
argument_list|(
name|cmd
operator|->
name|rxpdrd_ptr
argument_list|)
operator|&
literal|0x0000ffff
expr_stmt|;
name|hw
operator|->
name|rxdesc_write
operator|=
name|le32toh
argument_list|(
name|cmd
operator|->
name|rxpdwr_ptr
argument_list|)
operator|&
literal|0x0000ffff
expr_stmt|;
name|hw
operator|->
name|regioncode
operator|=
name|le16toh
argument_list|(
name|cmd
operator|->
name|regioncode
argument_list|)
operator|&
literal|0x00ff
expr_stmt|;
name|hw
operator|->
name|fw_releasenum
operator|=
name|le32toh
argument_list|(
name|cmd
operator|->
name|fw_releasenum
argument_list|)
expr_stmt|;
name|hw
operator|->
name|maxnum_wcb
operator|=
name|le16toh
argument_list|(
name|cmd
operator|->
name|num_wcb
argument_list|)
expr_stmt|;
name|hw
operator|->
name|maxnum_mcaddr
operator|=
name|le16toh
argument_list|(
name|cmd
operator|->
name|num_mcastaddr
argument_list|)
expr_stmt|;
name|hw
operator|->
name|num_antenna
operator|=
name|le16toh
argument_list|(
name|cmd
operator|->
name|num_antenna
argument_list|)
expr_stmt|;
name|hw
operator|->
name|hwversion
operator|=
name|cmd
operator|->
name|version
expr_stmt|;
name|hw
operator|->
name|hostinterface
operator|=
name|cmd
operator|->
name|hostif
expr_stmt|;
block|}
name|MALO_HAL_UNLOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|void
name|malo_hal_detach
parameter_list|(
name|struct
name|malo_hal
modifier|*
name|mh
parameter_list|)
block|{
name|bus_dmamem_free
argument_list|(
name|mh
operator|->
name|mh_dmat
argument_list|,
name|mh
operator|->
name|mh_cmdbuf
argument_list|,
name|mh
operator|->
name|mh_dmamap
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|mh
operator|->
name|mh_dmat
argument_list|,
name|mh
operator|->
name|mh_dmamap
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|mh
operator|->
name|mh_dmat
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|mh
operator|->
name|mh_mtx
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mh
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Configure antenna use.  Takes effect immediately.  *  * XXX tx antenna setting ignored  * XXX rx antenna setting should always be 3 (for now)  */
end_comment

begin_function
name|int
name|malo_hal_setantenna
parameter_list|(
name|struct
name|malo_hal
modifier|*
name|mh
parameter_list|,
name|enum
name|malo_hal_antenna
name|dirset
parameter_list|,
name|int
name|ant
parameter_list|)
block|{
name|struct
name|malo_cmd_rf_antenna
modifier|*
name|cmd
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|dirset
operator|==
name|MHA_ANTENNATYPE_RX
operator|||
name|dirset
operator|==
name|MHA_ANTENNATYPE_TX
operator|)
condition|)
return|return
name|EINVAL
return|;
name|MALO_HAL_LOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
name|_CMD_SETUP
argument_list|(
name|cmd
argument_list|,
expr|struct
name|malo_cmd_rf_antenna
argument_list|,
name|MALO_HOSTCMD_802_11_RF_ANTENNA
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|action
operator|=
name|htole16
argument_list|(
name|dirset
argument_list|)
expr_stmt|;
if|if
condition|(
name|ant
operator|==
literal|0
condition|)
block|{
comment|/* default to all/both antennae */
comment|/* XXX never reach now.  */
name|ant
operator|=
literal|3
expr_stmt|;
block|}
name|cmd
operator|->
name|mode
operator|=
name|htole16
argument_list|(
name|ant
argument_list|)
expr_stmt|;
name|ret
operator|=
name|malo_hal_execute_cmd
argument_list|(
name|mh
argument_list|,
name|MALO_HOSTCMD_802_11_RF_ANTENNA
argument_list|)
expr_stmt|;
name|MALO_HAL_UNLOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * Configure radio.  Takes effect immediately.  *  * XXX preamble installed after set fixed rate cmd  */
end_comment

begin_function
name|int
name|malo_hal_setradio
parameter_list|(
name|struct
name|malo_hal
modifier|*
name|mh
parameter_list|,
name|int
name|onoff
parameter_list|,
name|enum
name|malo_hal_preamble
name|preamble
parameter_list|)
block|{
name|struct
name|malo_cmd_radio_control
modifier|*
name|cmd
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|MALO_HAL_LOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
name|_CMD_SETUP
argument_list|(
name|cmd
argument_list|,
expr|struct
name|malo_cmd_radio_control
argument_list|,
name|MALO_HOSTCMD_802_11_RADIO_CONTROL
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|action
operator|=
name|htole16
argument_list|(
name|MALO_HOSTCMD_ACT_GEN_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|onoff
operator|==
literal|0
condition|)
name|cmd
operator|->
name|control
operator|=
literal|0
expr_stmt|;
else|else
name|cmd
operator|->
name|control
operator|=
name|htole16
argument_list|(
name|preamble
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|radio_on
operator|=
name|htole16
argument_list|(
name|onoff
argument_list|)
expr_stmt|;
name|ret
operator|=
name|malo_hal_execute_cmd
argument_list|(
name|mh
argument_list|,
name|MALO_HOSTCMD_802_11_RADIO_CONTROL
argument_list|)
expr_stmt|;
name|MALO_HAL_UNLOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * Set the interrupt mask.  */
end_comment

begin_function
name|void
name|malo_hal_intrset
parameter_list|(
name|struct
name|malo_hal
modifier|*
name|mh
parameter_list|,
name|uint32_t
name|mask
parameter_list|)
block|{
name|malo_hal_write4
argument_list|(
name|mh
argument_list|,
name|MALO_REG_A2H_INTERRUPT_MASK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|malo_hal_read4
argument_list|(
name|mh
argument_list|,
name|MALO_REG_INT_CODE
argument_list|)
expr_stmt|;
name|mh
operator|->
name|mh_imask
operator|=
name|mask
expr_stmt|;
name|malo_hal_write4
argument_list|(
name|mh
argument_list|,
name|MALO_REG_A2H_INTERRUPT_MASK
argument_list|,
name|mask
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|malo_hal_read4
argument_list|(
name|mh
argument_list|,
name|MALO_REG_INT_CODE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|malo_hal_setchannel
parameter_list|(
name|struct
name|malo_hal
modifier|*
name|mh
parameter_list|,
specifier|const
name|struct
name|malo_hal_channel
modifier|*
name|chan
parameter_list|)
block|{
name|struct
name|malo_cmd_fw_set_rf_channel
modifier|*
name|cmd
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|MALO_HAL_LOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
name|_CMD_SETUP
argument_list|(
name|cmd
argument_list|,
expr|struct
name|malo_cmd_fw_set_rf_channel
argument_list|,
name|MALO_HOSTCMD_SET_RF_CHANNEL
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|action
operator|=
name|htole16
argument_list|(
name|MALO_HOSTCMD_ACT_GEN_SET
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|cur_channel
operator|=
name|chan
operator|->
name|channel
expr_stmt|;
name|ret
operator|=
name|malo_hal_execute_cmd
argument_list|(
name|mh
argument_list|,
name|MALO_HOSTCMD_SET_RF_CHANNEL
argument_list|)
expr_stmt|;
name|MALO_HAL_UNLOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|malo_hal_settxpower
parameter_list|(
name|struct
name|malo_hal
modifier|*
name|mh
parameter_list|,
specifier|const
name|struct
name|malo_hal_channel
modifier|*
name|c
parameter_list|)
block|{
name|struct
name|malo_cmd_rf_tx_power
modifier|*
name|cmd
decl_stmt|;
specifier|const
name|struct
name|malo_hal_caldata
modifier|*
name|cal
init|=
operator|&
name|mh
operator|->
name|mh_caldata
decl_stmt|;
name|uint8_t
name|chan
init|=
name|c
operator|->
name|channel
decl_stmt|;
name|uint16_t
name|pow
decl_stmt|;
name|int
name|i
decl_stmt|,
name|idx
decl_stmt|,
name|ret
decl_stmt|;
name|MALO_HAL_LOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
name|_CMD_SETUP
argument_list|(
name|cmd
argument_list|,
expr|struct
name|malo_cmd_rf_tx_power
argument_list|,
name|MALO_HOSTCMD_802_11_RF_TX_POWER
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|action
operator|=
name|htole16
argument_list|(
name|MALO_HOSTCMD_ACT_GEN_SET_LIST
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|idx
operator|=
operator|(
name|chan
operator|-
literal|1
operator|)
operator|*
literal|4
operator|+
name|i
expr_stmt|;
name|pow
operator|=
name|cal
operator|->
name|pt_ratetable_20m
index|[
name|idx
index|]
expr_stmt|;
name|cmd
operator|->
name|power_levellist
index|[
name|i
index|]
operator|=
name|htole16
argument_list|(
name|pow
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
name|malo_hal_execute_cmd
argument_list|(
name|mh
argument_list|,
name|MALO_HOSTCMD_802_11_RF_TX_POWER
argument_list|)
expr_stmt|;
name|MALO_HAL_UNLOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|malo_hal_setpromisc
parameter_list|(
name|struct
name|malo_hal
modifier|*
name|mh
parameter_list|,
name|int
name|enable
parameter_list|)
block|{
comment|/* XXX need host cmd */
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|malo_hal_setassocid
parameter_list|(
name|struct
name|malo_hal
modifier|*
name|mh
parameter_list|,
specifier|const
name|uint8_t
name|bssid
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|,
name|uint16_t
name|associd
parameter_list|)
block|{
name|struct
name|malo_cmd_fw_set_aid
modifier|*
name|cmd
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|MALO_HAL_LOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
name|_CMD_SETUP
argument_list|(
name|cmd
argument_list|,
expr|struct
name|malo_cmd_fw_set_aid
argument_list|,
name|MALO_HOSTCMD_SET_AID
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|cmdhdr
operator|.
name|seqnum
operator|=
literal|1
expr_stmt|;
name|cmd
operator|->
name|associd
operator|=
name|htole16
argument_list|(
name|associd
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
operator|&
name|cmd
operator|->
name|macaddr
index|[
literal|0
index|]
argument_list|,
name|bssid
argument_list|)
expr_stmt|;
name|ret
operator|=
name|malo_hal_execute_cmd
argument_list|(
name|mh
argument_list|,
name|MALO_HOSTCMD_SET_AID
argument_list|)
expr_stmt|;
name|MALO_HAL_UNLOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * Kick the firmware to tell it there are new tx descriptors  * for processing.  The driver says what h/w q has work in  * case the f/w ever gets smarter.  */
end_comment

begin_function
name|void
name|malo_hal_txstart
parameter_list|(
name|struct
name|malo_hal
modifier|*
name|mh
parameter_list|,
name|int
name|qnum
parameter_list|)
block|{
name|bus_space_write_4
argument_list|(
name|mh
operator|->
name|mh_iot
argument_list|,
name|mh
operator|->
name|mh_ioh
argument_list|,
name|MALO_REG_H2A_INTERRUPT_EVENTS
argument_list|,
name|MALO_H2ARIC_BIT_PPA_READY
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|bus_space_read_4
argument_list|(
name|mh
operator|->
name|mh_iot
argument_list|,
name|mh
operator|->
name|mh_ioh
argument_list|,
name|MALO_REG_INT_CODE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return the current ISR setting and clear the cause.  */
end_comment

begin_function
name|void
name|malo_hal_getisr
parameter_list|(
name|struct
name|malo_hal
modifier|*
name|mh
parameter_list|,
name|uint32_t
modifier|*
name|status
parameter_list|)
block|{
name|uint32_t
name|cause
decl_stmt|;
name|cause
operator|=
name|bus_space_read_4
argument_list|(
name|mh
operator|->
name|mh_iot
argument_list|,
name|mh
operator|->
name|mh_ioh
argument_list|,
name|MALO_REG_A2H_INTERRUPT_CAUSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|cause
operator|==
literal|0xffffffff
condition|)
block|{
comment|/* card removed */
name|cause
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cause
operator|!=
literal|0
condition|)
block|{
comment|/* clear cause bits */
name|bus_space_write_4
argument_list|(
name|mh
operator|->
name|mh_iot
argument_list|,
name|mh
operator|->
name|mh_ioh
argument_list|,
name|MALO_REG_A2H_INTERRUPT_CAUSE
argument_list|,
name|cause
operator|&
operator|~
name|mh
operator|->
name|mh_imask
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|bus_space_read_4
argument_list|(
name|mh
operator|->
name|mh_iot
argument_list|,
name|mh
operator|->
name|mh_ioh
argument_list|,
name|MALO_REG_INT_CODE
argument_list|)
expr_stmt|;
name|cause
operator|&=
name|mh
operator|->
name|mh_imask
expr_stmt|;
block|}
operator|*
name|status
operator|=
name|cause
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Callback from the driver on a cmd done interrupt.  Nothing to do right  * now as we spin waiting for cmd completion.  */
end_comment

begin_function
name|void
name|malo_hal_cmddone
parameter_list|(
name|struct
name|malo_hal
modifier|*
name|mh
parameter_list|)
block|{
comment|/* NB : do nothing.  */
block|}
end_function

begin_function
name|int
name|malo_hal_prescan
parameter_list|(
name|struct
name|malo_hal
modifier|*
name|mh
parameter_list|)
block|{
name|struct
name|malo_cmd_prescan
modifier|*
name|cmd
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|MALO_HAL_LOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
name|_CMD_SETUP
argument_list|(
name|cmd
argument_list|,
expr|struct
name|malo_cmd_prescan
argument_list|,
name|MALO_HOSTCMD_SET_PRE_SCAN
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|cmdhdr
operator|.
name|seqnum
operator|=
literal|1
expr_stmt|;
name|ret
operator|=
name|malo_hal_execute_cmd
argument_list|(
name|mh
argument_list|,
name|MALO_HOSTCMD_SET_PRE_SCAN
argument_list|)
expr_stmt|;
name|MALO_HAL_UNLOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|malo_hal_postscan
parameter_list|(
name|struct
name|malo_hal
modifier|*
name|mh
parameter_list|,
name|uint8_t
modifier|*
name|macaddr
parameter_list|,
name|uint8_t
name|ibsson
parameter_list|)
block|{
name|struct
name|malo_cmd_postscan
modifier|*
name|cmd
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|MALO_HAL_LOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
name|_CMD_SETUP
argument_list|(
name|cmd
argument_list|,
expr|struct
name|malo_cmd_postscan
argument_list|,
name|MALO_HOSTCMD_SET_POST_SCAN
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|cmdhdr
operator|.
name|seqnum
operator|=
literal|1
expr_stmt|;
name|cmd
operator|->
name|isibss
operator|=
name|htole32
argument_list|(
name|ibsson
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
operator|&
name|cmd
operator|->
name|bssid
index|[
literal|0
index|]
argument_list|,
name|macaddr
argument_list|)
expr_stmt|;
name|ret
operator|=
name|malo_hal_execute_cmd
argument_list|(
name|mh
argument_list|,
name|MALO_HOSTCMD_SET_POST_SCAN
argument_list|)
expr_stmt|;
name|MALO_HAL_UNLOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|malo_hal_set_slot
parameter_list|(
name|struct
name|malo_hal
modifier|*
name|mh
parameter_list|,
name|int
name|is_short
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|struct
name|malo_cmd_fw_setslot
modifier|*
name|cmd
decl_stmt|;
name|MALO_HAL_LOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
name|_CMD_SETUP
argument_list|(
name|cmd
argument_list|,
expr|struct
name|malo_cmd_fw_setslot
argument_list|,
name|MALO_HOSTCMD_SET_SLOT
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|action
operator|=
name|htole16
argument_list|(
name|MALO_HOSTCMD_ACT_GEN_SET
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|slot
operator|=
operator|(
name|is_short
operator|==
literal|1
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
name|ret
operator|=
name|malo_hal_execute_cmd
argument_list|(
name|mh
argument_list|,
name|MALO_HOSTCMD_SET_SLOT
argument_list|)
expr_stmt|;
name|MALO_HAL_UNLOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|malo_hal_set_rate
parameter_list|(
name|struct
name|malo_hal
modifier|*
name|mh
parameter_list|,
name|uint16_t
name|curmode
parameter_list|,
name|uint8_t
name|rate
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|ret
decl_stmt|;
name|struct
name|malo_cmd_set_rate
modifier|*
name|cmd
decl_stmt|;
name|MALO_HAL_LOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
name|_CMD_SETUP
argument_list|(
name|cmd
argument_list|,
expr|struct
name|malo_cmd_set_rate
argument_list|,
name|MALO_HOSTCMD_SET_RATE
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|aprates
index|[
literal|0
index|]
operator|=
literal|2
expr_stmt|;
name|cmd
operator|->
name|aprates
index|[
literal|1
index|]
operator|=
literal|4
expr_stmt|;
name|cmd
operator|->
name|aprates
index|[
literal|2
index|]
operator|=
literal|11
expr_stmt|;
name|cmd
operator|->
name|aprates
index|[
literal|3
index|]
operator|=
literal|22
expr_stmt|;
if|if
condition|(
name|curmode
operator|==
name|IEEE80211_MODE_11G
condition|)
block|{
name|cmd
operator|->
name|aprates
index|[
literal|4
index|]
operator|=
literal|0
expr_stmt|;
comment|/* XXX reserved?  */
name|cmd
operator|->
name|aprates
index|[
literal|5
index|]
operator|=
literal|12
expr_stmt|;
name|cmd
operator|->
name|aprates
index|[
literal|6
index|]
operator|=
literal|18
expr_stmt|;
name|cmd
operator|->
name|aprates
index|[
literal|7
index|]
operator|=
literal|24
expr_stmt|;
name|cmd
operator|->
name|aprates
index|[
literal|8
index|]
operator|=
literal|36
expr_stmt|;
name|cmd
operator|->
name|aprates
index|[
literal|9
index|]
operator|=
literal|48
expr_stmt|;
name|cmd
operator|->
name|aprates
index|[
literal|10
index|]
operator|=
literal|72
expr_stmt|;
name|cmd
operator|->
name|aprates
index|[
literal|11
index|]
operator|=
literal|96
expr_stmt|;
name|cmd
operator|->
name|aprates
index|[
literal|12
index|]
operator|=
literal|108
expr_stmt|;
block|}
if|if
condition|(
name|rate
operator|!=
literal|0
condition|)
block|{
comment|/* fixed rate */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|13
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|cmd
operator|->
name|aprates
index|[
name|i
index|]
operator|==
name|rate
condition|)
block|{
name|cmd
operator|->
name|rateindex
operator|=
name|i
expr_stmt|;
name|cmd
operator|->
name|dataratetype
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
name|ret
operator|=
name|malo_hal_execute_cmd
argument_list|(
name|mh
argument_list|,
name|MALO_HOSTCMD_SET_RATE
argument_list|)
expr_stmt|;
name|MALO_HAL_UNLOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|malo_hal_setmcast
parameter_list|(
name|struct
name|malo_hal
modifier|*
name|mh
parameter_list|,
name|int
name|nmc
parameter_list|,
specifier|const
name|uint8_t
name|macs
index|[]
parameter_list|)
block|{
name|struct
name|malo_cmd_mcast
modifier|*
name|cmd
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|nmc
operator|>
name|MALO_HAL_MCAST_MAX
condition|)
return|return
name|EINVAL
return|;
name|MALO_HAL_LOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
name|_CMD_SETUP
argument_list|(
name|cmd
argument_list|,
expr|struct
name|malo_cmd_mcast
argument_list|,
name|MALO_HOSTCMD_MAC_MULTICAST_ADR
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|cmd
operator|->
name|maclist
argument_list|,
name|macs
argument_list|,
name|nmc
operator|*
name|IEEE80211_ADDR_LEN
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|numaddr
operator|=
name|htole16
argument_list|(
name|nmc
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|action
operator|=
name|htole16
argument_list|(
literal|0xffff
argument_list|)
expr_stmt|;
name|ret
operator|=
name|malo_hal_execute_cmd
argument_list|(
name|mh
argument_list|,
name|MALO_HOSTCMD_MAC_MULTICAST_ADR
argument_list|)
expr_stmt|;
name|MALO_HAL_UNLOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

end_unit

