begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2008 Weongyo Jeong<weongyo@freebsd.org>  * Copyright (c) 2007 Marvell Semiconductor, Inc.  * Copyright (c) 2007 Sam Leffler, Errno Consulting  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer,  *    without modification.  * 2. Redistributions in binary form must reproduce at minimum a disclaimer  *    similar to the "NO WARRANTY" disclaimer below ("Disclaimer") and any  *    redistribution must be conditioned upon including a substantially  *    similar Disclaimer requirement for further binary redistribution.  *  * NO WARRANTY  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF NONINFRINGEMENT, MERCHANTIBILITY  * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL  * THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY,  * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER  * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  * THE POSSIBILITY OF SUCH DAMAGES.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"opt_malo.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_var.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_regdomain.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<dev/malo/if_malo.h>
end_include

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_hw
argument_list|,
name|OID_AUTO
argument_list|,
name|malo
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"Marvell 88w8335 driver parameters"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|malo_txcoalesce
init|=
literal|8
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # tx pkts to q before poking f/w*/
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_malo
argument_list|,
name|OID_AUTO
argument_list|,
name|txcoalesce
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|malo_txcoalesce
argument_list|,
literal|0
argument_list|,
literal|"tx buffers to send at once"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.malo.txcoalesce"
argument_list|,
operator|&
name|malo_txcoalesce
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|malo_rxbuf
init|=
name|MALO_RXBUF
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # rx buffers to allocate */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_malo
argument_list|,
name|OID_AUTO
argument_list|,
name|rxbuf
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|malo_rxbuf
argument_list|,
literal|0
argument_list|,
literal|"rx buffers allocated"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.malo.rxbuf"
argument_list|,
operator|&
name|malo_rxbuf
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|malo_rxquota
init|=
name|MALO_RXBUF
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # max buffers to process */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_malo
argument_list|,
name|OID_AUTO
argument_list|,
name|rxquota
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|malo_rxquota
argument_list|,
literal|0
argument_list|,
literal|"max rx buffers to process per interrupt"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.malo.rxquota"
argument_list|,
operator|&
name|malo_rxquota
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|malo_txbuf
init|=
name|MALO_TXBUF
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # tx buffers to allocate */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_malo
argument_list|,
name|OID_AUTO
argument_list|,
name|txbuf
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|malo_txbuf
argument_list|,
literal|0
argument_list|,
literal|"tx buffers allocated"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.malo.txbuf"
argument_list|,
operator|&
name|malo_txbuf
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|MALO_DEBUG
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|malo_debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_malo
argument_list|,
name|OID_AUTO
argument_list|,
name|debug
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|malo_debug
argument_list|,
literal|0
argument_list|,
literal|"control debugging printfs"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.malo.debug"
argument_list|,
operator|&
name|malo_debug
argument_list|)
expr_stmt|;
end_expr_stmt

begin_enum
enum|enum
block|{
name|MALO_DEBUG_XMIT
init|=
literal|0x00000001
block|,
comment|/* basic xmit operation */
name|MALO_DEBUG_XMIT_DESC
init|=
literal|0x00000002
block|,
comment|/* xmit descriptors */
name|MALO_DEBUG_RECV
init|=
literal|0x00000004
block|,
comment|/* basic recv operation */
name|MALO_DEBUG_RECV_DESC
init|=
literal|0x00000008
block|,
comment|/* recv descriptors */
name|MALO_DEBUG_RESET
init|=
literal|0x00000010
block|,
comment|/* reset processing */
name|MALO_DEBUG_INTR
init|=
literal|0x00000040
block|,
comment|/* ISR */
name|MALO_DEBUG_TX_PROC
init|=
literal|0x00000080
block|,
comment|/* tx ISR proc */
name|MALO_DEBUG_RX_PROC
init|=
literal|0x00000100
block|,
comment|/* rx ISR proc */
name|MALO_DEBUG_STATE
init|=
literal|0x00000400
block|,
comment|/* 802.11 state transitions */
name|MALO_DEBUG_NODE
init|=
literal|0x00000800
block|,
comment|/* node management */
name|MALO_DEBUG_RECV_ALL
init|=
literal|0x00001000
block|,
comment|/* trace all frames (beacons) */
name|MALO_DEBUG_FW
init|=
literal|0x00008000
block|,
comment|/* firmware */
name|MALO_DEBUG_ANY
init|=
literal|0xffffffff
block|}
enum|;
end_enum

begin_define
define|#
directive|define
name|IS_BEACON
parameter_list|(
name|wh
parameter_list|)
define|\
value|((wh->i_fc[0]& (IEEE80211_FC0_TYPE_MASK |			\ 		IEEE80211_FC0_SUBTYPE_MASK)) ==				\ 	 (IEEE80211_FC0_TYPE_MGT|IEEE80211_FC0_SUBTYPE_BEACON))
end_define

begin_define
define|#
directive|define
name|IFF_DUMPPKTS_RECV
parameter_list|(
name|sc
parameter_list|,
name|wh
parameter_list|)
define|\
value|(((sc->malo_debug& MALO_DEBUG_RECV)&&				\ 	  ((sc->malo_debug& MALO_DEBUG_RECV_ALL) || !IS_BEACON(wh))) || \ 	 (sc->malo_ifp->if_flags& (IFF_DEBUG|IFF_LINK2)) ==		\ 	  (IFF_DEBUG|IFF_LINK2))
end_define

begin_define
define|#
directive|define
name|IFF_DUMPPKTS_XMIT
parameter_list|(
name|sc
parameter_list|)
define|\
value|((sc->malo_debug& MALO_DEBUG_XMIT) ||				\ 	 (sc->malo_ifp->if_flags& (IFF_DEBUG | IFF_LINK2)) ==		\ 	     (IFF_DEBUG | IFF_LINK2))
end_define

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
name|sc
parameter_list|,
name|m
parameter_list|,
name|fmt
parameter_list|,
modifier|...
parameter_list|)
value|do {				\ 	if (sc->malo_debug& (m))				\ 		printf(fmt, __VA_ARGS__);			\ } while (0)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
name|sc
parameter_list|,
name|m
parameter_list|,
name|fmt
parameter_list|,
modifier|...
parameter_list|)
value|do {				\ 	(void) sc;						\ } while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_MALODEV
argument_list|,
literal|"malodev"
argument_list|,
literal|"malo driver dma buffers"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|struct
name|ieee80211vap
modifier|*
name|malo_vap_create
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
specifier|const
name|char
name|name
index|[
name|IFNAMSIZ
index|]
parameter_list|,
name|int
name|unit
parameter_list|,
name|int
name|opmode
parameter_list|,
name|int
name|flags
parameter_list|,
specifier|const
name|uint8_t
name|bssid
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|,
specifier|const
name|uint8_t
name|mac
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|malo_vap_delete
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|malo_dma_setup
parameter_list|(
name|struct
name|malo_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|malo_setup_hwdma
parameter_list|(
name|struct
name|malo_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|malo_txq_init
parameter_list|(
name|struct
name|malo_softc
modifier|*
parameter_list|,
name|struct
name|malo_txq
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|malo_tx_cleanupq
parameter_list|(
name|struct
name|malo_softc
modifier|*
parameter_list|,
name|struct
name|malo_txq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|malo_start
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|malo_watchdog
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|malo_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|u_long
parameter_list|,
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|malo_updateslot
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|malo_newstate
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
parameter_list|,
name|enum
name|ieee80211_state
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|malo_scan_start
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|malo_scan_end
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|malo_set_channel
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|malo_raw_xmit
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
specifier|const
name|struct
name|ieee80211_bpf_params
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|malo_bpfattach
parameter_list|(
name|struct
name|malo_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|malo_sysctlattach
parameter_list|(
name|struct
name|malo_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|malo_announce
parameter_list|(
name|struct
name|malo_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|malo_dma_cleanup
parameter_list|(
name|struct
name|malo_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|malo_stop_locked
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|malo_chan_set
parameter_list|(
name|struct
name|malo_softc
modifier|*
parameter_list|,
name|struct
name|ieee80211_channel
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|malo_mode_init
parameter_list|(
name|struct
name|malo_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|malo_tx_proc
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|malo_rx_proc
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|malo_init
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Read/Write shorthands for accesses to BAR 0.  Note that all BAR 1  * operations are done in the "hal" except getting H/W MAC address at  * malo_attach and there should be no reference to them here.  */
end_comment

begin_function
specifier|static
name|uint32_t
name|malo_bar0_read4
parameter_list|(
name|struct
name|malo_softc
modifier|*
name|sc
parameter_list|,
name|bus_size_t
name|off
parameter_list|)
block|{
return|return
name|bus_space_read_4
argument_list|(
name|sc
operator|->
name|malo_io0t
argument_list|,
name|sc
operator|->
name|malo_io0h
argument_list|,
name|off
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|malo_bar0_write4
parameter_list|(
name|struct
name|malo_softc
modifier|*
name|sc
parameter_list|,
name|bus_size_t
name|off
parameter_list|,
name|uint32_t
name|val
parameter_list|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|MALO_DEBUG_FW
argument_list|,
literal|"%s: off 0x%zx val 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|off
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|sc
operator|->
name|malo_io0t
argument_list|,
name|sc
operator|->
name|malo_io0h
argument_list|,
name|off
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uint8_t
name|malo_bar1_read1
parameter_list|(
name|struct
name|malo_softc
modifier|*
name|sc
parameter_list|,
name|bus_size_t
name|off
parameter_list|)
block|{
return|return
name|bus_space_read_1
argument_list|(
name|sc
operator|->
name|malo_io1t
argument_list|,
name|sc
operator|->
name|malo_io1h
argument_list|,
name|off
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|malo_attach
parameter_list|(
name|uint16_t
name|devid
parameter_list|,
name|struct
name|malo_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|malo_hal
modifier|*
name|mh
decl_stmt|;
name|uint8_t
name|bands
decl_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|malo_ifp
operator|=
name|if_alloc
argument_list|(
name|IFT_IEEE80211
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|malo_dev
argument_list|,
literal|"can not if_alloc()\n"
argument_list|)
expr_stmt|;
return|return
name|ENOSPC
return|;
block|}
name|ic
operator|=
name|ifp
operator|->
name|if_l2com
expr_stmt|;
name|MALO_LOCK_INIT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* set these up early for if_printf use */
name|if_initname
argument_list|(
name|ifp
argument_list|,
name|device_get_name
argument_list|(
name|sc
operator|->
name|malo_dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|malo_dev
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * NB: get mac address from hardware directly here before we set DMAs 	 * for HAL because we don't want to disturb operations of HAL at BAR 1. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IEEE80211_ADDR_LEN
condition|;
name|i
operator|++
control|)
block|{
comment|/* XXX remove a magic number but we don't have documents.  */
name|ic
operator|->
name|ic_myaddr
index|[
name|i
index|]
operator|=
name|malo_bar1_read1
argument_list|(
name|sc
argument_list|,
literal|0xa528
operator|+
name|i
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
name|mh
operator|=
name|malo_hal_attach
argument_list|(
name|sc
operator|->
name|malo_dev
argument_list|,
name|devid
argument_list|,
name|sc
operator|->
name|malo_io1h
argument_list|,
name|sc
operator|->
name|malo_io1t
argument_list|,
name|sc
operator|->
name|malo_dmat
argument_list|)
expr_stmt|;
if|if
condition|(
name|mh
operator|==
name|NULL
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"unable to attach HAL\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|sc
operator|->
name|malo_mh
operator|=
name|mh
expr_stmt|;
comment|/* 	 * Load firmware so we can get setup.  We arbitrarily pick station 	 * firmware; we'll re-load firmware as needed so setting up 	 * the wrong mode isn't a big deal. 	 */
name|error
operator|=
name|malo_hal_fwload
argument_list|(
name|mh
argument_list|,
literal|"malo8335-h"
argument_list|,
literal|"malo8335-m"
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"unable to setup firmware\n"
argument_list|)
expr_stmt|;
goto|goto
name|bad1
goto|;
block|}
comment|/* XXX gethwspecs() extracts correct informations?  not maybe!  */
name|error
operator|=
name|malo_hal_gethwspecs
argument_list|(
name|mh
argument_list|,
operator|&
name|sc
operator|->
name|malo_hwspecs
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"unable to fetch h/w specs\n"
argument_list|)
expr_stmt|;
goto|goto
name|bad1
goto|;
block|}
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|MALO_DEBUG_FW
argument_list|,
literal|"malo_hal_gethwspecs: hwversion 0x%x hostif 0x%x"
literal|"maxnum_wcb 0x%x maxnum_mcaddr 0x%x maxnum_tx_wcb 0x%x"
literal|"regioncode 0x%x num_antenna 0x%x fw_releasenum 0x%x"
literal|"wcbbase0 0x%x rxdesc_read 0x%x rxdesc_write 0x%x"
literal|"ul_fw_awakecookie 0x%x w[4] = %x %x %x %x"
argument_list|,
name|sc
operator|->
name|malo_hwspecs
operator|.
name|hwversion
argument_list|,
name|sc
operator|->
name|malo_hwspecs
operator|.
name|hostinterface
argument_list|,
name|sc
operator|->
name|malo_hwspecs
operator|.
name|maxnum_wcb
argument_list|,
name|sc
operator|->
name|malo_hwspecs
operator|.
name|maxnum_mcaddr
argument_list|,
name|sc
operator|->
name|malo_hwspecs
operator|.
name|maxnum_tx_wcb
argument_list|,
name|sc
operator|->
name|malo_hwspecs
operator|.
name|regioncode
argument_list|,
name|sc
operator|->
name|malo_hwspecs
operator|.
name|num_antenna
argument_list|,
name|sc
operator|->
name|malo_hwspecs
operator|.
name|fw_releasenum
argument_list|,
name|sc
operator|->
name|malo_hwspecs
operator|.
name|wcbbase0
argument_list|,
name|sc
operator|->
name|malo_hwspecs
operator|.
name|rxdesc_read
argument_list|,
name|sc
operator|->
name|malo_hwspecs
operator|.
name|rxdesc_write
argument_list|,
name|sc
operator|->
name|malo_hwspecs
operator|.
name|ul_fw_awakecookie
argument_list|,
name|sc
operator|->
name|malo_hwspecs
operator|.
name|wcbbase
index|[
literal|0
index|]
argument_list|,
name|sc
operator|->
name|malo_hwspecs
operator|.
name|wcbbase
index|[
literal|1
index|]
argument_list|,
name|sc
operator|->
name|malo_hwspecs
operator|.
name|wcbbase
index|[
literal|2
index|]
argument_list|,
name|sc
operator|->
name|malo_hwspecs
operator|.
name|wcbbase
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
comment|/* NB: firmware looks that it does not export regdomain info API.  */
name|bands
operator|=
literal|0
expr_stmt|;
name|setbit
argument_list|(
operator|&
name|bands
argument_list|,
name|IEEE80211_MODE_11B
argument_list|)
expr_stmt|;
name|setbit
argument_list|(
operator|&
name|bands
argument_list|,
name|IEEE80211_MODE_11G
argument_list|)
expr_stmt|;
name|ieee80211_init_channels
argument_list|(
name|ic
argument_list|,
name|NULL
argument_list|,
operator|&
name|bands
argument_list|)
expr_stmt|;
name|sc
operator|->
name|malo_txantenna
operator|=
literal|0x2
expr_stmt|;
comment|/* h/w default */
name|sc
operator|->
name|malo_rxantenna
operator|=
literal|0xffff
expr_stmt|;
comment|/* h/w default */
comment|/* 	 * Allocate tx + rx descriptors and populate the lists. 	 * We immediately push the information to the firmware 	 * as otherwise it gets upset. 	 */
name|error
operator|=
name|malo_dma_setup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"failed to setup descriptors: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|bad1
goto|;
block|}
name|error
operator|=
name|malo_setup_hwdma
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* push to firmware */
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
comment|/* NB: malo_setupdma prints msg */
goto|goto
name|bad1
goto|;
name|sc
operator|->
name|malo_tq
operator|=
name|taskqueue_create_fast
argument_list|(
literal|"malo_taskq"
argument_list|,
name|M_NOWAIT
argument_list|,
name|taskqueue_thread_enqueue
argument_list|,
operator|&
name|sc
operator|->
name|malo_tq
argument_list|)
expr_stmt|;
name|taskqueue_start_threads
argument_list|(
operator|&
name|sc
operator|->
name|malo_tq
argument_list|,
literal|1
argument_list|,
name|PI_NET
argument_list|,
literal|"%s taskq"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|sc
operator|->
name|malo_rxtask
argument_list|,
literal|0
argument_list|,
name|malo_rx_proc
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|sc
operator|->
name|malo_txtask
argument_list|,
literal|0
argument_list|,
name|malo_tx_proc
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_softc
operator|=
name|sc
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_SIMPLEX
operator||
name|IFF_BROADCAST
operator||
name|IFF_MULTICAST
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|malo_start
expr_stmt|;
name|ifp
operator|->
name|if_watchdog
operator|=
name|malo_watchdog
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|malo_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|malo_init
expr_stmt|;
name|IFQ_SET_MAXLEN
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|IFQ_MAXLEN
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_drv_maxlen
operator|=
name|IFQ_MAXLEN
expr_stmt|;
name|IFQ_SET_READY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_ifp
operator|=
name|ifp
expr_stmt|;
comment|/* XXX not right but it's not used anywhere important */
name|ic
operator|->
name|ic_phytype
operator|=
name|IEEE80211_T_OFDM
expr_stmt|;
name|ic
operator|->
name|ic_opmode
operator|=
name|IEEE80211_M_STA
expr_stmt|;
name|ic
operator|->
name|ic_caps
operator|=
name|IEEE80211_C_BGSCAN
comment|/* capable of bg scanning */
operator||
name|IEEE80211_C_MONITOR
comment|/* monitor mode */
operator||
name|IEEE80211_C_SHPREAMBLE
comment|/* short preamble supported */
operator||
name|IEEE80211_C_SHSLOT
comment|/* short slot time supported */
operator||
name|IEEE80211_C_TXPMGT
comment|/* capable of txpow mgt */
operator||
name|IEEE80211_C_WPA
comment|/* capable of WPA1+WPA2 */
expr_stmt|;
comment|/* 	 * Transmit requires space in the packet for a special format transmit 	 * record and optional padding between this record and the payload. 	 * Ask the net80211 layer to arrange this when encapsulating 	 * packets so we can add it efficiently.  	 */
name|ic
operator|->
name|ic_headroom
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|malo_txrec
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_frame
argument_list|)
expr_stmt|;
comment|/* get mac address from hardware */
name|IEEE80211_ADDR_COPY
argument_list|(
name|ic
operator|->
name|ic_myaddr
argument_list|,
name|sc
operator|->
name|malo_hwspecs
operator|.
name|macaddr
argument_list|)
expr_stmt|;
comment|/* call MI attach routine. */
name|ieee80211_ifattach
argument_list|(
name|ic
argument_list|)
expr_stmt|;
comment|/* override default methods */
name|ic
operator|->
name|ic_vap_create
operator|=
name|malo_vap_create
expr_stmt|;
name|ic
operator|->
name|ic_vap_delete
operator|=
name|malo_vap_delete
expr_stmt|;
name|ic
operator|->
name|ic_raw_xmit
operator|=
name|malo_raw_xmit
expr_stmt|;
name|ic
operator|->
name|ic_updateslot
operator|=
name|malo_updateslot
expr_stmt|;
name|ic
operator|->
name|ic_scan_start
operator|=
name|malo_scan_start
expr_stmt|;
name|ic
operator|->
name|ic_scan_end
operator|=
name|malo_scan_end
expr_stmt|;
name|ic
operator|->
name|ic_set_channel
operator|=
name|malo_set_channel
expr_stmt|;
name|sc
operator|->
name|malo_invalid
operator|=
literal|0
expr_stmt|;
comment|/* ready to go, enable int handling */
name|malo_bpfattach
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Setup dynamic sysctl's. 	 */
name|malo_sysctlattach
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|ieee80211_announce
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|malo_announce
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|bad1
label|:
name|malo_hal_detach
argument_list|(
name|mh
argument_list|)
expr_stmt|;
name|bad
label|:
name|if_free
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|sc
operator|->
name|malo_invalid
operator|=
literal|1
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|ieee80211vap
modifier|*
name|malo_vap_create
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
specifier|const
name|char
name|name
index|[
name|IFNAMSIZ
index|]
parameter_list|,
name|int
name|unit
parameter_list|,
name|int
name|opmode
parameter_list|,
name|int
name|flags
parameter_list|,
specifier|const
name|uint8_t
name|bssid
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|,
specifier|const
name|uint8_t
name|mac
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|ic
operator|->
name|ic_ifp
decl_stmt|;
name|struct
name|malo_vap
modifier|*
name|mvp
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
decl_stmt|;
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|ic
operator|->
name|ic_vaps
argument_list|)
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"multiple vaps not supported\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
switch|switch
condition|(
name|opmode
condition|)
block|{
case|case
name|IEEE80211_M_STA
case|:
if|if
condition|(
name|opmode
operator|==
name|IEEE80211_M_STA
condition|)
name|flags
operator||=
name|IEEE80211_CLONE_NOBEACONS
expr_stmt|;
comment|/* fall thru... */
case|case
name|IEEE80211_M_MONITOR
case|:
break|break;
default|default:
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"%s mode not supported\n"
argument_list|,
name|ieee80211_opmode_name
index|[
name|opmode
index|]
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
comment|/* unsupported */
block|}
name|mvp
operator|=
operator|(
expr|struct
name|malo_vap
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|malo_vap
argument_list|)
argument_list|,
name|M_80211_VAP
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|mvp
operator|==
name|NULL
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"cannot allocate vap state block\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|vap
operator|=
operator|&
name|mvp
operator|->
name|malo_vap
expr_stmt|;
name|ieee80211_vap_setup
argument_list|(
name|ic
argument_list|,
name|vap
argument_list|,
name|name
argument_list|,
name|unit
argument_list|,
name|opmode
argument_list|,
name|flags
argument_list|,
name|bssid
argument_list|,
name|mac
argument_list|)
expr_stmt|;
comment|/* override state transition machine */
name|mvp
operator|->
name|malo_newstate
operator|=
name|vap
operator|->
name|iv_newstate
expr_stmt|;
name|vap
operator|->
name|iv_newstate
operator|=
name|malo_newstate
expr_stmt|;
comment|/* complete setup */
name|ieee80211_vap_attach
argument_list|(
name|vap
argument_list|,
name|ieee80211_media_change
argument_list|,
name|ieee80211_media_status
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_opmode
operator|=
name|opmode
expr_stmt|;
return|return
name|vap
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|malo_vap_delete
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
name|struct
name|malo_vap
modifier|*
name|mvp
init|=
name|MALO_VAP
argument_list|(
name|vap
argument_list|)
decl_stmt|;
name|ieee80211_vap_detach
argument_list|(
name|vap
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mvp
argument_list|,
name|M_80211_VAP
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|malo_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|malo_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|malo_hal
modifier|*
name|mh
init|=
name|sc
operator|->
name|malo_mh
decl_stmt|;
name|uint32_t
name|status
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|malo_invalid
condition|)
block|{
comment|/* 		 * The hardware is not ready/present, don't touch anything. 		 * Note this can happen early on if the IRQ is shared. 		 */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|MALO_DEBUG_ANY
argument_list|,
literal|"%s: invalid; ignored\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|FILTER_STRAY
operator|)
return|;
block|}
comment|/* 	 * Figure out the reason(s) for the interrupt. 	 */
name|malo_hal_getisr
argument_list|(
name|mh
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
comment|/* NB: clears ISR too */
if|if
condition|(
name|status
operator|==
literal|0
condition|)
comment|/* must be a shared irq */
return|return
operator|(
name|FILTER_STRAY
operator|)
return|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|MALO_DEBUG_INTR
argument_list|,
literal|"%s: status 0x%x imask 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|status
argument_list|,
name|sc
operator|->
name|malo_imask
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|MALO_A2HRIC_BIT_RX_RDY
condition|)
name|taskqueue_enqueue_fast
argument_list|(
name|sc
operator|->
name|malo_tq
argument_list|,
operator|&
name|sc
operator|->
name|malo_rxtask
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|MALO_A2HRIC_BIT_TX_DONE
condition|)
name|taskqueue_enqueue_fast
argument_list|(
name|sc
operator|->
name|malo_tq
argument_list|,
operator|&
name|sc
operator|->
name|malo_txtask
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|MALO_A2HRIC_BIT_OPC_DONE
condition|)
name|malo_hal_cmddone
argument_list|(
name|mh
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|MALO_A2HRIC_BIT_MAC_EVENT
condition|)
empty_stmt|;
if|if
condition|(
name|status
operator|&
name|MALO_A2HRIC_BIT_RX_PROBLEM
condition|)
empty_stmt|;
if|if
condition|(
name|status
operator|&
name|MALO_A2HRIC_BIT_ICV_ERROR
condition|)
block|{
comment|/* TKIP ICV error */
name|sc
operator|->
name|malo_stats
operator|.
name|mst_rx_badtkipicv
operator|++
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|MALO_DEBUG
if|if
condition|(
operator|(
operator|(
name|status
operator||
name|sc
operator|->
name|malo_imask
operator|)
operator|^
name|sc
operator|->
name|malo_imask
operator|)
operator|!=
literal|0
condition|)
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|MALO_DEBUG_INTR
argument_list|,
literal|"%s: can't handle interrupt status 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|status
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|FILTER_HANDLED
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|malo_load_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nsegs
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|bus_addr_t
modifier|*
name|paddr
init|=
operator|(
name|bus_addr_t
operator|*
operator|)
name|arg
decl_stmt|;
name|KASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|,
operator|(
literal|"error %u on bus_dma callback"
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
operator|*
name|paddr
operator|=
name|segs
operator|->
name|ds_addr
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|malo_desc_setup
parameter_list|(
name|struct
name|malo_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|malo_descdma
modifier|*
name|dd
parameter_list|,
name|int
name|nbuf
parameter_list|,
name|size_t
name|bufsize
parameter_list|,
name|int
name|ndesc
parameter_list|,
name|size_t
name|descsize
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|malo_ifp
decl_stmt|;
name|uint8_t
modifier|*
name|ds
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|MALO_DEBUG_RESET
argument_list|,
literal|"%s: %s DMA: %u bufs (%ju) %u desc/buf (%ju)\n"
argument_list|,
name|__func__
argument_list|,
name|name
argument_list|,
name|nbuf
argument_list|,
operator|(
name|uintmax_t
operator|)
name|bufsize
argument_list|,
name|ndesc
argument_list|,
operator|(
name|uintmax_t
operator|)
name|descsize
argument_list|)
expr_stmt|;
name|dd
operator|->
name|dd_name
operator|=
name|name
expr_stmt|;
name|dd
operator|->
name|dd_desc_len
operator|=
name|nbuf
operator|*
name|ndesc
operator|*
name|descsize
expr_stmt|;
comment|/* 	 * Setup DMA descriptor area. 	 */
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|sc
operator|->
name|malo_dev
argument_list|)
argument_list|,
comment|/* parent */
name|PAGE_SIZE
argument_list|,
literal|0
argument_list|,
comment|/* alignment, bounds */
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|dd
operator|->
name|dd_desc_len
argument_list|,
comment|/* maxsize */
literal|1
argument_list|,
comment|/* nsegments */
name|dd
operator|->
name|dd_desc_len
argument_list|,
comment|/* maxsegsize */
name|BUS_DMA_ALLOCNOW
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
comment|/* lockfunc */
name|NULL
argument_list|,
comment|/* lockarg */
operator|&
name|dd
operator|->
name|dd_dmat
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"cannot allocate %s DMA tag\n"
argument_list|,
name|dd
operator|->
name|dd_name
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* allocate descriptors */
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|dd
operator|->
name|dd_dmat
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|dd
operator|->
name|dd_dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"unable to create dmamap for %s descriptors, "
literal|"error %u\n"
argument_list|,
name|dd
operator|->
name|dd_name
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail0
goto|;
block|}
name|error
operator|=
name|bus_dmamem_alloc
argument_list|(
name|dd
operator|->
name|dd_dmat
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|dd
operator|->
name|dd_desc
argument_list|,
name|BUS_DMA_NOWAIT
operator||
name|BUS_DMA_COHERENT
argument_list|,
operator|&
name|dd
operator|->
name|dd_dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"unable to alloc memory for %u %s descriptors, "
literal|"error %u\n"
argument_list|,
name|nbuf
operator|*
name|ndesc
argument_list|,
name|dd
operator|->
name|dd_name
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|dd
operator|->
name|dd_dmat
argument_list|,
name|dd
operator|->
name|dd_dmamap
argument_list|,
name|dd
operator|->
name|dd_desc
argument_list|,
name|dd
operator|->
name|dd_desc_len
argument_list|,
name|malo_load_cb
argument_list|,
operator|&
name|dd
operator|->
name|dd_desc_paddr
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"unable to map %s descriptors, error %u\n"
argument_list|,
name|dd
operator|->
name|dd_name
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail2
goto|;
block|}
name|ds
operator|=
name|dd
operator|->
name|dd_desc
expr_stmt|;
name|memset
argument_list|(
name|ds
argument_list|,
literal|0
argument_list|,
name|dd
operator|->
name|dd_desc_len
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|MALO_DEBUG_RESET
argument_list|,
literal|"%s: %s DMA map: %p (%lu) -> %p (%lu)\n"
argument_list|,
name|__func__
argument_list|,
name|dd
operator|->
name|dd_name
argument_list|,
name|ds
argument_list|,
operator|(
name|u_long
operator|)
name|dd
operator|->
name|dd_desc_len
argument_list|,
operator|(
name|caddr_t
operator|)
name|dd
operator|->
name|dd_desc_paddr
argument_list|,
comment|/*XXX*/
operator|(
name|u_long
operator|)
name|dd
operator|->
name|dd_desc_len
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|fail2
label|:
name|bus_dmamem_free
argument_list|(
name|dd
operator|->
name|dd_dmat
argument_list|,
name|dd
operator|->
name|dd_desc
argument_list|,
name|dd
operator|->
name|dd_dmamap
argument_list|)
expr_stmt|;
name|fail1
label|:
name|bus_dmamap_destroy
argument_list|(
name|dd
operator|->
name|dd_dmat
argument_list|,
name|dd
operator|->
name|dd_dmamap
argument_list|)
expr_stmt|;
name|fail0
label|:
name|bus_dma_tag_destroy
argument_list|(
name|dd
operator|->
name|dd_dmat
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|dd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dd
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_define
define|#
directive|define
name|DS2PHYS
parameter_list|(
name|_dd
parameter_list|,
name|_ds
parameter_list|)
define|\
value|((_dd)->dd_desc_paddr + ((caddr_t)(_ds) - (caddr_t)(_dd)->dd_desc))
end_define

begin_function
specifier|static
name|int
name|malo_rxdma_setup
parameter_list|(
name|struct
name|malo_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|malo_ifp
decl_stmt|;
name|int
name|error
decl_stmt|,
name|bsize
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|malo_rxbuf
modifier|*
name|bf
decl_stmt|;
name|struct
name|malo_rxdesc
modifier|*
name|ds
decl_stmt|;
name|error
operator|=
name|malo_desc_setup
argument_list|(
name|sc
argument_list|,
literal|"rx"
argument_list|,
operator|&
name|sc
operator|->
name|malo_rxdma
argument_list|,
name|malo_rxbuf
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|malo_rxbuf
argument_list|)
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|malo_rxdesc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
name|error
return|;
comment|/* 	 * Allocate rx buffers and set them up. 	 */
name|bsize
operator|=
name|malo_rxbuf
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|malo_rxbuf
argument_list|)
expr_stmt|;
name|bf
operator|=
name|malloc
argument_list|(
name|bsize
argument_list|,
name|M_MALODEV
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf
operator|==
name|NULL
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"malloc of %u rx buffers failed\n"
argument_list|,
name|bsize
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|sc
operator|->
name|malo_rxdma
operator|.
name|dd_bufptr
operator|=
name|bf
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|malo_rxbuf
argument_list|)
expr_stmt|;
name|ds
operator|=
name|sc
operator|->
name|malo_rxdma
operator|.
name|dd_desc
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|malo_rxbuf
condition|;
name|i
operator|++
operator|,
name|bf
operator|++
operator|,
name|ds
operator|++
control|)
block|{
name|bf
operator|->
name|bf_desc
operator|=
name|ds
expr_stmt|;
name|bf
operator|->
name|bf_daddr
operator|=
name|DS2PHYS
argument_list|(
operator|&
name|sc
operator|->
name|malo_rxdma
argument_list|,
name|ds
argument_list|)
expr_stmt|;
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|sc
operator|->
name|malo_dmat
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|bf
operator|->
name|bf_dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"%s: unable to dmamap for rx buffer, "
literal|"error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* NB: tail is intentional to preserve descriptor order */
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|malo_rxbuf
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|malo_txdma_setup
parameter_list|(
name|struct
name|malo_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|malo_txq
modifier|*
name|txq
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|malo_ifp
decl_stmt|;
name|int
name|error
decl_stmt|,
name|bsize
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|malo_txbuf
modifier|*
name|bf
decl_stmt|;
name|struct
name|malo_txdesc
modifier|*
name|ds
decl_stmt|;
name|error
operator|=
name|malo_desc_setup
argument_list|(
name|sc
argument_list|,
literal|"tx"
argument_list|,
operator|&
name|txq
operator|->
name|dma
argument_list|,
name|malo_txbuf
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|malo_txbuf
argument_list|)
argument_list|,
name|MALO_TXDESC
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|malo_txdesc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
name|error
return|;
comment|/* allocate and setup tx buffers */
name|bsize
operator|=
name|malo_txbuf
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|malo_txbuf
argument_list|)
expr_stmt|;
name|bf
operator|=
name|malloc
argument_list|(
name|bsize
argument_list|,
name|M_MALODEV
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf
operator|==
name|NULL
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"malloc of %u tx buffers failed\n"
argument_list|,
name|malo_txbuf
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|txq
operator|->
name|dma
operator|.
name|dd_bufptr
operator|=
name|bf
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|txq
operator|->
name|free
argument_list|)
expr_stmt|;
name|txq
operator|->
name|nfree
operator|=
literal|0
expr_stmt|;
name|ds
operator|=
name|txq
operator|->
name|dma
operator|.
name|dd_desc
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|malo_txbuf
condition|;
name|i
operator|++
operator|,
name|bf
operator|++
operator|,
name|ds
operator|+=
name|MALO_TXDESC
control|)
block|{
name|bf
operator|->
name|bf_desc
operator|=
name|ds
expr_stmt|;
name|bf
operator|->
name|bf_daddr
operator|=
name|DS2PHYS
argument_list|(
operator|&
name|txq
operator|->
name|dma
argument_list|,
name|ds
argument_list|)
expr_stmt|;
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|sc
operator|->
name|malo_dmat
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|bf
operator|->
name|bf_dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"unable to create dmamap for tx "
literal|"buffer %u, error %u\n"
argument_list|,
name|i
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|txq
operator|->
name|free
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
name|txq
operator|->
name|nfree
operator|++
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|malo_desc_cleanup
parameter_list|(
name|struct
name|malo_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|malo_descdma
modifier|*
name|dd
parameter_list|)
block|{
name|bus_dmamap_unload
argument_list|(
name|dd
operator|->
name|dd_dmat
argument_list|,
name|dd
operator|->
name|dd_dmamap
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|dd
operator|->
name|dd_dmat
argument_list|,
name|dd
operator|->
name|dd_desc
argument_list|,
name|dd
operator|->
name|dd_dmamap
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|dd
operator|->
name|dd_dmat
argument_list|,
name|dd
operator|->
name|dd_dmamap
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|dd
operator|->
name|dd_dmat
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|dd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dd
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|malo_rxdma_cleanup
parameter_list|(
name|struct
name|malo_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|malo_rxbuf
modifier|*
name|bf
decl_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|bf
argument_list|,
argument|&sc->malo_rxbuf
argument_list|,
argument|bf_list
argument_list|)
block|{
if|if
condition|(
name|bf
operator|->
name|bf_m
operator|!=
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|bf
operator|->
name|bf_m
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_m
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|bf
operator|->
name|bf_dmamap
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|malo_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_dmamap
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|STAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|malo_rxbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|malo_rxdma
operator|.
name|dd_bufptr
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|sc
operator|->
name|malo_rxdma
operator|.
name|dd_bufptr
argument_list|,
name|M_MALODEV
argument_list|)
expr_stmt|;
name|sc
operator|->
name|malo_rxdma
operator|.
name|dd_bufptr
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|malo_rxdma
operator|.
name|dd_desc_len
operator|!=
literal|0
condition|)
name|malo_desc_cleanup
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|malo_rxdma
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|malo_txdma_cleanup
parameter_list|(
name|struct
name|malo_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|malo_txq
modifier|*
name|txq
parameter_list|)
block|{
name|struct
name|malo_txbuf
modifier|*
name|bf
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|bf
argument_list|,
argument|&txq->free
argument_list|,
argument|bf_list
argument_list|)
block|{
if|if
condition|(
name|bf
operator|->
name|bf_m
operator|!=
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|bf
operator|->
name|bf_m
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_m
operator|=
name|NULL
expr_stmt|;
block|}
name|ni
operator|=
name|bf
operator|->
name|bf_node
expr_stmt|;
name|bf
operator|->
name|bf_node
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ni
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * Reclaim node reference. 			 */
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bf
operator|->
name|bf_dmamap
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|malo_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_dmamap
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|STAILQ_INIT
argument_list|(
operator|&
name|txq
operator|->
name|free
argument_list|)
expr_stmt|;
name|txq
operator|->
name|nfree
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|txq
operator|->
name|dma
operator|.
name|dd_bufptr
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|txq
operator|->
name|dma
operator|.
name|dd_bufptr
argument_list|,
name|M_MALODEV
argument_list|)
expr_stmt|;
name|txq
operator|->
name|dma
operator|.
name|dd_bufptr
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|txq
operator|->
name|dma
operator|.
name|dd_desc_len
operator|!=
literal|0
condition|)
name|malo_desc_cleanup
argument_list|(
name|sc
argument_list|,
operator|&
name|txq
operator|->
name|dma
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|malo_dma_cleanup
parameter_list|(
name|struct
name|malo_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MALO_NUM_TX_QUEUES
condition|;
name|i
operator|++
control|)
name|malo_txdma_cleanup
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|malo_txq
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|malo_rxdma_cleanup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|malo_dma_setup
parameter_list|(
name|struct
name|malo_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
comment|/* rxdma initializing.  */
name|error
operator|=
name|malo_rxdma_setup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
name|error
return|;
comment|/* NB: we just have 1 tx queue now.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MALO_NUM_TX_QUEUES
condition|;
name|i
operator|++
control|)
block|{
name|error
operator|=
name|malo_txdma_setup
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|malo_txq
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|malo_dma_cleanup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|malo_txq_init
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|malo_txq
index|[
name|i
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|malo_hal_set_rxtxdma
parameter_list|(
name|struct
name|malo_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|malo_bar0_write4
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|malo_hwspecs
operator|.
name|rxdesc_read
argument_list|,
name|sc
operator|->
name|malo_hwdma
operator|.
name|rxdesc_read
argument_list|)
expr_stmt|;
name|malo_bar0_write4
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|malo_hwspecs
operator|.
name|rxdesc_write
argument_list|,
name|sc
operator|->
name|malo_hwdma
operator|.
name|rxdesc_read
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MALO_NUM_TX_QUEUES
condition|;
name|i
operator|++
control|)
block|{
name|malo_bar0_write4
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|malo_hwspecs
operator|.
name|wcbbase
index|[
name|i
index|]
argument_list|,
name|sc
operator|->
name|malo_hwdma
operator|.
name|wcbbase
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Inform firmware of our tx/rx dma setup.  The BAR 0 writes below are  * for compatibility with older firmware.  For current firmware we send  * this information with a cmd block via malo_hal_sethwdma.  */
end_comment

begin_function
specifier|static
name|int
name|malo_setup_hwdma
parameter_list|(
name|struct
name|malo_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|malo_txq
modifier|*
name|txq
decl_stmt|;
name|sc
operator|->
name|malo_hwdma
operator|.
name|rxdesc_read
operator|=
name|sc
operator|->
name|malo_rxdma
operator|.
name|dd_desc_paddr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MALO_NUM_TX_QUEUES
condition|;
name|i
operator|++
control|)
block|{
name|txq
operator|=
operator|&
name|sc
operator|->
name|malo_txq
index|[
name|i
index|]
expr_stmt|;
name|sc
operator|->
name|malo_hwdma
operator|.
name|wcbbase
index|[
name|i
index|]
operator|=
name|txq
operator|->
name|dma
operator|.
name|dd_desc_paddr
expr_stmt|;
block|}
name|sc
operator|->
name|malo_hwdma
operator|.
name|maxnum_txwcb
operator|=
name|malo_txbuf
expr_stmt|;
name|sc
operator|->
name|malo_hwdma
operator|.
name|maxnum_wcb
operator|=
name|MALO_NUM_TX_QUEUES
expr_stmt|;
name|malo_hal_set_rxtxdma
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|malo_txq_init
parameter_list|(
name|struct
name|malo_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|malo_txq
modifier|*
name|txq
parameter_list|,
name|int
name|qnum
parameter_list|)
block|{
name|struct
name|malo_txbuf
modifier|*
name|bf
decl_stmt|,
modifier|*
name|bn
decl_stmt|;
name|struct
name|malo_txdesc
modifier|*
name|ds
decl_stmt|;
name|MALO_TXQ_LOCK_INIT
argument_list|(
name|sc
argument_list|,
name|txq
argument_list|)
expr_stmt|;
name|txq
operator|->
name|qnum
operator|=
name|qnum
expr_stmt|;
name|txq
operator|->
name|txpri
operator|=
literal|0
expr_stmt|;
comment|/* XXX */
name|STAILQ_FOREACH
argument_list|(
argument|bf
argument_list|,
argument|&txq->free
argument_list|,
argument|bf_list
argument_list|)
block|{
name|bf
operator|->
name|bf_txq
operator|=
name|txq
expr_stmt|;
name|ds
operator|=
name|bf
operator|->
name|bf_desc
expr_stmt|;
name|bn
operator|=
name|STAILQ_NEXT
argument_list|(
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|bn
operator|==
name|NULL
condition|)
name|bn
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|txq
operator|->
name|free
argument_list|)
expr_stmt|;
name|ds
operator|->
name|physnext
operator|=
name|htole32
argument_list|(
name|bn
operator|->
name|bf_daddr
argument_list|)
expr_stmt|;
block|}
name|STAILQ_INIT
argument_list|(
operator|&
name|txq
operator|->
name|active
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Reclaim resources for a setup queue.  */
end_comment

begin_function
specifier|static
name|void
name|malo_tx_cleanupq
parameter_list|(
name|struct
name|malo_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|malo_txq
modifier|*
name|txq
parameter_list|)
block|{
comment|/* XXX hal work? */
name|MALO_TXQ_LOCK_DESTROY
argument_list|(
name|txq
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allocate a tx buffer for sending a frame.  */
end_comment

begin_function
specifier|static
name|struct
name|malo_txbuf
modifier|*
name|malo_getbuf
parameter_list|(
name|struct
name|malo_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|malo_txq
modifier|*
name|txq
parameter_list|)
block|{
name|struct
name|malo_txbuf
modifier|*
name|bf
decl_stmt|;
name|MALO_TXQ_LOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|bf
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|txq
operator|->
name|free
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf
operator|!=
name|NULL
condition|)
block|{
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|txq
operator|->
name|free
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
name|txq
operator|->
name|nfree
operator|--
expr_stmt|;
block|}
name|MALO_TXQ_UNLOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf
operator|==
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|MALO_DEBUG_XMIT
argument_list|,
literal|"%s: out of xmit buffers on q %d\n"
argument_list|,
name|__func__
argument_list|,
name|txq
operator|->
name|qnum
argument_list|)
expr_stmt|;
name|sc
operator|->
name|malo_stats
operator|.
name|mst_tx_qstop
operator|++
expr_stmt|;
block|}
return|return
name|bf
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|malo_tx_dmasetup
parameter_list|(
name|struct
name|malo_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|malo_txbuf
modifier|*
name|bf
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* 	 * Load the DMA map so any coalescing is done.  This also calculates 	 * the number of descriptors we need. 	 */
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|sc
operator|->
name|malo_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|,
name|m0
argument_list|,
name|bf
operator|->
name|bf_segs
argument_list|,
operator|&
name|bf
operator|->
name|bf_nseg
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EFBIG
condition|)
block|{
comment|/* XXX packet requires too many descriptors */
name|bf
operator|->
name|bf_nseg
operator|=
name|MALO_TXDESC
operator|+
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|sc
operator|->
name|malo_stats
operator|.
name|mst_tx_busdma
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* 	 * Discard null packets and check for packets that require too many 	 * TX descriptors.  We try to convert the latter to a cluster. 	 */
if|if
condition|(
name|error
operator|==
name|EFBIG
condition|)
block|{
comment|/* too many desc's, linearize */
name|sc
operator|->
name|malo_stats
operator|.
name|mst_tx_linear
operator|++
expr_stmt|;
name|m
operator|=
name|m_defrag
argument_list|(
name|m0
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|malo_stats
operator|.
name|mst_tx_nombuf
operator|++
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|m0
operator|=
name|m
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|sc
operator|->
name|malo_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|,
name|m0
argument_list|,
name|bf
operator|->
name|bf_segs
argument_list|,
operator|&
name|bf
operator|->
name|bf_nseg
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|sc
operator|->
name|malo_stats
operator|.
name|mst_tx_busdma
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|KASSERT
argument_list|(
name|bf
operator|->
name|bf_nseg
operator|<=
name|MALO_TXDESC
argument_list|,
operator|(
literal|"too many segments after defrag; nseg %u"
operator|,
name|bf
operator|->
name|bf_nseg
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bf
operator|->
name|bf_nseg
operator|==
literal|0
condition|)
block|{
comment|/* null packet, discard */
name|sc
operator|->
name|malo_stats
operator|.
name|mst_tx_nodata
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
block|}
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|MALO_DEBUG_XMIT
argument_list|,
literal|"%s: m %p len %u\n"
argument_list|,
name|__func__
argument_list|,
name|m0
argument_list|,
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|malo_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_m
operator|=
name|m0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|MALO_DEBUG
end_ifdef

begin_function
specifier|static
name|void
name|malo_printrxbuf
parameter_list|(
specifier|const
name|struct
name|malo_rxbuf
modifier|*
name|bf
parameter_list|,
name|u_int
name|ix
parameter_list|)
block|{
specifier|const
name|struct
name|malo_rxdesc
modifier|*
name|ds
init|=
name|bf
operator|->
name|bf_desc
decl_stmt|;
name|uint32_t
name|status
init|=
name|le32toh
argument_list|(
name|ds
operator|->
name|status
argument_list|)
decl_stmt|;
name|printf
argument_list|(
literal|"R[%2u] (DS.V:%p DS.P:%p) NEXT:%08x DATA:%08x RC:%02x%s\n"
literal|"      STAT:%02x LEN:%04x SNR:%02x NF:%02x CHAN:%02x"
literal|" RATE:%02x QOS:%04x\n"
argument_list|,
name|ix
argument_list|,
name|ds
argument_list|,
operator|(
specifier|const
expr|struct
name|malo_desc
operator|*
operator|)
name|bf
operator|->
name|bf_daddr
argument_list|,
name|le32toh
argument_list|(
name|ds
operator|->
name|physnext
argument_list|)
argument_list|,
name|le32toh
argument_list|(
name|ds
operator|->
name|physbuffdata
argument_list|)
argument_list|,
name|ds
operator|->
name|rxcontrol
argument_list|,
name|ds
operator|->
name|rxcontrol
operator|!=
name|MALO_RXD_CTRL_DRIVER_OWN
condition|?
literal|""
else|:
operator|(
name|status
operator|&
name|MALO_RXD_STATUS_OK
operator|)
condition|?
literal|" *"
else|:
literal|" !"
argument_list|,
name|ds
operator|->
name|status
argument_list|,
name|le16toh
argument_list|(
name|ds
operator|->
name|pktlen
argument_list|)
argument_list|,
name|ds
operator|->
name|snr
argument_list|,
name|ds
operator|->
name|nf
argument_list|,
name|ds
operator|->
name|channel
argument_list|,
name|ds
operator|->
name|rate
argument_list|,
name|le16toh
argument_list|(
name|ds
operator|->
name|qosctrl
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|malo_printtxbuf
parameter_list|(
specifier|const
name|struct
name|malo_txbuf
modifier|*
name|bf
parameter_list|,
name|u_int
name|qnum
parameter_list|,
name|u_int
name|ix
parameter_list|)
block|{
specifier|const
name|struct
name|malo_txdesc
modifier|*
name|ds
init|=
name|bf
operator|->
name|bf_desc
decl_stmt|;
name|uint32_t
name|status
init|=
name|le32toh
argument_list|(
name|ds
operator|->
name|status
argument_list|)
decl_stmt|;
name|printf
argument_list|(
literal|"Q%u[%3u]"
argument_list|,
name|qnum
argument_list|,
name|ix
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" (DS.V:%p DS.P:%p)\n"
argument_list|,
name|ds
argument_list|,
operator|(
specifier|const
expr|struct
name|malo_txdesc
operator|*
operator|)
name|bf
operator|->
name|bf_daddr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    NEXT:%08x DATA:%08x LEN:%04x STAT:%08x%s\n"
argument_list|,
name|le32toh
argument_list|(
name|ds
operator|->
name|physnext
argument_list|)
argument_list|,
name|le32toh
argument_list|(
name|ds
operator|->
name|pktptr
argument_list|)
argument_list|,
name|le16toh
argument_list|(
name|ds
operator|->
name|pktlen
argument_list|)
argument_list|,
name|status
argument_list|,
name|status
operator|&
name|MALO_TXD_STATUS_USED
condition|?
literal|""
else|:
operator|(
name|status
operator|&
literal|3
operator|)
operator|!=
literal|0
condition|?
literal|" *"
else|:
literal|" !"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    RATE:%02x PRI:%x QOS:%04x SAP:%08x FORMAT:%04x\n"
argument_list|,
name|ds
operator|->
name|datarate
argument_list|,
name|ds
operator|->
name|txpriority
argument_list|,
name|le16toh
argument_list|(
name|ds
operator|->
name|qosctrl
argument_list|)
argument_list|,
name|le32toh
argument_list|(
name|ds
operator|->
name|sap_pktinfo
argument_list|)
argument_list|,
name|le16toh
argument_list|(
name|ds
operator|->
name|format
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|{ 		const uint8_t *cp = (const uint8_t *) ds; 		int i; 		for (i = 0; i< sizeof(struct malo_txdesc); i++) { 			printf("%02x ", cp[i]); 			if (((i+1) % 16) == 0) 				printf("\n"); 		} 		printf("\n"); 	}
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MALO_DEBUG */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|malo_updatetxrate
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|int
name|rix
parameter_list|)
block|{
define|#
directive|define
name|N
parameter_list|(
name|x
parameter_list|)
value|(sizeof(x)/sizeof(x[0]))
specifier|static
specifier|const
name|int
name|ieeerates
index|[]
init|=
block|{
literal|2
block|,
literal|4
block|,
literal|11
block|,
literal|22
block|,
literal|44
block|,
literal|12
block|,
literal|18
block|,
literal|24
block|,
literal|36
block|,
literal|48
block|,
literal|96
block|,
literal|108
block|}
decl_stmt|;
if|if
condition|(
name|rix
operator|<
name|N
argument_list|(
name|ieeerates
argument_list|)
condition|)
name|ni
operator|->
name|ni_txrate
operator|=
name|ieeerates
index|[
name|rix
index|]
expr_stmt|;
undef|#
directive|undef
name|N
block|}
end_function

begin_function
specifier|static
name|int
name|malo_fix2rate
parameter_list|(
name|int
name|fix_rate
parameter_list|)
block|{
define|#
directive|define
name|N
parameter_list|(
name|x
parameter_list|)
value|(sizeof(x)/sizeof(x[0]))
specifier|static
specifier|const
name|int
name|rates
index|[]
init|=
block|{
literal|2
block|,
literal|4
block|,
literal|11
block|,
literal|22
block|,
literal|12
block|,
literal|18
block|,
literal|24
block|,
literal|36
block|,
literal|48
block|,
literal|96
block|,
literal|108
block|}
decl_stmt|;
return|return
operator|(
name|fix_rate
operator|<
name|N
argument_list|(
name|rates
argument_list|)
condition|?
name|rates
index|[
name|fix_rate
index|]
else|:
literal|0
operator|)
return|;
undef|#
directive|undef
name|N
block|}
end_function

begin_comment
comment|/* idiomatic shorthands: MS = mask+shift, SM = shift+mask */
end_comment

begin_define
define|#
directive|define
name|MS
parameter_list|(
name|v
parameter_list|,
name|x
parameter_list|)
value|(((v)& x)>> x##_S)
end_define

begin_define
define|#
directive|define
name|SM
parameter_list|(
name|v
parameter_list|,
name|x
parameter_list|)
value|(((v)<< x##_S)& x)
end_define

begin_comment
comment|/*  * Process completed xmit descriptors from the specified queue.  */
end_comment

begin_function
specifier|static
name|int
name|malo_tx_processq
parameter_list|(
name|struct
name|malo_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|malo_txq
modifier|*
name|txq
parameter_list|)
block|{
name|struct
name|malo_txbuf
modifier|*
name|bf
decl_stmt|;
name|struct
name|malo_txdesc
modifier|*
name|ds
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|int
name|nreaped
decl_stmt|;
name|uint32_t
name|status
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|MALO_DEBUG_TX_PROC
argument_list|,
literal|"%s: tx queue %u\n"
argument_list|,
name|__func__
argument_list|,
name|txq
operator|->
name|qnum
argument_list|)
expr_stmt|;
for|for
control|(
name|nreaped
operator|=
literal|0
init|;
condition|;
name|nreaped
operator|++
control|)
block|{
name|MALO_TXQ_LOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|bf
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|txq
operator|->
name|active
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf
operator|==
name|NULL
condition|)
block|{
name|MALO_TXQ_UNLOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
break|break;
block|}
name|ds
operator|=
name|bf
operator|->
name|bf_desc
expr_stmt|;
name|MALO_TXDESC_SYNC
argument_list|(
name|txq
argument_list|,
name|ds
argument_list|,
name|BUS_DMASYNC_POSTREAD
operator||
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|status
operator|&
name|htole32
argument_list|(
name|MALO_TXD_STATUS_FW_OWNED
argument_list|)
condition|)
block|{
name|MALO_TXQ_UNLOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
break|break;
block|}
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|txq
operator|->
name|active
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
name|MALO_TXQ_UNLOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MALO_DEBUG
if|if
condition|(
name|sc
operator|->
name|malo_debug
operator|&
name|MALO_DEBUG_XMIT_DESC
condition|)
name|malo_printtxbuf
argument_list|(
name|bf
argument_list|,
name|txq
operator|->
name|qnum
argument_list|,
name|nreaped
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ni
operator|=
name|bf
operator|->
name|bf_node
expr_stmt|;
if|if
condition|(
name|ni
operator|!=
name|NULL
condition|)
block|{
name|status
operator|=
name|le32toh
argument_list|(
name|ds
operator|->
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|MALO_TXD_STATUS_OK
condition|)
block|{
name|uint16_t
name|format
init|=
name|le16toh
argument_list|(
name|ds
operator|->
name|format
argument_list|)
decl_stmt|;
name|uint8_t
name|txant
init|=
name|MS
argument_list|(
name|format
argument_list|,
name|MALO_TXD_ANTENNA
argument_list|)
decl_stmt|;
name|sc
operator|->
name|malo_stats
operator|.
name|mst_ant_tx
index|[
name|txant
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|MALO_TXD_STATUS_OK_RETRY
condition|)
name|sc
operator|->
name|malo_stats
operator|.
name|mst_tx_retries
operator|++
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|MALO_TXD_STATUS_OK_MORE_RETRY
condition|)
name|sc
operator|->
name|malo_stats
operator|.
name|mst_tx_mretries
operator|++
expr_stmt|;
name|malo_updatetxrate
argument_list|(
name|ni
argument_list|,
name|ds
operator|->
name|datarate
argument_list|)
expr_stmt|;
name|sc
operator|->
name|malo_stats
operator|.
name|mst_tx_rate
operator|=
name|ds
operator|->
name|datarate
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|status
operator|&
name|MALO_TXD_STATUS_FAILED_LINK_ERROR
condition|)
name|sc
operator|->
name|malo_stats
operator|.
name|mst_tx_linkerror
operator|++
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|MALO_TXD_STATUS_FAILED_XRETRY
condition|)
name|sc
operator|->
name|malo_stats
operator|.
name|mst_tx_xretries
operator|++
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|MALO_TXD_STATUS_FAILED_AGING
condition|)
name|sc
operator|->
name|malo_stats
operator|.
name|mst_tx_aging
operator|++
expr_stmt|;
block|}
comment|/* 			 * Do any tx complete callback.  Note this must 			 * be done before releasing the node reference. 			 * XXX no way to figure out if frame was ACK'd 			 */
if|if
condition|(
name|bf
operator|->
name|bf_m
operator|->
name|m_flags
operator|&
name|M_TXCB
condition|)
block|{
comment|/* XXX strip fw len in case header inspected */
name|m_adj
argument_list|(
name|bf
operator|->
name|bf_m
argument_list|,
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
argument_list|)
expr_stmt|;
name|ieee80211_process_callback
argument_list|(
name|ni
argument_list|,
name|bf
operator|->
name|bf_m
argument_list|,
operator|(
name|status
operator|&
name|MALO_TXD_STATUS_OK
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * Reclaim reference to node. 			 * 			 * NB: the node may be reclaimed here if, for example 			 *     this is a DEAUTH message that was sent and the 			 *     node was timed out due to inactivity. 			 */
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
name|ds
operator|->
name|status
operator|=
name|htole32
argument_list|(
name|MALO_TXD_STATUS_IDLE
argument_list|)
expr_stmt|;
name|ds
operator|->
name|pktlen
operator|=
name|htole32
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|malo_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|malo_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|bf
operator|->
name|bf_m
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_m
operator|=
name|NULL
expr_stmt|;
name|bf
operator|->
name|bf_node
operator|=
name|NULL
expr_stmt|;
name|MALO_TXQ_LOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|txq
operator|->
name|free
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
name|txq
operator|->
name|nfree
operator|++
expr_stmt|;
name|MALO_TXQ_UNLOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
block|}
return|return
name|nreaped
return|;
block|}
end_function

begin_comment
comment|/*  * Deferred processing of transmit interrupt.  */
end_comment

begin_function
specifier|static
name|void
name|malo_tx_proc
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|npending
parameter_list|)
block|{
name|struct
name|malo_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|malo_ifp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|nreaped
decl_stmt|;
comment|/* 	 * Process each active queue. 	 */
name|nreaped
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MALO_NUM_TX_QUEUES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|STAILQ_EMPTY
argument_list|(
operator|&
name|sc
operator|->
name|malo_txq
index|[
name|i
index|]
operator|.
name|active
argument_list|)
condition|)
name|nreaped
operator|+=
name|malo_tx_processq
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|malo_txq
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nreaped
operator|!=
literal|0
condition|)
block|{
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
name|malo_start
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|malo_tx_start
parameter_list|(
name|struct
name|malo_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|malo_txbuf
modifier|*
name|bf
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|)
block|{
define|#
directive|define
name|IEEE80211_DIR_DSTODS
parameter_list|(
name|wh
parameter_list|)
define|\
value|((wh->i_fc[1]& IEEE80211_FC1_DIR_MASK) == IEEE80211_FC1_DIR_DSTODS)
define|#
directive|define
name|IS_DATA_FRAME
parameter_list|(
name|wh
parameter_list|)
define|\
value|((wh->i_fc[0]& (IEEE80211_FC0_TYPE_MASK)) == IEEE80211_FC0_TYPE_DATA)
name|int
name|error
decl_stmt|,
name|ismcast
decl_stmt|,
name|iswep
decl_stmt|;
name|int
name|copyhdrlen
decl_stmt|,
name|hdrlen
decl_stmt|,
name|pktlen
decl_stmt|;
name|struct
name|ieee80211_frame
modifier|*
name|wh
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|malo_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|malo_txdesc
modifier|*
name|ds
decl_stmt|;
name|struct
name|malo_txrec
modifier|*
name|tr
decl_stmt|;
name|struct
name|malo_txq
modifier|*
name|txq
decl_stmt|;
name|uint16_t
name|qos
decl_stmt|;
name|wh
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
name|iswep
operator|=
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator|&
name|IEEE80211_FC1_WEP
expr_stmt|;
name|ismcast
operator|=
name|IEEE80211_IS_MULTICAST
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|)
expr_stmt|;
name|copyhdrlen
operator|=
name|hdrlen
operator|=
name|ieee80211_anyhdrsize
argument_list|(
name|wh
argument_list|)
expr_stmt|;
name|pktlen
operator|=
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
if|if
condition|(
name|IEEE80211_QOS_HAS_SEQ
argument_list|(
name|wh
argument_list|)
condition|)
block|{
if|if
condition|(
name|IEEE80211_DIR_DSTODS
argument_list|(
name|wh
argument_list|)
condition|)
block|{
name|qos
operator|=
operator|*
operator|(
name|uint16_t
operator|*
operator|)
operator|(
operator|(
operator|(
expr|struct
name|ieee80211_qosframe_addr4
operator|*
operator|)
name|wh
operator|)
operator|->
name|i_qos
operator|)
expr_stmt|;
name|copyhdrlen
operator|-=
sizeof|sizeof
argument_list|(
name|qos
argument_list|)
expr_stmt|;
block|}
else|else
name|qos
operator|=
operator|*
operator|(
name|uint16_t
operator|*
operator|)
operator|(
operator|(
operator|(
expr|struct
name|ieee80211_qosframe
operator|*
operator|)
name|wh
operator|)
operator|->
name|i_qos
operator|)
expr_stmt|;
block|}
else|else
name|qos
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|iswep
condition|)
block|{
name|struct
name|ieee80211_key
modifier|*
name|k
decl_stmt|;
comment|/* 		 * Construct the 802.11 header+trailer for an encrypted 		 * frame. The only reason this can fail is because of an 		 * unknown or unsupported cipher/key type. 		 * 		 * NB: we do this even though the firmware will ignore 		 *     what we've done for WEP and TKIP as we need the 		 *     ExtIV filled in for CCMP and this also adjusts 		 *     the headers which simplifies our work below. 		 */
name|k
operator|=
name|ieee80211_crypto_encap
argument_list|(
name|ni
argument_list|,
name|m0
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * This can happen when the key is yanked after the 			 * frame was queued.  Just discard the frame; the 			 * 802.11 layer counts failures and provides 			 * debugging/diagnostics. 			 */
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
block|}
comment|/* 		 * Adjust the packet length for the crypto additions 		 * done during encap and any other bits that the f/w 		 * will add later on. 		 */
name|pktlen
operator|=
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
comment|/* packet header may have moved, reset our local pointer */
name|wh
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bpf_peers_present
argument_list|(
name|ifp
operator|->
name|if_bpf
argument_list|)
condition|)
block|{
name|sc
operator|->
name|malo_tx_th
operator|.
name|wt_flags
operator|=
literal|0
expr_stmt|;
comment|/* XXX */
if|if
condition|(
name|iswep
condition|)
name|sc
operator|->
name|malo_tx_th
operator|.
name|wt_flags
operator||=
name|IEEE80211_RADIOTAP_F_WEP
expr_stmt|;
name|sc
operator|->
name|malo_tx_th
operator|.
name|wt_txpower
operator|=
name|ni
operator|->
name|ni_txpower
expr_stmt|;
name|sc
operator|->
name|malo_tx_th
operator|.
name|wt_antenna
operator|=
name|sc
operator|->
name|malo_txantenna
expr_stmt|;
name|bpf_mtap2
argument_list|(
name|ifp
operator|->
name|if_bpf
argument_list|,
operator|&
name|sc
operator|->
name|malo_tx_th
argument_list|,
name|sc
operator|->
name|malo_tx_th_len
argument_list|,
name|m0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Copy up/down the 802.11 header; the firmware requires 	 * we present a 2-byte payload length followed by a 	 * 4-address header (w/o QoS), followed (optionally) by 	 * any WEP/ExtIV header (but only filled in for CCMP). 	 * We are assured the mbuf has sufficient headroom to 	 * prepend in-place by the setup of ic_headroom in 	 * malo_attach. 	 */
if|if
condition|(
name|hdrlen
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|malo_txrec
argument_list|)
condition|)
block|{
specifier|const
name|int
name|space
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|malo_txrec
argument_list|)
operator|-
name|hdrlen
decl_stmt|;
if|if
condition|(
name|M_LEADINGSPACE
argument_list|(
name|m0
argument_list|)
operator|<
name|space
condition|)
block|{
comment|/* NB: should never happen */
name|device_printf
argument_list|(
name|sc
operator|->
name|malo_dev
argument_list|,
literal|"not enough headroom, need %d found %zd, "
literal|"m_flags 0x%x m_len %d\n"
argument_list|,
name|space
argument_list|,
name|M_LEADINGSPACE
argument_list|(
name|m0
argument_list|)
argument_list|,
name|m0
operator|->
name|m_flags
argument_list|,
name|m0
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|ieee80211_dump_pkt
argument_list|(
name|ic
argument_list|,
name|mtod
argument_list|(
name|m0
argument_list|,
specifier|const
name|uint8_t
operator|*
argument_list|)
argument_list|,
name|m0
operator|->
name|m_len
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
comment|/* XXX stat */
return|return
name|EIO
return|;
block|}
name|M_PREPEND
argument_list|(
name|m0
argument_list|,
name|space
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
block|}
name|tr
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|malo_txrec
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|wh
operator|!=
operator|(
expr|struct
name|ieee80211_frame
operator|*
operator|)
operator|&
name|tr
operator|->
name|wh
condition|)
name|ovbcopy
argument_list|(
name|wh
argument_list|,
operator|&
name|tr
operator|->
name|wh
argument_list|,
name|hdrlen
argument_list|)
expr_stmt|;
comment|/* 	 * Note: the "firmware length" is actually the length of the fully 	 * formed "802.11 payload".  That is, it's everything except for 	 * the 802.11 header.  In particular this includes all crypto 	 * material including the MIC! 	 */
name|tr
operator|->
name|fwlen
operator|=
name|htole16
argument_list|(
name|pktlen
operator|-
name|hdrlen
argument_list|)
expr_stmt|;
comment|/* 	 * Load the DMA map so any coalescing is done.  This 	 * also calculates the number of descriptors we need. 	 */
name|error
operator|=
name|malo_tx_dmasetup
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|,
name|m0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
name|error
return|;
name|bf
operator|->
name|bf_node
operator|=
name|ni
expr_stmt|;
comment|/* NB: held reference */
name|m0
operator|=
name|bf
operator|->
name|bf_m
expr_stmt|;
comment|/* NB: may have changed */
name|tr
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|malo_txrec
operator|*
argument_list|)
expr_stmt|;
name|wh
operator|=
operator|(
expr|struct
name|ieee80211_frame
operator|*
operator|)
operator|&
name|tr
operator|->
name|wh
expr_stmt|;
comment|/* 	 * Formulate tx descriptor. 	 */
name|ds
operator|=
name|bf
operator|->
name|bf_desc
expr_stmt|;
name|txq
operator|=
name|bf
operator|->
name|bf_txq
expr_stmt|;
name|ds
operator|->
name|qosctrl
operator|=
name|qos
expr_stmt|;
comment|/* NB: already little-endian */
name|ds
operator|->
name|pktptr
operator|=
name|htole32
argument_list|(
name|bf
operator|->
name|bf_segs
index|[
literal|0
index|]
operator|.
name|ds_addr
argument_list|)
expr_stmt|;
name|ds
operator|->
name|pktlen
operator|=
name|htole16
argument_list|(
name|bf
operator|->
name|bf_segs
index|[
literal|0
index|]
operator|.
name|ds_len
argument_list|)
expr_stmt|;
comment|/* NB: pPhysNext setup once, don't touch */
name|ds
operator|->
name|datarate
operator|=
name|IS_DATA_FRAME
argument_list|(
name|wh
argument_list|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|ds
operator|->
name|sap_pktinfo
operator|=
literal|0
expr_stmt|;
name|ds
operator|->
name|format
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Select transmit rate. 	 */
switch|switch
condition|(
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|&
name|IEEE80211_FC0_TYPE_MASK
condition|)
block|{
case|case
name|IEEE80211_FC0_TYPE_MGT
case|:
name|sc
operator|->
name|malo_stats
operator|.
name|mst_tx_mgmt
operator|++
expr_stmt|;
comment|/* fall thru... */
case|case
name|IEEE80211_FC0_TYPE_CTL
case|:
name|ds
operator|->
name|txpriority
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|IEEE80211_FC0_TYPE_DATA
case|:
name|ds
operator|->
name|txpriority
operator|=
name|txq
operator|->
name|qnum
expr_stmt|;
break|break;
default|default:
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"bogus frame type 0x%x (%s)\n"
argument_list|,
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|&
name|IEEE80211_FC0_TYPE_MASK
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* XXX statistic */
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
block|}
ifdef|#
directive|ifdef
name|MALO_DEBUG
if|if
condition|(
name|IFF_DUMPPKTS_XMIT
argument_list|(
name|sc
argument_list|)
condition|)
name|ieee80211_dump_pkt
argument_list|(
name|ic
argument_list|,
name|mtod
argument_list|(
name|m0
argument_list|,
specifier|const
name|uint8_t
operator|*
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
argument_list|,
name|m0
operator|->
name|m_len
operator|-
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
argument_list|,
name|ds
operator|->
name|datarate
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|MALO_TXQ_LOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IS_DATA_FRAME
argument_list|(
name|wh
argument_list|)
condition|)
name|ds
operator|->
name|status
operator||=
name|htole32
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|ds
operator|->
name|status
operator||=
name|htole32
argument_list|(
name|MALO_TXD_STATUS_FW_OWNED
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|txq
operator|->
name|active
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
name|MALO_TXDESC_SYNC
argument_list|(
name|txq
argument_list|,
name|ds
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_opackets
operator|++
expr_stmt|;
name|ifp
operator|->
name|if_timer
operator|=
literal|5
expr_stmt|;
name|MALO_TXQ_UNLOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
undef|#
directive|undef
name|IEEE80211_DIR_DSTODS
block|}
end_function

begin_function
specifier|static
name|void
name|malo_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|malo_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|struct
name|malo_txq
modifier|*
name|txq
init|=
operator|&
name|sc
operator|->
name|malo_txq
index|[
literal|0
index|]
decl_stmt|;
name|struct
name|malo_txbuf
modifier|*
name|bf
init|=
name|NULL
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|nqueued
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
operator|||
name|sc
operator|->
name|malo_invalid
condition|)
return|return;
for|for
control|(
init|;
condition|;
control|)
block|{
name|IFQ_DRV_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
break|break;
name|ni
operator|=
operator|(
expr|struct
name|ieee80211_node
operator|*
operator|)
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
expr_stmt|;
name|bf
operator|=
name|malo_getbuf
argument_list|(
name|sc
argument_list|,
name|txq
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf
operator|==
name|NULL
condition|)
block|{
name|IFQ_DRV_PREPEND
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* XXX blocks other traffic */
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_OACTIVE
expr_stmt|;
name|sc
operator|->
name|malo_stats
operator|.
name|mst_tx_qstop
operator|++
expr_stmt|;
break|break;
block|}
comment|/* 		 * Encapsulate the packet in prep for transmission. 		 */
name|m
operator|=
name|ieee80211_encap
argument_list|(
name|ni
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|MALO_DEBUG_XMIT
argument_list|,
literal|"%s: encapsulation failure\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|sc
operator|->
name|malo_stats
operator|.
name|mst_tx_encap
operator|++
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 		 * Pass the frame to the h/w for transmission. 		 */
if|if
condition|(
name|malo_tx_start
argument_list|(
name|sc
argument_list|,
name|ni
argument_list|,
name|bf
argument_list|,
name|m
argument_list|)
condition|)
block|{
name|bad
label|:
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
if|if
condition|(
name|bf
operator|!=
name|NULL
condition|)
block|{
name|bf
operator|->
name|bf_m
operator|=
name|NULL
expr_stmt|;
name|bf
operator|->
name|bf_node
operator|=
name|NULL
expr_stmt|;
name|MALO_TXQ_LOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_HEAD
argument_list|(
operator|&
name|txq
operator|->
name|free
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
name|MALO_TXQ_UNLOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
block|}
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|nqueued
operator|++
expr_stmt|;
if|if
condition|(
name|nqueued
operator|>=
name|malo_txcoalesce
condition|)
block|{
comment|/* 			 * Poke the firmware to process queued frames; 			 * see below about (lack of) locking. 			 */
name|nqueued
operator|=
literal|0
expr_stmt|;
name|malo_hal_txstart
argument_list|(
name|sc
operator|->
name|malo_mh
argument_list|,
literal|0
comment|/*XXX*/
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|nqueued
condition|)
block|{
comment|/* 		 * NB: We don't need to lock against tx done because 		 * this just prods the firmware to check the transmit 		 * descriptors.  The firmware will also start fetching 		 * descriptors by itself if it notices new ones are 		 * present when it goes to deliver a tx done interrupt 		 * to the host. So if we race with tx done processing 		 * it's ok.  Delivering the kick here rather than in 		 * malo_tx_start is an optimization to avoid poking the 		 * firmware for each packet. 		 * 		 * NB: the queue id isn't used so 0 is ok. 		 */
name|malo_hal_txstart
argument_list|(
name|sc
operator|->
name|malo_mh
argument_list|,
literal|0
comment|/*XXX*/
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|malo_watchdog
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|malo_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|&&
operator|!
name|sc
operator|->
name|malo_invalid
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"watchdog timeout\n"
argument_list|)
expr_stmt|;
comment|/* XXX no way to reset h/w. now  */
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
name|sc
operator|->
name|malo_stats
operator|.
name|mst_watchdog
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|malo_hal_reset
parameter_list|(
name|struct
name|malo_softc
modifier|*
name|sc
parameter_list|)
block|{
specifier|static
name|int
name|first
init|=
literal|0
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|malo_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|malo_hal
modifier|*
name|mh
init|=
name|sc
operator|->
name|malo_mh
decl_stmt|;
if|if
condition|(
name|first
operator|==
literal|0
condition|)
block|{
comment|/* 		 * NB: when the device firstly is initialized, sometimes 		 * firmware could override rx/tx dma registers so we re-set 		 * these values once. 		 */
name|malo_hal_set_rxtxdma
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|first
operator|=
literal|1
expr_stmt|;
block|}
name|malo_hal_setantenna
argument_list|(
name|mh
argument_list|,
name|MHA_ANTENNATYPE_RX
argument_list|,
name|sc
operator|->
name|malo_rxantenna
argument_list|)
expr_stmt|;
name|malo_hal_setantenna
argument_list|(
name|mh
argument_list|,
name|MHA_ANTENNATYPE_TX
argument_list|,
name|sc
operator|->
name|malo_txantenna
argument_list|)
expr_stmt|;
name|malo_hal_setradio
argument_list|(
name|mh
argument_list|,
literal|1
argument_list|,
name|MHP_AUTO_PREAMBLE
argument_list|)
expr_stmt|;
name|malo_chan_set
argument_list|(
name|sc
argument_list|,
name|ic
operator|->
name|ic_curchan
argument_list|)
expr_stmt|;
comment|/* XXX needs other stuffs?  */
return|return
literal|1
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|mbuf
operator|*
name|malo_getrxmbuf
argument_list|(
argument|struct malo_softc *sc
argument_list|,
argument|struct malo_rxbuf *bf
argument_list|)
block|{ 	struct
name|mbuf
operator|*
name|m
block|;
name|bus_addr_t
name|paddr
block|;
name|int
name|error
block|;
comment|/* XXX don't need mbuf, just dma buffer */
name|m
operator|=
name|m_getjcl
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|,
name|MJUMPAGESIZE
argument_list|)
block|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|sc
operator|->
name|malo_stats
operator|.
name|mst_rx_nombuf
operator|++
expr_stmt|;
comment|/* XXX */
return|return
name|NULL
return|;
block|}
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|malo_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|MJUMPAGESIZE
argument_list|,
name|malo_load_cb
argument_list|,
operator|&
name|paddr
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|if_printf
argument_list|(
name|sc
operator|->
name|malo_ifp
argument_list|,
literal|"%s: bus_dmamap_load failed, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_if

begin_expr_stmt
name|bf
operator|->
name|bf_data
operator|=
name|paddr
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|malo_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|m
return|;
end_return

begin_function
unit|}  static
name|int
name|malo_rxbuf_init
parameter_list|(
name|struct
name|malo_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|malo_rxbuf
modifier|*
name|bf
parameter_list|)
block|{
name|struct
name|malo_rxdesc
modifier|*
name|ds
decl_stmt|;
name|ds
operator|=
name|bf
operator|->
name|bf_desc
expr_stmt|;
if|if
condition|(
name|bf
operator|->
name|bf_m
operator|==
name|NULL
condition|)
block|{
name|bf
operator|->
name|bf_m
operator|=
name|malo_getrxmbuf
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf
operator|->
name|bf_m
operator|==
name|NULL
condition|)
block|{
comment|/* mark descriptor to be skipped */
name|ds
operator|->
name|rxcontrol
operator|=
name|MALO_RXD_CTRL_OS_OWN
expr_stmt|;
comment|/* NB: don't need PREREAD */
name|MALO_RXDESC_SYNC
argument_list|(
name|sc
argument_list|,
name|ds
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
block|}
comment|/* 	 * Setup descriptor. 	 */
name|ds
operator|->
name|qosctrl
operator|=
literal|0
expr_stmt|;
name|ds
operator|->
name|snr
operator|=
literal|0
expr_stmt|;
name|ds
operator|->
name|status
operator|=
name|MALO_RXD_STATUS_IDLE
expr_stmt|;
name|ds
operator|->
name|channel
operator|=
literal|0
expr_stmt|;
name|ds
operator|->
name|pktlen
operator|=
name|htole16
argument_list|(
name|MALO_RXSIZE
argument_list|)
expr_stmt|;
name|ds
operator|->
name|nf
operator|=
literal|0
expr_stmt|;
name|ds
operator|->
name|physbuffdata
operator|=
name|htole32
argument_list|(
name|bf
operator|->
name|bf_data
argument_list|)
expr_stmt|;
comment|/* NB: don't touch pPhysNext, set once */
name|ds
operator|->
name|rxcontrol
operator|=
name|MALO_RXD_CTRL_DRIVER_OWN
expr_stmt|;
name|MALO_RXDESC_SYNC
argument_list|(
name|sc
argument_list|,
name|ds
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Setup the rx data structures.  This should only be done once or we may get  * out of sync with the firmware.  */
end_comment

begin_function
specifier|static
name|int
name|malo_startrecv
parameter_list|(
name|struct
name|malo_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|malo_rxbuf
modifier|*
name|bf
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
name|struct
name|malo_rxdesc
modifier|*
name|ds
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|malo_recvsetup
operator|==
literal|1
condition|)
block|{
name|malo_mode_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* set filters, etc. */
return|return
literal|0
return|;
block|}
name|prev
operator|=
name|NULL
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|bf
argument_list|,
argument|&sc->malo_rxbuf
argument_list|,
argument|bf_list
argument_list|)
block|{
name|int
name|error
init|=
name|malo_rxbuf_init
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|MALO_DEBUG_RECV
argument_list|,
literal|"%s: malo_rxbuf_init failed %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
if|if
condition|(
name|prev
operator|!=
name|NULL
condition|)
block|{
name|ds
operator|=
name|prev
operator|->
name|bf_desc
expr_stmt|;
name|ds
operator|->
name|physnext
operator|=
name|htole32
argument_list|(
name|bf
operator|->
name|bf_daddr
argument_list|)
expr_stmt|;
block|}
name|prev
operator|=
name|bf
expr_stmt|;
block|}
if|if
condition|(
name|prev
operator|!=
name|NULL
condition|)
block|{
name|ds
operator|=
name|prev
operator|->
name|bf_desc
expr_stmt|;
name|ds
operator|->
name|physnext
operator|=
name|htole32
argument_list|(
name|STAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|malo_rxbuf
argument_list|)
operator|->
name|bf_daddr
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|malo_recvsetup
operator|=
literal|1
expr_stmt|;
name|malo_mode_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* set filters, etc. */
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|malo_init_locked
parameter_list|(
name|struct
name|malo_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|malo_ifp
decl_stmt|;
name|struct
name|malo_hal
modifier|*
name|mh
init|=
name|sc
operator|->
name|malo_mh
decl_stmt|;
name|int
name|error
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|MALO_DEBUG_ANY
argument_list|,
literal|"%s: if_flags 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|ifp
operator|->
name|if_flags
argument_list|)
expr_stmt|;
name|MALO_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Stop anything previously setup.  This is safe whether this is 	 * the first time through or not. 	 */
name|malo_stop_locked
argument_list|(
name|ifp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Push state to the firmware. 	 */
if|if
condition|(
operator|!
name|malo_hal_reset
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"%s: unable to reset hardware\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Setup recv (once); transmit is already good to go. 	 */
name|error
operator|=
name|malo_startrecv
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"%s: unable to start recv logic, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Enable interrupts. 	 */
name|sc
operator|->
name|malo_imask
operator|=
name|MALO_A2HRIC_BIT_RX_RDY
operator||
name|MALO_A2HRIC_BIT_TX_DONE
operator||
name|MALO_A2HRIC_BIT_OPC_DONE
operator||
name|MALO_A2HRIC_BIT_MAC_EVENT
operator||
name|MALO_A2HRIC_BIT_RX_PROBLEM
operator||
name|MALO_A2HRIC_BIT_ICV_ERROR
operator||
name|MALO_A2HRIC_BIT_RADAR_DETECT
operator||
name|MALO_A2HRIC_BIT_CHAN_SWITCH
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_RUNNING
expr_stmt|;
name|malo_hal_intrset
argument_list|(
name|mh
argument_list|,
name|sc
operator|->
name|malo_imask
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|malo_init
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|malo_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|malo_softc
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|malo_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|MALO_DEBUG_ANY
argument_list|,
literal|"%s: if_flags 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|ifp
operator|->
name|if_flags
argument_list|)
expr_stmt|;
name|MALO_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|malo_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|MALO_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
name|ieee80211_start_all
argument_list|(
name|ic
argument_list|)
expr_stmt|;
comment|/* start all vap's */
block|}
end_function

begin_comment
comment|/*  * Set the multicast filter contents into the hardware.  */
end_comment

begin_function
specifier|static
name|void
name|malo_setmcastfilter
parameter_list|(
name|struct
name|malo_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|malo_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|ifmultiaddr
modifier|*
name|ifma
decl_stmt|;
name|uint8_t
name|macs
index|[
name|IEEE80211_ADDR_LEN
operator|*
name|MALO_HAL_MCAST_MAX
index|]
decl_stmt|;
name|uint8_t
modifier|*
name|mp
decl_stmt|;
name|int
name|nmc
decl_stmt|;
name|mp
operator|=
name|macs
expr_stmt|;
name|nmc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_MONITOR
operator|||
operator|(
name|ifp
operator|->
name|if_flags
operator|&
operator|(
name|IFF_ALLMULTI
operator||
name|IFF_PROMISC
operator|)
operator|)
condition|)
goto|goto
name|all
goto|;
name|IF_ADDR_LOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ifma
argument_list|,
argument|&ifp->if_multiaddrs
argument_list|,
argument|ifma_link
argument_list|)
block|{
if|if
condition|(
name|ifma
operator|->
name|ifma_addr
operator|->
name|sa_family
operator|!=
name|AF_LINK
condition|)
continue|continue;
if|if
condition|(
name|nmc
operator|==
name|MALO_HAL_MCAST_MAX
condition|)
block|{
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_ALLMULTI
expr_stmt|;
name|IF_ADDR_UNLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
goto|goto
name|all
goto|;
block|}
name|IEEE80211_ADDR_COPY
argument_list|(
name|mp
argument_list|,
name|LLADDR
argument_list|(
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifma
operator|->
name|ifma_addr
argument_list|)
argument_list|)
expr_stmt|;
name|mp
operator|+=
name|IEEE80211_ADDR_LEN
operator|,
name|nmc
operator|++
expr_stmt|;
block|}
name|IF_ADDR_UNLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|malo_hal_setmcast
argument_list|(
name|sc
operator|->
name|malo_mh
argument_list|,
name|nmc
argument_list|,
name|macs
argument_list|)
expr_stmt|;
name|all
label|:
comment|/* 	 * XXX we don't know how to set the f/w for supporting 	 * IFF_ALLMULTI | IFF_PROMISC cases 	 */
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|malo_mode_init
parameter_list|(
name|struct
name|malo_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|malo_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|malo_hal
modifier|*
name|mh
init|=
name|sc
operator|->
name|malo_mh
decl_stmt|;
comment|/* 	 * Handle any link-level address change.  Note that we only 	 * need to force ic_myaddr; any other addresses are handled 	 * as a byproduct of the ifnet code marking the interface 	 * down then up. 	 */
name|IEEE80211_ADDR_COPY
argument_list|(
name|ic
operator|->
name|ic_myaddr
argument_list|,
name|IF_LLADDR
argument_list|(
name|ifp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * NB: Ignore promisc in hostap mode; it's set by the 	 * bridge.  This is wrong but we have no way to 	 * identify internal requests (from the bridge) 	 * versus external requests such as for tcpdump. 	 */
name|malo_hal_setpromisc
argument_list|(
name|mh
argument_list|,
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
operator|)
operator|&&
name|ic
operator|->
name|ic_opmode
operator|!=
name|IEEE80211_M_HOSTAP
argument_list|)
expr_stmt|;
name|malo_setmcastfilter
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|malo_tx_draintxq
parameter_list|(
name|struct
name|malo_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|malo_txq
modifier|*
name|txq
parameter_list|)
block|{
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|struct
name|malo_txbuf
modifier|*
name|bf
decl_stmt|;
name|u_int
name|ix
decl_stmt|;
comment|/* 	 * NB: this assumes output has been stopped and 	 *     we do not need to block malo_tx_tasklet 	 */
for|for
control|(
name|ix
operator|=
literal|0
init|;
condition|;
name|ix
operator|++
control|)
block|{
name|MALO_TXQ_LOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|bf
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|txq
operator|->
name|active
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf
operator|==
name|NULL
condition|)
block|{
name|MALO_TXQ_UNLOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
break|break;
block|}
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|txq
operator|->
name|active
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
name|MALO_TXQ_UNLOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MALO_DEBUG
if|if
condition|(
name|sc
operator|->
name|malo_debug
operator|&
name|MALO_DEBUG_RESET
condition|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|malo_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
specifier|const
name|struct
name|malo_txrec
modifier|*
name|tr
init|=
name|mtod
argument_list|(
name|bf
operator|->
name|bf_m
argument_list|,
specifier|const
expr|struct
name|malo_txrec
operator|*
argument_list|)
decl_stmt|;
name|malo_printtxbuf
argument_list|(
name|bf
argument_list|,
name|txq
operator|->
name|qnum
argument_list|,
name|ix
argument_list|)
expr_stmt|;
name|ieee80211_dump_pkt
argument_list|(
name|ic
argument_list|,
operator|(
specifier|const
name|uint8_t
operator|*
operator|)
operator|&
name|tr
operator|->
name|wh
argument_list|,
name|bf
operator|->
name|bf_m
operator|->
name|m_len
operator|-
sizeof|sizeof
argument_list|(
name|tr
operator|->
name|fwlen
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* MALO_DEBUG */
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|malo_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|)
expr_stmt|;
name|ni
operator|=
name|bf
operator|->
name|bf_node
expr_stmt|;
name|bf
operator|->
name|bf_node
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ni
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * Reclaim node reference. 			 */
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
name|m_freem
argument_list|(
name|bf
operator|->
name|bf_m
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_m
operator|=
name|NULL
expr_stmt|;
name|MALO_TXQ_LOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|txq
operator|->
name|free
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
name|txq
operator|->
name|nfree
operator|++
expr_stmt|;
name|MALO_TXQ_UNLOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|malo_stop_locked
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|int
name|disable
parameter_list|)
block|{
name|struct
name|malo_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|malo_hal
modifier|*
name|mh
init|=
name|sc
operator|->
name|malo_mh
decl_stmt|;
name|int
name|i
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|MALO_DEBUG_ANY
argument_list|,
literal|"%s: invalid %u if_flags 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|sc
operator|->
name|malo_invalid
argument_list|,
name|ifp
operator|->
name|if_flags
argument_list|)
expr_stmt|;
name|MALO_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
return|return;
comment|/* 	 * Shutdown the hardware and driver: 	 *    disable interrupts 	 *    turn off the radio 	 *    drain and release tx queues 	 * 	 * Note that some of this work is not possible if the hardware 	 * is gone (invalid). 	 */
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_RUNNING
expr_stmt|;
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
comment|/* diable interrupt.  */
name|malo_hal_intrset
argument_list|(
name|mh
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* turn off the radio.  */
name|malo_hal_setradio
argument_list|(
name|mh
argument_list|,
literal|0
argument_list|,
name|MHP_AUTO_PREAMBLE
argument_list|)
expr_stmt|;
comment|/* drain and release tx queues.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MALO_NUM_TX_QUEUES
condition|;
name|i
operator|++
control|)
name|malo_tx_draintxq
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|malo_txq
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|malo_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
define|#
directive|define
name|MALO_IS_RUNNING
parameter_list|(
name|ifp
parameter_list|)
define|\
value|((ifp->if_flags& IFF_UP)&& (ifp->if_drv_flags& IFF_DRV_RUNNING))
name|struct
name|malo_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|startall
init|=
literal|0
decl_stmt|;
name|MALO_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCSIFFLAGS
case|:
if|if
condition|(
name|MALO_IS_RUNNING
argument_list|(
name|ifp
argument_list|)
condition|)
block|{
comment|/* 			 * To avoid rescanning another access point, 			 * do not call malo_init() here.  Instead, 			 * only reflect promisc mode settings. 			 */
name|malo_mode_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
comment|/* 			 * Beware of being called during attach/detach 			 * to reset promiscuous mode.  In that case we 			 * will still be marked UP but not RUNNING. 			 * However trying to re-init the interface 			 * is the wrong thing to do as we've already 			 * torn down much of our state.  There's 			 * probably a better way to deal with this. 			 */
if|if
condition|(
operator|!
name|sc
operator|->
name|malo_invalid
condition|)
block|{
name|malo_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|startall
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
name|malo_stop_locked
argument_list|(
name|ifp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCGIFMEDIA
case|:
case|case
name|SIOCSIFMEDIA
case|:
name|error
operator|=
name|ifmedia_ioctl
argument_list|(
name|ifp
argument_list|,
name|ifr
argument_list|,
operator|&
name|ic
operator|->
name|ic_media
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
block|}
name|MALO_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|startall
condition|)
name|ieee80211_start_all
argument_list|(
name|ic
argument_list|)
expr_stmt|;
return|return
name|error
return|;
undef|#
directive|undef
name|MALO_IS_RUNNING
block|}
end_function

begin_comment
comment|/*  * Callback from the 802.11 layer to update the slot time  * based on the current setting.  We use it to notify the  * firmware of ERP changes and the f/w takes care of things  * like slot time and preamble.  */
end_comment

begin_function
specifier|static
name|void
name|malo_updateslot
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|malo_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|malo_hal
modifier|*
name|mh
init|=
name|sc
operator|->
name|malo_mh
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* NB: can be called early; suppress needless cmds */
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
return|return;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|MALO_DEBUG_RESET
argument_list|,
literal|"%s: chan %u MHz/flags 0x%x %s slot, (ic_flags 0x%x)\n"
argument_list|,
name|__func__
argument_list|,
name|ic
operator|->
name|ic_curchan
operator|->
name|ic_freq
argument_list|,
name|ic
operator|->
name|ic_curchan
operator|->
name|ic_flags
argument_list|,
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_SHSLOT
condition|?
literal|"short"
else|:
literal|"long"
argument_list|,
name|ic
operator|->
name|ic_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_SHSLOT
condition|)
name|error
operator|=
name|malo_hal_set_slot
argument_list|(
name|mh
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|malo_hal_set_slot
argument_list|(
name|mh
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|malo_dev
argument_list|,
literal|"setting %s slot failed\n"
argument_list|,
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_SHSLOT
condition|?
literal|"short"
else|:
literal|"long"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|malo_newstate
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
name|enum
name|ieee80211_state
name|nstate
parameter_list|,
name|int
name|arg
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|struct
name|malo_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|malo_hal
modifier|*
name|mh
init|=
name|sc
operator|->
name|malo_mh
decl_stmt|;
name|int
name|error
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|MALO_DEBUG_STATE
argument_list|,
literal|"%s: %s -> %s\n"
argument_list|,
name|__func__
argument_list|,
name|ieee80211_state_name
index|[
name|vap
operator|->
name|iv_state
index|]
argument_list|,
name|ieee80211_state_name
index|[
name|nstate
index|]
argument_list|)
expr_stmt|;
comment|/* 	 * Invoke the net80211 layer first so iv_bss is setup. 	 */
name|error
operator|=
name|MALO_VAP
argument_list|(
name|vap
argument_list|)
operator|->
name|malo_newstate
argument_list|(
name|vap
argument_list|,
name|nstate
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
name|error
return|;
if|if
condition|(
name|nstate
operator|==
name|IEEE80211_S_RUN
operator|&&
name|vap
operator|->
name|iv_state
operator|!=
name|IEEE80211_S_RUN
condition|)
block|{
name|struct
name|ieee80211_node
modifier|*
name|ni
init|=
name|vap
operator|->
name|iv_bss
decl_stmt|;
name|enum
name|ieee80211_phymode
name|mode
init|=
name|ieee80211_chan2mode
argument_list|(
name|ni
operator|->
name|ni_chan
argument_list|)
decl_stmt|;
specifier|const
name|struct
name|ieee80211_txparam
modifier|*
name|tp
init|=
operator|&
name|vap
operator|->
name|iv_txparms
index|[
name|mode
index|]
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|MALO_DEBUG_STATE
argument_list|,
literal|"%s: %s(RUN): iv_flags 0x%08x bintvl %d bssid %s "
literal|"capinfo 0x%04x chan %d associd 0x%x mode %d rate %d\n"
argument_list|,
name|vap
operator|->
name|iv_ifp
operator|->
name|if_xname
argument_list|,
name|__func__
argument_list|,
name|vap
operator|->
name|iv_flags
argument_list|,
name|ni
operator|->
name|ni_intval
argument_list|,
name|ether_sprintf
argument_list|(
name|ni
operator|->
name|ni_bssid
argument_list|)
argument_list|,
name|ni
operator|->
name|ni_capinfo
argument_list|,
name|ieee80211_chan2ieee
argument_list|(
name|ic
argument_list|,
name|ic
operator|->
name|ic_curchan
argument_list|)
argument_list|,
name|ni
operator|->
name|ni_associd
argument_list|,
name|mode
argument_list|,
name|tp
operator|->
name|ucastrate
argument_list|)
expr_stmt|;
name|malo_hal_setradio
argument_list|(
name|mh
argument_list|,
literal|1
argument_list|,
operator|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_SHPREAMBLE
operator|)
condition|?
name|MHP_SHORT_PREAMBLE
else|:
name|MHP_LONG_PREAMBLE
argument_list|)
expr_stmt|;
name|malo_hal_setassocid
argument_list|(
name|sc
operator|->
name|malo_mh
argument_list|,
name|ni
operator|->
name|ni_bssid
argument_list|,
name|ni
operator|->
name|ni_associd
argument_list|)
expr_stmt|;
name|malo_hal_set_rate
argument_list|(
name|mh
argument_list|,
name|mode
argument_list|,
name|tp
operator|->
name|ucastrate
operator|==
name|IEEE80211_FIXED_RATE_NONE
condition|?
literal|0
else|:
name|malo_fix2rate
argument_list|(
name|tp
operator|->
name|ucastrate
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|malo_raw_xmit
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
specifier|const
name|struct
name|ieee80211_bpf_params
modifier|*
name|params
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|ic
operator|->
name|ic_ifp
decl_stmt|;
name|struct
name|malo_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|malo_txbuf
modifier|*
name|bf
decl_stmt|;
name|struct
name|malo_txq
modifier|*
name|txq
decl_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
operator|||
name|sc
operator|->
name|malo_invalid
condition|)
block|{
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|ENETDOWN
return|;
block|}
comment|/* 	 * Grab a TX buffer and associated resources.  Note that we depend 	 * on the classification by the 802.11 layer to get to the right h/w 	 * queue.  Management frames must ALWAYS go on queue 1 but we 	 * cannot just force that here because we may receive non-mgt frames. 	 */
name|txq
operator|=
operator|&
name|sc
operator|->
name|malo_txq
index|[
literal|0
index|]
expr_stmt|;
name|bf
operator|=
name|malo_getbuf
argument_list|(
name|sc
argument_list|,
name|txq
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf
operator|==
name|NULL
condition|)
block|{
comment|/* XXX blocks other traffic */
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_OACTIVE
expr_stmt|;
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|ENOBUFS
return|;
block|}
comment|/* 	 * Pass the frame to the h/w for transmission. 	 */
if|if
condition|(
name|malo_tx_start
argument_list|(
name|sc
argument_list|,
name|ni
argument_list|,
name|bf
argument_list|,
name|m
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
name|bf
operator|->
name|bf_m
operator|=
name|NULL
expr_stmt|;
name|bf
operator|->
name|bf_node
operator|=
name|NULL
expr_stmt|;
name|MALO_TXQ_LOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_HEAD
argument_list|(
operator|&
name|txq
operator|->
name|free
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
name|txq
operator|->
name|nfree
operator|++
expr_stmt|;
name|MALO_TXQ_UNLOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
comment|/* XXX */
block|}
comment|/* 	 * NB: We don't need to lock against tx done because this just 	 * prods the firmware to check the transmit descriptors.  The firmware 	 * will also start fetching descriptors by itself if it notices 	 * new ones are present when it goes to deliver a tx done interrupt 	 * to the host. So if we race with tx done processing it's ok. 	 * Delivering the kick here rather than in malo_tx_start is 	 * an optimization to avoid poking the firmware for each packet. 	 * 	 * NB: the queue id isn't used so 0 is ok. 	 */
name|malo_hal_txstart
argument_list|(
name|sc
operator|->
name|malo_mh
argument_list|,
literal|0
comment|/*XXX*/
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|malo_bpfattach
parameter_list|(
name|struct
name|malo_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|malo_ifp
decl_stmt|;
name|bpfattach
argument_list|(
name|ifp
argument_list|,
name|DLT_IEEE802_11_RADIO
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_frame
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|malo_tx_th
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize constant fields. 	 * XXX make header lengths a multiple of 32-bits so subsequent 	 *     headers are properly aligned; this is a kludge to keep 	 *     certain applications happy. 	 * 	 * NB: the channel is setup each time we transition to the 	 *     RUN state to avoid filling it in for each frame. 	 */
name|sc
operator|->
name|malo_tx_th_len
operator|=
name|roundup
argument_list|(
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|malo_tx_th
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|malo_tx_th
operator|.
name|wt_ihdr
operator|.
name|it_len
operator|=
name|htole16
argument_list|(
name|sc
operator|->
name|malo_tx_th_len
argument_list|)
expr_stmt|;
name|sc
operator|->
name|malo_tx_th
operator|.
name|wt_ihdr
operator|.
name|it_present
operator|=
name|htole32
argument_list|(
name|MALO_TX_RADIOTAP_PRESENT
argument_list|)
expr_stmt|;
name|sc
operator|->
name|malo_rx_th_len
operator|=
name|roundup
argument_list|(
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|malo_rx_th
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|malo_rx_th
operator|.
name|wr_ihdr
operator|.
name|it_len
operator|=
name|htole16
argument_list|(
name|sc
operator|->
name|malo_rx_th_len
argument_list|)
expr_stmt|;
name|sc
operator|->
name|malo_rx_th
operator|.
name|wr_ihdr
operator|.
name|it_present
operator|=
name|htole32
argument_list|(
name|MALO_RX_RADIOTAP_PRESENT
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|malo_sysctlattach
parameter_list|(
name|struct
name|malo_softc
modifier|*
name|sc
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|MALO_DEBUG
name|struct
name|sysctl_ctx_list
modifier|*
name|ctx
init|=
name|device_get_sysctl_ctx
argument_list|(
name|sc
operator|->
name|malo_dev
argument_list|)
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|tree
init|=
name|device_get_sysctl_tree
argument_list|(
name|sc
operator|->
name|malo_dev
argument_list|)
decl_stmt|;
name|sc
operator|->
name|malo_debug
operator|=
name|malo_debug
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"debug"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|malo_debug
argument_list|,
literal|0
argument_list|,
literal|"control debugging printfs"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|malo_announce
parameter_list|(
name|struct
name|malo_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|malo_ifp
decl_stmt|;
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"versions [hw %d fw %d.%d.%d.%d] (regioncode %d)\n"
argument_list|,
name|sc
operator|->
name|malo_hwspecs
operator|.
name|hwversion
argument_list|,
operator|(
name|sc
operator|->
name|malo_hwspecs
operator|.
name|fw_releasenum
operator|>>
literal|24
operator|)
operator|&
literal|0xff
argument_list|,
operator|(
name|sc
operator|->
name|malo_hwspecs
operator|.
name|fw_releasenum
operator|>>
literal|16
operator|)
operator|&
literal|0xff
argument_list|,
operator|(
name|sc
operator|->
name|malo_hwspecs
operator|.
name|fw_releasenum
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|,
operator|(
name|sc
operator|->
name|malo_hwspecs
operator|.
name|fw_releasenum
operator|>>
literal|0
operator|)
operator|&
literal|0xff
argument_list|,
name|sc
operator|->
name|malo_hwspecs
operator|.
name|regioncode
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
operator|||
name|malo_rxbuf
operator|!=
name|MALO_RXBUF
condition|)
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"using %u rx buffers\n"
argument_list|,
name|malo_rxbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
operator|||
name|malo_txbuf
operator|!=
name|MALO_TXBUF
condition|)
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"using %u tx buffers\n"
argument_list|,
name|malo_txbuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Convert net80211 channel to a HAL channel.  */
end_comment

begin_function
specifier|static
name|void
name|malo_mapchan
parameter_list|(
name|struct
name|malo_hal_channel
modifier|*
name|hc
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|)
block|{
name|hc
operator|->
name|channel
operator|=
name|chan
operator|->
name|ic_ieee
expr_stmt|;
operator|*
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|hc
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_2GHZ
argument_list|(
name|chan
argument_list|)
condition|)
name|hc
operator|->
name|flags
operator|.
name|freqband
operator|=
name|MALO_FREQ_BAND_2DOT4GHZ
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set/change channels.  If the channel is really being changed,  * it's done by reseting the chip.  To accomplish this we must  * first cleanup any pending DMA, then restart stuff after a la  * malo_init.  */
end_comment

begin_function
specifier|static
name|int
name|malo_chan_set
parameter_list|(
name|struct
name|malo_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|)
block|{
name|struct
name|malo_hal
modifier|*
name|mh
init|=
name|sc
operator|->
name|malo_mh
decl_stmt|;
name|struct
name|malo_hal_channel
name|hchan
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|MALO_DEBUG_RESET
argument_list|,
literal|"%s: chan %u MHz/flags 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|chan
operator|->
name|ic_freq
argument_list|,
name|chan
operator|->
name|ic_flags
argument_list|)
expr_stmt|;
comment|/* 	 * Convert to a HAL channel description with the flags constrained 	 * to reflect the current operating mode. 	 */
name|malo_mapchan
argument_list|(
operator|&
name|hchan
argument_list|,
name|chan
argument_list|)
expr_stmt|;
name|malo_hal_intrset
argument_list|(
name|mh
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* disable interrupts */
name|malo_hal_setchannel
argument_list|(
name|mh
argument_list|,
operator|&
name|hchan
argument_list|)
expr_stmt|;
name|malo_hal_settxpower
argument_list|(
name|mh
argument_list|,
operator|&
name|hchan
argument_list|)
expr_stmt|;
comment|/* 	 * Update internal state. 	 */
name|sc
operator|->
name|malo_tx_th
operator|.
name|wt_chan_freq
operator|=
name|htole16
argument_list|(
name|chan
operator|->
name|ic_freq
argument_list|)
expr_stmt|;
name|sc
operator|->
name|malo_rx_th
operator|.
name|wr_chan_freq
operator|=
name|htole16
argument_list|(
name|chan
operator|->
name|ic_freq
argument_list|)
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_ANYG
argument_list|(
name|chan
argument_list|)
condition|)
block|{
name|sc
operator|->
name|malo_tx_th
operator|.
name|wt_chan_flags
operator|=
name|htole16
argument_list|(
name|IEEE80211_CHAN_G
argument_list|)
expr_stmt|;
name|sc
operator|->
name|malo_rx_th
operator|.
name|wr_chan_flags
operator|=
name|htole16
argument_list|(
name|IEEE80211_CHAN_G
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|malo_tx_th
operator|.
name|wt_chan_flags
operator|=
name|htole16
argument_list|(
name|IEEE80211_CHAN_B
argument_list|)
expr_stmt|;
name|sc
operator|->
name|malo_rx_th
operator|.
name|wr_chan_flags
operator|=
name|htole16
argument_list|(
name|IEEE80211_CHAN_B
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|malo_curchan
operator|=
name|hchan
expr_stmt|;
name|malo_hal_intrset
argument_list|(
name|mh
argument_list|,
name|sc
operator|->
name|malo_imask
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|malo_scan_start
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|ic
operator|->
name|ic_ifp
decl_stmt|;
name|struct
name|malo_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|MALO_DEBUG_STATE
argument_list|,
literal|"%s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|malo_scan_end
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|ic
operator|->
name|ic_ifp
decl_stmt|;
name|struct
name|malo_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|MALO_DEBUG_STATE
argument_list|,
literal|"%s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|malo_set_channel
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|ic
operator|->
name|ic_ifp
decl_stmt|;
name|struct
name|malo_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
operator|(
name|void
operator|)
name|malo_chan_set
argument_list|(
name|sc
argument_list|,
name|ic
operator|->
name|ic_curchan
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|malo_rx_proc
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|npending
parameter_list|)
block|{
define|#
directive|define
name|IEEE80211_DIR_DSTODS
parameter_list|(
name|wh
parameter_list|)
define|\
value|((((const struct ieee80211_frame *)wh)->i_fc[1]&		\ 	    IEEE80211_FC1_DIR_MASK) == IEEE80211_FC1_DIR_DSTODS)
name|struct
name|malo_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|malo_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|malo_rxbuf
modifier|*
name|bf
decl_stmt|;
name|struct
name|malo_rxdesc
modifier|*
name|ds
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|mnew
decl_stmt|;
name|struct
name|ieee80211_qosframe
modifier|*
name|wh
decl_stmt|;
name|struct
name|ieee80211_qosframe_addr4
modifier|*
name|wh4
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|int
name|off
decl_stmt|,
name|len
decl_stmt|,
name|hdrlen
decl_stmt|,
name|pktlen
decl_stmt|,
name|rssi
decl_stmt|,
name|ntodo
decl_stmt|;
name|uint8_t
modifier|*
name|data
decl_stmt|,
name|status
decl_stmt|;
name|uint32_t
name|readptr
decl_stmt|,
name|writeptr
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|MALO_DEBUG_RX_PROC
argument_list|,
literal|"%s: pending %u rdptr(0x%x) 0x%x wrptr(0x%x) 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|npending
argument_list|,
name|sc
operator|->
name|malo_hwspecs
operator|.
name|rxdesc_read
argument_list|,
name|malo_bar0_read4
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|malo_hwspecs
operator|.
name|rxdesc_read
argument_list|)
argument_list|,
name|sc
operator|->
name|malo_hwspecs
operator|.
name|rxdesc_write
argument_list|,
name|malo_bar0_read4
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|malo_hwspecs
operator|.
name|rxdesc_write
argument_list|)
argument_list|)
expr_stmt|;
name|readptr
operator|=
name|malo_bar0_read4
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|malo_hwspecs
operator|.
name|rxdesc_read
argument_list|)
expr_stmt|;
name|writeptr
operator|=
name|malo_bar0_read4
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|malo_hwspecs
operator|.
name|rxdesc_write
argument_list|)
expr_stmt|;
if|if
condition|(
name|readptr
operator|==
name|writeptr
condition|)
return|return;
name|bf
operator|=
name|sc
operator|->
name|malo_rxnext
expr_stmt|;
for|for
control|(
name|ntodo
operator|=
name|malo_rxquota
init|;
name|ntodo
operator|>
literal|0
operator|&&
name|readptr
operator|!=
name|writeptr
condition|;
name|ntodo
operator|--
control|)
block|{
if|if
condition|(
name|bf
operator|==
name|NULL
condition|)
block|{
name|bf
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|malo_rxbuf
argument_list|)
expr_stmt|;
break|break;
block|}
name|ds
operator|=
name|bf
operator|->
name|bf_desc
expr_stmt|;
if|if
condition|(
name|bf
operator|->
name|bf_m
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * If data allocation failed previously there 			 * will be no buffer; try again to re-populate it. 			 * Note the firmware will not advance to the next 			 * descriptor with a dma buffer so we must mimic 			 * this or we'll get out of sync. 			 */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|MALO_DEBUG_ANY
argument_list|,
literal|"%s: rx buf w/o dma memory\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|malo_rxbuf_init
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
expr_stmt|;
break|break;
block|}
name|MALO_RXDESC_SYNC
argument_list|(
name|sc
argument_list|,
name|ds
argument_list|,
name|BUS_DMASYNC_POSTREAD
operator||
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|rxcontrol
operator|!=
name|MALO_RXD_CTRL_DMA_OWN
condition|)
break|break;
name|readptr
operator|=
name|le32toh
argument_list|(
name|ds
operator|->
name|physnext
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MALO_DEBUG
if|if
condition|(
name|sc
operator|->
name|malo_debug
operator|&
name|MALO_DEBUG_RECV_DESC
condition|)
name|malo_printrxbuf
argument_list|(
name|bf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|status
operator|=
name|ds
operator|->
name|status
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|MALO_RXD_STATUS_DECRYPT_ERR_MASK
condition|)
block|{
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
goto|goto
name|rx_next
goto|;
block|}
comment|/* 		 * Sync the data buffer. 		 */
name|len
operator|=
name|le16toh
argument_list|(
name|ds
operator|->
name|pktlen
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|malo_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
comment|/* 		 * The 802.11 header is provided all or in part at the front; 		 * use it to calculate the true size of the header that we'll 		 * construct below.  We use this to figure out where to copy 		 * payload prior to constructing the header. 		 */
name|m
operator|=
name|bf
operator|->
name|bf_m
expr_stmt|;
name|data
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|uint8_t
operator|*
argument_list|)
expr_stmt|;
empty_stmt|;
name|hdrlen
operator|=
name|ieee80211_anyhdrsize
argument_list|(
name|data
operator|+
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
argument_list|)
expr_stmt|;
name|off
operator|=
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_frame_addr4
argument_list|)
expr_stmt|;
comment|/* 		 * Calculate RSSI. XXX wrong 		 */
name|rssi
operator|=
literal|2
operator|*
operator|(
operator|(
name|int
operator|)
name|ds
operator|->
name|snr
operator|-
name|ds
operator|->
name|nf
operator|)
expr_stmt|;
comment|/* NB: .5 dBm  */
if|if
condition|(
name|rssi
operator|>
literal|100
condition|)
name|rssi
operator|=
literal|100
expr_stmt|;
name|pktlen
operator|=
name|hdrlen
operator|+
operator|(
name|len
operator|-
name|off
operator|)
expr_stmt|;
comment|/* 		 * NB: we know our frame is at least as large as 		 * IEEE80211_MIN_LEN because there is a 4-address frame at 		 * the front.  Hence there's no need to vet the packet length. 		 * If the frame in fact is too small it should be discarded 		 * at the net80211 layer. 		 */
comment|/* XXX don't need mbuf, just dma buffer */
name|mnew
operator|=
name|malo_getrxmbuf
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
expr_stmt|;
if|if
condition|(
name|mnew
operator|==
name|NULL
condition|)
block|{
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
goto|goto
name|rx_next
goto|;
block|}
comment|/* 		 * Attach the dma buffer to the mbuf; malo_rxbuf_init will 		 * re-setup the rx descriptor using the replacement dma 		 * buffer we just installed above. 		 */
name|bf
operator|->
name|bf_m
operator|=
name|mnew
expr_stmt|;
name|m
operator|->
name|m_data
operator|+=
name|off
operator|-
name|hdrlen
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|pktlen
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
comment|/* 		 * Piece 802.11 header together. 		 */
name|wh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ieee80211_qosframe
operator|*
argument_list|)
expr_stmt|;
comment|/* NB: don't need to do this sometimes but ... */
comment|/* XXX special case so we can memcpy after m_devget? */
name|ovbcopy
argument_list|(
name|data
operator|+
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
argument_list|,
name|wh
argument_list|,
name|hdrlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|IEEE80211_QOS_HAS_SEQ
argument_list|(
name|wh
argument_list|)
condition|)
block|{
if|if
condition|(
name|IEEE80211_DIR_DSTODS
argument_list|(
name|wh
argument_list|)
condition|)
block|{
name|wh4
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ieee80211_qosframe_addr4
operator|*
argument_list|)
expr_stmt|;
operator|*
operator|(
name|uint16_t
operator|*
operator|)
name|wh4
operator|->
name|i_qos
operator|=
name|ds
operator|->
name|qosctrl
expr_stmt|;
block|}
else|else
block|{
operator|*
operator|(
name|uint16_t
operator|*
operator|)
name|wh
operator|->
name|i_qos
operator|=
name|ds
operator|->
name|qosctrl
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sc
operator|->
name|malo_drvbpf
operator|!=
name|NULL
condition|)
block|{
name|sc
operator|->
name|malo_rx_th
operator|.
name|wr_flags
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|malo_rx_th
operator|.
name|wr_rate
operator|=
name|ds
operator|->
name|rate
expr_stmt|;
name|sc
operator|->
name|malo_rx_th
operator|.
name|wr_antsignal
operator|=
name|rssi
expr_stmt|;
name|sc
operator|->
name|malo_rx_th
operator|.
name|wr_antnoise
operator|=
name|ds
operator|->
name|nf
expr_stmt|;
name|bpf_mtap2
argument_list|(
name|ifp
operator|->
name|if_bpf
argument_list|,
operator|&
name|sc
operator|->
name|malo_rx_th
argument_list|,
name|sc
operator|->
name|malo_rx_th_len
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|MALO_DEBUG
if|if
condition|(
name|IFF_DUMPPKTS_RECV
argument_list|(
name|sc
argument_list|,
name|wh
argument_list|)
condition|)
block|{
name|ieee80211_dump_pkt
argument_list|(
name|ic
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|len
argument_list|,
name|ds
operator|->
name|rate
argument_list|,
name|rssi
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|ifp
operator|->
name|if_ipackets
operator|++
expr_stmt|;
comment|/* dispatch */
name|ni
operator|=
name|ieee80211_find_rxnode
argument_list|(
name|ic
argument_list|,
operator|(
expr|struct
name|ieee80211_frame_min
operator|*
operator|)
name|wh
argument_list|)
expr_stmt|;
if|if
condition|(
name|ni
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|ieee80211_input
argument_list|(
name|ni
argument_list|,
name|m
argument_list|,
name|rssi
argument_list|,
name|ds
operator|->
name|nf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|ieee80211_input_all
argument_list|(
name|ic
argument_list|,
name|m
argument_list|,
name|rssi
argument_list|,
name|ds
operator|->
name|nf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rx_next
label|:
comment|/* NB: ignore ENOMEM so we process more descriptors */
operator|(
name|void
operator|)
name|malo_rxbuf_init
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
expr_stmt|;
name|bf
operator|=
name|STAILQ_NEXT
argument_list|(
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
block|}
name|malo_bar0_write4
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|malo_hwspecs
operator|.
name|rxdesc_read
argument_list|,
name|readptr
argument_list|)
expr_stmt|;
name|sc
operator|->
name|malo_rxnext
operator|=
name|bf
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_OACTIVE
operator|)
operator|==
literal|0
operator|&&
operator|!
name|IFQ_IS_EMPTY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
condition|)
name|malo_start
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|IEEE80211_DIR_DSTODS
block|}
end_function

begin_function
specifier|static
name|void
name|malo_stop
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|int
name|disable
parameter_list|)
block|{
name|struct
name|malo_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|MALO_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|malo_stop_locked
argument_list|(
name|ifp
argument_list|,
name|disable
argument_list|)
expr_stmt|;
name|MALO_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Reclaim all tx queue resources.  */
end_comment

begin_function
specifier|static
name|void
name|malo_tx_cleanup
parameter_list|(
name|struct
name|malo_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MALO_NUM_TX_QUEUES
condition|;
name|i
operator|++
control|)
name|malo_tx_cleanupq
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|malo_txq
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|malo_detach
parameter_list|(
name|struct
name|malo_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|malo_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|MALO_DEBUG_ANY
argument_list|,
literal|"%s: if_flags %x\n"
argument_list|,
name|__func__
argument_list|,
name|ifp
operator|->
name|if_flags
argument_list|)
expr_stmt|;
name|malo_stop
argument_list|(
name|ifp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|malo_tq
operator|!=
name|NULL
condition|)
block|{
name|taskqueue_drain
argument_list|(
name|sc
operator|->
name|malo_tq
argument_list|,
operator|&
name|sc
operator|->
name|malo_rxtask
argument_list|)
expr_stmt|;
name|taskqueue_drain
argument_list|(
name|sc
operator|->
name|malo_tq
argument_list|,
operator|&
name|sc
operator|->
name|malo_txtask
argument_list|)
expr_stmt|;
name|taskqueue_free
argument_list|(
name|sc
operator|->
name|malo_tq
argument_list|)
expr_stmt|;
name|sc
operator|->
name|malo_tq
operator|=
name|NULL
expr_stmt|;
block|}
name|bpfdetach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* 	 * NB: the order of these is important: 	 * o call the 802.11 layer before detaching the hal to 	 *   insure callbacks into the driver to delete global 	 *   key cache entries can be handled 	 * o reclaim the tx queue data structures after calling 	 *   the 802.11 layer as we'll get called back to reclaim 	 *   node state and potentially want to use them 	 * o to cleanup the tx queues the hal is called, so detach 	 *   it last 	 * Other than that, it's straightforward... 	 */
name|ieee80211_ifdetach
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|malo_dma_cleanup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|malo_tx_cleanup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|malo_hal_detach
argument_list|(
name|sc
operator|->
name|malo_mh
argument_list|)
expr_stmt|;
name|if_free
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|MALO_LOCK_DESTROY
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|malo_shutdown
parameter_list|(
name|struct
name|malo_softc
modifier|*
name|sc
parameter_list|)
block|{
name|malo_stop
argument_list|(
name|sc
operator|->
name|malo_ifp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|malo_suspend
parameter_list|(
name|struct
name|malo_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|malo_ifp
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|MALO_DEBUG_ANY
argument_list|,
literal|"%s: if_flags %x\n"
argument_list|,
name|__func__
argument_list|,
name|ifp
operator|->
name|if_flags
argument_list|)
expr_stmt|;
name|malo_stop
argument_list|(
name|ifp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|malo_resume
parameter_list|(
name|struct
name|malo_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|malo_ifp
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|MALO_DEBUG_ANY
argument_list|,
literal|"%s: if_flags %x\n"
argument_list|,
name|__func__
argument_list|,
name|ifp
operator|->
name|if_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
name|malo_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

