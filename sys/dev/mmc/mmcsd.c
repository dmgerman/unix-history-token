begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2006 Bernd Walter.  All rights reserved.  * Copyright (c) 2006 M. Warner Losh.  All rights reserved.  * Copyright (c) 2017 Marius Strobl<marius@FreeBSD.org>  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * Portions of this software may have been developed with reference to  * the SD Simplified Specification.  The following disclaimer may apply:  *  * The following conditions apply to the release of the simplified  * specification ("Simplified Specification") by the SD Card Association and  * the SD Group. The Simplified Specification is a subset of the complete SD  * Specification which is owned by the SD Card Association and the SD  * Group. This Simplified Specification is provided on a non-confidential  * basis subject to the disclaimers below. Any implementation of the  * Simplified Specification may require a license from the SD Card  * Association, SD Group, SD-3C LLC or other third parties.  *  * Disclaimers:  *  * The information contained in the Simplified Specification is presented only  * as a standard specification for SD Cards and SD Host/Ancillary products and  * is provided "AS-IS" without any representations or warranties of any  * kind. No responsibility is assumed by the SD Group, SD-3C LLC or the SD  * Card Association for any damages, any infringements of patents or other  * right of the SD Group, SD-3C LLC, the SD Card Association or any third  * parties, which may result from its use. No license is granted by  * implication, estoppel or otherwise under any patent or other rights of the  * SD Group, SD-3C LLC, the SD Card Association or any third party. Nothing  * herein shall be construed as an obligation by the SD Group, the SD-3C LLC  * or the SD Card Association to disclose or distribute any technical  * information, know-how or other confidential information to any third party.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bio.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioccom.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/slicer.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<geom/geom.h>
end_include

begin_include
include|#
directive|include
file|<geom/geom_disk.h>
end_include

begin_include
include|#
directive|include
file|<dev/mmc/bridge.h>
end_include

begin_include
include|#
directive|include
file|<dev/mmc/mmc_ioctl.h>
end_include

begin_include
include|#
directive|include
file|<dev/mmc/mmc_subr.h>
end_include

begin_include
include|#
directive|include
file|<dev/mmc/mmcbrvar.h>
end_include

begin_include
include|#
directive|include
file|<dev/mmc/mmcreg.h>
end_include

begin_include
include|#
directive|include
file|<dev/mmc/mmcvar.h>
end_include

begin_include
include|#
directive|include
file|"mmcbus_if.h"
end_include

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|800002
end_if

begin_define
define|#
directive|define
name|kproc_create
value|kthread_create
end_define

begin_define
define|#
directive|define
name|kproc_exit
value|kthread_exit
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|MMCSD_CMD_RETRIES
value|5
end_define

begin_define
define|#
directive|define
name|MMCSD_FMT_BOOT
value|"mmcsd%dboot"
end_define

begin_define
define|#
directive|define
name|MMCSD_FMT_GP
value|"mmcsd%dgp"
end_define

begin_define
define|#
directive|define
name|MMCSD_FMT_RPMB
value|"mmcsd%drpmb"
end_define

begin_define
define|#
directive|define
name|MMCSD_LABEL_ENH
value|"enh"
end_define

begin_define
define|#
directive|define
name|MMCSD_PART_NAMELEN
value|(16 + 1)
end_define

begin_struct_decl
struct_decl|struct
name|mmcsd_softc
struct_decl|;
end_struct_decl

begin_struct
struct|struct
name|mmcsd_part
block|{
name|struct
name|mtx
name|disk_mtx
decl_stmt|;
name|struct
name|mtx
name|ioctl_mtx
decl_stmt|;
name|struct
name|mmcsd_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|disk
modifier|*
name|disk
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|bio_queue_head
name|bio_queue
decl_stmt|;
name|daddr_t
name|eblock
decl_stmt|,
name|eend
decl_stmt|;
comment|/* Range remaining after the last erase. */
name|u_int
name|cnt
decl_stmt|;
name|u_int
name|type
decl_stmt|;
name|int
name|running
decl_stmt|;
name|int
name|suspend
decl_stmt|;
name|int
name|ioctl
decl_stmt|;
name|bool
name|ro
decl_stmt|;
name|char
name|name
index|[
name|MMCSD_PART_NAMELEN
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|mmcsd_softc
block|{
name|device_t
name|dev
decl_stmt|;
name|device_t
name|mmcbus
decl_stmt|;
name|struct
name|mmcsd_part
modifier|*
name|part
index|[
name|MMC_PART_MAX
index|]
decl_stmt|;
name|enum
name|mmc_card_mode
name|mode
decl_stmt|;
name|u_int
name|max_data
decl_stmt|;
comment|/* Maximum data size [blocks] */
name|u_int
name|erase_sector
decl_stmt|;
comment|/* Device native erase sector size [blocks] */
name|uint8_t
name|high_cap
decl_stmt|;
comment|/* High Capacity device (block addressed) */
name|uint8_t
name|part_curr
decl_stmt|;
comment|/* Partition currently switched to */
name|uint8_t
name|ext_csd
index|[
name|MMC_EXTCSD_SIZE
index|]
decl_stmt|;
name|uint16_t
name|rca
decl_stmt|;
name|uint32_t
name|part_time
decl_stmt|;
comment|/* Partition switch timeout [us] */
name|off_t
name|enh_base
decl_stmt|;
comment|/* Enhanced user data area slice base ... */
name|off_t
name|enh_size
decl_stmt|;
comment|/* ... and size [bytes] */
name|int
name|log_count
decl_stmt|;
name|struct
name|timeval
name|log_time
decl_stmt|;
name|struct
name|cdev
modifier|*
name|rpmb_dev
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|errmsg
index|[]
init|=
block|{
literal|"None"
block|,
literal|"Timeout"
block|,
literal|"Bad CRC"
block|,
literal|"Fifo"
block|,
literal|"Failed"
block|,
literal|"Invalid"
block|,
literal|"NO MEMORY"
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|LOG_PPS
value|5
end_define

begin_comment
comment|/* Log no more than 5 errors per second. */
end_comment

begin_comment
comment|/* bus entry points */
end_comment

begin_function_decl
specifier|static
name|int
name|mmcsd_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mmcsd_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mmcsd_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* disk routines */
end_comment

begin_function_decl
specifier|static
name|int
name|mmcsd_close
parameter_list|(
name|struct
name|disk
modifier|*
name|dp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mmcsd_dump
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|void
modifier|*
name|virtual
parameter_list|,
name|vm_offset_t
name|physical
parameter_list|,
name|off_t
name|offset
parameter_list|,
name|size_t
name|length
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mmcsd_getattr
parameter_list|(
name|struct
name|bio
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mmcsd_ioctl_disk
parameter_list|(
name|struct
name|disk
modifier|*
name|disk
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|int
name|fflag
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mmcsd_open
parameter_list|(
name|struct
name|disk
modifier|*
name|dp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mmcsd_strategy
parameter_list|(
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mmcsd_task
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* RMPB cdev interface */
end_comment

begin_function_decl
specifier|static
name|int
name|mmcsd_ioctl_rpmb
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|int
name|fflag
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mmcsd_add_part
parameter_list|(
name|struct
name|mmcsd_softc
modifier|*
name|sc
parameter_list|,
name|u_int
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|u_int
name|cnt
parameter_list|,
name|off_t
name|media_size
parameter_list|,
name|off_t
name|erase_size
parameter_list|,
name|bool
name|ro
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mmcsd_bus_bit_width
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|daddr_t
name|mmcsd_delete
parameter_list|(
name|struct
name|mmcsd_part
modifier|*
name|part
parameter_list|,
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mmcsd_ioctl
parameter_list|(
name|struct
name|mmcsd_part
modifier|*
name|part
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|int
name|fflag
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mmcsd_ioctl_cmd
parameter_list|(
name|struct
name|mmcsd_part
modifier|*
name|part
parameter_list|,
name|struct
name|mmc_ioc_cmd
modifier|*
name|mic
parameter_list|,
name|int
name|fflag
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uintmax_t
name|mmcsd_pretty_size
parameter_list|(
name|off_t
name|size
parameter_list|,
name|char
modifier|*
name|unit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|daddr_t
name|mmcsd_rw
parameter_list|(
name|struct
name|mmcsd_part
modifier|*
name|part
parameter_list|,
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mmcsd_set_blockcount
parameter_list|(
name|struct
name|mmcsd_softc
modifier|*
name|sc
parameter_list|,
name|u_int
name|count
parameter_list|,
name|bool
name|rel
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mmcsd_slicer
parameter_list|(
name|device_t
name|dev
parameter_list|,
specifier|const
name|char
modifier|*
name|provider
parameter_list|,
name|struct
name|flash_slice
modifier|*
name|slices
parameter_list|,
name|int
modifier|*
name|nslices
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mmcsd_switch_part
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|dev
parameter_list|,
name|uint16_t
name|rca
parameter_list|,
name|u_int
name|part
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|MMCSD_DISK_LOCK
parameter_list|(
name|_part
parameter_list|)
value|mtx_lock(&(_part)->disk_mtx)
end_define

begin_define
define|#
directive|define
name|MMCSD_DISK_UNLOCK
parameter_list|(
name|_part
parameter_list|)
value|mtx_unlock(&(_part)->disk_mtx)
end_define

begin_define
define|#
directive|define
name|MMCSD_DISK_LOCK_INIT
parameter_list|(
name|_part
parameter_list|)
define|\
value|mtx_init(&(_part)->disk_mtx, (_part)->name, "mmcsd disk", MTX_DEF)
end_define

begin_define
define|#
directive|define
name|MMCSD_DISK_LOCK_DESTROY
parameter_list|(
name|_part
parameter_list|)
value|mtx_destroy(&(_part)->disk_mtx);
end_define

begin_define
define|#
directive|define
name|MMCSD_DISK_ASSERT_LOCKED
parameter_list|(
name|_part
parameter_list|)
define|\
value|mtx_assert(&(_part)->disk_mtx, MA_OWNED);
end_define

begin_define
define|#
directive|define
name|MMCSD_DISK_ASSERT_UNLOCKED
parameter_list|(
name|_part
parameter_list|)
define|\
value|mtx_assert(&(_part)->disk_mtx, MA_NOTOWNED);
end_define

begin_define
define|#
directive|define
name|MMCSD_IOCTL_LOCK
parameter_list|(
name|_part
parameter_list|)
value|mtx_lock(&(_part)->ioctl_mtx)
end_define

begin_define
define|#
directive|define
name|MMCSD_IOCTL_UNLOCK
parameter_list|(
name|_part
parameter_list|)
value|mtx_unlock(&(_part)->ioctl_mtx)
end_define

begin_define
define|#
directive|define
name|MMCSD_IOCTL_LOCK_INIT
parameter_list|(
name|_part
parameter_list|)
define|\
value|mtx_init(&(_part)->ioctl_mtx, (_part)->name, "mmcsd IOCTL", MTX_DEF)
end_define

begin_define
define|#
directive|define
name|MMCSD_IOCTL_LOCK_DESTROY
parameter_list|(
name|_part
parameter_list|)
value|mtx_destroy(&(_part)->ioctl_mtx);
end_define

begin_define
define|#
directive|define
name|MMCSD_IOCTL_ASSERT_LOCKED
parameter_list|(
name|_part
parameter_list|)
define|\
value|mtx_assert(&(_part)->ioctl_mtx, MA_OWNED);
end_define

begin_define
define|#
directive|define
name|MMCSD_IOCLT_ASSERT_UNLOCKED
parameter_list|(
name|_part
parameter_list|)
define|\
value|mtx_assert(&(_part)->ioctl_mtx, MA_NOTOWNED);
end_define

begin_function
specifier|static
name|int
name|mmcsd_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|device_quiet
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"MMC/SD Memory Card"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mmcsd_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|device_t
name|mmcbus
decl_stmt|;
name|struct
name|mmcsd_softc
modifier|*
name|sc
decl_stmt|;
specifier|const
name|uint8_t
modifier|*
name|ext_csd
decl_stmt|;
name|off_t
name|erase_size
decl_stmt|,
name|sector_size
decl_stmt|,
name|size
decl_stmt|,
name|wp_size
decl_stmt|;
name|uintmax_t
name|bytes
decl_stmt|;
name|int
name|err
decl_stmt|,
name|i
decl_stmt|;
name|uint8_t
name|rev
decl_stmt|;
name|bool
name|comp
decl_stmt|,
name|ro
decl_stmt|;
name|char
name|unit
index|[
literal|2
index|]
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|sc
operator|->
name|mmcbus
operator|=
name|mmcbus
operator|=
name|device_get_parent
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mode
operator|=
name|mmcbr_get_mode
argument_list|(
name|mmcbus
argument_list|)
expr_stmt|;
comment|/* 	 * Note that in principle with an SDHCI-like re-tuning implementation, 	 * the maximum data size can change at runtime due to a device removal/ 	 * insertion that results in switches to/from a transfer mode involving 	 * re-tuning, iff there are multiple devices on a given bus.  Until now 	 * mmc(4) lacks support for rescanning already attached buses, however, 	 * and sdhci(4) to date has no support for shared buses in the first 	 * place either. 	 */
name|sc
operator|->
name|max_data
operator|=
name|mmc_get_max_data
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|erase_sector
operator|=
name|mmc_get_erase_sector
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|high_cap
operator|=
name|mmc_get_high_cap
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rca
operator|=
name|mmc_get_rca
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Only MMC>= 4.x devices support EXT_CSD. */
if|if
condition|(
name|mmc_get_spec_vers
argument_list|(
name|dev
argument_list|)
operator|>=
literal|4
condition|)
block|{
name|MMCBUS_ACQUIRE_BUS
argument_list|(
name|mmcbus
argument_list|,
name|dev
argument_list|)
expr_stmt|;
name|err
operator|=
name|mmc_send_ext_csd
argument_list|(
name|mmcbus
argument_list|,
name|dev
argument_list|,
name|sc
operator|->
name|ext_csd
argument_list|)
expr_stmt|;
name|MMCBUS_RELEASE_BUS
argument_list|(
name|mmcbus
argument_list|,
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|MMC_ERR_NONE
condition|)
name|bzero
argument_list|(
name|sc
operator|->
name|ext_csd
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|ext_csd
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ext_csd
operator|=
name|sc
operator|->
name|ext_csd
expr_stmt|;
comment|/* 	 * Enhanced user data area and general purpose partitions are only 	 * supported in revision 1.4 (EXT_CSD_REV == 4) and later, the RPMB 	 * partition in revision 1.5 (MMC v4.41, EXT_CSD_REV == 5) and later. 	 */
name|rev
operator|=
name|ext_csd
index|[
name|EXT_CSD_REV
index|]
expr_stmt|;
comment|/* 	 * Ignore user-creatable enhanced user data area and general purpose 	 * partitions partitions as long as partitioning hasn't been finished. 	 */
name|comp
operator|=
operator|(
name|ext_csd
index|[
name|EXT_CSD_PART_SET
index|]
operator|&
name|EXT_CSD_PART_SET_COMPLETED
operator|)
operator|!=
literal|0
expr_stmt|;
comment|/* 	 * Add enhanced user data area slice, unless it spans the entirety of 	 * the user data area.  The enhanced area is of a multiple of high 	 * capacity write protect groups ((ERASE_GRP_SIZE + HC_WP_GRP_SIZE) * 	 * 512 KB) and its offset given in either sectors or bytes, depending 	 * on whether it's a high capacity device or not. 	 * NB: The slicer and its slices need to be registered before adding 	 *     the disk for the corresponding user data area as re-tasting is 	 *     racy. 	 */
name|sector_size
operator|=
name|mmc_get_sector_size
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|size
operator|=
name|ext_csd
index|[
name|EXT_CSD_ENH_SIZE_MULT
index|]
operator|+
operator|(
name|ext_csd
index|[
name|EXT_CSD_ENH_SIZE_MULT
operator|+
literal|1
index|]
operator|<<
literal|8
operator|)
operator|+
operator|(
name|ext_csd
index|[
name|EXT_CSD_ENH_SIZE_MULT
operator|+
literal|2
index|]
operator|<<
literal|16
operator|)
expr_stmt|;
if|if
condition|(
name|rev
operator|>=
literal|4
operator|&&
name|comp
operator|==
name|TRUE
operator|&&
name|size
operator|>
literal|0
operator|&&
operator|(
name|ext_csd
index|[
name|EXT_CSD_PART_SUPPORT
index|]
operator|&
name|EXT_CSD_PART_SUPPORT_ENH_ATTR_EN
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|ext_csd
index|[
name|EXT_CSD_PART_ATTR
index|]
operator|&
operator|(
name|EXT_CSD_PART_ATTR_ENH_USR
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|erase_size
operator|=
name|ext_csd
index|[
name|EXT_CSD_ERASE_GRP_SIZE
index|]
operator|*
literal|1024
operator|*
name|MMC_SECTOR_SIZE
expr_stmt|;
name|wp_size
operator|=
name|ext_csd
index|[
name|EXT_CSD_HC_WP_GRP_SIZE
index|]
expr_stmt|;
name|size
operator|*=
name|erase_size
operator|*
name|wp_size
expr_stmt|;
if|if
condition|(
name|size
operator|!=
name|mmc_get_media_size
argument_list|(
name|dev
argument_list|)
operator|*
name|sector_size
condition|)
block|{
name|sc
operator|->
name|enh_size
operator|=
name|size
expr_stmt|;
name|sc
operator|->
name|enh_base
operator|=
operator|(
name|ext_csd
index|[
name|EXT_CSD_ENH_START_ADDR
index|]
operator|+
operator|(
name|ext_csd
index|[
name|EXT_CSD_ENH_START_ADDR
operator|+
literal|1
index|]
operator|<<
literal|8
operator|)
operator|+
operator|(
name|ext_csd
index|[
name|EXT_CSD_ENH_START_ADDR
operator|+
literal|2
index|]
operator|<<
literal|16
operator|)
operator|+
operator|(
name|ext_csd
index|[
name|EXT_CSD_ENH_START_ADDR
operator|+
literal|3
index|]
operator|<<
literal|24
operator|)
operator|)
operator|*
operator|(
name|sc
operator|->
name|high_cap
operator|!=
literal|0
condition|?
name|MMC_SECTOR_SIZE
else|:
literal|1
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"enhanced user data area spans entire device\n"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Add default partition.  This may be the only one or the user 	 * data area in case partitions are supported. 	 */
name|ro
operator|=
name|mmc_get_read_only
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mmcsd_add_part
argument_list|(
name|sc
argument_list|,
name|EXT_CSD_PART_CONFIG_ACC_DEFAULT
argument_list|,
literal|"mmcsd"
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|,
name|mmc_get_media_size
argument_list|(
name|dev
argument_list|)
operator|*
name|sector_size
argument_list|,
name|sc
operator|->
name|erase_sector
operator|*
name|sector_size
argument_list|,
name|ro
argument_list|)
expr_stmt|;
if|if
condition|(
name|mmc_get_spec_vers
argument_list|(
name|dev
argument_list|)
operator|<
literal|3
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Belatedly announce enhanced user data slice. */
if|if
condition|(
name|sc
operator|->
name|enh_size
operator|!=
literal|0
condition|)
block|{
name|bytes
operator|=
name|mmcsd_pretty_size
argument_list|(
name|size
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|FLASH_SLICES_FMT
literal|": %ju%sB enhanced user data area "
literal|"slice offset 0x%jx at %s\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|,
name|MMCSD_LABEL_ENH
argument_list|,
name|bytes
argument_list|,
name|unit
argument_list|,
operator|(
name|uintmax_t
operator|)
name|sc
operator|->
name|enh_base
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Determine partition switch timeout (provided in units of 10 ms) 	 * and ensure it's at least 300 ms as some eMMC chips lie. 	 */
name|sc
operator|->
name|part_time
operator|=
name|max
argument_list|(
name|ext_csd
index|[
name|EXT_CSD_PART_SWITCH_TO
index|]
operator|*
literal|10
operator|*
literal|1000
argument_list|,
literal|300
operator|*
literal|1000
argument_list|)
expr_stmt|;
comment|/* Add boot partitions, which are of a fixed multiple of 128 KB. */
name|size
operator|=
name|ext_csd
index|[
name|EXT_CSD_BOOT_SIZE_MULT
index|]
operator|*
name|MMC_BOOT_RPMB_BLOCK_SIZE
expr_stmt|;
if|if
condition|(
name|size
operator|>
literal|0
operator|&&
operator|(
name|mmcbr_get_caps
argument_list|(
name|mmcbus
argument_list|)
operator|&
name|MMC_CAP_BOOT_NOACC
operator|)
operator|==
literal|0
condition|)
block|{
name|mmcsd_add_part
argument_list|(
name|sc
argument_list|,
name|EXT_CSD_PART_CONFIG_ACC_BOOT0
argument_list|,
name|MMCSD_FMT_BOOT
argument_list|,
literal|0
argument_list|,
name|size
argument_list|,
name|MMC_BOOT_RPMB_BLOCK_SIZE
argument_list|,
name|ro
operator||
operator|(
operator|(
name|ext_csd
index|[
name|EXT_CSD_BOOT_WP_STATUS
index|]
operator|&
name|EXT_CSD_BOOT_WP_STATUS_BOOT0_MASK
operator|)
operator|!=
literal|0
operator|)
argument_list|)
expr_stmt|;
name|mmcsd_add_part
argument_list|(
name|sc
argument_list|,
name|EXT_CSD_PART_CONFIG_ACC_BOOT1
argument_list|,
name|MMCSD_FMT_BOOT
argument_list|,
literal|1
argument_list|,
name|size
argument_list|,
name|MMC_BOOT_RPMB_BLOCK_SIZE
argument_list|,
name|ro
operator||
operator|(
operator|(
name|ext_csd
index|[
name|EXT_CSD_BOOT_WP_STATUS
index|]
operator|&
name|EXT_CSD_BOOT_WP_STATUS_BOOT1_MASK
operator|)
operator|!=
literal|0
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* Add RPMB partition, which also is of a fixed multiple of 128 KB. */
name|size
operator|=
name|ext_csd
index|[
name|EXT_CSD_RPMB_MULT
index|]
operator|*
name|MMC_BOOT_RPMB_BLOCK_SIZE
expr_stmt|;
if|if
condition|(
name|rev
operator|>=
literal|5
operator|&&
name|size
operator|>
literal|0
condition|)
name|mmcsd_add_part
argument_list|(
name|sc
argument_list|,
name|EXT_CSD_PART_CONFIG_ACC_RPMB
argument_list|,
name|MMCSD_FMT_RPMB
argument_list|,
literal|0
argument_list|,
name|size
argument_list|,
name|MMC_BOOT_RPMB_BLOCK_SIZE
argument_list|,
name|ro
argument_list|)
expr_stmt|;
if|if
condition|(
name|rev
operator|<=
literal|3
operator|||
name|comp
operator|==
name|FALSE
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Add general purpose partitions, which are of a multiple of high 	 * capacity write protect groups, too. 	 */
if|if
condition|(
operator|(
name|ext_csd
index|[
name|EXT_CSD_PART_SUPPORT
index|]
operator|&
name|EXT_CSD_PART_SUPPORT_EN
operator|)
operator|!=
literal|0
condition|)
block|{
name|erase_size
operator|=
name|ext_csd
index|[
name|EXT_CSD_ERASE_GRP_SIZE
index|]
operator|*
literal|1024
operator|*
name|MMC_SECTOR_SIZE
expr_stmt|;
name|wp_size
operator|=
name|ext_csd
index|[
name|EXT_CSD_HC_WP_GRP_SIZE
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MMC_PART_GP_MAX
condition|;
name|i
operator|++
control|)
block|{
name|size
operator|=
name|ext_csd
index|[
name|EXT_CSD_GP_SIZE_MULT
operator|+
name|i
operator|*
literal|3
index|]
operator|+
operator|(
name|ext_csd
index|[
name|EXT_CSD_GP_SIZE_MULT
operator|+
name|i
operator|*
literal|3
operator|+
literal|1
index|]
operator|<<
literal|8
operator|)
operator|+
operator|(
name|ext_csd
index|[
name|EXT_CSD_GP_SIZE_MULT
operator|+
name|i
operator|*
literal|3
operator|+
literal|2
index|]
operator|<<
literal|16
operator|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
continue|continue;
name|mmcsd_add_part
argument_list|(
name|sc
argument_list|,
name|EXT_CSD_PART_CONFIG_ACC_GP0
operator|+
name|i
argument_list|,
name|MMCSD_FMT_GP
argument_list|,
name|i
argument_list|,
name|size
operator|*
name|erase_size
operator|*
name|wp_size
argument_list|,
name|erase_size
argument_list|,
name|ro
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uintmax_t
name|mmcsd_pretty_size
parameter_list|(
name|off_t
name|size
parameter_list|,
name|char
modifier|*
name|unit
parameter_list|)
block|{
name|uintmax_t
name|bytes
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * Display in most natural units.  There's no card< 1MB.  However, 	 * RPMB partitions occasionally are smaller than that, though.  The 	 * SD standard goes to 2 GiB due to its reliance on FAT, but the data 	 * format supports up to 4 GiB and some card makers push it up to this 	 * limit.  The SDHC standard only goes to 32 GiB due to FAT32, but the 	 * data format supports up to 2 TiB however.  2048 GB isn't too ugly, 	 * so we note it in passing here and don't add the code to print TB). 	 * Since these cards are sold in terms of MB and GB not MiB and GiB, 	 * report them like that.  We also round to the nearest unit, since 	 * many cards are a few percent short, even of the power of 10 size. 	 */
name|bytes
operator|=
name|size
expr_stmt|;
name|unit
index|[
literal|0
index|]
operator|=
name|unit
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
literal|2
operator|&&
name|bytes
operator|>=
literal|1000
condition|;
name|i
operator|++
control|)
block|{
name|bytes
operator|=
operator|(
name|bytes
operator|+
literal|1000
operator|/
literal|2
operator|-
literal|1
operator|)
operator|/
literal|1000
expr_stmt|;
switch|switch
condition|(
name|i
condition|)
block|{
case|case
literal|0
case|:
name|unit
index|[
literal|0
index|]
operator|=
literal|'k'
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|unit
index|[
literal|0
index|]
operator|=
literal|'M'
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|unit
index|[
literal|0
index|]
operator|=
literal|'G'
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
return|return
operator|(
name|bytes
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|mmcsd_rpmb_cdevsw
init|=
block|{
operator|.
name|d_version
operator|=
name|D_VERSION
block|,
operator|.
name|d_name
operator|=
literal|"mmcsdrpmb"
block|,
operator|.
name|d_ioctl
operator|=
name|mmcsd_ioctl_rpmb
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|mmcsd_add_part
parameter_list|(
name|struct
name|mmcsd_softc
modifier|*
name|sc
parameter_list|,
name|u_int
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|u_int
name|cnt
parameter_list|,
name|off_t
name|media_size
parameter_list|,
name|off_t
name|erase_size
parameter_list|,
name|bool
name|ro
parameter_list|)
block|{
name|struct
name|make_dev_args
name|args
decl_stmt|;
name|device_t
name|dev
decl_stmt|,
name|mmcbus
decl_stmt|;
specifier|const
name|char
modifier|*
name|ext
decl_stmt|;
specifier|const
name|uint8_t
modifier|*
name|ext_csd
decl_stmt|;
name|struct
name|mmcsd_part
modifier|*
name|part
decl_stmt|;
name|struct
name|disk
modifier|*
name|d
decl_stmt|;
name|uintmax_t
name|bytes
decl_stmt|;
name|u_int
name|gp
decl_stmt|;
name|uint32_t
name|speed
decl_stmt|;
name|uint8_t
name|extattr
decl_stmt|;
name|bool
name|enh
decl_stmt|;
name|char
name|unit
index|[
literal|2
index|]
decl_stmt|;
name|dev
operator|=
name|sc
operator|->
name|dev
expr_stmt|;
name|mmcbus
operator|=
name|sc
operator|->
name|mmcbus
expr_stmt|;
name|part
operator|=
name|sc
operator|->
name|part
index|[
name|type
index|]
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|part
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|part
operator|->
name|sc
operator|=
name|sc
expr_stmt|;
name|part
operator|->
name|cnt
operator|=
name|cnt
expr_stmt|;
name|part
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|part
operator|->
name|ro
operator|=
name|ro
expr_stmt|;
name|snprintf
argument_list|(
name|part
operator|->
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|part
operator|->
name|name
argument_list|)
argument_list|,
name|name
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|MMCSD_IOCTL_LOCK_INIT
argument_list|(
name|part
argument_list|)
expr_stmt|;
comment|/* 	 * For the RPMB partition, allow IOCTL access only. 	 * NB: If ever attaching RPMB partitions to disk(9), the re-tuning 	 *     implementation and especially its pausing need to be revisited, 	 *     because then re-tuning requests may be issued by the IOCTL half 	 *     of this driver while re-tuning is already paused by the disk(9) 	 *     one and vice versa. 	 */
if|if
condition|(
name|type
operator|==
name|EXT_CSD_PART_CONFIG_ACC_RPMB
condition|)
block|{
name|make_dev_args_init
argument_list|(
operator|&
name|args
argument_list|)
expr_stmt|;
name|args
operator|.
name|mda_flags
operator|=
name|MAKEDEV_CHECKNAME
operator||
name|MAKEDEV_WAITOK
expr_stmt|;
name|args
operator|.
name|mda_devsw
operator|=
operator|&
name|mmcsd_rpmb_cdevsw
expr_stmt|;
name|args
operator|.
name|mda_uid
operator|=
name|UID_ROOT
expr_stmt|;
name|args
operator|.
name|mda_gid
operator|=
name|GID_OPERATOR
expr_stmt|;
name|args
operator|.
name|mda_mode
operator|=
literal|0640
expr_stmt|;
name|args
operator|.
name|mda_si_drv1
operator|=
name|part
expr_stmt|;
if|if
condition|(
name|make_dev_s
argument_list|(
operator|&
name|args
argument_list|,
operator|&
name|sc
operator|->
name|rpmb_dev
argument_list|,
literal|"%s"
argument_list|,
name|part
operator|->
name|name
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Failed to make RPMB device\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|part
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
name|MMCSD_DISK_LOCK_INIT
argument_list|(
name|part
argument_list|)
expr_stmt|;
name|d
operator|=
name|part
operator|->
name|disk
operator|=
name|disk_alloc
argument_list|()
expr_stmt|;
name|d
operator|->
name|d_open
operator|=
name|mmcsd_open
expr_stmt|;
name|d
operator|->
name|d_close
operator|=
name|mmcsd_close
expr_stmt|;
name|d
operator|->
name|d_strategy
operator|=
name|mmcsd_strategy
expr_stmt|;
name|d
operator|->
name|d_ioctl
operator|=
name|mmcsd_ioctl_disk
expr_stmt|;
name|d
operator|->
name|d_dump
operator|=
name|mmcsd_dump
expr_stmt|;
name|d
operator|->
name|d_getattr
operator|=
name|mmcsd_getattr
expr_stmt|;
name|d
operator|->
name|d_name
operator|=
name|part
operator|->
name|name
expr_stmt|;
name|d
operator|->
name|d_drv1
operator|=
name|part
expr_stmt|;
name|d
operator|->
name|d_sectorsize
operator|=
name|mmc_get_sector_size
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|d
operator|->
name|d_maxsize
operator|=
name|sc
operator|->
name|max_data
operator|*
name|d
operator|->
name|d_sectorsize
expr_stmt|;
name|d
operator|->
name|d_mediasize
operator|=
name|media_size
expr_stmt|;
name|d
operator|->
name|d_stripesize
operator|=
name|erase_size
expr_stmt|;
name|d
operator|->
name|d_unit
operator|=
name|cnt
expr_stmt|;
name|d
operator|->
name|d_flags
operator|=
name|DISKFLAG_CANDELETE
expr_stmt|;
name|d
operator|->
name|d_delmaxsize
operator|=
name|erase_size
expr_stmt|;
name|strlcpy
argument_list|(
name|d
operator|->
name|d_ident
argument_list|,
name|mmc_get_card_sn_string
argument_list|(
name|dev
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|d
operator|->
name|d_ident
argument_list|)
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|d
operator|->
name|d_descr
argument_list|,
name|mmc_get_card_id_string
argument_list|(
name|dev
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|d
operator|->
name|d_descr
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|->
name|d_rotation_rate
operator|=
name|DISK_RR_NON_ROTATING
expr_stmt|;
name|disk_create
argument_list|(
name|d
argument_list|,
name|DISK_VERSION
argument_list|)
expr_stmt|;
name|bioq_init
argument_list|(
operator|&
name|part
operator|->
name|bio_queue
argument_list|)
expr_stmt|;
name|part
operator|->
name|running
operator|=
literal|1
expr_stmt|;
name|kproc_create
argument_list|(
operator|&
name|mmcsd_task
argument_list|,
name|part
argument_list|,
operator|&
name|part
operator|->
name|p
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"%s%d: mmc/sd card"
argument_list|,
name|part
operator|->
name|name
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
block|}
name|bytes
operator|=
name|mmcsd_pretty_size
argument_list|(
name|media_size
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|EXT_CSD_PART_CONFIG_ACC_DEFAULT
condition|)
block|{
name|speed
operator|=
name|mmcbr_get_clock
argument_list|(
name|mmcbus
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s%d: %ju%sB<%s>%s at %s %d.%01dMHz/%dbit/%d-block\n"
argument_list|,
name|part
operator|->
name|name
argument_list|,
name|cnt
argument_list|,
name|bytes
argument_list|,
name|unit
argument_list|,
name|mmc_get_card_id_string
argument_list|(
name|dev
argument_list|)
argument_list|,
name|ro
condition|?
literal|" (read-only)"
else|:
literal|""
argument_list|,
name|device_get_nameunit
argument_list|(
name|mmcbus
argument_list|)
argument_list|,
name|speed
operator|/
literal|1000000
argument_list|,
operator|(
name|speed
operator|/
literal|100000
operator|)
operator|%
literal|10
argument_list|,
name|mmcsd_bus_bit_width
argument_list|(
name|dev
argument_list|)
argument_list|,
name|sc
operator|->
name|max_data
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|EXT_CSD_PART_CONFIG_ACC_RPMB
condition|)
block|{
name|printf
argument_list|(
literal|"%s: %ju%sB partion %d%s at %s\n"
argument_list|,
name|part
operator|->
name|name
argument_list|,
name|bytes
argument_list|,
name|unit
argument_list|,
name|type
argument_list|,
name|ro
condition|?
literal|" (read-only)"
else|:
literal|""
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|enh
operator|=
name|false
expr_stmt|;
name|ext
operator|=
name|NULL
expr_stmt|;
name|extattr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|type
operator|>=
name|EXT_CSD_PART_CONFIG_ACC_GP0
operator|&&
name|type
operator|<=
name|EXT_CSD_PART_CONFIG_ACC_GP3
condition|)
block|{
name|ext_csd
operator|=
name|sc
operator|->
name|ext_csd
expr_stmt|;
name|gp
operator|=
name|type
operator|-
name|EXT_CSD_PART_CONFIG_ACC_GP0
expr_stmt|;
if|if
condition|(
operator|(
name|ext_csd
index|[
name|EXT_CSD_PART_SUPPORT
index|]
operator|&
name|EXT_CSD_PART_SUPPORT_ENH_ATTR_EN
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|ext_csd
index|[
name|EXT_CSD_PART_ATTR
index|]
operator|&
operator|(
name|EXT_CSD_PART_ATTR_ENH_GP0
operator|<<
name|gp
operator|)
operator|)
operator|!=
literal|0
condition|)
name|enh
operator|=
name|true
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|ext_csd
index|[
name|EXT_CSD_PART_SUPPORT
index|]
operator|&
name|EXT_CSD_PART_SUPPORT_EXT_ATTR_EN
operator|)
operator|!=
literal|0
condition|)
block|{
name|extattr
operator|=
operator|(
name|ext_csd
index|[
name|EXT_CSD_EXT_PART_ATTR
operator|+
operator|(
name|gp
operator|/
literal|2
operator|)
index|]
operator|>>
operator|(
literal|4
operator|*
operator|(
name|gp
operator|%
literal|2
operator|)
operator|)
operator|)
operator|&
literal|0xF
expr_stmt|;
switch|switch
condition|(
name|extattr
condition|)
block|{
case|case
name|EXT_CSD_EXT_PART_ATTR_DEFAULT
case|:
break|break;
case|case
name|EXT_CSD_EXT_PART_ATTR_SYSTEMCODE
case|:
name|ext
operator|=
literal|"system code"
expr_stmt|;
break|break;
case|case
name|EXT_CSD_EXT_PART_ATTR_NPERSISTENT
case|:
name|ext
operator|=
literal|"non-persistent"
expr_stmt|;
break|break;
default|default:
name|ext
operator|=
literal|"reserved"
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|ext
operator|==
name|NULL
condition|)
name|printf
argument_list|(
literal|"%s%d: %ju%sB partion %d%s%s at %s\n"
argument_list|,
name|part
operator|->
name|name
argument_list|,
name|cnt
argument_list|,
name|bytes
argument_list|,
name|unit
argument_list|,
name|type
argument_list|,
name|enh
condition|?
literal|" enhanced"
else|:
literal|""
argument_list|,
name|ro
condition|?
literal|" (read-only)"
else|:
literal|""
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%s%d: %ju%sB partion %d extended 0x%x "
literal|"(%s)%s at %s\n"
argument_list|,
name|part
operator|->
name|name
argument_list|,
name|cnt
argument_list|,
name|bytes
argument_list|,
name|unit
argument_list|,
name|type
argument_list|,
name|extattr
argument_list|,
name|ext
argument_list|,
name|ro
condition|?
literal|" (read-only)"
else|:
literal|""
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|mmcsd_slicer
parameter_list|(
name|device_t
name|dev
parameter_list|,
specifier|const
name|char
modifier|*
name|provider
parameter_list|,
name|struct
name|flash_slice
modifier|*
name|slices
parameter_list|,
name|int
modifier|*
name|nslices
parameter_list|)
block|{
name|char
name|name
index|[
name|MMCSD_PART_NAMELEN
index|]
decl_stmt|;
name|struct
name|mmcsd_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mmcsd_part
modifier|*
name|part
decl_stmt|;
operator|*
name|nslices
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|slices
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|enh_size
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|part
operator|=
name|sc
operator|->
name|part
index|[
name|EXT_CSD_PART_CONFIG_ACC_DEFAULT
index|]
expr_stmt|;
name|snprintf
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
literal|"%s%d"
argument_list|,
name|part
operator|->
name|disk
operator|->
name|d_name
argument_list|,
name|part
operator|->
name|disk
operator|->
name|d_unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|provider
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
operator|*
name|nslices
operator|=
literal|1
expr_stmt|;
name|slices
index|[
literal|0
index|]
operator|.
name|base
operator|=
name|sc
operator|->
name|enh_base
expr_stmt|;
name|slices
index|[
literal|0
index|]
operator|.
name|size
operator|=
name|sc
operator|->
name|enh_size
expr_stmt|;
name|slices
index|[
literal|0
index|]
operator|.
name|label
operator|=
name|MMCSD_LABEL_ENH
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mmcsd_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|mmcsd_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|mmcsd_part
modifier|*
name|part
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MMC_PART_MAX
condition|;
name|i
operator|++
control|)
block|{
name|part
operator|=
name|sc
operator|->
name|part
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|part
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|part
operator|->
name|disk
operator|!=
name|NULL
condition|)
block|{
name|MMCSD_DISK_LOCK
argument_list|(
name|part
argument_list|)
expr_stmt|;
name|part
operator|->
name|suspend
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|part
operator|->
name|running
operator|>
literal|0
condition|)
block|{
comment|/* kill thread */
name|part
operator|->
name|running
operator|=
literal|0
expr_stmt|;
name|wakeup
argument_list|(
name|part
argument_list|)
expr_stmt|;
comment|/* wait for thread to finish. */
while|while
condition|(
name|part
operator|->
name|running
operator|!=
operator|-
literal|1
condition|)
name|msleep
argument_list|(
name|part
argument_list|,
operator|&
name|part
operator|->
name|disk_mtx
argument_list|,
literal|0
argument_list|,
literal|"mmcsd disk detach"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|MMCSD_DISK_UNLOCK
argument_list|(
name|part
argument_list|)
expr_stmt|;
block|}
name|MMCSD_IOCTL_LOCK
argument_list|(
name|part
argument_list|)
expr_stmt|;
while|while
condition|(
name|part
operator|->
name|ioctl
operator|>
literal|0
condition|)
name|msleep
argument_list|(
name|part
argument_list|,
operator|&
name|part
operator|->
name|ioctl_mtx
argument_list|,
literal|0
argument_list|,
literal|"mmcsd IOCTL detach"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|part
operator|->
name|ioctl
operator|=
operator|-
literal|1
expr_stmt|;
name|MMCSD_IOCTL_UNLOCK
argument_list|(
name|part
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sc
operator|->
name|rpmb_dev
operator|!=
name|NULL
condition|)
name|destroy_dev
argument_list|(
name|sc
operator|->
name|rpmb_dev
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MMC_PART_MAX
condition|;
name|i
operator|++
control|)
block|{
name|part
operator|=
name|sc
operator|->
name|part
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|part
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|part
operator|->
name|disk
operator|!=
name|NULL
condition|)
block|{
comment|/* Flush the request queue. */
name|bioq_flush
argument_list|(
operator|&
name|part
operator|->
name|bio_queue
argument_list|,
name|NULL
argument_list|,
name|ENXIO
argument_list|)
expr_stmt|;
comment|/* kill disk */
name|disk_destroy
argument_list|(
name|part
operator|->
name|disk
argument_list|)
expr_stmt|;
name|MMCSD_DISK_LOCK_DESTROY
argument_list|(
name|part
argument_list|)
expr_stmt|;
block|}
name|MMCSD_IOCTL_LOCK_DESTROY
argument_list|(
name|part
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|part
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mmcsd_suspend
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|mmcsd_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|mmcsd_part
modifier|*
name|part
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MMC_PART_MAX
condition|;
name|i
operator|++
control|)
block|{
name|part
operator|=
name|sc
operator|->
name|part
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|part
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|part
operator|->
name|disk
operator|!=
name|NULL
condition|)
block|{
name|MMCSD_DISK_LOCK
argument_list|(
name|part
argument_list|)
expr_stmt|;
name|part
operator|->
name|suspend
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|part
operator|->
name|running
operator|>
literal|0
condition|)
block|{
comment|/* kill thread */
name|part
operator|->
name|running
operator|=
literal|0
expr_stmt|;
name|wakeup
argument_list|(
name|part
argument_list|)
expr_stmt|;
comment|/* wait for thread to finish. */
while|while
condition|(
name|part
operator|->
name|running
operator|!=
operator|-
literal|1
condition|)
name|msleep
argument_list|(
name|part
argument_list|,
operator|&
name|part
operator|->
name|disk_mtx
argument_list|,
literal|0
argument_list|,
literal|"mmcsd disk suspension"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|MMCSD_DISK_UNLOCK
argument_list|(
name|part
argument_list|)
expr_stmt|;
block|}
name|MMCSD_IOCTL_LOCK
argument_list|(
name|part
argument_list|)
expr_stmt|;
while|while
condition|(
name|part
operator|->
name|ioctl
operator|>
literal|0
condition|)
name|msleep
argument_list|(
name|part
argument_list|,
operator|&
name|part
operator|->
name|ioctl_mtx
argument_list|,
literal|0
argument_list|,
literal|"mmcsd IOCTL suspension"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|part
operator|->
name|ioctl
operator|=
operator|-
literal|1
expr_stmt|;
name|MMCSD_IOCTL_UNLOCK
argument_list|(
name|part
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mmcsd_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|mmcsd_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|mmcsd_part
modifier|*
name|part
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MMC_PART_MAX
condition|;
name|i
operator|++
control|)
block|{
name|part
operator|=
name|sc
operator|->
name|part
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|part
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|part
operator|->
name|disk
operator|!=
name|NULL
condition|)
block|{
name|MMCSD_DISK_LOCK
argument_list|(
name|part
argument_list|)
expr_stmt|;
name|part
operator|->
name|suspend
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|part
operator|->
name|running
operator|<=
literal|0
condition|)
block|{
name|part
operator|->
name|running
operator|=
literal|1
expr_stmt|;
name|MMCSD_DISK_UNLOCK
argument_list|(
name|part
argument_list|)
expr_stmt|;
name|kproc_create
argument_list|(
operator|&
name|mmcsd_task
argument_list|,
name|part
argument_list|,
operator|&
name|part
operator|->
name|p
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"%s%d: mmc/sd card"
argument_list|,
name|part
operator|->
name|name
argument_list|,
name|part
operator|->
name|cnt
argument_list|)
expr_stmt|;
block|}
else|else
name|MMCSD_DISK_UNLOCK
argument_list|(
name|part
argument_list|)
expr_stmt|;
block|}
name|MMCSD_IOCTL_LOCK
argument_list|(
name|part
argument_list|)
expr_stmt|;
name|part
operator|->
name|ioctl
operator|=
literal|0
expr_stmt|;
name|MMCSD_IOCTL_UNLOCK
argument_list|(
name|part
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mmcsd_open
parameter_list|(
name|struct
name|disk
modifier|*
name|dp
name|__unused
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mmcsd_close
parameter_list|(
name|struct
name|disk
modifier|*
name|dp
name|__unused
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mmcsd_strategy
parameter_list|(
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|mmcsd_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mmcsd_part
modifier|*
name|part
decl_stmt|;
name|part
operator|=
name|bp
operator|->
name|bio_disk
operator|->
name|d_drv1
expr_stmt|;
name|sc
operator|=
name|part
operator|->
name|sc
expr_stmt|;
name|MMCSD_DISK_LOCK
argument_list|(
name|part
argument_list|)
expr_stmt|;
if|if
condition|(
name|part
operator|->
name|running
operator|>
literal|0
operator|||
name|part
operator|->
name|suspend
operator|>
literal|0
condition|)
block|{
name|bioq_disksort
argument_list|(
operator|&
name|part
operator|->
name|bio_queue
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|MMCSD_DISK_UNLOCK
argument_list|(
name|part
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|part
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|MMCSD_DISK_UNLOCK
argument_list|(
name|part
argument_list|)
expr_stmt|;
name|biofinish
argument_list|(
name|bp
argument_list|,
name|NULL
argument_list|,
name|ENXIO
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|mmcsd_ioctl_rpmb
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|int
name|fflag
parameter_list|,
name|struct
name|thread
modifier|*
name|td
name|__unused
parameter_list|)
block|{
return|return
operator|(
name|mmcsd_ioctl
argument_list|(
name|dev
operator|->
name|si_drv1
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|,
name|fflag
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mmcsd_ioctl_disk
parameter_list|(
name|struct
name|disk
modifier|*
name|disk
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|int
name|fflag
parameter_list|,
name|struct
name|thread
modifier|*
name|td
name|__unused
parameter_list|)
block|{
return|return
operator|(
name|mmcsd_ioctl
argument_list|(
name|disk
operator|->
name|d_drv1
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|,
name|fflag
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mmcsd_ioctl
parameter_list|(
name|struct
name|mmcsd_part
modifier|*
name|part
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|int
name|fflag
parameter_list|)
block|{
name|struct
name|mmc_ioc_cmd
modifier|*
name|mic
decl_stmt|;
name|struct
name|mmc_ioc_multi_cmd
modifier|*
name|mimc
decl_stmt|;
name|int
name|i
decl_stmt|,
name|err
decl_stmt|;
name|u_long
name|cnt
decl_stmt|,
name|size
decl_stmt|;
if|if
condition|(
operator|(
name|fflag
operator|&
name|FREAD
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EBADF
operator|)
return|;
name|err
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|MMC_IOC_CMD
case|:
name|mic
operator|=
name|data
expr_stmt|;
name|err
operator|=
name|mmcsd_ioctl_cmd
argument_list|(
name|part
argument_list|,
name|mic
argument_list|,
name|fflag
argument_list|)
expr_stmt|;
break|break;
case|case
name|MMC_IOC_MULTI_CMD
case|:
name|mimc
operator|=
name|data
expr_stmt|;
if|if
condition|(
name|mimc
operator|->
name|num_of_cmds
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|mimc
operator|->
name|num_of_cmds
operator|>
name|MMC_IOC_MAX_CMDS
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|cnt
operator|=
name|mimc
operator|->
name|num_of_cmds
expr_stmt|;
name|size
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|mic
argument_list|)
operator|*
name|cnt
expr_stmt|;
name|mic
operator|=
name|malloc
argument_list|(
name|size
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|err
operator|=
name|copyin
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|)
name|mimc
operator|->
name|cmds
argument_list|,
name|mic
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cnt
condition|;
name|i
operator|++
control|)
block|{
name|err
operator|=
name|mmcsd_ioctl_cmd
argument_list|(
name|part
argument_list|,
operator|&
name|mic
index|[
name|i
index|]
argument_list|,
name|fflag
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
break|break;
block|}
block|}
name|free
argument_list|(
name|mic
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|ENOIOCTL
operator|)
return|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mmcsd_ioctl_cmd
parameter_list|(
name|struct
name|mmcsd_part
modifier|*
name|part
parameter_list|,
name|struct
name|mmc_ioc_cmd
modifier|*
name|mic
parameter_list|,
name|int
name|fflag
parameter_list|)
block|{
name|struct
name|mmc_command
name|cmd
decl_stmt|;
name|struct
name|mmc_data
name|data
decl_stmt|;
name|struct
name|mmcsd_softc
modifier|*
name|sc
decl_stmt|;
name|device_t
name|dev
decl_stmt|,
name|mmcbus
decl_stmt|;
name|void
modifier|*
name|dp
decl_stmt|;
name|u_long
name|len
decl_stmt|;
name|int
name|err
decl_stmt|,
name|retries
decl_stmt|;
name|uint32_t
name|status
decl_stmt|;
name|uint16_t
name|rca
decl_stmt|;
if|if
condition|(
operator|(
name|fflag
operator|&
name|FWRITE
operator|)
operator|==
literal|0
operator|&&
name|mic
operator|->
name|write_flag
operator|!=
literal|0
condition|)
return|return
operator|(
name|EBADF
operator|)
return|;
if|if
condition|(
name|part
operator|->
name|ro
operator|==
name|TRUE
operator|&&
name|mic
operator|->
name|write_flag
operator|!=
literal|0
condition|)
return|return
operator|(
name|EROFS
operator|)
return|;
comment|/* 	 * We don't need to explicitly lock against the disk(9) half of this 	 * driver as MMCBUS_ACQUIRE_BUS() will serialize us.  However, it's 	 * necessary to protect against races with detachment and suspension, 	 * especially since it's required to switch away from RPMB partitions 	 * again after an access (see mmcsd_switch_part()). 	 */
name|MMCSD_IOCTL_LOCK
argument_list|(
name|part
argument_list|)
expr_stmt|;
while|while
condition|(
name|part
operator|->
name|ioctl
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|part
operator|->
name|ioctl
operator|<
literal|0
condition|)
block|{
name|MMCSD_IOCTL_UNLOCK
argument_list|(
name|part
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|msleep
argument_list|(
name|part
argument_list|,
operator|&
name|part
operator|->
name|ioctl_mtx
argument_list|,
literal|0
argument_list|,
literal|"mmcsd IOCTL"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|part
operator|->
name|ioctl
operator|=
literal|1
expr_stmt|;
name|MMCSD_IOCTL_UNLOCK
argument_list|(
name|part
argument_list|)
expr_stmt|;
name|err
operator|=
literal|0
expr_stmt|;
name|dp
operator|=
name|NULL
expr_stmt|;
name|len
operator|=
name|mic
operator|->
name|blksz
operator|*
name|mic
operator|->
name|blocks
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|MMC_IOC_MAX_BYTES
condition|)
block|{
name|err
operator|=
name|EOVERFLOW
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|len
operator|!=
literal|0
condition|)
block|{
name|dp
operator|=
name|malloc
argument_list|(
name|len
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|err
operator|=
name|copyin
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|mic
operator|->
name|data_ptr
argument_list|,
name|dp
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
block|}
name|memset
argument_list|(
operator|&
name|cmd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|data
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|data
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|opcode
operator|=
name|mic
operator|->
name|opcode
expr_stmt|;
name|cmd
operator|.
name|arg
operator|=
name|mic
operator|->
name|arg
expr_stmt|;
name|cmd
operator|.
name|flags
operator|=
name|mic
operator|->
name|flags
expr_stmt|;
if|if
condition|(
name|len
operator|!=
literal|0
condition|)
block|{
name|data
operator|.
name|len
operator|=
name|len
expr_stmt|;
name|data
operator|.
name|data
operator|=
name|dp
expr_stmt|;
name|data
operator|.
name|flags
operator|=
name|mic
operator|->
name|write_flag
operator|!=
literal|0
condition|?
name|MMC_DATA_WRITE
else|:
name|MMC_DATA_READ
expr_stmt|;
name|cmd
operator|.
name|data
operator|=
operator|&
name|data
expr_stmt|;
block|}
name|sc
operator|=
name|part
operator|->
name|sc
expr_stmt|;
name|rca
operator|=
name|sc
operator|->
name|rca
expr_stmt|;
if|if
condition|(
name|mic
operator|->
name|is_acmd
operator|==
literal|0
condition|)
block|{
comment|/* Enforce/patch/restrict RCA-based commands */
switch|switch
condition|(
name|cmd
operator|.
name|opcode
condition|)
block|{
case|case
name|MMC_SET_RELATIVE_ADDR
case|:
case|case
name|MMC_SELECT_CARD
case|:
name|err
operator|=
name|EPERM
expr_stmt|;
goto|goto
name|out
goto|;
case|case
name|MMC_STOP_TRANSMISSION
case|:
if|if
condition|(
operator|(
name|cmd
operator|.
name|arg
operator|&
literal|0x1
operator|)
operator|==
literal|0
condition|)
break|break;
comment|/* FALLTHROUGH */
case|case
name|MMC_SLEEP_AWAKE
case|:
case|case
name|MMC_SEND_CSD
case|:
case|case
name|MMC_SEND_CID
case|:
case|case
name|MMC_SEND_STATUS
case|:
case|case
name|MMC_GO_INACTIVE_STATE
case|:
case|case
name|MMC_FAST_IO
case|:
case|case
name|MMC_APP_CMD
case|:
name|cmd
operator|.
name|arg
operator|=
operator|(
name|cmd
operator|.
name|arg
operator|&
literal|0x0000FFFF
operator|)
operator||
operator|(
name|rca
operator|<<
literal|16
operator|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
name|dev
operator|=
name|sc
operator|->
name|dev
expr_stmt|;
name|mmcbus
operator|=
name|sc
operator|->
name|mmcbus
expr_stmt|;
name|MMCBUS_ACQUIRE_BUS
argument_list|(
name|mmcbus
argument_list|,
name|dev
argument_list|)
expr_stmt|;
name|err
operator|=
name|mmcsd_switch_part
argument_list|(
name|mmcbus
argument_list|,
name|dev
argument_list|,
name|rca
argument_list|,
name|part
operator|->
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|MMC_ERR_NONE
condition|)
goto|goto
name|release
goto|;
if|if
condition|(
name|part
operator|->
name|type
operator|==
name|EXT_CSD_PART_CONFIG_ACC_RPMB
condition|)
block|{
name|err
operator|=
name|mmcsd_set_blockcount
argument_list|(
name|sc
argument_list|,
name|mic
operator|->
name|blocks
argument_list|,
name|mic
operator|->
name|write_flag
operator|&
operator|(
literal|1
operator|<<
literal|31
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|MMC_ERR_NONE
condition|)
goto|goto
name|switch_back
goto|;
block|}
if|if
condition|(
name|mic
operator|->
name|is_acmd
operator|!=
literal|0
condition|)
operator|(
name|void
operator|)
name|mmc_wait_for_app_cmd
argument_list|(
name|mmcbus
argument_list|,
name|dev
argument_list|,
name|rca
argument_list|,
operator|&
name|cmd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|mmc_wait_for_cmd
argument_list|(
name|mmcbus
argument_list|,
name|dev
argument_list|,
operator|&
name|cmd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|part
operator|->
name|type
operator|==
name|EXT_CSD_PART_CONFIG_ACC_RPMB
condition|)
block|{
comment|/* 		 * If the request went to the RPMB partition, try to ensure 		 * that the command actually has completed ... 		 */
name|retries
operator|=
name|MMCSD_CMD_RETRIES
expr_stmt|;
do|do
block|{
name|err
operator|=
name|mmc_send_status
argument_list|(
name|mmcbus
argument_list|,
name|dev
argument_list|,
name|rca
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|MMC_ERR_NONE
condition|)
break|break;
if|if
condition|(
name|R1_STATUS
argument_list|(
name|status
argument_list|)
operator|==
literal|0
operator|&&
name|R1_CURRENT_STATE
argument_list|(
name|status
argument_list|)
operator|!=
name|R1_STATE_PRG
condition|)
break|break;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|retries
operator|--
operator|>
literal|0
condition|)
do|;
name|switch_back
label|:
comment|/* ... and always switch back to the default partition. */
name|err
operator|=
name|mmcsd_switch_part
argument_list|(
name|mmcbus
argument_list|,
name|dev
argument_list|,
name|rca
argument_list|,
name|EXT_CSD_PART_CONFIG_ACC_DEFAULT
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|MMC_ERR_NONE
condition|)
goto|goto
name|release
goto|;
block|}
comment|/* 	 * If EXT_CSD was changed, our copy is outdated now.  Specifically, 	 * the upper bits of EXT_CSD_PART_CONFIG used in mmcsd_switch_part(), 	 * so retrieve EXT_CSD again. 	 */
if|if
condition|(
name|cmd
operator|.
name|opcode
operator|==
name|MMC_SWITCH_FUNC
condition|)
block|{
name|err
operator|=
name|mmc_send_ext_csd
argument_list|(
name|mmcbus
argument_list|,
name|dev
argument_list|,
name|sc
operator|->
name|ext_csd
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|MMC_ERR_NONE
condition|)
goto|goto
name|release
goto|;
block|}
name|MMCBUS_RELEASE_BUS
argument_list|(
name|mmcbus
argument_list|,
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|.
name|error
operator|!=
name|MMC_ERR_NONE
condition|)
block|{
switch|switch
condition|(
name|cmd
operator|.
name|error
condition|)
block|{
case|case
name|MMC_ERR_TIMEOUT
case|:
name|err
operator|=
name|ETIMEDOUT
expr_stmt|;
break|break;
case|case
name|MMC_ERR_BADCRC
case|:
name|err
operator|=
name|EILSEQ
expr_stmt|;
break|break;
case|case
name|MMC_ERR_INVALID
case|:
name|err
operator|=
name|EINVAL
expr_stmt|;
break|break;
case|case
name|MMC_ERR_NO_MEMORY
case|:
name|err
operator|=
name|ENOMEM
expr_stmt|;
break|break;
default|default:
name|err
operator|=
name|EIO
expr_stmt|;
break|break;
block|}
goto|goto
name|out
goto|;
block|}
name|memcpy
argument_list|(
name|mic
operator|->
name|response
argument_list|,
name|cmd
operator|.
name|resp
argument_list|,
literal|4
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mic
operator|->
name|write_flag
operator|==
literal|0
operator|&&
name|len
operator|!=
literal|0
condition|)
block|{
name|err
operator|=
name|copyout
argument_list|(
name|dp
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|mic
operator|->
name|data_ptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
block|}
goto|goto
name|out
goto|;
name|release
label|:
name|MMCBUS_RELEASE_BUS
argument_list|(
name|mmcbus
argument_list|,
name|dev
argument_list|)
expr_stmt|;
name|err
operator|=
name|EIO
expr_stmt|;
name|out
label|:
name|MMCSD_IOCTL_LOCK
argument_list|(
name|part
argument_list|)
expr_stmt|;
name|part
operator|->
name|ioctl
operator|=
literal|0
expr_stmt|;
name|MMCSD_IOCTL_UNLOCK
argument_list|(
name|part
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|part
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|dp
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mmcsd_getattr
parameter_list|(
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|mmcsd_part
modifier|*
name|part
decl_stmt|;
name|device_t
name|dev
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|bp
operator|->
name|bio_attribute
argument_list|,
literal|"MMC::device"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|bp
operator|->
name|bio_length
operator|!=
sizeof|sizeof
argument_list|(
name|dev
argument_list|)
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
name|part
operator|=
name|bp
operator|->
name|bio_disk
operator|->
name|d_drv1
expr_stmt|;
name|dev
operator|=
name|part
operator|->
name|sc
operator|->
name|dev
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|dev
argument_list|,
name|bp
operator|->
name|bio_data
argument_list|,
sizeof|sizeof
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|bp
operator|->
name|bio_completed
operator|=
name|bp
operator|->
name|bio_length
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mmcsd_set_blockcount
parameter_list|(
name|struct
name|mmcsd_softc
modifier|*
name|sc
parameter_list|,
name|u_int
name|count
parameter_list|,
name|bool
name|reliable
parameter_list|)
block|{
name|struct
name|mmc_command
name|cmd
decl_stmt|;
name|struct
name|mmc_request
name|req
decl_stmt|;
name|memset
argument_list|(
operator|&
name|req
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|req
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|cmd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|mrq
operator|=
operator|&
name|req
expr_stmt|;
name|req
operator|.
name|cmd
operator|=
operator|&
name|cmd
expr_stmt|;
name|cmd
operator|.
name|opcode
operator|=
name|MMC_SET_BLOCK_COUNT
expr_stmt|;
name|cmd
operator|.
name|arg
operator|=
name|count
operator|&
literal|0x0000FFFF
expr_stmt|;
if|if
condition|(
name|reliable
condition|)
name|cmd
operator|.
name|arg
operator||=
literal|1
operator|<<
literal|31
expr_stmt|;
name|cmd
operator|.
name|flags
operator|=
name|MMC_RSP_R1
operator||
name|MMC_CMD_AC
expr_stmt|;
name|MMCBUS_WAIT_FOR_REQUEST
argument_list|(
name|sc
operator|->
name|mmcbus
argument_list|,
name|sc
operator|->
name|dev
argument_list|,
operator|&
name|req
argument_list|)
expr_stmt|;
return|return
operator|(
name|cmd
operator|.
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mmcsd_switch_part
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|dev
parameter_list|,
name|uint16_t
name|rca
parameter_list|,
name|u_int
name|part
parameter_list|)
block|{
name|struct
name|mmcsd_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|err
decl_stmt|;
name|uint8_t
name|value
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mode
operator|==
name|mode_sd
condition|)
return|return
operator|(
name|MMC_ERR_NONE
operator|)
return|;
comment|/* 	 * According to section "6.2.2 Command restrictions" of the eMMC 	 * specification v5.1, CMD19/CMD21 aren't allowed to be used with 	 * RPMB partitions.  So we pause re-tuning along with triggering 	 * it up-front to decrease the likelihood of re-tuning becoming 	 * necessary while accessing an RPMB partition.  Consequently, an 	 * RPMB partition should immediately be switched away from again 	 * after an access in order to allow for re-tuning to take place 	 * anew. 	 */
if|if
condition|(
name|part
operator|==
name|EXT_CSD_PART_CONFIG_ACC_RPMB
condition|)
name|MMCBUS_RETUNE_PAUSE
argument_list|(
name|sc
operator|->
name|mmcbus
argument_list|,
name|sc
operator|->
name|dev
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|part_curr
operator|==
name|part
condition|)
return|return
operator|(
name|MMC_ERR_NONE
operator|)
return|;
name|value
operator|=
operator|(
name|sc
operator|->
name|ext_csd
index|[
name|EXT_CSD_PART_CONFIG
index|]
operator|&
operator|~
name|EXT_CSD_PART_CONFIG_ACC_MASK
operator|)
operator||
name|part
expr_stmt|;
comment|/* Jump! */
name|err
operator|=
name|mmc_switch
argument_list|(
name|bus
argument_list|,
name|dev
argument_list|,
name|rca
argument_list|,
name|EXT_CSD_CMD_SET_NORMAL
argument_list|,
name|EXT_CSD_PART_CONFIG
argument_list|,
name|value
argument_list|,
name|sc
operator|->
name|part_time
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|MMC_ERR_NONE
condition|)
block|{
if|if
condition|(
name|part
operator|==
name|EXT_CSD_PART_CONFIG_ACC_RPMB
condition|)
name|MMCBUS_RETUNE_UNPAUSE
argument_list|(
name|sc
operator|->
name|mmcbus
argument_list|,
name|sc
operator|->
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
name|sc
operator|->
name|ext_csd
index|[
name|EXT_CSD_PART_CONFIG
index|]
operator|=
name|value
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|part_curr
operator|==
name|EXT_CSD_PART_CONFIG_ACC_RPMB
condition|)
name|MMCBUS_RETUNE_UNPAUSE
argument_list|(
name|sc
operator|->
name|mmcbus
argument_list|,
name|sc
operator|->
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|part_curr
operator|=
name|part
expr_stmt|;
return|return
operator|(
name|MMC_ERR_NONE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|mmcsd_errmsg
parameter_list|(
name|int
name|e
parameter_list|)
block|{
if|if
condition|(
name|e
operator|<
literal|0
operator|||
name|e
operator|>
name|MMC_ERR_MAX
condition|)
return|return
literal|"Bad error code"
return|;
return|return
operator|(
name|errmsg
index|[
name|e
index|]
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|daddr_t
name|mmcsd_rw
parameter_list|(
name|struct
name|mmcsd_part
modifier|*
name|part
parameter_list|,
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|daddr_t
name|block
decl_stmt|,
name|end
decl_stmt|;
name|struct
name|mmc_command
name|cmd
decl_stmt|;
name|struct
name|mmc_command
name|stop
decl_stmt|;
name|struct
name|mmc_request
name|req
decl_stmt|;
name|struct
name|mmc_data
name|data
decl_stmt|;
name|struct
name|mmcsd_softc
modifier|*
name|sc
decl_stmt|;
name|device_t
name|dev
decl_stmt|,
name|mmcbus
decl_stmt|;
name|u_int
name|numblocks
decl_stmt|,
name|sz
decl_stmt|;
name|char
modifier|*
name|vaddr
decl_stmt|;
name|sc
operator|=
name|part
operator|->
name|sc
expr_stmt|;
name|dev
operator|=
name|sc
operator|->
name|dev
expr_stmt|;
name|mmcbus
operator|=
name|sc
operator|->
name|mmcbus
expr_stmt|;
name|block
operator|=
name|bp
operator|->
name|bio_pblkno
expr_stmt|;
name|sz
operator|=
name|part
operator|->
name|disk
operator|->
name|d_sectorsize
expr_stmt|;
name|end
operator|=
name|bp
operator|->
name|bio_pblkno
operator|+
operator|(
name|bp
operator|->
name|bio_bcount
operator|/
name|sz
operator|)
expr_stmt|;
while|while
condition|(
name|block
operator|<
name|end
condition|)
block|{
name|vaddr
operator|=
name|bp
operator|->
name|bio_data
operator|+
operator|(
name|block
operator|-
name|bp
operator|->
name|bio_pblkno
operator|)
operator|*
name|sz
expr_stmt|;
name|numblocks
operator|=
name|min
argument_list|(
name|end
operator|-
name|block
argument_list|,
name|sc
operator|->
name|max_data
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|req
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|req
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|cmd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|stop
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|stop
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|data
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|data
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|mrq
operator|=
operator|&
name|req
expr_stmt|;
name|req
operator|.
name|cmd
operator|=
operator|&
name|cmd
expr_stmt|;
name|cmd
operator|.
name|data
operator|=
operator|&
name|data
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|bio_cmd
operator|==
name|BIO_READ
condition|)
block|{
if|if
condition|(
name|numblocks
operator|>
literal|1
condition|)
name|cmd
operator|.
name|opcode
operator|=
name|MMC_READ_MULTIPLE_BLOCK
expr_stmt|;
else|else
name|cmd
operator|.
name|opcode
operator|=
name|MMC_READ_SINGLE_BLOCK
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|numblocks
operator|>
literal|1
condition|)
name|cmd
operator|.
name|opcode
operator|=
name|MMC_WRITE_MULTIPLE_BLOCK
expr_stmt|;
else|else
name|cmd
operator|.
name|opcode
operator|=
name|MMC_WRITE_BLOCK
expr_stmt|;
block|}
name|cmd
operator|.
name|arg
operator|=
name|block
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|high_cap
operator|==
literal|0
condition|)
name|cmd
operator|.
name|arg
operator|<<=
literal|9
expr_stmt|;
name|cmd
operator|.
name|flags
operator|=
name|MMC_RSP_R1
operator||
name|MMC_CMD_ADTC
expr_stmt|;
name|data
operator|.
name|data
operator|=
name|vaddr
expr_stmt|;
name|data
operator|.
name|mrq
operator|=
operator|&
name|req
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|bio_cmd
operator|==
name|BIO_READ
condition|)
name|data
operator|.
name|flags
operator|=
name|MMC_DATA_READ
expr_stmt|;
else|else
name|data
operator|.
name|flags
operator|=
name|MMC_DATA_WRITE
expr_stmt|;
name|data
operator|.
name|len
operator|=
name|numblocks
operator|*
name|sz
expr_stmt|;
if|if
condition|(
name|numblocks
operator|>
literal|1
condition|)
block|{
name|data
operator|.
name|flags
operator||=
name|MMC_DATA_MULTI
expr_stmt|;
name|stop
operator|.
name|opcode
operator|=
name|MMC_STOP_TRANSMISSION
expr_stmt|;
name|stop
operator|.
name|arg
operator|=
literal|0
expr_stmt|;
name|stop
operator|.
name|flags
operator|=
name|MMC_RSP_R1B
operator||
name|MMC_CMD_AC
expr_stmt|;
name|stop
operator|.
name|mrq
operator|=
operator|&
name|req
expr_stmt|;
name|req
operator|.
name|stop
operator|=
operator|&
name|stop
expr_stmt|;
block|}
name|MMCBUS_WAIT_FOR_REQUEST
argument_list|(
name|mmcbus
argument_list|,
name|dev
argument_list|,
operator|&
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|.
name|cmd
operator|->
name|error
operator|!=
name|MMC_ERR_NONE
condition|)
block|{
if|if
condition|(
name|ppsratecheck
argument_list|(
operator|&
name|sc
operator|->
name|log_time
argument_list|,
operator|&
name|sc
operator|->
name|log_count
argument_list|,
name|LOG_PPS
argument_list|)
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Error indicated: %d %s\n"
argument_list|,
name|req
operator|.
name|cmd
operator|->
name|error
argument_list|,
name|mmcsd_errmsg
argument_list|(
name|req
operator|.
name|cmd
operator|->
name|error
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|block
operator|+=
name|numblocks
expr_stmt|;
block|}
return|return
operator|(
name|block
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|daddr_t
name|mmcsd_delete
parameter_list|(
name|struct
name|mmcsd_part
modifier|*
name|part
parameter_list|,
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|daddr_t
name|block
decl_stmt|,
name|end
decl_stmt|,
name|start
decl_stmt|,
name|stop
decl_stmt|;
name|struct
name|mmc_command
name|cmd
decl_stmt|;
name|struct
name|mmc_request
name|req
decl_stmt|;
name|struct
name|mmcsd_softc
modifier|*
name|sc
decl_stmt|;
name|device_t
name|dev
decl_stmt|,
name|mmcbus
decl_stmt|;
name|u_int
name|erase_sector
decl_stmt|,
name|sz
decl_stmt|;
name|sc
operator|=
name|part
operator|->
name|sc
expr_stmt|;
name|dev
operator|=
name|sc
operator|->
name|dev
expr_stmt|;
name|mmcbus
operator|=
name|sc
operator|->
name|mmcbus
expr_stmt|;
name|block
operator|=
name|bp
operator|->
name|bio_pblkno
expr_stmt|;
name|sz
operator|=
name|part
operator|->
name|disk
operator|->
name|d_sectorsize
expr_stmt|;
name|end
operator|=
name|bp
operator|->
name|bio_pblkno
operator|+
operator|(
name|bp
operator|->
name|bio_bcount
operator|/
name|sz
operator|)
expr_stmt|;
comment|/* Coalesce with part remaining from previous request. */
if|if
condition|(
name|block
operator|>
name|part
operator|->
name|eblock
operator|&&
name|block
operator|<=
name|part
operator|->
name|eend
condition|)
name|block
operator|=
name|part
operator|->
name|eblock
expr_stmt|;
if|if
condition|(
name|end
operator|>=
name|part
operator|->
name|eblock
operator|&&
name|end
operator|<
name|part
operator|->
name|eend
condition|)
name|end
operator|=
name|part
operator|->
name|eend
expr_stmt|;
comment|/* Safe round to the erase sector boundaries. */
name|erase_sector
operator|=
name|sc
operator|->
name|erase_sector
expr_stmt|;
name|start
operator|=
name|block
operator|+
name|erase_sector
operator|-
literal|1
expr_stmt|;
comment|/* Round up. */
name|start
operator|-=
name|start
operator|%
name|erase_sector
expr_stmt|;
name|stop
operator|=
name|end
expr_stmt|;
comment|/* Round down. */
name|stop
operator|-=
name|end
operator|%
name|erase_sector
expr_stmt|;
comment|/* We can't erase an area smaller than a sector, store it for later. */
if|if
condition|(
name|start
operator|>=
name|stop
condition|)
block|{
name|part
operator|->
name|eblock
operator|=
name|block
expr_stmt|;
name|part
operator|->
name|eend
operator|=
name|end
expr_stmt|;
return|return
operator|(
name|end
operator|)
return|;
block|}
comment|/* 	 * Pause re-tuning so it won't interfere with the order of erase 	 * commands.  Note that these latter don't use the data lines, so 	 * re-tuning shouldn't actually become necessary during erase. 	 */
name|MMCBUS_RETUNE_PAUSE
argument_list|(
name|mmcbus
argument_list|,
name|dev
argument_list|,
name|false
argument_list|)
expr_stmt|;
comment|/* Set erase start position. */
name|memset
argument_list|(
operator|&
name|req
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|req
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|cmd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|mrq
operator|=
operator|&
name|req
expr_stmt|;
name|req
operator|.
name|cmd
operator|=
operator|&
name|cmd
expr_stmt|;
if|if
condition|(
name|mmc_get_card_type
argument_list|(
name|dev
argument_list|)
operator|==
name|mode_sd
condition|)
name|cmd
operator|.
name|opcode
operator|=
name|SD_ERASE_WR_BLK_START
expr_stmt|;
else|else
name|cmd
operator|.
name|opcode
operator|=
name|MMC_ERASE_GROUP_START
expr_stmt|;
name|cmd
operator|.
name|arg
operator|=
name|start
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|high_cap
operator|==
literal|0
condition|)
name|cmd
operator|.
name|arg
operator|<<=
literal|9
expr_stmt|;
name|cmd
operator|.
name|flags
operator|=
name|MMC_RSP_R1
operator||
name|MMC_CMD_AC
expr_stmt|;
name|MMCBUS_WAIT_FOR_REQUEST
argument_list|(
name|mmcbus
argument_list|,
name|dev
argument_list|,
operator|&
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|.
name|cmd
operator|->
name|error
operator|!=
name|MMC_ERR_NONE
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Setting erase start position failed %d\n"
argument_list|,
name|req
operator|.
name|cmd
operator|->
name|error
argument_list|)
expr_stmt|;
name|block
operator|=
name|bp
operator|->
name|bio_pblkno
expr_stmt|;
goto|goto
name|unpause
goto|;
block|}
comment|/* Set erase stop position. */
name|memset
argument_list|(
operator|&
name|req
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|req
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|cmd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|.
name|cmd
operator|=
operator|&
name|cmd
expr_stmt|;
if|if
condition|(
name|mmc_get_card_type
argument_list|(
name|dev
argument_list|)
operator|==
name|mode_sd
condition|)
name|cmd
operator|.
name|opcode
operator|=
name|SD_ERASE_WR_BLK_END
expr_stmt|;
else|else
name|cmd
operator|.
name|opcode
operator|=
name|MMC_ERASE_GROUP_END
expr_stmt|;
name|cmd
operator|.
name|arg
operator|=
name|stop
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|high_cap
operator|==
literal|0
condition|)
name|cmd
operator|.
name|arg
operator|<<=
literal|9
expr_stmt|;
name|cmd
operator|.
name|arg
operator|--
expr_stmt|;
name|cmd
operator|.
name|flags
operator|=
name|MMC_RSP_R1
operator||
name|MMC_CMD_AC
expr_stmt|;
name|MMCBUS_WAIT_FOR_REQUEST
argument_list|(
name|mmcbus
argument_list|,
name|dev
argument_list|,
operator|&
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|.
name|cmd
operator|->
name|error
operator|!=
name|MMC_ERR_NONE
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Setting erase stop position failed %d\n"
argument_list|,
name|req
operator|.
name|cmd
operator|->
name|error
argument_list|)
expr_stmt|;
name|block
operator|=
name|bp
operator|->
name|bio_pblkno
expr_stmt|;
goto|goto
name|unpause
goto|;
block|}
comment|/* Erase range. */
name|memset
argument_list|(
operator|&
name|req
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|req
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|cmd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|.
name|cmd
operator|=
operator|&
name|cmd
expr_stmt|;
name|cmd
operator|.
name|opcode
operator|=
name|MMC_ERASE
expr_stmt|;
name|cmd
operator|.
name|arg
operator|=
literal|0
expr_stmt|;
name|cmd
operator|.
name|flags
operator|=
name|MMC_RSP_R1B
operator||
name|MMC_CMD_AC
expr_stmt|;
name|MMCBUS_WAIT_FOR_REQUEST
argument_list|(
name|mmcbus
argument_list|,
name|dev
argument_list|,
operator|&
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|.
name|cmd
operator|->
name|error
operator|!=
name|MMC_ERR_NONE
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"erase err3: %d\n"
argument_list|,
name|req
operator|.
name|cmd
operator|->
name|error
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Issuing erase command failed %d\n"
argument_list|,
name|req
operator|.
name|cmd
operator|->
name|error
argument_list|)
expr_stmt|;
name|block
operator|=
name|bp
operator|->
name|bio_pblkno
expr_stmt|;
goto|goto
name|unpause
goto|;
block|}
comment|/* Store one of remaining parts for the next call. */
if|if
condition|(
name|bp
operator|->
name|bio_pblkno
operator|>=
name|part
operator|->
name|eblock
operator|||
name|block
operator|==
name|start
condition|)
block|{
name|part
operator|->
name|eblock
operator|=
name|stop
expr_stmt|;
comment|/* Predict next forward. */
name|part
operator|->
name|eend
operator|=
name|end
expr_stmt|;
block|}
else|else
block|{
name|part
operator|->
name|eblock
operator|=
name|block
expr_stmt|;
comment|/* Predict next backward. */
name|part
operator|->
name|eend
operator|=
name|start
expr_stmt|;
block|}
name|block
operator|=
name|end
expr_stmt|;
name|unpause
label|:
name|MMCBUS_RETUNE_UNPAUSE
argument_list|(
name|mmcbus
argument_list|,
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|block
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mmcsd_dump
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|void
modifier|*
name|virtual
parameter_list|,
name|vm_offset_t
name|physical
parameter_list|,
name|off_t
name|offset
parameter_list|,
name|size_t
name|length
parameter_list|)
block|{
name|struct
name|bio
name|bp
decl_stmt|;
name|daddr_t
name|block
decl_stmt|,
name|end
decl_stmt|;
name|struct
name|disk
modifier|*
name|disk
decl_stmt|;
name|struct
name|mmcsd_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mmcsd_part
modifier|*
name|part
decl_stmt|;
name|device_t
name|dev
decl_stmt|,
name|mmcbus
decl_stmt|;
name|int
name|err
decl_stmt|;
comment|/* length zero is special and really means flush buffers to media */
if|if
condition|(
operator|!
name|length
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|disk
operator|=
name|arg
expr_stmt|;
name|part
operator|=
name|disk
operator|->
name|d_drv1
expr_stmt|;
name|sc
operator|=
name|part
operator|->
name|sc
expr_stmt|;
name|dev
operator|=
name|sc
operator|->
name|dev
expr_stmt|;
name|mmcbus
operator|=
name|sc
operator|->
name|mmcbus
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|bp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|bio
argument_list|)
argument_list|)
expr_stmt|;
name|bp
operator|.
name|bio_disk
operator|=
name|disk
expr_stmt|;
name|bp
operator|.
name|bio_pblkno
operator|=
name|offset
operator|/
name|disk
operator|->
name|d_sectorsize
expr_stmt|;
name|bp
operator|.
name|bio_bcount
operator|=
name|length
expr_stmt|;
name|bp
operator|.
name|bio_data
operator|=
name|virtual
expr_stmt|;
name|bp
operator|.
name|bio_cmd
operator|=
name|BIO_WRITE
expr_stmt|;
name|end
operator|=
name|bp
operator|.
name|bio_pblkno
operator|+
name|bp
operator|.
name|bio_bcount
operator|/
name|disk
operator|->
name|d_sectorsize
expr_stmt|;
name|MMCBUS_ACQUIRE_BUS
argument_list|(
name|mmcbus
argument_list|,
name|dev
argument_list|)
expr_stmt|;
name|err
operator|=
name|mmcsd_switch_part
argument_list|(
name|mmcbus
argument_list|,
name|dev
argument_list|,
name|sc
operator|->
name|rca
argument_list|,
name|part
operator|->
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|MMC_ERR_NONE
condition|)
block|{
if|if
condition|(
name|ppsratecheck
argument_list|(
operator|&
name|sc
operator|->
name|log_time
argument_list|,
operator|&
name|sc
operator|->
name|log_count
argument_list|,
name|LOG_PPS
argument_list|)
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Partition switch error\n"
argument_list|)
expr_stmt|;
name|MMCBUS_RELEASE_BUS
argument_list|(
name|mmcbus
argument_list|,
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|block
operator|=
name|mmcsd_rw
argument_list|(
name|part
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
name|MMCBUS_RELEASE_BUS
argument_list|(
name|mmcbus
argument_list|,
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|end
operator|<
name|block
operator|)
condition|?
name|EIO
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mmcsd_task
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|daddr_t
name|block
decl_stmt|,
name|end
decl_stmt|;
name|struct
name|mmcsd_part
modifier|*
name|part
decl_stmt|;
name|struct
name|mmcsd_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|bio
modifier|*
name|bp
decl_stmt|;
name|device_t
name|dev
decl_stmt|,
name|mmcbus
decl_stmt|;
name|int
name|err
decl_stmt|,
name|sz
decl_stmt|;
name|part
operator|=
name|arg
expr_stmt|;
name|sc
operator|=
name|part
operator|->
name|sc
expr_stmt|;
name|dev
operator|=
name|sc
operator|->
name|dev
expr_stmt|;
name|mmcbus
operator|=
name|sc
operator|->
name|mmcbus
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|MMCSD_DISK_LOCK
argument_list|(
name|part
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
name|part
operator|->
name|running
operator|==
literal|0
condition|)
goto|goto
name|out
goto|;
name|bp
operator|=
name|bioq_takefirst
argument_list|(
operator|&
name|part
operator|->
name|bio_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
name|msleep
argument_list|(
name|part
argument_list|,
operator|&
name|part
operator|->
name|disk_mtx
argument_list|,
name|PRIBIO
argument_list|,
literal|"mmcsd disk jobqueue"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|bp
operator|==
name|NULL
condition|)
do|;
name|MMCSD_DISK_UNLOCK
argument_list|(
name|part
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|bio_cmd
operator|!=
name|BIO_READ
operator|&&
name|part
operator|->
name|ro
condition|)
block|{
name|bp
operator|->
name|bio_error
operator|=
name|EROFS
expr_stmt|;
name|bp
operator|->
name|bio_resid
operator|=
name|bp
operator|->
name|bio_bcount
expr_stmt|;
name|bp
operator|->
name|bio_flags
operator||=
name|BIO_ERROR
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|MMCBUS_ACQUIRE_BUS
argument_list|(
name|mmcbus
argument_list|,
name|dev
argument_list|)
expr_stmt|;
name|sz
operator|=
name|part
operator|->
name|disk
operator|->
name|d_sectorsize
expr_stmt|;
name|block
operator|=
name|bp
operator|->
name|bio_pblkno
expr_stmt|;
name|end
operator|=
name|bp
operator|->
name|bio_pblkno
operator|+
operator|(
name|bp
operator|->
name|bio_bcount
operator|/
name|sz
operator|)
expr_stmt|;
name|err
operator|=
name|mmcsd_switch_part
argument_list|(
name|mmcbus
argument_list|,
name|dev
argument_list|,
name|sc
operator|->
name|rca
argument_list|,
name|part
operator|->
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|MMC_ERR_NONE
condition|)
block|{
if|if
condition|(
name|ppsratecheck
argument_list|(
operator|&
name|sc
operator|->
name|log_time
argument_list|,
operator|&
name|sc
operator|->
name|log_count
argument_list|,
name|LOG_PPS
argument_list|)
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Partition switch error\n"
argument_list|)
expr_stmt|;
goto|goto
name|release
goto|;
block|}
if|if
condition|(
name|bp
operator|->
name|bio_cmd
operator|==
name|BIO_READ
operator|||
name|bp
operator|->
name|bio_cmd
operator|==
name|BIO_WRITE
condition|)
block|{
comment|/* Access to the remaining erase block obsoletes it. */
if|if
condition|(
name|block
operator|<
name|part
operator|->
name|eend
operator|&&
name|end
operator|>
name|part
operator|->
name|eblock
condition|)
name|part
operator|->
name|eblock
operator|=
name|part
operator|->
name|eend
operator|=
literal|0
expr_stmt|;
name|block
operator|=
name|mmcsd_rw
argument_list|(
name|part
argument_list|,
name|bp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bp
operator|->
name|bio_cmd
operator|==
name|BIO_DELETE
condition|)
block|{
name|block
operator|=
name|mmcsd_delete
argument_list|(
name|part
argument_list|,
name|bp
argument_list|)
expr_stmt|;
block|}
name|release
label|:
name|MMCBUS_RELEASE_BUS
argument_list|(
name|mmcbus
argument_list|,
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|block
operator|<
name|end
condition|)
block|{
name|bp
operator|->
name|bio_error
operator|=
name|EIO
expr_stmt|;
name|bp
operator|->
name|bio_resid
operator|=
operator|(
name|end
operator|-
name|block
operator|)
operator|*
name|sz
expr_stmt|;
name|bp
operator|->
name|bio_flags
operator||=
name|BIO_ERROR
expr_stmt|;
block|}
else|else
block|{
name|bp
operator|->
name|bio_resid
operator|=
literal|0
expr_stmt|;
block|}
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
name|out
label|:
comment|/* tell parent we're done */
name|part
operator|->
name|running
operator|=
operator|-
literal|1
expr_stmt|;
name|MMCSD_DISK_UNLOCK
argument_list|(
name|part
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|part
argument_list|)
expr_stmt|;
name|kproc_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|mmcsd_bus_bit_width
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
if|if
condition|(
name|mmc_get_bus_width
argument_list|(
name|dev
argument_list|)
operator|==
name|bus_width_1
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|mmc_get_bus_width
argument_list|(
name|dev
argument_list|)
operator|==
name|bus_width_4
condition|)
return|return
operator|(
literal|4
operator|)
return|;
return|return
operator|(
literal|8
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|mmcsd_methods
index|[]
init|=
block|{
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|mmcsd_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|mmcsd_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|mmcsd_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|mmcsd_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|mmcsd_resume
argument_list|)
block|,
name|DEVMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|mmcsd_driver
init|=
block|{
literal|"mmcsd"
block|,
name|mmcsd_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|mmcsd_softc
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|mmcsd_devclass
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|mmcsd_handler
parameter_list|(
name|module_t
name|mod
name|__unused
parameter_list|,
name|int
name|what
parameter_list|,
name|void
modifier|*
name|arg
name|__unused
parameter_list|)
block|{
switch|switch
condition|(
name|what
condition|)
block|{
case|case
name|MOD_LOAD
case|:
name|flash_register_slicer
argument_list|(
name|mmcsd_slicer
argument_list|,
name|FLASH_SLICES_TYPE_MMC
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|MOD_UNLOAD
case|:
name|flash_register_slicer
argument_list|(
name|NULL
argument_list|,
name|FLASH_SLICES_TYPE_MMC
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|mmcsd
argument_list|,
name|mmc
argument_list|,
name|mmcsd_driver
argument_list|,
name|mmcsd_devclass
argument_list|,
name|mmcsd_handler
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|mmcsd
argument_list|,
name|g_flashmap
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MMC_DEPEND
argument_list|(
name|mmcsd
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

