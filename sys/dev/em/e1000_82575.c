begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*******************************************************************************    Copyright (c) 2001-2007, Intel Corporation    All rights reserved.      Redistribution and use in source and binary forms, with or without    modification, are permitted provided that the following conditions are met:       1. Redistributions of source code must retain the above copyright notice,        this list of conditions and the following disclaimer.       2. Redistributions in binary form must reproduce the above copyright        notice, this list of conditions and the following disclaimer in the        documentation and/or other materials provided with the distribution.       3. Neither the name of the Intel Corporation nor the names of its        contributors may be used to endorse or promote products derived from        this software without specific prior written permission.      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE    ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR    CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF    SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN    CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)    ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE   POSSIBILITY OF SUCH DAMAGE.  *******************************************************************************/
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* e1000_82575  * e1000_adoram  */
end_comment

begin_include
include|#
directive|include
file|"e1000_82575.h"
end_include

begin_function_decl
name|void
name|e1000_init_function_pointers_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|s32
name|e1000_init_phy_params_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|s32
name|e1000_init_nvm_params_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|s32
name|e1000_init_mac_params_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|s32
name|e1000_acquire_phy_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|void
name|e1000_release_phy_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|s32
name|e1000_acquire_nvm_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|void
name|e1000_release_nvm_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|s32
name|e1000_check_for_link_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|s32
name|e1000_get_cfg_done_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|s32
name|e1000_get_link_up_info_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
modifier|*
name|speed
parameter_list|,
name|u16
modifier|*
name|duplex
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|s32
name|e1000_init_hw_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|s32
name|e1000_phy_hw_reset_sgmii_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|s32
name|e1000_read_phy_reg_sgmii_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|void
name|e1000_rar_set_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u8
modifier|*
name|addr
parameter_list|,
name|u32
name|index
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|s32
name|e1000_reset_hw_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|s32
name|e1000_set_d0_lplu_state_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|boolean_t
name|active
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|s32
name|e1000_setup_copper_link_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|s32
name|e1000_setup_fiber_serdes_link_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|s32
name|e1000_write_phy_reg_sgmii_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u16
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|void
name|e1000_clear_hw_cntrs_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_acquire_swfw_sync_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|mask
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_configure_pcs_link_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_get_hw_semaphore_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_get_pcs_speed_and_duplex_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
modifier|*
name|speed
parameter_list|,
name|u16
modifier|*
name|duplex
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_get_phy_id_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|e1000_put_hw_semaphore_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|e1000_release_swfw_sync_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|mask
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|boolean_t
name|e1000_sgmii_active_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|s32
name|e1000_reset_init_script_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_struct
struct|struct
name|e1000_dev_spec_82575
block|{
name|boolean_t
name|sgmii_active
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/**  *  e1000_init_phy_params_82575 - Init PHY func ptrs.  *  @hw - pointer to the HW structure  *  *  This is a function pointer entry point called by the api module.  **/
end_comment

begin_function
name|STATIC
name|s32
name|e1000_init_phy_params_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|struct
name|e1000_functions
modifier|*
name|func
init|=
operator|&
name|hw
operator|->
name|func
decl_stmt|;
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_init_phy_params_82575"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|media_type
operator|!=
name|e1000_media_type_copper
condition|)
block|{
name|phy
operator|->
name|type
operator|=
name|e1000_phy_none
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|phy
operator|->
name|autoneg_mask
operator|=
name|AUTONEG_ADVERTISE_SPEED_DEFAULT
expr_stmt|;
name|phy
operator|->
name|reset_delay_us
operator|=
literal|100
expr_stmt|;
name|func
operator|->
name|acquire_phy
operator|=
name|e1000_acquire_phy_82575
expr_stmt|;
name|func
operator|->
name|check_reset_block
operator|=
name|e1000_check_reset_block_generic
expr_stmt|;
name|func
operator|->
name|commit_phy
operator|=
name|e1000_phy_sw_reset_generic
expr_stmt|;
name|func
operator|->
name|get_cfg_done
operator|=
name|e1000_get_cfg_done_82575
expr_stmt|;
name|func
operator|->
name|release_phy
operator|=
name|e1000_release_phy_82575
expr_stmt|;
if|if
condition|(
name|e1000_sgmii_active_82575
argument_list|(
name|hw
argument_list|)
operator|==
name|TRUE
condition|)
block|{
name|func
operator|->
name|reset_phy
operator|=
name|e1000_phy_hw_reset_sgmii_82575
expr_stmt|;
name|func
operator|->
name|read_phy_reg
operator|=
name|e1000_read_phy_reg_sgmii_82575
expr_stmt|;
name|func
operator|->
name|write_phy_reg
operator|=
name|e1000_write_phy_reg_sgmii_82575
expr_stmt|;
block|}
else|else
block|{
name|func
operator|->
name|reset_phy
operator|=
name|e1000_phy_hw_reset_generic
expr_stmt|;
name|func
operator|->
name|read_phy_reg
operator|=
name|e1000_read_phy_reg_igp
expr_stmt|;
name|func
operator|->
name|write_phy_reg
operator|=
name|e1000_write_phy_reg_igp
expr_stmt|;
block|}
comment|/* Set phy->phy_addr and phy->id. */
name|ret_val
operator|=
name|e1000_get_phy_id_82575
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Verify phy id and set remaining function pointers */
switch|switch
condition|(
name|phy
operator|->
name|id
condition|)
block|{
case|case
name|M88E1111_I_PHY_ID
case|:
name|phy
operator|->
name|type
operator|=
name|e1000_phy_m88
expr_stmt|;
name|func
operator|->
name|check_polarity
operator|=
name|e1000_check_polarity_m88
expr_stmt|;
name|func
operator|->
name|get_phy_info
operator|=
name|e1000_get_phy_info_m88
expr_stmt|;
name|func
operator|->
name|get_cable_length
operator|=
name|e1000_get_cable_length_m88
expr_stmt|;
name|func
operator|->
name|force_speed_duplex
operator|=
name|e1000_phy_force_speed_duplex_m88
expr_stmt|;
break|break;
case|case
name|IGP03E1000_E_PHY_ID
case|:
name|phy
operator|->
name|type
operator|=
name|e1000_phy_igp_3
expr_stmt|;
name|func
operator|->
name|check_polarity
operator|=
name|e1000_check_polarity_igp
expr_stmt|;
name|func
operator|->
name|get_phy_info
operator|=
name|e1000_get_phy_info_igp
expr_stmt|;
name|func
operator|->
name|get_cable_length
operator|=
name|e1000_get_cable_length_igp_2
expr_stmt|;
name|func
operator|->
name|force_speed_duplex
operator|=
name|e1000_phy_force_speed_duplex_igp
expr_stmt|;
name|func
operator|->
name|set_d0_lplu_state
operator|=
name|e1000_set_d0_lplu_state_82575
expr_stmt|;
name|func
operator|->
name|set_d3_lplu_state
operator|=
name|e1000_set_d3_lplu_state_generic
expr_stmt|;
break|break;
default|default:
name|ret_val
operator|=
operator|-
name|E1000_ERR_PHY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_init_nvm_params_82575 - Init NVM func ptrs.  *  @hw - pointer to the HW structure  *  *  This is a function pointer entry point called by the api module.  **/
end_comment

begin_function
name|STATIC
name|s32
name|e1000_init_nvm_params_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_nvm_info
modifier|*
name|nvm
init|=
operator|&
name|hw
operator|->
name|nvm
decl_stmt|;
name|struct
name|e1000_functions
modifier|*
name|func
init|=
operator|&
name|hw
operator|->
name|func
decl_stmt|;
name|u32
name|eecd
init|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_EECD
argument_list|)
decl_stmt|;
name|u16
name|size
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_init_nvm_params_82575"
argument_list|)
expr_stmt|;
name|nvm
operator|->
name|opcode_bits
operator|=
literal|8
expr_stmt|;
name|nvm
operator|->
name|delay_usec
operator|=
literal|1
expr_stmt|;
switch|switch
condition|(
name|nvm
operator|->
name|override
condition|)
block|{
case|case
name|e1000_nvm_override_spi_large
case|:
name|nvm
operator|->
name|page_size
operator|=
literal|32
expr_stmt|;
name|nvm
operator|->
name|address_bits
operator|=
literal|16
expr_stmt|;
break|break;
case|case
name|e1000_nvm_override_spi_small
case|:
name|nvm
operator|->
name|page_size
operator|=
literal|8
expr_stmt|;
name|nvm
operator|->
name|address_bits
operator|=
literal|8
expr_stmt|;
break|break;
default|default:
name|nvm
operator|->
name|page_size
operator|=
name|eecd
operator|&
name|E1000_EECD_ADDR_BITS
condition|?
literal|32
else|:
literal|8
expr_stmt|;
name|nvm
operator|->
name|address_bits
operator|=
name|eecd
operator|&
name|E1000_EECD_ADDR_BITS
condition|?
literal|16
else|:
literal|8
expr_stmt|;
break|break;
block|}
name|nvm
operator|->
name|type
operator|=
name|e1000_nvm_eeprom_spi
expr_stmt|;
name|size
operator|=
call|(
name|u16
call|)
argument_list|(
operator|(
name|eecd
operator|&
name|E1000_EECD_SIZE_EX_MASK
operator|)
operator|>>
name|E1000_EECD_SIZE_EX_SHIFT
argument_list|)
expr_stmt|;
comment|/* Added to a constant, "size" becomes the left-shift value 	 * for setting word_size. 	 */
name|size
operator|+=
name|NVM_WORD_SIZE_BASE_SHIFT
expr_stmt|;
name|nvm
operator|->
name|word_size
operator|=
literal|1
operator|<<
name|size
expr_stmt|;
comment|/* Function Pointers */
name|func
operator|->
name|acquire_nvm
operator|=
name|e1000_acquire_nvm_82575
expr_stmt|;
name|func
operator|->
name|read_nvm
operator|=
name|e1000_read_nvm_eerd
expr_stmt|;
name|func
operator|->
name|release_nvm
operator|=
name|e1000_release_nvm_82575
expr_stmt|;
name|func
operator|->
name|update_nvm
operator|=
name|e1000_update_nvm_checksum_generic
expr_stmt|;
name|func
operator|->
name|valid_led_default
operator|=
name|e1000_valid_led_default_generic
expr_stmt|;
name|func
operator|->
name|validate_nvm
operator|=
name|e1000_validate_nvm_checksum_generic
expr_stmt|;
name|func
operator|->
name|write_nvm
operator|=
name|e1000_write_nvm_spi
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_init_mac_params_82575 - Init MAC func ptrs.  *  @hw - pointer to the HW structure  *  *  This is a function pointer entry point called by the api module.  **/
end_comment

begin_function
name|STATIC
name|s32
name|e1000_init_mac_params_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_mac_info
modifier|*
name|mac
init|=
operator|&
name|hw
operator|->
name|mac
decl_stmt|;
name|struct
name|e1000_functions
modifier|*
name|func
init|=
operator|&
name|hw
operator|->
name|func
decl_stmt|;
name|struct
name|e1000_dev_spec_82575
modifier|*
name|dev_spec
decl_stmt|;
name|u32
name|ctrl
decl_stmt|,
name|ctrl_ext
decl_stmt|;
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_init_mac_params_82575"
argument_list|)
expr_stmt|;
name|hw
operator|->
name|dev_spec_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|e1000_dev_spec_82575
argument_list|)
expr_stmt|;
comment|/* Device-specific structure allocation */
name|ret_val
operator|=
name|e1000_alloc_zeroed_dev_spec_struct
argument_list|(
name|hw
argument_list|,
name|hw
operator|->
name|dev_spec_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|dev_spec
operator|=
operator|(
expr|struct
name|e1000_dev_spec_82575
operator|*
operator|)
name|hw
operator|->
name|dev_spec
expr_stmt|;
comment|/* Set media type */
comment|/* The 82575 uses bits 22:23 for link mode. The mode can be changed          * based on the EEPROM. We cannot rely upon device ID. There          * is no distinguishable difference between fiber and internal          * SerDes mode on the 82575. There can be an external PHY attached          * on the SGMII interface. For this, we'll set sgmii_active to TRUE.          */
name|hw
operator|->
name|media_type
operator|=
name|e1000_media_type_copper
expr_stmt|;
name|dev_spec
operator|->
name|sgmii_active
operator|=
name|FALSE
expr_stmt|;
name|ctrl_ext
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL_EXT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ctrl_ext
operator|&
name|E1000_CTRL_EXT_LINK_MODE_MASK
operator|)
operator|==
name|E1000_CTRL_EXT_LINK_MODE_PCIE_SERDES
condition|)
block|{
name|hw
operator|->
name|media_type
operator|=
name|e1000_media_type_internal_serdes
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctrl_ext
operator|&
name|E1000_CTRL_EXT_LINK_MODE_SGMII
condition|)
block|{
name|dev_spec
operator|->
name|sgmii_active
operator|=
name|TRUE
expr_stmt|;
name|ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|,
operator|(
name|ctrl
operator||
name|E1000_CTRL_I2C_ENA
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* Set mta register count */
name|mac
operator|->
name|mta_reg_count
operator|=
literal|128
expr_stmt|;
comment|/* Set rar entry count */
name|mac
operator|->
name|rar_entry_count
operator|=
name|E1000_RAR_ENTRIES_82575
expr_stmt|;
comment|/* Set if part includes ASF firmware */
name|mac
operator|->
name|asf_firmware_present
operator|=
name|TRUE
expr_stmt|;
comment|/* Set if manageability features are enabled. */
name|mac
operator|->
name|arc_subsystem_valid
operator|=
operator|(
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_FWSM
argument_list|)
operator|&
name|E1000_FWSM_MODE_MASK
operator|)
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
comment|/* Function pointers */
comment|/* bus type/speed/width */
name|func
operator|->
name|get_bus_info
operator|=
name|e1000_get_bus_info_pcie_generic
expr_stmt|;
comment|/* reset */
name|func
operator|->
name|reset_hw
operator|=
name|e1000_reset_hw_82575
expr_stmt|;
comment|/* hw initialization */
name|func
operator|->
name|init_hw
operator|=
name|e1000_init_hw_82575
expr_stmt|;
comment|/* link setup */
name|func
operator|->
name|setup_link
operator|=
name|e1000_setup_link_generic
expr_stmt|;
comment|/* physical interface link setup */
name|func
operator|->
name|setup_physical_interface
operator|=
operator|(
name|hw
operator|->
name|media_type
operator|==
name|e1000_media_type_copper
operator|)
condition|?
name|e1000_setup_copper_link_82575
else|:
name|e1000_setup_fiber_serdes_link_82575
expr_stmt|;
comment|/* check for link */
name|func
operator|->
name|check_for_link
operator|=
name|e1000_check_for_link_82575
expr_stmt|;
comment|/* receive address register setting */
name|func
operator|->
name|rar_set
operator|=
name|e1000_rar_set_82575
expr_stmt|;
comment|/* multicast address update */
name|func
operator|->
name|mc_addr_list_update
operator|=
name|e1000_mc_addr_list_update_generic
expr_stmt|;
comment|/* writing VFTA */
name|func
operator|->
name|write_vfta
operator|=
name|e1000_write_vfta_generic
expr_stmt|;
comment|/* clearing VFTA */
name|func
operator|->
name|clear_vfta
operator|=
name|e1000_clear_vfta_generic
expr_stmt|;
comment|/* setting MTA */
name|func
operator|->
name|mta_set
operator|=
name|e1000_mta_set_generic
expr_stmt|;
comment|/* blink LED */
name|func
operator|->
name|blink_led
operator|=
name|e1000_blink_led_generic
expr_stmt|;
comment|/* setup LED */
name|func
operator|->
name|setup_led
operator|=
name|e1000_setup_led_generic
expr_stmt|;
comment|/* cleanup LED */
name|func
operator|->
name|cleanup_led
operator|=
name|e1000_cleanup_led_generic
expr_stmt|;
comment|/* turn on/off LED */
name|func
operator|->
name|led_on
operator|=
name|e1000_led_on_generic
expr_stmt|;
name|func
operator|->
name|led_off
operator|=
name|e1000_led_off_generic
expr_stmt|;
comment|/* remove device */
name|func
operator|->
name|remove_device
operator|=
name|e1000_remove_device_generic
expr_stmt|;
comment|/* clear hardware counters */
name|func
operator|->
name|clear_hw_cntrs
operator|=
name|e1000_clear_hw_cntrs_82575
expr_stmt|;
comment|/* link info */
name|func
operator|->
name|get_link_up_info
operator|=
name|e1000_get_link_up_info_82575
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_init_function_pointers_82575 - Init func ptrs.  *  @hw - pointer to the HW structure  *  *  The only function explicitly called by the api module to initialize  *  all function pointers and parameters.  **/
end_comment

begin_function
name|void
name|e1000_init_function_pointers_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"e1000_init_function_pointers_82575"
argument_list|)
expr_stmt|;
name|hw
operator|->
name|func
operator|.
name|init_mac_params
operator|=
name|e1000_init_mac_params_82575
expr_stmt|;
name|hw
operator|->
name|func
operator|.
name|init_nvm_params
operator|=
name|e1000_init_nvm_params_82575
expr_stmt|;
name|hw
operator|->
name|func
operator|.
name|init_phy_params
operator|=
name|e1000_init_phy_params_82575
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  e1000_acquire_phy_82575 - Acquire rights to access PHY  *  @hw - pointer to the HW structure  *  *  Acquire access rights to the correct PHY.  This is a  *  function pointer entry point called by the api module.  **/
end_comment

begin_function
name|STATIC
name|s32
name|e1000_acquire_phy_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u16
name|mask
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_acquire_phy_82575"
argument_list|)
expr_stmt|;
name|mask
operator|=
name|hw
operator|->
name|bus
operator|.
name|func
condition|?
name|E1000_SWFW_PHY1_SM
else|:
name|E1000_SWFW_PHY0_SM
expr_stmt|;
return|return
name|e1000_acquire_swfw_sync_82575
argument_list|(
name|hw
argument_list|,
name|mask
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_release_phy_82575 - Release rights to access PHY  *  @hw - pointer to the HW structure  *  *  A wrapper to release access rights to the correct PHY.  This is a  *  function pointer entry point called by the api module.  **/
end_comment

begin_function
name|STATIC
name|void
name|e1000_release_phy_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u16
name|mask
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_release_phy_82575"
argument_list|)
expr_stmt|;
name|mask
operator|=
name|hw
operator|->
name|bus
operator|.
name|func
condition|?
name|E1000_SWFW_PHY1_SM
else|:
name|E1000_SWFW_PHY0_SM
expr_stmt|;
name|e1000_release_swfw_sync_82575
argument_list|(
name|hw
argument_list|,
name|mask
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  e1000_read_phy_reg_sgmii_82575 - Read PHY register using sgmii  *  @hw - pointer to the HW structure  *  @offset - register offset to be read  *  @data - pointer to the read data  *  *  Reads the PHY register at offset using the serial gigabit media independent  *  interface and stores the retrieved information in data.  **/
end_comment

begin_function
name|STATIC
name|s32
name|e1000_read_phy_reg_sgmii_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|e1000_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|u32
name|i
decl_stmt|,
name|i2ccmd
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_read_phy_reg_sgmii_82575"
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|>
name|E1000_MAX_SGMII_PHY_REG_ADDR
condition|)
block|{
name|DEBUGOUT1
argument_list|(
literal|"PHY Address %u is out of range\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_PARAM
return|;
block|}
comment|/* Set up Op-code, Phy Address, and register address in the I2CCMD 	 * register.  The MAC will take care of interfacing with the 	 * PHY to retrieve the desired data. 	 */
name|i2ccmd
operator|=
operator|(
operator|(
name|offset
operator|<<
name|E1000_I2CCMD_REG_ADDR_SHIFT
operator|)
operator||
operator|(
name|phy
operator|->
name|addr
operator|<<
name|E1000_I2CCMD_PHY_ADDR_SHIFT
operator|)
operator||
operator|(
name|E1000_I2CCMD_OPCODE_READ
operator|)
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_I2CCMD
argument_list|,
name|i2ccmd
argument_list|)
expr_stmt|;
comment|/* Poll the ready bit to see if the I2C read completed */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|E1000_I2CCMD_PHY_TIMEOUT
condition|;
name|i
operator|++
control|)
block|{
name|usec_delay
argument_list|(
literal|50
argument_list|)
expr_stmt|;
name|i2ccmd
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_I2CCMD
argument_list|)
expr_stmt|;
if|if
condition|(
name|i2ccmd
operator|&
name|E1000_I2CCMD_READY
condition|)
break|break;
block|}
if|if
condition|(
operator|!
operator|(
name|i2ccmd
operator|&
name|E1000_I2CCMD_READY
operator|)
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"I2CCMD Read did not complete\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_PHY
return|;
block|}
if|if
condition|(
name|i2ccmd
operator|&
name|E1000_I2CCMD_ERROR
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"I2CCMD Error bit set\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_PHY
return|;
block|}
comment|/* Need to byte-swap the 16-bit value. */
operator|*
name|data
operator|=
operator|(
operator|(
name|i2ccmd
operator|>>
literal|8
operator|)
operator|&
literal|0x00FF
operator|)
operator||
operator|(
operator|(
name|i2ccmd
operator|<<
literal|8
operator|)
operator|&
literal|0xFF00
operator|)
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_write_phy_reg_sgmii_82575 - Write PHY register using sgmii  *  @hw - pointer to the HW structure  *  @offset - register offset to write to  *  @data - data to write at register offset  *  *  Writes the data to PHY register at the offset using the serial gigabit  *  media independent interface.  **/
end_comment

begin_function
name|STATIC
name|s32
name|e1000_write_phy_reg_sgmii_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u16
name|data
parameter_list|)
block|{
name|struct
name|e1000_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|u32
name|i
decl_stmt|,
name|i2ccmd
init|=
literal|0
decl_stmt|;
name|u16
name|phy_data_swapped
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_write_phy_reg_sgmii_82575"
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|>
name|E1000_MAX_SGMII_PHY_REG_ADDR
condition|)
block|{
name|DEBUGOUT1
argument_list|(
literal|"PHY Address %d is out of range\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_PARAM
return|;
block|}
comment|/* Swap the data bytes for the I2C interface */
name|phy_data_swapped
operator|=
operator|(
operator|(
name|data
operator|>>
literal|8
operator|)
operator|&
literal|0x00FF
operator|)
operator||
operator|(
operator|(
name|data
operator|<<
literal|8
operator|)
operator|&
literal|0xFF00
operator|)
expr_stmt|;
comment|/* Set up Op-code, Phy Address, and register address in the I2CCMD 	 * register.  The MAC will take care of interfacing with the 	 * PHY to retrieve the desired data. 	 */
name|i2ccmd
operator|=
operator|(
operator|(
name|offset
operator|<<
name|E1000_I2CCMD_REG_ADDR_SHIFT
operator|)
operator||
operator|(
name|phy
operator|->
name|addr
operator|<<
name|E1000_I2CCMD_PHY_ADDR_SHIFT
operator|)
operator||
name|E1000_I2CCMD_OPCODE_WRITE
operator||
name|phy_data_swapped
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_I2CCMD
argument_list|,
name|i2ccmd
argument_list|)
expr_stmt|;
comment|/* Poll the ready bit to see if the I2C read completed */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|E1000_I2CCMD_PHY_TIMEOUT
condition|;
name|i
operator|++
control|)
block|{
name|usec_delay
argument_list|(
literal|50
argument_list|)
expr_stmt|;
name|i2ccmd
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_I2CCMD
argument_list|)
expr_stmt|;
if|if
condition|(
name|i2ccmd
operator|&
name|E1000_I2CCMD_READY
condition|)
break|break;
block|}
if|if
condition|(
operator|!
operator|(
name|i2ccmd
operator|&
name|E1000_I2CCMD_READY
operator|)
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"I2CCMD Write did not complete\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_PHY
return|;
block|}
if|if
condition|(
name|i2ccmd
operator|&
name|E1000_I2CCMD_ERROR
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"I2CCMD Error bit set\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_PHY
return|;
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_get_phy_id_82575 - Retreive PHY addr and id  *  @hw - pointer to the HW structure  *  *  Retreives the PHY address and ID for both PHY's which do and do not use  *  sgmi interface.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_get_phy_id_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|u16
name|phy_id
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_get_phy_id_82575"
argument_list|)
expr_stmt|;
comment|/* For SGMII PHYs, we try the list of possible addresses until 	 * we find one that works.  For non-SGMII PHYs 	 * (e.g. integrated copper PHYs), an address of 1 should 	 * work.  The result of this function should mean phy->phy_addr 	 * and phy->id are set correctly. 	 */
if|if
condition|(
name|e1000_sgmii_active_82575
argument_list|(
name|hw
argument_list|)
operator|==
name|FALSE
condition|)
block|{
name|phy
operator|->
name|addr
operator|=
literal|1
expr_stmt|;
name|ret_val
operator|=
name|e1000_get_phy_id
argument_list|(
name|hw
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* The address field in the I2CCMD register is 3 bits and 0 is invalid. 	 * Therefore, we need to test 1-7 	 */
for|for
control|(
name|phy
operator|->
name|addr
operator|=
literal|1
init|;
name|phy
operator|->
name|addr
operator|<
literal|8
condition|;
name|phy
operator|->
name|addr
operator|++
control|)
block|{
name|ret_val
operator|=
name|e1000_read_phy_reg_sgmii_82575
argument_list|(
name|hw
argument_list|,
name|PHY_ID1
argument_list|,
operator|&
name|phy_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
operator|==
name|E1000_SUCCESS
condition|)
block|{
name|DEBUGOUT2
argument_list|(
literal|"Vendor ID 0x%08X read at address %u\n"
argument_list|,
name|phy_id
argument_list|,
name|phy
operator|->
name|addr
argument_list|)
expr_stmt|;
comment|/* At the time of this writing, The M88 part is 			 * the only supported SGMII PHY product. */
if|if
condition|(
name|phy_id
operator|==
name|M88_VENDOR
condition|)
break|break;
block|}
else|else
block|{
name|DEBUGOUT1
argument_list|(
literal|"PHY address %u was unreadable\n"
argument_list|,
name|phy
operator|->
name|addr
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* A valid PHY type couldn't be found. */
if|if
condition|(
name|phy
operator|->
name|addr
operator|==
literal|8
condition|)
block|{
name|phy
operator|->
name|addr
operator|=
literal|0
expr_stmt|;
name|ret_val
operator|=
operator|-
name|E1000_ERR_PHY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ret_val
operator|=
name|e1000_get_phy_id
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_phy_hw_reset_sgmii_82575 - Performs a PHY reset  *  @hw - pointer to the HW structure  *  *  Resets the PHY using the serial gigabit media independent interface.  **/
end_comment

begin_function
name|STATIC
name|s32
name|e1000_phy_hw_reset_sgmii_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|ret_val
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_phy_hw_reset_sgmii_82575"
argument_list|)
expr_stmt|;
comment|/* This isn't a true "hard" reset, but is the only reset 	 * available to us at this time. 	 */
name|DEBUGOUT
argument_list|(
literal|"Soft resetting SGMII attached PHY...\n"
argument_list|)
expr_stmt|;
comment|/* SFP documentation requires the following to configure the SPF module 	 * to work on SGMII.  No further documentation is given. 	 */
name|ret_val
operator|=
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
literal|0x1B
argument_list|,
literal|0x8084
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|ret_val
operator|=
name|e1000_phy_commit
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_set_d0_lplu_state_82575 - Set Low Power Linkup D0 state  *  @hw - pointer to the HW structure  *  @active - TRUE to enable LPLU, FALSE to disable  *  *  Sets the LPLU D0 state according to the active flag.  When  *  activating LPLU this function also disables smart speed  *  and vice versa.  LPLU will not be activated unless the  *  device autonegotiation advertisement meets standards of  *  either 10 or 10/100 or 10/100/1000 at all duplexes.  *  This is a function pointer entry point only called by  *  PHY setup routines.  **/
end_comment

begin_function
name|STATIC
name|s32
name|e1000_set_d0_lplu_state_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|boolean_t
name|active
parameter_list|)
block|{
name|struct
name|e1000_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|u16
name|data
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_set_d0_lplu_state_82575"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP02E1000_PHY_POWER_MGMT
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|active
condition|)
block|{
name|data
operator||=
name|IGP02E1000_PM_D0_LPLU
expr_stmt|;
name|ret_val
operator|=
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP02E1000_PHY_POWER_MGMT
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
comment|/* When LPLU is enabled, we should disable SmartSpeed */
name|ret_val
operator|=
name|e1000_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_CONFIG
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
name|data
operator|&=
operator|~
name|IGP01E1000_PSCFR_SMART_SPEED
expr_stmt|;
name|ret_val
operator|=
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_CONFIG
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
block|}
else|else
block|{
name|data
operator|&=
operator|~
name|IGP02E1000_PM_D0_LPLU
expr_stmt|;
name|ret_val
operator|=
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP02E1000_PHY_POWER_MGMT
argument_list|,
name|data
argument_list|)
expr_stmt|;
comment|/* LPLU and SmartSpeed are mutually exclusive.  LPLU is used 		 * during Dx states where the power conservation is most 		 * important.  During driver activity we should enable 		 * SmartSpeed, so performance is maintained. */
if|if
condition|(
name|phy
operator|->
name|smart_speed
operator|==
name|e1000_smart_speed_on
condition|)
block|{
name|ret_val
operator|=
name|e1000_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_CONFIG
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|data
operator||=
name|IGP01E1000_PSCFR_SMART_SPEED
expr_stmt|;
name|ret_val
operator|=
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_CONFIG
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
block|}
elseif|else
if|if
condition|(
name|phy
operator|->
name|smart_speed
operator|==
name|e1000_smart_speed_off
condition|)
block|{
name|ret_val
operator|=
name|e1000_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_CONFIG
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|data
operator|&=
operator|~
name|IGP01E1000_PSCFR_SMART_SPEED
expr_stmt|;
name|ret_val
operator|=
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_CONFIG
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
block|}
block|}
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_acquire_nvm_82575 - Request for access to EEPROM  *  @hw - pointer to the HW structure  *  *  Acquire the necessary semaphores for exclussive access to the EEPROM.  *  Set the EEPROM access request bit and wait for EEPROM access grant bit.  *  Return successful if access grant bit set, else clear the request for  *  EEPROM access and return -E1000_ERR_NVM (-1).  **/
end_comment

begin_function
name|STATIC
name|s32
name|e1000_acquire_nvm_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|ret_val
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_acquire_nvm_82575"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_acquire_swfw_sync_82575
argument_list|(
name|hw
argument_list|,
name|E1000_SWFW_EEP_SM
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|ret_val
operator|=
name|e1000_acquire_nvm_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
name|e1000_release_swfw_sync_82575
argument_list|(
name|hw
argument_list|,
name|E1000_SWFW_EEP_SM
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_release_nvm_82575 - Release exclusive access to EEPROM  *  @hw - pointer to the HW structure  *  *  Stop any current commands to the EEPROM and clear the EEPROM request bit,  *  then release the semaphores acquired.  **/
end_comment

begin_function
name|STATIC
name|void
name|e1000_release_nvm_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"e1000_release_nvm_82575"
argument_list|)
expr_stmt|;
name|e1000_release_nvm_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|e1000_release_swfw_sync_82575
argument_list|(
name|hw
argument_list|,
name|E1000_SWFW_EEP_SM
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  e1000_get_hw_semaphore_82575 - Acquire HW semaphore for PHY/NVM access  *  @hw - pointer to the HW structure  *  *  Acquire the HW semaphore to access the PHY or NVM  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_get_hw_semaphore_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|swsm
decl_stmt|;
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|s32
name|timeout
init|=
name|hw
operator|->
name|nvm
operator|.
name|word_size
operator|+
literal|1
decl_stmt|;
name|s32
name|i
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_get_hw_semaphore_82575"
argument_list|)
expr_stmt|;
comment|/* Get the SW semaphore. */
while|while
condition|(
name|i
operator|<
name|timeout
condition|)
block|{
name|swsm
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_SWSM
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|swsm
operator|&
name|E1000_SWSM_SMBI
operator|)
condition|)
break|break;
name|usec_delay
argument_list|(
literal|50
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
name|timeout
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Driver can't access device "
literal|"- SMBI bit is set.\n"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
operator|-
name|E1000_ERR_NVM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Get the FW semaphore. */
name|ret_val
operator|=
name|e1000_get_hw_semaphore_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
comment|/* Release 82575 semaphores */
name|e1000_put_hw_semaphore_82575
argument_list|(
name|hw
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_put_hw_semaphore_82575 - Release HW semaphore for PHY/NVM access  *  @hw - pointer to the HW structure  *  *  Release the HW semaphore used to access the PHY or NVM  **/
end_comment

begin_function
specifier|static
name|void
name|e1000_put_hw_semaphore_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|swsm
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_put_hw_semaphore_82575"
argument_list|)
expr_stmt|;
name|swsm
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_SWSM
argument_list|)
expr_stmt|;
name|swsm
operator|&=
operator|~
operator|(
name|E1000_SWSM_SMBI
operator||
name|E1000_SWSM_SWESMBI
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_SWSM
argument_list|,
name|swsm
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  e1000_acquire_swfw_sync_82575 - Acquire SW/FW semaphore  *  @hw - pointer to the HW structure  *  @mask - specifies which semaphore to acquire  *  *  Acquire the SW/FW semaphore to access the PHY or NVM.  The mask  *  will also specify which port we're acquiring the lock for.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_acquire_swfw_sync_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|mask
parameter_list|)
block|{
name|u32
name|swfw_sync
decl_stmt|;
name|u32
name|swmask
init|=
name|mask
decl_stmt|;
name|u32
name|fwmask
init|=
name|mask
operator|<<
literal|16
decl_stmt|;
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|s32
name|i
init|=
literal|0
decl_stmt|,
name|timeout
init|=
literal|200
decl_stmt|;
comment|/* FIXME: find real value to use here */
name|DEBUGFUNC
argument_list|(
literal|"e1000_acquire_swfw_sync_82575"
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|timeout
condition|)
block|{
if|if
condition|(
name|e1000_get_hw_semaphore_82575
argument_list|(
name|hw
argument_list|)
condition|)
block|{
name|ret_val
operator|=
operator|-
name|E1000_ERR_SWFW_SYNC
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|swfw_sync
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_SW_FW_SYNC
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|swfw_sync
operator|&
operator|(
name|fwmask
operator||
name|swmask
operator|)
operator|)
condition|)
break|break;
comment|/* Firmware currently using resource (fwmask) 		 * or other software thread using resource (swmask) */
name|e1000_put_hw_semaphore_82575
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|msec_delay_irq
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
name|timeout
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Driver can't access resource, SW_FW_SYNC timeout.\n"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
operator|-
name|E1000_ERR_SWFW_SYNC
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|swfw_sync
operator||=
name|swmask
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_SW_FW_SYNC
argument_list|,
name|swfw_sync
argument_list|)
expr_stmt|;
name|e1000_put_hw_semaphore_82575
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_release_swfw_sync_82575 - Release SW/FW semaphore  *  @hw - pointer to the HW structure  *  @mask - specifies which semaphore to acquire  *  *  Release the SW/FW semaphore used to access the PHY or NVM.  The mask  *  will also specify which port we're releasing the lock for.  **/
end_comment

begin_function
specifier|static
name|void
name|e1000_release_swfw_sync_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|mask
parameter_list|)
block|{
name|u32
name|swfw_sync
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_release_swfw_sync_82575"
argument_list|)
expr_stmt|;
while|while
condition|(
name|e1000_get_hw_semaphore_82575
argument_list|(
name|hw
argument_list|)
operator|!=
name|E1000_SUCCESS
condition|)
empty_stmt|;
comment|/* Empty */
name|swfw_sync
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_SW_FW_SYNC
argument_list|)
expr_stmt|;
name|swfw_sync
operator|&=
operator|~
name|mask
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_SW_FW_SYNC
argument_list|,
name|swfw_sync
argument_list|)
expr_stmt|;
name|e1000_put_hw_semaphore_82575
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  e1000_get_cfg_done_82575 - Read config done bit  *  @hw - pointer to the HW structure  *  *  Read the management control register for the config done bit for  *  completion status.  NOTE: silicon which is EEPROM-less will fail trying  *  to read the config done bit, so an error is *ONLY* logged and returns  *  E1000_SUCCESS.  If we were to return with error, EEPROM-less silicon  *  would not be able to be reset or change link.  **/
end_comment

begin_function
name|STATIC
name|s32
name|e1000_get_cfg_done_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|timeout
init|=
name|PHY_CFG_TIMEOUT
decl_stmt|;
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|u32
name|mask
init|=
name|E1000_NVM_CFG_DONE_PORT_0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_get_cfg_done_82575"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|bus
operator|.
name|func
operator|==
literal|1
condition|)
name|mask
operator|=
name|E1000_NVM_CFG_DONE_PORT_1
expr_stmt|;
while|while
condition|(
name|timeout
condition|)
block|{
if|if
condition|(
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_EEMNGCTL
argument_list|)
operator|&
name|mask
condition|)
break|break;
name|msec_delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|timeout
operator|--
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|timeout
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"MNG configuration cycle has not completed.\n"
argument_list|)
expr_stmt|;
block|}
comment|/* If EEPROM is not marked present, init the PHY manually */
if|if
condition|(
operator|(
operator|(
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_EECD
argument_list|)
operator|&
name|E1000_EECD_PRES
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|hw
operator|->
name|phy
operator|.
name|type
operator|==
name|e1000_phy_igp_3
operator|)
condition|)
block|{
name|e1000_phy_init_script_igp3
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_get_link_up_info_82575 - Get link speed/duplex info  *  @hw - pointer to the HW structure  *  @speed - stores the current speed  *  @duplex - stores the current duplex  *  *  This is a wrapper function, if using the serial gigabit media independent  *  interface, use pcs to retreive the link speed and duplex information.  *  Otherwise, use the generic function to get the link speed and duplex info.  **/
end_comment

begin_function
name|STATIC
name|s32
name|e1000_get_link_up_info_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
modifier|*
name|speed
parameter_list|,
name|u16
modifier|*
name|duplex
parameter_list|)
block|{
name|s32
name|ret_val
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_get_link_up_info_82575"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|media_type
operator|!=
name|e1000_media_type_copper
operator|||
name|e1000_sgmii_active_82575
argument_list|(
name|hw
argument_list|)
operator|==
name|TRUE
condition|)
block|{
name|ret_val
operator|=
name|e1000_get_pcs_speed_and_duplex_82575
argument_list|(
name|hw
argument_list|,
name|speed
argument_list|,
name|duplex
argument_list|)
expr_stmt|;
block|}
else|else
name|ret_val
operator|=
name|e1000_get_speed_and_duplex_copper_generic
argument_list|(
name|hw
argument_list|,
name|speed
argument_list|,
name|duplex
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_check_for_link_82575 - Check for link  *  @hw - pointer to the HW structure  *  *  If sgmii is enabled, then use the pcs register to determine link, otherwise  *  use the generic interface for determining link.  **/
end_comment

begin_function
name|STATIC
name|s32
name|e1000_check_for_link_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|ret_val
decl_stmt|;
name|u16
name|speed
decl_stmt|,
name|duplex
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_check_for_link_82575"
argument_list|)
expr_stmt|;
comment|/* SGMII link check is done through the PCS register. */
if|if
condition|(
operator|(
name|hw
operator|->
name|media_type
operator|!=
name|e1000_media_type_copper
operator|)
operator|||
operator|(
name|e1000_sgmii_active_82575
argument_list|(
name|hw
argument_list|)
operator|==
name|TRUE
operator|)
condition|)
name|ret_val
operator|=
name|e1000_get_pcs_speed_and_duplex_82575
argument_list|(
name|hw
argument_list|,
operator|&
name|speed
argument_list|,
operator|&
name|duplex
argument_list|)
expr_stmt|;
else|else
name|ret_val
operator|=
name|e1000_check_for_copper_link_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_get_pcs_speed_and_duplex_82575 - Retrieve current speed/duplex  *  @hw - pointer to the HW structure  *  @speed - stores the current speed  *  @duplex - stores the current duplex  *  *  Using the physical coding sub-layer (PCS), retreive the current speed and  *  duplex, then store the values in the pointers provided.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_get_pcs_speed_and_duplex_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
modifier|*
name|speed
parameter_list|,
name|u16
modifier|*
name|duplex
parameter_list|)
block|{
name|struct
name|e1000_mac_info
modifier|*
name|mac
init|=
operator|&
name|hw
operator|->
name|mac
decl_stmt|;
name|u32
name|pcs
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_get_pcs_speed_and_duplex_82575"
argument_list|)
expr_stmt|;
comment|/* Set up defaults for the return values of this function */
name|mac
operator|->
name|serdes_has_link
operator|=
name|FALSE
expr_stmt|;
operator|*
name|speed
operator|=
literal|0
expr_stmt|;
operator|*
name|duplex
operator|=
literal|0
expr_stmt|;
comment|/* Read the PCS Status register for link state. For non-copper mode, 	 * the status register is not accurate. The PCS status register is 	 * used instead. */
name|pcs
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PCS_LSTAT
argument_list|)
expr_stmt|;
comment|/* The link up bit determines when link is up on autoneg. The sync ok 	 * gets set once both sides sync up and agree upon link. Stable link 	 * can be determined by checking for both link up and link sync ok 	 */
if|if
condition|(
operator|(
name|pcs
operator|&
name|E1000_PCS_LSTS_LINK_OK
operator|)
operator|&&
operator|(
name|pcs
operator|&
name|E1000_PCS_LSTS_SYNK_OK
operator|)
condition|)
block|{
name|mac
operator|->
name|serdes_has_link
operator|=
name|TRUE
expr_stmt|;
comment|/* Detect and store PCS speed */
if|if
condition|(
name|pcs
operator|&
name|E1000_PCS_LSTS_SPEED_1000
condition|)
block|{
operator|*
name|speed
operator|=
name|SPEED_1000
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pcs
operator|&
name|E1000_PCS_LSTS_SPEED_100
condition|)
block|{
operator|*
name|speed
operator|=
name|SPEED_100
expr_stmt|;
block|}
else|else
block|{
operator|*
name|speed
operator|=
name|SPEED_10
expr_stmt|;
block|}
comment|/* Detect and store PCS duplex */
if|if
condition|(
name|pcs
operator|&
name|E1000_PCS_LSTS_DUPLEX_FULL
condition|)
block|{
operator|*
name|duplex
operator|=
name|FULL_DUPLEX
expr_stmt|;
block|}
else|else
block|{
operator|*
name|duplex
operator|=
name|HALF_DUPLEX
expr_stmt|;
block|}
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_rar_set_82575 - Set receive address register  *  @hw - pointer to the HW structure  *  @addr - pointer to the receive address  *  @index - receive address array register  *  *  Sets the receive address array register at index to the address passed  *  in by addr.  **/
end_comment

begin_function
name|void
name|e1000_rar_set_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u8
modifier|*
name|addr
parameter_list|,
name|u32
name|index
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"e1000_rar_set_82575"
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|<
name|E1000_RAR_ENTRIES_82575
condition|)
block|{
name|e1000_rar_set_generic
argument_list|(
name|hw
argument_list|,
name|addr
argument_list|,
name|index
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|out
label|:
return|return;
block|}
end_function

begin_comment
comment|/**  *  e1000_reset_hw_82575 - Reset hardware  *  @hw - pointer to the HW structure  *  *  This resets the hardware into a known state.  This is a  *  function pointer entry point called by the api module.  **/
end_comment

begin_function
name|STATIC
name|s32
name|e1000_reset_hw_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|ctrl
decl_stmt|,
name|icr
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_reset_hw_82575"
argument_list|)
expr_stmt|;
comment|/* Prevent the PCI-E bus from sticking if there is no TLP connection 	 * on the last TLP read/write transaction when MAC is reset. 	 */
name|ret_val
operator|=
name|e1000_disable_pcie_master_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"PCI-E Master disable polling has failed.\n"
argument_list|)
expr_stmt|;
block|}
name|DEBUGOUT
argument_list|(
literal|"Masking off all interrupts\n"
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_IMC
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RCTL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TCTL
argument_list|,
name|E1000_TCTL_PSP
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|msec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|)
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Issuing a global reset to MAC\n"
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|,
name|ctrl
operator||
name|E1000_CTRL_RST
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_get_auto_rd_done_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
comment|/* When auto config read does not complete, do not 		 * return with an error. This can happen in situations 		 * where there is no eeprom and prevents getting link. 		 */
name|DEBUGOUT
argument_list|(
literal|"Auto Read Done did not complete\n"
argument_list|)
expr_stmt|;
block|}
comment|/* If EEPROM is not present, run manual init scripts */
if|if
condition|(
operator|(
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_EECD
argument_list|)
operator|&
name|E1000_EECD_PRES
operator|)
operator|==
literal|0
condition|)
name|e1000_reset_init_script_82575
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Clear any pending interrupt events. */
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_IMC
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|icr
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_ICR
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_init_hw_82575 - Initialize hardware  *  @hw - pointer to the HW structure  *  *  This inits the hardware readying it for operation.  **/
end_comment

begin_function
name|STATIC
name|s32
name|e1000_init_hw_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_mac_info
modifier|*
name|mac
init|=
operator|&
name|hw
operator|->
name|mac
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|u16
name|i
decl_stmt|,
name|rar_count
init|=
name|mac
operator|->
name|rar_entry_count
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_init_hw_82575"
argument_list|)
expr_stmt|;
comment|/* Initialize identification LED */
name|ret_val
operator|=
name|e1000_id_led_init_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Error initializing identification LED\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Disabling VLAN filtering */
name|DEBUGOUT
argument_list|(
literal|"Initializing the IEEE VLAN\n"
argument_list|)
expr_stmt|;
name|e1000_clear_vfta
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Setup the receive address. */
name|e1000_init_rx_addrs_generic
argument_list|(
name|hw
argument_list|,
name|rar_count
argument_list|)
expr_stmt|;
comment|/* Zero out the Multicast HASH table */
name|DEBUGOUT
argument_list|(
literal|"Zeroing the MTA\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mac
operator|->
name|mta_reg_count
condition|;
name|i
operator|++
control|)
name|E1000_WRITE_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|E1000_MTA
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Setup link and flow control */
name|ret_val
operator|=
name|e1000_setup_link
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Clear all of the statistics registers (clear on read).  It is 	 * important that we do this after we have tried to establish link 	 * because the symbol error count will increment wildly if there 	 * is no link. 	 */
name|e1000_clear_hw_cntrs_82575
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_setup_copper_link_82575 - Configure copper link settings  *  @hw - pointer to the HW structure  *  *  Configures the link for auto-neg or forced speed and duplex.  Then we check  *  for link, once link is established calls to configure collision distance  *  and flow control are called.  **/
end_comment

begin_function
name|STATIC
name|s32
name|e1000_setup_copper_link_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|ctrl
decl_stmt|,
name|led_ctrl
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|boolean_t
name|link
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_setup_copper_link_82575"
argument_list|)
expr_stmt|;
name|ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|)
expr_stmt|;
name|ctrl
operator||=
name|E1000_CTRL_SLU
expr_stmt|;
name|ctrl
operator|&=
operator|~
operator|(
name|E1000_CTRL_FRCSPD
operator||
name|E1000_CTRL_FRCDPX
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|hw
operator|->
name|phy
operator|.
name|type
condition|)
block|{
case|case
name|e1000_phy_m88
case|:
name|ret_val
operator|=
name|e1000_copper_link_setup_m88
argument_list|(
name|hw
argument_list|)
expr_stmt|;
break|break;
case|case
name|e1000_phy_igp_3
case|:
name|ret_val
operator|=
name|e1000_copper_link_setup_igp
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Setup activity LED */
name|led_ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_LEDCTL
argument_list|)
expr_stmt|;
name|led_ctrl
operator|&=
name|IGP_ACTIVITY_LED_MASK
expr_stmt|;
name|led_ctrl
operator||=
operator|(
name|IGP_ACTIVITY_LED_ENABLE
operator||
name|IGP_LED3_MODE
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_LEDCTL
argument_list|,
name|led_ctrl
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ret_val
operator|=
operator|-
name|E1000_ERR_PHY
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|autoneg
condition|)
block|{
comment|/* Setup autoneg and flow control advertisement 		 * and perform autonegotiation. */
name|ret_val
operator|=
name|e1000_copper_link_autoneg
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
block|}
else|else
block|{
comment|/* PHY will be set to 10H, 10F, 100H or 100F 		 * depending on user settings. */
name|DEBUGOUT
argument_list|(
literal|"Forcing Speed and Duplex\n"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_phy_force_speed_duplex
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Error Forcing Speed and Duplex\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|ret_val
operator|=
name|e1000_configure_pcs_link_82575
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
comment|/* Check link status. Wait up to 100 microseconds for link to become 	 * valid. 	 */
name|ret_val
operator|=
name|e1000_phy_has_link_generic
argument_list|(
name|hw
argument_list|,
name|COPPER_LINK_UP_LIMIT
argument_list|,
literal|10
argument_list|,
operator|&
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|link
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Valid link established!!!\n"
argument_list|)
expr_stmt|;
comment|/* Config the MAC and PHY after link is up */
name|e1000_config_collision_dist_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_config_fc_after_link_up_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DEBUGOUT
argument_list|(
literal|"Unable to establish link!!!\n"
argument_list|)
expr_stmt|;
block|}
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_setup_fiber_serdes_link_82575 - Setup link for fiber/serdes  *  @hw - pointer to the HW structure  *  *  Configures speed and duplex for fiber and serdes links.  **/
end_comment

begin_function
name|STATIC
name|s32
name|e1000_setup_fiber_serdes_link_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|reg
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_setup_fiber_serdes_link_82575"
argument_list|)
expr_stmt|;
comment|/* On the 82575, SerDes loopback mode persists until it is 	 * explicitly turned off or a power cycle is performed.  A read to 	 * the register does not indicate its status.  Therefore, we ensure 	 * loopback mode is disabled during initialization. 	 */
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_SCTL
argument_list|,
name|E1000_SCTL_DISABLE_SERDES_LOOPBACK
argument_list|)
expr_stmt|;
comment|/* Force link up, set 1gb, set both sw defined pins */
name|reg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|)
expr_stmt|;
name|reg
operator||=
name|E1000_CTRL_SLU
operator||
name|E1000_CTRL_SPD_1000
operator||
name|E1000_CTRL_FRCSPD
operator||
name|E1000_CTRL_SWDPIN0
operator||
name|E1000_CTRL_SWDPIN1
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* Set switch control to serdes energy detect */
name|reg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CONNSW
argument_list|)
expr_stmt|;
name|reg
operator||=
name|E1000_CONNSW_ENRGSRC
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CONNSW
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* New SerDes mode allows for forcing speed or autonegotiating speed 	 * at 1gb. Autoneg should be default set by most drivers. This is the 	 * mode that will be compatible with older link partners and switches. 	 * However, both are supported by the hardware and some drivers/tools. 	 */
name|reg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PCS_LCTL
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|autoneg
condition|)
block|{
comment|/* Set PCS register for autoneg */
name|reg
operator||=
name|E1000_PCS_LCTL_FSV_1000
operator||
comment|/* Force 1000    */
name|E1000_PCS_LCTL_FDV_FULL
operator||
comment|/* SerDes Full duplex */
name|E1000_PCS_LCTL_AN_ENABLE
operator||
comment|/* Enable Autoneg */
name|E1000_PCS_LCTL_AN_RESTART
expr_stmt|;
comment|/* Restart autoneg */
name|DEBUGOUT1
argument_list|(
literal|"Configuring Autoneg; PCS_LCTL = 0x%08X\n"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Set PCS register for forced speed */
name|reg
operator||=
name|E1000_PCS_LCTL_FLV_LINK_UP
operator||
comment|/* Force link up */
name|E1000_PCS_LCTL_FSV_1000
operator||
comment|/* Force 1000    */
name|E1000_PCS_LCTL_FDV_FULL
operator||
comment|/* SerDes Full duplex */
name|E1000_PCS_LCTL_FSD
operator||
comment|/* Force Speed */
name|E1000_PCS_LCTL_FORCE_LINK
expr_stmt|;
comment|/* Force Link */
name|DEBUGOUT1
argument_list|(
literal|"Configuring Forced Link; PCS_LCTL = 0x%08X\n"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PCS_LCTL
argument_list|,
name|reg
argument_list|)
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_configure_pcs_link_82575 - Configure PCS link  *  @hw - pointer to the HW structure  *  *  Configure the physical coding sub-layer (PCS) link.  The PCS link is  *  only used on copper connections where the serialized gigabit media  *  independent interface (sgmii) is being used.  Configures the link  *  for auto-negotiation or forces speed/duplex.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_configure_pcs_link_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_mac_info
modifier|*
name|mac
init|=
operator|&
name|hw
operator|->
name|mac
decl_stmt|;
name|u32
name|reg
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_configure_pcs_link_82575"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|media_type
operator|!=
name|e1000_media_type_copper
operator|||
name|e1000_sgmii_active_82575
argument_list|(
name|hw
argument_list|)
operator|==
name|FALSE
condition|)
goto|goto
name|out
goto|;
comment|/* For SGMII, we need to issue a PCS autoneg restart */
name|reg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PCS_LCTL
argument_list|)
expr_stmt|;
comment|/* AN time out should be disabled for SGMII mode */
name|reg
operator|&=
operator|~
operator|(
name|E1000_PCS_LCTL_AN_TIMEOUT
operator|)
expr_stmt|;
if|if
condition|(
name|mac
operator|->
name|autoneg
condition|)
block|{
comment|/* Make sure forced speed and force link are not set */
name|reg
operator|&=
operator|~
operator|(
name|E1000_PCS_LCTL_FSD
operator||
name|E1000_PCS_LCTL_FORCE_LINK
operator|)
expr_stmt|;
comment|/* The PHY should be setup prior to calling this function. 		 * All we need to do is restart autoneg and enable autoneg. 		 */
name|reg
operator||=
name|E1000_PCS_LCTL_AN_RESTART
operator||
name|E1000_PCS_LCTL_AN_ENABLE
expr_stmt|;
block|}
else|else
block|{
comment|/* Set PCS regiseter for forced speed */
comment|/* Turn off bits for full duplex, speed, and autoneg */
name|reg
operator|&=
operator|~
operator|(
name|E1000_PCS_LCTL_FSV_1000
operator||
name|E1000_PCS_LCTL_FSV_100
operator||
name|E1000_PCS_LCTL_FDV_FULL
operator||
name|E1000_PCS_LCTL_AN_ENABLE
operator|)
expr_stmt|;
comment|/* Check for duplex first */
if|if
condition|(
name|mac
operator|->
name|forced_speed_duplex
operator|&
name|E1000_ALL_FULL_DUPLEX
condition|)
name|reg
operator||=
name|E1000_PCS_LCTL_FDV_FULL
expr_stmt|;
comment|/* Now set speed */
if|if
condition|(
name|mac
operator|->
name|forced_speed_duplex
operator|&
name|E1000_ALL_100_SPEED
condition|)
name|reg
operator||=
name|E1000_PCS_LCTL_FSV_100
expr_stmt|;
comment|/* Force speed and force link */
name|reg
operator||=
name|E1000_PCS_LCTL_FSD
operator||
name|E1000_PCS_LCTL_FORCE_LINK
operator||
name|E1000_PCS_LCTL_FLV_LINK_UP
expr_stmt|;
name|DEBUGOUT1
argument_list|(
literal|"Wrote 0x%08X to PCS_LCTL to configure forced link\n"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PCS_LCTL
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_sgmii_active_82575 - Return sgmii state  *  @hw - pointer to the HW structure  *  *  82575 silicon has a serialized gigabit media independent interface (sgmii)  *  which can be enabled for use in the embedded applications.  Simply  *  return the current state of the sgmii interface.  **/
end_comment

begin_function
specifier|static
name|boolean_t
name|e1000_sgmii_active_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_dev_spec_82575
modifier|*
name|dev_spec
decl_stmt|;
name|boolean_t
name|ret_val
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_sgmii_active_82575"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|!=
name|e1000_82575
condition|)
block|{
name|ret_val
operator|=
name|FALSE
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|dev_spec
operator|=
operator|(
expr|struct
name|e1000_dev_spec_82575
operator|*
operator|)
name|hw
operator|->
name|dev_spec
expr_stmt|;
name|ret_val
operator|=
name|dev_spec
operator|->
name|sgmii_active
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_translate_register_adoram - Translate the proper regiser offset  *  @reg - e1000 register to be read  *  *  Registers in adoram are located in different offsets than other adapters  *  even though they function in the same manner.  This function takes in  *  the name of the register to read and returns the correct offset for  *  adoram silicon.  **/
end_comment

begin_function
name|u32
name|e1000_translate_register_adoram
parameter_list|(
name|u32
name|reg
parameter_list|)
block|{
comment|/* Some of the Adoram registers are located at different 	 * offsets than they are in older adapters. 	 * Despite the difference in location, the registers 	 * function in the same manner. 	 */
switch|switch
condition|(
name|reg
condition|)
block|{
case|case
name|E1000_TDBAL
case|:
name|reg
operator|=
literal|0x0E000
expr_stmt|;
break|break;
case|case
name|E1000_TDBAH
case|:
name|reg
operator|=
literal|0x0E004
expr_stmt|;
break|break;
case|case
name|E1000_TDLEN
case|:
name|reg
operator|=
literal|0x0E008
expr_stmt|;
break|break;
case|case
name|E1000_TDH
case|:
name|reg
operator|=
literal|0x0E010
expr_stmt|;
break|break;
case|case
name|E1000_TDT
case|:
name|reg
operator|=
literal|0x0E018
expr_stmt|;
break|break;
case|case
name|E1000_TXDCTL
case|:
name|reg
operator|=
literal|0x0E028
expr_stmt|;
break|break;
case|case
name|E1000_RDBAL
case|:
name|reg
operator|=
literal|0x0C000
expr_stmt|;
break|break;
case|case
name|E1000_RDBAH
case|:
name|reg
operator|=
literal|0x0C004
expr_stmt|;
break|break;
case|case
name|E1000_RDLEN
case|:
name|reg
operator|=
literal|0x0C008
expr_stmt|;
break|break;
case|case
name|E1000_RDH
case|:
name|reg
operator|=
literal|0x0C010
expr_stmt|;
break|break;
case|case
name|E1000_RDT
case|:
name|reg
operator|=
literal|0x0C018
expr_stmt|;
break|break;
case|case
name|E1000_RXDCTL
case|:
name|reg
operator|=
literal|0x0C028
expr_stmt|;
break|break;
case|case
name|E1000_SRRCTL0
case|:
name|reg
operator|=
literal|0x0C00C
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
name|reg
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_reset_init_script_82575 - Inits HW defaults after reset  *  @hw - pointer to the HW structure  *  *  Inits recommended HW defaults after a reset when there is no EEPROM  *  detected. This is only for the 82575.  **/
end_comment

begin_function
name|STATIC
name|s32
name|e1000_reset_init_script_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"e1000_reset_init_script_82575"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_82575
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Running reset init script for 82575\n"
argument_list|)
expr_stmt|;
comment|/* SerDes configuration via SERDESCTRL */
name|e1000_write_8bit_ctrl_reg
argument_list|(
name|hw
argument_list|,
name|E1000_SCTL
argument_list|,
literal|0x00
argument_list|,
literal|0x0C
argument_list|)
expr_stmt|;
name|e1000_write_8bit_ctrl_reg
argument_list|(
name|hw
argument_list|,
name|E1000_SCTL
argument_list|,
literal|0x01
argument_list|,
literal|0x78
argument_list|)
expr_stmt|;
name|e1000_write_8bit_ctrl_reg
argument_list|(
name|hw
argument_list|,
name|E1000_SCTL
argument_list|,
literal|0x1B
argument_list|,
literal|0x23
argument_list|)
expr_stmt|;
name|e1000_write_8bit_ctrl_reg
argument_list|(
name|hw
argument_list|,
name|E1000_SCTL
argument_list|,
literal|0x23
argument_list|,
literal|0x15
argument_list|)
expr_stmt|;
comment|/* CCM configuration via CCMCTL register */
name|e1000_write_8bit_ctrl_reg
argument_list|(
name|hw
argument_list|,
name|E1000_CCMCTL
argument_list|,
literal|0x14
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|e1000_write_8bit_ctrl_reg
argument_list|(
name|hw
argument_list|,
name|E1000_CCMCTL
argument_list|,
literal|0x10
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* PCIe lanes configuration */
name|e1000_write_8bit_ctrl_reg
argument_list|(
name|hw
argument_list|,
name|E1000_GIOCTL
argument_list|,
literal|0x00
argument_list|,
literal|0xEC
argument_list|)
expr_stmt|;
name|e1000_write_8bit_ctrl_reg
argument_list|(
name|hw
argument_list|,
name|E1000_GIOCTL
argument_list|,
literal|0x61
argument_list|,
literal|0xDF
argument_list|)
expr_stmt|;
name|e1000_write_8bit_ctrl_reg
argument_list|(
name|hw
argument_list|,
name|E1000_GIOCTL
argument_list|,
literal|0x34
argument_list|,
literal|0x05
argument_list|)
expr_stmt|;
name|e1000_write_8bit_ctrl_reg
argument_list|(
name|hw
argument_list|,
name|E1000_GIOCTL
argument_list|,
literal|0x2F
argument_list|,
literal|0x81
argument_list|)
expr_stmt|;
comment|/* PCIe PLL Configuration */
name|e1000_write_8bit_ctrl_reg
argument_list|(
name|hw
argument_list|,
name|E1000_SCCTL
argument_list|,
literal|0x02
argument_list|,
literal|0x47
argument_list|)
expr_stmt|;
name|e1000_write_8bit_ctrl_reg
argument_list|(
name|hw
argument_list|,
name|E1000_SCCTL
argument_list|,
literal|0x14
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|e1000_write_8bit_ctrl_reg
argument_list|(
name|hw
argument_list|,
name|E1000_SCCTL
argument_list|,
literal|0x10
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_clear_hw_cntrs_82575 - Clear device specific hardware counters  *  @hw - pointer to the HW structure  *  *  Clears the hardware counters by reading the counter registers.  **/
end_comment

begin_function
name|STATIC
name|void
name|e1000_clear_hw_cntrs_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
specifier|volatile
name|u32
name|temp
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_clear_hw_cntrs_82575"
argument_list|)
expr_stmt|;
name|e1000_clear_hw_cntrs_base_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PRC64
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PRC127
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PRC255
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PRC511
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PRC1023
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PRC1522
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PTC64
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PTC127
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PTC255
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PTC511
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PTC1023
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PTC1522
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_ALGNERRC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RXERRC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TNCRS
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CEXTERR
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TSCTC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TSCTFC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_MGTPRC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_MGTPDC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_MGTPTC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_IAC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_ICRXOC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_ICRXPTC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_ICRXATC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_ICTXPTC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_ICTXATC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_ICTXQEC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_ICTXQMTC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_ICRXDMTC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CBTMPC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_HTDPMC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CBRMPC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RPTHC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_HGPTC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_HTCBDPC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_HGORCL
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_HGORCH
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_HGOTCL
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_HGOTCH
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_LENERRS
argument_list|)
expr_stmt|;
comment|/* This register should not be read in copper configurations */
if|if
condition|(
name|hw
operator|->
name|media_type
operator|==
name|e1000_media_type_internal_serdes
condition|)
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_SCVPC
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

