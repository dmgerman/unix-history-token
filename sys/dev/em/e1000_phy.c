begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*******************************************************************************    Copyright (c) 2001-2007, Intel Corporation    All rights reserved.      Redistribution and use in source and binary forms, with or without    modification, are permitted provided that the following conditions are met:       1. Redistributions of source code must retain the above copyright notice,        this list of conditions and the following disclaimer.       2. Redistributions in binary form must reproduce the above copyright        notice, this list of conditions and the following disclaimer in the        documentation and/or other materials provided with the distribution.       3. Neither the name of the Intel Corporation nor the names of its        contributors may be used to endorse or promote products derived from        this software without specific prior written permission.      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE    ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR    CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF    SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN    CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)    ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE   POSSIBILITY OF SUCH DAMAGE.  *******************************************************************************/
end_comment

begin_function_decl
name|$FreeBSD$
include|#
directive|include
file|"e1000_phy.h"
specifier|static
name|s32
name|e1000_get_phy_cfg_done
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|e1000_release_phy
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_acquire_phy
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Cable length tables */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|u16
name|e1000_m88_cable_length_table
index|[]
init|=
block|{
literal|0
block|,
literal|50
block|,
literal|80
block|,
literal|110
block|,
literal|140
block|,
literal|140
block|,
name|E1000_CABLE_LENGTH_UNDEFINED
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|M88E1000_CABLE_LENGTH_TABLE_SIZE
define|\
value|(sizeof(e1000_m88_cable_length_table) / \                  sizeof(e1000_m88_cable_length_table[0]))
end_define

begin_decl_stmt
specifier|static
specifier|const
name|u16
name|e1000_igp_2_cable_length_table
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|3
block|,
literal|5
block|,
literal|8
block|,
literal|11
block|,
literal|13
block|,
literal|16
block|,
literal|18
block|,
literal|21
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|3
block|,
literal|6
block|,
literal|10
block|,
literal|13
block|,
literal|16
block|,
literal|19
block|,
literal|23
block|,
literal|26
block|,
literal|29
block|,
literal|32
block|,
literal|35
block|,
literal|38
block|,
literal|41
block|,
literal|6
block|,
literal|10
block|,
literal|14
block|,
literal|18
block|,
literal|22
block|,
literal|26
block|,
literal|30
block|,
literal|33
block|,
literal|37
block|,
literal|41
block|,
literal|44
block|,
literal|48
block|,
literal|51
block|,
literal|54
block|,
literal|58
block|,
literal|61
block|,
literal|21
block|,
literal|26
block|,
literal|31
block|,
literal|35
block|,
literal|40
block|,
literal|44
block|,
literal|49
block|,
literal|53
block|,
literal|57
block|,
literal|61
block|,
literal|65
block|,
literal|68
block|,
literal|72
block|,
literal|75
block|,
literal|79
block|,
literal|82
block|,
literal|40
block|,
literal|45
block|,
literal|51
block|,
literal|56
block|,
literal|61
block|,
literal|66
block|,
literal|70
block|,
literal|75
block|,
literal|79
block|,
literal|83
block|,
literal|87
block|,
literal|91
block|,
literal|94
block|,
literal|98
block|,
literal|101
block|,
literal|104
block|,
literal|60
block|,
literal|66
block|,
literal|72
block|,
literal|77
block|,
literal|82
block|,
literal|87
block|,
literal|92
block|,
literal|96
block|,
literal|100
block|,
literal|104
block|,
literal|108
block|,
literal|111
block|,
literal|114
block|,
literal|117
block|,
literal|119
block|,
literal|121
block|,
literal|83
block|,
literal|89
block|,
literal|95
block|,
literal|100
block|,
literal|105
block|,
literal|109
block|,
literal|113
block|,
literal|116
block|,
literal|119
block|,
literal|122
block|,
literal|124
block|,
literal|104
block|,
literal|109
block|,
literal|114
block|,
literal|118
block|,
literal|121
block|,
literal|124
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|IGP02E1000_CABLE_LENGTH_TABLE_SIZE
define|\
value|(sizeof(e1000_igp_2_cable_length_table) / \                  sizeof(e1000_igp_2_cable_length_table[0]))
end_define

begin_comment
comment|/**  *  e1000_check_reset_block_generic - Check if PHY reset is blocked  *  @hw - pointer to the HW structure  *  *  Read the PHY management control register and check whether a PHY reset  *  is blocked.  If a reset is not blocked return E1000_SUCCESS, otherwise  *  return E1000_BLK_PHY_RESET (12).  **/
end_comment

begin_function
name|s32
name|e1000_check_reset_block_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|manc
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_check_reset_block"
argument_list|)
expr_stmt|;
name|manc
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_MANC
argument_list|)
expr_stmt|;
return|return
operator|(
name|manc
operator|&
name|E1000_MANC_BLK_PHY_RST_ON_IDE
operator|)
condition|?
name|E1000_BLK_PHY_RESET
else|:
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_get_phy_id - Retrieve the PHY ID and revision  *  @hw - pointer to the HW structure  *  *  Reads the PHY registers and stores the PHY ID and possibly the PHY  *  revision in the hardware structure.  **/
end_comment

begin_function
name|s32
name|e1000_get_phy_id
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|u16
name|phy_id
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_get_phy_id"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_ID1
argument_list|,
operator|&
name|phy_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|phy
operator|->
name|id
operator|=
call|(
name|u32
call|)
argument_list|(
name|phy_id
operator|<<
literal|16
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|20
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_ID2
argument_list|,
operator|&
name|phy_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|phy
operator|->
name|id
operator||=
call|(
name|u32
call|)
argument_list|(
name|phy_id
operator|&
name|PHY_REVISION_MASK
argument_list|)
expr_stmt|;
name|phy
operator|->
name|revision
operator|=
call|(
name|u32
call|)
argument_list|(
name|phy_id
operator|&
operator|~
name|PHY_REVISION_MASK
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_phy_reset_dsp_generic - Reset PHY DSP  *  @hw - pointer to the HW structure  *  *  Reset the digital signal processor.  **/
end_comment

begin_function
name|s32
name|e1000_phy_reset_dsp_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|ret_val
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_phy_reset_dsp_generic"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_GEN_CONTROL
argument_list|,
literal|0xC1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|ret_val
operator|=
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_GEN_CONTROL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_read_phy_reg_mdic - Read MDI control register  *  @hw - pointer to the HW structure  *  @offset - register offset to be read  *  @data - pointer to the read data  *  *  Reads the MDI control regsiter in the PHY at offset and stores the  *  information read to data.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_read_phy_reg_mdic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|e1000_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|u32
name|i
decl_stmt|,
name|mdic
init|=
literal|0
decl_stmt|;
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_read_phy_reg_mdic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|>
name|MAX_PHY_REG_ADDRESS
condition|)
block|{
name|DEBUGOUT1
argument_list|(
literal|"PHY Address %d is out of range\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|ret_val
operator|=
operator|-
name|E1000_ERR_PARAM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Set up Op-code, Phy Address, and register offset in the MDI 	 * Control register.  The MAC will take care of interfacing with the 	 * PHY to retrieve the desired data. 	 */
name|mdic
operator|=
operator|(
operator|(
name|offset
operator|<<
name|E1000_MDIC_REG_SHIFT
operator|)
operator||
operator|(
name|phy
operator|->
name|addr
operator|<<
name|E1000_MDIC_PHY_SHIFT
operator|)
operator||
operator|(
name|E1000_MDIC_OP_READ
operator|)
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_MDIC
argument_list|,
name|mdic
argument_list|)
expr_stmt|;
comment|/* Poll the ready bit to see if the MDI read completed */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|64
condition|;
name|i
operator|++
control|)
block|{
name|usec_delay
argument_list|(
literal|50
argument_list|)
expr_stmt|;
name|mdic
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_MDIC
argument_list|)
expr_stmt|;
if|if
condition|(
name|mdic
operator|&
name|E1000_MDIC_READY
condition|)
break|break;
block|}
if|if
condition|(
operator|!
operator|(
name|mdic
operator|&
name|E1000_MDIC_READY
operator|)
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"MDI Read did not complete\n"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
operator|-
name|E1000_ERR_PHY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|mdic
operator|&
name|E1000_MDIC_ERROR
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"MDI Error\n"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
operator|-
name|E1000_ERR_PHY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
operator|*
name|data
operator|=
operator|(
name|u16
operator|)
name|mdic
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_write_phy_reg_mdic - Write MDI control register  *  @hw - pointer to the HW structure  *  @offset - register offset to write to  *  @data - data to write to register at offset  *  *  Writes data to MDI control register in the PHY at offset.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_write_phy_reg_mdic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u16
name|data
parameter_list|)
block|{
name|struct
name|e1000_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|u32
name|i
decl_stmt|,
name|mdic
init|=
literal|0
decl_stmt|;
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_write_phy_reg_mdic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|>
name|MAX_PHY_REG_ADDRESS
condition|)
block|{
name|DEBUGOUT1
argument_list|(
literal|"PHY Address %d is out of range\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|ret_val
operator|=
operator|-
name|E1000_ERR_PARAM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Set up Op-code, Phy Address, and register offset in the MDI 	 * Control register.  The MAC will take care of interfacing with the 	 * PHY to retrieve the desired data. 	 */
name|mdic
operator|=
operator|(
operator|(
operator|(
name|u32
operator|)
name|data
operator|)
operator||
operator|(
name|offset
operator|<<
name|E1000_MDIC_REG_SHIFT
operator|)
operator||
operator|(
name|phy
operator|->
name|addr
operator|<<
name|E1000_MDIC_PHY_SHIFT
operator|)
operator||
operator|(
name|E1000_MDIC_OP_WRITE
operator|)
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_MDIC
argument_list|,
name|mdic
argument_list|)
expr_stmt|;
comment|/* Poll the ready bit to see if the MDI read completed */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|E1000_GEN_POLL_TIMEOUT
condition|;
name|i
operator|++
control|)
block|{
name|usec_delay
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|mdic
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_MDIC
argument_list|)
expr_stmt|;
if|if
condition|(
name|mdic
operator|&
name|E1000_MDIC_READY
condition|)
break|break;
block|}
if|if
condition|(
operator|!
operator|(
name|mdic
operator|&
name|E1000_MDIC_READY
operator|)
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"MDI Write did not complete\n"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
operator|-
name|E1000_ERR_PHY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_read_phy_reg_m88 - Read m88 PHY register  *  @hw - pointer to the HW structure  *  @offset - register offset to be read  *  @data - pointer to the read data  *  *  Acquires semaphore, if necessary, then reads the PHY register at offset  *  and storing the retrieved information in data.  Release any acquired  *  semaphores before exiting.  **/
end_comment

begin_function
name|s32
name|e1000_read_phy_reg_m88
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
block|{
name|s32
name|ret_val
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_read_phy_reg_m88"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_acquire_phy
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|ret_val
operator|=
name|e1000_read_phy_reg_mdic
argument_list|(
name|hw
argument_list|,
name|MAX_PHY_REG_ADDRESS
operator|&
name|offset
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|e1000_release_phy
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_write_phy_reg_m88 - Write m88 PHY register  *  @hw - pointer to the HW structure  *  @offset - register offset to write to  *  @data - data to write at register offset  *  *  Acquires semaphore, if necessary, then writes the data to PHY register  *  at the offset.  Release any acquired semaphores before exiting.  **/
end_comment

begin_function
name|s32
name|e1000_write_phy_reg_m88
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u16
name|data
parameter_list|)
block|{
name|s32
name|ret_val
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_write_phy_reg_m88"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_acquire_phy
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|ret_val
operator|=
name|e1000_write_phy_reg_mdic
argument_list|(
name|hw
argument_list|,
name|MAX_PHY_REG_ADDRESS
operator|&
name|offset
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|e1000_release_phy
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_read_phy_reg_igp - Read igp PHY register  *  @hw - pointer to the HW structure  *  @offset - register offset to be read  *  @data - pointer to the read data  *  *  Acquires semaphore, if necessary, then reads the PHY register at offset  *  and storing the retrieved information in data.  Release any acquired  *  semaphores before exiting.  **/
end_comment

begin_function
name|s32
name|e1000_read_phy_reg_igp
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
block|{
name|s32
name|ret_val
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_read_phy_reg_igp"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_acquire_phy
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|offset
operator|>
name|MAX_PHY_MULTI_PAGE_REG
condition|)
block|{
name|ret_val
operator|=
name|e1000_write_phy_reg_mdic
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PAGE_SELECT
argument_list|,
operator|(
name|u16
operator|)
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|e1000_release_phy
argument_list|(
name|hw
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|ret_val
operator|=
name|e1000_read_phy_reg_mdic
argument_list|(
name|hw
argument_list|,
name|MAX_PHY_REG_ADDRESS
operator|&
name|offset
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|e1000_release_phy
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_write_phy_reg_igp - Write igp PHY register  *  @hw - pointer to the HW structure  *  @offset - register offset to write to  *  @data - data to write at register offset  *  *  Acquires semaphore, if necessary, then writes the data to PHY register  *  at the offset.  Release any acquired semaphores before exiting.  **/
end_comment

begin_function
name|s32
name|e1000_write_phy_reg_igp
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u16
name|data
parameter_list|)
block|{
name|s32
name|ret_val
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_write_phy_reg_igp"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_acquire_phy
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|offset
operator|>
name|MAX_PHY_MULTI_PAGE_REG
condition|)
block|{
name|ret_val
operator|=
name|e1000_write_phy_reg_mdic
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PAGE_SELECT
argument_list|,
operator|(
name|u16
operator|)
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|e1000_release_phy
argument_list|(
name|hw
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|ret_val
operator|=
name|e1000_write_phy_reg_mdic
argument_list|(
name|hw
argument_list|,
name|MAX_PHY_REG_ADDRESS
operator|&
name|offset
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|e1000_release_phy
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_read_kmrn_reg_generic - Read kumeran register  *  @hw - pointer to the HW structure  *  @offset - register offset to be read  *  @data - pointer to the read data  *  *  Acquires semaphore, if necessary.  Then reads the PHY register at offset  *  using the kumeran interface.  The information retrieved is stored in data.  *  Release any acquired semaphores before exiting.  **/
end_comment

begin_function
name|s32
name|e1000_read_kmrn_reg_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
block|{
name|u32
name|kmrnctrlsta
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_read_kmrn_reg_generic"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_acquire_phy
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|kmrnctrlsta
operator|=
operator|(
operator|(
name|offset
operator|<<
name|E1000_KMRNCTRLSTA_OFFSET_SHIFT
operator|)
operator|&
name|E1000_KMRNCTRLSTA_OFFSET
operator|)
operator||
name|E1000_KMRNCTRLSTA_REN
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_KMRNCTRLSTA
argument_list|,
name|kmrnctrlsta
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|kmrnctrlsta
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_KMRNCTRLSTA
argument_list|)
expr_stmt|;
operator|*
name|data
operator|=
operator|(
name|u16
operator|)
name|kmrnctrlsta
expr_stmt|;
name|e1000_release_phy
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_write_kmrn_reg_generic - Write kumeran register  *  @hw - pointer to the HW structure  *  @offset - register offset to write to  *  @data - data to write at register offset  *  *  Acquires semaphore, if necessary.  Then write the data to PHY register  *  at the offset using the kumeran interface.  Release any acquired semaphores  *  before exiting.  **/
end_comment

begin_function
name|s32
name|e1000_write_kmrn_reg_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u16
name|data
parameter_list|)
block|{
name|u32
name|kmrnctrlsta
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_write_kmrn_reg_generic"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_acquire_phy
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|kmrnctrlsta
operator|=
operator|(
operator|(
name|offset
operator|<<
name|E1000_KMRNCTRLSTA_OFFSET_SHIFT
operator|)
operator|&
name|E1000_KMRNCTRLSTA_OFFSET
operator|)
operator||
name|data
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_KMRNCTRLSTA
argument_list|,
name|kmrnctrlsta
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|e1000_release_phy
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_copper_link_setup_m88 - Setup m88 PHY's for copper link  *  @hw - pointer to the HW structure  *  *  Sets up MDI/MDI-X and polarity for m88 PHY's.  If necessary, transmit clock  *  and downshift values are set also.  **/
end_comment

begin_function
name|s32
name|e1000_copper_link_setup_m88
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|u16
name|phy_data
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_copper_link_setup_m88"
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy
operator|->
name|reset_disable
condition|)
block|{
name|ret_val
operator|=
name|E1000_SUCCESS
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Enable CRS on TX. This must be set for half-duplex operation. */
name|ret_val
operator|=
name|e1000_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_SPEC_CTRL
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|phy_data
operator||=
name|M88E1000_PSCR_ASSERT_CRS_ON_TX
expr_stmt|;
comment|/* Options: 	 *   MDI/MDI-X = 0 (default) 	 *   0 - Auto for all speeds 	 *   1 - MDI mode 	 *   2 - MDI-X mode 	 *   3 - Auto for 1000Base-T only (MDI-X for 10/100Base-T modes) 	 */
name|phy_data
operator|&=
operator|~
name|M88E1000_PSCR_AUTO_X_MODE
expr_stmt|;
switch|switch
condition|(
name|phy
operator|->
name|mdix
condition|)
block|{
case|case
literal|1
case|:
name|phy_data
operator||=
name|M88E1000_PSCR_MDI_MANUAL_MODE
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|phy_data
operator||=
name|M88E1000_PSCR_MDIX_MANUAL_MODE
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|phy_data
operator||=
name|M88E1000_PSCR_AUTO_X_1000T
expr_stmt|;
break|break;
case|case
literal|0
case|:
default|default:
name|phy_data
operator||=
name|M88E1000_PSCR_AUTO_X_MODE
expr_stmt|;
break|break;
block|}
comment|/* Options: 	 *   disable_polarity_correction = 0 (default) 	 *       Automatic Correction for Reversed Cable Polarity 	 *   0 - Disabled 	 *   1 - Enabled 	 */
name|phy_data
operator|&=
operator|~
name|M88E1000_PSCR_POLARITY_REVERSAL
expr_stmt|;
if|if
condition|(
name|phy
operator|->
name|disable_polarity_correction
operator|==
literal|1
condition|)
name|phy_data
operator||=
name|M88E1000_PSCR_POLARITY_REVERSAL
expr_stmt|;
name|ret_val
operator|=
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_SPEC_CTRL
argument_list|,
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|phy
operator|->
name|revision
operator|<
name|E1000_REVISION_4
condition|)
block|{
comment|/* Force TX_CLK in the Extended PHY Specific Control Register 		 * to 25MHz clock. 		 */
name|ret_val
operator|=
name|e1000_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_EXT_PHY_SPEC_CTRL
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|phy_data
operator||=
name|M88E1000_EPSCR_TX_CLK_25
expr_stmt|;
if|if
condition|(
operator|(
name|phy
operator|->
name|revision
operator|==
name|E1000_REVISION_2
operator|)
operator|&&
operator|(
name|phy
operator|->
name|id
operator|==
name|M88E1111_I_PHY_ID
operator|)
condition|)
block|{
comment|/* 82573L PHY - set the downshift counter to 5x. */
name|phy_data
operator|&=
operator|~
name|M88EC018_EPSCR_DOWNSHIFT_COUNTER_MASK
expr_stmt|;
name|phy_data
operator||=
name|M88EC018_EPSCR_DOWNSHIFT_COUNTER_5X
expr_stmt|;
block|}
else|else
block|{
comment|/* Configure Master and Slave downshift values */
name|phy_data
operator|&=
operator|~
operator|(
name|M88E1000_EPSCR_MASTER_DOWNSHIFT_MASK
operator||
name|M88E1000_EPSCR_SLAVE_DOWNSHIFT_MASK
operator|)
expr_stmt|;
name|phy_data
operator||=
operator|(
name|M88E1000_EPSCR_MASTER_DOWNSHIFT_1X
operator||
name|M88E1000_EPSCR_SLAVE_DOWNSHIFT_1X
operator|)
expr_stmt|;
block|}
name|ret_val
operator|=
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_EXT_PHY_SPEC_CTRL
argument_list|,
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
block|}
comment|/* Commit the changes. */
name|ret_val
operator|=
name|e1000_phy_commit
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Error committing the PHY changes\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_copper_link_setup_igp - Setup igp PHY's for copper link  *  @hw - pointer to the HW structure  *  *  Sets up LPLU, MDI/MDI-X, polarity, Smartspeed and Master/Slave config for  *  igp PHY's.  **/
end_comment

begin_function
name|s32
name|e1000_copper_link_setup_igp
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|u16
name|data
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_copper_link_setup_igp"
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy
operator|->
name|reset_disable
condition|)
block|{
name|ret_val
operator|=
name|E1000_SUCCESS
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ret_val
operator|=
name|e1000_phy_hw_reset
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Error resetting the PHY.\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Wait 15ms for MAC to configure PHY from NVM settings. */
name|msec_delay
argument_list|(
literal|15
argument_list|)
expr_stmt|;
comment|/* The NVM settings will configure LPLU in D3 for 	 * non-IGP1 PHYs. */
if|if
condition|(
name|phy
operator|->
name|type
operator|==
name|e1000_phy_igp
condition|)
block|{
comment|/* disable lplu d3 during driver init */
name|ret_val
operator|=
name|e1000_set_d3_lplu_state
argument_list|(
name|hw
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Error Disabling LPLU D3\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
comment|/* disable lplu d0 during driver init */
name|ret_val
operator|=
name|e1000_set_d0_lplu_state
argument_list|(
name|hw
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Error Disabling LPLU D0\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Configure mdi-mdix settings */
name|ret_val
operator|=
name|e1000_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_CTRL
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|data
operator|&=
operator|~
name|IGP01E1000_PSCR_AUTO_MDIX
expr_stmt|;
switch|switch
condition|(
name|phy
operator|->
name|mdix
condition|)
block|{
case|case
literal|1
case|:
name|data
operator|&=
operator|~
name|IGP01E1000_PSCR_FORCE_MDI_MDIX
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|data
operator||=
name|IGP01E1000_PSCR_FORCE_MDI_MDIX
expr_stmt|;
break|break;
case|case
literal|0
case|:
default|default:
name|data
operator||=
name|IGP01E1000_PSCR_AUTO_MDIX
expr_stmt|;
break|break;
block|}
name|ret_val
operator|=
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_CTRL
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
comment|/* set auto-master slave resolution settings */
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|autoneg
condition|)
block|{
comment|/* when autonegotiation advertisement is only 1000Mbps then we 		 * should disable SmartSpeed and enable Auto MasterSlave 		 * resolution as hardware default. */
if|if
condition|(
name|phy
operator|->
name|autoneg_advertised
operator|==
name|ADVERTISE_1000_FULL
condition|)
block|{
comment|/* Disable SmartSpeed */
name|ret_val
operator|=
name|e1000_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_CONFIG
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|data
operator|&=
operator|~
name|IGP01E1000_PSCFR_SMART_SPEED
expr_stmt|;
name|ret_val
operator|=
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_CONFIG
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
comment|/* Set auto Master/Slave resolution process */
name|ret_val
operator|=
name|e1000_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_1000T_CTRL
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|data
operator|&=
operator|~
name|CR_1000T_MS_ENABLE
expr_stmt|;
name|ret_val
operator|=
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_1000T_CTRL
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
block|}
name|ret_val
operator|=
name|e1000_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_1000T_CTRL
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
comment|/* load defaults for future use */
name|phy
operator|->
name|original_ms_type
operator|=
operator|(
name|data
operator|&
name|CR_1000T_MS_ENABLE
operator|)
condition|?
operator|(
operator|(
name|data
operator|&
name|CR_1000T_MS_VALUE
operator|)
condition|?
name|e1000_ms_force_master
else|:
name|e1000_ms_force_slave
operator|)
else|:
name|e1000_ms_auto
expr_stmt|;
switch|switch
condition|(
name|phy
operator|->
name|ms_type
condition|)
block|{
case|case
name|e1000_ms_force_master
case|:
name|data
operator||=
operator|(
name|CR_1000T_MS_ENABLE
operator||
name|CR_1000T_MS_VALUE
operator|)
expr_stmt|;
break|break;
case|case
name|e1000_ms_force_slave
case|:
name|data
operator||=
name|CR_1000T_MS_ENABLE
expr_stmt|;
name|data
operator|&=
operator|~
operator|(
name|CR_1000T_MS_VALUE
operator|)
expr_stmt|;
break|break;
case|case
name|e1000_ms_auto
case|:
name|data
operator|&=
operator|~
name|CR_1000T_MS_ENABLE
expr_stmt|;
default|default:
break|break;
block|}
name|ret_val
operator|=
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_1000T_CTRL
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
block|}
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_copper_link_autoneg - Setup/Enable autoneg for copper link  *  @hw - pointer to the HW structure  *  *  Performs initial bounds checking on autoneg advertisement parameter, then  *  configure to advertise the full capability.  Setup the PHY to autoneg  *  and restart the negotiation process between the link partner.  If  *  wait_for_link, then wait for autoneg to complete before exiting.  **/
end_comment

begin_function
name|s32
name|e1000_copper_link_autoneg
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|u16
name|phy_ctrl
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_copper_link_autoneg"
argument_list|)
expr_stmt|;
comment|/* Perform some bounds checking on the autoneg advertisement 	 * parameter. 	 */
name|phy
operator|->
name|autoneg_advertised
operator|&=
name|phy
operator|->
name|autoneg_mask
expr_stmt|;
comment|/* If autoneg_advertised is zero, we assume it was not defaulted 	 * by the calling code so we set to advertise full capability. 	 */
if|if
condition|(
name|phy
operator|->
name|autoneg_advertised
operator|==
literal|0
condition|)
name|phy
operator|->
name|autoneg_advertised
operator|=
name|phy
operator|->
name|autoneg_mask
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Reconfiguring auto-neg advertisement params\n"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_phy_setup_autoneg
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Error Setting up Auto-Negotiation\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|DEBUGOUT
argument_list|(
literal|"Restarting Auto-Neg\n"
argument_list|)
expr_stmt|;
comment|/* Restart auto-negotiation by setting the Auto Neg Enable bit and 	 * the Auto Neg Restart bit in the PHY control register. 	 */
name|ret_val
operator|=
name|e1000_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_CONTROL
argument_list|,
operator|&
name|phy_ctrl
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|phy_ctrl
operator||=
operator|(
name|MII_CR_AUTO_NEG_EN
operator||
name|MII_CR_RESTART_AUTO_NEG
operator|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_CONTROL
argument_list|,
name|phy_ctrl
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
comment|/* Does the user want to wait for Auto-Neg to complete here, or 	 * check at a later time (for example, callback routine). 	 */
if|if
condition|(
name|phy
operator|->
name|wait_for_link
condition|)
block|{
name|ret_val
operator|=
name|e1000_wait_autoneg
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Error while waiting for "
literal|"autoneg to complete\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|hw
operator|->
name|mac
operator|.
name|get_link_status
operator|=
name|TRUE
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_phy_setup_autoneg - Configure PHY for auto-negotiation  *  @hw - pointer to the HW structure  *  *  Reads the MII auto-neg advertisement register and/or the 1000T control  *  register and if the PHY is already setup for auto-negotiation, then  *  return successful.  Otherwise, setup advertisement and flow control to  *  the appropriate values for the wanted auto-negotiation.  **/
end_comment

begin_function
name|s32
name|e1000_phy_setup_autoneg
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|u16
name|mii_autoneg_adv_reg
decl_stmt|;
name|u16
name|mii_1000t_ctrl_reg
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_phy_setup_autoneg"
argument_list|)
expr_stmt|;
name|phy
operator|->
name|autoneg_advertised
operator|&=
name|phy
operator|->
name|autoneg_mask
expr_stmt|;
comment|/* Read the MII Auto-Neg Advertisement Register (Address 4). */
name|ret_val
operator|=
name|e1000_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_AUTONEG_ADV
argument_list|,
operator|&
name|mii_autoneg_adv_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|phy
operator|->
name|autoneg_mask
operator|&
name|ADVERTISE_1000_FULL
condition|)
block|{
comment|/* Read the MII 1000Base-T Control Register (Address 9). */
name|ret_val
operator|=
name|e1000_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_1000T_CTRL
argument_list|,
operator|&
name|mii_1000t_ctrl_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
block|}
comment|/* Need to parse both autoneg_advertised and fc and set up 	 * the appropriate PHY registers.  First we will parse for 	 * autoneg_advertised software override.  Since we can advertise 	 * a plethora of combinations, we need to check each bit 	 * individually. 	 */
comment|/* First we clear all the 10/100 mb speed bits in the Auto-Neg 	 * Advertisement Register (Address 4) and the 1000 mb speed bits in 	 * the  1000Base-T Control Register (Address 9). 	 */
name|mii_autoneg_adv_reg
operator|&=
operator|~
operator|(
name|NWAY_AR_100TX_FD_CAPS
operator||
name|NWAY_AR_100TX_HD_CAPS
operator||
name|NWAY_AR_10T_FD_CAPS
operator||
name|NWAY_AR_10T_HD_CAPS
operator|)
expr_stmt|;
name|mii_1000t_ctrl_reg
operator|&=
operator|~
operator|(
name|CR_1000T_HD_CAPS
operator||
name|CR_1000T_FD_CAPS
operator|)
expr_stmt|;
name|DEBUGOUT1
argument_list|(
literal|"autoneg_advertised %x\n"
argument_list|,
name|phy
operator|->
name|autoneg_advertised
argument_list|)
expr_stmt|;
comment|/* Do we want to advertise 10 Mb Half Duplex? */
if|if
condition|(
name|phy
operator|->
name|autoneg_advertised
operator|&
name|ADVERTISE_10_HALF
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Advertise 10mb Half duplex\n"
argument_list|)
expr_stmt|;
name|mii_autoneg_adv_reg
operator||=
name|NWAY_AR_10T_HD_CAPS
expr_stmt|;
block|}
comment|/* Do we want to advertise 10 Mb Full Duplex? */
if|if
condition|(
name|phy
operator|->
name|autoneg_advertised
operator|&
name|ADVERTISE_10_FULL
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Advertise 10mb Full duplex\n"
argument_list|)
expr_stmt|;
name|mii_autoneg_adv_reg
operator||=
name|NWAY_AR_10T_FD_CAPS
expr_stmt|;
block|}
comment|/* Do we want to advertise 100 Mb Half Duplex? */
if|if
condition|(
name|phy
operator|->
name|autoneg_advertised
operator|&
name|ADVERTISE_100_HALF
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Advertise 100mb Half duplex\n"
argument_list|)
expr_stmt|;
name|mii_autoneg_adv_reg
operator||=
name|NWAY_AR_100TX_HD_CAPS
expr_stmt|;
block|}
comment|/* Do we want to advertise 100 Mb Full Duplex? */
if|if
condition|(
name|phy
operator|->
name|autoneg_advertised
operator|&
name|ADVERTISE_100_FULL
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Advertise 100mb Full duplex\n"
argument_list|)
expr_stmt|;
name|mii_autoneg_adv_reg
operator||=
name|NWAY_AR_100TX_FD_CAPS
expr_stmt|;
block|}
comment|/* We do not allow the Phy to advertise 1000 Mb Half Duplex */
if|if
condition|(
name|phy
operator|->
name|autoneg_advertised
operator|&
name|ADVERTISE_1000_HALF
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Advertise 1000mb Half duplex request denied!\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Do we want to advertise 1000 Mb Full Duplex? */
if|if
condition|(
name|phy
operator|->
name|autoneg_advertised
operator|&
name|ADVERTISE_1000_FULL
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Advertise 1000mb Full duplex\n"
argument_list|)
expr_stmt|;
name|mii_1000t_ctrl_reg
operator||=
name|CR_1000T_FD_CAPS
expr_stmt|;
block|}
comment|/* Check for a software override of the flow control settings, and 	 * setup the PHY advertisement registers accordingly.  If 	 * auto-negotiation is enabled, then software will have to set the 	 * "PAUSE" bits to the correct value in the Auto-Negotiation 	 * Advertisement Register (PHY_AUTONEG_ADV) and re-start auto- 	 * negotiation. 	 * 	 * The possible values of the "fc" parameter are: 	 *      0:  Flow control is completely disabled 	 *      1:  Rx flow control is enabled (we can receive pause frames 	 *          but not send pause frames). 	 *      2:  Tx flow control is enabled (we can send pause frames 	 *          but we do not support receiving pause frames). 	 *      3:  Both Rx and TX flow control (symmetric) are enabled. 	 *  other:  No software override.  The flow control configuration 	 *          in the EEPROM is used. 	 */
switch|switch
condition|(
name|hw
operator|->
name|mac
operator|.
name|fc
condition|)
block|{
case|case
name|e1000_fc_none
case|:
comment|/* Flow control (RX& TX) is completely disabled by a 		 * software over-ride. 		 */
name|mii_autoneg_adv_reg
operator|&=
operator|~
operator|(
name|NWAY_AR_ASM_DIR
operator||
name|NWAY_AR_PAUSE
operator|)
expr_stmt|;
break|break;
case|case
name|e1000_fc_rx_pause
case|:
comment|/* RX Flow control is enabled, and TX Flow control is 		 * disabled, by a software over-ride. 		 */
comment|/* Since there really isn't a way to advertise that we are 		 * capable of RX Pause ONLY, we will advertise that we 		 * support both symmetric and asymmetric RX PAUSE.  Later 		 * (in e1000_config_fc_after_link_up) we will disable the 		 * hw's ability to send PAUSE frames. 		 */
name|mii_autoneg_adv_reg
operator||=
operator|(
name|NWAY_AR_ASM_DIR
operator||
name|NWAY_AR_PAUSE
operator|)
expr_stmt|;
break|break;
case|case
name|e1000_fc_tx_pause
case|:
comment|/* TX Flow control is enabled, and RX Flow control is 		 * disabled, by a software over-ride. 		 */
name|mii_autoneg_adv_reg
operator||=
name|NWAY_AR_ASM_DIR
expr_stmt|;
name|mii_autoneg_adv_reg
operator|&=
operator|~
name|NWAY_AR_PAUSE
expr_stmt|;
break|break;
case|case
name|e1000_fc_full
case|:
comment|/* Flow control (both RX and TX) is enabled by a software 		 * over-ride. 		 */
name|mii_autoneg_adv_reg
operator||=
operator|(
name|NWAY_AR_ASM_DIR
operator||
name|NWAY_AR_PAUSE
operator|)
expr_stmt|;
break|break;
default|default:
name|DEBUGOUT
argument_list|(
literal|"Flow control param set incorrectly\n"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
operator|-
name|E1000_ERR_CONFIG
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ret_val
operator|=
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_AUTONEG_ADV
argument_list|,
name|mii_autoneg_adv_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|DEBUGOUT1
argument_list|(
literal|"Auto-Neg Advertising %x\n"
argument_list|,
name|mii_autoneg_adv_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy
operator|->
name|autoneg_mask
operator|&
name|ADVERTISE_1000_FULL
condition|)
block|{
name|ret_val
operator|=
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_1000T_CTRL
argument_list|,
name|mii_1000t_ctrl_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
block|}
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_setup_copper_link_generic - Configure copper link settings  *  @hw - pointer to the HW structure  *  *  Calls the appropriate function to configure the link for auto-neg or forced  *  speed and duplex.  Then we check for link, once link is established calls  *  to configure collision distance and flow control are called.  If link is  *  not established, we return -E1000_ERR_PHY (-2).  **/
end_comment

begin_function
name|s32
name|e1000_setup_copper_link_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|ret_val
decl_stmt|;
name|boolean_t
name|link
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_setup_copper_link_generic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|autoneg
condition|)
block|{
comment|/* Setup autoneg and flow control advertisement and perform 		 * autonegotiation. */
name|ret_val
operator|=
name|e1000_copper_link_autoneg
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
block|}
else|else
block|{
comment|/* PHY will be set to 10H, 10F, 100H or 100F 		 * depending on user settings. */
name|DEBUGOUT
argument_list|(
literal|"Forcing Speed and Duplex\n"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_phy_force_speed_duplex
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Error Forcing Speed and Duplex\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
comment|/* Check link status. Wait up to 100 microseconds for link to become 	 * valid. 	 */
name|ret_val
operator|=
name|e1000_phy_has_link_generic
argument_list|(
name|hw
argument_list|,
name|COPPER_LINK_UP_LIMIT
argument_list|,
literal|10
argument_list|,
operator|&
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|link
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Valid link established!!!\n"
argument_list|)
expr_stmt|;
name|e1000_config_collision_dist_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_config_fc_after_link_up_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DEBUGOUT
argument_list|(
literal|"Unable to establish link!!!\n"
argument_list|)
expr_stmt|;
block|}
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_phy_force_speed_duplex_igp - Force speed/duplex for igp PHY  *  @hw - pointer to the HW structure  *  *  Calls the PHY setup function to force speed and duplex.  Clears the  *  auto-crossover to force MDI manually.  Waits for link and returns  *  successful if link up is successful, else -E1000_ERR_PHY (-2).  **/
end_comment

begin_function
name|s32
name|e1000_phy_force_speed_duplex_igp
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|u16
name|phy_data
decl_stmt|;
name|boolean_t
name|link
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_phy_force_speed_duplex_igp"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_CONTROL
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|e1000_phy_force_speed_duplex_setup
argument_list|(
name|hw
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_CONTROL
argument_list|,
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
comment|/* Clear Auto-Crossover to force MDI manually.  IGP requires MDI 	 * forced whenever speed and duplex are forced. 	 */
name|ret_val
operator|=
name|e1000_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_CTRL
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|phy_data
operator|&=
operator|~
name|IGP01E1000_PSCR_AUTO_MDIX
expr_stmt|;
name|phy_data
operator|&=
operator|~
name|IGP01E1000_PSCR_FORCE_MDI_MDIX
expr_stmt|;
name|ret_val
operator|=
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_CTRL
argument_list|,
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|DEBUGOUT1
argument_list|(
literal|"IGP PSCR: %X\n"
argument_list|,
name|phy_data
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy
operator|->
name|wait_for_link
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Waiting for forced speed/duplex link on IGP phy.\n"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_phy_has_link_generic
argument_list|(
name|hw
argument_list|,
name|PHY_FORCE_LIMIT
argument_list|,
literal|100000
argument_list|,
operator|&
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|!
name|link
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Link taking longer than expected.\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Try once more */
name|ret_val
operator|=
name|e1000_phy_has_link_generic
argument_list|(
name|hw
argument_list|,
name|PHY_FORCE_LIMIT
argument_list|,
literal|100000
argument_list|,
operator|&
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
block|}
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_phy_force_speed_duplex_m88 - Force speed/duplex for m88 PHY  *  @hw - pointer to the HW structure  *  *  Calls the PHY setup function to force speed and duplex.  Clears the  *  auto-crossover to force MDI manually.  Resets the PHY to commit the  *  changes.  If time expires while waiting for link up, we reset the DSP.  *  After reset, TX_CLK and CRS on TX must be set.  Return successful upon  *  successful completion, else return corresponding error code.  **/
end_comment

begin_function
name|s32
name|e1000_phy_force_speed_duplex_m88
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|u16
name|phy_data
decl_stmt|;
name|boolean_t
name|link
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_phy_force_speed_duplex_m88"
argument_list|)
expr_stmt|;
comment|/* Clear Auto-Crossover to force MDI manually.  M88E1000 requires MDI 	 * forced whenever speed and duplex are forced. 	 */
name|ret_val
operator|=
name|e1000_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_SPEC_CTRL
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|phy_data
operator|&=
operator|~
name|M88E1000_PSCR_AUTO_X_MODE
expr_stmt|;
name|ret_val
operator|=
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_SPEC_CTRL
argument_list|,
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|DEBUGOUT1
argument_list|(
literal|"M88E1000 PSCR: %X\n"
argument_list|,
name|phy_data
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_CONTROL
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|e1000_phy_force_speed_duplex_setup
argument_list|(
name|hw
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
comment|/* Reset the phy to commit changes. */
name|phy_data
operator||=
name|MII_CR_RESET
expr_stmt|;
name|ret_val
operator|=
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_CONTROL
argument_list|,
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|usec_delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy
operator|->
name|wait_for_link
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Waiting for forced speed/duplex link on M88 phy.\n"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_phy_has_link_generic
argument_list|(
name|hw
argument_list|,
name|PHY_FORCE_LIMIT
argument_list|,
literal|100000
argument_list|,
operator|&
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|!
name|link
condition|)
block|{
comment|/* We didn't get link. 			 * Reset the DSP and cross our fingers. 			 */
name|ret_val
operator|=
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_PAGE_SELECT
argument_list|,
literal|0x001d
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|ret_val
operator|=
name|e1000_phy_reset_dsp_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
block|}
comment|/* Try once more */
name|ret_val
operator|=
name|e1000_phy_has_link_generic
argument_list|(
name|hw
argument_list|,
name|PHY_FORCE_LIMIT
argument_list|,
literal|100000
argument_list|,
operator|&
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
block|}
name|ret_val
operator|=
name|e1000_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_EXT_PHY_SPEC_CTRL
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
comment|/* Resetting the phy means we need to re-force TX_CLK in the 	 * Extended PHY Specific Control Register to 25MHz clock from 	 * the reset value of 2.5MHz. 	 */
name|phy_data
operator||=
name|M88E1000_EPSCR_TX_CLK_25
expr_stmt|;
name|ret_val
operator|=
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_EXT_PHY_SPEC_CTRL
argument_list|,
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
comment|/* In addition, we must re-enable CRS on Tx for both half and full 	 * duplex. 	 */
name|ret_val
operator|=
name|e1000_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_SPEC_CTRL
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|phy_data
operator||=
name|M88E1000_PSCR_ASSERT_CRS_ON_TX
expr_stmt|;
name|ret_val
operator|=
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_SPEC_CTRL
argument_list|,
name|phy_data
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_phy_force_speed_duplex_setup - Configure forced PHY speed/duplex  *  @hw - pointer to the HW structure  *  @phy_ctrl - pointer to current value of PHY_CONTROL  *  *  Forces speed and duplex on the PHY by doing the following: disable flow  *  control, force speed/duplex on the MAC, disable auto speed detection,  *  disable auto-negotiation, configure duplex, configure speed, configure  *  the collision distance, write configuration to CTRL register.  The  *  caller must write to the PHY_CONTROL register for these settings to  *  take affect.  **/
end_comment

begin_function
name|void
name|e1000_phy_force_speed_duplex_setup
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
modifier|*
name|phy_ctrl
parameter_list|)
block|{
name|struct
name|e1000_mac_info
modifier|*
name|mac
init|=
operator|&
name|hw
operator|->
name|mac
decl_stmt|;
name|u32
name|ctrl
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_phy_force_speed_duplex_setup"
argument_list|)
expr_stmt|;
comment|/* Turn off flow control when forcing speed/duplex */
name|mac
operator|->
name|fc
operator|=
name|e1000_fc_none
expr_stmt|;
comment|/* Force speed/duplex on the mac */
name|ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|)
expr_stmt|;
name|ctrl
operator||=
operator|(
name|E1000_CTRL_FRCSPD
operator||
name|E1000_CTRL_FRCDPX
operator|)
expr_stmt|;
name|ctrl
operator|&=
operator|~
name|E1000_CTRL_SPD_SEL
expr_stmt|;
comment|/* Disable Auto Speed Detection */
name|ctrl
operator|&=
operator|~
name|E1000_CTRL_ASDE
expr_stmt|;
comment|/* Disable autoneg on the phy */
operator|*
name|phy_ctrl
operator|&=
operator|~
name|MII_CR_AUTO_NEG_EN
expr_stmt|;
comment|/* Forcing Full or Half Duplex? */
if|if
condition|(
name|mac
operator|->
name|forced_speed_duplex
operator|&
name|E1000_ALL_HALF_DUPLEX
condition|)
block|{
name|ctrl
operator|&=
operator|~
name|E1000_CTRL_FD
expr_stmt|;
operator|*
name|phy_ctrl
operator|&=
operator|~
name|MII_CR_FULL_DUPLEX
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Half Duplex\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ctrl
operator||=
name|E1000_CTRL_FD
expr_stmt|;
operator|*
name|phy_ctrl
operator||=
name|MII_CR_FULL_DUPLEX
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Full Duplex\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Forcing 10mb or 100mb? */
if|if
condition|(
name|mac
operator|->
name|forced_speed_duplex
operator|&
name|E1000_ALL_100_SPEED
condition|)
block|{
name|ctrl
operator||=
name|E1000_CTRL_SPD_100
expr_stmt|;
operator|*
name|phy_ctrl
operator||=
name|MII_CR_SPEED_100
expr_stmt|;
operator|*
name|phy_ctrl
operator|&=
operator|~
operator|(
name|MII_CR_SPEED_1000
operator||
name|MII_CR_SPEED_10
operator|)
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Forcing 100mb\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ctrl
operator|&=
operator|~
operator|(
name|E1000_CTRL_SPD_1000
operator||
name|E1000_CTRL_SPD_100
operator|)
expr_stmt|;
operator|*
name|phy_ctrl
operator||=
name|MII_CR_SPEED_10
expr_stmt|;
operator|*
name|phy_ctrl
operator|&=
operator|~
operator|(
name|MII_CR_SPEED_1000
operator||
name|MII_CR_SPEED_100
operator|)
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Forcing 10mb\n"
argument_list|)
expr_stmt|;
block|}
name|e1000_config_collision_dist_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  e1000_set_d3_lplu_state_generic - Sets low power link up state for D3  *  @hw - pointer to the HW structure  *  @active boolean used to enable/disable lplu  *  *  Success returns 0, Failure returns 1  *  *  The low power link up (lplu) state is set to the power management level D3  *  and SmartSpeed is disabled when active is true, else clear lplu for D3  *  and enable Smartspeed.  LPLU and Smartspeed are mutually exclusive.  LPLU  *  is used during Dx states where the power conservation is most important.  *  During driver activity, SmartSpeed should be enabled so performance is  *  maintained.  **/
end_comment

begin_function
name|s32
name|e1000_set_d3_lplu_state_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|boolean_t
name|active
parameter_list|)
block|{
name|struct
name|e1000_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|u16
name|data
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_set_d3_lplu_state_generic"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP02E1000_PHY_POWER_MGMT
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|!
name|active
condition|)
block|{
name|data
operator|&=
operator|~
name|IGP02E1000_PM_D3_LPLU
expr_stmt|;
name|ret_val
operator|=
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP02E1000_PHY_POWER_MGMT
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
comment|/* LPLU and SmartSpeed are mutually exclusive.  LPLU is used 		 * during Dx states where the power conservation is most 		 * important.  During driver activity we should enable 		 * SmartSpeed, so performance is maintained. */
if|if
condition|(
name|phy
operator|->
name|smart_speed
operator|==
name|e1000_smart_speed_on
condition|)
block|{
name|ret_val
operator|=
name|e1000_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_CONFIG
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|data
operator||=
name|IGP01E1000_PSCFR_SMART_SPEED
expr_stmt|;
name|ret_val
operator|=
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_CONFIG
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
block|}
elseif|else
if|if
condition|(
name|phy
operator|->
name|smart_speed
operator|==
name|e1000_smart_speed_off
condition|)
block|{
name|ret_val
operator|=
name|e1000_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_CONFIG
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|data
operator|&=
operator|~
name|IGP01E1000_PSCFR_SMART_SPEED
expr_stmt|;
name|ret_val
operator|=
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_CONFIG
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|phy
operator|->
name|autoneg_advertised
operator|==
name|E1000_ALL_SPEED_DUPLEX
operator|)
operator|||
operator|(
name|phy
operator|->
name|autoneg_advertised
operator|==
name|E1000_ALL_NOT_GIG
operator|)
operator|||
operator|(
name|phy
operator|->
name|autoneg_advertised
operator|==
name|E1000_ALL_10_SPEED
operator|)
condition|)
block|{
name|data
operator||=
name|IGP02E1000_PM_D3_LPLU
expr_stmt|;
name|ret_val
operator|=
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP02E1000_PHY_POWER_MGMT
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
comment|/* When LPLU is enabled, we should disable SmartSpeed */
name|ret_val
operator|=
name|e1000_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_CONFIG
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|data
operator|&=
operator|~
name|IGP01E1000_PSCFR_SMART_SPEED
expr_stmt|;
name|ret_val
operator|=
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_CONFIG
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_check_downshift_generic - Checks whether a downshift in speed occured  *  @hw - pointer to the HW structure  *  *  Success returns 0, Failure returns 1  *  *  A downshift is detected by querying the PHY link health.  **/
end_comment

begin_function
name|s32
name|e1000_check_downshift_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|u16
name|phy_data
decl_stmt|,
name|offset
decl_stmt|,
name|mask
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_check_downshift_generic"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|phy
operator|->
name|type
condition|)
block|{
case|case
name|e1000_phy_m88
case|:
case|case
name|e1000_phy_gg82563
case|:
name|offset
operator|=
name|M88E1000_PHY_SPEC_STATUS
expr_stmt|;
name|mask
operator|=
name|M88E1000_PSSR_DOWNSHIFT
expr_stmt|;
break|break;
case|case
name|e1000_phy_igp_2
case|:
case|case
name|e1000_phy_igp
case|:
case|case
name|e1000_phy_igp_3
case|:
name|offset
operator|=
name|IGP01E1000_PHY_LINK_HEALTH
expr_stmt|;
name|mask
operator|=
name|IGP01E1000_PLHR_SS_DOWNGRADE
expr_stmt|;
break|break;
default|default:
comment|/* speed downshift not supported */
name|phy
operator|->
name|speed_downgraded
operator|=
name|FALSE
expr_stmt|;
name|ret_val
operator|=
name|E1000_SUCCESS
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ret_val
operator|=
name|e1000_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret_val
condition|)
name|phy
operator|->
name|speed_downgraded
operator|=
operator|(
name|phy_data
operator|&
name|mask
operator|)
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_check_polarity_m88 - Checks the polarity.  *  @hw - pointer to the HW structure  *  *  Success returns 0, Failure returns -E1000_ERR_PHY (-2)  *  *  Polarity is determined based on the PHY specific status register.  **/
end_comment

begin_function
name|s32
name|e1000_check_polarity_m88
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|u16
name|data
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_check_polarity_m88"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_SPEC_STATUS
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret_val
condition|)
name|phy
operator|->
name|cable_polarity
operator|=
operator|(
name|data
operator|&
name|M88E1000_PSSR_REV_POLARITY
operator|)
condition|?
name|e1000_rev_polarity_reversed
else|:
name|e1000_rev_polarity_normal
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_check_polarity_igp - Checks the polarity.  *  @hw - pointer to the HW structure  *  *  Success returns 0, Failure returns -E1000_ERR_PHY (-2)  *  *  Polarity is determined based on the PHY port status register, and the  *  current speed (since there is no polarity at 100Mbps).  **/
end_comment

begin_function
name|s32
name|e1000_check_polarity_igp
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|u16
name|data
decl_stmt|,
name|offset
decl_stmt|,
name|mask
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_check_polarity_igp"
argument_list|)
expr_stmt|;
comment|/* Polarity is determined based on the speed of 	 * our connection. */
name|ret_val
operator|=
name|e1000_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_STATUS
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|(
name|data
operator|&
name|IGP01E1000_PSSR_SPEED_MASK
operator|)
operator|==
name|IGP01E1000_PSSR_SPEED_1000MBPS
condition|)
block|{
name|offset
operator|=
name|IGP01E1000_PHY_PCS_INIT_REG
expr_stmt|;
name|mask
operator|=
name|IGP01E1000_PHY_POLARITY_MASK
expr_stmt|;
block|}
else|else
block|{
comment|/* This really only applies to 10Mbps since 		 * there is no polarity for 100Mbps (always 0). 		 */
name|offset
operator|=
name|IGP01E1000_PHY_PORT_STATUS
expr_stmt|;
name|mask
operator|=
name|IGP01E1000_PSSR_POLARITY_REVERSED
expr_stmt|;
block|}
name|ret_val
operator|=
name|e1000_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret_val
condition|)
name|phy
operator|->
name|cable_polarity
operator|=
operator|(
name|data
operator|&
name|mask
operator|)
condition|?
name|e1000_rev_polarity_reversed
else|:
name|e1000_rev_polarity_normal
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_wait_autoneg_generic - Wait for auto-neg compeletion  *  @hw - pointer to the HW structure  *  *  Waits for auto-negotiation to complete or for the auto-negotiation time  *  limit to expire, which ever happens first.  **/
end_comment

begin_function
name|s32
name|e1000_wait_autoneg_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|u16
name|i
decl_stmt|,
name|phy_status
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_wait_autoneg_generic"
argument_list|)
expr_stmt|;
comment|/* Break after autoneg completes or PHY_AUTO_NEG_LIMIT expires. */
for|for
control|(
name|i
operator|=
name|PHY_AUTO_NEG_LIMIT
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|ret_val
operator|=
name|e1000_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_STATUS
argument_list|,
operator|&
name|phy_status
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
break|break;
name|ret_val
operator|=
name|e1000_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_STATUS
argument_list|,
operator|&
name|phy_status
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
break|break;
if|if
condition|(
name|phy_status
operator|&
name|MII_SR_AUTONEG_COMPLETE
condition|)
break|break;
name|msec_delay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
comment|/* PHY_AUTO_NEG_TIME expiration doesn't guarantee auto-negotiation 	 * has completed. 	 */
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_phy_has_link_generic - Polls PHY for link  *  @hw - pointer to the HW structure  *  @iterations - number of times to poll for link  *  @usec_interval - delay between polling attempts  *  @success - pointer to whether polling was successful or not  *  *  Polls the PHY status register for link, 'iterations' number of times.  **/
end_comment

begin_function
name|s32
name|e1000_phy_has_link_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|iterations
parameter_list|,
name|u32
name|usec_interval
parameter_list|,
name|boolean_t
modifier|*
name|success
parameter_list|)
block|{
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|u16
name|i
decl_stmt|,
name|phy_status
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_phy_has_link_generic"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|iterations
condition|;
name|i
operator|++
control|)
block|{
comment|/* Some PHYs require the PHY_STATUS register to be read 		 * twice due to the link bit being sticky.  No harm doing 		 * it across the board. 		 */
name|ret_val
operator|=
name|e1000_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_STATUS
argument_list|,
operator|&
name|phy_status
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
break|break;
name|ret_val
operator|=
name|e1000_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_STATUS
argument_list|,
operator|&
name|phy_status
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
break|break;
if|if
condition|(
name|phy_status
operator|&
name|MII_SR_LINK_STATUS
condition|)
break|break;
if|if
condition|(
name|usec_interval
operator|>=
literal|1000
condition|)
name|msec_delay_irq
argument_list|(
name|usec_interval
operator|/
literal|1000
argument_list|)
expr_stmt|;
else|else
name|usec_delay
argument_list|(
name|usec_interval
argument_list|)
expr_stmt|;
block|}
operator|*
name|success
operator|=
operator|(
name|i
operator|<
name|iterations
operator|)
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_get_cable_length_m88 - Determine cable length for m88 PHY  *  @hw - pointer to the HW structure  *  *  Reads the PHY specific status register to retrieve the cable length  *  information.  The cable length is determined by averaging the minimum and  *  maximum values to get the "average" cable length.  The m88 PHY has four  *  possible cable length values, which are:  *	Register Value		Cable Length  *	0< 50 meters  *	1			50 - 80 meters  *	2			80 - 110 meters  *	3			110 - 140 meters  *	4> 140 meters  **/
end_comment

begin_function
name|s32
name|e1000_get_cable_length_m88
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|u16
name|phy_data
decl_stmt|,
name|index
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_get_cable_length_m88"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_SPEC_STATUS
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|index
operator|=
operator|(
name|phy_data
operator|&
name|M88E1000_PSSR_CABLE_LENGTH
operator|)
operator|>>
name|M88E1000_PSSR_CABLE_LENGTH_SHIFT
expr_stmt|;
name|phy
operator|->
name|min_cable_length
operator|=
name|e1000_m88_cable_length_table
index|[
name|index
index|]
expr_stmt|;
name|phy
operator|->
name|max_cable_length
operator|=
name|e1000_m88_cable_length_table
index|[
name|index
operator|+
literal|1
index|]
expr_stmt|;
name|phy
operator|->
name|cable_length
operator|=
operator|(
name|phy
operator|->
name|min_cable_length
operator|+
name|phy
operator|->
name|max_cable_length
operator|)
operator|/
literal|2
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_get_cable_length_igp_2 - Determine cable length for igp2 PHY  *  @hw - pointer to the HW structure  *  *  The automatic gain control (agc) normalizes the amplitude of the  *  received signal, adjusting for the attenuation produced by the  *  cable.  By reading the AGC registers, which reperesent the  *  cobination of course and fine gain value, the value can be put  *  into a lookup table to obtain the approximate cable length  *  for each channel.  **/
end_comment

begin_function
name|s32
name|e1000_get_cable_length_igp_2
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|u16
name|phy_data
decl_stmt|,
name|i
decl_stmt|,
name|agc_value
init|=
literal|0
decl_stmt|;
name|u16
name|cur_agc_index
decl_stmt|,
name|max_agc_index
init|=
literal|0
decl_stmt|;
name|u16
name|min_agc_index
init|=
name|IGP02E1000_CABLE_LENGTH_TABLE_SIZE
operator|-
literal|1
decl_stmt|;
name|u16
name|agc_reg_array
index|[
name|IGP02E1000_PHY_CHANNEL_NUM
index|]
init|=
block|{
name|IGP02E1000_PHY_AGC_A
block|,
name|IGP02E1000_PHY_AGC_B
block|,
name|IGP02E1000_PHY_AGC_C
block|,
name|IGP02E1000_PHY_AGC_D
block|}
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_get_cable_length_igp_2"
argument_list|)
expr_stmt|;
comment|/* Read the AGC registers for all channels */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IGP02E1000_PHY_CHANNEL_NUM
condition|;
name|i
operator|++
control|)
block|{
name|ret_val
operator|=
name|e1000_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|agc_reg_array
index|[
name|i
index|]
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
comment|/* Getting bits 15:9, which represent the combination of 		 * course and fine gain values.  The result is a number 		 * that can be put into the lookup table to obtain the 		 * approximate cable length. */
name|cur_agc_index
operator|=
operator|(
name|phy_data
operator|>>
name|IGP02E1000_AGC_LENGTH_SHIFT
operator|)
operator|&
name|IGP02E1000_AGC_LENGTH_MASK
expr_stmt|;
comment|/* Array index bound check. */
if|if
condition|(
operator|(
name|cur_agc_index
operator|>=
name|IGP02E1000_CABLE_LENGTH_TABLE_SIZE
operator|)
operator|||
operator|(
name|cur_agc_index
operator|==
literal|0
operator|)
condition|)
block|{
name|ret_val
operator|=
operator|-
name|E1000_ERR_PHY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Remove min& max AGC values from calculation. */
if|if
condition|(
name|e1000_igp_2_cable_length_table
index|[
name|min_agc_index
index|]
operator|>
name|e1000_igp_2_cable_length_table
index|[
name|cur_agc_index
index|]
condition|)
name|min_agc_index
operator|=
name|cur_agc_index
expr_stmt|;
if|if
condition|(
name|e1000_igp_2_cable_length_table
index|[
name|max_agc_index
index|]
operator|<
name|e1000_igp_2_cable_length_table
index|[
name|cur_agc_index
index|]
condition|)
name|max_agc_index
operator|=
name|cur_agc_index
expr_stmt|;
name|agc_value
operator|+=
name|e1000_igp_2_cable_length_table
index|[
name|cur_agc_index
index|]
expr_stmt|;
block|}
name|agc_value
operator|-=
operator|(
name|e1000_igp_2_cable_length_table
index|[
name|min_agc_index
index|]
operator|+
name|e1000_igp_2_cable_length_table
index|[
name|max_agc_index
index|]
operator|)
expr_stmt|;
name|agc_value
operator|/=
operator|(
name|IGP02E1000_PHY_CHANNEL_NUM
operator|-
literal|2
operator|)
expr_stmt|;
comment|/* Calculate cable length with the error range of +/- 10 meters. */
name|phy
operator|->
name|min_cable_length
operator|=
operator|(
operator|(
name|agc_value
operator|-
name|IGP02E1000_AGC_RANGE
operator|)
operator|>
literal|0
operator|)
condition|?
operator|(
name|agc_value
operator|-
name|IGP02E1000_AGC_RANGE
operator|)
else|:
literal|0
expr_stmt|;
name|phy
operator|->
name|max_cable_length
operator|=
name|agc_value
operator|+
name|IGP02E1000_AGC_RANGE
expr_stmt|;
name|phy
operator|->
name|cable_length
operator|=
operator|(
name|phy
operator|->
name|min_cable_length
operator|+
name|phy
operator|->
name|max_cable_length
operator|)
operator|/
literal|2
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_get_phy_info_m88 - Retrieve PHY information  *  @hw - pointer to the HW structure  *  *  Valid for only copper links.  Read the PHY status register (sticky read)  *  to verify that link is up.  Read the PHY special control register to  *  determine the polarity and 10base-T extended distance.  Read the PHY  *  special status register to determine MDI/MDIx and current speed.  If  *  speed is 1000, then determine cable length, local and remote receiver.  **/
end_comment

begin_function
name|s32
name|e1000_get_phy_info_m88
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|u16
name|phy_data
decl_stmt|;
name|boolean_t
name|link
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_get_phy_info_m88"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|media_type
operator|!=
name|e1000_media_type_copper
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Phy info is only valid for copper media\n"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
operator|-
name|E1000_ERR_CONFIG
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ret_val
operator|=
name|e1000_phy_has_link_generic
argument_list|(
name|hw
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
operator|&
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|!
name|link
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Phy info is only valid if link is up\n"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
operator|-
name|E1000_ERR_CONFIG
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ret_val
operator|=
name|e1000_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_SPEC_CTRL
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|phy
operator|->
name|polarity_correction
operator|=
operator|(
name|phy_data
operator|&
name|M88E1000_PSCR_POLARITY_REVERSAL
operator|)
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
name|ret_val
operator|=
name|e1000_check_polarity_m88
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|ret_val
operator|=
name|e1000_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_SPEC_STATUS
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|phy
operator|->
name|is_mdix
operator|=
operator|(
name|phy_data
operator|&
name|M88E1000_PSSR_MDIX
operator|)
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
if|if
condition|(
operator|(
name|phy_data
operator|&
name|M88E1000_PSSR_SPEED
operator|)
operator|==
name|M88E1000_PSSR_1000MBS
condition|)
block|{
name|ret_val
operator|=
name|e1000_get_cable_length
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|ret_val
operator|=
name|e1000_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_1000T_STATUS
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|phy
operator|->
name|local_rx
operator|=
operator|(
name|phy_data
operator|&
name|SR_1000T_LOCAL_RX_STATUS
operator|)
condition|?
name|e1000_1000t_rx_status_ok
else|:
name|e1000_1000t_rx_status_not_ok
expr_stmt|;
name|phy
operator|->
name|remote_rx
operator|=
operator|(
name|phy_data
operator|&
name|SR_1000T_REMOTE_RX_STATUS
operator|)
condition|?
name|e1000_1000t_rx_status_ok
else|:
name|e1000_1000t_rx_status_not_ok
expr_stmt|;
block|}
else|else
block|{
comment|/* Set values to "undefined" */
name|phy
operator|->
name|cable_length
operator|=
name|E1000_CABLE_LENGTH_UNDEFINED
expr_stmt|;
name|phy
operator|->
name|local_rx
operator|=
name|e1000_1000t_rx_status_undefined
expr_stmt|;
name|phy
operator|->
name|remote_rx
operator|=
name|e1000_1000t_rx_status_undefined
expr_stmt|;
block|}
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_get_phy_info_igp - Retrieve igp PHY information  *  @hw - pointer to the HW structure  *  *  Read PHY status to determine if link is up.  If link is up, then  *  set/determine 10base-T extended distance and polarity correction.  Read  *  PHY port status to determine MDI/MDIx and speed.  Based on the speed,  *  determine on the cable length, local and remote receiver.  **/
end_comment

begin_function
name|s32
name|e1000_get_phy_info_igp
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|u16
name|data
decl_stmt|;
name|boolean_t
name|link
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_get_phy_info_igp"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_phy_has_link_generic
argument_list|(
name|hw
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
operator|&
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|!
name|link
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Phy info is only valid if link is up\n"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
operator|-
name|E1000_ERR_CONFIG
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|phy
operator|->
name|polarity_correction
operator|=
name|TRUE
expr_stmt|;
name|ret_val
operator|=
name|e1000_check_polarity_igp
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|ret_val
operator|=
name|e1000_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_STATUS
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|phy
operator|->
name|is_mdix
operator|=
operator|(
name|data
operator|&
name|IGP01E1000_PSSR_MDIX
operator|)
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
if|if
condition|(
operator|(
name|data
operator|&
name|IGP01E1000_PSSR_SPEED_MASK
operator|)
operator|==
name|IGP01E1000_PSSR_SPEED_1000MBPS
condition|)
block|{
name|ret_val
operator|=
name|e1000_get_cable_length
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|ret_val
operator|=
name|e1000_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_1000T_STATUS
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|phy
operator|->
name|local_rx
operator|=
operator|(
name|data
operator|&
name|SR_1000T_LOCAL_RX_STATUS
operator|)
condition|?
name|e1000_1000t_rx_status_ok
else|:
name|e1000_1000t_rx_status_not_ok
expr_stmt|;
name|phy
operator|->
name|remote_rx
operator|=
operator|(
name|data
operator|&
name|SR_1000T_REMOTE_RX_STATUS
operator|)
condition|?
name|e1000_1000t_rx_status_ok
else|:
name|e1000_1000t_rx_status_not_ok
expr_stmt|;
block|}
else|else
block|{
name|phy
operator|->
name|cable_length
operator|=
name|E1000_CABLE_LENGTH_UNDEFINED
expr_stmt|;
name|phy
operator|->
name|local_rx
operator|=
name|e1000_1000t_rx_status_undefined
expr_stmt|;
name|phy
operator|->
name|remote_rx
operator|=
name|e1000_1000t_rx_status_undefined
expr_stmt|;
block|}
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_phy_sw_reset_generic - PHY software reset  *  @hw - pointer to the HW structure  *  *  Does a software reset of the PHY by reading the PHY control register and  *  setting/write the control register reset bit to the PHY.  **/
end_comment

begin_function
name|s32
name|e1000_phy_sw_reset_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|ret_val
decl_stmt|;
name|u16
name|phy_ctrl
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_phy_sw_reset_generic"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_CONTROL
argument_list|,
operator|&
name|phy_ctrl
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|phy_ctrl
operator||=
name|MII_CR_RESET
expr_stmt|;
name|ret_val
operator|=
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_CONTROL
argument_list|,
name|phy_ctrl
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|usec_delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_phy_hw_reset_generic - PHY hardware reset  *  @hw - pointer to the HW structure  *  *  Verify the reset block is not blocking us from resetting.  Acquire  *  semaphore (if necessary) and read/set/write the device control reset  *  bit in the PHY.  Wait the appropriate delay time for the device to  *  reset and relase the semaphore (if necessary).  **/
end_comment

begin_function
name|s32
name|e1000_phy_hw_reset_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|u32
name|ctrl
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_phy_hw_reset_generic"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_check_reset_block
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|ret_val
operator|=
name|E1000_SUCCESS
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ret_val
operator|=
name|e1000_acquire_phy
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|,
name|ctrl
operator||
name|E1000_CTRL_PHY_RST
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
name|phy
operator|->
name|reset_delay_us
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|150
argument_list|)
expr_stmt|;
name|e1000_release_phy
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_get_phy_cfg_done
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_get_cfg_done_generic - Generic configuration done  *  @hw - pointer to the HW structure  *  *  Generic function to wait 10 milli-seconds for configuration to complete  *  and return success.  **/
end_comment

begin_function
name|s32
name|e1000_get_cfg_done_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"e1000_get_cfg_done_generic"
argument_list|)
expr_stmt|;
name|msec_delay_irq
argument_list|(
literal|10
argument_list|)
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* Internal function pointers */
end_comment

begin_comment
comment|/**  *  e1000_get_phy_cfg_done - Generic PHY configuration done  *  @hw - pointer to the HW structure  *  *  Return success if silicon family did not implement a family specific  *  get_cfg_done function.  **/
end_comment

begin_function
name|s32
name|e1000_get_phy_cfg_done
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
if|if
condition|(
name|hw
operator|->
name|func
operator|.
name|get_cfg_done
operator|!=
name|NULL
condition|)
return|return
name|hw
operator|->
name|func
operator|.
name|get_cfg_done
argument_list|(
name|hw
argument_list|)
return|;
else|else
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_release_phy - Generic release PHY  *  @hw - pointer to the HW structure  *  *  Return if silicon family does not require a semaphore when accessing the  *  PHY.  **/
end_comment

begin_function
name|void
name|e1000_release_phy
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
if|if
condition|(
name|hw
operator|->
name|func
operator|.
name|release_phy
operator|!=
name|NULL
condition|)
name|hw
operator|->
name|func
operator|.
name|release_phy
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  e1000_acquire_phy - Generic acquire PHY  *  @hw - pointer to the HW structure  *  *  Return success if silicon family does not require a semaphore when  *  accessing the PHY.  **/
end_comment

begin_function
name|s32
name|e1000_acquire_phy
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
if|if
condition|(
name|hw
operator|->
name|func
operator|.
name|acquire_phy
operator|!=
name|NULL
condition|)
return|return
name|hw
operator|->
name|func
operator|.
name|acquire_phy
argument_list|(
name|hw
argument_list|)
return|;
else|else
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_phy_force_speed_duplex - Generic force PHY speed/duplex  *  @hw - pointer to the HW structure  *  *  When the silicon family has not implemented a forced speed/duplex  *  function for the PHY, simply return E1000_SUCCESS.  **/
end_comment

begin_function
name|s32
name|e1000_phy_force_speed_duplex
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
if|if
condition|(
name|hw
operator|->
name|func
operator|.
name|force_speed_duplex
operator|!=
name|NULL
condition|)
return|return
name|hw
operator|->
name|func
operator|.
name|force_speed_duplex
argument_list|(
name|hw
argument_list|)
return|;
else|else
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_phy_init_script_igp3 - Inits the IGP3 PHY  *  @hw - pointer to the HW structure  *  *  Initializes a Intel Gigabit PHY3 when an EEPROM is not present.  **/
end_comment

begin_function
name|s32
name|e1000_phy_init_script_igp3
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Running IGP 3 PHY init script\n"
argument_list|)
expr_stmt|;
comment|/* PHY init IGP 3 */
comment|/* Enable rise/fall, 10-mode work in class-A */
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
literal|0x2F5B
argument_list|,
literal|0x9018
argument_list|)
expr_stmt|;
comment|/* Remove all caps from Replica path filter */
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
literal|0x2F52
argument_list|,
literal|0x0000
argument_list|)
expr_stmt|;
comment|/* Bias trimming for ADC, AFE and Driver (Default) */
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
literal|0x2FB1
argument_list|,
literal|0x8B24
argument_list|)
expr_stmt|;
comment|/* Increase Hybrid poly bias */
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
literal|0x2FB2
argument_list|,
literal|0xF8F0
argument_list|)
expr_stmt|;
comment|/* Add 4% to TX amplitude in Giga mode */
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
literal|0x2010
argument_list|,
literal|0x10B0
argument_list|)
expr_stmt|;
comment|/* Disable trimming (TTT) */
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
literal|0x2011
argument_list|,
literal|0x0000
argument_list|)
expr_stmt|;
comment|/* Poly DC correction to 94.6% + 2% for all channels */
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
literal|0x20DD
argument_list|,
literal|0x249A
argument_list|)
expr_stmt|;
comment|/* ABS DC correction to 95.9% */
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
literal|0x20DE
argument_list|,
literal|0x00D3
argument_list|)
expr_stmt|;
comment|/* BG temp curve trim */
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
literal|0x28B4
argument_list|,
literal|0x04CE
argument_list|)
expr_stmt|;
comment|/* Increasing ADC OPAMP stage 1 currents to max */
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
literal|0x2F70
argument_list|,
literal|0x29E4
argument_list|)
expr_stmt|;
comment|/* Force 1000 ( required for enabling PHY regs configuration) */
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
literal|0x0000
argument_list|,
literal|0x0140
argument_list|)
expr_stmt|;
comment|/* Set upd_freq to 6 */
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
literal|0x1F30
argument_list|,
literal|0x1606
argument_list|)
expr_stmt|;
comment|/* Disable NPDFE */
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
literal|0x1F31
argument_list|,
literal|0xB814
argument_list|)
expr_stmt|;
comment|/* Disable adaptive fixed FFE (Default) */
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
literal|0x1F35
argument_list|,
literal|0x002A
argument_list|)
expr_stmt|;
comment|/* Enable FFE hysteresis */
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
literal|0x1F3E
argument_list|,
literal|0x0067
argument_list|)
expr_stmt|;
comment|/* Fixed FFE for short cable lengths */
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
literal|0x1F54
argument_list|,
literal|0x0065
argument_list|)
expr_stmt|;
comment|/* Fixed FFE for medium cable lengths */
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
literal|0x1F55
argument_list|,
literal|0x002A
argument_list|)
expr_stmt|;
comment|/* Fixed FFE for long cable lengths */
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
literal|0x1F56
argument_list|,
literal|0x002A
argument_list|)
expr_stmt|;
comment|/* Enable Adaptive Clip Threshold */
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
literal|0x1F72
argument_list|,
literal|0x3FB0
argument_list|)
expr_stmt|;
comment|/* AHT reset limit to 1 */
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
literal|0x1F76
argument_list|,
literal|0xC0FF
argument_list|)
expr_stmt|;
comment|/* Set AHT master delay to 127 msec */
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
literal|0x1F77
argument_list|,
literal|0x1DEC
argument_list|)
expr_stmt|;
comment|/* Set scan bits for AHT */
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
literal|0x1F78
argument_list|,
literal|0xF9EF
argument_list|)
expr_stmt|;
comment|/* Set AHT Preset bits */
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
literal|0x1F79
argument_list|,
literal|0x0210
argument_list|)
expr_stmt|;
comment|/* Change integ_factor of channel A to 3 */
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
literal|0x1895
argument_list|,
literal|0x0003
argument_list|)
expr_stmt|;
comment|/* Change prop_factor of channels BCD to 8 */
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
literal|0x1796
argument_list|,
literal|0x0008
argument_list|)
expr_stmt|;
comment|/* Change cg_icount + enable integbp for channels BCD */
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
literal|0x1798
argument_list|,
literal|0xD008
argument_list|)
expr_stmt|;
comment|/* Change cg_icount + enable integbp + change prop_factor_master 	 * to 8 for channel A 	 */
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
literal|0x1898
argument_list|,
literal|0xD918
argument_list|)
expr_stmt|;
comment|/* Disable AHT in Slave mode on channel A */
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
literal|0x187A
argument_list|,
literal|0x0800
argument_list|)
expr_stmt|;
comment|/* Enable LPLU and disable AN to 1000 in non-D0a states, 	 * Enable SPD+B2B 	 */
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
literal|0x0019
argument_list|,
literal|0x008D
argument_list|)
expr_stmt|;
comment|/* Enable restart AN on an1000_dis change */
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
literal|0x001B
argument_list|,
literal|0x2080
argument_list|)
expr_stmt|;
comment|/* Enable wh_fifo read clock in 10/100 modes */
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
literal|0x0014
argument_list|,
literal|0x0045
argument_list|)
expr_stmt|;
comment|/* Restart AN, Speed selection is 1000 */
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
literal|0x0000
argument_list|,
literal|0x1340
argument_list|)
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

end_unit

