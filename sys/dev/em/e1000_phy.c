begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************************    Copyright (c) 2001-2008, Intel Corporation    All rights reserved.      Redistribution and use in source and binary forms, with or without    modification, are permitted provided that the following conditions are met:       1. Redistributions of source code must retain the above copyright notice,        this list of conditions and the following disclaimer.       2. Redistributions in binary form must reproduce the above copyright        notice, this list of conditions and the following disclaimer in the        documentation and/or other materials provided with the distribution.       3. Neither the name of the Intel Corporation nor the names of its        contributors may be used to endorse or promote products derived from        this software without specific prior written permission.      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE    ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR    CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF    SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN    CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)    ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE   POSSIBILITY OF SUCH DAMAGE.  ******************************************************************************/
end_comment

begin_comment
comment|/*$FreeBSD$*/
end_comment

begin_include
include|#
directive|include
file|"e1000_api.h"
end_include

begin_include
include|#
directive|include
file|"e1000_phy.h"
end_include

begin_function_decl
specifier|static
name|u32
name|e1000_get_phy_addr_for_bm_page
parameter_list|(
name|u32
name|page
parameter_list|,
name|u32
name|reg
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Cable length tables */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|u16
name|e1000_m88_cable_length_table
index|[]
init|=
block|{
literal|0
block|,
literal|50
block|,
literal|80
block|,
literal|110
block|,
literal|140
block|,
literal|140
block|,
name|E1000_CABLE_LENGTH_UNDEFINED
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|M88E1000_CABLE_LENGTH_TABLE_SIZE
define|\
value|(sizeof(e1000_m88_cable_length_table) / \                  sizeof(e1000_m88_cable_length_table[0]))
end_define

begin_decl_stmt
specifier|static
specifier|const
name|u16
name|e1000_igp_2_cable_length_table
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|3
block|,
literal|5
block|,
literal|8
block|,
literal|11
block|,
literal|13
block|,
literal|16
block|,
literal|18
block|,
literal|21
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|3
block|,
literal|6
block|,
literal|10
block|,
literal|13
block|,
literal|16
block|,
literal|19
block|,
literal|23
block|,
literal|26
block|,
literal|29
block|,
literal|32
block|,
literal|35
block|,
literal|38
block|,
literal|41
block|,
literal|6
block|,
literal|10
block|,
literal|14
block|,
literal|18
block|,
literal|22
block|,
literal|26
block|,
literal|30
block|,
literal|33
block|,
literal|37
block|,
literal|41
block|,
literal|44
block|,
literal|48
block|,
literal|51
block|,
literal|54
block|,
literal|58
block|,
literal|61
block|,
literal|21
block|,
literal|26
block|,
literal|31
block|,
literal|35
block|,
literal|40
block|,
literal|44
block|,
literal|49
block|,
literal|53
block|,
literal|57
block|,
literal|61
block|,
literal|65
block|,
literal|68
block|,
literal|72
block|,
literal|75
block|,
literal|79
block|,
literal|82
block|,
literal|40
block|,
literal|45
block|,
literal|51
block|,
literal|56
block|,
literal|61
block|,
literal|66
block|,
literal|70
block|,
literal|75
block|,
literal|79
block|,
literal|83
block|,
literal|87
block|,
literal|91
block|,
literal|94
block|,
literal|98
block|,
literal|101
block|,
literal|104
block|,
literal|60
block|,
literal|66
block|,
literal|72
block|,
literal|77
block|,
literal|82
block|,
literal|87
block|,
literal|92
block|,
literal|96
block|,
literal|100
block|,
literal|104
block|,
literal|108
block|,
literal|111
block|,
literal|114
block|,
literal|117
block|,
literal|119
block|,
literal|121
block|,
literal|83
block|,
literal|89
block|,
literal|95
block|,
literal|100
block|,
literal|105
block|,
literal|109
block|,
literal|113
block|,
literal|116
block|,
literal|119
block|,
literal|122
block|,
literal|124
block|,
literal|104
block|,
literal|109
block|,
literal|114
block|,
literal|118
block|,
literal|121
block|,
literal|124
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|IGP02E1000_CABLE_LENGTH_TABLE_SIZE
define|\
value|(sizeof(e1000_igp_2_cable_length_table) / \                  sizeof(e1000_igp_2_cable_length_table[0]))
end_define

begin_comment
comment|/**  *  e1000_init_phy_ops_generic - Initialize PHY function pointers  *  @hw: pointer to the HW structure  *  *  Setups up the function pointers to no-op functions  **/
end_comment

begin_function
name|void
name|e1000_init_phy_ops_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_init_phy_ops_generic"
argument_list|)
expr_stmt|;
comment|/* Initialize function pointers */
name|phy
operator|->
name|ops
operator|.
name|init_params
operator|=
name|e1000_null_ops_generic
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|acquire
operator|=
name|e1000_null_ops_generic
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|check_polarity
operator|=
name|e1000_null_ops_generic
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|check_reset_block
operator|=
name|e1000_null_ops_generic
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|commit
operator|=
name|e1000_null_ops_generic
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|force_speed_duplex
operator|=
name|e1000_null_ops_generic
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|get_cfg_done
operator|=
name|e1000_null_ops_generic
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|get_cable_length
operator|=
name|e1000_null_ops_generic
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|get_info
operator|=
name|e1000_null_ops_generic
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|read_reg
operator|=
name|e1000_null_read_reg
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|release
operator|=
name|e1000_null_phy_generic
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|reset
operator|=
name|e1000_null_ops_generic
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|set_d0_lplu_state
operator|=
name|e1000_null_lplu_state
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|set_d3_lplu_state
operator|=
name|e1000_null_lplu_state
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|write_reg
operator|=
name|e1000_null_write_reg
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|power_up
operator|=
name|e1000_null_phy_generic
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|power_down
operator|=
name|e1000_null_phy_generic
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  e1000_null_read_reg - No-op function, return 0  *  @hw: pointer to the HW structure  **/
end_comment

begin_function
name|s32
name|e1000_null_read_reg
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"e1000_null_read_reg"
argument_list|)
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_null_phy_generic - No-op function, return void  *  @hw: pointer to the HW structure  **/
end_comment

begin_function
name|void
name|e1000_null_phy_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"e1000_null_phy_generic"
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**  *  e1000_null_lplu_state - No-op function, return 0  *  @hw: pointer to the HW structure  **/
end_comment

begin_function
name|s32
name|e1000_null_lplu_state
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|bool
name|active
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"e1000_null_lplu_state"
argument_list|)
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_null_write_reg - No-op function, return 0  *  @hw: pointer to the HW structure  **/
end_comment

begin_function
name|s32
name|e1000_null_write_reg
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u16
name|data
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"e1000_null_write_reg"
argument_list|)
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_check_reset_block_generic - Check if PHY reset is blocked  *  @hw: pointer to the HW structure  *  *  Read the PHY management control register and check whether a PHY reset  *  is blocked.  If a reset is not blocked return E1000_SUCCESS, otherwise  *  return E1000_BLK_PHY_RESET (12).  **/
end_comment

begin_function
name|s32
name|e1000_check_reset_block_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|manc
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_check_reset_block"
argument_list|)
expr_stmt|;
name|manc
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_MANC
argument_list|)
expr_stmt|;
return|return
operator|(
name|manc
operator|&
name|E1000_MANC_BLK_PHY_RST_ON_IDE
operator|)
condition|?
name|E1000_BLK_PHY_RESET
else|:
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_get_phy_id - Retrieve the PHY ID and revision  *  @hw: pointer to the HW structure  *  *  Reads the PHY registers and stores the PHY ID and possibly the PHY  *  revision in the hardware structure.  **/
end_comment

begin_function
name|s32
name|e1000_get_phy_id
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|u16
name|phy_id
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_get_phy_id"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|phy
operator|->
name|ops
operator|.
name|read_reg
operator|)
condition|)
goto|goto
name|out
goto|;
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|PHY_ID1
argument_list|,
operator|&
name|phy_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|phy
operator|->
name|id
operator|=
call|(
name|u32
call|)
argument_list|(
name|phy_id
operator|<<
literal|16
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|20
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|PHY_ID2
argument_list|,
operator|&
name|phy_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|phy
operator|->
name|id
operator||=
call|(
name|u32
call|)
argument_list|(
name|phy_id
operator|&
name|PHY_REVISION_MASK
argument_list|)
expr_stmt|;
name|phy
operator|->
name|revision
operator|=
call|(
name|u32
call|)
argument_list|(
name|phy_id
operator|&
operator|~
name|PHY_REVISION_MASK
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_phy_reset_dsp_generic - Reset PHY DSP  *  @hw: pointer to the HW structure  *  *  Reset the digital signal processor.  **/
end_comment

begin_function
name|s32
name|e1000_phy_reset_dsp_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_phy_reset_dsp_generic"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
operator|)
condition|)
goto|goto
name|out
goto|;
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_GEN_CONTROL
argument_list|,
literal|0xC1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_GEN_CONTROL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_read_phy_reg_mdic - Read MDI control register  *  @hw: pointer to the HW structure  *  @offset: register offset to be read  *  @data: pointer to the read data  *  *  Reads the MDI control register in the PHY at offset and stores the  *  information read to data.  **/
end_comment

begin_function
name|s32
name|e1000_read_phy_reg_mdic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|e1000_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|u32
name|i
decl_stmt|,
name|mdic
init|=
literal|0
decl_stmt|;
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_read_phy_reg_mdic"
argument_list|)
expr_stmt|;
comment|/* 	 * Set up Op-code, Phy Address, and register offset in the MDI 	 * Control register.  The MAC will take care of interfacing with the 	 * PHY to retrieve the desired data. 	 */
name|mdic
operator|=
operator|(
operator|(
name|offset
operator|<<
name|E1000_MDIC_REG_SHIFT
operator|)
operator||
operator|(
name|phy
operator|->
name|addr
operator|<<
name|E1000_MDIC_PHY_SHIFT
operator|)
operator||
operator|(
name|E1000_MDIC_OP_READ
operator|)
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_MDIC
argument_list|,
name|mdic
argument_list|)
expr_stmt|;
comment|/* 	 * Poll the ready bit to see if the MDI read completed 	 * Increasing the time out as testing showed failures with 	 * the lower time out 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|E1000_GEN_POLL_TIMEOUT
operator|*
literal|3
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|usec_delay
argument_list|(
literal|50
argument_list|)
expr_stmt|;
name|mdic
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_MDIC
argument_list|)
expr_stmt|;
if|if
condition|(
name|mdic
operator|&
name|E1000_MDIC_READY
condition|)
break|break;
block|}
if|if
condition|(
operator|!
operator|(
name|mdic
operator|&
name|E1000_MDIC_READY
operator|)
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"MDI Read did not complete\n"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
operator|-
name|E1000_ERR_PHY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|mdic
operator|&
name|E1000_MDIC_ERROR
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"MDI Error\n"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
operator|-
name|E1000_ERR_PHY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
operator|*
name|data
operator|=
operator|(
name|u16
operator|)
name|mdic
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_write_phy_reg_mdic - Write MDI control register  *  @hw: pointer to the HW structure  *  @offset: register offset to write to  *  @data: data to write to register at offset  *  *  Writes data to MDI control register in the PHY at offset.  **/
end_comment

begin_function
name|s32
name|e1000_write_phy_reg_mdic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u16
name|data
parameter_list|)
block|{
name|struct
name|e1000_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|u32
name|i
decl_stmt|,
name|mdic
init|=
literal|0
decl_stmt|;
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_write_phy_reg_mdic"
argument_list|)
expr_stmt|;
comment|/* 	 * Set up Op-code, Phy Address, and register offset in the MDI 	 * Control register.  The MAC will take care of interfacing with the 	 * PHY to retrieve the desired data. 	 */
name|mdic
operator|=
operator|(
operator|(
operator|(
name|u32
operator|)
name|data
operator|)
operator||
operator|(
name|offset
operator|<<
name|E1000_MDIC_REG_SHIFT
operator|)
operator||
operator|(
name|phy
operator|->
name|addr
operator|<<
name|E1000_MDIC_PHY_SHIFT
operator|)
operator||
operator|(
name|E1000_MDIC_OP_WRITE
operator|)
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_MDIC
argument_list|,
name|mdic
argument_list|)
expr_stmt|;
comment|/* 	 * Poll the ready bit to see if the MDI read completed 	 * Increasing the time out as testing showed failures with 	 * the lower time out 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|E1000_GEN_POLL_TIMEOUT
operator|*
literal|3
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|usec_delay
argument_list|(
literal|50
argument_list|)
expr_stmt|;
name|mdic
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_MDIC
argument_list|)
expr_stmt|;
if|if
condition|(
name|mdic
operator|&
name|E1000_MDIC_READY
condition|)
break|break;
block|}
if|if
condition|(
operator|!
operator|(
name|mdic
operator|&
name|E1000_MDIC_READY
operator|)
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"MDI Write did not complete\n"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
operator|-
name|E1000_ERR_PHY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|mdic
operator|&
name|E1000_MDIC_ERROR
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"MDI Error\n"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
operator|-
name|E1000_ERR_PHY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_read_phy_reg_m88 - Read m88 PHY register  *  @hw: pointer to the HW structure  *  @offset: register offset to be read  *  @data: pointer to the read data  *  *  Acquires semaphore, if necessary, then reads the PHY register at offset  *  and storing the retrieved information in data.  Release any acquired  *  semaphores before exiting.  **/
end_comment

begin_function
name|s32
name|e1000_read_phy_reg_m88
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
block|{
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_read_phy_reg_m88"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|acquire
operator|)
condition|)
goto|goto
name|out
goto|;
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|acquire
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|ret_val
operator|=
name|e1000_read_phy_reg_mdic
argument_list|(
name|hw
argument_list|,
name|MAX_PHY_REG_ADDRESS
operator|&
name|offset
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|release
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_write_phy_reg_m88 - Write m88 PHY register  *  @hw: pointer to the HW structure  *  @offset: register offset to write to  *  @data: data to write at register offset  *  *  Acquires semaphore, if necessary, then writes the data to PHY register  *  at the offset.  Release any acquired semaphores before exiting.  **/
end_comment

begin_function
name|s32
name|e1000_write_phy_reg_m88
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u16
name|data
parameter_list|)
block|{
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_write_phy_reg_m88"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|acquire
operator|)
condition|)
goto|goto
name|out
goto|;
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|acquire
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|ret_val
operator|=
name|e1000_write_phy_reg_mdic
argument_list|(
name|hw
argument_list|,
name|MAX_PHY_REG_ADDRESS
operator|&
name|offset
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|release
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_read_phy_reg_igp - Read igp PHY register  *  @hw: pointer to the HW structure  *  @offset: register offset to be read  *  @data: pointer to the read data  *  *  Acquires semaphore, if necessary, then reads the PHY register at offset  *  and storing the retrieved information in data.  Release any acquired  *  semaphores before exiting.  **/
end_comment

begin_function
name|s32
name|e1000_read_phy_reg_igp
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
block|{
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_read_phy_reg_igp"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|acquire
operator|)
condition|)
goto|goto
name|out
goto|;
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|acquire
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|offset
operator|>
name|MAX_PHY_MULTI_PAGE_REG
condition|)
block|{
name|ret_val
operator|=
name|e1000_write_phy_reg_mdic
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PAGE_SELECT
argument_list|,
operator|(
name|u16
operator|)
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|release
argument_list|(
name|hw
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|ret_val
operator|=
name|e1000_read_phy_reg_mdic
argument_list|(
name|hw
argument_list|,
name|MAX_PHY_REG_ADDRESS
operator|&
name|offset
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|release
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_write_phy_reg_igp - Write igp PHY register  *  @hw: pointer to the HW structure  *  @offset: register offset to write to  *  @data: data to write at register offset  *  *  Acquires semaphore, if necessary, then writes the data to PHY register  *  at the offset.  Release any acquired semaphores before exiting.  **/
end_comment

begin_function
name|s32
name|e1000_write_phy_reg_igp
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u16
name|data
parameter_list|)
block|{
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_write_phy_reg_igp"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|acquire
operator|)
condition|)
goto|goto
name|out
goto|;
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|acquire
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|offset
operator|>
name|MAX_PHY_MULTI_PAGE_REG
condition|)
block|{
name|ret_val
operator|=
name|e1000_write_phy_reg_mdic
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PAGE_SELECT
argument_list|,
operator|(
name|u16
operator|)
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|release
argument_list|(
name|hw
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|ret_val
operator|=
name|e1000_write_phy_reg_mdic
argument_list|(
name|hw
argument_list|,
name|MAX_PHY_REG_ADDRESS
operator|&
name|offset
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|release
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_read_kmrn_reg_generic - Read kumeran register  *  @hw: pointer to the HW structure  *  @offset: register offset to be read  *  @data: pointer to the read data  *  *  Acquires semaphore, if necessary.  Then reads the PHY register at offset  *  using the kumeran interface.  The information retrieved is stored in data.  *  Release any acquired semaphores before exiting.  **/
end_comment

begin_function
name|s32
name|e1000_read_kmrn_reg_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
block|{
name|u32
name|kmrnctrlsta
decl_stmt|;
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_read_kmrn_reg_generic"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|acquire
operator|)
condition|)
goto|goto
name|out
goto|;
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|acquire
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|kmrnctrlsta
operator|=
operator|(
operator|(
name|offset
operator|<<
name|E1000_KMRNCTRLSTA_OFFSET_SHIFT
operator|)
operator|&
name|E1000_KMRNCTRLSTA_OFFSET
operator|)
operator||
name|E1000_KMRNCTRLSTA_REN
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_KMRNCTRLSTA
argument_list|,
name|kmrnctrlsta
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|kmrnctrlsta
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_KMRNCTRLSTA
argument_list|)
expr_stmt|;
operator|*
name|data
operator|=
operator|(
name|u16
operator|)
name|kmrnctrlsta
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|release
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_write_kmrn_reg_generic - Write kumeran register  *  @hw: pointer to the HW structure  *  @offset: register offset to write to  *  @data: data to write at register offset  *  *  Acquires semaphore, if necessary.  Then write the data to PHY register  *  at the offset using the kumeran interface.  Release any acquired semaphores  *  before exiting.  **/
end_comment

begin_function
name|s32
name|e1000_write_kmrn_reg_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u16
name|data
parameter_list|)
block|{
name|u32
name|kmrnctrlsta
decl_stmt|;
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_write_kmrn_reg_generic"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|acquire
operator|)
condition|)
goto|goto
name|out
goto|;
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|acquire
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|kmrnctrlsta
operator|=
operator|(
operator|(
name|offset
operator|<<
name|E1000_KMRNCTRLSTA_OFFSET_SHIFT
operator|)
operator|&
name|E1000_KMRNCTRLSTA_OFFSET
operator|)
operator||
name|data
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_KMRNCTRLSTA
argument_list|,
name|kmrnctrlsta
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|release
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_copper_link_setup_m88 - Setup m88 PHY's for copper link  *  @hw: pointer to the HW structure  *  *  Sets up MDI/MDI-X and polarity for m88 PHY's.  If necessary, transmit clock  *  and downshift values are set also.  **/
end_comment

begin_function
name|s32
name|e1000_copper_link_setup_m88
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|u16
name|phy_data
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_copper_link_setup_m88"
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy
operator|->
name|reset_disable
condition|)
block|{
name|ret_val
operator|=
name|E1000_SUCCESS
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Enable CRS on TX. This must be set for half-duplex operation. */
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_SPEC_CTRL
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
comment|/* For newer PHYs this bit is downshift enable */
if|if
condition|(
name|phy
operator|->
name|type
operator|==
name|e1000_phy_m88
condition|)
name|phy_data
operator||=
name|M88E1000_PSCR_ASSERT_CRS_ON_TX
expr_stmt|;
comment|/* 	 * Options: 	 *   MDI/MDI-X = 0 (default) 	 *   0 - Auto for all speeds 	 *   1 - MDI mode 	 *   2 - MDI-X mode 	 *   3 - Auto for 1000Base-T only (MDI-X for 10/100Base-T modes) 	 */
name|phy_data
operator|&=
operator|~
name|M88E1000_PSCR_AUTO_X_MODE
expr_stmt|;
switch|switch
condition|(
name|phy
operator|->
name|mdix
condition|)
block|{
case|case
literal|1
case|:
name|phy_data
operator||=
name|M88E1000_PSCR_MDI_MANUAL_MODE
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|phy_data
operator||=
name|M88E1000_PSCR_MDIX_MANUAL_MODE
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|phy_data
operator||=
name|M88E1000_PSCR_AUTO_X_1000T
expr_stmt|;
break|break;
case|case
literal|0
case|:
default|default:
name|phy_data
operator||=
name|M88E1000_PSCR_AUTO_X_MODE
expr_stmt|;
break|break;
block|}
comment|/* 	 * Options: 	 *   disable_polarity_correction = 0 (default) 	 *       Automatic Correction for Reversed Cable Polarity 	 *   0 - Disabled 	 *   1 - Enabled 	 */
name|phy_data
operator|&=
operator|~
name|M88E1000_PSCR_POLARITY_REVERSAL
expr_stmt|;
if|if
condition|(
name|phy
operator|->
name|disable_polarity_correction
operator|==
literal|1
condition|)
name|phy_data
operator||=
name|M88E1000_PSCR_POLARITY_REVERSAL
expr_stmt|;
comment|/* Enable downshift on BM (disabled by default) */
if|if
condition|(
name|phy
operator|->
name|type
operator|==
name|e1000_phy_bm
condition|)
name|phy_data
operator||=
name|BME1000_PSCR_ENABLE_DOWNSHIFT
expr_stmt|;
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_SPEC_CTRL
argument_list|,
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|(
name|phy
operator|->
name|type
operator|==
name|e1000_phy_m88
operator|)
operator|&&
operator|(
name|phy
operator|->
name|revision
operator|<
name|E1000_REVISION_4
operator|)
operator|&&
operator|(
name|phy
operator|->
name|id
operator|!=
name|BME1000_E_PHY_ID_R2
operator|)
condition|)
block|{
comment|/* 		 * Force TX_CLK in the Extended PHY Specific Control Register 		 * to 25MHz clock. 		 */
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_EXT_PHY_SPEC_CTRL
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|phy_data
operator||=
name|M88E1000_EPSCR_TX_CLK_25
expr_stmt|;
if|if
condition|(
operator|(
name|phy
operator|->
name|revision
operator|==
name|E1000_REVISION_2
operator|)
operator|&&
operator|(
name|phy
operator|->
name|id
operator|==
name|M88E1111_I_PHY_ID
operator|)
condition|)
block|{
comment|/* 82573L PHY - set the downshift counter to 5x. */
name|phy_data
operator|&=
operator|~
name|M88EC018_EPSCR_DOWNSHIFT_COUNTER_MASK
expr_stmt|;
name|phy_data
operator||=
name|M88EC018_EPSCR_DOWNSHIFT_COUNTER_5X
expr_stmt|;
block|}
else|else
block|{
comment|/* Configure Master and Slave downshift values */
name|phy_data
operator|&=
operator|~
operator|(
name|M88E1000_EPSCR_MASTER_DOWNSHIFT_MASK
operator||
name|M88E1000_EPSCR_SLAVE_DOWNSHIFT_MASK
operator|)
expr_stmt|;
name|phy_data
operator||=
operator|(
name|M88E1000_EPSCR_MASTER_DOWNSHIFT_1X
operator||
name|M88E1000_EPSCR_SLAVE_DOWNSHIFT_1X
operator|)
expr_stmt|;
block|}
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_EXT_PHY_SPEC_CTRL
argument_list|,
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
block|}
comment|/* Commit the changes. */
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|commit
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Error committing the PHY changes\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_copper_link_setup_igp - Setup igp PHY's for copper link  *  @hw: pointer to the HW structure  *  *  Sets up LPLU, MDI/MDI-X, polarity, Smartspeed and Master/Slave config for  *  igp PHY's.  **/
end_comment

begin_function
name|s32
name|e1000_copper_link_setup_igp
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|u16
name|data
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_copper_link_setup_igp"
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy
operator|->
name|reset_disable
condition|)
block|{
name|ret_val
operator|=
name|E1000_SUCCESS
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ret_val
operator|=
name|e1000_phy_hw_reset
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Error resetting the PHY.\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * Wait 100ms for MAC to configure PHY from NVM settings, to avoid 	 * timeout issues when LFS is enabled. 	 */
name|msec_delay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
comment|/* 	 * The NVM settings will configure LPLU in D3 for 	 * non-IGP1 PHYs. 	 */
if|if
condition|(
name|phy
operator|->
name|type
operator|==
name|e1000_phy_igp
condition|)
block|{
comment|/* disable lplu d3 during driver init */
name|ret_val
operator|=
name|e1000_set_d3_lplu_state
argument_list|(
name|hw
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Error Disabling LPLU D3\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
comment|/* disable lplu d0 during driver init */
name|ret_val
operator|=
name|e1000_set_d0_lplu_state
argument_list|(
name|hw
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Error Disabling LPLU D0\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Configure mdi-mdix settings */
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_CTRL
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|data
operator|&=
operator|~
name|IGP01E1000_PSCR_AUTO_MDIX
expr_stmt|;
switch|switch
condition|(
name|phy
operator|->
name|mdix
condition|)
block|{
case|case
literal|1
case|:
name|data
operator|&=
operator|~
name|IGP01E1000_PSCR_FORCE_MDI_MDIX
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|data
operator||=
name|IGP01E1000_PSCR_FORCE_MDI_MDIX
expr_stmt|;
break|break;
case|case
literal|0
case|:
default|default:
name|data
operator||=
name|IGP01E1000_PSCR_AUTO_MDIX
expr_stmt|;
break|break;
block|}
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_CTRL
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
comment|/* set auto-master slave resolution settings */
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|autoneg
condition|)
block|{
comment|/* 		 * when autonegotiation advertisement is only 1000Mbps then we 		 * should disable SmartSpeed and enable Auto MasterSlave 		 * resolution as hardware default. 		 */
if|if
condition|(
name|phy
operator|->
name|autoneg_advertised
operator|==
name|ADVERTISE_1000_FULL
condition|)
block|{
comment|/* Disable SmartSpeed */
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_CONFIG
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|data
operator|&=
operator|~
name|IGP01E1000_PSCFR_SMART_SPEED
expr_stmt|;
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_CONFIG
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
comment|/* Set auto Master/Slave resolution process */
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|PHY_1000T_CTRL
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|data
operator|&=
operator|~
name|CR_1000T_MS_ENABLE
expr_stmt|;
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|PHY_1000T_CTRL
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
block|}
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|PHY_1000T_CTRL
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
comment|/* load defaults for future use */
name|phy
operator|->
name|original_ms_type
operator|=
operator|(
name|data
operator|&
name|CR_1000T_MS_ENABLE
operator|)
condition|?
operator|(
operator|(
name|data
operator|&
name|CR_1000T_MS_VALUE
operator|)
condition|?
name|e1000_ms_force_master
else|:
name|e1000_ms_force_slave
operator|)
else|:
name|e1000_ms_auto
expr_stmt|;
switch|switch
condition|(
name|phy
operator|->
name|ms_type
condition|)
block|{
case|case
name|e1000_ms_force_master
case|:
name|data
operator||=
operator|(
name|CR_1000T_MS_ENABLE
operator||
name|CR_1000T_MS_VALUE
operator|)
expr_stmt|;
break|break;
case|case
name|e1000_ms_force_slave
case|:
name|data
operator||=
name|CR_1000T_MS_ENABLE
expr_stmt|;
name|data
operator|&=
operator|~
operator|(
name|CR_1000T_MS_VALUE
operator|)
expr_stmt|;
break|break;
case|case
name|e1000_ms_auto
case|:
name|data
operator|&=
operator|~
name|CR_1000T_MS_ENABLE
expr_stmt|;
default|default:
break|break;
block|}
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|PHY_1000T_CTRL
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
block|}
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_copper_link_autoneg - Setup/Enable autoneg for copper link  *  @hw: pointer to the HW structure  *  *  Performs initial bounds checking on autoneg advertisement parameter, then  *  configure to advertise the full capability.  Setup the PHY to autoneg  *  and restart the negotiation process between the link partner.  If  *  autoneg_wait_to_complete, then wait for autoneg to complete before exiting.  **/
end_comment

begin_function
name|s32
name|e1000_copper_link_autoneg
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|u16
name|phy_ctrl
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_copper_link_autoneg"
argument_list|)
expr_stmt|;
comment|/* 	 * Perform some bounds checking on the autoneg advertisement 	 * parameter. 	 */
name|phy
operator|->
name|autoneg_advertised
operator|&=
name|phy
operator|->
name|autoneg_mask
expr_stmt|;
comment|/* 	 * If autoneg_advertised is zero, we assume it was not defaulted 	 * by the calling code so we set to advertise full capability. 	 */
if|if
condition|(
name|phy
operator|->
name|autoneg_advertised
operator|==
literal|0
condition|)
name|phy
operator|->
name|autoneg_advertised
operator|=
name|phy
operator|->
name|autoneg_mask
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Reconfiguring auto-neg advertisement params\n"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_phy_setup_autoneg
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Error Setting up Auto-Negotiation\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|DEBUGOUT
argument_list|(
literal|"Restarting Auto-Neg\n"
argument_list|)
expr_stmt|;
comment|/* 	 * Restart auto-negotiation by setting the Auto Neg Enable bit and 	 * the Auto Neg Restart bit in the PHY control register. 	 */
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|PHY_CONTROL
argument_list|,
operator|&
name|phy_ctrl
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|phy_ctrl
operator||=
operator|(
name|MII_CR_AUTO_NEG_EN
operator||
name|MII_CR_RESTART_AUTO_NEG
operator|)
expr_stmt|;
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|PHY_CONTROL
argument_list|,
name|phy_ctrl
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
comment|/* 	 * Does the user want to wait for Auto-Neg to complete here, or 	 * check at a later time (for example, callback routine). 	 */
if|if
condition|(
name|phy
operator|->
name|autoneg_wait_to_complete
condition|)
block|{
name|ret_val
operator|=
name|e1000_wait_autoneg
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Error while waiting for "
literal|"autoneg to complete\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|hw
operator|->
name|mac
operator|.
name|get_link_status
operator|=
name|TRUE
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_phy_setup_autoneg - Configure PHY for auto-negotiation  *  @hw: pointer to the HW structure  *  *  Reads the MII auto-neg advertisement register and/or the 1000T control  *  register and if the PHY is already setup for auto-negotiation, then  *  return successful.  Otherwise, setup advertisement and flow control to  *  the appropriate values for the wanted auto-negotiation.  **/
end_comment

begin_function
name|s32
name|e1000_phy_setup_autoneg
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|u16
name|mii_autoneg_adv_reg
decl_stmt|;
name|u16
name|mii_1000t_ctrl_reg
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_phy_setup_autoneg"
argument_list|)
expr_stmt|;
name|phy
operator|->
name|autoneg_advertised
operator|&=
name|phy
operator|->
name|autoneg_mask
expr_stmt|;
comment|/* Read the MII Auto-Neg Advertisement Register (Address 4). */
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|PHY_AUTONEG_ADV
argument_list|,
operator|&
name|mii_autoneg_adv_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|phy
operator|->
name|autoneg_mask
operator|&
name|ADVERTISE_1000_FULL
condition|)
block|{
comment|/* Read the MII 1000Base-T Control Register (Address 9). */
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|PHY_1000T_CTRL
argument_list|,
operator|&
name|mii_1000t_ctrl_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
block|}
comment|/* 	 * Need to parse both autoneg_advertised and fc and set up 	 * the appropriate PHY registers.  First we will parse for 	 * autoneg_advertised software override.  Since we can advertise 	 * a plethora of combinations, we need to check each bit 	 * individually. 	 */
comment|/* 	 * First we clear all the 10/100 mb speed bits in the Auto-Neg 	 * Advertisement Register (Address 4) and the 1000 mb speed bits in 	 * the  1000Base-T Control Register (Address 9). 	 */
name|mii_autoneg_adv_reg
operator|&=
operator|~
operator|(
name|NWAY_AR_100TX_FD_CAPS
operator||
name|NWAY_AR_100TX_HD_CAPS
operator||
name|NWAY_AR_10T_FD_CAPS
operator||
name|NWAY_AR_10T_HD_CAPS
operator|)
expr_stmt|;
name|mii_1000t_ctrl_reg
operator|&=
operator|~
operator|(
name|CR_1000T_HD_CAPS
operator||
name|CR_1000T_FD_CAPS
operator|)
expr_stmt|;
name|DEBUGOUT1
argument_list|(
literal|"autoneg_advertised %x\n"
argument_list|,
name|phy
operator|->
name|autoneg_advertised
argument_list|)
expr_stmt|;
comment|/* Do we want to advertise 10 Mb Half Duplex? */
if|if
condition|(
name|phy
operator|->
name|autoneg_advertised
operator|&
name|ADVERTISE_10_HALF
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Advertise 10mb Half duplex\n"
argument_list|)
expr_stmt|;
name|mii_autoneg_adv_reg
operator||=
name|NWAY_AR_10T_HD_CAPS
expr_stmt|;
block|}
comment|/* Do we want to advertise 10 Mb Full Duplex? */
if|if
condition|(
name|phy
operator|->
name|autoneg_advertised
operator|&
name|ADVERTISE_10_FULL
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Advertise 10mb Full duplex\n"
argument_list|)
expr_stmt|;
name|mii_autoneg_adv_reg
operator||=
name|NWAY_AR_10T_FD_CAPS
expr_stmt|;
block|}
comment|/* Do we want to advertise 100 Mb Half Duplex? */
if|if
condition|(
name|phy
operator|->
name|autoneg_advertised
operator|&
name|ADVERTISE_100_HALF
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Advertise 100mb Half duplex\n"
argument_list|)
expr_stmt|;
name|mii_autoneg_adv_reg
operator||=
name|NWAY_AR_100TX_HD_CAPS
expr_stmt|;
block|}
comment|/* Do we want to advertise 100 Mb Full Duplex? */
if|if
condition|(
name|phy
operator|->
name|autoneg_advertised
operator|&
name|ADVERTISE_100_FULL
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Advertise 100mb Full duplex\n"
argument_list|)
expr_stmt|;
name|mii_autoneg_adv_reg
operator||=
name|NWAY_AR_100TX_FD_CAPS
expr_stmt|;
block|}
comment|/* We do not allow the Phy to advertise 1000 Mb Half Duplex */
if|if
condition|(
name|phy
operator|->
name|autoneg_advertised
operator|&
name|ADVERTISE_1000_HALF
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Advertise 1000mb Half duplex request denied!\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Do we want to advertise 1000 Mb Full Duplex? */
if|if
condition|(
name|phy
operator|->
name|autoneg_advertised
operator|&
name|ADVERTISE_1000_FULL
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Advertise 1000mb Full duplex\n"
argument_list|)
expr_stmt|;
name|mii_1000t_ctrl_reg
operator||=
name|CR_1000T_FD_CAPS
expr_stmt|;
block|}
comment|/* 	 * Check for a software override of the flow control settings, and 	 * setup the PHY advertisement registers accordingly.  If 	 * auto-negotiation is enabled, then software will have to set the 	 * "PAUSE" bits to the correct value in the Auto-Negotiation 	 * Advertisement Register (PHY_AUTONEG_ADV) and re-start auto- 	 * negotiation. 	 * 	 * The possible values of the "fc" parameter are: 	 *      0:  Flow control is completely disabled 	 *      1:  Rx flow control is enabled (we can receive pause frames 	 *          but not send pause frames). 	 *      2:  Tx flow control is enabled (we can send pause frames 	 *          but we do not support receiving pause frames). 	 *      3:  Both Rx and Tx flow control (symmetric) are enabled. 	 *  other:  No software override.  The flow control configuration 	 *          in the EEPROM is used. 	 */
switch|switch
condition|(
name|hw
operator|->
name|fc
operator|.
name|type
condition|)
block|{
case|case
name|e1000_fc_none
case|:
comment|/* 		 * Flow control (Rx& Tx) is completely disabled by a 		 * software over-ride. 		 */
name|mii_autoneg_adv_reg
operator|&=
operator|~
operator|(
name|NWAY_AR_ASM_DIR
operator||
name|NWAY_AR_PAUSE
operator|)
expr_stmt|;
break|break;
case|case
name|e1000_fc_rx_pause
case|:
comment|/* 		 * Rx Flow control is enabled, and Tx Flow control is 		 * disabled, by a software over-ride. 		 * 		 * Since there really isn't a way to advertise that we are 		 * capable of Rx Pause ONLY, we will advertise that we 		 * support both symmetric and asymmetric Rx PAUSE.  Later 		 * (in e1000_config_fc_after_link_up) we will disable the 		 * hw's ability to send PAUSE frames. 		 */
name|mii_autoneg_adv_reg
operator||=
operator|(
name|NWAY_AR_ASM_DIR
operator||
name|NWAY_AR_PAUSE
operator|)
expr_stmt|;
break|break;
case|case
name|e1000_fc_tx_pause
case|:
comment|/* 		 * Tx Flow control is enabled, and Rx Flow control is 		 * disabled, by a software over-ride. 		 */
name|mii_autoneg_adv_reg
operator||=
name|NWAY_AR_ASM_DIR
expr_stmt|;
name|mii_autoneg_adv_reg
operator|&=
operator|~
name|NWAY_AR_PAUSE
expr_stmt|;
break|break;
case|case
name|e1000_fc_full
case|:
comment|/* 		 * Flow control (both Rx and Tx) is enabled by a software 		 * over-ride. 		 */
name|mii_autoneg_adv_reg
operator||=
operator|(
name|NWAY_AR_ASM_DIR
operator||
name|NWAY_AR_PAUSE
operator|)
expr_stmt|;
break|break;
default|default:
name|DEBUGOUT
argument_list|(
literal|"Flow control param set incorrectly\n"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
operator|-
name|E1000_ERR_CONFIG
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|PHY_AUTONEG_ADV
argument_list|,
name|mii_autoneg_adv_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|DEBUGOUT1
argument_list|(
literal|"Auto-Neg Advertising %x\n"
argument_list|,
name|mii_autoneg_adv_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy
operator|->
name|autoneg_mask
operator|&
name|ADVERTISE_1000_FULL
condition|)
block|{
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|PHY_1000T_CTRL
argument_list|,
name|mii_1000t_ctrl_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
block|}
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_setup_copper_link_generic - Configure copper link settings  *  @hw: pointer to the HW structure  *  *  Calls the appropriate function to configure the link for auto-neg or forced  *  speed and duplex.  Then we check for link, once link is established calls  *  to configure collision distance and flow control are called.  If link is  *  not established, we return -E1000_ERR_PHY (-2).  **/
end_comment

begin_function
name|s32
name|e1000_setup_copper_link_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|ret_val
decl_stmt|;
name|bool
name|link
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_setup_copper_link_generic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|autoneg
condition|)
block|{
comment|/* 		 * Setup autoneg and flow control advertisement and perform 		 * autonegotiation. 		 */
name|ret_val
operator|=
name|e1000_copper_link_autoneg
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
block|}
else|else
block|{
comment|/* 		 * PHY will be set to 10H, 10F, 100H or 100F 		 * depending on user settings. 		 */
name|DEBUGOUT
argument_list|(
literal|"Forcing Speed and Duplex\n"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|force_speed_duplex
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Error Forcing Speed and Duplex\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
comment|/* 	 * Check link status. Wait up to 100 microseconds for link to become 	 * valid. 	 */
name|ret_val
operator|=
name|e1000_phy_has_link_generic
argument_list|(
name|hw
argument_list|,
name|COPPER_LINK_UP_LIMIT
argument_list|,
literal|10
argument_list|,
operator|&
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|link
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Valid link established!!!\n"
argument_list|)
expr_stmt|;
name|e1000_config_collision_dist_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_config_fc_after_link_up_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DEBUGOUT
argument_list|(
literal|"Unable to establish link!!!\n"
argument_list|)
expr_stmt|;
block|}
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_phy_force_speed_duplex_igp - Force speed/duplex for igp PHY  *  @hw: pointer to the HW structure  *  *  Calls the PHY setup function to force speed and duplex.  Clears the  *  auto-crossover to force MDI manually.  Waits for link and returns  *  successful if link up is successful, else -E1000_ERR_PHY (-2).  **/
end_comment

begin_function
name|s32
name|e1000_phy_force_speed_duplex_igp
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|u16
name|phy_data
decl_stmt|;
name|bool
name|link
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_phy_force_speed_duplex_igp"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|PHY_CONTROL
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|e1000_phy_force_speed_duplex_setup
argument_list|(
name|hw
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|PHY_CONTROL
argument_list|,
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
comment|/* 	 * Clear Auto-Crossover to force MDI manually.  IGP requires MDI 	 * forced whenever speed and duplex are forced. 	 */
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_CTRL
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|phy_data
operator|&=
operator|~
name|IGP01E1000_PSCR_AUTO_MDIX
expr_stmt|;
name|phy_data
operator|&=
operator|~
name|IGP01E1000_PSCR_FORCE_MDI_MDIX
expr_stmt|;
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_CTRL
argument_list|,
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|DEBUGOUT1
argument_list|(
literal|"IGP PSCR: %X\n"
argument_list|,
name|phy_data
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy
operator|->
name|autoneg_wait_to_complete
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Waiting for forced speed/duplex link on IGP phy.\n"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_phy_has_link_generic
argument_list|(
name|hw
argument_list|,
name|PHY_FORCE_LIMIT
argument_list|,
literal|100000
argument_list|,
operator|&
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|!
name|link
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Link taking longer than expected.\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Try once more */
name|ret_val
operator|=
name|e1000_phy_has_link_generic
argument_list|(
name|hw
argument_list|,
name|PHY_FORCE_LIMIT
argument_list|,
literal|100000
argument_list|,
operator|&
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
block|}
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_phy_force_speed_duplex_m88 - Force speed/duplex for m88 PHY  *  @hw: pointer to the HW structure  *  *  Calls the PHY setup function to force speed and duplex.  Clears the  *  auto-crossover to force MDI manually.  Resets the PHY to commit the  *  changes.  If time expires while waiting for link up, we reset the DSP.  *  After reset, TX_CLK and CRS on Tx must be set.  Return successful upon  *  successful completion, else return corresponding error code.  **/
end_comment

begin_function
name|s32
name|e1000_phy_force_speed_duplex_m88
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|u16
name|phy_data
decl_stmt|;
name|bool
name|link
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_phy_force_speed_duplex_m88"
argument_list|)
expr_stmt|;
comment|/* 	 * Clear Auto-Crossover to force MDI manually.  M88E1000 requires MDI 	 * forced whenever speed and duplex are forced. 	 */
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_SPEC_CTRL
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|phy_data
operator|&=
operator|~
name|M88E1000_PSCR_AUTO_X_MODE
expr_stmt|;
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_SPEC_CTRL
argument_list|,
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|DEBUGOUT1
argument_list|(
literal|"M88E1000 PSCR: %X\n"
argument_list|,
name|phy_data
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|PHY_CONTROL
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|e1000_phy_force_speed_duplex_setup
argument_list|(
name|hw
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
comment|/* Reset the phy to commit changes. */
name|phy_data
operator||=
name|MII_CR_RESET
expr_stmt|;
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|PHY_CONTROL
argument_list|,
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|usec_delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy
operator|->
name|autoneg_wait_to_complete
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Waiting for forced speed/duplex link on M88 phy.\n"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_phy_has_link_generic
argument_list|(
name|hw
argument_list|,
name|PHY_FORCE_LIMIT
argument_list|,
literal|100000
argument_list|,
operator|&
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|!
name|link
condition|)
block|{
comment|/* 			 * We didn't get link. 			 * Reset the DSP and cross our fingers. 			 */
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_PAGE_SELECT
argument_list|,
literal|0x001d
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|ret_val
operator|=
name|e1000_phy_reset_dsp_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
block|}
comment|/* Try once more */
name|ret_val
operator|=
name|e1000_phy_has_link_generic
argument_list|(
name|hw
argument_list|,
name|PHY_FORCE_LIMIT
argument_list|,
literal|100000
argument_list|,
operator|&
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
block|}
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_EXT_PHY_SPEC_CTRL
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
comment|/* 	 * Resetting the phy means we need to re-force TX_CLK in the 	 * Extended PHY Specific Control Register to 25MHz clock from 	 * the reset value of 2.5MHz. 	 */
name|phy_data
operator||=
name|M88E1000_EPSCR_TX_CLK_25
expr_stmt|;
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_EXT_PHY_SPEC_CTRL
argument_list|,
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
comment|/* 	 * In addition, we must re-enable CRS on Tx for both half and full 	 * duplex. 	 */
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_SPEC_CTRL
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|phy_data
operator||=
name|M88E1000_PSCR_ASSERT_CRS_ON_TX
expr_stmt|;
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_SPEC_CTRL
argument_list|,
name|phy_data
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_phy_force_speed_duplex_setup - Configure forced PHY speed/duplex  *  @hw: pointer to the HW structure  *  @phy_ctrl: pointer to current value of PHY_CONTROL  *  *  Forces speed and duplex on the PHY by doing the following: disable flow  *  control, force speed/duplex on the MAC, disable auto speed detection,  *  disable auto-negotiation, configure duplex, configure speed, configure  *  the collision distance, write configuration to CTRL register.  The  *  caller must write to the PHY_CONTROL register for these settings to  *  take affect.  **/
end_comment

begin_function
name|void
name|e1000_phy_force_speed_duplex_setup
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
modifier|*
name|phy_ctrl
parameter_list|)
block|{
name|struct
name|e1000_mac_info
modifier|*
name|mac
init|=
operator|&
name|hw
operator|->
name|mac
decl_stmt|;
name|u32
name|ctrl
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_phy_force_speed_duplex_setup"
argument_list|)
expr_stmt|;
comment|/* Turn off flow control when forcing speed/duplex */
name|hw
operator|->
name|fc
operator|.
name|type
operator|=
name|e1000_fc_none
expr_stmt|;
comment|/* Force speed/duplex on the mac */
name|ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|)
expr_stmt|;
name|ctrl
operator||=
operator|(
name|E1000_CTRL_FRCSPD
operator||
name|E1000_CTRL_FRCDPX
operator|)
expr_stmt|;
name|ctrl
operator|&=
operator|~
name|E1000_CTRL_SPD_SEL
expr_stmt|;
comment|/* Disable Auto Speed Detection */
name|ctrl
operator|&=
operator|~
name|E1000_CTRL_ASDE
expr_stmt|;
comment|/* Disable autoneg on the phy */
operator|*
name|phy_ctrl
operator|&=
operator|~
name|MII_CR_AUTO_NEG_EN
expr_stmt|;
comment|/* Forcing Full or Half Duplex? */
if|if
condition|(
name|mac
operator|->
name|forced_speed_duplex
operator|&
name|E1000_ALL_HALF_DUPLEX
condition|)
block|{
name|ctrl
operator|&=
operator|~
name|E1000_CTRL_FD
expr_stmt|;
operator|*
name|phy_ctrl
operator|&=
operator|~
name|MII_CR_FULL_DUPLEX
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Half Duplex\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ctrl
operator||=
name|E1000_CTRL_FD
expr_stmt|;
operator|*
name|phy_ctrl
operator||=
name|MII_CR_FULL_DUPLEX
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Full Duplex\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Forcing 10mb or 100mb? */
if|if
condition|(
name|mac
operator|->
name|forced_speed_duplex
operator|&
name|E1000_ALL_100_SPEED
condition|)
block|{
name|ctrl
operator||=
name|E1000_CTRL_SPD_100
expr_stmt|;
operator|*
name|phy_ctrl
operator||=
name|MII_CR_SPEED_100
expr_stmt|;
operator|*
name|phy_ctrl
operator|&=
operator|~
operator|(
name|MII_CR_SPEED_1000
operator||
name|MII_CR_SPEED_10
operator|)
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Forcing 100mb\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ctrl
operator|&=
operator|~
operator|(
name|E1000_CTRL_SPD_1000
operator||
name|E1000_CTRL_SPD_100
operator|)
expr_stmt|;
operator|*
name|phy_ctrl
operator||=
name|MII_CR_SPEED_10
expr_stmt|;
operator|*
name|phy_ctrl
operator|&=
operator|~
operator|(
name|MII_CR_SPEED_1000
operator||
name|MII_CR_SPEED_100
operator|)
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Forcing 10mb\n"
argument_list|)
expr_stmt|;
block|}
name|e1000_config_collision_dist_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  e1000_set_d3_lplu_state_generic - Sets low power link up state for D3  *  @hw: pointer to the HW structure  *  @active: boolean used to enable/disable lplu  *  *  Success returns 0, Failure returns 1  *  *  The low power link up (lplu) state is set to the power management level D3  *  and SmartSpeed is disabled when active is TRUE, else clear lplu for D3  *  and enable Smartspeed.  LPLU and Smartspeed are mutually exclusive.  LPLU  *  is used during Dx states where the power conservation is most important.  *  During driver activity, SmartSpeed should be enabled so performance is  *  maintained.  **/
end_comment

begin_function
name|s32
name|e1000_set_d3_lplu_state_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|bool
name|active
parameter_list|)
block|{
name|struct
name|e1000_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|u16
name|data
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_set_d3_lplu_state_generic"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
operator|)
condition|)
goto|goto
name|out
goto|;
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IGP02E1000_PHY_POWER_MGMT
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|!
name|active
condition|)
block|{
name|data
operator|&=
operator|~
name|IGP02E1000_PM_D3_LPLU
expr_stmt|;
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|IGP02E1000_PHY_POWER_MGMT
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
comment|/* 		 * LPLU and SmartSpeed are mutually exclusive.  LPLU is used 		 * during Dx states where the power conservation is most 		 * important.  During driver activity we should enable 		 * SmartSpeed, so performance is maintained. 		 */
if|if
condition|(
name|phy
operator|->
name|smart_speed
operator|==
name|e1000_smart_speed_on
condition|)
block|{
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_CONFIG
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|data
operator||=
name|IGP01E1000_PSCFR_SMART_SPEED
expr_stmt|;
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_CONFIG
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
block|}
elseif|else
if|if
condition|(
name|phy
operator|->
name|smart_speed
operator|==
name|e1000_smart_speed_off
condition|)
block|{
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_CONFIG
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|data
operator|&=
operator|~
name|IGP01E1000_PSCFR_SMART_SPEED
expr_stmt|;
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_CONFIG
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|phy
operator|->
name|autoneg_advertised
operator|==
name|E1000_ALL_SPEED_DUPLEX
operator|)
operator|||
operator|(
name|phy
operator|->
name|autoneg_advertised
operator|==
name|E1000_ALL_NOT_GIG
operator|)
operator|||
operator|(
name|phy
operator|->
name|autoneg_advertised
operator|==
name|E1000_ALL_10_SPEED
operator|)
condition|)
block|{
name|data
operator||=
name|IGP02E1000_PM_D3_LPLU
expr_stmt|;
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|IGP02E1000_PHY_POWER_MGMT
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
comment|/* When LPLU is enabled, we should disable SmartSpeed */
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_CONFIG
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|data
operator|&=
operator|~
name|IGP01E1000_PSCFR_SMART_SPEED
expr_stmt|;
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_CONFIG
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_check_downshift_generic - Checks whether a downshift in speed occurred  *  @hw: pointer to the HW structure  *  *  Success returns 0, Failure returns 1  *  *  A downshift is detected by querying the PHY link health.  **/
end_comment

begin_function
name|s32
name|e1000_check_downshift_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|u16
name|phy_data
decl_stmt|,
name|offset
decl_stmt|,
name|mask
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_check_downshift_generic"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|phy
operator|->
name|type
condition|)
block|{
case|case
name|e1000_phy_m88
case|:
case|case
name|e1000_phy_gg82563
case|:
case|case
name|e1000_phy_bm
case|:
name|offset
operator|=
name|M88E1000_PHY_SPEC_STATUS
expr_stmt|;
name|mask
operator|=
name|M88E1000_PSSR_DOWNSHIFT
expr_stmt|;
break|break;
case|case
name|e1000_phy_igp_2
case|:
case|case
name|e1000_phy_igp
case|:
case|case
name|e1000_phy_igp_3
case|:
name|offset
operator|=
name|IGP01E1000_PHY_LINK_HEALTH
expr_stmt|;
name|mask
operator|=
name|IGP01E1000_PLHR_SS_DOWNGRADE
expr_stmt|;
break|break;
default|default:
comment|/* speed downshift not supported */
name|phy
operator|->
name|speed_downgraded
operator|=
name|FALSE
expr_stmt|;
name|ret_val
operator|=
name|E1000_SUCCESS
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret_val
condition|)
name|phy
operator|->
name|speed_downgraded
operator|=
operator|(
name|phy_data
operator|&
name|mask
operator|)
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_check_polarity_m88 - Checks the polarity.  *  @hw: pointer to the HW structure  *  *  Success returns 0, Failure returns -E1000_ERR_PHY (-2)  *  *  Polarity is determined based on the PHY specific status register.  **/
end_comment

begin_function
name|s32
name|e1000_check_polarity_m88
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|u16
name|data
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_check_polarity_m88"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_SPEC_STATUS
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret_val
condition|)
name|phy
operator|->
name|cable_polarity
operator|=
operator|(
name|data
operator|&
name|M88E1000_PSSR_REV_POLARITY
operator|)
condition|?
name|e1000_rev_polarity_reversed
else|:
name|e1000_rev_polarity_normal
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_check_polarity_igp - Checks the polarity.  *  @hw: pointer to the HW structure  *  *  Success returns 0, Failure returns -E1000_ERR_PHY (-2)  *  *  Polarity is determined based on the PHY port status register, and the  *  current speed (since there is no polarity at 100Mbps).  **/
end_comment

begin_function
name|s32
name|e1000_check_polarity_igp
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|u16
name|data
decl_stmt|,
name|offset
decl_stmt|,
name|mask
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_check_polarity_igp"
argument_list|)
expr_stmt|;
comment|/* 	 * Polarity is determined based on the speed of 	 * our connection. 	 */
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_STATUS
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|(
name|data
operator|&
name|IGP01E1000_PSSR_SPEED_MASK
operator|)
operator|==
name|IGP01E1000_PSSR_SPEED_1000MBPS
condition|)
block|{
name|offset
operator|=
name|IGP01E1000_PHY_PCS_INIT_REG
expr_stmt|;
name|mask
operator|=
name|IGP01E1000_PHY_POLARITY_MASK
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * This really only applies to 10Mbps since 		 * there is no polarity for 100Mbps (always 0). 		 */
name|offset
operator|=
name|IGP01E1000_PHY_PORT_STATUS
expr_stmt|;
name|mask
operator|=
name|IGP01E1000_PSSR_POLARITY_REVERSED
expr_stmt|;
block|}
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret_val
condition|)
name|phy
operator|->
name|cable_polarity
operator|=
operator|(
name|data
operator|&
name|mask
operator|)
condition|?
name|e1000_rev_polarity_reversed
else|:
name|e1000_rev_polarity_normal
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_wait_autoneg_generic - Wait for auto-neg completion  *  @hw: pointer to the HW structure  *  *  Waits for auto-negotiation to complete or for the auto-negotiation time  *  limit to expire, which ever happens first.  **/
end_comment

begin_function
name|s32
name|e1000_wait_autoneg_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|u16
name|i
decl_stmt|,
name|phy_status
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_wait_autoneg_generic"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
operator|)
condition|)
return|return
name|E1000_SUCCESS
return|;
comment|/* Break after autoneg completes or PHY_AUTO_NEG_LIMIT expires. */
for|for
control|(
name|i
operator|=
name|PHY_AUTO_NEG_LIMIT
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|PHY_STATUS
argument_list|,
operator|&
name|phy_status
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
break|break;
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|PHY_STATUS
argument_list|,
operator|&
name|phy_status
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
break|break;
if|if
condition|(
name|phy_status
operator|&
name|MII_SR_AUTONEG_COMPLETE
condition|)
break|break;
name|msec_delay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * PHY_AUTO_NEG_TIME expiration doesn't guarantee auto-negotiation 	 * has completed. 	 */
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_phy_has_link_generic - Polls PHY for link  *  @hw: pointer to the HW structure  *  @iterations: number of times to poll for link  *  @usec_interval: delay between polling attempts  *  @success: pointer to whether polling was successful or not  *  *  Polls the PHY status register for link, 'iterations' number of times.  **/
end_comment

begin_function
name|s32
name|e1000_phy_has_link_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|iterations
parameter_list|,
name|u32
name|usec_interval
parameter_list|,
name|bool
modifier|*
name|success
parameter_list|)
block|{
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|u16
name|i
decl_stmt|,
name|phy_status
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_phy_has_link_generic"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
operator|)
condition|)
return|return
name|E1000_SUCCESS
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|iterations
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		 * Some PHYs require the PHY_STATUS register to be read 		 * twice due to the link bit being sticky.  No harm doing 		 * it across the board. 		 */
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|PHY_STATUS
argument_list|,
operator|&
name|phy_status
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
break|break;
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|PHY_STATUS
argument_list|,
operator|&
name|phy_status
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
break|break;
if|if
condition|(
name|phy_status
operator|&
name|MII_SR_LINK_STATUS
condition|)
break|break;
if|if
condition|(
name|usec_interval
operator|>=
literal|1000
condition|)
name|msec_delay_irq
argument_list|(
name|usec_interval
operator|/
literal|1000
argument_list|)
expr_stmt|;
else|else
name|usec_delay
argument_list|(
name|usec_interval
argument_list|)
expr_stmt|;
block|}
operator|*
name|success
operator|=
operator|(
name|i
operator|<
name|iterations
operator|)
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_get_cable_length_m88 - Determine cable length for m88 PHY  *  @hw: pointer to the HW structure  *  *  Reads the PHY specific status register to retrieve the cable length  *  information.  The cable length is determined by averaging the minimum and  *  maximum values to get the "average" cable length.  The m88 PHY has four  *  possible cable length values, which are:  *	Register Value		Cable Length  *	0< 50 meters  *	1			50 - 80 meters  *	2			80 - 110 meters  *	3			110 - 140 meters  *	4> 140 meters  **/
end_comment

begin_function
name|s32
name|e1000_get_cable_length_m88
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|u16
name|phy_data
decl_stmt|,
name|index
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_get_cable_length_m88"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_SPEC_STATUS
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|index
operator|=
operator|(
name|phy_data
operator|&
name|M88E1000_PSSR_CABLE_LENGTH
operator|)
operator|>>
name|M88E1000_PSSR_CABLE_LENGTH_SHIFT
expr_stmt|;
name|phy
operator|->
name|min_cable_length
operator|=
name|e1000_m88_cable_length_table
index|[
name|index
index|]
expr_stmt|;
name|phy
operator|->
name|max_cable_length
operator|=
name|e1000_m88_cable_length_table
index|[
name|index
operator|+
literal|1
index|]
expr_stmt|;
name|phy
operator|->
name|cable_length
operator|=
operator|(
name|phy
operator|->
name|min_cable_length
operator|+
name|phy
operator|->
name|max_cable_length
operator|)
operator|/
literal|2
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_get_cable_length_igp_2 - Determine cable length for igp2 PHY  *  @hw: pointer to the HW structure  *  *  The automatic gain control (agc) normalizes the amplitude of the  *  received signal, adjusting for the attenuation produced by the  *  cable.  By reading the AGC registers, which represent the  *  combination of coarse and fine gain value, the value can be put  *  into a lookup table to obtain the approximate cable length  *  for each channel.  **/
end_comment

begin_function
name|s32
name|e1000_get_cable_length_igp_2
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|u16
name|phy_data
decl_stmt|,
name|i
decl_stmt|,
name|agc_value
init|=
literal|0
decl_stmt|;
name|u16
name|cur_agc_index
decl_stmt|,
name|max_agc_index
init|=
literal|0
decl_stmt|;
name|u16
name|min_agc_index
init|=
name|IGP02E1000_CABLE_LENGTH_TABLE_SIZE
operator|-
literal|1
decl_stmt|;
name|u16
name|agc_reg_array
index|[
name|IGP02E1000_PHY_CHANNEL_NUM
index|]
init|=
block|{
name|IGP02E1000_PHY_AGC_A
block|,
name|IGP02E1000_PHY_AGC_B
block|,
name|IGP02E1000_PHY_AGC_C
block|,
name|IGP02E1000_PHY_AGC_D
block|}
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_get_cable_length_igp_2"
argument_list|)
expr_stmt|;
comment|/* Read the AGC registers for all channels */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IGP02E1000_PHY_CHANNEL_NUM
condition|;
name|i
operator|++
control|)
block|{
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|agc_reg_array
index|[
name|i
index|]
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
comment|/* 		 * Getting bits 15:9, which represent the combination of 		 * coarse and fine gain values.  The result is a number 		 * that can be put into the lookup table to obtain the 		 * approximate cable length. 		 */
name|cur_agc_index
operator|=
operator|(
name|phy_data
operator|>>
name|IGP02E1000_AGC_LENGTH_SHIFT
operator|)
operator|&
name|IGP02E1000_AGC_LENGTH_MASK
expr_stmt|;
comment|/* Array index bound check. */
if|if
condition|(
operator|(
name|cur_agc_index
operator|>=
name|IGP02E1000_CABLE_LENGTH_TABLE_SIZE
operator|)
operator|||
operator|(
name|cur_agc_index
operator|==
literal|0
operator|)
condition|)
block|{
name|ret_val
operator|=
operator|-
name|E1000_ERR_PHY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Remove min& max AGC values from calculation. */
if|if
condition|(
name|e1000_igp_2_cable_length_table
index|[
name|min_agc_index
index|]
operator|>
name|e1000_igp_2_cable_length_table
index|[
name|cur_agc_index
index|]
condition|)
name|min_agc_index
operator|=
name|cur_agc_index
expr_stmt|;
if|if
condition|(
name|e1000_igp_2_cable_length_table
index|[
name|max_agc_index
index|]
operator|<
name|e1000_igp_2_cable_length_table
index|[
name|cur_agc_index
index|]
condition|)
name|max_agc_index
operator|=
name|cur_agc_index
expr_stmt|;
name|agc_value
operator|+=
name|e1000_igp_2_cable_length_table
index|[
name|cur_agc_index
index|]
expr_stmt|;
block|}
name|agc_value
operator|-=
operator|(
name|e1000_igp_2_cable_length_table
index|[
name|min_agc_index
index|]
operator|+
name|e1000_igp_2_cable_length_table
index|[
name|max_agc_index
index|]
operator|)
expr_stmt|;
name|agc_value
operator|/=
operator|(
name|IGP02E1000_PHY_CHANNEL_NUM
operator|-
literal|2
operator|)
expr_stmt|;
comment|/* Calculate cable length with the error range of +/- 10 meters. */
name|phy
operator|->
name|min_cable_length
operator|=
operator|(
operator|(
name|agc_value
operator|-
name|IGP02E1000_AGC_RANGE
operator|)
operator|>
literal|0
operator|)
condition|?
operator|(
name|agc_value
operator|-
name|IGP02E1000_AGC_RANGE
operator|)
else|:
literal|0
expr_stmt|;
name|phy
operator|->
name|max_cable_length
operator|=
name|agc_value
operator|+
name|IGP02E1000_AGC_RANGE
expr_stmt|;
name|phy
operator|->
name|cable_length
operator|=
operator|(
name|phy
operator|->
name|min_cable_length
operator|+
name|phy
operator|->
name|max_cable_length
operator|)
operator|/
literal|2
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_get_phy_info_m88 - Retrieve PHY information  *  @hw: pointer to the HW structure  *  *  Valid for only copper links.  Read the PHY status register (sticky read)  *  to verify that link is up.  Read the PHY special control register to  *  determine the polarity and 10base-T extended distance.  Read the PHY  *  special status register to determine MDI/MDIx and current speed.  If  *  speed is 1000, then determine cable length, local and remote receiver.  **/
end_comment

begin_function
name|s32
name|e1000_get_phy_info_m88
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|u16
name|phy_data
decl_stmt|;
name|bool
name|link
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_get_phy_info_m88"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|media_type
operator|!=
name|e1000_media_type_copper
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Phy info is only valid for copper media\n"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
operator|-
name|E1000_ERR_CONFIG
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ret_val
operator|=
name|e1000_phy_has_link_generic
argument_list|(
name|hw
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
operator|&
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|!
name|link
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Phy info is only valid if link is up\n"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
operator|-
name|E1000_ERR_CONFIG
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_SPEC_CTRL
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|phy
operator|->
name|polarity_correction
operator|=
operator|(
name|phy_data
operator|&
name|M88E1000_PSCR_POLARITY_REVERSAL
operator|)
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
name|ret_val
operator|=
name|e1000_check_polarity_m88
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_SPEC_STATUS
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|phy
operator|->
name|is_mdix
operator|=
operator|(
name|phy_data
operator|&
name|M88E1000_PSSR_MDIX
operator|)
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
if|if
condition|(
operator|(
name|phy_data
operator|&
name|M88E1000_PSSR_SPEED
operator|)
operator|==
name|M88E1000_PSSR_1000MBS
condition|)
block|{
name|ret_val
operator|=
name|e1000_get_cable_length
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|PHY_1000T_STATUS
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|phy
operator|->
name|local_rx
operator|=
operator|(
name|phy_data
operator|&
name|SR_1000T_LOCAL_RX_STATUS
operator|)
condition|?
name|e1000_1000t_rx_status_ok
else|:
name|e1000_1000t_rx_status_not_ok
expr_stmt|;
name|phy
operator|->
name|remote_rx
operator|=
operator|(
name|phy_data
operator|&
name|SR_1000T_REMOTE_RX_STATUS
operator|)
condition|?
name|e1000_1000t_rx_status_ok
else|:
name|e1000_1000t_rx_status_not_ok
expr_stmt|;
block|}
else|else
block|{
comment|/* Set values to "undefined" */
name|phy
operator|->
name|cable_length
operator|=
name|E1000_CABLE_LENGTH_UNDEFINED
expr_stmt|;
name|phy
operator|->
name|local_rx
operator|=
name|e1000_1000t_rx_status_undefined
expr_stmt|;
name|phy
operator|->
name|remote_rx
operator|=
name|e1000_1000t_rx_status_undefined
expr_stmt|;
block|}
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_get_phy_info_igp - Retrieve igp PHY information  *  @hw: pointer to the HW structure  *  *  Read PHY status to determine if link is up.  If link is up, then  *  set/determine 10base-T extended distance and polarity correction.  Read  *  PHY port status to determine MDI/MDIx and speed.  Based on the speed,  *  determine on the cable length, local and remote receiver.  **/
end_comment

begin_function
name|s32
name|e1000_get_phy_info_igp
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|u16
name|data
decl_stmt|;
name|bool
name|link
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_get_phy_info_igp"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_phy_has_link_generic
argument_list|(
name|hw
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
operator|&
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|!
name|link
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Phy info is only valid if link is up\n"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
operator|-
name|E1000_ERR_CONFIG
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|phy
operator|->
name|polarity_correction
operator|=
name|TRUE
expr_stmt|;
name|ret_val
operator|=
name|e1000_check_polarity_igp
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_STATUS
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|phy
operator|->
name|is_mdix
operator|=
operator|(
name|data
operator|&
name|IGP01E1000_PSSR_MDIX
operator|)
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
if|if
condition|(
operator|(
name|data
operator|&
name|IGP01E1000_PSSR_SPEED_MASK
operator|)
operator|==
name|IGP01E1000_PSSR_SPEED_1000MBPS
condition|)
block|{
name|ret_val
operator|=
name|e1000_get_cable_length
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|PHY_1000T_STATUS
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|phy
operator|->
name|local_rx
operator|=
operator|(
name|data
operator|&
name|SR_1000T_LOCAL_RX_STATUS
operator|)
condition|?
name|e1000_1000t_rx_status_ok
else|:
name|e1000_1000t_rx_status_not_ok
expr_stmt|;
name|phy
operator|->
name|remote_rx
operator|=
operator|(
name|data
operator|&
name|SR_1000T_REMOTE_RX_STATUS
operator|)
condition|?
name|e1000_1000t_rx_status_ok
else|:
name|e1000_1000t_rx_status_not_ok
expr_stmt|;
block|}
else|else
block|{
name|phy
operator|->
name|cable_length
operator|=
name|E1000_CABLE_LENGTH_UNDEFINED
expr_stmt|;
name|phy
operator|->
name|local_rx
operator|=
name|e1000_1000t_rx_status_undefined
expr_stmt|;
name|phy
operator|->
name|remote_rx
operator|=
name|e1000_1000t_rx_status_undefined
expr_stmt|;
block|}
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_phy_sw_reset_generic - PHY software reset  *  @hw: pointer to the HW structure  *  *  Does a software reset of the PHY by reading the PHY control register and  *  setting/write the control register reset bit to the PHY.  **/
end_comment

begin_function
name|s32
name|e1000_phy_sw_reset_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|u16
name|phy_ctrl
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_phy_sw_reset_generic"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
operator|)
condition|)
goto|goto
name|out
goto|;
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|PHY_CONTROL
argument_list|,
operator|&
name|phy_ctrl
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|phy_ctrl
operator||=
name|MII_CR_RESET
expr_stmt|;
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|PHY_CONTROL
argument_list|,
name|phy_ctrl
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|usec_delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_phy_hw_reset_generic - PHY hardware reset  *  @hw: pointer to the HW structure  *  *  Verify the reset block is not blocking us from resetting.  Acquire  *  semaphore (if necessary) and read/set/write the device control reset  *  bit in the PHY.  Wait the appropriate delay time for the device to  *  reset and release the semaphore (if necessary).  **/
end_comment

begin_function
name|s32
name|e1000_phy_hw_reset_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|u32
name|ctrl
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_phy_hw_reset_generic"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|check_reset_block
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|ret_val
operator|=
name|E1000_SUCCESS
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|acquire
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|,
name|ctrl
operator||
name|E1000_CTRL_PHY_RST
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
name|phy
operator|->
name|reset_delay_us
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|150
argument_list|)
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|release
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|get_cfg_done
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_get_cfg_done_generic - Generic configuration done  *  @hw: pointer to the HW structure  *  *  Generic function to wait 10 milli-seconds for configuration to complete  *  and return success.  **/
end_comment

begin_function
name|s32
name|e1000_get_cfg_done_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"e1000_get_cfg_done_generic"
argument_list|)
expr_stmt|;
name|msec_delay_irq
argument_list|(
literal|10
argument_list|)
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_phy_init_script_igp3 - Inits the IGP3 PHY  *  @hw: pointer to the HW structure  *  *  Initializes a Intel Gigabit PHY3 when an EEPROM is not present.  **/
end_comment

begin_function
name|s32
name|e1000_phy_init_script_igp3
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Running IGP 3 PHY init script\n"
argument_list|)
expr_stmt|;
comment|/* PHY init IGP 3 */
comment|/* Enable rise/fall, 10-mode work in class-A */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
literal|0x2F5B
argument_list|,
literal|0x9018
argument_list|)
expr_stmt|;
comment|/* Remove all caps from Replica path filter */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
literal|0x2F52
argument_list|,
literal|0x0000
argument_list|)
expr_stmt|;
comment|/* Bias trimming for ADC, AFE and Driver (Default) */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
literal|0x2FB1
argument_list|,
literal|0x8B24
argument_list|)
expr_stmt|;
comment|/* Increase Hybrid poly bias */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
literal|0x2FB2
argument_list|,
literal|0xF8F0
argument_list|)
expr_stmt|;
comment|/* Add 4% to Tx amplitude in Gig mode */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
literal|0x2010
argument_list|,
literal|0x10B0
argument_list|)
expr_stmt|;
comment|/* Disable trimming (TTT) */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
literal|0x2011
argument_list|,
literal|0x0000
argument_list|)
expr_stmt|;
comment|/* Poly DC correction to 94.6% + 2% for all channels */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
literal|0x20DD
argument_list|,
literal|0x249A
argument_list|)
expr_stmt|;
comment|/* ABS DC correction to 95.9% */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
literal|0x20DE
argument_list|,
literal|0x00D3
argument_list|)
expr_stmt|;
comment|/* BG temp curve trim */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
literal|0x28B4
argument_list|,
literal|0x04CE
argument_list|)
expr_stmt|;
comment|/* Increasing ADC OPAMP stage 1 currents to max */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
literal|0x2F70
argument_list|,
literal|0x29E4
argument_list|)
expr_stmt|;
comment|/* Force 1000 ( required for enabling PHY regs configuration) */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
literal|0x0000
argument_list|,
literal|0x0140
argument_list|)
expr_stmt|;
comment|/* Set upd_freq to 6 */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
literal|0x1F30
argument_list|,
literal|0x1606
argument_list|)
expr_stmt|;
comment|/* Disable NPDFE */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
literal|0x1F31
argument_list|,
literal|0xB814
argument_list|)
expr_stmt|;
comment|/* Disable adaptive fixed FFE (Default) */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
literal|0x1F35
argument_list|,
literal|0x002A
argument_list|)
expr_stmt|;
comment|/* Enable FFE hysteresis */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
literal|0x1F3E
argument_list|,
literal|0x0067
argument_list|)
expr_stmt|;
comment|/* Fixed FFE for short cable lengths */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
literal|0x1F54
argument_list|,
literal|0x0065
argument_list|)
expr_stmt|;
comment|/* Fixed FFE for medium cable lengths */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
literal|0x1F55
argument_list|,
literal|0x002A
argument_list|)
expr_stmt|;
comment|/* Fixed FFE for long cable lengths */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
literal|0x1F56
argument_list|,
literal|0x002A
argument_list|)
expr_stmt|;
comment|/* Enable Adaptive Clip Threshold */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
literal|0x1F72
argument_list|,
literal|0x3FB0
argument_list|)
expr_stmt|;
comment|/* AHT reset limit to 1 */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
literal|0x1F76
argument_list|,
literal|0xC0FF
argument_list|)
expr_stmt|;
comment|/* Set AHT master delay to 127 msec */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
literal|0x1F77
argument_list|,
literal|0x1DEC
argument_list|)
expr_stmt|;
comment|/* Set scan bits for AHT */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
literal|0x1F78
argument_list|,
literal|0xF9EF
argument_list|)
expr_stmt|;
comment|/* Set AHT Preset bits */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
literal|0x1F79
argument_list|,
literal|0x0210
argument_list|)
expr_stmt|;
comment|/* Change integ_factor of channel A to 3 */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
literal|0x1895
argument_list|,
literal|0x0003
argument_list|)
expr_stmt|;
comment|/* Change prop_factor of channels BCD to 8 */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
literal|0x1796
argument_list|,
literal|0x0008
argument_list|)
expr_stmt|;
comment|/* Change cg_icount + enable integbp for channels BCD */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
literal|0x1798
argument_list|,
literal|0xD008
argument_list|)
expr_stmt|;
comment|/* 	 * Change cg_icount + enable integbp + change prop_factor_master 	 * to 8 for channel A 	 */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
literal|0x1898
argument_list|,
literal|0xD918
argument_list|)
expr_stmt|;
comment|/* Disable AHT in Slave mode on channel A */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
literal|0x187A
argument_list|,
literal|0x0800
argument_list|)
expr_stmt|;
comment|/* 	 * Enable LPLU and disable AN to 1000 in non-D0a states, 	 * Enable SPD+B2B 	 */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
literal|0x0019
argument_list|,
literal|0x008D
argument_list|)
expr_stmt|;
comment|/* Enable restart AN on an1000_dis change */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
literal|0x001B
argument_list|,
literal|0x2080
argument_list|)
expr_stmt|;
comment|/* Enable wh_fifo read clock in 10/100 modes */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
literal|0x0014
argument_list|,
literal|0x0045
argument_list|)
expr_stmt|;
comment|/* Restart AN, Speed selection is 1000 */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
literal|0x0000
argument_list|,
literal|0x1340
argument_list|)
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_get_phy_type_from_id - Get PHY type from id  *  @phy_id: phy_id read from the phy  *  *  Returns the phy type from the id.  **/
end_comment

begin_function
name|e1000_phy_type
name|e1000_get_phy_type_from_id
parameter_list|(
name|u32
name|phy_id
parameter_list|)
block|{
name|e1000_phy_type
name|phy_type
init|=
name|e1000_phy_unknown
decl_stmt|;
switch|switch
condition|(
name|phy_id
condition|)
block|{
case|case
name|M88E1000_I_PHY_ID
case|:
case|case
name|M88E1000_E_PHY_ID
case|:
case|case
name|M88E1111_I_PHY_ID
case|:
case|case
name|M88E1011_I_PHY_ID
case|:
name|phy_type
operator|=
name|e1000_phy_m88
expr_stmt|;
break|break;
case|case
name|IGP01E1000_I_PHY_ID
case|:
comment|/* IGP 1& 2 share this */
name|phy_type
operator|=
name|e1000_phy_igp_2
expr_stmt|;
break|break;
case|case
name|GG82563_E_PHY_ID
case|:
name|phy_type
operator|=
name|e1000_phy_gg82563
expr_stmt|;
break|break;
case|case
name|IGP03E1000_E_PHY_ID
case|:
name|phy_type
operator|=
name|e1000_phy_igp_3
expr_stmt|;
break|break;
case|case
name|IFE_E_PHY_ID
case|:
case|case
name|IFE_PLUS_E_PHY_ID
case|:
case|case
name|IFE_C_E_PHY_ID
case|:
name|phy_type
operator|=
name|e1000_phy_ife
expr_stmt|;
break|break;
case|case
name|BME1000_E_PHY_ID
case|:
case|case
name|BME1000_E_PHY_ID_R2
case|:
name|phy_type
operator|=
name|e1000_phy_bm
expr_stmt|;
break|break;
default|default:
name|phy_type
operator|=
name|e1000_phy_unknown
expr_stmt|;
break|break;
block|}
return|return
name|phy_type
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_determine_phy_address - Determines PHY address.  *  @hw: pointer to the HW structure  *  *  This uses a trial and error method to loop through possible PHY  *  addresses. It tests each by reading the PHY ID registers and  *  checking for a match.  **/
end_comment

begin_function
name|s32
name|e1000_determine_phy_address
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|ret_val
init|=
operator|-
name|E1000_ERR_PHY_TYPE
decl_stmt|;
name|u32
name|phy_addr
init|=
literal|0
decl_stmt|;
name|u32
name|i
decl_stmt|;
name|e1000_phy_type
name|phy_type
init|=
name|e1000_phy_unknown
decl_stmt|;
for|for
control|(
name|phy_addr
operator|=
literal|0
init|;
name|phy_addr
operator|<
name|E1000_MAX_PHY_ADDR
condition|;
name|phy_addr
operator|++
control|)
block|{
name|hw
operator|->
name|phy
operator|.
name|addr
operator|=
name|phy_addr
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|e1000_get_phy_id
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|phy_type
operator|=
name|e1000_get_phy_type_from_id
argument_list|(
name|hw
operator|->
name|phy
operator|.
name|id
argument_list|)
expr_stmt|;
comment|/*  		 	 * If phy_type is valid, break - we found our 		 	 * PHY address 		 	 */
if|if
condition|(
name|phy_type
operator|!=
name|e1000_phy_unknown
condition|)
block|{
name|ret_val
operator|=
name|E1000_SUCCESS
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|msec_delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|i
operator|<
literal|10
condition|)
do|;
block|}
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_get_phy_addr_for_bm_page - Retrieve PHY page address  *  @page: page to access  *  *  Returns the phy address for the page requested.  **/
end_comment

begin_function
specifier|static
name|u32
name|e1000_get_phy_addr_for_bm_page
parameter_list|(
name|u32
name|page
parameter_list|,
name|u32
name|reg
parameter_list|)
block|{
name|u32
name|phy_addr
init|=
literal|2
decl_stmt|;
if|if
condition|(
operator|(
name|page
operator|>=
literal|768
operator|)
operator|||
operator|(
name|page
operator|==
literal|0
operator|&&
name|reg
operator|==
literal|25
operator|)
operator|||
operator|(
name|reg
operator|==
literal|31
operator|)
condition|)
name|phy_addr
operator|=
literal|1
expr_stmt|;
return|return
name|phy_addr
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_write_phy_reg_bm - Write BM PHY register  *  @hw: pointer to the HW structure  *  @offset: register offset to write to  *  @data: data to write at register offset  *  *  Acquires semaphore, if necessary, then writes the data to PHY register  *  at the offset.  Release any acquired semaphores before exiting.  **/
end_comment

begin_function
name|s32
name|e1000_write_phy_reg_bm
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u16
name|data
parameter_list|)
block|{
name|s32
name|ret_val
decl_stmt|;
name|u32
name|page_select
init|=
literal|0
decl_stmt|;
name|u32
name|page
init|=
name|offset
operator|>>
name|IGP_PAGE_SHIFT
decl_stmt|;
name|u32
name|page_shift
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_write_phy_reg_bm"
argument_list|)
expr_stmt|;
comment|/* Page 800 works differently than the rest so it has its own func */
if|if
condition|(
name|page
operator|==
name|BM_WUC_PAGE
condition|)
block|{
name|ret_val
operator|=
name|e1000_access_phy_wakeup_reg_bm
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
operator|&
name|data
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|acquire
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|hw
operator|->
name|phy
operator|.
name|addr
operator|=
name|e1000_get_phy_addr_for_bm_page
argument_list|(
name|page
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|>
name|MAX_PHY_MULTI_PAGE_REG
condition|)
block|{
comment|/* 		 * Page select is register 31 for phy address 1 and 22 for 		 * phy address 2 and 3. Page select is shifted only for 		 * phy address 1. 		 */
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|addr
operator|==
literal|1
condition|)
block|{
name|page_shift
operator|=
name|IGP_PAGE_SHIFT
expr_stmt|;
name|page_select
operator|=
name|IGP01E1000_PHY_PAGE_SELECT
expr_stmt|;
block|}
else|else
block|{
name|page_shift
operator|=
literal|0
expr_stmt|;
name|page_select
operator|=
name|BM_PHY_PAGE_SELECT
expr_stmt|;
block|}
comment|/* Page is shifted left, PHY expects (page x 32) */
name|ret_val
operator|=
name|e1000_write_phy_reg_mdic
argument_list|(
name|hw
argument_list|,
name|page_select
argument_list|,
operator|(
name|page
operator|<<
name|page_shift
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|release
argument_list|(
name|hw
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|ret_val
operator|=
name|e1000_write_phy_reg_mdic
argument_list|(
name|hw
argument_list|,
name|MAX_PHY_REG_ADDRESS
operator|&
name|offset
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|release
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_read_phy_reg_bm - Read BM PHY register  *  @hw: pointer to the HW structure  *  @offset: register offset to be read  *  @data: pointer to the read data  *  *  Acquires semaphore, if necessary, then reads the PHY register at offset  *  and storing the retrieved information in data.  Release any acquired  *  semaphores before exiting.  **/
end_comment

begin_function
name|s32
name|e1000_read_phy_reg_bm
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
block|{
name|s32
name|ret_val
decl_stmt|;
name|u32
name|page_select
init|=
literal|0
decl_stmt|;
name|u32
name|page
init|=
name|offset
operator|>>
name|IGP_PAGE_SHIFT
decl_stmt|;
name|u32
name|page_shift
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_read_phy_reg_bm"
argument_list|)
expr_stmt|;
comment|/* Page 800 works differently than the rest so it has its own func */
if|if
condition|(
name|page
operator|==
name|BM_WUC_PAGE
condition|)
block|{
name|ret_val
operator|=
name|e1000_access_phy_wakeup_reg_bm
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
name|data
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|acquire
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|hw
operator|->
name|phy
operator|.
name|addr
operator|=
name|e1000_get_phy_addr_for_bm_page
argument_list|(
name|page
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|>
name|MAX_PHY_MULTI_PAGE_REG
condition|)
block|{
comment|/* 		 * Page select is register 31 for phy address 1 and 22 for 		 * phy address 2 and 3. Page select is shifted only for 		 * phy address 1. 		 */
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|addr
operator|==
literal|1
condition|)
block|{
name|page_shift
operator|=
name|IGP_PAGE_SHIFT
expr_stmt|;
name|page_select
operator|=
name|IGP01E1000_PHY_PAGE_SELECT
expr_stmt|;
block|}
else|else
block|{
name|page_shift
operator|=
literal|0
expr_stmt|;
name|page_select
operator|=
name|BM_PHY_PAGE_SELECT
expr_stmt|;
block|}
comment|/* Page is shifted left, PHY expects (page x 32) */
name|ret_val
operator|=
name|e1000_write_phy_reg_mdic
argument_list|(
name|hw
argument_list|,
name|page_select
argument_list|,
operator|(
name|page
operator|<<
name|page_shift
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|release
argument_list|(
name|hw
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|ret_val
operator|=
name|e1000_read_phy_reg_mdic
argument_list|(
name|hw
argument_list|,
name|MAX_PHY_REG_ADDRESS
operator|&
name|offset
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|release
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_read_phy_reg_bm2 - Read BM PHY register  *  @hw: pointer to the HW structure  *  @offset: register offset to be read  *  @data: pointer to the read data  *  *  Acquires semaphore, if necessary, then reads the PHY register at offset  *  and storing the retrieved information in data.  Release any acquired  *  semaphores before exiting.  **/
end_comment

begin_function
name|s32
name|e1000_read_phy_reg_bm2
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
block|{
name|s32
name|ret_val
decl_stmt|;
name|u16
name|page
init|=
call|(
name|u16
call|)
argument_list|(
name|offset
operator|>>
name|IGP_PAGE_SHIFT
argument_list|)
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_write_phy_reg_bm2"
argument_list|)
expr_stmt|;
comment|/* Page 800 works differently than the rest so it has its own func */
if|if
condition|(
name|page
operator|==
name|BM_WUC_PAGE
condition|)
block|{
name|ret_val
operator|=
name|e1000_access_phy_wakeup_reg_bm
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
name|data
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|acquire
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|hw
operator|->
name|phy
operator|.
name|addr
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|offset
operator|>
name|MAX_PHY_MULTI_PAGE_REG
condition|)
block|{
comment|/* Page is shifted left, PHY expects (page x 32) */
name|ret_val
operator|=
name|e1000_write_phy_reg_mdic
argument_list|(
name|hw
argument_list|,
name|BM_PHY_PAGE_SELECT
argument_list|,
name|page
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|release
argument_list|(
name|hw
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|ret_val
operator|=
name|e1000_read_phy_reg_mdic
argument_list|(
name|hw
argument_list|,
name|MAX_PHY_REG_ADDRESS
operator|&
name|offset
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|release
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_write_phy_reg_bm2 - Write BM PHY register  *  @hw: pointer to the HW structure  *  @offset: register offset to write to  *  @data: data to write at register offset  *  *  Acquires semaphore, if necessary, then writes the data to PHY register  *  at the offset.  Release any acquired semaphores before exiting.  **/
end_comment

begin_function
name|s32
name|e1000_write_phy_reg_bm2
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u16
name|data
parameter_list|)
block|{
name|s32
name|ret_val
decl_stmt|;
name|u16
name|page
init|=
call|(
name|u16
call|)
argument_list|(
name|offset
operator|>>
name|IGP_PAGE_SHIFT
argument_list|)
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_write_phy_reg_bm2"
argument_list|)
expr_stmt|;
comment|/* Page 800 works differently than the rest so it has its own func */
if|if
condition|(
name|page
operator|==
name|BM_WUC_PAGE
condition|)
block|{
name|ret_val
operator|=
name|e1000_access_phy_wakeup_reg_bm
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
operator|&
name|data
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|acquire
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|hw
operator|->
name|phy
operator|.
name|addr
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|offset
operator|>
name|MAX_PHY_MULTI_PAGE_REG
condition|)
block|{
comment|/* Page is shifted left, PHY expects (page x 32) */
name|ret_val
operator|=
name|e1000_write_phy_reg_mdic
argument_list|(
name|hw
argument_list|,
name|BM_PHY_PAGE_SELECT
argument_list|,
name|page
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|release
argument_list|(
name|hw
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|ret_val
operator|=
name|e1000_write_phy_reg_mdic
argument_list|(
name|hw
argument_list|,
name|MAX_PHY_REG_ADDRESS
operator|&
name|offset
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|release
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_access_phy_wakeup_reg_bm - Read BM PHY wakeup register  *  @hw: pointer to the HW structure  *  @offset: register offset to be read or written  *  @data: pointer to the data to read or write  *  @read: determines if operation is read or write  *  *  Acquires semaphore, if necessary, then reads the PHY register at offset  *  and storing the retrieved information in data.  Release any acquired  *  semaphores before exiting. Note that procedure to read the wakeup  *  registers are different. It works as such:  *  1) Set page 769, register 17, bit 2 = 1  *  2) Set page to 800 for host (801 if we were manageability)  *  3) Write the address using the address opcode (0x11)  *  4) Read or write the data using the data opcode (0x12)  *  5) Restore 769_17.2 to its original value  **/
end_comment

begin_function
name|s32
name|e1000_access_phy_wakeup_reg_bm
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|,
name|bool
name|read
parameter_list|)
block|{
name|s32
name|ret_val
decl_stmt|;
name|u16
name|reg
init|=
operator|(
operator|(
name|u16
operator|)
name|offset
operator|)
operator|&
name|PHY_REG_MASK
decl_stmt|;
name|u16
name|phy_reg
init|=
literal|0
decl_stmt|;
name|u8
name|phy_acquired
init|=
literal|1
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_read_phy_wakeup_reg_bm"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|acquire
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Could not acquire PHY\n"
argument_list|)
expr_stmt|;
name|phy_acquired
operator|=
literal|0
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* All operations in this function are phy address 1 */
name|hw
operator|->
name|phy
operator|.
name|addr
operator|=
literal|1
expr_stmt|;
comment|/* Set page 769 */
name|e1000_write_phy_reg_mdic
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PAGE_SELECT
argument_list|,
operator|(
name|BM_WUC_ENABLE_PAGE
operator|<<
name|IGP_PAGE_SHIFT
operator|)
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_read_phy_reg_mdic
argument_list|(
name|hw
argument_list|,
name|BM_WUC_ENABLE_REG
argument_list|,
operator|&
name|phy_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Could not read PHY page 769\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* First clear bit 4 to avoid a power state change */
name|phy_reg
operator|&=
operator|~
operator|(
name|BM_WUC_HOST_WU_BIT
operator|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_write_phy_reg_mdic
argument_list|(
name|hw
argument_list|,
name|BM_WUC_ENABLE_REG
argument_list|,
name|phy_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Could not clear PHY page 769 bit 4\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Write bit 2 = 1, and clear bit 4 to 769_17 */
name|ret_val
operator|=
name|e1000_write_phy_reg_mdic
argument_list|(
name|hw
argument_list|,
name|BM_WUC_ENABLE_REG
argument_list|,
name|phy_reg
operator||
name|BM_WUC_ENABLE_BIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Could not write PHY page 769 bit 2\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Select page 800 */
name|ret_val
operator|=
name|e1000_write_phy_reg_mdic
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PAGE_SELECT
argument_list|,
operator|(
name|BM_WUC_PAGE
operator|<<
name|IGP_PAGE_SHIFT
operator|)
argument_list|)
expr_stmt|;
comment|/* Write the page 800 offset value using opcode 0x11 */
name|ret_val
operator|=
name|e1000_write_phy_reg_mdic
argument_list|(
name|hw
argument_list|,
name|BM_WUC_ADDRESS_OPCODE
argument_list|,
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Could not write address opcode to page 800\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|read
condition|)
block|{
comment|/* Read the page 800 value using opcode 0x12 */
name|ret_val
operator|=
name|e1000_read_phy_reg_mdic
argument_list|(
name|hw
argument_list|,
name|BM_WUC_DATA_OPCODE
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Read the page 800 value using opcode 0x12 */
name|ret_val
operator|=
name|e1000_write_phy_reg_mdic
argument_list|(
name|hw
argument_list|,
name|BM_WUC_DATA_OPCODE
argument_list|,
operator|*
name|data
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Could not read data value from page 800\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * Restore 769_17.2 to its original value 	 * Set page 769 	 */
name|e1000_write_phy_reg_mdic
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PAGE_SELECT
argument_list|,
operator|(
name|BM_WUC_ENABLE_PAGE
operator|<<
name|IGP_PAGE_SHIFT
operator|)
argument_list|)
expr_stmt|;
comment|/* Clear 769_17.2 */
name|ret_val
operator|=
name|e1000_write_phy_reg_mdic
argument_list|(
name|hw
argument_list|,
name|BM_WUC_ENABLE_REG
argument_list|,
name|phy_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Could not clear PHY page 769 bit 2\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|out
label|:
if|if
condition|(
name|phy_acquired
operator|==
literal|1
condition|)
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|release
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  * e1000_power_up_phy_copper - Restore copper link in case of PHY power down  * @hw: pointer to the HW structure  *  * In the case of a PHY power down to save power, or to turn off link during a  * driver unload, or wake on lan is not enabled, restore the link to previous  * settings.  **/
end_comment

begin_function
name|void
name|e1000_power_up_phy_copper
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u16
name|mii_reg
init|=
literal|0
decl_stmt|;
comment|/* The PHY will retain its settings across a power down/up cycle */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|PHY_CONTROL
argument_list|,
operator|&
name|mii_reg
argument_list|)
expr_stmt|;
name|mii_reg
operator|&=
operator|~
name|MII_CR_POWER_DOWN
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|PHY_CONTROL
argument_list|,
name|mii_reg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * e1000_power_down_phy_copper - Restore copper link in case of PHY power down  * @hw: pointer to the HW structure  *  * In the case of a PHY power down to save power, or to turn off link during a  * driver unload, or wake on lan is not enabled, restore the link to previous  * settings.  **/
end_comment

begin_function
name|void
name|e1000_power_down_phy_copper
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u16
name|mii_reg
init|=
literal|0
decl_stmt|;
comment|/* The PHY will retain its settings across a power down/up cycle */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|PHY_CONTROL
argument_list|,
operator|&
name|mii_reg
argument_list|)
expr_stmt|;
name|mii_reg
operator||=
name|MII_CR_POWER_DOWN
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|PHY_CONTROL
argument_list|,
name|mii_reg
argument_list|)
expr_stmt|;
name|msec_delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

