begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*******************************************************************************    Copyright (c) 2001-2002 Intel Corporation    All rights reserved.       Redistribution and use in source and binary forms of the Software, with or    without modification, are permitted provided that the following conditions    are met:        1. Redistributions of source code of the Software may retain the above        copyright notice, this list of conditions and the following disclaimer.        2. Redistributions in binary form of the Software may reproduce the above        copyright notice, this list of conditions and the following disclaimer        in the documentation and/or other materials provided with the        distribution.        3. Neither the name of the Intel Corporation nor the names of its        contributors shall be used to endorse or promote products derived from        this Software without specific prior written permission.      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE    ARE DISCLAIMED. IN NO EVENT SHALL THE INTEL OR ITS CONTRIBUTORS BE LIABLE    FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL    DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR    SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER    CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT    LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY    OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF    SUCH DAMAGE.  *******************************************************************************/
end_comment

begin_comment
comment|/*$FreeBSD$*/
end_comment

begin_comment
comment|/* if_em_fxhw.c  * Shared functions for accessing and configuring the MAC  */
end_comment

begin_include
include|#
directive|include
file|<dev/em/if_em_fxhw.h>
end_include

begin_include
include|#
directive|include
file|<dev/em/if_em_phy.h>
end_include

begin_comment
comment|/******************************************************************************  * Raises the EEPROM's clock input.  *  * shared - Struct containing variables accessed by shared code  * eecd_reg - EECD's current value  *****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|em_raise_clock
parameter_list|(
name|struct
name|em_shared_adapter
modifier|*
name|shared
parameter_list|,
name|uint32_t
modifier|*
name|eecd_reg
parameter_list|)
block|{
comment|/* Raise the clock input to the EEPROM (by setting the SK bit), and then      * wait 50 microseconds.      */
operator|*
name|eecd_reg
operator|=
operator|*
name|eecd_reg
operator||
name|E1000_EECD_SK
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|shared
argument_list|,
name|EECD
argument_list|,
operator|*
name|eecd_reg
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|50
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Lowers the EEPROM's clock input.  *  * shared - Struct containing variables accessed by shared code   * eecd_reg - EECD's current value  *****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|em_lower_clock
parameter_list|(
name|struct
name|em_shared_adapter
modifier|*
name|shared
parameter_list|,
name|uint32_t
modifier|*
name|eecd_reg
parameter_list|)
block|{
comment|/* Lower the clock input to the EEPROM (by clearing the SK bit), and then       * wait 50 microseconds.       */
operator|*
name|eecd_reg
operator|=
operator|*
name|eecd_reg
operator|&
operator|~
name|E1000_EECD_SK
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|shared
argument_list|,
name|EECD
argument_list|,
operator|*
name|eecd_reg
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|50
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Shift data bits out to the EEPROM.  *  * shared - Struct containing variables accessed by shared code  * data - data to send to the EEPROM  * count - number of bits to shift out  *****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|em_shift_out_bits
parameter_list|(
name|struct
name|em_shared_adapter
modifier|*
name|shared
parameter_list|,
name|uint16_t
name|data
parameter_list|,
name|uint16_t
name|count
parameter_list|)
block|{
name|uint32_t
name|eecd_reg
decl_stmt|;
name|uint32_t
name|mask
decl_stmt|;
comment|/* We need to shift "count" bits out to the EEPROM. So, value in the      * "data" parameter will be shifted out to the EEPROM one bit at a time.      * In order to do this, "data" must be broken down into bits.       */
name|mask
operator|=
literal|0x01
operator|<<
operator|(
name|count
operator|-
literal|1
operator|)
expr_stmt|;
name|eecd_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|shared
argument_list|,
name|EECD
argument_list|)
expr_stmt|;
name|eecd_reg
operator|&=
operator|~
operator|(
name|E1000_EECD_DO
operator||
name|E1000_EECD_DI
operator|)
expr_stmt|;
do|do
block|{
comment|/* A "1" is shifted out to the EEPROM by setting bit "DI" to a "1",          * and then raising and then lowering the clock (the SK bit controls          * the clock input to the EEPROM).  A "0" is shifted out to the EEPROM          * by setting "DI" to "0" and then raising and then lowering the clock.          */
name|eecd_reg
operator|&=
operator|~
name|E1000_EECD_DI
expr_stmt|;
if|if
condition|(
name|data
operator|&
name|mask
condition|)
name|eecd_reg
operator||=
name|E1000_EECD_DI
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|shared
argument_list|,
name|EECD
argument_list|,
name|eecd_reg
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|50
argument_list|)
expr_stmt|;
name|em_raise_clock
argument_list|(
name|shared
argument_list|,
operator|&
name|eecd_reg
argument_list|)
expr_stmt|;
name|em_lower_clock
argument_list|(
name|shared
argument_list|,
operator|&
name|eecd_reg
argument_list|)
expr_stmt|;
name|mask
operator|=
name|mask
operator|>>
literal|1
expr_stmt|;
block|}
do|while
condition|(
name|mask
condition|)
do|;
comment|/* We leave the "DI" bit set to "0" when we leave this routine. */
name|eecd_reg
operator|&=
operator|~
name|E1000_EECD_DI
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|shared
argument_list|,
name|EECD
argument_list|,
name|eecd_reg
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Shift data bits in from the EEPROM  *  * shared - Struct containing variables accessed by shared code  *****************************************************************************/
end_comment

begin_function
specifier|static
name|uint16_t
name|em_shift_in_bits
parameter_list|(
name|struct
name|em_shared_adapter
modifier|*
name|shared
parameter_list|)
block|{
name|uint32_t
name|eecd_reg
decl_stmt|;
name|uint32_t
name|i
decl_stmt|;
name|uint16_t
name|data
decl_stmt|;
comment|/* In order to read a register from the EEPROM, we need to shift 16 bits       * in from the EEPROM. Bits are "shifted in" by raising the clock input to      * the EEPROM (setting the SK bit), and then reading the value of the "DO"      * bit.  During this "shifting in" process the "DI" bit should always be       * clear..      */
name|eecd_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|shared
argument_list|,
name|EECD
argument_list|)
expr_stmt|;
name|eecd_reg
operator|&=
operator|~
operator|(
name|E1000_EECD_DO
operator||
name|E1000_EECD_DI
operator|)
expr_stmt|;
name|data
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|data
operator|=
name|data
operator|<<
literal|1
expr_stmt|;
name|em_raise_clock
argument_list|(
name|shared
argument_list|,
operator|&
name|eecd_reg
argument_list|)
expr_stmt|;
name|eecd_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|shared
argument_list|,
name|EECD
argument_list|)
expr_stmt|;
name|eecd_reg
operator|&=
operator|~
operator|(
name|E1000_EECD_DI
operator|)
expr_stmt|;
if|if
condition|(
name|eecd_reg
operator|&
name|E1000_EECD_DO
condition|)
name|data
operator||=
literal|1
expr_stmt|;
name|em_lower_clock
argument_list|(
name|shared
argument_list|,
operator|&
name|eecd_reg
argument_list|)
expr_stmt|;
block|}
return|return
name|data
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Prepares EEPROM for access  *  * shared - Struct containing variables accessed by shared code  *  * Lowers EEPROM clock. Clears input pin. Sets the chip select pin. This   * function should be called before issuing a command to the EEPROM.  *****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|em_setup_eeprom
parameter_list|(
name|struct
name|em_shared_adapter
modifier|*
name|shared
parameter_list|)
block|{
name|uint32_t
name|eecd_reg
decl_stmt|;
name|eecd_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|shared
argument_list|,
name|EECD
argument_list|)
expr_stmt|;
comment|/* Clear SK and DI */
name|eecd_reg
operator|&=
operator|~
operator|(
name|E1000_EECD_SK
operator||
name|E1000_EECD_DI
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|shared
argument_list|,
name|EECD
argument_list|,
name|eecd_reg
argument_list|)
expr_stmt|;
comment|/* Set CS */
name|eecd_reg
operator||=
name|E1000_EECD_CS
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|shared
argument_list|,
name|EECD
argument_list|,
name|eecd_reg
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Returns EEPROM to a "standby" state  *   * shared - Struct containing variables accessed by shared code  *****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|em_standby_eeprom
parameter_list|(
name|struct
name|em_shared_adapter
modifier|*
name|shared
parameter_list|)
block|{
name|uint32_t
name|eecd_reg
decl_stmt|;
name|eecd_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|shared
argument_list|,
name|EECD
argument_list|)
expr_stmt|;
comment|/* Deselct EEPROM */
name|eecd_reg
operator|&=
operator|~
operator|(
name|E1000_EECD_CS
operator||
name|E1000_EECD_SK
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|shared
argument_list|,
name|EECD
argument_list|,
name|eecd_reg
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|50
argument_list|)
expr_stmt|;
comment|/* Clock high */
name|eecd_reg
operator||=
name|E1000_EECD_SK
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|shared
argument_list|,
name|EECD
argument_list|,
name|eecd_reg
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|50
argument_list|)
expr_stmt|;
comment|/* Select EEPROM */
name|eecd_reg
operator||=
name|E1000_EECD_CS
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|shared
argument_list|,
name|EECD
argument_list|,
name|eecd_reg
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|50
argument_list|)
expr_stmt|;
comment|/* Clock low */
name|eecd_reg
operator|&=
operator|~
name|E1000_EECD_SK
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|shared
argument_list|,
name|EECD
argument_list|,
name|eecd_reg
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|50
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Raises then lowers the EEPROM's clock pin  *  * shared - Struct containing variables accessed by shared code  *****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|em_clock_eeprom
parameter_list|(
name|struct
name|em_shared_adapter
modifier|*
name|shared
parameter_list|)
block|{
name|uint32_t
name|eecd_reg
decl_stmt|;
name|eecd_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|shared
argument_list|,
name|EECD
argument_list|)
expr_stmt|;
comment|/* Rising edge of clock */
name|eecd_reg
operator||=
name|E1000_EECD_SK
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|shared
argument_list|,
name|EECD
argument_list|,
name|eecd_reg
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|50
argument_list|)
expr_stmt|;
comment|/* Falling edge of clock */
name|eecd_reg
operator|&=
operator|~
name|E1000_EECD_SK
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|shared
argument_list|,
name|EECD
argument_list|,
name|eecd_reg
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|50
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Terminates a command by lowering the EEPROM's chip select pin  *  * shared - Struct containing variables accessed by shared code  *****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|em_cleanup_eeprom
parameter_list|(
name|struct
name|em_shared_adapter
modifier|*
name|shared
parameter_list|)
block|{
name|uint32_t
name|eecd_reg
decl_stmt|;
name|eecd_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|shared
argument_list|,
name|EECD
argument_list|)
expr_stmt|;
name|eecd_reg
operator|&=
operator|~
operator|(
name|E1000_EECD_CS
operator||
name|E1000_EECD_DI
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|shared
argument_list|,
name|EECD
argument_list|,
name|eecd_reg
argument_list|)
expr_stmt|;
name|em_clock_eeprom
argument_list|(
name|shared
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Waits for the EEPROM to finish the current command.  *  * shared - Struct containing variables accessed by shared code  *  * The command is done when the EEPROM's data out pin goes high.  *****************************************************************************/
end_comment

begin_function
specifier|static
name|uint16_t
name|em_wait_eeprom_command
parameter_list|(
name|struct
name|em_shared_adapter
modifier|*
name|shared
parameter_list|)
block|{
name|uint32_t
name|eecd_reg
decl_stmt|;
name|uint32_t
name|i
decl_stmt|;
comment|/* Toggle the CS line.  This in effect tells to EEPROM to actually execute       * the command in question.      */
name|em_standby_eeprom
argument_list|(
name|shared
argument_list|)
expr_stmt|;
comment|/* Now read DO repeatedly until is high (equal to '1').  The EEEPROM will      * signal that the command has been completed by raising the DO signal.      * If DO does not go high in 10 milliseconds, then error out.      */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|200
condition|;
name|i
operator|++
control|)
block|{
name|eecd_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|shared
argument_list|,
name|EECD
argument_list|)
expr_stmt|;
if|if
condition|(
name|eecd_reg
operator|&
name|E1000_EECD_DO
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
name|usec_delay
argument_list|(
literal|50
argument_list|)
expr_stmt|;
block|}
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Forces the MAC's flow control settings.  *   * shared - Struct containing variables accessed by shared code  *  * Sets the TFCE and RFCE bits in the device control register to reflect  * the adapter settings. TFCE and RFCE need to be explicitly set by  * software when a Copper PHY is used because autonegotiation is managed  * by the PHY rather than the MAC. Software must also configure these  * bits when link is forced on a fiber connection.  *****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|em_force_mac_fc
parameter_list|(
name|struct
name|em_shared_adapter
modifier|*
name|shared
parameter_list|)
block|{
name|uint32_t
name|ctrl_reg
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_force_mac_fc"
argument_list|)
expr_stmt|;
comment|/* Get the current configuration of the Device Control Register */
name|ctrl_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|shared
argument_list|,
name|CTRL
argument_list|)
expr_stmt|;
comment|/* Because we didn't get link via the internal auto-negotiation      * mechanism (we either forced link or we got link via PHY      * auto-neg), we have to manually enable/disable transmit an      * receive flow control.      *      * The "Case" statement below enables/disable flow control      * according to the "shared->fc" parameter.      *      * The possible values of the "fc" parameter are:      *      0:  Flow control is completely disabled      *      1:  Rx flow control is enabled (we can receive pause      *          frames but not send pause frames).      *      2:  Tx flow control is enabled (we can send pause frames      *          frames but we do not receive pause frames).      *      3:  Both Rx and TX flow control (symmetric) is enabled.      *  other:  No other values should be possible at this point.      */
switch|switch
condition|(
name|shared
operator|->
name|fc
condition|)
block|{
case|case
name|em_fc_none
case|:
name|ctrl_reg
operator|&=
operator|(
operator|~
operator|(
name|E1000_CTRL_TFCE
operator||
name|E1000_CTRL_RFCE
operator|)
operator|)
expr_stmt|;
break|break;
case|case
name|em_fc_rx_pause
case|:
name|ctrl_reg
operator|&=
operator|(
operator|~
name|E1000_CTRL_TFCE
operator|)
expr_stmt|;
name|ctrl_reg
operator||=
name|E1000_CTRL_RFCE
expr_stmt|;
break|break;
case|case
name|em_fc_tx_pause
case|:
name|ctrl_reg
operator|&=
operator|(
operator|~
name|E1000_CTRL_RFCE
operator|)
expr_stmt|;
name|ctrl_reg
operator||=
name|E1000_CTRL_TFCE
expr_stmt|;
break|break;
case|case
name|em_fc_full
case|:
name|ctrl_reg
operator||=
operator|(
name|E1000_CTRL_TFCE
operator||
name|E1000_CTRL_RFCE
operator|)
expr_stmt|;
break|break;
default|default:
name|DEBUGOUT
argument_list|(
literal|"Flow control param set incorrectly\n"
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Disable TX Flow Control for 82542 (rev 2.0) */
if|if
condition|(
name|shared
operator|->
name|mac_type
operator|==
name|em_82542_rev2_0
condition|)
name|ctrl_reg
operator|&=
operator|(
operator|~
name|E1000_CTRL_TFCE
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|shared
argument_list|,
name|CTRL
argument_list|,
name|ctrl_reg
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Reset the transmit and receive units; mask and clear all interrupts.  *  * shared - Struct containing variables accessed by shared code  *****************************************************************************/
end_comment

begin_function
name|void
name|em_adapter_stop
parameter_list|(
name|struct
name|em_shared_adapter
modifier|*
name|shared
parameter_list|)
block|{
if|#
directive|if
name|DBG
name|uint32_t
name|ctrl_reg
decl_stmt|;
endif|#
directive|endif
name|uint32_t
name|ctrl_ext_reg
decl_stmt|;
name|uint32_t
name|icr_reg
decl_stmt|;
name|uint16_t
name|pci_cmd_word
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_shared_adapter_stop"
argument_list|)
expr_stmt|;
comment|/* If we are stopped or resetting exit gracefully and wait to be      * started again before accessing the hardware.      */
if|if
condition|(
name|shared
operator|->
name|adapter_stopped
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Exiting because the adapter is already stopped!!!\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Set the Adapter Stopped flag so other driver functions stop      * touching the Hardware.      */
name|shared
operator|->
name|adapter_stopped
operator|=
name|TRUE
expr_stmt|;
comment|/* For 82542 (rev 2.0), disable MWI before issuing a device reset */
if|if
condition|(
name|shared
operator|->
name|mac_type
operator|==
name|em_82542_rev2_0
condition|)
block|{
if|if
condition|(
name|shared
operator|->
name|pci_cmd_word
operator|&
name|CMD_MEM_WRT_INVALIDATE
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Disabling MWI on 82542 rev 2.0\n"
argument_list|)
expr_stmt|;
name|pci_cmd_word
operator|=
name|shared
operator|->
name|pci_cmd_word
operator|&
operator|~
name|CMD_MEM_WRT_INVALIDATE
expr_stmt|;
name|em_write_pci_cfg
argument_list|(
name|shared
argument_list|,
name|PCI_COMMAND_REGISTER
argument_list|,
operator|&
name|pci_cmd_word
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Clear interrupt mask to stop board from generating interrupts */
name|DEBUGOUT
argument_list|(
literal|"Masking off all interrupts\n"
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|shared
argument_list|,
name|IMC
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
comment|/* Disable the Transmit and Receive units.  Then delay to allow      * any pending transactions to complete before we hit the MAC with      * the global reset.      */
name|E1000_WRITE_REG
argument_list|(
name|shared
argument_list|,
name|RCTL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|shared
argument_list|,
name|TCTL
argument_list|,
name|E1000_TCTL_PSP
argument_list|)
expr_stmt|;
comment|/* The tbi_compatibility_on Flag must be cleared when Rctl is cleared. */
name|shared
operator|->
name|tbi_compatibility_on
operator|=
name|FALSE
expr_stmt|;
name|msec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
comment|/* Issue a global reset to the MAC.  This will reset the chip's      * transmit, receive, DMA, and link units.  It will not effect      * the current PCI configuration.  The global reset bit is self-      * clearing, and should clear within a microsecond.      */
name|DEBUGOUT
argument_list|(
literal|"Issuing a global reset to MAC\n"
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|shared
argument_list|,
name|CTRL
argument_list|,
name|E1000_CTRL_RST
argument_list|)
expr_stmt|;
comment|/* Delay a few ms just to allow the reset to complete */
name|msec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
if|#
directive|if
name|DBG
comment|/* Make sure the self-clearing global reset bit did self clear */
name|ctrl_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|shared
argument_list|,
name|CTRL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
operator|(
name|ctrl_reg
operator|&
name|E1000_CTRL_RST
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Force a reload from the EEPROM */
name|ctrl_ext_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|shared
argument_list|,
name|CTRL_EXT
argument_list|)
expr_stmt|;
name|ctrl_ext_reg
operator||=
name|E1000_CTRL_EXT_EE_RST
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|shared
argument_list|,
name|CTRL_EXT
argument_list|,
name|ctrl_ext_reg
argument_list|)
expr_stmt|;
name|msec_delay
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|/* Clear interrupt mask to stop board from generating interrupts */
name|DEBUGOUT
argument_list|(
literal|"Masking off all interrupts\n"
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|shared
argument_list|,
name|IMC
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
comment|/* Clear any pending interrupt events. */
name|icr_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|shared
argument_list|,
name|ICR
argument_list|)
expr_stmt|;
comment|/* If MWI was previously enabled, reenable it. */
if|if
condition|(
name|shared
operator|->
name|mac_type
operator|==
name|em_82542_rev2_0
condition|)
block|{
if|if
condition|(
name|shared
operator|->
name|pci_cmd_word
operator|&
name|CMD_MEM_WRT_INVALIDATE
condition|)
block|{
name|em_write_pci_cfg
argument_list|(
name|shared
argument_list|,
name|PCI_COMMAND_REGISTER
argument_list|,
operator|&
name|shared
operator|->
name|pci_cmd_word
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Performs basic configuration of the adapter.  *  * shared - Struct containing variables accessed by shared code  *   * Assumes that the controller has previously been reset and is in a   * post-reset uninitialized state. Initializes the receive address registers,  * multicast table, and VLAN filter table. Calls routines to setup link  * configuration and flow control settings. Clears all on-chip counters. Leaves  * the transmit and receive units disabled and uninitialized.  *****************************************************************************/
end_comment

begin_function
name|boolean_t
name|em_init_hw
parameter_list|(
name|struct
name|em_shared_adapter
modifier|*
name|shared
parameter_list|)
block|{
name|uint32_t
name|status_reg
decl_stmt|;
name|uint32_t
name|i
decl_stmt|;
name|uint16_t
name|pci_cmd_word
decl_stmt|;
name|boolean_t
name|status
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_init_hw"
argument_list|)
expr_stmt|;
comment|/* Set the Media Type and exit with error if it is not valid. */
if|if
condition|(
name|shared
operator|->
name|mac_type
operator|!=
name|em_82543
condition|)
block|{
comment|/* tbi_compatibility is only valid on 82543 */
name|shared
operator|->
name|tbi_compatibility_en
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|shared
operator|->
name|mac_type
operator|>=
name|em_82543
condition|)
block|{
name|status_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|shared
argument_list|,
name|STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
name|status_reg
operator|&
name|E1000_STATUS_TBIMODE
condition|)
block|{
name|shared
operator|->
name|media_type
operator|=
name|em_media_type_fiber
expr_stmt|;
comment|/* tbi_compatibility not valid on fiber */
name|shared
operator|->
name|tbi_compatibility_en
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
name|shared
operator|->
name|media_type
operator|=
name|em_media_type_copper
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* This is an 82542 (fiber only) */
name|shared
operator|->
name|media_type
operator|=
name|em_media_type_fiber
expr_stmt|;
block|}
comment|/* Disabling VLAN filtering. */
name|DEBUGOUT
argument_list|(
literal|"Initializing the IEEE VLAN\n"
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|shared
argument_list|,
name|VET
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|em_clear_vfta
argument_list|(
name|shared
argument_list|)
expr_stmt|;
comment|/* For 82542 (rev 2.0), disable MWI and put the receiver into reset */
if|if
condition|(
name|shared
operator|->
name|mac_type
operator|==
name|em_82542_rev2_0
condition|)
block|{
if|if
condition|(
name|shared
operator|->
name|pci_cmd_word
operator|&
name|CMD_MEM_WRT_INVALIDATE
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Disabling MWI on 82542 rev 2.0\n"
argument_list|)
expr_stmt|;
name|pci_cmd_word
operator|=
name|shared
operator|->
name|pci_cmd_word
operator|&
operator|~
name|CMD_MEM_WRT_INVALIDATE
expr_stmt|;
name|em_write_pci_cfg
argument_list|(
name|shared
argument_list|,
name|PCI_COMMAND_REGISTER
argument_list|,
operator|&
name|pci_cmd_word
argument_list|)
expr_stmt|;
block|}
name|E1000_WRITE_REG
argument_list|(
name|shared
argument_list|,
name|RCTL
argument_list|,
name|E1000_RCTL_RST
argument_list|)
expr_stmt|;
name|msec_delay
argument_list|(
literal|5
argument_list|)
expr_stmt|;
block|}
comment|/* Setup the receive address. This involves initializing all of the Receive      * Address Registers (RARs 0 - 15).      */
name|em_init_rx_addrs
argument_list|(
name|shared
argument_list|)
expr_stmt|;
comment|/* For 82542 (rev 2.0), take the receiver out of reset and enable MWI */
if|if
condition|(
name|shared
operator|->
name|mac_type
operator|==
name|em_82542_rev2_0
condition|)
block|{
name|E1000_WRITE_REG
argument_list|(
name|shared
argument_list|,
name|RCTL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|msec_delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|shared
operator|->
name|pci_cmd_word
operator|&
name|CMD_MEM_WRT_INVALIDATE
condition|)
block|{
name|em_write_pci_cfg
argument_list|(
name|shared
argument_list|,
name|PCI_COMMAND_REGISTER
argument_list|,
operator|&
name|shared
operator|->
name|pci_cmd_word
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Zero out the Multicast HASH table */
name|DEBUGOUT
argument_list|(
literal|"Zeroing the MTA\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|E1000_MC_TBL_SIZE
condition|;
name|i
operator|++
control|)
name|E1000_WRITE_REG_ARRAY
argument_list|(
name|shared
argument_list|,
name|MTA
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Call a subroutine to configure the link and setup flow control. */
name|status
operator|=
name|em_setup_fc_and_link
argument_list|(
name|shared
argument_list|)
expr_stmt|;
comment|/* Clear all of the statistics registers (clear on read).  It is      * important that we do this after we have tried to establish link      * because the symbol error count will increment wildly if there      * is no link.      */
name|em_clear_hw_cntrs
argument_list|(
name|shared
argument_list|)
expr_stmt|;
name|shared
operator|->
name|low_profile
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|shared
operator|->
name|mac_type
operator|==
name|em_82544
condition|)
block|{
if|if
condition|(
name|em_read_eeprom
argument_list|(
name|shared
argument_list|,
name|E1000_EEPROM_LED_LOGIC
argument_list|)
operator|&
name|E1000_EEPROM_SWDPIN0
condition|)
name|shared
operator|->
name|low_profile
operator|=
name|TRUE
expr_stmt|;
block|}
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Initializes receive address filters.  *  * shared - Struct containing variables accessed by shared code   *  * Places the MAC address in receive address register 0 and clears the rest  * of the receive addresss registers. Clears the multicast table. Assumes  * the receiver is in reset when the routine is called.  *****************************************************************************/
end_comment

begin_function
name|void
name|em_init_rx_addrs
parameter_list|(
name|struct
name|em_shared_adapter
modifier|*
name|shared
parameter_list|)
block|{
name|uint32_t
name|i
decl_stmt|;
name|uint32_t
name|addr_low
decl_stmt|;
name|uint32_t
name|addr_high
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_init_rx_addrs"
argument_list|)
expr_stmt|;
comment|/* Setup the receive address. */
name|DEBUGOUT
argument_list|(
literal|"Programming MAC Address into RAR[0]\n"
argument_list|)
expr_stmt|;
name|addr_low
operator|=
operator|(
name|shared
operator|->
name|mac_addr
index|[
literal|0
index|]
operator||
operator|(
name|shared
operator|->
name|mac_addr
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|shared
operator|->
name|mac_addr
index|[
literal|2
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|shared
operator|->
name|mac_addr
index|[
literal|3
index|]
operator|<<
literal|24
operator|)
operator|)
expr_stmt|;
name|addr_high
operator|=
operator|(
name|shared
operator|->
name|mac_addr
index|[
literal|4
index|]
operator||
operator|(
name|shared
operator|->
name|mac_addr
index|[
literal|5
index|]
operator|<<
literal|8
operator|)
operator||
name|E1000_RAH_AV
operator|)
expr_stmt|;
name|E1000_WRITE_REG_ARRAY
argument_list|(
name|shared
argument_list|,
name|RA
argument_list|,
literal|0
argument_list|,
name|addr_low
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG_ARRAY
argument_list|(
name|shared
argument_list|,
name|RA
argument_list|,
literal|1
argument_list|,
name|addr_high
argument_list|)
expr_stmt|;
comment|/* Zero out the other 15 receive addresses. */
name|DEBUGOUT
argument_list|(
literal|"Clearing RAR[1-15]\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|E1000_RAR_ENTRIES
condition|;
name|i
operator|++
control|)
block|{
name|E1000_WRITE_REG_ARRAY
argument_list|(
name|shared
argument_list|,
name|RA
argument_list|,
operator|(
name|i
operator|<<
literal|1
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG_ARRAY
argument_list|(
name|shared
argument_list|,
name|RA
argument_list|,
operator|(
operator|(
name|i
operator|<<
literal|1
operator|)
operator|+
literal|1
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Updates the MAC's list of multicast addresses.  *  * shared - Struct containing variables accessed by shared code  * mc_addr_list - the list of new multicast addresses  * mc_addr_count - number of addresses  * pad - number of bytes between addresses in the list  *  * The given list replaces any existing list. Clears the last 15 receive  * address registers and the multicast table. Uses receive address registers  * for the first 15 multicast addresses, and hashes the rest into the   * multicast table.  *****************************************************************************/
end_comment

begin_function
name|void
name|em_mc_addr_list_update
parameter_list|(
name|struct
name|em_shared_adapter
modifier|*
name|shared
parameter_list|,
name|uint8_t
modifier|*
name|mc_addr_list
parameter_list|,
name|uint32_t
name|mc_addr_count
parameter_list|,
name|uint32_t
name|pad
parameter_list|)
block|{
name|uint32_t
name|hash_value
decl_stmt|;
name|uint32_t
name|i
decl_stmt|;
name|uint32_t
name|rar_used_count
init|=
literal|1
decl_stmt|;
comment|/* RAR[0] is used for our MAC address */
name|DEBUGFUNC
argument_list|(
literal|"em_mc_addr_list_update"
argument_list|)
expr_stmt|;
comment|/* Set the new number of MC addresses that we are being requested to use. */
name|shared
operator|->
name|num_mc_addrs
operator|=
name|mc_addr_count
expr_stmt|;
comment|/* Clear RAR[1-15] */
name|DEBUGOUT
argument_list|(
literal|" Clearing RAR[1-15]\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|rar_used_count
init|;
name|i
operator|<
name|E1000_RAR_ENTRIES
condition|;
name|i
operator|++
control|)
block|{
name|E1000_WRITE_REG_ARRAY
argument_list|(
name|shared
argument_list|,
name|RA
argument_list|,
operator|(
name|i
operator|<<
literal|1
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG_ARRAY
argument_list|(
name|shared
argument_list|,
name|RA
argument_list|,
operator|(
operator|(
name|i
operator|<<
literal|1
operator|)
operator|+
literal|1
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Clear the MTA */
name|DEBUGOUT
argument_list|(
literal|" Clearing MTA\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|E1000_NUM_MTA_REGISTERS
condition|;
name|i
operator|++
control|)
block|{
name|E1000_WRITE_REG_ARRAY
argument_list|(
name|shared
argument_list|,
name|MTA
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Add the new addresses */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mc_addr_count
condition|;
name|i
operator|++
control|)
block|{
name|DEBUGOUT
argument_list|(
literal|" Adding the multicast addresses:\n"
argument_list|)
expr_stmt|;
name|DEBUGOUT7
argument_list|(
literal|" MC Addr #%d =%.2X %.2X %.2X %.2X %.2X %.2X\n"
argument_list|,
name|i
argument_list|,
name|mc_addr_list
index|[
name|i
operator|*
operator|(
name|ETH_LENGTH_OF_ADDRESS
operator|+
name|pad
operator|)
index|]
argument_list|,
name|mc_addr_list
index|[
name|i
operator|*
operator|(
name|ETH_LENGTH_OF_ADDRESS
operator|+
name|pad
operator|)
operator|+
literal|1
index|]
argument_list|,
name|mc_addr_list
index|[
name|i
operator|*
operator|(
name|ETH_LENGTH_OF_ADDRESS
operator|+
name|pad
operator|)
operator|+
literal|2
index|]
argument_list|,
name|mc_addr_list
index|[
name|i
operator|*
operator|(
name|ETH_LENGTH_OF_ADDRESS
operator|+
name|pad
operator|)
operator|+
literal|3
index|]
argument_list|,
name|mc_addr_list
index|[
name|i
operator|*
operator|(
name|ETH_LENGTH_OF_ADDRESS
operator|+
name|pad
operator|)
operator|+
literal|4
index|]
argument_list|,
name|mc_addr_list
index|[
name|i
operator|*
operator|(
name|ETH_LENGTH_OF_ADDRESS
operator|+
name|pad
operator|)
operator|+
literal|5
index|]
argument_list|)
expr_stmt|;
name|hash_value
operator|=
name|em_hash_mc_addr
argument_list|(
name|shared
argument_list|,
name|mc_addr_list
operator|+
operator|(
name|i
operator|*
operator|(
name|ETH_LENGTH_OF_ADDRESS
operator|+
name|pad
operator|)
operator|)
argument_list|)
expr_stmt|;
name|DEBUGOUT1
argument_list|(
literal|" Hash value = 0x%03X\n"
argument_list|,
name|hash_value
argument_list|)
expr_stmt|;
comment|/* Place this multicast address in the RAR if there is room, *          * else put it in the MTA                      */
if|if
condition|(
name|rar_used_count
operator|<
name|E1000_RAR_ENTRIES
condition|)
block|{
name|em_rar_set
argument_list|(
name|shared
argument_list|,
name|mc_addr_list
operator|+
operator|(
name|i
operator|*
operator|(
name|ETH_LENGTH_OF_ADDRESS
operator|+
name|pad
operator|)
operator|)
argument_list|,
name|rar_used_count
argument_list|)
expr_stmt|;
name|rar_used_count
operator|++
expr_stmt|;
block|}
else|else
block|{
name|em_mta_set
argument_list|(
name|shared
argument_list|,
name|hash_value
argument_list|)
expr_stmt|;
block|}
block|}
name|DEBUGOUT
argument_list|(
literal|"MC Update Complete\n"
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Hashes an address to determine its location in the multicast table  *  * shared - Struct containing variables accessed by shared code  * mc_addr - the multicast address to hash   *****************************************************************************/
end_comment

begin_function
name|uint32_t
name|em_hash_mc_addr
parameter_list|(
name|struct
name|em_shared_adapter
modifier|*
name|shared
parameter_list|,
name|uint8_t
modifier|*
name|mc_addr
parameter_list|)
block|{
name|uint32_t
name|hash_value
init|=
literal|0
decl_stmt|;
comment|/* The portion of the address that is used for the hash table is      * determined by the mc_filter_type setting.        */
switch|switch
condition|(
name|shared
operator|->
name|mc_filter_type
condition|)
block|{
comment|/* [0] [1] [2] [3] [4] [5]             * 01  AA  00  12  34  56             * LSB                 MSB - According to H/W docs */
case|case
literal|0
case|:
comment|/* [47:36] i.e. 0x563 for above example address */
name|hash_value
operator|=
operator|(
operator|(
name|mc_addr
index|[
literal|4
index|]
operator|>>
literal|4
operator|)
operator||
operator|(
operator|(
operator|(
name|uint16_t
operator|)
name|mc_addr
index|[
literal|5
index|]
operator|)
operator|<<
literal|4
operator|)
operator|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* [46:35] i.e. 0xAC6 for above example address */
name|hash_value
operator|=
operator|(
operator|(
name|mc_addr
index|[
literal|4
index|]
operator|>>
literal|3
operator|)
operator||
operator|(
operator|(
operator|(
name|uint16_t
operator|)
name|mc_addr
index|[
literal|5
index|]
operator|)
operator|<<
literal|5
operator|)
operator|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* [45:34] i.e. 0x5D8 for above example address */
name|hash_value
operator|=
operator|(
operator|(
name|mc_addr
index|[
literal|4
index|]
operator|>>
literal|2
operator|)
operator||
operator|(
operator|(
operator|(
name|uint16_t
operator|)
name|mc_addr
index|[
literal|5
index|]
operator|)
operator|<<
literal|6
operator|)
operator|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* [43:32] i.e. 0x634 for above example address */
name|hash_value
operator|=
operator|(
operator|(
name|mc_addr
index|[
literal|4
index|]
operator|)
operator||
operator|(
operator|(
operator|(
name|uint16_t
operator|)
name|mc_addr
index|[
literal|5
index|]
operator|)
operator|<<
literal|8
operator|)
operator|)
expr_stmt|;
break|break;
block|}
name|hash_value
operator|&=
literal|0xFFF
expr_stmt|;
return|return
operator|(
name|hash_value
operator|)
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Sets the bit in the multicast table corresponding to the hash value.  *  * shared - Struct containing variables accessed by shared code  * hash_value - Multicast address hash value  *****************************************************************************/
end_comment

begin_function
name|void
name|em_mta_set
parameter_list|(
name|struct
name|em_shared_adapter
modifier|*
name|shared
parameter_list|,
name|uint32_t
name|hash_value
parameter_list|)
block|{
name|uint32_t
name|hash_bit
decl_stmt|,
name|hash_reg
decl_stmt|;
name|uint32_t
name|mta_reg
decl_stmt|;
name|uint32_t
name|temp
decl_stmt|;
comment|/* The MTA is a register array of 128 32-bit registers.        * It is treated like an array of 4096 bits.  We want to set       * bit BitArray[hash_value]. So we figure out what register      * the bit is in, read it, OR in the new bit, then write      * back the new value.  The register is determined by the       * upper 7 bits of the hash value and the bit within that       * register are determined by the lower 5 bits of the value.      */
name|hash_reg
operator|=
operator|(
name|hash_value
operator|>>
literal|5
operator|)
operator|&
literal|0x7F
expr_stmt|;
name|hash_bit
operator|=
name|hash_value
operator|&
literal|0x1F
expr_stmt|;
name|mta_reg
operator|=
name|E1000_READ_REG_ARRAY
argument_list|(
name|shared
argument_list|,
name|MTA
argument_list|,
name|hash_reg
argument_list|)
expr_stmt|;
name|mta_reg
operator||=
operator|(
literal|1
operator|<<
name|hash_bit
operator|)
expr_stmt|;
comment|/* If we are on an 82544 and we are trying to write an odd offset      * in the MTA, save off the previous entry before writing and      * restore the old value after writing.      */
if|if
condition|(
operator|(
name|shared
operator|->
name|mac_type
operator|==
name|em_82544
operator|)
operator|&&
operator|(
operator|(
name|hash_reg
operator|&
literal|0x1
operator|)
operator|==
literal|1
operator|)
condition|)
block|{
name|temp
operator|=
name|E1000_READ_REG_ARRAY
argument_list|(
name|shared
argument_list|,
name|MTA
argument_list|,
operator|(
name|hash_reg
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG_ARRAY
argument_list|(
name|shared
argument_list|,
name|MTA
argument_list|,
name|hash_reg
argument_list|,
name|mta_reg
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG_ARRAY
argument_list|(
name|shared
argument_list|,
name|MTA
argument_list|,
operator|(
name|hash_reg
operator|-
literal|1
operator|)
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|E1000_WRITE_REG_ARRAY
argument_list|(
name|shared
argument_list|,
name|MTA
argument_list|,
name|hash_reg
argument_list|,
name|mta_reg
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Puts an ethernet address into a receive address register.  *  * shared - Struct containing variables accessed by shared code  * addr - Address to put into receive address register  * index - Receive address register to write  *****************************************************************************/
end_comment

begin_function
name|void
name|em_rar_set
parameter_list|(
name|struct
name|em_shared_adapter
modifier|*
name|shared
parameter_list|,
name|uint8_t
modifier|*
name|addr
parameter_list|,
name|uint32_t
name|index
parameter_list|)
block|{
name|uint32_t
name|rar_low
decl_stmt|,
name|rar_high
decl_stmt|;
comment|/* HW expects these in little endian so we reverse the byte order      * from network order (big endian) to little endian                    */
name|rar_low
operator|=
operator|(
operator|(
name|uint32_t
operator|)
name|addr
index|[
literal|0
index|]
operator||
operator|(
operator|(
name|uint32_t
operator|)
name|addr
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
name|uint32_t
operator|)
name|addr
index|[
literal|2
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|uint32_t
operator|)
name|addr
index|[
literal|3
index|]
operator|<<
literal|24
operator|)
operator|)
expr_stmt|;
name|rar_high
operator|=
operator|(
operator|(
name|uint32_t
operator|)
name|addr
index|[
literal|4
index|]
operator||
operator|(
operator|(
name|uint32_t
operator|)
name|addr
index|[
literal|5
index|]
operator|<<
literal|8
operator|)
operator||
name|E1000_RAH_AV
operator|)
expr_stmt|;
name|E1000_WRITE_REG_ARRAY
argument_list|(
name|shared
argument_list|,
name|RA
argument_list|,
operator|(
name|index
operator|<<
literal|1
operator|)
argument_list|,
name|rar_low
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG_ARRAY
argument_list|(
name|shared
argument_list|,
name|RA
argument_list|,
operator|(
operator|(
name|index
operator|<<
literal|1
operator|)
operator|+
literal|1
operator|)
argument_list|,
name|rar_high
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Writes a value to the specified offset in the VLAN filter table.  *  * shared - Struct containing variables accessed by shared code  * offset - Offset in VLAN filer table to write  * value - Value to write into VLAN filter table  *****************************************************************************/
end_comment

begin_function
name|void
name|em_write_vfta
parameter_list|(
name|struct
name|em_shared_adapter
modifier|*
name|shared
parameter_list|,
name|uint32_t
name|offset
parameter_list|,
name|uint32_t
name|value
parameter_list|)
block|{
name|uint32_t
name|temp
decl_stmt|;
if|if
condition|(
operator|(
name|shared
operator|->
name|mac_type
operator|==
name|em_82544
operator|)
operator|&&
operator|(
operator|(
name|offset
operator|&
literal|0x1
operator|)
operator|==
literal|1
operator|)
condition|)
block|{
name|temp
operator|=
name|E1000_READ_REG_ARRAY
argument_list|(
name|shared
argument_list|,
name|VFTA
argument_list|,
operator|(
name|offset
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG_ARRAY
argument_list|(
name|shared
argument_list|,
name|VFTA
argument_list|,
name|offset
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG_ARRAY
argument_list|(
name|shared
argument_list|,
name|VFTA
argument_list|,
operator|(
name|offset
operator|-
literal|1
operator|)
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|E1000_WRITE_REG_ARRAY
argument_list|(
name|shared
argument_list|,
name|VFTA
argument_list|,
name|offset
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Clears the VLAN filer table  *  * shared - Struct containing variables accessed by shared code  *****************************************************************************/
end_comment

begin_function
name|void
name|em_clear_vfta
parameter_list|(
name|struct
name|em_shared_adapter
modifier|*
name|shared
parameter_list|)
block|{
name|uint32_t
name|offset
decl_stmt|;
for|for
control|(
name|offset
operator|=
literal|0
init|;
name|offset
operator|<
name|E1000_VLAN_FILTER_TBL_SIZE
condition|;
name|offset
operator|++
control|)
name|E1000_WRITE_REG_ARRAY
argument_list|(
name|shared
argument_list|,
name|VFTA
argument_list|,
name|offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Configures flow control and link settings.  *   * shared - Struct containing variables accessed by shared code  *   * Determines which flow control settings to use. Calls the apropriate media-  * specific link configuration function. Configures the flow control settings.  * Assuming the adapter has a valid link partner, a valid link should be  * established. Assumes the hardware has previously been reset and the   * transmitter and receiver are not enabled.  *****************************************************************************/
end_comment

begin_function
name|boolean_t
name|em_setup_fc_and_link
parameter_list|(
name|struct
name|em_shared_adapter
modifier|*
name|shared
parameter_list|)
block|{
name|uint32_t
name|ctrl_reg
decl_stmt|;
name|uint32_t
name|eecd_reg
decl_stmt|;
name|uint32_t
name|ctrl_ext_reg
decl_stmt|;
name|boolean_t
name|status
init|=
name|TRUE
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_setup_fc_and_link"
argument_list|)
expr_stmt|;
comment|/* Read the SWDPIO bits and the ILOS bit out of word 0x0A in the      * EEPROM.  Store these bits in a variable that we will later write      * to the Device Control Register (CTRL).      */
name|eecd_reg
operator|=
name|em_read_eeprom
argument_list|(
name|shared
argument_list|,
name|EEPROM_INIT_CONTROL1_REG
argument_list|)
expr_stmt|;
name|ctrl_reg
operator|=
operator|(
operator|(
operator|(
name|eecd_reg
operator|&
name|EEPROM_WORD0A_SWDPIO
operator|)
operator|<<
name|SWDPIO_SHIFT
operator|)
operator||
operator|(
operator|(
name|eecd_reg
operator|&
name|EEPROM_WORD0A_ILOS
operator|)
operator|<<
name|ILOS_SHIFT
operator|)
operator|)
expr_stmt|;
comment|/* Set the PCI priority bit correctly in the CTRL register.  This      * determines if the adapter gives priority to receives, or if it      * gives equal priority to transmits and receives.      */
if|if
condition|(
name|shared
operator|->
name|dma_fairness
condition|)
name|ctrl_reg
operator||=
name|E1000_CTRL_PRIOR
expr_stmt|;
comment|/* Read and store word 0x0F of the EEPROM. This word contains bits      * that determine the hardware's default PAUSE (flow control) mode,      * a bit that determines whether the HW defaults to enabling or      * disabling auto-negotiation, and the direction of the      * SW defined pins. If there is no SW over-ride of the flow      * control setting, then the variable shared->fc will      * be initialized based on a value in the EEPROM.      */
name|eecd_reg
operator|=
name|em_read_eeprom
argument_list|(
name|shared
argument_list|,
name|EEPROM_INIT_CONTROL2_REG
argument_list|)
expr_stmt|;
if|if
condition|(
name|shared
operator|->
name|fc
operator|>
name|em_fc_full
condition|)
block|{
if|if
condition|(
operator|(
name|eecd_reg
operator|&
name|EEPROM_WORD0F_PAUSE_MASK
operator|)
operator|==
literal|0
condition|)
name|shared
operator|->
name|fc
operator|=
name|em_fc_none
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|eecd_reg
operator|&
name|EEPROM_WORD0F_PAUSE_MASK
operator|)
operator|==
name|EEPROM_WORD0F_ASM_DIR
condition|)
name|shared
operator|->
name|fc
operator|=
name|em_fc_tx_pause
expr_stmt|;
else|else
name|shared
operator|->
name|fc
operator|=
name|em_fc_full
expr_stmt|;
block|}
comment|/* We want to save off the original Flow Control configuration just      * in case we get disconnected and then reconnected into a different      * hub or switch with different Flow Control capabilities.      */
name|shared
operator|->
name|original_fc
operator|=
name|shared
operator|->
name|fc
expr_stmt|;
if|if
condition|(
name|shared
operator|->
name|mac_type
operator|==
name|em_82542_rev2_0
condition|)
name|shared
operator|->
name|fc
operator|&=
operator|(
operator|~
name|em_fc_tx_pause
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|shared
operator|->
name|mac_type
operator|<
name|em_82543
operator|)
operator|&&
operator|(
name|shared
operator|->
name|report_tx_early
operator|==
literal|1
operator|)
condition|)
name|shared
operator|->
name|fc
operator|&=
operator|(
operator|~
name|em_fc_rx_pause
operator|)
expr_stmt|;
name|DEBUGOUT1
argument_list|(
literal|"After fix-ups FlowControl is now = %x\n"
argument_list|,
name|shared
operator|->
name|fc
argument_list|)
expr_stmt|;
comment|/* Take the 4 bits from EEPROM word 0x0F that determine the initial      * polarity value for the SW controlled pins, and setup the      * Extended Device Control reg with that info.      * This is needed because one of the SW controlled pins is used for      * signal detection.  So this should be done before em_setup_pcs_link()      * or em_phy_setup() is called.      */
if|if
condition|(
name|shared
operator|->
name|mac_type
operator|==
name|em_82543
condition|)
block|{
name|ctrl_ext_reg
operator|=
operator|(
operator|(
name|eecd_reg
operator|&
name|EEPROM_WORD0F_SWPDIO_EXT
operator|)
operator|<<
name|SWDPIO__EXT_SHIFT
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|shared
argument_list|,
name|CTRL_EXT
argument_list|,
name|ctrl_ext_reg
argument_list|)
expr_stmt|;
block|}
comment|/* Call the necessary subroutine to configure the link. */
if|if
condition|(
name|shared
operator|->
name|media_type
operator|==
name|em_media_type_fiber
condition|)
name|status
operator|=
name|em_setup_pcs_link
argument_list|(
name|shared
argument_list|,
name|ctrl_reg
argument_list|)
expr_stmt|;
else|else
name|status
operator|=
name|em_phy_setup
argument_list|(
name|shared
argument_list|,
name|ctrl_reg
argument_list|)
expr_stmt|;
comment|/* Initialize the flow control address, type, and PAUSE timer      * registers to their default values.  This is done even if flow      * control is disabled, because it does not hurt anything to      * initialize these registers.      */
name|DEBUGOUT
argument_list|(
literal|"Initializing the Flow Control address, type and timer regs\n"
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|shared
argument_list|,
name|FCAL
argument_list|,
name|FLOW_CONTROL_ADDRESS_LOW
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|shared
argument_list|,
name|FCAH
argument_list|,
name|FLOW_CONTROL_ADDRESS_HIGH
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|shared
argument_list|,
name|FCT
argument_list|,
name|FLOW_CONTROL_TYPE
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|shared
argument_list|,
name|FCTTV
argument_list|,
name|shared
operator|->
name|fc_pause_time
argument_list|)
expr_stmt|;
comment|/* Set the flow control receive threshold registers.  Normally,      * these registers will be set to a default threshold that may be      * adjusted later by the driver's runtime code.  However, if the      * ability to transmit pause frames in not enabled, then these      * registers will be set to 0.       */
if|if
condition|(
operator|!
operator|(
name|shared
operator|->
name|fc
operator|&
name|em_fc_tx_pause
operator|)
condition|)
block|{
name|E1000_WRITE_REG
argument_list|(
name|shared
argument_list|,
name|FCRTL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|shared
argument_list|,
name|FCRTH
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* We need to set up the Receive Threshold high and low water marks          * as well as (optionally) enabling the transmission of XON frames.          */
if|if
condition|(
name|shared
operator|->
name|fc_send_xon
condition|)
block|{
name|E1000_WRITE_REG
argument_list|(
name|shared
argument_list|,
name|FCRTL
argument_list|,
operator|(
name|shared
operator|->
name|fc_low_water
operator||
name|E1000_FCRTL_XONE
operator|)
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|shared
argument_list|,
name|FCRTH
argument_list|,
name|shared
operator|->
name|fc_high_water
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|E1000_WRITE_REG
argument_list|(
name|shared
argument_list|,
name|FCRTL
argument_list|,
name|shared
operator|->
name|fc_low_water
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|shared
argument_list|,
name|FCRTH
argument_list|,
name|shared
operator|->
name|fc_high_water
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Sets up link for a fiber based adapter  *  * shared - Struct containing variables accessed by shared code  * ctrl_reg - Current value of the device control register  *  * Manipulates Physical Coding Sublayer functions in order to configure  * link. Assumes the hardware has been previously reset and the transmitter  * and receiver are not enabled.  *****************************************************************************/
end_comment

begin_function
name|boolean_t
name|em_setup_pcs_link
parameter_list|(
name|struct
name|em_shared_adapter
modifier|*
name|shared
parameter_list|,
name|uint32_t
name|ctrl_reg
parameter_list|)
block|{
name|uint32_t
name|status_reg
decl_stmt|;
name|uint32_t
name|tctl_reg
decl_stmt|;
name|uint32_t
name|txcw_reg
init|=
literal|0
decl_stmt|;
name|uint32_t
name|i
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_setup_pcs_link"
argument_list|)
expr_stmt|;
comment|/* Setup the collsion distance.  Since this is configuring the      * TBI it is assumed that we are in Full Duplex.      */
name|tctl_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|shared
argument_list|,
name|TCTL
argument_list|)
expr_stmt|;
name|i
operator|=
name|E1000_FDX_COLLISION_DISTANCE
expr_stmt|;
name|i
operator|<<=
name|E1000_COLD_SHIFT
expr_stmt|;
name|tctl_reg
operator||=
name|i
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|shared
argument_list|,
name|TCTL
argument_list|,
name|tctl_reg
argument_list|)
expr_stmt|;
comment|/* Check for a software override of the flow control settings, and      * setup the device accordingly.  If auto-negotiation is enabled,      * then software will have to set the "PAUSE" bits to the correct      * value in the Tranmsit Config Word Register (TXCW) and re-start      * auto-negotiation.  However, if auto-negotiation is disabled,      * then software will have to manually configure the two flow      * control enable bits in the CTRL register.      *      * The possible values of the "fc" parameter are:      *      0:  Flow control is completely disabled      *      1:  Rx flow control is enabled (we can receive pause frames      *          but not send pause frames).      *      2:  Tx flow control is enabled (we can send pause frames      *          but we do not support receiving pause frames).      *      3:  Both Rx and TX flow control (symmetric) are enabled.      *  other:  No software override.  The flow control configuration      *          in the EEPROM is used.      */
switch|switch
condition|(
name|shared
operator|->
name|fc
condition|)
block|{
case|case
name|em_fc_none
case|:
comment|/* 0 */
comment|/* Flow control (RX& TX) is completely disabled by a          * software over-ride.          */
name|txcw_reg
operator|=
operator|(
name|E1000_TXCW_ANE
operator||
name|E1000_TXCW_FD
operator|)
expr_stmt|;
break|break;
case|case
name|em_fc_rx_pause
case|:
comment|/* 1 */
comment|/* RX Flow control is enabled, and TX Flow control is          * disabled, by a software over-ride.          */
comment|/* Since there really isn't a way to advertise that we are          * capable of RX Pause ONLY, we will advertise that we          * support both symmetric and asymmetric RX PAUSE.  Later          * we will disable the adapter's ability to send PAUSE          * frames.          */
name|txcw_reg
operator|=
operator|(
name|E1000_TXCW_ANE
operator||
name|E1000_TXCW_FD
operator||
name|E1000_TXCW_PAUSE_MASK
operator|)
expr_stmt|;
break|break;
case|case
name|em_fc_tx_pause
case|:
comment|/* 2 */
comment|/* TX Flow control is enabled, and RX Flow control is          * disabled, by a software over-ride.          */
name|txcw_reg
operator|=
operator|(
name|E1000_TXCW_ANE
operator||
name|E1000_TXCW_FD
operator||
name|E1000_TXCW_ASM_DIR
operator|)
expr_stmt|;
break|break;
case|case
name|em_fc_full
case|:
comment|/* 3 */
comment|/* Flow control (both RX and TX) is enabled by a software          * over-ride.          */
name|txcw_reg
operator|=
operator|(
name|E1000_TXCW_ANE
operator||
name|E1000_TXCW_FD
operator||
name|E1000_TXCW_PAUSE_MASK
operator|)
expr_stmt|;
break|break;
default|default:
comment|/* We should never get here.  The value should be 0-3. */
name|DEBUGOUT
argument_list|(
literal|"Flow control param set incorrectly\n"
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Since auto-negotiation is enabled, take the link out of reset.      * (the link will be in reset, because we previously reset the      * chip). This will restart auto-negotiation.  If auto-neogtiation      * is successful then the link-up status bit will be set and the      * flow control enable bits (RFCE and TFCE) will be set according      * to their negotiated value.      */
name|DEBUGOUT
argument_list|(
literal|"Auto-negotiation enabled\n"
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|shared
argument_list|,
name|TXCW
argument_list|,
name|txcw_reg
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|shared
argument_list|,
name|CTRL
argument_list|,
name|ctrl_reg
argument_list|)
expr_stmt|;
name|shared
operator|->
name|txcw_reg
operator|=
name|txcw_reg
expr_stmt|;
name|msec_delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* If we have a signal then poll for a "Link-Up" indication in the      * Device Status Register.   Time-out if a link isn't seen in 500      * milliseconds seconds (Auto-negotiation should complete in less      * than 500 milliseconds even if the other end is doing it in SW).      */
if|if
condition|(
operator|!
operator|(
name|E1000_READ_REG
argument_list|(
name|shared
argument_list|,
name|CTRL
argument_list|)
operator|&
name|E1000_CTRL_SWDPIN1
operator|)
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Looking for Link\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|LINK_UP_TIMEOUT
operator|/
literal|10
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|msec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|status_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|shared
argument_list|,
name|STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
name|status_reg
operator|&
name|E1000_STATUS_LU
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
operator|(
name|LINK_UP_TIMEOUT
operator|/
literal|10
operator|)
condition|)
block|{
comment|/* AutoNeg failed to achieve a link, so we'll call the              * "CheckForLink" routine.  This routine will force the link              * up if we have "signal-detect".  This will allow us to              * communicate with non-autonegotiating link partners.              */
name|DEBUGOUT
argument_list|(
literal|"Never got a valid link from auto-neg!!!\n"
argument_list|)
expr_stmt|;
name|shared
operator|->
name|autoneg_failed
operator|=
literal|1
expr_stmt|;
name|em_check_for_link
argument_list|(
name|shared
argument_list|)
expr_stmt|;
name|shared
operator|->
name|autoneg_failed
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|shared
operator|->
name|autoneg_failed
operator|=
literal|0
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Valid Link Found\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|DEBUGOUT
argument_list|(
literal|"No Signal Detected\n"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Configures flow control settings after link is established  *   * shared - Struct containing variables accessed by shared code  *  * Should be called immediately after a valid link has been established.  * Forces MAC flow control settings if link was forced. When in MII/GMII mode  * and autonegotiation is enabled, the MAC flow control settings will be set  * based on the flow control negotiated by the PHY. In TBI mode, the TFCE  * and RFCE bits will be automaticaly set to the negotiated flow control mode.  *****************************************************************************/
end_comment

begin_function
name|void
name|em_config_fc_after_link_up
parameter_list|(
name|struct
name|em_shared_adapter
modifier|*
name|shared
parameter_list|)
block|{
name|uint16_t
name|mii_status_reg
decl_stmt|;
name|uint16_t
name|mii_nway_adv_reg
decl_stmt|;
name|uint16_t
name|mii_nway_lp_ability_reg
decl_stmt|;
name|uint16_t
name|speed
decl_stmt|;
name|uint16_t
name|duplex
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_config_fc_after_link_up"
argument_list|)
expr_stmt|;
comment|/* Check for the case where we have fiber media and auto-neg failed      * so we had to force link.  In this case, we need to force the      * configuration of the MAC to match the "fc" parameter.      */
if|if
condition|(
operator|(
operator|(
name|shared
operator|->
name|media_type
operator|==
name|em_media_type_fiber
operator|)
operator|&&
operator|(
name|shared
operator|->
name|autoneg_failed
operator|)
operator|)
operator|||
operator|(
operator|(
name|shared
operator|->
name|media_type
operator|==
name|em_media_type_copper
operator|)
operator|&&
operator|(
operator|!
name|shared
operator|->
name|autoneg
operator|)
operator|)
condition|)
block|{
name|em_force_mac_fc
argument_list|(
name|shared
argument_list|)
expr_stmt|;
block|}
comment|/* Check for the case where we have copper media and auto-neg is      * enabled.  In this case, we need to check and see if Auto-Neg      * has completed, and if so, how the PHY and link partner has      * flow control configured.      */
if|if
condition|(
operator|(
name|shared
operator|->
name|media_type
operator|==
name|em_media_type_copper
operator|)
operator|&&
name|shared
operator|->
name|autoneg
condition|)
block|{
comment|/* Read the MII Status Register and check to see if AutoNeg          * has completed.  We read this twice because this reg has          * some "sticky" (latched) bits.          */
name|mii_status_reg
operator|=
name|em_read_phy_reg
argument_list|(
name|shared
argument_list|,
name|PHY_STATUS
argument_list|)
expr_stmt|;
name|mii_status_reg
operator|=
name|em_read_phy_reg
argument_list|(
name|shared
argument_list|,
name|PHY_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
name|mii_status_reg
operator|&
name|MII_SR_AUTONEG_COMPLETE
condition|)
block|{
comment|/* The AutoNeg process has completed, so we now need to              * read both the Auto Negotiation Advertisement Register              * (Address 4) and the Auto_Negotiation Base Page Ability              * Register (Address 5) to determine how flow control was              * negotiated.              */
name|mii_nway_adv_reg
operator|=
name|em_read_phy_reg
argument_list|(
name|shared
argument_list|,
name|PHY_AUTONEG_ADV
argument_list|)
expr_stmt|;
name|mii_nway_lp_ability_reg
operator|=
name|em_read_phy_reg
argument_list|(
name|shared
argument_list|,
name|PHY_LP_ABILITY
argument_list|)
expr_stmt|;
comment|/* Two bits in the Auto Negotiation Advertisement Register              * (Address 4) and two bits in the Auto Negotiation Base              * Page Ability Register (Address 5) determine flow control              * for both the PHY and the link partner.  The following              * table, taken out of the IEEE 802.3ab/D6.0 dated March 25,              * 1999, describes these PAUSE resolution bits and how flow              * control is determined based upon these settings.              * NOTE:  DC = Don't Care              *              *   LOCAL DEVICE  |   LINK PARTNER              * PAUSE | ASM_DIR | PAUSE | ASM_DIR | NIC Resolution              *-------|---------|-------|---------|--------------------              *   0   |    0    |  DC   |   DC    | em_fc_none              *   0   |    1    |   0   |   DC    | em_fc_none              *   0   |    1    |   1   |    0    | em_fc_none              *   0   |    1    |   1   |    1    | em_fc_tx_pause              *   1   |    0    |   0   |   DC    | em_fc_none              *   1   |   DC    |   1   |   DC    | em_fc_full              *   1   |    1    |   0   |    0    | em_fc_none              *   1   |    1    |   0   |    1    | em_fc_rx_pause              *              */
comment|/* Are both PAUSE bits set to 1?  If so, this implies              * Symmetric Flow Control is enabled at both ends.  The              * ASM_DIR bits are irrelevant per the spec.              *              * For Symmetric Flow Control:              *              *   LOCAL DEVICE  |   LINK PARTNER              * PAUSE | ASM_DIR | PAUSE | ASM_DIR | Result              *-------|---------|-------|---------|--------------------              *   1   |   DC    |   1   |   DC    | em_fc_full              *              */
if|if
condition|(
operator|(
name|mii_nway_adv_reg
operator|&
name|NWAY_AR_PAUSE
operator|)
operator|&&
operator|(
name|mii_nway_lp_ability_reg
operator|&
name|NWAY_LPAR_PAUSE
operator|)
condition|)
block|{
comment|/* Now we need to check if the user selected RX ONLY                  * of pause frames.  In this case, we had to advertise                  * FULL flow control because we could not advertise RX                  * ONLY. Hence, we must now check to see if we need to                  * turn OFF  the TRANSMISSION of PAUSE frames.                  */
if|if
condition|(
name|shared
operator|->
name|original_fc
operator|==
name|em_fc_full
condition|)
block|{
name|shared
operator|->
name|fc
operator|=
name|em_fc_full
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Flow Control = FULL.\r\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|shared
operator|->
name|fc
operator|=
name|em_fc_rx_pause
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Flow Control = RX PAUSE frames only.\r\n"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* For receiving PAUSE frames ONLY.              *              *   LOCAL DEVICE  |   LINK PARTNER              * PAUSE | ASM_DIR | PAUSE | ASM_DIR | Result              *-------|---------|-------|---------|--------------------              *   0   |    1    |   1   |    1    | em_fc_tx_pause              *              */
elseif|else
if|if
condition|(
operator|!
operator|(
name|mii_nway_adv_reg
operator|&
name|NWAY_AR_PAUSE
operator|)
operator|&&
operator|(
name|mii_nway_adv_reg
operator|&
name|NWAY_AR_ASM_DIR
operator|)
operator|&&
operator|(
name|mii_nway_lp_ability_reg
operator|&
name|NWAY_LPAR_PAUSE
operator|)
operator|&&
operator|(
name|mii_nway_lp_ability_reg
operator|&
name|NWAY_LPAR_ASM_DIR
operator|)
condition|)
block|{
name|shared
operator|->
name|fc
operator|=
name|em_fc_tx_pause
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Flow Control = TX PAUSE frames only.\r\n"
argument_list|)
expr_stmt|;
block|}
comment|/* For transmitting PAUSE frames ONLY.              *              *   LOCAL DEVICE  |   LINK PARTNER              * PAUSE | ASM_DIR | PAUSE | ASM_DIR | Result              *-------|---------|-------|---------|--------------------              *   1   |    1    |   0   |    1    | em_fc_rx_pause              *              */
elseif|else
if|if
condition|(
operator|(
name|mii_nway_adv_reg
operator|&
name|NWAY_AR_PAUSE
operator|)
operator|&&
operator|(
name|mii_nway_adv_reg
operator|&
name|NWAY_AR_ASM_DIR
operator|)
operator|&&
operator|!
operator|(
name|mii_nway_lp_ability_reg
operator|&
name|NWAY_LPAR_PAUSE
operator|)
operator|&&
operator|(
name|mii_nway_lp_ability_reg
operator|&
name|NWAY_LPAR_ASM_DIR
operator|)
condition|)
block|{
name|shared
operator|->
name|fc
operator|=
name|em_fc_rx_pause
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Flow Control = RX PAUSE frames only.\r\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Per the IEEE spec, at this point flow control should be              * disabled.  However, we want to consider that we could              * be connected to a legacy switch that doesn't advertise              * desired flow control, but can be forced on the link              * partner.  So if we advertised no flow control, that is              * what we will resolve to.  If we advertised some kind of              * receive capability (Rx Pause Only or Full Flow Control)              * and the link partner advertised none, we will configure              * ourselves to enable Rx Flow Control only.  We can do              * this safely for two reasons:  If the link partner really              * didn't want flow control enabled, and we enable Rx, no              * harm done since we won't be receiving any PAUSE frames              * anyway.  If the intent on the link partner was to have              * flow control enabled, then by us enabling RX only, we              * can at least receive pause frames and process them.              * This is a good idea because in most cases, since we are              * predominantly a server NIC, more times than not we will              * be asked to delay transmission of packets than asking              * our link partner to pause transmission of frames.              */
elseif|else
if|if
condition|(
name|shared
operator|->
name|original_fc
operator|==
name|em_fc_none
operator|||
name|shared
operator|->
name|original_fc
operator|==
name|em_fc_tx_pause
condition|)
block|{
name|shared
operator|->
name|fc
operator|=
name|em_fc_none
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Flow Control = NONE.\r\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|shared
operator|->
name|fc
operator|=
name|em_fc_rx_pause
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Flow Control = RX PAUSE frames only.\r\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Now we need to do one last check...  If we auto-              * negotiated to HALF DUPLEX, flow control should not be              * enabled per IEEE 802.3 spec.              */
name|em_get_speed_and_duplex
argument_list|(
name|shared
argument_list|,
operator|&
name|speed
argument_list|,
operator|&
name|duplex
argument_list|)
expr_stmt|;
if|if
condition|(
name|duplex
operator|==
name|HALF_DUPLEX
condition|)
name|shared
operator|->
name|fc
operator|=
name|em_fc_none
expr_stmt|;
comment|/* Now we call a subroutine to actually force the MAC              * controller to use the correct flow control settings.              */
name|em_force_mac_fc
argument_list|(
name|shared
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DEBUGOUT
argument_list|(
literal|"Copper PHY and Auto Neg has not completed.\r\n"
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Checks to see if the link status of the hardware has changed.  *  * shared - Struct containing variables accessed by shared code  *  * Called by any function that needs to check the link status of the adapter.  *****************************************************************************/
end_comment

begin_function
name|void
name|em_check_for_link
parameter_list|(
name|struct
name|em_shared_adapter
modifier|*
name|shared
parameter_list|)
block|{
name|uint32_t
name|rxcw_reg
decl_stmt|;
name|uint32_t
name|ctrl_reg
decl_stmt|;
name|uint32_t
name|status_reg
decl_stmt|;
name|uint32_t
name|rctl_reg
decl_stmt|;
name|uint16_t
name|phy_data
decl_stmt|;
name|uint16_t
name|lp_capability
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_check_for_link"
argument_list|)
expr_stmt|;
name|ctrl_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|shared
argument_list|,
name|CTRL
argument_list|)
expr_stmt|;
name|status_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|shared
argument_list|,
name|STATUS
argument_list|)
expr_stmt|;
name|rxcw_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|shared
argument_list|,
name|RXCW
argument_list|)
expr_stmt|;
comment|/* If we have a copper PHY then we only want to go out to the PHY      * registers to see if Auto-Neg has completed and/or if our link      * status has changed.  The get_link_status flag will be set if we      * receive a Link Status Change interrupt or we have Rx Sequence      * Errors.      */
if|if
condition|(
name|shared
operator|->
name|media_type
operator|==
name|em_media_type_copper
operator|&&
name|shared
operator|->
name|get_link_status
condition|)
block|{
comment|/* First we want to see if the MII Status Register reports          * link.  If so, then we want to get the current speed/duplex          * of the PHY.          * Read the register twice since the link bit is sticky.          */
name|phy_data
operator|=
name|em_read_phy_reg
argument_list|(
name|shared
argument_list|,
name|PHY_STATUS
argument_list|)
expr_stmt|;
name|phy_data
operator|=
name|em_read_phy_reg
argument_list|(
name|shared
argument_list|,
name|PHY_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy_data
operator|&
name|MII_SR_LINK_STATUS
condition|)
block|{
name|shared
operator|->
name|get_link_status
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
name|DEBUGOUT
argument_list|(
literal|"**** CFL - No link detected. ****\r\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If we are forcing speed/duplex, then we simply return since          * we have already determined whether we have link or not.          */
if|if
condition|(
operator|!
name|shared
operator|->
name|autoneg
condition|)
block|{
return|return;
block|}
switch|switch
condition|(
name|shared
operator|->
name|phy_id
condition|)
block|{
case|case
name|M88E1000_12_PHY_ID
case|:
case|case
name|M88E1000_14_PHY_ID
case|:
case|case
name|M88E1000_I_PHY_ID
case|:
case|case
name|M88E1011_I_PHY_ID
case|:
comment|/* We have a M88E1000 PHY and Auto-Neg is enabled.  If we              * have Si on board that is 82544 or newer, Auto              * Speed Detection takes care of MAC speed/duplex              * configuration.  So we only need to configure Collision              * Distance in the MAC.  Otherwise, we need to force              * speed/duplex on the MAC to the current PHY speed/duplex              * settings.              */
if|if
condition|(
name|shared
operator|->
name|mac_type
operator|>=
name|em_82544
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"CFL - Auto-Neg complete."
argument_list|)
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Configuring Collision Distance."
argument_list|)
expr_stmt|;
name|em_config_collision_dist
argument_list|(
name|shared
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Read the Phy Specific Status register to get the                  * resolved speed/duplex settings.  Then call                  * em_config_mac_to_phy which will retrieve                  * PHY register information and configure the MAC to                  * equal the negotiated speed/duplex.                  */
name|phy_data
operator|=
name|em_read_phy_reg
argument_list|(
name|shared
argument_list|,
name|M88E1000_PHY_SPEC_STATUS
argument_list|)
expr_stmt|;
name|DEBUGOUT1
argument_list|(
literal|"CFL - Auto-Neg complete.  phy_data = %x\r\n"
argument_list|,
name|phy_data
argument_list|)
expr_stmt|;
name|em_config_mac_to_phy
argument_list|(
name|shared
argument_list|,
name|phy_data
argument_list|)
expr_stmt|;
block|}
comment|/* Configure Flow Control now that Auto-Neg has completed.              * We need to first restore the users desired Flow              * Control setting since we may have had to re-autoneg              * with a different link partner.              */
name|em_config_fc_after_link_up
argument_list|(
name|shared
argument_list|)
expr_stmt|;
break|break;
default|default:
name|DEBUGOUT
argument_list|(
literal|"CFL - Invalid PHY detected.\r\n"
argument_list|)
expr_stmt|;
block|}
comment|/* end switch statement */
comment|/* At this point we know that we are on copper, link is up,           * and we are auto-neg'd.  These are pre-conditions for checking          * the link parter capabilities register.  We use the link partner          * capabilities to determine if TBI Compatibility needs to be turned on          * or turned off.  If the link partner advertises any speed in addition          * to Gigabit, then we assume that they are GMII-based and TBI           * compatibility is not needed.          * If no other speeds are advertised, then we assume the link partner          * is TBI-based and we turn on TBI Compatibility.          */
if|if
condition|(
name|shared
operator|->
name|tbi_compatibility_en
condition|)
block|{
name|lp_capability
operator|=
name|em_read_phy_reg
argument_list|(
name|shared
argument_list|,
name|PHY_LP_ABILITY
argument_list|)
expr_stmt|;
if|if
condition|(
name|lp_capability
operator|&
operator|(
name|NWAY_LPAR_10T_HD_CAPS
operator||
name|NWAY_LPAR_10T_FD_CAPS
operator||
name|NWAY_LPAR_100TX_HD_CAPS
operator||
name|NWAY_LPAR_100TX_FD_CAPS
operator||
name|NWAY_LPAR_100T4_CAPS
operator|)
condition|)
block|{
comment|/* If our link partner advertises below Gig, then they do not                  * need the special Tbi Compatibility mode.                   */
if|if
condition|(
name|shared
operator|->
name|tbi_compatibility_on
condition|)
block|{
comment|/* If we previously were in the mode, turn it off, now. */
name|rctl_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|shared
argument_list|,
name|RCTL
argument_list|)
expr_stmt|;
name|rctl_reg
operator|&=
operator|~
name|E1000_RCTL_SBP
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|shared
argument_list|,
name|RCTL
argument_list|,
name|rctl_reg
argument_list|)
expr_stmt|;
name|shared
operator|->
name|tbi_compatibility_on
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* If the mode is was previously off, turn it on.                   * For compatibility with a suspected Tbi link partners,                   * we will store bad packets.                  * (Certain frames have an additional byte on the end and will                   * look like CRC errors to to the hardware).                  */
if|if
condition|(
operator|!
name|shared
operator|->
name|tbi_compatibility_on
condition|)
block|{
name|shared
operator|->
name|tbi_compatibility_on
operator|=
name|TRUE
expr_stmt|;
name|rctl_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|shared
argument_list|,
name|RCTL
argument_list|)
expr_stmt|;
name|rctl_reg
operator||=
name|E1000_RCTL_SBP
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|shared
argument_list|,
name|RCTL
argument_list|,
name|rctl_reg
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* end if em_media_type_copper statement */
comment|/* If we don't have link (auto-negotiation failed or link partner      * cannot auto-negotiate) and the cable is plugged in since we don't      * have Loss-Of-Signal (we HAVE a signal) and our link partner is      * not trying to AutoNeg with us (we are receiving idles/data      * then we need to force our link to connect to a non      * auto-negotiating link partner.  We also need to give      * auto-negotiation time to complete in case the cable was just      * plugged in.  The autoneg_failed flag does this.      */
elseif|else
if|if
condition|(
operator|(
name|shared
operator|->
name|media_type
operator|==
name|em_media_type_fiber
operator|)
operator|&&
comment|/* Fiber PHY */
operator|(
operator|!
operator|(
name|status_reg
operator|&
name|E1000_STATUS_LU
operator|)
operator|)
operator|&&
comment|/* no link and    */
operator|(
operator|!
operator|(
name|ctrl_reg
operator|&
name|E1000_CTRL_SWDPIN1
operator|)
operator|)
operator|&&
comment|/* we have signal */
operator|(
operator|!
operator|(
name|rxcw_reg
operator|&
name|E1000_RXCW_C
operator|)
operator|)
condition|)
block|{
comment|/* and rxing idle/data */
if|if
condition|(
name|shared
operator|->
name|autoneg_failed
operator|==
literal|0
condition|)
block|{
comment|/* given AutoNeg time */
name|shared
operator|->
name|autoneg_failed
operator|=
literal|1
expr_stmt|;
return|return;
block|}
name|DEBUGOUT
argument_list|(
literal|"NOT RXing /C/, disable AutoNeg and force link.\r\n"
argument_list|)
expr_stmt|;
comment|/* Disable auto-negotiation in the TXCW register */
name|E1000_WRITE_REG
argument_list|(
name|shared
argument_list|,
name|TXCW
argument_list|,
operator|(
name|shared
operator|->
name|txcw_reg
operator|&
operator|~
name|E1000_TXCW_ANE
operator|)
argument_list|)
expr_stmt|;
comment|/* Force link-up and also force full-duplex. */
name|ctrl_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|shared
argument_list|,
name|CTRL
argument_list|)
expr_stmt|;
name|ctrl_reg
operator||=
operator|(
name|E1000_CTRL_SLU
operator||
name|E1000_CTRL_FD
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|shared
argument_list|,
name|CTRL
argument_list|,
name|ctrl_reg
argument_list|)
expr_stmt|;
comment|/* Configure Flow Control after forcing link up. */
name|em_config_fc_after_link_up
argument_list|(
name|shared
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|shared
operator|->
name|media_type
operator|==
name|em_media_type_fiber
operator|)
operator|&&
comment|/* Fiber */
operator|(
name|ctrl_reg
operator|&
name|E1000_CTRL_SLU
operator|)
operator|&&
comment|/* we have forced link */
operator|(
name|rxcw_reg
operator|&
name|E1000_RXCW_C
operator|)
condition|)
block|{
comment|/* and Rxing /C/ ordered sets */
comment|/* If we are forcing link and we are receiving /C/ ordered sets,          * then re-enable auto-negotiation in the RXCW register and          * disable forced link in the Device Control register in an attempt          * to AutoNeg with our link partner.          */
name|DEBUGOUT
argument_list|(
literal|"RXing /C/, enable AutoNeg and stop forcing link.\r\n"
argument_list|)
expr_stmt|;
comment|/* Enable auto-negotiation in the TXCW register and stop          * forcing link.          */
name|E1000_WRITE_REG
argument_list|(
name|shared
argument_list|,
name|TXCW
argument_list|,
name|shared
operator|->
name|txcw_reg
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|shared
argument_list|,
name|CTRL
argument_list|,
operator|(
name|ctrl_reg
operator|&
operator|~
name|E1000_CTRL_SLU
operator|)
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Clears all hardware statistics counters.   *  * shared - Struct containing variables accessed by shared code  *****************************************************************************/
end_comment

begin_function
name|void
name|em_clear_hw_cntrs
parameter_list|(
name|struct
name|em_shared_adapter
modifier|*
name|shared
parameter_list|)
block|{
specifier|volatile
name|uint32_t
name|temp_reg
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_clear_hw_cntrs"
argument_list|)
expr_stmt|;
comment|/* if we are stopped or resetting exit gracefully */
if|if
condition|(
name|shared
operator|->
name|adapter_stopped
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Exiting because the adapter is stopped!!!\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|temp_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|shared
argument_list|,
name|CRCERRS
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|shared
argument_list|,
name|SYMERRS
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|shared
argument_list|,
name|MPC
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|shared
argument_list|,
name|SCC
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|shared
argument_list|,
name|ECOL
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|shared
argument_list|,
name|MCC
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|shared
argument_list|,
name|LATECOL
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|shared
argument_list|,
name|COLC
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|shared
argument_list|,
name|DC
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|shared
argument_list|,
name|SEC
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|shared
argument_list|,
name|RLEC
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|shared
argument_list|,
name|XONRXC
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|shared
argument_list|,
name|XONTXC
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|shared
argument_list|,
name|XOFFRXC
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|shared
argument_list|,
name|XOFFTXC
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|shared
argument_list|,
name|FCRUC
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|shared
argument_list|,
name|PRC64
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|shared
argument_list|,
name|PRC127
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|shared
argument_list|,
name|PRC255
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|shared
argument_list|,
name|PRC511
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|shared
argument_list|,
name|PRC1023
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|shared
argument_list|,
name|PRC1522
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|shared
argument_list|,
name|GPRC
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|shared
argument_list|,
name|BPRC
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|shared
argument_list|,
name|MPRC
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|shared
argument_list|,
name|GPTC
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|shared
argument_list|,
name|GORCL
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|shared
argument_list|,
name|GORCH
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|shared
argument_list|,
name|GOTCL
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|shared
argument_list|,
name|GOTCH
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|shared
argument_list|,
name|RNBC
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|shared
argument_list|,
name|RUC
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|shared
argument_list|,
name|RFC
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|shared
argument_list|,
name|ROC
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|shared
argument_list|,
name|RJC
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|shared
argument_list|,
name|TORL
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|shared
argument_list|,
name|TORH
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|shared
argument_list|,
name|TOTL
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|shared
argument_list|,
name|TOTH
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|shared
argument_list|,
name|TPR
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|shared
argument_list|,
name|TPT
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|shared
argument_list|,
name|PTC64
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|shared
argument_list|,
name|PTC127
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|shared
argument_list|,
name|PTC255
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|shared
argument_list|,
name|PTC511
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|shared
argument_list|,
name|PTC1023
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|shared
argument_list|,
name|PTC1522
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|shared
argument_list|,
name|MPTC
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|shared
argument_list|,
name|BPTC
argument_list|)
expr_stmt|;
if|if
condition|(
name|shared
operator|->
name|mac_type
operator|<
name|em_82543
condition|)
return|return;
name|temp_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|shared
argument_list|,
name|ALGNERRC
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|shared
argument_list|,
name|RXERRC
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|shared
argument_list|,
name|TNCRS
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|shared
argument_list|,
name|CEXTERR
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|shared
argument_list|,
name|TSCTC
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|shared
argument_list|,
name|TSCTFC
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Detects the current speed and duplex settings of the hardware.  *  * shared - Struct containing variables accessed by shared code  * speed - Speed of the connection  * duplex - Duplex setting of the connection  *****************************************************************************/
end_comment

begin_function
name|void
name|em_get_speed_and_duplex
parameter_list|(
name|struct
name|em_shared_adapter
modifier|*
name|shared
parameter_list|,
name|uint16_t
modifier|*
name|speed
parameter_list|,
name|uint16_t
modifier|*
name|duplex
parameter_list|)
block|{
name|uint32_t
name|status_reg
decl_stmt|;
if|#
directive|if
name|DBG
name|uint16_t
name|phy_data
decl_stmt|;
endif|#
directive|endif
name|DEBUGFUNC
argument_list|(
literal|"em_get_speed_and_duplex"
argument_list|)
expr_stmt|;
comment|/* If the adapter is stopped we don't have a speed or duplex */
if|if
condition|(
name|shared
operator|->
name|adapter_stopped
condition|)
block|{
operator|*
name|speed
operator|=
literal|0
expr_stmt|;
operator|*
name|duplex
operator|=
literal|0
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|shared
operator|->
name|mac_type
operator|>=
name|em_82543
condition|)
block|{
name|status_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|shared
argument_list|,
name|STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
name|status_reg
operator|&
name|E1000_STATUS_SPEED_1000
condition|)
block|{
operator|*
name|speed
operator|=
name|SPEED_1000
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"1000 Mbs, "
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|status_reg
operator|&
name|E1000_STATUS_SPEED_100
condition|)
block|{
operator|*
name|speed
operator|=
name|SPEED_100
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"100 Mbs, "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|speed
operator|=
name|SPEED_10
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"10 Mbs, "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status_reg
operator|&
name|E1000_STATUS_FD
condition|)
block|{
operator|*
name|duplex
operator|=
name|FULL_DUPLEX
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Full Duplex\r\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|duplex
operator|=
name|HALF_DUPLEX
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|" Half Duplex\r\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|DEBUGOUT
argument_list|(
literal|"1000 Mbs, Full Duplex\r\n"
argument_list|)
expr_stmt|;
operator|*
name|speed
operator|=
name|SPEED_1000
expr_stmt|;
operator|*
name|duplex
operator|=
name|FULL_DUPLEX
expr_stmt|;
block|}
if|#
directive|if
name|DBG
if|if
condition|(
name|shared
operator|->
name|phy_id
operator|==
name|M88E1000_12_PHY_ID
operator|||
name|shared
operator|->
name|phy_id
operator|==
name|M88E1000_14_PHY_ID
operator|||
name|shared
operator|->
name|phy_id
operator|==
name|M88E1000_I_PHY_ID
operator|||
name|shared
operator|->
name|phy_id
operator|==
name|M88E1011_I_PHY_ID
condition|)
block|{
comment|/* read the phy specific status register */
name|phy_data
operator|=
name|em_read_phy_reg
argument_list|(
name|shared
argument_list|,
name|M88E1000_PHY_SPEC_STATUS
argument_list|)
expr_stmt|;
name|DEBUGOUT1
argument_list|(
literal|"M88E1000 Phy Specific Status Reg contents = %x\n"
argument_list|,
name|phy_data
argument_list|)
expr_stmt|;
name|phy_data
operator|=
name|em_read_phy_reg
argument_list|(
name|shared
argument_list|,
name|PHY_STATUS
argument_list|)
expr_stmt|;
name|DEBUGOUT1
argument_list|(
literal|"Phy MII Status Reg contents = %x\n"
argument_list|,
name|phy_data
argument_list|)
expr_stmt|;
name|DEBUGOUT1
argument_list|(
literal|"Device Status Reg contents = %x\n"
argument_list|,
name|E1000_READ_REG
argument_list|(
name|shared
argument_list|,
name|STATUS
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Reads a 16 bit word from the EEPROM.  *  * shared - Struct containing variables accessed by shared code  * offset - offset of 16 bit word in the EEPROM to read  *****************************************************************************/
end_comment

begin_function
name|uint16_t
name|em_read_eeprom
parameter_list|(
name|struct
name|em_shared_adapter
modifier|*
name|shared
parameter_list|,
name|uint16_t
name|offset
parameter_list|)
block|{
name|boolean_t
name|large_eeprom
init|=
name|FALSE
decl_stmt|;
name|uint16_t
name|data
decl_stmt|;
name|uint32_t
name|eecd_reg
decl_stmt|;
name|uint32_t
name|tmp
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|shared
operator|->
name|mac_type
operator|>
name|em_82544
operator|)
operator|&&
operator|(
name|E1000_READ_REG
argument_list|(
name|shared
argument_list|,
name|EECD
argument_list|)
operator|&
name|E1000_EECD_SIZE
operator|)
condition|)
name|large_eeprom
operator|=
name|TRUE
expr_stmt|;
comment|/* Request EEPROM Access */
if|if
condition|(
name|shared
operator|->
name|mac_type
operator|>
name|em_82544
condition|)
block|{
name|E1000_WRITE_REG
argument_list|(
name|shared
argument_list|,
name|EECD
argument_list|,
operator|(
name|uint32_t
operator|)
name|E1000_EECD_REQ
argument_list|)
expr_stmt|;
name|eecd_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|shared
argument_list|,
name|EECD
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
operator|!
operator|(
name|eecd_reg
operator|&
name|E1000_EECD_GNT
operator|)
operator|)
operator|&&
operator|(
name|tmp
operator|<
literal|100
operator|)
condition|)
block|{
name|tmp
operator|++
expr_stmt|;
name|usec_delay
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|eecd_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|shared
argument_list|,
name|EECD
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|eecd_reg
operator|&
name|E1000_EECD_GNT
operator|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
comment|/*  Prepare the EEPROM for reading  */
name|em_setup_eeprom
argument_list|(
name|shared
argument_list|)
expr_stmt|;
comment|/*  Send the READ command (opcode + addr)  */
name|em_shift_out_bits
argument_list|(
name|shared
argument_list|,
name|EEPROM_READ_OPCODE
argument_list|,
literal|3
argument_list|)
expr_stmt|;
comment|/* If we have a 256 word EEPROM, there are 8 address bits      * if we have a 64 word EEPROM, there are 6 address bits      */
if|if
condition|(
name|large_eeprom
condition|)
name|em_shift_out_bits
argument_list|(
name|shared
argument_list|,
name|offset
argument_list|,
literal|8
argument_list|)
expr_stmt|;
else|else
name|em_shift_out_bits
argument_list|(
name|shared
argument_list|,
name|offset
argument_list|,
literal|6
argument_list|)
expr_stmt|;
comment|/* Read the data */
name|data
operator|=
name|em_shift_in_bits
argument_list|(
name|shared
argument_list|)
expr_stmt|;
comment|/* End this read operation */
name|em_standby_eeprom
argument_list|(
name|shared
argument_list|)
expr_stmt|;
comment|/* Stop requestiong EEPROM access */
if|if
condition|(
name|shared
operator|->
name|mac_type
operator|>
name|em_82544
condition|)
name|E1000_WRITE_REG
argument_list|(
name|shared
argument_list|,
name|EECD
argument_list|,
operator|(
name|uint32_t
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|data
operator|)
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Verifies that the EEPROM has a valid checksum  *   * shared - Struct containing variables accessed by shared code  *  * Reads the first 64 16 bit words of the EEPROM and sums the values read.  * If the the sum of the 64 16 bit words is 0xBABA, the EEPROM's checksum is  * valid.  *****************************************************************************/
end_comment

begin_function
name|boolean_t
name|em_validate_eeprom_checksum
parameter_list|(
name|struct
name|em_shared_adapter
modifier|*
name|shared
parameter_list|)
block|{
name|uint16_t
name|checksum
init|=
literal|0
decl_stmt|;
name|uint16_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|EEPROM_CHECKSUM_REG
operator|+
literal|1
operator|)
condition|;
name|i
operator|++
control|)
name|checksum
operator|+=
name|em_read_eeprom
argument_list|(
name|shared
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|checksum
operator|==
operator|(
name|uint16_t
operator|)
name|EEPROM_SUM
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
else|else
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Calculates the EEPROM checksum and writes it to the EEPROM  *  * shared - Struct containing variables accessed by shared code  *  * Sums the first 63 16 bit words of the EEPROM. Subtracts the sum from 0xBABA.  * Writes the difference to word offset 63 of the EEPROM.  *****************************************************************************/
end_comment

begin_function
name|void
name|em_update_eeprom_checksum
parameter_list|(
name|struct
name|em_shared_adapter
modifier|*
name|shared
parameter_list|)
block|{
name|uint16_t
name|checksum
init|=
literal|0
decl_stmt|;
name|uint16_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|EEPROM_CHECKSUM_REG
condition|;
name|i
operator|++
control|)
name|checksum
operator|+=
name|em_read_eeprom
argument_list|(
name|shared
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|checksum
operator|=
operator|(
name|uint16_t
operator|)
name|EEPROM_SUM
operator|-
name|checksum
expr_stmt|;
name|em_write_eeprom
argument_list|(
name|shared
argument_list|,
name|EEPROM_CHECKSUM_REG
argument_list|,
name|checksum
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Writes a 16 bit word to a given offset in the EEPROM.  *  * shared - Struct containing variables accessed by shared code  * offset - offset within the EEPROM to be written to  * data - 16 bit word to be writen to the EEPROM  *  * If em_update_eeprom_checksum is not called after this function, the   * EEPROM will most likely contain an invalid checksum.  *****************************************************************************/
end_comment

begin_function
name|boolean_t
name|em_write_eeprom
parameter_list|(
name|struct
name|em_shared_adapter
modifier|*
name|shared
parameter_list|,
name|uint16_t
name|offset
parameter_list|,
name|uint16_t
name|data
parameter_list|)
block|{
name|boolean_t
name|large_eeprom
init|=
name|FALSE
decl_stmt|;
name|uint32_t
name|eecd_reg
decl_stmt|;
name|uint32_t
name|tmp
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|shared
operator|->
name|mac_type
operator|>
name|em_82544
operator|)
operator|&&
operator|(
name|E1000_READ_REG
argument_list|(
name|shared
argument_list|,
name|EECD
argument_list|)
operator|&
name|E1000_EECD_SIZE
operator|)
condition|)
name|large_eeprom
operator|=
name|TRUE
expr_stmt|;
comment|/* Request EEPROM Access */
if|if
condition|(
name|shared
operator|->
name|mac_type
operator|>
name|em_82544
condition|)
block|{
name|E1000_WRITE_REG
argument_list|(
name|shared
argument_list|,
name|EECD
argument_list|,
operator|(
name|uint32_t
operator|)
name|E1000_EECD_REQ
argument_list|)
expr_stmt|;
name|eecd_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|shared
argument_list|,
name|EECD
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
operator|!
operator|(
name|eecd_reg
operator|&
name|E1000_EECD_GNT
operator|)
operator|)
operator|&&
operator|(
name|tmp
operator|<
literal|100
operator|)
condition|)
block|{
name|tmp
operator|++
expr_stmt|;
name|usec_delay
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|eecd_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|shared
argument_list|,
name|EECD
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|eecd_reg
operator|&
name|E1000_EECD_GNT
operator|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
comment|/* Prepare the EEPROM for writing  */
name|em_setup_eeprom
argument_list|(
name|shared
argument_list|)
expr_stmt|;
comment|/* Send the 9-bit (or 11-bit on large EEPROM) EWEN (write enable)       * command to the EEPROM (5-bit opcode plus 4/6-bit dummy).      * This puts the EEPROM into write/erase mode.       */
name|em_shift_out_bits
argument_list|(
name|shared
argument_list|,
name|EEPROM_EWEN_OPCODE
argument_list|,
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
name|large_eeprom
condition|)
name|em_shift_out_bits
argument_list|(
name|shared
argument_list|,
literal|0
argument_list|,
literal|6
argument_list|)
expr_stmt|;
else|else
name|em_shift_out_bits
argument_list|(
name|shared
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Prepare the EEPROM */
name|em_standby_eeprom
argument_list|(
name|shared
argument_list|)
expr_stmt|;
comment|/* Send the Write command (3-bit opcode + addr) */
name|em_shift_out_bits
argument_list|(
name|shared
argument_list|,
name|EEPROM_WRITE_OPCODE
argument_list|,
literal|3
argument_list|)
expr_stmt|;
comment|/* If we have a 256 word EEPROM, there are 8 address bits      * if we have a 64 word EEPROM, there are 6 address bits      */
if|if
condition|(
name|large_eeprom
condition|)
name|em_shift_out_bits
argument_list|(
name|shared
argument_list|,
name|offset
argument_list|,
literal|8
argument_list|)
expr_stmt|;
else|else
name|em_shift_out_bits
argument_list|(
name|shared
argument_list|,
name|offset
argument_list|,
literal|6
argument_list|)
expr_stmt|;
comment|/* Send the data */
name|em_shift_out_bits
argument_list|(
name|shared
argument_list|,
name|data
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|em_wait_eeprom_command
argument_list|(
name|shared
argument_list|)
expr_stmt|;
comment|/* Recover from write */
name|em_standby_eeprom
argument_list|(
name|shared
argument_list|)
expr_stmt|;
comment|/* Send the 9-bit  (or 11-bit on large EEPROM) EWDS (write disable)       * command to the EEPROM (5-bit opcode plus 4/6-bit dummy).      * This takes the EEPROM out of write/erase mode.      */
name|em_shift_out_bits
argument_list|(
name|shared
argument_list|,
name|EEPROM_EWDS_OPCODE
argument_list|,
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
name|large_eeprom
condition|)
name|em_shift_out_bits
argument_list|(
name|shared
argument_list|,
literal|0
argument_list|,
literal|6
argument_list|)
expr_stmt|;
else|else
name|em_shift_out_bits
argument_list|(
name|shared
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Done with writing */
name|em_cleanup_eeprom
argument_list|(
name|shared
argument_list|)
expr_stmt|;
comment|/* Stop requestiong EEPROM access */
if|if
condition|(
name|shared
operator|->
name|mac_type
operator|>
name|em_82544
condition|)
name|E1000_WRITE_REG
argument_list|(
name|shared
argument_list|,
name|EECD
argument_list|,
operator|(
name|uint32_t
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Reads the adapter's part number from the EEPROM  *  * shared - Struct containing variables accessed by shared code  * part_num - Adapter's part number  *****************************************************************************/
end_comment

begin_function
name|boolean_t
name|em_read_part_num
parameter_list|(
name|struct
name|em_shared_adapter
modifier|*
name|shared
parameter_list|,
name|uint32_t
modifier|*
name|part_num
parameter_list|)
block|{
name|uint16_t
name|eeprom_word
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_read_part_num"
argument_list|)
expr_stmt|;
comment|/* Don't read the EEPROM if we are stopped */
if|if
condition|(
name|shared
operator|->
name|adapter_stopped
condition|)
block|{
operator|*
name|part_num
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
comment|/* Get word 0 from EEPROM */
name|eeprom_word
operator|=
name|em_read_eeprom
argument_list|(
name|shared
argument_list|,
call|(
name|uint16_t
call|)
argument_list|(
name|EEPROM_PBA_BYTE_1
argument_list|)
argument_list|)
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Read first part number word\n"
argument_list|)
expr_stmt|;
comment|/* Save word 0 in upper half is PartNumber */
operator|*
name|part_num
operator|=
operator|(
name|uint32_t
operator|)
name|eeprom_word
expr_stmt|;
operator|*
name|part_num
operator|=
operator|*
name|part_num
operator|<<
literal|16
expr_stmt|;
comment|/* Get word 1 from EEPROM */
name|eeprom_word
operator|=
name|em_read_eeprom
argument_list|(
name|shared
argument_list|,
call|(
name|uint16_t
call|)
argument_list|(
name|EEPROM_PBA_BYTE_1
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Read second part number word\n"
argument_list|)
expr_stmt|;
comment|/* Save word 1 in lower half of PartNumber */
operator|*
name|part_num
operator||=
name|eeprom_word
expr_stmt|;
comment|/* read a valid part number */
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Turns on the software controllable LED  *  * shared - Struct containing variables accessed by shared code  *****************************************************************************/
end_comment

begin_function
name|void
name|em_led_on
parameter_list|(
name|struct
name|em_shared_adapter
modifier|*
name|shared
parameter_list|)
block|{
name|uint32_t
name|ctrl_reg
decl_stmt|;
comment|/* if we're stopped don't touch the hardware */
if|if
condition|(
name|shared
operator|->
name|adapter_stopped
condition|)
return|return;
comment|/* Read the content of the device control reg */
name|ctrl_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|shared
argument_list|,
name|CTRL
argument_list|)
expr_stmt|;
comment|/* Set the LED control pin to an output */
name|ctrl_reg
operator||=
name|E1000_CTRL_SWDPIO0
expr_stmt|;
comment|/* Drive it high on normal boards, low on low profile boards */
if|if
condition|(
name|shared
operator|->
name|low_profile
condition|)
name|ctrl_reg
operator|&=
operator|~
name|E1000_CTRL_SWDPIN0
expr_stmt|;
else|else
name|ctrl_reg
operator||=
name|E1000_CTRL_SWDPIN0
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|shared
argument_list|,
name|CTRL
argument_list|,
name|ctrl_reg
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Turns off the software controllable LED  *  * shared - Struct containing variables accessed by shared code  *****************************************************************************/
end_comment

begin_function
name|void
name|em_led_off
parameter_list|(
name|struct
name|em_shared_adapter
modifier|*
name|shared
parameter_list|)
block|{
name|uint32_t
name|ctrl_reg
decl_stmt|;
comment|/* if we're stopped don't touch the hardware */
if|if
condition|(
name|shared
operator|->
name|adapter_stopped
condition|)
return|return;
comment|/* Read the content of the device control reg */
name|ctrl_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|shared
argument_list|,
name|CTRL
argument_list|)
expr_stmt|;
comment|/* Set the LED control pin to an output */
name|ctrl_reg
operator||=
name|E1000_CTRL_SWDPIO0
expr_stmt|;
comment|/* Drive it low on normal boards, high on low profile boards */
if|if
condition|(
name|shared
operator|->
name|low_profile
condition|)
name|ctrl_reg
operator||=
name|E1000_CTRL_SWDPIN0
expr_stmt|;
else|else
name|ctrl_reg
operator|&=
operator|~
name|E1000_CTRL_SWDPIN0
expr_stmt|;
comment|/* Write the device control reg. back  */
name|E1000_WRITE_REG
argument_list|(
name|shared
argument_list|,
name|CTRL
argument_list|,
name|ctrl_reg
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Adjusts the statistic counters when a frame is accepted by TBI_ACCEPT  *   * shared - Struct containing variables accessed by shared code  * frame_len - The length of the frame in question  * mac_addr - The Ethernet destination address of the frame in question  *****************************************************************************/
end_comment

begin_function
name|uint32_t
name|em_tbi_adjust_stats
parameter_list|(
name|struct
name|em_shared_adapter
modifier|*
name|shared
parameter_list|,
name|struct
name|em_shared_stats
modifier|*
name|stats
parameter_list|,
name|uint32_t
name|frame_len
parameter_list|,
name|uint8_t
modifier|*
name|mac_addr
parameter_list|)
block|{
name|uint64_t
name|carry_bit
decl_stmt|;
comment|/* First adjust the frame length. */
name|frame_len
operator|--
expr_stmt|;
comment|/* We need to adjust the statistics counters, since the hardware      * counters overcount this packet as a CRC error and undercount      * the packet as a good packet      */
comment|/* This packet should not be counted as a CRC error.    */
name|stats
operator|->
name|crcerrs
operator|--
expr_stmt|;
comment|/* This packet does count as a Good Packet Received.    */
name|stats
operator|->
name|gprc
operator|++
expr_stmt|;
comment|/* Adjust the Good Octets received counters             */
name|carry_bit
operator|=
literal|0x80000000
operator|&
name|stats
operator|->
name|gorcl
expr_stmt|;
name|stats
operator|->
name|gorcl
operator|+=
name|frame_len
expr_stmt|;
comment|/* If the high bit of Gorcl (the low 32 bits of the Good Octets      * Received Count) was one before the addition,       * AND it is zero after, then we lost the carry out,       * need to add one to Gorch (Good Octets Received Count High).      * This could be simplified if all environments supported       * 64-bit integers.      */
if|if
condition|(
name|carry_bit
operator|&&
operator|(
operator|(
name|stats
operator|->
name|gorcl
operator|&
literal|0x80000000
operator|)
operator|==
literal|0
operator|)
condition|)
name|stats
operator|->
name|gorch
operator|++
expr_stmt|;
comment|/* Is this a broadcast or multicast?  Check broadcast first,      * since the test for a multicast frame will test positive on       * a broadcast frame.      */
if|if
condition|(
operator|(
name|mac_addr
index|[
literal|0
index|]
operator|==
operator|(
name|uint8_t
operator|)
literal|0xff
operator|)
operator|&&
operator|(
name|mac_addr
index|[
literal|1
index|]
operator|==
operator|(
name|uint8_t
operator|)
literal|0xff
operator|)
condition|)
comment|/* Broadcast packet */
name|stats
operator|->
name|bprc
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|mac_addr
operator|&
literal|0x01
condition|)
comment|/* Multicast packet */
name|stats
operator|->
name|mprc
operator|++
expr_stmt|;
if|if
condition|(
name|frame_len
operator|==
name|shared
operator|->
name|max_frame_size
condition|)
block|{
comment|/* In this case, the hardware has overcounted the number of          * oversize frames.          */
if|if
condition|(
name|stats
operator|->
name|roc
operator|>
literal|0
condition|)
name|stats
operator|->
name|roc
operator|--
expr_stmt|;
block|}
comment|/* Adjust the bin counters when the extra byte put the frame in the      * wrong bin. Remember that the frame_len was adjusted above.      */
if|if
condition|(
name|frame_len
operator|==
literal|64
condition|)
block|{
name|stats
operator|->
name|prc64
operator|++
expr_stmt|;
name|stats
operator|->
name|prc127
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|frame_len
operator|==
literal|127
condition|)
block|{
name|stats
operator|->
name|prc127
operator|++
expr_stmt|;
name|stats
operator|->
name|prc255
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|frame_len
operator|==
literal|255
condition|)
block|{
name|stats
operator|->
name|prc255
operator|++
expr_stmt|;
name|stats
operator|->
name|prc511
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|frame_len
operator|==
literal|511
condition|)
block|{
name|stats
operator|->
name|prc511
operator|++
expr_stmt|;
name|stats
operator|->
name|prc1023
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|frame_len
operator|==
literal|1023
condition|)
block|{
name|stats
operator|->
name|prc1023
operator|++
expr_stmt|;
name|stats
operator|->
name|prc1522
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|frame_len
operator|==
literal|1522
condition|)
block|{
name|stats
operator|->
name|prc1522
operator|++
expr_stmt|;
block|}
return|return
name|frame_len
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Gets the current PCI bus type, speed, and width of the hardware  *  * shared - Struct containing variables accessed by shared code  *****************************************************************************/
end_comment

begin_function
name|void
name|em_get_bus_info
parameter_list|(
name|struct
name|em_shared_adapter
modifier|*
name|shared
parameter_list|)
block|{
name|uint32_t
name|status_reg
decl_stmt|;
if|if
condition|(
name|shared
operator|->
name|mac_type
operator|<
name|em_82543
condition|)
block|{
name|shared
operator|->
name|bus_type
operator|=
name|em_bus_type_unknown
expr_stmt|;
name|shared
operator|->
name|bus_speed
operator|=
name|em_bus_speed_unknown
expr_stmt|;
name|shared
operator|->
name|bus_width
operator|=
name|em_bus_width_unknown
expr_stmt|;
return|return;
block|}
name|status_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|shared
argument_list|,
name|STATUS
argument_list|)
expr_stmt|;
name|shared
operator|->
name|bus_type
operator|=
operator|(
name|status_reg
operator|&
name|E1000_STATUS_PCIX_MODE
operator|)
condition|?
name|em_bus_type_pcix
else|:
name|em_bus_type_pci
expr_stmt|;
if|if
condition|(
name|shared
operator|->
name|bus_type
operator|==
name|em_bus_type_pci
condition|)
block|{
name|shared
operator|->
name|bus_speed
operator|=
operator|(
name|status_reg
operator|&
name|E1000_STATUS_PCI66
operator|)
condition|?
name|em_bus_speed_66
else|:
name|em_bus_speed_33
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|status_reg
operator|&
name|E1000_STATUS_PCIX_SPEED
condition|)
block|{
case|case
name|E1000_STATUS_PCIX_SPEED_66
case|:
name|shared
operator|->
name|bus_speed
operator|=
name|em_bus_speed_66
expr_stmt|;
break|break;
case|case
name|E1000_STATUS_PCIX_SPEED_100
case|:
name|shared
operator|->
name|bus_speed
operator|=
name|em_bus_speed_100
expr_stmt|;
break|break;
case|case
name|E1000_STATUS_PCIX_SPEED_133
case|:
name|shared
operator|->
name|bus_speed
operator|=
name|em_bus_speed_133
expr_stmt|;
break|break;
default|default:
name|shared
operator|->
name|bus_speed
operator|=
name|em_bus_speed_reserved
expr_stmt|;
break|break;
block|}
block|}
name|shared
operator|->
name|bus_width
operator|=
operator|(
name|status_reg
operator|&
name|E1000_STATUS_BUS64
operator|)
condition|?
name|em_bus_width_64
else|:
name|em_bus_width_32
expr_stmt|;
return|return;
block|}
end_function

end_unit

