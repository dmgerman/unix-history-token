begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*******************************************************************************    Copyright (c) 2001-2007, Intel Corporation    All rights reserved.      Redistribution and use in source and binary forms, with or without    modification, are permitted provided that the following conditions are met:       1. Redistributions of source code must retain the above copyright notice,        this list of conditions and the following disclaimer.       2. Redistributions in binary form must reproduce the above copyright        notice, this list of conditions and the following disclaimer in the        documentation and/or other materials provided with the distribution.       3. Neither the name of the Intel Corporation nor the names of its        contributors may be used to endorse or promote products derived from        this software without specific prior written permission.      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE    ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR    CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF    SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN    CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)    ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE   POSSIBILITY OF SUCH DAMAGE.  *******************************************************************************/
end_comment

begin_comment
comment|/*$FreeBSD$*/
end_comment

begin_comment
comment|/* e1000_80003es2lan  */
end_comment

begin_include
include|#
directive|include
file|"e1000_api.h"
end_include

begin_include
include|#
directive|include
file|"e1000_80003es2lan.h"
end_include

begin_function_decl
name|void
name|e1000_init_function_pointers_80003es2lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|s32
name|e1000_init_phy_params_80003es2lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|s32
name|e1000_init_nvm_params_80003es2lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|s32
name|e1000_init_mac_params_80003es2lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|s32
name|e1000_acquire_phy_80003es2lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|void
name|e1000_release_phy_80003es2lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|s32
name|e1000_acquire_nvm_80003es2lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|void
name|e1000_release_nvm_80003es2lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|s32
name|e1000_read_phy_reg_gg82563_80003es2lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|s32
name|e1000_write_phy_reg_gg82563_80003es2lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u16
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|s32
name|e1000_write_nvm_80003es2lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|offset
parameter_list|,
name|u16
name|words
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|s32
name|e1000_get_cfg_done_80003es2lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|s32
name|e1000_phy_force_speed_duplex_80003es2lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|s32
name|e1000_get_cable_length_80003es2lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|s32
name|e1000_get_link_up_info_80003es2lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
modifier|*
name|speed
parameter_list|,
name|u16
modifier|*
name|duplex
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|s32
name|e1000_reset_hw_80003es2lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|s32
name|e1000_init_hw_80003es2lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|s32
name|e1000_setup_copper_link_80003es2lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|void
name|e1000_clear_hw_cntrs_80003es2lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_acquire_swfw_sync_80003es2lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|mask
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_cfg_kmrn_10_100_80003es2lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|duplex
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_cfg_kmrn_1000_80003es2lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_copper_link_setup_gg82563_80003es2lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|e1000_initialize_hw_bits_80003es2lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|e1000_release_swfw_sync_80003es2lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|mask
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* A table for the GG82563 cable length where the range is defined  * with a lower bound at "index" and the upper bound at  * "index + 5".  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|u16
name|e1000_gg82563_cable_length_table
index|[]
init|=
block|{
literal|0
block|,
literal|60
block|,
literal|115
block|,
literal|150
block|,
literal|150
block|,
literal|60
block|,
literal|115
block|,
literal|150
block|,
literal|180
block|,
literal|180
block|,
literal|0xFF
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|GG82563_CABLE_LENGTH_TABLE_SIZE
define|\
value|(sizeof(e1000_gg82563_cable_length_table) / \                  sizeof(e1000_gg82563_cable_length_table[0]))
end_define

begin_comment
comment|/**  *  e1000_init_phy_params_80003es2lan - Init ESB2 PHY func ptrs.  *  @hw: pointer to the HW structure  *  *  This is a function pointer entry point called by the api module.  **/
end_comment

begin_function
name|STATIC
name|s32
name|e1000_init_phy_params_80003es2lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|struct
name|e1000_functions
modifier|*
name|func
init|=
operator|&
name|hw
operator|->
name|func
decl_stmt|;
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_init_phy_params_80003es2lan"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|media_type
operator|!=
name|e1000_media_type_copper
condition|)
block|{
name|phy
operator|->
name|type
operator|=
name|e1000_phy_none
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|phy
operator|->
name|addr
operator|=
literal|1
expr_stmt|;
name|phy
operator|->
name|autoneg_mask
operator|=
name|AUTONEG_ADVERTISE_SPEED_DEFAULT
expr_stmt|;
name|phy
operator|->
name|reset_delay_us
operator|=
literal|100
expr_stmt|;
name|phy
operator|->
name|type
operator|=
name|e1000_phy_gg82563
expr_stmt|;
name|func
operator|->
name|acquire_phy
operator|=
name|e1000_acquire_phy_80003es2lan
expr_stmt|;
name|func
operator|->
name|check_polarity
operator|=
name|e1000_check_polarity_m88
expr_stmt|;
name|func
operator|->
name|check_reset_block
operator|=
name|e1000_check_reset_block_generic
expr_stmt|;
name|func
operator|->
name|commit_phy
operator|=
name|e1000_phy_sw_reset_generic
expr_stmt|;
name|func
operator|->
name|get_cfg_done
operator|=
name|e1000_get_cfg_done_80003es2lan
expr_stmt|;
name|func
operator|->
name|get_phy_info
operator|=
name|e1000_get_phy_info_m88
expr_stmt|;
name|func
operator|->
name|release_phy
operator|=
name|e1000_release_phy_80003es2lan
expr_stmt|;
name|func
operator|->
name|reset_phy
operator|=
name|e1000_phy_hw_reset_generic
expr_stmt|;
name|func
operator|->
name|set_d3_lplu_state
operator|=
name|e1000_set_d3_lplu_state_generic
expr_stmt|;
name|func
operator|->
name|force_speed_duplex
operator|=
name|e1000_phy_force_speed_duplex_80003es2lan
expr_stmt|;
name|func
operator|->
name|get_cable_length
operator|=
name|e1000_get_cable_length_80003es2lan
expr_stmt|;
name|func
operator|->
name|read_phy_reg
operator|=
name|e1000_read_phy_reg_gg82563_80003es2lan
expr_stmt|;
name|func
operator|->
name|write_phy_reg
operator|=
name|e1000_write_phy_reg_gg82563_80003es2lan
expr_stmt|;
comment|/* This can only be done after all function pointers are setup. */
name|ret_val
operator|=
name|e1000_get_phy_id
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Verify phy id */
if|if
condition|(
name|phy
operator|->
name|id
operator|!=
name|GG82563_E_PHY_ID
condition|)
block|{
name|ret_val
operator|=
operator|-
name|E1000_ERR_PHY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_init_nvm_params_80003es2lan - Init ESB2 NVM func ptrs.  *  @hw: pointer to the HW structure  *  *  This is a function pointer entry point called by the api module.  **/
end_comment

begin_function
name|STATIC
name|s32
name|e1000_init_nvm_params_80003es2lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_nvm_info
modifier|*
name|nvm
init|=
operator|&
name|hw
operator|->
name|nvm
decl_stmt|;
name|struct
name|e1000_functions
modifier|*
name|func
init|=
operator|&
name|hw
operator|->
name|func
decl_stmt|;
name|u32
name|eecd
init|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_EECD
argument_list|)
decl_stmt|;
name|u16
name|size
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_init_nvm_params_80003es2lan"
argument_list|)
expr_stmt|;
name|nvm
operator|->
name|opcode_bits
operator|=
literal|8
expr_stmt|;
name|nvm
operator|->
name|delay_usec
operator|=
literal|1
expr_stmt|;
switch|switch
condition|(
name|nvm
operator|->
name|override
condition|)
block|{
case|case
name|e1000_nvm_override_spi_large
case|:
name|nvm
operator|->
name|page_size
operator|=
literal|32
expr_stmt|;
name|nvm
operator|->
name|address_bits
operator|=
literal|16
expr_stmt|;
break|break;
case|case
name|e1000_nvm_override_spi_small
case|:
name|nvm
operator|->
name|page_size
operator|=
literal|8
expr_stmt|;
name|nvm
operator|->
name|address_bits
operator|=
literal|8
expr_stmt|;
break|break;
default|default:
name|nvm
operator|->
name|page_size
operator|=
name|eecd
operator|&
name|E1000_EECD_ADDR_BITS
condition|?
literal|32
else|:
literal|8
expr_stmt|;
name|nvm
operator|->
name|address_bits
operator|=
name|eecd
operator|&
name|E1000_EECD_ADDR_BITS
condition|?
literal|16
else|:
literal|8
expr_stmt|;
break|break;
block|}
name|nvm
operator|->
name|type
operator|=
name|e1000_nvm_eeprom_spi
expr_stmt|;
name|size
operator|=
call|(
name|u16
call|)
argument_list|(
operator|(
name|eecd
operator|&
name|E1000_EECD_SIZE_EX_MASK
operator|)
operator|>>
name|E1000_EECD_SIZE_EX_SHIFT
argument_list|)
expr_stmt|;
comment|/* Added to a constant, "size" becomes the left-shift value 	 * for setting word_size. 	 */
name|size
operator|+=
name|NVM_WORD_SIZE_BASE_SHIFT
expr_stmt|;
name|nvm
operator|->
name|word_size
operator|=
literal|1
operator|<<
name|size
expr_stmt|;
comment|/* Function Pointers */
name|func
operator|->
name|acquire_nvm
operator|=
name|e1000_acquire_nvm_80003es2lan
expr_stmt|;
name|func
operator|->
name|read_nvm
operator|=
name|e1000_read_nvm_eerd
expr_stmt|;
name|func
operator|->
name|release_nvm
operator|=
name|e1000_release_nvm_80003es2lan
expr_stmt|;
name|func
operator|->
name|update_nvm
operator|=
name|e1000_update_nvm_checksum_generic
expr_stmt|;
name|func
operator|->
name|valid_led_default
operator|=
name|e1000_valid_led_default_generic
expr_stmt|;
name|func
operator|->
name|validate_nvm
operator|=
name|e1000_validate_nvm_checksum_generic
expr_stmt|;
name|func
operator|->
name|write_nvm
operator|=
name|e1000_write_nvm_80003es2lan
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_init_mac_params_80003es2lan - Init ESB2 MAC func ptrs.  *  @hw: pointer to the HW structure  *  *  This is a function pointer entry point called by the api module.  **/
end_comment

begin_function
name|STATIC
name|s32
name|e1000_init_mac_params_80003es2lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_mac_info
modifier|*
name|mac
init|=
operator|&
name|hw
operator|->
name|mac
decl_stmt|;
name|struct
name|e1000_functions
modifier|*
name|func
init|=
operator|&
name|hw
operator|->
name|func
decl_stmt|;
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_init_mac_params_80003es2lan"
argument_list|)
expr_stmt|;
comment|/* Set media type */
switch|switch
condition|(
name|hw
operator|->
name|device_id
condition|)
block|{
case|case
name|E1000_DEV_ID_80003ES2LAN_SERDES_DPT
case|:
name|hw
operator|->
name|media_type
operator|=
name|e1000_media_type_internal_serdes
expr_stmt|;
break|break;
default|default:
name|hw
operator|->
name|media_type
operator|=
name|e1000_media_type_copper
expr_stmt|;
break|break;
block|}
comment|/* Set mta register count */
name|mac
operator|->
name|mta_reg_count
operator|=
literal|128
expr_stmt|;
comment|/* Set rar entry count */
name|mac
operator|->
name|rar_entry_count
operator|=
name|E1000_RAR_ENTRIES
expr_stmt|;
comment|/* Set if part includes ASF firmware */
name|mac
operator|->
name|asf_firmware_present
operator|=
name|TRUE
expr_stmt|;
comment|/* Set if manageability features are enabled. */
name|mac
operator|->
name|arc_subsystem_valid
operator|=
operator|(
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_FWSM
argument_list|)
operator|&
name|E1000_FWSM_MODE_MASK
operator|)
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
comment|/* Function pointers */
comment|/* bus type/speed/width */
name|func
operator|->
name|get_bus_info
operator|=
name|e1000_get_bus_info_pcie_generic
expr_stmt|;
comment|/* reset */
name|func
operator|->
name|reset_hw
operator|=
name|e1000_reset_hw_80003es2lan
expr_stmt|;
comment|/* hw initialization */
name|func
operator|->
name|init_hw
operator|=
name|e1000_init_hw_80003es2lan
expr_stmt|;
comment|/* link setup */
name|func
operator|->
name|setup_link
operator|=
name|e1000_setup_link_generic
expr_stmt|;
comment|/* physical interface link setup */
name|func
operator|->
name|setup_physical_interface
operator|=
operator|(
name|hw
operator|->
name|media_type
operator|==
name|e1000_media_type_copper
operator|)
condition|?
name|e1000_setup_copper_link_80003es2lan
else|:
name|e1000_setup_fiber_serdes_link_generic
expr_stmt|;
comment|/* check for link */
switch|switch
condition|(
name|hw
operator|->
name|media_type
condition|)
block|{
case|case
name|e1000_media_type_copper
case|:
name|func
operator|->
name|check_for_link
operator|=
name|e1000_check_for_copper_link_generic
expr_stmt|;
break|break;
case|case
name|e1000_media_type_fiber
case|:
name|func
operator|->
name|check_for_link
operator|=
name|e1000_check_for_fiber_link_generic
expr_stmt|;
break|break;
case|case
name|e1000_media_type_internal_serdes
case|:
name|func
operator|->
name|check_for_link
operator|=
name|e1000_check_for_serdes_link_generic
expr_stmt|;
break|break;
default|default:
name|ret_val
operator|=
operator|-
name|E1000_ERR_CONFIG
expr_stmt|;
goto|goto
name|out
goto|;
break|break;
block|}
comment|/* check management mode */
name|func
operator|->
name|check_mng_mode
operator|=
name|e1000_check_mng_mode_generic
expr_stmt|;
comment|/* multicast address update */
name|func
operator|->
name|mc_addr_list_update
operator|=
name|e1000_mc_addr_list_update_generic
expr_stmt|;
comment|/* writing VFTA */
name|func
operator|->
name|write_vfta
operator|=
name|e1000_write_vfta_generic
expr_stmt|;
comment|/* clearing VFTA */
name|func
operator|->
name|clear_vfta
operator|=
name|e1000_clear_vfta_generic
expr_stmt|;
comment|/* setting MTA */
name|func
operator|->
name|mta_set
operator|=
name|e1000_mta_set_generic
expr_stmt|;
comment|/* blink LED */
name|func
operator|->
name|blink_led
operator|=
name|e1000_blink_led_generic
expr_stmt|;
comment|/* setup LED */
name|func
operator|->
name|setup_led
operator|=
name|e1000_setup_led_generic
expr_stmt|;
comment|/* cleanup LED */
name|func
operator|->
name|cleanup_led
operator|=
name|e1000_cleanup_led_generic
expr_stmt|;
comment|/* turn on/off LED */
name|func
operator|->
name|led_on
operator|=
name|e1000_led_on_generic
expr_stmt|;
name|func
operator|->
name|led_off
operator|=
name|e1000_led_off_generic
expr_stmt|;
comment|/* remove device */
name|func
operator|->
name|remove_device
operator|=
name|e1000_remove_device_generic
expr_stmt|;
comment|/* clear hardware counters */
name|func
operator|->
name|clear_hw_cntrs
operator|=
name|e1000_clear_hw_cntrs_80003es2lan
expr_stmt|;
comment|/* link info */
name|func
operator|->
name|get_link_up_info
operator|=
name|e1000_get_link_up_info_80003es2lan
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_init_function_pointers_80003es2lan - Init ESB2 func ptrs.  *  @hw: pointer to the HW structure  *  *  The only function explicitly called by the api module to initialize  *  all function pointers and parameters.  **/
end_comment

begin_function
name|void
name|e1000_init_function_pointers_80003es2lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"e1000_init_function_pointers_80003es2lan"
argument_list|)
expr_stmt|;
name|hw
operator|->
name|func
operator|.
name|init_mac_params
operator|=
name|e1000_init_mac_params_80003es2lan
expr_stmt|;
name|hw
operator|->
name|func
operator|.
name|init_nvm_params
operator|=
name|e1000_init_nvm_params_80003es2lan
expr_stmt|;
name|hw
operator|->
name|func
operator|.
name|init_phy_params
operator|=
name|e1000_init_phy_params_80003es2lan
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  e1000_acquire_phy_80003es2lan - Acquire rights to access PHY  *  @hw: pointer to the HW structure  *  *  A wrapper to acquire access rights to the correct PHY.  This is a  *  function pointer entry point called by the api module.  **/
end_comment

begin_function
name|STATIC
name|s32
name|e1000_acquire_phy_80003es2lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u16
name|mask
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_acquire_phy_80003es2lan"
argument_list|)
expr_stmt|;
name|mask
operator|=
name|hw
operator|->
name|bus
operator|.
name|func
condition|?
name|E1000_SWFW_PHY1_SM
else|:
name|E1000_SWFW_PHY0_SM
expr_stmt|;
return|return
name|e1000_acquire_swfw_sync_80003es2lan
argument_list|(
name|hw
argument_list|,
name|mask
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_release_phy_80003es2lan - Release rights to access PHY  *  @hw: pointer to the HW structure  *  *  A wrapper to release access rights to the correct PHY.  This is a  *  function pointer entry point called by the api module.  **/
end_comment

begin_function
name|STATIC
name|void
name|e1000_release_phy_80003es2lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u16
name|mask
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_release_phy_80003es2lan"
argument_list|)
expr_stmt|;
name|mask
operator|=
name|hw
operator|->
name|bus
operator|.
name|func
condition|?
name|E1000_SWFW_PHY1_SM
else|:
name|E1000_SWFW_PHY0_SM
expr_stmt|;
name|e1000_release_swfw_sync_80003es2lan
argument_list|(
name|hw
argument_list|,
name|mask
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  e1000_acquire_nvm_80003es2lan - Acquire rights to access NVM  *  @hw: pointer to the HW structure  *  *  Acquire the semaphore to access the EEPROM.  This is a function  *  pointer entry point called by the api module.  **/
end_comment

begin_function
name|STATIC
name|s32
name|e1000_acquire_nvm_80003es2lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|ret_val
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_acquire_nvm_80003es2lan"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_acquire_swfw_sync_80003es2lan
argument_list|(
name|hw
argument_list|,
name|E1000_SWFW_EEP_SM
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|ret_val
operator|=
name|e1000_acquire_nvm_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
name|e1000_release_swfw_sync_80003es2lan
argument_list|(
name|hw
argument_list|,
name|E1000_SWFW_EEP_SM
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_release_nvm_80003es2lan - Relinquish rights to access NVM  *  @hw: pointer to the HW structure  *  *  Release the semaphore used to access the EEPROM.  This is a  *  function pointer entry point called by the api module.  **/
end_comment

begin_function
name|STATIC
name|void
name|e1000_release_nvm_80003es2lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"e1000_release_nvm_80003es2lan"
argument_list|)
expr_stmt|;
name|e1000_release_nvm_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|e1000_release_swfw_sync_80003es2lan
argument_list|(
name|hw
argument_list|,
name|E1000_SWFW_EEP_SM
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  e1000_acquire_swfw_sync_80003es2lan - Acquire SW/FW semaphore  *  @hw: pointer to the HW structure  *  @mask: specifies which semaphore to acquire  *  *  Acquire the SW/FW semaphore to access the PHY or NVM.  The mask  *  will also specify which port we're acquiring the lock for.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_acquire_swfw_sync_80003es2lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|mask
parameter_list|)
block|{
name|u32
name|swfw_sync
decl_stmt|;
name|u32
name|swmask
init|=
name|mask
decl_stmt|;
name|u32
name|fwmask
init|=
name|mask
operator|<<
literal|16
decl_stmt|;
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|s32
name|i
init|=
literal|0
decl_stmt|,
name|timeout
init|=
literal|200
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_acquire_swfw_sync_80003es2lan"
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|timeout
condition|)
block|{
if|if
condition|(
name|e1000_get_hw_semaphore_generic
argument_list|(
name|hw
argument_list|)
condition|)
block|{
name|ret_val
operator|=
operator|-
name|E1000_ERR_SWFW_SYNC
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|swfw_sync
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_SW_FW_SYNC
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|swfw_sync
operator|&
operator|(
name|fwmask
operator||
name|swmask
operator|)
operator|)
condition|)
break|break;
comment|/* Firmware currently using resource (fwmask) 		 * or other software thread using resource (swmask) */
name|e1000_put_hw_semaphore_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|msec_delay_irq
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
name|timeout
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Driver can't access resource, SW_FW_SYNC timeout.\n"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
operator|-
name|E1000_ERR_SWFW_SYNC
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|swfw_sync
operator||=
name|swmask
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_SW_FW_SYNC
argument_list|,
name|swfw_sync
argument_list|)
expr_stmt|;
name|e1000_put_hw_semaphore_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_release_swfw_sync_80003es2lan - Release SW/FW semaphore  *  @hw: pointer to the HW structure  *  @mask: specifies which semaphore to acquire  *  *  Release the SW/FW semaphore used to access the PHY or NVM.  The mask  *  will also specify which port we're releasing the lock for.  **/
end_comment

begin_function
specifier|static
name|void
name|e1000_release_swfw_sync_80003es2lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|mask
parameter_list|)
block|{
name|u32
name|swfw_sync
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_release_swfw_sync_80003es2lan"
argument_list|)
expr_stmt|;
while|while
condition|(
name|e1000_get_hw_semaphore_generic
argument_list|(
name|hw
argument_list|)
operator|!=
name|E1000_SUCCESS
condition|)
empty_stmt|;
comment|/* Empty */
name|swfw_sync
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_SW_FW_SYNC
argument_list|)
expr_stmt|;
name|swfw_sync
operator|&=
operator|~
name|mask
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_SW_FW_SYNC
argument_list|,
name|swfw_sync
argument_list|)
expr_stmt|;
name|e1000_put_hw_semaphore_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  e1000_read_phy_reg_gg82563_80003es2lan - Read GG82563 PHY register  *  @hw: pointer to the HW structure  *  @offset: offset of the register to read  *  @data: pointer to the data returned from the operation  *  *  Read the GG82563 PHY register.  This is a function pointer entry  *  point called by the api module.  **/
end_comment

begin_function
name|STATIC
name|s32
name|e1000_read_phy_reg_gg82563_80003es2lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
block|{
name|s32
name|ret_val
decl_stmt|;
name|u32
name|page_select
decl_stmt|;
name|u16
name|temp
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_read_phy_reg_gg82563_80003es2lan"
argument_list|)
expr_stmt|;
comment|/* Select Configuration Page */
if|if
condition|(
operator|(
name|offset
operator|&
name|MAX_PHY_REG_ADDRESS
operator|)
operator|<
name|GG82563_MIN_ALT_REG
condition|)
name|page_select
operator|=
name|GG82563_PHY_PAGE_SELECT
expr_stmt|;
else|else
block|{
comment|/* Use Alternative Page Select register to access 		 * registers 30 and 31 		 */
name|page_select
operator|=
name|GG82563_PHY_PAGE_SELECT_ALT
expr_stmt|;
block|}
name|temp
operator|=
call|(
name|u16
call|)
argument_list|(
operator|(
name|u16
operator|)
name|offset
operator|>>
name|GG82563_PAGE_SHIFT
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_write_phy_reg_m88
argument_list|(
name|hw
argument_list|,
name|page_select
argument_list|,
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
comment|/* The "ready" bit in the MDIC register may be incorrectly set 	 * before the device has completed the "Page Select" MDI 	 * transaction.  So we wait 200us after each MDI command... 	 */
name|usec_delay
argument_list|(
literal|200
argument_list|)
expr_stmt|;
comment|/* ...and verify the command was successful. */
name|ret_val
operator|=
name|e1000_read_phy_reg_m88
argument_list|(
name|hw
argument_list|,
name|page_select
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|u16
operator|)
name|offset
operator|>>
name|GG82563_PAGE_SHIFT
operator|)
operator|!=
name|temp
condition|)
block|{
name|ret_val
operator|=
operator|-
name|E1000_ERR_PHY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|usec_delay
argument_list|(
literal|200
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_read_phy_reg_m88
argument_list|(
name|hw
argument_list|,
name|MAX_PHY_REG_ADDRESS
operator|&
name|offset
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|200
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_write_phy_reg_gg82563_80003es2lan - Write GG82563 PHY register  *  @hw: pointer to the HW structure  *  @offset: offset of the register to read  *  @data: value to write to the register  *  *  Write to the GG82563 PHY register.  This is a function pointer entry  *  point called by the api module.  **/
end_comment

begin_function
name|STATIC
name|s32
name|e1000_write_phy_reg_gg82563_80003es2lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u16
name|data
parameter_list|)
block|{
name|s32
name|ret_val
decl_stmt|;
name|u32
name|page_select
decl_stmt|;
name|u16
name|temp
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_write_phy_reg_gg82563_80003es2lan"
argument_list|)
expr_stmt|;
comment|/* Select Configuration Page */
if|if
condition|(
operator|(
name|offset
operator|&
name|MAX_PHY_REG_ADDRESS
operator|)
operator|<
name|GG82563_MIN_ALT_REG
condition|)
name|page_select
operator|=
name|GG82563_PHY_PAGE_SELECT
expr_stmt|;
else|else
block|{
comment|/* Use Alternative Page Select register to access 		 * registers 30 and 31 		 */
name|page_select
operator|=
name|GG82563_PHY_PAGE_SELECT_ALT
expr_stmt|;
block|}
name|temp
operator|=
call|(
name|u16
call|)
argument_list|(
operator|(
name|u16
operator|)
name|offset
operator|>>
name|GG82563_PAGE_SHIFT
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_write_phy_reg_m88
argument_list|(
name|hw
argument_list|,
name|page_select
argument_list|,
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
comment|/* The "ready" bit in the MDIC register may be incorrectly set 	 * before the device has completed the "Page Select" MDI 	 * transaction.  So we wait 200us after each MDI command... 	 */
name|usec_delay
argument_list|(
literal|200
argument_list|)
expr_stmt|;
comment|/* ...and verify the command was successful. */
name|ret_val
operator|=
name|e1000_read_phy_reg_m88
argument_list|(
name|hw
argument_list|,
name|page_select
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|u16
operator|)
name|offset
operator|>>
name|GG82563_PAGE_SHIFT
operator|)
operator|!=
name|temp
condition|)
block|{
name|ret_val
operator|=
operator|-
name|E1000_ERR_PHY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|usec_delay
argument_list|(
literal|200
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_write_phy_reg_m88
argument_list|(
name|hw
argument_list|,
name|MAX_PHY_REG_ADDRESS
operator|&
name|offset
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|200
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_write_nvm_80003es2lan - Write to ESB2 NVM  *  @hw: pointer to the HW structure  *  @offset: offset of the register to read  *  @words: number of words to write  *  @data: buffer of data to write to the NVM  *  *  Write "words" of data to the ESB2 NVM.  This is a function  *  pointer entry point called by the api module.  **/
end_comment

begin_function
name|STATIC
name|s32
name|e1000_write_nvm_80003es2lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|offset
parameter_list|,
name|u16
name|words
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"e1000_write_nvm_80003es2lan"
argument_list|)
expr_stmt|;
return|return
name|e1000_write_nvm_spi
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
name|words
argument_list|,
name|data
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_get_cfg_done_80003es2lan - Wait for configuration to complete  *  @hw: pointer to the HW structure  *  *  Wait a specific amount of time for manageability processes to complete.  *  This is a function pointer entry point called by the phy module.  **/
end_comment

begin_function
name|STATIC
name|s32
name|e1000_get_cfg_done_80003es2lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|timeout
init|=
name|PHY_CFG_TIMEOUT
decl_stmt|;
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|u32
name|mask
init|=
name|E1000_NVM_CFG_DONE_PORT_0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_get_cfg_done_80003es2lan"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|bus
operator|.
name|func
operator|==
literal|1
condition|)
name|mask
operator|=
name|E1000_NVM_CFG_DONE_PORT_1
expr_stmt|;
while|while
condition|(
name|timeout
condition|)
block|{
if|if
condition|(
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_EEMNGCTL
argument_list|)
operator|&
name|mask
condition|)
break|break;
name|msec_delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|timeout
operator|--
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|timeout
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"MNG configuration cycle has not completed.\n"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
operator|-
name|E1000_ERR_RESET
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_phy_force_speed_duplex_80003es2lan - Force PHY speed and duplex  *  @hw: pointer to the HW structure  *  *  Force the speed and duplex settings onto the PHY.  This is a  *  function pointer entry point called by the phy module.  **/
end_comment

begin_function
name|STATIC
name|s32
name|e1000_phy_force_speed_duplex_80003es2lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|ret_val
decl_stmt|;
name|u16
name|phy_data
decl_stmt|;
name|boolean_t
name|link
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_phy_force_speed_duplex_80003es2lan"
argument_list|)
expr_stmt|;
comment|/* Clear Auto-Crossover to force MDI manually.  M88E1000 requires MDI 	 * forced whenever speed and duplex are forced. 	 */
name|ret_val
operator|=
name|e1000_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_SPEC_CTRL
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|phy_data
operator|&=
operator|~
name|GG82563_PSCR_CROSSOVER_MODE_AUTO
expr_stmt|;
name|ret_val
operator|=
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|GG82563_PHY_SPEC_CTRL
argument_list|,
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|DEBUGOUT1
argument_list|(
literal|"GG82563 PSCR: %X\n"
argument_list|,
name|phy_data
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_CONTROL
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|e1000_phy_force_speed_duplex_setup
argument_list|(
name|hw
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
comment|/* Reset the phy to commit changes. */
name|phy_data
operator||=
name|MII_CR_RESET
expr_stmt|;
name|ret_val
operator|=
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_CONTROL
argument_list|,
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|usec_delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|wait_for_link
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Waiting for forced speed/duplex link "
literal|"on GG82563 phy.\n"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_phy_has_link_generic
argument_list|(
name|hw
argument_list|,
name|PHY_FORCE_LIMIT
argument_list|,
literal|100000
argument_list|,
operator|&
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|!
name|link
condition|)
block|{
comment|/* We didn't get link. 			 * Reset the DSP and cross our fingers. 			 */
name|ret_val
operator|=
name|e1000_phy_reset_dsp_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
block|}
comment|/* Try once more */
name|ret_val
operator|=
name|e1000_phy_has_link_generic
argument_list|(
name|hw
argument_list|,
name|PHY_FORCE_LIMIT
argument_list|,
literal|100000
argument_list|,
operator|&
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
block|}
name|ret_val
operator|=
name|e1000_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|GG82563_PHY_MAC_SPEC_CTRL
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
comment|/* Resetting the phy means we need to verify the TX_CLK corresponds 	 * to the link speed.  10Mbps -> 2.5MHz, else 25MHz. 	 */
name|phy_data
operator|&=
operator|~
name|GG82563_MSCR_TX_CLK_MASK
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|forced_speed_duplex
operator|&
name|E1000_ALL_10_SPEED
condition|)
name|phy_data
operator||=
name|GG82563_MSCR_TX_CLK_10MBPS_2_5
expr_stmt|;
else|else
name|phy_data
operator||=
name|GG82563_MSCR_TX_CLK_100MBPS_25
expr_stmt|;
comment|/* In addition, we must re-enable CRS on Tx for both half and full 	 * duplex. 	 */
name|phy_data
operator||=
name|GG82563_MSCR_ASSERT_CRS_ON_TX
expr_stmt|;
name|ret_val
operator|=
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|GG82563_PHY_MAC_SPEC_CTRL
argument_list|,
name|phy_data
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_get_cable_length_80003es2lan - Set approximate cable length  *  @hw: pointer to the HW structure  *  *  Find the approximate cable length as measured by the GG82563 PHY.  *  This is a function pointer entry point called by the phy module.  **/
end_comment

begin_function
name|STATIC
name|s32
name|e1000_get_cable_length_80003es2lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|u16
name|phy_data
decl_stmt|,
name|index
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_get_cable_length_80003es2lan"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|GG82563_PHY_DSP_DISTANCE
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|index
operator|=
name|phy_data
operator|&
name|GG82563_DSPD_CABLE_LENGTH
expr_stmt|;
name|phy
operator|->
name|min_cable_length
operator|=
name|e1000_gg82563_cable_length_table
index|[
name|index
index|]
expr_stmt|;
name|phy
operator|->
name|max_cable_length
operator|=
name|e1000_gg82563_cable_length_table
index|[
name|index
operator|+
literal|5
index|]
expr_stmt|;
name|phy
operator|->
name|cable_length
operator|=
operator|(
name|phy
operator|->
name|min_cable_length
operator|+
name|phy
operator|->
name|max_cable_length
operator|)
operator|/
literal|2
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_get_link_up_info_80003es2lan - Report speed and duplex  *  @hw: pointer to the HW structure  *  @speed: pointer to speed buffer  *  @duplex: pointer to duplex buffer  *  *  Retrieve the current speed and duplex configuration.  *  This is a function pointer entry point called by the api module.  **/
end_comment

begin_function
name|STATIC
name|s32
name|e1000_get_link_up_info_80003es2lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
modifier|*
name|speed
parameter_list|,
name|u16
modifier|*
name|duplex
parameter_list|)
block|{
name|s32
name|ret_val
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_get_link_up_info_80003es2lan"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|media_type
operator|==
name|e1000_media_type_copper
condition|)
block|{
name|ret_val
operator|=
name|e1000_get_speed_and_duplex_copper_generic
argument_list|(
name|hw
argument_list|,
name|speed
argument_list|,
name|duplex
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|*
name|speed
operator|==
name|SPEED_1000
condition|)
name|ret_val
operator|=
name|e1000_cfg_kmrn_1000_80003es2lan
argument_list|(
name|hw
argument_list|)
expr_stmt|;
else|else
name|ret_val
operator|=
name|e1000_cfg_kmrn_10_100_80003es2lan
argument_list|(
name|hw
argument_list|,
operator|*
name|duplex
argument_list|)
expr_stmt|;
block|}
else|else
name|ret_val
operator|=
name|e1000_get_speed_and_duplex_fiber_serdes_generic
argument_list|(
name|hw
argument_list|,
name|speed
argument_list|,
name|duplex
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_reset_hw_80003es2lan - Reset the ESB2 controller  *  @hw: pointer to the HW structure  *  *  Perform a global reset to the ESB2 controller.  *  This is a function pointer entry point called by the api module.  **/
end_comment

begin_function
name|STATIC
name|s32
name|e1000_reset_hw_80003es2lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|ctrl
decl_stmt|,
name|icr
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_reset_hw_80003es2lan"
argument_list|)
expr_stmt|;
comment|/* Prevent the PCI-E bus from sticking if there is no TLP connection 	 * on the last TLP read/write transaction when MAC is reset. 	 */
name|ret_val
operator|=
name|e1000_disable_pcie_master_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"PCI-E Master disable polling has failed.\n"
argument_list|)
expr_stmt|;
block|}
name|DEBUGOUT
argument_list|(
literal|"Masking off all interrupts\n"
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_IMC
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RCTL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TCTL
argument_list|,
name|E1000_TCTL_PSP
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|msec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|)
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Issuing a global reset to MAC\n"
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|,
name|ctrl
operator||
name|E1000_CTRL_RST
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_get_auto_rd_done_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
comment|/* We don't want to continue accessing MAC registers. */
goto|goto
name|out
goto|;
comment|/* Clear any pending interrupt events. */
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_IMC
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|icr
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_ICR
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_init_hw_80003es2lan - Initialize the ESB2 controller  *  @hw: pointer to the HW structure  *  *  Initialize the hw bits, LED, VFTA, MTA, link and hw counters.  *  This is a function pointer entry point called by the api module.  **/
end_comment

begin_function
name|STATIC
name|s32
name|e1000_init_hw_80003es2lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_mac_info
modifier|*
name|mac
init|=
operator|&
name|hw
operator|->
name|mac
decl_stmt|;
name|u32
name|reg_data
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|u16
name|i
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_init_hw_80003es2lan"
argument_list|)
expr_stmt|;
name|e1000_initialize_hw_bits_80003es2lan
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Initialize identification LED */
name|ret_val
operator|=
name|e1000_id_led_init_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Error initializing identification LED\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Disabling VLAN filtering */
name|DEBUGOUT
argument_list|(
literal|"Initializing the IEEE VLAN\n"
argument_list|)
expr_stmt|;
name|e1000_clear_vfta
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Setup the receive address. */
name|e1000_init_rx_addrs_generic
argument_list|(
name|hw
argument_list|,
name|mac
operator|->
name|rar_entry_count
argument_list|)
expr_stmt|;
comment|/* Zero out the Multicast HASH table */
name|DEBUGOUT
argument_list|(
literal|"Zeroing the MTA\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mac
operator|->
name|mta_reg_count
condition|;
name|i
operator|++
control|)
name|E1000_WRITE_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|E1000_MTA
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Setup link and flow control */
name|ret_val
operator|=
name|e1000_setup_link
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Set the transmit descriptor write-back policy */
name|reg_data
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TXDCTL
argument_list|)
expr_stmt|;
name|reg_data
operator|=
operator|(
name|reg_data
operator|&
operator|~
name|E1000_TXDCTL_WTHRESH
operator|)
operator||
name|E1000_TXDCTL_FULL_TX_DESC_WB
operator||
name|E1000_TXDCTL_COUNT_DESC
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TXDCTL
argument_list|,
name|reg_data
argument_list|)
expr_stmt|;
comment|/* ...for both queues. */
name|reg_data
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TXDCTL1
argument_list|)
expr_stmt|;
name|reg_data
operator|=
operator|(
name|reg_data
operator|&
operator|~
name|E1000_TXDCTL_WTHRESH
operator|)
operator||
name|E1000_TXDCTL_FULL_TX_DESC_WB
operator||
name|E1000_TXDCTL_COUNT_DESC
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TXDCTL1
argument_list|,
name|reg_data
argument_list|)
expr_stmt|;
comment|/* Enable retransmit on late collisions */
name|reg_data
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TCTL
argument_list|)
expr_stmt|;
name|reg_data
operator||=
name|E1000_TCTL_RTLC
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TCTL
argument_list|,
name|reg_data
argument_list|)
expr_stmt|;
comment|/* Configure Gigabit Carry Extend Padding */
name|reg_data
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TCTL_EXT
argument_list|)
expr_stmt|;
name|reg_data
operator|&=
operator|~
name|E1000_TCTL_EXT_GCEX_MASK
expr_stmt|;
name|reg_data
operator||=
name|DEFAULT_TCTL_EXT_GCEX_80003ES2LAN
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TCTL_EXT
argument_list|,
name|reg_data
argument_list|)
expr_stmt|;
comment|/* Configure Transmit Inter-Packet Gap */
name|reg_data
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TIPG
argument_list|)
expr_stmt|;
name|reg_data
operator|&=
operator|~
name|E1000_TIPG_IPGT_MASK
expr_stmt|;
name|reg_data
operator||=
name|DEFAULT_TIPG_IPGT_1000_80003ES2LAN
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TIPG
argument_list|,
name|reg_data
argument_list|)
expr_stmt|;
name|reg_data
operator|=
name|E1000_READ_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|E1000_FFLT
argument_list|,
literal|0x0001
argument_list|)
expr_stmt|;
name|reg_data
operator|&=
operator|~
literal|0x00100000
expr_stmt|;
name|E1000_WRITE_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|E1000_FFLT
argument_list|,
literal|0x0001
argument_list|,
name|reg_data
argument_list|)
expr_stmt|;
comment|/* Clear all of the statistics registers (clear on read).  It is 	 * important that we do this after we have tried to establish link 	 * because the symbol error count will increment wildly if there 	 * is no link. 	 */
name|e1000_clear_hw_cntrs_80003es2lan
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_initialize_hw_bits_80003es2lan - Init hw bits of ESB2  *  @hw: pointer to the HW structure  *  *  Initializes required hardware-dependent bits needed for normal operation.  **/
end_comment

begin_function
specifier|static
name|void
name|e1000_initialize_hw_bits_80003es2lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|reg
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_initialize_hw_bits_80003es2lan"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|disable_hw_init_bits
condition|)
goto|goto
name|out
goto|;
comment|/* Transmit Descriptor Control 0 */
name|reg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TXDCTL
argument_list|)
expr_stmt|;
name|reg
operator||=
operator|(
literal|1
operator|<<
literal|22
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TXDCTL
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* Transmit Descriptor Control 1 */
name|reg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TXDCTL1
argument_list|)
expr_stmt|;
name|reg
operator||=
operator|(
literal|1
operator|<<
literal|22
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TXDCTL1
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* Transmit Arbitration Control 0 */
name|reg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TARC0
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
operator|(
literal|0xF
operator|<<
literal|27
operator|)
expr_stmt|;
comment|/* 30:27 */
if|if
condition|(
name|hw
operator|->
name|media_type
operator|!=
name|e1000_media_type_copper
condition|)
name|reg
operator|&=
operator|~
operator|(
literal|1
operator|<<
literal|20
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TARC0
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* Transmit Arbitration Control 1 */
name|reg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TARC1
argument_list|)
expr_stmt|;
if|if
condition|(
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TCTL
argument_list|)
operator|&
name|E1000_TCTL_MULR
condition|)
name|reg
operator|&=
operator|~
operator|(
literal|1
operator|<<
literal|28
operator|)
expr_stmt|;
else|else
name|reg
operator||=
operator|(
literal|1
operator|<<
literal|28
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TARC1
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|out
label|:
return|return;
block|}
end_function

begin_comment
comment|/**  *  e1000_copper_link_setup_gg82563_80003es2lan - Configure GG82563 Link  *  @hw: pointer to the HW structure  *  *  Setup some GG82563 PHY registers for obtaining link  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_copper_link_setup_gg82563_80003es2lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|u32
name|ctrl_ext
decl_stmt|;
name|u16
name|data
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_copper_link_setup_gg82563_80003es2lan"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|phy
operator|->
name|reset_disable
condition|)
block|{
name|ret_val
operator|=
name|e1000_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|GG82563_PHY_MAC_SPEC_CTRL
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|data
operator||=
name|GG82563_MSCR_ASSERT_CRS_ON_TX
expr_stmt|;
comment|/* Use 25MHz for both link down and 1000Base-T for Tx clock. */
name|data
operator||=
name|GG82563_MSCR_TX_CLK_1000MBPS_25
expr_stmt|;
name|ret_val
operator|=
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|GG82563_PHY_MAC_SPEC_CTRL
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
comment|/* Options: 		 *   MDI/MDI-X = 0 (default) 		 *   0 - Auto for all speeds 		 *   1 - MDI mode 		 *   2 - MDI-X mode 		 *   3 - Auto for 1000Base-T only (MDI-X for 10/100Base-T modes) 		 */
name|ret_val
operator|=
name|e1000_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|GG82563_PHY_SPEC_CTRL
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|data
operator|&=
operator|~
name|GG82563_PSCR_CROSSOVER_MODE_MASK
expr_stmt|;
switch|switch
condition|(
name|phy
operator|->
name|mdix
condition|)
block|{
case|case
literal|1
case|:
name|data
operator||=
name|GG82563_PSCR_CROSSOVER_MODE_MDI
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|data
operator||=
name|GG82563_PSCR_CROSSOVER_MODE_MDIX
expr_stmt|;
break|break;
case|case
literal|0
case|:
default|default:
name|data
operator||=
name|GG82563_PSCR_CROSSOVER_MODE_AUTO
expr_stmt|;
break|break;
block|}
comment|/* Options: 		 *   disable_polarity_correction = 0 (default) 		 *       Automatic Correction for Reversed Cable Polarity 		 *   0 - Disabled 		 *   1 - Enabled 		 */
name|data
operator|&=
operator|~
name|GG82563_PSCR_POLARITY_REVERSAL_DISABLE
expr_stmt|;
if|if
condition|(
name|phy
operator|->
name|disable_polarity_correction
operator|==
name|TRUE
condition|)
name|data
operator||=
name|GG82563_PSCR_POLARITY_REVERSAL_DISABLE
expr_stmt|;
name|ret_val
operator|=
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|GG82563_PHY_SPEC_CTRL
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
comment|/* SW Reset the PHY so all changes take effect */
name|ret_val
operator|=
name|e1000_phy_commit
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Error Resetting the PHY\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
comment|/* Bypass RX and TX FIFO's */
name|ret_val
operator|=
name|e1000_write_kmrn_reg
argument_list|(
name|hw
argument_list|,
name|E1000_KMRNCTRLSTA_OFFSET_FIFO_CTRL
argument_list|,
name|E1000_KMRNCTRLSTA_FIFO_CTRL_RX_BYPASS
operator||
name|E1000_KMRNCTRLSTA_FIFO_CTRL_TX_BYPASS
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|ret_val
operator|=
name|e1000_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|GG82563_PHY_SPEC_CTRL_2
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|data
operator|&=
operator|~
name|GG82563_PSCR2_REVERSE_AUTO_NEG
expr_stmt|;
name|ret_val
operator|=
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|GG82563_PHY_SPEC_CTRL_2
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|ctrl_ext
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL_EXT
argument_list|)
expr_stmt|;
name|ctrl_ext
operator|&=
operator|~
operator|(
name|E1000_CTRL_EXT_LINK_MODE_MASK
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL_EXT
argument_list|,
name|ctrl_ext
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|GG82563_PHY_PWR_MGMT_CTRL
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
comment|/* Do not init these registers when the HW is in IAMT mode, since the 	 * firmware will have already initialized them.  We only initialize 	 * them if the HW is not in IAMT mode. 	 */
if|if
condition|(
name|e1000_check_mng_mode
argument_list|(
name|hw
argument_list|)
operator|==
name|FALSE
condition|)
block|{
comment|/* Enable Electrical Idle on the PHY */
name|data
operator||=
name|GG82563_PMCR_ENABLE_ELECTRICAL_IDLE
expr_stmt|;
name|ret_val
operator|=
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|GG82563_PHY_PWR_MGMT_CTRL
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|ret_val
operator|=
name|e1000_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|GG82563_PHY_KMRN_MODE_CTRL
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|data
operator|&=
operator|~
name|GG82563_KMCR_PASS_FALSE_CARRIER
expr_stmt|;
name|ret_val
operator|=
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|GG82563_PHY_KMRN_MODE_CTRL
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
block|}
comment|/* Workaround: Disable padding in Kumeran interface in the MAC 	 * and in the PHY to avoid CRC errors. 	 */
name|ret_val
operator|=
name|e1000_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|GG82563_PHY_INBAND_CTRL
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|data
operator||=
name|GG82563_ICR_DIS_PADDING
expr_stmt|;
name|ret_val
operator|=
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|GG82563_PHY_INBAND_CTRL
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_setup_copper_link_80003es2lan - Setup Copper Link for ESB2  *  @hw: pointer to the HW structure  *  *  Essentially a wrapper for setting up all things "copper" related.  *  This is a function pointer entry point called by the mac module.  **/
end_comment

begin_function
name|STATIC
name|s32
name|e1000_setup_copper_link_80003es2lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|ctrl
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|u16
name|reg_data
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_setup_copper_link_80003es2lan"
argument_list|)
expr_stmt|;
name|ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|)
expr_stmt|;
name|ctrl
operator||=
name|E1000_CTRL_SLU
expr_stmt|;
name|ctrl
operator|&=
operator|~
operator|(
name|E1000_CTRL_FRCSPD
operator||
name|E1000_CTRL_FRCDPX
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
comment|/* Set the mac to wait the maximum time between each 	 * iteration and increase the max iterations when 	 * polling the phy; this fixes erroneous timeouts at 10Mbps. */
name|ret_val
operator|=
name|e1000_write_kmrn_reg
argument_list|(
name|hw
argument_list|,
name|GG82563_REG
argument_list|(
literal|0x34
argument_list|,
literal|4
argument_list|)
argument_list|,
literal|0xFFFF
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|ret_val
operator|=
name|e1000_read_kmrn_reg
argument_list|(
name|hw
argument_list|,
name|GG82563_REG
argument_list|(
literal|0x34
argument_list|,
literal|9
argument_list|)
argument_list|,
operator|&
name|reg_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|reg_data
operator||=
literal|0x3F
expr_stmt|;
name|ret_val
operator|=
name|e1000_write_kmrn_reg
argument_list|(
name|hw
argument_list|,
name|GG82563_REG
argument_list|(
literal|0x34
argument_list|,
literal|9
argument_list|)
argument_list|,
name|reg_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|ret_val
operator|=
name|e1000_read_kmrn_reg
argument_list|(
name|hw
argument_list|,
name|E1000_KMRNCTRLSTA_OFFSET_INB_CTRL
argument_list|,
operator|&
name|reg_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|reg_data
operator||=
name|E1000_KMRNCTRLSTA_INB_CTRL_DIS_PADDING
expr_stmt|;
name|ret_val
operator|=
name|e1000_write_kmrn_reg
argument_list|(
name|hw
argument_list|,
name|E1000_KMRNCTRLSTA_OFFSET_INB_CTRL
argument_list|,
name|reg_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|ret_val
operator|=
name|e1000_copper_link_setup_gg82563_80003es2lan
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|ret_val
operator|=
name|e1000_setup_copper_link_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_cfg_kmrn_10_100_80003es2lan - Apply "quirks" for 10/100 operation  *  @hw: pointer to the HW structure  *  @duplex: current duplex setting  *  *  Configure the KMRN interface by applying last minute quirks for  *  10/100 operation.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_cfg_kmrn_10_100_80003es2lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|duplex
parameter_list|)
block|{
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|u32
name|tipg
decl_stmt|;
name|u32
name|i
init|=
literal|0
decl_stmt|;
name|u16
name|reg_data
decl_stmt|,
name|reg_data2
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_configure_kmrn_for_10_100"
argument_list|)
expr_stmt|;
name|reg_data
operator|=
name|E1000_KMRNCTRLSTA_HD_CTRL_10_100_DEFAULT
expr_stmt|;
name|ret_val
operator|=
name|e1000_write_kmrn_reg
argument_list|(
name|hw
argument_list|,
name|E1000_KMRNCTRLSTA_OFFSET_HD_CTRL
argument_list|,
name|reg_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
comment|/* Configure Transmit Inter-Packet Gap */
name|tipg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TIPG
argument_list|)
expr_stmt|;
name|tipg
operator|&=
operator|~
name|E1000_TIPG_IPGT_MASK
expr_stmt|;
name|tipg
operator||=
name|DEFAULT_TIPG_IPGT_10_100_80003ES2LAN
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TIPG
argument_list|,
name|tipg
argument_list|)
expr_stmt|;
do|do
block|{
name|ret_val
operator|=
name|e1000_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|GG82563_PHY_KMRN_MODE_CTRL
argument_list|,
operator|&
name|reg_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|ret_val
operator|=
name|e1000_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|GG82563_PHY_KMRN_MODE_CTRL
argument_list|,
operator|&
name|reg_data2
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|i
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|reg_data
operator|!=
name|reg_data2
operator|)
operator|&&
operator|(
name|i
operator|<
name|GG82563_MAX_KMRN_RETRY
operator|)
condition|)
do|;
if|if
condition|(
name|duplex
operator|==
name|HALF_DUPLEX
condition|)
name|reg_data
operator||=
name|GG82563_KMCR_PASS_FALSE_CARRIER
expr_stmt|;
else|else
name|reg_data
operator|&=
operator|~
name|GG82563_KMCR_PASS_FALSE_CARRIER
expr_stmt|;
name|ret_val
operator|=
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|GG82563_PHY_KMRN_MODE_CTRL
argument_list|,
name|reg_data
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_cfg_kmrn_1000_80003es2lan - Apply "quirks" for gigabit operation  *  @hw: pointer to the HW structure  *  *  Configure the KMRN interface by applying last minute quirks for  *  gigabit operation.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_cfg_kmrn_1000_80003es2lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|u16
name|reg_data
decl_stmt|,
name|reg_data2
decl_stmt|;
name|u32
name|tipg
decl_stmt|;
name|u32
name|i
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_configure_kmrn_for_1000"
argument_list|)
expr_stmt|;
name|reg_data
operator|=
name|E1000_KMRNCTRLSTA_HD_CTRL_1000_DEFAULT
expr_stmt|;
name|ret_val
operator|=
name|e1000_write_kmrn_reg
argument_list|(
name|hw
argument_list|,
name|E1000_KMRNCTRLSTA_OFFSET_HD_CTRL
argument_list|,
name|reg_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
comment|/* Configure Transmit Inter-Packet Gap */
name|tipg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TIPG
argument_list|)
expr_stmt|;
name|tipg
operator|&=
operator|~
name|E1000_TIPG_IPGT_MASK
expr_stmt|;
name|tipg
operator||=
name|DEFAULT_TIPG_IPGT_1000_80003ES2LAN
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TIPG
argument_list|,
name|tipg
argument_list|)
expr_stmt|;
do|do
block|{
name|ret_val
operator|=
name|e1000_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|GG82563_PHY_KMRN_MODE_CTRL
argument_list|,
operator|&
name|reg_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|ret_val
operator|=
name|e1000_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|GG82563_PHY_KMRN_MODE_CTRL
argument_list|,
operator|&
name|reg_data2
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|i
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|reg_data
operator|!=
name|reg_data2
operator|)
operator|&&
operator|(
name|i
operator|<
name|GG82563_MAX_KMRN_RETRY
operator|)
condition|)
do|;
name|reg_data
operator|&=
operator|~
name|GG82563_KMCR_PASS_FALSE_CARRIER
expr_stmt|;
name|ret_val
operator|=
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|GG82563_PHY_KMRN_MODE_CTRL
argument_list|,
name|reg_data
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_clear_hw_cntrs_80003es2lan - Clear device specific hardware counters  *  @hw: pointer to the HW structure  *  *  Clears the hardware counters by reading the counter registers.  **/
end_comment

begin_function
name|STATIC
name|void
name|e1000_clear_hw_cntrs_80003es2lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
specifier|volatile
name|u32
name|temp
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_clear_hw_cntrs_80003es2lan"
argument_list|)
expr_stmt|;
name|e1000_clear_hw_cntrs_base_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PRC64
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PRC127
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PRC255
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PRC511
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PRC1023
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PRC1522
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PTC64
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PTC127
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PTC255
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PTC511
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PTC1023
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PTC1522
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_ALGNERRC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RXERRC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TNCRS
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CEXTERR
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TSCTC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TSCTFC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_MGTPRC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_MGTPDC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_MGTPTC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_IAC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_ICRXOC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_ICRXPTC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_ICRXATC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_ICTXPTC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_ICTXATC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_ICTXQEC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_ICTXQMTC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_ICRXDMTC
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

