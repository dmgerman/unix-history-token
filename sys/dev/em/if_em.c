begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/************************************************************************** **************************************************************************  Copyright (c) 2001 Intel Corporation All rights reserved.  Redistribution and use in source and binary forms of the Software, with or without modification, are permitted provided that the following conditions are met:   1. Redistributions of source code of the Software may retain the above     copyright notice, this list of conditions and the following disclaimer.   2. Redistributions in binary form of the Software may reproduce the above     copyright notice, this list of conditions and the following disclaimer     in the documentation and/or other materials provided with the     distribution.   3. Neither the name of the Intel Corporation nor the names of its     contributors shall be used to endorse or promote products derived from     this Software without specific prior written permission.  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE INTEL OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *************************************************************************** ***************************************************************************/
end_comment

begin_comment
comment|/*$FreeBSD$*/
end_comment

begin_include
include|#
directive|include
file|<dev/em/if_em.h>
end_include

begin_comment
comment|/*********************************************************************  *  Set this to one to display debug statistics                                                     *********************************************************************/
end_comment

begin_decl_stmt
name|int
name|em_display_debug_stats
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*********************************************************************  *  Linked list of board private structures for all NICs found  *********************************************************************/
end_comment

begin_decl_stmt
name|struct
name|adapter
modifier|*
name|em_adapter_list
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*********************************************************************  *  Driver version  *********************************************************************/
end_comment

begin_decl_stmt
name|char
name|em_driver_version
index|[]
init|=
literal|"1.0.9"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*********************************************************************  *  PCI Device ID Table  *  *  Used by probe to select devices to load on  *  Last field stores an index into em_strings  *  Last entry must be all 0s  *  *  { Vendor ID, Device ID, SubVendor ID, SubDevice ID, String Index }  *********************************************************************/
end_comment

begin_decl_stmt
specifier|static
name|em_vendor_info_t
name|em_vendor_info_array
index|[]
init|=
block|{
comment|/* Intel(R) PRO/1000 Network Connection */
block|{
literal|0x8086
block|,
literal|0x1000
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
literal|0x1001
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
literal|0x1004
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
literal|0x1008
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
literal|0x1009
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
literal|0x100C
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
literal|0x100D
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
comment|/* required last entry */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*********************************************************************  *  Table of branding strings for all supported NICs.  *********************************************************************/
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|em_strings
index|[]
init|=
block|{
literal|"Intel(R) PRO/1000 Network Connection"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*********************************************************************  *  Function prototypes              *********************************************************************/
end_comment

begin_decl_stmt
specifier|static
name|int
name|em_probe
name|__P
argument_list|(
operator|(
name|device_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|em_attach
name|__P
argument_list|(
operator|(
name|device_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|em_detach
name|__P
argument_list|(
operator|(
name|device_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|em_shutdown
name|__P
argument_list|(
operator|(
name|device_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|em_intr
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|em_start
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|em_ioctl
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
operator|,
name|IOCTL_CMD_TYPE
operator|,
name|caddr_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|em_watchdog
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|em_init
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|em_stop
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|em_media_status
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
operator|,
expr|struct
name|ifmediareq
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|em_media_change
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|em_identify_hardware
name|__P
argument_list|(
operator|(
expr|struct
name|adapter
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|em_allocate_pci_resources
name|__P
argument_list|(
operator|(
expr|struct
name|adapter
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|em_free_pci_resources
name|__P
argument_list|(
operator|(
expr|struct
name|adapter
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|em_local_timer
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|em_hardware_init
name|__P
argument_list|(
operator|(
expr|struct
name|adapter
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|em_read_mac_address
name|__P
argument_list|(
operator|(
expr|struct
name|adapter
operator|*
operator|,
name|u_int8_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|em_setup_interface
name|__P
argument_list|(
operator|(
name|device_t
operator|,
expr|struct
name|adapter
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|em_setup_transmit_structures
name|__P
argument_list|(
operator|(
expr|struct
name|adapter
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|em_initialize_transmit_unit
name|__P
argument_list|(
operator|(
expr|struct
name|adapter
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|em_setup_receive_structures
name|__P
argument_list|(
operator|(
expr|struct
name|adapter
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|em_initialize_receive_unit
name|__P
argument_list|(
operator|(
expr|struct
name|adapter
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|EnableInterrupts
name|__P
argument_list|(
operator|(
expr|struct
name|adapter
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|DisableInterrupts
name|__P
argument_list|(
operator|(
expr|struct
name|adapter
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|em_free_transmit_structures
name|__P
argument_list|(
operator|(
expr|struct
name|adapter
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|em_free_receive_structures
name|__P
argument_list|(
operator|(
expr|struct
name|adapter
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|em_update_stats_counters
name|__P
argument_list|(
operator|(
expr|struct
name|adapter
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|em_clean_transmit_interrupts
name|__P
argument_list|(
operator|(
expr|struct
name|adapter
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|em_allocate_receive_structures
name|__P
argument_list|(
operator|(
expr|struct
name|adapter
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|em_allocate_transmit_structures
name|__P
argument_list|(
operator|(
expr|struct
name|adapter
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|em_process_receive_interrupts
name|__P
argument_list|(
operator|(
expr|struct
name|adapter
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|em_receive_checksum
name|__P
argument_list|(
operator|(
expr|struct
name|adapter
operator|*
operator|,
name|PE1000_RECEIVE_DESCRIPTOR
name|RxDescriptor
operator|,
expr|struct
name|mbuf
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|em_transmit_checksum_setup
name|__P
argument_list|(
operator|(
expr|struct
name|adapter
operator|*
operator|,
expr|struct
name|mbuf
operator|*
operator|,
expr|struct
name|em_tx_buffer
operator|*
operator|,
name|u_int32_t
operator|*
operator|,
name|u_int32_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|em_set_promisc
name|__P
argument_list|(
operator|(
expr|struct
name|adapter
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|em_disable_promisc
name|__P
argument_list|(
operator|(
expr|struct
name|adapter
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|em_set_multi
name|__P
argument_list|(
operator|(
expr|struct
name|adapter
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|em_print_hw_stats
name|__P
argument_list|(
operator|(
expr|struct
name|adapter
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|em_print_link_status
name|__P
argument_list|(
operator|(
expr|struct
name|adapter
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|em_get_buf
name|__P
argument_list|(
operator|(
expr|struct
name|em_rx_buffer
operator|*
operator|,
expr|struct
name|adapter
operator|*
operator|,
expr|struct
name|mbuf
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|em_get_std_buf
name|__P
argument_list|(
operator|(
expr|struct
name|em_rx_buffer
operator|*
operator|,
expr|struct
name|adapter
operator|*
operator|,
expr|struct
name|mbuf
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Jumbo Frame */
end_comment

begin_decl_stmt
specifier|static
name|int
name|em_alloc_jumbo_mem
name|__P
argument_list|(
operator|(
expr|struct
name|adapter
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
modifier|*
name|em_jalloc
name|__P
argument_list|(
operator|(
expr|struct
name|adapter
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|em_jref
name|__P
argument_list|(
operator|(
name|caddr_t
name|buf
operator|,
name|u_int
name|size
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|em_jfree
name|__P
argument_list|(
operator|(
name|caddr_t
name|buf
operator|,
name|u_int
name|size
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|em_get_jumbo_buf
name|__P
argument_list|(
operator|(
expr|struct
name|em_rx_buffer
operator|*
operator|,
expr|struct
name|adapter
operator|*
operator|,
expr|struct
name|mbuf
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*********************************************************************  *  FreeBSD Device Interface Entry Points                      *********************************************************************/
end_comment

begin_decl_stmt
specifier|static
name|device_method_t
name|em_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|em_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|em_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|em_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|em_shutdown
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|em_driver
init|=
block|{
literal|"em"
block|,
name|em_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|adapter
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|em_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|if_em
argument_list|,
name|pci
argument_list|,
name|em_driver
argument_list|,
name|em_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*********************************************************************  *  Device identification routine  *  *  em_probe determines if the driver should be loaded on  *  adapter based on PCI vendor/device id of the adapter.  *  *  return 0 on success, positive on failure  *********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|em_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|em_vendor_info_t
modifier|*
name|ent
decl_stmt|;
name|u_int16_t
name|pci_vendor_id
init|=
literal|0
decl_stmt|;
name|u_int16_t
name|pci_device_id
init|=
literal|0
decl_stmt|;
name|u_int16_t
name|pci_subvendor_id
init|=
literal|0
decl_stmt|;
name|u_int16_t
name|pci_subdevice_id
init|=
literal|0
decl_stmt|;
name|char
name|adapter_name
index|[
literal|60
index|]
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"em_probe: begin"
argument_list|)
expr_stmt|;
name|pci_vendor_id
operator|=
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|pci_vendor_id
operator|!=
name|EM_VENDOR_ID
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|pci_device_id
operator|=
name|pci_get_device
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|pci_subvendor_id
operator|=
name|pci_get_subvendor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|pci_subdevice_id
operator|=
name|pci_get_subdevice
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ent
operator|=
name|em_vendor_info_array
expr_stmt|;
while|while
condition|(
name|ent
operator|->
name|vendor_id
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|pci_vendor_id
operator|==
name|ent
operator|->
name|vendor_id
operator|)
operator|&&
operator|(
name|pci_device_id
operator|==
name|ent
operator|->
name|device_id
operator|)
operator|&&
operator|(
operator|(
name|pci_subvendor_id
operator|==
name|ent
operator|->
name|subvendor_id
operator|)
operator|||
operator|(
name|ent
operator|->
name|subvendor_id
operator|==
name|PCI_ANY_ID
operator|)
operator|)
operator|&&
operator|(
operator|(
name|pci_subdevice_id
operator|==
name|ent
operator|->
name|subdevice_id
operator|)
operator|||
operator|(
name|ent
operator|->
name|subdevice_id
operator|==
name|PCI_ANY_ID
operator|)
operator|)
condition|)
block|{
name|INIT_DEBUGOUT1
argument_list|(
literal|"em_probe: Found PRO/1000  (pci_device_id=0x%x)"
argument_list|,
name|pci_device_id
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|adapter_name
argument_list|,
literal|"%s, Version - %s"
argument_list|,
name|em_strings
index|[
name|ent
operator|->
name|index
index|]
argument_list|,
name|em_driver_version
argument_list|)
expr_stmt|;
name|device_set_desc_copy
argument_list|(
name|dev
argument_list|,
name|adapter_name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|ent
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  Device initialization routine  *  *  The attach entry point is called when the driver is being loaded.  *  This routine identifies the type of hardware, allocates all resources   *  and initializes the hardware.       *    *  return 0 on success, positive on failure  *********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|em_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|Adapter
decl_stmt|;
name|int
name|s
decl_stmt|;
name|int
name|tsize
decl_stmt|,
name|rsize
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"em_attach: begin"
argument_list|)
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
comment|/* Allocate, clear, and link in our Adapter structure */
if|if
condition|(
operator|!
operator|(
name|Adapter
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"em: Adapter structure allocation failed\n"
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|bzero
argument_list|(
name|Adapter
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|adapter
argument_list|)
argument_list|)
expr_stmt|;
name|Adapter
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|Adapter
operator|->
name|unit
operator|=
name|device_get_unit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|em_adapter_list
operator|!=
name|NULL
condition|)
name|em_adapter_list
operator|->
name|prev
operator|=
name|Adapter
expr_stmt|;
name|Adapter
operator|->
name|next
operator|=
name|em_adapter_list
expr_stmt|;
name|em_adapter_list
operator|=
name|Adapter
expr_stmt|;
name|callout_handle_init
argument_list|(
operator|&
name|Adapter
operator|->
name|timer_handle
argument_list|)
expr_stmt|;
comment|/* Determine hardware revision */
name|em_identify_hardware
argument_list|(
name|Adapter
argument_list|)
expr_stmt|;
comment|/* Parameters (to be read from user) */
name|Adapter
operator|->
name|NumTxDescriptors
operator|=
name|MAX_TXD
expr_stmt|;
name|Adapter
operator|->
name|NumRxDescriptors
operator|=
name|MAX_RXD
expr_stmt|;
name|Adapter
operator|->
name|TxIntDelay
operator|=
name|TIDV
expr_stmt|;
name|Adapter
operator|->
name|RxIntDelay
operator|=
name|RIDV
expr_stmt|;
name|Adapter
operator|->
name|AutoNeg
operator|=
name|DO_AUTO_NEG
expr_stmt|;
name|Adapter
operator|->
name|WaitAutoNegComplete
operator|=
name|WAIT_FOR_AUTO_NEG_DEFAULT
expr_stmt|;
name|Adapter
operator|->
name|AutoNegAdvertised
operator|=
name|AUTONEG_ADV_DEFAULT
expr_stmt|;
name|Adapter
operator|->
name|TbiCompatibilityEnable
operator|=
name|TRUE
expr_stmt|;
name|Adapter
operator|->
name|RxBufferLen
operator|=
name|EM_RXBUFFER_2048
expr_stmt|;
name|Adapter
operator|->
name|RxChecksum
operator|=
name|EM_ENABLE_RXCSUM_OFFLOAD
expr_stmt|;
name|Adapter
operator|->
name|JumboEnable
operator|=
name|EM_JUMBO_ENABLE_DEFAULT
expr_stmt|;
name|Adapter
operator|->
name|FlowControlHighWatermark
operator|=
name|FC_DEFAULT_HI_THRESH
expr_stmt|;
name|Adapter
operator|->
name|FlowControlLowWatermark
operator|=
name|FC_DEFAULT_LO_THRESH
expr_stmt|;
name|Adapter
operator|->
name|FlowControlPauseTime
operator|=
name|FC_DEFAULT_TX_TIMER
expr_stmt|;
name|Adapter
operator|->
name|FlowControlSendXon
operator|=
name|TRUE
expr_stmt|;
name|Adapter
operator|->
name|FlowControl
operator|=
name|FLOW_CONTROL_FULL
expr_stmt|;
comment|/* Set the max frame size assuming standard ethernet sized frames */
name|Adapter
operator|->
name|MaxFrameSize
operator|=
name|ETHERMTU
operator|+
name|ETHER_HDR_LEN
operator|+
name|ETHER_CRC_LEN
expr_stmt|;
comment|/* This controls when hardware reports transmit completion status. */
if|if
condition|(
operator|(
name|EM_REPORT_TX_EARLY
operator|==
literal|0
operator|)
operator|||
operator|(
name|EM_REPORT_TX_EARLY
operator|==
literal|1
operator|)
condition|)
block|{
name|Adapter
operator|->
name|ReportTxEarly
operator|=
name|EM_REPORT_TX_EARLY
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|Adapter
operator|->
name|MacType
operator|<
name|MAC_LIVENGOOD
condition|)
block|{
name|Adapter
operator|->
name|ReportTxEarly
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|Adapter
operator|->
name|ReportTxEarly
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|em_allocate_pci_resources
argument_list|(
name|Adapter
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"em%d: Allocation of PCI resources failed\n"
argument_list|,
name|Adapter
operator|->
name|unit
argument_list|)
expr_stmt|;
name|em_free_pci_resources
argument_list|(
name|Adapter
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|tsize
operator|=
name|EM_ROUNDUP
argument_list|(
name|Adapter
operator|->
name|NumTxDescriptors
operator|*
sizeof|sizeof
argument_list|(
name|E1000_TRANSMIT_DESCRIPTOR
argument_list|)
argument_list|,
literal|4096
argument_list|)
expr_stmt|;
comment|/* Allocate Transmit Descriptor ring */
if|if
condition|(
operator|!
operator|(
name|Adapter
operator|->
name|TxDescBase
operator|=
operator|(
name|PE1000_TRANSMIT_DESCRIPTOR
operator|)
name|contigmalloc
argument_list|(
name|tsize
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
name|PAGE_SIZE
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"em%d: Unable to allocate TxDescriptor memory\n"
argument_list|,
name|Adapter
operator|->
name|unit
argument_list|)
expr_stmt|;
name|em_free_pci_resources
argument_list|(
name|Adapter
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|rsize
operator|=
name|EM_ROUNDUP
argument_list|(
name|Adapter
operator|->
name|NumRxDescriptors
operator|*
sizeof|sizeof
argument_list|(
name|E1000_RECEIVE_DESCRIPTOR
argument_list|)
argument_list|,
literal|4096
argument_list|)
expr_stmt|;
comment|/* Allocate Receive Descriptor ring */
if|if
condition|(
operator|!
operator|(
name|Adapter
operator|->
name|RxDescBase
operator|=
operator|(
name|PE1000_RECEIVE_DESCRIPTOR
operator|)
name|contigmalloc
argument_list|(
name|rsize
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
name|PAGE_SIZE
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"em%d: Unable to allocate RxDescriptor memory\n"
argument_list|,
name|Adapter
operator|->
name|unit
argument_list|)
expr_stmt|;
name|em_free_pci_resources
argument_list|(
name|Adapter
argument_list|)
expr_stmt|;
name|contigfree
argument_list|(
name|Adapter
operator|->
name|TxDescBase
argument_list|,
name|tsize
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/* Allocate memory for jumbo frame buffers.     * We don't support jumbo frames on 82542 based adapters.     */
if|if
condition|(
name|Adapter
operator|->
name|MacType
operator|>=
name|MAC_LIVENGOOD
condition|)
block|{
if|if
condition|(
name|em_alloc_jumbo_mem
argument_list|(
name|Adapter
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"em%d: Unable to allocate Jumbo memory\n"
argument_list|,
name|Adapter
operator|->
name|unit
argument_list|)
expr_stmt|;
name|em_free_pci_resources
argument_list|(
name|Adapter
argument_list|)
expr_stmt|;
name|contigfree
argument_list|(
name|Adapter
operator|->
name|TxDescBase
argument_list|,
name|tsize
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|contigfree
argument_list|(
name|Adapter
operator|->
name|RxDescBase
argument_list|,
name|rsize
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
block|}
comment|/* Initialize the hardware */
if|if
condition|(
name|em_hardware_init
argument_list|(
name|Adapter
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"em%d: Unable to initialize the hardware\n"
argument_list|,
name|Adapter
operator|->
name|unit
argument_list|)
expr_stmt|;
name|em_free_pci_resources
argument_list|(
name|Adapter
argument_list|)
expr_stmt|;
name|contigfree
argument_list|(
name|Adapter
operator|->
name|TxDescBase
argument_list|,
name|tsize
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|contigfree
argument_list|(
name|Adapter
operator|->
name|RxDescBase
argument_list|,
name|rsize
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|Adapter
operator|->
name|MacType
operator|>=
name|MAC_LIVENGOOD
condition|)
name|contigfree
argument_list|(
name|Adapter
operator|->
name|em_jumbo_buf
argument_list|,
name|EM_JMEM
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
comment|/* Setup OS specific network interface */
name|em_setup_interface
argument_list|(
name|dev
argument_list|,
name|Adapter
argument_list|)
expr_stmt|;
comment|/* Initialize statistics */
name|em_clear_hw_stats_counters
argument_list|(
name|Adapter
argument_list|)
expr_stmt|;
name|em_update_stats_counters
argument_list|(
name|Adapter
argument_list|)
expr_stmt|;
name|Adapter
operator|->
name|GetLinkStatus
operator|=
literal|1
expr_stmt|;
name|em_check_for_link
argument_list|(
name|Adapter
argument_list|)
expr_stmt|;
comment|/* Print the link status */
if|if
condition|(
name|Adapter
operator|->
name|LinkIsActive
operator|==
literal|1
condition|)
name|printf
argument_list|(
literal|"em%d:  Speed:%d Mbps  Duplex:%s\n"
argument_list|,
name|Adapter
operator|->
name|unit
argument_list|,
name|Adapter
operator|->
name|LineSpeed
argument_list|,
name|Adapter
operator|->
name|FullDuplex
operator|==
name|FULL_DUPLEX
condition|?
literal|"Full"
else|:
literal|"Half"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"em%d:  Speed:N/A  Duplex:N/A\n"
argument_list|,
name|Adapter
operator|->
name|unit
argument_list|)
expr_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"em_attach: end"
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  Device removal routine  *  *  The detach entry point is called when the driver is being removed.  *  This routine stops the adapter and deallocates all the resources  *  that were allocated for driver operation.  *    *  return 0 on success, positive on failure  *********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|em_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|Adapter
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|Adapter
operator|->
name|interface_data
operator|.
name|ac_if
decl_stmt|;
name|int
name|s
decl_stmt|;
name|int
name|size
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"em_detach: begin"
argument_list|)
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|em_stop
argument_list|(
name|Adapter
argument_list|)
expr_stmt|;
name|em_phy_hardware_reset
argument_list|(
name|Adapter
argument_list|)
expr_stmt|;
name|ether_ifdetach
argument_list|(
operator|&
name|Adapter
operator|->
name|interface_data
operator|.
name|ac_if
argument_list|,
name|ETHER_BPF_SUPPORTED
argument_list|)
expr_stmt|;
name|em_free_pci_resources
argument_list|(
name|Adapter
argument_list|)
expr_stmt|;
name|size
operator|=
name|EM_ROUNDUP
argument_list|(
name|Adapter
operator|->
name|NumTxDescriptors
operator|*
sizeof|sizeof
argument_list|(
name|E1000_TRANSMIT_DESCRIPTOR
argument_list|)
argument_list|,
literal|4096
argument_list|)
expr_stmt|;
comment|/* Free Transmit Descriptor ring */
if|if
condition|(
name|Adapter
operator|->
name|TxDescBase
condition|)
block|{
name|contigfree
argument_list|(
name|Adapter
operator|->
name|TxDescBase
argument_list|,
name|size
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|Adapter
operator|->
name|TxDescBase
operator|=
name|NULL
expr_stmt|;
block|}
name|size
operator|=
name|EM_ROUNDUP
argument_list|(
name|Adapter
operator|->
name|NumRxDescriptors
operator|*
sizeof|sizeof
argument_list|(
name|E1000_RECEIVE_DESCRIPTOR
argument_list|)
argument_list|,
literal|4096
argument_list|)
expr_stmt|;
comment|/* Free Receive Descriptor ring */
if|if
condition|(
name|Adapter
operator|->
name|RxDescBase
condition|)
block|{
name|contigfree
argument_list|(
name|Adapter
operator|->
name|RxDescBase
argument_list|,
name|size
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|Adapter
operator|->
name|RxDescBase
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Free Jumbo Frame buffers */
if|if
condition|(
name|Adapter
operator|->
name|MacType
operator|>=
name|MAC_LIVENGOOD
condition|)
block|{
if|if
condition|(
name|Adapter
operator|->
name|em_jumbo_buf
condition|)
block|{
name|contigfree
argument_list|(
name|Adapter
operator|->
name|em_jumbo_buf
argument_list|,
name|EM_JMEM
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|Adapter
operator|->
name|em_jumbo_buf
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* Remove from the adapter list */
if|if
condition|(
name|em_adapter_list
operator|==
name|Adapter
condition|)
name|em_adapter_list
operator|=
name|Adapter
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|Adapter
operator|->
name|next
operator|!=
name|NULL
condition|)
name|Adapter
operator|->
name|next
operator|->
name|prev
operator|=
name|Adapter
operator|->
name|prev
expr_stmt|;
if|if
condition|(
name|Adapter
operator|->
name|prev
operator|!=
name|NULL
condition|)
name|Adapter
operator|->
name|prev
operator|->
name|next
operator|=
name|Adapter
operator|->
name|next
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
operator|(
name|IFF_RUNNING
operator||
name|IFF_OACTIVE
operator|)
expr_stmt|;
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|em_shutdown
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|Adapter
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
comment|/* Issue a global reset */
name|em_adapter_stop
argument_list|(
name|Adapter
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  Transmit entry point  *  *  em_start is called by the stack to initiate a transmit.  *  The driver will remain in this routine as long as there are  *  packets to transmit and transmit resources are available.  *  In case resources are not available stack is notified and  *  the packet is requeued.  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|em_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|struct
name|em_tx_buffer
modifier|*
name|tx_buffer
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m_head
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mp
decl_stmt|;
name|vm_offset_t
name|VirtualAddress
decl_stmt|;
name|u_int32_t
name|txd_upper
decl_stmt|;
name|u_int32_t
name|txd_lower
decl_stmt|;
name|PE1000_TRANSMIT_DESCRIPTOR
name|CurrentTxDescriptor
init|=
name|NULL
decl_stmt|;
name|struct
name|adapter
modifier|*
name|Adapter
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|TXRX_DEBUGOUT
argument_list|(
literal|"em_start: begin"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Adapter
operator|->
name|LinkIsActive
condition|)
return|return;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
while|while
condition|(
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_head
operator|!=
name|NULL
condition|)
block|{
name|IF_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m_head
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_head
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|Adapter
operator|->
name|NumTxDescriptorsAvail
operator|<=
name|TX_CLEANUP_THRESHOLD
condition|)
name|em_clean_transmit_interrupts
argument_list|(
name|Adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|Adapter
operator|->
name|NumTxDescriptorsAvail
operator|<=
name|TX_CLEANUP_THRESHOLD
condition|)
block|{
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_OACTIVE
expr_stmt|;
name|IF_PREPEND
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m_head
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DBG_STATS
name|Adapter
operator|->
name|NoTxDescAvail
operator|++
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
name|tx_buffer
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|Adapter
operator|->
name|FreeSwTxPacketList
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tx_buffer
condition|)
block|{
ifdef|#
directive|ifdef
name|DBG_STATS
name|Adapter
operator|->
name|NoTxBufferAvail1
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/*            * OK so we should not get here but I've seen it so lets try to            * clean up and then try to get a SwPacket again and only break            * if we still don't get one            */
name|em_clean_transmit_interrupts
argument_list|(
name|Adapter
argument_list|)
expr_stmt|;
name|tx_buffer
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|Adapter
operator|->
name|FreeSwTxPacketList
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tx_buffer
condition|)
block|{
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_OACTIVE
expr_stmt|;
name|IF_PREPEND
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m_head
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DBG_STATS
name|Adapter
operator|->
name|NoTxBufferAvail2
operator|++
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
block|}
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|Adapter
operator|->
name|FreeSwTxPacketList
argument_list|,
name|em_tx_entry
argument_list|)
expr_stmt|;
name|tx_buffer
operator|->
name|NumTxDescriptorsUsed
operator|=
literal|0
expr_stmt|;
name|tx_buffer
operator|->
name|Packet
operator|=
name|m_head
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_hwassist
operator|>
literal|0
condition|)
block|{
name|em_transmit_checksum_setup
argument_list|(
name|Adapter
argument_list|,
name|m_head
argument_list|,
name|tx_buffer
argument_list|,
operator|&
name|txd_upper
argument_list|,
operator|&
name|txd_lower
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|txd_upper
operator|=
literal|0
expr_stmt|;
name|txd_lower
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|mp
operator|=
name|m_head
init|;
name|mp
operator|!=
name|NULL
condition|;
name|mp
operator|=
name|mp
operator|->
name|m_next
control|)
block|{
if|if
condition|(
name|mp
operator|->
name|m_len
operator|==
literal|0
condition|)
continue|continue;
name|CurrentTxDescriptor
operator|=
name|Adapter
operator|->
name|NextAvailTxDescriptor
expr_stmt|;
name|VirtualAddress
operator|=
name|mtod
argument_list|(
name|mp
argument_list|,
name|vm_offset_t
argument_list|)
expr_stmt|;
name|CurrentTxDescriptor
operator|->
name|BufferAddress
operator|.
name|Hi32
operator|=
literal|0
expr_stmt|;
name|CurrentTxDescriptor
operator|->
name|BufferAddress
operator|.
name|Lo32
operator|=
name|vtophys
argument_list|(
name|VirtualAddress
argument_list|)
expr_stmt|;
name|CurrentTxDescriptor
operator|->
name|Lower
operator|.
name|DwordData
operator|=
operator|(
name|txd_lower
operator||
name|mp
operator|->
name|m_len
operator|)
expr_stmt|;
name|CurrentTxDescriptor
operator|->
name|Upper
operator|.
name|DwordData
operator|=
operator|(
name|txd_upper
operator|)
expr_stmt|;
if|if
condition|(
name|CurrentTxDescriptor
operator|==
name|Adapter
operator|->
name|LastTxDescriptor
condition|)
name|Adapter
operator|->
name|NextAvailTxDescriptor
operator|=
name|Adapter
operator|->
name|FirstTxDescriptor
expr_stmt|;
else|else
name|Adapter
operator|->
name|NextAvailTxDescriptor
operator|++
expr_stmt|;
name|Adapter
operator|->
name|NumTxDescriptorsAvail
operator|--
expr_stmt|;
name|tx_buffer
operator|->
name|NumTxDescriptorsUsed
operator|++
expr_stmt|;
block|}
comment|/* Put this tx_buffer at the end in the "in use" list */
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|Adapter
operator|->
name|UsedSwTxPacketList
argument_list|,
name|tx_buffer
argument_list|,
name|em_tx_entry
argument_list|)
expr_stmt|;
comment|/*         * Last Descriptor of Packet needs End Of Packet (EOP), Report Status        * (RS) and append Ethernet CRC (IFCS) bits set.        */
name|CurrentTxDescriptor
operator|->
name|Lower
operator|.
name|DwordData
operator||=
operator|(
name|Adapter
operator|->
name|TxdCmd
operator||
name|E1000_TXD_CMD_EOP
operator|)
expr_stmt|;
comment|/* Send a copy of the frame to the BPF listener */
if|if
condition|(
name|ifp
operator|->
name|if_bpf
condition|)
name|bpf_mtap
argument_list|(
name|ifp
argument_list|,
name|m_head
argument_list|)
expr_stmt|;
comment|/*         * Advance the Transmit Descriptor Tail (Tdt), this tells the E1000        * that this frame is available to transmit.        */
name|E1000_WRITE_REG
argument_list|(
name|Tdt
argument_list|,
operator|(
operator|(
operator|(
name|u_int32_t
operator|)
name|Adapter
operator|->
name|NextAvailTxDescriptor
operator|-
operator|(
name|u_int32_t
operator|)
name|Adapter
operator|->
name|FirstTxDescriptor
operator|)
operator|>>
literal|4
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* end of while loop */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* Set timeout in case chip has problems transmitting */
name|ifp
operator|->
name|if_timer
operator|=
name|EM_TX_TIMEOUT
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  Ioctl entry point  *  *  em_ioctl is called when the user wants to configure the  *  interface.  *  *  return 0 on success, positive on failure  **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|em_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|IOCTL_CMD_TYPE
name|command
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|int
name|s
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|adapter
modifier|*
name|Adapter
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|command
condition|)
block|{
case|case
name|SIOCSIFADDR
case|:
case|case
name|SIOCGIFADDR
case|:
name|IOCTL_DEBUGOUT
argument_list|(
literal|"ioctl rcv'd: SIOCxIFADDR (Get/Set Interface Addr)"
argument_list|)
expr_stmt|;
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|command
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFMTU
case|:
name|IOCTL_DEBUGOUT
argument_list|(
literal|"ioctl rcv'd: SIOCSIFMTU (Set Interface MTU)"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORTLARGEFRAME
if|if
condition|(
name|ifr
operator|->
name|ifr_mtu
operator|>
name|MAX_JUMBO_FRAME_SIZE
operator|-
name|ETHER_HDR_LEN
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
else|else
block|{
name|ifp
operator|->
name|if_mtu
operator|=
name|ifr
operator|->
name|ifr_mtu
expr_stmt|;
name|Adapter
operator|->
name|MaxFrameSize
operator|=
name|ifp
operator|->
name|if_mtu
operator|+
name|ETHER_HDR_LEN
operator|+
name|ETHER_CRC_LEN
expr_stmt|;
name|em_init
argument_list|(
name|Adapter
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
name|ifr
operator|->
name|ifr_mtu
operator|>
name|EM_JUMBO_MTU
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ifr
operator|->
name|ifr_mtu
operator|>
name|ETHERMTU
operator|&&
name|Adapter
operator|->
name|MacType
operator|<
name|MAC_LIVENGOOD
condition|)
block|{
name|printf
argument_list|(
literal|"Jumbo frames are not supported on 82542 based adapters\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
else|else
block|{
name|ifp
operator|->
name|if_mtu
operator|=
name|ifr
operator|->
name|ifr_mtu
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_mtu
operator|>
name|ETHERMTU
condition|)
block|{
name|Adapter
operator|->
name|JumboEnable
operator|=
literal|1
expr_stmt|;
name|Adapter
operator|->
name|RxBufferLen
operator|=
name|EM_RXBUFFER_16384
expr_stmt|;
block|}
else|else
block|{
name|Adapter
operator|->
name|JumboEnable
operator|=
literal|0
expr_stmt|;
name|Adapter
operator|->
name|RxBufferLen
operator|=
name|EM_RXBUFFER_2048
expr_stmt|;
block|}
name|Adapter
operator|->
name|MaxFrameSize
operator|=
name|ifp
operator|->
name|if_mtu
operator|+
name|ETHER_HDR_LEN
operator|+
name|ETHER_CRC_LEN
expr_stmt|;
name|em_init
argument_list|(
name|Adapter
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
break|break;
case|case
name|SIOCSIFFLAGS
case|:
name|IOCTL_DEBUGOUT
argument_list|(
literal|"ioctl rcv'd: SIOCSIFFLAGS (Set Interface Flags)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|&&
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
condition|)
block|{
name|em_set_promisc
argument_list|(
name|Adapter
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|&&
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
operator|)
condition|)
block|{
name|em_disable_promisc
argument_list|(
name|Adapter
argument_list|)
expr_stmt|;
block|}
else|else
name|em_init
argument_list|(
name|Adapter
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
condition|)
block|{
name|em_stop
argument_list|(
name|Adapter
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
name|IOCTL_DEBUGOUT
argument_list|(
literal|"ioctl rcv'd: SIOC(ADD|DEL)MULTI"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
condition|)
block|{
name|DisableInterrupts
argument_list|(
name|Adapter
argument_list|)
expr_stmt|;
name|em_set_multi
argument_list|(
name|Adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|Adapter
operator|->
name|MacType
operator|==
name|MAC_WISEMAN_2_0
condition|)
name|em_initialize_receive_unit
argument_list|(
name|Adapter
argument_list|)
expr_stmt|;
name|EnableInterrupts
argument_list|(
name|Adapter
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SIOCSIFMEDIA
case|:
case|case
name|SIOCGIFMEDIA
case|:
name|IOCTL_DEBUGOUT
argument_list|(
literal|"ioctl rcv'd: SIOCxIFMEDIA (Get/Set Interface Media)"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ifmedia_ioctl
argument_list|(
name|ifp
argument_list|,
name|ifr
argument_list|,
operator|&
name|Adapter
operator|->
name|media
argument_list|,
name|command
argument_list|)
expr_stmt|;
break|break;
default|default:
name|IOCTL_DEBUGOUT1
argument_list|(
literal|"ioctl received: UNKNOWN (0x%d)\n"
argument_list|,
operator|(
name|int
operator|)
name|command
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|em_set_promisc
parameter_list|(
name|struct
name|adapter
modifier|*
name|Adapter
parameter_list|)
block|{
name|u_int32_t
name|reg_rctl
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|Adapter
operator|->
name|interface_data
operator|.
name|ac_if
decl_stmt|;
name|reg_rctl
operator|=
name|E1000_READ_REG
argument_list|(
name|Rctl
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
condition|)
block|{
name|reg_rctl
operator||=
operator|(
name|E1000_RCTL_UPE
operator||
name|E1000_RCTL_MPE
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|Rctl
argument_list|,
name|reg_rctl
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_ALLMULTI
condition|)
block|{
name|reg_rctl
operator||=
name|E1000_RCTL_MPE
expr_stmt|;
name|reg_rctl
operator|&=
operator|~
name|E1000_RCTL_UPE
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|Rctl
argument_list|,
name|reg_rctl
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|em_disable_promisc
parameter_list|(
name|struct
name|adapter
modifier|*
name|Adapter
parameter_list|)
block|{
name|u_int32_t
name|reg_rctl
decl_stmt|;
name|reg_rctl
operator|=
name|E1000_READ_REG
argument_list|(
name|Rctl
argument_list|)
expr_stmt|;
name|reg_rctl
operator|&=
operator|(
operator|~
name|E1000_RCTL_UPE
operator|)
expr_stmt|;
name|reg_rctl
operator|&=
operator|(
operator|~
name|E1000_RCTL_MPE
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|Rctl
argument_list|,
name|reg_rctl
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  Multicast Update  *  *  This routine is called whenever multicast address list is updated.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|em_set_multi
parameter_list|(
name|struct
name|adapter
modifier|*
name|Adapter
parameter_list|)
block|{
name|u_int32_t
name|reg_rctl
init|=
literal|0
decl_stmt|;
name|u_int8_t
name|mta
index|[
name|MAX_NUM_MULTICAST_ADDRESSES
operator|*
name|ETH_LENGTH_OF_ADDRESS
index|]
decl_stmt|;
name|u_int16_t
name|PciCommandWord
decl_stmt|;
name|struct
name|ifmultiaddr
modifier|*
name|ifma_ptr
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|multi_cnt
init|=
literal|0
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|Adapter
operator|->
name|interface_data
operator|.
name|ac_if
decl_stmt|;
name|IOCTL_DEBUGOUT
argument_list|(
literal|"em_set_multi: begin"
argument_list|)
expr_stmt|;
if|if
condition|(
name|Adapter
operator|->
name|MacType
operator|==
name|MAC_WISEMAN_2_0
condition|)
block|{
name|reg_rctl
operator|=
name|E1000_READ_REG
argument_list|(
name|Rctl
argument_list|)
expr_stmt|;
if|if
condition|(
name|Adapter
operator|->
name|PciCommandWord
operator|&
name|CMD_MEM_WRT_INVALIDATE
condition|)
block|{
name|PciCommandWord
operator|=
name|Adapter
operator|->
name|PciCommandWord
operator|&
operator|~
name|CMD_MEM_WRT_INVALIDATE
expr_stmt|;
name|pci_write_config
argument_list|(
name|Adapter
operator|->
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
name|PciCommandWord
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
name|reg_rctl
operator||=
name|E1000_RCTL_RST
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|Rctl
argument_list|,
name|reg_rctl
argument_list|)
expr_stmt|;
name|DelayInMilliseconds
argument_list|(
literal|5
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|ifma_ptr
operator|=
name|ifp
operator|->
name|if_multiaddrs
operator|.
name|lh_first
init|;
name|ifma_ptr
operator|!=
name|NULL
condition|;
name|i
operator|++
operator|,
name|ifma_ptr
operator|=
name|ifma_ptr
operator|->
name|ifma_link
operator|.
name|le_next
control|)
block|{
name|multi_cnt
operator|++
expr_stmt|;
name|bcopy
argument_list|(
name|LLADDR
argument_list|(
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifma_ptr
operator|->
name|ifma_addr
argument_list|)
argument_list|,
operator|&
name|mta
index|[
name|i
operator|*
name|ETH_LENGTH_OF_ADDRESS
index|]
argument_list|,
name|ETH_LENGTH_OF_ADDRESS
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|multi_cnt
operator|>
name|MAX_NUM_MULTICAST_ADDRESSES
condition|)
block|{
name|reg_rctl
operator|=
name|E1000_READ_REG
argument_list|(
name|Rctl
argument_list|)
expr_stmt|;
name|reg_rctl
operator||=
name|E1000_RCTL_MPE
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|Rctl
argument_list|,
name|reg_rctl
argument_list|)
expr_stmt|;
block|}
else|else
name|em_multicast_address_list_update
argument_list|(
name|Adapter
argument_list|,
name|mta
argument_list|,
name|multi_cnt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|Adapter
operator|->
name|MacType
operator|==
name|MAC_WISEMAN_2_0
condition|)
block|{
name|reg_rctl
operator|=
name|E1000_READ_REG
argument_list|(
name|Rctl
argument_list|)
expr_stmt|;
name|reg_rctl
operator|&=
operator|~
name|E1000_RCTL_RST
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|Rctl
argument_list|,
name|reg_rctl
argument_list|)
expr_stmt|;
name|DelayInMilliseconds
argument_list|(
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
name|Adapter
operator|->
name|PciCommandWord
operator|&
name|CMD_MEM_WRT_INVALIDATE
condition|)
block|{
name|pci_write_config
argument_list|(
name|Adapter
operator|->
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
name|Adapter
operator|->
name|PciCommandWord
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  Watchdog entry point  *  *  This routine is called whenever hardware quits transmitting.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|em_watchdog
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|Adapter
decl_stmt|;
name|Adapter
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
comment|/* If we are in this routine because of pause frames, then     * don't reset the hardware.     */
if|if
condition|(
name|E1000_READ_REG
argument_list|(
name|Status
argument_list|)
operator|&
name|E1000_STATUS_TXOFF
condition|)
block|{
name|ifp
operator|->
name|if_timer
operator|=
name|EM_TX_TIMEOUT
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|"em%d: watchdog timeout -- resetting\n"
argument_list|,
name|Adapter
operator|->
name|unit
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_RUNNING
expr_stmt|;
name|em_stop
argument_list|(
name|Adapter
argument_list|)
expr_stmt|;
name|em_init
argument_list|(
name|Adapter
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  Timer routine  *  *  This routine checks for link status and updates statistics.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|em_local_timer
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|adapter
modifier|*
name|Adapter
init|=
name|arg
decl_stmt|;
name|ifp
operator|=
operator|&
name|Adapter
operator|->
name|interface_data
operator|.
name|ac_if
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|em_check_for_link
argument_list|(
name|Adapter
argument_list|)
expr_stmt|;
name|em_print_link_status
argument_list|(
name|Adapter
argument_list|)
expr_stmt|;
name|em_update_stats_counters
argument_list|(
name|Adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|em_display_debug_stats
operator|&&
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
condition|)
block|{
name|em_print_hw_stats
argument_list|(
name|Adapter
argument_list|)
expr_stmt|;
block|}
name|Adapter
operator|->
name|timer_handle
operator|=
name|timeout
argument_list|(
name|em_local_timer
argument_list|,
name|Adapter
argument_list|,
literal|2
operator|*
name|hz
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|em_print_link_status
parameter_list|(
name|struct
name|adapter
modifier|*
name|Adapter
parameter_list|)
block|{
if|if
condition|(
name|E1000_READ_REG
argument_list|(
name|Status
argument_list|)
operator|&
name|E1000_STATUS_LU
condition|)
block|{
if|if
condition|(
name|Adapter
operator|->
name|LinkIsActive
operator|==
literal|0
condition|)
block|{
name|em_get_speed_and_duplex
argument_list|(
name|Adapter
argument_list|,
operator|&
name|Adapter
operator|->
name|LineSpeed
argument_list|,
operator|&
name|Adapter
operator|->
name|FullDuplex
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"em%d: Link is up %d Mbps %s\n"
argument_list|,
name|Adapter
operator|->
name|unit
argument_list|,
name|Adapter
operator|->
name|LineSpeed
argument_list|,
operator|(
operator|(
name|Adapter
operator|->
name|FullDuplex
operator|==
name|FULL_DUPLEX
operator|)
condition|?
literal|"Full Duplex"
else|:
literal|"Half Duplex"
operator|)
argument_list|)
expr_stmt|;
name|Adapter
operator|->
name|LinkIsActive
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|Adapter
operator|->
name|LinkIsActive
operator|==
literal|1
condition|)
block|{
name|Adapter
operator|->
name|LineSpeed
operator|=
literal|0
expr_stmt|;
name|Adapter
operator|->
name|FullDuplex
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"em%d: Link is Down\n"
argument_list|,
name|Adapter
operator|->
name|unit
argument_list|)
expr_stmt|;
name|Adapter
operator|->
name|LinkIsActive
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  Init entry point  *  *  This routine is used in two ways. It is used by the stack as  *  init entry point in network interface structure. It is also used  *  by the driver as a hw/sw initialization routine to get to a   *  consistent state.  *  *  return 0 on success, positive on failure  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|em_init
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|adapter
modifier|*
name|Adapter
init|=
name|arg
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"em_init: begin"
argument_list|)
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|em_stop
argument_list|(
name|Adapter
argument_list|)
expr_stmt|;
comment|/* Initialize the hardware */
if|if
condition|(
name|em_hardware_init
argument_list|(
name|Adapter
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"em%d: Unable to initialize the hardware\n"
argument_list|,
name|Adapter
operator|->
name|unit
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
name|Adapter
operator|->
name|AdapterStopped
operator|=
name|FALSE
expr_stmt|;
comment|/* Prepare transmit descriptors and buffers */
if|if
condition|(
name|em_setup_transmit_structures
argument_list|(
name|Adapter
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"em%d: Could not setup transmit structures\n"
argument_list|,
name|Adapter
operator|->
name|unit
argument_list|)
expr_stmt|;
name|em_stop
argument_list|(
name|Adapter
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
name|em_initialize_transmit_unit
argument_list|(
name|Adapter
argument_list|)
expr_stmt|;
comment|/* Setup Multicast table */
name|em_set_multi
argument_list|(
name|Adapter
argument_list|)
expr_stmt|;
comment|/* Prepare receive descriptors and buffers */
if|if
condition|(
name|em_setup_receive_structures
argument_list|(
name|Adapter
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"em%d: Could not setup receive structures\n"
argument_list|,
name|Adapter
operator|->
name|unit
argument_list|)
expr_stmt|;
name|em_stop
argument_list|(
name|Adapter
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
name|em_initialize_receive_unit
argument_list|(
name|Adapter
argument_list|)
expr_stmt|;
name|ifp
operator|=
operator|&
name|Adapter
operator|->
name|interface_data
operator|.
name|ac_if
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_RUNNING
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
if|if
condition|(
name|Adapter
operator|->
name|MacType
operator|>=
name|MAC_LIVENGOOD
condition|)
name|ifp
operator|->
name|if_hwassist
operator|=
name|EM_CHECKSUM_FEATURES
expr_stmt|;
name|Adapter
operator|->
name|timer_handle
operator|=
name|timeout
argument_list|(
name|em_local_timer
argument_list|,
name|Adapter
argument_list|,
literal|2
operator|*
name|hz
argument_list|)
expr_stmt|;
name|em_clear_hw_stats_counters
argument_list|(
name|Adapter
argument_list|)
expr_stmt|;
name|EnableInterrupts
argument_list|(
name|Adapter
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  This routine disables all traffic on the adapter by issuing a  *  global reset on the MAC and deallocates TX/RX buffers.   *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|em_stop
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|adapter
modifier|*
name|Adapter
init|=
name|arg
decl_stmt|;
name|ifp
operator|=
operator|&
name|Adapter
operator|->
name|interface_data
operator|.
name|ac_if
expr_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"em_stop: begin\n"
argument_list|)
expr_stmt|;
name|DisableInterrupts
argument_list|(
name|Adapter
argument_list|)
expr_stmt|;
name|em_adapter_stop
argument_list|(
name|Adapter
argument_list|)
expr_stmt|;
name|untimeout
argument_list|(
name|em_local_timer
argument_list|,
name|Adapter
argument_list|,
name|Adapter
operator|->
name|timer_handle
argument_list|)
expr_stmt|;
name|em_free_transmit_structures
argument_list|(
name|Adapter
argument_list|)
expr_stmt|;
name|em_free_receive_structures
argument_list|(
name|Adapter
argument_list|)
expr_stmt|;
comment|/* Tell the stack that the interface is no longer active */
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
operator|(
name|IFF_RUNNING
operator||
name|IFF_OACTIVE
operator|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Interrupt Service routine  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|em_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|u_int32_t
name|ProcessCount
init|=
name|EM_MAX_INTR
decl_stmt|;
name|u_int32_t
name|IcrContents
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|adapter
modifier|*
name|Adapter
init|=
name|arg
decl_stmt|;
name|ifp
operator|=
operator|&
name|Adapter
operator|->
name|interface_data
operator|.
name|ac_if
expr_stmt|;
name|DisableInterrupts
argument_list|(
name|Adapter
argument_list|)
expr_stmt|;
while|while
condition|(
name|ProcessCount
operator|>
literal|0
operator|&&
operator|(
name|IcrContents
operator|=
name|E1000_READ_REG
argument_list|(
name|Icr
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Link status change */
if|if
condition|(
name|IcrContents
operator|&
operator|(
name|E1000_ICR_RXSEQ
operator||
name|E1000_ICR_LSC
operator|)
condition|)
block|{
name|untimeout
argument_list|(
name|em_local_timer
argument_list|,
name|Adapter
argument_list|,
name|Adapter
operator|->
name|timer_handle
argument_list|)
expr_stmt|;
name|Adapter
operator|->
name|GetLinkStatus
operator|=
literal|1
expr_stmt|;
name|em_check_for_link
argument_list|(
name|Adapter
argument_list|)
expr_stmt|;
name|em_print_link_status
argument_list|(
name|Adapter
argument_list|)
expr_stmt|;
name|Adapter
operator|->
name|timer_handle
operator|=
name|timeout
argument_list|(
name|em_local_timer
argument_list|,
name|Adapter
argument_list|,
literal|2
operator|*
name|hz
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
condition|)
block|{
name|em_process_receive_interrupts
argument_list|(
name|Adapter
argument_list|)
expr_stmt|;
name|em_clean_transmit_interrupts
argument_list|(
name|Adapter
argument_list|)
expr_stmt|;
block|}
name|ProcessCount
operator|--
expr_stmt|;
block|}
name|EnableInterrupts
argument_list|(
name|Adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|&&
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_head
operator|!=
name|NULL
condition|)
name|em_start
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Media Ioctl callback  *  *  This routine is called whenever the user queries the status of  *  the interface using ifconfig.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|em_media_status
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|ifmediareq
modifier|*
name|ifmr
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|Adapter
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"em_media_status: begin"
argument_list|)
expr_stmt|;
name|em_check_for_link
argument_list|(
name|Adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|E1000_READ_REG
argument_list|(
name|Status
argument_list|)
operator|&
name|E1000_STATUS_LU
condition|)
block|{
if|if
condition|(
name|Adapter
operator|->
name|LinkIsActive
operator|==
literal|0
condition|)
block|{
name|em_get_speed_and_duplex
argument_list|(
name|Adapter
argument_list|,
operator|&
name|Adapter
operator|->
name|LineSpeed
argument_list|,
operator|&
name|Adapter
operator|->
name|FullDuplex
argument_list|)
expr_stmt|;
name|Adapter
operator|->
name|LinkIsActive
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|Adapter
operator|->
name|LinkIsActive
operator|==
literal|1
condition|)
block|{
name|Adapter
operator|->
name|LineSpeed
operator|=
literal|0
expr_stmt|;
name|Adapter
operator|->
name|FullDuplex
operator|=
literal|0
expr_stmt|;
name|Adapter
operator|->
name|LinkIsActive
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|ifmr
operator|->
name|ifm_status
operator|=
name|IFM_AVALID
expr_stmt|;
name|ifmr
operator|->
name|ifm_active
operator|=
name|IFM_ETHER
expr_stmt|;
if|if
condition|(
operator|!
name|Adapter
operator|->
name|LinkIsActive
condition|)
return|return;
name|ifmr
operator|->
name|ifm_status
operator||=
name|IFM_ACTIVE
expr_stmt|;
if|if
condition|(
name|Adapter
operator|->
name|MediaType
operator|==
name|MEDIA_TYPE_FIBER
condition|)
block|{
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_1000_SX
operator||
name|IFM_FDX
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|Adapter
operator|->
name|LineSpeed
condition|)
block|{
case|case
literal|10
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_10_T
expr_stmt|;
break|break;
case|case
literal|100
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_100_TX
expr_stmt|;
break|break;
case|case
literal|1000
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_1000_TX
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|Adapter
operator|->
name|FullDuplex
operator|==
name|FULL_DUPLEX
condition|)
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_FDX
expr_stmt|;
else|else
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_HDX
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Media Ioctl callback  *  *  This routine is called when the user changes speed/duplex using  *  media/mediopt option with ifconfig.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|em_media_change
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|Adapter
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ifmedia
modifier|*
name|ifm
init|=
operator|&
name|Adapter
operator|->
name|media
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"em_media_change: begin"
argument_list|)
expr_stmt|;
if|if
condition|(
name|IFM_TYPE
argument_list|(
name|ifm
operator|->
name|ifm_media
argument_list|)
operator|!=
name|IFM_ETHER
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
switch|switch
condition|(
name|IFM_SUBTYPE
argument_list|(
name|ifm
operator|->
name|ifm_media
argument_list|)
condition|)
block|{
case|case
name|IFM_AUTO
case|:
if|if
condition|(
name|Adapter
operator|->
name|AutoNeg
condition|)
return|return
literal|0
return|;
else|else
block|{
name|Adapter
operator|->
name|AutoNeg
operator|=
name|DO_AUTO_NEG
expr_stmt|;
name|Adapter
operator|->
name|AutoNegAdvertised
operator|=
name|AUTONEG_ADV_DEFAULT
expr_stmt|;
block|}
break|break;
case|case
name|IFM_1000_SX
case|:
case|case
name|IFM_1000_TX
case|:
name|Adapter
operator|->
name|AutoNeg
operator|=
name|DO_AUTO_NEG
expr_stmt|;
name|Adapter
operator|->
name|AutoNegAdvertised
operator|=
name|ADVERTISE_1000_FULL
expr_stmt|;
break|break;
case|case
name|IFM_100_TX
case|:
name|Adapter
operator|->
name|AutoNeg
operator|=
name|FALSE
expr_stmt|;
name|Adapter
operator|->
name|AutoNegAdvertised
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|ifm
operator|->
name|ifm_media
operator|&
name|IFM_GMASK
operator|)
operator|==
name|IFM_FDX
condition|)
name|Adapter
operator|->
name|ForcedSpeedDuplex
operator|=
name|FULL_100
expr_stmt|;
else|else
name|Adapter
operator|->
name|ForcedSpeedDuplex
operator|=
name|HALF_100
expr_stmt|;
break|break;
case|case
name|IFM_10_T
case|:
name|Adapter
operator|->
name|AutoNeg
operator|=
name|FALSE
expr_stmt|;
name|Adapter
operator|->
name|AutoNegAdvertised
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|ifm
operator|->
name|ifm_media
operator|&
name|IFM_GMASK
operator|)
operator|==
name|IFM_FDX
condition|)
name|Adapter
operator|->
name|ForcedSpeedDuplex
operator|=
name|FULL_10
expr_stmt|;
else|else
name|Adapter
operator|->
name|ForcedSpeedDuplex
operator|=
name|HALF_10
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"em%d: Unsupported media type\n"
argument_list|,
name|Adapter
operator|->
name|unit
argument_list|)
expr_stmt|;
block|}
name|em_init
argument_list|(
name|Adapter
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Section end: Other registered entry points */
end_comment

begin_comment
comment|/*********************************************************************  *  *  Determine hardware revision.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|em_identify_hardware
parameter_list|(
name|struct
name|adapter
modifier|*
name|Adapter
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|Adapter
operator|->
name|dev
decl_stmt|;
comment|/* Make sure our PCI config space has the necessary stuff set */
name|Adapter
operator|->
name|PciCommandWord
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|Adapter
operator|->
name|PciCommandWord
operator||=
operator|(
name|PCIM_CMD_BUSMASTEREN
operator||
name|PCIM_CMD_MEMEN
operator|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
name|Adapter
operator|->
name|PciCommandWord
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Save off the information about this board */
name|Adapter
operator|->
name|VendorId
operator|=
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|Adapter
operator|->
name|DeviceId
operator|=
name|pci_get_device
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|Adapter
operator|->
name|RevId
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_REVID
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|Adapter
operator|->
name|SubVendorId
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_SUBVEND_0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|Adapter
operator|->
name|SubSystemId
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_SUBDEV_0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|INIT_DEBUGOUT2
argument_list|(
literal|"device id = 0x%x, Revid = 0x%x"
argument_list|,
name|Adapter
operator|->
name|DeviceId
argument_list|,
name|Adapter
operator|->
name|RevId
argument_list|)
expr_stmt|;
comment|/* Set MacType, etc. based on this PCI info */
switch|switch
condition|(
name|Adapter
operator|->
name|DeviceId
condition|)
block|{
case|case
name|PCI_DEVICE_ID_82542
case|:
name|Adapter
operator|->
name|MacType
operator|=
operator|(
name|Adapter
operator|->
name|RevId
operator|==
literal|3
operator|)
condition|?
name|MAC_WISEMAN_2_1
else|:
name|MAC_WISEMAN_2_0
expr_stmt|;
break|break;
case|case
name|PCI_DEVICE_ID_82543GC_FIBER
case|:
case|case
name|PCI_DEVICE_ID_82543GC_COPPER
case|:
name|Adapter
operator|->
name|MacType
operator|=
name|MAC_LIVENGOOD
expr_stmt|;
break|break;
case|case
name|PCI_DEVICE_ID_82544EI_FIBER
case|:
case|case
name|PCI_DEVICE_ID_82544EI_COPPER
case|:
case|case
name|PCI_DEVICE_ID_82544GC_COPPER
case|:
case|case
name|PCI_DEVICE_ID_82544GC_STRG
case|:
name|Adapter
operator|->
name|MacType
operator|=
name|MAC_CORDOVA
expr_stmt|;
break|break;
default|default:
name|INIT_DEBUGOUT1
argument_list|(
literal|"Unknown device id 0x%x"
argument_list|,
name|Adapter
operator|->
name|DeviceId
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|em_allocate_pci_resources
parameter_list|(
name|struct
name|adapter
modifier|*
name|Adapter
parameter_list|)
block|{
name|int
name|resource_id
init|=
name|EM_MMBA
decl_stmt|;
name|device_t
name|dev
init|=
name|Adapter
operator|->
name|dev
decl_stmt|;
name|Adapter
operator|->
name|res_memory
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|resource_id
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
literal|1
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|Adapter
operator|->
name|res_memory
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"em%d: Unable to allocate bus resource: memory\n"
argument_list|,
name|Adapter
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|Adapter
operator|->
name|bus_space_tag
operator|=
name|rman_get_bustag
argument_list|(
name|Adapter
operator|->
name|res_memory
argument_list|)
expr_stmt|;
name|Adapter
operator|->
name|bus_space_handle
operator|=
name|rman_get_bushandle
argument_list|(
name|Adapter
operator|->
name|res_memory
argument_list|)
expr_stmt|;
name|resource_id
operator|=
literal|0x0
expr_stmt|;
name|Adapter
operator|->
name|res_interrupt
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|resource_id
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
literal|1
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|Adapter
operator|->
name|res_interrupt
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"em%d: Unable to allocate bus resource: interrupt\n"
argument_list|,
name|Adapter
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|Adapter
operator|->
name|res_interrupt
argument_list|,
name|INTR_TYPE_NET
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|)
operator|)
name|em_intr
argument_list|,
name|Adapter
argument_list|,
operator|&
name|Adapter
operator|->
name|int_handler_tag
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"em%d: Error registering interrupt handler!\n"
argument_list|,
name|Adapter
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|em_free_pci_resources
parameter_list|(
name|struct
name|adapter
modifier|*
name|Adapter
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|Adapter
operator|->
name|dev
decl_stmt|;
if|if
condition|(
name|Adapter
operator|->
name|res_interrupt
operator|!=
name|NULL
condition|)
block|{
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|Adapter
operator|->
name|res_interrupt
argument_list|,
name|Adapter
operator|->
name|int_handler_tag
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
name|Adapter
operator|->
name|res_interrupt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Adapter
operator|->
name|res_memory
operator|!=
name|NULL
condition|)
block|{
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|EM_MMBA
argument_list|,
name|Adapter
operator|->
name|res_memory
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Initialize the hardware to a configuration as specified by the  *  Adapter structure. The controller is reset, the EEPROM is  *  verified, the MAC address is set, then the shared initialization  *  routines are called.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|em_hardware_init
parameter_list|(
name|struct
name|adapter
modifier|*
name|Adapter
parameter_list|)
block|{
comment|/* Issue a global reset */
name|Adapter
operator|->
name|AdapterStopped
operator|=
name|FALSE
expr_stmt|;
name|em_adapter_stop
argument_list|(
name|Adapter
argument_list|)
expr_stmt|;
name|Adapter
operator|->
name|AdapterStopped
operator|=
name|FALSE
expr_stmt|;
comment|/* Make sure we have a good EEPROM before we read from it */
if|if
condition|(
operator|!
name|em_validate_eeprom_checksum
argument_list|(
name|Adapter
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"em%d: The EEPROM Checksum Is Not Valid\n"
argument_list|,
name|Adapter
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
block|}
comment|/* Copy the permanent MAC address and part number out of the EEPROM */
name|em_read_mac_address
argument_list|(
name|Adapter
argument_list|,
name|Adapter
operator|->
name|interface_data
operator|.
name|ac_enaddr
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|Adapter
operator|->
name|CurrentNetAddress
argument_list|,
name|Adapter
operator|->
name|interface_data
operator|.
name|ac_enaddr
argument_list|,
name|ETH_LENGTH_OF_ADDRESS
argument_list|)
expr_stmt|;
name|em_read_part_number
argument_list|(
name|Adapter
argument_list|,
operator|&
operator|(
name|Adapter
operator|->
name|PartNumber
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|em_initialize_hardware
argument_list|(
name|Adapter
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"em%d: Hardware Initialization Failed"
argument_list|,
name|Adapter
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
block|}
name|em_check_for_link
argument_list|(
name|Adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|E1000_READ_REG
argument_list|(
name|Status
argument_list|)
operator|&
name|E1000_STATUS_LU
condition|)
name|Adapter
operator|->
name|LinkIsActive
operator|=
literal|1
expr_stmt|;
else|else
name|Adapter
operator|->
name|LinkIsActive
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|Adapter
operator|->
name|LinkIsActive
condition|)
block|{
name|em_get_speed_and_duplex
argument_list|(
name|Adapter
argument_list|,
operator|&
name|Adapter
operator|->
name|LineSpeed
argument_list|,
operator|&
name|Adapter
operator|->
name|FullDuplex
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Adapter
operator|->
name|LineSpeed
operator|=
literal|0
expr_stmt|;
name|Adapter
operator|->
name|FullDuplex
operator|=
literal|0
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|em_read_mac_address
parameter_list|(
name|struct
name|adapter
modifier|*
name|Adapter
parameter_list|,
name|u_int8_t
modifier|*
name|NodeAddress
parameter_list|)
block|{
name|u_int16_t
name|EepromWordValue
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NODE_ADDRESS_SIZE
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|EepromWordValue
operator|=
name|em_read_eeprom_word
argument_list|(
name|Adapter
argument_list|,
name|EEPROM_NODE_ADDRESS_BYTE_0
operator|+
operator|(
name|i
operator|/
literal|2
operator|)
argument_list|)
expr_stmt|;
name|NodeAddress
index|[
name|i
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|EepromWordValue
operator|&
literal|0x00FF
argument_list|)
expr_stmt|;
name|NodeAddress
index|[
name|i
operator|+
literal|1
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|EepromWordValue
operator|>>
literal|8
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Setup networking device structure and register an interface.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|em_setup_interface
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|adapter
modifier|*
name|Adapter
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"em_setup_interface: begin"
argument_list|)
expr_stmt|;
name|ifp
operator|=
operator|&
name|Adapter
operator|->
name|interface_data
operator|.
name|ac_if
expr_stmt|;
name|ifp
operator|->
name|if_unit
operator|=
name|Adapter
operator|->
name|unit
expr_stmt|;
name|ifp
operator|->
name|if_name
operator|=
literal|"em"
expr_stmt|;
name|ifp
operator|->
name|if_mtu
operator|=
name|ETHERMTU
expr_stmt|;
name|ifp
operator|->
name|if_output
operator|=
name|ether_output
expr_stmt|;
name|ifp
operator|->
name|if_baudrate
operator|=
literal|1000000000
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|em_init
expr_stmt|;
name|ifp
operator|->
name|if_softc
operator|=
name|Adapter
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|em_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|em_start
expr_stmt|;
name|ifp
operator|->
name|if_watchdog
operator|=
name|em_watchdog
expr_stmt|;
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_maxlen
operator|=
name|Adapter
operator|->
name|NumTxDescriptors
operator|-
literal|1
expr_stmt|;
name|ether_ifattach
argument_list|(
name|ifp
argument_list|,
name|ETHER_BPF_SUPPORTED
argument_list|)
expr_stmt|;
comment|/*      * Specify the media types supported by this adapter and register     * callbacks to update media and link information     */
name|ifmedia_init
argument_list|(
operator|&
name|Adapter
operator|->
name|media
argument_list|,
name|IFM_IMASK
argument_list|,
name|em_media_change
argument_list|,
name|em_media_status
argument_list|)
expr_stmt|;
if|if
condition|(
name|Adapter
operator|->
name|MediaType
operator|==
name|MEDIA_TYPE_FIBER
condition|)
block|{
name|ifmedia_add
argument_list|(
operator|&
name|Adapter
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_1000_SX
operator||
name|IFM_FDX
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|Adapter
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_1000_SX
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ifmedia_add
argument_list|(
operator|&
name|Adapter
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_10_T
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|Adapter
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_10_T
operator||
name|IFM_FDX
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|Adapter
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_100_TX
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|Adapter
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_100_TX
operator||
name|IFM_FDX
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|Adapter
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_1000_TX
operator||
name|IFM_FDX
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|Adapter
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_1000_TX
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|ifmedia_add
argument_list|(
operator|&
name|Adapter
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_AUTO
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
operator|&
name|Adapter
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_AUTO
argument_list|)
expr_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"em_setup_interface: end"
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Allocate memory for tx_buffer structures. The tx_buffer stores all   *  the information needed to transmit a packet on the wire.   *  **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|em_allocate_transmit_structures
parameter_list|(
name|struct
name|adapter
modifier|*
name|Adapter
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|Adapter
operator|->
name|tx_buffer_area
operator|=
operator|(
expr|struct
name|em_tx_buffer
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|em_tx_buffer
argument_list|)
operator|*
name|Adapter
operator|->
name|NumTxDescriptors
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"em%d: Unable to allocate tx_buffer memory\n"
argument_list|,
name|Adapter
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|bzero
argument_list|(
name|Adapter
operator|->
name|tx_buffer_area
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|em_tx_buffer
argument_list|)
operator|*
name|Adapter
operator|->
name|NumTxDescriptors
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Allocate and initialize transmit structures.   *  **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|em_setup_transmit_structures
parameter_list|(
name|struct
name|adapter
modifier|*
name|Adapter
parameter_list|)
block|{
name|struct
name|em_tx_buffer
modifier|*
name|tx_buffer
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|em_allocate_transmit_structures
argument_list|(
name|Adapter
argument_list|)
condition|)
return|return
name|ENOMEM
return|;
name|Adapter
operator|->
name|FirstTxDescriptor
operator|=
name|Adapter
operator|->
name|TxDescBase
expr_stmt|;
name|Adapter
operator|->
name|LastTxDescriptor
operator|=
name|Adapter
operator|->
name|FirstTxDescriptor
operator|+
operator|(
name|Adapter
operator|->
name|NumTxDescriptors
operator|-
literal|1
operator|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|Adapter
operator|->
name|FreeSwTxPacketList
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|Adapter
operator|->
name|UsedSwTxPacketList
argument_list|)
expr_stmt|;
name|tx_buffer
operator|=
name|Adapter
operator|->
name|tx_buffer_area
expr_stmt|;
comment|/* Setup the linked list of the tx_buffer's */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|Adapter
operator|->
name|NumTxDescriptors
condition|;
name|i
operator|++
operator|,
name|tx_buffer
operator|++
control|)
block|{
name|bzero
argument_list|(
operator|(
name|void
operator|*
operator|)
name|tx_buffer
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|em_tx_buffer
argument_list|)
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|Adapter
operator|->
name|FreeSwTxPacketList
argument_list|,
name|tx_buffer
argument_list|,
name|em_tx_entry
argument_list|)
expr_stmt|;
block|}
name|bzero
argument_list|(
operator|(
name|void
operator|*
operator|)
name|Adapter
operator|->
name|FirstTxDescriptor
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
name|E1000_TRANSMIT_DESCRIPTOR
argument_list|)
operator|)
operator|*
name|Adapter
operator|->
name|NumTxDescriptors
argument_list|)
expr_stmt|;
comment|/* Setup TX descriptor pointers */
name|Adapter
operator|->
name|NextAvailTxDescriptor
operator|=
name|Adapter
operator|->
name|FirstTxDescriptor
expr_stmt|;
name|Adapter
operator|->
name|OldestUsedTxDescriptor
operator|=
name|Adapter
operator|->
name|FirstTxDescriptor
expr_stmt|;
comment|/* Set number of descriptors available */
name|Adapter
operator|->
name|NumTxDescriptorsAvail
operator|=
name|Adapter
operator|->
name|NumTxDescriptors
expr_stmt|;
comment|/* Set checksum context */
name|Adapter
operator|->
name|ActiveChecksumContext
operator|=
name|OFFLOAD_NONE
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Enable transmit unit.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|em_initialize_transmit_unit
parameter_list|(
name|struct
name|adapter
modifier|*
name|Adapter
parameter_list|)
block|{
name|u_int32_t
name|reg_tctl
decl_stmt|;
name|u_int32_t
name|reg_tipg
init|=
literal|0
decl_stmt|;
comment|/* Setup the Base and Length of the Tx Descriptor Ring */
name|E1000_WRITE_REG
argument_list|(
name|Tdbal
argument_list|,
name|vtophys
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|Adapter
operator|->
name|TxDescBase
argument_list|)
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|Tdbah
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|Tdl
argument_list|,
name|Adapter
operator|->
name|NumTxDescriptors
operator|*
sizeof|sizeof
argument_list|(
name|E1000_TRANSMIT_DESCRIPTOR
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Setup the HW Tx Head and Tail descriptor pointers */
name|E1000_WRITE_REG
argument_list|(
name|Tdh
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|Tdt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|HW_DEBUGOUT2
argument_list|(
literal|"Base = %x, Length = %x\n"
argument_list|,
name|E1000_READ_REG
argument_list|(
name|Tdbal
argument_list|)
argument_list|,
name|E1000_READ_REG
argument_list|(
name|Tdl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Zero out the 82542 Tx Queue State registers - we don't use them */
if|if
condition|(
name|Adapter
operator|->
name|MacType
operator|<
name|MAC_LIVENGOOD
condition|)
block|{
name|E1000_WRITE_REG
argument_list|(
name|Tqsal
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|Tqsah
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Set the default values for the Tx Inter Packet Gap timer */
switch|switch
condition|(
name|Adapter
operator|->
name|MacType
condition|)
block|{
case|case
name|MAC_LIVENGOOD
case|:
case|case
name|MAC_WAINWRIGHT
case|:
case|case
name|MAC_CORDOVA
case|:
if|if
condition|(
name|Adapter
operator|->
name|MediaType
operator|==
name|MEDIA_TYPE_FIBER
condition|)
name|reg_tipg
operator|=
name|DEFAULT_LVGD_TIPG_IPGT_FIBER
expr_stmt|;
else|else
name|reg_tipg
operator|=
name|DEFAULT_LVGD_TIPG_IPGT_COPPER
expr_stmt|;
name|reg_tipg
operator||=
name|DEFAULT_LVGD_TIPG_IPGR1
operator|<<
name|E1000_TIPG_IPGR1_SHIFT
expr_stmt|;
name|reg_tipg
operator||=
name|DEFAULT_LVGD_TIPG_IPGR2
operator|<<
name|E1000_TIPG_IPGR2_SHIFT
expr_stmt|;
break|break;
case|case
name|MAC_WISEMAN_2_0
case|:
case|case
name|MAC_WISEMAN_2_1
case|:
name|reg_tipg
operator|=
name|DEFAULT_WSMN_TIPG_IPGT
expr_stmt|;
name|reg_tipg
operator||=
name|DEFAULT_WSMN_TIPG_IPGR1
operator|<<
name|E1000_TIPG_IPGR1_SHIFT
expr_stmt|;
name|reg_tipg
operator||=
name|DEFAULT_WSMN_TIPG_IPGR2
operator|<<
name|E1000_TIPG_IPGR2_SHIFT
expr_stmt|;
break|break;
block|}
name|E1000_WRITE_REG
argument_list|(
name|Tipg
argument_list|,
name|reg_tipg
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|Tidv
argument_list|,
name|Adapter
operator|->
name|TxIntDelay
argument_list|)
expr_stmt|;
comment|/* Program the Transmit Control Register */
name|reg_tctl
operator|=
name|E1000_TCTL_PSP
operator||
name|E1000_TCTL_EN
operator||
operator|(
name|E1000_COLLISION_THRESHOLD
operator|<<
name|E1000_CT_SHIFT
operator|)
expr_stmt|;
if|if
condition|(
name|Adapter
operator|->
name|FullDuplex
operator|==
literal|1
condition|)
block|{
name|reg_tctl
operator||=
name|E1000_FDX_COLLISION_DISTANCE
operator|<<
name|E1000_COLD_SHIFT
expr_stmt|;
block|}
else|else
block|{
name|reg_tctl
operator||=
name|E1000_HDX_COLLISION_DISTANCE
operator|<<
name|E1000_COLD_SHIFT
expr_stmt|;
block|}
name|E1000_WRITE_REG
argument_list|(
name|Tctl
argument_list|,
name|reg_tctl
argument_list|)
expr_stmt|;
comment|/* Setup Transmit Descriptor Settings for this adapter */
name|Adapter
operator|->
name|TxdCmd
operator|=
name|E1000_TXD_CMD_IFCS
expr_stmt|;
if|if
condition|(
name|Adapter
operator|->
name|TxIntDelay
operator|>
literal|0
condition|)
name|Adapter
operator|->
name|TxdCmd
operator||=
name|E1000_TXD_CMD_IDE
expr_stmt|;
if|if
condition|(
name|Adapter
operator|->
name|ReportTxEarly
operator|==
literal|1
condition|)
name|Adapter
operator|->
name|TxdCmd
operator||=
name|E1000_TXD_CMD_RS
expr_stmt|;
else|else
name|Adapter
operator|->
name|TxdCmd
operator||=
name|E1000_TXD_CMD_RPS
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Free all transmit related data structures.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|em_free_transmit_structures
parameter_list|(
name|struct
name|adapter
modifier|*
name|Adapter
parameter_list|)
block|{
name|struct
name|em_tx_buffer
modifier|*
name|tx_buffer
decl_stmt|;
name|int
name|i
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"free_transmit_structures: begin"
argument_list|)
expr_stmt|;
if|if
condition|(
name|Adapter
operator|->
name|tx_buffer_area
operator|!=
name|NULL
condition|)
block|{
name|tx_buffer
operator|=
name|Adapter
operator|->
name|tx_buffer_area
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|Adapter
operator|->
name|NumTxDescriptors
condition|;
name|i
operator|++
operator|,
name|tx_buffer
operator|++
control|)
block|{
if|if
condition|(
name|tx_buffer
operator|->
name|Packet
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|tx_buffer
operator|->
name|Packet
argument_list|)
expr_stmt|;
name|tx_buffer
operator|->
name|Packet
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|Adapter
operator|->
name|tx_buffer_area
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|Adapter
operator|->
name|tx_buffer_area
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|Adapter
operator|->
name|tx_buffer_area
operator|=
name|NULL
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  The offload context needs to be set when we transfer the first  *  packet of a particular protocol (TCP/UDP). We change the  *  context only if the protocol type changes.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|em_transmit_checksum_setup
parameter_list|(
name|struct
name|adapter
modifier|*
name|Adapter
parameter_list|,
name|struct
name|mbuf
modifier|*
name|mp
parameter_list|,
name|struct
name|em_tx_buffer
modifier|*
name|tx_buffer
parameter_list|,
name|u_int32_t
modifier|*
name|txd_upper
parameter_list|,
name|u_int32_t
modifier|*
name|txd_lower
parameter_list|)
block|{
name|PE1000_TCPIP_CONTEXT_TRANSMIT_DESCRIPTOR
name|TXD
decl_stmt|;
name|PE1000_TRANSMIT_DESCRIPTOR
name|CurrentTxDescriptor
decl_stmt|;
if|if
condition|(
name|mp
operator|->
name|m_pkthdr
operator|.
name|csum_flags
condition|)
block|{
if|if
condition|(
name|mp
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_TCP
condition|)
block|{
name|TXCSUM_DEBUGOUT
argument_list|(
literal|"Checksum TCP"
argument_list|)
expr_stmt|;
operator|*
name|txd_upper
operator|=
name|E1000_TXD_POPTS_TXSM
operator|<<
literal|8
expr_stmt|;
operator|*
name|txd_lower
operator|=
name|E1000_TXD_CMD_DEXT
operator||
name|E1000_TXD_DTYP_D
expr_stmt|;
if|if
condition|(
name|Adapter
operator|->
name|ActiveChecksumContext
operator|==
name|OFFLOAD_TCP_IP
condition|)
return|return;
else|else
name|Adapter
operator|->
name|ActiveChecksumContext
operator|=
name|OFFLOAD_TCP_IP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mp
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_UDP
condition|)
block|{
name|TXCSUM_DEBUGOUT
argument_list|(
literal|"Checksum UDP"
argument_list|)
expr_stmt|;
operator|*
name|txd_upper
operator|=
name|E1000_TXD_POPTS_TXSM
operator|<<
literal|8
expr_stmt|;
operator|*
name|txd_lower
operator|=
name|E1000_TXD_CMD_DEXT
operator||
name|E1000_TXD_DTYP_D
expr_stmt|;
if|if
condition|(
name|Adapter
operator|->
name|ActiveChecksumContext
operator|==
name|OFFLOAD_UDP_IP
condition|)
return|return;
else|else
name|Adapter
operator|->
name|ActiveChecksumContext
operator|=
name|OFFLOAD_UDP_IP
expr_stmt|;
block|}
else|else
block|{
name|TXCSUM_DEBUGOUT
argument_list|(
literal|"Invalid protocol for checksum calculation\n"
argument_list|)
expr_stmt|;
operator|*
name|txd_upper
operator|=
literal|0
expr_stmt|;
operator|*
name|txd_lower
operator|=
literal|0
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
name|TXCSUM_DEBUGOUT
argument_list|(
literal|"No checksum detected\n"
argument_list|)
expr_stmt|;
operator|*
name|txd_upper
operator|=
literal|0
expr_stmt|;
operator|*
name|txd_lower
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|/* If we reach this point, the checksum offload context     * needs to be reset.     */
name|CurrentTxDescriptor
operator|=
name|Adapter
operator|->
name|NextAvailTxDescriptor
expr_stmt|;
name|TXD
operator|=
operator|(
name|PE1000_TCPIP_CONTEXT_TRANSMIT_DESCRIPTOR
operator|)
name|CurrentTxDescriptor
expr_stmt|;
name|TXD
operator|->
name|LowerXsumSetup
operator|.
name|IpFields
operator|.
name|Ipcss
operator|=
name|ETHER_HDR_LEN
expr_stmt|;
name|TXD
operator|->
name|LowerXsumSetup
operator|.
name|IpFields
operator|.
name|Ipcso
operator|=
name|ETHER_HDR_LEN
operator|+
name|offsetof
argument_list|(
expr|struct
name|ip
argument_list|,
name|ip_sum
argument_list|)
expr_stmt|;
name|TXD
operator|->
name|LowerXsumSetup
operator|.
name|IpFields
operator|.
name|Ipcse
operator|=
name|ETHER_HDR_LEN
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|-
literal|1
expr_stmt|;
name|TXD
operator|->
name|UpperXsumSetup
operator|.
name|TcpFields
operator|.
name|Tucss
operator|=
name|ETHER_HDR_LEN
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
expr_stmt|;
name|TXD
operator|->
name|UpperXsumSetup
operator|.
name|TcpFields
operator|.
name|Tucse
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|Adapter
operator|->
name|ActiveChecksumContext
operator|==
name|OFFLOAD_TCP_IP
condition|)
block|{
name|TXD
operator|->
name|UpperXsumSetup
operator|.
name|TcpFields
operator|.
name|Tucso
operator|=
name|ETHER_HDR_LEN
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|+
name|offsetof
argument_list|(
expr|struct
name|tcphdr
argument_list|,
name|th_sum
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Adapter
operator|->
name|ActiveChecksumContext
operator|==
name|OFFLOAD_UDP_IP
condition|)
block|{
name|TXD
operator|->
name|UpperXsumSetup
operator|.
name|TcpFields
operator|.
name|Tucso
operator|=
name|ETHER_HDR_LEN
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|+
name|offsetof
argument_list|(
expr|struct
name|udphdr
argument_list|,
name|uh_sum
argument_list|)
expr_stmt|;
block|}
name|TXD
operator|->
name|TcpSegSetup
operator|.
name|DwordData
operator|=
literal|0
expr_stmt|;
name|TXD
operator|->
name|CmdAndLength
operator|=
name|E1000_TXD_CMD_DEXT
expr_stmt|;
if|if
condition|(
name|CurrentTxDescriptor
operator|==
name|Adapter
operator|->
name|LastTxDescriptor
condition|)
name|Adapter
operator|->
name|NextAvailTxDescriptor
operator|=
name|Adapter
operator|->
name|FirstTxDescriptor
expr_stmt|;
else|else
name|Adapter
operator|->
name|NextAvailTxDescriptor
operator|++
expr_stmt|;
name|Adapter
operator|->
name|NumTxDescriptorsAvail
operator|--
expr_stmt|;
name|tx_buffer
operator|->
name|NumTxDescriptorsUsed
operator|++
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Get buffer from driver maintained free list for jumbo frames.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|em_get_jumbo_buf
parameter_list|(
name|struct
name|em_rx_buffer
modifier|*
name|rx_buffer
parameter_list|,
name|struct
name|adapter
modifier|*
name|Adapter
parameter_list|,
name|struct
name|mbuf
modifier|*
name|mp
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|nmp
decl_stmt|;
if|if
condition|(
name|mp
operator|==
name|NULL
condition|)
block|{
name|caddr_t
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
name|MGETHDR
argument_list|(
name|nmp
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|nmp
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"em%d: Mbuf allocation failed\n"
argument_list|,
name|Adapter
operator|->
name|unit
argument_list|)
expr_stmt|;
name|Adapter
operator|->
name|JumboMbufFailed
operator|++
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
comment|/* Allocate the jumbo buffer */
name|buf
operator|=
name|em_jalloc
argument_list|(
name|Adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
name|Adapter
operator|->
name|JumboClusterFailed
operator|++
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
comment|/* Attach the buffer to the mbuf. */
name|nmp
operator|->
name|m_data
operator|=
name|nmp
operator|->
name|m_ext
operator|.
name|ext_buf
operator|=
operator|(
name|void
operator|*
operator|)
name|buf
expr_stmt|;
name|nmp
operator|->
name|m_flags
operator||=
name|M_EXT
expr_stmt|;
name|nmp
operator|->
name|m_len
operator|=
name|nmp
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|nmp
operator|->
name|m_ext
operator|.
name|ext_size
operator|=
name|EM_JUMBO_FRAMELEN
expr_stmt|;
name|nmp
operator|->
name|m_ext
operator|.
name|ext_free
operator|=
name|em_jfree
expr_stmt|;
name|nmp
operator|->
name|m_ext
operator|.
name|ext_ref
operator|=
name|em_jref
expr_stmt|;
block|}
else|else
block|{
name|nmp
operator|=
name|mp
expr_stmt|;
name|nmp
operator|->
name|m_data
operator|=
name|nmp
operator|->
name|m_ext
operator|.
name|ext_buf
expr_stmt|;
name|nmp
operator|->
name|m_ext
operator|.
name|ext_size
operator|=
name|EM_JUMBO_FRAMELEN
expr_stmt|;
block|}
name|m_adj
argument_list|(
name|nmp
argument_list|,
name|ETHER_ALIGN
argument_list|)
expr_stmt|;
name|rx_buffer
operator|->
name|Packet
operator|=
name|nmp
expr_stmt|;
name|rx_buffer
operator|->
name|LowPhysicalAddress
operator|=
name|vtophys
argument_list|(
name|mtod
argument_list|(
name|nmp
argument_list|,
name|vm_offset_t
argument_list|)
argument_list|)
expr_stmt|;
name|rx_buffer
operator|->
name|HighPhysicalAddress
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Get a buffer from system mbuf buffer pool.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|em_get_std_buf
parameter_list|(
name|struct
name|em_rx_buffer
modifier|*
name|rx_buffer
parameter_list|,
name|struct
name|adapter
modifier|*
name|Adapter
parameter_list|,
name|struct
name|mbuf
modifier|*
name|mp
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|nmp
decl_stmt|;
if|if
condition|(
name|mp
operator|==
name|NULL
condition|)
block|{
name|MGETHDR
argument_list|(
name|nmp
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|nmp
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"em%d: Mbuf allocation failed\n"
argument_list|,
name|Adapter
operator|->
name|unit
argument_list|)
expr_stmt|;
name|Adapter
operator|->
name|StdMbufFailed
operator|++
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|MCLGET
argument_list|(
name|nmp
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|nmp
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"em%d: Mbuf cluster allocation failed\n"
argument_list|,
name|Adapter
operator|->
name|unit
argument_list|)
expr_stmt|;
name|Adapter
operator|->
name|StdClusterFailed
operator|++
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|nmp
operator|->
name|m_len
operator|=
name|nmp
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|MCLBYTES
expr_stmt|;
block|}
else|else
block|{
name|nmp
operator|=
name|mp
expr_stmt|;
name|nmp
operator|->
name|m_len
operator|=
name|nmp
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|MCLBYTES
expr_stmt|;
name|nmp
operator|->
name|m_data
operator|=
name|nmp
operator|->
name|m_ext
operator|.
name|ext_buf
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|SUPPORTLARGEFRAME
name|m_adj
argument_list|(
name|nmp
argument_list|,
name|ETHER_ALIGN
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|rx_buffer
operator|->
name|Packet
operator|=
name|nmp
expr_stmt|;
name|rx_buffer
operator|->
name|LowPhysicalAddress
operator|=
name|vtophys
argument_list|(
name|mtod
argument_list|(
name|nmp
argument_list|,
name|vm_offset_t
argument_list|)
argument_list|)
expr_stmt|;
name|rx_buffer
operator|->
name|HighPhysicalAddress
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Get buffer from system or driver maintained buffer freelist.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|em_get_buf
parameter_list|(
name|struct
name|em_rx_buffer
modifier|*
name|rx_buffer
parameter_list|,
name|struct
name|adapter
modifier|*
name|Adapter
parameter_list|,
name|struct
name|mbuf
modifier|*
name|mp
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|Adapter
operator|->
name|JumboEnable
operator|==
literal|1
condition|)
name|error
operator|=
name|em_get_jumbo_buf
argument_list|(
name|rx_buffer
argument_list|,
name|Adapter
argument_list|,
name|mp
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|em_get_std_buf
argument_list|(
name|rx_buffer
argument_list|,
name|Adapter
argument_list|,
name|mp
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Allocate memory for rx_buffer structures. Since we use one   *  rx_buffer per received packet, the maximum number of rx_buffer's   *  that we'll need is equal to the number of receive descriptors   *  that we've allocated.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|em_allocate_receive_structures
parameter_list|(
name|struct
name|adapter
modifier|*
name|Adapter
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|em_rx_buffer
modifier|*
name|rx_buffer
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|Adapter
operator|->
name|rx_buffer_area
operator|=
operator|(
expr|struct
name|em_rx_buffer
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|em_rx_buffer
argument_list|)
operator|*
name|Adapter
operator|->
name|NumRxDescriptors
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"em%d: Unable to allocate rx_buffer memory\n"
argument_list|,
name|Adapter
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|bzero
argument_list|(
name|Adapter
operator|->
name|rx_buffer_area
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|em_rx_buffer
argument_list|)
operator|*
name|Adapter
operator|->
name|NumRxDescriptors
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|rx_buffer
operator|=
name|Adapter
operator|->
name|rx_buffer_area
init|;
name|i
operator|<
name|Adapter
operator|->
name|NumRxDescriptors
condition|;
name|i
operator|++
operator|,
name|rx_buffer
operator|++
control|)
block|{
if|if
condition|(
name|em_get_buf
argument_list|(
name|rx_buffer
argument_list|,
name|Adapter
argument_list|,
name|NULL
argument_list|)
operator|==
name|ENOBUFS
condition|)
block|{
name|rx_buffer
operator|->
name|Packet
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Allocate and initialize receive structures.  *    **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|em_setup_receive_structures
parameter_list|(
name|struct
name|adapter
modifier|*
name|Adapter
parameter_list|)
block|{
name|struct
name|em_rx_buffer
modifier|*
name|rx_buffer
decl_stmt|;
name|PE1000_RECEIVE_DESCRIPTOR
name|RxDescriptorPtr
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|em_allocate_receive_structures
argument_list|(
name|Adapter
argument_list|)
condition|)
return|return
name|ENOMEM
return|;
name|STAILQ_INIT
argument_list|(
operator|&
name|Adapter
operator|->
name|RxSwPacketList
argument_list|)
expr_stmt|;
name|Adapter
operator|->
name|FirstRxDescriptor
operator|=
operator|(
name|PE1000_RECEIVE_DESCRIPTOR
operator|)
name|Adapter
operator|->
name|RxDescBase
expr_stmt|;
name|Adapter
operator|->
name|LastRxDescriptor
operator|=
name|Adapter
operator|->
name|FirstRxDescriptor
operator|+
operator|(
name|Adapter
operator|->
name|NumRxDescriptors
operator|-
literal|1
operator|)
expr_stmt|;
name|rx_buffer
operator|=
operator|(
expr|struct
name|em_rx_buffer
operator|*
operator|)
name|Adapter
operator|->
name|rx_buffer_area
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|void
operator|*
operator|)
name|Adapter
operator|->
name|FirstRxDescriptor
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
name|E1000_RECEIVE_DESCRIPTOR
argument_list|)
operator|)
operator|*
name|Adapter
operator|->
name|NumRxDescriptors
argument_list|)
expr_stmt|;
comment|/* Build a linked list of rx_buffer's */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|RxDescriptorPtr
operator|=
name|Adapter
operator|->
name|FirstRxDescriptor
init|;
name|i
operator|<
name|Adapter
operator|->
name|NumRxDescriptors
condition|;
name|i
operator|++
operator|,
name|rx_buffer
operator|++
operator|,
name|RxDescriptorPtr
operator|++
control|)
block|{
if|if
condition|(
name|rx_buffer
operator|->
name|Packet
operator|==
name|NULL
condition|)
name|printf
argument_list|(
literal|"em%d: Receive buffer memory not allocated"
argument_list|,
name|Adapter
operator|->
name|unit
argument_list|)
expr_stmt|;
else|else
block|{
name|RxDescriptorPtr
operator|->
name|BufferAddress
operator|.
name|Lo32
operator|=
name|rx_buffer
operator|->
name|LowPhysicalAddress
expr_stmt|;
name|RxDescriptorPtr
operator|->
name|BufferAddress
operator|.
name|Hi32
operator|=
name|rx_buffer
operator|->
name|HighPhysicalAddress
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|Adapter
operator|->
name|RxSwPacketList
argument_list|,
name|rx_buffer
argument_list|,
name|em_rx_entry
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Setup our descriptor pointers */
name|Adapter
operator|->
name|NextRxDescriptorToCheck
operator|=
name|Adapter
operator|->
name|FirstRxDescriptor
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Enable receive unit.  *    **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|em_initialize_receive_unit
parameter_list|(
name|struct
name|adapter
modifier|*
name|Adapter
parameter_list|)
block|{
name|u_int32_t
name|reg_rctl
decl_stmt|;
name|u_int32_t
name|reg_rxcsum
decl_stmt|;
comment|/* Make sure receives are disabled while setting up the descriptor ring */
name|E1000_WRITE_REG
argument_list|(
name|Rctl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Set the Receive Delay Timer Register */
name|E1000_WRITE_REG
argument_list|(
name|Rdtr0
argument_list|,
name|Adapter
operator|->
name|RxIntDelay
operator||
name|E1000_RDT0_FPDB
argument_list|)
expr_stmt|;
comment|/* Setup the Base and Length of the Rx Descriptor Ring */
name|E1000_WRITE_REG
argument_list|(
name|Rdbal0
argument_list|,
name|vtophys
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|Adapter
operator|->
name|RxDescBase
argument_list|)
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|Rdbah0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|Rdlen0
argument_list|,
name|Adapter
operator|->
name|NumRxDescriptors
operator|*
sizeof|sizeof
argument_list|(
name|E1000_RECEIVE_DESCRIPTOR
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Setup the HW Rx Head and Tail Descriptor Pointers */
name|E1000_WRITE_REG
argument_list|(
name|Rdh0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|Rdt0
argument_list|,
operator|(
operator|(
operator|(
name|u_int32_t
operator|)
name|Adapter
operator|->
name|LastRxDescriptor
operator|-
operator|(
name|u_int32_t
operator|)
name|Adapter
operator|->
name|FirstRxDescriptor
operator|)
operator|>>
literal|4
operator|)
argument_list|)
expr_stmt|;
comment|/*      * Zero out the registers associated with the 82542 second receive     * descriptor ring - we don't use it     */
if|if
condition|(
name|Adapter
operator|->
name|MacType
operator|<
name|MAC_LIVENGOOD
condition|)
block|{
name|E1000_WRITE_REG
argument_list|(
name|Rdbal1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|Rdbah1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|Rdlen1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|Rdh1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|Rdt1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Setup the Receive Control Register */
name|reg_rctl
operator|=
name|E1000_RCTL_EN
operator||
name|E1000_RCTL_BAM
operator||
name|E1000_RCTL_LBM_NO
operator||
name|E1000_RCTL_RDMTS0_HALF
operator||
operator|(
name|Adapter
operator|->
name|MulticastFilterType
operator|<<
name|E1000_RCTL_MO_SHIFT
operator|)
expr_stmt|;
if|if
condition|(
name|Adapter
operator|->
name|TbiCompatibilityOn
operator|==
name|TRUE
condition|)
name|reg_rctl
operator||=
name|E1000_RCTL_SBP
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORTLARGEFRAME
switch|switch
condition|(
name|Adapter
operator|->
name|RxBufferLen
condition|)
block|{
case|case
name|EM_RXBUFFER_2048
case|:
name|reg_rctl
operator||=
name|E1000_RCTL_SZ_2048
operator||
name|E1000_RCTL_LPE
expr_stmt|;
break|break;
case|case
name|EM_RXBUFFER_4096
case|:
name|reg_rctl
operator||=
name|E1000_RCTL_SZ_4096
operator||
name|E1000_RCTL_BSEX
operator||
name|E1000_RCTL_LPE
expr_stmt|;
break|break;
case|case
name|EM_RXBUFFER_8192
case|:
name|reg_rctl
operator||=
name|E1000_RCTL_SZ_8192
operator||
name|E1000_RCTL_BSEX
operator||
name|E1000_RCTL_LPE
expr_stmt|;
break|break;
case|case
name|EM_RXBUFFER_16384
case|:
name|reg_rctl
operator||=
name|E1000_RCTL_SZ_16384
operator||
name|E1000_RCTL_BSEX
operator||
name|E1000_RCTL_LPE
expr_stmt|;
break|break;
default|default:
name|reg_rctl
operator||=
name|E1000_RCTL_SZ_2048
expr_stmt|;
block|}
else|#
directive|else
switch|switch
condition|(
name|Adapter
operator|->
name|RxBufferLen
condition|)
block|{
case|case
name|EM_RXBUFFER_2048
case|:
name|reg_rctl
operator||=
name|E1000_RCTL_SZ_2048
expr_stmt|;
break|break;
case|case
name|EM_RXBUFFER_4096
case|:
name|reg_rctl
operator||=
name|E1000_RCTL_SZ_4096
operator||
name|E1000_RCTL_BSEX
operator||
name|E1000_RCTL_LPE
expr_stmt|;
break|break;
case|case
name|EM_RXBUFFER_8192
case|:
name|reg_rctl
operator||=
name|E1000_RCTL_SZ_8192
operator||
name|E1000_RCTL_BSEX
operator||
name|E1000_RCTL_LPE
expr_stmt|;
break|break;
case|case
name|EM_RXBUFFER_16384
case|:
name|reg_rctl
operator||=
name|E1000_RCTL_SZ_16384
operator||
name|E1000_RCTL_BSEX
operator||
name|E1000_RCTL_LPE
expr_stmt|;
break|break;
default|default:
name|reg_rctl
operator||=
name|E1000_RCTL_SZ_2048
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Enable 82543 Receive Checksum Offload for TCP and UDP */
if|if
condition|(
operator|(
name|Adapter
operator|->
name|MacType
operator|>=
name|MAC_LIVENGOOD
operator|)
operator|&&
operator|(
name|Adapter
operator|->
name|RxChecksum
operator|==
literal|1
operator|)
condition|)
block|{
name|reg_rxcsum
operator|=
name|E1000_READ_REG
argument_list|(
name|Rxcsum
argument_list|)
expr_stmt|;
name|reg_rxcsum
operator||=
operator|(
name|E1000_RXCSUM_IPOFL
operator||
name|E1000_RXCSUM_TUOFL
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|Rxcsum
argument_list|,
name|reg_rxcsum
argument_list|)
expr_stmt|;
block|}
comment|/* Enable Receives */
name|E1000_WRITE_REG
argument_list|(
name|Rctl
argument_list|,
name|reg_rctl
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Free receive related data structures.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|em_free_receive_structures
parameter_list|(
name|struct
name|adapter
modifier|*
name|Adapter
parameter_list|)
block|{
name|struct
name|em_rx_buffer
modifier|*
name|rx_buffer
decl_stmt|;
name|int
name|i
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"free_receive_structures: begin"
argument_list|)
expr_stmt|;
if|if
condition|(
name|Adapter
operator|->
name|rx_buffer_area
operator|!=
name|NULL
condition|)
block|{
name|rx_buffer
operator|=
name|Adapter
operator|->
name|rx_buffer_area
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|Adapter
operator|->
name|NumRxDescriptors
condition|;
name|i
operator|++
operator|,
name|rx_buffer
operator|++
control|)
block|{
if|if
condition|(
name|rx_buffer
operator|->
name|Packet
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|rx_buffer
operator|->
name|Packet
argument_list|)
expr_stmt|;
name|rx_buffer
operator|->
name|Packet
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|Adapter
operator|->
name|rx_buffer_area
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|Adapter
operator|->
name|rx_buffer_area
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|Adapter
operator|->
name|rx_buffer_area
operator|=
name|NULL
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Allocate memory to be used for jumbo buffers  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|em_alloc_jumbo_mem
parameter_list|(
name|struct
name|adapter
modifier|*
name|Adapter
parameter_list|)
block|{
name|caddr_t
name|ptr
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|struct
name|em_jpool_entry
modifier|*
name|entry
decl_stmt|;
name|Adapter
operator|->
name|em_jumbo_buf
operator|=
name|contigmalloc
argument_list|(
name|EM_JMEM
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|,
literal|0
argument_list|,
literal|0xffffffff
argument_list|,
name|PAGE_SIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|Adapter
operator|->
name|em_jumbo_buf
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"em%d: No memory for jumbo buffers!\n"
argument_list|,
name|Adapter
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|SLIST_INIT
argument_list|(
operator|&
name|Adapter
operator|->
name|em_jfree_listhead
argument_list|)
expr_stmt|;
name|SLIST_INIT
argument_list|(
operator|&
name|Adapter
operator|->
name|em_jinuse_listhead
argument_list|)
expr_stmt|;
comment|/*     * Now divide it up into 9K pieces and save the addresses     * in an array. We use the the first few bytes in the buffer to hold      * the address of the adapter (softc) structure for this interface.      * This is because em_jfree() needs it, but it is called by the mbuf      * management code which will not pass it to us explicitly.     */
name|ptr
operator|=
name|Adapter
operator|->
name|em_jumbo_buf
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|EM_JSLOTS
condition|;
name|i
operator|++
control|)
block|{
name|u_int64_t
modifier|*
modifier|*
name|aptr
decl_stmt|;
name|aptr
operator|=
operator|(
name|u_int64_t
operator|*
operator|*
operator|)
name|ptr
expr_stmt|;
name|aptr
index|[
literal|0
index|]
operator|=
operator|(
name|u_int64_t
operator|*
operator|)
name|Adapter
expr_stmt|;
name|ptr
operator|+=
sizeof|sizeof
argument_list|(
name|u_int64_t
argument_list|)
expr_stmt|;
name|Adapter
operator|->
name|em_jslots
index|[
name|i
index|]
operator|.
name|em_buf
operator|=
name|ptr
expr_stmt|;
name|Adapter
operator|->
name|em_jslots
index|[
name|i
index|]
operator|.
name|em_inuse
operator|=
literal|0
expr_stmt|;
name|ptr
operator|+=
operator|(
name|EM_JLEN
operator|-
sizeof|sizeof
argument_list|(
name|u_int64_t
argument_list|)
operator|)
expr_stmt|;
name|entry
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|em_jpool_entry
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
block|{
name|contigfree
argument_list|(
name|Adapter
operator|->
name|em_jumbo_buf
argument_list|,
name|EM_JMEM
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|Adapter
operator|->
name|em_jumbo_buf
operator|=
name|NULL
expr_stmt|;
name|printf
argument_list|(
literal|"em%d: No memory for jumbo buffer queue!\n"
argument_list|,
name|Adapter
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|entry
operator|->
name|slot
operator|=
name|i
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|Adapter
operator|->
name|em_jfree_listhead
argument_list|,
name|entry
argument_list|,
name|em_jpool_entries
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Get Jumbo buffer from free list.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
modifier|*
name|em_jalloc
parameter_list|(
name|struct
name|adapter
modifier|*
name|Adapter
parameter_list|)
block|{
name|struct
name|em_jpool_entry
modifier|*
name|entry
decl_stmt|;
name|entry
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|Adapter
operator|->
name|em_jfree_listhead
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
block|{
name|Adapter
operator|->
name|NoJumboBufAvail
operator|++
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|SLIST_REMOVE_HEAD
argument_list|(
operator|&
name|Adapter
operator|->
name|em_jfree_listhead
argument_list|,
name|em_jpool_entries
argument_list|)
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|Adapter
operator|->
name|em_jinuse_listhead
argument_list|,
name|entry
argument_list|,
name|em_jpool_entries
argument_list|)
expr_stmt|;
name|Adapter
operator|->
name|em_jslots
index|[
name|entry
operator|->
name|slot
index|]
operator|.
name|em_inuse
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|Adapter
operator|->
name|em_jslots
index|[
name|entry
operator|->
name|slot
index|]
operator|.
name|em_buf
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Adjust usage count on a jumbo buffer.  *  *********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|em_jref
parameter_list|(
name|caddr_t
name|buf
parameter_list|,
name|u_int
name|size
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|Adapter
decl_stmt|;
name|u_int64_t
modifier|*
modifier|*
name|aptr
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
comment|/* Extract the Adapter (softc) struct pointer */
name|aptr
operator|=
operator|(
name|u_int64_t
operator|*
operator|*
operator|)
operator|(
name|buf
operator|-
sizeof|sizeof
argument_list|(
name|u_int64_t
argument_list|)
operator|)
expr_stmt|;
name|Adapter
operator|=
operator|(
expr|struct
name|adapter
operator|*
operator|)
operator|(
name|aptr
index|[
literal|0
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|Adapter
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"em_jref: Can't find softc pointer!"
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|!=
name|EM_JUMBO_FRAMELEN
condition|)
name|panic
argument_list|(
literal|"em_jref: Adjusting reference count of buf of wrong size!"
argument_list|)
expr_stmt|;
comment|/* Calculate the slot this buffer belongs to */
name|i
operator|=
operator|(
operator|(
name|vm_offset_t
operator|)
name|aptr
operator|-
operator|(
name|vm_offset_t
operator|)
name|Adapter
operator|->
name|em_jumbo_buf
operator|)
operator|/
name|EM_JLEN
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|<
literal|0
operator|)
operator|||
operator|(
name|i
operator|>=
name|EM_JSLOTS
operator|)
condition|)
name|panic
argument_list|(
literal|"em_jref: Asked to reference buffer that we don't manage!"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|Adapter
operator|->
name|em_jslots
index|[
name|i
index|]
operator|.
name|em_inuse
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"em_jref: Buffer already free!"
argument_list|)
expr_stmt|;
else|else
name|Adapter
operator|->
name|em_jslots
index|[
name|i
index|]
operator|.
name|em_inuse
operator|++
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Put the jumbo buffer back onto free list.  *  *********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|em_jfree
parameter_list|(
name|caddr_t
name|buf
parameter_list|,
name|u_int
name|size
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|Adapter
decl_stmt|;
name|u_int64_t
modifier|*
modifier|*
name|aptr
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|em_jpool_entry
modifier|*
name|entry
decl_stmt|;
comment|/* Extract the adapter (softc) struct pointer. */
name|aptr
operator|=
operator|(
name|u_int64_t
operator|*
operator|*
operator|)
operator|(
name|buf
operator|-
sizeof|sizeof
argument_list|(
name|u_int64_t
argument_list|)
operator|)
expr_stmt|;
name|Adapter
operator|=
operator|(
expr|struct
name|adapter
operator|*
operator|)
operator|(
name|aptr
index|[
literal|0
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|Adapter
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"em_jfree: Can't find softc pointer!"
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|!=
name|EM_JUMBO_FRAMELEN
condition|)
name|panic
argument_list|(
literal|"em_jfree: Freeing buffer of wrong size!"
argument_list|)
expr_stmt|;
comment|/* Calculate the slot this buffer belongs to */
name|i
operator|=
operator|(
operator|(
name|vm_offset_t
operator|)
name|aptr
operator|-
operator|(
name|vm_offset_t
operator|)
name|Adapter
operator|->
name|em_jumbo_buf
operator|)
operator|/
name|EM_JLEN
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|<
literal|0
operator|)
operator|||
operator|(
name|i
operator|>=
name|EM_JSLOTS
operator|)
condition|)
name|panic
argument_list|(
literal|"em_jfree: Asked to free buffer that we don't manage!"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|Adapter
operator|->
name|em_jslots
index|[
name|i
index|]
operator|.
name|em_inuse
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"em_jfree: Buffer already free!"
argument_list|)
expr_stmt|;
else|else
block|{
name|Adapter
operator|->
name|em_jslots
index|[
name|i
index|]
operator|.
name|em_inuse
operator|--
expr_stmt|;
if|if
condition|(
name|Adapter
operator|->
name|em_jslots
index|[
name|i
index|]
operator|.
name|em_inuse
operator|==
literal|0
condition|)
block|{
name|entry
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|Adapter
operator|->
name|em_jinuse_listhead
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"em_jfree: Buffer not in use!"
argument_list|)
expr_stmt|;
name|entry
operator|->
name|slot
operator|=
name|i
expr_stmt|;
name|SLIST_REMOVE_HEAD
argument_list|(
operator|&
name|Adapter
operator|->
name|em_jinuse_listhead
argument_list|,
name|em_jpool_entries
argument_list|)
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|Adapter
operator|->
name|em_jfree_listhead
argument_list|,
name|entry
argument_list|,
name|em_jpool_entries
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SUPPORTLARGEFRAME
end_ifdef

begin_comment
comment|/*********************************************************************  *  *  This routine executes in interrupt context. It replenishes  *  the mbufs in the descriptor and sends data which has been  *  dma'ed into host memory to upper layer.  *  *********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|em_process_receive_interrupts
parameter_list|(
name|struct
name|adapter
modifier|*
name|Adapter
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|mp
decl_stmt|,
modifier|*
name|lmp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|fmp
init|=
name|NULL
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|u_int16_t
name|Length
decl_stmt|;
name|u_int8_t
name|LastByte
decl_stmt|;
name|u_int8_t
name|AcceptFrame
init|=
literal|0
decl_stmt|;
name|u_int8_t
name|EndOfPacket
init|=
literal|0
decl_stmt|;
name|u_int16_t
name|PacketLength
init|=
literal|0
decl_stmt|;
comment|/* Pointer to the receive descriptor being examined. */
name|PE1000_RECEIVE_DESCRIPTOR
name|CurrentDescriptor
decl_stmt|;
name|PE1000_RECEIVE_DESCRIPTOR
name|LastDescriptorProcessed
decl_stmt|;
name|struct
name|em_rx_buffer
modifier|*
name|rx_buffer
decl_stmt|;
name|TXRX_DEBUGOUT
argument_list|(
literal|"em_process_receive_interrupts: begin"
argument_list|)
expr_stmt|;
name|ifp
operator|=
operator|&
name|Adapter
operator|->
name|interface_data
operator|.
name|ac_if
expr_stmt|;
name|CurrentDescriptor
operator|=
name|Adapter
operator|->
name|NextRxDescriptorToCheck
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|CurrentDescriptor
operator|->
name|ReceiveStatus
operator|)
operator|&
name|E1000_RXD_STAT_DD
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DBG_STATS
name|Adapter
operator|->
name|NoPacketsAvail
operator|++
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
while|while
condition|(
name|CurrentDescriptor
operator|->
name|ReceiveStatus
operator|&
name|E1000_RXD_STAT_DD
condition|)
block|{
comment|/* Get a pointer to the actual receive buffer */
name|rx_buffer
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|Adapter
operator|->
name|RxSwPacketList
argument_list|)
expr_stmt|;
if|if
condition|(
name|rx_buffer
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"em%d: Found null rx_buffer\n"
argument_list|,
name|Adapter
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
name|mp
operator|=
name|rx_buffer
operator|->
name|Packet
expr_stmt|;
name|AcceptFrame
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|CurrentDescriptor
operator|->
name|ReceiveStatus
operator|&
name|E1000_RXD_STAT_EOP
condition|)
block|{
name|EndOfPacket
operator|=
literal|1
expr_stmt|;
name|Length
operator|=
name|CurrentDescriptor
operator|->
name|Length
operator|-
name|ETHER_CRC_LEN
expr_stmt|;
block|}
else|else
block|{
name|EndOfPacket
operator|=
literal|0
expr_stmt|;
name|Length
operator|=
name|CurrentDescriptor
operator|->
name|Length
expr_stmt|;
block|}
if|if
condition|(
name|CurrentDescriptor
operator|->
name|Errors
operator|&
name|E1000_RXD_ERR_FRAME_ERR_MASK
condition|)
block|{
name|LastByte
operator|=
operator|*
operator|(
name|mtod
argument_list|(
name|rx_buffer
operator|->
name|Packet
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|Length
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|TBI_ACCEPT
argument_list|(
name|CurrentDescriptor
operator|->
name|Errors
argument_list|,
name|LastByte
argument_list|,
name|Length
argument_list|)
condition|)
block|{
name|em_adjust_tbi_accepted_stats
argument_list|(
name|Adapter
argument_list|,
name|Length
argument_list|,
name|Adapter
operator|->
name|CurrentNetAddress
argument_list|)
expr_stmt|;
name|Length
operator|--
expr_stmt|;
block|}
else|else
block|{
name|AcceptFrame
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|AcceptFrame
condition|)
block|{
comment|/* Keep track of entire packet length */
name|PacketLength
operator|+=
name|Length
expr_stmt|;
comment|/* Assign correct length to the current fragment */
name|mp
operator|->
name|m_len
operator|=
name|Length
expr_stmt|;
if|if
condition|(
name|fmp
operator|==
name|NULL
condition|)
block|{
name|fmp
operator|=
name|mp
expr_stmt|;
comment|/* Store the first mbuf */
name|lmp
operator|=
name|fmp
expr_stmt|;
block|}
else|else
block|{
comment|/* Chain mbuf's together */
name|mp
operator|->
name|m_flags
operator|&=
operator|~
name|M_PKTHDR
expr_stmt|;
name|lmp
operator|->
name|m_next
operator|=
name|mp
expr_stmt|;
name|lmp
operator|=
name|lmp
operator|->
name|m_next
expr_stmt|;
name|lmp
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|em_get_buf
argument_list|(
name|rx_buffer
argument_list|,
name|Adapter
argument_list|,
name|NULL
argument_list|)
operator|==
name|ENOBUFS
condition|)
block|{
name|Adapter
operator|->
name|DroppedPackets
operator|++
expr_stmt|;
name|em_get_buf
argument_list|(
name|rx_buffer
argument_list|,
name|Adapter
argument_list|,
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmp
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|fmp
argument_list|)
expr_stmt|;
name|fmp
operator|=
name|NULL
expr_stmt|;
name|lmp
operator|=
name|NULL
expr_stmt|;
name|PacketLength
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|EndOfPacket
condition|)
block|{
name|fmp
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
name|fmp
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|PacketLength
expr_stmt|;
name|eh
operator|=
name|mtod
argument_list|(
name|fmp
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
comment|/* Remove ethernet header from mbuf */
name|m_adj
argument_list|(
name|fmp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|)
expr_stmt|;
name|em_receive_checksum
argument_list|(
name|Adapter
argument_list|,
name|CurrentDescriptor
argument_list|,
name|fmp
argument_list|)
expr_stmt|;
name|ether_input
argument_list|(
name|ifp
argument_list|,
name|eh
argument_list|,
name|fmp
argument_list|)
expr_stmt|;
name|fmp
operator|=
name|NULL
expr_stmt|;
name|lmp
operator|=
name|NULL
expr_stmt|;
name|PacketLength
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|Adapter
operator|->
name|DroppedPackets
operator|++
expr_stmt|;
name|em_get_buf
argument_list|(
name|rx_buffer
argument_list|,
name|Adapter
argument_list|,
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmp
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|fmp
argument_list|)
expr_stmt|;
name|fmp
operator|=
name|NULL
expr_stmt|;
name|lmp
operator|=
name|NULL
expr_stmt|;
name|PacketLength
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Zero out the receive descriptors status  */
name|CurrentDescriptor
operator|->
name|ReceiveStatus
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rx_buffer
operator|->
name|Packet
operator|!=
name|NULL
condition|)
block|{
name|CurrentDescriptor
operator|->
name|BufferAddress
operator|.
name|Lo32
operator|=
name|rx_buffer
operator|->
name|LowPhysicalAddress
expr_stmt|;
name|CurrentDescriptor
operator|->
name|BufferAddress
operator|.
name|Hi32
operator|=
name|rx_buffer
operator|->
name|HighPhysicalAddress
expr_stmt|;
block|}
comment|/* Advance our pointers to the next descriptor (checking for wrap). */
if|if
condition|(
name|CurrentDescriptor
operator|==
name|Adapter
operator|->
name|LastRxDescriptor
condition|)
name|Adapter
operator|->
name|NextRxDescriptorToCheck
operator|=
name|Adapter
operator|->
name|FirstRxDescriptor
expr_stmt|;
else|else
operator|(
operator|(
name|Adapter
operator|)
operator|->
name|NextRxDescriptorToCheck
operator|)
operator|++
expr_stmt|;
name|LastDescriptorProcessed
operator|=
name|CurrentDescriptor
expr_stmt|;
name|CurrentDescriptor
operator|=
name|Adapter
operator|->
name|NextRxDescriptorToCheck
expr_stmt|;
comment|/*         * Put the buffer that we just indicated back at the end of our list        */
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|Adapter
operator|->
name|RxSwPacketList
argument_list|,
name|em_rx_entry
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|Adapter
operator|->
name|RxSwPacketList
argument_list|,
name|rx_buffer
argument_list|,
name|em_rx_entry
argument_list|)
expr_stmt|;
comment|/* Advance the E1000's Receive Queue #0  "Tail Pointer". */
name|E1000_WRITE_REG
argument_list|(
name|Rdt0
argument_list|,
operator|(
operator|(
operator|(
name|u_int32_t
operator|)
name|LastDescriptorProcessed
operator|-
operator|(
name|u_int32_t
operator|)
name|Adapter
operator|->
name|FirstRxDescriptor
operator|)
operator|>>
literal|4
operator|)
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/*********************************************************************  *  *  This routine executes in interrupt context. It replenishes  *  the mbufs in the descriptor and sends data which has been  *  dma'ed into host memory to upper layer.  *  *********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|em_process_receive_interrupts
parameter_list|(
name|struct
name|adapter
modifier|*
name|Adapter
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|mp
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|u_int16_t
name|Length
decl_stmt|;
name|u_int8_t
name|LastByte
decl_stmt|;
name|u_int8_t
name|AcceptFrame
decl_stmt|;
comment|/* Pointer to the receive descriptor being examined. */
name|PE1000_RECEIVE_DESCRIPTOR
name|CurrentDescriptor
decl_stmt|;
name|PE1000_RECEIVE_DESCRIPTOR
name|LastDescriptorProcessed
decl_stmt|;
name|struct
name|em_rx_buffer
modifier|*
name|rx_buffer
decl_stmt|;
name|TXRX_DEBUGOUT
argument_list|(
literal|"em_process_receive_interrupts: begin"
argument_list|)
expr_stmt|;
name|ifp
operator|=
operator|&
name|Adapter
operator|->
name|interface_data
operator|.
name|ac_if
expr_stmt|;
name|CurrentDescriptor
operator|=
name|Adapter
operator|->
name|NextRxDescriptorToCheck
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|CurrentDescriptor
operator|->
name|ReceiveStatus
operator|)
operator|&
name|E1000_RXD_STAT_DD
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DBG_STATS
name|Adapter
operator|->
name|NoPacketsAvail
operator|++
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
while|while
condition|(
name|CurrentDescriptor
operator|->
name|ReceiveStatus
operator|&
name|E1000_RXD_STAT_DD
condition|)
block|{
comment|/* Get a pointer to the actual receive buffer */
name|rx_buffer
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|Adapter
operator|->
name|RxSwPacketList
argument_list|)
expr_stmt|;
if|if
condition|(
name|rx_buffer
operator|==
name|NULL
condition|)
return|return;
name|mp
operator|=
name|rx_buffer
operator|->
name|Packet
expr_stmt|;
name|Length
operator|=
name|CurrentDescriptor
operator|->
name|Length
expr_stmt|;
comment|/* Make sure this is also the last descriptor in the packet. */
if|if
condition|(
name|CurrentDescriptor
operator|->
name|ReceiveStatus
operator|&
name|E1000_RXD_STAT_EOP
condition|)
block|{
name|AcceptFrame
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|CurrentDescriptor
operator|->
name|Errors
operator|&
name|E1000_RXD_ERR_FRAME_ERR_MASK
condition|)
block|{
name|LastByte
operator|=
operator|*
operator|(
name|mtod
argument_list|(
name|rx_buffer
operator|->
name|Packet
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|Length
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|TBI_ACCEPT
argument_list|(
name|CurrentDescriptor
operator|->
name|Errors
argument_list|,
name|LastByte
argument_list|,
name|Length
argument_list|)
condition|)
block|{
name|em_adjust_tbi_accepted_stats
argument_list|(
name|Adapter
argument_list|,
name|Length
argument_list|,
name|Adapter
operator|->
name|CurrentNetAddress
argument_list|)
expr_stmt|;
name|Length
operator|--
expr_stmt|;
block|}
else|else
block|{
name|AcceptFrame
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|AcceptFrame
condition|)
block|{
if|if
condition|(
name|em_get_buf
argument_list|(
name|rx_buffer
argument_list|,
name|Adapter
argument_list|,
name|NULL
argument_list|)
operator|==
name|ENOBUFS
condition|)
block|{
name|Adapter
operator|->
name|DroppedPackets
operator|++
expr_stmt|;
name|em_get_buf
argument_list|(
name|rx_buffer
argument_list|,
name|Adapter
argument_list|,
name|mp
argument_list|)
expr_stmt|;
break|break;
block|}
name|mp
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
name|mp
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|mp
operator|->
name|m_len
operator|=
name|Length
operator|-
name|ETHER_CRC_LEN
expr_stmt|;
name|eh
operator|=
name|mtod
argument_list|(
name|mp
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
comment|/* Remove ethernet header from mbuf */
name|m_adj
argument_list|(
name|mp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|)
expr_stmt|;
name|em_receive_checksum
argument_list|(
name|Adapter
argument_list|,
name|CurrentDescriptor
argument_list|,
name|mp
argument_list|)
expr_stmt|;
name|ether_input
argument_list|(
name|ifp
argument_list|,
name|eh
argument_list|,
name|mp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|em_get_buf
argument_list|(
name|rx_buffer
argument_list|,
name|Adapter
argument_list|,
name|mp
argument_list|)
expr_stmt|;
name|Adapter
operator|->
name|DroppedPackets
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/*            * If the received packet has spanned multiple descriptors, ignore           * and discard all the packets that do not have EOP set and proceed           * to the next packet.           */
name|printf
argument_list|(
literal|"em%d: !Receive packet consumed multiple buffers\n"
argument_list|,
name|Adapter
operator|->
name|unit
argument_list|)
expr_stmt|;
name|em_get_buf
argument_list|(
name|rx_buffer
argument_list|,
name|Adapter
argument_list|,
name|mp
argument_list|)
expr_stmt|;
name|Adapter
operator|->
name|DroppedPackets
operator|++
expr_stmt|;
block|}
comment|/* Zero out the receive descriptors status  */
name|CurrentDescriptor
operator|->
name|ReceiveStatus
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rx_buffer
operator|->
name|Packet
operator|!=
name|NULL
condition|)
block|{
name|CurrentDescriptor
operator|->
name|BufferAddress
operator|.
name|Lo32
operator|=
name|rx_buffer
operator|->
name|LowPhysicalAddress
expr_stmt|;
name|CurrentDescriptor
operator|->
name|BufferAddress
operator|.
name|Hi32
operator|=
name|rx_buffer
operator|->
name|HighPhysicalAddress
expr_stmt|;
block|}
comment|/* Advance our pointers to the next descriptor (checking for wrap). */
if|if
condition|(
name|CurrentDescriptor
operator|==
name|Adapter
operator|->
name|LastRxDescriptor
condition|)
name|Adapter
operator|->
name|NextRxDescriptorToCheck
operator|=
name|Adapter
operator|->
name|FirstRxDescriptor
expr_stmt|;
else|else
operator|(
operator|(
name|Adapter
operator|)
operator|->
name|NextRxDescriptorToCheck
operator|)
operator|++
expr_stmt|;
name|LastDescriptorProcessed
operator|=
name|CurrentDescriptor
expr_stmt|;
name|CurrentDescriptor
operator|=
name|Adapter
operator|->
name|NextRxDescriptorToCheck
expr_stmt|;
comment|/*         * Put the buffer that we just indicated back at the end of our list        */
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|Adapter
operator|->
name|RxSwPacketList
argument_list|,
name|em_rx_entry
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|Adapter
operator|->
name|RxSwPacketList
argument_list|,
name|rx_buffer
argument_list|,
name|em_rx_entry
argument_list|)
expr_stmt|;
comment|/* Advance the E1000's Receive Queue #0  "Tail Pointer". */
name|E1000_WRITE_REG
argument_list|(
name|Rdt0
argument_list|,
operator|(
operator|(
operator|(
name|u_int32_t
operator|)
name|LastDescriptorProcessed
operator|-
operator|(
name|u_int32_t
operator|)
name|Adapter
operator|->
name|FirstRxDescriptor
operator|)
operator|>>
literal|4
operator|)
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*********************************************************************  *  *  Verify that the hardware indicated that the checksum is valid.   *  Inform the stack about the status of checksum so that stack  *  doesn't spend time verifying the checksum.  *  *********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|em_receive_checksum
parameter_list|(
name|struct
name|adapter
modifier|*
name|Adapter
parameter_list|,
name|PE1000_RECEIVE_DESCRIPTOR
name|RxDescriptor
parameter_list|,
name|struct
name|mbuf
modifier|*
name|mp
parameter_list|)
block|{
comment|/* 82543 or newer only */
if|if
condition|(
operator|(
name|Adapter
operator|->
name|MacType
operator|<
name|MAC_LIVENGOOD
operator|)
operator|||
comment|/* Ignore Checksum bit is set */
operator|(
name|RxDescriptor
operator|->
name|ReceiveStatus
operator|&
name|E1000_RXD_STAT_IXSM
operator|)
condition|)
block|{
name|RXCSUM_DEBUGOUT
argument_list|(
literal|"Ignoring checksum"
argument_list|)
expr_stmt|;
name|mp
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|=
literal|0
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|RxDescriptor
operator|->
name|ReceiveStatus
operator|&
name|E1000_RXD_STAT_IPCS
condition|)
block|{
comment|/* Did it pass? */
if|if
condition|(
operator|!
operator|(
name|RxDescriptor
operator|->
name|Errors
operator|&
name|E1000_RXD_ERR_IPE
operator|)
condition|)
block|{
comment|/* IP Checksum Good */
name|RXCSUM_DEBUGOUT
argument_list|(
literal|"Good IP checksum"
argument_list|)
expr_stmt|;
name|mp
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|=
name|CSUM_IP_CHECKED
expr_stmt|;
name|mp
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator||=
name|CSUM_IP_VALID
expr_stmt|;
block|}
else|else
block|{
name|RXCSUM_DEBUGOUT
argument_list|(
literal|"Bad IP checksum"
argument_list|)
expr_stmt|;
name|mp
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|RXCSUM_DEBUGOUT
argument_list|(
literal|"IP Checksum not verified"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|RxDescriptor
operator|->
name|ReceiveStatus
operator|&
name|E1000_RXD_STAT_TCPCS
condition|)
block|{
comment|/* Did it pass? */
if|if
condition|(
operator|!
operator|(
name|RxDescriptor
operator|->
name|Errors
operator|&
name|E1000_RXD_ERR_TCPE
operator|)
condition|)
block|{
name|RXCSUM_DEBUGOUT
argument_list|(
literal|"Good TCP/UDP checksum"
argument_list|)
expr_stmt|;
name|mp
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator||=
operator|(
name|CSUM_DATA_VALID
operator||
name|CSUM_PSEUDO_HDR
operator|)
expr_stmt|;
name|mp
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|=
name|htons
argument_list|(
literal|0xffff
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|RXCSUM_DEBUGOUT
argument_list|(
literal|"Bad TCP/UDP checksum"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|RXCSUM_DEBUGOUT
argument_list|(
literal|"TCP/UDP checksum not verified"
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|EnableInterrupts
parameter_list|(
name|struct
name|adapter
modifier|*
name|Adapter
parameter_list|)
block|{
name|E1000_WRITE_REG
argument_list|(
name|Ims
argument_list|,
operator|(
name|IMS_ENABLE_MASK
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|DisableInterrupts
parameter_list|(
name|struct
name|adapter
modifier|*
name|Adapter
parameter_list|)
block|{
name|E1000_WRITE_REG
argument_list|(
name|Imc
argument_list|,
operator|(
literal|0xffffffff
operator|&
operator|~
name|E1000_IMC_RXSEQ
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**********************************************************************  *  *  Update the board statistics counters.   *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|em_update_stats_counters
parameter_list|(
name|struct
name|adapter
modifier|*
name|Adapter
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|Adapter
operator|->
name|Crcerrs
operator|+=
name|E1000_READ_REG
argument_list|(
name|Crcerrs
argument_list|)
expr_stmt|;
name|Adapter
operator|->
name|Crcerrs
operator|+=
name|E1000_READ_REG
argument_list|(
name|Crcerrs
argument_list|)
expr_stmt|;
name|Adapter
operator|->
name|Symerrs
operator|+=
name|E1000_READ_REG
argument_list|(
name|Symerrs
argument_list|)
expr_stmt|;
name|Adapter
operator|->
name|Mpc
operator|+=
name|E1000_READ_REG
argument_list|(
name|Mpc
argument_list|)
expr_stmt|;
name|Adapter
operator|->
name|Scc
operator|+=
name|E1000_READ_REG
argument_list|(
name|Scc
argument_list|)
expr_stmt|;
name|Adapter
operator|->
name|Ecol
operator|+=
name|E1000_READ_REG
argument_list|(
name|Ecol
argument_list|)
expr_stmt|;
name|Adapter
operator|->
name|Mcc
operator|+=
name|E1000_READ_REG
argument_list|(
name|Mcc
argument_list|)
expr_stmt|;
name|Adapter
operator|->
name|Latecol
operator|+=
name|E1000_READ_REG
argument_list|(
name|Latecol
argument_list|)
expr_stmt|;
name|Adapter
operator|->
name|Colc
operator|+=
name|E1000_READ_REG
argument_list|(
name|Colc
argument_list|)
expr_stmt|;
name|Adapter
operator|->
name|Dc
operator|+=
name|E1000_READ_REG
argument_list|(
name|Dc
argument_list|)
expr_stmt|;
name|Adapter
operator|->
name|Sec
operator|+=
name|E1000_READ_REG
argument_list|(
name|Sec
argument_list|)
expr_stmt|;
name|Adapter
operator|->
name|Rlec
operator|+=
name|E1000_READ_REG
argument_list|(
name|Rlec
argument_list|)
expr_stmt|;
name|Adapter
operator|->
name|Xonrxc
operator|+=
name|E1000_READ_REG
argument_list|(
name|Xonrxc
argument_list|)
expr_stmt|;
name|Adapter
operator|->
name|Xontxc
operator|+=
name|E1000_READ_REG
argument_list|(
name|Xontxc
argument_list|)
expr_stmt|;
name|Adapter
operator|->
name|Xoffrxc
operator|+=
name|E1000_READ_REG
argument_list|(
name|Xoffrxc
argument_list|)
expr_stmt|;
name|Adapter
operator|->
name|Xofftxc
operator|+=
name|E1000_READ_REG
argument_list|(
name|Xofftxc
argument_list|)
expr_stmt|;
name|Adapter
operator|->
name|Fcruc
operator|+=
name|E1000_READ_REG
argument_list|(
name|Fcruc
argument_list|)
expr_stmt|;
name|Adapter
operator|->
name|Prc64
operator|+=
name|E1000_READ_REG
argument_list|(
name|Prc64
argument_list|)
expr_stmt|;
name|Adapter
operator|->
name|Prc127
operator|+=
name|E1000_READ_REG
argument_list|(
name|Prc127
argument_list|)
expr_stmt|;
name|Adapter
operator|->
name|Prc255
operator|+=
name|E1000_READ_REG
argument_list|(
name|Prc255
argument_list|)
expr_stmt|;
name|Adapter
operator|->
name|Prc511
operator|+=
name|E1000_READ_REG
argument_list|(
name|Prc511
argument_list|)
expr_stmt|;
name|Adapter
operator|->
name|Prc1023
operator|+=
name|E1000_READ_REG
argument_list|(
name|Prc1023
argument_list|)
expr_stmt|;
name|Adapter
operator|->
name|Prc1522
operator|+=
name|E1000_READ_REG
argument_list|(
name|Prc1522
argument_list|)
expr_stmt|;
name|Adapter
operator|->
name|Gprc
operator|+=
name|E1000_READ_REG
argument_list|(
name|Gprc
argument_list|)
expr_stmt|;
name|Adapter
operator|->
name|Bprc
operator|+=
name|E1000_READ_REG
argument_list|(
name|Bprc
argument_list|)
expr_stmt|;
name|Adapter
operator|->
name|Mprc
operator|+=
name|E1000_READ_REG
argument_list|(
name|Mprc
argument_list|)
expr_stmt|;
name|Adapter
operator|->
name|Gptc
operator|+=
name|E1000_READ_REG
argument_list|(
name|Gptc
argument_list|)
expr_stmt|;
comment|/* For the 64-bit byte counters the low dword must be read first. */
comment|/* Both registers clear on the read of the high dword */
name|Adapter
operator|->
name|Gorcl
operator|+=
name|E1000_READ_REG
argument_list|(
name|Gorl
argument_list|)
expr_stmt|;
name|Adapter
operator|->
name|Gorch
operator|+=
name|E1000_READ_REG
argument_list|(
name|Gorh
argument_list|)
expr_stmt|;
name|Adapter
operator|->
name|Gotcl
operator|+=
name|E1000_READ_REG
argument_list|(
name|Gotl
argument_list|)
expr_stmt|;
name|Adapter
operator|->
name|Gotch
operator|+=
name|E1000_READ_REG
argument_list|(
name|Goth
argument_list|)
expr_stmt|;
name|Adapter
operator|->
name|Rnbc
operator|+=
name|E1000_READ_REG
argument_list|(
name|Rnbc
argument_list|)
expr_stmt|;
name|Adapter
operator|->
name|Ruc
operator|+=
name|E1000_READ_REG
argument_list|(
name|Ruc
argument_list|)
expr_stmt|;
name|Adapter
operator|->
name|Rfc
operator|+=
name|E1000_READ_REG
argument_list|(
name|Rfc
argument_list|)
expr_stmt|;
name|Adapter
operator|->
name|Roc
operator|+=
name|E1000_READ_REG
argument_list|(
name|Roc
argument_list|)
expr_stmt|;
name|Adapter
operator|->
name|Rjc
operator|+=
name|E1000_READ_REG
argument_list|(
name|Rjc
argument_list|)
expr_stmt|;
name|Adapter
operator|->
name|Torcl
operator|+=
name|E1000_READ_REG
argument_list|(
name|Torl
argument_list|)
expr_stmt|;
name|Adapter
operator|->
name|Torch
operator|+=
name|E1000_READ_REG
argument_list|(
name|Torh
argument_list|)
expr_stmt|;
name|Adapter
operator|->
name|Totcl
operator|+=
name|E1000_READ_REG
argument_list|(
name|Totl
argument_list|)
expr_stmt|;
name|Adapter
operator|->
name|Totch
operator|+=
name|E1000_READ_REG
argument_list|(
name|Toth
argument_list|)
expr_stmt|;
name|Adapter
operator|->
name|Tpr
operator|+=
name|E1000_READ_REG
argument_list|(
name|Tpr
argument_list|)
expr_stmt|;
name|Adapter
operator|->
name|Tpt
operator|+=
name|E1000_READ_REG
argument_list|(
name|Tpt
argument_list|)
expr_stmt|;
name|Adapter
operator|->
name|Ptc64
operator|+=
name|E1000_READ_REG
argument_list|(
name|Ptc64
argument_list|)
expr_stmt|;
name|Adapter
operator|->
name|Ptc127
operator|+=
name|E1000_READ_REG
argument_list|(
name|Ptc127
argument_list|)
expr_stmt|;
name|Adapter
operator|->
name|Ptc255
operator|+=
name|E1000_READ_REG
argument_list|(
name|Ptc255
argument_list|)
expr_stmt|;
name|Adapter
operator|->
name|Ptc511
operator|+=
name|E1000_READ_REG
argument_list|(
name|Ptc511
argument_list|)
expr_stmt|;
name|Adapter
operator|->
name|Ptc1023
operator|+=
name|E1000_READ_REG
argument_list|(
name|Ptc1023
argument_list|)
expr_stmt|;
name|Adapter
operator|->
name|Ptc1522
operator|+=
name|E1000_READ_REG
argument_list|(
name|Ptc1522
argument_list|)
expr_stmt|;
name|Adapter
operator|->
name|Mptc
operator|+=
name|E1000_READ_REG
argument_list|(
name|Mptc
argument_list|)
expr_stmt|;
name|Adapter
operator|->
name|Bptc
operator|+=
name|E1000_READ_REG
argument_list|(
name|Bptc
argument_list|)
expr_stmt|;
if|if
condition|(
name|Adapter
operator|->
name|MacType
operator|>=
name|MAC_LIVENGOOD
condition|)
block|{
name|Adapter
operator|->
name|Algnerrc
operator|+=
name|E1000_READ_REG
argument_list|(
name|Algnerrc
argument_list|)
expr_stmt|;
name|Adapter
operator|->
name|Rxerrc
operator|+=
name|E1000_READ_REG
argument_list|(
name|Rxerrc
argument_list|)
expr_stmt|;
name|Adapter
operator|->
name|Tuc
operator|+=
name|E1000_READ_REG
argument_list|(
name|Tuc
argument_list|)
expr_stmt|;
name|Adapter
operator|->
name|Tncrs
operator|+=
name|E1000_READ_REG
argument_list|(
name|Tncrs
argument_list|)
expr_stmt|;
name|Adapter
operator|->
name|Cexterr
operator|+=
name|E1000_READ_REG
argument_list|(
name|Cexterr
argument_list|)
expr_stmt|;
name|Adapter
operator|->
name|Rutec
operator|+=
name|E1000_READ_REG
argument_list|(
name|Rutec
argument_list|)
expr_stmt|;
block|}
name|ifp
operator|=
operator|&
name|Adapter
operator|->
name|interface_data
operator|.
name|ac_if
expr_stmt|;
comment|/* Fill out the OS statistics structure */
name|ifp
operator|->
name|if_ipackets
operator|=
name|Adapter
operator|->
name|Gprc
expr_stmt|;
name|ifp
operator|->
name|if_opackets
operator|=
name|Adapter
operator|->
name|Gptc
expr_stmt|;
name|ifp
operator|->
name|if_ibytes
operator|=
name|Adapter
operator|->
name|Gorcl
expr_stmt|;
name|ifp
operator|->
name|if_obytes
operator|=
name|Adapter
operator|->
name|Gotcl
expr_stmt|;
name|ifp
operator|->
name|if_imcasts
operator|=
name|Adapter
operator|->
name|Mprc
expr_stmt|;
name|ifp
operator|->
name|if_collisions
operator|=
name|Adapter
operator|->
name|Colc
expr_stmt|;
comment|/* Rx Errors */
name|ifp
operator|->
name|if_ierrors
operator|=
name|Adapter
operator|->
name|DroppedPackets
operator|+
name|Adapter
operator|->
name|Rxerrc
operator|+
name|Adapter
operator|->
name|Crcerrs
operator|+
name|Adapter
operator|->
name|Algnerrc
operator|+
name|Adapter
operator|->
name|Rlec
operator|+
name|Adapter
operator|->
name|Rnbc
operator|+
name|Adapter
operator|->
name|Mpc
operator|+
name|Adapter
operator|->
name|Cexterr
expr_stmt|;
comment|/* Tx Errors */
name|ifp
operator|->
name|if_oerrors
operator|=
name|Adapter
operator|->
name|Ecol
operator|+
name|Adapter
operator|->
name|Tuc
operator|+
name|Adapter
operator|->
name|Latecol
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************  *  *  This routine is called only when em_display_debug_stats is enabled.  *  This routine provides a way to take a look at important statistics  *  maintained by the driver and hardware.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|em_print_hw_stats
parameter_list|(
name|struct
name|adapter
modifier|*
name|Adapter
parameter_list|)
block|{
name|int
name|unit
init|=
name|Adapter
operator|->
name|unit
decl_stmt|;
ifdef|#
directive|ifdef
name|DBG_STATS
name|printf
argument_list|(
literal|"em%d: Tx Descriptors not Avail = %ld\n"
argument_list|,
name|unit
argument_list|,
name|Adapter
operator|->
name|NoTxDescAvail
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"em%d: Packets not Avail = %ld\n"
argument_list|,
name|unit
argument_list|,
name|Adapter
operator|->
name|NoPacketsAvail
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"em%d: CleanTxInterrupts = %ld\n"
argument_list|,
name|unit
argument_list|,
name|Adapter
operator|->
name|CleanTxInterrupts
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"em%d: Tx Buffer not avail1 = %ld\n"
argument_list|,
name|unit
argument_list|,
name|Adapter
operator|->
name|NoTxBufferAvail1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"em%d: Tx Buffer not avail2 = %ld\n"
argument_list|,
name|unit
argument_list|,
name|Adapter
operator|->
name|NoTxBufferAvail2
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|printf
argument_list|(
literal|"em%d: No Jumbo Buffer Avail = %ld\n"
argument_list|,
name|unit
argument_list|,
name|Adapter
operator|->
name|NoJumboBufAvail
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"em%d: Jumbo Mbuf Failed = %ld\n"
argument_list|,
name|unit
argument_list|,
name|Adapter
operator|->
name|JumboMbufFailed
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"em%d: Jumbo Cluster Failed = %ld\n"
argument_list|,
name|unit
argument_list|,
name|Adapter
operator|->
name|JumboClusterFailed
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"em%d: Std Mbuf Failed = %ld\n"
argument_list|,
name|unit
argument_list|,
name|Adapter
operator|->
name|StdMbufFailed
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"em%d: Std Cluster Failed = %ld\n"
argument_list|,
name|unit
argument_list|,
name|Adapter
operator|->
name|StdClusterFailed
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"em%d: Symbol errors = %ld\n"
argument_list|,
name|unit
argument_list|,
name|Adapter
operator|->
name|Symerrs
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"em%d: Sequence errors = %ld\n"
argument_list|,
name|unit
argument_list|,
name|Adapter
operator|->
name|Sec
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"em%d: Defer count = %ld\n"
argument_list|,
name|unit
argument_list|,
name|Adapter
operator|->
name|Dc
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"em%d: Missed Packets = %ld\n"
argument_list|,
name|unit
argument_list|,
name|Adapter
operator|->
name|Mpc
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"em%d: Receive No Buffers = %ld\n"
argument_list|,
name|unit
argument_list|,
name|Adapter
operator|->
name|Rnbc
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"em%d: Receive length errors = %ld\n"
argument_list|,
name|unit
argument_list|,
name|Adapter
operator|->
name|Rlec
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"em%d: Receive errors = %ld\n"
argument_list|,
name|unit
argument_list|,
name|Adapter
operator|->
name|Rxerrc
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"em%d: Crc errors = %ld\n"
argument_list|,
name|unit
argument_list|,
name|Adapter
operator|->
name|Crcerrs
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"em%d: Alignment errors = %ld\n"
argument_list|,
name|unit
argument_list|,
name|Adapter
operator|->
name|Algnerrc
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"em%d: Carrier extension errors = %ld\n"
argument_list|,
name|unit
argument_list|,
name|Adapter
operator|->
name|Cexterr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"em%d: Driver dropped packets = %ld\n"
argument_list|,
name|unit
argument_list|,
name|Adapter
operator|->
name|DroppedPackets
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"em%d: XON Rcvd = %ld\n"
argument_list|,
name|unit
argument_list|,
name|Adapter
operator|->
name|Xonrxc
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"em%d: XON Xmtd = %ld\n"
argument_list|,
name|unit
argument_list|,
name|Adapter
operator|->
name|Xontxc
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"em%d: XOFF Rcvd = %ld\n"
argument_list|,
name|unit
argument_list|,
name|Adapter
operator|->
name|Xoffrxc
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"em%d: XOFF Xmtd = %ld\n"
argument_list|,
name|unit
argument_list|,
name|Adapter
operator|->
name|Xofftxc
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"em%d: Good Packets Rcvd = %ld\n"
argument_list|,
name|unit
argument_list|,
name|Adapter
operator|->
name|Gprc
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"em%d: Good Packets Xmtd = %ld\n"
argument_list|,
name|unit
argument_list|,
name|Adapter
operator|->
name|Gptc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************  *  *  Examine each tx_buffer in the used queue. If the hardware is done  *  processing the packet then free associated resources. The  *  tx_buffer is put back on the free queue.   *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|em_clean_transmit_interrupts
parameter_list|(
name|struct
name|adapter
modifier|*
name|Adapter
parameter_list|)
block|{
name|struct
name|em_tx_buffer
modifier|*
name|tx_buffer
decl_stmt|;
specifier|volatile
name|PE1000_TRANSMIT_DESCRIPTOR
name|TransmitDescriptor
decl_stmt|;
name|int
name|s
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|DBG_STATS
name|Adapter
operator|->
name|CleanTxInterrupts
operator|++
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|tx_buffer
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|Adapter
operator|->
name|UsedSwTxPacketList
argument_list|)
init|;
name|tx_buffer
condition|;
name|tx_buffer
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|Adapter
operator|->
name|UsedSwTxPacketList
argument_list|)
control|)
block|{
comment|/*         * Get hold of the next descriptor that the em will report status        * back to (this will be the last descriptor of a given tx_buffer). We        * only want to free the tx_buffer (and it resources) if the driver is        * done with ALL of the descriptors.  If the driver is done with the        * last one then it is done with all of them.        */
name|TransmitDescriptor
operator|=
name|Adapter
operator|->
name|OldestUsedTxDescriptor
operator|+
operator|(
name|tx_buffer
operator|->
name|NumTxDescriptorsUsed
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* Check for wrap case */
if|if
condition|(
name|TransmitDescriptor
operator|>
name|Adapter
operator|->
name|LastTxDescriptor
condition|)
name|TransmitDescriptor
operator|-=
name|Adapter
operator|->
name|NumTxDescriptors
expr_stmt|;
comment|/*         * If the descriptor done bit is set free tx_buffer and associated        * resources        */
if|if
condition|(
name|TransmitDescriptor
operator|->
name|Upper
operator|.
name|Fields
operator|.
name|TransmitStatus
operator|&
name|E1000_TXD_STAT_DD
condition|)
block|{
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|Adapter
operator|->
name|UsedSwTxPacketList
argument_list|,
name|em_tx_entry
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|TransmitDescriptor
operator|==
name|Adapter
operator|->
name|LastTxDescriptor
operator|)
condition|)
name|Adapter
operator|->
name|OldestUsedTxDescriptor
operator|=
name|Adapter
operator|->
name|FirstTxDescriptor
expr_stmt|;
else|else
name|Adapter
operator|->
name|OldestUsedTxDescriptor
operator|=
operator|(
name|TransmitDescriptor
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* Make available the descriptors that were previously used */
name|Adapter
operator|->
name|NumTxDescriptorsAvail
operator|+=
name|tx_buffer
operator|->
name|NumTxDescriptorsUsed
expr_stmt|;
name|tx_buffer
operator|->
name|NumTxDescriptorsUsed
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tx_buffer
operator|->
name|Packet
condition|)
block|{
name|m_freem
argument_list|(
name|tx_buffer
operator|->
name|Packet
argument_list|)
expr_stmt|;
name|tx_buffer
operator|->
name|Packet
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Return this "Software packet" back to the "free" list */
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|Adapter
operator|->
name|FreeSwTxPacketList
argument_list|,
name|tx_buffer
argument_list|,
name|em_tx_entry
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*            * Found a tx_buffer that the em is not done with then there is           * no reason to check the rest of the queue.           */
break|break;
block|}
block|}
comment|/* end for each tx_buffer */
name|ifp
operator|=
operator|&
name|Adapter
operator|->
name|interface_data
operator|.
name|ac_if
expr_stmt|;
comment|/* Tell the stack that it is OK to send packets */
if|if
condition|(
name|Adapter
operator|->
name|NumTxDescriptorsAvail
operator|>
name|TX_CLEANUP_THRESHOLD
condition|)
block|{
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

end_unit

