begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*******************************************************************************    Copyright (c) 2001-2007, Intel Corporation    All rights reserved.      Redistribution and use in source and binary forms, with or without    modification, are permitted provided that the following conditions are met:       1. Redistributions of source code must retain the above copyright notice,        this list of conditions and the following disclaimer.       2. Redistributions in binary form must reproduce the above copyright        notice, this list of conditions and the following disclaimer in the        documentation and/or other materials provided with the distribution.       3. Neither the name of the Intel Corporation nor the names of its        contributors may be used to endorse or promote products derived from        this software without specific prior written permission.      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE    ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR    CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF    SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN    CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)    ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE   POSSIBILITY OF SUCH DAMAGE.  *******************************************************************************/
end_comment

begin_function_decl
name|$FreeBSD$
comment|/* e1000_82543  * e1000_82544  */
include|#
directive|include
file|"e1000_82543.h"
name|void
name|e1000_init_function_pointers_82543
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|s32
name|e1000_init_phy_params_82543
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|s32
name|e1000_init_nvm_params_82543
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|s32
name|e1000_init_mac_params_82543
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|s32
name|e1000_read_phy_reg_82543
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|s32
name|e1000_write_phy_reg_82543
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u16
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|s32
name|e1000_phy_force_speed_duplex_82543
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|s32
name|e1000_phy_hw_reset_82543
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|s32
name|e1000_reset_hw_82543
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|s32
name|e1000_init_hw_82543
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|s32
name|e1000_setup_link_82543
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|s32
name|e1000_setup_copper_link_82543
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|s32
name|e1000_setup_fiber_link_82543
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|s32
name|e1000_check_for_copper_link_82543
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|s32
name|e1000_check_for_fiber_link_82543
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|s32
name|e1000_led_on_82543
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|s32
name|e1000_led_off_82543
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|void
name|e1000_write_vfta_82543
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u32
name|value
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|void
name|e1000_mta_set_82543
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|hash_value
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|void
name|e1000_clear_hw_cntrs_82543
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_config_mac_to_phy_82543
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|boolean_t
name|e1000_init_phy_disabled_82543
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|e1000_lower_mdi_clk_82543
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
modifier|*
name|ctrl
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_polarity_reversal_workaround_82543
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|e1000_raise_mdi_clk_82543
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
modifier|*
name|ctrl
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u16
name|e1000_shift_in_mdi_bits_82543
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|e1000_shift_out_mdi_bits_82543
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|data
parameter_list|,
name|u16
name|count
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|boolean_t
name|e1000_tbi_compatibility_enabled_82543
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|e1000_set_tbi_sbp_82543
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|boolean_t
name|state
parameter_list|)
function_decl|;
end_function_decl

begin_struct
struct|struct
name|e1000_dev_spec_82543
block|{
name|u32
name|tbi_compatibility
decl_stmt|;
name|boolean_t
name|dma_fairness
decl_stmt|;
name|boolean_t
name|init_phy_disabled
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/**  *  e1000_init_phy_params_82543 - Init PHY func ptrs.  *  @hw - pointer to the HW structure  *  *  This is a function pointer entry point called by the api module.  **/
end_comment

begin_function
name|STATIC
name|s32
name|e1000_init_phy_params_82543
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|struct
name|e1000_functions
modifier|*
name|func
init|=
operator|&
name|hw
operator|->
name|func
decl_stmt|;
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_init_phy_params_82543"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|media_type
operator|!=
name|e1000_media_type_copper
condition|)
block|{
name|phy
operator|->
name|type
operator|=
name|e1000_phy_none
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|phy
operator|->
name|addr
operator|=
literal|1
expr_stmt|;
name|phy
operator|->
name|autoneg_mask
operator|=
name|AUTONEG_ADVERTISE_SPEED_DEFAULT
expr_stmt|;
name|phy
operator|->
name|reset_delay_us
operator|=
literal|10000
expr_stmt|;
name|phy
operator|->
name|type
operator|=
name|e1000_phy_m88
expr_stmt|;
comment|/* Function Pointers */
name|func
operator|->
name|check_polarity
operator|=
name|e1000_check_polarity_m88
expr_stmt|;
name|func
operator|->
name|commit_phy
operator|=
name|e1000_phy_sw_reset_generic
expr_stmt|;
name|func
operator|->
name|force_speed_duplex
operator|=
name|e1000_phy_force_speed_duplex_82543
expr_stmt|;
name|func
operator|->
name|get_cable_length
operator|=
name|e1000_get_cable_length_m88
expr_stmt|;
name|func
operator|->
name|get_cfg_done
operator|=
name|e1000_get_cfg_done_generic
expr_stmt|;
name|func
operator|->
name|read_phy_reg
operator|=
operator|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_82543
operator|)
condition|?
name|e1000_read_phy_reg_82543
else|:
name|e1000_read_phy_reg_m88
expr_stmt|;
name|func
operator|->
name|reset_phy
operator|=
operator|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_82543
operator|)
condition|?
name|e1000_phy_hw_reset_82543
else|:
name|e1000_phy_hw_reset_generic
expr_stmt|;
name|func
operator|->
name|write_phy_reg
operator|=
operator|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_82543
operator|)
condition|?
name|e1000_write_phy_reg_82543
else|:
name|e1000_write_phy_reg_m88
expr_stmt|;
name|func
operator|->
name|get_phy_info
operator|=
name|e1000_get_phy_info_m88
expr_stmt|;
comment|/* The external PHY of the 82543 can be in a funky state. 	 * Resetting helps us read the PHY registers for acquiring 	 * the PHY ID. 	 */
if|if
condition|(
operator|!
name|e1000_init_phy_disabled_82543
argument_list|(
name|hw
argument_list|)
condition|)
block|{
name|ret_val
operator|=
name|e1000_phy_hw_reset
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Resetting PHY during init failed.\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|msec_delay
argument_list|(
literal|20
argument_list|)
expr_stmt|;
block|}
name|ret_val
operator|=
name|e1000_get_phy_id
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
comment|/* Verify phy id */
switch|switch
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
condition|)
block|{
case|case
name|e1000_82543
case|:
if|if
condition|(
name|phy
operator|->
name|id
operator|!=
name|M88E1000_E_PHY_ID
condition|)
block|{
name|ret_val
operator|=
operator|-
name|E1000_ERR_PHY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
break|break;
case|case
name|e1000_82544
case|:
if|if
condition|(
name|phy
operator|->
name|id
operator|!=
name|M88E1000_I_PHY_ID
condition|)
block|{
name|ret_val
operator|=
operator|-
name|E1000_ERR_PHY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
break|break;
default|default:
name|ret_val
operator|=
operator|-
name|E1000_ERR_PHY
expr_stmt|;
goto|goto
name|out
goto|;
break|break;
block|}
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_init_nvm_params_82543 - Init NVM func ptrs.  *  @hw - pointer to the HW structure  *  *  This is a function pointer entry point called by the api module.  **/
end_comment

begin_function
name|STATIC
name|s32
name|e1000_init_nvm_params_82543
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_nvm_info
modifier|*
name|nvm
init|=
operator|&
name|hw
operator|->
name|nvm
decl_stmt|;
name|struct
name|e1000_functions
modifier|*
name|func
init|=
operator|&
name|hw
operator|->
name|func
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_init_nvm_params_82543"
argument_list|)
expr_stmt|;
name|nvm
operator|->
name|type
operator|=
name|e1000_nvm_eeprom_microwire
expr_stmt|;
name|nvm
operator|->
name|word_size
operator|=
literal|64
expr_stmt|;
name|nvm
operator|->
name|delay_usec
operator|=
literal|50
expr_stmt|;
name|nvm
operator|->
name|address_bits
operator|=
literal|6
expr_stmt|;
name|nvm
operator|->
name|opcode_bits
operator|=
literal|3
expr_stmt|;
comment|/* Function Pointers */
name|func
operator|->
name|read_nvm
operator|=
name|e1000_read_nvm_microwire
expr_stmt|;
name|func
operator|->
name|update_nvm
operator|=
name|e1000_update_nvm_checksum_generic
expr_stmt|;
name|func
operator|->
name|valid_led_default
operator|=
name|e1000_valid_led_default_generic
expr_stmt|;
name|func
operator|->
name|validate_nvm
operator|=
name|e1000_validate_nvm_checksum_generic
expr_stmt|;
name|func
operator|->
name|write_nvm
operator|=
name|e1000_write_nvm_microwire
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_init_mac_params_82543 - Init MAC func ptrs.  *  @hw - pointer to the HW structure  *  *  This is a function pointer entry point called by the api module.  **/
end_comment

begin_function
name|STATIC
name|s32
name|e1000_init_mac_params_82543
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_mac_info
modifier|*
name|mac
init|=
operator|&
name|hw
operator|->
name|mac
decl_stmt|;
name|struct
name|e1000_functions
modifier|*
name|func
init|=
operator|&
name|hw
operator|->
name|func
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_init_mac_params_82543"
argument_list|)
expr_stmt|;
comment|/* Set media type */
switch|switch
condition|(
name|hw
operator|->
name|device_id
condition|)
block|{
case|case
name|E1000_DEV_ID_82543GC_FIBER
case|:
case|case
name|E1000_DEV_ID_82544EI_FIBER
case|:
name|hw
operator|->
name|media_type
operator|=
name|e1000_media_type_fiber
expr_stmt|;
break|break;
default|default:
name|hw
operator|->
name|media_type
operator|=
name|e1000_media_type_copper
expr_stmt|;
break|break;
block|}
comment|/* Set mta register count */
name|mac
operator|->
name|mta_reg_count
operator|=
literal|128
expr_stmt|;
comment|/* Set rar entry count */
name|mac
operator|->
name|rar_entry_count
operator|=
name|E1000_RAR_ENTRIES
expr_stmt|;
comment|/* Function pointers */
comment|/* bus type/speed/width */
name|func
operator|->
name|get_bus_info
operator|=
name|e1000_get_bus_info_pci_generic
expr_stmt|;
comment|/* reset */
name|func
operator|->
name|reset_hw
operator|=
name|e1000_reset_hw_82543
expr_stmt|;
comment|/* hw initialization */
name|func
operator|->
name|init_hw
operator|=
name|e1000_init_hw_82543
expr_stmt|;
comment|/* link setup */
name|func
operator|->
name|setup_link
operator|=
name|e1000_setup_link_82543
expr_stmt|;
comment|/* physical interface setup */
name|func
operator|->
name|setup_physical_interface
operator|=
operator|(
name|hw
operator|->
name|media_type
operator|==
name|e1000_media_type_copper
operator|)
condition|?
name|e1000_setup_copper_link_82543
else|:
name|e1000_setup_fiber_link_82543
expr_stmt|;
comment|/* check for link */
name|func
operator|->
name|check_for_link
operator|=
operator|(
name|hw
operator|->
name|media_type
operator|==
name|e1000_media_type_copper
operator|)
condition|?
name|e1000_check_for_copper_link_82543
else|:
name|e1000_check_for_fiber_link_82543
expr_stmt|;
comment|/* link info */
name|func
operator|->
name|get_link_up_info
operator|=
operator|(
name|hw
operator|->
name|media_type
operator|==
name|e1000_media_type_copper
operator|)
condition|?
name|e1000_get_speed_and_duplex_copper_generic
else|:
name|e1000_get_speed_and_duplex_fiber_serdes_generic
expr_stmt|;
comment|/* multicast address update */
name|func
operator|->
name|mc_addr_list_update
operator|=
name|e1000_mc_addr_list_update_generic
expr_stmt|;
comment|/* writing VFTA */
name|func
operator|->
name|write_vfta
operator|=
name|e1000_write_vfta_82543
expr_stmt|;
comment|/* clearing VFTA */
name|func
operator|->
name|clear_vfta
operator|=
name|e1000_clear_vfta_generic
expr_stmt|;
comment|/* setting MTA */
name|func
operator|->
name|mta_set
operator|=
name|e1000_mta_set_82543
expr_stmt|;
comment|/* turn on/off LED */
name|func
operator|->
name|led_on
operator|=
name|e1000_led_on_82543
expr_stmt|;
name|func
operator|->
name|led_off
operator|=
name|e1000_led_off_82543
expr_stmt|;
comment|/* remove device */
name|func
operator|->
name|remove_device
operator|=
name|e1000_remove_device_generic
expr_stmt|;
comment|/* clear hardware counters */
name|func
operator|->
name|clear_hw_cntrs
operator|=
name|e1000_clear_hw_cntrs_82543
expr_stmt|;
name|hw
operator|->
name|dev_spec_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|e1000_dev_spec_82543
argument_list|)
expr_stmt|;
comment|/* Device-specific structure allocation */
name|ret_val
operator|=
name|e1000_alloc_zeroed_dev_spec_struct
argument_list|(
name|hw
argument_list|,
name|hw
operator|->
name|dev_spec_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
comment|/* Set tbi compatibility */
if|if
condition|(
operator|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|!=
name|e1000_82543
operator|)
operator|||
operator|(
name|hw
operator|->
name|media_type
operator|==
name|e1000_media_type_fiber
operator|)
condition|)
name|e1000_set_tbi_compatibility_82543
argument_list|(
name|hw
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_init_function_pointers_82543 - Init func ptrs.  *  @hw - pointer to the HW structure  *  *  The only function explicitly called by the api module to initialize  *  all function pointers and parameters.  **/
end_comment

begin_function
name|void
name|e1000_init_function_pointers_82543
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"e1000_init_function_pointers_82543"
argument_list|)
expr_stmt|;
name|hw
operator|->
name|func
operator|.
name|init_mac_params
operator|=
name|e1000_init_mac_params_82543
expr_stmt|;
name|hw
operator|->
name|func
operator|.
name|init_nvm_params
operator|=
name|e1000_init_nvm_params_82543
expr_stmt|;
name|hw
operator|->
name|func
operator|.
name|init_phy_params
operator|=
name|e1000_init_phy_params_82543
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  e1000_tbi_compatibility_enabled_82543 - Returns TBI compat status  *  @hw - pointer to the HW structure  *  *  Returns the curent status of 10-bit Interface (TBI) compatibility  *  (enabled/disabled).  **/
end_comment

begin_function
specifier|static
name|boolean_t
name|e1000_tbi_compatibility_enabled_82543
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_dev_spec_82543
modifier|*
name|dev_spec
decl_stmt|;
name|boolean_t
name|state
init|=
name|FALSE
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_tbi_compatibility_enabled_82543"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|!=
name|e1000_82543
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"TBI compatibility workaround for 82543 only.\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|dev_spec
operator|=
operator|(
expr|struct
name|e1000_dev_spec_82543
operator|*
operator|)
name|hw
operator|->
name|dev_spec
expr_stmt|;
if|if
condition|(
name|dev_spec
operator|==
name|NULL
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"dev_spec pointer is set to NULL.\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|state
operator|=
operator|(
name|dev_spec
operator|->
name|tbi_compatibility
operator|&
name|TBI_COMPAT_ENABLED
operator|)
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
name|out
label|:
return|return
name|state
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_set_tbi_compatibility_82543 - Set TBI compatibility  *  @hw - pointer to the HW structure  *  @state - enable/disable TBI compatibility  *  *  Enables or disabled 10-bit Interface (TBI) compatibility.  **/
end_comment

begin_function
name|void
name|e1000_set_tbi_compatibility_82543
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|boolean_t
name|state
parameter_list|)
block|{
name|struct
name|e1000_dev_spec_82543
modifier|*
name|dev_spec
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_set_tbi_compatibility_82543"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|!=
name|e1000_82543
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"TBI compatibility workaround for 82543 only.\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|dev_spec
operator|=
operator|(
expr|struct
name|e1000_dev_spec_82543
operator|*
operator|)
name|hw
operator|->
name|dev_spec
expr_stmt|;
if|if
condition|(
name|dev_spec
operator|==
name|NULL
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"dev_spec pointer is set to NULL.\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|state
condition|)
name|dev_spec
operator|->
name|tbi_compatibility
operator||=
name|TBI_COMPAT_ENABLED
expr_stmt|;
else|else
name|dev_spec
operator|->
name|tbi_compatibility
operator|&=
operator|~
name|TBI_COMPAT_ENABLED
expr_stmt|;
name|out
label|:
return|return;
block|}
end_function

begin_comment
comment|/**  *  e1000_tbi_sbp_enabled_82543 - Returns TBI SBP status  *  @hw - pointer to the HW structure  *  *  Returns the curent status of 10-bit Interface (TBI) store bad packet (SBP)  *  (enabled/disabled).  **/
end_comment

begin_function
name|boolean_t
name|e1000_tbi_sbp_enabled_82543
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_dev_spec_82543
modifier|*
name|dev_spec
decl_stmt|;
name|boolean_t
name|state
init|=
name|FALSE
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_tbi_sbp_enabled_82543"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|!=
name|e1000_82543
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"TBI compatibility workaround for 82543 only.\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|dev_spec
operator|=
operator|(
expr|struct
name|e1000_dev_spec_82543
operator|*
operator|)
name|hw
operator|->
name|dev_spec
expr_stmt|;
if|if
condition|(
name|dev_spec
operator|==
name|NULL
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"dev_spec pointer is set to NULL.\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|state
operator|=
operator|(
name|dev_spec
operator|->
name|tbi_compatibility
operator|&
name|TBI_SBP_ENABLED
operator|)
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
name|out
label|:
return|return
name|state
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_set_tbi_sbp_82543 - Set TBI SBP  *  @hw - pointer to the HW structure  *  @state - enable/disable TBI store bad packet  *  *  Enables or disabled 10-bit Interface (TBI) store bad packet (SBP).  **/
end_comment

begin_function
specifier|static
name|void
name|e1000_set_tbi_sbp_82543
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|boolean_t
name|state
parameter_list|)
block|{
name|struct
name|e1000_dev_spec_82543
modifier|*
name|dev_spec
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_set_tbi_sbp_82543"
argument_list|)
expr_stmt|;
name|dev_spec
operator|=
operator|(
expr|struct
name|e1000_dev_spec_82543
operator|*
operator|)
name|hw
operator|->
name|dev_spec
expr_stmt|;
if|if
condition|(
name|state
operator|&&
name|e1000_tbi_compatibility_enabled_82543
argument_list|(
name|hw
argument_list|)
condition|)
name|dev_spec
operator|->
name|tbi_compatibility
operator||=
name|TBI_SBP_ENABLED
expr_stmt|;
else|else
name|dev_spec
operator|->
name|tbi_compatibility
operator|&=
operator|~
name|TBI_SBP_ENABLED
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**  *  e1000_init_phy_disabled_82543 - Returns init PHY status  *  @hw - pointer to the HW structure  *  *  Returns the current status of whether PHY initialization is disabled.  *  True if PHY initialization is disabled else false.  **/
end_comment

begin_function
specifier|static
name|boolean_t
name|e1000_init_phy_disabled_82543
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_dev_spec_82543
modifier|*
name|dev_spec
decl_stmt|;
name|boolean_t
name|ret_val
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_init_phy_disabled_82543"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|!=
name|e1000_82543
condition|)
block|{
name|ret_val
operator|=
name|FALSE
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|dev_spec
operator|=
operator|(
expr|struct
name|e1000_dev_spec_82543
operator|*
operator|)
name|hw
operator|->
name|dev_spec
expr_stmt|;
if|if
condition|(
name|dev_spec
operator|==
name|NULL
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"dev_spec pointer is set to NULL.\n"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|FALSE
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ret_val
operator|=
name|dev_spec
operator|->
name|init_phy_disabled
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_tbi_adjust_stats_82543 - Adjust stats when TBI enabled  *  @hw - pointer to the HW structure  *  @stats - Struct containing statistic register values  *  @frame_len - The length of the frame in question  *  @mac_addr - The Ethernet destination address of the frame in question  *  *  Adjusts the statistic counters when a frame is accepted by TBI_ACCEPT  **/
end_comment

begin_function
name|void
name|e1000_tbi_adjust_stats_82543
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|struct
name|e1000_hw_stats
modifier|*
name|stats
parameter_list|,
name|u32
name|frame_len
parameter_list|,
name|u8
modifier|*
name|mac_addr
parameter_list|)
block|{
name|u64
name|carry_bit
decl_stmt|;
if|if
condition|(
name|e1000_tbi_sbp_enabled_82543
argument_list|(
name|hw
argument_list|)
operator|==
name|FALSE
condition|)
goto|goto
name|out
goto|;
comment|/* First adjust the frame length. */
name|frame_len
operator|--
expr_stmt|;
comment|/* We need to adjust the statistics counters, since the hardware 	 * counters overcount this packet as a CRC error and undercount 	 * the packet as a good packet 	 */
comment|/* This packet should not be counted as a CRC error.    */
name|stats
operator|->
name|crcerrs
operator|--
expr_stmt|;
comment|/* This packet does count as a Good Packet Received.    */
name|stats
operator|->
name|gprc
operator|++
expr_stmt|;
comment|/* Adjust the Good Octets received counters             */
name|carry_bit
operator|=
literal|0x80000000
operator|&
name|stats
operator|->
name|gorcl
expr_stmt|;
name|stats
operator|->
name|gorcl
operator|+=
name|frame_len
expr_stmt|;
comment|/* If the high bit of Gorcl (the low 32 bits of the Good Octets 	 * Received Count) was one before the addition, 	 * AND it is zero after, then we lost the carry out, 	 * need to add one to Gorch (Good Octets Received Count High). 	 * This could be simplified if all environments supported 	 * 64-bit integers. 	 */
if|if
condition|(
name|carry_bit
operator|&&
operator|(
operator|(
name|stats
operator|->
name|gorcl
operator|&
literal|0x80000000
operator|)
operator|==
literal|0
operator|)
condition|)
name|stats
operator|->
name|gorch
operator|++
expr_stmt|;
comment|/* Is this a broadcast or multicast?  Check broadcast first, 	 * since the test for a multicast frame will test positive on 	 * a broadcast frame. 	 */
if|if
condition|(
operator|(
name|mac_addr
index|[
literal|0
index|]
operator|==
literal|0xff
operator|)
operator|&&
operator|(
name|mac_addr
index|[
literal|1
index|]
operator|==
literal|0xff
operator|)
condition|)
comment|/* Broadcast packet */
name|stats
operator|->
name|bprc
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|mac_addr
operator|&
literal|0x01
condition|)
comment|/* Multicast packet */
name|stats
operator|->
name|mprc
operator|++
expr_stmt|;
comment|/* In this case, the hardware has overcounted the number of 	 * oversize frames. 	 */
if|if
condition|(
operator|(
name|frame_len
operator|==
name|hw
operator|->
name|mac
operator|.
name|max_frame_size
operator|)
operator|&&
operator|(
name|stats
operator|->
name|roc
operator|>
literal|0
operator|)
condition|)
name|stats
operator|->
name|roc
operator|--
expr_stmt|;
comment|/* Adjust the bin counters when the extra byte put the frame in the 	 * wrong bin. Remember that the frame_len was adjusted above. 	 */
if|if
condition|(
name|frame_len
operator|==
literal|64
condition|)
block|{
name|stats
operator|->
name|prc64
operator|++
expr_stmt|;
name|stats
operator|->
name|prc127
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|frame_len
operator|==
literal|127
condition|)
block|{
name|stats
operator|->
name|prc127
operator|++
expr_stmt|;
name|stats
operator|->
name|prc255
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|frame_len
operator|==
literal|255
condition|)
block|{
name|stats
operator|->
name|prc255
operator|++
expr_stmt|;
name|stats
operator|->
name|prc511
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|frame_len
operator|==
literal|511
condition|)
block|{
name|stats
operator|->
name|prc511
operator|++
expr_stmt|;
name|stats
operator|->
name|prc1023
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|frame_len
operator|==
literal|1023
condition|)
block|{
name|stats
operator|->
name|prc1023
operator|++
expr_stmt|;
name|stats
operator|->
name|prc1522
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|frame_len
operator|==
literal|1522
condition|)
block|{
name|stats
operator|->
name|prc1522
operator|++
expr_stmt|;
block|}
name|out
label|:
return|return;
block|}
end_function

begin_comment
comment|/**  *  e1000_read_phy_reg_82543 - Read PHY register  *  @hw - pointer to the HW structure  *  @offset - register offset to be read  *  @data - pointer to the read data  *  *  Reads the PHY at offset and stores the information read to data.  **/
end_comment

begin_function
name|STATIC
name|s32
name|e1000_read_phy_reg_82543
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
block|{
name|u32
name|mdic
decl_stmt|;
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_read_phy_reg_82543"
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|>
name|MAX_PHY_REG_ADDRESS
condition|)
block|{
name|DEBUGOUT1
argument_list|(
literal|"PHY Address %d is out of range\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|ret_val
operator|=
operator|-
name|E1000_ERR_PARAM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* We must first send a preamble through the MDIO pin to signal the 	 * beginning of an MII instruction.  This is done by sending 32 	 * consecutive "1" bits. 	 */
name|e1000_shift_out_mdi_bits_82543
argument_list|(
name|hw
argument_list|,
name|PHY_PREAMBLE
argument_list|,
name|PHY_PREAMBLE_SIZE
argument_list|)
expr_stmt|;
comment|/* Now combine the next few fields that are required for a read 	 * operation.  We use this method instead of calling the 	 * e1000_shift_out_mdi_bits routine five different times.  The format 	 * of an MII read instruction consists of a shift out of 14 bits and 	 * is defined as follows: 	 *<Preamble><SOF><Op Code><Phy Addr><Offset> 	 * followed by a shift in of 18 bits.  This first two bits shifted in 	 * are TurnAround bits used to avoid contention on the MDIO pin when a 	 * READ operation is performed.  These two bits are thrown away 	 * followed by a shift in of 16 bits which contains the desired data. 	 */
name|mdic
operator|=
operator|(
name|offset
operator||
operator|(
name|hw
operator|->
name|phy
operator|.
name|addr
operator|<<
literal|5
operator|)
operator||
operator|(
name|PHY_OP_READ
operator|<<
literal|10
operator|)
operator||
operator|(
name|PHY_SOF
operator|<<
literal|12
operator|)
operator|)
expr_stmt|;
name|e1000_shift_out_mdi_bits_82543
argument_list|(
name|hw
argument_list|,
name|mdic
argument_list|,
literal|14
argument_list|)
expr_stmt|;
comment|/* Now that we've shifted out the read command to the MII, we need to 	 * "shift in" the 16-bit value (18 total bits) of the requested PHY 	 * register address. 	 */
operator|*
name|data
operator|=
name|e1000_shift_in_mdi_bits_82543
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_write_phy_reg_82543 - Write PHY register  *  @hw - pointer to the HW structure  *  @offset - register offset to be written  *  @data - pointer to the data to be written at offset  *  *  Writes data to the PHY at offset.  **/
end_comment

begin_function
name|STATIC
name|s32
name|e1000_write_phy_reg_82543
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u16
name|data
parameter_list|)
block|{
name|u32
name|mdic
decl_stmt|;
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_write_phy_reg_82543"
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|>
name|MAX_PHY_REG_ADDRESS
condition|)
block|{
name|DEBUGOUT1
argument_list|(
literal|"PHY Address %d is out of range\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|ret_val
operator|=
operator|-
name|E1000_ERR_PARAM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* We'll need to use the SW defined pins to shift the write command 	 * out to the PHY. We first send a preamble to the PHY to signal the 	 * beginning of the MII instruction.  This is done by sending 32 	 * consecutive "1" bits. 	 */
name|e1000_shift_out_mdi_bits_82543
argument_list|(
name|hw
argument_list|,
name|PHY_PREAMBLE
argument_list|,
name|PHY_PREAMBLE_SIZE
argument_list|)
expr_stmt|;
comment|/* Now combine the remaining required fields that will indicate a 	 * write operation. We use this method instead of calling the 	 * e1000_shift_out_mdi_bits routine for each field in the command. The 	 * format of a MII write instruction is as follows: 	 *<Preamble><SOF><Op Code><Phy Addr><Reg Addr><Turnaround><Data>. 	 */
name|mdic
operator|=
operator|(
operator|(
name|PHY_TURNAROUND
operator|)
operator||
operator|(
name|offset
operator|<<
literal|2
operator|)
operator||
operator|(
name|hw
operator|->
name|phy
operator|.
name|addr
operator|<<
literal|7
operator|)
operator||
operator|(
name|PHY_OP_WRITE
operator|<<
literal|12
operator|)
operator||
operator|(
name|PHY_SOF
operator|<<
literal|14
operator|)
operator|)
expr_stmt|;
name|mdic
operator|<<=
literal|16
expr_stmt|;
name|mdic
operator||=
operator|(
name|u32
operator|)
name|data
expr_stmt|;
name|e1000_shift_out_mdi_bits_82543
argument_list|(
name|hw
argument_list|,
name|mdic
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_raise_mdi_clk_82543 - Raise Management Data Input clock  *  @hw - pointer to the HW structure  *  @ctrl - pointer to the control register  *  *  Raise the management data input clock by setting the MDC bit in the control  *  register.  **/
end_comment

begin_function
specifier|static
name|void
name|e1000_raise_mdi_clk_82543
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
modifier|*
name|ctrl
parameter_list|)
block|{
comment|/* Raise the clock input to the Management Data Clock (by setting the 	 * MDC bit), and then delay a sufficient amount of time. 	 */
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|,
operator|(
operator|*
name|ctrl
operator||
name|E1000_CTRL_MDC
operator|)
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  e1000_lower_mdi_clk_82543 - Lower Management Data Input clock  *  @hw - pointer to the HW structure  *  @ctrl - pointer to the control register  *  *  Lower the management data input clock by clearing the MDC bit in the control  *  register.  **/
end_comment

begin_function
specifier|static
name|void
name|e1000_lower_mdi_clk_82543
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
modifier|*
name|ctrl
parameter_list|)
block|{
comment|/* Lower the clock input to the Management Data Clock (by clearing the 	 * MDC bit), and then delay a sufficient amount of time. 	 */
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|,
operator|(
operator|*
name|ctrl
operator|&
operator|~
name|E1000_CTRL_MDC
operator|)
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  e1000_shift_out_mdi_bits_82543 - Shift data bits our to the PHY  *  @hw - pointer to the HW structure  *  @data - data to send to the PHY  *  @count - number of bits to shift out  *  *  We need to shift 'count' bits out to the PHY.  So, the value in the  *  "data" parameter will be shifted out to the PHY one bit at a time.  *  In order to do this, "data" must be broken down into bits.  **/
end_comment

begin_function
specifier|static
name|void
name|e1000_shift_out_mdi_bits_82543
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|data
parameter_list|,
name|u16
name|count
parameter_list|)
block|{
name|u32
name|ctrl
decl_stmt|,
name|mask
decl_stmt|;
comment|/* We need to shift "count" number of bits out to the PHY.  So, the 	 * value in the "data" parameter will be shifted out to the PHY one 	 * bit at a time.  In order to do this, "data" must be broken down 	 * into bits. 	 */
name|mask
operator|=
literal|0x01
expr_stmt|;
name|mask
operator|<<=
operator|(
name|count
operator|-
literal|1
operator|)
expr_stmt|;
name|ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|)
expr_stmt|;
comment|/* Set MDIO_DIR and MDC_DIR direction bits to be used as output pins. */
name|ctrl
operator||=
operator|(
name|E1000_CTRL_MDIO_DIR
operator||
name|E1000_CTRL_MDC_DIR
operator|)
expr_stmt|;
while|while
condition|(
name|mask
condition|)
block|{
comment|/* A "1" is shifted out to the PHY by setting the MDIO bit to 		 * "1" and then raising and lowering the Management Data Clock. 		 * A "0" is shifted out to the PHY by setting the MDIO bit to 		 * "0" and then raising and lowering the clock. 		 */
if|if
condition|(
name|data
operator|&
name|mask
condition|)
name|ctrl
operator||=
name|E1000_CTRL_MDIO
expr_stmt|;
else|else
name|ctrl
operator|&=
operator|~
name|E1000_CTRL_MDIO
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|e1000_raise_mdi_clk_82543
argument_list|(
name|hw
argument_list|,
operator|&
name|ctrl
argument_list|)
expr_stmt|;
name|e1000_lower_mdi_clk_82543
argument_list|(
name|hw
argument_list|,
operator|&
name|ctrl
argument_list|)
expr_stmt|;
name|mask
operator|>>=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  *  e1000_shift_in_mdi_bits_82543 - Shift data bits in from the PHY  *  @hw - pointer to the HW structure  *  *  In order to read a register from the PHY, we need to shift 18 bits  *  in from the PHY.  Bits are "shifted in" by raising the clock input to  *  the PHY (setting the MDC bit), and then reading the value of the data out  *  MDIO bit.  **/
end_comment

begin_function
specifier|static
name|u16
name|e1000_shift_in_mdi_bits_82543
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|ctrl
decl_stmt|;
name|u16
name|data
init|=
literal|0
decl_stmt|;
name|u8
name|i
decl_stmt|;
comment|/* In order to read a register from the PHY, we need to shift in a 	 * total of 18 bits from the PHY.  The first two bit (turnaround) 	 * times are used to avoid contention on the MDIO pin when a read 	 * operation is performed.  These two bits are ignored by us and 	 * thrown away.  Bits are "shifted in" by raising the input to the 	 * Management Data Clock (setting the MDC bit) and then reading the 	 * value of the MDIO bit. 	 */
name|ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|)
expr_stmt|;
comment|/* Clear MDIO_DIR (SWDPIO1) to indicate this bit is to be used as 	 * input. 	 */
name|ctrl
operator|&=
operator|~
name|E1000_CTRL_MDIO_DIR
expr_stmt|;
name|ctrl
operator|&=
operator|~
name|E1000_CTRL_MDIO
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Raise and lower the clock before reading in the data.  This accounts 	 * for the turnaround bits.  The first clock occurred when we clocked 	 * out the last bit of the Register Address. 	 */
name|e1000_raise_mdi_clk_82543
argument_list|(
name|hw
argument_list|,
operator|&
name|ctrl
argument_list|)
expr_stmt|;
name|e1000_lower_mdi_clk_82543
argument_list|(
name|hw
argument_list|,
operator|&
name|ctrl
argument_list|)
expr_stmt|;
for|for
control|(
name|data
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|data
operator|<<=
literal|1
expr_stmt|;
name|e1000_raise_mdi_clk_82543
argument_list|(
name|hw
argument_list|,
operator|&
name|ctrl
argument_list|)
expr_stmt|;
name|ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|)
expr_stmt|;
comment|/* Check to see if we shifted in a "1". */
if|if
condition|(
name|ctrl
operator|&
name|E1000_CTRL_MDIO
condition|)
name|data
operator||=
literal|1
expr_stmt|;
name|e1000_lower_mdi_clk_82543
argument_list|(
name|hw
argument_list|,
operator|&
name|ctrl
argument_list|)
expr_stmt|;
block|}
name|e1000_raise_mdi_clk_82543
argument_list|(
name|hw
argument_list|,
operator|&
name|ctrl
argument_list|)
expr_stmt|;
name|e1000_lower_mdi_clk_82543
argument_list|(
name|hw
argument_list|,
operator|&
name|ctrl
argument_list|)
expr_stmt|;
return|return
name|data
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_phy_force_speed_duplex_82543 - Force speed/duplex for PHY  *  @hw - pointer to the HW structure  *  *  Calls the function to force speed and duplex for the m88 PHY, and  *  if the PHY is not auto-negotiating and the speed is forced to 10Mbit,  *  then call the function for polarity reversal workaround.  **/
end_comment

begin_function
name|STATIC
name|s32
name|e1000_phy_force_speed_duplex_82543
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|ret_val
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_phy_force_speed_duplex_82543"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_phy_force_speed_duplex_m88
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|!
name|hw
operator|->
name|mac
operator|.
name|autoneg
operator|&&
operator|(
name|hw
operator|->
name|mac
operator|.
name|forced_speed_duplex
operator|&
name|E1000_ALL_10_SPEED
operator|)
condition|)
name|ret_val
operator|=
name|e1000_polarity_reversal_workaround_82543
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_polarity_reversal_workaround_82543 - Workaround polarity reversal  *  @hw - pointer to the HW structure  *  *  When forcing link to 10 Full or 10 Half, the PHY can reverse the polarity  *  inadvertantly.  To workaround the issue, we disable the transmitter on  *  the PHY until we have established the link partner's link parameters.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_polarity_reversal_workaround_82543
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|ret_val
decl_stmt|;
name|u16
name|mii_status_reg
decl_stmt|;
name|u16
name|i
decl_stmt|;
name|boolean_t
name|link
decl_stmt|;
comment|/* Polarity reversal workaround for forced 10F/10H links. */
comment|/* Disable the transmitter on the PHY */
name|ret_val
operator|=
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_PAGE_SELECT
argument_list|,
literal|0x0019
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|ret_val
operator|=
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_GEN_CONTROL
argument_list|,
literal|0xFFFF
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|ret_val
operator|=
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_PAGE_SELECT
argument_list|,
literal|0x0000
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
comment|/* This loop will early-out if the NO link condition has been met. 	 * In other words, DO NOT use e1000_phy_has_link_generic() here. 	 */
for|for
control|(
name|i
operator|=
name|PHY_FORCE_TIME
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
comment|/* Read the MII Status Register and wait for Link Status bit 		 * to be clear. 		 */
name|ret_val
operator|=
name|e1000_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_STATUS
argument_list|,
operator|&
name|mii_status_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|ret_val
operator|=
name|e1000_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_STATUS
argument_list|,
operator|&
name|mii_status_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|(
name|mii_status_reg
operator|&
operator|~
name|MII_SR_LINK_STATUS
operator|)
operator|==
literal|0
condition|)
break|break;
name|msec_delay_irq
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
comment|/* Recommended delay time after link has been lost */
name|msec_delay_irq
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
comment|/* Now we will re-enable the transmitter on the PHY */
name|ret_val
operator|=
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_PAGE_SELECT
argument_list|,
literal|0x0019
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|msec_delay_irq
argument_list|(
literal|50
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_GEN_CONTROL
argument_list|,
literal|0xFFF0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|msec_delay_irq
argument_list|(
literal|50
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_GEN_CONTROL
argument_list|,
literal|0xFF00
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|msec_delay_irq
argument_list|(
literal|50
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_GEN_CONTROL
argument_list|,
literal|0x0000
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|ret_val
operator|=
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_PAGE_SELECT
argument_list|,
literal|0x0000
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
comment|/* Read the MII Status Register and wait for Link Status bit 	 * to be set. 	 */
name|ret_val
operator|=
name|e1000_phy_has_link_generic
argument_list|(
name|hw
argument_list|,
name|PHY_FORCE_TIME
argument_list|,
literal|100000
argument_list|,
operator|&
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_phy_hw_reset_82543 - PHY hardware reset  *  @hw - pointer to the HW structure  *  *  Sets the PHY_RESET_DIR bit in the extended device control register  *  to put the PHY into a reset and waits for completion.  Once the reset  *  has been accomplished, clear the PHY_RESET_DIR bit to take the PHY out  *  of reset.  This is a function pointer entry point called by the api module.  **/
end_comment

begin_function
name|STATIC
name|s32
name|e1000_phy_hw_reset_82543
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_functions
modifier|*
name|func
init|=
operator|&
name|hw
operator|->
name|func
decl_stmt|;
name|u32
name|ctrl_ext
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_phy_hw_reset_82543"
argument_list|)
expr_stmt|;
comment|/* Read the Extended Device Control Register, assert the PHY_RESET_DIR 	 * bit to put the PHY into reset... 	 */
name|ctrl_ext
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL_EXT
argument_list|)
expr_stmt|;
name|ctrl_ext
operator||=
name|E1000_CTRL_EXT_SDP4_DIR
expr_stmt|;
name|ctrl_ext
operator|&=
operator|~
name|E1000_CTRL_EXT_SDP4_DATA
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL_EXT
argument_list|,
name|ctrl_ext
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|msec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
comment|/* ...then take it out of reset. */
name|ctrl_ext
operator||=
name|E1000_CTRL_EXT_SDP4_DATA
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL_EXT
argument_list|,
name|ctrl_ext
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|150
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|func
operator|->
name|get_cfg_done
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_reset_hw_82543 - Reset hardware  *  @hw - pointer to the HW structure  *  *  This resets the hardware into a known state.  This is a  *  function pointer entry point called by the api module.  **/
end_comment

begin_function
name|STATIC
name|s32
name|e1000_reset_hw_82543
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|ctrl
decl_stmt|,
name|icr
decl_stmt|;
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_reset_hw_82543"
argument_list|)
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Masking off all interrupts\n"
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_IMC
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RCTL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TCTL
argument_list|,
name|E1000_TCTL_PSP
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|e1000_set_tbi_sbp_82543
argument_list|(
name|hw
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* Delay to allow any outstanding PCI transactions to complete before 	 * resetting the device 	 */
name|msec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|)
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Issuing a global reset to 82543/82544 MAC\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_82543
condition|)
block|{
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|,
name|ctrl
operator||
name|E1000_CTRL_RST
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* The 82544 can't ACK the 64-bit write when issuing the 		 * reset, so use IO-mapping as a workaround. 		 */
name|E1000_WRITE_REG_IO
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|,
name|ctrl
operator||
name|E1000_CTRL_RST
argument_list|)
expr_stmt|;
block|}
comment|/* After MAC reset, force reload of NVM to restore power-on 	 * settings to device. 	 */
name|e1000_reload_nvm
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|msec_delay
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|/* Masking off and clearing any pending interrupts */
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_IMC
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|icr
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_ICR
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_init_hw_82543 - Initialize hardware  *  @hw - pointer to the HW structure  *  *  This inits the hardware readying it for operation.  **/
end_comment

begin_function
name|STATIC
name|s32
name|e1000_init_hw_82543
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_mac_info
modifier|*
name|mac
init|=
operator|&
name|hw
operator|->
name|mac
decl_stmt|;
name|struct
name|e1000_dev_spec_82543
modifier|*
name|dev_spec
decl_stmt|;
name|u32
name|ctrl
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|u16
name|i
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_init_hw_82543"
argument_list|)
expr_stmt|;
name|dev_spec
operator|=
operator|(
expr|struct
name|e1000_dev_spec_82543
operator|*
operator|)
name|hw
operator|->
name|dev_spec
expr_stmt|;
if|if
condition|(
name|dev_spec
operator|==
name|NULL
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"dev_spec pointer is set to NULL.\n"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
operator|-
name|E1000_ERR_CONFIG
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Disabling VLAN filtering */
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_VET
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|e1000_clear_vfta
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Setup the receive address. */
name|e1000_init_rx_addrs_generic
argument_list|(
name|hw
argument_list|,
name|mac
operator|->
name|rar_entry_count
argument_list|)
expr_stmt|;
comment|/* Zero out the Multicast HASH table */
name|DEBUGOUT
argument_list|(
literal|"Zeroing the MTA\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mac
operator|->
name|mta_reg_count
condition|;
name|i
operator|++
control|)
block|{
name|E1000_WRITE_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|E1000_MTA
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
comment|/* Set the PCI priority bit correctly in the CTRL register.  This 	 * determines if the adapter gives priority to receives, or if it 	 * gives equal priority to transmits and receives. 	 */
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_82543
operator|&&
name|dev_spec
operator|->
name|dma_fairness
condition|)
block|{
name|ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|,
name|ctrl
operator||
name|E1000_CTRL_PRIOR
argument_list|)
expr_stmt|;
block|}
name|e1000_pcix_mmrbc_workaround_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Setup link and flow control */
name|ret_val
operator|=
name|e1000_setup_link
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Clear all of the statistics registers (clear on read).  It is 	 * important that we do this after we have tried to establish link 	 * because the symbol error count will increment wildly if there 	 * is no link. 	 */
name|e1000_clear_hw_cntrs_82543
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_setup_link_82543 - Setup flow control and link settings  *  @hw - pointer to the HW structure  *  *  Read the EEPROM to determine the initial polarity value and write the  *  extended device control register with the information before calling  *  the generic setup link function, which does the following:  *  Determines which flow control settings to use, then configures flow  *  control.  Calls the appropriate media-specific link configuration  *  function.  Assuming the adapter has a valid link partner, a valid link  *  should be established.  Assumes the hardware has previously been reset  *  and the transmitter and receiver are not enabled.  **/
end_comment

begin_function
name|STATIC
name|s32
name|e1000_setup_link_82543
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|ctrl_ext
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|u16
name|data
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_setup_link_82543"
argument_list|)
expr_stmt|;
comment|/* Take the 4 bits from NVM word 0xF that determine the initial 	 * polarity value for the SW controlled pins, and setup the 	 * Extended Device Control reg with that info. 	 * This is needed because one of the SW controlled pins is used for 	 * signal detection.  So this should be done before phy setup. 	 */
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_82543
condition|)
block|{
name|ret_val
operator|=
name|e1000_read_nvm
argument_list|(
name|hw
argument_list|,
name|NVM_INIT_CONTROL2_REG
argument_list|,
literal|1
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"NVM Read Error\n"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
operator|-
name|E1000_ERR_NVM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ctrl_ext
operator|=
operator|(
operator|(
name|data
operator|&
name|NVM_WORD0F_SWPDIO_EXT_MASK
operator|)
operator|<<
name|NVM_SWDPIO_EXT_SHIFT
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL_EXT
argument_list|,
name|ctrl_ext
argument_list|)
expr_stmt|;
block|}
name|ret_val
operator|=
name|e1000_setup_link_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_setup_copper_link_82543 - Configure copper link settings  *  @hw - pointer to the HW structure  *  *  Configures the link for auto-neg or forced speed and duplex.  Then we check  *  for link, once link is established calls to configure collision distance  *  and flow control are called.  **/
end_comment

begin_function
name|STATIC
name|s32
name|e1000_setup_copper_link_82543
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|ctrl
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|boolean_t
name|link
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_setup_copper_link_82543"
argument_list|)
expr_stmt|;
name|ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|)
operator||
name|E1000_CTRL_SLU
expr_stmt|;
comment|/* With 82543, we need to force speed and duplex on the MAC 	 * equal to what the PHY speed and duplex configuration is. 	 * In addition, we need to perform a hardware reset on the 	 * PHY to take it out of reset. 	 */
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_82543
condition|)
block|{
name|ctrl
operator||=
operator|(
name|E1000_CTRL_FRCSPD
operator||
name|E1000_CTRL_FRCDPX
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_phy_hw_reset
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|hw
operator|->
name|phy
operator|.
name|reset_disable
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
name|ctrl
operator|&=
operator|~
operator|(
name|E1000_CTRL_FRCSPD
operator||
name|E1000_CTRL_FRCDPX
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
block|}
comment|/* Set MDI/MDI-X, Polarity Reversal, and downshift settings */
name|ret_val
operator|=
name|e1000_copper_link_setup_m88
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|autoneg
condition|)
block|{
comment|/* Setup autoneg and flow control advertisement and perform 		 * autonegotiation. */
name|ret_val
operator|=
name|e1000_copper_link_autoneg
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
block|}
else|else
block|{
comment|/* PHY will be set to 10H, 10F, 100H or 100F 		 * depending on user settings. */
name|DEBUGOUT
argument_list|(
literal|"Forcing Speed and Duplex\n"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_phy_force_speed_duplex_82543
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Error Forcing Speed and Duplex\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
comment|/* Check link status. Wait up to 100 microseconds for link to become 	 * valid. 	 */
name|ret_val
operator|=
name|e1000_phy_has_link_generic
argument_list|(
name|hw
argument_list|,
name|COPPER_LINK_UP_LIMIT
argument_list|,
literal|10
argument_list|,
operator|&
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|link
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Valid link established!!!\n"
argument_list|)
expr_stmt|;
comment|/* Config the MAC and PHY after link is up */
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_82544
condition|)
name|e1000_config_collision_dist_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
else|else
block|{
name|ret_val
operator|=
name|e1000_config_mac_to_phy_82543
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
block|}
name|ret_val
operator|=
name|e1000_config_fc_after_link_up_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DEBUGOUT
argument_list|(
literal|"Unable to establish link!!!\n"
argument_list|)
expr_stmt|;
block|}
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_setup_fiber_link_82543 - Setup link for fiber  *  @hw - pointer to the HW structure  *  *  Configures collision distance and flow control for fiber links.  Upon  *  successful setup, poll for link.  **/
end_comment

begin_function
name|STATIC
name|s32
name|e1000_setup_fiber_link_82543
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|ctrl
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_setup_fiber_link_82543"
argument_list|)
expr_stmt|;
name|ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|)
expr_stmt|;
comment|/* Take the link out of reset */
name|ctrl
operator|&=
operator|~
name|E1000_CTRL_LRST
expr_stmt|;
name|e1000_config_collision_dist_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_commit_fc_settings_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|DEBUGOUT
argument_list|(
literal|"Auto-negotiation enabled\n"
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|msec_delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* For these adapters, the SW defineable pin 1 is cleared when the 	 * optics detect a signal.  If we have a signal, then poll for a 	 * "Link-Up" indication. 	 */
if|if
condition|(
operator|!
operator|(
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|)
operator|&
name|E1000_CTRL_SWDPIN1
operator|)
condition|)
block|{
name|ret_val
operator|=
name|e1000_poll_fiber_serdes_link_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DEBUGOUT
argument_list|(
literal|"No signal detected\n"
argument_list|)
expr_stmt|;
block|}
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_check_for_copper_link_82543 - Check for link (Copper)  *  @hw - pointer to the HW structure  *  *  Checks the phy for link, if link exists, do the following:  *   - check for downshift  *   - do polarity workaround (if necessary)  *   - configure collision distance  *   - configure flow control after link up  *   - configure tbi compatibility  **/
end_comment

begin_function
name|STATIC
name|s32
name|e1000_check_for_copper_link_82543
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_mac_info
modifier|*
name|mac
init|=
operator|&
name|hw
operator|->
name|mac
decl_stmt|;
name|u32
name|icr
decl_stmt|,
name|rctl
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|u16
name|speed
decl_stmt|,
name|duplex
decl_stmt|;
name|boolean_t
name|link
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_check_for_copper_link_82543"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mac
operator|->
name|get_link_status
condition|)
block|{
name|ret_val
operator|=
name|E1000_SUCCESS
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ret_val
operator|=
name|e1000_phy_has_link_generic
argument_list|(
name|hw
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
operator|&
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|!
name|link
condition|)
goto|goto
name|out
goto|;
comment|/* No link detected */
name|mac
operator|->
name|get_link_status
operator|=
name|FALSE
expr_stmt|;
name|e1000_check_downshift_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* If we are forcing speed/duplex, then we can return since 	 * we have already determined whether we have link or not. 	 */
if|if
condition|(
operator|!
name|mac
operator|->
name|autoneg
condition|)
block|{
comment|/* If speed and duplex are forced to 10H or 10F, then we will 		 * implement the polarity reversal workaround.  We disable 		 * interrupts first, and upon returning, place the devices 		 * interrupt state to its previous value except for the link 		 * status change interrupt which will happened due to the 		 * execution of this workaround. 		 */
if|if
condition|(
name|mac
operator|->
name|forced_speed_duplex
operator|&
name|E1000_ALL_10_SPEED
condition|)
block|{
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_IMC
argument_list|,
literal|0xFFFFFFFF
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_polarity_reversal_workaround_82543
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|icr
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_ICR
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_ICS
argument_list|,
operator|(
name|icr
operator|&
operator|~
name|E1000_ICS_LSC
operator|)
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_IMS
argument_list|,
name|IMS_ENABLE_MASK
argument_list|)
expr_stmt|;
block|}
name|ret_val
operator|=
operator|-
name|E1000_ERR_CONFIG
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* We have a M88E1000 PHY and Auto-Neg is enabled.  If we 	 * have Si on board that is 82544 or newer, Auto 	 * Speed Detection takes care of MAC speed/duplex 	 * configuration.  So we only need to configure Collision 	 * Distance in the MAC.  Otherwise, we need to force 	 * speed/duplex on the MAC to the current PHY speed/duplex 	 * settings. 	 */
if|if
condition|(
name|mac
operator|->
name|type
operator|==
name|e1000_82544
condition|)
name|e1000_config_collision_dist_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
else|else
block|{
name|ret_val
operator|=
name|e1000_config_mac_to_phy_82543
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Error configuring MAC to PHY settings\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
comment|/* Configure Flow Control now that Auto-Neg has completed. 	 * First, we need to restore the desired flow control 	 * settings because we may have had to re-autoneg with a 	 * different link partner. 	 */
name|ret_val
operator|=
name|e1000_config_fc_after_link_up_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Error configuring flow control\n"
argument_list|)
expr_stmt|;
block|}
comment|/* At this point we know that we are on copper and we have 	 * auto-negotiated link.  These are conditions for checking the link 	 * partner capability register.  We use the link speed to determine if 	 * TBI compatibility needs to be turned on or off.  If the link is not 	 * at gigabit speed, then TBI compatibility is not needed.  If we are 	 * at gigabit speed, we turn on TBI compatibility. 	 */
if|if
condition|(
name|e1000_tbi_compatibility_enabled_82543
argument_list|(
name|hw
argument_list|)
condition|)
block|{
name|ret_val
operator|=
name|e1000_get_speed_and_duplex
argument_list|(
name|hw
argument_list|,
operator|&
name|speed
argument_list|,
operator|&
name|duplex
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Error getting link speed and duplex\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
if|if
condition|(
name|speed
operator|!=
name|SPEED_1000
condition|)
block|{
comment|/* If link speed is not set to gigabit speed, 			 * we do not need to enable TBI compatibility. 			 */
if|if
condition|(
name|e1000_tbi_sbp_enabled_82543
argument_list|(
name|hw
argument_list|)
condition|)
block|{
comment|/* If we previously were in the mode, 				 * turn it off. 				 */
name|e1000_set_tbi_sbp_82543
argument_list|(
name|hw
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|rctl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RCTL
argument_list|)
expr_stmt|;
name|rctl
operator|&=
operator|~
name|E1000_RCTL_SBP
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RCTL
argument_list|,
name|rctl
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* If TBI compatibility is was previously off, 			 * turn it on. For compatibility with a TBI link 			 * partner, we will store bad packets. Some 			 * frames have an additional byte on the end and 			 * will look like CRC errors to to the hardware. 			 */
if|if
condition|(
operator|!
name|e1000_tbi_sbp_enabled_82543
argument_list|(
name|hw
argument_list|)
condition|)
block|{
name|e1000_set_tbi_sbp_82543
argument_list|(
name|hw
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|rctl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RCTL
argument_list|)
expr_stmt|;
name|rctl
operator||=
name|E1000_RCTL_SBP
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RCTL
argument_list|,
name|rctl
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_check_for_fiber_link_82543 - Check for link (Fiber)  *  @hw - pointer to the HW structure  *  *  Checks for link up on the hardware.  If link is not up and we have  *  a signal, then we need to force link up.  **/
end_comment

begin_function
name|STATIC
name|s32
name|e1000_check_for_fiber_link_82543
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_mac_info
modifier|*
name|mac
init|=
operator|&
name|hw
operator|->
name|mac
decl_stmt|;
name|u32
name|rxcw
decl_stmt|,
name|ctrl
decl_stmt|,
name|status
decl_stmt|;
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_check_for_fiber_link_82543"
argument_list|)
expr_stmt|;
name|ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|)
expr_stmt|;
name|status
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|)
expr_stmt|;
name|rxcw
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|)
expr_stmt|;
comment|/* If we don't have link (auto-negotiation failed or link partner 	 * cannot auto-negotiate), the cable is plugged in (we have signal), 	 * and our link partner is not trying to auto-negotiate with us (we 	 * are receiving idles or data), we need to force link up. We also 	 * need to give auto-negotiation time to complete, in case the cable 	 * was just plugged in. The autoneg_failed flag does this. 	 */
comment|/* (ctrl& E1000_CTRL_SWDPIN1) == 0 == have signal */
if|if
condition|(
operator|(
operator|!
operator|(
name|ctrl
operator|&
name|E1000_CTRL_SWDPIN1
operator|)
operator|)
operator|&&
operator|(
operator|!
operator|(
name|status
operator|&
name|E1000_STATUS_LU
operator|)
operator|)
operator|&&
operator|(
operator|!
operator|(
name|rxcw
operator|&
name|E1000_RXCW_C
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|mac
operator|->
name|autoneg_failed
operator|==
literal|0
condition|)
block|{
name|mac
operator|->
name|autoneg_failed
operator|=
literal|1
expr_stmt|;
name|ret_val
operator|=
literal|0
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|DEBUGOUT
argument_list|(
literal|"NOT RXing /C/, disable AutoNeg and force link.\n"
argument_list|)
expr_stmt|;
comment|/* Disable auto-negotiation in the TXCW register */
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TXCW
argument_list|,
operator|(
name|mac
operator|->
name|txcw
operator|&
operator|~
name|E1000_TXCW_ANE
operator|)
argument_list|)
expr_stmt|;
comment|/* Force link-up and also force full-duplex. */
name|ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|)
expr_stmt|;
name|ctrl
operator||=
operator|(
name|E1000_CTRL_SLU
operator||
name|E1000_CTRL_FD
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
comment|/* Configure Flow Control after forcing link up. */
name|ret_val
operator|=
name|e1000_config_fc_after_link_up_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Error configuring flow control\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|ctrl
operator|&
name|E1000_CTRL_SLU
operator|)
operator|&&
operator|(
name|rxcw
operator|&
name|E1000_RXCW_C
operator|)
condition|)
block|{
comment|/* If we are forcing link and we are receiving /C/ ordered 		 * sets, re-enable auto-negotiation in the TXCW register 		 * and disable forced link in the Device Control register 		 * in an attempt to auto-negotiate with our link partner. 		 */
name|DEBUGOUT
argument_list|(
literal|"RXing /C/, enable AutoNeg and stop forcing link.\n"
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TXCW
argument_list|,
name|mac
operator|->
name|txcw
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|,
operator|(
name|ctrl
operator|&
operator|~
name|E1000_CTRL_SLU
operator|)
argument_list|)
expr_stmt|;
name|mac
operator|->
name|serdes_has_link
operator|=
name|TRUE
expr_stmt|;
block|}
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_config_mac_to_phy_82543 - Configure MAC to PHY settings  *  @hw - pointer to the HW structure  *  *  For the 82543 silicon, we need to set the MAC to match the settings  *  of the PHY, even if the PHY is auto-negotiating.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_config_mac_to_phy_82543
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|ctrl
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|u16
name|phy_data
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_config_mac_to_phy_82543"
argument_list|)
expr_stmt|;
comment|/* Set the bits to force speed and duplex */
name|ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|)
expr_stmt|;
name|ctrl
operator||=
operator|(
name|E1000_CTRL_FRCSPD
operator||
name|E1000_CTRL_FRCDPX
operator|)
expr_stmt|;
name|ctrl
operator|&=
operator|~
operator|(
name|E1000_CTRL_SPD_SEL
operator||
name|E1000_CTRL_ILOS
operator|)
expr_stmt|;
comment|/* Set up duplex in the Device Control and Transmit Control 	 * registers depending on negotiated values. 	 */
name|ret_val
operator|=
name|e1000_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_SPEC_STATUS
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|ctrl
operator|&=
operator|~
name|E1000_CTRL_FD
expr_stmt|;
if|if
condition|(
name|phy_data
operator|&
name|M88E1000_PSSR_DPLX
condition|)
name|ctrl
operator||=
name|E1000_CTRL_FD
expr_stmt|;
name|e1000_config_collision_dist_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Set up speed in the Device Control register depending on 	 * negotiated values. 	 */
if|if
condition|(
operator|(
name|phy_data
operator|&
name|M88E1000_PSSR_SPEED
operator|)
operator|==
name|M88E1000_PSSR_1000MBS
condition|)
name|ctrl
operator||=
name|E1000_CTRL_SPD_1000
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|phy_data
operator|&
name|M88E1000_PSSR_SPEED
operator|)
operator|==
name|M88E1000_PSSR_100MBS
condition|)
name|ctrl
operator||=
name|E1000_CTRL_SPD_100
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_write_vfta_82543 - Write value to VLAN filter table  *  @hw - pointer to the HW structure  *  @offset - the 32-bit offset in which to write the value to.  *  @value - the 32-bit value to write at location offset.  *  *  This writes a 32-bit value to a 32-bit offset in the VLAN filter  *  table.  **/
end_comment

begin_function
name|STATIC
name|void
name|e1000_write_vfta_82543
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u32
name|value
parameter_list|)
block|{
name|u32
name|temp
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_write_vfta_82543"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_82544
operator|)
operator|&&
operator|(
name|offset
operator|&
literal|1
operator|)
condition|)
block|{
name|temp
operator|=
name|E1000_READ_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|E1000_VFTA
argument_list|,
name|offset
operator|-
literal|1
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|E1000_VFTA
argument_list|,
name|offset
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|E1000_VFTA
argument_list|,
name|offset
operator|-
literal|1
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
else|else
name|e1000_write_vfta_generic
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  e1000_mta_set_82543 - Set multicast filter table address  *  @hw - pointer to the HW structure  *  @hash_value - determines the MTA register and bit to set  *  *  The multicast table address is a register array of 32-bit registers.  *  The hash_value is used to determine what register the bit is in, the  *  current value is read, the new bit is OR'd in and the new value is  *  written back into the register.  **/
end_comment

begin_function
name|STATIC
name|void
name|e1000_mta_set_82543
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|hash_value
parameter_list|)
block|{
name|u32
name|hash_bit
decl_stmt|,
name|hash_reg
decl_stmt|,
name|mta
decl_stmt|,
name|temp
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_mta_set_82543"
argument_list|)
expr_stmt|;
name|hash_reg
operator|=
operator|(
name|hash_value
operator|>>
literal|5
operator|)
expr_stmt|;
comment|/* If we are on an 82544 and we are trying to write an odd offset 	 * in the MTA, save off the previous entry before writing and 	 * restore the old value after writing. 	 */
if|if
condition|(
operator|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_82544
operator|)
operator|&&
operator|(
name|hash_reg
operator|&
literal|1
operator|)
condition|)
block|{
name|hash_reg
operator|&=
operator|(
name|hw
operator|->
name|mac
operator|.
name|mta_reg_count
operator|-
literal|1
operator|)
expr_stmt|;
name|hash_bit
operator|=
name|hash_value
operator|&
literal|0x1F
expr_stmt|;
name|mta
operator|=
name|E1000_READ_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|E1000_MTA
argument_list|,
name|hash_reg
argument_list|)
expr_stmt|;
name|mta
operator||=
operator|(
literal|1
operator|<<
name|hash_bit
operator|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|E1000_MTA
argument_list|,
name|hash_reg
operator|-
literal|1
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|E1000_MTA
argument_list|,
name|hash_reg
argument_list|,
name|mta
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|E1000_MTA
argument_list|,
name|hash_reg
operator|-
literal|1
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
else|else
name|e1000_mta_set_generic
argument_list|(
name|hw
argument_list|,
name|hash_value
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  e1000_led_on_82543 - Turn on SW controllable LED  *  @hw - pointer to the HW structure  *  *  Turns the SW defined LED on.  This is a function pointer entry point  *  called by the api module.  **/
end_comment

begin_function
name|STATIC
name|s32
name|e1000_led_on_82543
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|ctrl
init|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|)
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_led_on_82543"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_82544
operator|&&
name|hw
operator|->
name|media_type
operator|==
name|e1000_media_type_copper
condition|)
block|{
comment|/* Clear SW-defineable Pin 0 to turn on the LED */
name|ctrl
operator|&=
operator|~
name|E1000_CTRL_SWDPIN0
expr_stmt|;
name|ctrl
operator||=
name|E1000_CTRL_SWDPIO0
expr_stmt|;
block|}
else|else
block|{
comment|/* Fiber 82544 and all 82543 use this method */
name|ctrl
operator||=
name|E1000_CTRL_SWDPIN0
expr_stmt|;
name|ctrl
operator||=
name|E1000_CTRL_SWDPIO0
expr_stmt|;
block|}
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_led_off_82543 - Turn off SW controllable LED  *  @hw - pointer to the HW structure  *  *  Turns the SW defined LED off.  This is a function pointer entry point  *  called by the api module.  **/
end_comment

begin_function
name|STATIC
name|s32
name|e1000_led_off_82543
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|ctrl
init|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|)
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_led_off_82543"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_82544
operator|&&
name|hw
operator|->
name|media_type
operator|==
name|e1000_media_type_copper
condition|)
block|{
comment|/* Set SW-defineable Pin 0 to turn off the LED */
name|ctrl
operator||=
name|E1000_CTRL_SWDPIN0
expr_stmt|;
name|ctrl
operator||=
name|E1000_CTRL_SWDPIO0
expr_stmt|;
block|}
else|else
block|{
name|ctrl
operator|&=
operator|~
name|E1000_CTRL_SWDPIN0
expr_stmt|;
name|ctrl
operator||=
name|E1000_CTRL_SWDPIO0
expr_stmt|;
block|}
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_clear_hw_cntrs_82543 - Clear device specific hardware counters  *  @hw - pointer to the HW structure  *  *  Clears the hardware counters by reading the counter registers.  **/
end_comment

begin_function
name|STATIC
name|void
name|e1000_clear_hw_cntrs_82543
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
specifier|volatile
name|u32
name|temp
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_clear_hw_cntrs_82543"
argument_list|)
expr_stmt|;
name|e1000_clear_hw_cntrs_base_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PRC64
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PRC127
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PRC255
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PRC511
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PRC1023
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PRC1522
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PTC64
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PTC127
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PTC255
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PTC511
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PTC1023
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PTC1522
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_ALGNERRC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RXERRC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TNCRS
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CEXTERR
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TSCTC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TSCTFC
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

