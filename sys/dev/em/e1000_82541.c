begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*******************************************************************************    Copyright (c) 2001-2007, Intel Corporation    All rights reserved.      Redistribution and use in source and binary forms, with or without    modification, are permitted provided that the following conditions are met:       1. Redistributions of source code must retain the above copyright notice,        this list of conditions and the following disclaimer.       2. Redistributions in binary form must reproduce the above copyright        notice, this list of conditions and the following disclaimer in the        documentation and/or other materials provided with the distribution.       3. Neither the name of the Intel Corporation nor the names of its        contributors may be used to endorse or promote products derived from        this software without specific prior written permission.      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE    ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR    CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF    SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN    CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)    ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE   POSSIBILITY OF SUCH DAMAGE.  *******************************************************************************/
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* e1000_82541  * e1000_82547  * e1000_82541_rev_2  * e1000_82547_rev_2  */
end_comment

begin_include
include|#
directive|include
file|"e1000_82541.h"
end_include

begin_function_decl
name|void
name|e1000_init_function_pointers_82541
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|s32
name|e1000_init_phy_params_82541
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|s32
name|e1000_init_nvm_params_82541
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|s32
name|e1000_init_mac_params_82541
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|s32
name|e1000_reset_hw_82541
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|s32
name|e1000_init_hw_82541
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|s32
name|e1000_get_link_up_info_82541
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
modifier|*
name|speed
parameter_list|,
name|u16
modifier|*
name|duplex
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|s32
name|e1000_phy_hw_reset_82541
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|s32
name|e1000_setup_copper_link_82541
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|s32
name|e1000_check_for_link_82541
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|s32
name|e1000_get_cable_length_igp_82541
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|s32
name|e1000_set_d3_lplu_state_82541
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|boolean_t
name|active
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|s32
name|e1000_setup_led_82541
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|s32
name|e1000_cleanup_led_82541
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|void
name|e1000_clear_hw_cntrs_82541
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_config_dsp_after_link_change_82541
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|boolean_t
name|link_up
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_phy_init_script_82541
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
specifier|const
name|u16
name|e1000_igp_cable_length_table
index|[]
init|=
block|{
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|20
block|,
literal|20
block|,
literal|20
block|,
literal|20
block|,
literal|20
block|,
literal|25
block|,
literal|25
block|,
literal|25
block|,
literal|25
block|,
literal|25
block|,
literal|25
block|,
literal|25
block|,
literal|30
block|,
literal|30
block|,
literal|30
block|,
literal|30
block|,
literal|40
block|,
literal|40
block|,
literal|40
block|,
literal|40
block|,
literal|40
block|,
literal|40
block|,
literal|40
block|,
literal|40
block|,
literal|40
block|,
literal|50
block|,
literal|50
block|,
literal|50
block|,
literal|50
block|,
literal|50
block|,
literal|50
block|,
literal|50
block|,
literal|60
block|,
literal|60
block|,
literal|60
block|,
literal|60
block|,
literal|60
block|,
literal|60
block|,
literal|60
block|,
literal|60
block|,
literal|60
block|,
literal|70
block|,
literal|70
block|,
literal|70
block|,
literal|70
block|,
literal|70
block|,
literal|70
block|,
literal|80
block|,
literal|80
block|,
literal|80
block|,
literal|80
block|,
literal|80
block|,
literal|80
block|,
literal|90
block|,
literal|90
block|,
literal|90
block|,
literal|90
block|,
literal|90
block|,
literal|90
block|,
literal|90
block|,
literal|90
block|,
literal|90
block|,
literal|100
block|,
literal|100
block|,
literal|100
block|,
literal|100
block|,
literal|100
block|,
literal|100
block|,
literal|100
block|,
literal|100
block|,
literal|100
block|,
literal|100
block|,
literal|100
block|,
literal|100
block|,
literal|100
block|,
literal|100
block|,
literal|110
block|,
literal|110
block|,
literal|110
block|,
literal|110
block|,
literal|110
block|,
literal|110
block|,
literal|110
block|,
literal|110
block|,
literal|110
block|,
literal|110
block|,
literal|110
block|,
literal|110
block|,
literal|110
block|,
literal|110
block|,
literal|110
block|,
literal|110
block|,
literal|110
block|,
literal|110
block|,
literal|120
block|,
literal|120
block|,
literal|120
block|,
literal|120
block|,
literal|120
block|,
literal|120
block|,
literal|120
block|,
literal|120
block|,
literal|120
block|,
literal|120
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|IGP01E1000_AGC_LENGTH_TABLE_SIZE
define|\
value|(sizeof(e1000_igp_cable_length_table) / \                  sizeof(e1000_igp_cable_length_table[0]))
end_define

begin_struct
struct|struct
name|e1000_dev_spec_82541
block|{
name|e1000_dsp_config
name|dsp_config
decl_stmt|;
name|e1000_ffe_config
name|ffe_config
decl_stmt|;
name|u16
name|spd_default
decl_stmt|;
name|boolean_t
name|phy_init_script
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/**  *  e1000_init_phy_params_82541 - Init PHY func ptrs.  *  @hw - pointer to the HW structure  *  *  This is a function pointer entry point called by the api module.  **/
end_comment

begin_function
name|STATIC
name|s32
name|e1000_init_phy_params_82541
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|struct
name|e1000_functions
modifier|*
name|func
init|=
operator|&
name|hw
operator|->
name|func
decl_stmt|;
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_init_phy_params_82541"
argument_list|)
expr_stmt|;
name|phy
operator|->
name|addr
operator|=
literal|1
expr_stmt|;
name|phy
operator|->
name|autoneg_mask
operator|=
name|AUTONEG_ADVERTISE_SPEED_DEFAULT
expr_stmt|;
name|phy
operator|->
name|reset_delay_us
operator|=
literal|10000
expr_stmt|;
name|phy
operator|->
name|type
operator|=
name|e1000_phy_igp
expr_stmt|;
comment|/* Function Pointers */
name|func
operator|->
name|check_polarity
operator|=
name|e1000_check_polarity_igp
expr_stmt|;
name|func
operator|->
name|force_speed_duplex
operator|=
name|e1000_phy_force_speed_duplex_igp
expr_stmt|;
name|func
operator|->
name|get_cable_length
operator|=
name|e1000_get_cable_length_igp_82541
expr_stmt|;
name|func
operator|->
name|get_cfg_done
operator|=
name|e1000_get_cfg_done_generic
expr_stmt|;
name|func
operator|->
name|get_phy_info
operator|=
name|e1000_get_phy_info_igp
expr_stmt|;
name|func
operator|->
name|read_phy_reg
operator|=
name|e1000_read_phy_reg_igp
expr_stmt|;
name|func
operator|->
name|reset_phy
operator|=
name|e1000_phy_hw_reset_82541
expr_stmt|;
name|func
operator|->
name|set_d3_lplu_state
operator|=
name|e1000_set_d3_lplu_state_82541
expr_stmt|;
name|func
operator|->
name|write_phy_reg
operator|=
name|e1000_write_phy_reg_igp
expr_stmt|;
name|ret_val
operator|=
name|e1000_get_phy_id
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
comment|/* Verify phy id */
if|if
condition|(
name|phy
operator|->
name|id
operator|!=
name|IGP01E1000_I_PHY_ID
condition|)
block|{
name|ret_val
operator|=
operator|-
name|E1000_ERR_PHY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_init_nvm_params_82541 - Init NVM func ptrs.  *  @hw - pointer to the HW structure  *  *  This is a function pointer entry point called by the api module.  **/
end_comment

begin_function
name|STATIC
name|s32
name|e1000_init_nvm_params_82541
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_nvm_info
modifier|*
name|nvm
init|=
operator|&
name|hw
operator|->
name|nvm
decl_stmt|;
name|struct
name|e1000_functions
modifier|*
name|func
init|=
operator|&
name|hw
operator|->
name|func
decl_stmt|;
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|u32
name|eecd
init|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_EECD
argument_list|)
decl_stmt|;
name|u16
name|size
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_init_nvm_params_82541"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|nvm
operator|->
name|override
condition|)
block|{
case|case
name|e1000_nvm_override_spi_large
case|:
name|nvm
operator|->
name|type
operator|=
name|e1000_nvm_eeprom_spi
expr_stmt|;
name|eecd
operator||=
name|E1000_EECD_ADDR_BITS
expr_stmt|;
break|break;
case|case
name|e1000_nvm_override_spi_small
case|:
name|nvm
operator|->
name|type
operator|=
name|e1000_nvm_eeprom_spi
expr_stmt|;
name|eecd
operator|&=
operator|~
name|E1000_EECD_ADDR_BITS
expr_stmt|;
break|break;
case|case
name|e1000_nvm_override_microwire_large
case|:
name|nvm
operator|->
name|type
operator|=
name|e1000_nvm_eeprom_microwire
expr_stmt|;
name|eecd
operator||=
name|E1000_EECD_SIZE
expr_stmt|;
break|break;
case|case
name|e1000_nvm_override_microwire_small
case|:
name|nvm
operator|->
name|type
operator|=
name|e1000_nvm_eeprom_microwire
expr_stmt|;
name|eecd
operator|&=
operator|~
name|E1000_EECD_SIZE
expr_stmt|;
break|break;
default|default:
name|nvm
operator|->
name|type
operator|=
name|eecd
operator|&
name|E1000_EECD_TYPE
condition|?
name|e1000_nvm_eeprom_spi
else|:
name|e1000_nvm_eeprom_microwire
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|nvm
operator|->
name|type
operator|==
name|e1000_nvm_eeprom_spi
condition|)
block|{
name|nvm
operator|->
name|address_bits
operator|=
operator|(
name|eecd
operator|&
name|E1000_EECD_ADDR_BITS
operator|)
condition|?
literal|16
else|:
literal|8
expr_stmt|;
name|nvm
operator|->
name|delay_usec
operator|=
literal|1
expr_stmt|;
name|nvm
operator|->
name|opcode_bits
operator|=
literal|8
expr_stmt|;
name|nvm
operator|->
name|page_size
operator|=
operator|(
name|eecd
operator|&
name|E1000_EECD_ADDR_BITS
operator|)
condition|?
literal|32
else|:
literal|8
expr_stmt|;
comment|/* Function Pointers */
name|func
operator|->
name|acquire_nvm
operator|=
name|e1000_acquire_nvm_generic
expr_stmt|;
name|func
operator|->
name|read_nvm
operator|=
name|e1000_read_nvm_spi
expr_stmt|;
name|func
operator|->
name|release_nvm
operator|=
name|e1000_release_nvm_generic
expr_stmt|;
name|func
operator|->
name|update_nvm
operator|=
name|e1000_update_nvm_checksum_generic
expr_stmt|;
name|func
operator|->
name|valid_led_default
operator|=
name|e1000_valid_led_default_generic
expr_stmt|;
name|func
operator|->
name|validate_nvm
operator|=
name|e1000_validate_nvm_checksum_generic
expr_stmt|;
name|func
operator|->
name|write_nvm
operator|=
name|e1000_write_nvm_spi
expr_stmt|;
comment|/* nvm->word_size must be discovered after the pointers 		 * are set so we can verify the size from the nvm image 		 * itself.  Temporarily set it to a dummy value so the 		 * read will work. 		 */
name|nvm
operator|->
name|word_size
operator|=
literal|64
expr_stmt|;
name|ret_val
operator|=
name|e1000_read_nvm
argument_list|(
name|hw
argument_list|,
name|NVM_CFG
argument_list|,
literal|1
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|size
operator|=
operator|(
name|size
operator|&
name|NVM_SIZE_MASK
operator|)
operator|>>
name|NVM_SIZE_SHIFT
expr_stmt|;
comment|/* if size != 0, it can be added to a constant and become 		 * the left-shift value to set the word_size.  Otherwise, 		 * word_size stays at 64. 		 */
if|if
condition|(
name|size
condition|)
block|{
name|size
operator|+=
name|NVM_WORD_SIZE_BASE_SHIFT_82541
expr_stmt|;
name|nvm
operator|->
name|word_size
operator|=
literal|1
operator|<<
name|size
expr_stmt|;
block|}
block|}
else|else
block|{
name|nvm
operator|->
name|address_bits
operator|=
operator|(
name|eecd
operator|&
name|E1000_EECD_ADDR_BITS
operator|)
condition|?
literal|8
else|:
literal|6
expr_stmt|;
name|nvm
operator|->
name|delay_usec
operator|=
literal|50
expr_stmt|;
name|nvm
operator|->
name|opcode_bits
operator|=
literal|3
expr_stmt|;
name|nvm
operator|->
name|word_size
operator|=
operator|(
name|eecd
operator|&
name|E1000_EECD_ADDR_BITS
operator|)
condition|?
literal|256
else|:
literal|64
expr_stmt|;
comment|/* Function Pointers */
name|func
operator|->
name|acquire_nvm
operator|=
name|e1000_acquire_nvm_generic
expr_stmt|;
name|func
operator|->
name|read_nvm
operator|=
name|e1000_read_nvm_microwire
expr_stmt|;
name|func
operator|->
name|release_nvm
operator|=
name|e1000_release_nvm_generic
expr_stmt|;
name|func
operator|->
name|update_nvm
operator|=
name|e1000_update_nvm_checksum_generic
expr_stmt|;
name|func
operator|->
name|valid_led_default
operator|=
name|e1000_valid_led_default_generic
expr_stmt|;
name|func
operator|->
name|validate_nvm
operator|=
name|e1000_validate_nvm_checksum_generic
expr_stmt|;
name|func
operator|->
name|write_nvm
operator|=
name|e1000_write_nvm_microwire
expr_stmt|;
block|}
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_init_mac_params_82541 - Init MAC func ptrs.  *  @hw - pointer to the HW structure  *  *  This is a function pointer entry point called by the api module.  **/
end_comment

begin_function
name|STATIC
name|s32
name|e1000_init_mac_params_82541
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_mac_info
modifier|*
name|mac
init|=
operator|&
name|hw
operator|->
name|mac
decl_stmt|;
name|struct
name|e1000_functions
modifier|*
name|func
init|=
operator|&
name|hw
operator|->
name|func
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_init_mac_params_82541"
argument_list|)
expr_stmt|;
comment|/* Set media type */
name|hw
operator|->
name|media_type
operator|=
name|e1000_media_type_copper
expr_stmt|;
comment|/* Set mta register count */
name|mac
operator|->
name|mta_reg_count
operator|=
literal|128
expr_stmt|;
comment|/* Set rar entry count */
name|mac
operator|->
name|rar_entry_count
operator|=
name|E1000_RAR_ENTRIES
expr_stmt|;
comment|/* Set if part includes ASF firmware */
name|mac
operator|->
name|asf_firmware_present
operator|=
name|TRUE
expr_stmt|;
comment|/* Function Pointers */
comment|/* bus type/speed/width */
name|func
operator|->
name|get_bus_info
operator|=
name|e1000_get_bus_info_pci_generic
expr_stmt|;
comment|/* reset */
name|func
operator|->
name|reset_hw
operator|=
name|e1000_reset_hw_82541
expr_stmt|;
comment|/* hw initialization */
name|func
operator|->
name|init_hw
operator|=
name|e1000_init_hw_82541
expr_stmt|;
comment|/* link setup */
name|func
operator|->
name|setup_link
operator|=
name|e1000_setup_link_generic
expr_stmt|;
comment|/* physical interface link setup */
name|func
operator|->
name|setup_physical_interface
operator|=
name|e1000_setup_copper_link_82541
expr_stmt|;
comment|/* check for link */
name|func
operator|->
name|check_for_link
operator|=
name|e1000_check_for_link_82541
expr_stmt|;
comment|/* link info */
name|func
operator|->
name|get_link_up_info
operator|=
name|e1000_get_link_up_info_82541
expr_stmt|;
comment|/* multicast address update */
name|func
operator|->
name|mc_addr_list_update
operator|=
name|e1000_mc_addr_list_update_generic
expr_stmt|;
comment|/* writing VFTA */
name|func
operator|->
name|write_vfta
operator|=
name|e1000_write_vfta_generic
expr_stmt|;
comment|/* clearing VFTA */
name|func
operator|->
name|clear_vfta
operator|=
name|e1000_clear_vfta_generic
expr_stmt|;
comment|/* setting MTA */
name|func
operator|->
name|mta_set
operator|=
name|e1000_mta_set_generic
expr_stmt|;
comment|/* setup LED */
name|func
operator|->
name|setup_led
operator|=
name|e1000_setup_led_82541
expr_stmt|;
comment|/* cleanup LED */
name|func
operator|->
name|cleanup_led
operator|=
name|e1000_cleanup_led_82541
expr_stmt|;
comment|/* turn on/off LED */
name|func
operator|->
name|led_on
operator|=
name|e1000_led_on_generic
expr_stmt|;
name|func
operator|->
name|led_off
operator|=
name|e1000_led_off_generic
expr_stmt|;
comment|/* remove device */
name|func
operator|->
name|remove_device
operator|=
name|e1000_remove_device_generic
expr_stmt|;
comment|/* clear hardware counters */
name|func
operator|->
name|clear_hw_cntrs
operator|=
name|e1000_clear_hw_cntrs_82541
expr_stmt|;
name|hw
operator|->
name|dev_spec_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|e1000_dev_spec_82541
argument_list|)
expr_stmt|;
comment|/* Device-specific structure allocation */
name|ret_val
operator|=
name|e1000_alloc_zeroed_dev_spec_struct
argument_list|(
name|hw
argument_list|,
name|hw
operator|->
name|dev_spec_size
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_init_function_pointers_82541 - Init func ptrs.  *  @hw - pointer to the HW structure  *  *  The only function explicitly called by the api module to initialize  *  all function pointers and parameters.  **/
end_comment

begin_function
name|void
name|e1000_init_function_pointers_82541
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"e1000_init_function_pointers_82541"
argument_list|)
expr_stmt|;
name|hw
operator|->
name|func
operator|.
name|init_mac_params
operator|=
name|e1000_init_mac_params_82541
expr_stmt|;
name|hw
operator|->
name|func
operator|.
name|init_nvm_params
operator|=
name|e1000_init_nvm_params_82541
expr_stmt|;
name|hw
operator|->
name|func
operator|.
name|init_phy_params
operator|=
name|e1000_init_phy_params_82541
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  e1000_reset_hw_82541 - Reset hardware  *  @hw - pointer to the HW structure  *  *  This resets the hardware into a known state.  This is a  *  function pointer entry point called by the api module.  **/
end_comment

begin_function
name|STATIC
name|s32
name|e1000_reset_hw_82541
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|ledctl
decl_stmt|,
name|ctrl
decl_stmt|,
name|icr
decl_stmt|,
name|manc
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_reset_hw_82541"
argument_list|)
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Masking off all interrupts\n"
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_IMC
argument_list|,
literal|0xFFFFFFFF
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RCTL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TCTL
argument_list|,
name|E1000_TCTL_PSP
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Delay to allow any outstanding PCI transactions to complete 	 * before resetting the device. 	 */
name|msec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|)
expr_stmt|;
comment|/* Must reset the Phy before resetting the MAC */
if|if
condition|(
operator|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_82541
operator|)
operator|||
operator|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_82547
operator|)
condition|)
block|{
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|,
operator|(
name|ctrl
operator||
name|E1000_CTRL_PHY_RST
operator|)
argument_list|)
expr_stmt|;
name|msec_delay
argument_list|(
literal|5
argument_list|)
expr_stmt|;
block|}
name|DEBUGOUT
argument_list|(
literal|"Issuing a global reset to 82541/82547 MAC\n"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
condition|)
block|{
case|case
name|e1000_82541
case|:
case|case
name|e1000_82541_rev_2
case|:
comment|/* These controllers can't ack the 64-bit write when 		 * issuing the reset, so we use IO-mapping as a 		 * workaround to issue the reset. 		 */
name|E1000_WRITE_REG_IO
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|,
name|ctrl
operator||
name|E1000_CTRL_RST
argument_list|)
expr_stmt|;
break|break;
default|default:
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|,
name|ctrl
operator||
name|E1000_CTRL_RST
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Wait for NVM reload */
name|msec_delay
argument_list|(
literal|20
argument_list|)
expr_stmt|;
comment|/* Disable HW ARPs on ASF enabled adapters */
name|manc
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_MANC
argument_list|)
expr_stmt|;
name|manc
operator|&=
operator|~
name|E1000_MANC_ARP_EN
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_MANC
argument_list|,
name|manc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_82541
operator|)
operator|||
operator|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_82547
operator|)
condition|)
block|{
name|e1000_phy_init_script_82541
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Configure activity LED after Phy reset */
name|ledctl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_LEDCTL
argument_list|)
expr_stmt|;
name|ledctl
operator|&=
name|IGP_ACTIVITY_LED_MASK
expr_stmt|;
name|ledctl
operator||=
operator|(
name|IGP_ACTIVITY_LED_ENABLE
operator||
name|IGP_LED3_MODE
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_LEDCTL
argument_list|,
name|ledctl
argument_list|)
expr_stmt|;
block|}
comment|/* Once again, mask the interrupts */
name|DEBUGOUT
argument_list|(
literal|"Masking off all interrupts\n"
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_IMC
argument_list|,
literal|0xFFFFFFFF
argument_list|)
expr_stmt|;
comment|/* Clear any pending interrupt events. */
name|icr
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_ICR
argument_list|)
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_init_hw_82541 - Initialize hardware  *  @hw - pointer to the HW structure  *  *  This inits the hardware readying it for operation.  This is a  *  function pointer entry point called by the api module.  **/
end_comment

begin_function
name|STATIC
name|s32
name|e1000_init_hw_82541
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_mac_info
modifier|*
name|mac
init|=
operator|&
name|hw
operator|->
name|mac
decl_stmt|;
name|u32
name|i
decl_stmt|,
name|txdctl
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_init_hw_82541"
argument_list|)
expr_stmt|;
comment|/* Initialize identification LED */
name|ret_val
operator|=
name|e1000_id_led_init_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Error initializing identification LED\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Disabling VLAN filtering */
name|DEBUGOUT
argument_list|(
literal|"Initializing the IEEE VLAN\n"
argument_list|)
expr_stmt|;
name|e1000_clear_vfta
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Setup the receive address. */
name|e1000_init_rx_addrs_generic
argument_list|(
name|hw
argument_list|,
name|mac
operator|->
name|rar_entry_count
argument_list|)
expr_stmt|;
comment|/* Zero out the Multicast HASH table */
name|DEBUGOUT
argument_list|(
literal|"Zeroing the MTA\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mac
operator|->
name|mta_reg_count
condition|;
name|i
operator|++
control|)
block|{
name|E1000_WRITE_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|E1000_MTA
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Avoid back to back register writes by adding the register 		 * read (flush).  This is to protect against some strange 		 * bridge configurations that may issue Memory Write Block 		 * (MWB) to our register space. 		 */
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
comment|/* Setup link and flow control */
name|ret_val
operator|=
name|e1000_setup_link
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|txdctl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TXDCTL
argument_list|)
expr_stmt|;
name|txdctl
operator|=
operator|(
name|txdctl
operator|&
operator|~
name|E1000_TXDCTL_WTHRESH
operator|)
operator||
name|E1000_TXDCTL_FULL_TX_DESC_WB
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TXDCTL
argument_list|,
name|txdctl
argument_list|)
expr_stmt|;
comment|/* Clear all of the statistics registers (clear on read).  It is 	 * important that we do this after we have tried to establish link 	 * because the symbol error count will increment wildly if there 	 * is no link. 	 */
name|e1000_clear_hw_cntrs_82541
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  * e1000_get_link_up_info_82541 - Report speed and duplex  * @hw - pointer to the HW structure  * @speed - pointer to speed buffer  * @duplex - pointer to duplex buffer  *  * Retrieve the current speed and duplex configuration.  * This is a function pointer entry point called by the api module.  **/
end_comment

begin_function
name|STATIC
name|s32
name|e1000_get_link_up_info_82541
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
modifier|*
name|speed
parameter_list|,
name|u16
modifier|*
name|duplex
parameter_list|)
block|{
name|struct
name|e1000_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|u16
name|data
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_get_link_up_info_82541"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_get_speed_and_duplex_copper_generic
argument_list|(
name|hw
argument_list|,
name|speed
argument_list|,
name|duplex
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|!
name|phy
operator|->
name|speed_downgraded
condition|)
goto|goto
name|out
goto|;
comment|/* IGP01 PHY may advertise full duplex operation after speed 	 * downgrade even if it is operating at half duplex. 	 * Here we set the duplex settings to match the duplex in the 	 * link partner's capabilities. 	 */
name|ret_val
operator|=
name|e1000_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_AUTONEG_EXP
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|!
operator|(
name|data
operator|&
name|NWAY_ER_LP_NWAY_CAPS
operator|)
condition|)
operator|*
name|duplex
operator|=
name|HALF_DUPLEX
expr_stmt|;
else|else
block|{
name|ret_val
operator|=
name|e1000_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_LP_ABILITY
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|*
name|speed
operator|==
name|SPEED_100
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|data
operator|&
name|NWAY_LPAR_100TX_FD_CAPS
operator|)
condition|)
operator|*
name|duplex
operator|=
name|HALF_DUPLEX
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|speed
operator|==
name|SPEED_10
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|data
operator|&
name|NWAY_LPAR_10T_FD_CAPS
operator|)
condition|)
operator|*
name|duplex
operator|=
name|HALF_DUPLEX
expr_stmt|;
block|}
block|}
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_phy_hw_reset_82541 - PHY hardware reset  *  @hw - pointer to the HW structure  *  *  Verify the reset block is not blocking us from resetting.  Acquire  *  semaphore (if necessary) and read/set/write the device control reset  *  bit in the PHY.  Wait the appropriate delay time for the device to  *  reset and relase the semaphore (if necessary).  *  This is a function pointer entry point called by the api module.  **/
end_comment

begin_function
name|STATIC
name|s32
name|e1000_phy_hw_reset_82541
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|ret_val
decl_stmt|;
name|u32
name|ledctl
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_phy_hw_reset_82541"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_phy_hw_reset_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|e1000_phy_init_script_82541
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_82541
operator|)
operator|||
operator|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_82547
operator|)
condition|)
block|{
comment|/* Configure activity LED after PHY reset */
name|ledctl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_LEDCTL
argument_list|)
expr_stmt|;
name|ledctl
operator|&=
name|IGP_ACTIVITY_LED_MASK
expr_stmt|;
name|ledctl
operator||=
operator|(
name|IGP_ACTIVITY_LED_ENABLE
operator||
name|IGP_LED3_MODE
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_LEDCTL
argument_list|,
name|ledctl
argument_list|)
expr_stmt|;
block|}
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_setup_copper_link_82541 - Configure copper link settings  *  @hw - pointer to the HW structure  *  *  Calls the appropriate function to configure the link for auto-neg or forced  *  speed and duplex.  Then we check for link, once link is established calls  *  to configure collision distance and flow control are called.  If link is  *  not established, we return -E1000_ERR_PHY (-2).  This is a function  *  pointer entry point called by the api module.  **/
end_comment

begin_function
name|STATIC
name|s32
name|e1000_setup_copper_link_82541
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|struct
name|e1000_dev_spec_82541
modifier|*
name|dev_spec
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|u32
name|ctrl
decl_stmt|,
name|ledctl
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_setup_copper_link_82541"
argument_list|)
expr_stmt|;
name|ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|)
expr_stmt|;
name|ctrl
operator||=
name|E1000_CTRL_SLU
expr_stmt|;
name|ctrl
operator|&=
operator|~
operator|(
name|E1000_CTRL_FRCSPD
operator||
name|E1000_CTRL_FRCDPX
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|reset_disable
operator|=
name|FALSE
expr_stmt|;
name|dev_spec
operator|=
operator|(
expr|struct
name|e1000_dev_spec_82541
operator|*
operator|)
name|hw
operator|->
name|dev_spec
expr_stmt|;
comment|/* Earlier revs of the IGP phy require us to force MDI. */
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_82541
operator|||
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_82547
condition|)
block|{
name|dev_spec
operator|->
name|dsp_config
operator|=
name|e1000_dsp_config_disabled
expr_stmt|;
name|phy
operator|->
name|mdix
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|dev_spec
operator|->
name|dsp_config
operator|=
name|e1000_dsp_config_enabled
expr_stmt|;
name|ret_val
operator|=
name|e1000_copper_link_setup_igp
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|autoneg
condition|)
block|{
if|if
condition|(
name|dev_spec
operator|->
name|ffe_config
operator|==
name|e1000_ffe_config_active
condition|)
name|dev_spec
operator|->
name|ffe_config
operator|=
name|e1000_ffe_config_enabled
expr_stmt|;
block|}
comment|/* Configure activity LED after Phy reset */
name|ledctl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_LEDCTL
argument_list|)
expr_stmt|;
name|ledctl
operator|&=
name|IGP_ACTIVITY_LED_MASK
expr_stmt|;
name|ledctl
operator||=
operator|(
name|IGP_ACTIVITY_LED_ENABLE
operator||
name|IGP_LED3_MODE
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_LEDCTL
argument_list|,
name|ledctl
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_setup_copper_link_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_check_for_link_82541 - Check/Store link connection  *  @hw - pointer to the HW structure  *  *  This checks the link condition of the adapter and stores the  *  results in the hw->mac structure. This is a function pointer entry  *  point called by the api module.  **/
end_comment

begin_function
name|STATIC
name|s32
name|e1000_check_for_link_82541
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_mac_info
modifier|*
name|mac
init|=
operator|&
name|hw
operator|->
name|mac
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|boolean_t
name|link
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_check_for_link_82541"
argument_list|)
expr_stmt|;
comment|/* We only want to go out to the PHY registers to see if Auto-Neg 	 * has completed and/or if our link status has changed.  The 	 * get_link_status flag is set upon receiving a Link Status 	 * Change or Rx Sequence Error interrupt. 	 */
if|if
condition|(
operator|!
name|mac
operator|->
name|get_link_status
condition|)
block|{
name|ret_val
operator|=
name|E1000_SUCCESS
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* First we want to see if the MII Status Register reports 	 * link.  If so, then we want to get the current speed/duplex 	 * of the PHY. 	 */
name|ret_val
operator|=
name|e1000_phy_has_link_generic
argument_list|(
name|hw
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
operator|&
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|!
name|link
condition|)
block|{
name|ret_val
operator|=
name|e1000_config_dsp_after_link_change_82541
argument_list|(
name|hw
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
comment|/* No link detected */
block|}
name|mac
operator|->
name|get_link_status
operator|=
name|FALSE
expr_stmt|;
comment|/* Check if there was DownShift, must be checked 	 * immediately after link-up */
name|e1000_check_downshift_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* If we are forcing speed/duplex, then we simply return since 	 * we have already determined whether we have link or not. 	 */
if|if
condition|(
operator|!
name|mac
operator|->
name|autoneg
condition|)
block|{
name|ret_val
operator|=
operator|-
name|E1000_ERR_CONFIG
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ret_val
operator|=
name|e1000_config_dsp_after_link_change_82541
argument_list|(
name|hw
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* Auto-Neg is enabled.  Auto Speed Detection takes care 	 * of MAC speed/duplex configuration.  So we only need to 	 * configure Collision Distance in the MAC. 	 */
name|e1000_config_collision_dist_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Configure Flow Control now that Auto-Neg has completed. 	 * First, we need to restore the desired flow control 	 * settings because we may have had to re-autoneg with a 	 * different link partner. 	 */
name|ret_val
operator|=
name|e1000_config_fc_after_link_up_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Error configuring flow control\n"
argument_list|)
expr_stmt|;
block|}
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_config_dsp_after_link_change_82541 - Config DSP after link  *  @hw - pointer to the HW structure  *  @link_up - boolean flag for link up status  *  *  Return E1000_ERR_PHY when failing to read/write the PHY, else E1000_SUCCESS  *  at any other case.  *  *  82541_rev_2& 82547_rev_2 have the capability to configure the DSP when a  *  gigabit link is achieved to improve link quality.  *  This is a function pointer entry point called by the api module.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_config_dsp_after_link_change_82541
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|boolean_t
name|link_up
parameter_list|)
block|{
name|struct
name|e1000_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|struct
name|e1000_dev_spec_82541
modifier|*
name|dev_spec
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|u32
name|idle_errs
init|=
literal|0
decl_stmt|;
name|u16
name|phy_data
decl_stmt|,
name|phy_saved_data
decl_stmt|,
name|speed
decl_stmt|,
name|duplex
decl_stmt|,
name|i
decl_stmt|;
name|u16
name|ffe_idle_err_timeout
init|=
name|FFE_IDLE_ERR_COUNT_TIMEOUT_20
decl_stmt|;
name|u16
name|dsp_reg_array
index|[
name|IGP01E1000_PHY_CHANNEL_NUM
index|]
init|=
block|{
name|IGP01E1000_PHY_AGC_PARAM_A
block|,
name|IGP01E1000_PHY_AGC_PARAM_B
block|,
name|IGP01E1000_PHY_AGC_PARAM_C
block|,
name|IGP01E1000_PHY_AGC_PARAM_D
block|}
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_config_dsp_after_link_change_82541"
argument_list|)
expr_stmt|;
name|dev_spec
operator|=
operator|(
expr|struct
name|e1000_dev_spec_82541
operator|*
operator|)
name|hw
operator|->
name|dev_spec
expr_stmt|;
if|if
condition|(
name|link_up
condition|)
block|{
name|ret_val
operator|=
name|e1000_get_speed_and_duplex
argument_list|(
name|hw
argument_list|,
operator|&
name|speed
argument_list|,
operator|&
name|duplex
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Error getting link speed and duplex\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|speed
operator|!=
name|SPEED_1000
condition|)
block|{
name|ret_val
operator|=
name|E1000_SUCCESS
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ret_val
operator|=
name|e1000_get_cable_length
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|(
name|dev_spec
operator|->
name|dsp_config
operator|==
name|e1000_dsp_config_enabled
operator|)
operator|&&
name|phy
operator|->
name|min_cable_length
operator|>=
literal|50
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IGP01E1000_PHY_CHANNEL_NUM
condition|;
name|i
operator|++
control|)
block|{
name|ret_val
operator|=
name|e1000_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|dsp_reg_array
index|[
name|i
index|]
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|phy_data
operator|&=
operator|~
name|IGP01E1000_PHY_EDAC_MU_INDEX
expr_stmt|;
name|ret_val
operator|=
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|dsp_reg_array
index|[
name|i
index|]
argument_list|,
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
block|}
name|dev_spec
operator|->
name|dsp_config
operator|=
name|e1000_dsp_config_activated
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|dev_spec
operator|->
name|ffe_config
operator|!=
name|e1000_ffe_config_enabled
operator|)
operator|||
operator|(
name|phy
operator|->
name|min_cable_length
operator|>=
literal|50
operator|)
condition|)
block|{
name|ret_val
operator|=
name|E1000_SUCCESS
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* clear previous idle error counts */
name|ret_val
operator|=
name|e1000_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_1000T_STATUS
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ffe_idle_err_timeout
condition|;
name|i
operator|++
control|)
block|{
name|usec_delay
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_1000T_STATUS
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|idle_errs
operator|+=
operator|(
name|phy_data
operator|&
name|SR_1000T_IDLE_ERROR_CNT
operator|)
expr_stmt|;
if|if
condition|(
name|idle_errs
operator|>
name|SR_1000T_PHY_EXCESSIVE_IDLE_ERR_COUNT
condition|)
block|{
name|dev_spec
operator|->
name|ffe_config
operator|=
name|e1000_ffe_config_active
expr_stmt|;
name|ret_val
operator|=
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_DSP_FFE
argument_list|,
name|IGP01E1000_PHY_DSP_FFE_CM_CP
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
break|break;
block|}
if|if
condition|(
name|idle_errs
condition|)
name|ffe_idle_err_timeout
operator|=
name|FFE_IDLE_ERR_COUNT_TIMEOUT_100
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|dev_spec
operator|->
name|dsp_config
operator|==
name|e1000_dsp_config_activated
condition|)
block|{
comment|/* Save off the current value of register 0x2F5B 			 * to be restored at the end of the routines. */
name|ret_val
operator|=
name|e1000_read_phy_reg
argument_list|(
name|hw
argument_list|,
literal|0x2F5B
argument_list|,
operator|&
name|phy_saved_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
comment|/* Disable the PHY transmitter */
name|ret_val
operator|=
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
literal|0x2F5B
argument_list|,
literal|0x0003
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|msec_delay_irq
argument_list|(
literal|20
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
literal|0x0000
argument_list|,
name|IGP01E1000_IEEE_FORCE_GIG
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IGP01E1000_PHY_CHANNEL_NUM
condition|;
name|i
operator|++
control|)
block|{
name|ret_val
operator|=
name|e1000_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|dsp_reg_array
index|[
name|i
index|]
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|phy_data
operator|&=
operator|~
name|IGP01E1000_PHY_EDAC_MU_INDEX
expr_stmt|;
name|phy_data
operator||=
name|IGP01E1000_PHY_EDAC_SIGN_EXT_9_BITS
expr_stmt|;
name|ret_val
operator|=
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|dsp_reg_array
index|[
name|i
index|]
argument_list|,
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
block|}
name|ret_val
operator|=
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
literal|0x0000
argument_list|,
name|IGP01E1000_IEEE_RESTART_AUTONEG
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|msec_delay_irq
argument_list|(
literal|20
argument_list|)
expr_stmt|;
comment|/* Now enable the transmitter */
name|ret_val
operator|=
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
literal|0x2F5B
argument_list|,
name|phy_saved_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|dev_spec
operator|->
name|dsp_config
operator|=
name|e1000_dsp_config_enabled
expr_stmt|;
block|}
if|if
condition|(
name|dev_spec
operator|->
name|ffe_config
operator|!=
name|e1000_ffe_config_active
condition|)
block|{
name|ret_val
operator|=
name|E1000_SUCCESS
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Save off the current value of register 0x2F5B 		 * to be restored at the end of the routines. */
name|ret_val
operator|=
name|e1000_read_phy_reg
argument_list|(
name|hw
argument_list|,
literal|0x2F5B
argument_list|,
operator|&
name|phy_saved_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
comment|/* Disable the PHY transmitter */
name|ret_val
operator|=
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
literal|0x2F5B
argument_list|,
literal|0x0003
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|msec_delay_irq
argument_list|(
literal|20
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
literal|0x0000
argument_list|,
name|IGP01E1000_IEEE_FORCE_GIG
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|ret_val
operator|=
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_DSP_FFE
argument_list|,
name|IGP01E1000_PHY_DSP_FFE_DEFAULT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|ret_val
operator|=
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
literal|0x0000
argument_list|,
name|IGP01E1000_IEEE_RESTART_AUTONEG
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|msec_delay_irq
argument_list|(
literal|20
argument_list|)
expr_stmt|;
comment|/* Now enable the transmitter */
name|ret_val
operator|=
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
literal|0x2F5B
argument_list|,
name|phy_saved_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|dev_spec
operator|->
name|ffe_config
operator|=
name|e1000_ffe_config_enabled
expr_stmt|;
block|}
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_get_cable_length_igp_82541 - Determine cable length for igp PHY  *  @hw - pointer to the HW structure  *  *  The automatic gain control (agc) normalizes the amplitude of the  *  received signal, adjusting for the attenuation produced by the  *  cable.  By reading the AGC registers, which reperesent the  *  cobination of course and fine gain value, the value can be put  *  into a lookup table to obtain the approximate cable length  *  for each channel.  This is a function pointer entry point called by the  *  api module.  **/
end_comment

begin_function
name|STATIC
name|s32
name|e1000_get_cable_length_igp_82541
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|u16
name|i
decl_stmt|,
name|data
decl_stmt|;
name|u16
name|cur_agc_value
decl_stmt|,
name|agc_value
init|=
literal|0
decl_stmt|;
name|u16
name|min_agc_value
init|=
name|IGP01E1000_AGC_LENGTH_TABLE_SIZE
decl_stmt|;
name|u16
name|agc_reg_array
index|[
name|IGP01E1000_PHY_CHANNEL_NUM
index|]
init|=
block|{
name|IGP01E1000_PHY_AGC_A
block|,
name|IGP01E1000_PHY_AGC_B
block|,
name|IGP01E1000_PHY_AGC_C
block|,
name|IGP01E1000_PHY_AGC_D
block|}
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_get_cable_length_igp_82541"
argument_list|)
expr_stmt|;
comment|/* Read the AGC registers for all channels */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IGP01E1000_PHY_CHANNEL_NUM
condition|;
name|i
operator|++
control|)
block|{
name|ret_val
operator|=
name|e1000_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|agc_reg_array
index|[
name|i
index|]
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|cur_agc_value
operator|=
name|data
operator|>>
name|IGP01E1000_AGC_LENGTH_SHIFT
expr_stmt|;
comment|/* Bounds checking */
if|if
condition|(
operator|(
name|cur_agc_value
operator|>=
name|IGP01E1000_AGC_LENGTH_TABLE_SIZE
operator|-
literal|1
operator|)
operator|||
operator|(
name|cur_agc_value
operator|==
literal|0
operator|)
condition|)
block|{
name|ret_val
operator|=
operator|-
name|E1000_ERR_PHY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|agc_value
operator|+=
name|cur_agc_value
expr_stmt|;
if|if
condition|(
name|min_agc_value
operator|>
name|cur_agc_value
condition|)
name|min_agc_value
operator|=
name|cur_agc_value
expr_stmt|;
block|}
comment|/* Remove the minimal AGC result for length< 50m */
if|if
condition|(
name|agc_value
operator|<
name|IGP01E1000_PHY_CHANNEL_NUM
operator|*
literal|50
condition|)
block|{
name|agc_value
operator|-=
name|min_agc_value
expr_stmt|;
comment|/* Average the three remaining channels for the length. */
name|agc_value
operator|/=
operator|(
name|IGP01E1000_PHY_CHANNEL_NUM
operator|-
literal|1
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Average the channels for the length. */
name|agc_value
operator|/=
name|IGP01E1000_PHY_CHANNEL_NUM
expr_stmt|;
block|}
name|phy
operator|->
name|min_cable_length
operator|=
operator|(
name|e1000_igp_cable_length_table
index|[
name|agc_value
index|]
operator|>
name|IGP01E1000_AGC_RANGE
operator|)
condition|?
operator|(
name|e1000_igp_cable_length_table
index|[
name|agc_value
index|]
operator|-
name|IGP01E1000_AGC_RANGE
operator|)
else|:
literal|0
expr_stmt|;
name|phy
operator|->
name|max_cable_length
operator|=
name|e1000_igp_cable_length_table
index|[
name|agc_value
index|]
operator|+
name|IGP01E1000_AGC_RANGE
expr_stmt|;
name|phy
operator|->
name|cable_length
operator|=
operator|(
name|phy
operator|->
name|min_cable_length
operator|+
name|phy
operator|->
name|max_cable_length
operator|)
operator|/
literal|2
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_set_d3_lplu_state_82541 - Sets low power link up state for D3  *  @hw - pointer to the HW structure  *  @active boolean used to enable/disable lplu  *  *  Success returns 0, Failure returns 1  *  *  The low power link up (lplu) state is set to the power management level D3  *  and SmartSpeed is disabled when active is true, else clear lplu for D3  *  and enable Smartspeed.  LPLU and Smartspeed are mutually exclusive.  LPLU  *  is used during Dx states where the power conservation is most important.  *  During driver activity, SmartSpeed should be enabled so performance is  *  maintained.  This is a function pointer entry point called by the  *  api module.  **/
end_comment

begin_function
name|STATIC
name|s32
name|e1000_set_d3_lplu_state_82541
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|boolean_t
name|active
parameter_list|)
block|{
name|struct
name|e1000_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|u16
name|data
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_set_d3_lplu_state_82541"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
condition|)
block|{
case|case
name|e1000_82541_rev_2
case|:
case|case
name|e1000_82547_rev_2
case|:
break|break;
default|default:
name|ret_val
operator|=
name|e1000_set_d3_lplu_state_generic
argument_list|(
name|hw
argument_list|,
name|active
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
break|break;
block|}
name|ret_val
operator|=
name|e1000_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_GMII_FIFO
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|!
name|active
condition|)
block|{
name|data
operator|&=
operator|~
name|IGP01E1000_GMII_FLEX_SPD
expr_stmt|;
name|ret_val
operator|=
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_GMII_FIFO
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
comment|/* LPLU and SmartSpeed are mutually exclusive.  LPLU is used 		 * during Dx states where the power conservation is most 		 * important.  During driver activity we should enable 		 * SmartSpeed, so performance is maintained. */
if|if
condition|(
name|phy
operator|->
name|smart_speed
operator|==
name|e1000_smart_speed_on
condition|)
block|{
name|ret_val
operator|=
name|e1000_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_CONFIG
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|data
operator||=
name|IGP01E1000_PSCFR_SMART_SPEED
expr_stmt|;
name|ret_val
operator|=
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_CONFIG
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
block|}
elseif|else
if|if
condition|(
name|phy
operator|->
name|smart_speed
operator|==
name|e1000_smart_speed_off
condition|)
block|{
name|ret_val
operator|=
name|e1000_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_CONFIG
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|data
operator|&=
operator|~
name|IGP01E1000_PSCFR_SMART_SPEED
expr_stmt|;
name|ret_val
operator|=
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_CONFIG
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|phy
operator|->
name|autoneg_advertised
operator|==
name|E1000_ALL_SPEED_DUPLEX
operator|)
operator|||
operator|(
name|phy
operator|->
name|autoneg_advertised
operator|==
name|E1000_ALL_NOT_GIG
operator|)
operator|||
operator|(
name|phy
operator|->
name|autoneg_advertised
operator|==
name|E1000_ALL_10_SPEED
operator|)
condition|)
block|{
name|data
operator||=
name|IGP01E1000_GMII_FLEX_SPD
expr_stmt|;
name|ret_val
operator|=
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_GMII_FIFO
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
comment|/* When LPLU is enabled, we should disable SmartSpeed */
name|ret_val
operator|=
name|e1000_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_CONFIG
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|data
operator|&=
operator|~
name|IGP01E1000_PSCFR_SMART_SPEED
expr_stmt|;
name|ret_val
operator|=
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_CONFIG
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_setup_led_82541 - Configures SW controllable LED  *  @hw - pointer to the HW structure  *  *  This prepares the SW controllable LED for use and saves the current state  *  of the LED so it can be later restored.  This is a function pointer entry  *  point called by the api module.  **/
end_comment

begin_function
name|STATIC
name|s32
name|e1000_setup_led_82541
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_dev_spec_82541
modifier|*
name|dev_spec
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_setup_led_82541"
argument_list|)
expr_stmt|;
name|dev_spec
operator|=
operator|(
expr|struct
name|e1000_dev_spec_82541
operator|*
operator|)
name|hw
operator|->
name|dev_spec
expr_stmt|;
name|ret_val
operator|=
name|e1000_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_GMII_FIFO
argument_list|,
operator|&
name|dev_spec
operator|->
name|spd_default
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|ret_val
operator|=
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_GMII_FIFO
argument_list|,
call|(
name|u16
call|)
argument_list|(
name|dev_spec
operator|->
name|spd_default
operator|&
operator|~
name|IGP01E1000_GMII_SPD
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_LEDCTL
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|ledctl_mode1
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_cleanup_led_82541 - Set LED config to default operation  *  @hw - pointer to the HW structure  *  *  Remove the current LED configuration and set the LED configuration  *  to the default value, saved from the EEPROM.  This is a function pointer  *  entry point called by the api module.  **/
end_comment

begin_function
name|STATIC
name|s32
name|e1000_cleanup_led_82541
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_dev_spec_82541
modifier|*
name|dev_spec
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_cleanup_led_82541"
argument_list|)
expr_stmt|;
name|dev_spec
operator|=
operator|(
expr|struct
name|e1000_dev_spec_82541
operator|*
operator|)
name|hw
operator|->
name|dev_spec
expr_stmt|;
name|ret_val
operator|=
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_GMII_FIFO
argument_list|,
name|dev_spec
operator|->
name|spd_default
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_LEDCTL
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|ledctl_default
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_phy_init_script_82541 - Initialize GbE PHY  *  @hw - pointer to the HW structure  *  *  Initializes the IGP PHY.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_phy_init_script_82541
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_dev_spec_82541
modifier|*
name|dev_spec
decl_stmt|;
name|u32
name|ret_val
decl_stmt|;
name|u16
name|phy_saved_data
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_phy_init_script_82541"
argument_list|)
expr_stmt|;
name|dev_spec
operator|=
operator|(
expr|struct
name|e1000_dev_spec_82541
operator|*
operator|)
name|hw
operator|->
name|dev_spec
expr_stmt|;
if|if
condition|(
operator|!
name|dev_spec
operator|->
name|phy_init_script
condition|)
block|{
name|ret_val
operator|=
name|E1000_SUCCESS
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Delay after phy reset to enable NVM configuration to load */
name|msec_delay
argument_list|(
literal|20
argument_list|)
expr_stmt|;
comment|/* Save off the current value of register 0x2F5B to be restored at 	 * the end of this routine. */
name|ret_val
operator|=
name|e1000_read_phy_reg
argument_list|(
name|hw
argument_list|,
literal|0x2F5B
argument_list|,
operator|&
name|phy_saved_data
argument_list|)
expr_stmt|;
comment|/* Disabled the PHY transmitter */
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
literal|0x2F5B
argument_list|,
literal|0x0003
argument_list|)
expr_stmt|;
name|msec_delay
argument_list|(
literal|20
argument_list|)
expr_stmt|;
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
literal|0x0000
argument_list|,
literal|0x0140
argument_list|)
expr_stmt|;
name|msec_delay
argument_list|(
literal|5
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
condition|)
block|{
case|case
name|e1000_82541
case|:
case|case
name|e1000_82547
case|:
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
literal|0x1F95
argument_list|,
literal|0x0001
argument_list|)
expr_stmt|;
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
literal|0x1F71
argument_list|,
literal|0xBD21
argument_list|)
expr_stmt|;
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
literal|0x1F79
argument_list|,
literal|0x0018
argument_list|)
expr_stmt|;
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
literal|0x1F30
argument_list|,
literal|0x1600
argument_list|)
expr_stmt|;
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
literal|0x1F31
argument_list|,
literal|0x0014
argument_list|)
expr_stmt|;
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
literal|0x1F32
argument_list|,
literal|0x161C
argument_list|)
expr_stmt|;
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
literal|0x1F94
argument_list|,
literal|0x0003
argument_list|)
expr_stmt|;
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
literal|0x1F96
argument_list|,
literal|0x003F
argument_list|)
expr_stmt|;
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
literal|0x2010
argument_list|,
literal|0x0008
argument_list|)
expr_stmt|;
break|break;
case|case
name|e1000_82541_rev_2
case|:
case|case
name|e1000_82547_rev_2
case|:
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
literal|0x1F73
argument_list|,
literal|0x0099
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
literal|0x0000
argument_list|,
literal|0x3300
argument_list|)
expr_stmt|;
name|msec_delay
argument_list|(
literal|20
argument_list|)
expr_stmt|;
comment|/* Now enable the transmitter */
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
literal|0x2F5B
argument_list|,
name|phy_saved_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_82547
condition|)
block|{
name|u16
name|fused
decl_stmt|,
name|fine
decl_stmt|,
name|coarse
decl_stmt|;
comment|/* Move to analog registers page */
name|e1000_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_ANALOG_SPARE_FUSE_STATUS
argument_list|,
operator|&
name|fused
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|fused
operator|&
name|IGP01E1000_ANALOG_SPARE_FUSE_ENABLED
operator|)
condition|)
block|{
name|e1000_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_ANALOG_FUSE_STATUS
argument_list|,
operator|&
name|fused
argument_list|)
expr_stmt|;
name|fine
operator|=
name|fused
operator|&
name|IGP01E1000_ANALOG_FUSE_FINE_MASK
expr_stmt|;
name|coarse
operator|=
name|fused
operator|&
name|IGP01E1000_ANALOG_FUSE_COARSE_MASK
expr_stmt|;
if|if
condition|(
name|coarse
operator|>
name|IGP01E1000_ANALOG_FUSE_COARSE_THRESH
condition|)
block|{
name|coarse
operator|-=
name|IGP01E1000_ANALOG_FUSE_COARSE_10
expr_stmt|;
name|fine
operator|-=
name|IGP01E1000_ANALOG_FUSE_FINE_1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|coarse
operator|==
name|IGP01E1000_ANALOG_FUSE_COARSE_THRESH
condition|)
name|fine
operator|-=
name|IGP01E1000_ANALOG_FUSE_FINE_10
expr_stmt|;
name|fused
operator|=
operator|(
name|fused
operator|&
name|IGP01E1000_ANALOG_FUSE_POLY_MASK
operator|)
operator||
operator|(
name|fine
operator|&
name|IGP01E1000_ANALOG_FUSE_FINE_MASK
operator|)
operator||
operator|(
name|coarse
operator|&
name|IGP01E1000_ANALOG_FUSE_COARSE_MASK
operator|)
expr_stmt|;
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_ANALOG_FUSE_CONTROL
argument_list|,
name|fused
argument_list|)
expr_stmt|;
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_ANALOG_FUSE_BYPASS
argument_list|,
name|IGP01E1000_ANALOG_FUSE_ENABLE_SW_CONTROL
argument_list|)
expr_stmt|;
block|}
block|}
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_init_script_state_82541 - Enable/Disable PHY init script  *  @hw - pointer to the HW structure  *  @state - boolean value used to enable/disable PHY init script  *  *  Allows the driver to enable/disable the PHY init script, if the PHY is an  *  IGP PHY.  This is a function pointer entry point called by the api module.  **/
end_comment

begin_function
name|void
name|e1000_init_script_state_82541
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|boolean_t
name|state
parameter_list|)
block|{
name|struct
name|e1000_dev_spec_82541
modifier|*
name|dev_spec
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_init_script_state_82541"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|type
operator|!=
name|e1000_phy_igp
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Initialization script not necessary.\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|dev_spec
operator|=
operator|(
expr|struct
name|e1000_dev_spec_82541
operator|*
operator|)
name|hw
operator|->
name|dev_spec
expr_stmt|;
if|if
condition|(
name|dev_spec
operator|==
name|NULL
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"dev_spec pointer is set to NULL.\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|dev_spec
operator|->
name|phy_init_script
operator|=
name|state
expr_stmt|;
name|out
label|:
return|return;
block|}
end_function

begin_comment
comment|/**  *  e1000_clear_hw_cntrs_82541 - Clear device specific hardware counters  *  @hw - pointer to the HW structure  *  *  Clears the hardware counters by reading the counter registers.  **/
end_comment

begin_function
name|STATIC
name|void
name|e1000_clear_hw_cntrs_82541
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
specifier|volatile
name|u32
name|temp
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_clear_hw_cntrs_82541"
argument_list|)
expr_stmt|;
name|e1000_clear_hw_cntrs_base_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PRC64
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PRC127
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PRC255
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PRC511
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PRC1023
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PRC1522
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PTC64
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PTC127
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PTC255
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PTC511
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PTC1023
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PTC1522
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_ALGNERRC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RXERRC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TNCRS
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CEXTERR
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TSCTC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TSCTFC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_MGTPRC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_MGTPDC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_MGTPTC
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

