begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*******************************************************************************    Copyright (c) 2001-2002, Intel Corporation    All rights reserved.      Redistribution and use in source and binary forms, with or without    modification, are permitted provided that the following conditions are met:       1. Redistributions of source code must retain the above copyright notice,        this list of conditions and the following disclaimer.       2. Redistributions in binary form must reproduce the above copyright        notice, this list of conditions and the following disclaimer in the        documentation and/or other materials provided with the distribution.       3. Neither the name of the Intel Corporation nor the names of its        contributors may be used to endorse or promote products derived from        this software without specific prior written permission.      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE    ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR    CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF    SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN    CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)    ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE   POSSIBILITY OF SUCH DAMAGE.  *******************************************************************************/
end_comment

begin_comment
comment|/*$FreeBSD$*/
end_comment

begin_comment
comment|/* if_em_hw.c  * Shared functions for accessing and configuring the MAC  */
end_comment

begin_include
include|#
directive|include
file|<dev/em/if_em_hw.h>
end_include

begin_function_decl
specifier|static
name|int32_t
name|em_setup_fiber_link
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|em_setup_copper_link
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|em_phy_force_speed_duplex
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|em_config_mac_to_phy
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|em_force_mac_fc
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_raise_mdi_clk
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint32_t
modifier|*
name|ctrl
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_lower_mdi_clk
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint32_t
modifier|*
name|ctrl
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_shift_out_mdi_bits
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint32_t
name|data
parameter_list|,
name|uint16_t
name|count
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint16_t
name|em_shift_in_mdi_bits
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|em_phy_reset_dsp
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_raise_ee_clk
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint32_t
modifier|*
name|eecd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_lower_ee_clk
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint32_t
modifier|*
name|eecd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_shift_out_ee_bits
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint16_t
name|data
parameter_list|,
name|uint16_t
name|count
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint16_t
name|em_shift_in_ee_bits
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_setup_eeprom
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_clock_eeprom
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_cleanup_eeprom
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_standby_eeprom
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|em_id_led_init
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/******************************************************************************  * Set the mac type member in the hw struct.  *   * hw - Struct containing variables accessed by shared code  *****************************************************************************/
end_comment

begin_function
name|int32_t
name|em_set_mac_type
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"em_set_mac_type"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|hw
operator|->
name|device_id
condition|)
block|{
case|case
name|E1000_DEV_ID_82542
case|:
switch|switch
condition|(
name|hw
operator|->
name|revision_id
condition|)
block|{
case|case
name|E1000_82542_2_0_REV_ID
case|:
name|hw
operator|->
name|mac_type
operator|=
name|em_82542_rev2_0
expr_stmt|;
break|break;
case|case
name|E1000_82542_2_1_REV_ID
case|:
name|hw
operator|->
name|mac_type
operator|=
name|em_82542_rev2_1
expr_stmt|;
break|break;
default|default:
comment|/* Invalid 82542 revision ID */
return|return
operator|-
name|E1000_ERR_MAC_TYPE
return|;
block|}
break|break;
case|case
name|E1000_DEV_ID_82543GC_FIBER
case|:
case|case
name|E1000_DEV_ID_82543GC_COPPER
case|:
name|hw
operator|->
name|mac_type
operator|=
name|em_82543
expr_stmt|;
break|break;
case|case
name|E1000_DEV_ID_82544EI_COPPER
case|:
case|case
name|E1000_DEV_ID_82544EI_FIBER
case|:
case|case
name|E1000_DEV_ID_82544GC_COPPER
case|:
case|case
name|E1000_DEV_ID_82544GC_LOM
case|:
name|hw
operator|->
name|mac_type
operator|=
name|em_82544
expr_stmt|;
break|break;
case|case
name|E1000_DEV_ID_82540EM
case|:
case|case
name|E1000_DEV_ID_82540EM_LOM
case|:
case|case
name|E1000_DEV_ID_82540EP
case|:
case|case
name|E1000_DEV_ID_82540EP_LOM
case|:
case|case
name|E1000_DEV_ID_82540EP_LP
case|:
name|hw
operator|->
name|mac_type
operator|=
name|em_82540
expr_stmt|;
break|break;
case|case
name|E1000_DEV_ID_82545EM_COPPER
case|:
case|case
name|E1000_DEV_ID_82545EM_FIBER
case|:
name|hw
operator|->
name|mac_type
operator|=
name|em_82545
expr_stmt|;
break|break;
case|case
name|E1000_DEV_ID_82546EB_COPPER
case|:
case|case
name|E1000_DEV_ID_82546EB_FIBER
case|:
name|hw
operator|->
name|mac_type
operator|=
name|em_82546
expr_stmt|;
break|break;
default|default:
comment|/* Should never have loaded on this device */
return|return
operator|-
name|E1000_ERR_MAC_TYPE
return|;
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Reset the transmit and receive units; mask and clear all interrupts.  *  * hw - Struct containing variables accessed by shared code  *****************************************************************************/
end_comment

begin_function
name|void
name|em_reset_hw
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|uint32_t
name|ctrl
decl_stmt|;
name|uint32_t
name|ctrl_ext
decl_stmt|;
name|uint32_t
name|icr
decl_stmt|;
name|uint32_t
name|manc
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_reset_hw"
argument_list|)
expr_stmt|;
comment|/* For 82542 (rev 2.0), disable MWI before issuing a device reset */
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|==
name|em_82542_rev2_0
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Disabling MWI on 82542 rev 2.0\n"
argument_list|)
expr_stmt|;
name|em_pci_clear_mwi
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
comment|/* Clear interrupt mask to stop board from generating interrupts */
name|DEBUGOUT
argument_list|(
literal|"Masking off all interrupts\n"
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IMC
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
comment|/* Disable the Transmit and Receive units.  Then delay to allow      * any pending transactions to complete before we hit the MAC with      * the global reset.      */
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|RCTL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|TCTL
argument_list|,
name|E1000_TCTL_PSP
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* The tbi_compatibility_on Flag must be cleared when Rctl is cleared. */
name|hw
operator|->
name|tbi_compatibility_on
operator|=
name|FALSE
expr_stmt|;
comment|/* Delay to allow any outstanding PCI transactions to complete before      * resetting the device      */
name|msec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
comment|/* Issue a global reset to the MAC.  This will reset the chip's      * transmit, receive, DMA, and link units.  It will not effect      * the current PCI configuration.  The global reset bit is self-      * clearing, and should clear within a microsecond.      */
name|DEBUGOUT
argument_list|(
literal|"Issuing a global reset to MAC\n"
argument_list|)
expr_stmt|;
name|ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|>
name|em_82543
condition|)
name|E1000_WRITE_REG_IO
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|,
operator|(
name|ctrl
operator||
name|E1000_CTRL_RST
operator|)
argument_list|)
expr_stmt|;
else|else
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|,
operator|(
name|ctrl
operator||
name|E1000_CTRL_RST
operator|)
argument_list|)
expr_stmt|;
comment|/* Force a reload from the EEPROM if necessary */
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|<
name|em_82540
condition|)
block|{
comment|/* Wait for reset to complete */
name|usec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|ctrl_ext
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|CTRL_EXT
argument_list|)
expr_stmt|;
name|ctrl_ext
operator||=
name|E1000_CTRL_EXT_EE_RST
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|CTRL_EXT
argument_list|,
name|ctrl_ext
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Wait for EEPROM reload */
name|msec_delay
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Wait for EEPROM reload (it happens automatically) */
name|msec_delay
argument_list|(
literal|4
argument_list|)
expr_stmt|;
comment|/* Dissable HW ARPs on ASF enabled adapters */
name|manc
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|MANC
argument_list|)
expr_stmt|;
name|manc
operator|&=
operator|~
operator|(
name|E1000_MANC_ARP_EN
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|MANC
argument_list|,
name|manc
argument_list|)
expr_stmt|;
block|}
comment|/* Clear interrupt mask to stop board from generating interrupts */
name|DEBUGOUT
argument_list|(
literal|"Masking off all interrupts\n"
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IMC
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
comment|/* Clear any pending interrupt events. */
name|icr
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|ICR
argument_list|)
expr_stmt|;
comment|/* If MWI was previously enabled, reenable it. */
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|==
name|em_82542_rev2_0
condition|)
block|{
if|if
condition|(
name|hw
operator|->
name|pci_cmd_word
operator|&
name|CMD_MEM_WRT_INVALIDATE
condition|)
name|em_pci_set_mwi
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/******************************************************************************  * Performs basic configuration of the adapter.  *  * hw - Struct containing variables accessed by shared code  *   * Assumes that the controller has previously been reset and is in a   * post-reset uninitialized state. Initializes the receive address registers,  * multicast table, and VLAN filter table. Calls routines to setup link  * configuration and flow control settings. Clears all on-chip counters. Leaves  * the transmit and receive units disabled and uninitialized.  *****************************************************************************/
end_comment

begin_function
name|int32_t
name|em_init_hw
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|uint32_t
name|ctrl
decl_stmt|,
name|status
decl_stmt|;
name|uint32_t
name|i
decl_stmt|;
name|int32_t
name|ret_val
decl_stmt|;
name|uint16_t
name|pcix_cmd_word
decl_stmt|;
name|uint16_t
name|pcix_stat_hi_word
decl_stmt|;
name|uint16_t
name|cmd_mmrbc
decl_stmt|;
name|uint16_t
name|stat_mmrbc
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_init_hw"
argument_list|)
expr_stmt|;
comment|/* Initialize Identification LED */
name|ret_val
operator|=
name|em_id_led_init
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
operator|<
literal|0
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Error Initializing Identification LED\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
comment|/* Set the Media Type and exit with error if it is not valid. */
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|!=
name|em_82543
condition|)
block|{
comment|/* tbi_compatibility is only valid on 82543 */
name|hw
operator|->
name|tbi_compatibility_en
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|>=
name|em_82543
condition|)
block|{
name|status
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|E1000_STATUS_TBIMODE
condition|)
block|{
name|hw
operator|->
name|media_type
operator|=
name|em_media_type_fiber
expr_stmt|;
comment|/* tbi_compatibility not valid on fiber */
name|hw
operator|->
name|tbi_compatibility_en
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
name|hw
operator|->
name|media_type
operator|=
name|em_media_type_copper
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* This is an 82542 (fiber only) */
name|hw
operator|->
name|media_type
operator|=
name|em_media_type_fiber
expr_stmt|;
block|}
comment|/* Disabling VLAN filtering. */
name|DEBUGOUT
argument_list|(
literal|"Initializing the IEEE VLAN\n"
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|VET
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|em_clear_vfta
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* For 82542 (rev 2.0), disable MWI and put the receiver into reset */
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|==
name|em_82542_rev2_0
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Disabling MWI on 82542 rev 2.0\n"
argument_list|)
expr_stmt|;
name|em_pci_clear_mwi
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|RCTL
argument_list|,
name|E1000_RCTL_RST
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|msec_delay
argument_list|(
literal|5
argument_list|)
expr_stmt|;
block|}
comment|/* Setup the receive address. This involves initializing all of the Receive      * Address Registers (RARs 0 - 15).      */
name|em_init_rx_addrs
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* For 82542 (rev 2.0), take the receiver out of reset and enable MWI */
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|==
name|em_82542_rev2_0
condition|)
block|{
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|RCTL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|msec_delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|pci_cmd_word
operator|&
name|CMD_MEM_WRT_INVALIDATE
condition|)
name|em_pci_set_mwi
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
comment|/* Zero out the Multicast HASH table */
name|DEBUGOUT
argument_list|(
literal|"Zeroing the MTA\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|E1000_MC_TBL_SIZE
condition|;
name|i
operator|++
control|)
name|E1000_WRITE_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|MTA
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Set the PCI priority bit correctly in the CTRL register.  This      * determines if the adapter gives priority to receives, or if it      * gives equal priority to transmits and receives.      */
if|if
condition|(
name|hw
operator|->
name|dma_fairness
condition|)
block|{
name|ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|,
name|ctrl
operator||
name|E1000_CTRL_PRIOR
argument_list|)
expr_stmt|;
block|}
comment|/* Workaround for PCI-X problem when BIOS sets MMRBC incorrectly. */
if|if
condition|(
name|hw
operator|->
name|bus_type
operator|==
name|em_bus_type_pcix
condition|)
block|{
name|em_read_pci_cfg
argument_list|(
name|hw
argument_list|,
name|PCIX_COMMAND_REGISTER
argument_list|,
operator|&
name|pcix_cmd_word
argument_list|)
expr_stmt|;
name|em_read_pci_cfg
argument_list|(
name|hw
argument_list|,
name|PCIX_STATUS_REGISTER_HI
argument_list|,
operator|&
name|pcix_stat_hi_word
argument_list|)
expr_stmt|;
name|cmd_mmrbc
operator|=
operator|(
name|pcix_cmd_word
operator|&
name|PCIX_COMMAND_MMRBC_MASK
operator|)
operator|>>
name|PCIX_COMMAND_MMRBC_SHIFT
expr_stmt|;
name|stat_mmrbc
operator|=
operator|(
name|pcix_stat_hi_word
operator|&
name|PCIX_STATUS_HI_MMRBC_MASK
operator|)
operator|>>
name|PCIX_STATUS_HI_MMRBC_SHIFT
expr_stmt|;
if|if
condition|(
name|stat_mmrbc
operator|==
name|PCIX_STATUS_HI_MMRBC_4K
condition|)
name|stat_mmrbc
operator|=
name|PCIX_STATUS_HI_MMRBC_2K
expr_stmt|;
if|if
condition|(
name|cmd_mmrbc
operator|>
name|stat_mmrbc
condition|)
block|{
name|pcix_cmd_word
operator|&=
operator|~
name|PCIX_COMMAND_MMRBC_MASK
expr_stmt|;
name|pcix_cmd_word
operator||=
name|stat_mmrbc
operator|<<
name|PCIX_COMMAND_MMRBC_SHIFT
expr_stmt|;
name|em_write_pci_cfg
argument_list|(
name|hw
argument_list|,
name|PCIX_COMMAND_REGISTER
argument_list|,
operator|&
name|pcix_cmd_word
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Call a subroutine to configure the link and setup flow control. */
name|ret_val
operator|=
name|em_setup_link
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Set the transmit descriptor write-back policy */
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|>
name|em_82544
condition|)
block|{
name|ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|TXDCTL
argument_list|)
expr_stmt|;
name|ctrl
operator|=
operator|(
name|ctrl
operator|&
operator|~
name|E1000_TXDCTL_WTHRESH
operator|)
operator||
name|E1000_TXDCTL_FULL_TX_DESC_WB
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|TXDCTL
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
block|}
comment|/* Clear all of the statistics registers (clear on read).  It is      * important that we do this after we have tried to establish link      * because the symbol error count will increment wildly if there      * is no link.      */
name|em_clear_hw_cntrs
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Configures flow control and link settings.  *   * hw - Struct containing variables accessed by shared code  *   * Determines which flow control settings to use. Calls the apropriate media-  * specific link configuration function. Configures the flow control settings.  * Assuming the adapter has a valid link partner, a valid link should be  * established. Assumes the hardware has previously been reset and the   * transmitter and receiver are not enabled.  *****************************************************************************/
end_comment

begin_function
name|int32_t
name|em_setup_link
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|uint32_t
name|ctrl_ext
decl_stmt|;
name|int32_t
name|ret_val
decl_stmt|;
name|uint16_t
name|eeprom_data
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_setup_link"
argument_list|)
expr_stmt|;
comment|/* Read and store word 0x0F of the EEPROM. This word contains bits      * that determine the hardware's default PAUSE (flow control) mode,      * a bit that determines whether the HW defaults to enabling or      * disabling auto-negotiation, and the direction of the      * SW defined pins. If there is no SW over-ride of the flow      * control setting, then the variable hw->fc will      * be initialized based on a value in the EEPROM.      */
if|if
condition|(
name|em_read_eeprom
argument_list|(
name|hw
argument_list|,
name|EEPROM_INIT_CONTROL2_REG
argument_list|,
operator|&
name|eeprom_data
argument_list|)
operator|<
literal|0
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"EEPROM Read Error\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_EEPROM
return|;
block|}
if|if
condition|(
name|hw
operator|->
name|fc
operator|==
name|em_fc_default
condition|)
block|{
if|if
condition|(
operator|(
name|eeprom_data
operator|&
name|EEPROM_WORD0F_PAUSE_MASK
operator|)
operator|==
literal|0
condition|)
name|hw
operator|->
name|fc
operator|=
name|em_fc_none
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|eeprom_data
operator|&
name|EEPROM_WORD0F_PAUSE_MASK
operator|)
operator|==
name|EEPROM_WORD0F_ASM_DIR
condition|)
name|hw
operator|->
name|fc
operator|=
name|em_fc_tx_pause
expr_stmt|;
else|else
name|hw
operator|->
name|fc
operator|=
name|em_fc_full
expr_stmt|;
block|}
comment|/* We want to save off the original Flow Control configuration just      * in case we get disconnected and then reconnected into a different      * hub or switch with different Flow Control capabilities.      */
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|==
name|em_82542_rev2_0
condition|)
name|hw
operator|->
name|fc
operator|&=
operator|(
operator|~
name|em_fc_tx_pause
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|hw
operator|->
name|mac_type
operator|<
name|em_82543
operator|)
operator|&&
operator|(
name|hw
operator|->
name|report_tx_early
operator|==
literal|1
operator|)
condition|)
name|hw
operator|->
name|fc
operator|&=
operator|(
operator|~
name|em_fc_rx_pause
operator|)
expr_stmt|;
name|hw
operator|->
name|original_fc
operator|=
name|hw
operator|->
name|fc
expr_stmt|;
name|DEBUGOUT1
argument_list|(
literal|"After fix-ups FlowControl is now = %x\n"
argument_list|,
name|hw
operator|->
name|fc
argument_list|)
expr_stmt|;
comment|/* Take the 4 bits from EEPROM word 0x0F that determine the initial      * polarity value for the SW controlled pins, and setup the      * Extended Device Control reg with that info.      * This is needed because one of the SW controlled pins is used for      * signal detection.  So this should be done before em_setup_pcs_link()      * or em_phy_setup() is called.      */
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|==
name|em_82543
condition|)
block|{
name|ctrl_ext
operator|=
operator|(
operator|(
name|eeprom_data
operator|&
name|EEPROM_WORD0F_SWPDIO_EXT
operator|)
operator|<<
name|SWDPIO__EXT_SHIFT
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|CTRL_EXT
argument_list|,
name|ctrl_ext
argument_list|)
expr_stmt|;
block|}
comment|/* Call the necessary subroutine to configure the link. */
name|ret_val
operator|=
operator|(
name|hw
operator|->
name|media_type
operator|==
name|em_media_type_fiber
operator|)
condition|?
name|em_setup_fiber_link
argument_list|(
name|hw
argument_list|)
else|:
name|em_setup_copper_link
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Initialize the flow control address, type, and PAUSE timer      * registers to their default values.  This is done even if flow      * control is disabled, because it does not hurt anything to      * initialize these registers.      */
name|DEBUGOUT
argument_list|(
literal|"Initializing the Flow Control address, type and timer regs\n"
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|FCAL
argument_list|,
name|FLOW_CONTROL_ADDRESS_LOW
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|FCAH
argument_list|,
name|FLOW_CONTROL_ADDRESS_HIGH
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|FCT
argument_list|,
name|FLOW_CONTROL_TYPE
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|FCTTV
argument_list|,
name|hw
operator|->
name|fc_pause_time
argument_list|)
expr_stmt|;
comment|/* Set the flow control receive threshold registers.  Normally,      * these registers will be set to a default threshold that may be      * adjusted later by the driver's runtime code.  However, if the      * ability to transmit pause frames in not enabled, then these      * registers will be set to 0.       */
if|if
condition|(
operator|!
operator|(
name|hw
operator|->
name|fc
operator|&
name|em_fc_tx_pause
operator|)
condition|)
block|{
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|FCRTL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|FCRTH
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* We need to set up the Receive Threshold high and low water marks          * as well as (optionally) enabling the transmission of XON frames.          */
if|if
condition|(
name|hw
operator|->
name|fc_send_xon
condition|)
block|{
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|FCRTL
argument_list|,
operator|(
name|hw
operator|->
name|fc_low_water
operator||
name|E1000_FCRTL_XONE
operator|)
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|FCRTH
argument_list|,
name|hw
operator|->
name|fc_high_water
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|FCRTL
argument_list|,
name|hw
operator|->
name|fc_low_water
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|FCRTH
argument_list|,
name|hw
operator|->
name|fc_high_water
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Sets up link for a fiber based adapter  *  * hw - Struct containing variables accessed by shared code  *  * Manipulates Physical Coding Sublayer functions in order to configure  * link. Assumes the hardware has been previously reset and the transmitter  * and receiver are not enabled.  *****************************************************************************/
end_comment

begin_function
specifier|static
name|int32_t
name|em_setup_fiber_link
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|uint32_t
name|ctrl
decl_stmt|;
name|uint32_t
name|status
decl_stmt|;
name|uint32_t
name|txcw
init|=
literal|0
decl_stmt|;
name|uint32_t
name|i
decl_stmt|;
name|uint32_t
name|signal
decl_stmt|;
name|int32_t
name|ret_val
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_setup_fiber_link"
argument_list|)
expr_stmt|;
comment|/* On adapters with a MAC newer that 82544, SW Defineable pin 1 will be       * set when the optics detect a signal. On older adapters, it will be       * cleared when there is a signal      */
name|ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|>
name|em_82544
condition|)
name|signal
operator|=
name|E1000_CTRL_SWDPIN1
expr_stmt|;
else|else
name|signal
operator|=
literal|0
expr_stmt|;
comment|/* Take the link out of reset */
name|ctrl
operator|&=
operator|~
operator|(
name|E1000_CTRL_LRST
operator|)
expr_stmt|;
name|em_config_collision_dist
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Check for a software override of the flow control settings, and setup      * the device accordingly.  If auto-negotiation is enabled, then software      * will have to set the "PAUSE" bits to the correct value in the Tranmsit      * Config Word Register (TXCW) and re-start auto-negotiation.  However, if      * auto-negotiation is disabled, then software will have to manually       * configure the two flow control enable bits in the CTRL register.      *      * The possible values of the "fc" parameter are:      *      0:  Flow control is completely disabled      *      1:  Rx flow control is enabled (we can receive pause frames, but       *          not send pause frames).      *      2:  Tx flow control is enabled (we can send pause frames but we do      *          not support receiving pause frames).      *      3:  Both Rx and TX flow control (symmetric) are enabled.      */
switch|switch
condition|(
name|hw
operator|->
name|fc
condition|)
block|{
case|case
name|em_fc_none
case|:
comment|/* Flow control is completely disabled by a software over-ride. */
name|txcw
operator|=
operator|(
name|E1000_TXCW_ANE
operator||
name|E1000_TXCW_FD
operator|)
expr_stmt|;
break|break;
case|case
name|em_fc_rx_pause
case|:
comment|/* RX Flow control is enabled and TX Flow control is disabled by a           * software over-ride. Since there really isn't a way to advertise           * that we are capable of RX Pause ONLY, we will advertise that we          * support both symmetric and asymmetric RX PAUSE. Later, we will          *  disable the adapter's ability to send PAUSE frames.          */
name|txcw
operator|=
operator|(
name|E1000_TXCW_ANE
operator||
name|E1000_TXCW_FD
operator||
name|E1000_TXCW_PAUSE_MASK
operator|)
expr_stmt|;
break|break;
case|case
name|em_fc_tx_pause
case|:
comment|/* TX Flow control is enabled, and RX Flow control is disabled, by a           * software over-ride.          */
name|txcw
operator|=
operator|(
name|E1000_TXCW_ANE
operator||
name|E1000_TXCW_FD
operator||
name|E1000_TXCW_ASM_DIR
operator|)
expr_stmt|;
break|break;
case|case
name|em_fc_full
case|:
comment|/* Flow control (both RX and TX) is enabled by a software over-ride. */
name|txcw
operator|=
operator|(
name|E1000_TXCW_ANE
operator||
name|E1000_TXCW_FD
operator||
name|E1000_TXCW_PAUSE_MASK
operator|)
expr_stmt|;
break|break;
default|default:
name|DEBUGOUT
argument_list|(
literal|"Flow control param set incorrectly\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_CONFIG
return|;
break|break;
block|}
comment|/* Since auto-negotiation is enabled, take the link out of reset (the link      * will be in reset, because we previously reset the chip). This will      * restart auto-negotiation.  If auto-neogtiation is successful then the      * link-up status bit will be set and the flow control enable bits (RFCE      * and TFCE) will be set according to their negotiated value.      */
name|DEBUGOUT
argument_list|(
literal|"Auto-negotiation enabled\n"
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|TXCW
argument_list|,
name|txcw
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|hw
operator|->
name|txcw
operator|=
name|txcw
expr_stmt|;
name|msec_delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* If we have a signal (the cable is plugged in) then poll for a "Link-Up"      * indication in the Device Status Register.  Time-out if a link isn't       * seen in 500 milliseconds seconds (Auto-negotiation should complete in       * less than 500 milliseconds even if the other end is doing it in SW).      */
if|if
condition|(
operator|(
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|)
operator|&
name|E1000_CTRL_SWDPIN1
operator|)
operator|==
name|signal
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Looking for Link\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|LINK_UP_TIMEOUT
operator|/
literal|10
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|msec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|status
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|E1000_STATUS_LU
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
operator|(
name|LINK_UP_TIMEOUT
operator|/
literal|10
operator|)
condition|)
block|{
comment|/* AutoNeg failed to achieve a link, so we'll call               * em_check_for_link. This routine will force the link up if we              * detect a signal. This will allow us to communicate with              * non-autonegotiating link partners.              */
name|DEBUGOUT
argument_list|(
literal|"Never got a valid link from auto-neg!!!\n"
argument_list|)
expr_stmt|;
name|hw
operator|->
name|autoneg_failed
operator|=
literal|1
expr_stmt|;
name|ret_val
operator|=
name|em_check_for_link
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
operator|<
literal|0
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Error while checking for link\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
name|hw
operator|->
name|autoneg_failed
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|hw
operator|->
name|autoneg_failed
operator|=
literal|0
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Valid Link Found\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|DEBUGOUT
argument_list|(
literal|"No Signal Detected\n"
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************** * Detects which PHY is present and the speed and duplex * * hw - Struct containing variables accessed by shared code ******************************************************************************/
end_comment

begin_function
specifier|static
name|int32_t
name|em_setup_copper_link
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|uint32_t
name|ctrl
decl_stmt|;
name|int32_t
name|ret_val
decl_stmt|;
name|uint16_t
name|i
decl_stmt|;
name|uint16_t
name|phy_data
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_setup_copper_link"
argument_list|)
expr_stmt|;
name|ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|)
expr_stmt|;
comment|/* With 82543, we need to force speed and duplex on the MAC equal to what      * the PHY speed and duplex configuration is. In addition, we need to      * perform a hardware reset on the PHY to take it out of reset.      */
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|>
name|em_82543
condition|)
block|{
name|ctrl
operator||=
name|E1000_CTRL_SLU
expr_stmt|;
name|ctrl
operator|&=
operator|~
operator|(
name|E1000_CTRL_FRCSPD
operator||
name|E1000_CTRL_FRCDPX
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ctrl
operator||=
operator|(
name|E1000_CTRL_FRCSPD
operator||
name|E1000_CTRL_FRCDPX
operator||
name|E1000_CTRL_SLU
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
name|em_phy_hw_reset
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
comment|/* Make sure we have a valid PHY */
name|ret_val
operator|=
name|em_detect_gig_phy
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
operator|<
literal|0
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Error, did not detect valid phy.\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
name|DEBUGOUT1
argument_list|(
literal|"Phy ID = %x \n"
argument_list|,
name|hw
operator|->
name|phy_id
argument_list|)
expr_stmt|;
comment|/* Enable CRS on TX. This must be set for half-duplex operation. */
if|if
condition|(
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_SPEC_CTRL
argument_list|,
operator|&
name|phy_data
argument_list|)
operator|<
literal|0
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"PHY Read Error\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_PHY
return|;
block|}
name|phy_data
operator||=
name|M88E1000_PSCR_ASSERT_CRS_ON_TX
expr_stmt|;
comment|/* Options:      *   MDI/MDI-X = 0 (default)      *   0 - Auto for all speeds      *   1 - MDI mode      *   2 - MDI-X mode      *   3 - Auto for 1000Base-T only (MDI-X for 10/100Base-T modes)      */
name|phy_data
operator|&=
operator|~
name|M88E1000_PSCR_AUTO_X_MODE
expr_stmt|;
switch|switch
condition|(
name|hw
operator|->
name|mdix
condition|)
block|{
case|case
literal|1
case|:
name|phy_data
operator||=
name|M88E1000_PSCR_MDI_MANUAL_MODE
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|phy_data
operator||=
name|M88E1000_PSCR_MDIX_MANUAL_MODE
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|phy_data
operator||=
name|M88E1000_PSCR_AUTO_X_1000T
expr_stmt|;
break|break;
case|case
literal|0
case|:
default|default:
name|phy_data
operator||=
name|M88E1000_PSCR_AUTO_X_MODE
expr_stmt|;
break|break;
block|}
comment|/* Options:      *   disable_polarity_correction = 0 (default)      *       Automatic Correction for Reversed Cable Polarity      *   0 - Disabled      *   1 - Enabled      */
name|phy_data
operator|&=
operator|~
name|M88E1000_PSCR_POLARITY_REVERSAL
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|disable_polarity_correction
operator|==
literal|1
condition|)
name|phy_data
operator||=
name|M88E1000_PSCR_POLARITY_REVERSAL
expr_stmt|;
if|if
condition|(
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_SPEC_CTRL
argument_list|,
name|phy_data
argument_list|)
operator|<
literal|0
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"PHY Write Error\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_PHY
return|;
block|}
comment|/* Force TX_CLK in the Extended PHY Specific Control Register      * to 25MHz clock.      */
if|if
condition|(
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_EXT_PHY_SPEC_CTRL
argument_list|,
operator|&
name|phy_data
argument_list|)
operator|<
literal|0
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"PHY Read Error\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_PHY
return|;
block|}
name|phy_data
operator||=
name|M88E1000_EPSCR_TX_CLK_25
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|phy_revision
operator|<
name|M88E1011_I_REV_4
condition|)
block|{
comment|/* Configure Master and Slave downshift values */
name|phy_data
operator|&=
operator|~
operator|(
name|M88E1000_EPSCR_MASTER_DOWNSHIFT_MASK
operator||
name|M88E1000_EPSCR_SLAVE_DOWNSHIFT_MASK
operator|)
expr_stmt|;
name|phy_data
operator||=
operator|(
name|M88E1000_EPSCR_MASTER_DOWNSHIFT_1X
operator||
name|M88E1000_EPSCR_SLAVE_DOWNSHIFT_1X
operator|)
expr_stmt|;
if|if
condition|(
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_EXT_PHY_SPEC_CTRL
argument_list|,
name|phy_data
argument_list|)
operator|<
literal|0
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"PHY Write Error\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_PHY
return|;
block|}
block|}
comment|/* SW Reset the PHY so all changes take effect */
name|ret_val
operator|=
name|em_phy_reset
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
operator|<
literal|0
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Error Resetting the PHY\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
comment|/* Options:      *   autoneg = 1 (default)      *      PHY will advertise value(s) parsed from      *      autoneg_advertised and fc      *   autoneg = 0      *      PHY will be set to 10H, 10F, 100H, or 100F      *      depending on value parsed from forced_speed_duplex.      */
comment|/* Is autoneg enabled?  This is enabled by default or by software override.      * If so, call em_phy_setup_autoneg routine to parse the      * autoneg_advertised and fc options. If autoneg is NOT enabled, then the      * user should have provided a speed/duplex override.  If so, then call      * em_phy_force_speed_duplex to parse and set this up.      */
if|if
condition|(
name|hw
operator|->
name|autoneg
condition|)
block|{
comment|/* Perform some bounds checking on the hw->autoneg_advertised          * parameter.  If this variable is zero, then set it to the default.          */
name|hw
operator|->
name|autoneg_advertised
operator|&=
name|AUTONEG_ADVERTISE_SPEED_DEFAULT
expr_stmt|;
comment|/* If autoneg_advertised is zero, we assume it was not defaulted          * by the calling code so we set to advertise full capability.          */
if|if
condition|(
name|hw
operator|->
name|autoneg_advertised
operator|==
literal|0
condition|)
name|hw
operator|->
name|autoneg_advertised
operator|=
name|AUTONEG_ADVERTISE_SPEED_DEFAULT
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Reconfiguring auto-neg advertisement params\n"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|em_phy_setup_autoneg
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
operator|<
literal|0
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Error Setting up Auto-Negotiation\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
name|DEBUGOUT
argument_list|(
literal|"Restarting Auto-Neg\n"
argument_list|)
expr_stmt|;
comment|/* Restart auto-negotiation by setting the Auto Neg Enable bit and          * the Auto Neg Restart bit in the PHY control register.          */
if|if
condition|(
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_CTRL
argument_list|,
operator|&
name|phy_data
argument_list|)
operator|<
literal|0
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"PHY Read Error\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_PHY
return|;
block|}
name|phy_data
operator||=
operator|(
name|MII_CR_AUTO_NEG_EN
operator||
name|MII_CR_RESTART_AUTO_NEG
operator|)
expr_stmt|;
if|if
condition|(
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_CTRL
argument_list|,
name|phy_data
argument_list|)
operator|<
literal|0
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"PHY Write Error\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_PHY
return|;
block|}
comment|/* Does the user want to wait for Auto-Neg to complete here, or          * check at a later time (for example, callback routine).          */
if|if
condition|(
name|hw
operator|->
name|wait_autoneg_complete
condition|)
block|{
name|ret_val
operator|=
name|em_wait_autoneg
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
operator|<
literal|0
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Error while waiting for autoneg to complete\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
block|}
block|}
else|else
block|{
name|DEBUGOUT
argument_list|(
literal|"Forcing speed and duplex\n"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|em_phy_force_speed_duplex
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
operator|<
literal|0
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Error Forcing Speed and Duplex\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
block|}
comment|/* Check link status. Wait up to 100 microseconds for link to become      * valid.      */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_STATUS
argument_list|,
operator|&
name|phy_data
argument_list|)
operator|<
literal|0
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"PHY Read Error\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_PHY
return|;
block|}
if|if
condition|(
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_STATUS
argument_list|,
operator|&
name|phy_data
argument_list|)
operator|<
literal|0
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"PHY Read Error\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_PHY
return|;
block|}
if|if
condition|(
name|phy_data
operator|&
name|MII_SR_LINK_STATUS
condition|)
block|{
comment|/* We have link, so we need to finish the config process:              *   1) Set up the MAC to the current PHY speed/duplex              *      if we are on 82543.  If we              *      are on newer silicon, we only need to configure              *      collision distance in the Transmit Control Register.              *   2) Set up flow control on the MAC to that established with              *      the link partner.              */
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|>=
name|em_82544
condition|)
block|{
name|em_config_collision_dist
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret_val
operator|=
name|em_config_mac_to_phy
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
operator|<
literal|0
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Error configuring MAC to PHY settings\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
block|}
name|ret_val
operator|=
name|em_config_fc_after_link_up
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
operator|<
literal|0
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Error Configuring Flow Control\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
name|DEBUGOUT
argument_list|(
literal|"Valid link established!!!\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|usec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
name|DEBUGOUT
argument_list|(
literal|"Unable to establish link!!!\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************** * Configures PHY autoneg and flow control advertisement settings * * hw - Struct containing variables accessed by shared code ******************************************************************************/
end_comment

begin_function
name|int32_t
name|em_phy_setup_autoneg
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|uint16_t
name|mii_autoneg_adv_reg
decl_stmt|;
name|uint16_t
name|mii_1000t_ctrl_reg
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_phy_setup_autoneg"
argument_list|)
expr_stmt|;
comment|/* Read the MII Auto-Neg Advertisement Register (Address 4). */
if|if
condition|(
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_AUTONEG_ADV
argument_list|,
operator|&
name|mii_autoneg_adv_reg
argument_list|)
operator|<
literal|0
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"PHY Read Error\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_PHY
return|;
block|}
comment|/* Read the MII 1000Base-T Control Register (Address 9). */
if|if
condition|(
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_1000T_CTRL
argument_list|,
operator|&
name|mii_1000t_ctrl_reg
argument_list|)
operator|<
literal|0
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"PHY Read Error\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_PHY
return|;
block|}
comment|/* Need to parse both autoneg_advertised and fc and set up      * the appropriate PHY registers.  First we will parse for      * autoneg_advertised software override.  Since we can advertise      * a plethora of combinations, we need to check each bit      * individually.      */
comment|/* First we clear all the 10/100 mb speed bits in the Auto-Neg      * Advertisement Register (Address 4) and the 1000 mb speed bits in      * the  1000Base-T Control Register (Address 9).      */
name|mii_autoneg_adv_reg
operator|&=
operator|~
name|REG4_SPEED_MASK
expr_stmt|;
name|mii_1000t_ctrl_reg
operator|&=
operator|~
name|REG9_SPEED_MASK
expr_stmt|;
name|DEBUGOUT1
argument_list|(
literal|"autoneg_advertised %x\n"
argument_list|,
name|hw
operator|->
name|autoneg_advertised
argument_list|)
expr_stmt|;
comment|/* Do we want to advertise 10 Mb Half Duplex? */
if|if
condition|(
name|hw
operator|->
name|autoneg_advertised
operator|&
name|ADVERTISE_10_HALF
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Advertise 10mb Half duplex\n"
argument_list|)
expr_stmt|;
name|mii_autoneg_adv_reg
operator||=
name|NWAY_AR_10T_HD_CAPS
expr_stmt|;
block|}
comment|/* Do we want to advertise 10 Mb Full Duplex? */
if|if
condition|(
name|hw
operator|->
name|autoneg_advertised
operator|&
name|ADVERTISE_10_FULL
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Advertise 10mb Full duplex\n"
argument_list|)
expr_stmt|;
name|mii_autoneg_adv_reg
operator||=
name|NWAY_AR_10T_FD_CAPS
expr_stmt|;
block|}
comment|/* Do we want to advertise 100 Mb Half Duplex? */
if|if
condition|(
name|hw
operator|->
name|autoneg_advertised
operator|&
name|ADVERTISE_100_HALF
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Advertise 100mb Half duplex\n"
argument_list|)
expr_stmt|;
name|mii_autoneg_adv_reg
operator||=
name|NWAY_AR_100TX_HD_CAPS
expr_stmt|;
block|}
comment|/* Do we want to advertise 100 Mb Full Duplex? */
if|if
condition|(
name|hw
operator|->
name|autoneg_advertised
operator|&
name|ADVERTISE_100_FULL
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Advertise 100mb Full duplex\n"
argument_list|)
expr_stmt|;
name|mii_autoneg_adv_reg
operator||=
name|NWAY_AR_100TX_FD_CAPS
expr_stmt|;
block|}
comment|/* We do not allow the Phy to advertise 1000 Mb Half Duplex */
if|if
condition|(
name|hw
operator|->
name|autoneg_advertised
operator|&
name|ADVERTISE_1000_HALF
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Advertise 1000mb Half duplex requested, request denied!\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Do we want to advertise 1000 Mb Full Duplex? */
if|if
condition|(
name|hw
operator|->
name|autoneg_advertised
operator|&
name|ADVERTISE_1000_FULL
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Advertise 1000mb Full duplex\n"
argument_list|)
expr_stmt|;
name|mii_1000t_ctrl_reg
operator||=
name|CR_1000T_FD_CAPS
expr_stmt|;
block|}
comment|/* Check for a software override of the flow control settings, and      * setup the PHY advertisement registers accordingly.  If      * auto-negotiation is enabled, then software will have to set the      * "PAUSE" bits to the correct value in the Auto-Negotiation      * Advertisement Register (PHY_AUTONEG_ADV) and re-start auto-negotiation.      *      * The possible values of the "fc" parameter are:      *      0:  Flow control is completely disabled      *      1:  Rx flow control is enabled (we can receive pause frames      *          but not send pause frames).      *      2:  Tx flow control is enabled (we can send pause frames      *          but we do not support receiving pause frames).      *      3:  Both Rx and TX flow control (symmetric) are enabled.      *  other:  No software override.  The flow control configuration      *          in the EEPROM is used.      */
switch|switch
condition|(
name|hw
operator|->
name|fc
condition|)
block|{
case|case
name|em_fc_none
case|:
comment|/* 0 */
comment|/* Flow control (RX& TX) is completely disabled by a          * software over-ride.          */
name|mii_autoneg_adv_reg
operator|&=
operator|~
operator|(
name|NWAY_AR_ASM_DIR
operator||
name|NWAY_AR_PAUSE
operator|)
expr_stmt|;
break|break;
case|case
name|em_fc_rx_pause
case|:
comment|/* 1 */
comment|/* RX Flow control is enabled, and TX Flow control is          * disabled, by a software over-ride.          */
comment|/* Since there really isn't a way to advertise that we are          * capable of RX Pause ONLY, we will advertise that we          * support both symmetric and asymmetric RX PAUSE.  Later          * (in em_config_fc_after_link_up) we will disable the          *hw's ability to send PAUSE frames.          */
name|mii_autoneg_adv_reg
operator||=
operator|(
name|NWAY_AR_ASM_DIR
operator||
name|NWAY_AR_PAUSE
operator|)
expr_stmt|;
break|break;
case|case
name|em_fc_tx_pause
case|:
comment|/* 2 */
comment|/* TX Flow control is enabled, and RX Flow control is          * disabled, by a software over-ride.          */
name|mii_autoneg_adv_reg
operator||=
name|NWAY_AR_ASM_DIR
expr_stmt|;
name|mii_autoneg_adv_reg
operator|&=
operator|~
name|NWAY_AR_PAUSE
expr_stmt|;
break|break;
case|case
name|em_fc_full
case|:
comment|/* 3 */
comment|/* Flow control (both RX and TX) is enabled by a software          * over-ride.          */
name|mii_autoneg_adv_reg
operator||=
operator|(
name|NWAY_AR_ASM_DIR
operator||
name|NWAY_AR_PAUSE
operator|)
expr_stmt|;
break|break;
default|default:
name|DEBUGOUT
argument_list|(
literal|"Flow control param set incorrectly\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_CONFIG
return|;
block|}
if|if
condition|(
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_AUTONEG_ADV
argument_list|,
name|mii_autoneg_adv_reg
argument_list|)
operator|<
literal|0
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"PHY Write Error\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_PHY
return|;
block|}
name|DEBUGOUT1
argument_list|(
literal|"Auto-Neg Advertising %x\n"
argument_list|,
name|mii_autoneg_adv_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_1000T_CTRL
argument_list|,
name|mii_1000t_ctrl_reg
argument_list|)
operator|<
literal|0
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"PHY Write Error\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_PHY
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************** * Force PHY speed and duplex settings to hw->forced_speed_duplex * * hw - Struct containing variables accessed by shared code ******************************************************************************/
end_comment

begin_function
specifier|static
name|int32_t
name|em_phy_force_speed_duplex
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|uint32_t
name|ctrl
decl_stmt|;
name|int32_t
name|ret_val
decl_stmt|;
name|uint16_t
name|mii_ctrl_reg
decl_stmt|;
name|uint16_t
name|mii_status_reg
decl_stmt|;
name|uint16_t
name|phy_data
decl_stmt|;
name|uint16_t
name|i
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_phy_force_speed_duplex"
argument_list|)
expr_stmt|;
comment|/* Turn off Flow control if we are forcing speed and duplex. */
name|hw
operator|->
name|fc
operator|=
name|em_fc_none
expr_stmt|;
name|DEBUGOUT1
argument_list|(
literal|"hw->fc = %d\n"
argument_list|,
name|hw
operator|->
name|fc
argument_list|)
expr_stmt|;
comment|/* Read the Device Control Register. */
name|ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|)
expr_stmt|;
comment|/* Set the bits to Force Speed and Duplex in the Device Ctrl Reg. */
name|ctrl
operator||=
operator|(
name|E1000_CTRL_FRCSPD
operator||
name|E1000_CTRL_FRCDPX
operator|)
expr_stmt|;
name|ctrl
operator|&=
operator|~
operator|(
name|DEVICE_SPEED_MASK
operator|)
expr_stmt|;
comment|/* Clear the Auto Speed Detect Enable bit. */
name|ctrl
operator|&=
operator|~
name|E1000_CTRL_ASDE
expr_stmt|;
comment|/* Read the MII Control Register. */
if|if
condition|(
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_CTRL
argument_list|,
operator|&
name|mii_ctrl_reg
argument_list|)
operator|<
literal|0
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"PHY Read Error\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_PHY
return|;
block|}
comment|/* We need to disable autoneg in order to force link and duplex. */
name|mii_ctrl_reg
operator|&=
operator|~
name|MII_CR_AUTO_NEG_EN
expr_stmt|;
comment|/* Are we forcing Full or Half Duplex? */
if|if
condition|(
name|hw
operator|->
name|forced_speed_duplex
operator|==
name|em_100_full
operator|||
name|hw
operator|->
name|forced_speed_duplex
operator|==
name|em_10_full
condition|)
block|{
comment|/* We want to force full duplex so we SET the full duplex bits in the          * Device and MII Control Registers.          */
name|ctrl
operator||=
name|E1000_CTRL_FD
expr_stmt|;
name|mii_ctrl_reg
operator||=
name|MII_CR_FULL_DUPLEX
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Full Duplex\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* We want to force half duplex so we CLEAR the full duplex bits in          * the Device and MII Control Registers.          */
name|ctrl
operator|&=
operator|~
name|E1000_CTRL_FD
expr_stmt|;
name|mii_ctrl_reg
operator|&=
operator|~
name|MII_CR_FULL_DUPLEX
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Half Duplex\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Are we forcing 100Mbps??? */
if|if
condition|(
name|hw
operator|->
name|forced_speed_duplex
operator|==
name|em_100_full
operator|||
name|hw
operator|->
name|forced_speed_duplex
operator|==
name|em_100_half
condition|)
block|{
comment|/* Set the 100Mb bit and turn off the 1000Mb and 10Mb bits. */
name|ctrl
operator||=
name|E1000_CTRL_SPD_100
expr_stmt|;
name|mii_ctrl_reg
operator||=
name|MII_CR_SPEED_100
expr_stmt|;
name|mii_ctrl_reg
operator|&=
operator|~
operator|(
name|MII_CR_SPEED_1000
operator||
name|MII_CR_SPEED_10
operator|)
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Forcing 100mb "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Set the 10Mb bit and turn off the 1000Mb and 100Mb bits. */
name|ctrl
operator|&=
operator|~
operator|(
name|E1000_CTRL_SPD_1000
operator||
name|E1000_CTRL_SPD_100
operator|)
expr_stmt|;
name|mii_ctrl_reg
operator||=
name|MII_CR_SPEED_10
expr_stmt|;
name|mii_ctrl_reg
operator|&=
operator|~
operator|(
name|MII_CR_SPEED_1000
operator||
name|MII_CR_SPEED_100
operator|)
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Forcing 10mb "
argument_list|)
expr_stmt|;
block|}
name|em_config_collision_dist
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Write the configured values back to the Device Control Reg. */
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
if|if
condition|(
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_SPEC_CTRL
argument_list|,
operator|&
name|phy_data
argument_list|)
operator|<
literal|0
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"PHY Read Error\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_PHY
return|;
block|}
comment|/* Clear Auto-Crossover to force MDI manually. M88E1000 requires MDI      * forced whenever speed are duplex are forced.      */
name|phy_data
operator|&=
operator|~
name|M88E1000_PSCR_AUTO_X_MODE
expr_stmt|;
if|if
condition|(
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_SPEC_CTRL
argument_list|,
name|phy_data
argument_list|)
operator|<
literal|0
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"PHY Write Error\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_PHY
return|;
block|}
name|DEBUGOUT1
argument_list|(
literal|"M88E1000 PSCR: %x \n"
argument_list|,
name|phy_data
argument_list|)
expr_stmt|;
comment|/* Need to reset the PHY or these changes will be ignored */
name|mii_ctrl_reg
operator||=
name|MII_CR_RESET
expr_stmt|;
comment|/* Write back the modified PHY MII control register. */
if|if
condition|(
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_CTRL
argument_list|,
name|mii_ctrl_reg
argument_list|)
operator|<
literal|0
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"PHY Write Error\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_PHY
return|;
block|}
name|usec_delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* The wait_autoneg_complete flag may be a little misleading here.      * Since we are forcing speed and duplex, Auto-Neg is not enabled.      * But we do want to delay for a period while forcing only so we      * don't generate false No Link messages.  So we will wait here      * only if the user has set wait_autoneg_complete to 1, which is      * the default.      */
if|if
condition|(
name|hw
operator|->
name|wait_autoneg_complete
condition|)
block|{
comment|/* We will wait for autoneg to complete. */
name|DEBUGOUT
argument_list|(
literal|"Waiting for forced speed/duplex link.\n"
argument_list|)
expr_stmt|;
name|mii_status_reg
operator|=
literal|0
expr_stmt|;
comment|/* We will wait for autoneg to complete or 4.5 seconds to expire. */
for|for
control|(
name|i
operator|=
name|PHY_FORCE_TIME
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
comment|/* Read the MII Status Register and wait for Auto-Neg Complete bit              * to be set.              */
if|if
condition|(
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_STATUS
argument_list|,
operator|&
name|mii_status_reg
argument_list|)
operator|<
literal|0
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"PHY Read Error\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_PHY
return|;
block|}
if|if
condition|(
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_STATUS
argument_list|,
operator|&
name|mii_status_reg
argument_list|)
operator|<
literal|0
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"PHY Read Error\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_PHY
return|;
block|}
if|if
condition|(
name|mii_status_reg
operator|&
name|MII_SR_LINK_STATUS
condition|)
break|break;
name|msec_delay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
comment|/* We didn't get link */
comment|/* Reset the DSP and wait again for link. */
name|ret_val
operator|=
name|em_phy_reset_dsp
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
operator|<
literal|0
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Error Resetting PHY DSP\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
block|}
comment|/* This loop will early-out if the link condition has been met.  */
for|for
control|(
name|i
operator|=
name|PHY_FORCE_TIME
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|mii_status_reg
operator|&
name|MII_SR_LINK_STATUS
condition|)
break|break;
name|msec_delay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
comment|/* Read the MII Status Register and wait for Auto-Neg Complete bit              * to be set.              */
if|if
condition|(
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_STATUS
argument_list|,
operator|&
name|mii_status_reg
argument_list|)
operator|<
literal|0
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"PHY Read Error\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_PHY
return|;
block|}
if|if
condition|(
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_STATUS
argument_list|,
operator|&
name|mii_status_reg
argument_list|)
operator|<
literal|0
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"PHY Read Error\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_PHY
return|;
block|}
block|}
block|}
comment|/* Because we reset the PHY above, we need to re-force TX_CLK in the      * Extended PHY Specific Control Register to 25MHz clock.  This value      * defaults back to a 2.5MHz clock when the PHY is reset.      */
if|if
condition|(
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_EXT_PHY_SPEC_CTRL
argument_list|,
operator|&
name|phy_data
argument_list|)
operator|<
literal|0
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"PHY Read Error\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_PHY
return|;
block|}
name|phy_data
operator||=
name|M88E1000_EPSCR_TX_CLK_25
expr_stmt|;
if|if
condition|(
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_EXT_PHY_SPEC_CTRL
argument_list|,
name|phy_data
argument_list|)
operator|<
literal|0
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"PHY Write Error\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_PHY
return|;
block|}
comment|/* In addition, because of the s/w reset above, we need to enable CRS on      * TX.  This must be set for both full and half duplex operation.      */
if|if
condition|(
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_SPEC_CTRL
argument_list|,
operator|&
name|phy_data
argument_list|)
operator|<
literal|0
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"PHY Read Error\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_PHY
return|;
block|}
name|phy_data
operator||=
name|M88E1000_PSCR_ASSERT_CRS_ON_TX
expr_stmt|;
if|if
condition|(
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_SPEC_CTRL
argument_list|,
name|phy_data
argument_list|)
operator|<
literal|0
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"PHY Write Error\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_PHY
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************** * Sets the collision distance in the Transmit Control register * * hw - Struct containing variables accessed by shared code * * Link should have been established previously. Reads the speed and duplex * information from the Device Status register. ******************************************************************************/
end_comment

begin_function
name|void
name|em_config_collision_dist
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|uint32_t
name|tctl
decl_stmt|;
name|tctl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|TCTL
argument_list|)
expr_stmt|;
name|tctl
operator|&=
operator|~
name|E1000_TCTL_COLD
expr_stmt|;
name|tctl
operator||=
name|E1000_COLLISION_DISTANCE
operator|<<
name|E1000_COLD_SHIFT
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|TCTL
argument_list|,
name|tctl
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************** * Sets MAC speed and duplex settings to reflect the those in the PHY * * hw - Struct containing variables accessed by shared code * mii_reg - data to write to the MII control register * * The contents of the PHY register containing the needed information need to * be passed in. ******************************************************************************/
end_comment

begin_function
specifier|static
name|int32_t
name|em_config_mac_to_phy
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|uint32_t
name|ctrl
decl_stmt|;
name|uint16_t
name|phy_data
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_config_mac_to_phy"
argument_list|)
expr_stmt|;
comment|/* Read the Device Control Register and set the bits to Force Speed      * and Duplex.      */
name|ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|)
expr_stmt|;
name|ctrl
operator||=
operator|(
name|E1000_CTRL_FRCSPD
operator||
name|E1000_CTRL_FRCDPX
operator|)
expr_stmt|;
name|ctrl
operator|&=
operator|~
operator|(
name|E1000_CTRL_SPD_SEL
operator||
name|E1000_CTRL_ILOS
operator|)
expr_stmt|;
comment|/* Set up duplex in the Device Control and Transmit Control      * registers depending on negotiated values.      */
if|if
condition|(
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_SPEC_STATUS
argument_list|,
operator|&
name|phy_data
argument_list|)
operator|<
literal|0
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"PHY Read Error\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_PHY
return|;
block|}
if|if
condition|(
name|phy_data
operator|&
name|M88E1000_PSSR_DPLX
condition|)
name|ctrl
operator||=
name|E1000_CTRL_FD
expr_stmt|;
else|else
name|ctrl
operator|&=
operator|~
name|E1000_CTRL_FD
expr_stmt|;
name|em_config_collision_dist
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Set up speed in the Device Control register depending on      * negotiated values.      */
if|if
condition|(
operator|(
name|phy_data
operator|&
name|M88E1000_PSSR_SPEED
operator|)
operator|==
name|M88E1000_PSSR_1000MBS
condition|)
name|ctrl
operator||=
name|E1000_CTRL_SPD_1000
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|phy_data
operator|&
name|M88E1000_PSSR_SPEED
operator|)
operator|==
name|M88E1000_PSSR_100MBS
condition|)
name|ctrl
operator||=
name|E1000_CTRL_SPD_100
expr_stmt|;
comment|/* Write the configured values back to the Device Control Reg. */
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Forces the MAC's flow control settings.  *   * hw - Struct containing variables accessed by shared code  *  * Sets the TFCE and RFCE bits in the device control register to reflect  * the adapter settings. TFCE and RFCE need to be explicitly set by  * software when a Copper PHY is used because autonegotiation is managed  * by the PHY rather than the MAC. Software must also configure these  * bits when link is forced on a fiber connection.  *****************************************************************************/
end_comment

begin_function
specifier|static
name|int32_t
name|em_force_mac_fc
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|uint32_t
name|ctrl
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_force_mac_fc"
argument_list|)
expr_stmt|;
comment|/* Get the current configuration of the Device Control Register */
name|ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|)
expr_stmt|;
comment|/* Because we didn't get link via the internal auto-negotiation      * mechanism (we either forced link or we got link via PHY      * auto-neg), we have to manually enable/disable transmit an      * receive flow control.      *      * The "Case" statement below enables/disable flow control      * according to the "hw->fc" parameter.      *      * The possible values of the "fc" parameter are:      *      0:  Flow control is completely disabled      *      1:  Rx flow control is enabled (we can receive pause      *          frames but not send pause frames).      *      2:  Tx flow control is enabled (we can send pause frames      *          frames but we do not receive pause frames).      *      3:  Both Rx and TX flow control (symmetric) is enabled.      *  other:  No other values should be possible at this point.      */
switch|switch
condition|(
name|hw
operator|->
name|fc
condition|)
block|{
case|case
name|em_fc_none
case|:
name|ctrl
operator|&=
operator|(
operator|~
operator|(
name|E1000_CTRL_TFCE
operator||
name|E1000_CTRL_RFCE
operator|)
operator|)
expr_stmt|;
break|break;
case|case
name|em_fc_rx_pause
case|:
name|ctrl
operator|&=
operator|(
operator|~
name|E1000_CTRL_TFCE
operator|)
expr_stmt|;
name|ctrl
operator||=
name|E1000_CTRL_RFCE
expr_stmt|;
break|break;
case|case
name|em_fc_tx_pause
case|:
name|ctrl
operator|&=
operator|(
operator|~
name|E1000_CTRL_RFCE
operator|)
expr_stmt|;
name|ctrl
operator||=
name|E1000_CTRL_TFCE
expr_stmt|;
break|break;
case|case
name|em_fc_full
case|:
name|ctrl
operator||=
operator|(
name|E1000_CTRL_TFCE
operator||
name|E1000_CTRL_RFCE
operator|)
expr_stmt|;
break|break;
default|default:
name|DEBUGOUT
argument_list|(
literal|"Flow control param set incorrectly\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_CONFIG
return|;
block|}
comment|/* Disable TX Flow Control for 82542 (rev 2.0) */
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|==
name|em_82542_rev2_0
condition|)
name|ctrl
operator|&=
operator|(
operator|~
name|E1000_CTRL_TFCE
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Configures flow control settings after link is established  *   * hw - Struct containing variables accessed by shared code  *  * Should be called immediately after a valid link has been established.  * Forces MAC flow control settings if link was forced. When in MII/GMII mode  * and autonegotiation is enabled, the MAC flow control settings will be set  * based on the flow control negotiated by the PHY. In TBI mode, the TFCE  * and RFCE bits will be automaticaly set to the negotiated flow control mode.  *****************************************************************************/
end_comment

begin_function
name|int32_t
name|em_config_fc_after_link_up
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|int32_t
name|ret_val
decl_stmt|;
name|uint16_t
name|mii_status_reg
decl_stmt|;
name|uint16_t
name|mii_nway_adv_reg
decl_stmt|;
name|uint16_t
name|mii_nway_lp_ability_reg
decl_stmt|;
name|uint16_t
name|speed
decl_stmt|;
name|uint16_t
name|duplex
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_config_fc_after_link_up"
argument_list|)
expr_stmt|;
comment|/* Check for the case where we have fiber media and auto-neg failed      * so we had to force link.  In this case, we need to force the      * configuration of the MAC to match the "fc" parameter.      */
if|if
condition|(
operator|(
operator|(
name|hw
operator|->
name|media_type
operator|==
name|em_media_type_fiber
operator|)
operator|&&
operator|(
name|hw
operator|->
name|autoneg_failed
operator|)
operator|)
operator|||
operator|(
operator|(
name|hw
operator|->
name|media_type
operator|==
name|em_media_type_copper
operator|)
operator|&&
operator|(
operator|!
name|hw
operator|->
name|autoneg
operator|)
operator|)
condition|)
block|{
name|ret_val
operator|=
name|em_force_mac_fc
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
operator|<
literal|0
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Error forcing flow control settings\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
block|}
comment|/* Check for the case where we have copper media and auto-neg is      * enabled.  In this case, we need to check and see if Auto-Neg      * has completed, and if so, how the PHY and link partner has      * flow control configured.      */
if|if
condition|(
operator|(
name|hw
operator|->
name|media_type
operator|==
name|em_media_type_copper
operator|)
operator|&&
name|hw
operator|->
name|autoneg
condition|)
block|{
comment|/* Read the MII Status Register and check to see if AutoNeg          * has completed.  We read this twice because this reg has          * some "sticky" (latched) bits.          */
if|if
condition|(
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_STATUS
argument_list|,
operator|&
name|mii_status_reg
argument_list|)
operator|<
literal|0
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"PHY Read Error \n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_PHY
return|;
block|}
if|if
condition|(
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_STATUS
argument_list|,
operator|&
name|mii_status_reg
argument_list|)
operator|<
literal|0
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"PHY Read Error \n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_PHY
return|;
block|}
if|if
condition|(
name|mii_status_reg
operator|&
name|MII_SR_AUTONEG_COMPLETE
condition|)
block|{
comment|/* The AutoNeg process has completed, so we now need to              * read both the Auto Negotiation Advertisement Register              * (Address 4) and the Auto_Negotiation Base Page Ability              * Register (Address 5) to determine how flow control was              * negotiated.              */
if|if
condition|(
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_AUTONEG_ADV
argument_list|,
operator|&
name|mii_nway_adv_reg
argument_list|)
operator|<
literal|0
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"PHY Read Error\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_PHY
return|;
block|}
if|if
condition|(
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_LP_ABILITY
argument_list|,
operator|&
name|mii_nway_lp_ability_reg
argument_list|)
operator|<
literal|0
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"PHY Read Error\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_PHY
return|;
block|}
comment|/* Two bits in the Auto Negotiation Advertisement Register              * (Address 4) and two bits in the Auto Negotiation Base              * Page Ability Register (Address 5) determine flow control              * for both the PHY and the link partner.  The following              * table, taken out of the IEEE 802.3ab/D6.0 dated March 25,              * 1999, describes these PAUSE resolution bits and how flow              * control is determined based upon these settings.              * NOTE:  DC = Don't Care              *              *   LOCAL DEVICE  |   LINK PARTNER              * PAUSE | ASM_DIR | PAUSE | ASM_DIR | NIC Resolution              *-------|---------|-------|---------|--------------------              *   0   |    0    |  DC   |   DC    | em_fc_none              *   0   |    1    |   0   |   DC    | em_fc_none              *   0   |    1    |   1   |    0    | em_fc_none              *   0   |    1    |   1   |    1    | em_fc_tx_pause              *   1   |    0    |   0   |   DC    | em_fc_none              *   1   |   DC    |   1   |   DC    | em_fc_full              *   1   |    1    |   0   |    0    | em_fc_none              *   1   |    1    |   0   |    1    | em_fc_rx_pause              *              */
comment|/* Are both PAUSE bits set to 1?  If so, this implies              * Symmetric Flow Control is enabled at both ends.  The              * ASM_DIR bits are irrelevant per the spec.              *              * For Symmetric Flow Control:              *              *   LOCAL DEVICE  |   LINK PARTNER              * PAUSE | ASM_DIR | PAUSE | ASM_DIR | Result              *-------|---------|-------|---------|--------------------              *   1   |   DC    |   1   |   DC    | em_fc_full              *              */
if|if
condition|(
operator|(
name|mii_nway_adv_reg
operator|&
name|NWAY_AR_PAUSE
operator|)
operator|&&
operator|(
name|mii_nway_lp_ability_reg
operator|&
name|NWAY_LPAR_PAUSE
operator|)
condition|)
block|{
comment|/* Now we need to check if the user selected RX ONLY                  * of pause frames.  In this case, we had to advertise                  * FULL flow control because we could not advertise RX                  * ONLY. Hence, we must now check to see if we need to                  * turn OFF  the TRANSMISSION of PAUSE frames.                  */
if|if
condition|(
name|hw
operator|->
name|original_fc
operator|==
name|em_fc_full
condition|)
block|{
name|hw
operator|->
name|fc
operator|=
name|em_fc_full
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Flow Control = FULL.\r\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|hw
operator|->
name|fc
operator|=
name|em_fc_rx_pause
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Flow Control = RX PAUSE frames only.\r\n"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* For receiving PAUSE frames ONLY.              *              *   LOCAL DEVICE  |   LINK PARTNER              * PAUSE | ASM_DIR | PAUSE | ASM_DIR | Result              *-------|---------|-------|---------|--------------------              *   0   |    1    |   1   |    1    | em_fc_tx_pause              *              */
elseif|else
if|if
condition|(
operator|!
operator|(
name|mii_nway_adv_reg
operator|&
name|NWAY_AR_PAUSE
operator|)
operator|&&
operator|(
name|mii_nway_adv_reg
operator|&
name|NWAY_AR_ASM_DIR
operator|)
operator|&&
operator|(
name|mii_nway_lp_ability_reg
operator|&
name|NWAY_LPAR_PAUSE
operator|)
operator|&&
operator|(
name|mii_nway_lp_ability_reg
operator|&
name|NWAY_LPAR_ASM_DIR
operator|)
condition|)
block|{
name|hw
operator|->
name|fc
operator|=
name|em_fc_tx_pause
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Flow Control = TX PAUSE frames only.\r\n"
argument_list|)
expr_stmt|;
block|}
comment|/* For transmitting PAUSE frames ONLY.              *              *   LOCAL DEVICE  |   LINK PARTNER              * PAUSE | ASM_DIR | PAUSE | ASM_DIR | Result              *-------|---------|-------|---------|--------------------              *   1   |    1    |   0   |    1    | em_fc_rx_pause              *              */
elseif|else
if|if
condition|(
operator|(
name|mii_nway_adv_reg
operator|&
name|NWAY_AR_PAUSE
operator|)
operator|&&
operator|(
name|mii_nway_adv_reg
operator|&
name|NWAY_AR_ASM_DIR
operator|)
operator|&&
operator|!
operator|(
name|mii_nway_lp_ability_reg
operator|&
name|NWAY_LPAR_PAUSE
operator|)
operator|&&
operator|(
name|mii_nway_lp_ability_reg
operator|&
name|NWAY_LPAR_ASM_DIR
operator|)
condition|)
block|{
name|hw
operator|->
name|fc
operator|=
name|em_fc_rx_pause
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Flow Control = RX PAUSE frames only.\r\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Per the IEEE spec, at this point flow control should be              * disabled.  However, we want to consider that we could              * be connected to a legacy switch that doesn't advertise              * desired flow control, but can be forced on the link              * partner.  So if we advertised no flow control, that is              * what we will resolve to.  If we advertised some kind of              * receive capability (Rx Pause Only or Full Flow Control)              * and the link partner advertised none, we will configure              * ourselves to enable Rx Flow Control only.  We can do              * this safely for two reasons:  If the link partner really              * didn't want flow control enabled, and we enable Rx, no              * harm done since we won't be receiving any PAUSE frames              * anyway.  If the intent on the link partner was to have              * flow control enabled, then by us enabling RX only, we              * can at least receive pause frames and process them.              * This is a good idea because in most cases, since we are              * predominantly a server NIC, more times than not we will              * be asked to delay transmission of packets than asking              * our link partner to pause transmission of frames.              */
elseif|else
if|if
condition|(
name|hw
operator|->
name|original_fc
operator|==
name|em_fc_none
operator|||
name|hw
operator|->
name|original_fc
operator|==
name|em_fc_tx_pause
condition|)
block|{
name|hw
operator|->
name|fc
operator|=
name|em_fc_none
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Flow Control = NONE.\r\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|hw
operator|->
name|fc
operator|=
name|em_fc_rx_pause
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Flow Control = RX PAUSE frames only.\r\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Now we need to do one last check...  If we auto-              * negotiated to HALF DUPLEX, flow control should not be              * enabled per IEEE 802.3 spec.              */
name|em_get_speed_and_duplex
argument_list|(
name|hw
argument_list|,
operator|&
name|speed
argument_list|,
operator|&
name|duplex
argument_list|)
expr_stmt|;
if|if
condition|(
name|duplex
operator|==
name|HALF_DUPLEX
condition|)
name|hw
operator|->
name|fc
operator|=
name|em_fc_none
expr_stmt|;
comment|/* Now we call a subroutine to actually force the MAC              * controller to use the correct flow control settings.              */
name|ret_val
operator|=
name|em_force_mac_fc
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
operator|<
literal|0
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Error forcing flow control settings\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
block|}
else|else
block|{
name|DEBUGOUT
argument_list|(
literal|"Copper PHY and Auto Neg has not completed.\r\n"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Checks to see if the link status of the hardware has changed.  *  * hw - Struct containing variables accessed by shared code  *  * Called by any function that needs to check the link status of the adapter.  *****************************************************************************/
end_comment

begin_function
name|int32_t
name|em_check_for_link
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|uint32_t
name|rxcw
decl_stmt|;
name|uint32_t
name|ctrl
decl_stmt|;
name|uint32_t
name|status
decl_stmt|;
name|uint32_t
name|rctl
decl_stmt|;
name|uint32_t
name|signal
decl_stmt|;
name|int32_t
name|ret_val
decl_stmt|;
name|uint16_t
name|phy_data
decl_stmt|;
name|uint16_t
name|lp_capability
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_check_for_link"
argument_list|)
expr_stmt|;
comment|/* On adapters with a MAC newer that 82544, SW Defineable pin 1 will be       * set when the optics detect a signal. On older adapters, it will be       * cleared when there is a signal      */
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|>
name|em_82544
condition|)
name|signal
operator|=
name|E1000_CTRL_SWDPIN1
expr_stmt|;
else|else
name|signal
operator|=
literal|0
expr_stmt|;
name|ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|)
expr_stmt|;
name|status
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|STATUS
argument_list|)
expr_stmt|;
name|rxcw
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|RXCW
argument_list|)
expr_stmt|;
comment|/* If we have a copper PHY then we only want to go out to the PHY      * registers to see if Auto-Neg has completed and/or if our link      * status has changed.  The get_link_status flag will be set if we      * receive a Link Status Change interrupt or we have Rx Sequence      * Errors.      */
if|if
condition|(
operator|(
name|hw
operator|->
name|media_type
operator|==
name|em_media_type_copper
operator|)
operator|&&
name|hw
operator|->
name|get_link_status
condition|)
block|{
comment|/* First we want to see if the MII Status Register reports          * link.  If so, then we want to get the current speed/duplex          * of the PHY.          * Read the register twice since the link bit is sticky.          */
if|if
condition|(
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_STATUS
argument_list|,
operator|&
name|phy_data
argument_list|)
operator|<
literal|0
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"PHY Read Error\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_PHY
return|;
block|}
if|if
condition|(
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_STATUS
argument_list|,
operator|&
name|phy_data
argument_list|)
operator|<
literal|0
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"PHY Read Error\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_PHY
return|;
block|}
if|if
condition|(
name|phy_data
operator|&
name|MII_SR_LINK_STATUS
condition|)
block|{
name|hw
operator|->
name|get_link_status
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
comment|/* No link detected */
return|return
literal|0
return|;
block|}
comment|/* If we are forcing speed/duplex, then we simply return since          * we have already determined whether we have link or not.          */
if|if
condition|(
operator|!
name|hw
operator|->
name|autoneg
condition|)
return|return
operator|-
name|E1000_ERR_CONFIG
return|;
comment|/* We have a M88E1000 PHY and Auto-Neg is enabled.  If we          * have Si on board that is 82544 or newer, Auto          * Speed Detection takes care of MAC speed/duplex          * configuration.  So we only need to configure Collision          * Distance in the MAC.  Otherwise, we need to force          * speed/duplex on the MAC to the current PHY speed/duplex          * settings.          */
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|>=
name|em_82544
condition|)
name|em_config_collision_dist
argument_list|(
name|hw
argument_list|)
expr_stmt|;
else|else
block|{
name|ret_val
operator|=
name|em_config_mac_to_phy
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
operator|<
literal|0
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Error configuring MAC to PHY settings\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
block|}
comment|/* Configure Flow Control now that Auto-Neg has completed. First, we           * need to restore the desired flow control settings because we may          * have had to re-autoneg with a different link partner.          */
name|ret_val
operator|=
name|em_config_fc_after_link_up
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
operator|<
literal|0
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Error configuring flow control\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
comment|/* At this point we know that we are on copper and we have          * auto-negotiated link.  These are conditions for checking the link          * parter capability register.  We use the link partner capability to          * determine if TBI Compatibility needs to be turned on or off.  If          * the link partner advertises any speed in addition to Gigabit, then          * we assume that they are GMII-based, and TBI compatibility is not          * needed. If no other speeds are advertised, we assume the link          * partner is TBI-based, and we turn on TBI Compatibility.          */
if|if
condition|(
name|hw
operator|->
name|tbi_compatibility_en
condition|)
block|{
if|if
condition|(
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_LP_ABILITY
argument_list|,
operator|&
name|lp_capability
argument_list|)
operator|<
literal|0
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"PHY Read Error\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_PHY
return|;
block|}
if|if
condition|(
name|lp_capability
operator|&
operator|(
name|NWAY_LPAR_10T_HD_CAPS
operator||
name|NWAY_LPAR_10T_FD_CAPS
operator||
name|NWAY_LPAR_100TX_HD_CAPS
operator||
name|NWAY_LPAR_100TX_FD_CAPS
operator||
name|NWAY_LPAR_100T4_CAPS
operator|)
condition|)
block|{
comment|/* If our link partner advertises anything in addition to                   * gigabit, we do not need to enable TBI compatibility.                  */
if|if
condition|(
name|hw
operator|->
name|tbi_compatibility_on
condition|)
block|{
comment|/* If we previously were in the mode, turn it off. */
name|rctl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|RCTL
argument_list|)
expr_stmt|;
name|rctl
operator|&=
operator|~
name|E1000_RCTL_SBP
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|RCTL
argument_list|,
name|rctl
argument_list|)
expr_stmt|;
name|hw
operator|->
name|tbi_compatibility_on
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* If TBI compatibility is was previously off, turn it on. For                  * compatibility with a TBI link partner, we will store bad                  * packets. Some frames have an additional byte on the end and                  * will look like CRC errors to to the hardware.                  */
if|if
condition|(
operator|!
name|hw
operator|->
name|tbi_compatibility_on
condition|)
block|{
name|hw
operator|->
name|tbi_compatibility_on
operator|=
name|TRUE
expr_stmt|;
name|rctl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|RCTL
argument_list|)
expr_stmt|;
name|rctl
operator||=
name|E1000_RCTL_SBP
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|RCTL
argument_list|,
name|rctl
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* If we don't have link (auto-negotiation failed or link partner cannot      * auto-negotiate), the cable is plugged in (we have signal), and our      * link partner is not trying to auto-negotiate with us (we are receiving      * idles or data), we need to force link up. We also need to give      * auto-negotiation time to complete, in case the cable was just plugged      * in. The autoneg_failed flag does this.      */
elseif|else
if|if
condition|(
operator|(
name|hw
operator|->
name|media_type
operator|==
name|em_media_type_fiber
operator|)
operator|&&
operator|(
operator|!
operator|(
name|status
operator|&
name|E1000_STATUS_LU
operator|)
operator|)
operator|&&
operator|(
operator|(
name|ctrl
operator|&
name|E1000_CTRL_SWDPIN1
operator|)
operator|==
name|signal
operator|)
operator|&&
operator|(
operator|!
operator|(
name|rxcw
operator|&
name|E1000_RXCW_C
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|hw
operator|->
name|autoneg_failed
operator|==
literal|0
condition|)
block|{
name|hw
operator|->
name|autoneg_failed
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
name|DEBUGOUT
argument_list|(
literal|"NOT RXing /C/, disable AutoNeg and force link.\r\n"
argument_list|)
expr_stmt|;
comment|/* Disable auto-negotiation in the TXCW register */
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|TXCW
argument_list|,
operator|(
name|hw
operator|->
name|txcw
operator|&
operator|~
name|E1000_TXCW_ANE
operator|)
argument_list|)
expr_stmt|;
comment|/* Force link-up and also force full-duplex. */
name|ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|)
expr_stmt|;
name|ctrl
operator||=
operator|(
name|E1000_CTRL_SLU
operator||
name|E1000_CTRL_FD
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
comment|/* Configure Flow Control after forcing link up. */
name|ret_val
operator|=
name|em_config_fc_after_link_up
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
operator|<
literal|0
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Error configuring flow control\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
block|}
comment|/* If we are forcing link and we are receiving /C/ ordered sets, re-enable      * auto-negotiation in the TXCW register and disable forced link in the      * Device Control register in an attempt to auto-negotiate with our link      * partner.      */
elseif|else
if|if
condition|(
operator|(
name|hw
operator|->
name|media_type
operator|==
name|em_media_type_fiber
operator|)
operator|&&
operator|(
name|ctrl
operator|&
name|E1000_CTRL_SLU
operator|)
operator|&&
operator|(
name|rxcw
operator|&
name|E1000_RXCW_C
operator|)
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"RXing /C/, enable AutoNeg and stop forcing link.\r\n"
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|TXCW
argument_list|,
name|hw
operator|->
name|txcw
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|,
operator|(
name|ctrl
operator|&
operator|~
name|E1000_CTRL_SLU
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Detects the current speed and duplex settings of the hardware.  *  * hw - Struct containing variables accessed by shared code  * speed - Speed of the connection  * duplex - Duplex setting of the connection  *****************************************************************************/
end_comment

begin_function
name|void
name|em_get_speed_and_duplex
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint16_t
modifier|*
name|speed
parameter_list|,
name|uint16_t
modifier|*
name|duplex
parameter_list|)
block|{
name|uint32_t
name|status
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_get_speed_and_duplex"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|>=
name|em_82543
condition|)
block|{
name|status
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|E1000_STATUS_SPEED_1000
condition|)
block|{
operator|*
name|speed
operator|=
name|SPEED_1000
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"1000 Mbs, "
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|status
operator|&
name|E1000_STATUS_SPEED_100
condition|)
block|{
operator|*
name|speed
operator|=
name|SPEED_100
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"100 Mbs, "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|speed
operator|=
name|SPEED_10
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"10 Mbs, "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|&
name|E1000_STATUS_FD
condition|)
block|{
operator|*
name|duplex
operator|=
name|FULL_DUPLEX
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Full Duplex\r\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|duplex
operator|=
name|HALF_DUPLEX
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|" Half Duplex\r\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|DEBUGOUT
argument_list|(
literal|"1000 Mbs, Full Duplex\r\n"
argument_list|)
expr_stmt|;
operator|*
name|speed
operator|=
name|SPEED_1000
expr_stmt|;
operator|*
name|duplex
operator|=
name|FULL_DUPLEX
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/****************************************************************************** * Blocks until autoneg completes or times out (~4.5 seconds) * * hw - Struct containing variables accessed by shared code ******************************************************************************/
end_comment

begin_function
name|int32_t
name|em_wait_autoneg
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|uint16_t
name|i
decl_stmt|;
name|uint16_t
name|phy_data
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_wait_autoneg"
argument_list|)
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Waiting for Auto-Neg to complete.\n"
argument_list|)
expr_stmt|;
comment|/* We will wait for autoneg to complete or 4.5 seconds to expire. */
for|for
control|(
name|i
operator|=
name|PHY_AUTO_NEG_TIME
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
comment|/* Read the MII Status Register and wait for Auto-Neg          * Complete bit to be set.          */
if|if
condition|(
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_STATUS
argument_list|,
operator|&
name|phy_data
argument_list|)
operator|<
literal|0
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"PHY Read Error\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_PHY
return|;
block|}
if|if
condition|(
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_STATUS
argument_list|,
operator|&
name|phy_data
argument_list|)
operator|<
literal|0
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"PHY Read Error\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_PHY
return|;
block|}
if|if
condition|(
name|phy_data
operator|&
name|MII_SR_AUTONEG_COMPLETE
condition|)
block|{
return|return
literal|0
return|;
block|}
name|msec_delay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************** * Raises the Management Data Clock * * hw - Struct containing variables accessed by shared code * ctrl - Device control register's current value ******************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|em_raise_mdi_clk
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint32_t
modifier|*
name|ctrl
parameter_list|)
block|{
comment|/* Raise the clock input to the Management Data Clock (by setting the MDC      * bit), and then delay 2 microseconds.      */
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|,
operator|(
operator|*
name|ctrl
operator||
name|E1000_CTRL_MDC
operator|)
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************** * Lowers the Management Data Clock * * hw - Struct containing variables accessed by shared code * ctrl - Device control register's current value ******************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|em_lower_mdi_clk
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint32_t
modifier|*
name|ctrl
parameter_list|)
block|{
comment|/* Lower the clock input to the Management Data Clock (by clearing the MDC      * bit), and then delay 2 microseconds.      */
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|,
operator|(
operator|*
name|ctrl
operator|&
operator|~
name|E1000_CTRL_MDC
operator|)
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************** * Shifts data bits out to the PHY * * hw - Struct containing variables accessed by shared code * data - Data to send out to the PHY * count - Number of bits to shift out * * Bits are shifted out in MSB to LSB order. ******************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|em_shift_out_mdi_bits
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint32_t
name|data
parameter_list|,
name|uint16_t
name|count
parameter_list|)
block|{
name|uint32_t
name|ctrl
decl_stmt|;
name|uint32_t
name|mask
decl_stmt|;
comment|/* We need to shift "count" number of bits out to the PHY. So, the value      * in the "data" parameter will be shifted out to the PHY one bit at a       * time. In order to do this, "data" must be broken down into bits.      */
name|mask
operator|=
literal|0x01
expr_stmt|;
name|mask
operator|<<=
operator|(
name|count
operator|-
literal|1
operator|)
expr_stmt|;
name|ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|)
expr_stmt|;
comment|/* Set MDIO_DIR and MDC_DIR direction bits to be used as output pins. */
name|ctrl
operator||=
operator|(
name|E1000_CTRL_MDIO_DIR
operator||
name|E1000_CTRL_MDC_DIR
operator|)
expr_stmt|;
while|while
condition|(
name|mask
condition|)
block|{
comment|/* A "1" is shifted out to the PHY by setting the MDIO bit to "1" and          * then raising and lowering the Management Data Clock. A "0" is          * shifted out to the PHY by setting the MDIO bit to "0" and then          * raising and lowering the clock.          */
if|if
condition|(
name|data
operator|&
name|mask
condition|)
name|ctrl
operator||=
name|E1000_CTRL_MDIO
expr_stmt|;
else|else
name|ctrl
operator|&=
operator|~
name|E1000_CTRL_MDIO
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|em_raise_mdi_clk
argument_list|(
name|hw
argument_list|,
operator|&
name|ctrl
argument_list|)
expr_stmt|;
name|em_lower_mdi_clk
argument_list|(
name|hw
argument_list|,
operator|&
name|ctrl
argument_list|)
expr_stmt|;
name|mask
operator|=
name|mask
operator|>>
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/****************************************************************************** * Shifts data bits in from the PHY * * hw - Struct containing variables accessed by shared code * * Bits are shifted in in MSB to LSB order.  ******************************************************************************/
end_comment

begin_function
specifier|static
name|uint16_t
name|em_shift_in_mdi_bits
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|uint32_t
name|ctrl
decl_stmt|;
name|uint16_t
name|data
init|=
literal|0
decl_stmt|;
name|uint8_t
name|i
decl_stmt|;
comment|/* In order to read a register from the PHY, we need to shift in a total      * of 18 bits from the PHY. The first two bit (turnaround) times are used      * to avoid contention on the MDIO pin when a read operation is performed.      * These two bits are ignored by us and thrown away. Bits are "shifted in"      * by raising the input to the Management Data Clock (setting the MDC bit),      * and then reading the value of the MDIO bit.      */
name|ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|)
expr_stmt|;
comment|/* Clear MDIO_DIR (SWDPIO1) to indicate this bit is to be used as input. */
name|ctrl
operator|&=
operator|~
name|E1000_CTRL_MDIO_DIR
expr_stmt|;
name|ctrl
operator|&=
operator|~
name|E1000_CTRL_MDIO
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Raise and Lower the clock before reading in the data. This accounts for      * the turnaround bits. The first clock occurred when we clocked out the      * last bit of the Register Address.      */
name|em_raise_mdi_clk
argument_list|(
name|hw
argument_list|,
operator|&
name|ctrl
argument_list|)
expr_stmt|;
name|em_lower_mdi_clk
argument_list|(
name|hw
argument_list|,
operator|&
name|ctrl
argument_list|)
expr_stmt|;
for|for
control|(
name|data
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|data
operator|=
name|data
operator|<<
literal|1
expr_stmt|;
name|em_raise_mdi_clk
argument_list|(
name|hw
argument_list|,
operator|&
name|ctrl
argument_list|)
expr_stmt|;
name|ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|)
expr_stmt|;
comment|/* Check to see if we shifted in a "1". */
if|if
condition|(
name|ctrl
operator|&
name|E1000_CTRL_MDIO
condition|)
name|data
operator||=
literal|1
expr_stmt|;
name|em_lower_mdi_clk
argument_list|(
name|hw
argument_list|,
operator|&
name|ctrl
argument_list|)
expr_stmt|;
block|}
name|em_raise_mdi_clk
argument_list|(
name|hw
argument_list|,
operator|&
name|ctrl
argument_list|)
expr_stmt|;
name|em_lower_mdi_clk
argument_list|(
name|hw
argument_list|,
operator|&
name|ctrl
argument_list|)
expr_stmt|;
return|return
name|data
return|;
block|}
end_function

begin_comment
comment|/***************************************************************************** * Reads the value from a PHY register * * hw - Struct containing variables accessed by shared code * reg_addr - address of the PHY register to read ******************************************************************************/
end_comment

begin_function
name|int32_t
name|em_read_phy_reg
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint32_t
name|reg_addr
parameter_list|,
name|uint16_t
modifier|*
name|phy_data
parameter_list|)
block|{
name|uint32_t
name|i
decl_stmt|;
name|uint32_t
name|mdic
init|=
literal|0
decl_stmt|;
specifier|const
name|uint32_t
name|phy_addr
init|=
literal|1
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_read_phy_reg"
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_addr
operator|>
name|MAX_PHY_REG_ADDRESS
condition|)
block|{
name|DEBUGOUT1
argument_list|(
literal|"PHY Address %d is out of range\n"
argument_list|,
name|reg_addr
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_PARAM
return|;
block|}
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|>
name|em_82543
condition|)
block|{
comment|/* Set up Op-code, Phy Address, and register address in the MDI          * Control register.  The MAC will take care of interfacing with the          * PHY to retrieve the desired data.          */
name|mdic
operator|=
operator|(
operator|(
name|reg_addr
operator|<<
name|E1000_MDIC_REG_SHIFT
operator|)
operator||
operator|(
name|phy_addr
operator|<<
name|E1000_MDIC_PHY_SHIFT
operator|)
operator||
operator|(
name|E1000_MDIC_OP_READ
operator|)
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|MDIC
argument_list|,
name|mdic
argument_list|)
expr_stmt|;
comment|/* Poll the ready bit to see if the MDI read completed */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|64
condition|;
name|i
operator|++
control|)
block|{
name|usec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|mdic
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|MDIC
argument_list|)
expr_stmt|;
if|if
condition|(
name|mdic
operator|&
name|E1000_MDIC_READY
condition|)
break|break;
block|}
if|if
condition|(
operator|!
operator|(
name|mdic
operator|&
name|E1000_MDIC_READY
operator|)
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"MDI Read did not complete\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_PHY
return|;
block|}
if|if
condition|(
name|mdic
operator|&
name|E1000_MDIC_ERROR
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"MDI Error\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_PHY
return|;
block|}
operator|*
name|phy_data
operator|=
operator|(
name|uint16_t
operator|)
name|mdic
expr_stmt|;
block|}
else|else
block|{
comment|/* We must first send a preamble through the MDIO pin to signal the          * beginning of an MII instruction.  This is done by sending 32          * consecutive "1" bits.          */
name|em_shift_out_mdi_bits
argument_list|(
name|hw
argument_list|,
name|PHY_PREAMBLE
argument_list|,
name|PHY_PREAMBLE_SIZE
argument_list|)
expr_stmt|;
comment|/* Now combine the next few fields that are required for a read          * operation.  We use this method instead of calling the          * em_shift_out_mdi_bits routine five different times. The format of          * a MII read instruction consists of a shift out of 14 bits and is          * defined as follows:          *<Preamble><SOF><Op Code><Phy Addr><Reg Addr>          * followed by a shift in of 18 bits.  This first two bits shifted in          * are TurnAround bits used to avoid contention on the MDIO pin when a          * READ operation is performed.  These two bits are thrown away          * followed by a shift in of 16 bits which contains the desired data.          */
name|mdic
operator|=
operator|(
operator|(
name|reg_addr
operator|)
operator||
operator|(
name|phy_addr
operator|<<
literal|5
operator|)
operator||
operator|(
name|PHY_OP_READ
operator|<<
literal|10
operator|)
operator||
operator|(
name|PHY_SOF
operator|<<
literal|12
operator|)
operator|)
expr_stmt|;
name|em_shift_out_mdi_bits
argument_list|(
name|hw
argument_list|,
name|mdic
argument_list|,
literal|14
argument_list|)
expr_stmt|;
comment|/* Now that we've shifted out the read command to the MII, we need to          * "shift in" the 16-bit value (18 total bits) of the requested PHY          * register address.          */
operator|*
name|phy_data
operator|=
name|em_shift_in_mdi_bits
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************** * Writes a value to a PHY register * * hw - Struct containing variables accessed by shared code * reg_addr - address of the PHY register to write * data - data to write to the PHY ******************************************************************************/
end_comment

begin_function
name|int32_t
name|em_write_phy_reg
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint32_t
name|reg_addr
parameter_list|,
name|uint16_t
name|phy_data
parameter_list|)
block|{
name|uint32_t
name|i
decl_stmt|;
name|uint32_t
name|mdic
init|=
literal|0
decl_stmt|;
specifier|const
name|uint32_t
name|phy_addr
init|=
literal|1
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_write_phy_reg"
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_addr
operator|>
name|MAX_PHY_REG_ADDRESS
condition|)
block|{
name|DEBUGOUT1
argument_list|(
literal|"PHY Address %d is out of range\n"
argument_list|,
name|reg_addr
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_PARAM
return|;
block|}
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|>
name|em_82543
condition|)
block|{
comment|/* Set up Op-code, Phy Address, register address, and data intended          * for the PHY register in the MDI Control register.  The MAC will take          * care of interfacing with the PHY to send the desired data.          */
name|mdic
operator|=
operator|(
operator|(
operator|(
name|uint32_t
operator|)
name|phy_data
operator|)
operator||
operator|(
name|reg_addr
operator|<<
name|E1000_MDIC_REG_SHIFT
operator|)
operator||
operator|(
name|phy_addr
operator|<<
name|E1000_MDIC_PHY_SHIFT
operator|)
operator||
operator|(
name|E1000_MDIC_OP_WRITE
operator|)
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|MDIC
argument_list|,
name|mdic
argument_list|)
expr_stmt|;
comment|/* Poll the ready bit to see if the MDI read completed */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|64
condition|;
name|i
operator|++
control|)
block|{
name|usec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|mdic
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|MDIC
argument_list|)
expr_stmt|;
if|if
condition|(
name|mdic
operator|&
name|E1000_MDIC_READY
condition|)
break|break;
block|}
if|if
condition|(
operator|!
operator|(
name|mdic
operator|&
name|E1000_MDIC_READY
operator|)
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"MDI Write did not complete\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_PHY
return|;
block|}
block|}
else|else
block|{
comment|/* We'll need to use the SW defined pins to shift the write command          * out to the PHY. We first send a preamble to the PHY to signal the          * beginning of the MII instruction.  This is done by sending 32           * consecutive "1" bits.          */
name|em_shift_out_mdi_bits
argument_list|(
name|hw
argument_list|,
name|PHY_PREAMBLE
argument_list|,
name|PHY_PREAMBLE_SIZE
argument_list|)
expr_stmt|;
comment|/* Now combine the remaining required fields that will indicate a           * write operation. We use this method instead of calling the          * em_shift_out_mdi_bits routine for each field in the command. The          * format of a MII write instruction is as follows:          *<Preamble><SOF><Op Code><Phy Addr><Reg Addr><Turnaround><Data>.          */
name|mdic
operator|=
operator|(
operator|(
name|PHY_TURNAROUND
operator|)
operator||
operator|(
name|reg_addr
operator|<<
literal|2
operator|)
operator||
operator|(
name|phy_addr
operator|<<
literal|7
operator|)
operator||
operator|(
name|PHY_OP_WRITE
operator|<<
literal|12
operator|)
operator||
operator|(
name|PHY_SOF
operator|<<
literal|14
operator|)
operator|)
expr_stmt|;
name|mdic
operator|<<=
literal|16
expr_stmt|;
name|mdic
operator||=
operator|(
name|uint32_t
operator|)
name|phy_data
expr_stmt|;
name|em_shift_out_mdi_bits
argument_list|(
name|hw
argument_list|,
name|mdic
argument_list|,
literal|32
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************** * Returns the PHY to the power-on reset state * * hw - Struct containing variables accessed by shared code ******************************************************************************/
end_comment

begin_function
name|void
name|em_phy_hw_reset
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|uint32_t
name|ctrl
decl_stmt|;
name|uint32_t
name|ctrl_ext
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_phy_hw_reset"
argument_list|)
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Resetting Phy...\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|>
name|em_82543
condition|)
block|{
comment|/* Read the device control register and assert the E1000_CTRL_PHY_RST          * bit. Then, take it out of reset.          */
name|ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|,
name|ctrl
operator||
name|E1000_CTRL_PHY_RST
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|msec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Read the Extended Device Control Register, assert the PHY_RESET_DIR          * bit to put the PHY into reset. Then, take it out of reset.          */
name|ctrl_ext
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|CTRL_EXT
argument_list|)
expr_stmt|;
name|ctrl_ext
operator||=
name|E1000_CTRL_EXT_SDP4_DIR
expr_stmt|;
name|ctrl_ext
operator|&=
operator|~
name|E1000_CTRL_EXT_SDP4_DATA
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|CTRL_EXT
argument_list|,
name|ctrl_ext
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|msec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|ctrl_ext
operator||=
name|E1000_CTRL_EXT_SDP4_DATA
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|CTRL_EXT
argument_list|,
name|ctrl_ext
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
name|usec_delay
argument_list|(
literal|150
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************** * Resets the PHY * * hw - Struct containing variables accessed by shared code * * Sets bit 15 of the MII Control regiser ******************************************************************************/
end_comment

begin_function
name|int32_t
name|em_phy_reset
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|uint16_t
name|phy_data
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_phy_reset"
argument_list|)
expr_stmt|;
if|if
condition|(
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_CTRL
argument_list|,
operator|&
name|phy_data
argument_list|)
operator|<
literal|0
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"PHY Read Error\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_PHY
return|;
block|}
name|phy_data
operator||=
name|MII_CR_RESET
expr_stmt|;
if|if
condition|(
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_CTRL
argument_list|,
name|phy_data
argument_list|)
operator|<
literal|0
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"PHY Write Error\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_PHY
return|;
block|}
name|usec_delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************** * Probes the expected PHY address for known PHY IDs * * hw - Struct containing variables accessed by shared code ******************************************************************************/
end_comment

begin_function
name|int32_t
name|em_detect_gig_phy
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|uint16_t
name|phy_id_high
decl_stmt|,
name|phy_id_low
decl_stmt|;
name|boolean_t
name|match
init|=
name|FALSE
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_detect_gig_phy"
argument_list|)
expr_stmt|;
comment|/* Read the PHY ID Registers to identify which PHY is onboard. */
if|if
condition|(
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_ID1
argument_list|,
operator|&
name|phy_id_high
argument_list|)
operator|<
literal|0
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"PHY Read Error\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_PHY
return|;
block|}
name|hw
operator|->
name|phy_id
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|phy_id_high
operator|<<
literal|16
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_ID2
argument_list|,
operator|&
name|phy_id_low
argument_list|)
operator|<
literal|0
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"PHY Read Error\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_PHY
return|;
block|}
name|hw
operator|->
name|phy_id
operator||=
call|(
name|uint32_t
call|)
argument_list|(
name|phy_id_low
operator|&
name|PHY_REVISION_MASK
argument_list|)
expr_stmt|;
name|hw
operator|->
name|phy_revision
operator|=
operator|(
name|uint32_t
operator|)
name|phy_id_low
operator|&
operator|~
name|PHY_REVISION_MASK
expr_stmt|;
switch|switch
condition|(
name|hw
operator|->
name|mac_type
condition|)
block|{
case|case
name|em_82543
case|:
if|if
condition|(
name|hw
operator|->
name|phy_id
operator|==
name|M88E1000_E_PHY_ID
condition|)
name|match
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|em_82544
case|:
if|if
condition|(
name|hw
operator|->
name|phy_id
operator|==
name|M88E1000_I_PHY_ID
condition|)
name|match
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|em_82540
case|:
case|case
name|em_82545
case|:
case|case
name|em_82546
case|:
if|if
condition|(
name|hw
operator|->
name|phy_id
operator|==
name|M88E1011_I_PHY_ID
condition|)
name|match
operator|=
name|TRUE
expr_stmt|;
break|break;
default|default:
name|DEBUGOUT1
argument_list|(
literal|"Invalid MAC type %d\n"
argument_list|,
name|hw
operator|->
name|mac_type
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_CONFIG
return|;
block|}
if|if
condition|(
name|match
condition|)
block|{
name|DEBUGOUT1
argument_list|(
literal|"PHY ID 0x%X detected\n"
argument_list|,
name|hw
operator|->
name|phy_id
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|DEBUGOUT1
argument_list|(
literal|"Invalid PHY ID 0x%X\n"
argument_list|,
name|hw
operator|->
name|phy_id
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_PHY
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************** * Resets the PHY's DSP * * hw - Struct containing variables accessed by shared code ******************************************************************************/
end_comment

begin_function
specifier|static
name|int32_t
name|em_phy_reset_dsp
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|int32_t
name|ret_val
init|=
operator|-
name|E1000_ERR_PHY
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_phy_reset_dsp"
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
literal|29
argument_list|,
literal|0x001d
argument_list|)
operator|<
literal|0
condition|)
break|break;
if|if
condition|(
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
literal|30
argument_list|,
literal|0x00c1
argument_list|)
operator|<
literal|0
condition|)
break|break;
if|if
condition|(
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
literal|30
argument_list|,
literal|0x0000
argument_list|)
operator|<
literal|0
condition|)
break|break;
name|ret_val
operator|=
literal|0
expr_stmt|;
block|}
do|while
condition|(
literal|0
condition|)
do|;
if|if
condition|(
name|ret_val
operator|<
literal|0
condition|)
name|DEBUGOUT
argument_list|(
literal|"PHY Write Error\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************** * Get PHY information from various PHY registers * * hw - Struct containing variables accessed by shared code * phy_info - PHY information structure ******************************************************************************/
end_comment

begin_function
name|int32_t
name|em_phy_get_info
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|struct
name|em_phy_info
modifier|*
name|phy_info
parameter_list|)
block|{
name|int32_t
name|ret_val
init|=
operator|-
name|E1000_ERR_PHY
decl_stmt|;
name|uint16_t
name|phy_data
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_phy_get_info"
argument_list|)
expr_stmt|;
name|phy_info
operator|->
name|cable_length
operator|=
name|em_cable_length_undefined
expr_stmt|;
name|phy_info
operator|->
name|extended_10bt_distance
operator|=
name|em_10bt_ext_dist_enable_undefined
expr_stmt|;
name|phy_info
operator|->
name|cable_polarity
operator|=
name|em_rev_polarity_undefined
expr_stmt|;
name|phy_info
operator|->
name|polarity_correction
operator|=
name|em_polarity_reversal_undefined
expr_stmt|;
name|phy_info
operator|->
name|mdix_mode
operator|=
name|em_auto_x_mode_undefined
expr_stmt|;
name|phy_info
operator|->
name|local_rx
operator|=
name|em_1000t_rx_status_undefined
expr_stmt|;
name|phy_info
operator|->
name|remote_rx
operator|=
name|em_1000t_rx_status_undefined
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|media_type
operator|!=
name|em_media_type_copper
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"PHY info is only valid for copper media\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_CONFIG
return|;
block|}
do|do
block|{
if|if
condition|(
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_STATUS
argument_list|,
operator|&
name|phy_data
argument_list|)
operator|<
literal|0
condition|)
break|break;
if|if
condition|(
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_STATUS
argument_list|,
operator|&
name|phy_data
argument_list|)
operator|<
literal|0
condition|)
break|break;
if|if
condition|(
operator|(
name|phy_data
operator|&
name|MII_SR_LINK_STATUS
operator|)
operator|!=
name|MII_SR_LINK_STATUS
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"PHY info is only valid if link is up\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_CONFIG
return|;
block|}
if|if
condition|(
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_SPEC_CTRL
argument_list|,
operator|&
name|phy_data
argument_list|)
operator|<
literal|0
condition|)
break|break;
name|phy_info
operator|->
name|extended_10bt_distance
operator|=
operator|(
name|phy_data
operator|&
name|M88E1000_PSCR_10BT_EXT_DIST_ENABLE
operator|)
operator|>>
name|M88E1000_PSCR_10BT_EXT_DIST_ENABLE_SHIFT
expr_stmt|;
name|phy_info
operator|->
name|polarity_correction
operator|=
operator|(
name|phy_data
operator|&
name|M88E1000_PSCR_POLARITY_REVERSAL
operator|)
operator|>>
name|M88E1000_PSCR_POLARITY_REVERSAL_SHIFT
expr_stmt|;
if|if
condition|(
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_SPEC_STATUS
argument_list|,
operator|&
name|phy_data
argument_list|)
operator|<
literal|0
condition|)
break|break;
name|phy_info
operator|->
name|cable_polarity
operator|=
operator|(
name|phy_data
operator|&
name|M88E1000_PSSR_REV_POLARITY
operator|)
operator|>>
name|M88E1000_PSSR_REV_POLARITY_SHIFT
expr_stmt|;
name|phy_info
operator|->
name|mdix_mode
operator|=
operator|(
name|phy_data
operator|&
name|M88E1000_PSSR_MDIX
operator|)
operator|>>
name|M88E1000_PSSR_MDIX_SHIFT
expr_stmt|;
if|if
condition|(
name|phy_data
operator|&
name|M88E1000_PSSR_1000MBS
condition|)
block|{
comment|/* Cable Length Estimation and Local/Remote Receiver Informatoion              * are only valid at 1000 Mbps              */
name|phy_info
operator|->
name|cable_length
operator|=
operator|(
operator|(
name|phy_data
operator|&
name|M88E1000_PSSR_CABLE_LENGTH
operator|)
operator|>>
name|M88E1000_PSSR_CABLE_LENGTH_SHIFT
operator|)
expr_stmt|;
if|if
condition|(
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_1000T_STATUS
argument_list|,
operator|&
name|phy_data
argument_list|)
operator|<
literal|0
condition|)
break|break;
name|phy_info
operator|->
name|local_rx
operator|=
operator|(
name|phy_data
operator|&
name|SR_1000T_LOCAL_RX_STATUS
operator|)
operator|>>
name|SR_1000T_LOCAL_RX_STATUS_SHIFT
expr_stmt|;
name|phy_info
operator|->
name|remote_rx
operator|=
operator|(
name|phy_data
operator|&
name|SR_1000T_REMOTE_RX_STATUS
operator|)
operator|>>
name|SR_1000T_REMOTE_RX_STATUS_SHIFT
expr_stmt|;
block|}
name|ret_val
operator|=
literal|0
expr_stmt|;
block|}
do|while
condition|(
literal|0
condition|)
do|;
if|if
condition|(
name|ret_val
operator|<
literal|0
condition|)
name|DEBUGOUT
argument_list|(
literal|"PHY Read Error\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_function
name|int32_t
name|em_validate_mdi_setting
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"em_validate_mdi_settings"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hw
operator|->
name|autoneg
operator|&&
operator|(
name|hw
operator|->
name|mdix
operator|==
literal|0
operator|||
name|hw
operator|->
name|mdix
operator|==
literal|3
operator|)
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Invalid MDI setting detected\n"
argument_list|)
expr_stmt|;
name|hw
operator|->
name|mdix
operator|=
literal|1
expr_stmt|;
return|return
operator|-
name|E1000_ERR_CONFIG
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Raises the EEPROM's clock input.  *  * hw - Struct containing variables accessed by shared code  * eecd - EECD's current value  *****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|em_raise_ee_clk
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint32_t
modifier|*
name|eecd
parameter_list|)
block|{
comment|/* Raise the clock input to the EEPROM (by setting the SK bit), and then      * wait<delay> microseconds.      */
operator|*
name|eecd
operator|=
operator|*
name|eecd
operator||
name|E1000_EECD_SK
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|EECD
argument_list|,
operator|*
name|eecd
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|50
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Lowers the EEPROM's clock input.  *  * hw - Struct containing variables accessed by shared code   * eecd - EECD's current value  *****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|em_lower_ee_clk
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint32_t
modifier|*
name|eecd
parameter_list|)
block|{
comment|/* Lower the clock input to the EEPROM (by clearing the SK bit), and then       * wait 50 microseconds.       */
operator|*
name|eecd
operator|=
operator|*
name|eecd
operator|&
operator|~
name|E1000_EECD_SK
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|EECD
argument_list|,
operator|*
name|eecd
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|50
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Shift data bits out to the EEPROM.  *  * hw - Struct containing variables accessed by shared code  * data - data to send to the EEPROM  * count - number of bits to shift out  *****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|em_shift_out_ee_bits
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint16_t
name|data
parameter_list|,
name|uint16_t
name|count
parameter_list|)
block|{
name|uint32_t
name|eecd
decl_stmt|;
name|uint32_t
name|mask
decl_stmt|;
comment|/* We need to shift "count" bits out to the EEPROM. So, value in the      * "data" parameter will be shifted out to the EEPROM one bit at a time.      * In order to do this, "data" must be broken down into bits.       */
name|mask
operator|=
literal|0x01
operator|<<
operator|(
name|count
operator|-
literal|1
operator|)
expr_stmt|;
name|eecd
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|EECD
argument_list|)
expr_stmt|;
name|eecd
operator|&=
operator|~
operator|(
name|E1000_EECD_DO
operator||
name|E1000_EECD_DI
operator|)
expr_stmt|;
do|do
block|{
comment|/* A "1" is shifted out to the EEPROM by setting bit "DI" to a "1",          * and then raising and then lowering the clock (the SK bit controls          * the clock input to the EEPROM).  A "0" is shifted out to the EEPROM          * by setting "DI" to "0" and then raising and then lowering the clock.          */
name|eecd
operator|&=
operator|~
name|E1000_EECD_DI
expr_stmt|;
if|if
condition|(
name|data
operator|&
name|mask
condition|)
name|eecd
operator||=
name|E1000_EECD_DI
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|EECD
argument_list|,
name|eecd
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|50
argument_list|)
expr_stmt|;
name|em_raise_ee_clk
argument_list|(
name|hw
argument_list|,
operator|&
name|eecd
argument_list|)
expr_stmt|;
name|em_lower_ee_clk
argument_list|(
name|hw
argument_list|,
operator|&
name|eecd
argument_list|)
expr_stmt|;
name|mask
operator|=
name|mask
operator|>>
literal|1
expr_stmt|;
block|}
do|while
condition|(
name|mask
condition|)
do|;
comment|/* We leave the "DI" bit set to "0" when we leave this routine. */
name|eecd
operator|&=
operator|~
name|E1000_EECD_DI
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|EECD
argument_list|,
name|eecd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Shift data bits in from the EEPROM  *  * hw - Struct containing variables accessed by shared code  *****************************************************************************/
end_comment

begin_function
specifier|static
name|uint16_t
name|em_shift_in_ee_bits
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|uint32_t
name|eecd
decl_stmt|;
name|uint32_t
name|i
decl_stmt|;
name|uint16_t
name|data
decl_stmt|;
comment|/* In order to read a register from the EEPROM, we need to shift 'count'      * bits in from the EEPROM. Bits are "shifted in" by raising the clock      * input to the EEPROM (setting the SK bit), and then reading the value of      * the "DO" bit.  During this "shifting in" process the "DI" bit should      * always be clear.      */
name|eecd
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|EECD
argument_list|)
expr_stmt|;
name|eecd
operator|&=
operator|~
operator|(
name|E1000_EECD_DO
operator||
name|E1000_EECD_DI
operator|)
expr_stmt|;
name|data
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|data
operator|=
name|data
operator|<<
literal|1
expr_stmt|;
name|em_raise_ee_clk
argument_list|(
name|hw
argument_list|,
operator|&
name|eecd
argument_list|)
expr_stmt|;
name|eecd
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|EECD
argument_list|)
expr_stmt|;
name|eecd
operator|&=
operator|~
operator|(
name|E1000_EECD_DI
operator|)
expr_stmt|;
if|if
condition|(
name|eecd
operator|&
name|E1000_EECD_DO
condition|)
name|data
operator||=
literal|1
expr_stmt|;
name|em_lower_ee_clk
argument_list|(
name|hw
argument_list|,
operator|&
name|eecd
argument_list|)
expr_stmt|;
block|}
return|return
name|data
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Prepares EEPROM for access  *  * hw - Struct containing variables accessed by shared code  *  * Lowers EEPROM clock. Clears input pin. Sets the chip select pin. This   * function should be called before issuing a command to the EEPROM.  *****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|em_setup_eeprom
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|uint32_t
name|eecd
decl_stmt|;
name|eecd
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|EECD
argument_list|)
expr_stmt|;
comment|/* Clear SK and DI */
name|eecd
operator|&=
operator|~
operator|(
name|E1000_EECD_SK
operator||
name|E1000_EECD_DI
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|EECD
argument_list|,
name|eecd
argument_list|)
expr_stmt|;
comment|/* Set CS */
name|eecd
operator||=
name|E1000_EECD_CS
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|EECD
argument_list|,
name|eecd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Returns EEPROM to a "standby" state  *   * hw - Struct containing variables accessed by shared code  *****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|em_standby_eeprom
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|uint32_t
name|eecd
decl_stmt|;
name|eecd
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|EECD
argument_list|)
expr_stmt|;
comment|/* Deselct EEPROM */
name|eecd
operator|&=
operator|~
operator|(
name|E1000_EECD_CS
operator||
name|E1000_EECD_SK
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|EECD
argument_list|,
name|eecd
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|50
argument_list|)
expr_stmt|;
comment|/* Clock high */
name|eecd
operator||=
name|E1000_EECD_SK
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|EECD
argument_list|,
name|eecd
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|50
argument_list|)
expr_stmt|;
comment|/* Select EEPROM */
name|eecd
operator||=
name|E1000_EECD_CS
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|EECD
argument_list|,
name|eecd
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|50
argument_list|)
expr_stmt|;
comment|/* Clock low */
name|eecd
operator|&=
operator|~
name|E1000_EECD_SK
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|EECD
argument_list|,
name|eecd
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|50
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Raises then lowers the EEPROM's clock pin  *  * hw - Struct containing variables accessed by shared code  *****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|em_clock_eeprom
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|uint32_t
name|eecd
decl_stmt|;
name|eecd
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|EECD
argument_list|)
expr_stmt|;
comment|/* Rising edge of clock */
name|eecd
operator||=
name|E1000_EECD_SK
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|EECD
argument_list|,
name|eecd
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|50
argument_list|)
expr_stmt|;
comment|/* Falling edge of clock */
name|eecd
operator|&=
operator|~
name|E1000_EECD_SK
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|EECD
argument_list|,
name|eecd
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|50
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Terminates a command by lowering the EEPROM's chip select pin  *  * hw - Struct containing variables accessed by shared code  *****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|em_cleanup_eeprom
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|uint32_t
name|eecd
decl_stmt|;
name|eecd
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|EECD
argument_list|)
expr_stmt|;
name|eecd
operator|&=
operator|~
operator|(
name|E1000_EECD_CS
operator||
name|E1000_EECD_DI
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|EECD
argument_list|,
name|eecd
argument_list|)
expr_stmt|;
name|em_clock_eeprom
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Reads a 16 bit word from the EEPROM.  *  * hw - Struct containing variables accessed by shared code  * offset - offset of  word in the EEPROM to read  * data - word read from the EEPROM   *****************************************************************************/
end_comment

begin_function
name|int32_t
name|em_read_eeprom
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint16_t
name|offset
parameter_list|,
name|uint16_t
modifier|*
name|data
parameter_list|)
block|{
name|uint32_t
name|eecd
decl_stmt|;
name|uint32_t
name|i
init|=
literal|0
decl_stmt|;
name|boolean_t
name|large_eeprom
init|=
name|FALSE
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_read_eeprom"
argument_list|)
expr_stmt|;
comment|/* Request EEPROM Access */
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|>
name|em_82544
condition|)
block|{
name|eecd
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|EECD
argument_list|)
expr_stmt|;
if|if
condition|(
name|eecd
operator|&
name|E1000_EECD_SIZE
condition|)
name|large_eeprom
operator|=
name|TRUE
expr_stmt|;
name|eecd
operator||=
name|E1000_EECD_REQ
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|EECD
argument_list|,
name|eecd
argument_list|)
expr_stmt|;
name|eecd
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|EECD
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
operator|!
operator|(
name|eecd
operator|&
name|E1000_EECD_GNT
operator|)
operator|)
operator|&&
operator|(
name|i
operator|<
literal|100
operator|)
condition|)
block|{
name|i
operator|++
expr_stmt|;
name|usec_delay
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|eecd
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|EECD
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|eecd
operator|&
name|E1000_EECD_GNT
operator|)
condition|)
block|{
name|eecd
operator|&=
operator|~
name|E1000_EECD_REQ
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|EECD
argument_list|,
name|eecd
argument_list|)
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Could not acquire EEPROM grant\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_EEPROM
return|;
block|}
block|}
comment|/*  Prepare the EEPROM for reading  */
name|em_setup_eeprom
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/*  Send the READ command (opcode + addr)  */
name|em_shift_out_ee_bits
argument_list|(
name|hw
argument_list|,
name|EEPROM_READ_OPCODE
argument_list|,
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|large_eeprom
condition|)
block|{
comment|/* If we have a 256 word EEPROM, there are 8 address bits */
name|em_shift_out_ee_bits
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* If we have a 64 word EEPROM, there are 6 address bits */
name|em_shift_out_ee_bits
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
literal|6
argument_list|)
expr_stmt|;
block|}
comment|/* Read the data */
operator|*
name|data
operator|=
name|em_shift_in_ee_bits
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* End this read operation */
name|em_standby_eeprom
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Stop requesting EEPROM access */
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|>
name|em_82544
condition|)
block|{
name|eecd
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|EECD
argument_list|)
expr_stmt|;
name|eecd
operator|&=
operator|~
name|E1000_EECD_REQ
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|EECD
argument_list|,
name|eecd
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Verifies that the EEPROM has a valid checksum  *   * hw - Struct containing variables accessed by shared code  *  * Reads the first 64 16 bit words of the EEPROM and sums the values read.  * If the the sum of the 64 16 bit words is 0xBABA, the EEPROM's checksum is  * valid.  *****************************************************************************/
end_comment

begin_function
name|int32_t
name|em_validate_eeprom_checksum
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|uint16_t
name|checksum
init|=
literal|0
decl_stmt|;
name|uint16_t
name|i
decl_stmt|,
name|eeprom_data
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_validate_eeprom_checksum"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|EEPROM_CHECKSUM_REG
operator|+
literal|1
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|em_read_eeprom
argument_list|(
name|hw
argument_list|,
name|i
argument_list|,
operator|&
name|eeprom_data
argument_list|)
operator|<
literal|0
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"EEPROM Read Error\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_EEPROM
return|;
block|}
name|checksum
operator|+=
name|eeprom_data
expr_stmt|;
block|}
if|if
condition|(
name|checksum
operator|==
operator|(
name|uint16_t
operator|)
name|EEPROM_SUM
condition|)
block|{
return|return
literal|0
return|;
block|}
else|else
block|{
name|DEBUGOUT
argument_list|(
literal|"EEPROM Checksum Invalid\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_EEPROM
return|;
block|}
block|}
end_function

begin_comment
comment|/******************************************************************************  * Calculates the EEPROM checksum and writes it to the EEPROM  *  * hw - Struct containing variables accessed by shared code  *  * Sums the first 63 16 bit words of the EEPROM. Subtracts the sum from 0xBABA.  * Writes the difference to word offset 63 of the EEPROM.  *****************************************************************************/
end_comment

begin_function
name|int32_t
name|em_update_eeprom_checksum
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|uint16_t
name|checksum
init|=
literal|0
decl_stmt|;
name|uint16_t
name|i
decl_stmt|,
name|eeprom_data
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_update_eeprom_checksum"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|EEPROM_CHECKSUM_REG
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|em_read_eeprom
argument_list|(
name|hw
argument_list|,
name|i
argument_list|,
operator|&
name|eeprom_data
argument_list|)
operator|<
literal|0
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"EEPROM Read Error\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_EEPROM
return|;
block|}
name|checksum
operator|+=
name|eeprom_data
expr_stmt|;
block|}
name|checksum
operator|=
operator|(
name|uint16_t
operator|)
name|EEPROM_SUM
operator|-
name|checksum
expr_stmt|;
if|if
condition|(
name|em_write_eeprom
argument_list|(
name|hw
argument_list|,
name|EEPROM_CHECKSUM_REG
argument_list|,
name|checksum
argument_list|)
operator|<
literal|0
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"EEPROM Write Error\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_EEPROM
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Writes a 16 bit word to a given offset in the EEPROM.  *  * hw - Struct containing variables accessed by shared code  * offset - offset within the EEPROM to be written to  * data - 16 bit word to be writen to the EEPROM  *  * If em_update_eeprom_checksum is not called after this function, the   * EEPROM will most likely contain an invalid checksum.  *****************************************************************************/
end_comment

begin_function
name|int32_t
name|em_write_eeprom
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint16_t
name|offset
parameter_list|,
name|uint16_t
name|data
parameter_list|)
block|{
name|uint32_t
name|eecd
decl_stmt|;
name|uint32_t
name|i
init|=
literal|0
decl_stmt|;
name|int32_t
name|status
init|=
literal|0
decl_stmt|;
name|boolean_t
name|large_eeprom
init|=
name|FALSE
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_write_eeprom"
argument_list|)
expr_stmt|;
comment|/* Request EEPROM Access */
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|>
name|em_82544
condition|)
block|{
name|eecd
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|EECD
argument_list|)
expr_stmt|;
if|if
condition|(
name|eecd
operator|&
name|E1000_EECD_SIZE
condition|)
name|large_eeprom
operator|=
name|TRUE
expr_stmt|;
name|eecd
operator||=
name|E1000_EECD_REQ
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|EECD
argument_list|,
name|eecd
argument_list|)
expr_stmt|;
name|eecd
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|EECD
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
operator|!
operator|(
name|eecd
operator|&
name|E1000_EECD_GNT
operator|)
operator|)
operator|&&
operator|(
name|i
operator|<
literal|100
operator|)
condition|)
block|{
name|i
operator|++
expr_stmt|;
name|usec_delay
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|eecd
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|EECD
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|eecd
operator|&
name|E1000_EECD_GNT
operator|)
condition|)
block|{
name|eecd
operator|&=
operator|~
name|E1000_EECD_REQ
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|EECD
argument_list|,
name|eecd
argument_list|)
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Could not acquire EEPROM grant\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_EEPROM
return|;
block|}
block|}
comment|/* Prepare the EEPROM for writing  */
name|em_setup_eeprom
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Send the 9-bit (or 11-bit on large EEPROM) EWEN (write enable) command      * to the EEPROM (5-bit opcode plus 4/6-bit dummy). This puts the EEPROM      * into write/erase mode.       */
name|em_shift_out_ee_bits
argument_list|(
name|hw
argument_list|,
name|EEPROM_EWEN_OPCODE
argument_list|,
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
name|large_eeprom
condition|)
name|em_shift_out_ee_bits
argument_list|(
name|hw
argument_list|,
literal|0
argument_list|,
literal|6
argument_list|)
expr_stmt|;
else|else
name|em_shift_out_ee_bits
argument_list|(
name|hw
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Prepare the EEPROM */
name|em_standby_eeprom
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Send the Write command (3-bit opcode + addr) */
name|em_shift_out_ee_bits
argument_list|(
name|hw
argument_list|,
name|EEPROM_WRITE_OPCODE
argument_list|,
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|large_eeprom
condition|)
comment|/* If we have a 256 word EEPROM, there are 8 address bits */
name|em_shift_out_ee_bits
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
literal|8
argument_list|)
expr_stmt|;
else|else
comment|/* If we have a 64 word EEPROM, there are 6 address bits */
name|em_shift_out_ee_bits
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
literal|6
argument_list|)
expr_stmt|;
comment|/* Send the data */
name|em_shift_out_ee_bits
argument_list|(
name|hw
argument_list|,
name|data
argument_list|,
literal|16
argument_list|)
expr_stmt|;
comment|/* Toggle the CS line.  This in effect tells to EEPROM to actually execute       * the command in question.      */
name|em_standby_eeprom
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Now read DO repeatedly until is high (equal to '1').  The EEEPROM will      * signal that the command has been completed by raising the DO signal.      * If DO does not go high in 10 milliseconds, then error out.      */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|200
condition|;
name|i
operator|++
control|)
block|{
name|eecd
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|EECD
argument_list|)
expr_stmt|;
if|if
condition|(
name|eecd
operator|&
name|E1000_EECD_DO
condition|)
break|break;
name|usec_delay
argument_list|(
literal|50
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
literal|200
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"EEPROM Write did not complete\n"
argument_list|)
expr_stmt|;
name|status
operator|=
operator|-
name|E1000_ERR_EEPROM
expr_stmt|;
block|}
comment|/* Recover from write */
name|em_standby_eeprom
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Send the 9-bit (or 11-bit on large EEPROM) EWDS (write disable) command      * to the EEPROM (5-bit opcode plus 4/6-bit dummy). This takes the EEPROM      * out of write/erase mode.      */
name|em_shift_out_ee_bits
argument_list|(
name|hw
argument_list|,
name|EEPROM_EWDS_OPCODE
argument_list|,
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
name|large_eeprom
condition|)
name|em_shift_out_ee_bits
argument_list|(
name|hw
argument_list|,
literal|0
argument_list|,
literal|6
argument_list|)
expr_stmt|;
else|else
name|em_shift_out_ee_bits
argument_list|(
name|hw
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Done with writing */
name|em_cleanup_eeprom
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Stop requesting EEPROM access */
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|>
name|em_82544
condition|)
block|{
name|eecd
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|EECD
argument_list|)
expr_stmt|;
name|eecd
operator|&=
operator|~
name|E1000_EECD_REQ
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|EECD
argument_list|,
name|eecd
argument_list|)
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Reads the adapter's part number from the EEPROM  *  * hw - Struct containing variables accessed by shared code  * part_num - Adapter's part number  *****************************************************************************/
end_comment

begin_function
name|int32_t
name|em_read_part_num
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint32_t
modifier|*
name|part_num
parameter_list|)
block|{
name|uint16_t
name|offset
init|=
name|EEPROM_PBA_BYTE_1
decl_stmt|;
name|uint16_t
name|eeprom_data
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_read_part_num"
argument_list|)
expr_stmt|;
comment|/* Get word 0 from EEPROM */
if|if
condition|(
name|em_read_eeprom
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
operator|&
name|eeprom_data
argument_list|)
operator|<
literal|0
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"EEPROM Read Error\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_EEPROM
return|;
block|}
comment|/* Save word 0 in upper half of part_num */
operator|*
name|part_num
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|eeprom_data
operator|<<
literal|16
argument_list|)
expr_stmt|;
comment|/* Get word 1 from EEPROM */
if|if
condition|(
name|em_read_eeprom
argument_list|(
name|hw
argument_list|,
operator|++
name|offset
argument_list|,
operator|&
name|eeprom_data
argument_list|)
operator|<
literal|0
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"EEPROM Read Error\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_EEPROM
return|;
block|}
comment|/* Save word 1 in lower half of part_num */
operator|*
name|part_num
operator||=
name|eeprom_data
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Reads the adapter's MAC address from the EEPROM and inverts the LSB for the  * second function of dual function devices  *  * hw - Struct containing variables accessed by shared code  *****************************************************************************/
end_comment

begin_function
name|int32_t
name|em_read_mac_addr
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|uint16_t
name|offset
decl_stmt|;
name|uint16_t
name|eeprom_data
decl_stmt|,
name|i
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_read_mac_addr"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NODE_ADDRESS_SIZE
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|offset
operator|=
name|i
operator|>>
literal|1
expr_stmt|;
if|if
condition|(
name|em_read_eeprom
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
operator|&
name|eeprom_data
argument_list|)
operator|<
literal|0
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"EEPROM Read Error\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_EEPROM
return|;
block|}
name|hw
operator|->
name|perm_mac_addr
index|[
name|i
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|eeprom_data
operator|&
literal|0x00FF
argument_list|)
expr_stmt|;
name|hw
operator|->
name|perm_mac_addr
index|[
name|i
operator|+
literal|1
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|eeprom_data
operator|>>
literal|8
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|hw
operator|->
name|mac_type
operator|==
name|em_82546
operator|)
operator|&&
operator|(
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|STATUS
argument_list|)
operator|&
name|E1000_STATUS_FUNC_1
operator|)
condition|)
block|{
if|if
condition|(
name|hw
operator|->
name|perm_mac_addr
index|[
literal|5
index|]
operator|&
literal|0x01
condition|)
name|hw
operator|->
name|perm_mac_addr
index|[
literal|5
index|]
operator|&=
operator|~
operator|(
literal|0x01
operator|)
expr_stmt|;
else|else
name|hw
operator|->
name|perm_mac_addr
index|[
literal|5
index|]
operator||=
literal|0x01
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NODE_ADDRESS_SIZE
condition|;
name|i
operator|++
control|)
name|hw
operator|->
name|mac_addr
index|[
name|i
index|]
operator|=
name|hw
operator|->
name|perm_mac_addr
index|[
name|i
index|]
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Initializes receive address filters.  *  * hw - Struct containing variables accessed by shared code   *  * Places the MAC address in receive address register 0 and clears the rest  * of the receive addresss registers. Clears the multicast table. Assumes  * the receiver is in reset when the routine is called.  *****************************************************************************/
end_comment

begin_function
name|void
name|em_init_rx_addrs
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|uint32_t
name|i
decl_stmt|;
name|uint32_t
name|addr_low
decl_stmt|;
name|uint32_t
name|addr_high
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_init_rx_addrs"
argument_list|)
expr_stmt|;
comment|/* Setup the receive address. */
name|DEBUGOUT
argument_list|(
literal|"Programming MAC Address into RAR[0]\n"
argument_list|)
expr_stmt|;
name|addr_low
operator|=
operator|(
name|hw
operator|->
name|mac_addr
index|[
literal|0
index|]
operator||
operator|(
name|hw
operator|->
name|mac_addr
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|hw
operator|->
name|mac_addr
index|[
literal|2
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|hw
operator|->
name|mac_addr
index|[
literal|3
index|]
operator|<<
literal|24
operator|)
operator|)
expr_stmt|;
name|addr_high
operator|=
operator|(
name|hw
operator|->
name|mac_addr
index|[
literal|4
index|]
operator||
operator|(
name|hw
operator|->
name|mac_addr
index|[
literal|5
index|]
operator|<<
literal|8
operator|)
operator||
name|E1000_RAH_AV
operator|)
expr_stmt|;
name|E1000_WRITE_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|RA
argument_list|,
literal|0
argument_list|,
name|addr_low
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|RA
argument_list|,
literal|1
argument_list|,
name|addr_high
argument_list|)
expr_stmt|;
comment|/* Zero out the other 15 receive addresses. */
name|DEBUGOUT
argument_list|(
literal|"Clearing RAR[1-15]\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|E1000_RAR_ENTRIES
condition|;
name|i
operator|++
control|)
block|{
name|E1000_WRITE_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|RA
argument_list|,
operator|(
name|i
operator|<<
literal|1
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|RA
argument_list|,
operator|(
operator|(
name|i
operator|<<
literal|1
operator|)
operator|+
literal|1
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/******************************************************************************  * Updates the MAC's list of multicast addresses.  *  * hw - Struct containing variables accessed by shared code  * mc_addr_list - the list of new multicast addresses  * mc_addr_count - number of addresses  * pad - number of bytes between addresses in the list  *  * The given list replaces any existing list. Clears the last 15 receive  * address registers and the multicast table. Uses receive address registers  * for the first 15 multicast addresses, and hashes the rest into the   * multicast table.  *****************************************************************************/
end_comment

begin_function
name|void
name|em_mc_addr_list_update
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint8_t
modifier|*
name|mc_addr_list
parameter_list|,
name|uint32_t
name|mc_addr_count
parameter_list|,
name|uint32_t
name|pad
parameter_list|)
block|{
name|uint32_t
name|hash_value
decl_stmt|;
name|uint32_t
name|i
decl_stmt|;
name|uint32_t
name|rar_used_count
init|=
literal|1
decl_stmt|;
comment|/* RAR[0] is used for our MAC address */
name|DEBUGFUNC
argument_list|(
literal|"em_mc_addr_list_update"
argument_list|)
expr_stmt|;
comment|/* Set the new number of MC addresses that we are being requested to use. */
name|hw
operator|->
name|num_mc_addrs
operator|=
name|mc_addr_count
expr_stmt|;
comment|/* Clear RAR[1-15] */
name|DEBUGOUT
argument_list|(
literal|" Clearing RAR[1-15]\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|rar_used_count
init|;
name|i
operator|<
name|E1000_RAR_ENTRIES
condition|;
name|i
operator|++
control|)
block|{
name|E1000_WRITE_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|RA
argument_list|,
operator|(
name|i
operator|<<
literal|1
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|RA
argument_list|,
operator|(
operator|(
name|i
operator|<<
literal|1
operator|)
operator|+
literal|1
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Clear the MTA */
name|DEBUGOUT
argument_list|(
literal|" Clearing MTA\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|E1000_NUM_MTA_REGISTERS
condition|;
name|i
operator|++
control|)
block|{
name|E1000_WRITE_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|MTA
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Add the new addresses */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mc_addr_count
condition|;
name|i
operator|++
control|)
block|{
name|DEBUGOUT
argument_list|(
literal|" Adding the multicast addresses:\n"
argument_list|)
expr_stmt|;
name|DEBUGOUT7
argument_list|(
literal|" MC Addr #%d =%.2X %.2X %.2X %.2X %.2X %.2X\n"
argument_list|,
name|i
argument_list|,
name|mc_addr_list
index|[
name|i
operator|*
operator|(
name|ETH_LENGTH_OF_ADDRESS
operator|+
name|pad
operator|)
index|]
argument_list|,
name|mc_addr_list
index|[
name|i
operator|*
operator|(
name|ETH_LENGTH_OF_ADDRESS
operator|+
name|pad
operator|)
operator|+
literal|1
index|]
argument_list|,
name|mc_addr_list
index|[
name|i
operator|*
operator|(
name|ETH_LENGTH_OF_ADDRESS
operator|+
name|pad
operator|)
operator|+
literal|2
index|]
argument_list|,
name|mc_addr_list
index|[
name|i
operator|*
operator|(
name|ETH_LENGTH_OF_ADDRESS
operator|+
name|pad
operator|)
operator|+
literal|3
index|]
argument_list|,
name|mc_addr_list
index|[
name|i
operator|*
operator|(
name|ETH_LENGTH_OF_ADDRESS
operator|+
name|pad
operator|)
operator|+
literal|4
index|]
argument_list|,
name|mc_addr_list
index|[
name|i
operator|*
operator|(
name|ETH_LENGTH_OF_ADDRESS
operator|+
name|pad
operator|)
operator|+
literal|5
index|]
argument_list|)
expr_stmt|;
name|hash_value
operator|=
name|em_hash_mc_addr
argument_list|(
name|hw
argument_list|,
name|mc_addr_list
operator|+
operator|(
name|i
operator|*
operator|(
name|ETH_LENGTH_OF_ADDRESS
operator|+
name|pad
operator|)
operator|)
argument_list|)
expr_stmt|;
name|DEBUGOUT1
argument_list|(
literal|" Hash value = 0x%03X\n"
argument_list|,
name|hash_value
argument_list|)
expr_stmt|;
comment|/* Place this multicast address in the RAR if there is room, *          * else put it in the MTA                      */
if|if
condition|(
name|rar_used_count
operator|<
name|E1000_RAR_ENTRIES
condition|)
block|{
name|em_rar_set
argument_list|(
name|hw
argument_list|,
name|mc_addr_list
operator|+
operator|(
name|i
operator|*
operator|(
name|ETH_LENGTH_OF_ADDRESS
operator|+
name|pad
operator|)
operator|)
argument_list|,
name|rar_used_count
argument_list|)
expr_stmt|;
name|rar_used_count
operator|++
expr_stmt|;
block|}
else|else
block|{
name|em_mta_set
argument_list|(
name|hw
argument_list|,
name|hash_value
argument_list|)
expr_stmt|;
block|}
block|}
name|DEBUGOUT
argument_list|(
literal|"MC Update Complete\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Hashes an address to determine its location in the multicast table  *  * hw - Struct containing variables accessed by shared code  * mc_addr - the multicast address to hash   *****************************************************************************/
end_comment

begin_function
name|uint32_t
name|em_hash_mc_addr
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint8_t
modifier|*
name|mc_addr
parameter_list|)
block|{
name|uint32_t
name|hash_value
init|=
literal|0
decl_stmt|;
comment|/* The portion of the address that is used for the hash table is      * determined by the mc_filter_type setting.        */
switch|switch
condition|(
name|hw
operator|->
name|mc_filter_type
condition|)
block|{
comment|/* [0] [1] [2] [3] [4] [5]      * 01  AA  00  12  34  56      * LSB                 MSB      */
case|case
literal|0
case|:
comment|/* [47:36] i.e. 0x563 for above example address */
name|hash_value
operator|=
operator|(
operator|(
name|mc_addr
index|[
literal|4
index|]
operator|>>
literal|4
operator|)
operator||
operator|(
operator|(
operator|(
name|uint16_t
operator|)
name|mc_addr
index|[
literal|5
index|]
operator|)
operator|<<
literal|4
operator|)
operator|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* [46:35] i.e. 0xAC6 for above example address */
name|hash_value
operator|=
operator|(
operator|(
name|mc_addr
index|[
literal|4
index|]
operator|>>
literal|3
operator|)
operator||
operator|(
operator|(
operator|(
name|uint16_t
operator|)
name|mc_addr
index|[
literal|5
index|]
operator|)
operator|<<
literal|5
operator|)
operator|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* [45:34] i.e. 0x5D8 for above example address */
name|hash_value
operator|=
operator|(
operator|(
name|mc_addr
index|[
literal|4
index|]
operator|>>
literal|2
operator|)
operator||
operator|(
operator|(
operator|(
name|uint16_t
operator|)
name|mc_addr
index|[
literal|5
index|]
operator|)
operator|<<
literal|6
operator|)
operator|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* [43:32] i.e. 0x634 for above example address */
name|hash_value
operator|=
operator|(
operator|(
name|mc_addr
index|[
literal|4
index|]
operator|)
operator||
operator|(
operator|(
operator|(
name|uint16_t
operator|)
name|mc_addr
index|[
literal|5
index|]
operator|)
operator|<<
literal|8
operator|)
operator|)
expr_stmt|;
break|break;
block|}
name|hash_value
operator|&=
literal|0xFFF
expr_stmt|;
return|return
name|hash_value
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Sets the bit in the multicast table corresponding to the hash value.  *  * hw - Struct containing variables accessed by shared code  * hash_value - Multicast address hash value  *****************************************************************************/
end_comment

begin_function
name|void
name|em_mta_set
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint32_t
name|hash_value
parameter_list|)
block|{
name|uint32_t
name|hash_bit
decl_stmt|,
name|hash_reg
decl_stmt|;
name|uint32_t
name|mta
decl_stmt|;
name|uint32_t
name|temp
decl_stmt|;
comment|/* The MTA is a register array of 128 32-bit registers.        * It is treated like an array of 4096 bits.  We want to set       * bit BitArray[hash_value]. So we figure out what register      * the bit is in, read it, OR in the new bit, then write      * back the new value.  The register is determined by the       * upper 7 bits of the hash value and the bit within that       * register are determined by the lower 5 bits of the value.      */
name|hash_reg
operator|=
operator|(
name|hash_value
operator|>>
literal|5
operator|)
operator|&
literal|0x7F
expr_stmt|;
name|hash_bit
operator|=
name|hash_value
operator|&
literal|0x1F
expr_stmt|;
name|mta
operator|=
name|E1000_READ_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|MTA
argument_list|,
name|hash_reg
argument_list|)
expr_stmt|;
name|mta
operator||=
operator|(
literal|1
operator|<<
name|hash_bit
operator|)
expr_stmt|;
comment|/* If we are on an 82544 and we are trying to write an odd offset      * in the MTA, save off the previous entry before writing and      * restore the old value after writing.      */
if|if
condition|(
operator|(
name|hw
operator|->
name|mac_type
operator|==
name|em_82544
operator|)
operator|&&
operator|(
operator|(
name|hash_reg
operator|&
literal|0x1
operator|)
operator|==
literal|1
operator|)
condition|)
block|{
name|temp
operator|=
name|E1000_READ_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|MTA
argument_list|,
operator|(
name|hash_reg
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|MTA
argument_list|,
name|hash_reg
argument_list|,
name|mta
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|MTA
argument_list|,
operator|(
name|hash_reg
operator|-
literal|1
operator|)
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|E1000_WRITE_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|MTA
argument_list|,
name|hash_reg
argument_list|,
name|mta
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/******************************************************************************  * Puts an ethernet address into a receive address register.  *  * hw - Struct containing variables accessed by shared code  * addr - Address to put into receive address register  * index - Receive address register to write  *****************************************************************************/
end_comment

begin_function
name|void
name|em_rar_set
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint8_t
modifier|*
name|addr
parameter_list|,
name|uint32_t
name|index
parameter_list|)
block|{
name|uint32_t
name|rar_low
decl_stmt|,
name|rar_high
decl_stmt|;
comment|/* HW expects these in little endian so we reverse the byte order      * from network order (big endian) to little endian                    */
name|rar_low
operator|=
operator|(
operator|(
name|uint32_t
operator|)
name|addr
index|[
literal|0
index|]
operator||
operator|(
operator|(
name|uint32_t
operator|)
name|addr
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
name|uint32_t
operator|)
name|addr
index|[
literal|2
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|uint32_t
operator|)
name|addr
index|[
literal|3
index|]
operator|<<
literal|24
operator|)
operator|)
expr_stmt|;
name|rar_high
operator|=
operator|(
operator|(
name|uint32_t
operator|)
name|addr
index|[
literal|4
index|]
operator||
operator|(
operator|(
name|uint32_t
operator|)
name|addr
index|[
literal|5
index|]
operator|<<
literal|8
operator|)
operator||
name|E1000_RAH_AV
operator|)
expr_stmt|;
name|E1000_WRITE_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|RA
argument_list|,
operator|(
name|index
operator|<<
literal|1
operator|)
argument_list|,
name|rar_low
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|RA
argument_list|,
operator|(
operator|(
name|index
operator|<<
literal|1
operator|)
operator|+
literal|1
operator|)
argument_list|,
name|rar_high
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Writes a value to the specified offset in the VLAN filter table.  *  * hw - Struct containing variables accessed by shared code  * offset - Offset in VLAN filer table to write  * value - Value to write into VLAN filter table  *****************************************************************************/
end_comment

begin_function
name|void
name|em_write_vfta
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint32_t
name|offset
parameter_list|,
name|uint32_t
name|value
parameter_list|)
block|{
name|uint32_t
name|temp
decl_stmt|;
if|if
condition|(
operator|(
name|hw
operator|->
name|mac_type
operator|==
name|em_82544
operator|)
operator|&&
operator|(
operator|(
name|offset
operator|&
literal|0x1
operator|)
operator|==
literal|1
operator|)
condition|)
block|{
name|temp
operator|=
name|E1000_READ_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|VFTA
argument_list|,
operator|(
name|offset
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|VFTA
argument_list|,
name|offset
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|VFTA
argument_list|,
operator|(
name|offset
operator|-
literal|1
operator|)
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|E1000_WRITE_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|VFTA
argument_list|,
name|offset
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/******************************************************************************  * Clears the VLAN filer table  *  * hw - Struct containing variables accessed by shared code  *****************************************************************************/
end_comment

begin_function
name|void
name|em_clear_vfta
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|uint32_t
name|offset
decl_stmt|;
for|for
control|(
name|offset
operator|=
literal|0
init|;
name|offset
operator|<
name|E1000_VLAN_FILTER_TBL_SIZE
condition|;
name|offset
operator|++
control|)
name|E1000_WRITE_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|VFTA
argument_list|,
name|offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int32_t
name|em_id_led_init
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|uint32_t
name|ledctl
decl_stmt|;
specifier|const
name|uint32_t
name|ledctl_mask
init|=
literal|0x000000FF
decl_stmt|;
specifier|const
name|uint32_t
name|ledctl_on
init|=
name|E1000_LEDCTL_MODE_LED_ON
decl_stmt|;
specifier|const
name|uint32_t
name|ledctl_off
init|=
name|E1000_LEDCTL_MODE_LED_OFF
decl_stmt|;
name|uint16_t
name|eeprom_data
decl_stmt|,
name|i
decl_stmt|,
name|temp
decl_stmt|;
specifier|const
name|uint16_t
name|led_mask
init|=
literal|0x0F
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_id_led_init"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|<
name|em_82540
condition|)
block|{
comment|/* Nothing to do */
return|return
literal|0
return|;
block|}
name|ledctl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|LEDCTL
argument_list|)
expr_stmt|;
name|hw
operator|->
name|ledctl_default
operator|=
name|ledctl
expr_stmt|;
name|hw
operator|->
name|ledctl_mode1
operator|=
name|hw
operator|->
name|ledctl_default
expr_stmt|;
name|hw
operator|->
name|ledctl_mode2
operator|=
name|hw
operator|->
name|ledctl_default
expr_stmt|;
if|if
condition|(
name|em_read_eeprom
argument_list|(
name|hw
argument_list|,
name|EEPROM_ID_LED_SETTINGS
argument_list|,
operator|&
name|eeprom_data
argument_list|)
operator|<
literal|0
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"EEPROM Read Error\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_EEPROM
return|;
block|}
if|if
condition|(
operator|(
name|eeprom_data
operator|==
name|ID_LED_RESERVED_0000
operator|)
operator|||
operator|(
name|eeprom_data
operator|==
name|ID_LED_RESERVED_FFFF
operator|)
condition|)
name|eeprom_data
operator|=
name|ID_LED_DEFAULT
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|temp
operator|=
operator|(
name|eeprom_data
operator|>>
operator|(
name|i
operator|<<
literal|2
operator|)
operator|)
operator|&
name|led_mask
expr_stmt|;
switch|switch
condition|(
name|temp
condition|)
block|{
case|case
name|ID_LED_ON1_DEF2
case|:
case|case
name|ID_LED_ON1_ON2
case|:
case|case
name|ID_LED_ON1_OFF2
case|:
name|hw
operator|->
name|ledctl_mode1
operator|&=
operator|~
operator|(
name|ledctl_mask
operator|<<
operator|(
name|i
operator|<<
literal|3
operator|)
operator|)
expr_stmt|;
name|hw
operator|->
name|ledctl_mode1
operator||=
name|ledctl_on
operator|<<
operator|(
name|i
operator|<<
literal|3
operator|)
expr_stmt|;
break|break;
case|case
name|ID_LED_OFF1_DEF2
case|:
case|case
name|ID_LED_OFF1_ON2
case|:
case|case
name|ID_LED_OFF1_OFF2
case|:
name|hw
operator|->
name|ledctl_mode1
operator|&=
operator|~
operator|(
name|ledctl_mask
operator|<<
operator|(
name|i
operator|<<
literal|3
operator|)
operator|)
expr_stmt|;
name|hw
operator|->
name|ledctl_mode1
operator||=
name|ledctl_off
operator|<<
operator|(
name|i
operator|<<
literal|3
operator|)
expr_stmt|;
break|break;
default|default:
comment|/* Do nothing */
break|break;
block|}
switch|switch
condition|(
name|temp
condition|)
block|{
case|case
name|ID_LED_DEF1_ON2
case|:
case|case
name|ID_LED_ON1_ON2
case|:
case|case
name|ID_LED_OFF1_ON2
case|:
name|hw
operator|->
name|ledctl_mode2
operator|&=
operator|~
operator|(
name|ledctl_mask
operator|<<
operator|(
name|i
operator|<<
literal|3
operator|)
operator|)
expr_stmt|;
name|hw
operator|->
name|ledctl_mode2
operator||=
name|ledctl_on
operator|<<
operator|(
name|i
operator|<<
literal|3
operator|)
expr_stmt|;
break|break;
case|case
name|ID_LED_DEF1_OFF2
case|:
case|case
name|ID_LED_ON1_OFF2
case|:
case|case
name|ID_LED_OFF1_OFF2
case|:
name|hw
operator|->
name|ledctl_mode2
operator|&=
operator|~
operator|(
name|ledctl_mask
operator|<<
operator|(
name|i
operator|<<
literal|3
operator|)
operator|)
expr_stmt|;
name|hw
operator|->
name|ledctl_mode2
operator||=
name|ledctl_off
operator|<<
operator|(
name|i
operator|<<
literal|3
operator|)
expr_stmt|;
break|break;
default|default:
comment|/* Do nothing */
break|break;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Prepares SW controlable LED for use and saves the current state of the LED.  *  * hw - Struct containing variables accessed by shared code  *****************************************************************************/
end_comment

begin_function
name|int32_t
name|em_setup_led
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|uint32_t
name|ledctl
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_setup_led"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|hw
operator|->
name|device_id
condition|)
block|{
case|case
name|E1000_DEV_ID_82542
case|:
case|case
name|E1000_DEV_ID_82543GC_FIBER
case|:
case|case
name|E1000_DEV_ID_82543GC_COPPER
case|:
case|case
name|E1000_DEV_ID_82544EI_COPPER
case|:
case|case
name|E1000_DEV_ID_82544EI_FIBER
case|:
case|case
name|E1000_DEV_ID_82544GC_COPPER
case|:
case|case
name|E1000_DEV_ID_82544GC_LOM
case|:
comment|/* No setup necessary */
break|break;
case|case
name|E1000_DEV_ID_82545EM_FIBER
case|:
case|case
name|E1000_DEV_ID_82546EB_FIBER
case|:
name|ledctl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|LEDCTL
argument_list|)
expr_stmt|;
comment|/* Save current LEDCTL settings */
name|hw
operator|->
name|ledctl_default
operator|=
name|ledctl
expr_stmt|;
comment|/* Turn off LED0 */
name|ledctl
operator|&=
operator|~
operator|(
name|E1000_LEDCTL_LED0_IVRT
operator||
name|E1000_LEDCTL_LED0_BLINK
operator||
name|E1000_LEDCTL_LED0_MODE_MASK
operator|)
expr_stmt|;
name|ledctl
operator||=
operator|(
name|E1000_LEDCTL_MODE_LED_OFF
operator|<<
name|E1000_LEDCTL_LED0_MODE_SHIFT
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|LEDCTL
argument_list|,
name|ledctl
argument_list|)
expr_stmt|;
break|break;
case|case
name|E1000_DEV_ID_82540EP
case|:
case|case
name|E1000_DEV_ID_82540EP_LOM
case|:
case|case
name|E1000_DEV_ID_82540EP_LP
case|:
case|case
name|E1000_DEV_ID_82540EM
case|:
case|case
name|E1000_DEV_ID_82540EM_LOM
case|:
case|case
name|E1000_DEV_ID_82545EM_COPPER
case|:
case|case
name|E1000_DEV_ID_82546EB_COPPER
case|:
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|LEDCTL
argument_list|,
name|hw
operator|->
name|ledctl_mode1
argument_list|)
expr_stmt|;
break|break;
default|default:
name|DEBUGOUT
argument_list|(
literal|"Invalid device ID\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_CONFIG
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Restores the saved state of the SW controlable LED.  *  * hw - Struct containing variables accessed by shared code  *****************************************************************************/
end_comment

begin_function
name|int32_t
name|em_cleanup_led
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"em_cleanup_led"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|hw
operator|->
name|device_id
condition|)
block|{
case|case
name|E1000_DEV_ID_82542
case|:
case|case
name|E1000_DEV_ID_82543GC_FIBER
case|:
case|case
name|E1000_DEV_ID_82543GC_COPPER
case|:
case|case
name|E1000_DEV_ID_82544EI_COPPER
case|:
case|case
name|E1000_DEV_ID_82544EI_FIBER
case|:
case|case
name|E1000_DEV_ID_82544GC_COPPER
case|:
case|case
name|E1000_DEV_ID_82544GC_LOM
case|:
comment|/* No cleanup necessary */
break|break;
case|case
name|E1000_DEV_ID_82540EP
case|:
case|case
name|E1000_DEV_ID_82540EP_LOM
case|:
case|case
name|E1000_DEV_ID_82540EP_LP
case|:
case|case
name|E1000_DEV_ID_82540EM
case|:
case|case
name|E1000_DEV_ID_82540EM_LOM
case|:
case|case
name|E1000_DEV_ID_82545EM_COPPER
case|:
case|case
name|E1000_DEV_ID_82545EM_FIBER
case|:
case|case
name|E1000_DEV_ID_82546EB_COPPER
case|:
case|case
name|E1000_DEV_ID_82546EB_FIBER
case|:
comment|/* Restore LEDCTL settings */
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|LEDCTL
argument_list|,
name|hw
operator|->
name|ledctl_default
argument_list|)
expr_stmt|;
break|break;
default|default:
name|DEBUGOUT
argument_list|(
literal|"Invalid device ID\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_CONFIG
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Turns on the software controllable LED  *  * hw - Struct containing variables accessed by shared code  *****************************************************************************/
end_comment

begin_function
name|int32_t
name|em_led_on
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|uint32_t
name|ctrl
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_led_on"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|hw
operator|->
name|device_id
condition|)
block|{
case|case
name|E1000_DEV_ID_82542
case|:
case|case
name|E1000_DEV_ID_82543GC_FIBER
case|:
case|case
name|E1000_DEV_ID_82543GC_COPPER
case|:
case|case
name|E1000_DEV_ID_82544EI_FIBER
case|:
name|ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|)
expr_stmt|;
comment|/* Set SW Defineable Pin 0 to turn on the LED */
name|ctrl
operator||=
name|E1000_CTRL_SWDPIN0
expr_stmt|;
name|ctrl
operator||=
name|E1000_CTRL_SWDPIO0
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
break|break;
case|case
name|E1000_DEV_ID_82544EI_COPPER
case|:
case|case
name|E1000_DEV_ID_82544GC_COPPER
case|:
case|case
name|E1000_DEV_ID_82544GC_LOM
case|:
case|case
name|E1000_DEV_ID_82545EM_FIBER
case|:
case|case
name|E1000_DEV_ID_82546EB_FIBER
case|:
name|ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|)
expr_stmt|;
comment|/* Clear SW Defineable Pin 0 to turn on the LED */
name|ctrl
operator|&=
operator|~
name|E1000_CTRL_SWDPIN0
expr_stmt|;
name|ctrl
operator||=
name|E1000_CTRL_SWDPIO0
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
break|break;
case|case
name|E1000_DEV_ID_82540EP
case|:
case|case
name|E1000_DEV_ID_82540EP_LOM
case|:
case|case
name|E1000_DEV_ID_82540EP_LP
case|:
case|case
name|E1000_DEV_ID_82540EM
case|:
case|case
name|E1000_DEV_ID_82540EM_LOM
case|:
case|case
name|E1000_DEV_ID_82545EM_COPPER
case|:
case|case
name|E1000_DEV_ID_82546EB_COPPER
case|:
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|LEDCTL
argument_list|,
name|hw
operator|->
name|ledctl_mode2
argument_list|)
expr_stmt|;
break|break;
default|default:
name|DEBUGOUT
argument_list|(
literal|"Invalid device ID\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_CONFIG
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Turns off the software controllable LED  *  * hw - Struct containing variables accessed by shared code  *****************************************************************************/
end_comment

begin_function
name|int32_t
name|em_led_off
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|uint32_t
name|ctrl
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_led_off"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|hw
operator|->
name|device_id
condition|)
block|{
case|case
name|E1000_DEV_ID_82542
case|:
case|case
name|E1000_DEV_ID_82543GC_FIBER
case|:
case|case
name|E1000_DEV_ID_82543GC_COPPER
case|:
case|case
name|E1000_DEV_ID_82544EI_FIBER
case|:
name|ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|)
expr_stmt|;
comment|/* Clear SW Defineable Pin 0 to turn off the LED */
name|ctrl
operator|&=
operator|~
name|E1000_CTRL_SWDPIN0
expr_stmt|;
name|ctrl
operator||=
name|E1000_CTRL_SWDPIO0
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
break|break;
case|case
name|E1000_DEV_ID_82544EI_COPPER
case|:
case|case
name|E1000_DEV_ID_82544GC_COPPER
case|:
case|case
name|E1000_DEV_ID_82544GC_LOM
case|:
case|case
name|E1000_DEV_ID_82545EM_FIBER
case|:
case|case
name|E1000_DEV_ID_82546EB_FIBER
case|:
name|ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|)
expr_stmt|;
comment|/* Set SW Defineable Pin 0 to turn off the LED */
name|ctrl
operator||=
name|E1000_CTRL_SWDPIN0
expr_stmt|;
name|ctrl
operator||=
name|E1000_CTRL_SWDPIO0
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
break|break;
case|case
name|E1000_DEV_ID_82540EP
case|:
case|case
name|E1000_DEV_ID_82540EP_LOM
case|:
case|case
name|E1000_DEV_ID_82540EP_LP
case|:
case|case
name|E1000_DEV_ID_82540EM
case|:
case|case
name|E1000_DEV_ID_82540EM_LOM
case|:
case|case
name|E1000_DEV_ID_82545EM_COPPER
case|:
case|case
name|E1000_DEV_ID_82546EB_COPPER
case|:
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|LEDCTL
argument_list|,
name|hw
operator|->
name|ledctl_mode1
argument_list|)
expr_stmt|;
break|break;
default|default:
name|DEBUGOUT
argument_list|(
literal|"Invalid device ID\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_CONFIG
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Clears all hardware statistics counters.   *  * hw - Struct containing variables accessed by shared code  *****************************************************************************/
end_comment

begin_function
name|void
name|em_clear_hw_cntrs
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
specifier|volatile
name|uint32_t
name|temp
decl_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|CRCERRS
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|SYMERRS
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|MPC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|SCC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|ECOL
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|MCC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|LATECOL
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|COLC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|DC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|SEC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|RLEC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|XONRXC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|XONTXC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|XOFFRXC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|XOFFTXC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|FCRUC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|PRC64
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|PRC127
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|PRC255
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|PRC511
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|PRC1023
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|PRC1522
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|GPRC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|BPRC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|MPRC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|GPTC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|GORCL
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|GORCH
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|GOTCL
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|GOTCH
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|RNBC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|RUC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|RFC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|ROC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|RJC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|TORL
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|TORH
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|TOTL
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|TOTH
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|TPR
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|TPT
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|PTC64
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|PTC127
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|PTC255
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|PTC511
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|PTC1023
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|PTC1522
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|MPTC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|BPTC
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|<
name|em_82543
condition|)
return|return;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|ALGNERRC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|RXERRC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|TNCRS
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|CEXTERR
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|TSCTC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|TSCTFC
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|<=
name|em_82544
condition|)
return|return;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|MGTPRC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|MGTPDC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|MGTPTC
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Resets Adaptive IFS to its default state.  *  * hw - Struct containing variables accessed by shared code  *  * Call this after em_init_hw. You may override the IFS defaults by setting  * hw->ifs_params_forced to TRUE. However, you must initialize hw->  * current_ifs_val, ifs_min_val, ifs_max_val, ifs_step_size, and ifs_ratio  * before calling this function.  *****************************************************************************/
end_comment

begin_function
name|void
name|em_reset_adaptive
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"em_reset_adaptive"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|adaptive_ifs
condition|)
block|{
if|if
condition|(
operator|!
name|hw
operator|->
name|ifs_params_forced
condition|)
block|{
name|hw
operator|->
name|current_ifs_val
operator|=
literal|0
expr_stmt|;
name|hw
operator|->
name|ifs_min_val
operator|=
name|IFS_MIN
expr_stmt|;
name|hw
operator|->
name|ifs_max_val
operator|=
name|IFS_MAX
expr_stmt|;
name|hw
operator|->
name|ifs_step_size
operator|=
name|IFS_STEP
expr_stmt|;
name|hw
operator|->
name|ifs_ratio
operator|=
name|IFS_RATIO
expr_stmt|;
block|}
name|hw
operator|->
name|in_ifs_mode
operator|=
name|FALSE
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|AIT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DEBUGOUT
argument_list|(
literal|"Not in Adaptive IFS mode!\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/******************************************************************************  * Called during the callback/watchdog routine to update IFS value based on  * the ratio of transmits to collisions.  *  * hw - Struct containing variables accessed by shared code  * tx_packets - Number of transmits since last callback  * total_collisions - Number of collisions since last callback  *****************************************************************************/
end_comment

begin_function
name|void
name|em_update_adaptive
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"em_update_adaptive"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|adaptive_ifs
condition|)
block|{
if|if
condition|(
operator|(
name|hw
operator|->
name|collision_delta
operator|*
name|hw
operator|->
name|ifs_ratio
operator|)
operator|>
name|hw
operator|->
name|tx_packet_delta
condition|)
block|{
if|if
condition|(
name|hw
operator|->
name|tx_packet_delta
operator|>
name|MIN_NUM_XMITS
condition|)
block|{
name|hw
operator|->
name|in_ifs_mode
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|current_ifs_val
operator|<
name|hw
operator|->
name|ifs_max_val
condition|)
block|{
if|if
condition|(
name|hw
operator|->
name|current_ifs_val
operator|==
literal|0
condition|)
name|hw
operator|->
name|current_ifs_val
operator|=
name|hw
operator|->
name|ifs_min_val
expr_stmt|;
else|else
name|hw
operator|->
name|current_ifs_val
operator|+=
name|hw
operator|->
name|ifs_step_size
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|AIT
argument_list|,
name|hw
operator|->
name|current_ifs_val
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|hw
operator|->
name|in_ifs_mode
operator|==
name|TRUE
operator|)
operator|&&
operator|(
name|hw
operator|->
name|tx_packet_delta
operator|<=
name|MIN_NUM_XMITS
operator|)
condition|)
block|{
name|hw
operator|->
name|current_ifs_val
operator|=
literal|0
expr_stmt|;
name|hw
operator|->
name|in_ifs_mode
operator|=
name|FALSE
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|AIT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|DEBUGOUT
argument_list|(
literal|"Not in Adaptive IFS mode!\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/******************************************************************************  * Adjusts the statistic counters when a frame is accepted by TBI_ACCEPT  *   * hw - Struct containing variables accessed by shared code  * frame_len - The length of the frame in question  * mac_addr - The Ethernet destination address of the frame in question  *****************************************************************************/
end_comment

begin_function
name|void
name|em_tbi_adjust_stats
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|struct
name|em_hw_stats
modifier|*
name|stats
parameter_list|,
name|uint32_t
name|frame_len
parameter_list|,
name|uint8_t
modifier|*
name|mac_addr
parameter_list|)
block|{
name|uint64_t
name|carry_bit
decl_stmt|;
comment|/* First adjust the frame length. */
name|frame_len
operator|--
expr_stmt|;
comment|/* We need to adjust the statistics counters, since the hardware      * counters overcount this packet as a CRC error and undercount      * the packet as a good packet      */
comment|/* This packet should not be counted as a CRC error.    */
name|stats
operator|->
name|crcerrs
operator|--
expr_stmt|;
comment|/* This packet does count as a Good Packet Received.    */
name|stats
operator|->
name|gprc
operator|++
expr_stmt|;
comment|/* Adjust the Good Octets received counters             */
name|carry_bit
operator|=
literal|0x80000000
operator|&
name|stats
operator|->
name|gorcl
expr_stmt|;
name|stats
operator|->
name|gorcl
operator|+=
name|frame_len
expr_stmt|;
comment|/* If the high bit of Gorcl (the low 32 bits of the Good Octets      * Received Count) was one before the addition,       * AND it is zero after, then we lost the carry out,       * need to add one to Gorch (Good Octets Received Count High).      * This could be simplified if all environments supported       * 64-bit integers.      */
if|if
condition|(
name|carry_bit
operator|&&
operator|(
operator|(
name|stats
operator|->
name|gorcl
operator|&
literal|0x80000000
operator|)
operator|==
literal|0
operator|)
condition|)
name|stats
operator|->
name|gorch
operator|++
expr_stmt|;
comment|/* Is this a broadcast or multicast?  Check broadcast first,      * since the test for a multicast frame will test positive on       * a broadcast frame.      */
if|if
condition|(
operator|(
name|mac_addr
index|[
literal|0
index|]
operator|==
operator|(
name|uint8_t
operator|)
literal|0xff
operator|)
operator|&&
operator|(
name|mac_addr
index|[
literal|1
index|]
operator|==
operator|(
name|uint8_t
operator|)
literal|0xff
operator|)
condition|)
comment|/* Broadcast packet */
name|stats
operator|->
name|bprc
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|mac_addr
operator|&
literal|0x01
condition|)
comment|/* Multicast packet */
name|stats
operator|->
name|mprc
operator|++
expr_stmt|;
if|if
condition|(
name|frame_len
operator|==
name|hw
operator|->
name|max_frame_size
condition|)
block|{
comment|/* In this case, the hardware has overcounted the number of          * oversize frames.          */
if|if
condition|(
name|stats
operator|->
name|roc
operator|>
literal|0
condition|)
name|stats
operator|->
name|roc
operator|--
expr_stmt|;
block|}
comment|/* Adjust the bin counters when the extra byte put the frame in the      * wrong bin. Remember that the frame_len was adjusted above.      */
if|if
condition|(
name|frame_len
operator|==
literal|64
condition|)
block|{
name|stats
operator|->
name|prc64
operator|++
expr_stmt|;
name|stats
operator|->
name|prc127
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|frame_len
operator|==
literal|127
condition|)
block|{
name|stats
operator|->
name|prc127
operator|++
expr_stmt|;
name|stats
operator|->
name|prc255
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|frame_len
operator|==
literal|255
condition|)
block|{
name|stats
operator|->
name|prc255
operator|++
expr_stmt|;
name|stats
operator|->
name|prc511
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|frame_len
operator|==
literal|511
condition|)
block|{
name|stats
operator|->
name|prc511
operator|++
expr_stmt|;
name|stats
operator|->
name|prc1023
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|frame_len
operator|==
literal|1023
condition|)
block|{
name|stats
operator|->
name|prc1023
operator|++
expr_stmt|;
name|stats
operator|->
name|prc1522
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|frame_len
operator|==
literal|1522
condition|)
block|{
name|stats
operator|->
name|prc1522
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/******************************************************************************  * Gets the current PCI bus type, speed, and width of the hardware  *  * hw - Struct containing variables accessed by shared code  *****************************************************************************/
end_comment

begin_function
name|void
name|em_get_bus_info
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|uint32_t
name|status
decl_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|<
name|em_82543
condition|)
block|{
name|hw
operator|->
name|bus_type
operator|=
name|em_bus_type_unknown
expr_stmt|;
name|hw
operator|->
name|bus_speed
operator|=
name|em_bus_speed_unknown
expr_stmt|;
name|hw
operator|->
name|bus_width
operator|=
name|em_bus_width_unknown
expr_stmt|;
return|return;
block|}
name|status
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|STATUS
argument_list|)
expr_stmt|;
name|hw
operator|->
name|bus_type
operator|=
operator|(
name|status
operator|&
name|E1000_STATUS_PCIX_MODE
operator|)
condition|?
name|em_bus_type_pcix
else|:
name|em_bus_type_pci
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|bus_type
operator|==
name|em_bus_type_pci
condition|)
block|{
name|hw
operator|->
name|bus_speed
operator|=
operator|(
name|status
operator|&
name|E1000_STATUS_PCI66
operator|)
condition|?
name|em_bus_speed_66
else|:
name|em_bus_speed_33
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|status
operator|&
name|E1000_STATUS_PCIX_SPEED
condition|)
block|{
case|case
name|E1000_STATUS_PCIX_SPEED_66
case|:
name|hw
operator|->
name|bus_speed
operator|=
name|em_bus_speed_66
expr_stmt|;
break|break;
case|case
name|E1000_STATUS_PCIX_SPEED_100
case|:
name|hw
operator|->
name|bus_speed
operator|=
name|em_bus_speed_100
expr_stmt|;
break|break;
case|case
name|E1000_STATUS_PCIX_SPEED_133
case|:
name|hw
operator|->
name|bus_speed
operator|=
name|em_bus_speed_133
expr_stmt|;
break|break;
default|default:
name|hw
operator|->
name|bus_speed
operator|=
name|em_bus_speed_reserved
expr_stmt|;
break|break;
block|}
block|}
name|hw
operator|->
name|bus_width
operator|=
operator|(
name|status
operator|&
name|E1000_STATUS_BUS64
operator|)
condition|?
name|em_bus_width_64
else|:
name|em_bus_width_32
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Reads a value from one of the devices registers using port I/O (as opposed  * memory mapped I/O). Only 82544 and newer devices support port I/O.  *  * hw - Struct containing variables accessed by shared code  * offset - offset to read from  *****************************************************************************/
end_comment

begin_function
name|uint32_t
name|em_read_reg_io
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint32_t
name|offset
parameter_list|)
block|{
name|uint32_t
name|io_addr
init|=
name|hw
operator|->
name|io_base
decl_stmt|;
name|uint32_t
name|io_data
init|=
name|hw
operator|->
name|io_base
operator|+
literal|4
decl_stmt|;
name|em_io_write
argument_list|(
name|hw
argument_list|,
name|io_addr
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|em_io_read
argument_list|(
name|hw
argument_list|,
name|io_data
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Writes a value to one of the devices registers using port I/O (as opposed to  * memory mapped I/O). Only 82544 and newer devices support port I/O.  *  * hw - Struct containing variables accessed by shared code  * offset - offset to write to  * value - value to write  *****************************************************************************/
end_comment

begin_function
name|void
name|em_write_reg_io
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint32_t
name|offset
parameter_list|,
name|uint32_t
name|value
parameter_list|)
block|{
name|uint32_t
name|io_addr
init|=
name|hw
operator|->
name|io_base
decl_stmt|;
name|uint32_t
name|io_data
init|=
name|hw
operator|->
name|io_base
operator|+
literal|4
decl_stmt|;
name|em_io_write
argument_list|(
name|hw
argument_list|,
name|io_addr
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|em_io_write
argument_list|(
name|hw
argument_list|,
name|io_data
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

