begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*******************************************************************************    Copyright (c) 2001-2005, Intel Corporation    All rights reserved.      Redistribution and use in source and binary forms, with or without    modification, are permitted provided that the following conditions are met:       1. Redistributions of source code must retain the above copyright notice,        this list of conditions and the following disclaimer.       2. Redistributions in binary form must reproduce the above copyright        notice, this list of conditions and the following disclaimer in the        documentation and/or other materials provided with the distribution.       3. Neither the name of the Intel Corporation nor the names of its        contributors may be used to endorse or promote products derived from        this software without specific prior written permission.      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE    ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR    CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF    SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN    CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)    ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE   POSSIBILITY OF SUCH DAMAGE.  *******************************************************************************/
end_comment

begin_comment
comment|/*$FreeBSD$*/
end_comment

begin_comment
comment|/* if_em_hw.c  * Shared functions for accessing and configuring the MAC  */
end_comment

begin_define
define|#
directive|define
name|STATIC
value|static
end_define

begin_include
include|#
directive|include
file|<dev/em/if_em_hw.h>
end_include

begin_function_decl
specifier|static
name|int32_t
name|em_swfw_sync_acquire
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint16_t
name|mask
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_swfw_sync_release
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint16_t
name|mask
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|em_read_kmrn_reg
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint32_t
name|reg_addr
parameter_list|,
name|uint16_t
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|em_write_kmrn_reg
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint32_t
name|reg_addr
parameter_list|,
name|uint16_t
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|em_get_software_semaphore
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_release_software_semaphore
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint8_t
name|em_arc_subsystem_valid
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|em_check_downshift
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|em_check_polarity
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|em_rev_polarity
modifier|*
name|polarity
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_clear_vfta
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|em_commit_shadow_ram
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|em_config_dsp_after_link_change
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|boolean_t
name|link_up
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|em_config_fc_after_link_up
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|em_detect_gig_phy
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|em_erase_ich8_4k_segment
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint32_t
name|bank
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|em_get_auto_rd_done
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|em_get_cable_length
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint16_t
modifier|*
name|min_length
parameter_list|,
name|uint16_t
modifier|*
name|max_length
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|em_get_hw_eeprom_semaphore
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|em_get_phy_cfg_done
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|em_get_software_flag
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|em_ich8_cycle_init
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|em_ich8_flash_cycle
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint32_t
name|timeout
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|em_id_led_init
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|em_init_lcd_from_nvm_config_region
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint32_t
name|cnf_base_addr
parameter_list|,
name|uint32_t
name|cnf_size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|em_init_lcd_from_nvm
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_init_rx_addrs
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_initialize_hardware_bits
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|boolean_t
name|em_is_onboard_nvm_eeprom
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|em_kumeran_lock_loss_workaround
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|em_mng_enable_host_if
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|em_mng_host_if_write
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint8_t
modifier|*
name|buffer
parameter_list|,
name|uint16_t
name|length
parameter_list|,
name|uint16_t
name|offset
parameter_list|,
name|uint8_t
modifier|*
name|sum
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|em_mng_write_cmd_header
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|struct
name|em_host_mng_command_header
modifier|*
name|hdr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|em_mng_write_commit
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|em_phy_ife_get_info
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|struct
name|em_phy_info
modifier|*
name|phy_info
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|em_phy_igp_get_info
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|struct
name|em_phy_info
modifier|*
name|phy_info
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|em_read_eeprom_eerd
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint16_t
name|offset
parameter_list|,
name|uint16_t
name|words
parameter_list|,
name|uint16_t
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|em_write_eeprom_eewr
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint16_t
name|offset
parameter_list|,
name|uint16_t
name|words
parameter_list|,
name|uint16_t
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|em_poll_eerd_eewr_done
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|int
name|eerd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|em_phy_m88_get_info
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|struct
name|em_phy_info
modifier|*
name|phy_info
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_put_hw_eeprom_semaphore
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|em_read_ich8_byte
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint32_t
name|index
parameter_list|,
name|uint8_t
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|em_verify_write_ich8_byte
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint32_t
name|index
parameter_list|,
name|uint8_t
name|byte
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|em_write_ich8_byte
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint32_t
name|index
parameter_list|,
name|uint8_t
name|byte
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|em_read_ich8_word
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint32_t
name|index
parameter_list|,
name|uint16_t
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|em_read_ich8_data
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint32_t
name|index
parameter_list|,
name|uint32_t
name|size
parameter_list|,
name|uint16_t
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|em_write_ich8_data
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint32_t
name|index
parameter_list|,
name|uint32_t
name|size
parameter_list|,
name|uint16_t
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|em_read_eeprom_ich8
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint16_t
name|offset
parameter_list|,
name|uint16_t
name|words
parameter_list|,
name|uint16_t
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|em_write_eeprom_ich8
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint16_t
name|offset
parameter_list|,
name|uint16_t
name|words
parameter_list|,
name|uint16_t
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_release_software_flag
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|em_set_d3_lplu_state
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|boolean_t
name|active
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|em_set_d0_lplu_state
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|boolean_t
name|active
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|em_set_pci_ex_no_snoop
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint32_t
name|no_snoop
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_set_pci_express_master_disable
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|em_wait_autoneg
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_write_reg_io
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint32_t
name|offset
parameter_list|,
name|uint32_t
name|value
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|em_set_phy_type
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_phy_init_script
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|em_setup_copper_link
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|em_setup_fiber_serdes_link
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|em_adjust_serdes_amplitude
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|em_phy_force_speed_duplex
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|em_config_mac_to_phy
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_raise_mdi_clk
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint32_t
modifier|*
name|ctrl
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_lower_mdi_clk
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint32_t
modifier|*
name|ctrl
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_shift_out_mdi_bits
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint32_t
name|data
parameter_list|,
name|uint16_t
name|count
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint16_t
name|em_shift_in_mdi_bits
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|em_phy_reset_dsp
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|em_write_eeprom_spi
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint16_t
name|offset
parameter_list|,
name|uint16_t
name|words
parameter_list|,
name|uint16_t
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|em_write_eeprom_microwire
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint16_t
name|offset
parameter_list|,
name|uint16_t
name|words
parameter_list|,
name|uint16_t
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|em_spi_eeprom_ready
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_raise_ee_clk
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint32_t
modifier|*
name|eecd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_lower_ee_clk
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint32_t
modifier|*
name|eecd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_shift_out_ee_bits
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint16_t
name|data
parameter_list|,
name|uint16_t
name|count
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|em_write_phy_reg_ex
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint32_t
name|reg_addr
parameter_list|,
name|uint16_t
name|phy_data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|em_read_phy_reg_ex
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint32_t
name|reg_addr
parameter_list|,
name|uint16_t
modifier|*
name|phy_data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint16_t
name|em_shift_in_ee_bits
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint16_t
name|count
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|em_acquire_eeprom
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_release_eeprom
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_standby_eeprom
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|em_set_vco_speed
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|em_polarity_reversal_workaround
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|em_set_phy_mode
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|em_host_if_read_cookie
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint8_t
modifier|*
name|buffer
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint8_t
name|em_calculate_mng_checksum
parameter_list|(
name|char
modifier|*
name|buffer
parameter_list|,
name|uint32_t
name|length
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|em_configure_kmrn_for_10_100
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint16_t
name|duplex
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|em_configure_kmrn_for_1000
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* IGP cable length table */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|uint16_t
name|em_igp_cable_length_table
index|[
name|IGP01E1000_AGC_LENGTH_TABLE_SIZE
index|]
init|=
block|{
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|20
block|,
literal|20
block|,
literal|20
block|,
literal|20
block|,
literal|20
block|,
literal|25
block|,
literal|25
block|,
literal|25
block|,
literal|25
block|,
literal|25
block|,
literal|25
block|,
literal|25
block|,
literal|30
block|,
literal|30
block|,
literal|30
block|,
literal|30
block|,
literal|40
block|,
literal|40
block|,
literal|40
block|,
literal|40
block|,
literal|40
block|,
literal|40
block|,
literal|40
block|,
literal|40
block|,
literal|40
block|,
literal|50
block|,
literal|50
block|,
literal|50
block|,
literal|50
block|,
literal|50
block|,
literal|50
block|,
literal|50
block|,
literal|60
block|,
literal|60
block|,
literal|60
block|,
literal|60
block|,
literal|60
block|,
literal|60
block|,
literal|60
block|,
literal|60
block|,
literal|60
block|,
literal|70
block|,
literal|70
block|,
literal|70
block|,
literal|70
block|,
literal|70
block|,
literal|70
block|,
literal|80
block|,
literal|80
block|,
literal|80
block|,
literal|80
block|,
literal|80
block|,
literal|80
block|,
literal|90
block|,
literal|90
block|,
literal|90
block|,
literal|90
block|,
literal|90
block|,
literal|90
block|,
literal|90
block|,
literal|90
block|,
literal|90
block|,
literal|100
block|,
literal|100
block|,
literal|100
block|,
literal|100
block|,
literal|100
block|,
literal|100
block|,
literal|100
block|,
literal|100
block|,
literal|100
block|,
literal|100
block|,
literal|100
block|,
literal|100
block|,
literal|100
block|,
literal|100
block|,
literal|110
block|,
literal|110
block|,
literal|110
block|,
literal|110
block|,
literal|110
block|,
literal|110
block|,
literal|110
block|,
literal|110
block|,
literal|110
block|,
literal|110
block|,
literal|110
block|,
literal|110
block|,
literal|110
block|,
literal|110
block|,
literal|110
block|,
literal|110
block|,
literal|110
block|,
literal|110
block|,
literal|120
block|,
literal|120
block|,
literal|120
block|,
literal|120
block|,
literal|120
block|,
literal|120
block|,
literal|120
block|,
literal|120
block|,
literal|120
block|,
literal|120
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|uint16_t
name|em_igp_2_cable_length_table
index|[
name|IGP02E1000_AGC_LENGTH_TABLE_SIZE
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|3
block|,
literal|5
block|,
literal|8
block|,
literal|11
block|,
literal|13
block|,
literal|16
block|,
literal|18
block|,
literal|21
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|3
block|,
literal|6
block|,
literal|10
block|,
literal|13
block|,
literal|16
block|,
literal|19
block|,
literal|23
block|,
literal|26
block|,
literal|29
block|,
literal|32
block|,
literal|35
block|,
literal|38
block|,
literal|41
block|,
literal|6
block|,
literal|10
block|,
literal|14
block|,
literal|18
block|,
literal|22
block|,
literal|26
block|,
literal|30
block|,
literal|33
block|,
literal|37
block|,
literal|41
block|,
literal|44
block|,
literal|48
block|,
literal|51
block|,
literal|54
block|,
literal|58
block|,
literal|61
block|,
literal|21
block|,
literal|26
block|,
literal|31
block|,
literal|35
block|,
literal|40
block|,
literal|44
block|,
literal|49
block|,
literal|53
block|,
literal|57
block|,
literal|61
block|,
literal|65
block|,
literal|68
block|,
literal|72
block|,
literal|75
block|,
literal|79
block|,
literal|82
block|,
literal|40
block|,
literal|45
block|,
literal|51
block|,
literal|56
block|,
literal|61
block|,
literal|66
block|,
literal|70
block|,
literal|75
block|,
literal|79
block|,
literal|83
block|,
literal|87
block|,
literal|91
block|,
literal|94
block|,
literal|98
block|,
literal|101
block|,
literal|104
block|,
literal|60
block|,
literal|66
block|,
literal|72
block|,
literal|77
block|,
literal|82
block|,
literal|87
block|,
literal|92
block|,
literal|96
block|,
literal|100
block|,
literal|104
block|,
literal|108
block|,
literal|111
block|,
literal|114
block|,
literal|117
block|,
literal|119
block|,
literal|121
block|,
literal|83
block|,
literal|89
block|,
literal|95
block|,
literal|100
block|,
literal|105
block|,
literal|109
block|,
literal|113
block|,
literal|116
block|,
literal|119
block|,
literal|122
block|,
literal|124
block|,
literal|104
block|,
literal|109
block|,
literal|114
block|,
literal|118
block|,
literal|121
block|,
literal|124
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/******************************************************************************  * Set the phy type member in the hw struct.  *  * hw - Struct containing variables accessed by shared code  *****************************************************************************/
end_comment

begin_function
name|STATIC
name|int32_t
name|em_set_phy_type
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"em_set_phy_type"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|==
name|em_undefined
condition|)
return|return
operator|-
name|E1000_ERR_PHY_TYPE
return|;
switch|switch
condition|(
name|hw
operator|->
name|phy_id
condition|)
block|{
case|case
name|M88E1000_E_PHY_ID
case|:
case|case
name|M88E1000_I_PHY_ID
case|:
case|case
name|M88E1011_I_PHY_ID
case|:
case|case
name|M88E1111_I_PHY_ID
case|:
name|hw
operator|->
name|phy_type
operator|=
name|em_phy_m88
expr_stmt|;
break|break;
case|case
name|IGP01E1000_I_PHY_ID
case|:
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|==
name|em_82541
operator|||
name|hw
operator|->
name|mac_type
operator|==
name|em_82541_rev_2
operator|||
name|hw
operator|->
name|mac_type
operator|==
name|em_82547
operator|||
name|hw
operator|->
name|mac_type
operator|==
name|em_82547_rev_2
condition|)
block|{
name|hw
operator|->
name|phy_type
operator|=
name|em_phy_igp
expr_stmt|;
break|break;
block|}
case|case
name|IGP03E1000_E_PHY_ID
case|:
name|hw
operator|->
name|phy_type
operator|=
name|em_phy_igp_3
expr_stmt|;
break|break;
case|case
name|IFE_E_PHY_ID
case|:
case|case
name|IFE_PLUS_E_PHY_ID
case|:
case|case
name|IFE_C_E_PHY_ID
case|:
name|hw
operator|->
name|phy_type
operator|=
name|em_phy_ife
expr_stmt|;
break|break;
case|case
name|GG82563_E_PHY_ID
case|:
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|==
name|em_80003es2lan
condition|)
block|{
name|hw
operator|->
name|phy_type
operator|=
name|em_phy_gg82563
expr_stmt|;
break|break;
block|}
comment|/* Fall Through */
default|default:
comment|/* Should never have loaded on this device */
name|hw
operator|->
name|phy_type
operator|=
name|em_phy_undefined
expr_stmt|;
return|return
operator|-
name|E1000_ERR_PHY_TYPE
return|;
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * IGP phy init script - initializes the GbE PHY  *  * hw - Struct containing variables accessed by shared code  *****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|em_phy_init_script
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|uint32_t
name|ret_val
decl_stmt|;
name|uint16_t
name|phy_saved_data
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_phy_init_script"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|phy_init_script
condition|)
block|{
name|msec_delay
argument_list|(
literal|20
argument_list|)
expr_stmt|;
comment|/* Save off the current value of register 0x2F5B to be restored at          * the end of this routine. */
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
literal|0x2F5B
argument_list|,
operator|&
name|phy_saved_data
argument_list|)
expr_stmt|;
comment|/* Disabled the PHY transmitter */
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
literal|0x2F5B
argument_list|,
literal|0x0003
argument_list|)
expr_stmt|;
name|msec_delay
argument_list|(
literal|20
argument_list|)
expr_stmt|;
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
literal|0x0000
argument_list|,
literal|0x0140
argument_list|)
expr_stmt|;
name|msec_delay
argument_list|(
literal|5
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|hw
operator|->
name|mac_type
condition|)
block|{
case|case
name|em_82541
case|:
case|case
name|em_82547
case|:
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
literal|0x1F95
argument_list|,
literal|0x0001
argument_list|)
expr_stmt|;
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
literal|0x1F71
argument_list|,
literal|0xBD21
argument_list|)
expr_stmt|;
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
literal|0x1F79
argument_list|,
literal|0x0018
argument_list|)
expr_stmt|;
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
literal|0x1F30
argument_list|,
literal|0x1600
argument_list|)
expr_stmt|;
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
literal|0x1F31
argument_list|,
literal|0x0014
argument_list|)
expr_stmt|;
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
literal|0x1F32
argument_list|,
literal|0x161C
argument_list|)
expr_stmt|;
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
literal|0x1F94
argument_list|,
literal|0x0003
argument_list|)
expr_stmt|;
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
literal|0x1F96
argument_list|,
literal|0x003F
argument_list|)
expr_stmt|;
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
literal|0x2010
argument_list|,
literal|0x0008
argument_list|)
expr_stmt|;
break|break;
case|case
name|em_82541_rev_2
case|:
case|case
name|em_82547_rev_2
case|:
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
literal|0x1F73
argument_list|,
literal|0x0099
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
literal|0x0000
argument_list|,
literal|0x3300
argument_list|)
expr_stmt|;
name|msec_delay
argument_list|(
literal|20
argument_list|)
expr_stmt|;
comment|/* Now enable the transmitter */
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
literal|0x2F5B
argument_list|,
name|phy_saved_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|==
name|em_82547
condition|)
block|{
name|uint16_t
name|fused
decl_stmt|,
name|fine
decl_stmt|,
name|coarse
decl_stmt|;
comment|/* Move to analog registers page */
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_ANALOG_SPARE_FUSE_STATUS
argument_list|,
operator|&
name|fused
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|fused
operator|&
name|IGP01E1000_ANALOG_SPARE_FUSE_ENABLED
operator|)
condition|)
block|{
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_ANALOG_FUSE_STATUS
argument_list|,
operator|&
name|fused
argument_list|)
expr_stmt|;
name|fine
operator|=
name|fused
operator|&
name|IGP01E1000_ANALOG_FUSE_FINE_MASK
expr_stmt|;
name|coarse
operator|=
name|fused
operator|&
name|IGP01E1000_ANALOG_FUSE_COARSE_MASK
expr_stmt|;
if|if
condition|(
name|coarse
operator|>
name|IGP01E1000_ANALOG_FUSE_COARSE_THRESH
condition|)
block|{
name|coarse
operator|-=
name|IGP01E1000_ANALOG_FUSE_COARSE_10
expr_stmt|;
name|fine
operator|-=
name|IGP01E1000_ANALOG_FUSE_FINE_1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|coarse
operator|==
name|IGP01E1000_ANALOG_FUSE_COARSE_THRESH
condition|)
name|fine
operator|-=
name|IGP01E1000_ANALOG_FUSE_FINE_10
expr_stmt|;
name|fused
operator|=
operator|(
name|fused
operator|&
name|IGP01E1000_ANALOG_FUSE_POLY_MASK
operator|)
operator||
operator|(
name|fine
operator|&
name|IGP01E1000_ANALOG_FUSE_FINE_MASK
operator|)
operator||
operator|(
name|coarse
operator|&
name|IGP01E1000_ANALOG_FUSE_COARSE_MASK
operator|)
expr_stmt|;
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_ANALOG_FUSE_CONTROL
argument_list|,
name|fused
argument_list|)
expr_stmt|;
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_ANALOG_FUSE_BYPASS
argument_list|,
name|IGP01E1000_ANALOG_FUSE_ENABLE_SW_CONTROL
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/******************************************************************************  * Set the mac type member in the hw struct.  *  * hw - Struct containing variables accessed by shared code  *****************************************************************************/
end_comment

begin_function
name|int32_t
name|em_set_mac_type
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"em_set_mac_type"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|hw
operator|->
name|device_id
condition|)
block|{
case|case
name|E1000_DEV_ID_82542
case|:
switch|switch
condition|(
name|hw
operator|->
name|revision_id
condition|)
block|{
case|case
name|E1000_82542_2_0_REV_ID
case|:
name|hw
operator|->
name|mac_type
operator|=
name|em_82542_rev2_0
expr_stmt|;
break|break;
case|case
name|E1000_82542_2_1_REV_ID
case|:
name|hw
operator|->
name|mac_type
operator|=
name|em_82542_rev2_1
expr_stmt|;
break|break;
default|default:
comment|/* Invalid 82542 revision ID */
return|return
operator|-
name|E1000_ERR_MAC_TYPE
return|;
block|}
break|break;
case|case
name|E1000_DEV_ID_82543GC_FIBER
case|:
case|case
name|E1000_DEV_ID_82543GC_COPPER
case|:
name|hw
operator|->
name|mac_type
operator|=
name|em_82543
expr_stmt|;
break|break;
case|case
name|E1000_DEV_ID_82544EI_COPPER
case|:
case|case
name|E1000_DEV_ID_82544EI_FIBER
case|:
case|case
name|E1000_DEV_ID_82544GC_COPPER
case|:
case|case
name|E1000_DEV_ID_82544GC_LOM
case|:
name|hw
operator|->
name|mac_type
operator|=
name|em_82544
expr_stmt|;
break|break;
case|case
name|E1000_DEV_ID_82540EM
case|:
case|case
name|E1000_DEV_ID_82540EM_LOM
case|:
case|case
name|E1000_DEV_ID_82540EP
case|:
case|case
name|E1000_DEV_ID_82540EP_LOM
case|:
case|case
name|E1000_DEV_ID_82540EP_LP
case|:
name|hw
operator|->
name|mac_type
operator|=
name|em_82540
expr_stmt|;
break|break;
case|case
name|E1000_DEV_ID_82545EM_COPPER
case|:
case|case
name|E1000_DEV_ID_82545EM_FIBER
case|:
name|hw
operator|->
name|mac_type
operator|=
name|em_82545
expr_stmt|;
break|break;
case|case
name|E1000_DEV_ID_82545GM_COPPER
case|:
case|case
name|E1000_DEV_ID_82545GM_FIBER
case|:
case|case
name|E1000_DEV_ID_82545GM_SERDES
case|:
name|hw
operator|->
name|mac_type
operator|=
name|em_82545_rev_3
expr_stmt|;
break|break;
case|case
name|E1000_DEV_ID_82546EB_COPPER
case|:
case|case
name|E1000_DEV_ID_82546EB_FIBER
case|:
case|case
name|E1000_DEV_ID_82546EB_QUAD_COPPER
case|:
name|hw
operator|->
name|mac_type
operator|=
name|em_82546
expr_stmt|;
break|break;
case|case
name|E1000_DEV_ID_82546GB_COPPER
case|:
case|case
name|E1000_DEV_ID_82546GB_FIBER
case|:
case|case
name|E1000_DEV_ID_82546GB_SERDES
case|:
case|case
name|E1000_DEV_ID_82546GB_PCIE
case|:
case|case
name|E1000_DEV_ID_82546GB_QUAD_COPPER
case|:
case|case
name|E1000_DEV_ID_82546GB_QUAD_COPPER_KSP3
case|:
name|hw
operator|->
name|mac_type
operator|=
name|em_82546_rev_3
expr_stmt|;
break|break;
case|case
name|E1000_DEV_ID_82541EI
case|:
case|case
name|E1000_DEV_ID_82541EI_MOBILE
case|:
case|case
name|E1000_DEV_ID_82541ER_LOM
case|:
name|hw
operator|->
name|mac_type
operator|=
name|em_82541
expr_stmt|;
break|break;
case|case
name|E1000_DEV_ID_82541ER
case|:
case|case
name|E1000_DEV_ID_82541GI
case|:
case|case
name|E1000_DEV_ID_82541GI_LF
case|:
case|case
name|E1000_DEV_ID_82541GI_MOBILE
case|:
name|hw
operator|->
name|mac_type
operator|=
name|em_82541_rev_2
expr_stmt|;
break|break;
case|case
name|E1000_DEV_ID_82547EI
case|:
case|case
name|E1000_DEV_ID_82547EI_MOBILE
case|:
name|hw
operator|->
name|mac_type
operator|=
name|em_82547
expr_stmt|;
break|break;
case|case
name|E1000_DEV_ID_82547GI
case|:
name|hw
operator|->
name|mac_type
operator|=
name|em_82547_rev_2
expr_stmt|;
break|break;
case|case
name|E1000_DEV_ID_82571EB_COPPER
case|:
case|case
name|E1000_DEV_ID_82571EB_FIBER
case|:
case|case
name|E1000_DEV_ID_82571EB_SERDES
case|:
case|case
name|E1000_DEV_ID_82571EB_QUAD_COPPER
case|:
case|case
name|E1000_DEV_ID_82571EB_QUAD_COPPER_LOWPROFILE
case|:
name|hw
operator|->
name|mac_type
operator|=
name|em_82571
expr_stmt|;
break|break;
case|case
name|E1000_DEV_ID_82572EI_COPPER
case|:
case|case
name|E1000_DEV_ID_82572EI_FIBER
case|:
case|case
name|E1000_DEV_ID_82572EI_SERDES
case|:
case|case
name|E1000_DEV_ID_82572EI
case|:
name|hw
operator|->
name|mac_type
operator|=
name|em_82572
expr_stmt|;
break|break;
case|case
name|E1000_DEV_ID_82573E
case|:
case|case
name|E1000_DEV_ID_82573E_IAMT
case|:
case|case
name|E1000_DEV_ID_82573L
case|:
name|hw
operator|->
name|mac_type
operator|=
name|em_82573
expr_stmt|;
break|break;
case|case
name|E1000_DEV_ID_80003ES2LAN_COPPER_SPT
case|:
case|case
name|E1000_DEV_ID_80003ES2LAN_SERDES_SPT
case|:
case|case
name|E1000_DEV_ID_80003ES2LAN_COPPER_DPT
case|:
case|case
name|E1000_DEV_ID_80003ES2LAN_SERDES_DPT
case|:
name|hw
operator|->
name|mac_type
operator|=
name|em_80003es2lan
expr_stmt|;
break|break;
case|case
name|E1000_DEV_ID_ICH8_IGP_M_AMT
case|:
case|case
name|E1000_DEV_ID_ICH8_IGP_AMT
case|:
case|case
name|E1000_DEV_ID_ICH8_IGP_C
case|:
case|case
name|E1000_DEV_ID_ICH8_IFE
case|:
case|case
name|E1000_DEV_ID_ICH8_IFE_GT
case|:
case|case
name|E1000_DEV_ID_ICH8_IFE_G
case|:
case|case
name|E1000_DEV_ID_ICH8_IGP_M
case|:
name|hw
operator|->
name|mac_type
operator|=
name|em_ich8lan
expr_stmt|;
break|break;
default|default:
comment|/* Should never have loaded on this device */
return|return
operator|-
name|E1000_ERR_MAC_TYPE
return|;
block|}
switch|switch
condition|(
name|hw
operator|->
name|mac_type
condition|)
block|{
case|case
name|em_ich8lan
case|:
name|hw
operator|->
name|swfwhw_semaphore_present
operator|=
name|TRUE
expr_stmt|;
name|hw
operator|->
name|asf_firmware_present
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|em_80003es2lan
case|:
name|hw
operator|->
name|swfw_sync_present
operator|=
name|TRUE
expr_stmt|;
comment|/* fall through */
case|case
name|em_82571
case|:
case|case
name|em_82572
case|:
case|case
name|em_82573
case|:
name|hw
operator|->
name|eeprom_semaphore_present
operator|=
name|TRUE
expr_stmt|;
comment|/* fall through */
case|case
name|em_82541
case|:
case|case
name|em_82547
case|:
case|case
name|em_82541_rev_2
case|:
case|case
name|em_82547_rev_2
case|:
name|hw
operator|->
name|asf_firmware_present
operator|=
name|TRUE
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************  * Set media type and TBI compatibility.  *  * hw - Struct containing variables accessed by shared code  * **************************************************************************/
end_comment

begin_function
name|void
name|em_set_media_type
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|uint32_t
name|status
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_set_media_type"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|!=
name|em_82543
condition|)
block|{
comment|/* tbi_compatibility is only valid on 82543 */
name|hw
operator|->
name|tbi_compatibility_en
operator|=
name|FALSE
expr_stmt|;
block|}
switch|switch
condition|(
name|hw
operator|->
name|device_id
condition|)
block|{
case|case
name|E1000_DEV_ID_82545GM_SERDES
case|:
case|case
name|E1000_DEV_ID_82546GB_SERDES
case|:
case|case
name|E1000_DEV_ID_82571EB_SERDES
case|:
case|case
name|E1000_DEV_ID_82572EI_SERDES
case|:
case|case
name|E1000_DEV_ID_80003ES2LAN_SERDES_DPT
case|:
name|hw
operator|->
name|media_type
operator|=
name|em_media_type_internal_serdes
expr_stmt|;
break|break;
default|default:
switch|switch
condition|(
name|hw
operator|->
name|mac_type
condition|)
block|{
case|case
name|em_82542_rev2_0
case|:
case|case
name|em_82542_rev2_1
case|:
name|hw
operator|->
name|media_type
operator|=
name|em_media_type_fiber
expr_stmt|;
break|break;
case|case
name|em_ich8lan
case|:
case|case
name|em_82573
case|:
comment|/* The STATUS_TBIMODE bit is reserved or reused for the this              * device.              */
name|hw
operator|->
name|media_type
operator|=
name|em_media_type_copper
expr_stmt|;
break|break;
default|default:
name|status
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|E1000_STATUS_TBIMODE
condition|)
block|{
name|hw
operator|->
name|media_type
operator|=
name|em_media_type_fiber
expr_stmt|;
comment|/* tbi_compatibility not valid on fiber */
name|hw
operator|->
name|tbi_compatibility_en
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
name|hw
operator|->
name|media_type
operator|=
name|em_media_type_copper
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/******************************************************************************  * Reset the transmit and receive units; mask and clear all interrupts.  *  * hw - Struct containing variables accessed by shared code  *****************************************************************************/
end_comment

begin_function
name|int32_t
name|em_reset_hw
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|uint32_t
name|ctrl
decl_stmt|;
name|uint32_t
name|ctrl_ext
decl_stmt|;
name|uint32_t
name|icr
decl_stmt|;
name|uint32_t
name|manc
decl_stmt|;
name|uint32_t
name|led_ctrl
decl_stmt|;
name|uint32_t
name|timeout
decl_stmt|;
name|uint32_t
name|extcnf_ctrl
decl_stmt|;
name|int32_t
name|ret_val
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_reset_hw"
argument_list|)
expr_stmt|;
comment|/* For 82542 (rev 2.0), disable MWI before issuing a device reset */
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|==
name|em_82542_rev2_0
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Disabling MWI on 82542 rev 2.0\n"
argument_list|)
expr_stmt|;
name|em_pci_clear_mwi
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hw
operator|->
name|bus_type
operator|==
name|em_bus_type_pci_express
condition|)
block|{
comment|/* Prevent the PCI-E bus from sticking if there is no TLP connection          * on the last TLP read/write transaction when MAC is reset.          */
if|if
condition|(
name|em_disable_pciex_master
argument_list|(
name|hw
argument_list|)
operator|!=
name|E1000_SUCCESS
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"PCI-E Master disable polling has failed.\n"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Clear interrupt mask to stop board from generating interrupts */
name|DEBUGOUT
argument_list|(
literal|"Masking off all interrupts\n"
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IMC
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
comment|/* Disable the Transmit and Receive units.  Then delay to allow      * any pending transactions to complete before we hit the MAC with      * the global reset.      */
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|RCTL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|TCTL
argument_list|,
name|E1000_TCTL_PSP
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* The tbi_compatibility_on Flag must be cleared when Rctl is cleared. */
name|hw
operator|->
name|tbi_compatibility_on
operator|=
name|FALSE
expr_stmt|;
comment|/* Delay to allow any outstanding PCI transactions to complete before      * resetting the device      */
name|msec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|)
expr_stmt|;
comment|/* Must reset the PHY before resetting the MAC */
if|if
condition|(
operator|(
name|hw
operator|->
name|mac_type
operator|==
name|em_82541
operator|)
operator|||
operator|(
name|hw
operator|->
name|mac_type
operator|==
name|em_82547
operator|)
condition|)
block|{
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|,
operator|(
name|ctrl
operator||
name|E1000_CTRL_PHY_RST
operator|)
argument_list|)
expr_stmt|;
name|msec_delay
argument_list|(
literal|5
argument_list|)
expr_stmt|;
block|}
comment|/* Must acquire the MDIO ownership before MAC reset.      * Ownership defaults to firmware after a reset. */
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|==
name|em_82573
condition|)
block|{
name|timeout
operator|=
literal|10
expr_stmt|;
name|extcnf_ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|EXTCNF_CTRL
argument_list|)
expr_stmt|;
name|extcnf_ctrl
operator||=
name|E1000_EXTCNF_CTRL_MDIO_SW_OWNERSHIP
expr_stmt|;
do|do
block|{
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|EXTCNF_CTRL
argument_list|,
name|extcnf_ctrl
argument_list|)
expr_stmt|;
name|extcnf_ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|EXTCNF_CTRL
argument_list|)
expr_stmt|;
if|if
condition|(
name|extcnf_ctrl
operator|&
name|E1000_EXTCNF_CTRL_MDIO_SW_OWNERSHIP
condition|)
break|break;
else|else
name|extcnf_ctrl
operator||=
name|E1000_EXTCNF_CTRL_MDIO_SW_OWNERSHIP
expr_stmt|;
name|msec_delay
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|timeout
operator|--
expr_stmt|;
block|}
do|while
condition|(
name|timeout
condition|)
do|;
block|}
comment|/* Workaround for ICH8 bit corruption issue in FIFO memory */
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|==
name|em_ich8lan
condition|)
block|{
comment|/* Set Tx and Rx buffer allocation to 8k apiece. */
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|PBA
argument_list|,
name|E1000_PBA_8K
argument_list|)
expr_stmt|;
comment|/* Set Packet Buffer Size to 16k. */
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|PBS
argument_list|,
name|E1000_PBS_16K
argument_list|)
expr_stmt|;
block|}
comment|/* Issue a global reset to the MAC.  This will reset the chip's      * transmit, receive, DMA, and link units.  It will not effect      * the current PCI configuration.  The global reset bit is self-      * clearing, and should clear within a microsecond.      */
name|DEBUGOUT
argument_list|(
literal|"Issuing a global reset to MAC\n"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|hw
operator|->
name|mac_type
condition|)
block|{
case|case
name|em_82544
case|:
case|case
name|em_82540
case|:
case|case
name|em_82545
case|:
case|case
name|em_82546
case|:
case|case
name|em_82541
case|:
case|case
name|em_82541_rev_2
case|:
comment|/* These controllers can't ack the 64-bit write when issuing the              * reset, so use IO-mapping as a workaround to issue the reset */
name|E1000_WRITE_REG_IO
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|,
operator|(
name|ctrl
operator||
name|E1000_CTRL_RST
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|em_82545_rev_3
case|:
case|case
name|em_82546_rev_3
case|:
comment|/* Reset is performed on a shadow of the control register */
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|CTRL_DUP
argument_list|,
operator|(
name|ctrl
operator||
name|E1000_CTRL_RST
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|em_ich8lan
case|:
if|if
condition|(
operator|!
name|hw
operator|->
name|phy_reset_disable
operator|&&
name|em_check_phy_reset_block
argument_list|(
name|hw
argument_list|)
operator|==
name|E1000_SUCCESS
condition|)
block|{
comment|/* em_ich8lan PHY HW reset requires MAC CORE reset                  * at the same time to make sure the interface between                  * MAC and the external PHY is reset.                  */
name|ctrl
operator||=
name|E1000_CTRL_PHY_RST
expr_stmt|;
block|}
name|em_get_software_flag
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|,
operator|(
name|ctrl
operator||
name|E1000_CTRL_RST
operator|)
argument_list|)
expr_stmt|;
name|msec_delay
argument_list|(
literal|5
argument_list|)
expr_stmt|;
break|break;
default|default:
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|,
operator|(
name|ctrl
operator||
name|E1000_CTRL_RST
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* After MAC reset, force reload of EEPROM to restore power-on settings to      * device.  Later controllers reload the EEPROM automatically, so just wait      * for reload to complete.      */
switch|switch
condition|(
name|hw
operator|->
name|mac_type
condition|)
block|{
case|case
name|em_82542_rev2_0
case|:
case|case
name|em_82542_rev2_1
case|:
case|case
name|em_82543
case|:
case|case
name|em_82544
case|:
comment|/* Wait for reset to complete */
name|usec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|ctrl_ext
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|CTRL_EXT
argument_list|)
expr_stmt|;
name|ctrl_ext
operator||=
name|E1000_CTRL_EXT_EE_RST
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|CTRL_EXT
argument_list|,
name|ctrl_ext
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Wait for EEPROM reload */
name|msec_delay
argument_list|(
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|em_82541
case|:
case|case
name|em_82541_rev_2
case|:
case|case
name|em_82547
case|:
case|case
name|em_82547_rev_2
case|:
comment|/* Wait for EEPROM reload */
name|msec_delay
argument_list|(
literal|20
argument_list|)
expr_stmt|;
break|break;
case|case
name|em_82573
case|:
if|if
condition|(
name|em_is_onboard_nvm_eeprom
argument_list|(
name|hw
argument_list|)
operator|==
name|FALSE
condition|)
block|{
name|usec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|ctrl_ext
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|CTRL_EXT
argument_list|)
expr_stmt|;
name|ctrl_ext
operator||=
name|E1000_CTRL_EXT_EE_RST
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|CTRL_EXT
argument_list|,
name|ctrl_ext
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
comment|/* fall through */
default|default:
comment|/* Auto read done will delay 5ms or poll based on mac type */
name|ret_val
operator|=
name|em_get_auto_rd_done
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
break|break;
block|}
comment|/* Disable HW ARPs on ASF enabled adapters */
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|>=
name|em_82540
operator|&&
name|hw
operator|->
name|mac_type
operator|<=
name|em_82547_rev_2
condition|)
block|{
name|manc
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|MANC
argument_list|)
expr_stmt|;
name|manc
operator|&=
operator|~
operator|(
name|E1000_MANC_ARP_EN
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|MANC
argument_list|,
name|manc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|hw
operator|->
name|mac_type
operator|==
name|em_82541
operator|)
operator|||
operator|(
name|hw
operator|->
name|mac_type
operator|==
name|em_82547
operator|)
condition|)
block|{
name|em_phy_init_script
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Configure activity LED after PHY reset */
name|led_ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|LEDCTL
argument_list|)
expr_stmt|;
name|led_ctrl
operator|&=
name|IGP_ACTIVITY_LED_MASK
expr_stmt|;
name|led_ctrl
operator||=
operator|(
name|IGP_ACTIVITY_LED_ENABLE
operator||
name|IGP_LED3_MODE
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|LEDCTL
argument_list|,
name|led_ctrl
argument_list|)
expr_stmt|;
block|}
comment|/* Clear interrupt mask to stop board from generating interrupts */
name|DEBUGOUT
argument_list|(
literal|"Masking off all interrupts\n"
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IMC
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
comment|/* Clear any pending interrupt events. */
name|icr
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|ICR
argument_list|)
expr_stmt|;
comment|/* If MWI was previously enabled, reenable it. */
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|==
name|em_82542_rev2_0
condition|)
block|{
if|if
condition|(
name|hw
operator|->
name|pci_cmd_word
operator|&
name|CMD_MEM_WRT_INVALIDATE
condition|)
name|em_pci_set_mwi
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|==
name|em_ich8lan
condition|)
block|{
name|uint32_t
name|kab
init|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|KABGTXD
argument_list|)
decl_stmt|;
name|kab
operator||=
name|E1000_KABGTXD_BGSQLBIAS
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|KABGTXD
argument_list|,
name|kab
argument_list|)
expr_stmt|;
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  *  * Initialize a number of hardware-dependent bits  *  * hw: Struct containing variables accessed by shared code  *  *****************************************************************************/
end_comment

begin_function
name|STATIC
name|void
name|em_initialize_hardware_bits
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
if|if
condition|(
operator|(
name|hw
operator|->
name|mac_type
operator|>=
name|em_82571
operator|)
operator|&&
operator|(
operator|!
name|hw
operator|->
name|initialize_hw_bits_disable
operator|)
condition|)
block|{
comment|/* Settings common to all silicon */
name|uint32_t
name|reg_ctrl
decl_stmt|,
name|reg_ctrl_ext
decl_stmt|;
name|uint32_t
name|reg_tarc0
decl_stmt|,
name|reg_tarc1
decl_stmt|;
name|uint32_t
name|reg_tctl
decl_stmt|;
name|uint32_t
name|reg_txdctl
decl_stmt|,
name|reg_txdctl1
decl_stmt|;
name|reg_tarc0
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|TARC0
argument_list|)
expr_stmt|;
name|reg_tarc0
operator|&=
operator|~
literal|0x78000000
expr_stmt|;
comment|/* Clear bits 30, 29, 28, and 27 */
name|reg_txdctl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|TXDCTL
argument_list|)
expr_stmt|;
name|reg_txdctl
operator||=
name|E1000_TXDCTL_COUNT_DESC
expr_stmt|;
comment|/* Set bit 22 */
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|TXDCTL
argument_list|,
name|reg_txdctl
argument_list|)
expr_stmt|;
name|reg_txdctl1
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|TXDCTL1
argument_list|)
expr_stmt|;
name|reg_txdctl1
operator||=
name|E1000_TXDCTL_COUNT_DESC
expr_stmt|;
comment|/* Set bit 22 */
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|TXDCTL1
argument_list|,
name|reg_txdctl1
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|hw
operator|->
name|mac_type
condition|)
block|{
case|case
name|em_82571
case|:
case|case
name|em_82572
case|:
name|reg_tarc1
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|TARC1
argument_list|)
expr_stmt|;
name|reg_tctl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|TCTL
argument_list|)
expr_stmt|;
comment|/* Set the phy Tx compatible mode bits */
name|reg_tarc1
operator|&=
operator|~
literal|0x60000000
expr_stmt|;
comment|/* Clear bits 30 and 29 */
name|reg_tarc0
operator||=
literal|0x07800000
expr_stmt|;
comment|/* Set TARC0 bits 23-26 */
name|reg_tarc1
operator||=
literal|0x07000000
expr_stmt|;
comment|/* Set TARC1 bits 24-26 */
if|if
condition|(
name|reg_tctl
operator|&
name|E1000_TCTL_MULR
condition|)
name|reg_tarc1
operator|&=
operator|~
literal|0x10000000
expr_stmt|;
comment|/* Clear bit 28 if MULR is 1b */
else|else
name|reg_tarc1
operator||=
literal|0x10000000
expr_stmt|;
comment|/* Set bit 28 if MULR is 0b */
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|TARC1
argument_list|,
name|reg_tarc1
argument_list|)
expr_stmt|;
break|break;
case|case
name|em_82573
case|:
name|reg_ctrl_ext
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|CTRL_EXT
argument_list|)
expr_stmt|;
name|reg_ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|)
expr_stmt|;
name|reg_ctrl_ext
operator|&=
operator|~
literal|0x00800000
expr_stmt|;
comment|/* Clear bit 23 */
name|reg_ctrl_ext
operator||=
literal|0x00400000
expr_stmt|;
comment|/* Set bit 22 */
name|reg_ctrl
operator|&=
operator|~
literal|0x20000000
expr_stmt|;
comment|/* Clear bit 29 */
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|CTRL_EXT
argument_list|,
name|reg_ctrl_ext
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|,
name|reg_ctrl
argument_list|)
expr_stmt|;
break|break;
case|case
name|em_80003es2lan
case|:
if|if
condition|(
operator|(
name|hw
operator|->
name|media_type
operator|==
name|em_media_type_fiber
operator|)
operator|||
operator|(
name|hw
operator|->
name|media_type
operator|==
name|em_media_type_internal_serdes
operator|)
condition|)
block|{
name|reg_tarc0
operator|&=
operator|~
literal|0x00100000
expr_stmt|;
comment|/* Clear bit 20 */
block|}
name|reg_tctl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|TCTL
argument_list|)
expr_stmt|;
name|reg_tarc1
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|TARC1
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_tctl
operator|&
name|E1000_TCTL_MULR
condition|)
name|reg_tarc1
operator|&=
operator|~
literal|0x10000000
expr_stmt|;
comment|/* Clear bit 28 if MULR is 1b */
else|else
name|reg_tarc1
operator||=
literal|0x10000000
expr_stmt|;
comment|/* Set bit 28 if MULR is 0b */
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|TARC1
argument_list|,
name|reg_tarc1
argument_list|)
expr_stmt|;
break|break;
case|case
name|em_ich8lan
case|:
if|if
condition|(
operator|(
name|hw
operator|->
name|revision_id
operator|<
literal|3
operator|)
operator|||
operator|(
operator|(
name|hw
operator|->
name|device_id
operator|!=
name|E1000_DEV_ID_ICH8_IGP_M_AMT
operator|)
operator|&&
operator|(
name|hw
operator|->
name|device_id
operator|!=
name|E1000_DEV_ID_ICH8_IGP_M
operator|)
operator|)
condition|)
name|reg_tarc0
operator||=
literal|0x30000000
expr_stmt|;
comment|/* Set TARC0 bits 29 and 28 */
name|reg_ctrl_ext
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|CTRL_EXT
argument_list|)
expr_stmt|;
name|reg_ctrl_ext
operator||=
literal|0x00400000
expr_stmt|;
comment|/* Set bit 22 */
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|CTRL_EXT
argument_list|,
name|reg_ctrl_ext
argument_list|)
expr_stmt|;
name|reg_tarc0
operator||=
literal|0x0d800000
expr_stmt|;
comment|/* Set TARC0 bits 23, 24, 26, 27 */
name|reg_tarc1
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|TARC1
argument_list|)
expr_stmt|;
name|reg_tctl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|TCTL
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_tctl
operator|&
name|E1000_TCTL_MULR
condition|)
name|reg_tarc1
operator|&=
operator|~
literal|0x10000000
expr_stmt|;
comment|/* Clear bit 28 if MULR is 1b */
else|else
name|reg_tarc1
operator||=
literal|0x10000000
expr_stmt|;
comment|/* Set bit 28 if MULR is 0b */
name|reg_tarc1
operator||=
literal|0x45000000
expr_stmt|;
comment|/* Set bit 24, 26 and 30 */
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|TARC1
argument_list|,
name|reg_tarc1
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|TARC0
argument_list|,
name|reg_tarc0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/******************************************************************************  * Performs basic configuration of the adapter.  *  * hw - Struct containing variables accessed by shared code  *  * Assumes that the controller has previously been reset and is in a  * post-reset uninitialized state. Initializes the receive address registers,  * multicast table, and VLAN filter table. Calls routines to setup link  * configuration and flow control settings. Clears all on-chip counters. Leaves  * the transmit and receive units disabled and uninitialized.  *****************************************************************************/
end_comment

begin_function
name|int32_t
name|em_init_hw
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|uint32_t
name|ctrl
decl_stmt|;
name|uint32_t
name|i
decl_stmt|;
name|int32_t
name|ret_val
decl_stmt|;
name|uint16_t
name|pcix_cmd_word
decl_stmt|;
name|uint16_t
name|pcix_stat_hi_word
decl_stmt|;
name|uint16_t
name|cmd_mmrbc
decl_stmt|;
name|uint16_t
name|stat_mmrbc
decl_stmt|;
name|uint32_t
name|mta_size
decl_stmt|;
name|uint32_t
name|reg_data
decl_stmt|;
name|uint32_t
name|ctrl_ext
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_init_hw"
argument_list|)
expr_stmt|;
comment|/* force full DMA clock frequency for 10/100 on ICH8 A0-B0 */
if|if
condition|(
operator|(
name|hw
operator|->
name|mac_type
operator|==
name|em_ich8lan
operator|)
operator|&&
operator|(
operator|(
name|hw
operator|->
name|revision_id
operator|<
literal|3
operator|)
operator|||
operator|(
operator|(
name|hw
operator|->
name|device_id
operator|!=
name|E1000_DEV_ID_ICH8_IGP_M_AMT
operator|)
operator|&&
operator|(
name|hw
operator|->
name|device_id
operator|!=
name|E1000_DEV_ID_ICH8_IGP_M
operator|)
operator|)
operator|)
condition|)
block|{
name|reg_data
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|STATUS
argument_list|)
expr_stmt|;
name|reg_data
operator|&=
operator|~
literal|0x80000000
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|STATUS
argument_list|,
name|reg_data
argument_list|)
expr_stmt|;
block|}
comment|/* Initialize Identification LED */
name|ret_val
operator|=
name|em_id_led_init
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Error Initializing Identification LED\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
comment|/* Set the media type and TBI compatibility */
name|em_set_media_type
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Must be called after em_set_media_type because media_type is used */
name|em_initialize_hardware_bits
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Disabling VLAN filtering. */
name|DEBUGOUT
argument_list|(
literal|"Initializing the IEEE VLAN\n"
argument_list|)
expr_stmt|;
comment|/* VET hardcoded to standard value and VFTA removed in ICH8 LAN */
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|!=
name|em_ich8lan
condition|)
block|{
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|<
name|em_82545_rev_3
condition|)
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|VET
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|em_clear_vfta
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
comment|/* For 82542 (rev 2.0), disable MWI and put the receiver into reset */
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|==
name|em_82542_rev2_0
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Disabling MWI on 82542 rev 2.0\n"
argument_list|)
expr_stmt|;
name|em_pci_clear_mwi
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|RCTL
argument_list|,
name|E1000_RCTL_RST
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|msec_delay
argument_list|(
literal|5
argument_list|)
expr_stmt|;
block|}
comment|/* Setup the receive address. This involves initializing all of the Receive      * Address Registers (RARs 0 - 15).      */
name|em_init_rx_addrs
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* For 82542 (rev 2.0), take the receiver out of reset and enable MWI */
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|==
name|em_82542_rev2_0
condition|)
block|{
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|RCTL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|msec_delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|pci_cmd_word
operator|&
name|CMD_MEM_WRT_INVALIDATE
condition|)
name|em_pci_set_mwi
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
comment|/* Zero out the Multicast HASH table */
name|DEBUGOUT
argument_list|(
literal|"Zeroing the MTA\n"
argument_list|)
expr_stmt|;
name|mta_size
operator|=
name|E1000_MC_TBL_SIZE
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|==
name|em_ich8lan
condition|)
name|mta_size
operator|=
name|E1000_MC_TBL_SIZE_ICH8LAN
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mta_size
condition|;
name|i
operator|++
control|)
block|{
name|E1000_WRITE_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|MTA
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* use write flush to prevent Memory Write Block (MWB) from          * occuring when accessing our register space */
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
comment|/* Set the PCI priority bit correctly in the CTRL register.  This      * determines if the adapter gives priority to receives, or if it      * gives equal priority to transmits and receives.  Valid only on      * 82542 and 82543 silicon.      */
if|if
condition|(
name|hw
operator|->
name|dma_fairness
operator|&&
name|hw
operator|->
name|mac_type
operator|<=
name|em_82543
condition|)
block|{
name|ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|,
name|ctrl
operator||
name|E1000_CTRL_PRIOR
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|hw
operator|->
name|mac_type
condition|)
block|{
case|case
name|em_82545_rev_3
case|:
case|case
name|em_82546_rev_3
case|:
break|break;
default|default:
comment|/* Workaround for PCI-X problem when BIOS sets MMRBC incorrectly. */
if|if
condition|(
name|hw
operator|->
name|bus_type
operator|==
name|em_bus_type_pcix
condition|)
block|{
name|em_read_pci_cfg
argument_list|(
name|hw
argument_list|,
name|PCIX_COMMAND_REGISTER
argument_list|,
operator|&
name|pcix_cmd_word
argument_list|)
expr_stmt|;
name|em_read_pci_cfg
argument_list|(
name|hw
argument_list|,
name|PCIX_STATUS_REGISTER_HI
argument_list|,
operator|&
name|pcix_stat_hi_word
argument_list|)
expr_stmt|;
name|cmd_mmrbc
operator|=
operator|(
name|pcix_cmd_word
operator|&
name|PCIX_COMMAND_MMRBC_MASK
operator|)
operator|>>
name|PCIX_COMMAND_MMRBC_SHIFT
expr_stmt|;
name|stat_mmrbc
operator|=
operator|(
name|pcix_stat_hi_word
operator|&
name|PCIX_STATUS_HI_MMRBC_MASK
operator|)
operator|>>
name|PCIX_STATUS_HI_MMRBC_SHIFT
expr_stmt|;
if|if
condition|(
name|stat_mmrbc
operator|==
name|PCIX_STATUS_HI_MMRBC_4K
condition|)
name|stat_mmrbc
operator|=
name|PCIX_STATUS_HI_MMRBC_2K
expr_stmt|;
if|if
condition|(
name|cmd_mmrbc
operator|>
name|stat_mmrbc
condition|)
block|{
name|pcix_cmd_word
operator|&=
operator|~
name|PCIX_COMMAND_MMRBC_MASK
expr_stmt|;
name|pcix_cmd_word
operator||=
name|stat_mmrbc
operator|<<
name|PCIX_COMMAND_MMRBC_SHIFT
expr_stmt|;
name|em_write_pci_cfg
argument_list|(
name|hw
argument_list|,
name|PCIX_COMMAND_REGISTER
argument_list|,
operator|&
name|pcix_cmd_word
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
comment|/* More time needed for PHY to initialize */
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|==
name|em_ich8lan
condition|)
name|msec_delay
argument_list|(
literal|15
argument_list|)
expr_stmt|;
comment|/* Call a subroutine to configure the link and setup flow control. */
name|ret_val
operator|=
name|em_setup_link
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Set the transmit descriptor write-back policy */
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|>
name|em_82544
condition|)
block|{
name|ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|TXDCTL
argument_list|)
expr_stmt|;
name|ctrl
operator|=
operator|(
name|ctrl
operator|&
operator|~
name|E1000_TXDCTL_WTHRESH
operator|)
operator||
name|E1000_TXDCTL_FULL_TX_DESC_WB
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|TXDCTL
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|==
name|em_82573
condition|)
block|{
name|em_enable_tx_pkt_filtering
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|hw
operator|->
name|mac_type
condition|)
block|{
default|default:
break|break;
case|case
name|em_80003es2lan
case|:
comment|/* Enable retransmit on late collisions */
name|reg_data
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|TCTL
argument_list|)
expr_stmt|;
name|reg_data
operator||=
name|E1000_TCTL_RTLC
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|TCTL
argument_list|,
name|reg_data
argument_list|)
expr_stmt|;
comment|/* Configure Gigabit Carry Extend Padding */
name|reg_data
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|TCTL_EXT
argument_list|)
expr_stmt|;
name|reg_data
operator|&=
operator|~
name|E1000_TCTL_EXT_GCEX_MASK
expr_stmt|;
name|reg_data
operator||=
name|DEFAULT_80003ES2LAN_TCTL_EXT_GCEX
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|TCTL_EXT
argument_list|,
name|reg_data
argument_list|)
expr_stmt|;
comment|/* Configure Transmit Inter-Packet Gap */
name|reg_data
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|TIPG
argument_list|)
expr_stmt|;
name|reg_data
operator|&=
operator|~
name|E1000_TIPG_IPGT_MASK
expr_stmt|;
name|reg_data
operator||=
name|DEFAULT_80003ES2LAN_TIPG_IPGT_1000
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|TIPG
argument_list|,
name|reg_data
argument_list|)
expr_stmt|;
name|reg_data
operator|=
name|E1000_READ_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|FFLT
argument_list|,
literal|0x0001
argument_list|)
expr_stmt|;
name|reg_data
operator|&=
operator|~
literal|0x00100000
expr_stmt|;
name|E1000_WRITE_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|FFLT
argument_list|,
literal|0x0001
argument_list|,
name|reg_data
argument_list|)
expr_stmt|;
comment|/* Fall through */
case|case
name|em_82571
case|:
case|case
name|em_82572
case|:
case|case
name|em_ich8lan
case|:
name|ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|TXDCTL1
argument_list|)
expr_stmt|;
name|ctrl
operator|=
operator|(
name|ctrl
operator|&
operator|~
name|E1000_TXDCTL_WTHRESH
operator|)
operator||
name|E1000_TXDCTL_FULL_TX_DESC_WB
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|TXDCTL1
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|==
name|em_82573
condition|)
block|{
name|uint32_t
name|gcr
init|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|GCR
argument_list|)
decl_stmt|;
name|gcr
operator||=
name|E1000_GCR_L1_ACT_WITHOUT_L0S_RX
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|GCR
argument_list|,
name|gcr
argument_list|)
expr_stmt|;
block|}
comment|/* Clear all of the statistics registers (clear on read).  It is      * important that we do this after we have tried to establish link      * because the symbol error count will increment wildly if there      * is no link.      */
name|em_clear_hw_cntrs
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* ICH8 No-snoop bits are opposite polarity.      * Set to snoop by default after reset. */
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|==
name|em_ich8lan
condition|)
name|em_set_pci_ex_no_snoop
argument_list|(
name|hw
argument_list|,
name|PCI_EX_82566_SNOOP_ALL
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|device_id
operator|==
name|E1000_DEV_ID_82546GB_QUAD_COPPER
operator|||
name|hw
operator|->
name|device_id
operator|==
name|E1000_DEV_ID_82546GB_QUAD_COPPER_KSP3
condition|)
block|{
name|ctrl_ext
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|CTRL_EXT
argument_list|)
expr_stmt|;
comment|/* Relaxed ordering must be disabled to avoid a parity          * error crash in a PCI slot. */
name|ctrl_ext
operator||=
name|E1000_CTRL_EXT_RO_DIS
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|CTRL_EXT
argument_list|,
name|ctrl_ext
argument_list|)
expr_stmt|;
block|}
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Adjust SERDES output amplitude based on EEPROM setting.  *  * hw - Struct containing variables accessed by shared code.  *****************************************************************************/
end_comment

begin_function
specifier|static
name|int32_t
name|em_adjust_serdes_amplitude
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|uint16_t
name|eeprom_data
decl_stmt|;
name|int32_t
name|ret_val
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_adjust_serdes_amplitude"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|media_type
operator|!=
name|em_media_type_internal_serdes
condition|)
return|return
name|E1000_SUCCESS
return|;
switch|switch
condition|(
name|hw
operator|->
name|mac_type
condition|)
block|{
case|case
name|em_82545_rev_3
case|:
case|case
name|em_82546_rev_3
case|:
break|break;
default|default:
return|return
name|E1000_SUCCESS
return|;
block|}
name|ret_val
operator|=
name|em_read_eeprom
argument_list|(
name|hw
argument_list|,
name|EEPROM_SERDES_AMPLITUDE
argument_list|,
literal|1
argument_list|,
operator|&
name|eeprom_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
return|return
name|ret_val
return|;
block|}
if|if
condition|(
name|eeprom_data
operator|!=
name|EEPROM_RESERVED_WORD
condition|)
block|{
comment|/* Adjust SERDES output amplitude only. */
name|eeprom_data
operator|&=
name|EEPROM_SERDES_AMPLITUDE_MASK
expr_stmt|;
name|ret_val
operator|=
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_EXT_CTRL
argument_list|,
name|eeprom_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Configures flow control and link settings.  *  * hw - Struct containing variables accessed by shared code  *  * Determines which flow control settings to use. Calls the apropriate media-  * specific link configuration function. Configures the flow control settings.  * Assuming the adapter has a valid link partner, a valid link should be  * established. Assumes the hardware has previously been reset and the  * transmitter and receiver are not enabled.  *****************************************************************************/
end_comment

begin_function
name|int32_t
name|em_setup_link
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|uint32_t
name|ctrl_ext
decl_stmt|;
name|int32_t
name|ret_val
decl_stmt|;
name|uint16_t
name|eeprom_data
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_setup_link"
argument_list|)
expr_stmt|;
comment|/* In the case of the phy reset being blocked, we already have a link.      * We do not have to set it up again. */
if|if
condition|(
name|em_check_phy_reset_block
argument_list|(
name|hw
argument_list|)
condition|)
return|return
name|E1000_SUCCESS
return|;
comment|/* Read and store word 0x0F of the EEPROM. This word contains bits      * that determine the hardware's default PAUSE (flow control) mode,      * a bit that determines whether the HW defaults to enabling or      * disabling auto-negotiation, and the direction of the      * SW defined pins. If there is no SW over-ride of the flow      * control setting, then the variable hw->fc will      * be initialized based on a value in the EEPROM.      */
if|if
condition|(
name|hw
operator|->
name|fc
operator|==
name|E1000_FC_DEFAULT
condition|)
block|{
switch|switch
condition|(
name|hw
operator|->
name|mac_type
condition|)
block|{
case|case
name|em_ich8lan
case|:
case|case
name|em_82573
case|:
name|hw
operator|->
name|fc
operator|=
name|E1000_FC_FULL
expr_stmt|;
break|break;
default|default:
name|ret_val
operator|=
name|em_read_eeprom
argument_list|(
name|hw
argument_list|,
name|EEPROM_INIT_CONTROL2_REG
argument_list|,
literal|1
argument_list|,
operator|&
name|eeprom_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"EEPROM Read Error\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_EEPROM
return|;
block|}
if|if
condition|(
operator|(
name|eeprom_data
operator|&
name|EEPROM_WORD0F_PAUSE_MASK
operator|)
operator|==
literal|0
condition|)
name|hw
operator|->
name|fc
operator|=
name|E1000_FC_NONE
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|eeprom_data
operator|&
name|EEPROM_WORD0F_PAUSE_MASK
operator|)
operator|==
name|EEPROM_WORD0F_ASM_DIR
condition|)
name|hw
operator|->
name|fc
operator|=
name|E1000_FC_TX_PAUSE
expr_stmt|;
else|else
name|hw
operator|->
name|fc
operator|=
name|E1000_FC_FULL
expr_stmt|;
break|break;
block|}
block|}
comment|/* We want to save off the original Flow Control configuration just      * in case we get disconnected and then reconnected into a different      * hub or switch with different Flow Control capabilities.      */
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|==
name|em_82542_rev2_0
condition|)
name|hw
operator|->
name|fc
operator|&=
operator|(
operator|~
name|E1000_FC_TX_PAUSE
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|hw
operator|->
name|mac_type
operator|<
name|em_82543
operator|)
operator|&&
operator|(
name|hw
operator|->
name|report_tx_early
operator|==
literal|1
operator|)
condition|)
name|hw
operator|->
name|fc
operator|&=
operator|(
operator|~
name|E1000_FC_RX_PAUSE
operator|)
expr_stmt|;
name|hw
operator|->
name|original_fc
operator|=
name|hw
operator|->
name|fc
expr_stmt|;
name|DEBUGOUT1
argument_list|(
literal|"After fix-ups FlowControl is now = %x\n"
argument_list|,
name|hw
operator|->
name|fc
argument_list|)
expr_stmt|;
comment|/* Take the 4 bits from EEPROM word 0x0F that determine the initial      * polarity value for the SW controlled pins, and setup the      * Extended Device Control reg with that info.      * This is needed because one of the SW controlled pins is used for      * signal detection.  So this should be done before em_setup_pcs_link()      * or em_phy_setup() is called.      */
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|==
name|em_82543
condition|)
block|{
name|ret_val
operator|=
name|em_read_eeprom
argument_list|(
name|hw
argument_list|,
name|EEPROM_INIT_CONTROL2_REG
argument_list|,
literal|1
argument_list|,
operator|&
name|eeprom_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"EEPROM Read Error\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_EEPROM
return|;
block|}
name|ctrl_ext
operator|=
operator|(
operator|(
name|eeprom_data
operator|&
name|EEPROM_WORD0F_SWPDIO_EXT
operator|)
operator|<<
name|SWDPIO__EXT_SHIFT
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|CTRL_EXT
argument_list|,
name|ctrl_ext
argument_list|)
expr_stmt|;
block|}
comment|/* Call the necessary subroutine to configure the link. */
name|ret_val
operator|=
operator|(
name|hw
operator|->
name|media_type
operator|==
name|em_media_type_copper
operator|)
condition|?
name|em_setup_copper_link
argument_list|(
name|hw
argument_list|)
else|:
name|em_setup_fiber_serdes_link
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Initialize the flow control address, type, and PAUSE timer      * registers to their default values.  This is done even if flow      * control is disabled, because it does not hurt anything to      * initialize these registers.      */
name|DEBUGOUT
argument_list|(
literal|"Initializing the Flow Control address, type and timer regs\n"
argument_list|)
expr_stmt|;
comment|/* FCAL/H and FCT are hardcoded to standard values in em_ich8lan. */
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|!=
name|em_ich8lan
condition|)
block|{
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|FCT
argument_list|,
name|FLOW_CONTROL_TYPE
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|FCAH
argument_list|,
name|FLOW_CONTROL_ADDRESS_HIGH
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|FCAL
argument_list|,
name|FLOW_CONTROL_ADDRESS_LOW
argument_list|)
expr_stmt|;
block|}
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|FCTTV
argument_list|,
name|hw
operator|->
name|fc_pause_time
argument_list|)
expr_stmt|;
comment|/* Set the flow control receive threshold registers.  Normally,      * these registers will be set to a default threshold that may be      * adjusted later by the driver's runtime code.  However, if the      * ability to transmit pause frames in not enabled, then these      * registers will be set to 0.      */
if|if
condition|(
operator|!
operator|(
name|hw
operator|->
name|fc
operator|&
name|E1000_FC_TX_PAUSE
operator|)
condition|)
block|{
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|FCRTL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|FCRTH
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* We need to set up the Receive Threshold high and low water marks          * as well as (optionally) enabling the transmission of XON frames.          */
if|if
condition|(
name|hw
operator|->
name|fc_send_xon
condition|)
block|{
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|FCRTL
argument_list|,
operator|(
name|hw
operator|->
name|fc_low_water
operator||
name|E1000_FCRTL_XONE
operator|)
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|FCRTH
argument_list|,
name|hw
operator|->
name|fc_high_water
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|FCRTL
argument_list|,
name|hw
operator|->
name|fc_low_water
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|FCRTH
argument_list|,
name|hw
operator|->
name|fc_high_water
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Sets up link for a fiber based or serdes based adapter  *  * hw - Struct containing variables accessed by shared code  *  * Manipulates Physical Coding Sublayer functions in order to configure  * link. Assumes the hardware has been previously reset and the transmitter  * and receiver are not enabled.  *****************************************************************************/
end_comment

begin_function
specifier|static
name|int32_t
name|em_setup_fiber_serdes_link
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|uint32_t
name|ctrl
decl_stmt|;
name|uint32_t
name|status
decl_stmt|;
name|uint32_t
name|txcw
init|=
literal|0
decl_stmt|;
name|uint32_t
name|i
decl_stmt|;
name|uint32_t
name|signal
init|=
literal|0
decl_stmt|;
name|int32_t
name|ret_val
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_setup_fiber_serdes_link"
argument_list|)
expr_stmt|;
comment|/* On 82571 and 82572 Fiber connections, SerDes loopback mode persists      * until explicitly turned off or a power cycle is performed.  A read to      * the register does not indicate its status.  Therefore, we ensure      * loopback mode is disabled during initialization.      */
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|==
name|em_82571
operator|||
name|hw
operator|->
name|mac_type
operator|==
name|em_82572
condition|)
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|SCTL
argument_list|,
name|E1000_DISABLE_SERDES_LOOPBACK
argument_list|)
expr_stmt|;
comment|/* On adapters with a MAC newer than 82544, SWDP 1 will be      * set when the optics detect a signal. On older adapters, it will be      * cleared when there is a signal.  This applies to fiber media only.      * If we're on serdes media, adjust the output amplitude to value      * set in the EEPROM.      */
name|ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|media_type
operator|==
name|em_media_type_fiber
condition|)
name|signal
operator|=
operator|(
name|hw
operator|->
name|mac_type
operator|>
name|em_82544
operator|)
condition|?
name|E1000_CTRL_SWDPIN1
else|:
literal|0
expr_stmt|;
name|ret_val
operator|=
name|em_adjust_serdes_amplitude
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
comment|/* Take the link out of reset */
name|ctrl
operator|&=
operator|~
operator|(
name|E1000_CTRL_LRST
operator|)
expr_stmt|;
comment|/* Adjust VCO speed to improve BER performance */
name|ret_val
operator|=
name|em_set_vco_speed
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|em_config_collision_dist
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Check for a software override of the flow control settings, and setup      * the device accordingly.  If auto-negotiation is enabled, then software      * will have to set the "PAUSE" bits to the correct value in the Tranmsit      * Config Word Register (TXCW) and re-start auto-negotiation.  However, if      * auto-negotiation is disabled, then software will have to manually      * configure the two flow control enable bits in the CTRL register.      *      * The possible values of the "fc" parameter are:      *      0:  Flow control is completely disabled      *      1:  Rx flow control is enabled (we can receive pause frames, but      *          not send pause frames).      *      2:  Tx flow control is enabled (we can send pause frames but we do      *          not support receiving pause frames).      *      3:  Both Rx and TX flow control (symmetric) are enabled.      */
switch|switch
condition|(
name|hw
operator|->
name|fc
condition|)
block|{
case|case
name|E1000_FC_NONE
case|:
comment|/* Flow control is completely disabled by a software over-ride. */
name|txcw
operator|=
operator|(
name|E1000_TXCW_ANE
operator||
name|E1000_TXCW_FD
operator|)
expr_stmt|;
break|break;
case|case
name|E1000_FC_RX_PAUSE
case|:
comment|/* RX Flow control is enabled and TX Flow control is disabled by a          * software over-ride. Since there really isn't a way to advertise          * that we are capable of RX Pause ONLY, we will advertise that we          * support both symmetric and asymmetric RX PAUSE. Later, we will          *  disable the adapter's ability to send PAUSE frames.          */
name|txcw
operator|=
operator|(
name|E1000_TXCW_ANE
operator||
name|E1000_TXCW_FD
operator||
name|E1000_TXCW_PAUSE_MASK
operator|)
expr_stmt|;
break|break;
case|case
name|E1000_FC_TX_PAUSE
case|:
comment|/* TX Flow control is enabled, and RX Flow control is disabled, by a          * software over-ride.          */
name|txcw
operator|=
operator|(
name|E1000_TXCW_ANE
operator||
name|E1000_TXCW_FD
operator||
name|E1000_TXCW_ASM_DIR
operator|)
expr_stmt|;
break|break;
case|case
name|E1000_FC_FULL
case|:
comment|/* Flow control (both RX and TX) is enabled by a software over-ride. */
name|txcw
operator|=
operator|(
name|E1000_TXCW_ANE
operator||
name|E1000_TXCW_FD
operator||
name|E1000_TXCW_PAUSE_MASK
operator|)
expr_stmt|;
break|break;
default|default:
name|DEBUGOUT
argument_list|(
literal|"Flow control param set incorrectly\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_CONFIG
return|;
break|break;
block|}
comment|/* Since auto-negotiation is enabled, take the link out of reset (the link      * will be in reset, because we previously reset the chip). This will      * restart auto-negotiation.  If auto-neogtiation is successful then the      * link-up status bit will be set and the flow control enable bits (RFCE      * and TFCE) will be set according to their negotiated value.      */
name|DEBUGOUT
argument_list|(
literal|"Auto-negotiation enabled\n"
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|TXCW
argument_list|,
name|txcw
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|hw
operator|->
name|txcw
operator|=
name|txcw
expr_stmt|;
name|msec_delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* If we have a signal (the cable is plugged in) then poll for a "Link-Up"      * indication in the Device Status Register.  Time-out if a link isn't      * seen in 500 milliseconds seconds (Auto-negotiation should complete in      * less than 500 milliseconds even if the other end is doing it in SW).      * For internal serdes, we just assume a signal is present, then poll.      */
if|if
condition|(
name|hw
operator|->
name|media_type
operator|==
name|em_media_type_internal_serdes
operator|||
operator|(
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|)
operator|&
name|E1000_CTRL_SWDPIN1
operator|)
operator|==
name|signal
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Looking for Link\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|LINK_UP_TIMEOUT
operator|/
literal|10
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|msec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|status
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|E1000_STATUS_LU
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
operator|(
name|LINK_UP_TIMEOUT
operator|/
literal|10
operator|)
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Never got a valid link from auto-neg!!!\n"
argument_list|)
expr_stmt|;
name|hw
operator|->
name|autoneg_failed
operator|=
literal|1
expr_stmt|;
comment|/* AutoNeg failed to achieve a link, so we'll call              * em_check_for_link. This routine will force the link up if              * we detect a signal. This will allow us to communicate with              * non-autonegotiating link partners.              */
name|ret_val
operator|=
name|em_check_for_link
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Error while checking for link\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
name|hw
operator|->
name|autoneg_failed
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|hw
operator|->
name|autoneg_failed
operator|=
literal|0
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Valid Link Found\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|DEBUGOUT
argument_list|(
literal|"No Signal Detected\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************** * Make sure we have a valid PHY and change PHY mode before link setup. * * hw - Struct containing variables accessed by shared code ******************************************************************************/
end_comment

begin_function
specifier|static
name|int32_t
name|em_copper_link_preconfig
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|uint32_t
name|ctrl
decl_stmt|;
name|int32_t
name|ret_val
decl_stmt|;
name|uint16_t
name|phy_data
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_copper_link_preconfig"
argument_list|)
expr_stmt|;
name|ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|)
expr_stmt|;
comment|/* With 82543, we need to force speed and duplex on the MAC equal to what      * the PHY speed and duplex configuration is. In addition, we need to      * perform a hardware reset on the PHY to take it out of reset.      */
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|>
name|em_82543
condition|)
block|{
name|ctrl
operator||=
name|E1000_CTRL_SLU
expr_stmt|;
name|ctrl
operator|&=
operator|~
operator|(
name|E1000_CTRL_FRCSPD
operator||
name|E1000_CTRL_FRCDPX
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ctrl
operator||=
operator|(
name|E1000_CTRL_FRCSPD
operator||
name|E1000_CTRL_FRCDPX
operator||
name|E1000_CTRL_SLU
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|em_phy_hw_reset
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
block|}
comment|/* Make sure we have a valid PHY */
name|ret_val
operator|=
name|em_detect_gig_phy
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Error, did not detect valid phy.\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
name|DEBUGOUT1
argument_list|(
literal|"Phy ID = %x \n"
argument_list|,
name|hw
operator|->
name|phy_id
argument_list|)
expr_stmt|;
comment|/* Set PHY to class A mode (if necessary) */
name|ret_val
operator|=
name|em_set_phy_mode
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
if|if
condition|(
operator|(
name|hw
operator|->
name|mac_type
operator|==
name|em_82545_rev_3
operator|)
operator|||
operator|(
name|hw
operator|->
name|mac_type
operator|==
name|em_82546_rev_3
operator|)
condition|)
block|{
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_SPEC_CTRL
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
name|phy_data
operator||=
literal|0x00000008
expr_stmt|;
name|ret_val
operator|=
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_SPEC_CTRL
argument_list|,
name|phy_data
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|<=
name|em_82543
operator|||
name|hw
operator|->
name|mac_type
operator|==
name|em_82541
operator|||
name|hw
operator|->
name|mac_type
operator|==
name|em_82547
operator|||
name|hw
operator|->
name|mac_type
operator|==
name|em_82541_rev_2
operator|||
name|hw
operator|->
name|mac_type
operator|==
name|em_82547_rev_2
condition|)
name|hw
operator|->
name|phy_reset_disable
operator|=
name|FALSE
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/******************************************************************** * Copper link setup for em_phy_igp series. * * hw - Struct containing variables accessed by shared code *********************************************************************/
end_comment

begin_function
specifier|static
name|int32_t
name|em_copper_link_igp_setup
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|uint32_t
name|led_ctrl
decl_stmt|;
name|int32_t
name|ret_val
decl_stmt|;
name|uint16_t
name|phy_data
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_copper_link_igp_setup"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|phy_reset_disable
condition|)
return|return
name|E1000_SUCCESS
return|;
name|ret_val
operator|=
name|em_phy_reset
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Error Resetting the PHY\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
comment|/* Wait 15ms for MAC to configure PHY from eeprom settings */
name|msec_delay
argument_list|(
literal|15
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|!=
name|em_ich8lan
condition|)
block|{
comment|/* Configure activity LED after PHY reset */
name|led_ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|LEDCTL
argument_list|)
expr_stmt|;
name|led_ctrl
operator|&=
name|IGP_ACTIVITY_LED_MASK
expr_stmt|;
name|led_ctrl
operator||=
operator|(
name|IGP_ACTIVITY_LED_ENABLE
operator||
name|IGP_LED3_MODE
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|LEDCTL
argument_list|,
name|led_ctrl
argument_list|)
expr_stmt|;
block|}
comment|/* The NVM settings will configure LPLU in D3 for IGP2 and IGP3 PHYs */
if|if
condition|(
name|hw
operator|->
name|phy_type
operator|==
name|em_phy_igp
condition|)
block|{
comment|/* disable lplu d3 during driver init */
name|ret_val
operator|=
name|em_set_d3_lplu_state
argument_list|(
name|hw
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Error Disabling LPLU D3\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
block|}
comment|/* disable lplu d0 during driver init */
name|ret_val
operator|=
name|em_set_d0_lplu_state
argument_list|(
name|hw
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Error Disabling LPLU D0\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
comment|/* Configure mdi-mdix settings */
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_CTRL
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
if|if
condition|(
operator|(
name|hw
operator|->
name|mac_type
operator|==
name|em_82541
operator|)
operator|||
operator|(
name|hw
operator|->
name|mac_type
operator|==
name|em_82547
operator|)
condition|)
block|{
name|hw
operator|->
name|dsp_config_state
operator|=
name|em_dsp_config_disabled
expr_stmt|;
comment|/* Force MDI for earlier revs of the IGP PHY */
name|phy_data
operator|&=
operator|~
operator|(
name|IGP01E1000_PSCR_AUTO_MDIX
operator||
name|IGP01E1000_PSCR_FORCE_MDI_MDIX
operator|)
expr_stmt|;
name|hw
operator|->
name|mdix
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|hw
operator|->
name|dsp_config_state
operator|=
name|em_dsp_config_enabled
expr_stmt|;
name|phy_data
operator|&=
operator|~
name|IGP01E1000_PSCR_AUTO_MDIX
expr_stmt|;
switch|switch
condition|(
name|hw
operator|->
name|mdix
condition|)
block|{
case|case
literal|1
case|:
name|phy_data
operator|&=
operator|~
name|IGP01E1000_PSCR_FORCE_MDI_MDIX
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|phy_data
operator||=
name|IGP01E1000_PSCR_FORCE_MDI_MDIX
expr_stmt|;
break|break;
case|case
literal|0
case|:
default|default:
name|phy_data
operator||=
name|IGP01E1000_PSCR_AUTO_MDIX
expr_stmt|;
break|break;
block|}
block|}
name|ret_val
operator|=
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_CTRL
argument_list|,
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
comment|/* set auto-master slave resolution settings */
if|if
condition|(
name|hw
operator|->
name|autoneg
condition|)
block|{
name|em_ms_type
name|phy_ms_setting
init|=
name|hw
operator|->
name|master_slave
decl_stmt|;
if|if
condition|(
name|hw
operator|->
name|ffe_config_state
operator|==
name|em_ffe_config_active
condition|)
name|hw
operator|->
name|ffe_config_state
operator|=
name|em_ffe_config_enabled
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|dsp_config_state
operator|==
name|em_dsp_config_activated
condition|)
name|hw
operator|->
name|dsp_config_state
operator|=
name|em_dsp_config_enabled
expr_stmt|;
comment|/* when autonegotiation advertisment is only 1000Mbps then we           * should disable SmartSpeed and enable Auto MasterSlave           * resolution as hardware default. */
if|if
condition|(
name|hw
operator|->
name|autoneg_advertised
operator|==
name|ADVERTISE_1000_FULL
condition|)
block|{
comment|/* Disable SmartSpeed */
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_CONFIG
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|phy_data
operator|&=
operator|~
name|IGP01E1000_PSCFR_SMART_SPEED
expr_stmt|;
name|ret_val
operator|=
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_CONFIG
argument_list|,
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
comment|/* Set auto Master/Slave resolution process */
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_1000T_CTRL
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|phy_data
operator|&=
operator|~
name|CR_1000T_MS_ENABLE
expr_stmt|;
name|ret_val
operator|=
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_1000T_CTRL
argument_list|,
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
block|}
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_1000T_CTRL
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
comment|/* load defaults for future use */
name|hw
operator|->
name|original_master_slave
operator|=
operator|(
name|phy_data
operator|&
name|CR_1000T_MS_ENABLE
operator|)
condition|?
operator|(
operator|(
name|phy_data
operator|&
name|CR_1000T_MS_VALUE
operator|)
condition|?
name|em_ms_force_master
else|:
name|em_ms_force_slave
operator|)
else|:
name|em_ms_auto
expr_stmt|;
switch|switch
condition|(
name|phy_ms_setting
condition|)
block|{
case|case
name|em_ms_force_master
case|:
name|phy_data
operator||=
operator|(
name|CR_1000T_MS_ENABLE
operator||
name|CR_1000T_MS_VALUE
operator|)
expr_stmt|;
break|break;
case|case
name|em_ms_force_slave
case|:
name|phy_data
operator||=
name|CR_1000T_MS_ENABLE
expr_stmt|;
name|phy_data
operator|&=
operator|~
operator|(
name|CR_1000T_MS_VALUE
operator|)
expr_stmt|;
break|break;
case|case
name|em_ms_auto
case|:
name|phy_data
operator|&=
operator|~
name|CR_1000T_MS_ENABLE
expr_stmt|;
default|default:
break|break;
block|}
name|ret_val
operator|=
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_1000T_CTRL
argument_list|,
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/******************************************************************** * Copper link setup for em_phy_gg82563 series. * * hw - Struct containing variables accessed by shared code *********************************************************************/
end_comment

begin_function
specifier|static
name|int32_t
name|em_copper_link_ggp_setup
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|int32_t
name|ret_val
decl_stmt|;
name|uint16_t
name|phy_data
decl_stmt|;
name|uint32_t
name|reg_data
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_copper_link_ggp_setup"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hw
operator|->
name|phy_reset_disable
condition|)
block|{
comment|/* Enable CRS on TX for half-duplex operation. */
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|GG82563_PHY_MAC_SPEC_CTRL
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|phy_data
operator||=
name|GG82563_MSCR_ASSERT_CRS_ON_TX
expr_stmt|;
comment|/* Use 25MHz for both link down and 1000BASE-T for Tx clock */
name|phy_data
operator||=
name|GG82563_MSCR_TX_CLK_1000MBPS_25MHZ
expr_stmt|;
name|ret_val
operator|=
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|GG82563_PHY_MAC_SPEC_CTRL
argument_list|,
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
comment|/* Options:          *   MDI/MDI-X = 0 (default)          *   0 - Auto for all speeds          *   1 - MDI mode          *   2 - MDI-X mode          *   3 - Auto for 1000Base-T only (MDI-X for 10/100Base-T modes)          */
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|GG82563_PHY_SPEC_CTRL
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|phy_data
operator|&=
operator|~
name|GG82563_PSCR_CROSSOVER_MODE_MASK
expr_stmt|;
switch|switch
condition|(
name|hw
operator|->
name|mdix
condition|)
block|{
case|case
literal|1
case|:
name|phy_data
operator||=
name|GG82563_PSCR_CROSSOVER_MODE_MDI
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|phy_data
operator||=
name|GG82563_PSCR_CROSSOVER_MODE_MDIX
expr_stmt|;
break|break;
case|case
literal|0
case|:
default|default:
name|phy_data
operator||=
name|GG82563_PSCR_CROSSOVER_MODE_AUTO
expr_stmt|;
break|break;
block|}
comment|/* Options:          *   disable_polarity_correction = 0 (default)          *       Automatic Correction for Reversed Cable Polarity          *   0 - Disabled          *   1 - Enabled          */
name|phy_data
operator|&=
operator|~
name|GG82563_PSCR_POLARITY_REVERSAL_DISABLE
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|disable_polarity_correction
operator|==
literal|1
condition|)
name|phy_data
operator||=
name|GG82563_PSCR_POLARITY_REVERSAL_DISABLE
expr_stmt|;
name|ret_val
operator|=
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|GG82563_PHY_SPEC_CTRL
argument_list|,
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
comment|/* SW Reset the PHY so all changes take effect */
name|ret_val
operator|=
name|em_phy_reset
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Error Resetting the PHY\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
block|}
comment|/* phy_reset_disable */
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|==
name|em_80003es2lan
condition|)
block|{
comment|/* Bypass RX and TX FIFO's */
name|ret_val
operator|=
name|em_write_kmrn_reg
argument_list|(
name|hw
argument_list|,
name|E1000_KUMCTRLSTA_OFFSET_FIFO_CTRL
argument_list|,
name|E1000_KUMCTRLSTA_FIFO_CTRL_RX_BYPASS
operator||
name|E1000_KUMCTRLSTA_FIFO_CTRL_TX_BYPASS
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|GG82563_PHY_SPEC_CTRL_2
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|phy_data
operator|&=
operator|~
name|GG82563_PSCR2_REVERSE_AUTO_NEG
expr_stmt|;
name|ret_val
operator|=
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|GG82563_PHY_SPEC_CTRL_2
argument_list|,
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|reg_data
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|CTRL_EXT
argument_list|)
expr_stmt|;
name|reg_data
operator|&=
operator|~
operator|(
name|E1000_CTRL_EXT_LINK_MODE_MASK
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|CTRL_EXT
argument_list|,
name|reg_data
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|GG82563_PHY_PWR_MGMT_CTRL
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
comment|/* Do not init these registers when the HW is in IAMT mode, since the          * firmware will have already initialized them.  We only initialize          * them if the HW is not in IAMT mode.          */
if|if
condition|(
name|em_check_mng_mode
argument_list|(
name|hw
argument_list|)
operator|==
name|FALSE
condition|)
block|{
comment|/* Enable Electrical Idle on the PHY */
name|phy_data
operator||=
name|GG82563_PMCR_ENABLE_ELECTRICAL_IDLE
expr_stmt|;
name|ret_val
operator|=
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|GG82563_PHY_PWR_MGMT_CTRL
argument_list|,
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|GG82563_PHY_KMRN_MODE_CTRL
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|phy_data
operator|&=
operator|~
name|GG82563_KMCR_PASS_FALSE_CARRIER
expr_stmt|;
name|ret_val
operator|=
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|GG82563_PHY_KMRN_MODE_CTRL
argument_list|,
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
block|}
comment|/* Workaround: Disable padding in Kumeran interface in the MAC          * and in the PHY to avoid CRC errors.          */
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|GG82563_PHY_INBAND_CTRL
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|phy_data
operator||=
name|GG82563_ICR_DIS_PADDING
expr_stmt|;
name|ret_val
operator|=
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|GG82563_PHY_INBAND_CTRL
argument_list|,
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/******************************************************************** * Copper link setup for em_phy_m88 series. * * hw - Struct containing variables accessed by shared code *********************************************************************/
end_comment

begin_function
specifier|static
name|int32_t
name|em_copper_link_mgp_setup
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|int32_t
name|ret_val
decl_stmt|;
name|uint16_t
name|phy_data
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_copper_link_mgp_setup"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|phy_reset_disable
condition|)
return|return
name|E1000_SUCCESS
return|;
comment|/* Enable CRS on TX. This must be set for half-duplex operation. */
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_SPEC_CTRL
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|phy_data
operator||=
name|M88E1000_PSCR_ASSERT_CRS_ON_TX
expr_stmt|;
comment|/* Options:      *   MDI/MDI-X = 0 (default)      *   0 - Auto for all speeds      *   1 - MDI mode      *   2 - MDI-X mode      *   3 - Auto for 1000Base-T only (MDI-X for 10/100Base-T modes)      */
name|phy_data
operator|&=
operator|~
name|M88E1000_PSCR_AUTO_X_MODE
expr_stmt|;
switch|switch
condition|(
name|hw
operator|->
name|mdix
condition|)
block|{
case|case
literal|1
case|:
name|phy_data
operator||=
name|M88E1000_PSCR_MDI_MANUAL_MODE
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|phy_data
operator||=
name|M88E1000_PSCR_MDIX_MANUAL_MODE
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|phy_data
operator||=
name|M88E1000_PSCR_AUTO_X_1000T
expr_stmt|;
break|break;
case|case
literal|0
case|:
default|default:
name|phy_data
operator||=
name|M88E1000_PSCR_AUTO_X_MODE
expr_stmt|;
break|break;
block|}
comment|/* Options:      *   disable_polarity_correction = 0 (default)      *       Automatic Correction for Reversed Cable Polarity      *   0 - Disabled      *   1 - Enabled      */
name|phy_data
operator|&=
operator|~
name|M88E1000_PSCR_POLARITY_REVERSAL
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|disable_polarity_correction
operator|==
literal|1
condition|)
name|phy_data
operator||=
name|M88E1000_PSCR_POLARITY_REVERSAL
expr_stmt|;
name|ret_val
operator|=
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_SPEC_CTRL
argument_list|,
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
if|if
condition|(
name|hw
operator|->
name|phy_revision
operator|<
name|M88E1011_I_REV_4
condition|)
block|{
comment|/* Force TX_CLK in the Extended PHY Specific Control Register          * to 25MHz clock.          */
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_EXT_PHY_SPEC_CTRL
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|phy_data
operator||=
name|M88E1000_EPSCR_TX_CLK_25
expr_stmt|;
if|if
condition|(
operator|(
name|hw
operator|->
name|phy_revision
operator|==
name|E1000_REVISION_2
operator|)
operator|&&
operator|(
name|hw
operator|->
name|phy_id
operator|==
name|M88E1111_I_PHY_ID
operator|)
condition|)
block|{
comment|/* Vidalia Phy, set the downshift counter to 5x */
name|phy_data
operator|&=
operator|~
operator|(
name|M88EC018_EPSCR_DOWNSHIFT_COUNTER_MASK
operator|)
expr_stmt|;
name|phy_data
operator||=
name|M88EC018_EPSCR_DOWNSHIFT_COUNTER_5X
expr_stmt|;
name|ret_val
operator|=
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_EXT_PHY_SPEC_CTRL
argument_list|,
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
block|}
else|else
block|{
comment|/* Configure Master and Slave downshift values */
name|phy_data
operator|&=
operator|~
operator|(
name|M88E1000_EPSCR_MASTER_DOWNSHIFT_MASK
operator||
name|M88E1000_EPSCR_SLAVE_DOWNSHIFT_MASK
operator|)
expr_stmt|;
name|phy_data
operator||=
operator|(
name|M88E1000_EPSCR_MASTER_DOWNSHIFT_1X
operator||
name|M88E1000_EPSCR_SLAVE_DOWNSHIFT_1X
operator|)
expr_stmt|;
name|ret_val
operator|=
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_EXT_PHY_SPEC_CTRL
argument_list|,
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
block|}
block|}
comment|/* SW Reset the PHY so all changes take effect */
name|ret_val
operator|=
name|em_phy_reset
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Error Resetting the PHY\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/******************************************************************** * Setup auto-negotiation and flow control advertisements, * and then perform auto-negotiation. * * hw - Struct containing variables accessed by shared code *********************************************************************/
end_comment

begin_function
specifier|static
name|int32_t
name|em_copper_link_autoneg
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|int32_t
name|ret_val
decl_stmt|;
name|uint16_t
name|phy_data
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_copper_link_autoneg"
argument_list|)
expr_stmt|;
comment|/* Perform some bounds checking on the hw->autoneg_advertised      * parameter.  If this variable is zero, then set it to the default.      */
name|hw
operator|->
name|autoneg_advertised
operator|&=
name|AUTONEG_ADVERTISE_SPEED_DEFAULT
expr_stmt|;
comment|/* If autoneg_advertised is zero, we assume it was not defaulted      * by the calling code so we set to advertise full capability.      */
if|if
condition|(
name|hw
operator|->
name|autoneg_advertised
operator|==
literal|0
condition|)
name|hw
operator|->
name|autoneg_advertised
operator|=
name|AUTONEG_ADVERTISE_SPEED_DEFAULT
expr_stmt|;
comment|/* IFE phy only supports 10/100 */
if|if
condition|(
name|hw
operator|->
name|phy_type
operator|==
name|em_phy_ife
condition|)
name|hw
operator|->
name|autoneg_advertised
operator|&=
name|AUTONEG_ADVERTISE_10_100_ALL
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Reconfiguring auto-neg advertisement params\n"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|em_phy_setup_autoneg
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Error Setting up Auto-Negotiation\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
name|DEBUGOUT
argument_list|(
literal|"Restarting Auto-Neg\n"
argument_list|)
expr_stmt|;
comment|/* Restart auto-negotiation by setting the Auto Neg Enable bit and      * the Auto Neg Restart bit in the PHY control register.      */
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_CTRL
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|phy_data
operator||=
operator|(
name|MII_CR_AUTO_NEG_EN
operator||
name|MII_CR_RESTART_AUTO_NEG
operator|)
expr_stmt|;
name|ret_val
operator|=
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_CTRL
argument_list|,
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
comment|/* Does the user want to wait for Auto-Neg to complete here, or      * check at a later time (for example, callback routine).      */
if|if
condition|(
name|hw
operator|->
name|wait_autoneg_complete
condition|)
block|{
name|ret_val
operator|=
name|em_wait_autoneg
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Error while waiting for autoneg to complete\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
block|}
name|hw
operator|->
name|get_link_status
operator|=
name|TRUE
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************** * Config the MAC and the PHY after link is up. *   1) Set up the MAC to the current PHY speed/duplex *      if we are on 82543.  If we *      are on newer silicon, we only need to configure *      collision distance in the Transmit Control Register. *   2) Set up flow control on the MAC to that established with *      the link partner. *   3) Config DSP to improve Gigabit link quality for some PHY revisions. * * hw - Struct containing variables accessed by shared code ******************************************************************************/
end_comment

begin_function
specifier|static
name|int32_t
name|em_copper_link_postconfig
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|int32_t
name|ret_val
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_copper_link_postconfig"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|>=
name|em_82544
condition|)
block|{
name|em_config_collision_dist
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret_val
operator|=
name|em_config_mac_to_phy
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Error configuring MAC to PHY settings\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
block|}
name|ret_val
operator|=
name|em_config_fc_after_link_up
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Error Configuring Flow Control\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
comment|/* Config DSP to improve Giga link quality */
if|if
condition|(
name|hw
operator|->
name|phy_type
operator|==
name|em_phy_igp
condition|)
block|{
name|ret_val
operator|=
name|em_config_dsp_after_link_change
argument_list|(
name|hw
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Error Configuring DSP after link up\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************** * Detects which PHY is present and setup the speed and duplex * * hw - Struct containing variables accessed by shared code ******************************************************************************/
end_comment

begin_function
specifier|static
name|int32_t
name|em_setup_copper_link
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|int32_t
name|ret_val
decl_stmt|;
name|uint16_t
name|i
decl_stmt|;
name|uint16_t
name|phy_data
decl_stmt|;
name|uint16_t
name|reg_data
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_setup_copper_link"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|hw
operator|->
name|mac_type
condition|)
block|{
case|case
name|em_80003es2lan
case|:
case|case
name|em_ich8lan
case|:
comment|/* Set the mac to wait the maximum time between each          * iteration and increase the max iterations when          * polling the phy; this fixes erroneous timeouts at 10Mbps. */
name|ret_val
operator|=
name|em_write_kmrn_reg
argument_list|(
name|hw
argument_list|,
name|GG82563_REG
argument_list|(
literal|0x34
argument_list|,
literal|4
argument_list|)
argument_list|,
literal|0xFFFF
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|ret_val
operator|=
name|em_read_kmrn_reg
argument_list|(
name|hw
argument_list|,
name|GG82563_REG
argument_list|(
literal|0x34
argument_list|,
literal|9
argument_list|)
argument_list|,
operator|&
name|reg_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|reg_data
operator||=
literal|0x3F
expr_stmt|;
name|ret_val
operator|=
name|em_write_kmrn_reg
argument_list|(
name|hw
argument_list|,
name|GG82563_REG
argument_list|(
literal|0x34
argument_list|,
literal|9
argument_list|)
argument_list|,
name|reg_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
default|default:
break|break;
block|}
comment|/* Check if it is a valid PHY and set PHY mode if necessary. */
name|ret_val
operator|=
name|em_copper_link_preconfig
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
switch|switch
condition|(
name|hw
operator|->
name|mac_type
condition|)
block|{
case|case
name|em_80003es2lan
case|:
comment|/* Kumeran registers are written-only */
name|reg_data
operator|=
name|E1000_KUMCTRLSTA_INB_CTRL_LINK_STATUS_TX_TIMEOUT_DEFAULT
expr_stmt|;
name|reg_data
operator||=
name|E1000_KUMCTRLSTA_INB_CTRL_DIS_PADDING
expr_stmt|;
name|ret_val
operator|=
name|em_write_kmrn_reg
argument_list|(
name|hw
argument_list|,
name|E1000_KUMCTRLSTA_OFFSET_INB_CTRL
argument_list|,
name|reg_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|hw
operator|->
name|phy_type
operator|==
name|em_phy_igp
operator|||
name|hw
operator|->
name|phy_type
operator|==
name|em_phy_igp_3
operator|||
name|hw
operator|->
name|phy_type
operator|==
name|em_phy_igp_2
condition|)
block|{
name|ret_val
operator|=
name|em_copper_link_igp_setup
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
block|}
elseif|else
if|if
condition|(
name|hw
operator|->
name|phy_type
operator|==
name|em_phy_m88
condition|)
block|{
name|ret_val
operator|=
name|em_copper_link_mgp_setup
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
block|}
elseif|else
if|if
condition|(
name|hw
operator|->
name|phy_type
operator|==
name|em_phy_gg82563
condition|)
block|{
name|ret_val
operator|=
name|em_copper_link_ggp_setup
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
block|}
if|if
condition|(
name|hw
operator|->
name|autoneg
condition|)
block|{
comment|/* Setup autoneg and flow control advertisement           * and perform autonegotiation */
name|ret_val
operator|=
name|em_copper_link_autoneg
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
block|}
else|else
block|{
comment|/* PHY will be set to 10H, 10F, 100H,or 100F           * depending on value from forced_speed_duplex. */
name|DEBUGOUT
argument_list|(
literal|"Forcing speed and duplex\n"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|em_phy_force_speed_duplex
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Error Forcing Speed and Duplex\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
block|}
comment|/* Check link status. Wait up to 100 microseconds for link to become      * valid.      */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
block|{
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_STATUS
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_STATUS
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
if|if
condition|(
name|phy_data
operator|&
name|MII_SR_LINK_STATUS
condition|)
block|{
comment|/* Config the MAC and PHY after link is up */
name|ret_val
operator|=
name|em_copper_link_postconfig
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|DEBUGOUT
argument_list|(
literal|"Valid link established!!!\n"
argument_list|)
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
name|usec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
name|DEBUGOUT
argument_list|(
literal|"Unable to establish link!!!\n"
argument_list|)
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************** * Configure the MAC-to-PHY interface for 10/100Mbps * * hw - Struct containing variables accessed by shared code ******************************************************************************/
end_comment

begin_function
specifier|static
name|int32_t
name|em_configure_kmrn_for_10_100
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint16_t
name|duplex
parameter_list|)
block|{
name|int32_t
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|uint32_t
name|tipg
decl_stmt|;
name|uint16_t
name|reg_data
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_configure_kmrn_for_10_100"
argument_list|)
expr_stmt|;
name|reg_data
operator|=
name|E1000_KUMCTRLSTA_HD_CTRL_10_100_DEFAULT
expr_stmt|;
name|ret_val
operator|=
name|em_write_kmrn_reg
argument_list|(
name|hw
argument_list|,
name|E1000_KUMCTRLSTA_OFFSET_HD_CTRL
argument_list|,
name|reg_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
comment|/* Configure Transmit Inter-Packet Gap */
name|tipg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|TIPG
argument_list|)
expr_stmt|;
name|tipg
operator|&=
operator|~
name|E1000_TIPG_IPGT_MASK
expr_stmt|;
name|tipg
operator||=
name|DEFAULT_80003ES2LAN_TIPG_IPGT_10_100
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|TIPG
argument_list|,
name|tipg
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|GG82563_PHY_KMRN_MODE_CTRL
argument_list|,
operator|&
name|reg_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
if|if
condition|(
name|duplex
operator|==
name|HALF_DUPLEX
condition|)
name|reg_data
operator||=
name|GG82563_KMCR_PASS_FALSE_CARRIER
expr_stmt|;
else|else
name|reg_data
operator|&=
operator|~
name|GG82563_KMCR_PASS_FALSE_CARRIER
expr_stmt|;
name|ret_val
operator|=
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|GG82563_PHY_KMRN_MODE_CTRL
argument_list|,
name|reg_data
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_function
specifier|static
name|int32_t
name|em_configure_kmrn_for_1000
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|int32_t
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|uint16_t
name|reg_data
decl_stmt|;
name|uint32_t
name|tipg
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_configure_kmrn_for_1000"
argument_list|)
expr_stmt|;
name|reg_data
operator|=
name|E1000_KUMCTRLSTA_HD_CTRL_1000_DEFAULT
expr_stmt|;
name|ret_val
operator|=
name|em_write_kmrn_reg
argument_list|(
name|hw
argument_list|,
name|E1000_KUMCTRLSTA_OFFSET_HD_CTRL
argument_list|,
name|reg_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
comment|/* Configure Transmit Inter-Packet Gap */
name|tipg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|TIPG
argument_list|)
expr_stmt|;
name|tipg
operator|&=
operator|~
name|E1000_TIPG_IPGT_MASK
expr_stmt|;
name|tipg
operator||=
name|DEFAULT_80003ES2LAN_TIPG_IPGT_1000
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|TIPG
argument_list|,
name|tipg
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|GG82563_PHY_KMRN_MODE_CTRL
argument_list|,
operator|&
name|reg_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|reg_data
operator|&=
operator|~
name|GG82563_KMCR_PASS_FALSE_CARRIER
expr_stmt|;
name|ret_val
operator|=
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|GG82563_PHY_KMRN_MODE_CTRL
argument_list|,
name|reg_data
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************** * Configures PHY autoneg and flow control advertisement settings * * hw - Struct containing variables accessed by shared code ******************************************************************************/
end_comment

begin_function
name|int32_t
name|em_phy_setup_autoneg
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|int32_t
name|ret_val
decl_stmt|;
name|uint16_t
name|mii_autoneg_adv_reg
decl_stmt|;
name|uint16_t
name|mii_1000t_ctrl_reg
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_phy_setup_autoneg"
argument_list|)
expr_stmt|;
comment|/* Read the MII Auto-Neg Advertisement Register (Address 4). */
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_AUTONEG_ADV
argument_list|,
operator|&
name|mii_autoneg_adv_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
if|if
condition|(
name|hw
operator|->
name|phy_type
operator|!=
name|em_phy_ife
condition|)
block|{
comment|/* Read the MII 1000Base-T Control Register (Address 9). */
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_1000T_CTRL
argument_list|,
operator|&
name|mii_1000t_ctrl_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
block|}
else|else
name|mii_1000t_ctrl_reg
operator|=
literal|0
expr_stmt|;
comment|/* Need to parse both autoneg_advertised and fc and set up      * the appropriate PHY registers.  First we will parse for      * autoneg_advertised software override.  Since we can advertise      * a plethora of combinations, we need to check each bit      * individually.      */
comment|/* First we clear all the 10/100 mb speed bits in the Auto-Neg      * Advertisement Register (Address 4) and the 1000 mb speed bits in      * the  1000Base-T Control Register (Address 9).      */
name|mii_autoneg_adv_reg
operator|&=
operator|~
name|REG4_SPEED_MASK
expr_stmt|;
name|mii_1000t_ctrl_reg
operator|&=
operator|~
name|REG9_SPEED_MASK
expr_stmt|;
name|DEBUGOUT1
argument_list|(
literal|"autoneg_advertised %x\n"
argument_list|,
name|hw
operator|->
name|autoneg_advertised
argument_list|)
expr_stmt|;
comment|/* Do we want to advertise 10 Mb Half Duplex? */
if|if
condition|(
name|hw
operator|->
name|autoneg_advertised
operator|&
name|ADVERTISE_10_HALF
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Advertise 10mb Half duplex\n"
argument_list|)
expr_stmt|;
name|mii_autoneg_adv_reg
operator||=
name|NWAY_AR_10T_HD_CAPS
expr_stmt|;
block|}
comment|/* Do we want to advertise 10 Mb Full Duplex? */
if|if
condition|(
name|hw
operator|->
name|autoneg_advertised
operator|&
name|ADVERTISE_10_FULL
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Advertise 10mb Full duplex\n"
argument_list|)
expr_stmt|;
name|mii_autoneg_adv_reg
operator||=
name|NWAY_AR_10T_FD_CAPS
expr_stmt|;
block|}
comment|/* Do we want to advertise 100 Mb Half Duplex? */
if|if
condition|(
name|hw
operator|->
name|autoneg_advertised
operator|&
name|ADVERTISE_100_HALF
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Advertise 100mb Half duplex\n"
argument_list|)
expr_stmt|;
name|mii_autoneg_adv_reg
operator||=
name|NWAY_AR_100TX_HD_CAPS
expr_stmt|;
block|}
comment|/* Do we want to advertise 100 Mb Full Duplex? */
if|if
condition|(
name|hw
operator|->
name|autoneg_advertised
operator|&
name|ADVERTISE_100_FULL
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Advertise 100mb Full duplex\n"
argument_list|)
expr_stmt|;
name|mii_autoneg_adv_reg
operator||=
name|NWAY_AR_100TX_FD_CAPS
expr_stmt|;
block|}
comment|/* We do not allow the Phy to advertise 1000 Mb Half Duplex */
if|if
condition|(
name|hw
operator|->
name|autoneg_advertised
operator|&
name|ADVERTISE_1000_HALF
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Advertise 1000mb Half duplex requested, request denied!\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Do we want to advertise 1000 Mb Full Duplex? */
if|if
condition|(
name|hw
operator|->
name|autoneg_advertised
operator|&
name|ADVERTISE_1000_FULL
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Advertise 1000mb Full duplex\n"
argument_list|)
expr_stmt|;
name|mii_1000t_ctrl_reg
operator||=
name|CR_1000T_FD_CAPS
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|phy_type
operator|==
name|em_phy_ife
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"em_phy_ife is a 10/100 PHY. Gigabit speed is not supported.\n"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Check for a software override of the flow control settings, and      * setup the PHY advertisement registers accordingly.  If      * auto-negotiation is enabled, then software will have to set the      * "PAUSE" bits to the correct value in the Auto-Negotiation      * Advertisement Register (PHY_AUTONEG_ADV) and re-start auto-negotiation.      *      * The possible values of the "fc" parameter are:      *      0:  Flow control is completely disabled      *      1:  Rx flow control is enabled (we can receive pause frames      *          but not send pause frames).      *      2:  Tx flow control is enabled (we can send pause frames      *          but we do not support receiving pause frames).      *      3:  Both Rx and TX flow control (symmetric) are enabled.      *  other:  No software override.  The flow control configuration      *          in the EEPROM is used.      */
switch|switch
condition|(
name|hw
operator|->
name|fc
condition|)
block|{
case|case
name|E1000_FC_NONE
case|:
comment|/* 0 */
comment|/* Flow control (RX& TX) is completely disabled by a          * software over-ride.          */
name|mii_autoneg_adv_reg
operator|&=
operator|~
operator|(
name|NWAY_AR_ASM_DIR
operator||
name|NWAY_AR_PAUSE
operator|)
expr_stmt|;
break|break;
case|case
name|E1000_FC_RX_PAUSE
case|:
comment|/* 1 */
comment|/* RX Flow control is enabled, and TX Flow control is          * disabled, by a software over-ride.          */
comment|/* Since there really isn't a way to advertise that we are          * capable of RX Pause ONLY, we will advertise that we          * support both symmetric and asymmetric RX PAUSE.  Later          * (in em_config_fc_after_link_up) we will disable the          *hw's ability to send PAUSE frames.          */
name|mii_autoneg_adv_reg
operator||=
operator|(
name|NWAY_AR_ASM_DIR
operator||
name|NWAY_AR_PAUSE
operator|)
expr_stmt|;
break|break;
case|case
name|E1000_FC_TX_PAUSE
case|:
comment|/* 2 */
comment|/* TX Flow control is enabled, and RX Flow control is          * disabled, by a software over-ride.          */
name|mii_autoneg_adv_reg
operator||=
name|NWAY_AR_ASM_DIR
expr_stmt|;
name|mii_autoneg_adv_reg
operator|&=
operator|~
name|NWAY_AR_PAUSE
expr_stmt|;
break|break;
case|case
name|E1000_FC_FULL
case|:
comment|/* 3 */
comment|/* Flow control (both RX and TX) is enabled by a software          * over-ride.          */
name|mii_autoneg_adv_reg
operator||=
operator|(
name|NWAY_AR_ASM_DIR
operator||
name|NWAY_AR_PAUSE
operator|)
expr_stmt|;
break|break;
default|default:
name|DEBUGOUT
argument_list|(
literal|"Flow control param set incorrectly\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_CONFIG
return|;
block|}
name|ret_val
operator|=
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_AUTONEG_ADV
argument_list|,
name|mii_autoneg_adv_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|DEBUGOUT1
argument_list|(
literal|"Auto-Neg Advertising %x\n"
argument_list|,
name|mii_autoneg_adv_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|phy_type
operator|!=
name|em_phy_ife
condition|)
block|{
name|ret_val
operator|=
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_1000T_CTRL
argument_list|,
name|mii_1000t_ctrl_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************** * Force PHY speed and duplex settings to hw->forced_speed_duplex * * hw - Struct containing variables accessed by shared code ******************************************************************************/
end_comment

begin_function
specifier|static
name|int32_t
name|em_phy_force_speed_duplex
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|uint32_t
name|ctrl
decl_stmt|;
name|int32_t
name|ret_val
decl_stmt|;
name|uint16_t
name|mii_ctrl_reg
decl_stmt|;
name|uint16_t
name|mii_status_reg
decl_stmt|;
name|uint16_t
name|phy_data
decl_stmt|;
name|uint16_t
name|i
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_phy_force_speed_duplex"
argument_list|)
expr_stmt|;
comment|/* Turn off Flow control if we are forcing speed and duplex. */
name|hw
operator|->
name|fc
operator|=
name|E1000_FC_NONE
expr_stmt|;
name|DEBUGOUT1
argument_list|(
literal|"hw->fc = %d\n"
argument_list|,
name|hw
operator|->
name|fc
argument_list|)
expr_stmt|;
comment|/* Read the Device Control Register. */
name|ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|)
expr_stmt|;
comment|/* Set the bits to Force Speed and Duplex in the Device Ctrl Reg. */
name|ctrl
operator||=
operator|(
name|E1000_CTRL_FRCSPD
operator||
name|E1000_CTRL_FRCDPX
operator|)
expr_stmt|;
name|ctrl
operator|&=
operator|~
operator|(
name|DEVICE_SPEED_MASK
operator|)
expr_stmt|;
comment|/* Clear the Auto Speed Detect Enable bit. */
name|ctrl
operator|&=
operator|~
name|E1000_CTRL_ASDE
expr_stmt|;
comment|/* Read the MII Control Register. */
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_CTRL
argument_list|,
operator|&
name|mii_ctrl_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
comment|/* We need to disable autoneg in order to force link and duplex. */
name|mii_ctrl_reg
operator|&=
operator|~
name|MII_CR_AUTO_NEG_EN
expr_stmt|;
comment|/* Are we forcing Full or Half Duplex? */
if|if
condition|(
name|hw
operator|->
name|forced_speed_duplex
operator|==
name|em_100_full
operator|||
name|hw
operator|->
name|forced_speed_duplex
operator|==
name|em_10_full
condition|)
block|{
comment|/* We want to force full duplex so we SET the full duplex bits in the          * Device and MII Control Registers.          */
name|ctrl
operator||=
name|E1000_CTRL_FD
expr_stmt|;
name|mii_ctrl_reg
operator||=
name|MII_CR_FULL_DUPLEX
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Full Duplex\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* We want to force half duplex so we CLEAR the full duplex bits in          * the Device and MII Control Registers.          */
name|ctrl
operator|&=
operator|~
name|E1000_CTRL_FD
expr_stmt|;
name|mii_ctrl_reg
operator|&=
operator|~
name|MII_CR_FULL_DUPLEX
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Half Duplex\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Are we forcing 100Mbps??? */
if|if
condition|(
name|hw
operator|->
name|forced_speed_duplex
operator|==
name|em_100_full
operator|||
name|hw
operator|->
name|forced_speed_duplex
operator|==
name|em_100_half
condition|)
block|{
comment|/* Set the 100Mb bit and turn off the 1000Mb and 10Mb bits. */
name|ctrl
operator||=
name|E1000_CTRL_SPD_100
expr_stmt|;
name|mii_ctrl_reg
operator||=
name|MII_CR_SPEED_100
expr_stmt|;
name|mii_ctrl_reg
operator|&=
operator|~
operator|(
name|MII_CR_SPEED_1000
operator||
name|MII_CR_SPEED_10
operator|)
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Forcing 100mb "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Set the 10Mb bit and turn off the 1000Mb and 100Mb bits. */
name|ctrl
operator|&=
operator|~
operator|(
name|E1000_CTRL_SPD_1000
operator||
name|E1000_CTRL_SPD_100
operator|)
expr_stmt|;
name|mii_ctrl_reg
operator||=
name|MII_CR_SPEED_10
expr_stmt|;
name|mii_ctrl_reg
operator|&=
operator|~
operator|(
name|MII_CR_SPEED_1000
operator||
name|MII_CR_SPEED_100
operator|)
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Forcing 10mb "
argument_list|)
expr_stmt|;
block|}
name|em_config_collision_dist
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Write the configured values back to the Device Control Reg. */
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|hw
operator|->
name|phy_type
operator|==
name|em_phy_m88
operator|)
operator|||
operator|(
name|hw
operator|->
name|phy_type
operator|==
name|em_phy_gg82563
operator|)
condition|)
block|{
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_SPEC_CTRL
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
comment|/* Clear Auto-Crossover to force MDI manually. M88E1000 requires MDI          * forced whenever speed are duplex are forced.          */
name|phy_data
operator|&=
operator|~
name|M88E1000_PSCR_AUTO_X_MODE
expr_stmt|;
name|ret_val
operator|=
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_SPEC_CTRL
argument_list|,
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|DEBUGOUT1
argument_list|(
literal|"M88E1000 PSCR: %x \n"
argument_list|,
name|phy_data
argument_list|)
expr_stmt|;
comment|/* Need to reset the PHY or these changes will be ignored */
name|mii_ctrl_reg
operator||=
name|MII_CR_RESET
expr_stmt|;
comment|/* Disable MDI-X support for 10/100 */
block|}
elseif|else
if|if
condition|(
name|hw
operator|->
name|phy_type
operator|==
name|em_phy_ife
condition|)
block|{
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|IFE_PHY_MDIX_CONTROL
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|phy_data
operator|&=
operator|~
name|IFE_PMC_AUTO_MDIX
expr_stmt|;
name|phy_data
operator|&=
operator|~
name|IFE_PMC_FORCE_MDIX
expr_stmt|;
name|ret_val
operator|=
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|IFE_PHY_MDIX_CONTROL
argument_list|,
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
block|}
else|else
block|{
comment|/* Clear Auto-Crossover to force MDI manually.  IGP requires MDI          * forced whenever speed or duplex are forced.          */
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_CTRL
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|phy_data
operator|&=
operator|~
name|IGP01E1000_PSCR_AUTO_MDIX
expr_stmt|;
name|phy_data
operator|&=
operator|~
name|IGP01E1000_PSCR_FORCE_MDI_MDIX
expr_stmt|;
name|ret_val
operator|=
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_CTRL
argument_list|,
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
block|}
comment|/* Write back the modified PHY MII control register. */
name|ret_val
operator|=
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_CTRL
argument_list|,
name|mii_ctrl_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|usec_delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* The wait_autoneg_complete flag may be a little misleading here.      * Since we are forcing speed and duplex, Auto-Neg is not enabled.      * But we do want to delay for a period while forcing only so we      * don't generate false No Link messages.  So we will wait here      * only if the user has set wait_autoneg_complete to 1, which is      * the default.      */
if|if
condition|(
name|hw
operator|->
name|wait_autoneg_complete
condition|)
block|{
comment|/* We will wait for autoneg to complete. */
name|DEBUGOUT
argument_list|(
literal|"Waiting for forced speed/duplex link.\n"
argument_list|)
expr_stmt|;
name|mii_status_reg
operator|=
literal|0
expr_stmt|;
comment|/* We will wait for autoneg to complete or 4.5 seconds to expire. */
for|for
control|(
name|i
operator|=
name|PHY_FORCE_TIME
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
comment|/* Read the MII Status Register and wait for Auto-Neg Complete bit              * to be set.              */
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_STATUS
argument_list|,
operator|&
name|mii_status_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_STATUS
argument_list|,
operator|&
name|mii_status_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
if|if
condition|(
name|mii_status_reg
operator|&
name|MII_SR_LINK_STATUS
condition|)
break|break;
name|msec_delay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|i
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|hw
operator|->
name|phy_type
operator|==
name|em_phy_m88
operator|)
operator|||
operator|(
name|hw
operator|->
name|phy_type
operator|==
name|em_phy_gg82563
operator|)
operator|)
condition|)
block|{
comment|/* We didn't get link.  Reset the DSP and wait again for link. */
name|ret_val
operator|=
name|em_phy_reset_dsp
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Error Resetting PHY DSP\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
block|}
comment|/* This loop will early-out if the link condition has been met.  */
for|for
control|(
name|i
operator|=
name|PHY_FORCE_TIME
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|mii_status_reg
operator|&
name|MII_SR_LINK_STATUS
condition|)
break|break;
name|msec_delay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
comment|/* Read the MII Status Register and wait for Auto-Neg Complete bit              * to be set.              */
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_STATUS
argument_list|,
operator|&
name|mii_status_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_STATUS
argument_list|,
operator|&
name|mii_status_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
block|}
block|}
if|if
condition|(
name|hw
operator|->
name|phy_type
operator|==
name|em_phy_m88
condition|)
block|{
comment|/* Because we reset the PHY above, we need to re-force TX_CLK in the          * Extended PHY Specific Control Register to 25MHz clock.  This value          * defaults back to a 2.5MHz clock when the PHY is reset.          */
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_EXT_PHY_SPEC_CTRL
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|phy_data
operator||=
name|M88E1000_EPSCR_TX_CLK_25
expr_stmt|;
name|ret_val
operator|=
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_EXT_PHY_SPEC_CTRL
argument_list|,
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
comment|/* In addition, because of the s/w reset above, we need to enable CRS on          * TX.  This must be set for both full and half duplex operation.          */
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_SPEC_CTRL
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|phy_data
operator||=
name|M88E1000_PSCR_ASSERT_CRS_ON_TX
expr_stmt|;
name|ret_val
operator|=
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_SPEC_CTRL
argument_list|,
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
if|if
condition|(
operator|(
name|hw
operator|->
name|mac_type
operator|==
name|em_82544
operator|||
name|hw
operator|->
name|mac_type
operator|==
name|em_82543
operator|)
operator|&&
operator|(
operator|!
name|hw
operator|->
name|autoneg
operator|)
operator|&&
operator|(
name|hw
operator|->
name|forced_speed_duplex
operator|==
name|em_10_full
operator|||
name|hw
operator|->
name|forced_speed_duplex
operator|==
name|em_10_half
operator|)
condition|)
block|{
name|ret_val
operator|=
name|em_polarity_reversal_workaround
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|hw
operator|->
name|phy_type
operator|==
name|em_phy_gg82563
condition|)
block|{
comment|/* The TX_CLK of the Extended PHY Specific Control Register defaults          * to 2.5MHz on a reset.  We need to re-force it back to 25MHz, if          * we're not in a forced 10/duplex configuration. */
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|GG82563_PHY_MAC_SPEC_CTRL
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|phy_data
operator|&=
operator|~
name|GG82563_MSCR_TX_CLK_MASK
expr_stmt|;
if|if
condition|(
operator|(
name|hw
operator|->
name|forced_speed_duplex
operator|==
name|em_10_full
operator|)
operator|||
operator|(
name|hw
operator|->
name|forced_speed_duplex
operator|==
name|em_10_half
operator|)
condition|)
name|phy_data
operator||=
name|GG82563_MSCR_TX_CLK_10MBPS_2_5MHZ
expr_stmt|;
else|else
name|phy_data
operator||=
name|GG82563_MSCR_TX_CLK_100MBPS_25MHZ
expr_stmt|;
comment|/* Also due to the reset, we need to enable CRS on Tx. */
name|phy_data
operator||=
name|GG82563_MSCR_ASSERT_CRS_ON_TX
expr_stmt|;
name|ret_val
operator|=
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|GG82563_PHY_MAC_SPEC_CTRL
argument_list|,
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************** * Sets the collision distance in the Transmit Control register * * hw - Struct containing variables accessed by shared code * * Link should have been established previously. Reads the speed and duplex * information from the Device Status register. ******************************************************************************/
end_comment

begin_function
name|void
name|em_config_collision_dist
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|uint32_t
name|tctl
decl_stmt|,
name|coll_dist
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_config_collision_dist"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|<
name|em_82543
condition|)
name|coll_dist
operator|=
name|E1000_COLLISION_DISTANCE_82542
expr_stmt|;
else|else
name|coll_dist
operator|=
name|E1000_COLLISION_DISTANCE
expr_stmt|;
name|tctl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|TCTL
argument_list|)
expr_stmt|;
name|tctl
operator|&=
operator|~
name|E1000_TCTL_COLD
expr_stmt|;
name|tctl
operator||=
name|coll_dist
operator|<<
name|E1000_COLD_SHIFT
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|TCTL
argument_list|,
name|tctl
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************** * Sets MAC speed and duplex settings to reflect the those in the PHY * * hw - Struct containing variables accessed by shared code * mii_reg - data to write to the MII control register * * The contents of the PHY register containing the needed information need to * be passed in. ******************************************************************************/
end_comment

begin_function
specifier|static
name|int32_t
name|em_config_mac_to_phy
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|uint32_t
name|ctrl
decl_stmt|;
name|int32_t
name|ret_val
decl_stmt|;
name|uint16_t
name|phy_data
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_config_mac_to_phy"
argument_list|)
expr_stmt|;
comment|/* 82544 or newer MAC, Auto Speed Detection takes care of     * MAC speed/duplex configuration.*/
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|>=
name|em_82544
condition|)
return|return
name|E1000_SUCCESS
return|;
comment|/* Read the Device Control Register and set the bits to Force Speed      * and Duplex.      */
name|ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|)
expr_stmt|;
name|ctrl
operator||=
operator|(
name|E1000_CTRL_FRCSPD
operator||
name|E1000_CTRL_FRCDPX
operator|)
expr_stmt|;
name|ctrl
operator|&=
operator|~
operator|(
name|E1000_CTRL_SPD_SEL
operator||
name|E1000_CTRL_ILOS
operator|)
expr_stmt|;
comment|/* Set up duplex in the Device Control and Transmit Control      * registers depending on negotiated values.      */
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_SPEC_STATUS
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
if|if
condition|(
name|phy_data
operator|&
name|M88E1000_PSSR_DPLX
condition|)
name|ctrl
operator||=
name|E1000_CTRL_FD
expr_stmt|;
else|else
name|ctrl
operator|&=
operator|~
name|E1000_CTRL_FD
expr_stmt|;
name|em_config_collision_dist
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Set up speed in the Device Control register depending on      * negotiated values.      */
if|if
condition|(
operator|(
name|phy_data
operator|&
name|M88E1000_PSSR_SPEED
operator|)
operator|==
name|M88E1000_PSSR_1000MBS
condition|)
name|ctrl
operator||=
name|E1000_CTRL_SPD_1000
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|phy_data
operator|&
name|M88E1000_PSSR_SPEED
operator|)
operator|==
name|M88E1000_PSSR_100MBS
condition|)
name|ctrl
operator||=
name|E1000_CTRL_SPD_100
expr_stmt|;
comment|/* Write the configured values back to the Device Control Reg. */
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Forces the MAC's flow control settings.  *  * hw - Struct containing variables accessed by shared code  *  * Sets the TFCE and RFCE bits in the device control register to reflect  * the adapter settings. TFCE and RFCE need to be explicitly set by  * software when a Copper PHY is used because autonegotiation is managed  * by the PHY rather than the MAC. Software must also configure these  * bits when link is forced on a fiber connection.  *****************************************************************************/
end_comment

begin_function
name|int32_t
name|em_force_mac_fc
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|uint32_t
name|ctrl
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_force_mac_fc"
argument_list|)
expr_stmt|;
comment|/* Get the current configuration of the Device Control Register */
name|ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|)
expr_stmt|;
comment|/* Because we didn't get link via the internal auto-negotiation      * mechanism (we either forced link or we got link via PHY      * auto-neg), we have to manually enable/disable transmit an      * receive flow control.      *      * The "Case" statement below enables/disable flow control      * according to the "hw->fc" parameter.      *      * The possible values of the "fc" parameter are:      *      0:  Flow control is completely disabled      *      1:  Rx flow control is enabled (we can receive pause      *          frames but not send pause frames).      *      2:  Tx flow control is enabled (we can send pause frames      *          frames but we do not receive pause frames).      *      3:  Both Rx and TX flow control (symmetric) is enabled.      *  other:  No other values should be possible at this point.      */
switch|switch
condition|(
name|hw
operator|->
name|fc
condition|)
block|{
case|case
name|E1000_FC_NONE
case|:
name|ctrl
operator|&=
operator|(
operator|~
operator|(
name|E1000_CTRL_TFCE
operator||
name|E1000_CTRL_RFCE
operator|)
operator|)
expr_stmt|;
break|break;
case|case
name|E1000_FC_RX_PAUSE
case|:
name|ctrl
operator|&=
operator|(
operator|~
name|E1000_CTRL_TFCE
operator|)
expr_stmt|;
name|ctrl
operator||=
name|E1000_CTRL_RFCE
expr_stmt|;
break|break;
case|case
name|E1000_FC_TX_PAUSE
case|:
name|ctrl
operator|&=
operator|(
operator|~
name|E1000_CTRL_RFCE
operator|)
expr_stmt|;
name|ctrl
operator||=
name|E1000_CTRL_TFCE
expr_stmt|;
break|break;
case|case
name|E1000_FC_FULL
case|:
name|ctrl
operator||=
operator|(
name|E1000_CTRL_TFCE
operator||
name|E1000_CTRL_RFCE
operator|)
expr_stmt|;
break|break;
default|default:
name|DEBUGOUT
argument_list|(
literal|"Flow control param set incorrectly\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_CONFIG
return|;
block|}
comment|/* Disable TX Flow Control for 82542 (rev 2.0) */
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|==
name|em_82542_rev2_0
condition|)
name|ctrl
operator|&=
operator|(
operator|~
name|E1000_CTRL_TFCE
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Configures flow control settings after link is established  *  * hw - Struct containing variables accessed by shared code  *  * Should be called immediately after a valid link has been established.  * Forces MAC flow control settings if link was forced. When in MII/GMII mode  * and autonegotiation is enabled, the MAC flow control settings will be set  * based on the flow control negotiated by the PHY. In TBI mode, the TFCE  * and RFCE bits will be automaticaly set to the negotiated flow control mode.  *****************************************************************************/
end_comment

begin_function
name|STATIC
name|int32_t
name|em_config_fc_after_link_up
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|int32_t
name|ret_val
decl_stmt|;
name|uint16_t
name|mii_status_reg
decl_stmt|;
name|uint16_t
name|mii_nway_adv_reg
decl_stmt|;
name|uint16_t
name|mii_nway_lp_ability_reg
decl_stmt|;
name|uint16_t
name|speed
decl_stmt|;
name|uint16_t
name|duplex
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_config_fc_after_link_up"
argument_list|)
expr_stmt|;
comment|/* Check for the case where we have fiber media and auto-neg failed      * so we had to force link.  In this case, we need to force the      * configuration of the MAC to match the "fc" parameter.      */
if|if
condition|(
operator|(
operator|(
name|hw
operator|->
name|media_type
operator|==
name|em_media_type_fiber
operator|)
operator|&&
operator|(
name|hw
operator|->
name|autoneg_failed
operator|)
operator|)
operator|||
operator|(
operator|(
name|hw
operator|->
name|media_type
operator|==
name|em_media_type_internal_serdes
operator|)
operator|&&
operator|(
name|hw
operator|->
name|autoneg_failed
operator|)
operator|)
operator|||
operator|(
operator|(
name|hw
operator|->
name|media_type
operator|==
name|em_media_type_copper
operator|)
operator|&&
operator|(
operator|!
name|hw
operator|->
name|autoneg
operator|)
operator|)
condition|)
block|{
name|ret_val
operator|=
name|em_force_mac_fc
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Error forcing flow control settings\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
block|}
comment|/* Check for the case where we have copper media and auto-neg is      * enabled.  In this case, we need to check and see if Auto-Neg      * has completed, and if so, how the PHY and link partner has      * flow control configured.      */
if|if
condition|(
operator|(
name|hw
operator|->
name|media_type
operator|==
name|em_media_type_copper
operator|)
operator|&&
name|hw
operator|->
name|autoneg
condition|)
block|{
comment|/* Read the MII Status Register and check to see if AutoNeg          * has completed.  We read this twice because this reg has          * some "sticky" (latched) bits.          */
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_STATUS
argument_list|,
operator|&
name|mii_status_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_STATUS
argument_list|,
operator|&
name|mii_status_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
if|if
condition|(
name|mii_status_reg
operator|&
name|MII_SR_AUTONEG_COMPLETE
condition|)
block|{
comment|/* The AutoNeg process has completed, so we now need to              * read both the Auto Negotiation Advertisement Register              * (Address 4) and the Auto_Negotiation Base Page Ability              * Register (Address 5) to determine how flow control was              * negotiated.              */
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_AUTONEG_ADV
argument_list|,
operator|&
name|mii_nway_adv_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_LP_ABILITY
argument_list|,
operator|&
name|mii_nway_lp_ability_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
comment|/* Two bits in the Auto Negotiation Advertisement Register              * (Address 4) and two bits in the Auto Negotiation Base              * Page Ability Register (Address 5) determine flow control              * for both the PHY and the link partner.  The following              * table, taken out of the IEEE 802.3ab/D6.0 dated March 25,              * 1999, describes these PAUSE resolution bits and how flow              * control is determined based upon these settings.              * NOTE:  DC = Don't Care              *              *   LOCAL DEVICE  |   LINK PARTNER              * PAUSE | ASM_DIR | PAUSE | ASM_DIR | NIC Resolution              *-------|---------|-------|---------|--------------------              *   0   |    0    |  DC   |   DC    | em_fc_none              *   0   |    1    |   0   |   DC    | em_fc_none              *   0   |    1    |   1   |    0    | em_fc_none              *   0   |    1    |   1   |    1    | em_fc_tx_pause              *   1   |    0    |   0   |   DC    | em_fc_none              *   1   |   DC    |   1   |   DC    | em_fc_full              *   1   |    1    |   0   |    0    | em_fc_none              *   1   |    1    |   0   |    1    | em_fc_rx_pause              *              */
comment|/* Are both PAUSE bits set to 1?  If so, this implies              * Symmetric Flow Control is enabled at both ends.  The              * ASM_DIR bits are irrelevant per the spec.              *              * For Symmetric Flow Control:              *              *   LOCAL DEVICE  |   LINK PARTNER              * PAUSE | ASM_DIR | PAUSE | ASM_DIR | Result              *-------|---------|-------|---------|--------------------              *   1   |   DC    |   1   |   DC    | em_fc_full              *              */
if|if
condition|(
operator|(
name|mii_nway_adv_reg
operator|&
name|NWAY_AR_PAUSE
operator|)
operator|&&
operator|(
name|mii_nway_lp_ability_reg
operator|&
name|NWAY_LPAR_PAUSE
operator|)
condition|)
block|{
comment|/* Now we need to check if the user selected RX ONLY                  * of pause frames.  In this case, we had to advertise                  * FULL flow control because we could not advertise RX                  * ONLY. Hence, we must now check to see if we need to                  * turn OFF  the TRANSMISSION of PAUSE frames.                  */
if|if
condition|(
name|hw
operator|->
name|original_fc
operator|==
name|E1000_FC_FULL
condition|)
block|{
name|hw
operator|->
name|fc
operator|=
name|E1000_FC_FULL
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Flow Control = FULL.\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|hw
operator|->
name|fc
operator|=
name|E1000_FC_RX_PAUSE
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Flow Control = RX PAUSE frames only.\n"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* For receiving PAUSE frames ONLY.              *              *   LOCAL DEVICE  |   LINK PARTNER              * PAUSE | ASM_DIR | PAUSE | ASM_DIR | Result              *-------|---------|-------|---------|--------------------              *   0   |    1    |   1   |    1    | em_fc_tx_pause              *              */
elseif|else
if|if
condition|(
operator|!
operator|(
name|mii_nway_adv_reg
operator|&
name|NWAY_AR_PAUSE
operator|)
operator|&&
operator|(
name|mii_nway_adv_reg
operator|&
name|NWAY_AR_ASM_DIR
operator|)
operator|&&
operator|(
name|mii_nway_lp_ability_reg
operator|&
name|NWAY_LPAR_PAUSE
operator|)
operator|&&
operator|(
name|mii_nway_lp_ability_reg
operator|&
name|NWAY_LPAR_ASM_DIR
operator|)
condition|)
block|{
name|hw
operator|->
name|fc
operator|=
name|E1000_FC_TX_PAUSE
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Flow Control = TX PAUSE frames only.\n"
argument_list|)
expr_stmt|;
block|}
comment|/* For transmitting PAUSE frames ONLY.              *              *   LOCAL DEVICE  |   LINK PARTNER              * PAUSE | ASM_DIR | PAUSE | ASM_DIR | Result              *-------|---------|-------|---------|--------------------              *   1   |    1    |   0   |    1    | em_fc_rx_pause              *              */
elseif|else
if|if
condition|(
operator|(
name|mii_nway_adv_reg
operator|&
name|NWAY_AR_PAUSE
operator|)
operator|&&
operator|(
name|mii_nway_adv_reg
operator|&
name|NWAY_AR_ASM_DIR
operator|)
operator|&&
operator|!
operator|(
name|mii_nway_lp_ability_reg
operator|&
name|NWAY_LPAR_PAUSE
operator|)
operator|&&
operator|(
name|mii_nway_lp_ability_reg
operator|&
name|NWAY_LPAR_ASM_DIR
operator|)
condition|)
block|{
name|hw
operator|->
name|fc
operator|=
name|E1000_FC_RX_PAUSE
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Flow Control = RX PAUSE frames only.\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Per the IEEE spec, at this point flow control should be              * disabled.  However, we want to consider that we could              * be connected to a legacy switch that doesn't advertise              * desired flow control, but can be forced on the link              * partner.  So if we advertised no flow control, that is              * what we will resolve to.  If we advertised some kind of              * receive capability (Rx Pause Only or Full Flow Control)              * and the link partner advertised none, we will configure              * ourselves to enable Rx Flow Control only.  We can do              * this safely for two reasons:  If the link partner really              * didn't want flow control enabled, and we enable Rx, no              * harm done since we won't be receiving any PAUSE frames              * anyway.  If the intent on the link partner was to have              * flow control enabled, then by us enabling RX only, we              * can at least receive pause frames and process them.              * This is a good idea because in most cases, since we are              * predominantly a server NIC, more times than not we will              * be asked to delay transmission of packets than asking              * our link partner to pause transmission of frames.              */
elseif|else
if|if
condition|(
operator|(
name|hw
operator|->
name|original_fc
operator|==
name|E1000_FC_NONE
operator|||
name|hw
operator|->
name|original_fc
operator|==
name|E1000_FC_TX_PAUSE
operator|)
operator|||
name|hw
operator|->
name|fc_strict_ieee
condition|)
block|{
name|hw
operator|->
name|fc
operator|=
name|E1000_FC_NONE
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Flow Control = NONE.\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|hw
operator|->
name|fc
operator|=
name|E1000_FC_RX_PAUSE
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Flow Control = RX PAUSE frames only.\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Now we need to do one last check...  If we auto-              * negotiated to HALF DUPLEX, flow control should not be              * enabled per IEEE 802.3 spec.              */
name|ret_val
operator|=
name|em_get_speed_and_duplex
argument_list|(
name|hw
argument_list|,
operator|&
name|speed
argument_list|,
operator|&
name|duplex
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Error getting link speed and duplex\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
if|if
condition|(
name|duplex
operator|==
name|HALF_DUPLEX
condition|)
name|hw
operator|->
name|fc
operator|=
name|E1000_FC_NONE
expr_stmt|;
comment|/* Now we call a subroutine to actually force the MAC              * controller to use the correct flow control settings.              */
name|ret_val
operator|=
name|em_force_mac_fc
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Error forcing flow control settings\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
block|}
else|else
block|{
name|DEBUGOUT
argument_list|(
literal|"Copper PHY and Auto Neg has not completed.\n"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Checks to see if the link status of the hardware has changed.  *  * hw - Struct containing variables accessed by shared code  *  * Called by any function that needs to check the link status of the adapter.  *****************************************************************************/
end_comment

begin_function
name|int32_t
name|em_check_for_link
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|uint32_t
name|rxcw
init|=
literal|0
decl_stmt|;
name|uint32_t
name|ctrl
decl_stmt|;
name|uint32_t
name|status
decl_stmt|;
name|uint32_t
name|rctl
decl_stmt|;
name|uint32_t
name|icr
decl_stmt|;
name|uint32_t
name|signal
init|=
literal|0
decl_stmt|;
name|int32_t
name|ret_val
decl_stmt|;
name|uint16_t
name|phy_data
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_check_for_link"
argument_list|)
expr_stmt|;
name|ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|)
expr_stmt|;
name|status
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|STATUS
argument_list|)
expr_stmt|;
comment|/* On adapters with a MAC newer than 82544, SW Defineable pin 1 will be      * set when the optics detect a signal. On older adapters, it will be      * cleared when there is a signal.  This applies to fiber media only.      */
if|if
condition|(
operator|(
name|hw
operator|->
name|media_type
operator|==
name|em_media_type_fiber
operator|)
operator|||
operator|(
name|hw
operator|->
name|media_type
operator|==
name|em_media_type_internal_serdes
operator|)
condition|)
block|{
name|rxcw
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|RXCW
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|media_type
operator|==
name|em_media_type_fiber
condition|)
block|{
name|signal
operator|=
operator|(
name|hw
operator|->
name|mac_type
operator|>
name|em_82544
operator|)
condition|?
name|E1000_CTRL_SWDPIN1
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|E1000_STATUS_LU
condition|)
name|hw
operator|->
name|get_link_status
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
comment|/* If we have a copper PHY then we only want to go out to the PHY      * registers to see if Auto-Neg has completed and/or if our link      * status has changed.  The get_link_status flag will be set if we      * receive a Link Status Change interrupt or we have Rx Sequence      * Errors.      */
if|if
condition|(
operator|(
name|hw
operator|->
name|media_type
operator|==
name|em_media_type_copper
operator|)
operator|&&
name|hw
operator|->
name|get_link_status
condition|)
block|{
comment|/* First we want to see if the MII Status Register reports          * link.  If so, then we want to get the current speed/duplex          * of the PHY.          * Read the register twice since the link bit is sticky.          */
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_STATUS
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_STATUS
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
if|if
condition|(
name|phy_data
operator|&
name|MII_SR_LINK_STATUS
condition|)
block|{
name|hw
operator|->
name|get_link_status
operator|=
name|FALSE
expr_stmt|;
comment|/* Check if there was DownShift, must be checked immediately after              * link-up */
name|em_check_downshift
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* If we are on 82544 or 82543 silicon and speed/duplex              * are forced to 10H or 10F, then we will implement the polarity              * reversal workaround.  We disable interrupts first, and upon              * returning, place the devices interrupt state to its previous              * value except for the link status change interrupt which will              * happen due to the execution of this workaround.              */
if|if
condition|(
operator|(
name|hw
operator|->
name|mac_type
operator|==
name|em_82544
operator|||
name|hw
operator|->
name|mac_type
operator|==
name|em_82543
operator|)
operator|&&
operator|(
operator|!
name|hw
operator|->
name|autoneg
operator|)
operator|&&
operator|(
name|hw
operator|->
name|forced_speed_duplex
operator|==
name|em_10_full
operator|||
name|hw
operator|->
name|forced_speed_duplex
operator|==
name|em_10_half
operator|)
condition|)
block|{
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IMC
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|em_polarity_reversal_workaround
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|icr
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|ICR
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|ICS
argument_list|,
operator|(
name|icr
operator|&
operator|~
name|E1000_ICS_LSC
operator|)
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IMS
argument_list|,
name|IMS_ENABLE_MASK
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* No link detected */
name|em_config_dsp_after_link_change
argument_list|(
name|hw
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* If we are forcing speed/duplex, then we simply return since          * we have already determined whether we have link or not.          */
if|if
condition|(
operator|!
name|hw
operator|->
name|autoneg
condition|)
return|return
operator|-
name|E1000_ERR_CONFIG
return|;
comment|/* optimize the dsp settings for the igp phy */
name|em_config_dsp_after_link_change
argument_list|(
name|hw
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* We have a M88E1000 PHY and Auto-Neg is enabled.  If we          * have Si on board that is 82544 or newer, Auto          * Speed Detection takes care of MAC speed/duplex          * configuration.  So we only need to configure Collision          * Distance in the MAC.  Otherwise, we need to force          * speed/duplex on the MAC to the current PHY speed/duplex          * settings.          */
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|>=
name|em_82544
condition|)
name|em_config_collision_dist
argument_list|(
name|hw
argument_list|)
expr_stmt|;
else|else
block|{
name|ret_val
operator|=
name|em_config_mac_to_phy
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Error configuring MAC to PHY settings\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
block|}
comment|/* Configure Flow Control now that Auto-Neg has completed. First, we          * need to restore the desired flow control settings because we may          * have had to re-autoneg with a different link partner.          */
name|ret_val
operator|=
name|em_config_fc_after_link_up
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Error configuring flow control\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
comment|/* At this point we know that we are on copper and we have          * auto-negotiated link.  These are conditions for checking the link          * partner capability register.  We use the link speed to determine if          * TBI compatibility needs to be turned on or off.  If the link is not          * at gigabit speed, then TBI compatibility is not needed.  If we are          * at gigabit speed, we turn on TBI compatibility.          */
if|if
condition|(
name|hw
operator|->
name|tbi_compatibility_en
condition|)
block|{
name|uint16_t
name|speed
decl_stmt|,
name|duplex
decl_stmt|;
name|ret_val
operator|=
name|em_get_speed_and_duplex
argument_list|(
name|hw
argument_list|,
operator|&
name|speed
argument_list|,
operator|&
name|duplex
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Error getting link speed and duplex\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
if|if
condition|(
name|speed
operator|!=
name|SPEED_1000
condition|)
block|{
comment|/* If link speed is not set to gigabit speed, we do not need                  * to enable TBI compatibility.                  */
if|if
condition|(
name|hw
operator|->
name|tbi_compatibility_on
condition|)
block|{
comment|/* If we previously were in the mode, turn it off. */
name|rctl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|RCTL
argument_list|)
expr_stmt|;
name|rctl
operator|&=
operator|~
name|E1000_RCTL_SBP
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|RCTL
argument_list|,
name|rctl
argument_list|)
expr_stmt|;
name|hw
operator|->
name|tbi_compatibility_on
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* If TBI compatibility is was previously off, turn it on. For                  * compatibility with a TBI link partner, we will store bad                  * packets. Some frames have an additional byte on the end and                  * will look like CRC errors to to the hardware.                  */
if|if
condition|(
operator|!
name|hw
operator|->
name|tbi_compatibility_on
condition|)
block|{
name|hw
operator|->
name|tbi_compatibility_on
operator|=
name|TRUE
expr_stmt|;
name|rctl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|RCTL
argument_list|)
expr_stmt|;
name|rctl
operator||=
name|E1000_RCTL_SBP
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|RCTL
argument_list|,
name|rctl
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* If we don't have link (auto-negotiation failed or link partner cannot      * auto-negotiate), the cable is plugged in (we have signal), and our      * link partner is not trying to auto-negotiate with us (we are receiving      * idles or data), we need to force link up. We also need to give      * auto-negotiation time to complete, in case the cable was just plugged      * in. The autoneg_failed flag does this.      */
elseif|else
if|if
condition|(
operator|(
operator|(
operator|(
name|hw
operator|->
name|media_type
operator|==
name|em_media_type_fiber
operator|)
operator|&&
operator|(
operator|(
name|ctrl
operator|&
name|E1000_CTRL_SWDPIN1
operator|)
operator|==
name|signal
operator|)
operator|)
operator|||
operator|(
name|hw
operator|->
name|media_type
operator|==
name|em_media_type_internal_serdes
operator|)
operator|)
operator|&&
operator|(
operator|!
operator|(
name|status
operator|&
name|E1000_STATUS_LU
operator|)
operator|)
operator|&&
operator|(
operator|!
operator|(
name|rxcw
operator|&
name|E1000_RXCW_C
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|hw
operator|->
name|autoneg_failed
operator|==
literal|0
condition|)
block|{
name|hw
operator|->
name|autoneg_failed
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
name|DEBUGOUT
argument_list|(
literal|"NOT RXing /C/, disable AutoNeg and force link.\n"
argument_list|)
expr_stmt|;
comment|/* Disable auto-negotiation in the TXCW register */
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|TXCW
argument_list|,
operator|(
name|hw
operator|->
name|txcw
operator|&
operator|~
name|E1000_TXCW_ANE
operator|)
argument_list|)
expr_stmt|;
comment|/* Force link-up and also force full-duplex. */
name|ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|)
expr_stmt|;
name|ctrl
operator||=
operator|(
name|E1000_CTRL_SLU
operator||
name|E1000_CTRL_FD
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
comment|/* Configure Flow Control after forcing link up. */
name|ret_val
operator|=
name|em_config_fc_after_link_up
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Error configuring flow control\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
block|}
comment|/* If we are forcing link and we are receiving /C/ ordered sets, re-enable      * auto-negotiation in the TXCW register and disable forced link in the      * Device Control register in an attempt to auto-negotiate with our link      * partner.      */
elseif|else
if|if
condition|(
operator|(
operator|(
name|hw
operator|->
name|media_type
operator|==
name|em_media_type_fiber
operator|)
operator|||
operator|(
name|hw
operator|->
name|media_type
operator|==
name|em_media_type_internal_serdes
operator|)
operator|)
operator|&&
operator|(
name|ctrl
operator|&
name|E1000_CTRL_SLU
operator|)
operator|&&
operator|(
name|rxcw
operator|&
name|E1000_RXCW_C
operator|)
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"RXing /C/, enable AutoNeg and stop forcing link.\n"
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|TXCW
argument_list|,
name|hw
operator|->
name|txcw
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|,
operator|(
name|ctrl
operator|&
operator|~
name|E1000_CTRL_SLU
operator|)
argument_list|)
expr_stmt|;
name|hw
operator|->
name|serdes_link_down
operator|=
name|FALSE
expr_stmt|;
block|}
comment|/* If we force link for non-auto-negotiation switch, check link status      * based on MAC synchronization for internal serdes media type.      */
elseif|else
if|if
condition|(
operator|(
name|hw
operator|->
name|media_type
operator|==
name|em_media_type_internal_serdes
operator|)
operator|&&
operator|!
operator|(
name|E1000_TXCW_ANE
operator|&
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|TXCW
argument_list|)
operator|)
condition|)
block|{
comment|/* SYNCH bit and IV bit are sticky. */
name|usec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|E1000_RXCW_SYNCH
operator|&
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|RXCW
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|rxcw
operator|&
name|E1000_RXCW_IV
operator|)
condition|)
block|{
name|hw
operator|->
name|serdes_link_down
operator|=
name|FALSE
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"SERDES: Link is up.\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|hw
operator|->
name|serdes_link_down
operator|=
name|TRUE
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"SERDES: Link is down.\n"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|hw
operator|->
name|media_type
operator|==
name|em_media_type_internal_serdes
operator|)
operator|&&
operator|(
name|E1000_TXCW_ANE
operator|&
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|TXCW
argument_list|)
operator|)
condition|)
block|{
name|hw
operator|->
name|serdes_link_down
operator|=
operator|!
operator|(
name|E1000_STATUS_LU
operator|&
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|STATUS
argument_list|)
operator|)
expr_stmt|;
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Detects the current speed and duplex settings of the hardware.  *  * hw - Struct containing variables accessed by shared code  * speed - Speed of the connection  * duplex - Duplex setting of the connection  *****************************************************************************/
end_comment

begin_function
name|int32_t
name|em_get_speed_and_duplex
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint16_t
modifier|*
name|speed
parameter_list|,
name|uint16_t
modifier|*
name|duplex
parameter_list|)
block|{
name|uint32_t
name|status
decl_stmt|;
name|int32_t
name|ret_val
decl_stmt|;
name|uint16_t
name|phy_data
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_get_speed_and_duplex"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|>=
name|em_82543
condition|)
block|{
name|status
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|E1000_STATUS_SPEED_1000
condition|)
block|{
operator|*
name|speed
operator|=
name|SPEED_1000
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"1000 Mbs, "
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|status
operator|&
name|E1000_STATUS_SPEED_100
condition|)
block|{
operator|*
name|speed
operator|=
name|SPEED_100
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"100 Mbs, "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|speed
operator|=
name|SPEED_10
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"10 Mbs, "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|&
name|E1000_STATUS_FD
condition|)
block|{
operator|*
name|duplex
operator|=
name|FULL_DUPLEX
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Full Duplex\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|duplex
operator|=
name|HALF_DUPLEX
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|" Half Duplex\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|DEBUGOUT
argument_list|(
literal|"1000 Mbs, Full Duplex\n"
argument_list|)
expr_stmt|;
operator|*
name|speed
operator|=
name|SPEED_1000
expr_stmt|;
operator|*
name|duplex
operator|=
name|FULL_DUPLEX
expr_stmt|;
block|}
comment|/* IGP01 PHY may advertise full duplex operation after speed downgrade even      * if it is operating at half duplex.  Here we set the duplex settings to      * match the duplex in the link partner's capabilities.      */
if|if
condition|(
name|hw
operator|->
name|phy_type
operator|==
name|em_phy_igp
operator|&&
name|hw
operator|->
name|speed_downgraded
condition|)
block|{
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_AUTONEG_EXP
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
if|if
condition|(
operator|!
operator|(
name|phy_data
operator|&
name|NWAY_ER_LP_NWAY_CAPS
operator|)
condition|)
operator|*
name|duplex
operator|=
name|HALF_DUPLEX
expr_stmt|;
else|else
block|{
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_LP_ABILITY
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
if|if
condition|(
operator|(
operator|*
name|speed
operator|==
name|SPEED_100
operator|&&
operator|!
operator|(
name|phy_data
operator|&
name|NWAY_LPAR_100TX_FD_CAPS
operator|)
operator|)
operator|||
operator|(
operator|*
name|speed
operator|==
name|SPEED_10
operator|&&
operator|!
operator|(
name|phy_data
operator|&
name|NWAY_LPAR_10T_FD_CAPS
operator|)
operator|)
condition|)
operator|*
name|duplex
operator|=
name|HALF_DUPLEX
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|hw
operator|->
name|mac_type
operator|==
name|em_80003es2lan
operator|)
operator|&&
operator|(
name|hw
operator|->
name|media_type
operator|==
name|em_media_type_copper
operator|)
condition|)
block|{
if|if
condition|(
operator|*
name|speed
operator|==
name|SPEED_1000
condition|)
name|ret_val
operator|=
name|em_configure_kmrn_for_1000
argument_list|(
name|hw
argument_list|)
expr_stmt|;
else|else
name|ret_val
operator|=
name|em_configure_kmrn_for_10_100
argument_list|(
name|hw
argument_list|,
operator|*
name|duplex
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
block|}
if|if
condition|(
operator|(
name|hw
operator|->
name|phy_type
operator|==
name|em_phy_igp_3
operator|)
operator|&&
operator|(
operator|*
name|speed
operator|==
name|SPEED_1000
operator|)
condition|)
block|{
name|ret_val
operator|=
name|em_kumeran_lock_loss_workaround
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************** * Blocks until autoneg completes or times out (~4.5 seconds) * * hw - Struct containing variables accessed by shared code ******************************************************************************/
end_comment

begin_function
name|STATIC
name|int32_t
name|em_wait_autoneg
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|int32_t
name|ret_val
decl_stmt|;
name|uint16_t
name|i
decl_stmt|;
name|uint16_t
name|phy_data
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_wait_autoneg"
argument_list|)
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Waiting for Auto-Neg to complete.\n"
argument_list|)
expr_stmt|;
comment|/* We will wait for autoneg to complete or 4.5 seconds to expire. */
for|for
control|(
name|i
operator|=
name|PHY_AUTO_NEG_TIME
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
comment|/* Read the MII Status Register and wait for Auto-Neg          * Complete bit to be set.          */
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_STATUS
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_STATUS
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
if|if
condition|(
name|phy_data
operator|&
name|MII_SR_AUTONEG_COMPLETE
condition|)
block|{
return|return
name|E1000_SUCCESS
return|;
block|}
name|msec_delay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************** * Raises the Management Data Clock * * hw - Struct containing variables accessed by shared code * ctrl - Device control register's current value ******************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|em_raise_mdi_clk
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint32_t
modifier|*
name|ctrl
parameter_list|)
block|{
comment|/* Raise the clock input to the Management Data Clock (by setting the MDC      * bit), and then delay 10 microseconds.      */
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|,
operator|(
operator|*
name|ctrl
operator||
name|E1000_CTRL_MDC
operator|)
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************** * Lowers the Management Data Clock * * hw - Struct containing variables accessed by shared code * ctrl - Device control register's current value ******************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|em_lower_mdi_clk
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint32_t
modifier|*
name|ctrl
parameter_list|)
block|{
comment|/* Lower the clock input to the Management Data Clock (by clearing the MDC      * bit), and then delay 10 microseconds.      */
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|,
operator|(
operator|*
name|ctrl
operator|&
operator|~
name|E1000_CTRL_MDC
operator|)
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************** * Shifts data bits out to the PHY * * hw - Struct containing variables accessed by shared code * data - Data to send out to the PHY * count - Number of bits to shift out * * Bits are shifted out in MSB to LSB order. ******************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|em_shift_out_mdi_bits
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint32_t
name|data
parameter_list|,
name|uint16_t
name|count
parameter_list|)
block|{
name|uint32_t
name|ctrl
decl_stmt|;
name|uint32_t
name|mask
decl_stmt|;
comment|/* We need to shift "count" number of bits out to the PHY. So, the value      * in the "data" parameter will be shifted out to the PHY one bit at a      * time. In order to do this, "data" must be broken down into bits.      */
name|mask
operator|=
literal|0x01
expr_stmt|;
name|mask
operator|<<=
operator|(
name|count
operator|-
literal|1
operator|)
expr_stmt|;
name|ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|)
expr_stmt|;
comment|/* Set MDIO_DIR and MDC_DIR direction bits to be used as output pins. */
name|ctrl
operator||=
operator|(
name|E1000_CTRL_MDIO_DIR
operator||
name|E1000_CTRL_MDC_DIR
operator|)
expr_stmt|;
while|while
condition|(
name|mask
condition|)
block|{
comment|/* A "1" is shifted out to the PHY by setting the MDIO bit to "1" and          * then raising and lowering the Management Data Clock. A "0" is          * shifted out to the PHY by setting the MDIO bit to "0" and then          * raising and lowering the clock.          */
if|if
condition|(
name|data
operator|&
name|mask
condition|)
name|ctrl
operator||=
name|E1000_CTRL_MDIO
expr_stmt|;
else|else
name|ctrl
operator|&=
operator|~
name|E1000_CTRL_MDIO
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|em_raise_mdi_clk
argument_list|(
name|hw
argument_list|,
operator|&
name|ctrl
argument_list|)
expr_stmt|;
name|em_lower_mdi_clk
argument_list|(
name|hw
argument_list|,
operator|&
name|ctrl
argument_list|)
expr_stmt|;
name|mask
operator|=
name|mask
operator|>>
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/****************************************************************************** * Shifts data bits in from the PHY * * hw - Struct containing variables accessed by shared code * * Bits are shifted in in MSB to LSB order. ******************************************************************************/
end_comment

begin_function
specifier|static
name|uint16_t
name|em_shift_in_mdi_bits
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|uint32_t
name|ctrl
decl_stmt|;
name|uint16_t
name|data
init|=
literal|0
decl_stmt|;
name|uint8_t
name|i
decl_stmt|;
comment|/* In order to read a register from the PHY, we need to shift in a total      * of 18 bits from the PHY. The first two bit (turnaround) times are used      * to avoid contention on the MDIO pin when a read operation is performed.      * These two bits are ignored by us and thrown away. Bits are "shifted in"      * by raising the input to the Management Data Clock (setting the MDC bit),      * and then reading the value of the MDIO bit.      */
name|ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|)
expr_stmt|;
comment|/* Clear MDIO_DIR (SWDPIO1) to indicate this bit is to be used as input. */
name|ctrl
operator|&=
operator|~
name|E1000_CTRL_MDIO_DIR
expr_stmt|;
name|ctrl
operator|&=
operator|~
name|E1000_CTRL_MDIO
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Raise and Lower the clock before reading in the data. This accounts for      * the turnaround bits. The first clock occurred when we clocked out the      * last bit of the Register Address.      */
name|em_raise_mdi_clk
argument_list|(
name|hw
argument_list|,
operator|&
name|ctrl
argument_list|)
expr_stmt|;
name|em_lower_mdi_clk
argument_list|(
name|hw
argument_list|,
operator|&
name|ctrl
argument_list|)
expr_stmt|;
for|for
control|(
name|data
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|data
operator|=
name|data
operator|<<
literal|1
expr_stmt|;
name|em_raise_mdi_clk
argument_list|(
name|hw
argument_list|,
operator|&
name|ctrl
argument_list|)
expr_stmt|;
name|ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|)
expr_stmt|;
comment|/* Check to see if we shifted in a "1". */
if|if
condition|(
name|ctrl
operator|&
name|E1000_CTRL_MDIO
condition|)
name|data
operator||=
literal|1
expr_stmt|;
name|em_lower_mdi_clk
argument_list|(
name|hw
argument_list|,
operator|&
name|ctrl
argument_list|)
expr_stmt|;
block|}
name|em_raise_mdi_clk
argument_list|(
name|hw
argument_list|,
operator|&
name|ctrl
argument_list|)
expr_stmt|;
name|em_lower_mdi_clk
argument_list|(
name|hw
argument_list|,
operator|&
name|ctrl
argument_list|)
expr_stmt|;
return|return
name|data
return|;
block|}
end_function

begin_function
name|STATIC
name|int32_t
name|em_swfw_sync_acquire
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint16_t
name|mask
parameter_list|)
block|{
name|uint32_t
name|swfw_sync
init|=
literal|0
decl_stmt|;
name|uint32_t
name|swmask
init|=
name|mask
decl_stmt|;
name|uint32_t
name|fwmask
init|=
name|mask
operator|<<
literal|16
decl_stmt|;
name|int32_t
name|timeout
init|=
literal|200
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_swfw_sync_acquire"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|swfwhw_semaphore_present
condition|)
return|return
name|em_get_software_flag
argument_list|(
name|hw
argument_list|)
return|;
if|if
condition|(
operator|!
name|hw
operator|->
name|swfw_sync_present
condition|)
return|return
name|em_get_hw_eeprom_semaphore
argument_list|(
name|hw
argument_list|)
return|;
while|while
condition|(
name|timeout
condition|)
block|{
if|if
condition|(
name|em_get_hw_eeprom_semaphore
argument_list|(
name|hw
argument_list|)
condition|)
return|return
operator|-
name|E1000_ERR_SWFW_SYNC
return|;
name|swfw_sync
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|SW_FW_SYNC
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|swfw_sync
operator|&
operator|(
name|fwmask
operator||
name|swmask
operator|)
operator|)
condition|)
block|{
break|break;
block|}
comment|/* firmware currently using resource (fwmask) */
comment|/* or other software thread currently using resource (swmask) */
name|em_put_hw_eeprom_semaphore
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|msec_delay_irq
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|timeout
operator|--
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|timeout
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Driver can't access resource, SW_FW_SYNC timeout.\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_SWFW_SYNC
return|;
block|}
name|swfw_sync
operator||=
name|swmask
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|SW_FW_SYNC
argument_list|,
name|swfw_sync
argument_list|)
expr_stmt|;
name|em_put_hw_eeprom_semaphore
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_function
name|STATIC
name|void
name|em_swfw_sync_release
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint16_t
name|mask
parameter_list|)
block|{
name|uint32_t
name|swfw_sync
decl_stmt|;
name|uint32_t
name|swmask
init|=
name|mask
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_swfw_sync_release"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|swfwhw_semaphore_present
condition|)
block|{
name|em_release_software_flag
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|hw
operator|->
name|swfw_sync_present
condition|)
block|{
name|em_put_hw_eeprom_semaphore
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* if (em_get_hw_eeprom_semaphore(hw))      *    return -E1000_ERR_SWFW_SYNC; */
while|while
condition|(
name|em_get_hw_eeprom_semaphore
argument_list|(
name|hw
argument_list|)
operator|!=
name|E1000_SUCCESS
condition|)
empty_stmt|;
comment|/* empty */
name|swfw_sync
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|SW_FW_SYNC
argument_list|)
expr_stmt|;
name|swfw_sync
operator|&=
operator|~
name|swmask
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|SW_FW_SYNC
argument_list|,
name|swfw_sync
argument_list|)
expr_stmt|;
name|em_put_hw_eeprom_semaphore
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/***************************************************************************** * Reads the value from a PHY register, if the value is on a specific non zero * page, sets the page first. * hw - Struct containing variables accessed by shared code * reg_addr - address of the PHY register to read ******************************************************************************/
end_comment

begin_function
name|int32_t
name|em_read_phy_reg
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint32_t
name|reg_addr
parameter_list|,
name|uint16_t
modifier|*
name|phy_data
parameter_list|)
block|{
name|uint32_t
name|ret_val
decl_stmt|;
name|uint16_t
name|swfw
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_read_phy_reg"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|hw
operator|->
name|mac_type
operator|==
name|em_80003es2lan
operator|)
operator|&&
operator|(
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|STATUS
argument_list|)
operator|&
name|E1000_STATUS_FUNC_1
operator|)
condition|)
block|{
name|swfw
operator|=
name|E1000_SWFW_PHY1_SM
expr_stmt|;
block|}
else|else
block|{
name|swfw
operator|=
name|E1000_SWFW_PHY0_SM
expr_stmt|;
block|}
if|if
condition|(
name|em_swfw_sync_acquire
argument_list|(
name|hw
argument_list|,
name|swfw
argument_list|)
condition|)
return|return
operator|-
name|E1000_ERR_SWFW_SYNC
return|;
if|if
condition|(
operator|(
name|hw
operator|->
name|phy_type
operator|==
name|em_phy_igp
operator|||
name|hw
operator|->
name|phy_type
operator|==
name|em_phy_igp_3
operator|||
name|hw
operator|->
name|phy_type
operator|==
name|em_phy_igp_2
operator|)
operator|&&
operator|(
name|reg_addr
operator|>
name|MAX_PHY_MULTI_PAGE_REG
operator|)
condition|)
block|{
name|ret_val
operator|=
name|em_write_phy_reg_ex
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PAGE_SELECT
argument_list|,
operator|(
name|uint16_t
operator|)
name|reg_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|em_swfw_sync_release
argument_list|(
name|hw
argument_list|,
name|swfw
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|hw
operator|->
name|phy_type
operator|==
name|em_phy_gg82563
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|reg_addr
operator|&
name|MAX_PHY_REG_ADDRESS
operator|)
operator|>
name|MAX_PHY_MULTI_PAGE_REG
operator|)
operator|||
operator|(
name|hw
operator|->
name|mac_type
operator|==
name|em_80003es2lan
operator|)
condition|)
block|{
comment|/* Select Configuration Page */
if|if
condition|(
operator|(
name|reg_addr
operator|&
name|MAX_PHY_REG_ADDRESS
operator|)
operator|<
name|GG82563_MIN_ALT_REG
condition|)
block|{
name|ret_val
operator|=
name|em_write_phy_reg_ex
argument_list|(
name|hw
argument_list|,
name|GG82563_PHY_PAGE_SELECT
argument_list|,
call|(
name|uint16_t
call|)
argument_list|(
operator|(
name|uint16_t
operator|)
name|reg_addr
operator|>>
name|GG82563_PAGE_SHIFT
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Use Alternative Page Select register to access                  * registers 30 and 31                  */
name|ret_val
operator|=
name|em_write_phy_reg_ex
argument_list|(
name|hw
argument_list|,
name|GG82563_PHY_PAGE_SELECT_ALT
argument_list|,
call|(
name|uint16_t
call|)
argument_list|(
operator|(
name|uint16_t
operator|)
name|reg_addr
operator|>>
name|GG82563_PAGE_SHIFT
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ret_val
condition|)
block|{
name|em_swfw_sync_release
argument_list|(
name|hw
argument_list|,
name|swfw
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
block|}
block|}
name|ret_val
operator|=
name|em_read_phy_reg_ex
argument_list|(
name|hw
argument_list|,
name|MAX_PHY_REG_ADDRESS
operator|&
name|reg_addr
argument_list|,
name|phy_data
argument_list|)
expr_stmt|;
name|em_swfw_sync_release
argument_list|(
name|hw
argument_list|,
name|swfw
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_function
name|STATIC
name|int32_t
name|em_read_phy_reg_ex
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint32_t
name|reg_addr
parameter_list|,
name|uint16_t
modifier|*
name|phy_data
parameter_list|)
block|{
name|uint32_t
name|i
decl_stmt|;
name|uint32_t
name|mdic
init|=
literal|0
decl_stmt|;
specifier|const
name|uint32_t
name|phy_addr
init|=
literal|1
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_read_phy_reg_ex"
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_addr
operator|>
name|MAX_PHY_REG_ADDRESS
condition|)
block|{
name|DEBUGOUT1
argument_list|(
literal|"PHY Address %d is out of range\n"
argument_list|,
name|reg_addr
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_PARAM
return|;
block|}
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|>
name|em_82543
condition|)
block|{
comment|/* Set up Op-code, Phy Address, and register address in the MDI          * Control register.  The MAC will take care of interfacing with the          * PHY to retrieve the desired data.          */
name|mdic
operator|=
operator|(
operator|(
name|reg_addr
operator|<<
name|E1000_MDIC_REG_SHIFT
operator|)
operator||
operator|(
name|phy_addr
operator|<<
name|E1000_MDIC_PHY_SHIFT
operator|)
operator||
operator|(
name|E1000_MDIC_OP_READ
operator|)
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|MDIC
argument_list|,
name|mdic
argument_list|)
expr_stmt|;
comment|/* Poll the ready bit to see if the MDI read completed */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|64
condition|;
name|i
operator|++
control|)
block|{
name|usec_delay
argument_list|(
literal|50
argument_list|)
expr_stmt|;
name|mdic
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|MDIC
argument_list|)
expr_stmt|;
if|if
condition|(
name|mdic
operator|&
name|E1000_MDIC_READY
condition|)
break|break;
block|}
if|if
condition|(
operator|!
operator|(
name|mdic
operator|&
name|E1000_MDIC_READY
operator|)
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"MDI Read did not complete\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_PHY
return|;
block|}
if|if
condition|(
name|mdic
operator|&
name|E1000_MDIC_ERROR
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"MDI Error\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_PHY
return|;
block|}
operator|*
name|phy_data
operator|=
operator|(
name|uint16_t
operator|)
name|mdic
expr_stmt|;
block|}
else|else
block|{
comment|/* We must first send a preamble through the MDIO pin to signal the          * beginning of an MII instruction.  This is done by sending 32          * consecutive "1" bits.          */
name|em_shift_out_mdi_bits
argument_list|(
name|hw
argument_list|,
name|PHY_PREAMBLE
argument_list|,
name|PHY_PREAMBLE_SIZE
argument_list|)
expr_stmt|;
comment|/* Now combine the next few fields that are required for a read          * operation.  We use this method instead of calling the          * em_shift_out_mdi_bits routine five different times. The format of          * a MII read instruction consists of a shift out of 14 bits and is          * defined as follows:          *<Preamble><SOF><Op Code><Phy Addr><Reg Addr>          * followed by a shift in of 18 bits.  This first two bits shifted in          * are TurnAround bits used to avoid contention on the MDIO pin when a          * READ operation is performed.  These two bits are thrown away          * followed by a shift in of 16 bits which contains the desired data.          */
name|mdic
operator|=
operator|(
operator|(
name|reg_addr
operator|)
operator||
operator|(
name|phy_addr
operator|<<
literal|5
operator|)
operator||
operator|(
name|PHY_OP_READ
operator|<<
literal|10
operator|)
operator||
operator|(
name|PHY_SOF
operator|<<
literal|12
operator|)
operator|)
expr_stmt|;
name|em_shift_out_mdi_bits
argument_list|(
name|hw
argument_list|,
name|mdic
argument_list|,
literal|14
argument_list|)
expr_stmt|;
comment|/* Now that we've shifted out the read command to the MII, we need to          * "shift in" the 16-bit value (18 total bits) of the requested PHY          * register address.          */
operator|*
name|phy_data
operator|=
name|em_shift_in_mdi_bits
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************** * Writes a value to a PHY register * * hw - Struct containing variables accessed by shared code * reg_addr - address of the PHY register to write * data - data to write to the PHY ******************************************************************************/
end_comment

begin_function
name|int32_t
name|em_write_phy_reg
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint32_t
name|reg_addr
parameter_list|,
name|uint16_t
name|phy_data
parameter_list|)
block|{
name|uint32_t
name|ret_val
decl_stmt|;
name|uint16_t
name|swfw
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_write_phy_reg"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|hw
operator|->
name|mac_type
operator|==
name|em_80003es2lan
operator|)
operator|&&
operator|(
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|STATUS
argument_list|)
operator|&
name|E1000_STATUS_FUNC_1
operator|)
condition|)
block|{
name|swfw
operator|=
name|E1000_SWFW_PHY1_SM
expr_stmt|;
block|}
else|else
block|{
name|swfw
operator|=
name|E1000_SWFW_PHY0_SM
expr_stmt|;
block|}
if|if
condition|(
name|em_swfw_sync_acquire
argument_list|(
name|hw
argument_list|,
name|swfw
argument_list|)
condition|)
return|return
operator|-
name|E1000_ERR_SWFW_SYNC
return|;
if|if
condition|(
operator|(
name|hw
operator|->
name|phy_type
operator|==
name|em_phy_igp
operator|||
name|hw
operator|->
name|phy_type
operator|==
name|em_phy_igp_3
operator|||
name|hw
operator|->
name|phy_type
operator|==
name|em_phy_igp_2
operator|)
operator|&&
operator|(
name|reg_addr
operator|>
name|MAX_PHY_MULTI_PAGE_REG
operator|)
condition|)
block|{
name|ret_val
operator|=
name|em_write_phy_reg_ex
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PAGE_SELECT
argument_list|,
operator|(
name|uint16_t
operator|)
name|reg_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|em_swfw_sync_release
argument_list|(
name|hw
argument_list|,
name|swfw
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|hw
operator|->
name|phy_type
operator|==
name|em_phy_gg82563
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|reg_addr
operator|&
name|MAX_PHY_REG_ADDRESS
operator|)
operator|>
name|MAX_PHY_MULTI_PAGE_REG
operator|)
operator|||
operator|(
name|hw
operator|->
name|mac_type
operator|==
name|em_80003es2lan
operator|)
condition|)
block|{
comment|/* Select Configuration Page */
if|if
condition|(
operator|(
name|reg_addr
operator|&
name|MAX_PHY_REG_ADDRESS
operator|)
operator|<
name|GG82563_MIN_ALT_REG
condition|)
block|{
name|ret_val
operator|=
name|em_write_phy_reg_ex
argument_list|(
name|hw
argument_list|,
name|GG82563_PHY_PAGE_SELECT
argument_list|,
call|(
name|uint16_t
call|)
argument_list|(
operator|(
name|uint16_t
operator|)
name|reg_addr
operator|>>
name|GG82563_PAGE_SHIFT
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Use Alternative Page Select register to access                  * registers 30 and 31                  */
name|ret_val
operator|=
name|em_write_phy_reg_ex
argument_list|(
name|hw
argument_list|,
name|GG82563_PHY_PAGE_SELECT_ALT
argument_list|,
call|(
name|uint16_t
call|)
argument_list|(
operator|(
name|uint16_t
operator|)
name|reg_addr
operator|>>
name|GG82563_PAGE_SHIFT
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ret_val
condition|)
block|{
name|em_swfw_sync_release
argument_list|(
name|hw
argument_list|,
name|swfw
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
block|}
block|}
name|ret_val
operator|=
name|em_write_phy_reg_ex
argument_list|(
name|hw
argument_list|,
name|MAX_PHY_REG_ADDRESS
operator|&
name|reg_addr
argument_list|,
name|phy_data
argument_list|)
expr_stmt|;
name|em_swfw_sync_release
argument_list|(
name|hw
argument_list|,
name|swfw
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_function
name|STATIC
name|int32_t
name|em_write_phy_reg_ex
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint32_t
name|reg_addr
parameter_list|,
name|uint16_t
name|phy_data
parameter_list|)
block|{
name|uint32_t
name|i
decl_stmt|;
name|uint32_t
name|mdic
init|=
literal|0
decl_stmt|;
specifier|const
name|uint32_t
name|phy_addr
init|=
literal|1
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_write_phy_reg_ex"
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_addr
operator|>
name|MAX_PHY_REG_ADDRESS
condition|)
block|{
name|DEBUGOUT1
argument_list|(
literal|"PHY Address %d is out of range\n"
argument_list|,
name|reg_addr
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_PARAM
return|;
block|}
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|>
name|em_82543
condition|)
block|{
comment|/* Set up Op-code, Phy Address, register address, and data intended          * for the PHY register in the MDI Control register.  The MAC will take          * care of interfacing with the PHY to send the desired data.          */
name|mdic
operator|=
operator|(
operator|(
operator|(
name|uint32_t
operator|)
name|phy_data
operator|)
operator||
operator|(
name|reg_addr
operator|<<
name|E1000_MDIC_REG_SHIFT
operator|)
operator||
operator|(
name|phy_addr
operator|<<
name|E1000_MDIC_PHY_SHIFT
operator|)
operator||
operator|(
name|E1000_MDIC_OP_WRITE
operator|)
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|MDIC
argument_list|,
name|mdic
argument_list|)
expr_stmt|;
comment|/* Poll the ready bit to see if the MDI read completed */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|641
condition|;
name|i
operator|++
control|)
block|{
name|usec_delay
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|mdic
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|MDIC
argument_list|)
expr_stmt|;
if|if
condition|(
name|mdic
operator|&
name|E1000_MDIC_READY
condition|)
break|break;
block|}
if|if
condition|(
operator|!
operator|(
name|mdic
operator|&
name|E1000_MDIC_READY
operator|)
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"MDI Write did not complete\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_PHY
return|;
block|}
block|}
else|else
block|{
comment|/* We'll need to use the SW defined pins to shift the write command          * out to the PHY. We first send a preamble to the PHY to signal the          * beginning of the MII instruction.  This is done by sending 32          * consecutive "1" bits.          */
name|em_shift_out_mdi_bits
argument_list|(
name|hw
argument_list|,
name|PHY_PREAMBLE
argument_list|,
name|PHY_PREAMBLE_SIZE
argument_list|)
expr_stmt|;
comment|/* Now combine the remaining required fields that will indicate a          * write operation. We use this method instead of calling the          * em_shift_out_mdi_bits routine for each field in the command. The          * format of a MII write instruction is as follows:          *<Preamble><SOF><Op Code><Phy Addr><Reg Addr><Turnaround><Data>.          */
name|mdic
operator|=
operator|(
operator|(
name|PHY_TURNAROUND
operator|)
operator||
operator|(
name|reg_addr
operator|<<
literal|2
operator|)
operator||
operator|(
name|phy_addr
operator|<<
literal|7
operator|)
operator||
operator|(
name|PHY_OP_WRITE
operator|<<
literal|12
operator|)
operator||
operator|(
name|PHY_SOF
operator|<<
literal|14
operator|)
operator|)
expr_stmt|;
name|mdic
operator|<<=
literal|16
expr_stmt|;
name|mdic
operator||=
operator|(
name|uint32_t
operator|)
name|phy_data
expr_stmt|;
name|em_shift_out_mdi_bits
argument_list|(
name|hw
argument_list|,
name|mdic
argument_list|,
literal|32
argument_list|)
expr_stmt|;
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_function
name|STATIC
name|int32_t
name|em_read_kmrn_reg
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint32_t
name|reg_addr
parameter_list|,
name|uint16_t
modifier|*
name|data
parameter_list|)
block|{
name|uint32_t
name|reg_val
decl_stmt|;
name|uint16_t
name|swfw
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_read_kmrn_reg"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|hw
operator|->
name|mac_type
operator|==
name|em_80003es2lan
operator|)
operator|&&
operator|(
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|STATUS
argument_list|)
operator|&
name|E1000_STATUS_FUNC_1
operator|)
condition|)
block|{
name|swfw
operator|=
name|E1000_SWFW_PHY1_SM
expr_stmt|;
block|}
else|else
block|{
name|swfw
operator|=
name|E1000_SWFW_PHY0_SM
expr_stmt|;
block|}
if|if
condition|(
name|em_swfw_sync_acquire
argument_list|(
name|hw
argument_list|,
name|swfw
argument_list|)
condition|)
return|return
operator|-
name|E1000_ERR_SWFW_SYNC
return|;
comment|/* Write register address */
name|reg_val
operator|=
operator|(
operator|(
name|reg_addr
operator|<<
name|E1000_KUMCTRLSTA_OFFSET_SHIFT
operator|)
operator|&
name|E1000_KUMCTRLSTA_OFFSET
operator|)
operator||
name|E1000_KUMCTRLSTA_REN
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|KUMCTRLSTA
argument_list|,
name|reg_val
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|/* Read the data returned */
name|reg_val
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|KUMCTRLSTA
argument_list|)
expr_stmt|;
operator|*
name|data
operator|=
operator|(
name|uint16_t
operator|)
name|reg_val
expr_stmt|;
name|em_swfw_sync_release
argument_list|(
name|hw
argument_list|,
name|swfw
argument_list|)
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_function
name|STATIC
name|int32_t
name|em_write_kmrn_reg
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint32_t
name|reg_addr
parameter_list|,
name|uint16_t
name|data
parameter_list|)
block|{
name|uint32_t
name|reg_val
decl_stmt|;
name|uint16_t
name|swfw
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_write_kmrn_reg"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|hw
operator|->
name|mac_type
operator|==
name|em_80003es2lan
operator|)
operator|&&
operator|(
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|STATUS
argument_list|)
operator|&
name|E1000_STATUS_FUNC_1
operator|)
condition|)
block|{
name|swfw
operator|=
name|E1000_SWFW_PHY1_SM
expr_stmt|;
block|}
else|else
block|{
name|swfw
operator|=
name|E1000_SWFW_PHY0_SM
expr_stmt|;
block|}
if|if
condition|(
name|em_swfw_sync_acquire
argument_list|(
name|hw
argument_list|,
name|swfw
argument_list|)
condition|)
return|return
operator|-
name|E1000_ERR_SWFW_SYNC
return|;
name|reg_val
operator|=
operator|(
operator|(
name|reg_addr
operator|<<
name|E1000_KUMCTRLSTA_OFFSET_SHIFT
operator|)
operator|&
name|E1000_KUMCTRLSTA_OFFSET
operator|)
operator||
name|data
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|KUMCTRLSTA
argument_list|,
name|reg_val
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|em_swfw_sync_release
argument_list|(
name|hw
argument_list|,
name|swfw
argument_list|)
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************** * Returns the PHY to the power-on reset state * * hw - Struct containing variables accessed by shared code ******************************************************************************/
end_comment

begin_function
name|int32_t
name|em_phy_hw_reset
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|uint32_t
name|ctrl
decl_stmt|,
name|ctrl_ext
decl_stmt|;
name|uint32_t
name|led_ctrl
decl_stmt|;
name|int32_t
name|ret_val
decl_stmt|;
name|uint16_t
name|swfw
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_phy_hw_reset"
argument_list|)
expr_stmt|;
comment|/* In the case of the phy reset being blocked, it's not an error, we      * simply return success without performing the reset. */
name|ret_val
operator|=
name|em_check_phy_reset_block
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|E1000_SUCCESS
return|;
name|DEBUGOUT
argument_list|(
literal|"Resetting Phy...\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|>
name|em_82543
condition|)
block|{
if|if
condition|(
operator|(
name|hw
operator|->
name|mac_type
operator|==
name|em_80003es2lan
operator|)
operator|&&
operator|(
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|STATUS
argument_list|)
operator|&
name|E1000_STATUS_FUNC_1
operator|)
condition|)
block|{
name|swfw
operator|=
name|E1000_SWFW_PHY1_SM
expr_stmt|;
block|}
else|else
block|{
name|swfw
operator|=
name|E1000_SWFW_PHY0_SM
expr_stmt|;
block|}
if|if
condition|(
name|em_swfw_sync_acquire
argument_list|(
name|hw
argument_list|,
name|swfw
argument_list|)
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Unable to acquire swfw sync\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_SWFW_SYNC
return|;
block|}
comment|/* Read the device control register and assert the E1000_CTRL_PHY_RST          * bit. Then, take it out of reset.          * For pre-em_82571 hardware, we delay for 10ms between the assert          * and deassert.  For em_82571 hardware and later, we instead delay          * for 50us between and 10ms after the deassertion.          */
name|ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|,
name|ctrl
operator||
name|E1000_CTRL_PHY_RST
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|<
name|em_82571
condition|)
name|msec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
else|else
name|usec_delay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|>=
name|em_82571
condition|)
name|msec_delay_irq
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|em_swfw_sync_release
argument_list|(
name|hw
argument_list|,
name|swfw
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Read the Extended Device Control Register, assert the PHY_RESET_DIR          * bit to put the PHY into reset. Then, take it out of reset.          */
name|ctrl_ext
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|CTRL_EXT
argument_list|)
expr_stmt|;
name|ctrl_ext
operator||=
name|E1000_CTRL_EXT_SDP4_DIR
expr_stmt|;
name|ctrl_ext
operator|&=
operator|~
name|E1000_CTRL_EXT_SDP4_DATA
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|CTRL_EXT
argument_list|,
name|ctrl_ext
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|msec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|ctrl_ext
operator||=
name|E1000_CTRL_EXT_SDP4_DATA
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|CTRL_EXT
argument_list|,
name|ctrl_ext
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
name|usec_delay
argument_list|(
literal|150
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|hw
operator|->
name|mac_type
operator|==
name|em_82541
operator|)
operator|||
operator|(
name|hw
operator|->
name|mac_type
operator|==
name|em_82547
operator|)
condition|)
block|{
comment|/* Configure activity LED after PHY reset */
name|led_ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|LEDCTL
argument_list|)
expr_stmt|;
name|led_ctrl
operator|&=
name|IGP_ACTIVITY_LED_MASK
expr_stmt|;
name|led_ctrl
operator||=
operator|(
name|IGP_ACTIVITY_LED_ENABLE
operator||
name|IGP_LED3_MODE
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|LEDCTL
argument_list|,
name|led_ctrl
argument_list|)
expr_stmt|;
block|}
comment|/* Wait for FW to finish PHY configuration. */
name|ret_val
operator|=
name|em_get_phy_cfg_done
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
operator|!=
name|E1000_SUCCESS
condition|)
return|return
name|ret_val
return|;
name|em_release_software_semaphore
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|hw
operator|->
name|mac_type
operator|==
name|em_ich8lan
operator|)
operator|&&
operator|(
name|hw
operator|->
name|phy_type
operator|==
name|em_phy_igp_3
operator|)
condition|)
name|ret_val
operator|=
name|em_init_lcd_from_nvm
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************** * Resets the PHY * * hw - Struct containing variables accessed by shared code * * Sets bit 15 of the MII Control regiser ******************************************************************************/
end_comment

begin_function
name|int32_t
name|em_phy_reset
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|int32_t
name|ret_val
decl_stmt|;
name|uint16_t
name|phy_data
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_phy_reset"
argument_list|)
expr_stmt|;
comment|/* In the case of the phy reset being blocked, it's not an error, we      * simply return success without performing the reset. */
name|ret_val
operator|=
name|em_check_phy_reset_block
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|E1000_SUCCESS
return|;
switch|switch
condition|(
name|hw
operator|->
name|phy_type
condition|)
block|{
case|case
name|em_phy_igp
case|:
case|case
name|em_phy_igp_2
case|:
case|case
name|em_phy_igp_3
case|:
case|case
name|em_phy_ife
case|:
name|ret_val
operator|=
name|em_phy_hw_reset
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
break|break;
default|default:
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_CTRL
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|phy_data
operator||=
name|MII_CR_RESET
expr_stmt|;
name|ret_val
operator|=
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_CTRL
argument_list|,
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|usec_delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|hw
operator|->
name|phy_type
operator|==
name|em_phy_igp
operator|||
name|hw
operator|->
name|phy_type
operator|==
name|em_phy_igp_2
condition|)
name|em_phy_init_script
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************** * Work-around for 82566 power-down: on D3 entry- * 1) disable gigabit link * 2) write VR power-down enable * 3) read it back * if successful continue, else issue LCD reset and repeat * * hw - struct containing variables accessed by shared code ******************************************************************************/
end_comment

begin_function
name|void
name|em_phy_powerdown_workaround
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|int32_t
name|reg
decl_stmt|;
name|uint16_t
name|phy_data
decl_stmt|;
name|int32_t
name|retry
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_phy_powerdown_workaround"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|phy_type
operator|!=
name|em_phy_igp_3
condition|)
return|return;
do|do
block|{
comment|/* Disable link */
name|reg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|PHY_CTRL
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|PHY_CTRL
argument_list|,
name|reg
operator||
name|E1000_PHY_CTRL_GBE_DISABLE
operator||
name|E1000_PHY_CTRL_NOND0A_GBE_DISABLE
argument_list|)
expr_stmt|;
comment|/* Write VR power-down enable - bits 9:8 should be 10b */
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP3_VR_CTRL
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
name|phy_data
operator||=
operator|(
literal|1
operator|<<
literal|9
operator|)
expr_stmt|;
name|phy_data
operator|&=
operator|~
operator|(
literal|1
operator|<<
literal|8
operator|)
expr_stmt|;
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP3_VR_CTRL
argument_list|,
name|phy_data
argument_list|)
expr_stmt|;
comment|/* Read it back and test */
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP3_VR_CTRL
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|phy_data
operator|&
name|IGP3_VR_CTRL_MODE_MASK
operator|)
operator|==
name|IGP3_VR_CTRL_MODE_SHUT
operator|)
operator|||
name|retry
condition|)
break|break;
comment|/* Issue PHY reset and repeat at most one more time */
name|reg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|,
name|reg
operator||
name|E1000_CTRL_PHY_RST
argument_list|)
expr_stmt|;
name|retry
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|retry
condition|)
do|;
return|return;
block|}
end_function

begin_comment
comment|/****************************************************************************** * Work-around for 82566 Kumeran PCS lock loss: * On link status change (i.e. PCI reset, speed change) and link is up and * speed is gigabit- * 0) if workaround is optionally disabled do nothing * 1) wait 1ms for Kumeran link to come up * 2) check Kumeran Diagnostic register PCS lock loss bit * 3) if not set the link is locked (all is good), otherwise... * 4) reset the PHY * 5) repeat up to 10 times * Note: this is only called for IGP3 copper when speed is 1gb. * * hw - struct containing variables accessed by shared code ******************************************************************************/
end_comment

begin_function
name|STATIC
name|int32_t
name|em_kumeran_lock_loss_workaround
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|int32_t
name|ret_val
decl_stmt|;
name|int32_t
name|reg
decl_stmt|;
name|int32_t
name|cnt
decl_stmt|;
name|uint16_t
name|phy_data
decl_stmt|;
if|if
condition|(
name|hw
operator|->
name|kmrn_lock_loss_workaround_disabled
condition|)
return|return
name|E1000_SUCCESS
return|;
comment|/* Make sure link is up before proceeding.  If not just return.      * Attempting this while link is negotiating fouled up link      * stability */
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_STATUS
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_STATUS
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy_data
operator|&
name|MII_SR_LINK_STATUS
condition|)
block|{
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
literal|10
condition|;
name|cnt
operator|++
control|)
block|{
comment|/* read once to clear */
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP3_KMRN_DIAG
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
comment|/* and again to get new status */
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP3_KMRN_DIAG
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
comment|/* check for PCS lock */
if|if
condition|(
operator|!
operator|(
name|phy_data
operator|&
name|IGP3_KMRN_DIAG_PCS_LOCK_LOSS
operator|)
condition|)
return|return
name|E1000_SUCCESS
return|;
comment|/* Issue PHY reset */
name|em_phy_hw_reset
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|msec_delay_irq
argument_list|(
literal|5
argument_list|)
expr_stmt|;
block|}
comment|/* Disable GigE link negotiation */
name|reg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|PHY_CTRL
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|PHY_CTRL
argument_list|,
name|reg
operator||
name|E1000_PHY_CTRL_GBE_DISABLE
operator||
name|E1000_PHY_CTRL_NOND0A_GBE_DISABLE
argument_list|)
expr_stmt|;
comment|/* unable to acquire PCS lock */
return|return
name|E1000_ERR_PHY
return|;
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************** * Probes the expected PHY address for known PHY IDs * * hw - Struct containing variables accessed by shared code ******************************************************************************/
end_comment

begin_function
name|STATIC
name|int32_t
name|em_detect_gig_phy
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|int32_t
name|phy_init_status
decl_stmt|,
name|ret_val
decl_stmt|;
name|uint16_t
name|phy_id_high
decl_stmt|,
name|phy_id_low
decl_stmt|;
name|boolean_t
name|match
init|=
name|FALSE
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_detect_gig_phy"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|phy_id
operator|!=
literal|0
condition|)
return|return
name|E1000_SUCCESS
return|;
comment|/* The 82571 firmware may still be configuring the PHY.  In this      * case, we cannot access the PHY until the configuration is done.  So      * we explicitly set the PHY values. */
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|==
name|em_82571
operator|||
name|hw
operator|->
name|mac_type
operator|==
name|em_82572
condition|)
block|{
name|hw
operator|->
name|phy_id
operator|=
name|IGP01E1000_I_PHY_ID
expr_stmt|;
name|hw
operator|->
name|phy_type
operator|=
name|em_phy_igp_2
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
comment|/* ESB-2 PHY reads require em_phy_gg82563 to be set because of a work-      * around that forces PHY page 0 to be set or the reads fail.  The rest of      * the code in this routine uses em_read_phy_reg to read the PHY ID.      * So for ESB-2 we need to have this set so our reads won't fail.  If the      * attached PHY is not a em_phy_gg82563, the routines below will figure      * this out as well. */
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|==
name|em_80003es2lan
condition|)
name|hw
operator|->
name|phy_type
operator|=
name|em_phy_gg82563
expr_stmt|;
comment|/* Read the PHY ID Registers to identify which PHY is onboard. */
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_ID1
argument_list|,
operator|&
name|phy_id_high
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|hw
operator|->
name|phy_id
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|phy_id_high
operator|<<
literal|16
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|20
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_ID2
argument_list|,
operator|&
name|phy_id_low
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|hw
operator|->
name|phy_id
operator||=
call|(
name|uint32_t
call|)
argument_list|(
name|phy_id_low
operator|&
name|PHY_REVISION_MASK
argument_list|)
expr_stmt|;
name|hw
operator|->
name|phy_revision
operator|=
operator|(
name|uint32_t
operator|)
name|phy_id_low
operator|&
operator|~
name|PHY_REVISION_MASK
expr_stmt|;
switch|switch
condition|(
name|hw
operator|->
name|mac_type
condition|)
block|{
case|case
name|em_82543
case|:
if|if
condition|(
name|hw
operator|->
name|phy_id
operator|==
name|M88E1000_E_PHY_ID
condition|)
name|match
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|em_82544
case|:
if|if
condition|(
name|hw
operator|->
name|phy_id
operator|==
name|M88E1000_I_PHY_ID
condition|)
name|match
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|em_82540
case|:
case|case
name|em_82545
case|:
case|case
name|em_82545_rev_3
case|:
case|case
name|em_82546
case|:
case|case
name|em_82546_rev_3
case|:
if|if
condition|(
name|hw
operator|->
name|phy_id
operator|==
name|M88E1011_I_PHY_ID
condition|)
name|match
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|em_82541
case|:
case|case
name|em_82541_rev_2
case|:
case|case
name|em_82547
case|:
case|case
name|em_82547_rev_2
case|:
if|if
condition|(
name|hw
operator|->
name|phy_id
operator|==
name|IGP01E1000_I_PHY_ID
condition|)
name|match
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|em_82573
case|:
if|if
condition|(
name|hw
operator|->
name|phy_id
operator|==
name|M88E1111_I_PHY_ID
condition|)
name|match
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|em_80003es2lan
case|:
if|if
condition|(
name|hw
operator|->
name|phy_id
operator|==
name|GG82563_E_PHY_ID
condition|)
name|match
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|em_ich8lan
case|:
if|if
condition|(
name|hw
operator|->
name|phy_id
operator|==
name|IGP03E1000_E_PHY_ID
condition|)
name|match
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|phy_id
operator|==
name|IFE_E_PHY_ID
condition|)
name|match
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|phy_id
operator|==
name|IFE_PLUS_E_PHY_ID
condition|)
name|match
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|phy_id
operator|==
name|IFE_C_E_PHY_ID
condition|)
name|match
operator|=
name|TRUE
expr_stmt|;
break|break;
default|default:
name|DEBUGOUT1
argument_list|(
literal|"Invalid MAC type %d\n"
argument_list|,
name|hw
operator|->
name|mac_type
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_CONFIG
return|;
block|}
name|phy_init_status
operator|=
name|em_set_phy_type
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|match
operator|)
operator|&&
operator|(
name|phy_init_status
operator|==
name|E1000_SUCCESS
operator|)
condition|)
block|{
name|DEBUGOUT1
argument_list|(
literal|"PHY ID 0x%X detected\n"
argument_list|,
name|hw
operator|->
name|phy_id
argument_list|)
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
name|DEBUGOUT1
argument_list|(
literal|"Invalid PHY ID 0x%X\n"
argument_list|,
name|hw
operator|->
name|phy_id
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_PHY
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************** * Resets the PHY's DSP * * hw - Struct containing variables accessed by shared code ******************************************************************************/
end_comment

begin_function
specifier|static
name|int32_t
name|em_phy_reset_dsp
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|int32_t
name|ret_val
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_phy_reset_dsp"
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
name|hw
operator|->
name|phy_type
operator|!=
name|em_phy_gg82563
condition|)
block|{
name|ret_val
operator|=
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
literal|29
argument_list|,
literal|0x001d
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
break|break;
block|}
name|ret_val
operator|=
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
literal|30
argument_list|,
literal|0x00c1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
break|break;
name|ret_val
operator|=
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
literal|30
argument_list|,
literal|0x0000
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
break|break;
name|ret_val
operator|=
name|E1000_SUCCESS
expr_stmt|;
block|}
do|while
condition|(
literal|0
condition|)
do|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************** * Get PHY information from various PHY registers for igp PHY only. * * hw - Struct containing variables accessed by shared code * phy_info - PHY information structure ******************************************************************************/
end_comment

begin_function
name|STATIC
name|int32_t
name|em_phy_igp_get_info
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|struct
name|em_phy_info
modifier|*
name|phy_info
parameter_list|)
block|{
name|int32_t
name|ret_val
decl_stmt|;
name|uint16_t
name|phy_data
decl_stmt|,
name|min_length
decl_stmt|,
name|max_length
decl_stmt|,
name|average
decl_stmt|;
name|em_rev_polarity
name|polarity
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_phy_igp_get_info"
argument_list|)
expr_stmt|;
comment|/* The downshift status is checked only once, after link is established,      * and it stored in the hw->speed_downgraded parameter. */
name|phy_info
operator|->
name|downshift
operator|=
operator|(
name|em_downshift
operator|)
name|hw
operator|->
name|speed_downgraded
expr_stmt|;
comment|/* IGP01E1000 does not need to support it. */
name|phy_info
operator|->
name|extended_10bt_distance
operator|=
name|em_10bt_ext_dist_enable_normal
expr_stmt|;
comment|/* IGP01E1000 always correct polarity reversal */
name|phy_info
operator|->
name|polarity_correction
operator|=
name|em_polarity_reversal_enabled
expr_stmt|;
comment|/* Check polarity status */
name|ret_val
operator|=
name|em_check_polarity
argument_list|(
name|hw
argument_list|,
operator|&
name|polarity
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|phy_info
operator|->
name|cable_polarity
operator|=
name|polarity
expr_stmt|;
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_STATUS
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|phy_info
operator|->
name|mdix_mode
operator|=
call|(
name|em_auto_x_mode
call|)
argument_list|(
operator|(
name|phy_data
operator|&
name|IGP01E1000_PSSR_MDIX
operator|)
operator|>>
name|IGP01E1000_PSSR_MDIX_SHIFT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|phy_data
operator|&
name|IGP01E1000_PSSR_SPEED_MASK
operator|)
operator|==
name|IGP01E1000_PSSR_SPEED_1000MBPS
condition|)
block|{
comment|/* Local/Remote Receiver Information are only valid at 1000 Mbps */
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_1000T_STATUS
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|phy_info
operator|->
name|local_rx
operator|=
operator|(
operator|(
name|phy_data
operator|&
name|SR_1000T_LOCAL_RX_STATUS
operator|)
operator|>>
name|SR_1000T_LOCAL_RX_STATUS_SHIFT
operator|)
condition|?
name|em_1000t_rx_status_ok
else|:
name|em_1000t_rx_status_not_ok
expr_stmt|;
name|phy_info
operator|->
name|remote_rx
operator|=
operator|(
operator|(
name|phy_data
operator|&
name|SR_1000T_REMOTE_RX_STATUS
operator|)
operator|>>
name|SR_1000T_REMOTE_RX_STATUS_SHIFT
operator|)
condition|?
name|em_1000t_rx_status_ok
else|:
name|em_1000t_rx_status_not_ok
expr_stmt|;
comment|/* Get cable length */
name|ret_val
operator|=
name|em_get_cable_length
argument_list|(
name|hw
argument_list|,
operator|&
name|min_length
argument_list|,
operator|&
name|max_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
comment|/* Translate to old method */
name|average
operator|=
operator|(
name|max_length
operator|+
name|min_length
operator|)
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|average
operator|<=
name|em_igp_cable_length_50
condition|)
name|phy_info
operator|->
name|cable_length
operator|=
name|em_cable_length_50
expr_stmt|;
elseif|else
if|if
condition|(
name|average
operator|<=
name|em_igp_cable_length_80
condition|)
name|phy_info
operator|->
name|cable_length
operator|=
name|em_cable_length_50_80
expr_stmt|;
elseif|else
if|if
condition|(
name|average
operator|<=
name|em_igp_cable_length_110
condition|)
name|phy_info
operator|->
name|cable_length
operator|=
name|em_cable_length_80_110
expr_stmt|;
elseif|else
if|if
condition|(
name|average
operator|<=
name|em_igp_cable_length_140
condition|)
name|phy_info
operator|->
name|cable_length
operator|=
name|em_cable_length_110_140
expr_stmt|;
else|else
name|phy_info
operator|->
name|cable_length
operator|=
name|em_cable_length_140
expr_stmt|;
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************** * Get PHY information from various PHY registers for ife PHY only. * * hw - Struct containing variables accessed by shared code * phy_info - PHY information structure ******************************************************************************/
end_comment

begin_function
name|STATIC
name|int32_t
name|em_phy_ife_get_info
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|struct
name|em_phy_info
modifier|*
name|phy_info
parameter_list|)
block|{
name|int32_t
name|ret_val
decl_stmt|;
name|uint16_t
name|phy_data
decl_stmt|;
name|em_rev_polarity
name|polarity
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_phy_ife_get_info"
argument_list|)
expr_stmt|;
name|phy_info
operator|->
name|downshift
operator|=
operator|(
name|em_downshift
operator|)
name|hw
operator|->
name|speed_downgraded
expr_stmt|;
name|phy_info
operator|->
name|extended_10bt_distance
operator|=
name|em_10bt_ext_dist_enable_normal
expr_stmt|;
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|IFE_PHY_SPECIAL_CONTROL
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|phy_info
operator|->
name|polarity_correction
operator|=
operator|(
operator|(
name|phy_data
operator|&
name|IFE_PSC_AUTO_POLARITY_DISABLE
operator|)
operator|>>
name|IFE_PSC_AUTO_POLARITY_DISABLE_SHIFT
operator|)
condition|?
name|em_polarity_reversal_disabled
else|:
name|em_polarity_reversal_enabled
expr_stmt|;
if|if
condition|(
name|phy_info
operator|->
name|polarity_correction
operator|==
name|em_polarity_reversal_enabled
condition|)
block|{
name|ret_val
operator|=
name|em_check_polarity
argument_list|(
name|hw
argument_list|,
operator|&
name|polarity
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
block|}
else|else
block|{
comment|/* Polarity is forced. */
name|polarity
operator|=
operator|(
operator|(
name|phy_data
operator|&
name|IFE_PSC_FORCE_POLARITY
operator|)
operator|>>
name|IFE_PSC_FORCE_POLARITY_SHIFT
operator|)
condition|?
name|em_rev_polarity_reversed
else|:
name|em_rev_polarity_normal
expr_stmt|;
block|}
name|phy_info
operator|->
name|cable_polarity
operator|=
name|polarity
expr_stmt|;
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|IFE_PHY_MDIX_CONTROL
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|phy_info
operator|->
name|mdix_mode
operator|=
call|(
name|em_auto_x_mode
call|)
argument_list|(
operator|(
name|phy_data
operator|&
operator|(
name|IFE_PMC_AUTO_MDIX
operator||
name|IFE_PMC_FORCE_MDIX
operator|)
operator|)
operator|>>
name|IFE_PMC_MDIX_MODE_SHIFT
argument_list|)
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************** * Get PHY information from various PHY registers fot m88 PHY only. * * hw - Struct containing variables accessed by shared code * phy_info - PHY information structure ******************************************************************************/
end_comment

begin_function
name|STATIC
name|int32_t
name|em_phy_m88_get_info
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|struct
name|em_phy_info
modifier|*
name|phy_info
parameter_list|)
block|{
name|int32_t
name|ret_val
decl_stmt|;
name|uint16_t
name|phy_data
decl_stmt|;
name|em_rev_polarity
name|polarity
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_phy_m88_get_info"
argument_list|)
expr_stmt|;
comment|/* The downshift status is checked only once, after link is established,      * and it stored in the hw->speed_downgraded parameter. */
name|phy_info
operator|->
name|downshift
operator|=
operator|(
name|em_downshift
operator|)
name|hw
operator|->
name|speed_downgraded
expr_stmt|;
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_SPEC_CTRL
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|phy_info
operator|->
name|extended_10bt_distance
operator|=
operator|(
operator|(
name|phy_data
operator|&
name|M88E1000_PSCR_10BT_EXT_DIST_ENABLE
operator|)
operator|>>
name|M88E1000_PSCR_10BT_EXT_DIST_ENABLE_SHIFT
operator|)
condition|?
name|em_10bt_ext_dist_enable_lower
else|:
name|em_10bt_ext_dist_enable_normal
expr_stmt|;
name|phy_info
operator|->
name|polarity_correction
operator|=
operator|(
operator|(
name|phy_data
operator|&
name|M88E1000_PSCR_POLARITY_REVERSAL
operator|)
operator|>>
name|M88E1000_PSCR_POLARITY_REVERSAL_SHIFT
operator|)
condition|?
name|em_polarity_reversal_disabled
else|:
name|em_polarity_reversal_enabled
expr_stmt|;
comment|/* Check polarity status */
name|ret_val
operator|=
name|em_check_polarity
argument_list|(
name|hw
argument_list|,
operator|&
name|polarity
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|phy_info
operator|->
name|cable_polarity
operator|=
name|polarity
expr_stmt|;
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_SPEC_STATUS
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|phy_info
operator|->
name|mdix_mode
operator|=
call|(
name|em_auto_x_mode
call|)
argument_list|(
operator|(
name|phy_data
operator|&
name|M88E1000_PSSR_MDIX
operator|)
operator|>>
name|M88E1000_PSSR_MDIX_SHIFT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|phy_data
operator|&
name|M88E1000_PSSR_SPEED
operator|)
operator|==
name|M88E1000_PSSR_1000MBS
condition|)
block|{
comment|/* Cable Length Estimation and Local/Remote Receiver Information          * are only valid at 1000 Mbps.          */
if|if
condition|(
name|hw
operator|->
name|phy_type
operator|!=
name|em_phy_gg82563
condition|)
block|{
name|phy_info
operator|->
name|cable_length
operator|=
call|(
name|em_cable_length
call|)
argument_list|(
operator|(
name|phy_data
operator|&
name|M88E1000_PSSR_CABLE_LENGTH
operator|)
operator|>>
name|M88E1000_PSSR_CABLE_LENGTH_SHIFT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|GG82563_PHY_DSP_DISTANCE
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|phy_info
operator|->
name|cable_length
operator|=
call|(
name|em_cable_length
call|)
argument_list|(
name|phy_data
operator|&
name|GG82563_DSPD_CABLE_LENGTH
argument_list|)
expr_stmt|;
block|}
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_1000T_STATUS
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|phy_info
operator|->
name|local_rx
operator|=
operator|(
operator|(
name|phy_data
operator|&
name|SR_1000T_LOCAL_RX_STATUS
operator|)
operator|>>
name|SR_1000T_LOCAL_RX_STATUS_SHIFT
operator|)
condition|?
name|em_1000t_rx_status_ok
else|:
name|em_1000t_rx_status_not_ok
expr_stmt|;
name|phy_info
operator|->
name|remote_rx
operator|=
operator|(
operator|(
name|phy_data
operator|&
name|SR_1000T_REMOTE_RX_STATUS
operator|)
operator|>>
name|SR_1000T_REMOTE_RX_STATUS_SHIFT
operator|)
condition|?
name|em_1000t_rx_status_ok
else|:
name|em_1000t_rx_status_not_ok
expr_stmt|;
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************** * Get PHY information from various PHY registers * * hw - Struct containing variables accessed by shared code * phy_info - PHY information structure ******************************************************************************/
end_comment

begin_function
name|int32_t
name|em_phy_get_info
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|struct
name|em_phy_info
modifier|*
name|phy_info
parameter_list|)
block|{
name|int32_t
name|ret_val
decl_stmt|;
name|uint16_t
name|phy_data
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_phy_get_info"
argument_list|)
expr_stmt|;
name|phy_info
operator|->
name|cable_length
operator|=
name|em_cable_length_undefined
expr_stmt|;
name|phy_info
operator|->
name|extended_10bt_distance
operator|=
name|em_10bt_ext_dist_enable_undefined
expr_stmt|;
name|phy_info
operator|->
name|cable_polarity
operator|=
name|em_rev_polarity_undefined
expr_stmt|;
name|phy_info
operator|->
name|downshift
operator|=
name|em_downshift_undefined
expr_stmt|;
name|phy_info
operator|->
name|polarity_correction
operator|=
name|em_polarity_reversal_undefined
expr_stmt|;
name|phy_info
operator|->
name|mdix_mode
operator|=
name|em_auto_x_mode_undefined
expr_stmt|;
name|phy_info
operator|->
name|local_rx
operator|=
name|em_1000t_rx_status_undefined
expr_stmt|;
name|phy_info
operator|->
name|remote_rx
operator|=
name|em_1000t_rx_status_undefined
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|media_type
operator|!=
name|em_media_type_copper
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"PHY info is only valid for copper media\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_CONFIG
return|;
block|}
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_STATUS
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_STATUS
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
if|if
condition|(
operator|(
name|phy_data
operator|&
name|MII_SR_LINK_STATUS
operator|)
operator|!=
name|MII_SR_LINK_STATUS
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"PHY info is only valid if link is up\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_CONFIG
return|;
block|}
if|if
condition|(
name|hw
operator|->
name|phy_type
operator|==
name|em_phy_igp
operator|||
name|hw
operator|->
name|phy_type
operator|==
name|em_phy_igp_3
operator|||
name|hw
operator|->
name|phy_type
operator|==
name|em_phy_igp_2
condition|)
return|return
name|em_phy_igp_get_info
argument_list|(
name|hw
argument_list|,
name|phy_info
argument_list|)
return|;
elseif|else
if|if
condition|(
name|hw
operator|->
name|phy_type
operator|==
name|em_phy_ife
condition|)
return|return
name|em_phy_ife_get_info
argument_list|(
name|hw
argument_list|,
name|phy_info
argument_list|)
return|;
else|else
return|return
name|em_phy_m88_get_info
argument_list|(
name|hw
argument_list|,
name|phy_info
argument_list|)
return|;
block|}
end_function

begin_function
name|int32_t
name|em_validate_mdi_setting
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"em_validate_mdi_settings"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hw
operator|->
name|autoneg
operator|&&
operator|(
name|hw
operator|->
name|mdix
operator|==
literal|0
operator|||
name|hw
operator|->
name|mdix
operator|==
literal|3
operator|)
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Invalid MDI setting detected\n"
argument_list|)
expr_stmt|;
name|hw
operator|->
name|mdix
operator|=
literal|1
expr_stmt|;
return|return
operator|-
name|E1000_ERR_CONFIG
return|;
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Sets up eeprom variables in the hw struct.  Must be called after mac_type  * is configured.  Additionally, if this is ICH8, the flash controller GbE  * registers must be mapped, or this will crash.  *  * hw - Struct containing variables accessed by shared code  *****************************************************************************/
end_comment

begin_function
name|int32_t
name|em_init_eeprom_params
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|em_eeprom_info
modifier|*
name|eeprom
init|=
operator|&
name|hw
operator|->
name|eeprom
decl_stmt|;
name|uint32_t
name|eecd
init|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|EECD
argument_list|)
decl_stmt|;
name|int32_t
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|uint16_t
name|eeprom_size
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_init_eeprom_params"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|hw
operator|->
name|mac_type
condition|)
block|{
case|case
name|em_82542_rev2_0
case|:
case|case
name|em_82542_rev2_1
case|:
case|case
name|em_82543
case|:
case|case
name|em_82544
case|:
name|eeprom
operator|->
name|type
operator|=
name|em_eeprom_microwire
expr_stmt|;
name|eeprom
operator|->
name|word_size
operator|=
literal|64
expr_stmt|;
name|eeprom
operator|->
name|opcode_bits
operator|=
literal|3
expr_stmt|;
name|eeprom
operator|->
name|address_bits
operator|=
literal|6
expr_stmt|;
name|eeprom
operator|->
name|delay_usec
operator|=
literal|50
expr_stmt|;
name|eeprom
operator|->
name|use_eerd
operator|=
name|FALSE
expr_stmt|;
name|eeprom
operator|->
name|use_eewr
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|em_82540
case|:
case|case
name|em_82545
case|:
case|case
name|em_82545_rev_3
case|:
case|case
name|em_82546
case|:
case|case
name|em_82546_rev_3
case|:
name|eeprom
operator|->
name|type
operator|=
name|em_eeprom_microwire
expr_stmt|;
name|eeprom
operator|->
name|opcode_bits
operator|=
literal|3
expr_stmt|;
name|eeprom
operator|->
name|delay_usec
operator|=
literal|50
expr_stmt|;
if|if
condition|(
name|eecd
operator|&
name|E1000_EECD_SIZE
condition|)
block|{
name|eeprom
operator|->
name|word_size
operator|=
literal|256
expr_stmt|;
name|eeprom
operator|->
name|address_bits
operator|=
literal|8
expr_stmt|;
block|}
else|else
block|{
name|eeprom
operator|->
name|word_size
operator|=
literal|64
expr_stmt|;
name|eeprom
operator|->
name|address_bits
operator|=
literal|6
expr_stmt|;
block|}
name|eeprom
operator|->
name|use_eerd
operator|=
name|FALSE
expr_stmt|;
name|eeprom
operator|->
name|use_eewr
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|em_82541
case|:
case|case
name|em_82541_rev_2
case|:
case|case
name|em_82547
case|:
case|case
name|em_82547_rev_2
case|:
if|if
condition|(
name|eecd
operator|&
name|E1000_EECD_TYPE
condition|)
block|{
name|eeprom
operator|->
name|type
operator|=
name|em_eeprom_spi
expr_stmt|;
name|eeprom
operator|->
name|opcode_bits
operator|=
literal|8
expr_stmt|;
name|eeprom
operator|->
name|delay_usec
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|eecd
operator|&
name|E1000_EECD_ADDR_BITS
condition|)
block|{
name|eeprom
operator|->
name|page_size
operator|=
literal|32
expr_stmt|;
name|eeprom
operator|->
name|address_bits
operator|=
literal|16
expr_stmt|;
block|}
else|else
block|{
name|eeprom
operator|->
name|page_size
operator|=
literal|8
expr_stmt|;
name|eeprom
operator|->
name|address_bits
operator|=
literal|8
expr_stmt|;
block|}
block|}
else|else
block|{
name|eeprom
operator|->
name|type
operator|=
name|em_eeprom_microwire
expr_stmt|;
name|eeprom
operator|->
name|opcode_bits
operator|=
literal|3
expr_stmt|;
name|eeprom
operator|->
name|delay_usec
operator|=
literal|50
expr_stmt|;
if|if
condition|(
name|eecd
operator|&
name|E1000_EECD_ADDR_BITS
condition|)
block|{
name|eeprom
operator|->
name|word_size
operator|=
literal|256
expr_stmt|;
name|eeprom
operator|->
name|address_bits
operator|=
literal|8
expr_stmt|;
block|}
else|else
block|{
name|eeprom
operator|->
name|word_size
operator|=
literal|64
expr_stmt|;
name|eeprom
operator|->
name|address_bits
operator|=
literal|6
expr_stmt|;
block|}
block|}
name|eeprom
operator|->
name|use_eerd
operator|=
name|FALSE
expr_stmt|;
name|eeprom
operator|->
name|use_eewr
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|em_82571
case|:
case|case
name|em_82572
case|:
name|eeprom
operator|->
name|type
operator|=
name|em_eeprom_spi
expr_stmt|;
name|eeprom
operator|->
name|opcode_bits
operator|=
literal|8
expr_stmt|;
name|eeprom
operator|->
name|delay_usec
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|eecd
operator|&
name|E1000_EECD_ADDR_BITS
condition|)
block|{
name|eeprom
operator|->
name|page_size
operator|=
literal|32
expr_stmt|;
name|eeprom
operator|->
name|address_bits
operator|=
literal|16
expr_stmt|;
block|}
else|else
block|{
name|eeprom
operator|->
name|page_size
operator|=
literal|8
expr_stmt|;
name|eeprom
operator|->
name|address_bits
operator|=
literal|8
expr_stmt|;
block|}
name|eeprom
operator|->
name|use_eerd
operator|=
name|FALSE
expr_stmt|;
name|eeprom
operator|->
name|use_eewr
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|em_82573
case|:
name|eeprom
operator|->
name|type
operator|=
name|em_eeprom_spi
expr_stmt|;
name|eeprom
operator|->
name|opcode_bits
operator|=
literal|8
expr_stmt|;
name|eeprom
operator|->
name|delay_usec
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|eecd
operator|&
name|E1000_EECD_ADDR_BITS
condition|)
block|{
name|eeprom
operator|->
name|page_size
operator|=
literal|32
expr_stmt|;
name|eeprom
operator|->
name|address_bits
operator|=
literal|16
expr_stmt|;
block|}
else|else
block|{
name|eeprom
operator|->
name|page_size
operator|=
literal|8
expr_stmt|;
name|eeprom
operator|->
name|address_bits
operator|=
literal|8
expr_stmt|;
block|}
name|eeprom
operator|->
name|use_eerd
operator|=
name|TRUE
expr_stmt|;
name|eeprom
operator|->
name|use_eewr
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|em_is_onboard_nvm_eeprom
argument_list|(
name|hw
argument_list|)
operator|==
name|FALSE
condition|)
block|{
name|eeprom
operator|->
name|type
operator|=
name|em_eeprom_flash
expr_stmt|;
name|eeprom
operator|->
name|word_size
operator|=
literal|2048
expr_stmt|;
comment|/* Ensure that the Autonomous FLASH update bit is cleared due to              * Flash update issue on parts which use a FLASH for NVM. */
name|eecd
operator|&=
operator|~
name|E1000_EECD_AUPDEN
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|EECD
argument_list|,
name|eecd
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|em_80003es2lan
case|:
name|eeprom
operator|->
name|type
operator|=
name|em_eeprom_spi
expr_stmt|;
name|eeprom
operator|->
name|opcode_bits
operator|=
literal|8
expr_stmt|;
name|eeprom
operator|->
name|delay_usec
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|eecd
operator|&
name|E1000_EECD_ADDR_BITS
condition|)
block|{
name|eeprom
operator|->
name|page_size
operator|=
literal|32
expr_stmt|;
name|eeprom
operator|->
name|address_bits
operator|=
literal|16
expr_stmt|;
block|}
else|else
block|{
name|eeprom
operator|->
name|page_size
operator|=
literal|8
expr_stmt|;
name|eeprom
operator|->
name|address_bits
operator|=
literal|8
expr_stmt|;
block|}
name|eeprom
operator|->
name|use_eerd
operator|=
name|TRUE
expr_stmt|;
name|eeprom
operator|->
name|use_eewr
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|em_ich8lan
case|:
block|{
name|int32_t
name|i
init|=
literal|0
decl_stmt|;
name|uint32_t
name|flash_size
init|=
name|E1000_READ_ICH_FLASH_REG
argument_list|(
name|hw
argument_list|,
name|ICH_FLASH_GFPREG
argument_list|)
decl_stmt|;
name|eeprom
operator|->
name|type
operator|=
name|em_eeprom_ich8
expr_stmt|;
name|eeprom
operator|->
name|use_eerd
operator|=
name|FALSE
expr_stmt|;
name|eeprom
operator|->
name|use_eewr
operator|=
name|FALSE
expr_stmt|;
name|eeprom
operator|->
name|word_size
operator|=
name|E1000_SHADOW_RAM_WORDS
expr_stmt|;
comment|/* Zero the shadow RAM structure. But don't load it from NVM          * so as to save time for driver init */
if|if
condition|(
name|hw
operator|->
name|eeprom_shadow_ram
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|E1000_SHADOW_RAM_WORDS
condition|;
name|i
operator|++
control|)
block|{
name|hw
operator|->
name|eeprom_shadow_ram
index|[
name|i
index|]
operator|.
name|modified
operator|=
name|FALSE
expr_stmt|;
name|hw
operator|->
name|eeprom_shadow_ram
index|[
name|i
index|]
operator|.
name|eeprom_word
operator|=
literal|0xFFFF
expr_stmt|;
block|}
block|}
name|hw
operator|->
name|flash_base_addr
operator|=
operator|(
name|flash_size
operator|&
name|ICH_GFPREG_BASE_MASK
operator|)
operator|*
name|ICH_FLASH_SECTOR_SIZE
expr_stmt|;
name|hw
operator|->
name|flash_bank_size
operator|=
operator|(
operator|(
name|flash_size
operator|>>
literal|16
operator|)
operator|&
name|ICH_GFPREG_BASE_MASK
operator|)
operator|+
literal|1
expr_stmt|;
name|hw
operator|->
name|flash_bank_size
operator|-=
operator|(
name|flash_size
operator|&
name|ICH_GFPREG_BASE_MASK
operator|)
expr_stmt|;
name|hw
operator|->
name|flash_bank_size
operator|*=
name|ICH_FLASH_SECTOR_SIZE
expr_stmt|;
name|hw
operator|->
name|flash_bank_size
operator|/=
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
break|break;
block|}
if|if
condition|(
name|eeprom
operator|->
name|type
operator|==
name|em_eeprom_spi
condition|)
block|{
comment|/* eeprom_size will be an enum [0..8] that maps to eeprom sizes 128B to          * 32KB (incremented by powers of 2).          */
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|<=
name|em_82547_rev_2
condition|)
block|{
comment|/* Set to default value for initial eeprom read. */
name|eeprom
operator|->
name|word_size
operator|=
literal|64
expr_stmt|;
name|ret_val
operator|=
name|em_read_eeprom
argument_list|(
name|hw
argument_list|,
name|EEPROM_CFG
argument_list|,
literal|1
argument_list|,
operator|&
name|eeprom_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|eeprom_size
operator|=
operator|(
name|eeprom_size
operator|&
name|EEPROM_SIZE_MASK
operator|)
operator|>>
name|EEPROM_SIZE_SHIFT
expr_stmt|;
comment|/* 256B eeprom size was not supported in earlier hardware, so we              * bump eeprom_size up one to ensure that "1" (which maps to 256B)              * is never the result used in the shifting logic below. */
if|if
condition|(
name|eeprom_size
condition|)
name|eeprom_size
operator|++
expr_stmt|;
block|}
else|else
block|{
name|eeprom_size
operator|=
call|(
name|uint16_t
call|)
argument_list|(
operator|(
name|eecd
operator|&
name|E1000_EECD_SIZE_EX_MASK
operator|)
operator|>>
name|E1000_EECD_SIZE_EX_SHIFT
argument_list|)
expr_stmt|;
block|}
name|eeprom
operator|->
name|word_size
operator|=
literal|1
operator|<<
operator|(
name|eeprom_size
operator|+
name|EEPROM_WORD_SIZE_SHIFT
operator|)
expr_stmt|;
block|}
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Raises the EEPROM's clock input.  *  * hw - Struct containing variables accessed by shared code  * eecd - EECD's current value  *****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|em_raise_ee_clk
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint32_t
modifier|*
name|eecd
parameter_list|)
block|{
comment|/* Raise the clock input to the EEPROM (by setting the SK bit), and then      * wait<delay> microseconds.      */
operator|*
name|eecd
operator|=
operator|*
name|eecd
operator||
name|E1000_EECD_SK
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|EECD
argument_list|,
operator|*
name|eecd
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
name|hw
operator|->
name|eeprom
operator|.
name|delay_usec
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Lowers the EEPROM's clock input.  *  * hw - Struct containing variables accessed by shared code  * eecd - EECD's current value  *****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|em_lower_ee_clk
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint32_t
modifier|*
name|eecd
parameter_list|)
block|{
comment|/* Lower the clock input to the EEPROM (by clearing the SK bit), and then      * wait 50 microseconds.      */
operator|*
name|eecd
operator|=
operator|*
name|eecd
operator|&
operator|~
name|E1000_EECD_SK
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|EECD
argument_list|,
operator|*
name|eecd
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
name|hw
operator|->
name|eeprom
operator|.
name|delay_usec
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Shift data bits out to the EEPROM.  *  * hw - Struct containing variables accessed by shared code  * data - data to send to the EEPROM  * count - number of bits to shift out  *****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|em_shift_out_ee_bits
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint16_t
name|data
parameter_list|,
name|uint16_t
name|count
parameter_list|)
block|{
name|struct
name|em_eeprom_info
modifier|*
name|eeprom
init|=
operator|&
name|hw
operator|->
name|eeprom
decl_stmt|;
name|uint32_t
name|eecd
decl_stmt|;
name|uint32_t
name|mask
decl_stmt|;
comment|/* We need to shift "count" bits out to the EEPROM. So, value in the      * "data" parameter will be shifted out to the EEPROM one bit at a time.      * In order to do this, "data" must be broken down into bits.      */
name|mask
operator|=
literal|0x01
operator|<<
operator|(
name|count
operator|-
literal|1
operator|)
expr_stmt|;
name|eecd
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|EECD
argument_list|)
expr_stmt|;
if|if
condition|(
name|eeprom
operator|->
name|type
operator|==
name|em_eeprom_microwire
condition|)
block|{
name|eecd
operator|&=
operator|~
name|E1000_EECD_DO
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|eeprom
operator|->
name|type
operator|==
name|em_eeprom_spi
condition|)
block|{
name|eecd
operator||=
name|E1000_EECD_DO
expr_stmt|;
block|}
do|do
block|{
comment|/* A "1" is shifted out to the EEPROM by setting bit "DI" to a "1",          * and then raising and then lowering the clock (the SK bit controls          * the clock input to the EEPROM).  A "0" is shifted out to the EEPROM          * by setting "DI" to "0" and then raising and then lowering the clock.          */
name|eecd
operator|&=
operator|~
name|E1000_EECD_DI
expr_stmt|;
if|if
condition|(
name|data
operator|&
name|mask
condition|)
name|eecd
operator||=
name|E1000_EECD_DI
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|EECD
argument_list|,
name|eecd
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
name|eeprom
operator|->
name|delay_usec
argument_list|)
expr_stmt|;
name|em_raise_ee_clk
argument_list|(
name|hw
argument_list|,
operator|&
name|eecd
argument_list|)
expr_stmt|;
name|em_lower_ee_clk
argument_list|(
name|hw
argument_list|,
operator|&
name|eecd
argument_list|)
expr_stmt|;
name|mask
operator|=
name|mask
operator|>>
literal|1
expr_stmt|;
block|}
do|while
condition|(
name|mask
condition|)
do|;
comment|/* We leave the "DI" bit set to "0" when we leave this routine. */
name|eecd
operator|&=
operator|~
name|E1000_EECD_DI
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|EECD
argument_list|,
name|eecd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Shift data bits in from the EEPROM  *  * hw - Struct containing variables accessed by shared code  *****************************************************************************/
end_comment

begin_function
specifier|static
name|uint16_t
name|em_shift_in_ee_bits
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint16_t
name|count
parameter_list|)
block|{
name|uint32_t
name|eecd
decl_stmt|;
name|uint32_t
name|i
decl_stmt|;
name|uint16_t
name|data
decl_stmt|;
comment|/* In order to read a register from the EEPROM, we need to shift 'count'      * bits in from the EEPROM. Bits are "shifted in" by raising the clock      * input to the EEPROM (setting the SK bit), and then reading the value of      * the "DO" bit.  During this "shifting in" process the "DI" bit should      * always be clear.      */
name|eecd
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|EECD
argument_list|)
expr_stmt|;
name|eecd
operator|&=
operator|~
operator|(
name|E1000_EECD_DO
operator||
name|E1000_EECD_DI
operator|)
expr_stmt|;
name|data
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|data
operator|=
name|data
operator|<<
literal|1
expr_stmt|;
name|em_raise_ee_clk
argument_list|(
name|hw
argument_list|,
operator|&
name|eecd
argument_list|)
expr_stmt|;
name|eecd
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|EECD
argument_list|)
expr_stmt|;
name|eecd
operator|&=
operator|~
operator|(
name|E1000_EECD_DI
operator|)
expr_stmt|;
if|if
condition|(
name|eecd
operator|&
name|E1000_EECD_DO
condition|)
name|data
operator||=
literal|1
expr_stmt|;
name|em_lower_ee_clk
argument_list|(
name|hw
argument_list|,
operator|&
name|eecd
argument_list|)
expr_stmt|;
block|}
return|return
name|data
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Prepares EEPROM for access  *  * hw - Struct containing variables accessed by shared code  *  * Lowers EEPROM clock. Clears input pin. Sets the chip select pin. This  * function should be called before issuing a command to the EEPROM.  *****************************************************************************/
end_comment

begin_function
specifier|static
name|int32_t
name|em_acquire_eeprom
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|em_eeprom_info
modifier|*
name|eeprom
init|=
operator|&
name|hw
operator|->
name|eeprom
decl_stmt|;
name|uint32_t
name|eecd
decl_stmt|,
name|i
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_acquire_eeprom"
argument_list|)
expr_stmt|;
if|if
condition|(
name|em_swfw_sync_acquire
argument_list|(
name|hw
argument_list|,
name|E1000_SWFW_EEP_SM
argument_list|)
condition|)
return|return
operator|-
name|E1000_ERR_SWFW_SYNC
return|;
name|eecd
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|EECD
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|!=
name|em_82573
condition|)
block|{
comment|/* Request EEPROM Access */
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|>
name|em_82544
condition|)
block|{
name|eecd
operator||=
name|E1000_EECD_REQ
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|EECD
argument_list|,
name|eecd
argument_list|)
expr_stmt|;
name|eecd
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|EECD
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
operator|!
operator|(
name|eecd
operator|&
name|E1000_EECD_GNT
operator|)
operator|)
operator|&&
operator|(
name|i
operator|<
name|E1000_EEPROM_GRANT_ATTEMPTS
operator|)
condition|)
block|{
name|i
operator|++
expr_stmt|;
name|usec_delay
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|eecd
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|EECD
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|eecd
operator|&
name|E1000_EECD_GNT
operator|)
condition|)
block|{
name|eecd
operator|&=
operator|~
name|E1000_EECD_REQ
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|EECD
argument_list|,
name|eecd
argument_list|)
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Could not acquire EEPROM grant\n"
argument_list|)
expr_stmt|;
name|em_swfw_sync_release
argument_list|(
name|hw
argument_list|,
name|E1000_SWFW_EEP_SM
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_EEPROM
return|;
block|}
block|}
block|}
comment|/* Setup EEPROM for Read/Write */
if|if
condition|(
name|eeprom
operator|->
name|type
operator|==
name|em_eeprom_microwire
condition|)
block|{
comment|/* Clear SK and DI */
name|eecd
operator|&=
operator|~
operator|(
name|E1000_EECD_DI
operator||
name|E1000_EECD_SK
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|EECD
argument_list|,
name|eecd
argument_list|)
expr_stmt|;
comment|/* Set CS */
name|eecd
operator||=
name|E1000_EECD_CS
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|EECD
argument_list|,
name|eecd
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|eeprom
operator|->
name|type
operator|==
name|em_eeprom_spi
condition|)
block|{
comment|/* Clear SK and CS */
name|eecd
operator|&=
operator|~
operator|(
name|E1000_EECD_CS
operator||
name|E1000_EECD_SK
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|EECD
argument_list|,
name|eecd
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Returns EEPROM to a "standby" state  *  * hw - Struct containing variables accessed by shared code  *****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|em_standby_eeprom
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|em_eeprom_info
modifier|*
name|eeprom
init|=
operator|&
name|hw
operator|->
name|eeprom
decl_stmt|;
name|uint32_t
name|eecd
decl_stmt|;
name|eecd
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|EECD
argument_list|)
expr_stmt|;
if|if
condition|(
name|eeprom
operator|->
name|type
operator|==
name|em_eeprom_microwire
condition|)
block|{
name|eecd
operator|&=
operator|~
operator|(
name|E1000_EECD_CS
operator||
name|E1000_EECD_SK
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|EECD
argument_list|,
name|eecd
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
name|eeprom
operator|->
name|delay_usec
argument_list|)
expr_stmt|;
comment|/* Clock high */
name|eecd
operator||=
name|E1000_EECD_SK
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|EECD
argument_list|,
name|eecd
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
name|eeprom
operator|->
name|delay_usec
argument_list|)
expr_stmt|;
comment|/* Select EEPROM */
name|eecd
operator||=
name|E1000_EECD_CS
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|EECD
argument_list|,
name|eecd
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
name|eeprom
operator|->
name|delay_usec
argument_list|)
expr_stmt|;
comment|/* Clock low */
name|eecd
operator|&=
operator|~
name|E1000_EECD_SK
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|EECD
argument_list|,
name|eecd
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
name|eeprom
operator|->
name|delay_usec
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|eeprom
operator|->
name|type
operator|==
name|em_eeprom_spi
condition|)
block|{
comment|/* Toggle CS to flush commands */
name|eecd
operator||=
name|E1000_EECD_CS
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|EECD
argument_list|,
name|eecd
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
name|eeprom
operator|->
name|delay_usec
argument_list|)
expr_stmt|;
name|eecd
operator|&=
operator|~
name|E1000_EECD_CS
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|EECD
argument_list|,
name|eecd
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
name|eeprom
operator|->
name|delay_usec
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/******************************************************************************  * Terminates a command by inverting the EEPROM's chip select pin  *  * hw - Struct containing variables accessed by shared code  *****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|em_release_eeprom
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|uint32_t
name|eecd
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_release_eeprom"
argument_list|)
expr_stmt|;
name|eecd
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|EECD
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|eeprom
operator|.
name|type
operator|==
name|em_eeprom_spi
condition|)
block|{
name|eecd
operator||=
name|E1000_EECD_CS
expr_stmt|;
comment|/* Pull CS high */
name|eecd
operator|&=
operator|~
name|E1000_EECD_SK
expr_stmt|;
comment|/* Lower SCK */
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|EECD
argument_list|,
name|eecd
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
name|hw
operator|->
name|eeprom
operator|.
name|delay_usec
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|hw
operator|->
name|eeprom
operator|.
name|type
operator|==
name|em_eeprom_microwire
condition|)
block|{
comment|/* cleanup eeprom */
comment|/* CS on Microwire is active-high */
name|eecd
operator|&=
operator|~
operator|(
name|E1000_EECD_CS
operator||
name|E1000_EECD_DI
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|EECD
argument_list|,
name|eecd
argument_list|)
expr_stmt|;
comment|/* Rising edge of clock */
name|eecd
operator||=
name|E1000_EECD_SK
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|EECD
argument_list|,
name|eecd
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
name|hw
operator|->
name|eeprom
operator|.
name|delay_usec
argument_list|)
expr_stmt|;
comment|/* Falling edge of clock */
name|eecd
operator|&=
operator|~
name|E1000_EECD_SK
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|EECD
argument_list|,
name|eecd
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
name|hw
operator|->
name|eeprom
operator|.
name|delay_usec
argument_list|)
expr_stmt|;
block|}
comment|/* Stop requesting EEPROM access */
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|>
name|em_82544
condition|)
block|{
name|eecd
operator|&=
operator|~
name|E1000_EECD_REQ
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|EECD
argument_list|,
name|eecd
argument_list|)
expr_stmt|;
block|}
name|em_swfw_sync_release
argument_list|(
name|hw
argument_list|,
name|E1000_SWFW_EEP_SM
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Reads a 16 bit word from the EEPROM.  *  * hw - Struct containing variables accessed by shared code  *****************************************************************************/
end_comment

begin_function
name|STATIC
name|int32_t
name|em_spi_eeprom_ready
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|uint16_t
name|retry_count
init|=
literal|0
decl_stmt|;
name|uint8_t
name|spi_stat_reg
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_spi_eeprom_ready"
argument_list|)
expr_stmt|;
comment|/* Read "Status Register" repeatedly until the LSB is cleared.  The      * EEPROM will signal that the command has been completed by clearing      * bit 0 of the internal status register.  If it's not cleared within      * 5 milliseconds, then error out.      */
name|retry_count
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|em_shift_out_ee_bits
argument_list|(
name|hw
argument_list|,
name|EEPROM_RDSR_OPCODE_SPI
argument_list|,
name|hw
operator|->
name|eeprom
operator|.
name|opcode_bits
argument_list|)
expr_stmt|;
name|spi_stat_reg
operator|=
operator|(
name|uint8_t
operator|)
name|em_shift_in_ee_bits
argument_list|(
name|hw
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|spi_stat_reg
operator|&
name|EEPROM_STATUS_RDY_SPI
operator|)
condition|)
break|break;
name|usec_delay
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|retry_count
operator|+=
literal|5
expr_stmt|;
name|em_standby_eeprom
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|retry_count
operator|<
name|EEPROM_MAX_RETRY_SPI
condition|)
do|;
comment|/* ATMEL SPI write time could vary from 0-20mSec on 3.3V devices (and      * only 0-5mSec on 5V devices)      */
if|if
condition|(
name|retry_count
operator|>=
name|EEPROM_MAX_RETRY_SPI
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"SPI EEPROM Status error\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_EEPROM
return|;
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Reads a 16 bit word from the EEPROM.  *  * hw - Struct containing variables accessed by shared code  * offset - offset of  word in the EEPROM to read  * data - word read from the EEPROM  * words - number of words to read  *****************************************************************************/
end_comment

begin_function
name|int32_t
name|em_read_eeprom
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint16_t
name|offset
parameter_list|,
name|uint16_t
name|words
parameter_list|,
name|uint16_t
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|em_eeprom_info
modifier|*
name|eeprom
init|=
operator|&
name|hw
operator|->
name|eeprom
decl_stmt|;
name|uint32_t
name|i
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_read_eeprom"
argument_list|)
expr_stmt|;
comment|/* If eeprom is not yet detected, do so now */
if|if
condition|(
name|eeprom
operator|->
name|word_size
operator|==
literal|0
condition|)
name|em_init_eeprom_params
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* A check for invalid values:  offset too large, too many words, and not      * enough words.      */
if|if
condition|(
operator|(
name|offset
operator|>=
name|eeprom
operator|->
name|word_size
operator|)
operator|||
operator|(
name|words
operator|>
name|eeprom
operator|->
name|word_size
operator|-
name|offset
operator|)
operator|||
operator|(
name|words
operator|==
literal|0
operator|)
condition|)
block|{
name|DEBUGOUT2
argument_list|(
literal|"\"words\" parameter out of bounds. Words = %d, size = %d\n"
argument_list|,
name|offset
argument_list|,
name|eeprom
operator|->
name|word_size
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_EEPROM
return|;
block|}
comment|/* EEPROM's that don't use EERD to read require us to bit-bang the SPI      * directly. In this case, we need to acquire the EEPROM so that      * FW or other port software does not interrupt.      */
if|if
condition|(
name|em_is_onboard_nvm_eeprom
argument_list|(
name|hw
argument_list|)
operator|==
name|TRUE
operator|&&
name|hw
operator|->
name|eeprom
operator|.
name|use_eerd
operator|==
name|FALSE
condition|)
block|{
comment|/* Prepare the EEPROM for bit-bang reading */
if|if
condition|(
name|em_acquire_eeprom
argument_list|(
name|hw
argument_list|)
operator|!=
name|E1000_SUCCESS
condition|)
return|return
operator|-
name|E1000_ERR_EEPROM
return|;
block|}
comment|/* Eerd register EEPROM access requires no eeprom aquire/release */
if|if
condition|(
name|eeprom
operator|->
name|use_eerd
operator|==
name|TRUE
condition|)
return|return
name|em_read_eeprom_eerd
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
name|words
argument_list|,
name|data
argument_list|)
return|;
comment|/* ICH EEPROM access is done via the ICH flash controller */
if|if
condition|(
name|eeprom
operator|->
name|type
operator|==
name|em_eeprom_ich8
condition|)
return|return
name|em_read_eeprom_ich8
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
name|words
argument_list|,
name|data
argument_list|)
return|;
comment|/* Set up the SPI or Microwire EEPROM for bit-bang reading.  We have      * acquired the EEPROM at this point, so any returns should relase it */
if|if
condition|(
name|eeprom
operator|->
name|type
operator|==
name|em_eeprom_spi
condition|)
block|{
name|uint16_t
name|word_in
decl_stmt|;
name|uint8_t
name|read_opcode
init|=
name|EEPROM_READ_OPCODE_SPI
decl_stmt|;
if|if
condition|(
name|em_spi_eeprom_ready
argument_list|(
name|hw
argument_list|)
condition|)
block|{
name|em_release_eeprom
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_EEPROM
return|;
block|}
name|em_standby_eeprom
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Some SPI eeproms use the 8th address bit embedded in the opcode */
if|if
condition|(
operator|(
name|eeprom
operator|->
name|address_bits
operator|==
literal|8
operator|)
operator|&&
operator|(
name|offset
operator|>=
literal|128
operator|)
condition|)
name|read_opcode
operator||=
name|EEPROM_A8_OPCODE_SPI
expr_stmt|;
comment|/* Send the READ command (opcode + addr)  */
name|em_shift_out_ee_bits
argument_list|(
name|hw
argument_list|,
name|read_opcode
argument_list|,
name|eeprom
operator|->
name|opcode_bits
argument_list|)
expr_stmt|;
name|em_shift_out_ee_bits
argument_list|(
name|hw
argument_list|,
call|(
name|uint16_t
call|)
argument_list|(
name|offset
operator|*
literal|2
argument_list|)
argument_list|,
name|eeprom
operator|->
name|address_bits
argument_list|)
expr_stmt|;
comment|/* Read the data.  The address of the eeprom internally increments with          * each byte (spi) being read, saving on the overhead of eeprom setup          * and tear-down.  The address counter will roll over if reading beyond          * the size of the eeprom, thus allowing the entire memory to be read          * starting from any offset. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|words
condition|;
name|i
operator|++
control|)
block|{
name|word_in
operator|=
name|em_shift_in_ee_bits
argument_list|(
name|hw
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|data
index|[
name|i
index|]
operator|=
operator|(
name|word_in
operator|>>
literal|8
operator|)
operator||
operator|(
name|word_in
operator|<<
literal|8
operator|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|eeprom
operator|->
name|type
operator|==
name|em_eeprom_microwire
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|words
condition|;
name|i
operator|++
control|)
block|{
comment|/* Send the READ command (opcode + addr)  */
name|em_shift_out_ee_bits
argument_list|(
name|hw
argument_list|,
name|EEPROM_READ_OPCODE_MICROWIRE
argument_list|,
name|eeprom
operator|->
name|opcode_bits
argument_list|)
expr_stmt|;
name|em_shift_out_ee_bits
argument_list|(
name|hw
argument_list|,
call|(
name|uint16_t
call|)
argument_list|(
name|offset
operator|+
name|i
argument_list|)
argument_list|,
name|eeprom
operator|->
name|address_bits
argument_list|)
expr_stmt|;
comment|/* Read the data.  For microwire, each word requires the overhead              * of eeprom setup and tear-down. */
name|data
index|[
name|i
index|]
operator|=
name|em_shift_in_ee_bits
argument_list|(
name|hw
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|em_standby_eeprom
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* End this read operation */
name|em_release_eeprom
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Reads a 16 bit word from the EEPROM using the EERD register.  *  * hw - Struct containing variables accessed by shared code  * offset - offset of  word in the EEPROM to read  * data - word read from the EEPROM  * words - number of words to read  *****************************************************************************/
end_comment

begin_function
name|STATIC
name|int32_t
name|em_read_eeprom_eerd
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint16_t
name|offset
parameter_list|,
name|uint16_t
name|words
parameter_list|,
name|uint16_t
modifier|*
name|data
parameter_list|)
block|{
name|uint32_t
name|i
decl_stmt|,
name|eerd
init|=
literal|0
decl_stmt|;
name|int32_t
name|error
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|words
condition|;
name|i
operator|++
control|)
block|{
name|eerd
operator|=
operator|(
operator|(
name|offset
operator|+
name|i
operator|)
operator|<<
name|E1000_EEPROM_RW_ADDR_SHIFT
operator|)
operator|+
name|E1000_EEPROM_RW_REG_START
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|EERD
argument_list|,
name|eerd
argument_list|)
expr_stmt|;
name|error
operator|=
name|em_poll_eerd_eewr_done
argument_list|(
name|hw
argument_list|,
name|E1000_EEPROM_POLL_READ
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
break|break;
block|}
name|data
index|[
name|i
index|]
operator|=
operator|(
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|EERD
argument_list|)
operator|>>
name|E1000_EEPROM_RW_REG_DATA
operator|)
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Writes a 16 bit word from the EEPROM using the EEWR register.  *  * hw - Struct containing variables accessed by shared code  * offset - offset of  word in the EEPROM to read  * data - word read from the EEPROM  * words - number of words to read  *****************************************************************************/
end_comment

begin_function
name|STATIC
name|int32_t
name|em_write_eeprom_eewr
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint16_t
name|offset
parameter_list|,
name|uint16_t
name|words
parameter_list|,
name|uint16_t
modifier|*
name|data
parameter_list|)
block|{
name|uint32_t
name|register_value
init|=
literal|0
decl_stmt|;
name|uint32_t
name|i
init|=
literal|0
decl_stmt|;
name|int32_t
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|em_swfw_sync_acquire
argument_list|(
name|hw
argument_list|,
name|E1000_SWFW_EEP_SM
argument_list|)
condition|)
return|return
operator|-
name|E1000_ERR_SWFW_SYNC
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|words
condition|;
name|i
operator|++
control|)
block|{
name|register_value
operator|=
operator|(
name|data
index|[
name|i
index|]
operator|<<
name|E1000_EEPROM_RW_REG_DATA
operator|)
operator||
operator|(
operator|(
name|offset
operator|+
name|i
operator|)
operator|<<
name|E1000_EEPROM_RW_ADDR_SHIFT
operator|)
operator||
name|E1000_EEPROM_RW_REG_START
expr_stmt|;
name|error
operator|=
name|em_poll_eerd_eewr_done
argument_list|(
name|hw
argument_list|,
name|E1000_EEPROM_POLL_WRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
break|break;
block|}
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|EEWR
argument_list|,
name|register_value
argument_list|)
expr_stmt|;
name|error
operator|=
name|em_poll_eerd_eewr_done
argument_list|(
name|hw
argument_list|,
name|E1000_EEPROM_POLL_WRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
break|break;
block|}
block|}
name|em_swfw_sync_release
argument_list|(
name|hw
argument_list|,
name|E1000_SWFW_EEP_SM
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Polls the status bit (bit 1) of the EERD to determine when the read is done.  *  * hw - Struct containing variables accessed by shared code  *****************************************************************************/
end_comment

begin_function
name|STATIC
name|int32_t
name|em_poll_eerd_eewr_done
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|int
name|eerd
parameter_list|)
block|{
name|uint32_t
name|attempts
init|=
literal|100000
decl_stmt|;
name|uint32_t
name|i
decl_stmt|,
name|reg
init|=
literal|0
decl_stmt|;
name|int32_t
name|done
init|=
name|E1000_ERR_EEPROM
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|attempts
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|eerd
operator|==
name|E1000_EEPROM_POLL_READ
condition|)
name|reg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|EERD
argument_list|)
expr_stmt|;
else|else
name|reg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|EEWR
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|&
name|E1000_EEPROM_RW_REG_DONE
condition|)
block|{
name|done
operator|=
name|E1000_SUCCESS
expr_stmt|;
break|break;
block|}
name|usec_delay
argument_list|(
literal|5
argument_list|)
expr_stmt|;
block|}
return|return
name|done
return|;
block|}
end_function

begin_comment
comment|/*************************************************************************** * Description:     Determines if the onboard NVM is FLASH or EEPROM. * * hw - Struct containing variables accessed by shared code ****************************************************************************/
end_comment

begin_function
name|STATIC
name|boolean_t
name|em_is_onboard_nvm_eeprom
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|uint32_t
name|eecd
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_is_onboard_nvm_eeprom"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|==
name|em_ich8lan
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|==
name|em_82573
condition|)
block|{
name|eecd
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|EECD
argument_list|)
expr_stmt|;
comment|/* Isolate bits 15& 16 */
name|eecd
operator|=
operator|(
operator|(
name|eecd
operator|>>
literal|15
operator|)
operator|&
literal|0x03
operator|)
expr_stmt|;
comment|/* If both bits are set, device is Flash type */
if|if
condition|(
name|eecd
operator|==
literal|0x03
condition|)
block|{
return|return
name|FALSE
return|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Verifies that the EEPROM has a valid checksum  *  * hw - Struct containing variables accessed by shared code  *  * Reads the first 64 16 bit words of the EEPROM and sums the values read.  * If the the sum of the 64 16 bit words is 0xBABA, the EEPROM's checksum is  * valid.  *****************************************************************************/
end_comment

begin_function
name|int32_t
name|em_validate_eeprom_checksum
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|uint16_t
name|checksum
init|=
literal|0
decl_stmt|;
name|uint16_t
name|i
decl_stmt|,
name|eeprom_data
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_validate_eeprom_checksum"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|hw
operator|->
name|mac_type
operator|==
name|em_82573
operator|)
operator|&&
operator|(
name|em_is_onboard_nvm_eeprom
argument_list|(
name|hw
argument_list|)
operator|==
name|FALSE
operator|)
condition|)
block|{
comment|/* Check bit 4 of word 10h.  If it is 0, firmware is done updating          * 10h-12h.  Checksum may need to be fixed. */
name|em_read_eeprom
argument_list|(
name|hw
argument_list|,
literal|0x10
argument_list|,
literal|1
argument_list|,
operator|&
name|eeprom_data
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|eeprom_data
operator|&
literal|0x10
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Read 0x23 and check bit 15.  This bit is a 1 when the checksum              * has already been fixed.  If the checksum is still wrong and this              * bit is a 1, we need to return bad checksum.  Otherwise, we need              * to set this bit to a 1 and update the checksum. */
name|em_read_eeprom
argument_list|(
name|hw
argument_list|,
literal|0x23
argument_list|,
literal|1
argument_list|,
operator|&
name|eeprom_data
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|eeprom_data
operator|&
literal|0x8000
operator|)
operator|==
literal|0
condition|)
block|{
name|eeprom_data
operator||=
literal|0x8000
expr_stmt|;
name|em_write_eeprom
argument_list|(
name|hw
argument_list|,
literal|0x23
argument_list|,
literal|1
argument_list|,
operator|&
name|eeprom_data
argument_list|)
expr_stmt|;
name|em_update_eeprom_checksum
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|==
name|em_ich8lan
condition|)
block|{
comment|/* Drivers must allocate the shadow ram structure for the          * EEPROM checksum to be updated.  Otherwise, this bit as well          * as the checksum must both be set correctly for this          * validation to pass.          */
name|em_read_eeprom
argument_list|(
name|hw
argument_list|,
literal|0x19
argument_list|,
literal|1
argument_list|,
operator|&
name|eeprom_data
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|eeprom_data
operator|&
literal|0x40
operator|)
operator|==
literal|0
condition|)
block|{
name|eeprom_data
operator||=
literal|0x40
expr_stmt|;
name|em_write_eeprom
argument_list|(
name|hw
argument_list|,
literal|0x19
argument_list|,
literal|1
argument_list|,
operator|&
name|eeprom_data
argument_list|)
expr_stmt|;
name|em_update_eeprom_checksum
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|EEPROM_CHECKSUM_REG
operator|+
literal|1
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|em_read_eeprom
argument_list|(
name|hw
argument_list|,
name|i
argument_list|,
literal|1
argument_list|,
operator|&
name|eeprom_data
argument_list|)
operator|<
literal|0
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"EEPROM Read Error\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_EEPROM
return|;
block|}
name|checksum
operator|+=
name|eeprom_data
expr_stmt|;
block|}
if|if
condition|(
name|checksum
operator|==
operator|(
name|uint16_t
operator|)
name|EEPROM_SUM
condition|)
return|return
name|E1000_SUCCESS
return|;
else|else
block|{
name|DEBUGOUT
argument_list|(
literal|"EEPROM Checksum Invalid\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_EEPROM
return|;
block|}
block|}
end_function

begin_comment
comment|/******************************************************************************  * Calculates the EEPROM checksum and writes it to the EEPROM  *  * hw - Struct containing variables accessed by shared code  *  * Sums the first 63 16 bit words of the EEPROM. Subtracts the sum from 0xBABA.  * Writes the difference to word offset 63 of the EEPROM.  *****************************************************************************/
end_comment

begin_function
name|int32_t
name|em_update_eeprom_checksum
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|uint32_t
name|ctrl_ext
decl_stmt|;
name|uint16_t
name|checksum
init|=
literal|0
decl_stmt|;
name|uint16_t
name|i
decl_stmt|,
name|eeprom_data
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_update_eeprom_checksum"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|EEPROM_CHECKSUM_REG
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|em_read_eeprom
argument_list|(
name|hw
argument_list|,
name|i
argument_list|,
literal|1
argument_list|,
operator|&
name|eeprom_data
argument_list|)
operator|<
literal|0
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"EEPROM Read Error\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_EEPROM
return|;
block|}
name|checksum
operator|+=
name|eeprom_data
expr_stmt|;
block|}
name|checksum
operator|=
operator|(
name|uint16_t
operator|)
name|EEPROM_SUM
operator|-
name|checksum
expr_stmt|;
if|if
condition|(
name|em_write_eeprom
argument_list|(
name|hw
argument_list|,
name|EEPROM_CHECKSUM_REG
argument_list|,
literal|1
argument_list|,
operator|&
name|checksum
argument_list|)
operator|<
literal|0
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"EEPROM Write Error\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_EEPROM
return|;
block|}
elseif|else
if|if
condition|(
name|hw
operator|->
name|eeprom
operator|.
name|type
operator|==
name|em_eeprom_flash
condition|)
block|{
name|em_commit_shadow_ram
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|hw
operator|->
name|eeprom
operator|.
name|type
operator|==
name|em_eeprom_ich8
condition|)
block|{
name|em_commit_shadow_ram
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Reload the EEPROM, or else modifications will not appear          * until after next adapter reset. */
name|ctrl_ext
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|CTRL_EXT
argument_list|)
expr_stmt|;
name|ctrl_ext
operator||=
name|E1000_CTRL_EXT_EE_RST
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|CTRL_EXT
argument_list|,
name|ctrl_ext
argument_list|)
expr_stmt|;
name|msec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Parent function for writing words to the different EEPROM types.  *  * hw - Struct containing variables accessed by shared code  * offset - offset within the EEPROM to be written to  * words - number of words to write  * data - 16 bit word to be written to the EEPROM  *  * If em_update_eeprom_checksum is not called after this function, the  * EEPROM will most likely contain an invalid checksum.  *****************************************************************************/
end_comment

begin_function
name|int32_t
name|em_write_eeprom
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint16_t
name|offset
parameter_list|,
name|uint16_t
name|words
parameter_list|,
name|uint16_t
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|em_eeprom_info
modifier|*
name|eeprom
init|=
operator|&
name|hw
operator|->
name|eeprom
decl_stmt|;
name|int32_t
name|status
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_write_eeprom"
argument_list|)
expr_stmt|;
comment|/* If eeprom is not yet detected, do so now */
if|if
condition|(
name|eeprom
operator|->
name|word_size
operator|==
literal|0
condition|)
name|em_init_eeprom_params
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* A check for invalid values:  offset too large, too many words, and not      * enough words.      */
if|if
condition|(
operator|(
name|offset
operator|>=
name|eeprom
operator|->
name|word_size
operator|)
operator|||
operator|(
name|words
operator|>
name|eeprom
operator|->
name|word_size
operator|-
name|offset
operator|)
operator|||
operator|(
name|words
operator|==
literal|0
operator|)
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"\"words\" parameter out of bounds\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_EEPROM
return|;
block|}
comment|/* 82573 writes only through eewr */
if|if
condition|(
name|eeprom
operator|->
name|use_eewr
operator|==
name|TRUE
condition|)
return|return
name|em_write_eeprom_eewr
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
name|words
argument_list|,
name|data
argument_list|)
return|;
if|if
condition|(
name|eeprom
operator|->
name|type
operator|==
name|em_eeprom_ich8
condition|)
return|return
name|em_write_eeprom_ich8
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
name|words
argument_list|,
name|data
argument_list|)
return|;
comment|/* Prepare the EEPROM for writing  */
if|if
condition|(
name|em_acquire_eeprom
argument_list|(
name|hw
argument_list|)
operator|!=
name|E1000_SUCCESS
condition|)
return|return
operator|-
name|E1000_ERR_EEPROM
return|;
if|if
condition|(
name|eeprom
operator|->
name|type
operator|==
name|em_eeprom_microwire
condition|)
block|{
name|status
operator|=
name|em_write_eeprom_microwire
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
name|words
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|status
operator|=
name|em_write_eeprom_spi
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
name|words
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|msec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
comment|/* Done with writing */
name|em_release_eeprom
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Writes a 16 bit word to a given offset in an SPI EEPROM.  *  * hw - Struct containing variables accessed by shared code  * offset - offset within the EEPROM to be written to  * words - number of words to write  * data - pointer to array of 8 bit words to be written to the EEPROM  *  *****************************************************************************/
end_comment

begin_function
name|STATIC
name|int32_t
name|em_write_eeprom_spi
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint16_t
name|offset
parameter_list|,
name|uint16_t
name|words
parameter_list|,
name|uint16_t
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|em_eeprom_info
modifier|*
name|eeprom
init|=
operator|&
name|hw
operator|->
name|eeprom
decl_stmt|;
name|uint16_t
name|widx
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_write_eeprom_spi"
argument_list|)
expr_stmt|;
while|while
condition|(
name|widx
operator|<
name|words
condition|)
block|{
name|uint8_t
name|write_opcode
init|=
name|EEPROM_WRITE_OPCODE_SPI
decl_stmt|;
if|if
condition|(
name|em_spi_eeprom_ready
argument_list|(
name|hw
argument_list|)
condition|)
return|return
operator|-
name|E1000_ERR_EEPROM
return|;
name|em_standby_eeprom
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/*  Send the WRITE ENABLE command (8 bit opcode )  */
name|em_shift_out_ee_bits
argument_list|(
name|hw
argument_list|,
name|EEPROM_WREN_OPCODE_SPI
argument_list|,
name|eeprom
operator|->
name|opcode_bits
argument_list|)
expr_stmt|;
name|em_standby_eeprom
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Some SPI eeproms use the 8th address bit embedded in the opcode */
if|if
condition|(
operator|(
name|eeprom
operator|->
name|address_bits
operator|==
literal|8
operator|)
operator|&&
operator|(
name|offset
operator|>=
literal|128
operator|)
condition|)
name|write_opcode
operator||=
name|EEPROM_A8_OPCODE_SPI
expr_stmt|;
comment|/* Send the Write command (8-bit opcode + addr) */
name|em_shift_out_ee_bits
argument_list|(
name|hw
argument_list|,
name|write_opcode
argument_list|,
name|eeprom
operator|->
name|opcode_bits
argument_list|)
expr_stmt|;
name|em_shift_out_ee_bits
argument_list|(
name|hw
argument_list|,
call|(
name|uint16_t
call|)
argument_list|(
operator|(
name|offset
operator|+
name|widx
operator|)
operator|*
literal|2
argument_list|)
argument_list|,
name|eeprom
operator|->
name|address_bits
argument_list|)
expr_stmt|;
comment|/* Send the data */
comment|/* Loop to allow for up to whole page write (32 bytes) of eeprom */
while|while
condition|(
name|widx
operator|<
name|words
condition|)
block|{
name|uint16_t
name|word_out
init|=
name|data
index|[
name|widx
index|]
decl_stmt|;
name|word_out
operator|=
operator|(
name|word_out
operator|>>
literal|8
operator|)
operator||
operator|(
name|word_out
operator|<<
literal|8
operator|)
expr_stmt|;
name|em_shift_out_ee_bits
argument_list|(
name|hw
argument_list|,
name|word_out
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|widx
operator|++
expr_stmt|;
comment|/* Some larger eeprom sizes are capable of a 32-byte PAGE WRITE              * operation, while the smaller eeproms are capable of an 8-byte              * PAGE WRITE operation.  Break the inner loop to pass new address              */
if|if
condition|(
operator|(
operator|(
operator|(
name|offset
operator|+
name|widx
operator|)
operator|*
literal|2
operator|)
operator|%
name|eeprom
operator|->
name|page_size
operator|)
operator|==
literal|0
condition|)
block|{
name|em_standby_eeprom
argument_list|(
name|hw
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Writes a 16 bit word to a given offset in a Microwire EEPROM.  *  * hw - Struct containing variables accessed by shared code  * offset - offset within the EEPROM to be written to  * words - number of words to write  * data - pointer to array of 16 bit words to be written to the EEPROM  *  *****************************************************************************/
end_comment

begin_function
name|STATIC
name|int32_t
name|em_write_eeprom_microwire
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint16_t
name|offset
parameter_list|,
name|uint16_t
name|words
parameter_list|,
name|uint16_t
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|em_eeprom_info
modifier|*
name|eeprom
init|=
operator|&
name|hw
operator|->
name|eeprom
decl_stmt|;
name|uint32_t
name|eecd
decl_stmt|;
name|uint16_t
name|words_written
init|=
literal|0
decl_stmt|;
name|uint16_t
name|i
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_write_eeprom_microwire"
argument_list|)
expr_stmt|;
comment|/* Send the write enable command to the EEPROM (3-bit opcode plus      * 6/8-bit dummy address beginning with 11).  It's less work to include      * the 11 of the dummy address as part of the opcode than it is to shift      * it over the correct number of bits for the address.  This puts the      * EEPROM into write/erase mode.      */
name|em_shift_out_ee_bits
argument_list|(
name|hw
argument_list|,
name|EEPROM_EWEN_OPCODE_MICROWIRE
argument_list|,
call|(
name|uint16_t
call|)
argument_list|(
name|eeprom
operator|->
name|opcode_bits
operator|+
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|em_shift_out_ee_bits
argument_list|(
name|hw
argument_list|,
literal|0
argument_list|,
call|(
name|uint16_t
call|)
argument_list|(
name|eeprom
operator|->
name|address_bits
operator|-
literal|2
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Prepare the EEPROM */
name|em_standby_eeprom
argument_list|(
name|hw
argument_list|)
expr_stmt|;
while|while
condition|(
name|words_written
operator|<
name|words
condition|)
block|{
comment|/* Send the Write command (3-bit opcode + addr) */
name|em_shift_out_ee_bits
argument_list|(
name|hw
argument_list|,
name|EEPROM_WRITE_OPCODE_MICROWIRE
argument_list|,
name|eeprom
operator|->
name|opcode_bits
argument_list|)
expr_stmt|;
name|em_shift_out_ee_bits
argument_list|(
name|hw
argument_list|,
call|(
name|uint16_t
call|)
argument_list|(
name|offset
operator|+
name|words_written
argument_list|)
argument_list|,
name|eeprom
operator|->
name|address_bits
argument_list|)
expr_stmt|;
comment|/* Send the data */
name|em_shift_out_ee_bits
argument_list|(
name|hw
argument_list|,
name|data
index|[
name|words_written
index|]
argument_list|,
literal|16
argument_list|)
expr_stmt|;
comment|/* Toggle the CS line.  This in effect tells the EEPROM to execute          * the previous command.          */
name|em_standby_eeprom
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Read DO repeatedly until it is high (equal to '1').  The EEPROM will          * signal that the command has been completed by raising the DO signal.          * If DO does not go high in 10 milliseconds, then error out.          */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|200
condition|;
name|i
operator|++
control|)
block|{
name|eecd
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|EECD
argument_list|)
expr_stmt|;
if|if
condition|(
name|eecd
operator|&
name|E1000_EECD_DO
condition|)
break|break;
name|usec_delay
argument_list|(
literal|50
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
literal|200
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"EEPROM Write did not complete\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_EEPROM
return|;
block|}
comment|/* Recover from write */
name|em_standby_eeprom
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|words_written
operator|++
expr_stmt|;
block|}
comment|/* Send the write disable command to the EEPROM (3-bit opcode plus      * 6/8-bit dummy address beginning with 10).  It's less work to include      * the 10 of the dummy address as part of the opcode than it is to shift      * it over the correct number of bits for the address.  This takes the      * EEPROM out of write/erase mode.      */
name|em_shift_out_ee_bits
argument_list|(
name|hw
argument_list|,
name|EEPROM_EWDS_OPCODE_MICROWIRE
argument_list|,
call|(
name|uint16_t
call|)
argument_list|(
name|eeprom
operator|->
name|opcode_bits
operator|+
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|em_shift_out_ee_bits
argument_list|(
name|hw
argument_list|,
literal|0
argument_list|,
call|(
name|uint16_t
call|)
argument_list|(
name|eeprom
operator|->
name|address_bits
operator|-
literal|2
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Flushes the cached eeprom to NVM. This is done by saving the modified values  * in the eeprom cache and the non modified values in the currently active bank  * to the new bank.  *  * hw - Struct containing variables accessed by shared code  * offset - offset of  word in the EEPROM to read  * data - word read from the EEPROM  * words - number of words to read  *****************************************************************************/
end_comment

begin_function
name|STATIC
name|int32_t
name|em_commit_shadow_ram
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|uint32_t
name|attempts
init|=
literal|100000
decl_stmt|;
name|uint32_t
name|eecd
init|=
literal|0
decl_stmt|;
name|uint32_t
name|flop
init|=
literal|0
decl_stmt|;
name|uint32_t
name|i
init|=
literal|0
decl_stmt|;
name|int32_t
name|error
init|=
name|E1000_SUCCESS
decl_stmt|;
name|uint32_t
name|old_bank_offset
init|=
literal|0
decl_stmt|;
name|uint32_t
name|new_bank_offset
init|=
literal|0
decl_stmt|;
name|uint8_t
name|low_byte
init|=
literal|0
decl_stmt|;
name|uint8_t
name|high_byte
init|=
literal|0
decl_stmt|;
name|boolean_t
name|sector_write_failed
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|==
name|em_82573
condition|)
block|{
comment|/* The flop register will be used to determine if flash type is STM */
name|flop
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|FLOP
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|attempts
condition|;
name|i
operator|++
control|)
block|{
name|eecd
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|EECD
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|eecd
operator|&
name|E1000_EECD_FLUPD
operator|)
operator|==
literal|0
condition|)
block|{
break|break;
block|}
name|usec_delay
argument_list|(
literal|5
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
name|attempts
condition|)
block|{
return|return
operator|-
name|E1000_ERR_EEPROM
return|;
block|}
comment|/* If STM opcode located in bits 15:8 of flop, reset firmware */
if|if
condition|(
operator|(
name|flop
operator|&
literal|0xFF00
operator|)
operator|==
name|E1000_STM_OPCODE
condition|)
block|{
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|HICR
argument_list|,
name|E1000_HICR_FW_RESET
argument_list|)
expr_stmt|;
block|}
comment|/* Perform the flash update */
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|EECD
argument_list|,
name|eecd
operator||
name|E1000_EECD_FLUPD
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|attempts
condition|;
name|i
operator|++
control|)
block|{
name|eecd
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|EECD
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|eecd
operator|&
name|E1000_EECD_FLUPD
operator|)
operator|==
literal|0
condition|)
block|{
break|break;
block|}
name|usec_delay
argument_list|(
literal|5
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
name|attempts
condition|)
block|{
return|return
operator|-
name|E1000_ERR_EEPROM
return|;
block|}
block|}
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|==
name|em_ich8lan
operator|&&
name|hw
operator|->
name|eeprom_shadow_ram
operator|!=
name|NULL
condition|)
block|{
comment|/* We're writing to the opposite bank so if we're on bank 1,          * write to bank 0 etc.  We also need to erase the segment that          * is going to be written */
if|if
condition|(
operator|!
operator|(
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|EECD
argument_list|)
operator|&
name|E1000_EECD_SEC1VAL
operator|)
condition|)
block|{
name|new_bank_offset
operator|=
name|hw
operator|->
name|flash_bank_size
operator|*
literal|2
expr_stmt|;
name|old_bank_offset
operator|=
literal|0
expr_stmt|;
name|em_erase_ich8_4k_segment
argument_list|(
name|hw
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|old_bank_offset
operator|=
name|hw
operator|->
name|flash_bank_size
operator|*
literal|2
expr_stmt|;
name|new_bank_offset
operator|=
literal|0
expr_stmt|;
name|em_erase_ich8_4k_segment
argument_list|(
name|hw
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|sector_write_failed
operator|=
name|FALSE
expr_stmt|;
comment|/* Loop for every byte in the shadow RAM,          * which is in units of words. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|E1000_SHADOW_RAM_WORDS
condition|;
name|i
operator|++
control|)
block|{
comment|/* Determine whether to write the value stored              * in the other NVM bank or a modified value stored              * in the shadow RAM */
if|if
condition|(
name|hw
operator|->
name|eeprom_shadow_ram
index|[
name|i
index|]
operator|.
name|modified
operator|==
name|TRUE
condition|)
block|{
name|low_byte
operator|=
operator|(
name|uint8_t
operator|)
name|hw
operator|->
name|eeprom_shadow_ram
index|[
name|i
index|]
operator|.
name|eeprom_word
expr_stmt|;
name|usec_delay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|error
operator|=
name|em_verify_write_ich8_byte
argument_list|(
name|hw
argument_list|,
operator|(
name|i
operator|<<
literal|1
operator|)
operator|+
name|new_bank_offset
argument_list|,
name|low_byte
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|E1000_SUCCESS
condition|)
name|sector_write_failed
operator|=
name|TRUE
expr_stmt|;
else|else
block|{
name|high_byte
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|hw
operator|->
name|eeprom_shadow_ram
index|[
name|i
index|]
operator|.
name|eeprom_word
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|em_read_ich8_byte
argument_list|(
name|hw
argument_list|,
operator|(
name|i
operator|<<
literal|1
operator|)
operator|+
name|old_bank_offset
argument_list|,
operator|&
name|low_byte
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|error
operator|=
name|em_verify_write_ich8_byte
argument_list|(
name|hw
argument_list|,
operator|(
name|i
operator|<<
literal|1
operator|)
operator|+
name|new_bank_offset
argument_list|,
name|low_byte
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|E1000_SUCCESS
condition|)
name|sector_write_failed
operator|=
name|TRUE
expr_stmt|;
else|else
block|{
name|em_read_ich8_byte
argument_list|(
name|hw
argument_list|,
operator|(
name|i
operator|<<
literal|1
operator|)
operator|+
name|old_bank_offset
operator|+
literal|1
argument_list|,
operator|&
name|high_byte
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If the write of the low byte was successful, go ahread and              * write the high byte while checking to make sure that if it              * is the signature byte, then it is handled properly */
if|if
condition|(
name|sector_write_failed
operator|==
name|FALSE
condition|)
block|{
comment|/* If the word is 0x13, then make sure the signature bits                  * (15:14) are 11b until the commit has completed.                  * This will allow us to write 10b which indicates the                  * signature is valid.  We want to do this after the write                  * has completed so that we don't mark the segment valid                  * while the write is still in progress */
if|if
condition|(
name|i
operator|==
name|E1000_ICH_NVM_SIG_WORD
condition|)
name|high_byte
operator|=
name|E1000_ICH_NVM_SIG_MASK
operator||
name|high_byte
expr_stmt|;
name|error
operator|=
name|em_verify_write_ich8_byte
argument_list|(
name|hw
argument_list|,
operator|(
name|i
operator|<<
literal|1
operator|)
operator|+
name|new_bank_offset
operator|+
literal|1
argument_list|,
name|high_byte
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|E1000_SUCCESS
condition|)
name|sector_write_failed
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
comment|/* If the write failed then break from the loop and                  * return an error */
break|break;
block|}
block|}
comment|/* Don't bother writing the segment valid bits if sector          * programming failed. */
if|if
condition|(
name|sector_write_failed
operator|==
name|FALSE
condition|)
block|{
comment|/* Finally validate the new segment by setting bit 15:14              * to 10b in word 0x13 , this can be done without an              * erase as well since these bits are 11 to start with              * and we need to change bit 14 to 0b */
name|em_read_ich8_byte
argument_list|(
name|hw
argument_list|,
name|E1000_ICH_NVM_SIG_WORD
operator|*
literal|2
operator|+
literal|1
operator|+
name|new_bank_offset
argument_list|,
operator|&
name|high_byte
argument_list|)
expr_stmt|;
name|high_byte
operator|&=
literal|0xBF
expr_stmt|;
name|error
operator|=
name|em_verify_write_ich8_byte
argument_list|(
name|hw
argument_list|,
name|E1000_ICH_NVM_SIG_WORD
operator|*
literal|2
operator|+
literal|1
operator|+
name|new_bank_offset
argument_list|,
name|high_byte
argument_list|)
expr_stmt|;
comment|/* And invalidate the previously valid segment by setting              * its signature word (0x13) high_byte to 0b. This can be              * done without an erase because flash erase sets all bits              * to 1's. We can write 1's to 0's without an erase */
if|if
condition|(
name|error
operator|==
name|E1000_SUCCESS
condition|)
block|{
name|error
operator|=
name|em_verify_write_ich8_byte
argument_list|(
name|hw
argument_list|,
name|E1000_ICH_NVM_SIG_WORD
operator|*
literal|2
operator|+
literal|1
operator|+
name|old_bank_offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Clear the now not used entry in the cache */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|E1000_SHADOW_RAM_WORDS
condition|;
name|i
operator|++
control|)
block|{
name|hw
operator|->
name|eeprom_shadow_ram
index|[
name|i
index|]
operator|.
name|modified
operator|=
name|FALSE
expr_stmt|;
name|hw
operator|->
name|eeprom_shadow_ram
index|[
name|i
index|]
operator|.
name|eeprom_word
operator|=
literal|0xFFFF
expr_stmt|;
block|}
block|}
block|}
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Reads the adapter's part number from the EEPROM  *  * hw - Struct containing variables accessed by shared code  * part_num - Adapter's part number  *****************************************************************************/
end_comment

begin_function
name|int32_t
name|em_read_part_num
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint32_t
modifier|*
name|part_num
parameter_list|)
block|{
name|uint16_t
name|offset
init|=
name|EEPROM_PBA_BYTE_1
decl_stmt|;
name|uint16_t
name|eeprom_data
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_read_part_num"
argument_list|)
expr_stmt|;
comment|/* Get word 0 from EEPROM */
if|if
condition|(
name|em_read_eeprom
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
literal|1
argument_list|,
operator|&
name|eeprom_data
argument_list|)
operator|<
literal|0
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"EEPROM Read Error\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_EEPROM
return|;
block|}
comment|/* Save word 0 in upper half of part_num */
operator|*
name|part_num
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|eeprom_data
operator|<<
literal|16
argument_list|)
expr_stmt|;
comment|/* Get word 1 from EEPROM */
if|if
condition|(
name|em_read_eeprom
argument_list|(
name|hw
argument_list|,
operator|++
name|offset
argument_list|,
literal|1
argument_list|,
operator|&
name|eeprom_data
argument_list|)
operator|<
literal|0
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"EEPROM Read Error\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_EEPROM
return|;
block|}
comment|/* Save word 1 in lower half of part_num */
operator|*
name|part_num
operator||=
name|eeprom_data
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Reads the adapter's MAC address from the EEPROM and inverts the LSB for the  * second function of dual function devices  *  * hw - Struct containing variables accessed by shared code  *****************************************************************************/
end_comment

begin_function
name|int32_t
name|em_read_mac_addr
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|uint16_t
name|offset
decl_stmt|;
name|uint16_t
name|eeprom_data
decl_stmt|,
name|i
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_read_mac_addr"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NODE_ADDRESS_SIZE
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|offset
operator|=
name|i
operator|>>
literal|1
expr_stmt|;
if|if
condition|(
name|em_read_eeprom
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
literal|1
argument_list|,
operator|&
name|eeprom_data
argument_list|)
operator|<
literal|0
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"EEPROM Read Error\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_EEPROM
return|;
block|}
name|hw
operator|->
name|perm_mac_addr
index|[
name|i
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|eeprom_data
operator|&
literal|0x00FF
argument_list|)
expr_stmt|;
name|hw
operator|->
name|perm_mac_addr
index|[
name|i
operator|+
literal|1
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|eeprom_data
operator|>>
literal|8
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|hw
operator|->
name|mac_type
condition|)
block|{
default|default:
break|break;
case|case
name|em_82546
case|:
case|case
name|em_82546_rev_3
case|:
case|case
name|em_82571
case|:
case|case
name|em_80003es2lan
case|:
if|if
condition|(
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|STATUS
argument_list|)
operator|&
name|E1000_STATUS_FUNC_1
condition|)
name|hw
operator|->
name|perm_mac_addr
index|[
literal|5
index|]
operator|^=
literal|0x01
expr_stmt|;
break|break;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NODE_ADDRESS_SIZE
condition|;
name|i
operator|++
control|)
name|hw
operator|->
name|mac_addr
index|[
name|i
index|]
operator|=
name|hw
operator|->
name|perm_mac_addr
index|[
name|i
index|]
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Initializes receive address filters.  *  * hw - Struct containing variables accessed by shared code  *  * Places the MAC address in receive address register 0 and clears the rest  * of the receive addresss registers. Clears the multicast table. Assumes  * the receiver is in reset when the routine is called.  *****************************************************************************/
end_comment

begin_function
name|STATIC
name|void
name|em_init_rx_addrs
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|uint32_t
name|i
decl_stmt|;
name|uint32_t
name|rar_num
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_init_rx_addrs"
argument_list|)
expr_stmt|;
comment|/* Setup the receive address. */
name|DEBUGOUT
argument_list|(
literal|"Programming MAC Address into RAR[0]\n"
argument_list|)
expr_stmt|;
name|em_rar_set
argument_list|(
name|hw
argument_list|,
name|hw
operator|->
name|mac_addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rar_num
operator|=
name|E1000_RAR_ENTRIES
expr_stmt|;
comment|/* Reserve a spot for the Locally Administered Address to work around      * an 82571 issue in which a reset on one port will reload the MAC on      * the other port. */
if|if
condition|(
operator|(
name|hw
operator|->
name|mac_type
operator|==
name|em_82571
operator|)
operator|&&
operator|(
name|hw
operator|->
name|laa_is_present
operator|==
name|TRUE
operator|)
condition|)
name|rar_num
operator|-=
literal|1
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|==
name|em_ich8lan
condition|)
name|rar_num
operator|=
name|E1000_RAR_ENTRIES_ICH8LAN
expr_stmt|;
comment|/* Zero out the other 15 receive addresses. */
name|DEBUGOUT
argument_list|(
literal|"Clearing RAR[1-15]\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|rar_num
condition|;
name|i
operator|++
control|)
block|{
name|E1000_WRITE_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|RA
argument_list|,
operator|(
name|i
operator|<<
literal|1
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|RA
argument_list|,
operator|(
operator|(
name|i
operator|<<
literal|1
operator|)
operator|+
literal|1
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/******************************************************************************  * Updates the MAC's list of multicast addresses.  *  * hw - Struct containing variables accessed by shared code  * mc_addr_list - the list of new multicast addresses  * mc_addr_count - number of addresses  * pad - number of bytes between addresses in the list  * rar_used_count - offset where to start adding mc addresses into the RAR's  *  * The given list replaces any existing list. Clears the last 15 receive  * address registers and the multicast table. Uses receive address registers  * for the first 15 multicast addresses, and hashes the rest into the  * multicast table.  *****************************************************************************/
end_comment

begin_function
name|void
name|em_mc_addr_list_update
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint8_t
modifier|*
name|mc_addr_list
parameter_list|,
name|uint32_t
name|mc_addr_count
parameter_list|,
name|uint32_t
name|pad
parameter_list|,
name|uint32_t
name|rar_used_count
parameter_list|)
block|{
name|uint32_t
name|hash_value
decl_stmt|;
name|uint32_t
name|i
decl_stmt|;
name|uint32_t
name|num_rar_entry
decl_stmt|;
name|uint32_t
name|num_mta_entry
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_mc_addr_list_update"
argument_list|)
expr_stmt|;
comment|/* Set the new number of MC addresses that we are being requested to use. */
name|hw
operator|->
name|num_mc_addrs
operator|=
name|mc_addr_count
expr_stmt|;
comment|/* Clear RAR[1-15] */
name|DEBUGOUT
argument_list|(
literal|" Clearing RAR[1-15]\n"
argument_list|)
expr_stmt|;
name|num_rar_entry
operator|=
name|E1000_RAR_ENTRIES
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|==
name|em_ich8lan
condition|)
name|num_rar_entry
operator|=
name|E1000_RAR_ENTRIES_ICH8LAN
expr_stmt|;
comment|/* Reserve a spot for the Locally Administered Address to work around      * an 82571 issue in which a reset on one port will reload the MAC on      * the other port. */
if|if
condition|(
operator|(
name|hw
operator|->
name|mac_type
operator|==
name|em_82571
operator|)
operator|&&
operator|(
name|hw
operator|->
name|laa_is_present
operator|==
name|TRUE
operator|)
condition|)
name|num_rar_entry
operator|-=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
name|rar_used_count
init|;
name|i
operator|<
name|num_rar_entry
condition|;
name|i
operator|++
control|)
block|{
name|E1000_WRITE_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|RA
argument_list|,
operator|(
name|i
operator|<<
literal|1
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|RA
argument_list|,
operator|(
operator|(
name|i
operator|<<
literal|1
operator|)
operator|+
literal|1
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
comment|/* Clear the MTA */
name|DEBUGOUT
argument_list|(
literal|" Clearing MTA\n"
argument_list|)
expr_stmt|;
name|num_mta_entry
operator|=
name|E1000_NUM_MTA_REGISTERS
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|==
name|em_ich8lan
condition|)
name|num_mta_entry
operator|=
name|E1000_NUM_MTA_REGISTERS_ICH8LAN
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_mta_entry
condition|;
name|i
operator|++
control|)
block|{
name|E1000_WRITE_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|MTA
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
comment|/* Add the new addresses */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mc_addr_count
condition|;
name|i
operator|++
control|)
block|{
name|DEBUGOUT
argument_list|(
literal|" Adding the multicast addresses:\n"
argument_list|)
expr_stmt|;
name|DEBUGOUT7
argument_list|(
literal|" MC Addr #%d =%.2X %.2X %.2X %.2X %.2X %.2X\n"
argument_list|,
name|i
argument_list|,
name|mc_addr_list
index|[
name|i
operator|*
operator|(
name|ETH_LENGTH_OF_ADDRESS
operator|+
name|pad
operator|)
index|]
argument_list|,
name|mc_addr_list
index|[
name|i
operator|*
operator|(
name|ETH_LENGTH_OF_ADDRESS
operator|+
name|pad
operator|)
operator|+
literal|1
index|]
argument_list|,
name|mc_addr_list
index|[
name|i
operator|*
operator|(
name|ETH_LENGTH_OF_ADDRESS
operator|+
name|pad
operator|)
operator|+
literal|2
index|]
argument_list|,
name|mc_addr_list
index|[
name|i
operator|*
operator|(
name|ETH_LENGTH_OF_ADDRESS
operator|+
name|pad
operator|)
operator|+
literal|3
index|]
argument_list|,
name|mc_addr_list
index|[
name|i
operator|*
operator|(
name|ETH_LENGTH_OF_ADDRESS
operator|+
name|pad
operator|)
operator|+
literal|4
index|]
argument_list|,
name|mc_addr_list
index|[
name|i
operator|*
operator|(
name|ETH_LENGTH_OF_ADDRESS
operator|+
name|pad
operator|)
operator|+
literal|5
index|]
argument_list|)
expr_stmt|;
name|hash_value
operator|=
name|em_hash_mc_addr
argument_list|(
name|hw
argument_list|,
name|mc_addr_list
operator|+
operator|(
name|i
operator|*
operator|(
name|ETH_LENGTH_OF_ADDRESS
operator|+
name|pad
operator|)
operator|)
argument_list|)
expr_stmt|;
name|DEBUGOUT1
argument_list|(
literal|" Hash value = 0x%03X\n"
argument_list|,
name|hash_value
argument_list|)
expr_stmt|;
comment|/* Place this multicast address in the RAR if there is room, *          * else put it in the MTA          */
if|if
condition|(
name|rar_used_count
operator|<
name|num_rar_entry
condition|)
block|{
name|em_rar_set
argument_list|(
name|hw
argument_list|,
name|mc_addr_list
operator|+
operator|(
name|i
operator|*
operator|(
name|ETH_LENGTH_OF_ADDRESS
operator|+
name|pad
operator|)
operator|)
argument_list|,
name|rar_used_count
argument_list|)
expr_stmt|;
name|rar_used_count
operator|++
expr_stmt|;
block|}
else|else
block|{
name|em_mta_set
argument_list|(
name|hw
argument_list|,
name|hash_value
argument_list|)
expr_stmt|;
block|}
block|}
name|DEBUGOUT
argument_list|(
literal|"MC Update Complete\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Hashes an address to determine its location in the multicast table  *  * hw - Struct containing variables accessed by shared code  * mc_addr - the multicast address to hash  *****************************************************************************/
end_comment

begin_function
name|uint32_t
name|em_hash_mc_addr
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint8_t
modifier|*
name|mc_addr
parameter_list|)
block|{
name|uint32_t
name|hash_value
init|=
literal|0
decl_stmt|;
comment|/* The portion of the address that is used for the hash table is      * determined by the mc_filter_type setting.      */
switch|switch
condition|(
name|hw
operator|->
name|mc_filter_type
condition|)
block|{
comment|/* [0] [1] [2] [3] [4] [5]      * 01  AA  00  12  34  56      * LSB                 MSB      */
case|case
literal|0
case|:
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|==
name|em_ich8lan
condition|)
block|{
comment|/* [47:38] i.e. 0x158 for above example address */
name|hash_value
operator|=
operator|(
operator|(
name|mc_addr
index|[
literal|4
index|]
operator|>>
literal|6
operator|)
operator||
operator|(
operator|(
operator|(
name|uint16_t
operator|)
name|mc_addr
index|[
literal|5
index|]
operator|)
operator|<<
literal|2
operator|)
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* [47:36] i.e. 0x563 for above example address */
name|hash_value
operator|=
operator|(
operator|(
name|mc_addr
index|[
literal|4
index|]
operator|>>
literal|4
operator|)
operator||
operator|(
operator|(
operator|(
name|uint16_t
operator|)
name|mc_addr
index|[
literal|5
index|]
operator|)
operator|<<
literal|4
operator|)
operator|)
expr_stmt|;
block|}
break|break;
case|case
literal|1
case|:
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|==
name|em_ich8lan
condition|)
block|{
comment|/* [46:37] i.e. 0x2B1 for above example address */
name|hash_value
operator|=
operator|(
operator|(
name|mc_addr
index|[
literal|4
index|]
operator|>>
literal|5
operator|)
operator||
operator|(
operator|(
operator|(
name|uint16_t
operator|)
name|mc_addr
index|[
literal|5
index|]
operator|)
operator|<<
literal|3
operator|)
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* [46:35] i.e. 0xAC6 for above example address */
name|hash_value
operator|=
operator|(
operator|(
name|mc_addr
index|[
literal|4
index|]
operator|>>
literal|3
operator|)
operator||
operator|(
operator|(
operator|(
name|uint16_t
operator|)
name|mc_addr
index|[
literal|5
index|]
operator|)
operator|<<
literal|5
operator|)
operator|)
expr_stmt|;
block|}
break|break;
case|case
literal|2
case|:
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|==
name|em_ich8lan
condition|)
block|{
comment|/*[45:36] i.e. 0x163 for above example address */
name|hash_value
operator|=
operator|(
operator|(
name|mc_addr
index|[
literal|4
index|]
operator|>>
literal|4
operator|)
operator||
operator|(
operator|(
operator|(
name|uint16_t
operator|)
name|mc_addr
index|[
literal|5
index|]
operator|)
operator|<<
literal|4
operator|)
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* [45:34] i.e. 0x5D8 for above example address */
name|hash_value
operator|=
operator|(
operator|(
name|mc_addr
index|[
literal|4
index|]
operator|>>
literal|2
operator|)
operator||
operator|(
operator|(
operator|(
name|uint16_t
operator|)
name|mc_addr
index|[
literal|5
index|]
operator|)
operator|<<
literal|6
operator|)
operator|)
expr_stmt|;
block|}
break|break;
case|case
literal|3
case|:
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|==
name|em_ich8lan
condition|)
block|{
comment|/* [43:34] i.e. 0x18D for above example address */
name|hash_value
operator|=
operator|(
operator|(
name|mc_addr
index|[
literal|4
index|]
operator|>>
literal|2
operator|)
operator||
operator|(
operator|(
operator|(
name|uint16_t
operator|)
name|mc_addr
index|[
literal|5
index|]
operator|)
operator|<<
literal|6
operator|)
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* [43:32] i.e. 0x634 for above example address */
name|hash_value
operator|=
operator|(
operator|(
name|mc_addr
index|[
literal|4
index|]
operator|)
operator||
operator|(
operator|(
operator|(
name|uint16_t
operator|)
name|mc_addr
index|[
literal|5
index|]
operator|)
operator|<<
literal|8
operator|)
operator|)
expr_stmt|;
block|}
break|break;
block|}
name|hash_value
operator|&=
literal|0xFFF
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|==
name|em_ich8lan
condition|)
name|hash_value
operator|&=
literal|0x3FF
expr_stmt|;
return|return
name|hash_value
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Sets the bit in the multicast table corresponding to the hash value.  *  * hw - Struct containing variables accessed by shared code  * hash_value - Multicast address hash value  *****************************************************************************/
end_comment

begin_function
name|void
name|em_mta_set
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint32_t
name|hash_value
parameter_list|)
block|{
name|uint32_t
name|hash_bit
decl_stmt|,
name|hash_reg
decl_stmt|;
name|uint32_t
name|mta
decl_stmt|;
name|uint32_t
name|temp
decl_stmt|;
comment|/* The MTA is a register array of 128 32-bit registers.      * It is treated like an array of 4096 bits.  We want to set      * bit BitArray[hash_value]. So we figure out what register      * the bit is in, read it, OR in the new bit, then write      * back the new value.  The register is determined by the      * upper 7 bits of the hash value and the bit within that      * register are determined by the lower 5 bits of the value.      */
name|hash_reg
operator|=
operator|(
name|hash_value
operator|>>
literal|5
operator|)
operator|&
literal|0x7F
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|==
name|em_ich8lan
condition|)
name|hash_reg
operator|&=
literal|0x1F
expr_stmt|;
name|hash_bit
operator|=
name|hash_value
operator|&
literal|0x1F
expr_stmt|;
name|mta
operator|=
name|E1000_READ_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|MTA
argument_list|,
name|hash_reg
argument_list|)
expr_stmt|;
name|mta
operator||=
operator|(
literal|1
operator|<<
name|hash_bit
operator|)
expr_stmt|;
comment|/* If we are on an 82544 and we are trying to write an odd offset      * in the MTA, save off the previous entry before writing and      * restore the old value after writing.      */
if|if
condition|(
operator|(
name|hw
operator|->
name|mac_type
operator|==
name|em_82544
operator|)
operator|&&
operator|(
operator|(
name|hash_reg
operator|&
literal|0x1
operator|)
operator|==
literal|1
operator|)
condition|)
block|{
name|temp
operator|=
name|E1000_READ_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|MTA
argument_list|,
operator|(
name|hash_reg
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|MTA
argument_list|,
name|hash_reg
argument_list|,
name|mta
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|MTA
argument_list|,
operator|(
name|hash_reg
operator|-
literal|1
operator|)
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|E1000_WRITE_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|MTA
argument_list|,
name|hash_reg
argument_list|,
name|mta
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/******************************************************************************  * Puts an ethernet address into a receive address register.  *  * hw - Struct containing variables accessed by shared code  * addr - Address to put into receive address register  * index - Receive address register to write  *****************************************************************************/
end_comment

begin_function
name|void
name|em_rar_set
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint8_t
modifier|*
name|addr
parameter_list|,
name|uint32_t
name|index
parameter_list|)
block|{
name|uint32_t
name|rar_low
decl_stmt|,
name|rar_high
decl_stmt|;
comment|/* HW expects these in little endian so we reverse the byte order      * from network order (big endian) to little endian      */
name|rar_low
operator|=
operator|(
operator|(
name|uint32_t
operator|)
name|addr
index|[
literal|0
index|]
operator||
operator|(
operator|(
name|uint32_t
operator|)
name|addr
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
name|uint32_t
operator|)
name|addr
index|[
literal|2
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|uint32_t
operator|)
name|addr
index|[
literal|3
index|]
operator|<<
literal|24
operator|)
operator|)
expr_stmt|;
name|rar_high
operator|=
operator|(
operator|(
name|uint32_t
operator|)
name|addr
index|[
literal|4
index|]
operator||
operator|(
operator|(
name|uint32_t
operator|)
name|addr
index|[
literal|5
index|]
operator|<<
literal|8
operator|)
operator|)
expr_stmt|;
comment|/* Disable Rx and flush all Rx frames before enabling RSS to avoid Rx      * unit hang.      *      * Description:      * If there are any Rx frames queued up or otherwise present in the HW      * before RSS is enabled, and then we enable RSS, the HW Rx unit will      * hang.  To work around this issue, we have to disable receives and      * flush out all Rx frames before we enable RSS. To do so, we modify we      * redirect all Rx traffic to manageability and then reset the HW.      * This flushes away Rx frames, and (since the redirections to      * manageability persists across resets) keeps new ones from coming in      * while we work.  Then, we clear the Address Valid AV bit for all MAC      * addresses and undo the re-direction to manageability.      * Now, frames are coming in again, but the MAC won't accept them, so      * far so good.  We now proceed to initialize RSS (if necessary) and      * configure the Rx unit.  Last, we re-enable the AV bits and continue      * on our merry way.      */
switch|switch
condition|(
name|hw
operator|->
name|mac_type
condition|)
block|{
case|case
name|em_82571
case|:
case|case
name|em_82572
case|:
case|case
name|em_80003es2lan
case|:
if|if
condition|(
name|hw
operator|->
name|leave_av_bit_off
operator|==
name|TRUE
condition|)
break|break;
default|default:
comment|/* Indicate to hardware the Address is Valid. */
name|rar_high
operator||=
name|E1000_RAH_AV
expr_stmt|;
break|break;
block|}
name|E1000_WRITE_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|RA
argument_list|,
operator|(
name|index
operator|<<
literal|1
operator|)
argument_list|,
name|rar_low
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|RA
argument_list|,
operator|(
operator|(
name|index
operator|<<
literal|1
operator|)
operator|+
literal|1
operator|)
argument_list|,
name|rar_high
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Writes a value to the specified offset in the VLAN filter table.  *  * hw - Struct containing variables accessed by shared code  * offset - Offset in VLAN filer table to write  * value - Value to write into VLAN filter table  *****************************************************************************/
end_comment

begin_function
name|void
name|em_write_vfta
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint32_t
name|offset
parameter_list|,
name|uint32_t
name|value
parameter_list|)
block|{
name|uint32_t
name|temp
decl_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|==
name|em_ich8lan
condition|)
return|return;
if|if
condition|(
operator|(
name|hw
operator|->
name|mac_type
operator|==
name|em_82544
operator|)
operator|&&
operator|(
operator|(
name|offset
operator|&
literal|0x1
operator|)
operator|==
literal|1
operator|)
condition|)
block|{
name|temp
operator|=
name|E1000_READ_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|VFTA
argument_list|,
operator|(
name|offset
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|VFTA
argument_list|,
name|offset
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|VFTA
argument_list|,
operator|(
name|offset
operator|-
literal|1
operator|)
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|E1000_WRITE_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|VFTA
argument_list|,
name|offset
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/******************************************************************************  * Clears the VLAN filer table  *  * hw - Struct containing variables accessed by shared code  *****************************************************************************/
end_comment

begin_function
name|STATIC
name|void
name|em_clear_vfta
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|uint32_t
name|offset
decl_stmt|;
name|uint32_t
name|vfta_value
init|=
literal|0
decl_stmt|;
name|uint32_t
name|vfta_offset
init|=
literal|0
decl_stmt|;
name|uint32_t
name|vfta_bit_in_reg
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|==
name|em_ich8lan
condition|)
return|return;
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|==
name|em_82573
condition|)
block|{
if|if
condition|(
name|hw
operator|->
name|mng_cookie
operator|.
name|vlan_id
operator|!=
literal|0
condition|)
block|{
comment|/* The VFTA is a 4096b bit-field, each identifying a single VLAN              * ID.  The following operations determine which 32b entry              * (i.e. offset) into the array we want to set the VLAN ID              * (i.e. bit) of the manageability unit. */
name|vfta_offset
operator|=
operator|(
name|hw
operator|->
name|mng_cookie
operator|.
name|vlan_id
operator|>>
name|E1000_VFTA_ENTRY_SHIFT
operator|)
operator|&
name|E1000_VFTA_ENTRY_MASK
expr_stmt|;
name|vfta_bit_in_reg
operator|=
literal|1
operator|<<
operator|(
name|hw
operator|->
name|mng_cookie
operator|.
name|vlan_id
operator|&
name|E1000_VFTA_ENTRY_BIT_SHIFT_MASK
operator|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|offset
operator|=
literal|0
init|;
name|offset
operator|<
name|E1000_VLAN_FILTER_TBL_SIZE
condition|;
name|offset
operator|++
control|)
block|{
comment|/* If the offset we want to clear is the same offset of the          * manageability VLAN ID, then clear all bits except that of the          * manageability unit */
name|vfta_value
operator|=
operator|(
name|offset
operator|==
name|vfta_offset
operator|)
condition|?
name|vfta_bit_in_reg
else|:
literal|0
expr_stmt|;
name|E1000_WRITE_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|VFTA
argument_list|,
name|offset
argument_list|,
name|vfta_value
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|STATIC
name|int32_t
name|em_id_led_init
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|uint32_t
name|ledctl
decl_stmt|;
specifier|const
name|uint32_t
name|ledctl_mask
init|=
literal|0x000000FF
decl_stmt|;
specifier|const
name|uint32_t
name|ledctl_on
init|=
name|E1000_LEDCTL_MODE_LED_ON
decl_stmt|;
specifier|const
name|uint32_t
name|ledctl_off
init|=
name|E1000_LEDCTL_MODE_LED_OFF
decl_stmt|;
name|uint16_t
name|eeprom_data
decl_stmt|,
name|i
decl_stmt|,
name|temp
decl_stmt|;
specifier|const
name|uint16_t
name|led_mask
init|=
literal|0x0F
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_id_led_init"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|<
name|em_82540
condition|)
block|{
comment|/* Nothing to do */
return|return
name|E1000_SUCCESS
return|;
block|}
name|ledctl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|LEDCTL
argument_list|)
expr_stmt|;
name|hw
operator|->
name|ledctl_default
operator|=
name|ledctl
expr_stmt|;
name|hw
operator|->
name|ledctl_mode1
operator|=
name|hw
operator|->
name|ledctl_default
expr_stmt|;
name|hw
operator|->
name|ledctl_mode2
operator|=
name|hw
operator|->
name|ledctl_default
expr_stmt|;
if|if
condition|(
name|em_read_eeprom
argument_list|(
name|hw
argument_list|,
name|EEPROM_ID_LED_SETTINGS
argument_list|,
literal|1
argument_list|,
operator|&
name|eeprom_data
argument_list|)
operator|<
literal|0
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"EEPROM Read Error\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_EEPROM
return|;
block|}
if|if
condition|(
operator|(
name|hw
operator|->
name|mac_type
operator|==
name|em_82573
operator|)
operator|&&
operator|(
name|eeprom_data
operator|==
name|ID_LED_RESERVED_82573
operator|)
condition|)
name|eeprom_data
operator|=
name|ID_LED_DEFAULT_82573
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|eeprom_data
operator|==
name|ID_LED_RESERVED_0000
operator|)
operator|||
operator|(
name|eeprom_data
operator|==
name|ID_LED_RESERVED_FFFF
operator|)
condition|)
block|{
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|==
name|em_ich8lan
condition|)
name|eeprom_data
operator|=
name|ID_LED_DEFAULT_ICH8LAN
expr_stmt|;
else|else
name|eeprom_data
operator|=
name|ID_LED_DEFAULT
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|temp
operator|=
operator|(
name|eeprom_data
operator|>>
operator|(
name|i
operator|<<
literal|2
operator|)
operator|)
operator|&
name|led_mask
expr_stmt|;
switch|switch
condition|(
name|temp
condition|)
block|{
case|case
name|ID_LED_ON1_DEF2
case|:
case|case
name|ID_LED_ON1_ON2
case|:
case|case
name|ID_LED_ON1_OFF2
case|:
name|hw
operator|->
name|ledctl_mode1
operator|&=
operator|~
operator|(
name|ledctl_mask
operator|<<
operator|(
name|i
operator|<<
literal|3
operator|)
operator|)
expr_stmt|;
name|hw
operator|->
name|ledctl_mode1
operator||=
name|ledctl_on
operator|<<
operator|(
name|i
operator|<<
literal|3
operator|)
expr_stmt|;
break|break;
case|case
name|ID_LED_OFF1_DEF2
case|:
case|case
name|ID_LED_OFF1_ON2
case|:
case|case
name|ID_LED_OFF1_OFF2
case|:
name|hw
operator|->
name|ledctl_mode1
operator|&=
operator|~
operator|(
name|ledctl_mask
operator|<<
operator|(
name|i
operator|<<
literal|3
operator|)
operator|)
expr_stmt|;
name|hw
operator|->
name|ledctl_mode1
operator||=
name|ledctl_off
operator|<<
operator|(
name|i
operator|<<
literal|3
operator|)
expr_stmt|;
break|break;
default|default:
comment|/* Do nothing */
break|break;
block|}
switch|switch
condition|(
name|temp
condition|)
block|{
case|case
name|ID_LED_DEF1_ON2
case|:
case|case
name|ID_LED_ON1_ON2
case|:
case|case
name|ID_LED_OFF1_ON2
case|:
name|hw
operator|->
name|ledctl_mode2
operator|&=
operator|~
operator|(
name|ledctl_mask
operator|<<
operator|(
name|i
operator|<<
literal|3
operator|)
operator|)
expr_stmt|;
name|hw
operator|->
name|ledctl_mode2
operator||=
name|ledctl_on
operator|<<
operator|(
name|i
operator|<<
literal|3
operator|)
expr_stmt|;
break|break;
case|case
name|ID_LED_DEF1_OFF2
case|:
case|case
name|ID_LED_ON1_OFF2
case|:
case|case
name|ID_LED_OFF1_OFF2
case|:
name|hw
operator|->
name|ledctl_mode2
operator|&=
operator|~
operator|(
name|ledctl_mask
operator|<<
operator|(
name|i
operator|<<
literal|3
operator|)
operator|)
expr_stmt|;
name|hw
operator|->
name|ledctl_mode2
operator||=
name|ledctl_off
operator|<<
operator|(
name|i
operator|<<
literal|3
operator|)
expr_stmt|;
break|break;
default|default:
comment|/* Do nothing */
break|break;
block|}
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Prepares SW controlable LED for use and saves the current state of the LED.  *  * hw - Struct containing variables accessed by shared code  *****************************************************************************/
end_comment

begin_function
name|int32_t
name|em_setup_led
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|uint32_t
name|ledctl
decl_stmt|;
name|int32_t
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_setup_led"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|hw
operator|->
name|mac_type
condition|)
block|{
case|case
name|em_82542_rev2_0
case|:
case|case
name|em_82542_rev2_1
case|:
case|case
name|em_82543
case|:
case|case
name|em_82544
case|:
comment|/* No setup necessary */
break|break;
case|case
name|em_82541
case|:
case|case
name|em_82547
case|:
case|case
name|em_82541_rev_2
case|:
case|case
name|em_82547_rev_2
case|:
comment|/* Turn off PHY Smart Power Down (if enabled) */
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_GMII_FIFO
argument_list|,
operator|&
name|hw
operator|->
name|phy_spd_default
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|ret_val
operator|=
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_GMII_FIFO
argument_list|,
call|(
name|uint16_t
call|)
argument_list|(
name|hw
operator|->
name|phy_spd_default
operator|&
operator|~
name|IGP01E1000_GMII_SPD
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
comment|/* Fall Through */
default|default:
if|if
condition|(
name|hw
operator|->
name|media_type
operator|==
name|em_media_type_fiber
condition|)
block|{
name|ledctl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|LEDCTL
argument_list|)
expr_stmt|;
comment|/* Save current LEDCTL settings */
name|hw
operator|->
name|ledctl_default
operator|=
name|ledctl
expr_stmt|;
comment|/* Turn off LED0 */
name|ledctl
operator|&=
operator|~
operator|(
name|E1000_LEDCTL_LED0_IVRT
operator||
name|E1000_LEDCTL_LED0_BLINK
operator||
name|E1000_LEDCTL_LED0_MODE_MASK
operator|)
expr_stmt|;
name|ledctl
operator||=
operator|(
name|E1000_LEDCTL_MODE_LED_OFF
operator|<<
name|E1000_LEDCTL_LED0_MODE_SHIFT
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|LEDCTL
argument_list|,
name|ledctl
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|hw
operator|->
name|media_type
operator|==
name|em_media_type_copper
condition|)
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|LEDCTL
argument_list|,
name|hw
operator|->
name|ledctl_mode1
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Used on 82571 and later Si that has LED blink bits.  * Callers must use their own timer and should have already called  * em_id_led_init()  * Call em_cleanup led() to stop blinking  *  * hw - Struct containing variables accessed by shared code  *****************************************************************************/
end_comment

begin_function
name|int32_t
name|em_blink_led_start
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|int16_t
name|i
decl_stmt|;
name|uint32_t
name|ledctl_blink
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_id_led_blink_on"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|<
name|em_82571
condition|)
block|{
comment|/* Nothing to do */
return|return
name|E1000_SUCCESS
return|;
block|}
if|if
condition|(
name|hw
operator|->
name|media_type
operator|==
name|em_media_type_fiber
condition|)
block|{
comment|/* always blink LED0 for PCI-E fiber */
name|ledctl_blink
operator|=
name|E1000_LEDCTL_LED0_BLINK
operator||
operator|(
name|E1000_LEDCTL_MODE_LED_ON
operator|<<
name|E1000_LEDCTL_LED0_MODE_SHIFT
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* set the blink bit for each LED that's "on" (0x0E) in ledctl_mode2 */
name|ledctl_blink
operator|=
name|hw
operator|->
name|ledctl_mode2
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
operator|(
name|hw
operator|->
name|ledctl_mode2
operator|>>
operator|(
name|i
operator|*
literal|8
operator|)
operator|)
operator|&
literal|0xFF
operator|)
operator|==
name|E1000_LEDCTL_MODE_LED_ON
condition|)
name|ledctl_blink
operator||=
operator|(
name|E1000_LEDCTL_LED0_BLINK
operator|<<
operator|(
name|i
operator|*
literal|8
operator|)
operator|)
expr_stmt|;
block|}
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|LEDCTL
argument_list|,
name|ledctl_blink
argument_list|)
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Restores the saved state of the SW controlable LED.  *  * hw - Struct containing variables accessed by shared code  *****************************************************************************/
end_comment

begin_function
name|int32_t
name|em_cleanup_led
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|int32_t
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_cleanup_led"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|hw
operator|->
name|mac_type
condition|)
block|{
case|case
name|em_82542_rev2_0
case|:
case|case
name|em_82542_rev2_1
case|:
case|case
name|em_82543
case|:
case|case
name|em_82544
case|:
comment|/* No cleanup necessary */
break|break;
case|case
name|em_82541
case|:
case|case
name|em_82547
case|:
case|case
name|em_82541_rev_2
case|:
case|case
name|em_82547_rev_2
case|:
comment|/* Turn on PHY Smart Power Down (if previously enabled) */
name|ret_val
operator|=
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_GMII_FIFO
argument_list|,
name|hw
operator|->
name|phy_spd_default
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
comment|/* Fall Through */
default|default:
if|if
condition|(
name|hw
operator|->
name|phy_type
operator|==
name|em_phy_ife
condition|)
block|{
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|IFE_PHY_SPECIAL_CONTROL_LED
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Restore LEDCTL settings */
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|LEDCTL
argument_list|,
name|hw
operator|->
name|ledctl_default
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Turns on the software controllable LED  *  * hw - Struct containing variables accessed by shared code  *****************************************************************************/
end_comment

begin_function
name|int32_t
name|em_led_on
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|uint32_t
name|ctrl
init|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|)
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_led_on"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|hw
operator|->
name|mac_type
condition|)
block|{
case|case
name|em_82542_rev2_0
case|:
case|case
name|em_82542_rev2_1
case|:
case|case
name|em_82543
case|:
comment|/* Set SW Defineable Pin 0 to turn on the LED */
name|ctrl
operator||=
name|E1000_CTRL_SWDPIN0
expr_stmt|;
name|ctrl
operator||=
name|E1000_CTRL_SWDPIO0
expr_stmt|;
break|break;
case|case
name|em_82544
case|:
if|if
condition|(
name|hw
operator|->
name|media_type
operator|==
name|em_media_type_fiber
condition|)
block|{
comment|/* Set SW Defineable Pin 0 to turn on the LED */
name|ctrl
operator||=
name|E1000_CTRL_SWDPIN0
expr_stmt|;
name|ctrl
operator||=
name|E1000_CTRL_SWDPIO0
expr_stmt|;
block|}
else|else
block|{
comment|/* Clear SW Defineable Pin 0 to turn on the LED */
name|ctrl
operator|&=
operator|~
name|E1000_CTRL_SWDPIN0
expr_stmt|;
name|ctrl
operator||=
name|E1000_CTRL_SWDPIO0
expr_stmt|;
block|}
break|break;
default|default:
if|if
condition|(
name|hw
operator|->
name|media_type
operator|==
name|em_media_type_fiber
condition|)
block|{
comment|/* Clear SW Defineable Pin 0 to turn on the LED */
name|ctrl
operator|&=
operator|~
name|E1000_CTRL_SWDPIN0
expr_stmt|;
name|ctrl
operator||=
name|E1000_CTRL_SWDPIO0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|hw
operator|->
name|phy_type
operator|==
name|em_phy_ife
condition|)
block|{
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|IFE_PHY_SPECIAL_CONTROL_LED
argument_list|,
operator|(
name|IFE_PSCL_PROBE_MODE
operator||
name|IFE_PSCL_PROBE_LEDS_ON
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|hw
operator|->
name|media_type
operator|==
name|em_media_type_copper
condition|)
block|{
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|LEDCTL
argument_list|,
name|hw
operator|->
name|ledctl_mode2
argument_list|)
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
break|break;
block|}
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Turns off the software controllable LED  *  * hw - Struct containing variables accessed by shared code  *****************************************************************************/
end_comment

begin_function
name|int32_t
name|em_led_off
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|uint32_t
name|ctrl
init|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|)
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_led_off"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|hw
operator|->
name|mac_type
condition|)
block|{
case|case
name|em_82542_rev2_0
case|:
case|case
name|em_82542_rev2_1
case|:
case|case
name|em_82543
case|:
comment|/* Clear SW Defineable Pin 0 to turn off the LED */
name|ctrl
operator|&=
operator|~
name|E1000_CTRL_SWDPIN0
expr_stmt|;
name|ctrl
operator||=
name|E1000_CTRL_SWDPIO0
expr_stmt|;
break|break;
case|case
name|em_82544
case|:
if|if
condition|(
name|hw
operator|->
name|media_type
operator|==
name|em_media_type_fiber
condition|)
block|{
comment|/* Clear SW Defineable Pin 0 to turn off the LED */
name|ctrl
operator|&=
operator|~
name|E1000_CTRL_SWDPIN0
expr_stmt|;
name|ctrl
operator||=
name|E1000_CTRL_SWDPIO0
expr_stmt|;
block|}
else|else
block|{
comment|/* Set SW Defineable Pin 0 to turn off the LED */
name|ctrl
operator||=
name|E1000_CTRL_SWDPIN0
expr_stmt|;
name|ctrl
operator||=
name|E1000_CTRL_SWDPIO0
expr_stmt|;
block|}
break|break;
default|default:
if|if
condition|(
name|hw
operator|->
name|media_type
operator|==
name|em_media_type_fiber
condition|)
block|{
comment|/* Set SW Defineable Pin 0 to turn off the LED */
name|ctrl
operator||=
name|E1000_CTRL_SWDPIN0
expr_stmt|;
name|ctrl
operator||=
name|E1000_CTRL_SWDPIO0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|hw
operator|->
name|phy_type
operator|==
name|em_phy_ife
condition|)
block|{
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|IFE_PHY_SPECIAL_CONTROL_LED
argument_list|,
operator|(
name|IFE_PSCL_PROBE_MODE
operator||
name|IFE_PSCL_PROBE_LEDS_OFF
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|hw
operator|->
name|media_type
operator|==
name|em_media_type_copper
condition|)
block|{
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|LEDCTL
argument_list|,
name|hw
operator|->
name|ledctl_mode1
argument_list|)
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
break|break;
block|}
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Clears all hardware statistics counters.  *  * hw - Struct containing variables accessed by shared code  *****************************************************************************/
end_comment

begin_function
name|void
name|em_clear_hw_cntrs
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
specifier|volatile
name|uint32_t
name|temp
decl_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|CRCERRS
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|SYMERRS
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|MPC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|SCC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|ECOL
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|MCC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|LATECOL
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|COLC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|DC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|SEC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|RLEC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|XONRXC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|XONTXC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|XOFFRXC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|XOFFTXC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|FCRUC
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|!=
name|em_ich8lan
condition|)
block|{
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|PRC64
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|PRC127
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|PRC255
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|PRC511
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|PRC1023
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|PRC1522
argument_list|)
expr_stmt|;
block|}
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|GPRC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|BPRC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|MPRC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|GPTC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|GORCL
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|GORCH
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|GOTCL
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|GOTCH
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|RNBC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|RUC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|RFC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|ROC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|RJC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|TORL
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|TORH
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|TOTL
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|TOTH
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|TPR
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|TPT
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|!=
name|em_ich8lan
condition|)
block|{
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|PTC64
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|PTC127
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|PTC255
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|PTC511
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|PTC1023
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|PTC1522
argument_list|)
expr_stmt|;
block|}
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|MPTC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|BPTC
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|<
name|em_82543
condition|)
return|return;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|ALGNERRC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|RXERRC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|TNCRS
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|CEXTERR
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|TSCTC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|TSCTFC
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|<=
name|em_82544
condition|)
return|return;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|MGTPRC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|MGTPDC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|MGTPTC
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|<=
name|em_82547_rev_2
condition|)
return|return;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|IAC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|ICRXOC
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|==
name|em_ich8lan
condition|)
return|return;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|ICRXPTC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|ICRXATC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|ICTXPTC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|ICTXATC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|ICTXQEC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|ICTXQMTC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|ICRXDMTC
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Resets Adaptive IFS to its default state.  *  * hw - Struct containing variables accessed by shared code  *  * Call this after em_init_hw. You may override the IFS defaults by setting  * hw->ifs_params_forced to TRUE. However, you must initialize hw->  * current_ifs_val, ifs_min_val, ifs_max_val, ifs_step_size, and ifs_ratio  * before calling this function.  *****************************************************************************/
end_comment

begin_function
name|void
name|em_reset_adaptive
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"em_reset_adaptive"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|adaptive_ifs
condition|)
block|{
if|if
condition|(
operator|!
name|hw
operator|->
name|ifs_params_forced
condition|)
block|{
name|hw
operator|->
name|current_ifs_val
operator|=
literal|0
expr_stmt|;
name|hw
operator|->
name|ifs_min_val
operator|=
name|IFS_MIN
expr_stmt|;
name|hw
operator|->
name|ifs_max_val
operator|=
name|IFS_MAX
expr_stmt|;
name|hw
operator|->
name|ifs_step_size
operator|=
name|IFS_STEP
expr_stmt|;
name|hw
operator|->
name|ifs_ratio
operator|=
name|IFS_RATIO
expr_stmt|;
block|}
name|hw
operator|->
name|in_ifs_mode
operator|=
name|FALSE
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|AIT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DEBUGOUT
argument_list|(
literal|"Not in Adaptive IFS mode!\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/******************************************************************************  * Called during the callback/watchdog routine to update IFS value based on  * the ratio of transmits to collisions.  *  * hw - Struct containing variables accessed by shared code  * tx_packets - Number of transmits since last callback  * total_collisions - Number of collisions since last callback  *****************************************************************************/
end_comment

begin_function
name|void
name|em_update_adaptive
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"em_update_adaptive"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|adaptive_ifs
condition|)
block|{
if|if
condition|(
operator|(
name|hw
operator|->
name|collision_delta
operator|*
name|hw
operator|->
name|ifs_ratio
operator|)
operator|>
name|hw
operator|->
name|tx_packet_delta
condition|)
block|{
if|if
condition|(
name|hw
operator|->
name|tx_packet_delta
operator|>
name|MIN_NUM_XMITS
condition|)
block|{
name|hw
operator|->
name|in_ifs_mode
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|current_ifs_val
operator|<
name|hw
operator|->
name|ifs_max_val
condition|)
block|{
if|if
condition|(
name|hw
operator|->
name|current_ifs_val
operator|==
literal|0
condition|)
name|hw
operator|->
name|current_ifs_val
operator|=
name|hw
operator|->
name|ifs_min_val
expr_stmt|;
else|else
name|hw
operator|->
name|current_ifs_val
operator|+=
name|hw
operator|->
name|ifs_step_size
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|AIT
argument_list|,
name|hw
operator|->
name|current_ifs_val
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|hw
operator|->
name|in_ifs_mode
operator|&&
operator|(
name|hw
operator|->
name|tx_packet_delta
operator|<=
name|MIN_NUM_XMITS
operator|)
condition|)
block|{
name|hw
operator|->
name|current_ifs_val
operator|=
literal|0
expr_stmt|;
name|hw
operator|->
name|in_ifs_mode
operator|=
name|FALSE
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|AIT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|DEBUGOUT
argument_list|(
literal|"Not in Adaptive IFS mode!\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/******************************************************************************  * Adjusts the statistic counters when a frame is accepted by TBI_ACCEPT  *  * hw - Struct containing variables accessed by shared code  * frame_len - The length of the frame in question  * mac_addr - The Ethernet destination address of the frame in question  *****************************************************************************/
end_comment

begin_function
name|void
name|em_tbi_adjust_stats
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|struct
name|em_hw_stats
modifier|*
name|stats
parameter_list|,
name|uint32_t
name|frame_len
parameter_list|,
name|uint8_t
modifier|*
name|mac_addr
parameter_list|)
block|{
name|uint64_t
name|carry_bit
decl_stmt|;
comment|/* First adjust the frame length. */
name|frame_len
operator|--
expr_stmt|;
comment|/* We need to adjust the statistics counters, since the hardware      * counters overcount this packet as a CRC error and undercount      * the packet as a good packet      */
comment|/* This packet should not be counted as a CRC error.    */
name|stats
operator|->
name|crcerrs
operator|--
expr_stmt|;
comment|/* This packet does count as a Good Packet Received.    */
name|stats
operator|->
name|gprc
operator|++
expr_stmt|;
comment|/* Adjust the Good Octets received counters             */
name|carry_bit
operator|=
literal|0x80000000
operator|&
name|stats
operator|->
name|gorcl
expr_stmt|;
name|stats
operator|->
name|gorcl
operator|+=
name|frame_len
expr_stmt|;
comment|/* If the high bit of Gorcl (the low 32 bits of the Good Octets      * Received Count) was one before the addition,      * AND it is zero after, then we lost the carry out,      * need to add one to Gorch (Good Octets Received Count High).      * This could be simplified if all environments supported      * 64-bit integers.      */
if|if
condition|(
name|carry_bit
operator|&&
operator|(
operator|(
name|stats
operator|->
name|gorcl
operator|&
literal|0x80000000
operator|)
operator|==
literal|0
operator|)
condition|)
name|stats
operator|->
name|gorch
operator|++
expr_stmt|;
comment|/* Is this a broadcast or multicast?  Check broadcast first,      * since the test for a multicast frame will test positive on      * a broadcast frame.      */
if|if
condition|(
operator|(
name|mac_addr
index|[
literal|0
index|]
operator|==
operator|(
name|uint8_t
operator|)
literal|0xff
operator|)
operator|&&
operator|(
name|mac_addr
index|[
literal|1
index|]
operator|==
operator|(
name|uint8_t
operator|)
literal|0xff
operator|)
condition|)
comment|/* Broadcast packet */
name|stats
operator|->
name|bprc
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|mac_addr
operator|&
literal|0x01
condition|)
comment|/* Multicast packet */
name|stats
operator|->
name|mprc
operator|++
expr_stmt|;
if|if
condition|(
name|frame_len
operator|==
name|hw
operator|->
name|max_frame_size
condition|)
block|{
comment|/* In this case, the hardware has overcounted the number of          * oversize frames.          */
if|if
condition|(
name|stats
operator|->
name|roc
operator|>
literal|0
condition|)
name|stats
operator|->
name|roc
operator|--
expr_stmt|;
block|}
comment|/* Adjust the bin counters when the extra byte put the frame in the      * wrong bin. Remember that the frame_len was adjusted above.      */
if|if
condition|(
name|frame_len
operator|==
literal|64
condition|)
block|{
name|stats
operator|->
name|prc64
operator|++
expr_stmt|;
name|stats
operator|->
name|prc127
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|frame_len
operator|==
literal|127
condition|)
block|{
name|stats
operator|->
name|prc127
operator|++
expr_stmt|;
name|stats
operator|->
name|prc255
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|frame_len
operator|==
literal|255
condition|)
block|{
name|stats
operator|->
name|prc255
operator|++
expr_stmt|;
name|stats
operator|->
name|prc511
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|frame_len
operator|==
literal|511
condition|)
block|{
name|stats
operator|->
name|prc511
operator|++
expr_stmt|;
name|stats
operator|->
name|prc1023
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|frame_len
operator|==
literal|1023
condition|)
block|{
name|stats
operator|->
name|prc1023
operator|++
expr_stmt|;
name|stats
operator|->
name|prc1522
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|frame_len
operator|==
literal|1522
condition|)
block|{
name|stats
operator|->
name|prc1522
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/******************************************************************************  * Gets the current PCI bus type, speed, and width of the hardware  *  * hw - Struct containing variables accessed by shared code  *****************************************************************************/
end_comment

begin_function
name|void
name|em_get_bus_info
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|int32_t
name|ret_val
decl_stmt|;
name|uint16_t
name|pci_ex_link_status
decl_stmt|;
name|uint32_t
name|status
decl_stmt|;
switch|switch
condition|(
name|hw
operator|->
name|mac_type
condition|)
block|{
case|case
name|em_82542_rev2_0
case|:
case|case
name|em_82542_rev2_1
case|:
name|hw
operator|->
name|bus_type
operator|=
name|em_bus_type_unknown
expr_stmt|;
name|hw
operator|->
name|bus_speed
operator|=
name|em_bus_speed_unknown
expr_stmt|;
name|hw
operator|->
name|bus_width
operator|=
name|em_bus_width_unknown
expr_stmt|;
break|break;
case|case
name|em_82571
case|:
case|case
name|em_82572
case|:
case|case
name|em_82573
case|:
case|case
name|em_80003es2lan
case|:
name|hw
operator|->
name|bus_type
operator|=
name|em_bus_type_pci_express
expr_stmt|;
name|hw
operator|->
name|bus_speed
operator|=
name|em_bus_speed_2500
expr_stmt|;
name|ret_val
operator|=
name|em_read_pcie_cap_reg
argument_list|(
name|hw
argument_list|,
name|PCI_EX_LINK_STATUS
argument_list|,
operator|&
name|pci_ex_link_status
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
name|hw
operator|->
name|bus_width
operator|=
name|em_bus_width_unknown
expr_stmt|;
else|else
name|hw
operator|->
name|bus_width
operator|=
operator|(
name|pci_ex_link_status
operator|&
name|PCI_EX_LINK_WIDTH_MASK
operator|)
operator|>>
name|PCI_EX_LINK_WIDTH_SHIFT
expr_stmt|;
break|break;
case|case
name|em_ich8lan
case|:
name|hw
operator|->
name|bus_type
operator|=
name|em_bus_type_pci_express
expr_stmt|;
name|hw
operator|->
name|bus_speed
operator|=
name|em_bus_speed_2500
expr_stmt|;
name|hw
operator|->
name|bus_width
operator|=
name|em_bus_width_pciex_1
expr_stmt|;
break|break;
default|default:
name|status
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|STATUS
argument_list|)
expr_stmt|;
name|hw
operator|->
name|bus_type
operator|=
operator|(
name|status
operator|&
name|E1000_STATUS_PCIX_MODE
operator|)
condition|?
name|em_bus_type_pcix
else|:
name|em_bus_type_pci
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|device_id
operator|==
name|E1000_DEV_ID_82546EB_QUAD_COPPER
condition|)
block|{
name|hw
operator|->
name|bus_speed
operator|=
operator|(
name|hw
operator|->
name|bus_type
operator|==
name|em_bus_type_pci
operator|)
condition|?
name|em_bus_speed_66
else|:
name|em_bus_speed_120
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|hw
operator|->
name|bus_type
operator|==
name|em_bus_type_pci
condition|)
block|{
name|hw
operator|->
name|bus_speed
operator|=
operator|(
name|status
operator|&
name|E1000_STATUS_PCI66
operator|)
condition|?
name|em_bus_speed_66
else|:
name|em_bus_speed_33
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|status
operator|&
name|E1000_STATUS_PCIX_SPEED
condition|)
block|{
case|case
name|E1000_STATUS_PCIX_SPEED_66
case|:
name|hw
operator|->
name|bus_speed
operator|=
name|em_bus_speed_66
expr_stmt|;
break|break;
case|case
name|E1000_STATUS_PCIX_SPEED_100
case|:
name|hw
operator|->
name|bus_speed
operator|=
name|em_bus_speed_100
expr_stmt|;
break|break;
case|case
name|E1000_STATUS_PCIX_SPEED_133
case|:
name|hw
operator|->
name|bus_speed
operator|=
name|em_bus_speed_133
expr_stmt|;
break|break;
default|default:
name|hw
operator|->
name|bus_speed
operator|=
name|em_bus_speed_reserved
expr_stmt|;
break|break;
block|}
block|}
name|hw
operator|->
name|bus_width
operator|=
operator|(
name|status
operator|&
name|E1000_STATUS_BUS64
operator|)
condition|?
name|em_bus_width_64
else|:
name|em_bus_width_32
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/******************************************************************************  * Writes a value to one of the devices registers using port I/O (as opposed to  * memory mapped I/O). Only 82544 and newer devices support port I/O.  *  * hw - Struct containing variables accessed by shared code  * offset - offset to write to  * value - value to write  *****************************************************************************/
end_comment

begin_function
name|STATIC
name|void
name|em_write_reg_io
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint32_t
name|offset
parameter_list|,
name|uint32_t
name|value
parameter_list|)
block|{
name|unsigned
name|long
name|io_addr
init|=
name|hw
operator|->
name|io_base
decl_stmt|;
name|unsigned
name|long
name|io_data
init|=
name|hw
operator|->
name|io_base
operator|+
literal|4
decl_stmt|;
name|em_io_write
argument_list|(
name|hw
argument_list|,
name|io_addr
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|em_io_write
argument_list|(
name|hw
argument_list|,
name|io_data
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Estimates the cable length.  *  * hw - Struct containing variables accessed by shared code  * min_length - The estimated minimum length  * max_length - The estimated maximum length  *  * returns: - E1000_ERR_XXX  *            E1000_SUCCESS  *  * This function always returns a ranged length (minimum& maximum).  * So for M88 phy's, this function interprets the one value returned from the  * register to the minimum and maximum range.  * For IGP phy's, the function calculates the range by the AGC registers.  *****************************************************************************/
end_comment

begin_function
name|STATIC
name|int32_t
name|em_get_cable_length
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint16_t
modifier|*
name|min_length
parameter_list|,
name|uint16_t
modifier|*
name|max_length
parameter_list|)
block|{
name|int32_t
name|ret_val
decl_stmt|;
name|uint16_t
name|agc_value
init|=
literal|0
decl_stmt|;
name|uint16_t
name|i
decl_stmt|,
name|phy_data
decl_stmt|;
name|uint16_t
name|cable_length
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_get_cable_length"
argument_list|)
expr_stmt|;
operator|*
name|min_length
operator|=
operator|*
name|max_length
operator|=
literal|0
expr_stmt|;
comment|/* Use old method for Phy older than IGP */
if|if
condition|(
name|hw
operator|->
name|phy_type
operator|==
name|em_phy_m88
condition|)
block|{
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_SPEC_STATUS
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|cable_length
operator|=
operator|(
name|phy_data
operator|&
name|M88E1000_PSSR_CABLE_LENGTH
operator|)
operator|>>
name|M88E1000_PSSR_CABLE_LENGTH_SHIFT
expr_stmt|;
comment|/* Convert the enum value to ranged values */
switch|switch
condition|(
name|cable_length
condition|)
block|{
case|case
name|em_cable_length_50
case|:
operator|*
name|min_length
operator|=
literal|0
expr_stmt|;
operator|*
name|max_length
operator|=
name|em_igp_cable_length_50
expr_stmt|;
break|break;
case|case
name|em_cable_length_50_80
case|:
operator|*
name|min_length
operator|=
name|em_igp_cable_length_50
expr_stmt|;
operator|*
name|max_length
operator|=
name|em_igp_cable_length_80
expr_stmt|;
break|break;
case|case
name|em_cable_length_80_110
case|:
operator|*
name|min_length
operator|=
name|em_igp_cable_length_80
expr_stmt|;
operator|*
name|max_length
operator|=
name|em_igp_cable_length_110
expr_stmt|;
break|break;
case|case
name|em_cable_length_110_140
case|:
operator|*
name|min_length
operator|=
name|em_igp_cable_length_110
expr_stmt|;
operator|*
name|max_length
operator|=
name|em_igp_cable_length_140
expr_stmt|;
break|break;
case|case
name|em_cable_length_140
case|:
operator|*
name|min_length
operator|=
name|em_igp_cable_length_140
expr_stmt|;
operator|*
name|max_length
operator|=
name|em_igp_cable_length_170
expr_stmt|;
break|break;
default|default:
return|return
operator|-
name|E1000_ERR_PHY
return|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|hw
operator|->
name|phy_type
operator|==
name|em_phy_gg82563
condition|)
block|{
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|GG82563_PHY_DSP_DISTANCE
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|cable_length
operator|=
name|phy_data
operator|&
name|GG82563_DSPD_CABLE_LENGTH
expr_stmt|;
switch|switch
condition|(
name|cable_length
condition|)
block|{
case|case
name|em_gg_cable_length_60
case|:
operator|*
name|min_length
operator|=
literal|0
expr_stmt|;
operator|*
name|max_length
operator|=
name|em_igp_cable_length_60
expr_stmt|;
break|break;
case|case
name|em_gg_cable_length_60_115
case|:
operator|*
name|min_length
operator|=
name|em_igp_cable_length_60
expr_stmt|;
operator|*
name|max_length
operator|=
name|em_igp_cable_length_115
expr_stmt|;
break|break;
case|case
name|em_gg_cable_length_115_150
case|:
operator|*
name|min_length
operator|=
name|em_igp_cable_length_115
expr_stmt|;
operator|*
name|max_length
operator|=
name|em_igp_cable_length_150
expr_stmt|;
break|break;
case|case
name|em_gg_cable_length_150
case|:
operator|*
name|min_length
operator|=
name|em_igp_cable_length_150
expr_stmt|;
operator|*
name|max_length
operator|=
name|em_igp_cable_length_180
expr_stmt|;
break|break;
default|default:
return|return
operator|-
name|E1000_ERR_PHY
return|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|hw
operator|->
name|phy_type
operator|==
name|em_phy_igp
condition|)
block|{
comment|/* For IGP PHY */
name|uint16_t
name|cur_agc_value
decl_stmt|;
name|uint16_t
name|min_agc_value
init|=
name|IGP01E1000_AGC_LENGTH_TABLE_SIZE
decl_stmt|;
name|uint16_t
name|agc_reg_array
index|[
name|IGP01E1000_PHY_CHANNEL_NUM
index|]
init|=
block|{
name|IGP01E1000_PHY_AGC_A
block|,
name|IGP01E1000_PHY_AGC_B
block|,
name|IGP01E1000_PHY_AGC_C
block|,
name|IGP01E1000_PHY_AGC_D
block|}
decl_stmt|;
comment|/* Read the AGC registers for all channels */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IGP01E1000_PHY_CHANNEL_NUM
condition|;
name|i
operator|++
control|)
block|{
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|agc_reg_array
index|[
name|i
index|]
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|cur_agc_value
operator|=
name|phy_data
operator|>>
name|IGP01E1000_AGC_LENGTH_SHIFT
expr_stmt|;
comment|/* Value bound check. */
if|if
condition|(
operator|(
name|cur_agc_value
operator|>=
name|IGP01E1000_AGC_LENGTH_TABLE_SIZE
operator|-
literal|1
operator|)
operator|||
operator|(
name|cur_agc_value
operator|==
literal|0
operator|)
condition|)
return|return
operator|-
name|E1000_ERR_PHY
return|;
name|agc_value
operator|+=
name|cur_agc_value
expr_stmt|;
comment|/* Update minimal AGC value. */
if|if
condition|(
name|min_agc_value
operator|>
name|cur_agc_value
condition|)
name|min_agc_value
operator|=
name|cur_agc_value
expr_stmt|;
block|}
comment|/* Remove the minimal AGC result for length< 50m */
if|if
condition|(
name|agc_value
operator|<
name|IGP01E1000_PHY_CHANNEL_NUM
operator|*
name|em_igp_cable_length_50
condition|)
block|{
name|agc_value
operator|-=
name|min_agc_value
expr_stmt|;
comment|/* Get the average length of the remaining 3 channels */
name|agc_value
operator|/=
operator|(
name|IGP01E1000_PHY_CHANNEL_NUM
operator|-
literal|1
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Get the average length of all the 4 channels. */
name|agc_value
operator|/=
name|IGP01E1000_PHY_CHANNEL_NUM
expr_stmt|;
block|}
comment|/* Set the range of the calculated length. */
operator|*
name|min_length
operator|=
operator|(
operator|(
name|em_igp_cable_length_table
index|[
name|agc_value
index|]
operator|-
name|IGP01E1000_AGC_RANGE
operator|)
operator|>
literal|0
operator|)
condition|?
operator|(
name|em_igp_cable_length_table
index|[
name|agc_value
index|]
operator|-
name|IGP01E1000_AGC_RANGE
operator|)
else|:
literal|0
expr_stmt|;
operator|*
name|max_length
operator|=
name|em_igp_cable_length_table
index|[
name|agc_value
index|]
operator|+
name|IGP01E1000_AGC_RANGE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|hw
operator|->
name|phy_type
operator|==
name|em_phy_igp_2
operator|||
name|hw
operator|->
name|phy_type
operator|==
name|em_phy_igp_3
condition|)
block|{
name|uint16_t
name|cur_agc_index
decl_stmt|,
name|max_agc_index
init|=
literal|0
decl_stmt|;
name|uint16_t
name|min_agc_index
init|=
name|IGP02E1000_AGC_LENGTH_TABLE_SIZE
operator|-
literal|1
decl_stmt|;
name|uint16_t
name|agc_reg_array
index|[
name|IGP02E1000_PHY_CHANNEL_NUM
index|]
init|=
block|{
name|IGP02E1000_PHY_AGC_A
block|,
name|IGP02E1000_PHY_AGC_B
block|,
name|IGP02E1000_PHY_AGC_C
block|,
name|IGP02E1000_PHY_AGC_D
block|}
decl_stmt|;
comment|/* Read the AGC registers for all channels */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IGP02E1000_PHY_CHANNEL_NUM
condition|;
name|i
operator|++
control|)
block|{
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|agc_reg_array
index|[
name|i
index|]
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
comment|/* Getting bits 15:9, which represent the combination of course and              * fine gain values.  The result is a number that can be put into              * the lookup table to obtain the approximate cable length. */
name|cur_agc_index
operator|=
operator|(
name|phy_data
operator|>>
name|IGP02E1000_AGC_LENGTH_SHIFT
operator|)
operator|&
name|IGP02E1000_AGC_LENGTH_MASK
expr_stmt|;
comment|/* Array index bound check. */
if|if
condition|(
operator|(
name|cur_agc_index
operator|>=
name|IGP02E1000_AGC_LENGTH_TABLE_SIZE
operator|)
operator|||
operator|(
name|cur_agc_index
operator|==
literal|0
operator|)
condition|)
return|return
operator|-
name|E1000_ERR_PHY
return|;
comment|/* Remove min& max AGC values from calculation. */
if|if
condition|(
name|em_igp_2_cable_length_table
index|[
name|min_agc_index
index|]
operator|>
name|em_igp_2_cable_length_table
index|[
name|cur_agc_index
index|]
condition|)
name|min_agc_index
operator|=
name|cur_agc_index
expr_stmt|;
if|if
condition|(
name|em_igp_2_cable_length_table
index|[
name|max_agc_index
index|]
operator|<
name|em_igp_2_cable_length_table
index|[
name|cur_agc_index
index|]
condition|)
name|max_agc_index
operator|=
name|cur_agc_index
expr_stmt|;
name|agc_value
operator|+=
name|em_igp_2_cable_length_table
index|[
name|cur_agc_index
index|]
expr_stmt|;
block|}
name|agc_value
operator|-=
operator|(
name|em_igp_2_cable_length_table
index|[
name|min_agc_index
index|]
operator|+
name|em_igp_2_cable_length_table
index|[
name|max_agc_index
index|]
operator|)
expr_stmt|;
name|agc_value
operator|/=
operator|(
name|IGP02E1000_PHY_CHANNEL_NUM
operator|-
literal|2
operator|)
expr_stmt|;
comment|/* Calculate cable length with the error range of +/- 10 meters. */
operator|*
name|min_length
operator|=
operator|(
operator|(
name|agc_value
operator|-
name|IGP02E1000_AGC_RANGE
operator|)
operator|>
literal|0
operator|)
condition|?
operator|(
name|agc_value
operator|-
name|IGP02E1000_AGC_RANGE
operator|)
else|:
literal|0
expr_stmt|;
operator|*
name|max_length
operator|=
name|agc_value
operator|+
name|IGP02E1000_AGC_RANGE
expr_stmt|;
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Check the cable polarity  *  * hw - Struct containing variables accessed by shared code  * polarity - output parameter : 0 - Polarity is not reversed  *                               1 - Polarity is reversed.  *  * returns: - E1000_ERR_XXX  *            E1000_SUCCESS  *  * For phy's older then IGP, this function simply reads the polarity bit in the  * Phy Status register.  For IGP phy's, this bit is valid only if link speed is  * 10 Mbps.  If the link speed is 100 Mbps there is no polarity so this bit will  * return 0.  If the link speed is 1000 Mbps the polarity status is in the  * IGP01E1000_PHY_PCS_INIT_REG.  *****************************************************************************/
end_comment

begin_function
name|STATIC
name|int32_t
name|em_check_polarity
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|em_rev_polarity
modifier|*
name|polarity
parameter_list|)
block|{
name|int32_t
name|ret_val
decl_stmt|;
name|uint16_t
name|phy_data
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_check_polarity"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|hw
operator|->
name|phy_type
operator|==
name|em_phy_m88
operator|)
operator|||
operator|(
name|hw
operator|->
name|phy_type
operator|==
name|em_phy_gg82563
operator|)
condition|)
block|{
comment|/* return the Polarity bit in the Status register. */
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_SPEC_STATUS
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
operator|*
name|polarity
operator|=
operator|(
operator|(
name|phy_data
operator|&
name|M88E1000_PSSR_REV_POLARITY
operator|)
operator|>>
name|M88E1000_PSSR_REV_POLARITY_SHIFT
operator|)
condition|?
name|em_rev_polarity_reversed
else|:
name|em_rev_polarity_normal
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|hw
operator|->
name|phy_type
operator|==
name|em_phy_igp
operator|||
name|hw
operator|->
name|phy_type
operator|==
name|em_phy_igp_3
operator|||
name|hw
operator|->
name|phy_type
operator|==
name|em_phy_igp_2
condition|)
block|{
comment|/* Read the Status register to check the speed */
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_STATUS
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
comment|/* If speed is 1000 Mbps, must read the IGP01E1000_PHY_PCS_INIT_REG to          * find the polarity status */
if|if
condition|(
operator|(
name|phy_data
operator|&
name|IGP01E1000_PSSR_SPEED_MASK
operator|)
operator|==
name|IGP01E1000_PSSR_SPEED_1000MBPS
condition|)
block|{
comment|/* Read the GIG initialization PCS register (0x00B4) */
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PCS_INIT_REG
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
comment|/* Check the polarity bits */
operator|*
name|polarity
operator|=
operator|(
name|phy_data
operator|&
name|IGP01E1000_PHY_POLARITY_MASK
operator|)
condition|?
name|em_rev_polarity_reversed
else|:
name|em_rev_polarity_normal
expr_stmt|;
block|}
else|else
block|{
comment|/* For 10 Mbps, read the polarity bit in the status register. (for              * 100 Mbps this bit is always 0) */
operator|*
name|polarity
operator|=
operator|(
name|phy_data
operator|&
name|IGP01E1000_PSSR_POLARITY_REVERSED
operator|)
condition|?
name|em_rev_polarity_reversed
else|:
name|em_rev_polarity_normal
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|hw
operator|->
name|phy_type
operator|==
name|em_phy_ife
condition|)
block|{
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|IFE_PHY_EXTENDED_STATUS_CONTROL
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
operator|*
name|polarity
operator|=
operator|(
operator|(
name|phy_data
operator|&
name|IFE_PESC_POLARITY_REVERSED
operator|)
operator|>>
name|IFE_PESC_POLARITY_REVERSED_SHIFT
operator|)
condition|?
name|em_rev_polarity_reversed
else|:
name|em_rev_polarity_normal
expr_stmt|;
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Check if Downshift occured  *  * hw - Struct containing variables accessed by shared code  * downshift - output parameter : 0 - No Downshift ocured.  *                                1 - Downshift ocured.  *  * returns: - E1000_ERR_XXX  *            E1000_SUCCESS  *  * For phy's older then IGP, this function reads the Downshift bit in the Phy  * Specific Status register.  For IGP phy's, it reads the Downgrade bit in the  * Link Health register.  In IGP this bit is latched high, so the driver must  * read it immediately after link is established.  *****************************************************************************/
end_comment

begin_function
name|STATIC
name|int32_t
name|em_check_downshift
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|int32_t
name|ret_val
decl_stmt|;
name|uint16_t
name|phy_data
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_check_downshift"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|phy_type
operator|==
name|em_phy_igp
operator|||
name|hw
operator|->
name|phy_type
operator|==
name|em_phy_igp_3
operator|||
name|hw
operator|->
name|phy_type
operator|==
name|em_phy_igp_2
condition|)
block|{
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_LINK_HEALTH
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|hw
operator|->
name|speed_downgraded
operator|=
operator|(
name|phy_data
operator|&
name|IGP01E1000_PLHR_SS_DOWNGRADE
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|hw
operator|->
name|phy_type
operator|==
name|em_phy_m88
operator|)
operator|||
operator|(
name|hw
operator|->
name|phy_type
operator|==
name|em_phy_gg82563
operator|)
condition|)
block|{
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_SPEC_STATUS
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|hw
operator|->
name|speed_downgraded
operator|=
operator|(
name|phy_data
operator|&
name|M88E1000_PSSR_DOWNSHIFT
operator|)
operator|>>
name|M88E1000_PSSR_DOWNSHIFT_SHIFT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|hw
operator|->
name|phy_type
operator|==
name|em_phy_ife
condition|)
block|{
comment|/* em_phy_ife supports 10/100 speed only */
name|hw
operator|->
name|speed_downgraded
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************  *  * 82541_rev_2& 82547_rev_2 have the capability to configure the DSP when a  * gigabit link is achieved to improve link quality.  *  * hw: Struct containing variables accessed by shared code  *  * returns: - E1000_ERR_PHY if fail to read/write the PHY  *            E1000_SUCCESS at any other case.  *  ****************************************************************************/
end_comment

begin_function
name|STATIC
name|int32_t
name|em_config_dsp_after_link_change
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|boolean_t
name|link_up
parameter_list|)
block|{
name|int32_t
name|ret_val
decl_stmt|;
name|uint16_t
name|phy_data
decl_stmt|,
name|phy_saved_data
decl_stmt|,
name|speed
decl_stmt|,
name|duplex
decl_stmt|,
name|i
decl_stmt|;
name|uint16_t
name|dsp_reg_array
index|[
name|IGP01E1000_PHY_CHANNEL_NUM
index|]
init|=
block|{
name|IGP01E1000_PHY_AGC_PARAM_A
block|,
name|IGP01E1000_PHY_AGC_PARAM_B
block|,
name|IGP01E1000_PHY_AGC_PARAM_C
block|,
name|IGP01E1000_PHY_AGC_PARAM_D
block|}
decl_stmt|;
name|uint16_t
name|min_length
decl_stmt|,
name|max_length
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_config_dsp_after_link_change"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|phy_type
operator|!=
name|em_phy_igp
condition|)
return|return
name|E1000_SUCCESS
return|;
if|if
condition|(
name|link_up
condition|)
block|{
name|ret_val
operator|=
name|em_get_speed_and_duplex
argument_list|(
name|hw
argument_list|,
operator|&
name|speed
argument_list|,
operator|&
name|duplex
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Error getting link speed and duplex\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
if|if
condition|(
name|speed
operator|==
name|SPEED_1000
condition|)
block|{
name|ret_val
operator|=
name|em_get_cable_length
argument_list|(
name|hw
argument_list|,
operator|&
name|min_length
argument_list|,
operator|&
name|max_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
if|if
condition|(
operator|(
name|hw
operator|->
name|dsp_config_state
operator|==
name|em_dsp_config_enabled
operator|)
operator|&&
name|min_length
operator|>=
name|em_igp_cable_length_50
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IGP01E1000_PHY_CHANNEL_NUM
condition|;
name|i
operator|++
control|)
block|{
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|dsp_reg_array
index|[
name|i
index|]
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|phy_data
operator|&=
operator|~
name|IGP01E1000_PHY_EDAC_MU_INDEX
expr_stmt|;
name|ret_val
operator|=
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|dsp_reg_array
index|[
name|i
index|]
argument_list|,
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
block|}
name|hw
operator|->
name|dsp_config_state
operator|=
name|em_dsp_config_activated
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|hw
operator|->
name|ffe_config_state
operator|==
name|em_ffe_config_enabled
operator|)
operator|&&
operator|(
name|min_length
operator|<
name|em_igp_cable_length_50
operator|)
condition|)
block|{
name|uint16_t
name|ffe_idle_err_timeout
init|=
name|FFE_IDLE_ERR_COUNT_TIMEOUT_20
decl_stmt|;
name|uint32_t
name|idle_errs
init|=
literal|0
decl_stmt|;
comment|/* clear previous idle error counts */
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_1000T_STATUS
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ffe_idle_err_timeout
condition|;
name|i
operator|++
control|)
block|{
name|usec_delay
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_1000T_STATUS
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|idle_errs
operator|+=
operator|(
name|phy_data
operator|&
name|SR_1000T_IDLE_ERROR_CNT
operator|)
expr_stmt|;
if|if
condition|(
name|idle_errs
operator|>
name|SR_1000T_PHY_EXCESSIVE_IDLE_ERR_COUNT
condition|)
block|{
name|hw
operator|->
name|ffe_config_state
operator|=
name|em_ffe_config_active
expr_stmt|;
name|ret_val
operator|=
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_DSP_FFE
argument_list|,
name|IGP01E1000_PHY_DSP_FFE_CM_CP
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
break|break;
block|}
if|if
condition|(
name|idle_errs
condition|)
name|ffe_idle_err_timeout
operator|=
name|FFE_IDLE_ERR_COUNT_TIMEOUT_100
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|hw
operator|->
name|dsp_config_state
operator|==
name|em_dsp_config_activated
condition|)
block|{
comment|/* Save off the current value of register 0x2F5B to be restored at              * the end of the routines. */
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
literal|0x2F5B
argument_list|,
operator|&
name|phy_saved_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
comment|/* Disable the PHY transmitter */
name|ret_val
operator|=
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
literal|0x2F5B
argument_list|,
literal|0x0003
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|msec_delay_irq
argument_list|(
literal|20
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
literal|0x0000
argument_list|,
name|IGP01E1000_IEEE_FORCE_GIGA
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IGP01E1000_PHY_CHANNEL_NUM
condition|;
name|i
operator|++
control|)
block|{
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|dsp_reg_array
index|[
name|i
index|]
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|phy_data
operator|&=
operator|~
name|IGP01E1000_PHY_EDAC_MU_INDEX
expr_stmt|;
name|phy_data
operator||=
name|IGP01E1000_PHY_EDAC_SIGN_EXT_9_BITS
expr_stmt|;
name|ret_val
operator|=
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|dsp_reg_array
index|[
name|i
index|]
argument_list|,
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
block|}
name|ret_val
operator|=
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
literal|0x0000
argument_list|,
name|IGP01E1000_IEEE_RESTART_AUTONEG
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|msec_delay_irq
argument_list|(
literal|20
argument_list|)
expr_stmt|;
comment|/* Now enable the transmitter */
name|ret_val
operator|=
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
literal|0x2F5B
argument_list|,
name|phy_saved_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|hw
operator|->
name|dsp_config_state
operator|=
name|em_dsp_config_enabled
expr_stmt|;
block|}
if|if
condition|(
name|hw
operator|->
name|ffe_config_state
operator|==
name|em_ffe_config_active
condition|)
block|{
comment|/* Save off the current value of register 0x2F5B to be restored at              * the end of the routines. */
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
literal|0x2F5B
argument_list|,
operator|&
name|phy_saved_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
comment|/* Disable the PHY transmitter */
name|ret_val
operator|=
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
literal|0x2F5B
argument_list|,
literal|0x0003
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|msec_delay_irq
argument_list|(
literal|20
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
literal|0x0000
argument_list|,
name|IGP01E1000_IEEE_FORCE_GIGA
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|ret_val
operator|=
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_DSP_FFE
argument_list|,
name|IGP01E1000_PHY_DSP_FFE_DEFAULT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|ret_val
operator|=
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
literal|0x0000
argument_list|,
name|IGP01E1000_IEEE_RESTART_AUTONEG
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|msec_delay_irq
argument_list|(
literal|20
argument_list|)
expr_stmt|;
comment|/* Now enable the transmitter */
name|ret_val
operator|=
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
literal|0x2F5B
argument_list|,
name|phy_saved_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|hw
operator|->
name|ffe_config_state
operator|=
name|em_ffe_config_enabled
expr_stmt|;
block|}
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************  * Set PHY to class A mode  * Assumes the following operations will follow to enable the new class mode.  *  1. Do a PHY soft reset  *  2. Restart auto-negotiation or force link.  *  * hw - Struct containing variables accessed by shared code  ****************************************************************************/
end_comment

begin_function
specifier|static
name|int32_t
name|em_set_phy_mode
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|int32_t
name|ret_val
decl_stmt|;
name|uint16_t
name|eeprom_data
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_set_phy_mode"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|hw
operator|->
name|mac_type
operator|==
name|em_82545_rev_3
operator|)
operator|&&
operator|(
name|hw
operator|->
name|media_type
operator|==
name|em_media_type_copper
operator|)
condition|)
block|{
name|ret_val
operator|=
name|em_read_eeprom
argument_list|(
name|hw
argument_list|,
name|EEPROM_PHY_CLASS_WORD
argument_list|,
literal|1
argument_list|,
operator|&
name|eeprom_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
return|return
name|ret_val
return|;
block|}
if|if
condition|(
operator|(
name|eeprom_data
operator|!=
name|EEPROM_RESERVED_WORD
operator|)
operator|&&
operator|(
name|eeprom_data
operator|&
name|EEPROM_PHY_CLASS_A
operator|)
condition|)
block|{
name|ret_val
operator|=
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_PAGE_SELECT
argument_list|,
literal|0x000B
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|ret_val
operator|=
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_GEN_CONTROL
argument_list|,
literal|0x8104
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|hw
operator|->
name|phy_reset_disable
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************  *  * This function sets the lplu state according to the active flag.  When  * activating lplu this function also disables smart speed and vise versa.  * lplu will not be activated unless the device autonegotiation advertisment  * meets standards of either 10 or 10/100 or 10/100/1000 at all duplexes.  * hw: Struct containing variables accessed by shared code  * active - true to enable lplu false to disable lplu.  *  * returns: - E1000_ERR_PHY if fail to read/write the PHY  *            E1000_SUCCESS at any other case.  *  ****************************************************************************/
end_comment

begin_function
name|STATIC
name|int32_t
name|em_set_d3_lplu_state
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|boolean_t
name|active
parameter_list|)
block|{
name|uint32_t
name|phy_ctrl
init|=
literal|0
decl_stmt|;
name|int32_t
name|ret_val
decl_stmt|;
name|uint16_t
name|phy_data
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_set_d3_lplu_state"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|phy_type
operator|!=
name|em_phy_igp
operator|&&
name|hw
operator|->
name|phy_type
operator|!=
name|em_phy_igp_2
operator|&&
name|hw
operator|->
name|phy_type
operator|!=
name|em_phy_igp_3
condition|)
return|return
name|E1000_SUCCESS
return|;
comment|/* During driver activity LPLU should not be used or it will attain link      * from the lowest speeds starting from 10Mbps. The capability is used for      * Dx transitions and states */
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|==
name|em_82541_rev_2
operator|||
name|hw
operator|->
name|mac_type
operator|==
name|em_82547_rev_2
condition|)
block|{
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_GMII_FIFO
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
block|}
elseif|else
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|==
name|em_ich8lan
condition|)
block|{
comment|/* MAC writes into PHY register based on the state transition          * and start auto-negotiation. SW driver can overwrite the settings          * in CSR PHY power control E1000_PHY_CTRL register. */
name|phy_ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|PHY_CTRL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP02E1000_PHY_POWER_MGMT
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
block|}
if|if
condition|(
operator|!
name|active
condition|)
block|{
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|==
name|em_82541_rev_2
operator|||
name|hw
operator|->
name|mac_type
operator|==
name|em_82547_rev_2
condition|)
block|{
name|phy_data
operator|&=
operator|~
name|IGP01E1000_GMII_FLEX_SPD
expr_stmt|;
name|ret_val
operator|=
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_GMII_FIFO
argument_list|,
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
block|}
else|else
block|{
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|==
name|em_ich8lan
condition|)
block|{
name|phy_ctrl
operator|&=
operator|~
name|E1000_PHY_CTRL_NOND0A_LPLU
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|PHY_CTRL
argument_list|,
name|phy_ctrl
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|phy_data
operator|&=
operator|~
name|IGP02E1000_PM_D3_LPLU
expr_stmt|;
name|ret_val
operator|=
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP02E1000_PHY_POWER_MGMT
argument_list|,
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
block|}
block|}
comment|/* LPLU and SmartSpeed are mutually exclusive.  LPLU is used during          * Dx states where the power conservation is most important.  During          * driver activity we should enable SmartSpeed, so performance is          * maintained. */
if|if
condition|(
name|hw
operator|->
name|smart_speed
operator|==
name|em_smart_speed_on
condition|)
block|{
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_CONFIG
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|phy_data
operator||=
name|IGP01E1000_PSCFR_SMART_SPEED
expr_stmt|;
name|ret_val
operator|=
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_CONFIG
argument_list|,
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
block|}
elseif|else
if|if
condition|(
name|hw
operator|->
name|smart_speed
operator|==
name|em_smart_speed_off
condition|)
block|{
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_CONFIG
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|phy_data
operator|&=
operator|~
name|IGP01E1000_PSCFR_SMART_SPEED
expr_stmt|;
name|ret_val
operator|=
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_CONFIG
argument_list|,
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|hw
operator|->
name|autoneg_advertised
operator|==
name|AUTONEG_ADVERTISE_SPEED_DEFAULT
operator|)
operator|||
operator|(
name|hw
operator|->
name|autoneg_advertised
operator|==
name|AUTONEG_ADVERTISE_10_ALL
operator|)
operator|||
operator|(
name|hw
operator|->
name|autoneg_advertised
operator|==
name|AUTONEG_ADVERTISE_10_100_ALL
operator|)
condition|)
block|{
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|==
name|em_82541_rev_2
operator|||
name|hw
operator|->
name|mac_type
operator|==
name|em_82547_rev_2
condition|)
block|{
name|phy_data
operator||=
name|IGP01E1000_GMII_FLEX_SPD
expr_stmt|;
name|ret_val
operator|=
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_GMII_FIFO
argument_list|,
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
block|}
else|else
block|{
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|==
name|em_ich8lan
condition|)
block|{
name|phy_ctrl
operator||=
name|E1000_PHY_CTRL_NOND0A_LPLU
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|PHY_CTRL
argument_list|,
name|phy_ctrl
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|phy_data
operator||=
name|IGP02E1000_PM_D3_LPLU
expr_stmt|;
name|ret_val
operator|=
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP02E1000_PHY_POWER_MGMT
argument_list|,
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
block|}
block|}
comment|/* When LPLU is enabled we should disable SmartSpeed */
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_CONFIG
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|phy_data
operator|&=
operator|~
name|IGP01E1000_PSCFR_SMART_SPEED
expr_stmt|;
name|ret_val
operator|=
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_CONFIG
argument_list|,
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************  *  * This function sets the lplu d0 state according to the active flag.  When  * activating lplu this function also disables smart speed and vise versa.  * lplu will not be activated unless the device autonegotiation advertisment  * meets standards of either 10 or 10/100 or 10/100/1000 at all duplexes.  * hw: Struct containing variables accessed by shared code  * active - true to enable lplu false to disable lplu.  *  * returns: - E1000_ERR_PHY if fail to read/write the PHY  *            E1000_SUCCESS at any other case.  *  ****************************************************************************/
end_comment

begin_function
name|STATIC
name|int32_t
name|em_set_d0_lplu_state
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|boolean_t
name|active
parameter_list|)
block|{
name|uint32_t
name|phy_ctrl
init|=
literal|0
decl_stmt|;
name|int32_t
name|ret_val
decl_stmt|;
name|uint16_t
name|phy_data
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_set_d0_lplu_state"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|<=
name|em_82547_rev_2
condition|)
return|return
name|E1000_SUCCESS
return|;
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|==
name|em_ich8lan
condition|)
block|{
name|phy_ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|PHY_CTRL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP02E1000_PHY_POWER_MGMT
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
block|}
if|if
condition|(
operator|!
name|active
condition|)
block|{
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|==
name|em_ich8lan
condition|)
block|{
name|phy_ctrl
operator|&=
operator|~
name|E1000_PHY_CTRL_D0A_LPLU
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|PHY_CTRL
argument_list|,
name|phy_ctrl
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|phy_data
operator|&=
operator|~
name|IGP02E1000_PM_D0_LPLU
expr_stmt|;
name|ret_val
operator|=
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP02E1000_PHY_POWER_MGMT
argument_list|,
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
block|}
comment|/* LPLU and SmartSpeed are mutually exclusive.  LPLU is used during          * Dx states where the power conservation is most important.  During          * driver activity we should enable SmartSpeed, so performance is          * maintained. */
if|if
condition|(
name|hw
operator|->
name|smart_speed
operator|==
name|em_smart_speed_on
condition|)
block|{
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_CONFIG
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|phy_data
operator||=
name|IGP01E1000_PSCFR_SMART_SPEED
expr_stmt|;
name|ret_val
operator|=
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_CONFIG
argument_list|,
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
block|}
elseif|else
if|if
condition|(
name|hw
operator|->
name|smart_speed
operator|==
name|em_smart_speed_off
condition|)
block|{
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_CONFIG
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|phy_data
operator|&=
operator|~
name|IGP01E1000_PSCFR_SMART_SPEED
expr_stmt|;
name|ret_val
operator|=
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_CONFIG
argument_list|,
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|==
name|em_ich8lan
condition|)
block|{
name|phy_ctrl
operator||=
name|E1000_PHY_CTRL_D0A_LPLU
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|PHY_CTRL
argument_list|,
name|phy_ctrl
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|phy_data
operator||=
name|IGP02E1000_PM_D0_LPLU
expr_stmt|;
name|ret_val
operator|=
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP02E1000_PHY_POWER_MGMT
argument_list|,
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
block|}
comment|/* When LPLU is enabled we should disable SmartSpeed */
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_CONFIG
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|phy_data
operator|&=
operator|~
name|IGP01E1000_PSCFR_SMART_SPEED
expr_stmt|;
name|ret_val
operator|=
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_CONFIG
argument_list|,
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Change VCO speed register to improve Bit Error Rate performance of SERDES.  *  * hw - Struct containing variables accessed by shared code  *****************************************************************************/
end_comment

begin_function
specifier|static
name|int32_t
name|em_set_vco_speed
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|int32_t
name|ret_val
decl_stmt|;
name|uint16_t
name|default_page
init|=
literal|0
decl_stmt|;
name|uint16_t
name|phy_data
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_set_vco_speed"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|hw
operator|->
name|mac_type
condition|)
block|{
case|case
name|em_82545_rev_3
case|:
case|case
name|em_82546_rev_3
case|:
break|break;
default|default:
return|return
name|E1000_SUCCESS
return|;
block|}
comment|/* Set PHY register 30, page 5, bit 8 to 0 */
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_PAGE_SELECT
argument_list|,
operator|&
name|default_page
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|ret_val
operator|=
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_PAGE_SELECT
argument_list|,
literal|0x0005
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_GEN_CONTROL
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|phy_data
operator|&=
operator|~
name|M88E1000_PHY_VCO_REG_BIT8
expr_stmt|;
name|ret_val
operator|=
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_GEN_CONTROL
argument_list|,
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
comment|/* Set PHY register 30, page 4, bit 11 to 1 */
name|ret_val
operator|=
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_PAGE_SELECT
argument_list|,
literal|0x0004
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_GEN_CONTROL
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|phy_data
operator||=
name|M88E1000_PHY_VCO_REG_BIT11
expr_stmt|;
name|ret_val
operator|=
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_GEN_CONTROL
argument_list|,
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|ret_val
operator|=
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_PAGE_SELECT
argument_list|,
name|default_page
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************  * This function reads the cookie from ARC ram.  *  * returns: - E1000_SUCCESS .  ****************************************************************************/
end_comment

begin_function
name|STATIC
name|int32_t
name|em_host_if_read_cookie
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint8_t
modifier|*
name|buffer
parameter_list|)
block|{
name|uint8_t
name|i
decl_stmt|;
name|uint32_t
name|offset
init|=
name|E1000_MNG_DHCP_COOKIE_OFFSET
decl_stmt|;
name|uint8_t
name|length
init|=
name|E1000_MNG_DHCP_COOKIE_LENGTH
decl_stmt|;
name|length
operator|=
operator|(
name|length
operator|>>
literal|2
operator|)
expr_stmt|;
name|offset
operator|=
operator|(
name|offset
operator|>>
literal|2
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
operator|*
operator|(
operator|(
name|uint32_t
operator|*
operator|)
name|buffer
operator|+
name|i
operator|)
operator|=
name|E1000_READ_REG_ARRAY_DWORD
argument_list|(
name|hw
argument_list|,
name|HOST_IF
argument_list|,
name|offset
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************  * This function checks whether the HOST IF is enabled for command operaton  * and also checks whether the previous command is completed.  * It busy waits in case of previous command is not completed.  *  * returns: - E1000_ERR_HOST_INTERFACE_COMMAND in case if is not ready or  *            timeout  *          - E1000_SUCCESS for success.  ****************************************************************************/
end_comment

begin_function
name|STATIC
name|int32_t
name|em_mng_enable_host_if
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|uint32_t
name|hicr
decl_stmt|;
name|uint8_t
name|i
decl_stmt|;
comment|/* Check that the host interface is enabled. */
name|hicr
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|HICR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|hicr
operator|&
name|E1000_HICR_EN
operator|)
operator|==
literal|0
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"E1000_HOST_EN bit disabled.\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_HOST_INTERFACE_COMMAND
return|;
block|}
comment|/* check the previous command is completed */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|E1000_MNG_DHCP_COMMAND_TIMEOUT
condition|;
name|i
operator|++
control|)
block|{
name|hicr
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|HICR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|hicr
operator|&
name|E1000_HICR_C
operator|)
condition|)
break|break;
name|msec_delay_irq
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
name|E1000_MNG_DHCP_COMMAND_TIMEOUT
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Previous command timeout failed .\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_HOST_INTERFACE_COMMAND
return|;
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************  * This function writes the buffer content at the offset given on the host if.  * It also does alignment considerations to do the writes in most efficient way.  * Also fills up the sum of the buffer in *buffer parameter.  *  * returns  - E1000_SUCCESS for success.  ****************************************************************************/
end_comment

begin_function
name|STATIC
name|int32_t
name|em_mng_host_if_write
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint8_t
modifier|*
name|buffer
parameter_list|,
name|uint16_t
name|length
parameter_list|,
name|uint16_t
name|offset
parameter_list|,
name|uint8_t
modifier|*
name|sum
parameter_list|)
block|{
name|uint8_t
modifier|*
name|tmp
decl_stmt|;
name|uint8_t
modifier|*
name|bufptr
init|=
name|buffer
decl_stmt|;
name|uint32_t
name|data
init|=
literal|0
decl_stmt|;
name|uint16_t
name|remaining
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|,
name|prev_bytes
decl_stmt|;
comment|/* sum = only sum of the data and it is not checksum */
if|if
condition|(
name|length
operator|==
literal|0
operator|||
name|offset
operator|+
name|length
operator|>
name|E1000_HI_MAX_MNG_DATA_LENGTH
condition|)
block|{
return|return
operator|-
name|E1000_ERR_PARAM
return|;
block|}
name|tmp
operator|=
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|data
expr_stmt|;
name|prev_bytes
operator|=
name|offset
operator|&
literal|0x3
expr_stmt|;
name|offset
operator|&=
literal|0xFFFC
expr_stmt|;
name|offset
operator|>>=
literal|2
expr_stmt|;
if|if
condition|(
name|prev_bytes
condition|)
block|{
name|data
operator|=
name|E1000_READ_REG_ARRAY_DWORD
argument_list|(
name|hw
argument_list|,
name|HOST_IF
argument_list|,
name|offset
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
name|prev_bytes
init|;
name|j
operator|<
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
operator|*
operator|(
name|tmp
operator|+
name|j
operator|)
operator|=
operator|*
name|bufptr
operator|++
expr_stmt|;
operator|*
name|sum
operator|+=
operator|*
operator|(
name|tmp
operator|+
name|j
operator|)
expr_stmt|;
block|}
name|E1000_WRITE_REG_ARRAY_DWORD
argument_list|(
name|hw
argument_list|,
name|HOST_IF
argument_list|,
name|offset
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|length
operator|-=
name|j
operator|-
name|prev_bytes
expr_stmt|;
name|offset
operator|++
expr_stmt|;
block|}
name|remaining
operator|=
name|length
operator|&
literal|0x3
expr_stmt|;
name|length
operator|-=
name|remaining
expr_stmt|;
comment|/* Calculate length in DWORDs */
name|length
operator|>>=
literal|2
expr_stmt|;
comment|/* The device driver writes the relevant command block into the      * ram area. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
operator|*
operator|(
name|tmp
operator|+
name|j
operator|)
operator|=
operator|*
name|bufptr
operator|++
expr_stmt|;
operator|*
name|sum
operator|+=
operator|*
operator|(
name|tmp
operator|+
name|j
operator|)
expr_stmt|;
block|}
name|E1000_WRITE_REG_ARRAY_DWORD
argument_list|(
name|hw
argument_list|,
name|HOST_IF
argument_list|,
name|offset
operator|+
name|i
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|remaining
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|j
operator|<
name|remaining
condition|)
operator|*
operator|(
name|tmp
operator|+
name|j
operator|)
operator|=
operator|*
name|bufptr
operator|++
expr_stmt|;
else|else
operator|*
operator|(
name|tmp
operator|+
name|j
operator|)
operator|=
literal|0
expr_stmt|;
operator|*
name|sum
operator|+=
operator|*
operator|(
name|tmp
operator|+
name|j
operator|)
expr_stmt|;
block|}
name|E1000_WRITE_REG_ARRAY_DWORD
argument_list|(
name|hw
argument_list|,
name|HOST_IF
argument_list|,
name|offset
operator|+
name|i
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************  * This function writes the command header after does the checksum calculation.  *  * returns  - E1000_SUCCESS for success.  ****************************************************************************/
end_comment

begin_function
name|STATIC
name|int32_t
name|em_mng_write_cmd_header
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|struct
name|em_host_mng_command_header
modifier|*
name|hdr
parameter_list|)
block|{
name|uint16_t
name|i
decl_stmt|;
name|uint8_t
name|sum
decl_stmt|;
name|uint8_t
modifier|*
name|buffer
decl_stmt|;
comment|/* Write the whole command header structure which includes sum of      * the buffer */
name|uint16_t
name|length
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|em_host_mng_command_header
argument_list|)
decl_stmt|;
name|sum
operator|=
name|hdr
operator|->
name|checksum
expr_stmt|;
name|hdr
operator|->
name|checksum
operator|=
literal|0
expr_stmt|;
name|buffer
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|hdr
expr_stmt|;
name|i
operator|=
name|length
expr_stmt|;
while|while
condition|(
name|i
operator|--
condition|)
name|sum
operator|+=
name|buffer
index|[
name|i
index|]
expr_stmt|;
name|hdr
operator|->
name|checksum
operator|=
literal|0
operator|-
name|sum
expr_stmt|;
name|length
operator|>>=
literal|2
expr_stmt|;
comment|/* The device driver writes the relevant command block into the ram area. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
name|E1000_WRITE_REG_ARRAY_DWORD
argument_list|(
name|hw
argument_list|,
name|HOST_IF
argument_list|,
name|i
argument_list|,
operator|*
operator|(
operator|(
name|uint32_t
operator|*
operator|)
name|hdr
operator|+
name|i
operator|)
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************  * This function indicates to ARC that a new command is pending which completes  * one write operation by the driver.  *  * returns  - E1000_SUCCESS for success.  ****************************************************************************/
end_comment

begin_function
name|STATIC
name|int32_t
name|em_mng_write_commit
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|uint32_t
name|hicr
decl_stmt|;
name|hicr
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|HICR
argument_list|)
expr_stmt|;
comment|/* Setting this bit tells the ARC that a new command is pending. */
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|HICR
argument_list|,
name|hicr
operator||
name|E1000_HICR_C
argument_list|)
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************  * This function checks the mode of the firmware.  *  * returns  - TRUE when the mode is IAMT or FALSE.  ****************************************************************************/
end_comment

begin_function
name|boolean_t
name|em_check_mng_mode
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|uint32_t
name|fwsm
decl_stmt|;
name|fwsm
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|FWSM
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|==
name|em_ich8lan
condition|)
block|{
if|if
condition|(
operator|(
name|fwsm
operator|&
name|E1000_FWSM_MODE_MASK
operator|)
operator|==
operator|(
name|E1000_MNG_ICH_IAMT_MODE
operator|<<
name|E1000_FWSM_MODE_SHIFT
operator|)
condition|)
return|return
name|TRUE
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|fwsm
operator|&
name|E1000_FWSM_MODE_MASK
operator|)
operator|==
operator|(
name|E1000_MNG_IAMT_MODE
operator|<<
name|E1000_FWSM_MODE_SHIFT
operator|)
condition|)
return|return
name|TRUE
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************  * This function writes the dhcp info .  ****************************************************************************/
end_comment

begin_function
name|int32_t
name|em_mng_write_dhcp_info
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint8_t
modifier|*
name|buffer
parameter_list|,
name|uint16_t
name|length
parameter_list|)
block|{
name|int32_t
name|ret_val
decl_stmt|;
name|struct
name|em_host_mng_command_header
name|hdr
decl_stmt|;
name|hdr
operator|.
name|command_id
operator|=
name|E1000_MNG_DHCP_TX_PAYLOAD_CMD
expr_stmt|;
name|hdr
operator|.
name|command_length
operator|=
name|length
expr_stmt|;
name|hdr
operator|.
name|reserved1
operator|=
literal|0
expr_stmt|;
name|hdr
operator|.
name|reserved2
operator|=
literal|0
expr_stmt|;
name|hdr
operator|.
name|checksum
operator|=
literal|0
expr_stmt|;
name|ret_val
operator|=
name|em_mng_enable_host_if
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
operator|==
name|E1000_SUCCESS
condition|)
block|{
name|ret_val
operator|=
name|em_mng_host_if_write
argument_list|(
name|hw
argument_list|,
name|buffer
argument_list|,
name|length
argument_list|,
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
argument_list|,
operator|&
operator|(
name|hdr
operator|.
name|checksum
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
operator|==
name|E1000_SUCCESS
condition|)
block|{
name|ret_val
operator|=
name|em_mng_write_cmd_header
argument_list|(
name|hw
argument_list|,
operator|&
name|hdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
operator|==
name|E1000_SUCCESS
condition|)
name|ret_val
operator|=
name|em_mng_write_commit
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************  * This function calculates the checksum.  *  * returns  - checksum of buffer contents.  ****************************************************************************/
end_comment

begin_function
name|STATIC
name|uint8_t
name|em_calculate_mng_checksum
parameter_list|(
name|char
modifier|*
name|buffer
parameter_list|,
name|uint32_t
name|length
parameter_list|)
block|{
name|uint8_t
name|sum
init|=
literal|0
decl_stmt|;
name|uint32_t
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|buffer
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
name|sum
operator|+=
name|buffer
index|[
name|i
index|]
expr_stmt|;
return|return
call|(
name|uint8_t
call|)
argument_list|(
literal|0
operator|-
name|sum
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************  * This function checks whether tx pkt filtering needs to be enabled or not.  *  * returns  - TRUE for packet filtering or FALSE.  ****************************************************************************/
end_comment

begin_function
name|boolean_t
name|em_enable_tx_pkt_filtering
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
comment|/* called in init as well as watchdog timer functions */
name|int32_t
name|ret_val
decl_stmt|,
name|checksum
decl_stmt|;
name|boolean_t
name|tx_filter
init|=
name|FALSE
decl_stmt|;
name|struct
name|em_host_mng_dhcp_cookie
modifier|*
name|hdr
init|=
operator|&
operator|(
name|hw
operator|->
name|mng_cookie
operator|)
decl_stmt|;
name|uint8_t
modifier|*
name|buffer
init|=
operator|(
name|uint8_t
operator|*
operator|)
operator|&
operator|(
name|hw
operator|->
name|mng_cookie
operator|)
decl_stmt|;
if|if
condition|(
name|em_check_mng_mode
argument_list|(
name|hw
argument_list|)
condition|)
block|{
name|ret_val
operator|=
name|em_mng_enable_host_if
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
operator|==
name|E1000_SUCCESS
condition|)
block|{
name|ret_val
operator|=
name|em_host_if_read_cookie
argument_list|(
name|hw
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
operator|==
name|E1000_SUCCESS
condition|)
block|{
name|checksum
operator|=
name|hdr
operator|->
name|checksum
expr_stmt|;
name|hdr
operator|->
name|checksum
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|hdr
operator|->
name|signature
operator|==
name|E1000_IAMT_SIGNATURE
operator|)
operator|&&
name|checksum
operator|==
name|em_calculate_mng_checksum
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buffer
argument_list|,
name|E1000_MNG_DHCP_COOKIE_LENGTH
argument_list|)
condition|)
block|{
if|if
condition|(
name|hdr
operator|->
name|status
operator|&
name|E1000_MNG_DHCP_COOKIE_STATUS_PARSING_SUPPORT
condition|)
name|tx_filter
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
name|tx_filter
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
name|tx_filter
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
name|hw
operator|->
name|tx_pkt_filtering
operator|=
name|tx_filter
expr_stmt|;
return|return
name|tx_filter
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Verifies the hardware needs to allow ARPs to be processed by the host  *  * hw - Struct containing variables accessed by shared code  *  * returns: - TRUE/FALSE  *  *****************************************************************************/
end_comment

begin_function
name|uint32_t
name|em_enable_mng_pass_thru
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|uint32_t
name|manc
decl_stmt|;
name|uint32_t
name|fwsm
decl_stmt|,
name|factps
decl_stmt|;
if|if
condition|(
name|hw
operator|->
name|asf_firmware_present
condition|)
block|{
name|manc
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|MANC
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|manc
operator|&
name|E1000_MANC_RCV_TCO_EN
operator|)
operator|||
operator|!
operator|(
name|manc
operator|&
name|E1000_MANC_EN_MAC_ADDR_FILTER
operator|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|em_arc_subsystem_valid
argument_list|(
name|hw
argument_list|)
operator|==
name|TRUE
condition|)
block|{
name|fwsm
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|FWSM
argument_list|)
expr_stmt|;
name|factps
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|FACTPS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|fwsm
operator|&
name|E1000_FWSM_MODE_MASK
operator|)
operator|==
operator|(
name|em_mng_mode_pt
operator|<<
name|E1000_FWSM_MODE_SHIFT
operator|)
operator|)
operator|&&
operator|(
name|factps
operator|&
name|E1000_FACTPS_MNGCG
operator|)
condition|)
return|return
name|TRUE
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|manc
operator|&
name|E1000_MANC_SMBUS_EN
operator|)
operator|&&
operator|!
operator|(
name|manc
operator|&
name|E1000_MANC_ASF_EN
operator|)
condition|)
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|int32_t
name|em_polarity_reversal_workaround
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|int32_t
name|ret_val
decl_stmt|;
name|uint16_t
name|mii_status_reg
decl_stmt|;
name|uint16_t
name|i
decl_stmt|;
comment|/* Polarity reversal workaround for forced 10F/10H links. */
comment|/* Disable the transmitter on the PHY */
name|ret_val
operator|=
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_PAGE_SELECT
argument_list|,
literal|0x0019
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|ret_val
operator|=
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_GEN_CONTROL
argument_list|,
literal|0xFFFF
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|ret_val
operator|=
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_PAGE_SELECT
argument_list|,
literal|0x0000
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
comment|/* This loop will early-out if the NO link condition has been met. */
for|for
control|(
name|i
operator|=
name|PHY_FORCE_TIME
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
comment|/* Read the MII Status Register and wait for Link Status bit          * to be clear.          */
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_STATUS
argument_list|,
operator|&
name|mii_status_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_STATUS
argument_list|,
operator|&
name|mii_status_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
if|if
condition|(
operator|(
name|mii_status_reg
operator|&
operator|~
name|MII_SR_LINK_STATUS
operator|)
operator|==
literal|0
condition|)
break|break;
name|msec_delay_irq
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
comment|/* Recommended delay time after link has been lost */
name|msec_delay_irq
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
comment|/* Now we will re-enable th transmitter on the PHY */
name|ret_val
operator|=
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_PAGE_SELECT
argument_list|,
literal|0x0019
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|msec_delay_irq
argument_list|(
literal|50
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_GEN_CONTROL
argument_list|,
literal|0xFFF0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|msec_delay_irq
argument_list|(
literal|50
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_GEN_CONTROL
argument_list|,
literal|0xFF00
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|msec_delay_irq
argument_list|(
literal|50
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_GEN_CONTROL
argument_list|,
literal|0x0000
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|ret_val
operator|=
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_PAGE_SELECT
argument_list|,
literal|0x0000
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
comment|/* This loop will early-out if the link condition has been met. */
for|for
control|(
name|i
operator|=
name|PHY_FORCE_TIME
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
comment|/* Read the MII Status Register and wait for Link Status bit          * to be set.          */
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_STATUS
argument_list|,
operator|&
name|mii_status_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_STATUS
argument_list|,
operator|&
name|mii_status_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
if|if
condition|(
name|mii_status_reg
operator|&
name|MII_SR_LINK_STATUS
condition|)
break|break;
name|msec_delay_irq
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/***************************************************************************  *  * Disables PCI-Express master access.  *  * hw: Struct containing variables accessed by shared code  *  * returns: - none.  *  ***************************************************************************/
end_comment

begin_function
name|STATIC
name|void
name|em_set_pci_express_master_disable
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|uint32_t
name|ctrl
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_set_pci_express_master_disable"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|bus_type
operator|!=
name|em_bus_type_pci_express
condition|)
return|return;
name|ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|)
expr_stmt|;
name|ctrl
operator||=
name|E1000_CTRL_GIO_MASTER_DISABLE
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * Disables PCI-Express master access and verifies there are no pending requests  *  * hw: Struct containing variables accessed by shared code  *  * returns: - E1000_ERR_MASTER_REQUESTS_PENDING if master disable bit hasn't  *            caused the master requests to be disabled.  *            E1000_SUCCESS master requests disabled.  *  ******************************************************************************/
end_comment

begin_function
name|int32_t
name|em_disable_pciex_master
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|int32_t
name|timeout
init|=
name|MASTER_DISABLE_TIMEOUT
decl_stmt|;
comment|/* 80ms */
name|DEBUGFUNC
argument_list|(
literal|"em_disable_pciex_master"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|bus_type
operator|!=
name|em_bus_type_pci_express
condition|)
return|return
name|E1000_SUCCESS
return|;
name|em_set_pci_express_master_disable
argument_list|(
name|hw
argument_list|)
expr_stmt|;
while|while
condition|(
name|timeout
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|STATUS
argument_list|)
operator|&
name|E1000_STATUS_GIO_MASTER_ENABLE
operator|)
condition|)
break|break;
else|else
name|usec_delay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|timeout
operator|--
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|timeout
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Master requests are pending.\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_MASTER_REQUESTS_PENDING
return|;
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * Check for EEPROM Auto Read bit done.  *  * hw: Struct containing variables accessed by shared code  *  * returns: - E1000_ERR_RESET if fail to reset MAC  *            E1000_SUCCESS at any other case.  *  ******************************************************************************/
end_comment

begin_function
name|STATIC
name|int32_t
name|em_get_auto_rd_done
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|int32_t
name|timeout
init|=
name|AUTO_READ_DONE_TIMEOUT
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_get_auto_rd_done"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|hw
operator|->
name|mac_type
condition|)
block|{
default|default:
name|msec_delay
argument_list|(
literal|5
argument_list|)
expr_stmt|;
break|break;
case|case
name|em_82571
case|:
case|case
name|em_82572
case|:
case|case
name|em_82573
case|:
case|case
name|em_80003es2lan
case|:
case|case
name|em_ich8lan
case|:
while|while
condition|(
name|timeout
condition|)
block|{
if|if
condition|(
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|EECD
argument_list|)
operator|&
name|E1000_EECD_AUTO_RD
condition|)
break|break;
else|else
name|msec_delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|timeout
operator|--
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|timeout
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Auto read by HW from EEPROM has not completed.\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_RESET
return|;
block|}
break|break;
block|}
comment|/* PHY configuration from NVM just starts after EECD_AUTO_RD sets to high.      * Need to wait for PHY configuration completion before accessing NVM      * and PHY. */
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|==
name|em_82573
condition|)
name|msec_delay
argument_list|(
literal|25
argument_list|)
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/***************************************************************************  * Checks if the PHY configuration is done  *  * hw: Struct containing variables accessed by shared code  *  * returns: - E1000_ERR_RESET if fail to reset MAC  *            E1000_SUCCESS at any other case.  *  ***************************************************************************/
end_comment

begin_function
name|STATIC
name|int32_t
name|em_get_phy_cfg_done
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|int32_t
name|timeout
init|=
name|PHY_CFG_TIMEOUT
decl_stmt|;
name|uint32_t
name|cfg_mask
init|=
name|E1000_EEPROM_CFG_DONE
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_get_phy_cfg_done"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|hw
operator|->
name|mac_type
condition|)
block|{
default|default:
name|msec_delay_irq
argument_list|(
literal|10
argument_list|)
expr_stmt|;
break|break;
case|case
name|em_80003es2lan
case|:
comment|/* Separate *_CFG_DONE_* bit for each port */
if|if
condition|(
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|STATUS
argument_list|)
operator|&
name|E1000_STATUS_FUNC_1
condition|)
name|cfg_mask
operator|=
name|E1000_EEPROM_CFG_DONE_PORT_1
expr_stmt|;
comment|/* Fall Through */
case|case
name|em_82571
case|:
case|case
name|em_82572
case|:
while|while
condition|(
name|timeout
condition|)
block|{
if|if
condition|(
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|EEMNGCTL
argument_list|)
operator|&
name|cfg_mask
condition|)
break|break;
else|else
name|msec_delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|timeout
operator|--
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|timeout
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"MNG configuration cycle has not completed.\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_RESET
return|;
block|}
break|break;
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/***************************************************************************  *  * Using the combination of SMBI and SWESMBI semaphore bits when resetting  * adapter or Eeprom access.  *  * hw: Struct containing variables accessed by shared code  *  * returns: - E1000_ERR_EEPROM if fail to access EEPROM.  *            E1000_SUCCESS at any other case.  *  ***************************************************************************/
end_comment

begin_function
name|STATIC
name|int32_t
name|em_get_hw_eeprom_semaphore
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|int32_t
name|timeout
decl_stmt|;
name|uint32_t
name|swsm
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_get_hw_eeprom_semaphore"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hw
operator|->
name|eeprom_semaphore_present
condition|)
return|return
name|E1000_SUCCESS
return|;
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|==
name|em_80003es2lan
condition|)
block|{
comment|/* Get the SW semaphore. */
if|if
condition|(
name|em_get_software_semaphore
argument_list|(
name|hw
argument_list|)
operator|!=
name|E1000_SUCCESS
condition|)
return|return
operator|-
name|E1000_ERR_EEPROM
return|;
block|}
comment|/* Get the FW semaphore. */
name|timeout
operator|=
name|hw
operator|->
name|eeprom
operator|.
name|word_size
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|timeout
condition|)
block|{
name|swsm
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|SWSM
argument_list|)
expr_stmt|;
name|swsm
operator||=
name|E1000_SWSM_SWESMBI
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|SWSM
argument_list|,
name|swsm
argument_list|)
expr_stmt|;
comment|/* if we managed to set the bit we got the semaphore. */
name|swsm
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|SWSM
argument_list|)
expr_stmt|;
if|if
condition|(
name|swsm
operator|&
name|E1000_SWSM_SWESMBI
condition|)
break|break;
name|usec_delay
argument_list|(
literal|50
argument_list|)
expr_stmt|;
name|timeout
operator|--
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|timeout
condition|)
block|{
comment|/* Release semaphores */
name|em_put_hw_eeprom_semaphore
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Driver can't access the Eeprom - SWESMBI bit is set.\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_EEPROM
return|;
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/***************************************************************************  * This function clears HW semaphore bits.  *  * hw: Struct containing variables accessed by shared code  *  * returns: - None.  *  ***************************************************************************/
end_comment

begin_function
name|STATIC
name|void
name|em_put_hw_eeprom_semaphore
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|uint32_t
name|swsm
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_put_hw_eeprom_semaphore"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hw
operator|->
name|eeprom_semaphore_present
condition|)
return|return;
name|swsm
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|SWSM
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|==
name|em_80003es2lan
condition|)
block|{
comment|/* Release both semaphores. */
name|swsm
operator|&=
operator|~
operator|(
name|E1000_SWSM_SMBI
operator||
name|E1000_SWSM_SWESMBI
operator|)
expr_stmt|;
block|}
else|else
name|swsm
operator|&=
operator|~
operator|(
name|E1000_SWSM_SWESMBI
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|SWSM
argument_list|,
name|swsm
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/***************************************************************************  *  * Obtaining software semaphore bit (SMBI) before resetting PHY.  *  * hw: Struct containing variables accessed by shared code  *  * returns: - E1000_ERR_RESET if fail to obtain semaphore.  *            E1000_SUCCESS at any other case.  *  ***************************************************************************/
end_comment

begin_function
name|STATIC
name|int32_t
name|em_get_software_semaphore
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|int32_t
name|timeout
init|=
name|hw
operator|->
name|eeprom
operator|.
name|word_size
operator|+
literal|1
decl_stmt|;
name|uint32_t
name|swsm
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_get_software_semaphore"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|!=
name|em_80003es2lan
condition|)
block|{
return|return
name|E1000_SUCCESS
return|;
block|}
while|while
condition|(
name|timeout
condition|)
block|{
name|swsm
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|SWSM
argument_list|)
expr_stmt|;
comment|/* If SMBI bit cleared, it is now set and we hold the semaphore */
if|if
condition|(
operator|!
operator|(
name|swsm
operator|&
name|E1000_SWSM_SMBI
operator|)
condition|)
break|break;
name|msec_delay_irq
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|timeout
operator|--
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|timeout
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Driver can't access device - SMBI bit is set.\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_RESET
return|;
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/***************************************************************************  *  * Release semaphore bit (SMBI).  *  * hw: Struct containing variables accessed by shared code  *  ***************************************************************************/
end_comment

begin_function
name|STATIC
name|void
name|em_release_software_semaphore
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|uint32_t
name|swsm
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_release_software_semaphore"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|!=
name|em_80003es2lan
condition|)
block|{
return|return;
block|}
name|swsm
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|SWSM
argument_list|)
expr_stmt|;
comment|/* Release the SW semaphores.*/
name|swsm
operator|&=
operator|~
name|E1000_SWSM_SMBI
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|SWSM
argument_list|,
name|swsm
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Checks if PHY reset is blocked due to SOL/IDER session, for example.  * Returning E1000_BLK_PHY_RESET isn't necessarily an error.  But it's up to  * the caller to figure out how to deal with it.  *  * hw - Struct containing variables accessed by shared code  *  * returns: - E1000_BLK_PHY_RESET  *            E1000_SUCCESS  *  *****************************************************************************/
end_comment

begin_function
name|int32_t
name|em_check_phy_reset_block
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|uint32_t
name|manc
init|=
literal|0
decl_stmt|;
name|uint32_t
name|fwsm
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|==
name|em_ich8lan
condition|)
block|{
name|fwsm
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|FWSM
argument_list|)
expr_stmt|;
return|return
operator|(
name|fwsm
operator|&
name|E1000_FWSM_RSPCIPHY
operator|)
condition|?
name|E1000_SUCCESS
else|:
name|E1000_BLK_PHY_RESET
return|;
block|}
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|>
name|em_82547_rev_2
condition|)
name|manc
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|MANC
argument_list|)
expr_stmt|;
return|return
operator|(
name|manc
operator|&
name|E1000_MANC_BLK_PHY_RST_ON_IDE
operator|)
condition|?
name|E1000_BLK_PHY_RESET
else|:
name|E1000_SUCCESS
return|;
block|}
end_function

begin_function
name|STATIC
name|uint8_t
name|em_arc_subsystem_valid
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|uint32_t
name|fwsm
decl_stmt|;
comment|/* On 8257x silicon, registers in the range of 0x8800 - 0x8FFC      * may not be provided a DMA clock when no manageability features are      * enabled.  We do not want to perform any reads/writes to these registers      * if this is the case.  We read FWSM to determine the manageability mode.      */
switch|switch
condition|(
name|hw
operator|->
name|mac_type
condition|)
block|{
case|case
name|em_82571
case|:
case|case
name|em_82572
case|:
case|case
name|em_82573
case|:
case|case
name|em_80003es2lan
case|:
name|fwsm
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|FWSM
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fwsm
operator|&
name|E1000_FWSM_MODE_MASK
operator|)
operator|!=
literal|0
condition|)
return|return
name|TRUE
return|;
break|break;
case|case
name|em_ich8lan
case|:
return|return
name|TRUE
return|;
default|default:
break|break;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Configure PCI-Ex no-snoop  *  * hw - Struct containing variables accessed by shared code.  * no_snoop - Bitmap of no-snoop events.  *  * returns: E1000_SUCCESS  *  *****************************************************************************/
end_comment

begin_function
name|STATIC
name|int32_t
name|em_set_pci_ex_no_snoop
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint32_t
name|no_snoop
parameter_list|)
block|{
name|uint32_t
name|gcr_reg
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_set_pci_ex_no_snoop"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|bus_type
operator|==
name|em_bus_type_unknown
condition|)
name|em_get_bus_info
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|bus_type
operator|!=
name|em_bus_type_pci_express
condition|)
return|return
name|E1000_SUCCESS
return|;
if|if
condition|(
name|no_snoop
condition|)
block|{
name|gcr_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|GCR
argument_list|)
expr_stmt|;
name|gcr_reg
operator|&=
operator|~
operator|(
name|PCI_EX_NO_SNOOP_ALL
operator|)
expr_stmt|;
name|gcr_reg
operator||=
name|no_snoop
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|GCR
argument_list|,
name|gcr_reg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|==
name|em_ich8lan
condition|)
block|{
name|uint32_t
name|ctrl_ext
decl_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|GCR
argument_list|,
name|PCI_EX_82566_SNOOP_ALL
argument_list|)
expr_stmt|;
name|ctrl_ext
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|CTRL_EXT
argument_list|)
expr_stmt|;
name|ctrl_ext
operator||=
name|E1000_CTRL_EXT_RO_DIS
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|CTRL_EXT
argument_list|,
name|ctrl_ext
argument_list|)
expr_stmt|;
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/***************************************************************************  *  * Get software semaphore FLAG bit (SWFLAG).  * SWFLAG is used to synchronize the access to all shared resource between  * SW, FW and HW.  *  * hw: Struct containing variables accessed by shared code  *  ***************************************************************************/
end_comment

begin_function
name|STATIC
name|int32_t
name|em_get_software_flag
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|int32_t
name|timeout
init|=
name|PHY_CFG_TIMEOUT
decl_stmt|;
name|uint32_t
name|extcnf_ctrl
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_get_software_flag"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|==
name|em_ich8lan
condition|)
block|{
while|while
condition|(
name|timeout
condition|)
block|{
name|extcnf_ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|EXTCNF_CTRL
argument_list|)
expr_stmt|;
name|extcnf_ctrl
operator||=
name|E1000_EXTCNF_CTRL_SWFLAG
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|EXTCNF_CTRL
argument_list|,
name|extcnf_ctrl
argument_list|)
expr_stmt|;
name|extcnf_ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|EXTCNF_CTRL
argument_list|)
expr_stmt|;
if|if
condition|(
name|extcnf_ctrl
operator|&
name|E1000_EXTCNF_CTRL_SWFLAG
condition|)
break|break;
name|msec_delay_irq
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|timeout
operator|--
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|timeout
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"FW or HW locks the resource too long.\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_CONFIG
return|;
block|}
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/***************************************************************************  *  * Release software semaphore FLAG bit (SWFLAG).  * SWFLAG is used to synchronize the access to all shared resource between  * SW, FW and HW.  *  * hw: Struct containing variables accessed by shared code  *  ***************************************************************************/
end_comment

begin_function
name|STATIC
name|void
name|em_release_software_flag
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|uint32_t
name|extcnf_ctrl
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_release_software_flag"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|==
name|em_ich8lan
condition|)
block|{
name|extcnf_ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|EXTCNF_CTRL
argument_list|)
expr_stmt|;
name|extcnf_ctrl
operator|&=
operator|~
name|E1000_EXTCNF_CTRL_SWFLAG
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|EXTCNF_CTRL
argument_list|,
name|extcnf_ctrl
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Reads a 16 bit word or words from the EEPROM using the ICH8's flash access  * register.  *  * hw - Struct containing variables accessed by shared code  * offset - offset of word in the EEPROM to read  * data - word read from the EEPROM  * words - number of words to read  *****************************************************************************/
end_comment

begin_function
name|STATIC
name|int32_t
name|em_read_eeprom_ich8
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint16_t
name|offset
parameter_list|,
name|uint16_t
name|words
parameter_list|,
name|uint16_t
modifier|*
name|data
parameter_list|)
block|{
name|int32_t
name|error
init|=
name|E1000_SUCCESS
decl_stmt|;
name|uint32_t
name|flash_bank
init|=
literal|0
decl_stmt|;
name|uint32_t
name|act_offset
init|=
literal|0
decl_stmt|;
name|uint32_t
name|bank_offset
init|=
literal|0
decl_stmt|;
name|uint16_t
name|word
init|=
literal|0
decl_stmt|;
name|uint16_t
name|i
init|=
literal|0
decl_stmt|;
comment|/* We need to know which is the valid flash bank.  In the event      * that we didn't allocate eeprom_shadow_ram, we may not be      * managing flash_bank.  So it cannot be trusted and needs      * to be updated with each read.      */
comment|/* Value of bit 22 corresponds to the flash bank we're on. */
name|flash_bank
operator|=
operator|(
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|EECD
argument_list|)
operator|&
name|E1000_EECD_SEC1VAL
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
comment|/* Adjust offset appropriately if we're on bank 1 - adjust for word size */
name|bank_offset
operator|=
name|flash_bank
operator|*
operator|(
name|hw
operator|->
name|flash_bank_size
operator|*
literal|2
operator|)
expr_stmt|;
name|error
operator|=
name|em_get_software_flag
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|E1000_SUCCESS
condition|)
return|return
name|error
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|words
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|hw
operator|->
name|eeprom_shadow_ram
operator|!=
name|NULL
operator|&&
name|hw
operator|->
name|eeprom_shadow_ram
index|[
name|offset
operator|+
name|i
index|]
operator|.
name|modified
operator|==
name|TRUE
condition|)
block|{
name|data
index|[
name|i
index|]
operator|=
name|hw
operator|->
name|eeprom_shadow_ram
index|[
name|offset
operator|+
name|i
index|]
operator|.
name|eeprom_word
expr_stmt|;
block|}
else|else
block|{
comment|/* The NVM part needs a byte offset, hence * 2 */
name|act_offset
operator|=
name|bank_offset
operator|+
operator|(
operator|(
name|offset
operator|+
name|i
operator|)
operator|*
literal|2
operator|)
expr_stmt|;
name|error
operator|=
name|em_read_ich8_word
argument_list|(
name|hw
argument_list|,
name|act_offset
argument_list|,
operator|&
name|word
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|E1000_SUCCESS
condition|)
break|break;
name|data
index|[
name|i
index|]
operator|=
name|word
expr_stmt|;
block|}
block|}
name|em_release_software_flag
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Writes a 16 bit word or words to the EEPROM using the ICH8's flash access  * register.  Actually, writes are written to the shadow ram cache in the hw  * structure hw->em_shadow_ram.  em_commit_shadow_ram flushes this to  * the NVM, which occurs when the NVM checksum is updated.  *  * hw - Struct containing variables accessed by shared code  * offset - offset of word in the EEPROM to write  * words - number of words to write  * data - words to write to the EEPROM  *****************************************************************************/
end_comment

begin_function
name|STATIC
name|int32_t
name|em_write_eeprom_ich8
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint16_t
name|offset
parameter_list|,
name|uint16_t
name|words
parameter_list|,
name|uint16_t
modifier|*
name|data
parameter_list|)
block|{
name|uint32_t
name|i
init|=
literal|0
decl_stmt|;
name|int32_t
name|error
init|=
name|E1000_SUCCESS
decl_stmt|;
name|error
operator|=
name|em_get_software_flag
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|E1000_SUCCESS
condition|)
return|return
name|error
return|;
comment|/* A driver can write to the NVM only if it has eeprom_shadow_ram      * allocated.  Subsequent reads to the modified words are read from      * this cached structure as well.  Writes will only go into this      * cached structure unless it's followed by a call to      * em_update_eeprom_checksum() where it will commit the changes      * and clear the "modified" field.      */
if|if
condition|(
name|hw
operator|->
name|eeprom_shadow_ram
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|words
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|offset
operator|+
name|i
operator|)
operator|<
name|E1000_SHADOW_RAM_WORDS
condition|)
block|{
name|hw
operator|->
name|eeprom_shadow_ram
index|[
name|offset
operator|+
name|i
index|]
operator|.
name|modified
operator|=
name|TRUE
expr_stmt|;
name|hw
operator|->
name|eeprom_shadow_ram
index|[
name|offset
operator|+
name|i
index|]
operator|.
name|eeprom_word
operator|=
name|data
index|[
name|i
index|]
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
operator|-
name|E1000_ERR_EEPROM
expr_stmt|;
break|break;
block|}
block|}
block|}
else|else
block|{
comment|/* Drivers have the option to not allocate eeprom_shadow_ram as long          * as they don't perform any NVM writes.  An attempt in doing so          * will result in this error.          */
name|error
operator|=
operator|-
name|E1000_ERR_EEPROM
expr_stmt|;
block|}
name|em_release_software_flag
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * This function does initial flash setup so that a new read/write/erase cycle  * can be started.  *  * hw - The pointer to the hw structure  ****************************************************************************/
end_comment

begin_function
name|STATIC
name|int32_t
name|em_ich8_cycle_init
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|union
name|ich8_hws_flash_status
name|hsfsts
decl_stmt|;
name|int32_t
name|error
init|=
name|E1000_ERR_EEPROM
decl_stmt|;
name|int32_t
name|i
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_ich8_cycle_init"
argument_list|)
expr_stmt|;
name|hsfsts
operator|.
name|regval
operator|=
name|E1000_READ_ICH_FLASH_REG16
argument_list|(
name|hw
argument_list|,
name|ICH_FLASH_HSFSTS
argument_list|)
expr_stmt|;
comment|/* May be check the Flash Des Valid bit in Hw status */
if|if
condition|(
name|hsfsts
operator|.
name|hsf_status
operator|.
name|fldesvalid
operator|==
literal|0
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Flash descriptor invalid.  SW Sequencing must be used."
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* Clear FCERR in Hw status by writing 1 */
comment|/* Clear DAEL in Hw status by writing a 1 */
name|hsfsts
operator|.
name|hsf_status
operator|.
name|flcerr
operator|=
literal|1
expr_stmt|;
name|hsfsts
operator|.
name|hsf_status
operator|.
name|dael
operator|=
literal|1
expr_stmt|;
name|E1000_WRITE_ICH_FLASH_REG16
argument_list|(
name|hw
argument_list|,
name|ICH_FLASH_HSFSTS
argument_list|,
name|hsfsts
operator|.
name|regval
argument_list|)
expr_stmt|;
comment|/* Either we should have a hardware SPI cycle in progress bit to check      * against, in order to start a new cycle or FDONE bit should be changed      * in the hardware so that it is 1 after harware reset, which can then be      * used as an indication whether a cycle is in progress or has been      * completed .. we should also have some software semaphore mechanism to      * guard FDONE or the cycle in progress bit so that two threads access to      * those bits can be sequentiallized or a way so that 2 threads dont      * start the cycle at the same time */
if|if
condition|(
name|hsfsts
operator|.
name|hsf_status
operator|.
name|flcinprog
operator|==
literal|0
condition|)
block|{
comment|/* There is no cycle running at present, so we can start a cycle */
comment|/* Begin by setting Flash Cycle Done. */
name|hsfsts
operator|.
name|hsf_status
operator|.
name|flcdone
operator|=
literal|1
expr_stmt|;
name|E1000_WRITE_ICH_FLASH_REG16
argument_list|(
name|hw
argument_list|,
name|ICH_FLASH_HSFSTS
argument_list|,
name|hsfsts
operator|.
name|regval
argument_list|)
expr_stmt|;
name|error
operator|=
name|E1000_SUCCESS
expr_stmt|;
block|}
else|else
block|{
comment|/* otherwise poll for sometime so the current cycle has a chance          * to end before giving up. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ICH_FLASH_COMMAND_TIMEOUT
condition|;
name|i
operator|++
control|)
block|{
name|hsfsts
operator|.
name|regval
operator|=
name|E1000_READ_ICH_FLASH_REG16
argument_list|(
name|hw
argument_list|,
name|ICH_FLASH_HSFSTS
argument_list|)
expr_stmt|;
if|if
condition|(
name|hsfsts
operator|.
name|hsf_status
operator|.
name|flcinprog
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|E1000_SUCCESS
expr_stmt|;
break|break;
block|}
name|usec_delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
name|E1000_SUCCESS
condition|)
block|{
comment|/* Successful in waiting for previous cycle to timeout,              * now set the Flash Cycle Done. */
name|hsfsts
operator|.
name|hsf_status
operator|.
name|flcdone
operator|=
literal|1
expr_stmt|;
name|E1000_WRITE_ICH_FLASH_REG16
argument_list|(
name|hw
argument_list|,
name|ICH_FLASH_HSFSTS
argument_list|,
name|hsfsts
operator|.
name|regval
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DEBUGOUT
argument_list|(
literal|"Flash controller busy, cannot get access"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * This function starts a flash cycle and waits for its completion  *  * hw - The pointer to the hw structure  ****************************************************************************/
end_comment

begin_function
name|STATIC
name|int32_t
name|em_ich8_flash_cycle
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint32_t
name|timeout
parameter_list|)
block|{
name|union
name|ich8_hws_flash_ctrl
name|hsflctl
decl_stmt|;
name|union
name|ich8_hws_flash_status
name|hsfsts
decl_stmt|;
name|int32_t
name|error
init|=
name|E1000_ERR_EEPROM
decl_stmt|;
name|uint32_t
name|i
init|=
literal|0
decl_stmt|;
comment|/* Start a cycle by writing 1 in Flash Cycle Go in Hw Flash Control */
name|hsflctl
operator|.
name|regval
operator|=
name|E1000_READ_ICH_FLASH_REG16
argument_list|(
name|hw
argument_list|,
name|ICH_FLASH_HSFCTL
argument_list|)
expr_stmt|;
name|hsflctl
operator|.
name|hsf_ctrl
operator|.
name|flcgo
operator|=
literal|1
expr_stmt|;
name|E1000_WRITE_ICH_FLASH_REG16
argument_list|(
name|hw
argument_list|,
name|ICH_FLASH_HSFCTL
argument_list|,
name|hsflctl
operator|.
name|regval
argument_list|)
expr_stmt|;
comment|/* wait till FDONE bit is set to 1 */
do|do
block|{
name|hsfsts
operator|.
name|regval
operator|=
name|E1000_READ_ICH_FLASH_REG16
argument_list|(
name|hw
argument_list|,
name|ICH_FLASH_HSFSTS
argument_list|)
expr_stmt|;
if|if
condition|(
name|hsfsts
operator|.
name|hsf_status
operator|.
name|flcdone
operator|==
literal|1
condition|)
break|break;
name|usec_delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|i
operator|<
name|timeout
condition|)
do|;
if|if
condition|(
name|hsfsts
operator|.
name|hsf_status
operator|.
name|flcdone
operator|==
literal|1
operator|&&
name|hsfsts
operator|.
name|hsf_status
operator|.
name|flcerr
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|E1000_SUCCESS
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Reads a byte or word from the NVM using the ICH8 flash access registers.  *  * hw - The pointer to the hw structure  * index - The index of the byte or word to read.  * size - Size of data to read, 1=byte 2=word  * data - Pointer to the word to store the value read.  *****************************************************************************/
end_comment

begin_function
name|STATIC
name|int32_t
name|em_read_ich8_data
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint32_t
name|index
parameter_list|,
name|uint32_t
name|size
parameter_list|,
name|uint16_t
modifier|*
name|data
parameter_list|)
block|{
name|union
name|ich8_hws_flash_status
name|hsfsts
decl_stmt|;
name|union
name|ich8_hws_flash_ctrl
name|hsflctl
decl_stmt|;
name|uint32_t
name|flash_linear_address
decl_stmt|;
name|uint32_t
name|flash_data
init|=
literal|0
decl_stmt|;
name|int32_t
name|error
init|=
operator|-
name|E1000_ERR_EEPROM
decl_stmt|;
name|int32_t
name|count
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_read_ich8_data"
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|<
literal|1
operator|||
name|size
operator|>
literal|2
operator|||
name|data
operator|==
literal|0x0
operator|||
name|index
operator|>
name|ICH_FLASH_LINEAR_ADDR_MASK
condition|)
return|return
name|error
return|;
name|flash_linear_address
operator|=
operator|(
name|ICH_FLASH_LINEAR_ADDR_MASK
operator|&
name|index
operator|)
operator|+
name|hw
operator|->
name|flash_base_addr
expr_stmt|;
do|do
block|{
name|usec_delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Steps */
name|error
operator|=
name|em_ich8_cycle_init
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|E1000_SUCCESS
condition|)
break|break;
name|hsflctl
operator|.
name|regval
operator|=
name|E1000_READ_ICH_FLASH_REG16
argument_list|(
name|hw
argument_list|,
name|ICH_FLASH_HSFCTL
argument_list|)
expr_stmt|;
comment|/* 0b/1b corresponds to 1 or 2 byte size, respectively. */
name|hsflctl
operator|.
name|hsf_ctrl
operator|.
name|fldbcount
operator|=
name|size
operator|-
literal|1
expr_stmt|;
name|hsflctl
operator|.
name|hsf_ctrl
operator|.
name|flcycle
operator|=
name|ICH_CYCLE_READ
expr_stmt|;
name|E1000_WRITE_ICH_FLASH_REG16
argument_list|(
name|hw
argument_list|,
name|ICH_FLASH_HSFCTL
argument_list|,
name|hsflctl
operator|.
name|regval
argument_list|)
expr_stmt|;
comment|/* Write the last 24 bits of index into Flash Linear address field in          * Flash Address */
comment|/* TODO: TBD maybe check the index against the size of flash */
name|E1000_WRITE_ICH_FLASH_REG
argument_list|(
name|hw
argument_list|,
name|ICH_FLASH_FADDR
argument_list|,
name|flash_linear_address
argument_list|)
expr_stmt|;
name|error
operator|=
name|em_ich8_flash_cycle
argument_list|(
name|hw
argument_list|,
name|ICH_FLASH_COMMAND_TIMEOUT
argument_list|)
expr_stmt|;
comment|/* Check if FCERR is set to 1, if set to 1, clear it and try the whole          * sequence a few more times, else read in (shift in) the Flash Data0,          * the order is least significant byte first msb to lsb */
if|if
condition|(
name|error
operator|==
name|E1000_SUCCESS
condition|)
block|{
name|flash_data
operator|=
name|E1000_READ_ICH_FLASH_REG
argument_list|(
name|hw
argument_list|,
name|ICH_FLASH_FDATA0
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|1
condition|)
block|{
operator|*
name|data
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|flash_data
operator|&
literal|0x000000FF
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|size
operator|==
literal|2
condition|)
block|{
operator|*
name|data
operator|=
call|(
name|uint16_t
call|)
argument_list|(
name|flash_data
operator|&
literal|0x0000FFFF
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
else|else
block|{
comment|/* If we've gotten here, then things are probably completely hosed,              * but if the error condition is detected, it won't hurt to give              * it another try...ICH_FLASH_CYCLE_REPEAT_COUNT times.              */
name|hsfsts
operator|.
name|regval
operator|=
name|E1000_READ_ICH_FLASH_REG16
argument_list|(
name|hw
argument_list|,
name|ICH_FLASH_HSFSTS
argument_list|)
expr_stmt|;
if|if
condition|(
name|hsfsts
operator|.
name|hsf_status
operator|.
name|flcerr
operator|==
literal|1
condition|)
block|{
comment|/* Repeat for some time before giving up. */
continue|continue;
block|}
elseif|else
if|if
condition|(
name|hsfsts
operator|.
name|hsf_status
operator|.
name|flcdone
operator|==
literal|0
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Timeout error - flash cycle did not complete."
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
do|while
condition|(
name|count
operator|++
operator|<
name|ICH_FLASH_CYCLE_REPEAT_COUNT
condition|)
do|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Writes One /two bytes to the NVM using the ICH8 flash access registers.  *  * hw - The pointer to the hw structure  * index - The index of the byte/word to read.  * size - Size of data to read, 1=byte 2=word  * data - The byte(s) to write to the NVM.  *****************************************************************************/
end_comment

begin_function
name|STATIC
name|int32_t
name|em_write_ich8_data
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint32_t
name|index
parameter_list|,
name|uint32_t
name|size
parameter_list|,
name|uint16_t
name|data
parameter_list|)
block|{
name|union
name|ich8_hws_flash_status
name|hsfsts
decl_stmt|;
name|union
name|ich8_hws_flash_ctrl
name|hsflctl
decl_stmt|;
name|uint32_t
name|flash_linear_address
decl_stmt|;
name|uint32_t
name|flash_data
init|=
literal|0
decl_stmt|;
name|int32_t
name|error
init|=
operator|-
name|E1000_ERR_EEPROM
decl_stmt|;
name|int32_t
name|count
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_write_ich8_data"
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|<
literal|1
operator|||
name|size
operator|>
literal|2
operator|||
name|data
operator|>
name|size
operator|*
literal|0xff
operator|||
name|index
operator|>
name|ICH_FLASH_LINEAR_ADDR_MASK
condition|)
return|return
name|error
return|;
name|flash_linear_address
operator|=
operator|(
name|ICH_FLASH_LINEAR_ADDR_MASK
operator|&
name|index
operator|)
operator|+
name|hw
operator|->
name|flash_base_addr
expr_stmt|;
do|do
block|{
name|usec_delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Steps */
name|error
operator|=
name|em_ich8_cycle_init
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|E1000_SUCCESS
condition|)
break|break;
name|hsflctl
operator|.
name|regval
operator|=
name|E1000_READ_ICH_FLASH_REG16
argument_list|(
name|hw
argument_list|,
name|ICH_FLASH_HSFCTL
argument_list|)
expr_stmt|;
comment|/* 0b/1b corresponds to 1 or 2 byte size, respectively. */
name|hsflctl
operator|.
name|hsf_ctrl
operator|.
name|fldbcount
operator|=
name|size
operator|-
literal|1
expr_stmt|;
name|hsflctl
operator|.
name|hsf_ctrl
operator|.
name|flcycle
operator|=
name|ICH_CYCLE_WRITE
expr_stmt|;
name|E1000_WRITE_ICH_FLASH_REG16
argument_list|(
name|hw
argument_list|,
name|ICH_FLASH_HSFCTL
argument_list|,
name|hsflctl
operator|.
name|regval
argument_list|)
expr_stmt|;
comment|/* Write the last 24 bits of index into Flash Linear address field in          * Flash Address */
name|E1000_WRITE_ICH_FLASH_REG
argument_list|(
name|hw
argument_list|,
name|ICH_FLASH_FADDR
argument_list|,
name|flash_linear_address
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|1
condition|)
name|flash_data
operator|=
operator|(
name|uint32_t
operator|)
name|data
operator|&
literal|0x00FF
expr_stmt|;
else|else
name|flash_data
operator|=
operator|(
name|uint32_t
operator|)
name|data
expr_stmt|;
name|E1000_WRITE_ICH_FLASH_REG
argument_list|(
name|hw
argument_list|,
name|ICH_FLASH_FDATA0
argument_list|,
name|flash_data
argument_list|)
expr_stmt|;
comment|/* check if FCERR is set to 1 , if set to 1, clear it and try the whole          * sequence a few more times else done */
name|error
operator|=
name|em_ich8_flash_cycle
argument_list|(
name|hw
argument_list|,
name|ICH_FLASH_COMMAND_TIMEOUT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|E1000_SUCCESS
condition|)
block|{
break|break;
block|}
else|else
block|{
comment|/* If we're here, then things are most likely completely hosed,              * but if the error condition is detected, it won't hurt to give              * it another try...ICH_FLASH_CYCLE_REPEAT_COUNT times.              */
name|hsfsts
operator|.
name|regval
operator|=
name|E1000_READ_ICH_FLASH_REG16
argument_list|(
name|hw
argument_list|,
name|ICH_FLASH_HSFSTS
argument_list|)
expr_stmt|;
if|if
condition|(
name|hsfsts
operator|.
name|hsf_status
operator|.
name|flcerr
operator|==
literal|1
condition|)
block|{
comment|/* Repeat for some time before giving up. */
continue|continue;
block|}
elseif|else
if|if
condition|(
name|hsfsts
operator|.
name|hsf_status
operator|.
name|flcdone
operator|==
literal|0
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Timeout error - flash cycle did not complete."
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
do|while
condition|(
name|count
operator|++
operator|<
name|ICH_FLASH_CYCLE_REPEAT_COUNT
condition|)
do|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Reads a single byte from the NVM using the ICH8 flash access registers.  *  * hw - pointer to em_hw structure  * index - The index of the byte to read.  * data - Pointer to a byte to store the value read.  *****************************************************************************/
end_comment

begin_function
name|STATIC
name|int32_t
name|em_read_ich8_byte
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint32_t
name|index
parameter_list|,
name|uint8_t
modifier|*
name|data
parameter_list|)
block|{
name|int32_t
name|status
init|=
name|E1000_SUCCESS
decl_stmt|;
name|uint16_t
name|word
init|=
literal|0
decl_stmt|;
name|status
operator|=
name|em_read_ich8_data
argument_list|(
name|hw
argument_list|,
name|index
argument_list|,
literal|1
argument_list|,
operator|&
name|word
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|E1000_SUCCESS
condition|)
block|{
operator|*
name|data
operator|=
operator|(
name|uint8_t
operator|)
name|word
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Writes a single byte to the NVM using the ICH8 flash access registers.  * Performs verification by reading back the value and then going through  * a retry algorithm before giving up.  *  * hw - pointer to em_hw structure  * index - The index of the byte to write.  * byte - The byte to write to the NVM.  *****************************************************************************/
end_comment

begin_function
name|STATIC
name|int32_t
name|em_verify_write_ich8_byte
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint32_t
name|index
parameter_list|,
name|uint8_t
name|byte
parameter_list|)
block|{
name|int32_t
name|error
init|=
name|E1000_SUCCESS
decl_stmt|;
name|int32_t
name|program_retries
init|=
literal|0
decl_stmt|;
name|DEBUGOUT2
argument_list|(
literal|"Byte := %2.2X Offset := %d\n"
argument_list|,
name|byte
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|error
operator|=
name|em_write_ich8_byte
argument_list|(
name|hw
argument_list|,
name|index
argument_list|,
name|byte
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|E1000_SUCCESS
condition|)
block|{
for|for
control|(
name|program_retries
operator|=
literal|0
init|;
name|program_retries
operator|<
literal|100
condition|;
name|program_retries
operator|++
control|)
block|{
name|DEBUGOUT2
argument_list|(
literal|"Retrying \t Byte := %2.2X Offset := %d\n"
argument_list|,
name|byte
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|error
operator|=
name|em_write_ich8_byte
argument_list|(
name|hw
argument_list|,
name|index
argument_list|,
name|byte
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|E1000_SUCCESS
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|program_retries
operator|==
literal|100
condition|)
name|error
operator|=
name|E1000_ERR_EEPROM
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Writes a single byte to the NVM using the ICH8 flash access registers.  *  * hw - pointer to em_hw structure  * index - The index of the byte to read.  * data - The byte to write to the NVM.  *****************************************************************************/
end_comment

begin_function
name|STATIC
name|int32_t
name|em_write_ich8_byte
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint32_t
name|index
parameter_list|,
name|uint8_t
name|data
parameter_list|)
block|{
name|int32_t
name|status
init|=
name|E1000_SUCCESS
decl_stmt|;
name|uint16_t
name|word
init|=
operator|(
name|uint16_t
operator|)
name|data
decl_stmt|;
name|status
operator|=
name|em_write_ich8_data
argument_list|(
name|hw
argument_list|,
name|index
argument_list|,
literal|1
argument_list|,
name|word
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Reads a word from the NVM using the ICH8 flash access registers.  *  * hw - pointer to em_hw structure  * index - The starting byte index of the word to read.  * data - Pointer to a word to store the value read.  *****************************************************************************/
end_comment

begin_function
name|STATIC
name|int32_t
name|em_read_ich8_word
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint32_t
name|index
parameter_list|,
name|uint16_t
modifier|*
name|data
parameter_list|)
block|{
name|int32_t
name|status
init|=
name|E1000_SUCCESS
decl_stmt|;
name|status
operator|=
name|em_read_ich8_data
argument_list|(
name|hw
argument_list|,
name|index
argument_list|,
literal|2
argument_list|,
name|data
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Erases the bank specified. Each bank may be a 4, 8 or 64k block. Banks are 0  * based.  *  * hw - pointer to em_hw structure  * bank - 0 for first bank, 1 for second bank  *  * Note that this function may actually erase as much as 8 or 64 KBytes.  The  * amount of NVM used in each bank is a *minimum* of 4 KBytes, but in fact the  * bank size may be 4, 8 or 64 KBytes  *****************************************************************************/
end_comment

begin_function
name|int32_t
name|em_erase_ich8_4k_segment
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint32_t
name|bank
parameter_list|)
block|{
name|union
name|ich8_hws_flash_status
name|hsfsts
decl_stmt|;
name|union
name|ich8_hws_flash_ctrl
name|hsflctl
decl_stmt|;
name|uint32_t
name|flash_linear_address
decl_stmt|;
name|int32_t
name|count
init|=
literal|0
decl_stmt|;
name|int32_t
name|error
init|=
name|E1000_ERR_EEPROM
decl_stmt|;
name|int32_t
name|iteration
decl_stmt|;
name|int32_t
name|sub_sector_size
init|=
literal|0
decl_stmt|;
name|int32_t
name|bank_size
decl_stmt|;
name|int32_t
name|j
init|=
literal|0
decl_stmt|;
name|int32_t
name|error_flag
init|=
literal|0
decl_stmt|;
name|hsfsts
operator|.
name|regval
operator|=
name|E1000_READ_ICH_FLASH_REG16
argument_list|(
name|hw
argument_list|,
name|ICH_FLASH_HSFSTS
argument_list|)
expr_stmt|;
comment|/* Determine HW Sector size: Read BERASE bits of Hw flash Status register */
comment|/* 00: The Hw sector is 256 bytes, hence we need to erase 16      *     consecutive sectors.  The start index for the nth Hw sector can be      *     calculated as bank * 4096 + n * 256      * 01: The Hw sector is 4K bytes, hence we need to erase 1 sector.      *     The start index for the nth Hw sector can be calculated      *     as bank * 4096      * 10: The HW sector is 8K bytes      * 11: The Hw sector size is 64K bytes */
if|if
condition|(
name|hsfsts
operator|.
name|hsf_status
operator|.
name|berasesz
operator|==
literal|0x0
condition|)
block|{
comment|/* Hw sector size 256 */
name|sub_sector_size
operator|=
name|ICH_FLASH_SEG_SIZE_256
expr_stmt|;
name|bank_size
operator|=
name|ICH_FLASH_SECTOR_SIZE
expr_stmt|;
name|iteration
operator|=
name|ICH_FLASH_SECTOR_SIZE
operator|/
name|ICH_FLASH_SEG_SIZE_256
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|hsfsts
operator|.
name|hsf_status
operator|.
name|berasesz
operator|==
literal|0x1
condition|)
block|{
name|bank_size
operator|=
name|ICH_FLASH_SEG_SIZE_4K
expr_stmt|;
name|iteration
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|hsfsts
operator|.
name|hsf_status
operator|.
name|berasesz
operator|==
literal|0x3
condition|)
block|{
name|bank_size
operator|=
name|ICH_FLASH_SEG_SIZE_64K
expr_stmt|;
name|iteration
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
return|return
name|error
return|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|iteration
condition|;
name|j
operator|++
control|)
block|{
do|do
block|{
name|count
operator|++
expr_stmt|;
comment|/* Steps */
name|error
operator|=
name|em_ich8_cycle_init
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|E1000_SUCCESS
condition|)
block|{
name|error_flag
operator|=
literal|1
expr_stmt|;
break|break;
block|}
comment|/* Write a value 11 (block Erase) in Flash Cycle field in Hw flash              * Control */
name|hsflctl
operator|.
name|regval
operator|=
name|E1000_READ_ICH_FLASH_REG16
argument_list|(
name|hw
argument_list|,
name|ICH_FLASH_HSFCTL
argument_list|)
expr_stmt|;
name|hsflctl
operator|.
name|hsf_ctrl
operator|.
name|flcycle
operator|=
name|ICH_CYCLE_ERASE
expr_stmt|;
name|E1000_WRITE_ICH_FLASH_REG16
argument_list|(
name|hw
argument_list|,
name|ICH_FLASH_HSFCTL
argument_list|,
name|hsflctl
operator|.
name|regval
argument_list|)
expr_stmt|;
comment|/* Write the last 24 bits of an index within the block into Flash              * Linear address field in Flash Address.  This probably needs to              * be calculated here based off the on-chip erase sector size and              * the software bank size (4, 8 or 64 KBytes) */
name|flash_linear_address
operator|=
name|bank
operator|*
name|bank_size
operator|+
name|j
operator|*
name|sub_sector_size
expr_stmt|;
name|flash_linear_address
operator|+=
name|hw
operator|->
name|flash_base_addr
expr_stmt|;
name|flash_linear_address
operator|&=
name|ICH_FLASH_LINEAR_ADDR_MASK
expr_stmt|;
name|E1000_WRITE_ICH_FLASH_REG
argument_list|(
name|hw
argument_list|,
name|ICH_FLASH_FADDR
argument_list|,
name|flash_linear_address
argument_list|)
expr_stmt|;
name|error
operator|=
name|em_ich8_flash_cycle
argument_list|(
name|hw
argument_list|,
name|ICH_FLASH_ERASE_TIMEOUT
argument_list|)
expr_stmt|;
comment|/* Check if FCERR is set to 1.  If 1, clear it and try the whole              * sequence a few more times else Done */
if|if
condition|(
name|error
operator|==
name|E1000_SUCCESS
condition|)
block|{
break|break;
block|}
else|else
block|{
name|hsfsts
operator|.
name|regval
operator|=
name|E1000_READ_ICH_FLASH_REG16
argument_list|(
name|hw
argument_list|,
name|ICH_FLASH_HSFSTS
argument_list|)
expr_stmt|;
if|if
condition|(
name|hsfsts
operator|.
name|hsf_status
operator|.
name|flcerr
operator|==
literal|1
condition|)
block|{
comment|/* repeat for some time before giving up */
continue|continue;
block|}
elseif|else
if|if
condition|(
name|hsfsts
operator|.
name|hsf_status
operator|.
name|flcdone
operator|==
literal|0
condition|)
block|{
name|error_flag
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
do|while
condition|(
operator|(
name|count
operator|<
name|ICH_FLASH_CYCLE_REPEAT_COUNT
operator|)
operator|&&
operator|!
name|error_flag
condition|)
do|;
if|if
condition|(
name|error_flag
operator|==
literal|1
condition|)
break|break;
block|}
if|if
condition|(
name|error_flag
operator|!=
literal|1
condition|)
name|error
operator|=
name|E1000_SUCCESS
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
name|STATIC
name|int32_t
name|em_init_lcd_from_nvm_config_region
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint32_t
name|cnf_base_addr
parameter_list|,
name|uint32_t
name|cnf_size
parameter_list|)
block|{
name|uint32_t
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|uint16_t
name|word_addr
decl_stmt|,
name|reg_data
decl_stmt|,
name|reg_addr
decl_stmt|;
name|uint16_t
name|i
decl_stmt|;
comment|/* cnf_base_addr is in DWORD */
name|word_addr
operator|=
call|(
name|uint16_t
call|)
argument_list|(
name|cnf_base_addr
operator|<<
literal|1
argument_list|)
expr_stmt|;
comment|/* cnf_size is returned in size of dwords */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cnf_size
condition|;
name|i
operator|++
control|)
block|{
name|ret_val
operator|=
name|em_read_eeprom
argument_list|(
name|hw
argument_list|,
operator|(
name|word_addr
operator|+
name|i
operator|*
literal|2
operator|)
argument_list|,
literal|1
argument_list|,
operator|&
name|reg_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|ret_val
operator|=
name|em_read_eeprom
argument_list|(
name|hw
argument_list|,
operator|(
name|word_addr
operator|+
name|i
operator|*
literal|2
operator|+
literal|1
operator|)
argument_list|,
literal|1
argument_list|,
operator|&
name|reg_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|ret_val
operator|=
name|em_get_software_flag
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
operator|!=
name|E1000_SUCCESS
condition|)
return|return
name|ret_val
return|;
name|ret_val
operator|=
name|em_write_phy_reg_ex
argument_list|(
name|hw
argument_list|,
operator|(
name|uint32_t
operator|)
name|reg_addr
argument_list|,
name|reg_data
argument_list|)
expr_stmt|;
name|em_release_software_flag
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * This function initializes the PHY from the NVM on ICH8 platforms. This  * is needed due to an issue where the NVM configuration is not properly  * autoloaded after power transitions. Therefore, after each PHY reset, we  * will load the configuration data out of the NVM manually.  *  * hw: Struct containing variables accessed by shared code  *****************************************************************************/
end_comment

begin_function
name|STATIC
name|int32_t
name|em_init_lcd_from_nvm
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|uint32_t
name|reg_data
decl_stmt|,
name|cnf_base_addr
decl_stmt|,
name|cnf_size
decl_stmt|,
name|ret_val
decl_stmt|,
name|loop
decl_stmt|;
if|if
condition|(
name|hw
operator|->
name|phy_type
operator|!=
name|em_phy_igp_3
condition|)
return|return
name|E1000_SUCCESS
return|;
comment|/* Check if SW needs configure the PHY */
name|reg_data
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|FEXTNVM
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|reg_data
operator|&
name|FEXTNVM_SW_CONFIG
operator|)
condition|)
return|return
name|E1000_SUCCESS
return|;
comment|/* Wait for basic configuration completes before proceeding*/
name|loop
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|reg_data
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|STATUS
argument_list|)
operator|&
name|E1000_STATUS_LAN_INIT_DONE
expr_stmt|;
name|usec_delay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|loop
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|(
operator|!
name|reg_data
operator|)
operator|&&
operator|(
name|loop
operator|<
literal|50
operator|)
condition|)
do|;
comment|/* Clear the Init Done bit for the next init event */
name|reg_data
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|STATUS
argument_list|)
expr_stmt|;
name|reg_data
operator|&=
operator|~
name|E1000_STATUS_LAN_INIT_DONE
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|STATUS
argument_list|,
name|reg_data
argument_list|)
expr_stmt|;
comment|/* Make sure HW does not configure LCD from PHY extended configuration        before SW configuration */
name|reg_data
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|EXTCNF_CTRL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|reg_data
operator|&
name|E1000_EXTCNF_CTRL_LCD_WRITE_ENABLE
operator|)
operator|==
literal|0x0000
condition|)
block|{
name|reg_data
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|EXTCNF_SIZE
argument_list|)
expr_stmt|;
name|cnf_size
operator|=
name|reg_data
operator|&
name|E1000_EXTCNF_SIZE_EXT_PCIE_LENGTH
expr_stmt|;
name|cnf_size
operator|>>=
literal|16
expr_stmt|;
if|if
condition|(
name|cnf_size
condition|)
block|{
name|reg_data
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|EXTCNF_CTRL
argument_list|)
expr_stmt|;
name|cnf_base_addr
operator|=
name|reg_data
operator|&
name|E1000_EXTCNF_CTRL_EXT_CNF_POINTER
expr_stmt|;
comment|/* cnf_base_addr is in DWORD */
name|cnf_base_addr
operator|>>=
literal|16
expr_stmt|;
comment|/* Configure LCD from extended configuration region. */
name|ret_val
operator|=
name|em_init_lcd_from_nvm_config_region
argument_list|(
name|hw
argument_list|,
name|cnf_base_addr
argument_list|,
name|cnf_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
block|}
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

end_unit

