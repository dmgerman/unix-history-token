begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*******************************************************************************    Copyright (c) 2001-2003, Intel Corporation    All rights reserved.      Redistribution and use in source and binary forms, with or without    modification, are permitted provided that the following conditions are met:       1. Redistributions of source code must retain the above copyright notice,        this list of conditions and the following disclaimer.       2. Redistributions in binary form must reproduce the above copyright        notice, this list of conditions and the following disclaimer in the        documentation and/or other materials provided with the distribution.       3. Neither the name of the Intel Corporation nor the names of its        contributors may be used to endorse or promote products derived from        this software without specific prior written permission.      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE    ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR    CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF    SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN    CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)    ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE   POSSIBILITY OF SUCH DAMAGE.  *******************************************************************************/
end_comment

begin_comment
comment|/*$FreeBSD$*/
end_comment

begin_comment
comment|/* if_em_hw.c  * Shared functions for accessing and configuring the MAC  */
end_comment

begin_include
include|#
directive|include
file|<dev/em/if_em_hw.h>
end_include

begin_function_decl
specifier|static
name|int32_t
name|em_set_phy_type
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_phy_init_script
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|em_setup_copper_link
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|em_setup_fiber_serdes_link
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|em_adjust_serdes_amplitude
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|em_phy_force_speed_duplex
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|em_config_mac_to_phy
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_raise_mdi_clk
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint32_t
modifier|*
name|ctrl
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_lower_mdi_clk
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint32_t
modifier|*
name|ctrl
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_shift_out_mdi_bits
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint32_t
name|data
parameter_list|,
name|uint16_t
name|count
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint16_t
name|em_shift_in_mdi_bits
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|em_phy_reset_dsp
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|em_write_eeprom_spi
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint16_t
name|offset
parameter_list|,
name|uint16_t
name|words
parameter_list|,
name|uint16_t
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|em_write_eeprom_microwire
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint16_t
name|offset
parameter_list|,
name|uint16_t
name|words
parameter_list|,
name|uint16_t
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|em_spi_eeprom_ready
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_raise_ee_clk
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint32_t
modifier|*
name|eecd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_lower_ee_clk
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint32_t
modifier|*
name|eecd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_shift_out_ee_bits
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint16_t
name|data
parameter_list|,
name|uint16_t
name|count
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|em_write_phy_reg_ex
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint32_t
name|reg_addr
parameter_list|,
name|uint16_t
name|phy_data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|em_read_phy_reg_ex
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint32_t
name|reg_addr
parameter_list|,
name|uint16_t
modifier|*
name|phy_data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint16_t
name|em_shift_in_ee_bits
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint16_t
name|count
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|em_acquire_eeprom
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_release_eeprom
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_standby_eeprom
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|em_id_led_init
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|em_set_vco_speed
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* IGP cable length table */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|uint16_t
name|em_igp_cable_length_table
index|[
name|IGP01E1000_AGC_LENGTH_TABLE_SIZE
index|]
init|=
block|{
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|20
block|,
literal|20
block|,
literal|20
block|,
literal|20
block|,
literal|20
block|,
literal|25
block|,
literal|25
block|,
literal|25
block|,
literal|25
block|,
literal|25
block|,
literal|25
block|,
literal|25
block|,
literal|30
block|,
literal|30
block|,
literal|30
block|,
literal|30
block|,
literal|40
block|,
literal|40
block|,
literal|40
block|,
literal|40
block|,
literal|40
block|,
literal|40
block|,
literal|40
block|,
literal|40
block|,
literal|40
block|,
literal|50
block|,
literal|50
block|,
literal|50
block|,
literal|50
block|,
literal|50
block|,
literal|50
block|,
literal|50
block|,
literal|60
block|,
literal|60
block|,
literal|60
block|,
literal|60
block|,
literal|60
block|,
literal|60
block|,
literal|60
block|,
literal|60
block|,
literal|60
block|,
literal|70
block|,
literal|70
block|,
literal|70
block|,
literal|70
block|,
literal|70
block|,
literal|70
block|,
literal|80
block|,
literal|80
block|,
literal|80
block|,
literal|80
block|,
literal|80
block|,
literal|80
block|,
literal|90
block|,
literal|90
block|,
literal|90
block|,
literal|90
block|,
literal|90
block|,
literal|90
block|,
literal|90
block|,
literal|90
block|,
literal|90
block|,
literal|100
block|,
literal|100
block|,
literal|100
block|,
literal|100
block|,
literal|100
block|,
literal|100
block|,
literal|100
block|,
literal|100
block|,
literal|100
block|,
literal|100
block|,
literal|100
block|,
literal|100
block|,
literal|100
block|,
literal|100
block|,
literal|110
block|,
literal|110
block|,
literal|110
block|,
literal|110
block|,
literal|110
block|,
literal|110
block|,
literal|110
block|,
literal|110
block|,
literal|110
block|,
literal|110
block|,
literal|110
block|,
literal|110
block|,
literal|110
block|,
literal|110
block|,
literal|110
block|,
literal|110
block|,
literal|110
block|,
literal|110
block|,
literal|120
block|,
literal|120
block|,
literal|120
block|,
literal|120
block|,
literal|120
block|,
literal|120
block|,
literal|120
block|,
literal|120
block|,
literal|120
block|,
literal|120
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/******************************************************************************  * Set the phy type member in the hw struct.  *  * hw - Struct containing variables accessed by shared code  *****************************************************************************/
end_comment

begin_function
name|int32_t
name|em_set_phy_type
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"em_set_phy_type"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|hw
operator|->
name|phy_id
condition|)
block|{
case|case
name|M88E1000_E_PHY_ID
case|:
case|case
name|M88E1000_I_PHY_ID
case|:
case|case
name|M88E1011_I_PHY_ID
case|:
name|hw
operator|->
name|phy_type
operator|=
name|em_phy_m88
expr_stmt|;
break|break;
case|case
name|IGP01E1000_I_PHY_ID
case|:
name|hw
operator|->
name|phy_type
operator|=
name|em_phy_igp
expr_stmt|;
break|break;
default|default:
comment|/* Should never have loaded on this device */
name|hw
operator|->
name|phy_type
operator|=
name|em_phy_undefined
expr_stmt|;
return|return
operator|-
name|E1000_ERR_PHY_TYPE
return|;
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * IGP phy init script - initializes the GbE PHY  *  * hw - Struct containing variables accessed by shared code  *****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|em_phy_init_script
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"em_phy_init_script"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|phy_init_script
condition|)
block|{
name|msec_delay
argument_list|(
literal|20
argument_list|)
expr_stmt|;
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
literal|0x0000
argument_list|,
literal|0x0140
argument_list|)
expr_stmt|;
name|msec_delay
argument_list|(
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|==
name|em_82541
operator|||
name|hw
operator|->
name|mac_type
operator|==
name|em_82547
condition|)
block|{
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
literal|0x1F95
argument_list|,
literal|0x0001
argument_list|)
expr_stmt|;
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
literal|0x1F71
argument_list|,
literal|0xBD21
argument_list|)
expr_stmt|;
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
literal|0x1F79
argument_list|,
literal|0x0018
argument_list|)
expr_stmt|;
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
literal|0x1F30
argument_list|,
literal|0x1600
argument_list|)
expr_stmt|;
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
literal|0x1F31
argument_list|,
literal|0x0014
argument_list|)
expr_stmt|;
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
literal|0x1F32
argument_list|,
literal|0x161C
argument_list|)
expr_stmt|;
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
literal|0x1F94
argument_list|,
literal|0x0003
argument_list|)
expr_stmt|;
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
literal|0x1F96
argument_list|,
literal|0x003F
argument_list|)
expr_stmt|;
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
literal|0x2010
argument_list|,
literal|0x0008
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
literal|0x1F73
argument_list|,
literal|0x0099
argument_list|)
expr_stmt|;
block|}
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
literal|0x0000
argument_list|,
literal|0x3300
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|==
name|em_82547
condition|)
block|{
name|uint16_t
name|fused
decl_stmt|,
name|fine
decl_stmt|,
name|coarse
decl_stmt|;
comment|/* Move to analog registers page */
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_ANALOG_SPARE_FUSE_STATUS
argument_list|,
operator|&
name|fused
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|fused
operator|&
name|IGP01E1000_ANALOG_SPARE_FUSE_ENABLED
operator|)
condition|)
block|{
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_ANALOG_FUSE_STATUS
argument_list|,
operator|&
name|fused
argument_list|)
expr_stmt|;
name|fine
operator|=
name|fused
operator|&
name|IGP01E1000_ANALOG_FUSE_FINE_MASK
expr_stmt|;
name|coarse
operator|=
name|fused
operator|&
name|IGP01E1000_ANALOG_FUSE_COARSE_MASK
expr_stmt|;
if|if
condition|(
name|coarse
operator|>
name|IGP01E1000_ANALOG_FUSE_COARSE_THRESH
condition|)
block|{
name|coarse
operator|-=
name|IGP01E1000_ANALOG_FUSE_COARSE_10
expr_stmt|;
name|fine
operator|-=
name|IGP01E1000_ANALOG_FUSE_FINE_1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|coarse
operator|==
name|IGP01E1000_ANALOG_FUSE_COARSE_THRESH
condition|)
name|fine
operator|-=
name|IGP01E1000_ANALOG_FUSE_FINE_10
expr_stmt|;
name|fused
operator|=
operator|(
name|fused
operator|&
name|IGP01E1000_ANALOG_FUSE_POLY_MASK
operator|)
operator||
operator|(
name|fine
operator|&
name|IGP01E1000_ANALOG_FUSE_FINE_MASK
operator|)
operator||
operator|(
name|coarse
operator|&
name|IGP01E1000_ANALOG_FUSE_COARSE_MASK
operator|)
expr_stmt|;
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_ANALOG_FUSE_CONTROL
argument_list|,
name|fused
argument_list|)
expr_stmt|;
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_ANALOG_FUSE_BYPASS
argument_list|,
name|IGP01E1000_ANALOG_FUSE_ENABLE_SW_CONTROL
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/******************************************************************************  * Set the mac type member in the hw struct.  *  * hw - Struct containing variables accessed by shared code  *****************************************************************************/
end_comment

begin_function
name|int32_t
name|em_set_mac_type
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"em_set_mac_type"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|hw
operator|->
name|device_id
condition|)
block|{
case|case
name|E1000_DEV_ID_82542
case|:
switch|switch
condition|(
name|hw
operator|->
name|revision_id
condition|)
block|{
case|case
name|E1000_82542_2_0_REV_ID
case|:
name|hw
operator|->
name|mac_type
operator|=
name|em_82542_rev2_0
expr_stmt|;
break|break;
case|case
name|E1000_82542_2_1_REV_ID
case|:
name|hw
operator|->
name|mac_type
operator|=
name|em_82542_rev2_1
expr_stmt|;
break|break;
default|default:
comment|/* Invalid 82542 revision ID */
return|return
operator|-
name|E1000_ERR_MAC_TYPE
return|;
block|}
break|break;
case|case
name|E1000_DEV_ID_82543GC_FIBER
case|:
case|case
name|E1000_DEV_ID_82543GC_COPPER
case|:
name|hw
operator|->
name|mac_type
operator|=
name|em_82543
expr_stmt|;
break|break;
case|case
name|E1000_DEV_ID_82544EI_COPPER
case|:
case|case
name|E1000_DEV_ID_82544EI_FIBER
case|:
case|case
name|E1000_DEV_ID_82544GC_COPPER
case|:
case|case
name|E1000_DEV_ID_82544GC_LOM
case|:
name|hw
operator|->
name|mac_type
operator|=
name|em_82544
expr_stmt|;
break|break;
case|case
name|E1000_DEV_ID_82540EM
case|:
case|case
name|E1000_DEV_ID_82540EM_LOM
case|:
case|case
name|E1000_DEV_ID_82540EP
case|:
case|case
name|E1000_DEV_ID_82540EP_LOM
case|:
case|case
name|E1000_DEV_ID_82540EP_LP
case|:
name|hw
operator|->
name|mac_type
operator|=
name|em_82540
expr_stmt|;
break|break;
case|case
name|E1000_DEV_ID_82545EM_COPPER
case|:
case|case
name|E1000_DEV_ID_82545EM_FIBER
case|:
name|hw
operator|->
name|mac_type
operator|=
name|em_82545
expr_stmt|;
break|break;
case|case
name|E1000_DEV_ID_82545GM_COPPER
case|:
case|case
name|E1000_DEV_ID_82545GM_FIBER
case|:
case|case
name|E1000_DEV_ID_82545GM_SERDES
case|:
name|hw
operator|->
name|mac_type
operator|=
name|em_82545_rev_3
expr_stmt|;
break|break;
case|case
name|E1000_DEV_ID_82546EB_COPPER
case|:
case|case
name|E1000_DEV_ID_82546EB_FIBER
case|:
case|case
name|E1000_DEV_ID_82546EB_QUAD_COPPER
case|:
name|hw
operator|->
name|mac_type
operator|=
name|em_82546
expr_stmt|;
break|break;
case|case
name|E1000_DEV_ID_82546GB_COPPER
case|:
case|case
name|E1000_DEV_ID_82546GB_FIBER
case|:
case|case
name|E1000_DEV_ID_82546GB_SERDES
case|:
name|hw
operator|->
name|mac_type
operator|=
name|em_82546_rev_3
expr_stmt|;
break|break;
case|case
name|E1000_DEV_ID_82541EI
case|:
case|case
name|E1000_DEV_ID_82541EI_MOBILE
case|:
name|hw
operator|->
name|mac_type
operator|=
name|em_82541
expr_stmt|;
break|break;
case|case
name|E1000_DEV_ID_82541ER
case|:
case|case
name|E1000_DEV_ID_82541GI
case|:
case|case
name|E1000_DEV_ID_82541GI_MOBILE
case|:
name|hw
operator|->
name|mac_type
operator|=
name|em_82541_rev_2
expr_stmt|;
break|break;
case|case
name|E1000_DEV_ID_82547EI
case|:
name|hw
operator|->
name|mac_type
operator|=
name|em_82547
expr_stmt|;
break|break;
case|case
name|E1000_DEV_ID_82547GI
case|:
name|hw
operator|->
name|mac_type
operator|=
name|em_82547_rev_2
expr_stmt|;
break|break;
default|default:
comment|/* Should never have loaded on this device */
return|return
operator|-
name|E1000_ERR_MAC_TYPE
return|;
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************  * Set media type and TBI compatibility.  *  * hw - Struct containing variables accessed by shared code  * **************************************************************************/
end_comment

begin_function
name|void
name|em_set_media_type
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|uint32_t
name|status
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_set_media_type"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|!=
name|em_82543
condition|)
block|{
comment|/* tbi_compatibility is only valid on 82543 */
name|hw
operator|->
name|tbi_compatibility_en
operator|=
name|FALSE
expr_stmt|;
block|}
switch|switch
condition|(
name|hw
operator|->
name|device_id
condition|)
block|{
case|case
name|E1000_DEV_ID_82545GM_SERDES
case|:
case|case
name|E1000_DEV_ID_82546GB_SERDES
case|:
name|hw
operator|->
name|media_type
operator|=
name|em_media_type_internal_serdes
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|>=
name|em_82543
condition|)
block|{
name|status
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|E1000_STATUS_TBIMODE
condition|)
block|{
name|hw
operator|->
name|media_type
operator|=
name|em_media_type_fiber
expr_stmt|;
comment|/* tbi_compatibility not valid on fiber */
name|hw
operator|->
name|tbi_compatibility_en
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
name|hw
operator|->
name|media_type
operator|=
name|em_media_type_copper
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* This is an 82542 (fiber only) */
name|hw
operator|->
name|media_type
operator|=
name|em_media_type_fiber
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/******************************************************************************  * Reset the transmit and receive units; mask and clear all interrupts.  *  * hw - Struct containing variables accessed by shared code  *****************************************************************************/
end_comment

begin_function
name|int32_t
name|em_reset_hw
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|uint32_t
name|ctrl
decl_stmt|;
name|uint32_t
name|ctrl_ext
decl_stmt|;
name|uint32_t
name|icr
decl_stmt|;
name|uint32_t
name|manc
decl_stmt|;
name|uint32_t
name|led_ctrl
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_reset_hw"
argument_list|)
expr_stmt|;
comment|/* For 82542 (rev 2.0), disable MWI before issuing a device reset */
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|==
name|em_82542_rev2_0
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Disabling MWI on 82542 rev 2.0\n"
argument_list|)
expr_stmt|;
name|em_pci_clear_mwi
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
comment|/* Clear interrupt mask to stop board from generating interrupts */
name|DEBUGOUT
argument_list|(
literal|"Masking off all interrupts\n"
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IMC
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
comment|/* Disable the Transmit and Receive units.  Then delay to allow      * any pending transactions to complete before we hit the MAC with      * the global reset.      */
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|RCTL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|TCTL
argument_list|,
name|E1000_TCTL_PSP
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* The tbi_compatibility_on Flag must be cleared when Rctl is cleared. */
name|hw
operator|->
name|tbi_compatibility_on
operator|=
name|FALSE
expr_stmt|;
comment|/* Delay to allow any outstanding PCI transactions to complete before      * resetting the device      */
name|msec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|)
expr_stmt|;
comment|/* Must reset the PHY before resetting the MAC */
if|if
condition|(
operator|(
name|hw
operator|->
name|mac_type
operator|==
name|em_82541
operator|)
operator|||
operator|(
name|hw
operator|->
name|mac_type
operator|==
name|em_82547
operator|)
condition|)
block|{
name|E1000_WRITE_REG_IO
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|,
operator|(
name|ctrl
operator||
name|E1000_CTRL_PHY_RST
operator|)
argument_list|)
expr_stmt|;
name|msec_delay
argument_list|(
literal|5
argument_list|)
expr_stmt|;
block|}
comment|/* Issue a global reset to the MAC.  This will reset the chip's      * transmit, receive, DMA, and link units.  It will not effect      * the current PCI configuration.  The global reset bit is self-      * clearing, and should clear within a microsecond.      */
name|DEBUGOUT
argument_list|(
literal|"Issuing a global reset to MAC\n"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|hw
operator|->
name|mac_type
condition|)
block|{
case|case
name|em_82544
case|:
case|case
name|em_82540
case|:
case|case
name|em_82545
case|:
case|case
name|em_82546
case|:
case|case
name|em_82541
case|:
case|case
name|em_82541_rev_2
case|:
comment|/* These controllers can't ack the 64-bit write when issuing the              * reset, so use IO-mapping as a workaround to issue the reset */
name|E1000_WRITE_REG_IO
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|,
operator|(
name|ctrl
operator||
name|E1000_CTRL_RST
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|em_82545_rev_3
case|:
case|case
name|em_82546_rev_3
case|:
comment|/* Reset is performed on a shadow of the control register */
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|CTRL_DUP
argument_list|,
operator|(
name|ctrl
operator||
name|E1000_CTRL_RST
operator|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|,
operator|(
name|ctrl
operator||
name|E1000_CTRL_RST
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* After MAC reset, force reload of EEPROM to restore power-on settings to      * device.  Later controllers reload the EEPROM automatically, so just wait      * for reload to complete.      */
switch|switch
condition|(
name|hw
operator|->
name|mac_type
condition|)
block|{
case|case
name|em_82542_rev2_0
case|:
case|case
name|em_82542_rev2_1
case|:
case|case
name|em_82543
case|:
case|case
name|em_82544
case|:
comment|/* Wait for reset to complete */
name|usec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|ctrl_ext
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|CTRL_EXT
argument_list|)
expr_stmt|;
name|ctrl_ext
operator||=
name|E1000_CTRL_EXT_EE_RST
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|CTRL_EXT
argument_list|,
name|ctrl_ext
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Wait for EEPROM reload */
name|msec_delay
argument_list|(
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|em_82541
case|:
case|case
name|em_82541_rev_2
case|:
case|case
name|em_82547
case|:
case|case
name|em_82547_rev_2
case|:
comment|/* Wait for EEPROM reload */
name|msec_delay
argument_list|(
literal|20
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Wait for EEPROM reload (it happens automatically) */
name|msec_delay
argument_list|(
literal|5
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Disable HW ARPs on ASF enabled adapters */
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|>=
name|em_82540
condition|)
block|{
name|manc
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|MANC
argument_list|)
expr_stmt|;
name|manc
operator|&=
operator|~
operator|(
name|E1000_MANC_ARP_EN
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|MANC
argument_list|,
name|manc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|hw
operator|->
name|mac_type
operator|==
name|em_82541
operator|)
operator|||
operator|(
name|hw
operator|->
name|mac_type
operator|==
name|em_82547
operator|)
condition|)
block|{
name|em_phy_init_script
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Configure activity LED after PHY reset */
name|led_ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|LEDCTL
argument_list|)
expr_stmt|;
name|led_ctrl
operator|&=
name|IGP_ACTIVITY_LED_MASK
expr_stmt|;
name|led_ctrl
operator||=
operator|(
name|IGP_ACTIVITY_LED_ENABLE
operator||
name|IGP_LED3_MODE
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|LEDCTL
argument_list|,
name|led_ctrl
argument_list|)
expr_stmt|;
block|}
comment|/* Clear interrupt mask to stop board from generating interrupts */
name|DEBUGOUT
argument_list|(
literal|"Masking off all interrupts\n"
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IMC
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
comment|/* Clear any pending interrupt events. */
name|icr
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|ICR
argument_list|)
expr_stmt|;
comment|/* If MWI was previously enabled, reenable it. */
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|==
name|em_82542_rev2_0
condition|)
block|{
if|if
condition|(
name|hw
operator|->
name|pci_cmd_word
operator|&
name|CMD_MEM_WRT_INVALIDATE
condition|)
name|em_pci_set_mwi
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Performs basic configuration of the adapter.  *  * hw - Struct containing variables accessed by shared code  *  * Assumes that the controller has previously been reset and is in a  * post-reset uninitialized state. Initializes the receive address registers,  * multicast table, and VLAN filter table. Calls routines to setup link  * configuration and flow control settings. Clears all on-chip counters. Leaves  * the transmit and receive units disabled and uninitialized.  *****************************************************************************/
end_comment

begin_function
name|int32_t
name|em_init_hw
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|uint32_t
name|ctrl
decl_stmt|;
name|uint32_t
name|i
decl_stmt|;
name|int32_t
name|ret_val
decl_stmt|;
name|uint16_t
name|pcix_cmd_word
decl_stmt|;
name|uint16_t
name|pcix_stat_hi_word
decl_stmt|;
name|uint16_t
name|cmd_mmrbc
decl_stmt|;
name|uint16_t
name|stat_mmrbc
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_init_hw"
argument_list|)
expr_stmt|;
comment|/* Initialize Identification LED */
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_id_led_init
argument_list|(
name|hw
argument_list|)
operator|)
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Error Initializing Identification LED\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
comment|/* Set the media type and TBI compatibility */
name|em_set_media_type
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Disabling VLAN filtering. */
name|DEBUGOUT
argument_list|(
literal|"Initializing the IEEE VLAN\n"
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|VET
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|em_clear_vfta
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* For 82542 (rev 2.0), disable MWI and put the receiver into reset */
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|==
name|em_82542_rev2_0
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Disabling MWI on 82542 rev 2.0\n"
argument_list|)
expr_stmt|;
name|em_pci_clear_mwi
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|RCTL
argument_list|,
name|E1000_RCTL_RST
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|msec_delay
argument_list|(
literal|5
argument_list|)
expr_stmt|;
block|}
comment|/* Setup the receive address. This involves initializing all of the Receive      * Address Registers (RARs 0 - 15).      */
name|em_init_rx_addrs
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* For 82542 (rev 2.0), take the receiver out of reset and enable MWI */
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|==
name|em_82542_rev2_0
condition|)
block|{
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|RCTL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|msec_delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|pci_cmd_word
operator|&
name|CMD_MEM_WRT_INVALIDATE
condition|)
name|em_pci_set_mwi
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
comment|/* Zero out the Multicast HASH table */
name|DEBUGOUT
argument_list|(
literal|"Zeroing the MTA\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|E1000_MC_TBL_SIZE
condition|;
name|i
operator|++
control|)
name|E1000_WRITE_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|MTA
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Set the PCI priority bit correctly in the CTRL register.  This      * determines if the adapter gives priority to receives, or if it      * gives equal priority to transmits and receives.      */
if|if
condition|(
name|hw
operator|->
name|dma_fairness
condition|)
block|{
name|ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|,
name|ctrl
operator||
name|E1000_CTRL_PRIOR
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|hw
operator|->
name|mac_type
condition|)
block|{
case|case
name|em_82545_rev_3
case|:
case|case
name|em_82546_rev_3
case|:
break|break;
default|default:
comment|/* Workaround for PCI-X problem when BIOS sets MMRBC incorrectly. */
if|if
condition|(
name|hw
operator|->
name|bus_type
operator|==
name|em_bus_type_pcix
condition|)
block|{
name|em_read_pci_cfg
argument_list|(
name|hw
argument_list|,
name|PCIX_COMMAND_REGISTER
argument_list|,
operator|&
name|pcix_cmd_word
argument_list|)
expr_stmt|;
name|em_read_pci_cfg
argument_list|(
name|hw
argument_list|,
name|PCIX_STATUS_REGISTER_HI
argument_list|,
operator|&
name|pcix_stat_hi_word
argument_list|)
expr_stmt|;
name|cmd_mmrbc
operator|=
operator|(
name|pcix_cmd_word
operator|&
name|PCIX_COMMAND_MMRBC_MASK
operator|)
operator|>>
name|PCIX_COMMAND_MMRBC_SHIFT
expr_stmt|;
name|stat_mmrbc
operator|=
operator|(
name|pcix_stat_hi_word
operator|&
name|PCIX_STATUS_HI_MMRBC_MASK
operator|)
operator|>>
name|PCIX_STATUS_HI_MMRBC_SHIFT
expr_stmt|;
if|if
condition|(
name|stat_mmrbc
operator|==
name|PCIX_STATUS_HI_MMRBC_4K
condition|)
name|stat_mmrbc
operator|=
name|PCIX_STATUS_HI_MMRBC_2K
expr_stmt|;
if|if
condition|(
name|cmd_mmrbc
operator|>
name|stat_mmrbc
condition|)
block|{
name|pcix_cmd_word
operator|&=
operator|~
name|PCIX_COMMAND_MMRBC_MASK
expr_stmt|;
name|pcix_cmd_word
operator||=
name|stat_mmrbc
operator|<<
name|PCIX_COMMAND_MMRBC_SHIFT
expr_stmt|;
name|em_write_pci_cfg
argument_list|(
name|hw
argument_list|,
name|PCIX_COMMAND_REGISTER
argument_list|,
operator|&
name|pcix_cmd_word
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
comment|/* Call a subroutine to configure the link and setup flow control. */
name|ret_val
operator|=
name|em_setup_link
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Set the transmit descriptor write-back policy */
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|>
name|em_82544
condition|)
block|{
name|ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|TXDCTL
argument_list|)
expr_stmt|;
name|ctrl
operator|=
operator|(
name|ctrl
operator|&
operator|~
name|E1000_TXDCTL_WTHRESH
operator|)
operator||
name|E1000_TXDCTL_FULL_TX_DESC_WB
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|TXDCTL
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
block|}
comment|/* Clear all of the statistics registers (clear on read).  It is      * important that we do this after we have tried to establish link      * because the symbol error count will increment wildly if there      * is no link.      */
name|em_clear_hw_cntrs
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Adjust SERDES output amplitude based on EEPROM setting.  *  * hw - Struct containing variables accessed by shared code.  *****************************************************************************/
end_comment

begin_function
specifier|static
name|int32_t
name|em_adjust_serdes_amplitude
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|uint16_t
name|eeprom_data
decl_stmt|;
name|int32_t
name|ret_val
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_adjust_serdes_amplitude"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|media_type
operator|!=
name|em_media_type_internal_serdes
condition|)
return|return
name|E1000_SUCCESS
return|;
switch|switch
condition|(
name|hw
operator|->
name|mac_type
condition|)
block|{
case|case
name|em_82545_rev_3
case|:
case|case
name|em_82546_rev_3
case|:
break|break;
default|default:
return|return
name|E1000_SUCCESS
return|;
block|}
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_read_eeprom
argument_list|(
name|hw
argument_list|,
name|EEPROM_SERDES_AMPLITUDE
argument_list|,
literal|1
argument_list|,
operator|&
name|eeprom_data
argument_list|)
operator|)
condition|)
block|{
return|return
name|ret_val
return|;
block|}
if|if
condition|(
name|eeprom_data
operator|!=
name|EEPROM_RESERVED_WORD
condition|)
block|{
comment|/* Adjust SERDES output amplitude only. */
name|eeprom_data
operator|&=
name|EEPROM_SERDES_AMPLITUDE_MASK
expr_stmt|;
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_EXT_CTRL
argument_list|,
name|eeprom_data
argument_list|)
operator|)
condition|)
return|return
name|ret_val
return|;
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Configures flow control and link settings.  *  * hw - Struct containing variables accessed by shared code  *  * Determines which flow control settings to use. Calls the apropriate media-  * specific link configuration function. Configures the flow control settings.  * Assuming the adapter has a valid link partner, a valid link should be  * established. Assumes the hardware has previously been reset and the  * transmitter and receiver are not enabled.  *****************************************************************************/
end_comment

begin_function
name|int32_t
name|em_setup_link
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|uint32_t
name|ctrl_ext
decl_stmt|;
name|int32_t
name|ret_val
decl_stmt|;
name|uint16_t
name|eeprom_data
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_setup_link"
argument_list|)
expr_stmt|;
comment|/* Read and store word 0x0F of the EEPROM. This word contains bits      * that determine the hardware's default PAUSE (flow control) mode,      * a bit that determines whether the HW defaults to enabling or      * disabling auto-negotiation, and the direction of the      * SW defined pins. If there is no SW over-ride of the flow      * control setting, then the variable hw->fc will      * be initialized based on a value in the EEPROM.      */
if|if
condition|(
name|em_read_eeprom
argument_list|(
name|hw
argument_list|,
name|EEPROM_INIT_CONTROL2_REG
argument_list|,
literal|1
argument_list|,
operator|&
name|eeprom_data
argument_list|)
operator|<
literal|0
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"EEPROM Read Error\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_EEPROM
return|;
block|}
if|if
condition|(
name|hw
operator|->
name|fc
operator|==
name|em_fc_default
condition|)
block|{
if|if
condition|(
operator|(
name|eeprom_data
operator|&
name|EEPROM_WORD0F_PAUSE_MASK
operator|)
operator|==
literal|0
condition|)
name|hw
operator|->
name|fc
operator|=
name|em_fc_none
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|eeprom_data
operator|&
name|EEPROM_WORD0F_PAUSE_MASK
operator|)
operator|==
name|EEPROM_WORD0F_ASM_DIR
condition|)
name|hw
operator|->
name|fc
operator|=
name|em_fc_tx_pause
expr_stmt|;
else|else
name|hw
operator|->
name|fc
operator|=
name|em_fc_full
expr_stmt|;
block|}
comment|/* We want to save off the original Flow Control configuration just      * in case we get disconnected and then reconnected into a different      * hub or switch with different Flow Control capabilities.      */
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|==
name|em_82542_rev2_0
condition|)
name|hw
operator|->
name|fc
operator|&=
operator|(
operator|~
name|em_fc_tx_pause
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|hw
operator|->
name|mac_type
operator|<
name|em_82543
operator|)
operator|&&
operator|(
name|hw
operator|->
name|report_tx_early
operator|==
literal|1
operator|)
condition|)
name|hw
operator|->
name|fc
operator|&=
operator|(
operator|~
name|em_fc_rx_pause
operator|)
expr_stmt|;
name|hw
operator|->
name|original_fc
operator|=
name|hw
operator|->
name|fc
expr_stmt|;
name|DEBUGOUT1
argument_list|(
literal|"After fix-ups FlowControl is now = %x\n"
argument_list|,
name|hw
operator|->
name|fc
argument_list|)
expr_stmt|;
comment|/* Take the 4 bits from EEPROM word 0x0F that determine the initial      * polarity value for the SW controlled pins, and setup the      * Extended Device Control reg with that info.      * This is needed because one of the SW controlled pins is used for      * signal detection.  So this should be done before em_setup_pcs_link()      * or em_phy_setup() is called.      */
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|==
name|em_82543
condition|)
block|{
name|ctrl_ext
operator|=
operator|(
operator|(
name|eeprom_data
operator|&
name|EEPROM_WORD0F_SWPDIO_EXT
operator|)
operator|<<
name|SWDPIO__EXT_SHIFT
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|CTRL_EXT
argument_list|,
name|ctrl_ext
argument_list|)
expr_stmt|;
block|}
comment|/* Call the necessary subroutine to configure the link. */
name|ret_val
operator|=
operator|(
name|hw
operator|->
name|media_type
operator|==
name|em_media_type_copper
operator|)
condition|?
name|em_setup_copper_link
argument_list|(
name|hw
argument_list|)
else|:
name|em_setup_fiber_serdes_link
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Initialize the flow control address, type, and PAUSE timer      * registers to their default values.  This is done even if flow      * control is disabled, because it does not hurt anything to      * initialize these registers.      */
name|DEBUGOUT
argument_list|(
literal|"Initializing the Flow Control address, type and timer regs\n"
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|FCAL
argument_list|,
name|FLOW_CONTROL_ADDRESS_LOW
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|FCAH
argument_list|,
name|FLOW_CONTROL_ADDRESS_HIGH
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|FCT
argument_list|,
name|FLOW_CONTROL_TYPE
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|FCTTV
argument_list|,
name|hw
operator|->
name|fc_pause_time
argument_list|)
expr_stmt|;
comment|/* Set the flow control receive threshold registers.  Normally,      * these registers will be set to a default threshold that may be      * adjusted later by the driver's runtime code.  However, if the      * ability to transmit pause frames in not enabled, then these      * registers will be set to 0.      */
if|if
condition|(
operator|!
operator|(
name|hw
operator|->
name|fc
operator|&
name|em_fc_tx_pause
operator|)
condition|)
block|{
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|FCRTL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|FCRTH
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* We need to set up the Receive Threshold high and low water marks          * as well as (optionally) enabling the transmission of XON frames.          */
if|if
condition|(
name|hw
operator|->
name|fc_send_xon
condition|)
block|{
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|FCRTL
argument_list|,
operator|(
name|hw
operator|->
name|fc_low_water
operator||
name|E1000_FCRTL_XONE
operator|)
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|FCRTH
argument_list|,
name|hw
operator|->
name|fc_high_water
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|FCRTL
argument_list|,
name|hw
operator|->
name|fc_low_water
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|FCRTH
argument_list|,
name|hw
operator|->
name|fc_high_water
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Sets up link for a fiber based or serdes based adapter  *  * hw - Struct containing variables accessed by shared code  *  * Manipulates Physical Coding Sublayer functions in order to configure  * link. Assumes the hardware has been previously reset and the transmitter  * and receiver are not enabled.  *****************************************************************************/
end_comment

begin_function
specifier|static
name|int32_t
name|em_setup_fiber_serdes_link
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|uint32_t
name|ctrl
decl_stmt|;
name|uint32_t
name|status
decl_stmt|;
name|uint32_t
name|txcw
init|=
literal|0
decl_stmt|;
name|uint32_t
name|i
decl_stmt|;
name|uint32_t
name|signal
init|=
literal|0
decl_stmt|;
name|int32_t
name|ret_val
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_setup_fiber_serdes_link"
argument_list|)
expr_stmt|;
comment|/* On adapters with a MAC newer than 82544, SW Defineable pin 1 will be      * set when the optics detect a signal. On older adapters, it will be      * cleared when there is a signal.  This applies to fiber media only.      * If we're on serdes media, adjust the output amplitude to value set in      * the EEPROM.      */
name|ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|media_type
operator|==
name|em_media_type_fiber
condition|)
name|signal
operator|=
operator|(
name|hw
operator|->
name|mac_type
operator|>
name|em_82544
operator|)
condition|?
name|E1000_CTRL_SWDPIN1
else|:
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_adjust_serdes_amplitude
argument_list|(
name|hw
argument_list|)
operator|)
condition|)
return|return
name|ret_val
return|;
comment|/* Take the link out of reset */
name|ctrl
operator|&=
operator|~
operator|(
name|E1000_CTRL_LRST
operator|)
expr_stmt|;
comment|/* Adjust VCO speed to improve BER performance */
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_set_vco_speed
argument_list|(
name|hw
argument_list|)
operator|)
condition|)
return|return
name|ret_val
return|;
name|em_config_collision_dist
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Check for a software override of the flow control settings, and setup      * the device accordingly.  If auto-negotiation is enabled, then software      * will have to set the "PAUSE" bits to the correct value in the Tranmsit      * Config Word Register (TXCW) and re-start auto-negotiation.  However, if      * auto-negotiation is disabled, then software will have to manually      * configure the two flow control enable bits in the CTRL register.      *      * The possible values of the "fc" parameter are:      *      0:  Flow control is completely disabled      *      1:  Rx flow control is enabled (we can receive pause frames, but      *          not send pause frames).      *      2:  Tx flow control is enabled (we can send pause frames but we do      *          not support receiving pause frames).      *      3:  Both Rx and TX flow control (symmetric) are enabled.      */
switch|switch
condition|(
name|hw
operator|->
name|fc
condition|)
block|{
case|case
name|em_fc_none
case|:
comment|/* Flow control is completely disabled by a software over-ride. */
name|txcw
operator|=
operator|(
name|E1000_TXCW_ANE
operator||
name|E1000_TXCW_FD
operator|)
expr_stmt|;
break|break;
case|case
name|em_fc_rx_pause
case|:
comment|/* RX Flow control is enabled and TX Flow control is disabled by a          * software over-ride. Since there really isn't a way to advertise          * that we are capable of RX Pause ONLY, we will advertise that we          * support both symmetric and asymmetric RX PAUSE. Later, we will          *  disable the adapter's ability to send PAUSE frames.          */
name|txcw
operator|=
operator|(
name|E1000_TXCW_ANE
operator||
name|E1000_TXCW_FD
operator||
name|E1000_TXCW_PAUSE_MASK
operator|)
expr_stmt|;
break|break;
case|case
name|em_fc_tx_pause
case|:
comment|/* TX Flow control is enabled, and RX Flow control is disabled, by a          * software over-ride.          */
name|txcw
operator|=
operator|(
name|E1000_TXCW_ANE
operator||
name|E1000_TXCW_FD
operator||
name|E1000_TXCW_ASM_DIR
operator|)
expr_stmt|;
break|break;
case|case
name|em_fc_full
case|:
comment|/* Flow control (both RX and TX) is enabled by a software over-ride. */
name|txcw
operator|=
operator|(
name|E1000_TXCW_ANE
operator||
name|E1000_TXCW_FD
operator||
name|E1000_TXCW_PAUSE_MASK
operator|)
expr_stmt|;
break|break;
default|default:
name|DEBUGOUT
argument_list|(
literal|"Flow control param set incorrectly\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_CONFIG
return|;
break|break;
block|}
comment|/* Since auto-negotiation is enabled, take the link out of reset (the link      * will be in reset, because we previously reset the chip). This will      * restart auto-negotiation.  If auto-neogtiation is successful then the      * link-up status bit will be set and the flow control enable bits (RFCE      * and TFCE) will be set according to their negotiated value.      */
name|DEBUGOUT
argument_list|(
literal|"Auto-negotiation enabled\n"
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|TXCW
argument_list|,
name|txcw
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|hw
operator|->
name|txcw
operator|=
name|txcw
expr_stmt|;
name|msec_delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* If we have a signal (the cable is plugged in) then poll for a "Link-Up"      * indication in the Device Status Register.  Time-out if a link isn't      * seen in 500 milliseconds seconds (Auto-negotiation should complete in      * less than 500 milliseconds even if the other end is doing it in SW).      * For internal serdes, we just assume a signal is present, then poll.      */
if|if
condition|(
name|hw
operator|->
name|media_type
operator|==
name|em_media_type_internal_serdes
operator|||
operator|(
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|)
operator|&
name|E1000_CTRL_SWDPIN1
operator|)
operator|==
name|signal
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Looking for Link\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|LINK_UP_TIMEOUT
operator|/
literal|10
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|msec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|status
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|E1000_STATUS_LU
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
operator|(
name|LINK_UP_TIMEOUT
operator|/
literal|10
operator|)
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Never got a valid link from auto-neg!!!\n"
argument_list|)
expr_stmt|;
name|hw
operator|->
name|autoneg_failed
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|media_type
operator|==
name|em_media_type_fiber
condition|)
block|{
comment|/* AutoNeg failed to achieve a link, so we'll call                  * em_check_for_link. This routine will force the link up if                  * we detect a signal. This will allow us to communicate with                  * non-autonegotiating link partners.                  */
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_check_for_link
argument_list|(
name|hw
argument_list|)
operator|)
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Error while checking for link\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
name|hw
operator|->
name|autoneg_failed
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|hw
operator|->
name|autoneg_failed
operator|=
literal|0
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Valid Link Found\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|DEBUGOUT
argument_list|(
literal|"No Signal Detected\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************** * Detects which PHY is present and the speed and duplex * * hw - Struct containing variables accessed by shared code ******************************************************************************/
end_comment

begin_function
specifier|static
name|int32_t
name|em_setup_copper_link
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|uint32_t
name|ctrl
decl_stmt|;
name|uint32_t
name|led_ctrl
decl_stmt|;
name|int32_t
name|ret_val
decl_stmt|;
name|uint16_t
name|i
decl_stmt|;
name|uint16_t
name|phy_data
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_setup_copper_link"
argument_list|)
expr_stmt|;
name|ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|)
expr_stmt|;
comment|/* With 82543, we need to force speed and duplex on the MAC equal to what      * the PHY speed and duplex configuration is. In addition, we need to      * perform a hardware reset on the PHY to take it out of reset.      */
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|>
name|em_82543
condition|)
block|{
name|ctrl
operator||=
name|E1000_CTRL_SLU
expr_stmt|;
name|ctrl
operator|&=
operator|~
operator|(
name|E1000_CTRL_FRCSPD
operator||
name|E1000_CTRL_FRCDPX
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ctrl
operator||=
operator|(
name|E1000_CTRL_FRCSPD
operator||
name|E1000_CTRL_FRCDPX
operator||
name|E1000_CTRL_SLU
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
name|em_phy_hw_reset
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
comment|/* Make sure we have a valid PHY */
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_detect_gig_phy
argument_list|(
name|hw
argument_list|)
operator|)
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Error, did not detect valid phy.\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
name|DEBUGOUT1
argument_list|(
literal|"Phy ID = %x \n"
argument_list|,
name|hw
operator|->
name|phy_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|<=
name|em_82543
operator|||
name|hw
operator|->
name|mac_type
operator|==
name|em_82541
operator|||
name|hw
operator|->
name|mac_type
operator|==
name|em_82547
operator|||
name|hw
operator|->
name|mac_type
operator|==
name|em_82541_rev_2
operator|||
name|hw
operator|->
name|mac_type
operator|==
name|em_82547_rev_2
condition|)
name|hw
operator|->
name|phy_reset_disable
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|!
name|hw
operator|->
name|phy_reset_disable
condition|)
block|{
if|if
condition|(
name|hw
operator|->
name|phy_type
operator|==
name|em_phy_igp
condition|)
block|{
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_phy_reset
argument_list|(
name|hw
argument_list|)
operator|)
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Error Resetting the PHY\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
comment|/* Wait 10ms for MAC to configure PHY from eeprom settings */
name|msec_delay
argument_list|(
literal|15
argument_list|)
expr_stmt|;
comment|/* Configure activity LED after PHY reset */
name|led_ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|LEDCTL
argument_list|)
expr_stmt|;
name|led_ctrl
operator|&=
name|IGP_ACTIVITY_LED_MASK
expr_stmt|;
name|led_ctrl
operator||=
operator|(
name|IGP_ACTIVITY_LED_ENABLE
operator||
name|IGP_LED3_MODE
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|LEDCTL
argument_list|,
name|led_ctrl
argument_list|)
expr_stmt|;
comment|/* disable lplu d3 during driver init */
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_set_d3_lplu_state
argument_list|(
name|hw
argument_list|,
name|FALSE
argument_list|)
operator|)
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Error Disabling LPLU D3\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
comment|/* Configure mdi-mdix settings */
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_CTRL
argument_list|,
operator|&
name|phy_data
argument_list|)
operator|)
condition|)
return|return
name|ret_val
return|;
if|if
condition|(
operator|(
name|hw
operator|->
name|mac_type
operator|==
name|em_82541
operator|)
operator|||
operator|(
name|hw
operator|->
name|mac_type
operator|==
name|em_82547
operator|)
condition|)
block|{
name|hw
operator|->
name|dsp_config_state
operator|=
name|em_dsp_config_disabled
expr_stmt|;
comment|/* Force MDI for IGP B-0 PHY */
name|phy_data
operator|&=
operator|~
operator|(
name|IGP01E1000_PSCR_AUTO_MDIX
operator||
name|IGP01E1000_PSCR_FORCE_MDI_MDIX
operator|)
expr_stmt|;
name|hw
operator|->
name|mdix
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|hw
operator|->
name|dsp_config_state
operator|=
name|em_dsp_config_enabled
expr_stmt|;
name|phy_data
operator|&=
operator|~
name|IGP01E1000_PSCR_AUTO_MDIX
expr_stmt|;
switch|switch
condition|(
name|hw
operator|->
name|mdix
condition|)
block|{
case|case
literal|1
case|:
name|phy_data
operator|&=
operator|~
name|IGP01E1000_PSCR_FORCE_MDI_MDIX
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|phy_data
operator||=
name|IGP01E1000_PSCR_FORCE_MDI_MDIX
expr_stmt|;
break|break;
case|case
literal|0
case|:
default|default:
name|phy_data
operator||=
name|IGP01E1000_PSCR_AUTO_MDIX
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_CTRL
argument_list|,
name|phy_data
argument_list|)
operator|)
condition|)
return|return
name|ret_val
return|;
comment|/* set auto-master slave resolution settings */
if|if
condition|(
name|hw
operator|->
name|autoneg
condition|)
block|{
name|em_ms_type
name|phy_ms_setting
init|=
name|hw
operator|->
name|master_slave
decl_stmt|;
if|if
condition|(
name|hw
operator|->
name|ffe_config_state
operator|==
name|em_ffe_config_active
condition|)
name|hw
operator|->
name|ffe_config_state
operator|=
name|em_ffe_config_enabled
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|dsp_config_state
operator|==
name|em_dsp_config_activated
condition|)
name|hw
operator|->
name|dsp_config_state
operator|=
name|em_dsp_config_enabled
expr_stmt|;
comment|/* when autonegotiation advertisment is only 1000Mbps then we                  * should disable SmartSpeed and enable Auto MasterSlave                  * resolution as hardware default. */
if|if
condition|(
name|hw
operator|->
name|autoneg_advertised
operator|==
name|ADVERTISE_1000_FULL
condition|)
block|{
comment|/* Disable SmartSpeed */
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_CONFIG
argument_list|,
operator|&
name|phy_data
argument_list|)
operator|)
condition|)
return|return
name|ret_val
return|;
name|phy_data
operator|&=
operator|~
name|IGP01E1000_PSCFR_SMART_SPEED
expr_stmt|;
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_CONFIG
argument_list|,
name|phy_data
argument_list|)
operator|)
condition|)
return|return
name|ret_val
return|;
comment|/* Set auto Master/Slave resolution process */
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_1000T_CTRL
argument_list|,
operator|&
name|phy_data
argument_list|)
operator|)
condition|)
return|return
name|ret_val
return|;
name|phy_data
operator|&=
operator|~
name|CR_1000T_MS_ENABLE
expr_stmt|;
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_1000T_CTRL
argument_list|,
name|phy_data
argument_list|)
operator|)
condition|)
return|return
name|ret_val
return|;
block|}
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_1000T_CTRL
argument_list|,
operator|&
name|phy_data
argument_list|)
operator|)
condition|)
return|return
name|ret_val
return|;
comment|/* load defaults for future use */
name|hw
operator|->
name|original_master_slave
operator|=
operator|(
name|phy_data
operator|&
name|CR_1000T_MS_ENABLE
operator|)
condition|?
operator|(
operator|(
name|phy_data
operator|&
name|CR_1000T_MS_VALUE
operator|)
condition|?
name|em_ms_force_master
else|:
name|em_ms_force_slave
operator|)
else|:
name|em_ms_auto
expr_stmt|;
switch|switch
condition|(
name|phy_ms_setting
condition|)
block|{
case|case
name|em_ms_force_master
case|:
name|phy_data
operator||=
operator|(
name|CR_1000T_MS_ENABLE
operator||
name|CR_1000T_MS_VALUE
operator|)
expr_stmt|;
break|break;
case|case
name|em_ms_force_slave
case|:
name|phy_data
operator||=
name|CR_1000T_MS_ENABLE
expr_stmt|;
name|phy_data
operator|&=
operator|~
operator|(
name|CR_1000T_MS_VALUE
operator|)
expr_stmt|;
break|break;
case|case
name|em_ms_auto
case|:
name|phy_data
operator|&=
operator|~
name|CR_1000T_MS_ENABLE
expr_stmt|;
default|default:
break|break;
block|}
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_1000T_CTRL
argument_list|,
name|phy_data
argument_list|)
operator|)
condition|)
return|return
name|ret_val
return|;
block|}
block|}
else|else
block|{
comment|/* Enable CRS on TX. This must be set for half-duplex operation. */
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_SPEC_CTRL
argument_list|,
operator|&
name|phy_data
argument_list|)
operator|)
condition|)
return|return
name|ret_val
return|;
name|phy_data
operator||=
name|M88E1000_PSCR_ASSERT_CRS_ON_TX
expr_stmt|;
comment|/* Options:              *   MDI/MDI-X = 0 (default)              *   0 - Auto for all speeds              *   1 - MDI mode              *   2 - MDI-X mode              *   3 - Auto for 1000Base-T only (MDI-X for 10/100Base-T modes)              */
name|phy_data
operator|&=
operator|~
name|M88E1000_PSCR_AUTO_X_MODE
expr_stmt|;
switch|switch
condition|(
name|hw
operator|->
name|mdix
condition|)
block|{
case|case
literal|1
case|:
name|phy_data
operator||=
name|M88E1000_PSCR_MDI_MANUAL_MODE
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|phy_data
operator||=
name|M88E1000_PSCR_MDIX_MANUAL_MODE
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|phy_data
operator||=
name|M88E1000_PSCR_AUTO_X_1000T
expr_stmt|;
break|break;
case|case
literal|0
case|:
default|default:
name|phy_data
operator||=
name|M88E1000_PSCR_AUTO_X_MODE
expr_stmt|;
break|break;
block|}
comment|/* Options:              *   disable_polarity_correction = 0 (default)              *       Automatic Correction for Reversed Cable Polarity              *   0 - Disabled              *   1 - Enabled              */
name|phy_data
operator|&=
operator|~
name|M88E1000_PSCR_POLARITY_REVERSAL
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|disable_polarity_correction
operator|==
literal|1
condition|)
name|phy_data
operator||=
name|M88E1000_PSCR_POLARITY_REVERSAL
expr_stmt|;
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_SPEC_CTRL
argument_list|,
name|phy_data
argument_list|)
operator|)
condition|)
return|return
name|ret_val
return|;
comment|/* Force TX_CLK in the Extended PHY Specific Control Register              * to 25MHz clock.              */
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_EXT_PHY_SPEC_CTRL
argument_list|,
operator|&
name|phy_data
argument_list|)
operator|)
condition|)
return|return
name|ret_val
return|;
name|phy_data
operator||=
name|M88E1000_EPSCR_TX_CLK_25
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|phy_revision
operator|<
name|M88E1011_I_REV_4
condition|)
block|{
comment|/* Configure Master and Slave downshift values */
name|phy_data
operator|&=
operator|~
operator|(
name|M88E1000_EPSCR_MASTER_DOWNSHIFT_MASK
operator||
name|M88E1000_EPSCR_SLAVE_DOWNSHIFT_MASK
operator|)
expr_stmt|;
name|phy_data
operator||=
operator|(
name|M88E1000_EPSCR_MASTER_DOWNSHIFT_1X
operator||
name|M88E1000_EPSCR_SLAVE_DOWNSHIFT_1X
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_EXT_PHY_SPEC_CTRL
argument_list|,
name|phy_data
argument_list|)
operator|)
condition|)
return|return
name|ret_val
return|;
block|}
comment|/* SW Reset the PHY so all changes take effect */
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_phy_reset
argument_list|(
name|hw
argument_list|)
operator|)
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Error Resetting the PHY\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
block|}
comment|/* Options:          *   autoneg = 1 (default)          *      PHY will advertise value(s) parsed from          *      autoneg_advertised and fc          *   autoneg = 0          *      PHY will be set to 10H, 10F, 100H, or 100F          *      depending on value parsed from forced_speed_duplex.          */
comment|/* Is autoneg enabled?  This is enabled by default or by software          * override.  If so, call em_phy_setup_autoneg routine to parse the          * autoneg_advertised and fc options. If autoneg is NOT enabled, then          * the user should have provided a speed/duplex override.  If so, then          * call em_phy_force_speed_duplex to parse and set this up.          */
if|if
condition|(
name|hw
operator|->
name|autoneg
condition|)
block|{
comment|/* Perform some bounds checking on the hw->autoneg_advertised              * parameter.  If this variable is zero, then set it to the default.              */
name|hw
operator|->
name|autoneg_advertised
operator|&=
name|AUTONEG_ADVERTISE_SPEED_DEFAULT
expr_stmt|;
comment|/* If autoneg_advertised is zero, we assume it was not defaulted              * by the calling code so we set to advertise full capability.              */
if|if
condition|(
name|hw
operator|->
name|autoneg_advertised
operator|==
literal|0
condition|)
name|hw
operator|->
name|autoneg_advertised
operator|=
name|AUTONEG_ADVERTISE_SPEED_DEFAULT
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Reconfiguring auto-neg advertisement params\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_phy_setup_autoneg
argument_list|(
name|hw
argument_list|)
operator|)
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Error Setting up Auto-Negotiation\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
name|DEBUGOUT
argument_list|(
literal|"Restarting Auto-Neg\n"
argument_list|)
expr_stmt|;
comment|/* Restart auto-negotiation by setting the Auto Neg Enable bit and              * the Auto Neg Restart bit in the PHY control register.              */
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_CTRL
argument_list|,
operator|&
name|phy_data
argument_list|)
operator|)
condition|)
return|return
name|ret_val
return|;
name|phy_data
operator||=
operator|(
name|MII_CR_AUTO_NEG_EN
operator||
name|MII_CR_RESTART_AUTO_NEG
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_CTRL
argument_list|,
name|phy_data
argument_list|)
operator|)
condition|)
return|return
name|ret_val
return|;
comment|/* Does the user want to wait for Auto-Neg to complete here, or              * check at a later time (for example, callback routine).              */
if|if
condition|(
name|hw
operator|->
name|wait_autoneg_complete
condition|)
block|{
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_wait_autoneg
argument_list|(
name|hw
argument_list|)
operator|)
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Error while waiting for autoneg to complete\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
block|}
name|hw
operator|->
name|get_link_status
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|DEBUGOUT
argument_list|(
literal|"Forcing speed and duplex\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_phy_force_speed_duplex
argument_list|(
name|hw
argument_list|)
operator|)
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Error Forcing Speed and Duplex\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
block|}
block|}
comment|/* !hw->phy_reset_disable */
comment|/* Check link status. Wait up to 100 microseconds for link to become      * valid.      */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_STATUS
argument_list|,
operator|&
name|phy_data
argument_list|)
operator|)
condition|)
return|return
name|ret_val
return|;
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_STATUS
argument_list|,
operator|&
name|phy_data
argument_list|)
operator|)
condition|)
return|return
name|ret_val
return|;
if|if
condition|(
name|phy_data
operator|&
name|MII_SR_LINK_STATUS
condition|)
block|{
comment|/* We have link, so we need to finish the config process:              *   1) Set up the MAC to the current PHY speed/duplex              *      if we are on 82543.  If we              *      are on newer silicon, we only need to configure              *      collision distance in the Transmit Control Register.              *   2) Set up flow control on the MAC to that established with              *      the link partner.              */
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|>=
name|em_82544
condition|)
block|{
name|em_config_collision_dist
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_config_mac_to_phy
argument_list|(
name|hw
argument_list|)
operator|)
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Error configuring MAC to PHY settings\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
block|}
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_config_fc_after_link_up
argument_list|(
name|hw
argument_list|)
operator|)
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Error Configuring Flow Control\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
name|DEBUGOUT
argument_list|(
literal|"Valid link established!!!\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|phy_type
operator|==
name|em_phy_igp
condition|)
block|{
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_config_dsp_after_link_change
argument_list|(
name|hw
argument_list|,
name|TRUE
argument_list|)
operator|)
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Error Configuring DSP after link up\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
block|}
name|DEBUGOUT
argument_list|(
literal|"Valid link established!!!\n"
argument_list|)
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
name|usec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
name|DEBUGOUT
argument_list|(
literal|"Unable to establish link!!!\n"
argument_list|)
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************** * Configures PHY autoneg and flow control advertisement settings * * hw - Struct containing variables accessed by shared code ******************************************************************************/
end_comment

begin_function
name|int32_t
name|em_phy_setup_autoneg
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|int32_t
name|ret_val
decl_stmt|;
name|uint16_t
name|mii_autoneg_adv_reg
decl_stmt|;
name|uint16_t
name|mii_1000t_ctrl_reg
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_phy_setup_autoneg"
argument_list|)
expr_stmt|;
comment|/* Read the MII Auto-Neg Advertisement Register (Address 4). */
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_AUTONEG_ADV
argument_list|,
operator|&
name|mii_autoneg_adv_reg
argument_list|)
operator|)
condition|)
return|return
name|ret_val
return|;
comment|/* Read the MII 1000Base-T Control Register (Address 9). */
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_1000T_CTRL
argument_list|,
operator|&
name|mii_1000t_ctrl_reg
argument_list|)
operator|)
condition|)
return|return
name|ret_val
return|;
comment|/* Need to parse both autoneg_advertised and fc and set up      * the appropriate PHY registers.  First we will parse for      * autoneg_advertised software override.  Since we can advertise      * a plethora of combinations, we need to check each bit      * individually.      */
comment|/* First we clear all the 10/100 mb speed bits in the Auto-Neg      * Advertisement Register (Address 4) and the 1000 mb speed bits in      * the  1000Base-T Control Register (Address 9).      */
name|mii_autoneg_adv_reg
operator|&=
operator|~
name|REG4_SPEED_MASK
expr_stmt|;
name|mii_1000t_ctrl_reg
operator|&=
operator|~
name|REG9_SPEED_MASK
expr_stmt|;
name|DEBUGOUT1
argument_list|(
literal|"autoneg_advertised %x\n"
argument_list|,
name|hw
operator|->
name|autoneg_advertised
argument_list|)
expr_stmt|;
comment|/* Do we want to advertise 10 Mb Half Duplex? */
if|if
condition|(
name|hw
operator|->
name|autoneg_advertised
operator|&
name|ADVERTISE_10_HALF
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Advertise 10mb Half duplex\n"
argument_list|)
expr_stmt|;
name|mii_autoneg_adv_reg
operator||=
name|NWAY_AR_10T_HD_CAPS
expr_stmt|;
block|}
comment|/* Do we want to advertise 10 Mb Full Duplex? */
if|if
condition|(
name|hw
operator|->
name|autoneg_advertised
operator|&
name|ADVERTISE_10_FULL
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Advertise 10mb Full duplex\n"
argument_list|)
expr_stmt|;
name|mii_autoneg_adv_reg
operator||=
name|NWAY_AR_10T_FD_CAPS
expr_stmt|;
block|}
comment|/* Do we want to advertise 100 Mb Half Duplex? */
if|if
condition|(
name|hw
operator|->
name|autoneg_advertised
operator|&
name|ADVERTISE_100_HALF
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Advertise 100mb Half duplex\n"
argument_list|)
expr_stmt|;
name|mii_autoneg_adv_reg
operator||=
name|NWAY_AR_100TX_HD_CAPS
expr_stmt|;
block|}
comment|/* Do we want to advertise 100 Mb Full Duplex? */
if|if
condition|(
name|hw
operator|->
name|autoneg_advertised
operator|&
name|ADVERTISE_100_FULL
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Advertise 100mb Full duplex\n"
argument_list|)
expr_stmt|;
name|mii_autoneg_adv_reg
operator||=
name|NWAY_AR_100TX_FD_CAPS
expr_stmt|;
block|}
comment|/* We do not allow the Phy to advertise 1000 Mb Half Duplex */
if|if
condition|(
name|hw
operator|->
name|autoneg_advertised
operator|&
name|ADVERTISE_1000_HALF
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Advertise 1000mb Half duplex requested, request denied!\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Do we want to advertise 1000 Mb Full Duplex? */
if|if
condition|(
name|hw
operator|->
name|autoneg_advertised
operator|&
name|ADVERTISE_1000_FULL
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Advertise 1000mb Full duplex\n"
argument_list|)
expr_stmt|;
name|mii_1000t_ctrl_reg
operator||=
name|CR_1000T_FD_CAPS
expr_stmt|;
block|}
comment|/* Check for a software override of the flow control settings, and      * setup the PHY advertisement registers accordingly.  If      * auto-negotiation is enabled, then software will have to set the      * "PAUSE" bits to the correct value in the Auto-Negotiation      * Advertisement Register (PHY_AUTONEG_ADV) and re-start auto-negotiation.      *      * The possible values of the "fc" parameter are:      *      0:  Flow control is completely disabled      *      1:  Rx flow control is enabled (we can receive pause frames      *          but not send pause frames).      *      2:  Tx flow control is enabled (we can send pause frames      *          but we do not support receiving pause frames).      *      3:  Both Rx and TX flow control (symmetric) are enabled.      *  other:  No software override.  The flow control configuration      *          in the EEPROM is used.      */
switch|switch
condition|(
name|hw
operator|->
name|fc
condition|)
block|{
case|case
name|em_fc_none
case|:
comment|/* 0 */
comment|/* Flow control (RX& TX) is completely disabled by a          * software over-ride.          */
name|mii_autoneg_adv_reg
operator|&=
operator|~
operator|(
name|NWAY_AR_ASM_DIR
operator||
name|NWAY_AR_PAUSE
operator|)
expr_stmt|;
break|break;
case|case
name|em_fc_rx_pause
case|:
comment|/* 1 */
comment|/* RX Flow control is enabled, and TX Flow control is          * disabled, by a software over-ride.          */
comment|/* Since there really isn't a way to advertise that we are          * capable of RX Pause ONLY, we will advertise that we          * support both symmetric and asymmetric RX PAUSE.  Later          * (in em_config_fc_after_link_up) we will disable the          *hw's ability to send PAUSE frames.          */
name|mii_autoneg_adv_reg
operator||=
operator|(
name|NWAY_AR_ASM_DIR
operator||
name|NWAY_AR_PAUSE
operator|)
expr_stmt|;
break|break;
case|case
name|em_fc_tx_pause
case|:
comment|/* 2 */
comment|/* TX Flow control is enabled, and RX Flow control is          * disabled, by a software over-ride.          */
name|mii_autoneg_adv_reg
operator||=
name|NWAY_AR_ASM_DIR
expr_stmt|;
name|mii_autoneg_adv_reg
operator|&=
operator|~
name|NWAY_AR_PAUSE
expr_stmt|;
break|break;
case|case
name|em_fc_full
case|:
comment|/* 3 */
comment|/* Flow control (both RX and TX) is enabled by a software          * over-ride.          */
name|mii_autoneg_adv_reg
operator||=
operator|(
name|NWAY_AR_ASM_DIR
operator||
name|NWAY_AR_PAUSE
operator|)
expr_stmt|;
break|break;
default|default:
name|DEBUGOUT
argument_list|(
literal|"Flow control param set incorrectly\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_CONFIG
return|;
block|}
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_AUTONEG_ADV
argument_list|,
name|mii_autoneg_adv_reg
argument_list|)
operator|)
condition|)
return|return
name|ret_val
return|;
name|DEBUGOUT1
argument_list|(
literal|"Auto-Neg Advertising %x\n"
argument_list|,
name|mii_autoneg_adv_reg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_1000T_CTRL
argument_list|,
name|mii_1000t_ctrl_reg
argument_list|)
operator|)
condition|)
return|return
name|ret_val
return|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************** * Force PHY speed and duplex settings to hw->forced_speed_duplex * * hw - Struct containing variables accessed by shared code ******************************************************************************/
end_comment

begin_function
specifier|static
name|int32_t
name|em_phy_force_speed_duplex
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|uint32_t
name|ctrl
decl_stmt|;
name|int32_t
name|ret_val
decl_stmt|;
name|uint16_t
name|mii_ctrl_reg
decl_stmt|;
name|uint16_t
name|mii_status_reg
decl_stmt|;
name|uint16_t
name|phy_data
decl_stmt|;
name|uint16_t
name|i
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_phy_force_speed_duplex"
argument_list|)
expr_stmt|;
comment|/* Turn off Flow control if we are forcing speed and duplex. */
name|hw
operator|->
name|fc
operator|=
name|em_fc_none
expr_stmt|;
name|DEBUGOUT1
argument_list|(
literal|"hw->fc = %d\n"
argument_list|,
name|hw
operator|->
name|fc
argument_list|)
expr_stmt|;
comment|/* Read the Device Control Register. */
name|ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|)
expr_stmt|;
comment|/* Set the bits to Force Speed and Duplex in the Device Ctrl Reg. */
name|ctrl
operator||=
operator|(
name|E1000_CTRL_FRCSPD
operator||
name|E1000_CTRL_FRCDPX
operator|)
expr_stmt|;
name|ctrl
operator|&=
operator|~
operator|(
name|DEVICE_SPEED_MASK
operator|)
expr_stmt|;
comment|/* Clear the Auto Speed Detect Enable bit. */
name|ctrl
operator|&=
operator|~
name|E1000_CTRL_ASDE
expr_stmt|;
comment|/* Read the MII Control Register. */
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_CTRL
argument_list|,
operator|&
name|mii_ctrl_reg
argument_list|)
operator|)
condition|)
return|return
name|ret_val
return|;
comment|/* We need to disable autoneg in order to force link and duplex. */
name|mii_ctrl_reg
operator|&=
operator|~
name|MII_CR_AUTO_NEG_EN
expr_stmt|;
comment|/* Are we forcing Full or Half Duplex? */
if|if
condition|(
name|hw
operator|->
name|forced_speed_duplex
operator|==
name|em_100_full
operator|||
name|hw
operator|->
name|forced_speed_duplex
operator|==
name|em_10_full
condition|)
block|{
comment|/* We want to force full duplex so we SET the full duplex bits in the          * Device and MII Control Registers.          */
name|ctrl
operator||=
name|E1000_CTRL_FD
expr_stmt|;
name|mii_ctrl_reg
operator||=
name|MII_CR_FULL_DUPLEX
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Full Duplex\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* We want to force half duplex so we CLEAR the full duplex bits in          * the Device and MII Control Registers.          */
name|ctrl
operator|&=
operator|~
name|E1000_CTRL_FD
expr_stmt|;
name|mii_ctrl_reg
operator|&=
operator|~
name|MII_CR_FULL_DUPLEX
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Half Duplex\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Are we forcing 100Mbps??? */
if|if
condition|(
name|hw
operator|->
name|forced_speed_duplex
operator|==
name|em_100_full
operator|||
name|hw
operator|->
name|forced_speed_duplex
operator|==
name|em_100_half
condition|)
block|{
comment|/* Set the 100Mb bit and turn off the 1000Mb and 10Mb bits. */
name|ctrl
operator||=
name|E1000_CTRL_SPD_100
expr_stmt|;
name|mii_ctrl_reg
operator||=
name|MII_CR_SPEED_100
expr_stmt|;
name|mii_ctrl_reg
operator|&=
operator|~
operator|(
name|MII_CR_SPEED_1000
operator||
name|MII_CR_SPEED_10
operator|)
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Forcing 100mb "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Set the 10Mb bit and turn off the 1000Mb and 100Mb bits. */
name|ctrl
operator|&=
operator|~
operator|(
name|E1000_CTRL_SPD_1000
operator||
name|E1000_CTRL_SPD_100
operator|)
expr_stmt|;
name|mii_ctrl_reg
operator||=
name|MII_CR_SPEED_10
expr_stmt|;
name|mii_ctrl_reg
operator|&=
operator|~
operator|(
name|MII_CR_SPEED_1000
operator||
name|MII_CR_SPEED_100
operator|)
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Forcing 10mb "
argument_list|)
expr_stmt|;
block|}
name|em_config_collision_dist
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Write the configured values back to the Device Control Reg. */
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|phy_type
operator|==
name|em_phy_m88
condition|)
block|{
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_SPEC_CTRL
argument_list|,
operator|&
name|phy_data
argument_list|)
operator|)
condition|)
return|return
name|ret_val
return|;
comment|/* Clear Auto-Crossover to force MDI manually. M88E1000 requires MDI          * forced whenever speed are duplex are forced.          */
name|phy_data
operator|&=
operator|~
name|M88E1000_PSCR_AUTO_X_MODE
expr_stmt|;
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_SPEC_CTRL
argument_list|,
name|phy_data
argument_list|)
operator|)
condition|)
return|return
name|ret_val
return|;
name|DEBUGOUT1
argument_list|(
literal|"M88E1000 PSCR: %x \n"
argument_list|,
name|phy_data
argument_list|)
expr_stmt|;
comment|/* Need to reset the PHY or these changes will be ignored */
name|mii_ctrl_reg
operator||=
name|MII_CR_RESET
expr_stmt|;
block|}
else|else
block|{
comment|/* Clear Auto-Crossover to force MDI manually.  IGP requires MDI          * forced whenever speed or duplex are forced.          */
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_CTRL
argument_list|,
operator|&
name|phy_data
argument_list|)
operator|)
condition|)
return|return
name|ret_val
return|;
name|phy_data
operator|&=
operator|~
name|IGP01E1000_PSCR_AUTO_MDIX
expr_stmt|;
name|phy_data
operator|&=
operator|~
name|IGP01E1000_PSCR_FORCE_MDI_MDIX
expr_stmt|;
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_CTRL
argument_list|,
name|phy_data
argument_list|)
operator|)
condition|)
return|return
name|ret_val
return|;
block|}
comment|/* Write back the modified PHY MII control register. */
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_CTRL
argument_list|,
name|mii_ctrl_reg
argument_list|)
operator|)
condition|)
return|return
name|ret_val
return|;
name|usec_delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* The wait_autoneg_complete flag may be a little misleading here.      * Since we are forcing speed and duplex, Auto-Neg is not enabled.      * But we do want to delay for a period while forcing only so we      * don't generate false No Link messages.  So we will wait here      * only if the user has set wait_autoneg_complete to 1, which is      * the default.      */
if|if
condition|(
name|hw
operator|->
name|wait_autoneg_complete
condition|)
block|{
comment|/* We will wait for autoneg to complete. */
name|DEBUGOUT
argument_list|(
literal|"Waiting for forced speed/duplex link.\n"
argument_list|)
expr_stmt|;
name|mii_status_reg
operator|=
literal|0
expr_stmt|;
comment|/* We will wait for autoneg to complete or 4.5 seconds to expire. */
for|for
control|(
name|i
operator|=
name|PHY_FORCE_TIME
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
comment|/* Read the MII Status Register and wait for Auto-Neg Complete bit              * to be set.              */
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_STATUS
argument_list|,
operator|&
name|mii_status_reg
argument_list|)
operator|)
condition|)
return|return
name|ret_val
return|;
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_STATUS
argument_list|,
operator|&
name|mii_status_reg
argument_list|)
operator|)
condition|)
return|return
name|ret_val
return|;
if|if
condition|(
name|mii_status_reg
operator|&
name|MII_SR_LINK_STATUS
condition|)
break|break;
name|msec_delay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
comment|/* We didn't get link */
comment|/* Reset the DSP and wait again for link. */
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_phy_reset_dsp
argument_list|(
name|hw
argument_list|)
operator|)
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Error Resetting PHY DSP\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
block|}
comment|/* This loop will early-out if the link condition has been met.  */
for|for
control|(
name|i
operator|=
name|PHY_FORCE_TIME
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|mii_status_reg
operator|&
name|MII_SR_LINK_STATUS
condition|)
break|break;
name|msec_delay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
comment|/* Read the MII Status Register and wait for Auto-Neg Complete bit              * to be set.              */
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_STATUS
argument_list|,
operator|&
name|mii_status_reg
argument_list|)
operator|)
condition|)
return|return
name|ret_val
return|;
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_STATUS
argument_list|,
operator|&
name|mii_status_reg
argument_list|)
operator|)
condition|)
return|return
name|ret_val
return|;
block|}
block|}
if|if
condition|(
name|hw
operator|->
name|phy_type
operator|==
name|em_phy_m88
condition|)
block|{
comment|/* Because we reset the PHY above, we need to re-force TX_CLK in the          * Extended PHY Specific Control Register to 25MHz clock.  This value          * defaults back to a 2.5MHz clock when the PHY is reset.          */
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_EXT_PHY_SPEC_CTRL
argument_list|,
operator|&
name|phy_data
argument_list|)
operator|)
condition|)
return|return
name|ret_val
return|;
name|phy_data
operator||=
name|M88E1000_EPSCR_TX_CLK_25
expr_stmt|;
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_EXT_PHY_SPEC_CTRL
argument_list|,
name|phy_data
argument_list|)
operator|)
condition|)
return|return
name|ret_val
return|;
comment|/* In addition, because of the s/w reset above, we need to enable CRS on          * TX.  This must be set for both full and half duplex operation.          */
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_SPEC_CTRL
argument_list|,
operator|&
name|phy_data
argument_list|)
operator|)
condition|)
return|return
name|ret_val
return|;
name|phy_data
operator||=
name|M88E1000_PSCR_ASSERT_CRS_ON_TX
expr_stmt|;
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_SPEC_CTRL
argument_list|,
name|phy_data
argument_list|)
operator|)
condition|)
return|return
name|ret_val
return|;
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************** * Sets the collision distance in the Transmit Control register * * hw - Struct containing variables accessed by shared code * * Link should have been established previously. Reads the speed and duplex * information from the Device Status register. ******************************************************************************/
end_comment

begin_function
name|void
name|em_config_collision_dist
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|uint32_t
name|tctl
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_config_collision_dist"
argument_list|)
expr_stmt|;
name|tctl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|TCTL
argument_list|)
expr_stmt|;
name|tctl
operator|&=
operator|~
name|E1000_TCTL_COLD
expr_stmt|;
name|tctl
operator||=
name|E1000_COLLISION_DISTANCE
operator|<<
name|E1000_COLD_SHIFT
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|TCTL
argument_list|,
name|tctl
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************** * Sets MAC speed and duplex settings to reflect the those in the PHY * * hw - Struct containing variables accessed by shared code * mii_reg - data to write to the MII control register * * The contents of the PHY register containing the needed information need to * be passed in. ******************************************************************************/
end_comment

begin_function
specifier|static
name|int32_t
name|em_config_mac_to_phy
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|uint32_t
name|ctrl
decl_stmt|;
name|int32_t
name|ret_val
decl_stmt|;
name|uint16_t
name|phy_data
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_config_mac_to_phy"
argument_list|)
expr_stmt|;
comment|/* Read the Device Control Register and set the bits to Force Speed      * and Duplex.      */
name|ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|)
expr_stmt|;
name|ctrl
operator||=
operator|(
name|E1000_CTRL_FRCSPD
operator||
name|E1000_CTRL_FRCDPX
operator|)
expr_stmt|;
name|ctrl
operator|&=
operator|~
operator|(
name|E1000_CTRL_SPD_SEL
operator||
name|E1000_CTRL_ILOS
operator|)
expr_stmt|;
comment|/* Set up duplex in the Device Control and Transmit Control      * registers depending on negotiated values.      */
if|if
condition|(
name|hw
operator|->
name|phy_type
operator|==
name|em_phy_igp
condition|)
block|{
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_STATUS
argument_list|,
operator|&
name|phy_data
argument_list|)
operator|)
condition|)
return|return
name|ret_val
return|;
if|if
condition|(
name|phy_data
operator|&
name|IGP01E1000_PSSR_FULL_DUPLEX
condition|)
name|ctrl
operator||=
name|E1000_CTRL_FD
expr_stmt|;
else|else
name|ctrl
operator|&=
operator|~
name|E1000_CTRL_FD
expr_stmt|;
name|em_config_collision_dist
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Set up speed in the Device Control register depending on          * negotiated values.          */
if|if
condition|(
operator|(
name|phy_data
operator|&
name|IGP01E1000_PSSR_SPEED_MASK
operator|)
operator|==
name|IGP01E1000_PSSR_SPEED_1000MBPS
condition|)
name|ctrl
operator||=
name|E1000_CTRL_SPD_1000
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|phy_data
operator|&
name|IGP01E1000_PSSR_SPEED_MASK
operator|)
operator|==
name|IGP01E1000_PSSR_SPEED_100MBPS
condition|)
name|ctrl
operator||=
name|E1000_CTRL_SPD_100
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_SPEC_STATUS
argument_list|,
operator|&
name|phy_data
argument_list|)
operator|)
condition|)
return|return
name|ret_val
return|;
if|if
condition|(
name|phy_data
operator|&
name|M88E1000_PSSR_DPLX
condition|)
name|ctrl
operator||=
name|E1000_CTRL_FD
expr_stmt|;
else|else
name|ctrl
operator|&=
operator|~
name|E1000_CTRL_FD
expr_stmt|;
name|em_config_collision_dist
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Set up speed in the Device Control register depending on          * negotiated values.          */
if|if
condition|(
operator|(
name|phy_data
operator|&
name|M88E1000_PSSR_SPEED
operator|)
operator|==
name|M88E1000_PSSR_1000MBS
condition|)
name|ctrl
operator||=
name|E1000_CTRL_SPD_1000
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|phy_data
operator|&
name|M88E1000_PSSR_SPEED
operator|)
operator|==
name|M88E1000_PSSR_100MBS
condition|)
name|ctrl
operator||=
name|E1000_CTRL_SPD_100
expr_stmt|;
block|}
comment|/* Write the configured values back to the Device Control Reg. */
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Forces the MAC's flow control settings.  *  * hw - Struct containing variables accessed by shared code  *  * Sets the TFCE and RFCE bits in the device control register to reflect  * the adapter settings. TFCE and RFCE need to be explicitly set by  * software when a Copper PHY is used because autonegotiation is managed  * by the PHY rather than the MAC. Software must also configure these  * bits when link is forced on a fiber connection.  *****************************************************************************/
end_comment

begin_function
name|int32_t
name|em_force_mac_fc
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|uint32_t
name|ctrl
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_force_mac_fc"
argument_list|)
expr_stmt|;
comment|/* Get the current configuration of the Device Control Register */
name|ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|)
expr_stmt|;
comment|/* Because we didn't get link via the internal auto-negotiation      * mechanism (we either forced link or we got link via PHY      * auto-neg), we have to manually enable/disable transmit an      * receive flow control.      *      * The "Case" statement below enables/disable flow control      * according to the "hw->fc" parameter.      *      * The possible values of the "fc" parameter are:      *      0:  Flow control is completely disabled      *      1:  Rx flow control is enabled (we can receive pause      *          frames but not send pause frames).      *      2:  Tx flow control is enabled (we can send pause frames      *          frames but we do not receive pause frames).      *      3:  Both Rx and TX flow control (symmetric) is enabled.      *  other:  No other values should be possible at this point.      */
switch|switch
condition|(
name|hw
operator|->
name|fc
condition|)
block|{
case|case
name|em_fc_none
case|:
name|ctrl
operator|&=
operator|(
operator|~
operator|(
name|E1000_CTRL_TFCE
operator||
name|E1000_CTRL_RFCE
operator|)
operator|)
expr_stmt|;
break|break;
case|case
name|em_fc_rx_pause
case|:
name|ctrl
operator|&=
operator|(
operator|~
name|E1000_CTRL_TFCE
operator|)
expr_stmt|;
name|ctrl
operator||=
name|E1000_CTRL_RFCE
expr_stmt|;
break|break;
case|case
name|em_fc_tx_pause
case|:
name|ctrl
operator|&=
operator|(
operator|~
name|E1000_CTRL_RFCE
operator|)
expr_stmt|;
name|ctrl
operator||=
name|E1000_CTRL_TFCE
expr_stmt|;
break|break;
case|case
name|em_fc_full
case|:
name|ctrl
operator||=
operator|(
name|E1000_CTRL_TFCE
operator||
name|E1000_CTRL_RFCE
operator|)
expr_stmt|;
break|break;
default|default:
name|DEBUGOUT
argument_list|(
literal|"Flow control param set incorrectly\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_CONFIG
return|;
block|}
comment|/* Disable TX Flow Control for 82542 (rev 2.0) */
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|==
name|em_82542_rev2_0
condition|)
name|ctrl
operator|&=
operator|(
operator|~
name|E1000_CTRL_TFCE
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Configures flow control settings after link is established  *  * hw - Struct containing variables accessed by shared code  *  * Should be called immediately after a valid link has been established.  * Forces MAC flow control settings if link was forced. When in MII/GMII mode  * and autonegotiation is enabled, the MAC flow control settings will be set  * based on the flow control negotiated by the PHY. In TBI mode, the TFCE  * and RFCE bits will be automaticaly set to the negotiated flow control mode.  *****************************************************************************/
end_comment

begin_function
name|int32_t
name|em_config_fc_after_link_up
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|int32_t
name|ret_val
decl_stmt|;
name|uint16_t
name|mii_status_reg
decl_stmt|;
name|uint16_t
name|mii_nway_adv_reg
decl_stmt|;
name|uint16_t
name|mii_nway_lp_ability_reg
decl_stmt|;
name|uint16_t
name|speed
decl_stmt|;
name|uint16_t
name|duplex
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_config_fc_after_link_up"
argument_list|)
expr_stmt|;
comment|/* Check for the case where we have fiber media and auto-neg failed      * so we had to force link.  In this case, we need to force the      * configuration of the MAC to match the "fc" parameter.      */
if|if
condition|(
operator|(
operator|(
name|hw
operator|->
name|media_type
operator|==
name|em_media_type_fiber
operator|)
operator|&&
operator|(
name|hw
operator|->
name|autoneg_failed
operator|)
operator|)
operator|||
operator|(
operator|(
name|hw
operator|->
name|media_type
operator|==
name|em_media_type_internal_serdes
operator|)
operator|&&
operator|(
name|hw
operator|->
name|autoneg_failed
operator|)
operator|)
operator|||
operator|(
operator|(
name|hw
operator|->
name|media_type
operator|==
name|em_media_type_copper
operator|)
operator|&&
operator|(
operator|!
name|hw
operator|->
name|autoneg
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_force_mac_fc
argument_list|(
name|hw
argument_list|)
operator|)
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Error forcing flow control settings\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
block|}
comment|/* Check for the case where we have copper media and auto-neg is      * enabled.  In this case, we need to check and see if Auto-Neg      * has completed, and if so, how the PHY and link partner has      * flow control configured.      */
if|if
condition|(
operator|(
name|hw
operator|->
name|media_type
operator|==
name|em_media_type_copper
operator|)
operator|&&
name|hw
operator|->
name|autoneg
condition|)
block|{
comment|/* Read the MII Status Register and check to see if AutoNeg          * has completed.  We read this twice because this reg has          * some "sticky" (latched) bits.          */
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_STATUS
argument_list|,
operator|&
name|mii_status_reg
argument_list|)
operator|)
condition|)
return|return
name|ret_val
return|;
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_STATUS
argument_list|,
operator|&
name|mii_status_reg
argument_list|)
operator|)
condition|)
return|return
name|ret_val
return|;
if|if
condition|(
name|mii_status_reg
operator|&
name|MII_SR_AUTONEG_COMPLETE
condition|)
block|{
comment|/* The AutoNeg process has completed, so we now need to              * read both the Auto Negotiation Advertisement Register              * (Address 4) and the Auto_Negotiation Base Page Ability              * Register (Address 5) to determine how flow control was              * negotiated.              */
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_AUTONEG_ADV
argument_list|,
operator|&
name|mii_nway_adv_reg
argument_list|)
operator|)
condition|)
return|return
name|ret_val
return|;
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_LP_ABILITY
argument_list|,
operator|&
name|mii_nway_lp_ability_reg
argument_list|)
operator|)
condition|)
return|return
name|ret_val
return|;
comment|/* Two bits in the Auto Negotiation Advertisement Register              * (Address 4) and two bits in the Auto Negotiation Base              * Page Ability Register (Address 5) determine flow control              * for both the PHY and the link partner.  The following              * table, taken out of the IEEE 802.3ab/D6.0 dated March 25,              * 1999, describes these PAUSE resolution bits and how flow              * control is determined based upon these settings.              * NOTE:  DC = Don't Care              *              *   LOCAL DEVICE  |   LINK PARTNER              * PAUSE | ASM_DIR | PAUSE | ASM_DIR | NIC Resolution              *-------|---------|-------|---------|--------------------              *   0   |    0    |  DC   |   DC    | em_fc_none              *   0   |    1    |   0   |   DC    | em_fc_none              *   0   |    1    |   1   |    0    | em_fc_none              *   0   |    1    |   1   |    1    | em_fc_tx_pause              *   1   |    0    |   0   |   DC    | em_fc_none              *   1   |   DC    |   1   |   DC    | em_fc_full              *   1   |    1    |   0   |    0    | em_fc_none              *   1   |    1    |   0   |    1    | em_fc_rx_pause              *              */
comment|/* Are both PAUSE bits set to 1?  If so, this implies              * Symmetric Flow Control is enabled at both ends.  The              * ASM_DIR bits are irrelevant per the spec.              *              * For Symmetric Flow Control:              *              *   LOCAL DEVICE  |   LINK PARTNER              * PAUSE | ASM_DIR | PAUSE | ASM_DIR | Result              *-------|---------|-------|---------|--------------------              *   1   |   DC    |   1   |   DC    | em_fc_full              *              */
if|if
condition|(
operator|(
name|mii_nway_adv_reg
operator|&
name|NWAY_AR_PAUSE
operator|)
operator|&&
operator|(
name|mii_nway_lp_ability_reg
operator|&
name|NWAY_LPAR_PAUSE
operator|)
condition|)
block|{
comment|/* Now we need to check if the user selected RX ONLY                  * of pause frames.  In this case, we had to advertise                  * FULL flow control because we could not advertise RX                  * ONLY. Hence, we must now check to see if we need to                  * turn OFF  the TRANSMISSION of PAUSE frames.                  */
if|if
condition|(
name|hw
operator|->
name|original_fc
operator|==
name|em_fc_full
condition|)
block|{
name|hw
operator|->
name|fc
operator|=
name|em_fc_full
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Flow Control = FULL.\r\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|hw
operator|->
name|fc
operator|=
name|em_fc_rx_pause
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Flow Control = RX PAUSE frames only.\r\n"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* For receiving PAUSE frames ONLY.              *              *   LOCAL DEVICE  |   LINK PARTNER              * PAUSE | ASM_DIR | PAUSE | ASM_DIR | Result              *-------|---------|-------|---------|--------------------              *   0   |    1    |   1   |    1    | em_fc_tx_pause              *              */
elseif|else
if|if
condition|(
operator|!
operator|(
name|mii_nway_adv_reg
operator|&
name|NWAY_AR_PAUSE
operator|)
operator|&&
operator|(
name|mii_nway_adv_reg
operator|&
name|NWAY_AR_ASM_DIR
operator|)
operator|&&
operator|(
name|mii_nway_lp_ability_reg
operator|&
name|NWAY_LPAR_PAUSE
operator|)
operator|&&
operator|(
name|mii_nway_lp_ability_reg
operator|&
name|NWAY_LPAR_ASM_DIR
operator|)
condition|)
block|{
name|hw
operator|->
name|fc
operator|=
name|em_fc_tx_pause
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Flow Control = TX PAUSE frames only.\r\n"
argument_list|)
expr_stmt|;
block|}
comment|/* For transmitting PAUSE frames ONLY.              *              *   LOCAL DEVICE  |   LINK PARTNER              * PAUSE | ASM_DIR | PAUSE | ASM_DIR | Result              *-------|---------|-------|---------|--------------------              *   1   |    1    |   0   |    1    | em_fc_rx_pause              *              */
elseif|else
if|if
condition|(
operator|(
name|mii_nway_adv_reg
operator|&
name|NWAY_AR_PAUSE
operator|)
operator|&&
operator|(
name|mii_nway_adv_reg
operator|&
name|NWAY_AR_ASM_DIR
operator|)
operator|&&
operator|!
operator|(
name|mii_nway_lp_ability_reg
operator|&
name|NWAY_LPAR_PAUSE
operator|)
operator|&&
operator|(
name|mii_nway_lp_ability_reg
operator|&
name|NWAY_LPAR_ASM_DIR
operator|)
condition|)
block|{
name|hw
operator|->
name|fc
operator|=
name|em_fc_rx_pause
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Flow Control = RX PAUSE frames only.\r\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Per the IEEE spec, at this point flow control should be              * disabled.  However, we want to consider that we could              * be connected to a legacy switch that doesn't advertise              * desired flow control, but can be forced on the link              * partner.  So if we advertised no flow control, that is              * what we will resolve to.  If we advertised some kind of              * receive capability (Rx Pause Only or Full Flow Control)              * and the link partner advertised none, we will configure              * ourselves to enable Rx Flow Control only.  We can do              * this safely for two reasons:  If the link partner really              * didn't want flow control enabled, and we enable Rx, no              * harm done since we won't be receiving any PAUSE frames              * anyway.  If the intent on the link partner was to have              * flow control enabled, then by us enabling RX only, we              * can at least receive pause frames and process them.              * This is a good idea because in most cases, since we are              * predominantly a server NIC, more times than not we will              * be asked to delay transmission of packets than asking              * our link partner to pause transmission of frames.              */
elseif|else
if|if
condition|(
name|hw
operator|->
name|original_fc
operator|==
name|em_fc_none
operator|||
name|hw
operator|->
name|original_fc
operator|==
name|em_fc_tx_pause
condition|)
block|{
name|hw
operator|->
name|fc
operator|=
name|em_fc_none
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Flow Control = NONE.\r\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|hw
operator|->
name|fc_strict_ieee
condition|)
block|{
name|hw
operator|->
name|fc
operator|=
name|em_fc_rx_pause
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Flow Control = RX PAUSE frames only.\r\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Now we need to do one last check...  If we auto-              * negotiated to HALF DUPLEX, flow control should not be              * enabled per IEEE 802.3 spec.              */
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_get_speed_and_duplex
argument_list|(
name|hw
argument_list|,
operator|&
name|speed
argument_list|,
operator|&
name|duplex
argument_list|)
operator|)
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Error getting link speed and duplex\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
if|if
condition|(
name|duplex
operator|==
name|HALF_DUPLEX
condition|)
name|hw
operator|->
name|fc
operator|=
name|em_fc_none
expr_stmt|;
comment|/* Now we call a subroutine to actually force the MAC              * controller to use the correct flow control settings.              */
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_force_mac_fc
argument_list|(
name|hw
argument_list|)
operator|)
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Error forcing flow control settings\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
block|}
else|else
block|{
name|DEBUGOUT
argument_list|(
literal|"Copper PHY and Auto Neg has not completed.\r\n"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Checks to see if the link status of the hardware has changed.  *  * hw - Struct containing variables accessed by shared code  *  * Called by any function that needs to check the link status of the adapter.  *****************************************************************************/
end_comment

begin_function
name|int32_t
name|em_check_for_link
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|uint32_t
name|rxcw
decl_stmt|;
name|uint32_t
name|ctrl
decl_stmt|;
name|uint32_t
name|status
decl_stmt|;
name|uint32_t
name|rctl
decl_stmt|;
name|uint32_t
name|signal
init|=
literal|0
decl_stmt|;
name|int32_t
name|ret_val
decl_stmt|;
name|uint16_t
name|phy_data
decl_stmt|;
name|uint16_t
name|lp_capability
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_check_for_link"
argument_list|)
expr_stmt|;
comment|/* On adapters with a MAC newer than 82544, SW Defineable pin 1 will be      * set when the optics detect a signal. On older adapters, it will be      * cleared when there is a signal.  This applies to fiber media only.      */
if|if
condition|(
name|hw
operator|->
name|media_type
operator|==
name|em_media_type_fiber
condition|)
name|signal
operator|=
operator|(
name|hw
operator|->
name|mac_type
operator|>
name|em_82544
operator|)
condition|?
name|E1000_CTRL_SWDPIN1
else|:
literal|0
expr_stmt|;
name|ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|)
expr_stmt|;
name|status
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|STATUS
argument_list|)
expr_stmt|;
name|rxcw
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|RXCW
argument_list|)
expr_stmt|;
comment|/* If we have a copper PHY then we only want to go out to the PHY      * registers to see if Auto-Neg has completed and/or if our link      * status has changed.  The get_link_status flag will be set if we      * receive a Link Status Change interrupt or we have Rx Sequence      * Errors.      */
if|if
condition|(
operator|(
name|hw
operator|->
name|media_type
operator|==
name|em_media_type_copper
operator|)
operator|&&
name|hw
operator|->
name|get_link_status
condition|)
block|{
comment|/* First we want to see if the MII Status Register reports          * link.  If so, then we want to get the current speed/duplex          * of the PHY.          * Read the register twice since the link bit is sticky.          */
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_STATUS
argument_list|,
operator|&
name|phy_data
argument_list|)
operator|)
condition|)
return|return
name|ret_val
return|;
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_STATUS
argument_list|,
operator|&
name|phy_data
argument_list|)
operator|)
condition|)
return|return
name|ret_val
return|;
if|if
condition|(
name|phy_data
operator|&
name|MII_SR_LINK_STATUS
condition|)
block|{
name|hw
operator|->
name|get_link_status
operator|=
name|FALSE
expr_stmt|;
comment|/* Check if there was DownShift, must be checked immediately after              * link-up */
name|em_check_downshift
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* No link detected */
name|em_config_dsp_after_link_change
argument_list|(
name|hw
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* If we are forcing speed/duplex, then we simply return since          * we have already determined whether we have link or not.          */
if|if
condition|(
operator|!
name|hw
operator|->
name|autoneg
condition|)
return|return
operator|-
name|E1000_ERR_CONFIG
return|;
comment|/* optimize the dsp settings for the igp phy */
name|em_config_dsp_after_link_change
argument_list|(
name|hw
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* We have a M88E1000 PHY and Auto-Neg is enabled.  If we          * have Si on board that is 82544 or newer, Auto          * Speed Detection takes care of MAC speed/duplex          * configuration.  So we only need to configure Collision          * Distance in the MAC.  Otherwise, we need to force          * speed/duplex on the MAC to the current PHY speed/duplex          * settings.          */
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|>=
name|em_82544
condition|)
name|em_config_collision_dist
argument_list|(
name|hw
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_config_mac_to_phy
argument_list|(
name|hw
argument_list|)
operator|)
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Error configuring MAC to PHY settings\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
block|}
comment|/* Configure Flow Control now that Auto-Neg has completed. First, we          * need to restore the desired flow control settings because we may          * have had to re-autoneg with a different link partner.          */
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_config_fc_after_link_up
argument_list|(
name|hw
argument_list|)
operator|)
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Error configuring flow control\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
comment|/* At this point we know that we are on copper and we have          * auto-negotiated link.  These are conditions for checking the link          * parter capability register.  We use the link partner capability to          * determine if TBI Compatibility needs to be turned on or off.  If          * the link partner advertises any speed in addition to Gigabit, then          * we assume that they are GMII-based, and TBI compatibility is not          * needed. If no other speeds are advertised, we assume the link          * partner is TBI-based, and we turn on TBI Compatibility.          */
if|if
condition|(
name|hw
operator|->
name|tbi_compatibility_en
condition|)
block|{
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_LP_ABILITY
argument_list|,
operator|&
name|lp_capability
argument_list|)
operator|)
condition|)
return|return
name|ret_val
return|;
if|if
condition|(
name|lp_capability
operator|&
operator|(
name|NWAY_LPAR_10T_HD_CAPS
operator||
name|NWAY_LPAR_10T_FD_CAPS
operator||
name|NWAY_LPAR_100TX_HD_CAPS
operator||
name|NWAY_LPAR_100TX_FD_CAPS
operator||
name|NWAY_LPAR_100T4_CAPS
operator|)
condition|)
block|{
comment|/* If our link partner advertises anything in addition to                  * gigabit, we do not need to enable TBI compatibility.                  */
if|if
condition|(
name|hw
operator|->
name|tbi_compatibility_on
condition|)
block|{
comment|/* If we previously were in the mode, turn it off. */
name|rctl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|RCTL
argument_list|)
expr_stmt|;
name|rctl
operator|&=
operator|~
name|E1000_RCTL_SBP
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|RCTL
argument_list|,
name|rctl
argument_list|)
expr_stmt|;
name|hw
operator|->
name|tbi_compatibility_on
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* If TBI compatibility is was previously off, turn it on. For                  * compatibility with a TBI link partner, we will store bad                  * packets. Some frames have an additional byte on the end and                  * will look like CRC errors to to the hardware.                  */
if|if
condition|(
operator|!
name|hw
operator|->
name|tbi_compatibility_on
condition|)
block|{
name|hw
operator|->
name|tbi_compatibility_on
operator|=
name|TRUE
expr_stmt|;
name|rctl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|RCTL
argument_list|)
expr_stmt|;
name|rctl
operator||=
name|E1000_RCTL_SBP
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|RCTL
argument_list|,
name|rctl
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* If we don't have link (auto-negotiation failed or link partner cannot      * auto-negotiate), the cable is plugged in (we have signal), and our      * link partner is not trying to auto-negotiate with us (we are receiving      * idles or data), we need to force link up. We also need to give      * auto-negotiation time to complete, in case the cable was just plugged      * in. The autoneg_failed flag does this.      */
elseif|else
if|if
condition|(
operator|(
name|hw
operator|->
name|media_type
operator|==
name|em_media_type_fiber
operator|)
operator|&&
operator|(
operator|!
operator|(
name|status
operator|&
name|E1000_STATUS_LU
operator|)
operator|)
operator|&&
operator|(
operator|(
name|ctrl
operator|&
name|E1000_CTRL_SWDPIN1
operator|)
operator|==
name|signal
operator|)
operator|&&
operator|(
operator|!
operator|(
name|rxcw
operator|&
name|E1000_RXCW_C
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|hw
operator|->
name|autoneg_failed
operator|==
literal|0
condition|)
block|{
name|hw
operator|->
name|autoneg_failed
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
name|DEBUGOUT
argument_list|(
literal|"NOT RXing /C/, disable AutoNeg and force link.\r\n"
argument_list|)
expr_stmt|;
comment|/* Disable auto-negotiation in the TXCW register */
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|TXCW
argument_list|,
operator|(
name|hw
operator|->
name|txcw
operator|&
operator|~
name|E1000_TXCW_ANE
operator|)
argument_list|)
expr_stmt|;
comment|/* Force link-up and also force full-duplex. */
name|ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|)
expr_stmt|;
name|ctrl
operator||=
operator|(
name|E1000_CTRL_SLU
operator||
name|E1000_CTRL_FD
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
comment|/* Configure Flow Control after forcing link up. */
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_config_fc_after_link_up
argument_list|(
name|hw
argument_list|)
operator|)
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Error configuring flow control\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
block|}
comment|/* If we are forcing link and we are receiving /C/ ordered sets, re-enable      * auto-negotiation in the TXCW register and disable forced link in the      * Device Control register in an attempt to auto-negotiate with our link      * partner.      */
elseif|else
if|if
condition|(
operator|(
name|hw
operator|->
name|media_type
operator|==
name|em_media_type_fiber
operator|)
operator|&&
operator|(
name|ctrl
operator|&
name|E1000_CTRL_SLU
operator|)
operator|&&
operator|(
name|rxcw
operator|&
name|E1000_RXCW_C
operator|)
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"RXing /C/, enable AutoNeg and stop forcing link.\r\n"
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|TXCW
argument_list|,
name|hw
operator|->
name|txcw
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|,
operator|(
name|ctrl
operator|&
operator|~
name|E1000_CTRL_SLU
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Detects the current speed and duplex settings of the hardware.  *  * hw - Struct containing variables accessed by shared code  * speed - Speed of the connection  * duplex - Duplex setting of the connection  *****************************************************************************/
end_comment

begin_function
name|int32_t
name|em_get_speed_and_duplex
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint16_t
modifier|*
name|speed
parameter_list|,
name|uint16_t
modifier|*
name|duplex
parameter_list|)
block|{
name|uint32_t
name|status
decl_stmt|;
name|int32_t
name|ret_val
decl_stmt|;
name|uint16_t
name|phy_data
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_get_speed_and_duplex"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|>=
name|em_82543
condition|)
block|{
name|status
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|E1000_STATUS_SPEED_1000
condition|)
block|{
operator|*
name|speed
operator|=
name|SPEED_1000
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"1000 Mbs, "
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|status
operator|&
name|E1000_STATUS_SPEED_100
condition|)
block|{
operator|*
name|speed
operator|=
name|SPEED_100
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"100 Mbs, "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|speed
operator|=
name|SPEED_10
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"10 Mbs, "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|&
name|E1000_STATUS_FD
condition|)
block|{
operator|*
name|duplex
operator|=
name|FULL_DUPLEX
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Full Duplex\r\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|duplex
operator|=
name|HALF_DUPLEX
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|" Half Duplex\r\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|DEBUGOUT
argument_list|(
literal|"1000 Mbs, Full Duplex\r\n"
argument_list|)
expr_stmt|;
operator|*
name|speed
operator|=
name|SPEED_1000
expr_stmt|;
operator|*
name|duplex
operator|=
name|FULL_DUPLEX
expr_stmt|;
block|}
comment|/* IGP01 PHY may advertise full duplex operation after speed downgrade even      * if it is operating at half duplex.  Here we set the duplex settings to      * match the duplex in the link partner's capabilities.      */
if|if
condition|(
name|hw
operator|->
name|phy_type
operator|==
name|em_phy_igp
operator|&&
name|hw
operator|->
name|speed_downgraded
condition|)
block|{
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_AUTONEG_EXP
argument_list|,
operator|&
name|phy_data
argument_list|)
operator|)
condition|)
return|return
name|ret_val
return|;
if|if
condition|(
operator|!
operator|(
name|phy_data
operator|&
name|NWAY_ER_LP_NWAY_CAPS
operator|)
condition|)
operator|*
name|duplex
operator|=
name|HALF_DUPLEX
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|(
name|ret_val
operator|==
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_LP_ABILITY
argument_list|,
operator|&
name|phy_data
argument_list|)
operator|)
condition|)
return|return
name|ret_val
return|;
if|if
condition|(
operator|(
operator|*
name|speed
operator|==
name|SPEED_100
operator|&&
operator|!
operator|(
name|phy_data
operator|&
name|NWAY_LPAR_100TX_FD_CAPS
operator|)
operator|)
operator|||
operator|(
operator|*
name|speed
operator|==
name|SPEED_10
operator|&&
operator|!
operator|(
name|phy_data
operator|&
name|NWAY_LPAR_10T_FD_CAPS
operator|)
operator|)
condition|)
operator|*
name|duplex
operator|=
name|HALF_DUPLEX
expr_stmt|;
block|}
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************** * Blocks until autoneg completes or times out (~4.5 seconds) * * hw - Struct containing variables accessed by shared code ******************************************************************************/
end_comment

begin_function
name|int32_t
name|em_wait_autoneg
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|int32_t
name|ret_val
decl_stmt|;
name|uint16_t
name|i
decl_stmt|;
name|uint16_t
name|phy_data
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_wait_autoneg"
argument_list|)
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Waiting for Auto-Neg to complete.\n"
argument_list|)
expr_stmt|;
comment|/* We will wait for autoneg to complete or 4.5 seconds to expire. */
for|for
control|(
name|i
operator|=
name|PHY_AUTO_NEG_TIME
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
comment|/* Read the MII Status Register and wait for Auto-Neg          * Complete bit to be set.          */
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_STATUS
argument_list|,
operator|&
name|phy_data
argument_list|)
operator|)
condition|)
return|return
name|ret_val
return|;
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_STATUS
argument_list|,
operator|&
name|phy_data
argument_list|)
operator|)
condition|)
return|return
name|ret_val
return|;
if|if
condition|(
name|phy_data
operator|&
name|MII_SR_AUTONEG_COMPLETE
condition|)
block|{
return|return
name|E1000_SUCCESS
return|;
block|}
name|msec_delay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************** * Raises the Management Data Clock * * hw - Struct containing variables accessed by shared code * ctrl - Device control register's current value ******************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|em_raise_mdi_clk
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint32_t
modifier|*
name|ctrl
parameter_list|)
block|{
comment|/* Raise the clock input to the Management Data Clock (by setting the MDC      * bit), and then delay 10 microseconds.      */
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|,
operator|(
operator|*
name|ctrl
operator||
name|E1000_CTRL_MDC
operator|)
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************** * Lowers the Management Data Clock * * hw - Struct containing variables accessed by shared code * ctrl - Device control register's current value ******************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|em_lower_mdi_clk
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint32_t
modifier|*
name|ctrl
parameter_list|)
block|{
comment|/* Lower the clock input to the Management Data Clock (by clearing the MDC      * bit), and then delay 10 microseconds.      */
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|,
operator|(
operator|*
name|ctrl
operator|&
operator|~
name|E1000_CTRL_MDC
operator|)
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************** * Shifts data bits out to the PHY * * hw - Struct containing variables accessed by shared code * data - Data to send out to the PHY * count - Number of bits to shift out * * Bits are shifted out in MSB to LSB order. ******************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|em_shift_out_mdi_bits
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint32_t
name|data
parameter_list|,
name|uint16_t
name|count
parameter_list|)
block|{
name|uint32_t
name|ctrl
decl_stmt|;
name|uint32_t
name|mask
decl_stmt|;
comment|/* We need to shift "count" number of bits out to the PHY. So, the value      * in the "data" parameter will be shifted out to the PHY one bit at a      * time. In order to do this, "data" must be broken down into bits.      */
name|mask
operator|=
literal|0x01
expr_stmt|;
name|mask
operator|<<=
operator|(
name|count
operator|-
literal|1
operator|)
expr_stmt|;
name|ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|)
expr_stmt|;
comment|/* Set MDIO_DIR and MDC_DIR direction bits to be used as output pins. */
name|ctrl
operator||=
operator|(
name|E1000_CTRL_MDIO_DIR
operator||
name|E1000_CTRL_MDC_DIR
operator|)
expr_stmt|;
while|while
condition|(
name|mask
condition|)
block|{
comment|/* A "1" is shifted out to the PHY by setting the MDIO bit to "1" and          * then raising and lowering the Management Data Clock. A "0" is          * shifted out to the PHY by setting the MDIO bit to "0" and then          * raising and lowering the clock.          */
if|if
condition|(
name|data
operator|&
name|mask
condition|)
name|ctrl
operator||=
name|E1000_CTRL_MDIO
expr_stmt|;
else|else
name|ctrl
operator|&=
operator|~
name|E1000_CTRL_MDIO
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|em_raise_mdi_clk
argument_list|(
name|hw
argument_list|,
operator|&
name|ctrl
argument_list|)
expr_stmt|;
name|em_lower_mdi_clk
argument_list|(
name|hw
argument_list|,
operator|&
name|ctrl
argument_list|)
expr_stmt|;
name|mask
operator|=
name|mask
operator|>>
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/****************************************************************************** * Shifts data bits in from the PHY * * hw - Struct containing variables accessed by shared code * * Bits are shifted in in MSB to LSB order. ******************************************************************************/
end_comment

begin_function
specifier|static
name|uint16_t
name|em_shift_in_mdi_bits
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|uint32_t
name|ctrl
decl_stmt|;
name|uint16_t
name|data
init|=
literal|0
decl_stmt|;
name|uint8_t
name|i
decl_stmt|;
comment|/* In order to read a register from the PHY, we need to shift in a total      * of 18 bits from the PHY. The first two bit (turnaround) times are used      * to avoid contention on the MDIO pin when a read operation is performed.      * These two bits are ignored by us and thrown away. Bits are "shifted in"      * by raising the input to the Management Data Clock (setting the MDC bit),      * and then reading the value of the MDIO bit.      */
name|ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|)
expr_stmt|;
comment|/* Clear MDIO_DIR (SWDPIO1) to indicate this bit is to be used as input. */
name|ctrl
operator|&=
operator|~
name|E1000_CTRL_MDIO_DIR
expr_stmt|;
name|ctrl
operator|&=
operator|~
name|E1000_CTRL_MDIO
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Raise and Lower the clock before reading in the data. This accounts for      * the turnaround bits. The first clock occurred when we clocked out the      * last bit of the Register Address.      */
name|em_raise_mdi_clk
argument_list|(
name|hw
argument_list|,
operator|&
name|ctrl
argument_list|)
expr_stmt|;
name|em_lower_mdi_clk
argument_list|(
name|hw
argument_list|,
operator|&
name|ctrl
argument_list|)
expr_stmt|;
for|for
control|(
name|data
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|data
operator|=
name|data
operator|<<
literal|1
expr_stmt|;
name|em_raise_mdi_clk
argument_list|(
name|hw
argument_list|,
operator|&
name|ctrl
argument_list|)
expr_stmt|;
name|ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|)
expr_stmt|;
comment|/* Check to see if we shifted in a "1". */
if|if
condition|(
name|ctrl
operator|&
name|E1000_CTRL_MDIO
condition|)
name|data
operator||=
literal|1
expr_stmt|;
name|em_lower_mdi_clk
argument_list|(
name|hw
argument_list|,
operator|&
name|ctrl
argument_list|)
expr_stmt|;
block|}
name|em_raise_mdi_clk
argument_list|(
name|hw
argument_list|,
operator|&
name|ctrl
argument_list|)
expr_stmt|;
name|em_lower_mdi_clk
argument_list|(
name|hw
argument_list|,
operator|&
name|ctrl
argument_list|)
expr_stmt|;
return|return
name|data
return|;
block|}
end_function

begin_comment
comment|/***************************************************************************** * Reads the value from a PHY register, if the value is on a specific non zero * page, sets the page first. * hw - Struct containing variables accessed by shared code * reg_addr - address of the PHY register to read ******************************************************************************/
end_comment

begin_function
name|int32_t
name|em_read_phy_reg
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint32_t
name|reg_addr
parameter_list|,
name|uint16_t
modifier|*
name|phy_data
parameter_list|)
block|{
name|uint32_t
name|ret_val
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_read_phy_reg"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|phy_type
operator|==
name|em_phy_igp
operator|&&
operator|(
name|reg_addr
operator|>
name|MAX_PHY_MULTI_PAGE_REG
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_write_phy_reg_ex
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PAGE_SELECT
argument_list|,
operator|(
name|uint16_t
operator|)
name|reg_addr
argument_list|)
operator|)
condition|)
return|return
name|ret_val
return|;
block|}
name|ret_val
operator|=
name|em_read_phy_reg_ex
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PAGE_SELECT
operator|&
name|reg_addr
argument_list|,
name|phy_data
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_function
name|int32_t
name|em_read_phy_reg_ex
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint32_t
name|reg_addr
parameter_list|,
name|uint16_t
modifier|*
name|phy_data
parameter_list|)
block|{
name|uint32_t
name|i
decl_stmt|;
name|uint32_t
name|mdic
init|=
literal|0
decl_stmt|;
specifier|const
name|uint32_t
name|phy_addr
init|=
literal|1
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_read_phy_reg_ex"
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_addr
operator|>
name|MAX_PHY_REG_ADDRESS
condition|)
block|{
name|DEBUGOUT1
argument_list|(
literal|"PHY Address %d is out of range\n"
argument_list|,
name|reg_addr
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_PARAM
return|;
block|}
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|>
name|em_82543
condition|)
block|{
comment|/* Set up Op-code, Phy Address, and register address in the MDI          * Control register.  The MAC will take care of interfacing with the          * PHY to retrieve the desired data.          */
name|mdic
operator|=
operator|(
operator|(
name|reg_addr
operator|<<
name|E1000_MDIC_REG_SHIFT
operator|)
operator||
operator|(
name|phy_addr
operator|<<
name|E1000_MDIC_PHY_SHIFT
operator|)
operator||
operator|(
name|E1000_MDIC_OP_READ
operator|)
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|MDIC
argument_list|,
name|mdic
argument_list|)
expr_stmt|;
comment|/* Poll the ready bit to see if the MDI read completed */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|64
condition|;
name|i
operator|++
control|)
block|{
name|usec_delay
argument_list|(
literal|50
argument_list|)
expr_stmt|;
name|mdic
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|MDIC
argument_list|)
expr_stmt|;
if|if
condition|(
name|mdic
operator|&
name|E1000_MDIC_READY
condition|)
break|break;
block|}
if|if
condition|(
operator|!
operator|(
name|mdic
operator|&
name|E1000_MDIC_READY
operator|)
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"MDI Read did not complete\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_PHY
return|;
block|}
if|if
condition|(
name|mdic
operator|&
name|E1000_MDIC_ERROR
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"MDI Error\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_PHY
return|;
block|}
operator|*
name|phy_data
operator|=
operator|(
name|uint16_t
operator|)
name|mdic
expr_stmt|;
block|}
else|else
block|{
comment|/* We must first send a preamble through the MDIO pin to signal the          * beginning of an MII instruction.  This is done by sending 32          * consecutive "1" bits.          */
name|em_shift_out_mdi_bits
argument_list|(
name|hw
argument_list|,
name|PHY_PREAMBLE
argument_list|,
name|PHY_PREAMBLE_SIZE
argument_list|)
expr_stmt|;
comment|/* Now combine the next few fields that are required for a read          * operation.  We use this method instead of calling the          * em_shift_out_mdi_bits routine five different times. The format of          * a MII read instruction consists of a shift out of 14 bits and is          * defined as follows:          *<Preamble><SOF><Op Code><Phy Addr><Reg Addr>          * followed by a shift in of 18 bits.  This first two bits shifted in          * are TurnAround bits used to avoid contention on the MDIO pin when a          * READ operation is performed.  These two bits are thrown away          * followed by a shift in of 16 bits which contains the desired data.          */
name|mdic
operator|=
operator|(
operator|(
name|reg_addr
operator|)
operator||
operator|(
name|phy_addr
operator|<<
literal|5
operator|)
operator||
operator|(
name|PHY_OP_READ
operator|<<
literal|10
operator|)
operator||
operator|(
name|PHY_SOF
operator|<<
literal|12
operator|)
operator|)
expr_stmt|;
name|em_shift_out_mdi_bits
argument_list|(
name|hw
argument_list|,
name|mdic
argument_list|,
literal|14
argument_list|)
expr_stmt|;
comment|/* Now that we've shifted out the read command to the MII, we need to          * "shift in" the 16-bit value (18 total bits) of the requested PHY          * register address.          */
operator|*
name|phy_data
operator|=
name|em_shift_in_mdi_bits
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************** * Writes a value to a PHY register * * hw - Struct containing variables accessed by shared code * reg_addr - address of the PHY register to write * data - data to write to the PHY ******************************************************************************/
end_comment

begin_function
name|int32_t
name|em_write_phy_reg
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint32_t
name|reg_addr
parameter_list|,
name|uint16_t
name|phy_data
parameter_list|)
block|{
name|uint32_t
name|ret_val
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_write_phy_reg"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|phy_type
operator|==
name|em_phy_igp
operator|&&
operator|(
name|reg_addr
operator|>
name|MAX_PHY_MULTI_PAGE_REG
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_write_phy_reg_ex
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PAGE_SELECT
argument_list|,
operator|(
name|uint16_t
operator|)
name|reg_addr
argument_list|)
operator|)
condition|)
return|return
name|ret_val
return|;
block|}
name|ret_val
operator|=
name|em_write_phy_reg_ex
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PAGE_SELECT
operator|&
name|reg_addr
argument_list|,
name|phy_data
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_function
name|int32_t
name|em_write_phy_reg_ex
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint32_t
name|reg_addr
parameter_list|,
name|uint16_t
name|phy_data
parameter_list|)
block|{
name|uint32_t
name|i
decl_stmt|;
name|uint32_t
name|mdic
init|=
literal|0
decl_stmt|;
specifier|const
name|uint32_t
name|phy_addr
init|=
literal|1
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_write_phy_reg_ex"
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_addr
operator|>
name|MAX_PHY_REG_ADDRESS
condition|)
block|{
name|DEBUGOUT1
argument_list|(
literal|"PHY Address %d is out of range\n"
argument_list|,
name|reg_addr
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_PARAM
return|;
block|}
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|>
name|em_82543
condition|)
block|{
comment|/* Set up Op-code, Phy Address, register address, and data intended          * for the PHY register in the MDI Control register.  The MAC will take          * care of interfacing with the PHY to send the desired data.          */
name|mdic
operator|=
operator|(
operator|(
operator|(
name|uint32_t
operator|)
name|phy_data
operator|)
operator||
operator|(
name|reg_addr
operator|<<
name|E1000_MDIC_REG_SHIFT
operator|)
operator||
operator|(
name|phy_addr
operator|<<
name|E1000_MDIC_PHY_SHIFT
operator|)
operator||
operator|(
name|E1000_MDIC_OP_WRITE
operator|)
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|MDIC
argument_list|,
name|mdic
argument_list|)
expr_stmt|;
comment|/* Poll the ready bit to see if the MDI read completed */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|64
condition|;
name|i
operator|++
control|)
block|{
name|usec_delay
argument_list|(
literal|50
argument_list|)
expr_stmt|;
name|mdic
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|MDIC
argument_list|)
expr_stmt|;
if|if
condition|(
name|mdic
operator|&
name|E1000_MDIC_READY
condition|)
break|break;
block|}
if|if
condition|(
operator|!
operator|(
name|mdic
operator|&
name|E1000_MDIC_READY
operator|)
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"MDI Write did not complete\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_PHY
return|;
block|}
block|}
else|else
block|{
comment|/* We'll need to use the SW defined pins to shift the write command          * out to the PHY. We first send a preamble to the PHY to signal the          * beginning of the MII instruction.  This is done by sending 32          * consecutive "1" bits.          */
name|em_shift_out_mdi_bits
argument_list|(
name|hw
argument_list|,
name|PHY_PREAMBLE
argument_list|,
name|PHY_PREAMBLE_SIZE
argument_list|)
expr_stmt|;
comment|/* Now combine the remaining required fields that will indicate a          * write operation. We use this method instead of calling the          * em_shift_out_mdi_bits routine for each field in the command. The          * format of a MII write instruction is as follows:          *<Preamble><SOF><Op Code><Phy Addr><Reg Addr><Turnaround><Data>.          */
name|mdic
operator|=
operator|(
operator|(
name|PHY_TURNAROUND
operator|)
operator||
operator|(
name|reg_addr
operator|<<
literal|2
operator|)
operator||
operator|(
name|phy_addr
operator|<<
literal|7
operator|)
operator||
operator|(
name|PHY_OP_WRITE
operator|<<
literal|12
operator|)
operator||
operator|(
name|PHY_SOF
operator|<<
literal|14
operator|)
operator|)
expr_stmt|;
name|mdic
operator|<<=
literal|16
expr_stmt|;
name|mdic
operator||=
operator|(
name|uint32_t
operator|)
name|phy_data
expr_stmt|;
name|em_shift_out_mdi_bits
argument_list|(
name|hw
argument_list|,
name|mdic
argument_list|,
literal|32
argument_list|)
expr_stmt|;
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************** * Returns the PHY to the power-on reset state * * hw - Struct containing variables accessed by shared code ******************************************************************************/
end_comment

begin_function
name|void
name|em_phy_hw_reset
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|uint32_t
name|ctrl
decl_stmt|,
name|ctrl_ext
decl_stmt|;
name|uint32_t
name|led_ctrl
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_phy_hw_reset"
argument_list|)
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Resetting Phy...\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|>
name|em_82543
condition|)
block|{
comment|/* Read the device control register and assert the E1000_CTRL_PHY_RST          * bit. Then, take it out of reset.          */
name|ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|,
name|ctrl
operator||
name|E1000_CTRL_PHY_RST
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|msec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Read the Extended Device Control Register, assert the PHY_RESET_DIR          * bit to put the PHY into reset. Then, take it out of reset.          */
name|ctrl_ext
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|CTRL_EXT
argument_list|)
expr_stmt|;
name|ctrl_ext
operator||=
name|E1000_CTRL_EXT_SDP4_DIR
expr_stmt|;
name|ctrl_ext
operator|&=
operator|~
name|E1000_CTRL_EXT_SDP4_DATA
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|CTRL_EXT
argument_list|,
name|ctrl_ext
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|msec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|ctrl_ext
operator||=
name|E1000_CTRL_EXT_SDP4_DATA
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|CTRL_EXT
argument_list|,
name|ctrl_ext
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
name|usec_delay
argument_list|(
literal|150
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|hw
operator|->
name|mac_type
operator|==
name|em_82541
operator|)
operator|||
operator|(
name|hw
operator|->
name|mac_type
operator|==
name|em_82547
operator|)
condition|)
block|{
comment|/* Configure activity LED after PHY reset */
name|led_ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|LEDCTL
argument_list|)
expr_stmt|;
name|led_ctrl
operator|&=
name|IGP_ACTIVITY_LED_MASK
expr_stmt|;
name|led_ctrl
operator||=
operator|(
name|IGP_ACTIVITY_LED_ENABLE
operator||
name|IGP_LED3_MODE
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|LEDCTL
argument_list|,
name|led_ctrl
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/****************************************************************************** * Resets the PHY * * hw - Struct containing variables accessed by shared code * * Sets bit 15 of the MII Control regiser ******************************************************************************/
end_comment

begin_function
name|int32_t
name|em_phy_reset
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|int32_t
name|ret_val
decl_stmt|;
name|uint16_t
name|phy_data
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_phy_reset"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|!=
name|em_82541_rev_2
condition|)
block|{
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_CTRL
argument_list|,
operator|&
name|phy_data
argument_list|)
operator|)
condition|)
return|return
name|ret_val
return|;
name|phy_data
operator||=
name|MII_CR_RESET
expr_stmt|;
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_CTRL
argument_list|,
name|phy_data
argument_list|)
operator|)
condition|)
return|return
name|ret_val
return|;
name|usec_delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|em_phy_hw_reset
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|phy_type
operator|==
name|em_phy_igp
condition|)
name|em_phy_init_script
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************** * Probes the expected PHY address for known PHY IDs * * hw - Struct containing variables accessed by shared code ******************************************************************************/
end_comment

begin_function
name|int32_t
name|em_detect_gig_phy
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|int32_t
name|phy_init_status
decl_stmt|,
name|ret_val
decl_stmt|;
name|uint16_t
name|phy_id_high
decl_stmt|,
name|phy_id_low
decl_stmt|;
name|boolean_t
name|match
init|=
name|FALSE
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_detect_gig_phy"
argument_list|)
expr_stmt|;
comment|/* Read the PHY ID Registers to identify which PHY is onboard. */
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_ID1
argument_list|,
operator|&
name|phy_id_high
argument_list|)
operator|)
condition|)
return|return
name|ret_val
return|;
name|hw
operator|->
name|phy_id
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|phy_id_high
operator|<<
literal|16
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|20
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_ID2
argument_list|,
operator|&
name|phy_id_low
argument_list|)
operator|)
condition|)
return|return
name|ret_val
return|;
name|hw
operator|->
name|phy_id
operator||=
call|(
name|uint32_t
call|)
argument_list|(
name|phy_id_low
operator|&
name|PHY_REVISION_MASK
argument_list|)
expr_stmt|;
name|hw
operator|->
name|phy_revision
operator|=
operator|(
name|uint32_t
operator|)
name|phy_id_low
operator|&
operator|~
name|PHY_REVISION_MASK
expr_stmt|;
switch|switch
condition|(
name|hw
operator|->
name|mac_type
condition|)
block|{
case|case
name|em_82543
case|:
if|if
condition|(
name|hw
operator|->
name|phy_id
operator|==
name|M88E1000_E_PHY_ID
condition|)
name|match
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|em_82544
case|:
if|if
condition|(
name|hw
operator|->
name|phy_id
operator|==
name|M88E1000_I_PHY_ID
condition|)
name|match
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|em_82540
case|:
case|case
name|em_82545
case|:
case|case
name|em_82545_rev_3
case|:
case|case
name|em_82546
case|:
case|case
name|em_82546_rev_3
case|:
if|if
condition|(
name|hw
operator|->
name|phy_id
operator|==
name|M88E1011_I_PHY_ID
condition|)
name|match
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|em_82541
case|:
case|case
name|em_82541_rev_2
case|:
case|case
name|em_82547
case|:
case|case
name|em_82547_rev_2
case|:
if|if
condition|(
name|hw
operator|->
name|phy_id
operator|==
name|IGP01E1000_I_PHY_ID
condition|)
name|match
operator|=
name|TRUE
expr_stmt|;
break|break;
default|default:
name|DEBUGOUT1
argument_list|(
literal|"Invalid MAC type %d\n"
argument_list|,
name|hw
operator|->
name|mac_type
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_CONFIG
return|;
block|}
name|phy_init_status
operator|=
name|em_set_phy_type
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|match
operator|)
operator|&&
operator|(
name|phy_init_status
operator|==
name|E1000_SUCCESS
operator|)
condition|)
block|{
name|DEBUGOUT1
argument_list|(
literal|"PHY ID 0x%X detected\n"
argument_list|,
name|hw
operator|->
name|phy_id
argument_list|)
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
name|DEBUGOUT1
argument_list|(
literal|"Invalid PHY ID 0x%X\n"
argument_list|,
name|hw
operator|->
name|phy_id
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_PHY
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************** * Resets the PHY's DSP * * hw - Struct containing variables accessed by shared code ******************************************************************************/
end_comment

begin_function
specifier|static
name|int32_t
name|em_phy_reset_dsp
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|int32_t
name|ret_val
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_phy_reset_dsp"
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
literal|29
argument_list|,
literal|0x001d
argument_list|)
operator|)
condition|)
break|break;
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
literal|30
argument_list|,
literal|0x00c1
argument_list|)
operator|)
condition|)
break|break;
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
literal|30
argument_list|,
literal|0x0000
argument_list|)
operator|)
condition|)
break|break;
name|ret_val
operator|=
name|E1000_SUCCESS
expr_stmt|;
block|}
do|while
condition|(
literal|0
condition|)
do|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************** * Get PHY information from various PHY registers for igp PHY only. * * hw - Struct containing variables accessed by shared code * phy_info - PHY information structure ******************************************************************************/
end_comment

begin_function
name|int32_t
name|em_phy_igp_get_info
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|struct
name|em_phy_info
modifier|*
name|phy_info
parameter_list|)
block|{
name|int32_t
name|ret_val
decl_stmt|;
name|uint16_t
name|phy_data
decl_stmt|,
name|polarity
decl_stmt|,
name|min_length
decl_stmt|,
name|max_length
decl_stmt|,
name|average
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_phy_igp_get_info"
argument_list|)
expr_stmt|;
comment|/* The downshift status is checked only once, after link is established,      * and it stored in the hw->speed_downgraded parameter. */
name|phy_info
operator|->
name|downshift
operator|=
name|hw
operator|->
name|speed_downgraded
expr_stmt|;
comment|/* IGP01E1000 does not need to support it. */
name|phy_info
operator|->
name|extended_10bt_distance
operator|=
name|em_10bt_ext_dist_enable_normal
expr_stmt|;
comment|/* IGP01E1000 always correct polarity reversal */
name|phy_info
operator|->
name|polarity_correction
operator|=
name|em_polarity_reversal_enabled
expr_stmt|;
comment|/* Check polarity status */
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_check_polarity
argument_list|(
name|hw
argument_list|,
operator|&
name|polarity
argument_list|)
operator|)
condition|)
return|return
name|ret_val
return|;
name|phy_info
operator|->
name|cable_polarity
operator|=
name|polarity
expr_stmt|;
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_STATUS
argument_list|,
operator|&
name|phy_data
argument_list|)
operator|)
condition|)
return|return
name|ret_val
return|;
name|phy_info
operator|->
name|mdix_mode
operator|=
operator|(
name|phy_data
operator|&
name|IGP01E1000_PSSR_MDIX
operator|)
operator|>>
name|IGP01E1000_PSSR_MDIX_SHIFT
expr_stmt|;
if|if
condition|(
operator|(
name|phy_data
operator|&
name|IGP01E1000_PSSR_SPEED_MASK
operator|)
operator|==
name|IGP01E1000_PSSR_SPEED_1000MBPS
condition|)
block|{
comment|/* Local/Remote Receiver Information are only valid at 1000 Mbps */
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_1000T_STATUS
argument_list|,
operator|&
name|phy_data
argument_list|)
operator|)
condition|)
return|return
name|ret_val
return|;
name|phy_info
operator|->
name|local_rx
operator|=
operator|(
name|phy_data
operator|&
name|SR_1000T_LOCAL_RX_STATUS
operator|)
operator|>>
name|SR_1000T_LOCAL_RX_STATUS_SHIFT
expr_stmt|;
name|phy_info
operator|->
name|remote_rx
operator|=
operator|(
name|phy_data
operator|&
name|SR_1000T_REMOTE_RX_STATUS
operator|)
operator|>>
name|SR_1000T_REMOTE_RX_STATUS_SHIFT
expr_stmt|;
comment|/* Get cable length */
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_get_cable_length
argument_list|(
name|hw
argument_list|,
operator|&
name|min_length
argument_list|,
operator|&
name|max_length
argument_list|)
operator|)
condition|)
return|return
name|ret_val
return|;
comment|/* transalte to old method */
name|average
operator|=
operator|(
name|max_length
operator|+
name|min_length
operator|)
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|average
operator|<=
name|em_igp_cable_length_50
condition|)
name|phy_info
operator|->
name|cable_length
operator|=
name|em_cable_length_50
expr_stmt|;
elseif|else
if|if
condition|(
name|average
operator|<=
name|em_igp_cable_length_80
condition|)
name|phy_info
operator|->
name|cable_length
operator|=
name|em_cable_length_50_80
expr_stmt|;
elseif|else
if|if
condition|(
name|average
operator|<=
name|em_igp_cable_length_110
condition|)
name|phy_info
operator|->
name|cable_length
operator|=
name|em_cable_length_80_110
expr_stmt|;
elseif|else
if|if
condition|(
name|average
operator|<=
name|em_igp_cable_length_140
condition|)
name|phy_info
operator|->
name|cable_length
operator|=
name|em_cable_length_110_140
expr_stmt|;
else|else
name|phy_info
operator|->
name|cable_length
operator|=
name|em_cable_length_140
expr_stmt|;
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************** * Get PHY information from various PHY registers fot m88 PHY only. * * hw - Struct containing variables accessed by shared code * phy_info - PHY information structure ******************************************************************************/
end_comment

begin_function
name|int32_t
name|em_phy_m88_get_info
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|struct
name|em_phy_info
modifier|*
name|phy_info
parameter_list|)
block|{
name|int32_t
name|ret_val
decl_stmt|;
name|uint16_t
name|phy_data
decl_stmt|,
name|polarity
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_phy_m88_get_info"
argument_list|)
expr_stmt|;
comment|/* The downshift status is checked only once, after link is established,      * and it stored in the hw->speed_downgraded parameter. */
name|phy_info
operator|->
name|downshift
operator|=
name|hw
operator|->
name|speed_downgraded
expr_stmt|;
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_SPEC_CTRL
argument_list|,
operator|&
name|phy_data
argument_list|)
operator|)
condition|)
return|return
name|ret_val
return|;
name|phy_info
operator|->
name|extended_10bt_distance
operator|=
operator|(
name|phy_data
operator|&
name|M88E1000_PSCR_10BT_EXT_DIST_ENABLE
operator|)
operator|>>
name|M88E1000_PSCR_10BT_EXT_DIST_ENABLE_SHIFT
expr_stmt|;
name|phy_info
operator|->
name|polarity_correction
operator|=
operator|(
name|phy_data
operator|&
name|M88E1000_PSCR_POLARITY_REVERSAL
operator|)
operator|>>
name|M88E1000_PSCR_POLARITY_REVERSAL_SHIFT
expr_stmt|;
comment|/* Check polarity status */
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_check_polarity
argument_list|(
name|hw
argument_list|,
operator|&
name|polarity
argument_list|)
operator|)
condition|)
return|return
name|ret_val
return|;
name|phy_info
operator|->
name|cable_polarity
operator|=
name|polarity
expr_stmt|;
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_SPEC_STATUS
argument_list|,
operator|&
name|phy_data
argument_list|)
operator|)
condition|)
return|return
name|ret_val
return|;
name|phy_info
operator|->
name|mdix_mode
operator|=
operator|(
name|phy_data
operator|&
name|M88E1000_PSSR_MDIX
operator|)
operator|>>
name|M88E1000_PSSR_MDIX_SHIFT
expr_stmt|;
if|if
condition|(
name|phy_data
operator|&
name|M88E1000_PSSR_1000MBS
condition|)
block|{
comment|/* Cable Length Estimation and Local/Remote Receiver Informatoion          * are only valid at 1000 Mbps          */
name|phy_info
operator|->
name|cable_length
operator|=
operator|(
operator|(
name|phy_data
operator|&
name|M88E1000_PSSR_CABLE_LENGTH
operator|)
operator|>>
name|M88E1000_PSSR_CABLE_LENGTH_SHIFT
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_1000T_STATUS
argument_list|,
operator|&
name|phy_data
argument_list|)
operator|)
condition|)
return|return
name|ret_val
return|;
name|phy_info
operator|->
name|local_rx
operator|=
operator|(
name|phy_data
operator|&
name|SR_1000T_LOCAL_RX_STATUS
operator|)
operator|>>
name|SR_1000T_LOCAL_RX_STATUS_SHIFT
expr_stmt|;
name|phy_info
operator|->
name|remote_rx
operator|=
operator|(
name|phy_data
operator|&
name|SR_1000T_REMOTE_RX_STATUS
operator|)
operator|>>
name|SR_1000T_REMOTE_RX_STATUS_SHIFT
expr_stmt|;
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************** * Get PHY information from various PHY registers * * hw - Struct containing variables accessed by shared code * phy_info - PHY information structure ******************************************************************************/
end_comment

begin_function
name|int32_t
name|em_phy_get_info
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|struct
name|em_phy_info
modifier|*
name|phy_info
parameter_list|)
block|{
name|int32_t
name|ret_val
decl_stmt|;
name|uint16_t
name|phy_data
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_phy_get_info"
argument_list|)
expr_stmt|;
name|phy_info
operator|->
name|cable_length
operator|=
name|em_cable_length_undefined
expr_stmt|;
name|phy_info
operator|->
name|extended_10bt_distance
operator|=
name|em_10bt_ext_dist_enable_undefined
expr_stmt|;
name|phy_info
operator|->
name|cable_polarity
operator|=
name|em_rev_polarity_undefined
expr_stmt|;
name|phy_info
operator|->
name|downshift
operator|=
name|em_downshift_undefined
expr_stmt|;
name|phy_info
operator|->
name|polarity_correction
operator|=
name|em_polarity_reversal_undefined
expr_stmt|;
name|phy_info
operator|->
name|mdix_mode
operator|=
name|em_auto_x_mode_undefined
expr_stmt|;
name|phy_info
operator|->
name|local_rx
operator|=
name|em_1000t_rx_status_undefined
expr_stmt|;
name|phy_info
operator|->
name|remote_rx
operator|=
name|em_1000t_rx_status_undefined
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|media_type
operator|!=
name|em_media_type_copper
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"PHY info is only valid for copper media\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_CONFIG
return|;
block|}
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_STATUS
argument_list|,
operator|&
name|phy_data
argument_list|)
operator|)
condition|)
return|return
name|ret_val
return|;
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_STATUS
argument_list|,
operator|&
name|phy_data
argument_list|)
operator|)
condition|)
return|return
name|ret_val
return|;
if|if
condition|(
operator|(
name|phy_data
operator|&
name|MII_SR_LINK_STATUS
operator|)
operator|!=
name|MII_SR_LINK_STATUS
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"PHY info is only valid if link is up\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_CONFIG
return|;
block|}
if|if
condition|(
name|hw
operator|->
name|phy_type
operator|==
name|em_phy_igp
condition|)
return|return
name|em_phy_igp_get_info
argument_list|(
name|hw
argument_list|,
name|phy_info
argument_list|)
return|;
else|else
return|return
name|em_phy_m88_get_info
argument_list|(
name|hw
argument_list|,
name|phy_info
argument_list|)
return|;
block|}
end_function

begin_function
name|int32_t
name|em_validate_mdi_setting
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"em_validate_mdi_settings"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hw
operator|->
name|autoneg
operator|&&
operator|(
name|hw
operator|->
name|mdix
operator|==
literal|0
operator|||
name|hw
operator|->
name|mdix
operator|==
literal|3
operator|)
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Invalid MDI setting detected\n"
argument_list|)
expr_stmt|;
name|hw
operator|->
name|mdix
operator|=
literal|1
expr_stmt|;
return|return
operator|-
name|E1000_ERR_CONFIG
return|;
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Sets up eeprom variables in the hw struct.  Must be called after mac_type  * is configured.  *  * hw - Struct containing variables accessed by shared code  *****************************************************************************/
end_comment

begin_function
name|void
name|em_init_eeprom_params
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|em_eeprom_info
modifier|*
name|eeprom
init|=
operator|&
name|hw
operator|->
name|eeprom
decl_stmt|;
name|uint32_t
name|eecd
init|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|EECD
argument_list|)
decl_stmt|;
name|uint16_t
name|eeprom_size
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_init_eeprom_params"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|hw
operator|->
name|mac_type
condition|)
block|{
case|case
name|em_82542_rev2_0
case|:
case|case
name|em_82542_rev2_1
case|:
case|case
name|em_82543
case|:
case|case
name|em_82544
case|:
name|eeprom
operator|->
name|type
operator|=
name|em_eeprom_microwire
expr_stmt|;
name|eeprom
operator|->
name|word_size
operator|=
literal|64
expr_stmt|;
name|eeprom
operator|->
name|opcode_bits
operator|=
literal|3
expr_stmt|;
name|eeprom
operator|->
name|address_bits
operator|=
literal|6
expr_stmt|;
name|eeprom
operator|->
name|delay_usec
operator|=
literal|50
expr_stmt|;
break|break;
case|case
name|em_82540
case|:
case|case
name|em_82545
case|:
case|case
name|em_82545_rev_3
case|:
case|case
name|em_82546
case|:
case|case
name|em_82546_rev_3
case|:
name|eeprom
operator|->
name|type
operator|=
name|em_eeprom_microwire
expr_stmt|;
name|eeprom
operator|->
name|opcode_bits
operator|=
literal|3
expr_stmt|;
name|eeprom
operator|->
name|delay_usec
operator|=
literal|50
expr_stmt|;
if|if
condition|(
name|eecd
operator|&
name|E1000_EECD_SIZE
condition|)
block|{
name|eeprom
operator|->
name|word_size
operator|=
literal|256
expr_stmt|;
name|eeprom
operator|->
name|address_bits
operator|=
literal|8
expr_stmt|;
block|}
else|else
block|{
name|eeprom
operator|->
name|word_size
operator|=
literal|64
expr_stmt|;
name|eeprom
operator|->
name|address_bits
operator|=
literal|6
expr_stmt|;
block|}
break|break;
case|case
name|em_82541
case|:
case|case
name|em_82541_rev_2
case|:
case|case
name|em_82547
case|:
case|case
name|em_82547_rev_2
case|:
if|if
condition|(
name|eecd
operator|&
name|E1000_EECD_TYPE
condition|)
block|{
name|eeprom
operator|->
name|type
operator|=
name|em_eeprom_spi
expr_stmt|;
name|eeprom
operator|->
name|opcode_bits
operator|=
literal|8
expr_stmt|;
name|eeprom
operator|->
name|delay_usec
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|eecd
operator|&
name|E1000_EECD_ADDR_BITS
condition|)
block|{
name|eeprom
operator|->
name|page_size
operator|=
literal|32
expr_stmt|;
name|eeprom
operator|->
name|address_bits
operator|=
literal|16
expr_stmt|;
block|}
else|else
block|{
name|eeprom
operator|->
name|page_size
operator|=
literal|8
expr_stmt|;
name|eeprom
operator|->
name|address_bits
operator|=
literal|8
expr_stmt|;
block|}
block|}
else|else
block|{
name|eeprom
operator|->
name|type
operator|=
name|em_eeprom_microwire
expr_stmt|;
name|eeprom
operator|->
name|opcode_bits
operator|=
literal|3
expr_stmt|;
name|eeprom
operator|->
name|delay_usec
operator|=
literal|50
expr_stmt|;
if|if
condition|(
name|eecd
operator|&
name|E1000_EECD_ADDR_BITS
condition|)
block|{
name|eeprom
operator|->
name|word_size
operator|=
literal|256
expr_stmt|;
name|eeprom
operator|->
name|address_bits
operator|=
literal|8
expr_stmt|;
block|}
else|else
block|{
name|eeprom
operator|->
name|word_size
operator|=
literal|64
expr_stmt|;
name|eeprom
operator|->
name|address_bits
operator|=
literal|6
expr_stmt|;
block|}
block|}
break|break;
default|default:
name|eeprom
operator|->
name|type
operator|=
name|em_eeprom_spi
expr_stmt|;
name|eeprom
operator|->
name|opcode_bits
operator|=
literal|8
expr_stmt|;
name|eeprom
operator|->
name|delay_usec
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|eecd
operator|&
name|E1000_EECD_ADDR_BITS
condition|)
block|{
name|eeprom
operator|->
name|page_size
operator|=
literal|32
expr_stmt|;
name|eeprom
operator|->
name|address_bits
operator|=
literal|16
expr_stmt|;
block|}
else|else
block|{
name|eeprom
operator|->
name|page_size
operator|=
literal|8
expr_stmt|;
name|eeprom
operator|->
name|address_bits
operator|=
literal|8
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|eeprom
operator|->
name|type
operator|==
name|em_eeprom_spi
condition|)
block|{
name|eeprom
operator|->
name|word_size
operator|=
literal|64
expr_stmt|;
if|if
condition|(
name|em_read_eeprom
argument_list|(
name|hw
argument_list|,
name|EEPROM_CFG
argument_list|,
literal|1
argument_list|,
operator|&
name|eeprom_size
argument_list|)
operator|==
literal|0
condition|)
block|{
name|eeprom_size
operator|&=
name|EEPROM_SIZE_MASK
expr_stmt|;
switch|switch
condition|(
name|eeprom_size
condition|)
block|{
case|case
name|EEPROM_SIZE_16KB
case|:
name|eeprom
operator|->
name|word_size
operator|=
literal|8192
expr_stmt|;
break|break;
case|case
name|EEPROM_SIZE_8KB
case|:
name|eeprom
operator|->
name|word_size
operator|=
literal|4096
expr_stmt|;
break|break;
case|case
name|EEPROM_SIZE_4KB
case|:
name|eeprom
operator|->
name|word_size
operator|=
literal|2048
expr_stmt|;
break|break;
case|case
name|EEPROM_SIZE_2KB
case|:
name|eeprom
operator|->
name|word_size
operator|=
literal|1024
expr_stmt|;
break|break;
case|case
name|EEPROM_SIZE_1KB
case|:
name|eeprom
operator|->
name|word_size
operator|=
literal|512
expr_stmt|;
break|break;
case|case
name|EEPROM_SIZE_512B
case|:
name|eeprom
operator|->
name|word_size
operator|=
literal|256
expr_stmt|;
break|break;
case|case
name|EEPROM_SIZE_128B
case|:
default|default:
name|eeprom
operator|->
name|word_size
operator|=
literal|64
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/******************************************************************************  * Raises the EEPROM's clock input.  *  * hw - Struct containing variables accessed by shared code  * eecd - EECD's current value  *****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|em_raise_ee_clk
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint32_t
modifier|*
name|eecd
parameter_list|)
block|{
comment|/* Raise the clock input to the EEPROM (by setting the SK bit), and then      * wait<delay> microseconds.      */
operator|*
name|eecd
operator|=
operator|*
name|eecd
operator||
name|E1000_EECD_SK
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|EECD
argument_list|,
operator|*
name|eecd
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
name|hw
operator|->
name|eeprom
operator|.
name|delay_usec
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Lowers the EEPROM's clock input.  *  * hw - Struct containing variables accessed by shared code  * eecd - EECD's current value  *****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|em_lower_ee_clk
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint32_t
modifier|*
name|eecd
parameter_list|)
block|{
comment|/* Lower the clock input to the EEPROM (by clearing the SK bit), and then      * wait 50 microseconds.      */
operator|*
name|eecd
operator|=
operator|*
name|eecd
operator|&
operator|~
name|E1000_EECD_SK
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|EECD
argument_list|,
operator|*
name|eecd
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
name|hw
operator|->
name|eeprom
operator|.
name|delay_usec
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Shift data bits out to the EEPROM.  *  * hw - Struct containing variables accessed by shared code  * data - data to send to the EEPROM  * count - number of bits to shift out  *****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|em_shift_out_ee_bits
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint16_t
name|data
parameter_list|,
name|uint16_t
name|count
parameter_list|)
block|{
name|struct
name|em_eeprom_info
modifier|*
name|eeprom
init|=
operator|&
name|hw
operator|->
name|eeprom
decl_stmt|;
name|uint32_t
name|eecd
decl_stmt|;
name|uint32_t
name|mask
decl_stmt|;
comment|/* We need to shift "count" bits out to the EEPROM. So, value in the      * "data" parameter will be shifted out to the EEPROM one bit at a time.      * In order to do this, "data" must be broken down into bits.      */
name|mask
operator|=
literal|0x01
operator|<<
operator|(
name|count
operator|-
literal|1
operator|)
expr_stmt|;
name|eecd
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|EECD
argument_list|)
expr_stmt|;
if|if
condition|(
name|eeprom
operator|->
name|type
operator|==
name|em_eeprom_microwire
condition|)
block|{
name|eecd
operator|&=
operator|~
name|E1000_EECD_DO
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|eeprom
operator|->
name|type
operator|==
name|em_eeprom_spi
condition|)
block|{
name|eecd
operator||=
name|E1000_EECD_DO
expr_stmt|;
block|}
do|do
block|{
comment|/* A "1" is shifted out to the EEPROM by setting bit "DI" to a "1",          * and then raising and then lowering the clock (the SK bit controls          * the clock input to the EEPROM).  A "0" is shifted out to the EEPROM          * by setting "DI" to "0" and then raising and then lowering the clock.          */
name|eecd
operator|&=
operator|~
name|E1000_EECD_DI
expr_stmt|;
if|if
condition|(
name|data
operator|&
name|mask
condition|)
name|eecd
operator||=
name|E1000_EECD_DI
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|EECD
argument_list|,
name|eecd
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
name|eeprom
operator|->
name|delay_usec
argument_list|)
expr_stmt|;
name|em_raise_ee_clk
argument_list|(
name|hw
argument_list|,
operator|&
name|eecd
argument_list|)
expr_stmt|;
name|em_lower_ee_clk
argument_list|(
name|hw
argument_list|,
operator|&
name|eecd
argument_list|)
expr_stmt|;
name|mask
operator|=
name|mask
operator|>>
literal|1
expr_stmt|;
block|}
do|while
condition|(
name|mask
condition|)
do|;
comment|/* We leave the "DI" bit set to "0" when we leave this routine. */
name|eecd
operator|&=
operator|~
name|E1000_EECD_DI
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|EECD
argument_list|,
name|eecd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Shift data bits in from the EEPROM  *  * hw - Struct containing variables accessed by shared code  *****************************************************************************/
end_comment

begin_function
specifier|static
name|uint16_t
name|em_shift_in_ee_bits
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint16_t
name|count
parameter_list|)
block|{
name|uint32_t
name|eecd
decl_stmt|;
name|uint32_t
name|i
decl_stmt|;
name|uint16_t
name|data
decl_stmt|;
comment|/* In order to read a register from the EEPROM, we need to shift 'count'      * bits in from the EEPROM. Bits are "shifted in" by raising the clock      * input to the EEPROM (setting the SK bit), and then reading the value of      * the "DO" bit.  During this "shifting in" process the "DI" bit should      * always be clear.      */
name|eecd
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|EECD
argument_list|)
expr_stmt|;
name|eecd
operator|&=
operator|~
operator|(
name|E1000_EECD_DO
operator||
name|E1000_EECD_DI
operator|)
expr_stmt|;
name|data
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|data
operator|=
name|data
operator|<<
literal|1
expr_stmt|;
name|em_raise_ee_clk
argument_list|(
name|hw
argument_list|,
operator|&
name|eecd
argument_list|)
expr_stmt|;
name|eecd
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|EECD
argument_list|)
expr_stmt|;
name|eecd
operator|&=
operator|~
operator|(
name|E1000_EECD_DI
operator|)
expr_stmt|;
if|if
condition|(
name|eecd
operator|&
name|E1000_EECD_DO
condition|)
name|data
operator||=
literal|1
expr_stmt|;
name|em_lower_ee_clk
argument_list|(
name|hw
argument_list|,
operator|&
name|eecd
argument_list|)
expr_stmt|;
block|}
return|return
name|data
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Prepares EEPROM for access  *  * hw - Struct containing variables accessed by shared code  *  * Lowers EEPROM clock. Clears input pin. Sets the chip select pin. This  * function should be called before issuing a command to the EEPROM.  *****************************************************************************/
end_comment

begin_function
specifier|static
name|int32_t
name|em_acquire_eeprom
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|em_eeprom_info
modifier|*
name|eeprom
init|=
operator|&
name|hw
operator|->
name|eeprom
decl_stmt|;
name|uint32_t
name|eecd
decl_stmt|,
name|i
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_acquire_eeprom"
argument_list|)
expr_stmt|;
name|eecd
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|EECD
argument_list|)
expr_stmt|;
comment|/* Request EEPROM Access */
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|>
name|em_82544
condition|)
block|{
name|eecd
operator||=
name|E1000_EECD_REQ
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|EECD
argument_list|,
name|eecd
argument_list|)
expr_stmt|;
name|eecd
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|EECD
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
operator|!
operator|(
name|eecd
operator|&
name|E1000_EECD_GNT
operator|)
operator|)
operator|&&
operator|(
name|i
operator|<
name|E1000_EEPROM_GRANT_ATTEMPTS
operator|)
condition|)
block|{
name|i
operator|++
expr_stmt|;
name|usec_delay
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|eecd
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|EECD
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|eecd
operator|&
name|E1000_EECD_GNT
operator|)
condition|)
block|{
name|eecd
operator|&=
operator|~
name|E1000_EECD_REQ
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|EECD
argument_list|,
name|eecd
argument_list|)
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Could not acquire EEPROM grant\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_EEPROM
return|;
block|}
block|}
comment|/* Setup EEPROM for Read/Write */
if|if
condition|(
name|eeprom
operator|->
name|type
operator|==
name|em_eeprom_microwire
condition|)
block|{
comment|/* Clear SK and DI */
name|eecd
operator|&=
operator|~
operator|(
name|E1000_EECD_DI
operator||
name|E1000_EECD_SK
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|EECD
argument_list|,
name|eecd
argument_list|)
expr_stmt|;
comment|/* Set CS */
name|eecd
operator||=
name|E1000_EECD_CS
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|EECD
argument_list|,
name|eecd
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|eeprom
operator|->
name|type
operator|==
name|em_eeprom_spi
condition|)
block|{
comment|/* Clear SK and CS */
name|eecd
operator|&=
operator|~
operator|(
name|E1000_EECD_CS
operator||
name|E1000_EECD_SK
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|EECD
argument_list|,
name|eecd
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Returns EEPROM to a "standby" state  *  * hw - Struct containing variables accessed by shared code  *****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|em_standby_eeprom
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|em_eeprom_info
modifier|*
name|eeprom
init|=
operator|&
name|hw
operator|->
name|eeprom
decl_stmt|;
name|uint32_t
name|eecd
decl_stmt|;
name|eecd
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|EECD
argument_list|)
expr_stmt|;
if|if
condition|(
name|eeprom
operator|->
name|type
operator|==
name|em_eeprom_microwire
condition|)
block|{
name|eecd
operator|&=
operator|~
operator|(
name|E1000_EECD_CS
operator||
name|E1000_EECD_SK
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|EECD
argument_list|,
name|eecd
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
name|eeprom
operator|->
name|delay_usec
argument_list|)
expr_stmt|;
comment|/* Clock high */
name|eecd
operator||=
name|E1000_EECD_SK
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|EECD
argument_list|,
name|eecd
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
name|eeprom
operator|->
name|delay_usec
argument_list|)
expr_stmt|;
comment|/* Select EEPROM */
name|eecd
operator||=
name|E1000_EECD_CS
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|EECD
argument_list|,
name|eecd
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
name|eeprom
operator|->
name|delay_usec
argument_list|)
expr_stmt|;
comment|/* Clock low */
name|eecd
operator|&=
operator|~
name|E1000_EECD_SK
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|EECD
argument_list|,
name|eecd
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
name|eeprom
operator|->
name|delay_usec
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|eeprom
operator|->
name|type
operator|==
name|em_eeprom_spi
condition|)
block|{
comment|/* Toggle CS to flush commands */
name|eecd
operator||=
name|E1000_EECD_CS
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|EECD
argument_list|,
name|eecd
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
name|eeprom
operator|->
name|delay_usec
argument_list|)
expr_stmt|;
name|eecd
operator|&=
operator|~
name|E1000_EECD_CS
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|EECD
argument_list|,
name|eecd
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
name|eeprom
operator|->
name|delay_usec
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/******************************************************************************  * Terminates a command by inverting the EEPROM's chip select pin  *  * hw - Struct containing variables accessed by shared code  *****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|em_release_eeprom
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|uint32_t
name|eecd
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_release_eeprom"
argument_list|)
expr_stmt|;
name|eecd
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|EECD
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|eeprom
operator|.
name|type
operator|==
name|em_eeprom_spi
condition|)
block|{
name|eecd
operator||=
name|E1000_EECD_CS
expr_stmt|;
comment|/* Pull CS high */
name|eecd
operator|&=
operator|~
name|E1000_EECD_SK
expr_stmt|;
comment|/* Lower SCK */
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|EECD
argument_list|,
name|eecd
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
name|hw
operator|->
name|eeprom
operator|.
name|delay_usec
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|hw
operator|->
name|eeprom
operator|.
name|type
operator|==
name|em_eeprom_microwire
condition|)
block|{
comment|/* cleanup eeprom */
comment|/* CS on Microwire is active-high */
name|eecd
operator|&=
operator|~
operator|(
name|E1000_EECD_CS
operator||
name|E1000_EECD_DI
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|EECD
argument_list|,
name|eecd
argument_list|)
expr_stmt|;
comment|/* Rising edge of clock */
name|eecd
operator||=
name|E1000_EECD_SK
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|EECD
argument_list|,
name|eecd
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
name|hw
operator|->
name|eeprom
operator|.
name|delay_usec
argument_list|)
expr_stmt|;
comment|/* Falling edge of clock */
name|eecd
operator|&=
operator|~
name|E1000_EECD_SK
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|EECD
argument_list|,
name|eecd
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
name|hw
operator|->
name|eeprom
operator|.
name|delay_usec
argument_list|)
expr_stmt|;
block|}
comment|/* Stop requesting EEPROM access */
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|>
name|em_82544
condition|)
block|{
name|eecd
operator|&=
operator|~
name|E1000_EECD_REQ
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|EECD
argument_list|,
name|eecd
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/******************************************************************************  * Reads a 16 bit word from the EEPROM.  *  * hw - Struct containing variables accessed by shared code  *****************************************************************************/
end_comment

begin_function
name|int32_t
name|em_spi_eeprom_ready
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|uint16_t
name|retry_count
init|=
literal|0
decl_stmt|;
name|uint8_t
name|spi_stat_reg
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_spi_eeprom_ready"
argument_list|)
expr_stmt|;
comment|/* Read "Status Register" repeatedly until the LSB is cleared.  The      * EEPROM will signal that the command has been completed by clearing      * bit 0 of the internal status register.  If it's not cleared within      * 5 milliseconds, then error out.      */
name|retry_count
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|em_shift_out_ee_bits
argument_list|(
name|hw
argument_list|,
name|EEPROM_RDSR_OPCODE_SPI
argument_list|,
name|hw
operator|->
name|eeprom
operator|.
name|opcode_bits
argument_list|)
expr_stmt|;
name|spi_stat_reg
operator|=
operator|(
name|uint8_t
operator|)
name|em_shift_in_ee_bits
argument_list|(
name|hw
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|spi_stat_reg
operator|&
name|EEPROM_STATUS_RDY_SPI
operator|)
condition|)
break|break;
name|usec_delay
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|retry_count
operator|+=
literal|5
expr_stmt|;
block|}
do|while
condition|(
name|retry_count
operator|<
name|EEPROM_MAX_RETRY_SPI
condition|)
do|;
comment|/* ATMEL SPI write time could vary from 0-20mSec on 3.3V devices (and      * only 0-5mSec on 5V devices)      */
if|if
condition|(
name|retry_count
operator|>=
name|EEPROM_MAX_RETRY_SPI
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"SPI EEPROM Status error\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_EEPROM
return|;
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Reads a 16 bit word from the EEPROM.  *  * hw - Struct containing variables accessed by shared code  * offset - offset of  word in the EEPROM to read  * data - word read from the EEPROM  * words - number of words to read  *****************************************************************************/
end_comment

begin_function
name|int32_t
name|em_read_eeprom
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint16_t
name|offset
parameter_list|,
name|uint16_t
name|words
parameter_list|,
name|uint16_t
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|em_eeprom_info
modifier|*
name|eeprom
init|=
operator|&
name|hw
operator|->
name|eeprom
decl_stmt|;
name|uint32_t
name|i
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_read_eeprom"
argument_list|)
expr_stmt|;
comment|/* A check for invalid values:  offset too large, too many words, and not      * enough words.      */
if|if
condition|(
operator|(
name|offset
operator|>
name|eeprom
operator|->
name|word_size
operator|)
operator|||
operator|(
name|words
operator|>
name|eeprom
operator|->
name|word_size
operator|-
name|offset
operator|)
operator|||
operator|(
name|words
operator|==
literal|0
operator|)
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"\"words\" parameter out of bounds\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_EEPROM
return|;
block|}
comment|/* Prepare the EEPROM for reading  */
if|if
condition|(
name|em_acquire_eeprom
argument_list|(
name|hw
argument_list|)
operator|!=
name|E1000_SUCCESS
condition|)
return|return
operator|-
name|E1000_ERR_EEPROM
return|;
if|if
condition|(
name|eeprom
operator|->
name|type
operator|==
name|em_eeprom_spi
condition|)
block|{
name|uint16_t
name|word_in
decl_stmt|;
name|uint8_t
name|read_opcode
init|=
name|EEPROM_READ_OPCODE_SPI
decl_stmt|;
if|if
condition|(
name|em_spi_eeprom_ready
argument_list|(
name|hw
argument_list|)
condition|)
block|{
name|em_release_eeprom
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_EEPROM
return|;
block|}
name|em_standby_eeprom
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Some SPI eeproms use the 8th address bit embedded in the opcode */
if|if
condition|(
operator|(
name|eeprom
operator|->
name|address_bits
operator|==
literal|8
operator|)
operator|&&
operator|(
name|offset
operator|>=
literal|128
operator|)
condition|)
name|read_opcode
operator||=
name|EEPROM_A8_OPCODE_SPI
expr_stmt|;
comment|/* Send the READ command (opcode + addr)  */
name|em_shift_out_ee_bits
argument_list|(
name|hw
argument_list|,
name|read_opcode
argument_list|,
name|eeprom
operator|->
name|opcode_bits
argument_list|)
expr_stmt|;
name|em_shift_out_ee_bits
argument_list|(
name|hw
argument_list|,
call|(
name|uint16_t
call|)
argument_list|(
name|offset
operator|*
literal|2
argument_list|)
argument_list|,
name|eeprom
operator|->
name|address_bits
argument_list|)
expr_stmt|;
comment|/* Read the data.  The address of the eeprom internally increments with          * each byte (spi) being read, saving on the overhead of eeprom setup          * and tear-down.  The address counter will roll over if reading beyond          * the size of the eeprom, thus allowing the entire memory to be read          * starting from any offset. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|words
condition|;
name|i
operator|++
control|)
block|{
name|word_in
operator|=
name|em_shift_in_ee_bits
argument_list|(
name|hw
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|data
index|[
name|i
index|]
operator|=
operator|(
name|word_in
operator|>>
literal|8
operator|)
operator||
operator|(
name|word_in
operator|<<
literal|8
operator|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|eeprom
operator|->
name|type
operator|==
name|em_eeprom_microwire
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|words
condition|;
name|i
operator|++
control|)
block|{
comment|/* Send the READ command (opcode + addr)  */
name|em_shift_out_ee_bits
argument_list|(
name|hw
argument_list|,
name|EEPROM_READ_OPCODE_MICROWIRE
argument_list|,
name|eeprom
operator|->
name|opcode_bits
argument_list|)
expr_stmt|;
name|em_shift_out_ee_bits
argument_list|(
name|hw
argument_list|,
call|(
name|uint16_t
call|)
argument_list|(
name|offset
operator|+
name|i
argument_list|)
argument_list|,
name|eeprom
operator|->
name|address_bits
argument_list|)
expr_stmt|;
comment|/* Read the data.  For microwire, each word requires the overhead              * of eeprom setup and tear-down. */
name|data
index|[
name|i
index|]
operator|=
name|em_shift_in_ee_bits
argument_list|(
name|hw
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|em_standby_eeprom
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* End this read operation */
name|em_release_eeprom
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Verifies that the EEPROM has a valid checksum  *  * hw - Struct containing variables accessed by shared code  *  * Reads the first 64 16 bit words of the EEPROM and sums the values read.  * If the the sum of the 64 16 bit words is 0xBABA, the EEPROM's checksum is  * valid.  *****************************************************************************/
end_comment

begin_function
name|int32_t
name|em_validate_eeprom_checksum
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|uint16_t
name|checksum
init|=
literal|0
decl_stmt|;
name|uint16_t
name|i
decl_stmt|,
name|eeprom_data
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_validate_eeprom_checksum"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|EEPROM_CHECKSUM_REG
operator|+
literal|1
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|em_read_eeprom
argument_list|(
name|hw
argument_list|,
name|i
argument_list|,
literal|1
argument_list|,
operator|&
name|eeprom_data
argument_list|)
operator|<
literal|0
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"EEPROM Read Error\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_EEPROM
return|;
block|}
name|checksum
operator|+=
name|eeprom_data
expr_stmt|;
block|}
if|if
condition|(
name|checksum
operator|==
operator|(
name|uint16_t
operator|)
name|EEPROM_SUM
condition|)
return|return
name|E1000_SUCCESS
return|;
else|else
block|{
name|DEBUGOUT
argument_list|(
literal|"EEPROM Checksum Invalid\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_EEPROM
return|;
block|}
block|}
end_function

begin_comment
comment|/******************************************************************************  * Calculates the EEPROM checksum and writes it to the EEPROM  *  * hw - Struct containing variables accessed by shared code  *  * Sums the first 63 16 bit words of the EEPROM. Subtracts the sum from 0xBABA.  * Writes the difference to word offset 63 of the EEPROM.  *****************************************************************************/
end_comment

begin_function
name|int32_t
name|em_update_eeprom_checksum
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|uint16_t
name|checksum
init|=
literal|0
decl_stmt|;
name|uint16_t
name|i
decl_stmt|,
name|eeprom_data
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_update_eeprom_checksum"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|EEPROM_CHECKSUM_REG
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|em_read_eeprom
argument_list|(
name|hw
argument_list|,
name|i
argument_list|,
literal|1
argument_list|,
operator|&
name|eeprom_data
argument_list|)
operator|<
literal|0
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"EEPROM Read Error\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_EEPROM
return|;
block|}
name|checksum
operator|+=
name|eeprom_data
expr_stmt|;
block|}
name|checksum
operator|=
operator|(
name|uint16_t
operator|)
name|EEPROM_SUM
operator|-
name|checksum
expr_stmt|;
if|if
condition|(
name|em_write_eeprom
argument_list|(
name|hw
argument_list|,
name|EEPROM_CHECKSUM_REG
argument_list|,
literal|1
argument_list|,
operator|&
name|checksum
argument_list|)
operator|<
literal|0
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"EEPROM Write Error\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_EEPROM
return|;
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Parent function for writing words to the different EEPROM types.  *  * hw - Struct containing variables accessed by shared code  * offset - offset within the EEPROM to be written to  * words - number of words to write  * data - 16 bit word to be written to the EEPROM  *  * If em_update_eeprom_checksum is not called after this function, the  * EEPROM will most likely contain an invalid checksum.  *****************************************************************************/
end_comment

begin_function
name|int32_t
name|em_write_eeprom
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint16_t
name|offset
parameter_list|,
name|uint16_t
name|words
parameter_list|,
name|uint16_t
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|em_eeprom_info
modifier|*
name|eeprom
init|=
operator|&
name|hw
operator|->
name|eeprom
decl_stmt|;
name|int32_t
name|status
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_write_eeprom"
argument_list|)
expr_stmt|;
comment|/* A check for invalid values:  offset too large, too many words, and not      * enough words.      */
if|if
condition|(
operator|(
name|offset
operator|>
name|eeprom
operator|->
name|word_size
operator|)
operator|||
operator|(
name|words
operator|>
name|eeprom
operator|->
name|word_size
operator|-
name|offset
operator|)
operator|||
operator|(
name|words
operator|==
literal|0
operator|)
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"\"words\" parameter out of bounds\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_EEPROM
return|;
block|}
comment|/* Prepare the EEPROM for writing  */
if|if
condition|(
name|em_acquire_eeprom
argument_list|(
name|hw
argument_list|)
operator|!=
name|E1000_SUCCESS
condition|)
return|return
operator|-
name|E1000_ERR_EEPROM
return|;
if|if
condition|(
name|eeprom
operator|->
name|type
operator|==
name|em_eeprom_microwire
condition|)
name|status
operator|=
name|em_write_eeprom_microwire
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
name|words
argument_list|,
name|data
argument_list|)
expr_stmt|;
else|else
name|status
operator|=
name|em_write_eeprom_spi
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
name|words
argument_list|,
name|data
argument_list|)
expr_stmt|;
comment|/* Done with writing */
name|em_release_eeprom
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Writes a 16 bit word to a given offset in an SPI EEPROM.  *  * hw - Struct containing variables accessed by shared code  * offset - offset within the EEPROM to be written to  * words - number of words to write  * data - pointer to array of 8 bit words to be written to the EEPROM  *  *****************************************************************************/
end_comment

begin_function
name|int32_t
name|em_write_eeprom_spi
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint16_t
name|offset
parameter_list|,
name|uint16_t
name|words
parameter_list|,
name|uint16_t
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|em_eeprom_info
modifier|*
name|eeprom
init|=
operator|&
name|hw
operator|->
name|eeprom
decl_stmt|;
name|uint16_t
name|widx
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_write_eeprom_spi"
argument_list|)
expr_stmt|;
while|while
condition|(
name|widx
operator|<
name|words
condition|)
block|{
name|uint8_t
name|write_opcode
init|=
name|EEPROM_WRITE_OPCODE_SPI
decl_stmt|;
if|if
condition|(
name|em_spi_eeprom_ready
argument_list|(
name|hw
argument_list|)
condition|)
return|return
operator|-
name|E1000_ERR_EEPROM
return|;
name|em_standby_eeprom
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/*  Send the WRITE ENABLE command (8 bit opcode )  */
name|em_shift_out_ee_bits
argument_list|(
name|hw
argument_list|,
name|EEPROM_WREN_OPCODE_SPI
argument_list|,
name|eeprom
operator|->
name|opcode_bits
argument_list|)
expr_stmt|;
name|em_standby_eeprom
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Some SPI eeproms use the 8th address bit embedded in the opcode */
if|if
condition|(
operator|(
name|eeprom
operator|->
name|address_bits
operator|==
literal|8
operator|)
operator|&&
operator|(
name|offset
operator|>=
literal|128
operator|)
condition|)
name|write_opcode
operator||=
name|EEPROM_A8_OPCODE_SPI
expr_stmt|;
comment|/* Send the Write command (8-bit opcode + addr) */
name|em_shift_out_ee_bits
argument_list|(
name|hw
argument_list|,
name|write_opcode
argument_list|,
name|eeprom
operator|->
name|opcode_bits
argument_list|)
expr_stmt|;
name|em_shift_out_ee_bits
argument_list|(
name|hw
argument_list|,
call|(
name|uint16_t
call|)
argument_list|(
operator|(
name|offset
operator|+
name|widx
operator|)
operator|*
literal|2
argument_list|)
argument_list|,
name|eeprom
operator|->
name|address_bits
argument_list|)
expr_stmt|;
comment|/* Send the data */
comment|/* Loop to allow for up to whole page write (32 bytes) of eeprom */
while|while
condition|(
name|widx
operator|<
name|words
condition|)
block|{
name|uint16_t
name|word_out
init|=
name|data
index|[
name|widx
index|]
decl_stmt|;
name|word_out
operator|=
operator|(
name|word_out
operator|>>
literal|8
operator|)
operator||
operator|(
name|word_out
operator|<<
literal|8
operator|)
expr_stmt|;
name|em_shift_out_ee_bits
argument_list|(
name|hw
argument_list|,
name|word_out
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|widx
operator|++
expr_stmt|;
comment|/* Some larger eeprom sizes are capable of a 32-byte PAGE WRITE              * operation, while the smaller eeproms are capable of an 8-byte              * PAGE WRITE operation.  Break the inner loop to pass new address              */
if|if
condition|(
operator|(
operator|(
operator|(
name|offset
operator|+
name|widx
operator|)
operator|*
literal|2
operator|)
operator|%
name|eeprom
operator|->
name|page_size
operator|)
operator|==
literal|0
condition|)
block|{
name|em_standby_eeprom
argument_list|(
name|hw
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Writes a 16 bit word to a given offset in a Microwire EEPROM.  *  * hw - Struct containing variables accessed by shared code  * offset - offset within the EEPROM to be written to  * words - number of words to write  * data - pointer to array of 16 bit words to be written to the EEPROM  *  *****************************************************************************/
end_comment

begin_function
name|int32_t
name|em_write_eeprom_microwire
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint16_t
name|offset
parameter_list|,
name|uint16_t
name|words
parameter_list|,
name|uint16_t
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|em_eeprom_info
modifier|*
name|eeprom
init|=
operator|&
name|hw
operator|->
name|eeprom
decl_stmt|;
name|uint32_t
name|eecd
decl_stmt|;
name|uint16_t
name|words_written
init|=
literal|0
decl_stmt|;
name|uint16_t
name|i
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_write_eeprom_microwire"
argument_list|)
expr_stmt|;
comment|/* Send the write enable command to the EEPROM (3-bit opcode plus      * 6/8-bit dummy address beginning with 11).  It's less work to include      * the 11 of the dummy address as part of the opcode than it is to shift      * it over the correct number of bits for the address.  This puts the      * EEPROM into write/erase mode.      */
name|em_shift_out_ee_bits
argument_list|(
name|hw
argument_list|,
name|EEPROM_EWEN_OPCODE_MICROWIRE
argument_list|,
call|(
name|uint16_t
call|)
argument_list|(
name|eeprom
operator|->
name|opcode_bits
operator|+
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|em_shift_out_ee_bits
argument_list|(
name|hw
argument_list|,
literal|0
argument_list|,
call|(
name|uint16_t
call|)
argument_list|(
name|eeprom
operator|->
name|address_bits
operator|-
literal|2
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Prepare the EEPROM */
name|em_standby_eeprom
argument_list|(
name|hw
argument_list|)
expr_stmt|;
while|while
condition|(
name|words_written
operator|<
name|words
condition|)
block|{
comment|/* Send the Write command (3-bit opcode + addr) */
name|em_shift_out_ee_bits
argument_list|(
name|hw
argument_list|,
name|EEPROM_WRITE_OPCODE_MICROWIRE
argument_list|,
name|eeprom
operator|->
name|opcode_bits
argument_list|)
expr_stmt|;
name|em_shift_out_ee_bits
argument_list|(
name|hw
argument_list|,
call|(
name|uint16_t
call|)
argument_list|(
name|offset
operator|+
name|words_written
argument_list|)
argument_list|,
name|eeprom
operator|->
name|address_bits
argument_list|)
expr_stmt|;
comment|/* Send the data */
name|em_shift_out_ee_bits
argument_list|(
name|hw
argument_list|,
name|data
index|[
name|words_written
index|]
argument_list|,
literal|16
argument_list|)
expr_stmt|;
comment|/* Toggle the CS line.  This in effect tells the EEPROM to execute          * the previous command.          */
name|em_standby_eeprom
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Read DO repeatedly until it is high (equal to '1').  The EEPROM will          * signal that the command has been completed by raising the DO signal.          * If DO does not go high in 10 milliseconds, then error out.          */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|200
condition|;
name|i
operator|++
control|)
block|{
name|eecd
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|EECD
argument_list|)
expr_stmt|;
if|if
condition|(
name|eecd
operator|&
name|E1000_EECD_DO
condition|)
break|break;
name|usec_delay
argument_list|(
literal|50
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
literal|200
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"EEPROM Write did not complete\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_EEPROM
return|;
block|}
comment|/* Recover from write */
name|em_standby_eeprom
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|words_written
operator|++
expr_stmt|;
block|}
comment|/* Send the write disable command to the EEPROM (3-bit opcode plus      * 6/8-bit dummy address beginning with 10).  It's less work to include      * the 10 of the dummy address as part of the opcode than it is to shift      * it over the correct number of bits for the address.  This takes the      * EEPROM out of write/erase mode.      */
name|em_shift_out_ee_bits
argument_list|(
name|hw
argument_list|,
name|EEPROM_EWDS_OPCODE_MICROWIRE
argument_list|,
call|(
name|uint16_t
call|)
argument_list|(
name|eeprom
operator|->
name|opcode_bits
operator|+
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|em_shift_out_ee_bits
argument_list|(
name|hw
argument_list|,
literal|0
argument_list|,
call|(
name|uint16_t
call|)
argument_list|(
name|eeprom
operator|->
name|address_bits
operator|-
literal|2
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Reads the adapter's part number from the EEPROM  *  * hw - Struct containing variables accessed by shared code  * part_num - Adapter's part number  *****************************************************************************/
end_comment

begin_function
name|int32_t
name|em_read_part_num
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint32_t
modifier|*
name|part_num
parameter_list|)
block|{
name|uint16_t
name|offset
init|=
name|EEPROM_PBA_BYTE_1
decl_stmt|;
name|uint16_t
name|eeprom_data
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_read_part_num"
argument_list|)
expr_stmt|;
comment|/* Get word 0 from EEPROM */
if|if
condition|(
name|em_read_eeprom
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
literal|1
argument_list|,
operator|&
name|eeprom_data
argument_list|)
operator|<
literal|0
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"EEPROM Read Error\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_EEPROM
return|;
block|}
comment|/* Save word 0 in upper half of part_num */
operator|*
name|part_num
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|eeprom_data
operator|<<
literal|16
argument_list|)
expr_stmt|;
comment|/* Get word 1 from EEPROM */
if|if
condition|(
name|em_read_eeprom
argument_list|(
name|hw
argument_list|,
operator|++
name|offset
argument_list|,
literal|1
argument_list|,
operator|&
name|eeprom_data
argument_list|)
operator|<
literal|0
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"EEPROM Read Error\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_EEPROM
return|;
block|}
comment|/* Save word 1 in lower half of part_num */
operator|*
name|part_num
operator||=
name|eeprom_data
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Reads the adapter's MAC address from the EEPROM and inverts the LSB for the  * second function of dual function devices  *  * hw - Struct containing variables accessed by shared code  *****************************************************************************/
end_comment

begin_function
name|int32_t
name|em_read_mac_addr
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|uint16_t
name|offset
decl_stmt|;
name|uint16_t
name|eeprom_data
decl_stmt|,
name|i
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_read_mac_addr"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NODE_ADDRESS_SIZE
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|offset
operator|=
name|i
operator|>>
literal|1
expr_stmt|;
if|if
condition|(
name|em_read_eeprom
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
literal|1
argument_list|,
operator|&
name|eeprom_data
argument_list|)
operator|<
literal|0
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"EEPROM Read Error\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_EEPROM
return|;
block|}
name|hw
operator|->
name|perm_mac_addr
index|[
name|i
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|eeprom_data
operator|&
literal|0x00FF
argument_list|)
expr_stmt|;
name|hw
operator|->
name|perm_mac_addr
index|[
name|i
operator|+
literal|1
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|eeprom_data
operator|>>
literal|8
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|(
name|hw
operator|->
name|mac_type
operator|==
name|em_82546
operator|)
operator|||
operator|(
name|hw
operator|->
name|mac_type
operator|==
name|em_82546_rev_3
operator|)
operator|)
operator|&&
operator|(
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|STATUS
argument_list|)
operator|&
name|E1000_STATUS_FUNC_1
operator|)
condition|)
block|{
if|if
condition|(
name|hw
operator|->
name|perm_mac_addr
index|[
literal|5
index|]
operator|&
literal|0x01
condition|)
name|hw
operator|->
name|perm_mac_addr
index|[
literal|5
index|]
operator|&=
operator|~
operator|(
literal|0x01
operator|)
expr_stmt|;
else|else
name|hw
operator|->
name|perm_mac_addr
index|[
literal|5
index|]
operator||=
literal|0x01
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NODE_ADDRESS_SIZE
condition|;
name|i
operator|++
control|)
name|hw
operator|->
name|mac_addr
index|[
name|i
index|]
operator|=
name|hw
operator|->
name|perm_mac_addr
index|[
name|i
index|]
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Initializes receive address filters.  *  * hw - Struct containing variables accessed by shared code  *  * Places the MAC address in receive address register 0 and clears the rest  * of the receive addresss registers. Clears the multicast table. Assumes  * the receiver is in reset when the routine is called.  *****************************************************************************/
end_comment

begin_function
name|void
name|em_init_rx_addrs
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|uint32_t
name|i
decl_stmt|;
name|uint32_t
name|addr_low
decl_stmt|;
name|uint32_t
name|addr_high
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_init_rx_addrs"
argument_list|)
expr_stmt|;
comment|/* Setup the receive address. */
name|DEBUGOUT
argument_list|(
literal|"Programming MAC Address into RAR[0]\n"
argument_list|)
expr_stmt|;
name|addr_low
operator|=
operator|(
name|hw
operator|->
name|mac_addr
index|[
literal|0
index|]
operator||
operator|(
name|hw
operator|->
name|mac_addr
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|hw
operator|->
name|mac_addr
index|[
literal|2
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|hw
operator|->
name|mac_addr
index|[
literal|3
index|]
operator|<<
literal|24
operator|)
operator|)
expr_stmt|;
name|addr_high
operator|=
operator|(
name|hw
operator|->
name|mac_addr
index|[
literal|4
index|]
operator||
operator|(
name|hw
operator|->
name|mac_addr
index|[
literal|5
index|]
operator|<<
literal|8
operator|)
operator||
name|E1000_RAH_AV
operator|)
expr_stmt|;
name|E1000_WRITE_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|RA
argument_list|,
literal|0
argument_list|,
name|addr_low
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|RA
argument_list|,
literal|1
argument_list|,
name|addr_high
argument_list|)
expr_stmt|;
comment|/* Zero out the other 15 receive addresses. */
name|DEBUGOUT
argument_list|(
literal|"Clearing RAR[1-15]\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|E1000_RAR_ENTRIES
condition|;
name|i
operator|++
control|)
block|{
name|E1000_WRITE_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|RA
argument_list|,
operator|(
name|i
operator|<<
literal|1
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|RA
argument_list|,
operator|(
operator|(
name|i
operator|<<
literal|1
operator|)
operator|+
literal|1
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/******************************************************************************  * Updates the MAC's list of multicast addresses.  *  * hw - Struct containing variables accessed by shared code  * mc_addr_list - the list of new multicast addresses  * mc_addr_count - number of addresses  * pad - number of bytes between addresses in the list  *  * The given list replaces any existing list. Clears the last 15 receive  * address registers and the multicast table. Uses receive address registers  * for the first 15 multicast addresses, and hashes the rest into the  * multicast table.  *****************************************************************************/
end_comment

begin_function
name|void
name|em_mc_addr_list_update
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint8_t
modifier|*
name|mc_addr_list
parameter_list|,
name|uint32_t
name|mc_addr_count
parameter_list|,
name|uint32_t
name|pad
parameter_list|)
block|{
name|uint32_t
name|hash_value
decl_stmt|;
name|uint32_t
name|i
decl_stmt|;
name|uint32_t
name|rar_used_count
init|=
literal|1
decl_stmt|;
comment|/* RAR[0] is used for our MAC address */
name|DEBUGFUNC
argument_list|(
literal|"em_mc_addr_list_update"
argument_list|)
expr_stmt|;
comment|/* Set the new number of MC addresses that we are being requested to use. */
name|hw
operator|->
name|num_mc_addrs
operator|=
name|mc_addr_count
expr_stmt|;
comment|/* Clear RAR[1-15] */
name|DEBUGOUT
argument_list|(
literal|" Clearing RAR[1-15]\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|rar_used_count
init|;
name|i
operator|<
name|E1000_RAR_ENTRIES
condition|;
name|i
operator|++
control|)
block|{
name|E1000_WRITE_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|RA
argument_list|,
operator|(
name|i
operator|<<
literal|1
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|RA
argument_list|,
operator|(
operator|(
name|i
operator|<<
literal|1
operator|)
operator|+
literal|1
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Clear the MTA */
name|DEBUGOUT
argument_list|(
literal|" Clearing MTA\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|E1000_NUM_MTA_REGISTERS
condition|;
name|i
operator|++
control|)
block|{
name|E1000_WRITE_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|MTA
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Add the new addresses */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mc_addr_count
condition|;
name|i
operator|++
control|)
block|{
name|DEBUGOUT
argument_list|(
literal|" Adding the multicast addresses:\n"
argument_list|)
expr_stmt|;
name|DEBUGOUT7
argument_list|(
literal|" MC Addr #%d =%.2X %.2X %.2X %.2X %.2X %.2X\n"
argument_list|,
name|i
argument_list|,
name|mc_addr_list
index|[
name|i
operator|*
operator|(
name|ETH_LENGTH_OF_ADDRESS
operator|+
name|pad
operator|)
index|]
argument_list|,
name|mc_addr_list
index|[
name|i
operator|*
operator|(
name|ETH_LENGTH_OF_ADDRESS
operator|+
name|pad
operator|)
operator|+
literal|1
index|]
argument_list|,
name|mc_addr_list
index|[
name|i
operator|*
operator|(
name|ETH_LENGTH_OF_ADDRESS
operator|+
name|pad
operator|)
operator|+
literal|2
index|]
argument_list|,
name|mc_addr_list
index|[
name|i
operator|*
operator|(
name|ETH_LENGTH_OF_ADDRESS
operator|+
name|pad
operator|)
operator|+
literal|3
index|]
argument_list|,
name|mc_addr_list
index|[
name|i
operator|*
operator|(
name|ETH_LENGTH_OF_ADDRESS
operator|+
name|pad
operator|)
operator|+
literal|4
index|]
argument_list|,
name|mc_addr_list
index|[
name|i
operator|*
operator|(
name|ETH_LENGTH_OF_ADDRESS
operator|+
name|pad
operator|)
operator|+
literal|5
index|]
argument_list|)
expr_stmt|;
name|hash_value
operator|=
name|em_hash_mc_addr
argument_list|(
name|hw
argument_list|,
name|mc_addr_list
operator|+
operator|(
name|i
operator|*
operator|(
name|ETH_LENGTH_OF_ADDRESS
operator|+
name|pad
operator|)
operator|)
argument_list|)
expr_stmt|;
name|DEBUGOUT1
argument_list|(
literal|" Hash value = 0x%03X\n"
argument_list|,
name|hash_value
argument_list|)
expr_stmt|;
comment|/* Place this multicast address in the RAR if there is room, *          * else put it in the MTA          */
if|if
condition|(
name|rar_used_count
operator|<
name|E1000_RAR_ENTRIES
condition|)
block|{
name|em_rar_set
argument_list|(
name|hw
argument_list|,
name|mc_addr_list
operator|+
operator|(
name|i
operator|*
operator|(
name|ETH_LENGTH_OF_ADDRESS
operator|+
name|pad
operator|)
operator|)
argument_list|,
name|rar_used_count
argument_list|)
expr_stmt|;
name|rar_used_count
operator|++
expr_stmt|;
block|}
else|else
block|{
name|em_mta_set
argument_list|(
name|hw
argument_list|,
name|hash_value
argument_list|)
expr_stmt|;
block|}
block|}
name|DEBUGOUT
argument_list|(
literal|"MC Update Complete\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Hashes an address to determine its location in the multicast table  *  * hw - Struct containing variables accessed by shared code  * mc_addr - the multicast address to hash  *****************************************************************************/
end_comment

begin_function
name|uint32_t
name|em_hash_mc_addr
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint8_t
modifier|*
name|mc_addr
parameter_list|)
block|{
name|uint32_t
name|hash_value
init|=
literal|0
decl_stmt|;
comment|/* The portion of the address that is used for the hash table is      * determined by the mc_filter_type setting.      */
switch|switch
condition|(
name|hw
operator|->
name|mc_filter_type
condition|)
block|{
comment|/* [0] [1] [2] [3] [4] [5]      * 01  AA  00  12  34  56      * LSB                 MSB      */
case|case
literal|0
case|:
comment|/* [47:36] i.e. 0x563 for above example address */
name|hash_value
operator|=
operator|(
operator|(
name|mc_addr
index|[
literal|4
index|]
operator|>>
literal|4
operator|)
operator||
operator|(
operator|(
operator|(
name|uint16_t
operator|)
name|mc_addr
index|[
literal|5
index|]
operator|)
operator|<<
literal|4
operator|)
operator|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* [46:35] i.e. 0xAC6 for above example address */
name|hash_value
operator|=
operator|(
operator|(
name|mc_addr
index|[
literal|4
index|]
operator|>>
literal|3
operator|)
operator||
operator|(
operator|(
operator|(
name|uint16_t
operator|)
name|mc_addr
index|[
literal|5
index|]
operator|)
operator|<<
literal|5
operator|)
operator|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* [45:34] i.e. 0x5D8 for above example address */
name|hash_value
operator|=
operator|(
operator|(
name|mc_addr
index|[
literal|4
index|]
operator|>>
literal|2
operator|)
operator||
operator|(
operator|(
operator|(
name|uint16_t
operator|)
name|mc_addr
index|[
literal|5
index|]
operator|)
operator|<<
literal|6
operator|)
operator|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* [43:32] i.e. 0x634 for above example address */
name|hash_value
operator|=
operator|(
operator|(
name|mc_addr
index|[
literal|4
index|]
operator|)
operator||
operator|(
operator|(
operator|(
name|uint16_t
operator|)
name|mc_addr
index|[
literal|5
index|]
operator|)
operator|<<
literal|8
operator|)
operator|)
expr_stmt|;
break|break;
block|}
name|hash_value
operator|&=
literal|0xFFF
expr_stmt|;
return|return
name|hash_value
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Sets the bit in the multicast table corresponding to the hash value.  *  * hw - Struct containing variables accessed by shared code  * hash_value - Multicast address hash value  *****************************************************************************/
end_comment

begin_function
name|void
name|em_mta_set
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint32_t
name|hash_value
parameter_list|)
block|{
name|uint32_t
name|hash_bit
decl_stmt|,
name|hash_reg
decl_stmt|;
name|uint32_t
name|mta
decl_stmt|;
name|uint32_t
name|temp
decl_stmt|;
comment|/* The MTA is a register array of 128 32-bit registers.      * It is treated like an array of 4096 bits.  We want to set      * bit BitArray[hash_value]. So we figure out what register      * the bit is in, read it, OR in the new bit, then write      * back the new value.  The register is determined by the      * upper 7 bits of the hash value and the bit within that      * register are determined by the lower 5 bits of the value.      */
name|hash_reg
operator|=
operator|(
name|hash_value
operator|>>
literal|5
operator|)
operator|&
literal|0x7F
expr_stmt|;
name|hash_bit
operator|=
name|hash_value
operator|&
literal|0x1F
expr_stmt|;
name|mta
operator|=
name|E1000_READ_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|MTA
argument_list|,
name|hash_reg
argument_list|)
expr_stmt|;
name|mta
operator||=
operator|(
literal|1
operator|<<
name|hash_bit
operator|)
expr_stmt|;
comment|/* If we are on an 82544 and we are trying to write an odd offset      * in the MTA, save off the previous entry before writing and      * restore the old value after writing.      */
if|if
condition|(
operator|(
name|hw
operator|->
name|mac_type
operator|==
name|em_82544
operator|)
operator|&&
operator|(
operator|(
name|hash_reg
operator|&
literal|0x1
operator|)
operator|==
literal|1
operator|)
condition|)
block|{
name|temp
operator|=
name|E1000_READ_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|MTA
argument_list|,
operator|(
name|hash_reg
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|MTA
argument_list|,
name|hash_reg
argument_list|,
name|mta
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|MTA
argument_list|,
operator|(
name|hash_reg
operator|-
literal|1
operator|)
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|E1000_WRITE_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|MTA
argument_list|,
name|hash_reg
argument_list|,
name|mta
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/******************************************************************************  * Puts an ethernet address into a receive address register.  *  * hw - Struct containing variables accessed by shared code  * addr - Address to put into receive address register  * index - Receive address register to write  *****************************************************************************/
end_comment

begin_function
name|void
name|em_rar_set
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint8_t
modifier|*
name|addr
parameter_list|,
name|uint32_t
name|index
parameter_list|)
block|{
name|uint32_t
name|rar_low
decl_stmt|,
name|rar_high
decl_stmt|;
comment|/* HW expects these in little endian so we reverse the byte order      * from network order (big endian) to little endian      */
name|rar_low
operator|=
operator|(
operator|(
name|uint32_t
operator|)
name|addr
index|[
literal|0
index|]
operator||
operator|(
operator|(
name|uint32_t
operator|)
name|addr
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
name|uint32_t
operator|)
name|addr
index|[
literal|2
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|uint32_t
operator|)
name|addr
index|[
literal|3
index|]
operator|<<
literal|24
operator|)
operator|)
expr_stmt|;
name|rar_high
operator|=
operator|(
operator|(
name|uint32_t
operator|)
name|addr
index|[
literal|4
index|]
operator||
operator|(
operator|(
name|uint32_t
operator|)
name|addr
index|[
literal|5
index|]
operator|<<
literal|8
operator|)
operator||
name|E1000_RAH_AV
operator|)
expr_stmt|;
name|E1000_WRITE_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|RA
argument_list|,
operator|(
name|index
operator|<<
literal|1
operator|)
argument_list|,
name|rar_low
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|RA
argument_list|,
operator|(
operator|(
name|index
operator|<<
literal|1
operator|)
operator|+
literal|1
operator|)
argument_list|,
name|rar_high
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Writes a value to the specified offset in the VLAN filter table.  *  * hw - Struct containing variables accessed by shared code  * offset - Offset in VLAN filer table to write  * value - Value to write into VLAN filter table  *****************************************************************************/
end_comment

begin_function
name|void
name|em_write_vfta
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint32_t
name|offset
parameter_list|,
name|uint32_t
name|value
parameter_list|)
block|{
name|uint32_t
name|temp
decl_stmt|;
if|if
condition|(
operator|(
name|hw
operator|->
name|mac_type
operator|==
name|em_82544
operator|)
operator|&&
operator|(
operator|(
name|offset
operator|&
literal|0x1
operator|)
operator|==
literal|1
operator|)
condition|)
block|{
name|temp
operator|=
name|E1000_READ_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|VFTA
argument_list|,
operator|(
name|offset
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|VFTA
argument_list|,
name|offset
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|VFTA
argument_list|,
operator|(
name|offset
operator|-
literal|1
operator|)
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|E1000_WRITE_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|VFTA
argument_list|,
name|offset
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/******************************************************************************  * Clears the VLAN filer table  *  * hw - Struct containing variables accessed by shared code  *****************************************************************************/
end_comment

begin_function
name|void
name|em_clear_vfta
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|uint32_t
name|offset
decl_stmt|;
for|for
control|(
name|offset
operator|=
literal|0
init|;
name|offset
operator|<
name|E1000_VLAN_FILTER_TBL_SIZE
condition|;
name|offset
operator|++
control|)
name|E1000_WRITE_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|VFTA
argument_list|,
name|offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int32_t
name|em_id_led_init
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|uint32_t
name|ledctl
decl_stmt|;
specifier|const
name|uint32_t
name|ledctl_mask
init|=
literal|0x000000FF
decl_stmt|;
specifier|const
name|uint32_t
name|ledctl_on
init|=
name|E1000_LEDCTL_MODE_LED_ON
decl_stmt|;
specifier|const
name|uint32_t
name|ledctl_off
init|=
name|E1000_LEDCTL_MODE_LED_OFF
decl_stmt|;
name|uint16_t
name|eeprom_data
decl_stmt|,
name|i
decl_stmt|,
name|temp
decl_stmt|;
specifier|const
name|uint16_t
name|led_mask
init|=
literal|0x0F
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_id_led_init"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|<
name|em_82540
condition|)
block|{
comment|/* Nothing to do */
return|return
name|E1000_SUCCESS
return|;
block|}
name|ledctl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|LEDCTL
argument_list|)
expr_stmt|;
name|hw
operator|->
name|ledctl_default
operator|=
name|ledctl
expr_stmt|;
name|hw
operator|->
name|ledctl_mode1
operator|=
name|hw
operator|->
name|ledctl_default
expr_stmt|;
name|hw
operator|->
name|ledctl_mode2
operator|=
name|hw
operator|->
name|ledctl_default
expr_stmt|;
if|if
condition|(
name|em_read_eeprom
argument_list|(
name|hw
argument_list|,
name|EEPROM_ID_LED_SETTINGS
argument_list|,
literal|1
argument_list|,
operator|&
name|eeprom_data
argument_list|)
operator|<
literal|0
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"EEPROM Read Error\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_EEPROM
return|;
block|}
if|if
condition|(
operator|(
name|eeprom_data
operator|==
name|ID_LED_RESERVED_0000
operator|)
operator|||
operator|(
name|eeprom_data
operator|==
name|ID_LED_RESERVED_FFFF
operator|)
condition|)
name|eeprom_data
operator|=
name|ID_LED_DEFAULT
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|temp
operator|=
operator|(
name|eeprom_data
operator|>>
operator|(
name|i
operator|<<
literal|2
operator|)
operator|)
operator|&
name|led_mask
expr_stmt|;
switch|switch
condition|(
name|temp
condition|)
block|{
case|case
name|ID_LED_ON1_DEF2
case|:
case|case
name|ID_LED_ON1_ON2
case|:
case|case
name|ID_LED_ON1_OFF2
case|:
name|hw
operator|->
name|ledctl_mode1
operator|&=
operator|~
operator|(
name|ledctl_mask
operator|<<
operator|(
name|i
operator|<<
literal|3
operator|)
operator|)
expr_stmt|;
name|hw
operator|->
name|ledctl_mode1
operator||=
name|ledctl_on
operator|<<
operator|(
name|i
operator|<<
literal|3
operator|)
expr_stmt|;
break|break;
case|case
name|ID_LED_OFF1_DEF2
case|:
case|case
name|ID_LED_OFF1_ON2
case|:
case|case
name|ID_LED_OFF1_OFF2
case|:
name|hw
operator|->
name|ledctl_mode1
operator|&=
operator|~
operator|(
name|ledctl_mask
operator|<<
operator|(
name|i
operator|<<
literal|3
operator|)
operator|)
expr_stmt|;
name|hw
operator|->
name|ledctl_mode1
operator||=
name|ledctl_off
operator|<<
operator|(
name|i
operator|<<
literal|3
operator|)
expr_stmt|;
break|break;
default|default:
comment|/* Do nothing */
break|break;
block|}
switch|switch
condition|(
name|temp
condition|)
block|{
case|case
name|ID_LED_DEF1_ON2
case|:
case|case
name|ID_LED_ON1_ON2
case|:
case|case
name|ID_LED_OFF1_ON2
case|:
name|hw
operator|->
name|ledctl_mode2
operator|&=
operator|~
operator|(
name|ledctl_mask
operator|<<
operator|(
name|i
operator|<<
literal|3
operator|)
operator|)
expr_stmt|;
name|hw
operator|->
name|ledctl_mode2
operator||=
name|ledctl_on
operator|<<
operator|(
name|i
operator|<<
literal|3
operator|)
expr_stmt|;
break|break;
case|case
name|ID_LED_DEF1_OFF2
case|:
case|case
name|ID_LED_ON1_OFF2
case|:
case|case
name|ID_LED_OFF1_OFF2
case|:
name|hw
operator|->
name|ledctl_mode2
operator|&=
operator|~
operator|(
name|ledctl_mask
operator|<<
operator|(
name|i
operator|<<
literal|3
operator|)
operator|)
expr_stmt|;
name|hw
operator|->
name|ledctl_mode2
operator||=
name|ledctl_off
operator|<<
operator|(
name|i
operator|<<
literal|3
operator|)
expr_stmt|;
break|break;
default|default:
comment|/* Do nothing */
break|break;
block|}
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Prepares SW controlable LED for use and saves the current state of the LED.  *  * hw - Struct containing variables accessed by shared code  *****************************************************************************/
end_comment

begin_function
name|int32_t
name|em_setup_led
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|uint32_t
name|ledctl
decl_stmt|;
name|int32_t
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_setup_led"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|hw
operator|->
name|mac_type
condition|)
block|{
case|case
name|em_82542_rev2_0
case|:
case|case
name|em_82542_rev2_1
case|:
case|case
name|em_82543
case|:
case|case
name|em_82544
case|:
comment|/* No setup necessary */
break|break;
case|case
name|em_82541
case|:
case|case
name|em_82547
case|:
case|case
name|em_82541_rev_2
case|:
case|case
name|em_82547_rev_2
case|:
comment|/* Turn off PHY Smart Power Down (if enabled) */
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_GMII_FIFO
argument_list|,
operator|&
name|hw
operator|->
name|phy_spd_default
argument_list|)
operator|)
condition|)
return|return
name|ret_val
return|;
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_GMII_FIFO
argument_list|,
call|(
name|uint16_t
call|)
argument_list|(
name|hw
operator|->
name|phy_spd_default
operator|&
operator|~
name|IGP01E1000_GMII_SPD
argument_list|)
argument_list|)
operator|)
condition|)
return|return
name|ret_val
return|;
comment|/* Fall Through */
default|default:
if|if
condition|(
name|hw
operator|->
name|media_type
operator|==
name|em_media_type_fiber
condition|)
block|{
name|ledctl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|LEDCTL
argument_list|)
expr_stmt|;
comment|/* Save current LEDCTL settings */
name|hw
operator|->
name|ledctl_default
operator|=
name|ledctl
expr_stmt|;
comment|/* Turn off LED0 */
name|ledctl
operator|&=
operator|~
operator|(
name|E1000_LEDCTL_LED0_IVRT
operator||
name|E1000_LEDCTL_LED0_BLINK
operator||
name|E1000_LEDCTL_LED0_MODE_MASK
operator|)
expr_stmt|;
name|ledctl
operator||=
operator|(
name|E1000_LEDCTL_MODE_LED_OFF
operator|<<
name|E1000_LEDCTL_LED0_MODE_SHIFT
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|LEDCTL
argument_list|,
name|ledctl
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|hw
operator|->
name|media_type
operator|==
name|em_media_type_copper
condition|)
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|LEDCTL
argument_list|,
name|hw
operator|->
name|ledctl_mode1
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Restores the saved state of the SW controlable LED.  *  * hw - Struct containing variables accessed by shared code  *****************************************************************************/
end_comment

begin_function
name|int32_t
name|em_cleanup_led
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|int32_t
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_cleanup_led"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|hw
operator|->
name|mac_type
condition|)
block|{
case|case
name|em_82542_rev2_0
case|:
case|case
name|em_82542_rev2_1
case|:
case|case
name|em_82543
case|:
case|case
name|em_82544
case|:
comment|/* No cleanup necessary */
break|break;
case|case
name|em_82541
case|:
case|case
name|em_82547
case|:
case|case
name|em_82541_rev_2
case|:
case|case
name|em_82547_rev_2
case|:
comment|/* Turn on PHY Smart Power Down (if previously enabled) */
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_GMII_FIFO
argument_list|,
name|hw
operator|->
name|phy_spd_default
argument_list|)
operator|)
condition|)
return|return
name|ret_val
return|;
comment|/* Fall Through */
default|default:
comment|/* Restore LEDCTL settings */
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|LEDCTL
argument_list|,
name|hw
operator|->
name|ledctl_default
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Turns on the software controllable LED  *  * hw - Struct containing variables accessed by shared code  *****************************************************************************/
end_comment

begin_function
name|int32_t
name|em_led_on
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|uint32_t
name|ctrl
init|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|)
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_led_on"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|hw
operator|->
name|mac_type
condition|)
block|{
case|case
name|em_82542_rev2_0
case|:
case|case
name|em_82542_rev2_1
case|:
case|case
name|em_82543
case|:
comment|/* Set SW Defineable Pin 0 to turn on the LED */
name|ctrl
operator||=
name|E1000_CTRL_SWDPIN0
expr_stmt|;
name|ctrl
operator||=
name|E1000_CTRL_SWDPIO0
expr_stmt|;
break|break;
case|case
name|em_82544
case|:
if|if
condition|(
name|hw
operator|->
name|media_type
operator|==
name|em_media_type_fiber
condition|)
block|{
comment|/* Set SW Defineable Pin 0 to turn on the LED */
name|ctrl
operator||=
name|E1000_CTRL_SWDPIN0
expr_stmt|;
name|ctrl
operator||=
name|E1000_CTRL_SWDPIO0
expr_stmt|;
block|}
else|else
block|{
comment|/* Clear SW Defineable Pin 0 to turn on the LED */
name|ctrl
operator|&=
operator|~
name|E1000_CTRL_SWDPIN0
expr_stmt|;
name|ctrl
operator||=
name|E1000_CTRL_SWDPIO0
expr_stmt|;
block|}
break|break;
default|default:
if|if
condition|(
name|hw
operator|->
name|media_type
operator|==
name|em_media_type_fiber
condition|)
block|{
comment|/* Clear SW Defineable Pin 0 to turn on the LED */
name|ctrl
operator|&=
operator|~
name|E1000_CTRL_SWDPIN0
expr_stmt|;
name|ctrl
operator||=
name|E1000_CTRL_SWDPIO0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|hw
operator|->
name|media_type
operator|==
name|em_media_type_copper
condition|)
block|{
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|LEDCTL
argument_list|,
name|hw
operator|->
name|ledctl_mode2
argument_list|)
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
break|break;
block|}
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Turns off the software controllable LED  *  * hw - Struct containing variables accessed by shared code  *****************************************************************************/
end_comment

begin_function
name|int32_t
name|em_led_off
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|uint32_t
name|ctrl
init|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|)
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_led_off"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|hw
operator|->
name|mac_type
condition|)
block|{
case|case
name|em_82542_rev2_0
case|:
case|case
name|em_82542_rev2_1
case|:
case|case
name|em_82543
case|:
comment|/* Clear SW Defineable Pin 0 to turn off the LED */
name|ctrl
operator|&=
operator|~
name|E1000_CTRL_SWDPIN0
expr_stmt|;
name|ctrl
operator||=
name|E1000_CTRL_SWDPIO0
expr_stmt|;
break|break;
case|case
name|em_82544
case|:
if|if
condition|(
name|hw
operator|->
name|media_type
operator|==
name|em_media_type_fiber
condition|)
block|{
comment|/* Clear SW Defineable Pin 0 to turn off the LED */
name|ctrl
operator|&=
operator|~
name|E1000_CTRL_SWDPIN0
expr_stmt|;
name|ctrl
operator||=
name|E1000_CTRL_SWDPIO0
expr_stmt|;
block|}
else|else
block|{
comment|/* Set SW Defineable Pin 0 to turn off the LED */
name|ctrl
operator||=
name|E1000_CTRL_SWDPIN0
expr_stmt|;
name|ctrl
operator||=
name|E1000_CTRL_SWDPIO0
expr_stmt|;
block|}
break|break;
default|default:
if|if
condition|(
name|hw
operator|->
name|media_type
operator|==
name|em_media_type_fiber
condition|)
block|{
comment|/* Set SW Defineable Pin 0 to turn off the LED */
name|ctrl
operator||=
name|E1000_CTRL_SWDPIN0
expr_stmt|;
name|ctrl
operator||=
name|E1000_CTRL_SWDPIO0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|hw
operator|->
name|media_type
operator|==
name|em_media_type_copper
condition|)
block|{
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|LEDCTL
argument_list|,
name|hw
operator|->
name|ledctl_mode1
argument_list|)
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
break|break;
block|}
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|CTRL
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Clears all hardware statistics counters.  *  * hw - Struct containing variables accessed by shared code  *****************************************************************************/
end_comment

begin_function
name|void
name|em_clear_hw_cntrs
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
specifier|volatile
name|uint32_t
name|temp
decl_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|CRCERRS
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|SYMERRS
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|MPC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|SCC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|ECOL
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|MCC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|LATECOL
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|COLC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|DC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|SEC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|RLEC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|XONRXC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|XONTXC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|XOFFRXC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|XOFFTXC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|FCRUC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|PRC64
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|PRC127
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|PRC255
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|PRC511
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|PRC1023
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|PRC1522
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|GPRC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|BPRC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|MPRC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|GPTC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|GORCL
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|GORCH
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|GOTCL
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|GOTCH
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|RNBC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|RUC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|RFC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|ROC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|RJC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|TORL
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|TORH
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|TOTL
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|TOTH
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|TPR
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|TPT
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|PTC64
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|PTC127
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|PTC255
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|PTC511
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|PTC1023
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|PTC1522
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|MPTC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|BPTC
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|<
name|em_82543
condition|)
return|return;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|ALGNERRC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|RXERRC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|TNCRS
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|CEXTERR
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|TSCTC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|TSCTFC
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|<=
name|em_82544
condition|)
return|return;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|MGTPRC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|MGTPDC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|MGTPTC
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Resets Adaptive IFS to its default state.  *  * hw - Struct containing variables accessed by shared code  *  * Call this after em_init_hw. You may override the IFS defaults by setting  * hw->ifs_params_forced to TRUE. However, you must initialize hw->  * current_ifs_val, ifs_min_val, ifs_max_val, ifs_step_size, and ifs_ratio  * before calling this function.  *****************************************************************************/
end_comment

begin_function
name|void
name|em_reset_adaptive
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"em_reset_adaptive"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|adaptive_ifs
condition|)
block|{
if|if
condition|(
operator|!
name|hw
operator|->
name|ifs_params_forced
condition|)
block|{
name|hw
operator|->
name|current_ifs_val
operator|=
literal|0
expr_stmt|;
name|hw
operator|->
name|ifs_min_val
operator|=
name|IFS_MIN
expr_stmt|;
name|hw
operator|->
name|ifs_max_val
operator|=
name|IFS_MAX
expr_stmt|;
name|hw
operator|->
name|ifs_step_size
operator|=
name|IFS_STEP
expr_stmt|;
name|hw
operator|->
name|ifs_ratio
operator|=
name|IFS_RATIO
expr_stmt|;
block|}
name|hw
operator|->
name|in_ifs_mode
operator|=
name|FALSE
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|AIT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DEBUGOUT
argument_list|(
literal|"Not in Adaptive IFS mode!\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/******************************************************************************  * Called during the callback/watchdog routine to update IFS value based on  * the ratio of transmits to collisions.  *  * hw - Struct containing variables accessed by shared code  * tx_packets - Number of transmits since last callback  * total_collisions - Number of collisions since last callback  *****************************************************************************/
end_comment

begin_function
name|void
name|em_update_adaptive
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"em_update_adaptive"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|adaptive_ifs
condition|)
block|{
if|if
condition|(
operator|(
name|hw
operator|->
name|collision_delta
operator|*
name|hw
operator|->
name|ifs_ratio
operator|)
operator|>
name|hw
operator|->
name|tx_packet_delta
condition|)
block|{
if|if
condition|(
name|hw
operator|->
name|tx_packet_delta
operator|>
name|MIN_NUM_XMITS
condition|)
block|{
name|hw
operator|->
name|in_ifs_mode
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|current_ifs_val
operator|<
name|hw
operator|->
name|ifs_max_val
condition|)
block|{
if|if
condition|(
name|hw
operator|->
name|current_ifs_val
operator|==
literal|0
condition|)
name|hw
operator|->
name|current_ifs_val
operator|=
name|hw
operator|->
name|ifs_min_val
expr_stmt|;
else|else
name|hw
operator|->
name|current_ifs_val
operator|+=
name|hw
operator|->
name|ifs_step_size
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|AIT
argument_list|,
name|hw
operator|->
name|current_ifs_val
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|hw
operator|->
name|in_ifs_mode
operator|&&
operator|(
name|hw
operator|->
name|tx_packet_delta
operator|<=
name|MIN_NUM_XMITS
operator|)
condition|)
block|{
name|hw
operator|->
name|current_ifs_val
operator|=
literal|0
expr_stmt|;
name|hw
operator|->
name|in_ifs_mode
operator|=
name|FALSE
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|AIT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|DEBUGOUT
argument_list|(
literal|"Not in Adaptive IFS mode!\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/******************************************************************************  * Adjusts the statistic counters when a frame is accepted by TBI_ACCEPT  *  * hw - Struct containing variables accessed by shared code  * frame_len - The length of the frame in question  * mac_addr - The Ethernet destination address of the frame in question  *****************************************************************************/
end_comment

begin_function
name|void
name|em_tbi_adjust_stats
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|struct
name|em_hw_stats
modifier|*
name|stats
parameter_list|,
name|uint32_t
name|frame_len
parameter_list|,
name|uint8_t
modifier|*
name|mac_addr
parameter_list|)
block|{
name|uint64_t
name|carry_bit
decl_stmt|;
comment|/* First adjust the frame length. */
name|frame_len
operator|--
expr_stmt|;
comment|/* We need to adjust the statistics counters, since the hardware      * counters overcount this packet as a CRC error and undercount      * the packet as a good packet      */
comment|/* This packet should not be counted as a CRC error.    */
name|stats
operator|->
name|crcerrs
operator|--
expr_stmt|;
comment|/* This packet does count as a Good Packet Received.    */
name|stats
operator|->
name|gprc
operator|++
expr_stmt|;
comment|/* Adjust the Good Octets received counters             */
name|carry_bit
operator|=
literal|0x80000000
operator|&
name|stats
operator|->
name|gorcl
expr_stmt|;
name|stats
operator|->
name|gorcl
operator|+=
name|frame_len
expr_stmt|;
comment|/* If the high bit of Gorcl (the low 32 bits of the Good Octets      * Received Count) was one before the addition,      * AND it is zero after, then we lost the carry out,      * need to add one to Gorch (Good Octets Received Count High).      * This could be simplified if all environments supported      * 64-bit integers.      */
if|if
condition|(
name|carry_bit
operator|&&
operator|(
operator|(
name|stats
operator|->
name|gorcl
operator|&
literal|0x80000000
operator|)
operator|==
literal|0
operator|)
condition|)
name|stats
operator|->
name|gorch
operator|++
expr_stmt|;
comment|/* Is this a broadcast or multicast?  Check broadcast first,      * since the test for a multicast frame will test positive on      * a broadcast frame.      */
if|if
condition|(
operator|(
name|mac_addr
index|[
literal|0
index|]
operator|==
operator|(
name|uint8_t
operator|)
literal|0xff
operator|)
operator|&&
operator|(
name|mac_addr
index|[
literal|1
index|]
operator|==
operator|(
name|uint8_t
operator|)
literal|0xff
operator|)
condition|)
comment|/* Broadcast packet */
name|stats
operator|->
name|bprc
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|mac_addr
operator|&
literal|0x01
condition|)
comment|/* Multicast packet */
name|stats
operator|->
name|mprc
operator|++
expr_stmt|;
if|if
condition|(
name|frame_len
operator|==
name|hw
operator|->
name|max_frame_size
condition|)
block|{
comment|/* In this case, the hardware has overcounted the number of          * oversize frames.          */
if|if
condition|(
name|stats
operator|->
name|roc
operator|>
literal|0
condition|)
name|stats
operator|->
name|roc
operator|--
expr_stmt|;
block|}
comment|/* Adjust the bin counters when the extra byte put the frame in the      * wrong bin. Remember that the frame_len was adjusted above.      */
if|if
condition|(
name|frame_len
operator|==
literal|64
condition|)
block|{
name|stats
operator|->
name|prc64
operator|++
expr_stmt|;
name|stats
operator|->
name|prc127
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|frame_len
operator|==
literal|127
condition|)
block|{
name|stats
operator|->
name|prc127
operator|++
expr_stmt|;
name|stats
operator|->
name|prc255
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|frame_len
operator|==
literal|255
condition|)
block|{
name|stats
operator|->
name|prc255
operator|++
expr_stmt|;
name|stats
operator|->
name|prc511
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|frame_len
operator|==
literal|511
condition|)
block|{
name|stats
operator|->
name|prc511
operator|++
expr_stmt|;
name|stats
operator|->
name|prc1023
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|frame_len
operator|==
literal|1023
condition|)
block|{
name|stats
operator|->
name|prc1023
operator|++
expr_stmt|;
name|stats
operator|->
name|prc1522
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|frame_len
operator|==
literal|1522
condition|)
block|{
name|stats
operator|->
name|prc1522
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/******************************************************************************  * Gets the current PCI bus type, speed, and width of the hardware  *  * hw - Struct containing variables accessed by shared code  *****************************************************************************/
end_comment

begin_function
name|void
name|em_get_bus_info
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|uint32_t
name|status
decl_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac_type
operator|<
name|em_82543
condition|)
block|{
name|hw
operator|->
name|bus_type
operator|=
name|em_bus_type_unknown
expr_stmt|;
name|hw
operator|->
name|bus_speed
operator|=
name|em_bus_speed_unknown
expr_stmt|;
name|hw
operator|->
name|bus_width
operator|=
name|em_bus_width_unknown
expr_stmt|;
return|return;
block|}
name|status
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|STATUS
argument_list|)
expr_stmt|;
name|hw
operator|->
name|bus_type
operator|=
operator|(
name|status
operator|&
name|E1000_STATUS_PCIX_MODE
operator|)
condition|?
name|em_bus_type_pcix
else|:
name|em_bus_type_pci
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|device_id
operator|==
name|E1000_DEV_ID_82546EB_QUAD_COPPER
condition|)
block|{
name|hw
operator|->
name|bus_speed
operator|=
operator|(
name|hw
operator|->
name|bus_type
operator|==
name|em_bus_type_pci
operator|)
condition|?
name|em_bus_speed_66
else|:
name|em_bus_speed_120
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|hw
operator|->
name|bus_type
operator|==
name|em_bus_type_pci
condition|)
block|{
name|hw
operator|->
name|bus_speed
operator|=
operator|(
name|status
operator|&
name|E1000_STATUS_PCI66
operator|)
condition|?
name|em_bus_speed_66
else|:
name|em_bus_speed_33
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|status
operator|&
name|E1000_STATUS_PCIX_SPEED
condition|)
block|{
case|case
name|E1000_STATUS_PCIX_SPEED_66
case|:
name|hw
operator|->
name|bus_speed
operator|=
name|em_bus_speed_66
expr_stmt|;
break|break;
case|case
name|E1000_STATUS_PCIX_SPEED_100
case|:
name|hw
operator|->
name|bus_speed
operator|=
name|em_bus_speed_100
expr_stmt|;
break|break;
case|case
name|E1000_STATUS_PCIX_SPEED_133
case|:
name|hw
operator|->
name|bus_speed
operator|=
name|em_bus_speed_133
expr_stmt|;
break|break;
default|default:
name|hw
operator|->
name|bus_speed
operator|=
name|em_bus_speed_reserved
expr_stmt|;
break|break;
block|}
block|}
name|hw
operator|->
name|bus_width
operator|=
operator|(
name|status
operator|&
name|E1000_STATUS_BUS64
operator|)
condition|?
name|em_bus_width_64
else|:
name|em_bus_width_32
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Reads a value from one of the devices registers using port I/O (as opposed  * memory mapped I/O). Only 82544 and newer devices support port I/O.  *  * hw - Struct containing variables accessed by shared code  * offset - offset to read from  *****************************************************************************/
end_comment

begin_function
name|uint32_t
name|em_read_reg_io
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint32_t
name|offset
parameter_list|)
block|{
name|uint32_t
name|io_addr
init|=
name|hw
operator|->
name|io_base
decl_stmt|;
name|uint32_t
name|io_data
init|=
name|hw
operator|->
name|io_base
operator|+
literal|4
decl_stmt|;
name|em_io_write
argument_list|(
name|hw
argument_list|,
name|io_addr
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|em_io_read
argument_list|(
name|hw
argument_list|,
name|io_data
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Writes a value to one of the devices registers using port I/O (as opposed to  * memory mapped I/O). Only 82544 and newer devices support port I/O.  *  * hw - Struct containing variables accessed by shared code  * offset - offset to write to  * value - value to write  *****************************************************************************/
end_comment

begin_function
name|void
name|em_write_reg_io
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint32_t
name|offset
parameter_list|,
name|uint32_t
name|value
parameter_list|)
block|{
name|uint32_t
name|io_addr
init|=
name|hw
operator|->
name|io_base
decl_stmt|;
name|uint32_t
name|io_data
init|=
name|hw
operator|->
name|io_base
operator|+
literal|4
decl_stmt|;
name|em_io_write
argument_list|(
name|hw
argument_list|,
name|io_addr
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|em_io_write
argument_list|(
name|hw
argument_list|,
name|io_data
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Estimates the cable length.  *  * hw - Struct containing variables accessed by shared code  * min_length - The estimated minimum length  * max_length - The estimated maximum length  *  * returns: - E1000_ERR_XXX  *            E1000_SUCCESS  *  * This function always returns a ranged length (minimum& maximum).  * So for M88 phy's, this function interprets the one value returned from the  * register to the minimum and maximum range.  * For IGP phy's, the function calculates the range by the AGC registers.  *****************************************************************************/
end_comment

begin_function
name|int32_t
name|em_get_cable_length
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint16_t
modifier|*
name|min_length
parameter_list|,
name|uint16_t
modifier|*
name|max_length
parameter_list|)
block|{
name|int32_t
name|ret_val
decl_stmt|;
name|uint16_t
name|agc_value
init|=
literal|0
decl_stmt|;
name|uint16_t
name|cur_agc
decl_stmt|,
name|min_agc
init|=
name|IGP01E1000_AGC_LENGTH_TABLE_SIZE
decl_stmt|;
name|uint16_t
name|i
decl_stmt|,
name|phy_data
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_get_cable_length"
argument_list|)
expr_stmt|;
operator|*
name|min_length
operator|=
operator|*
name|max_length
operator|=
literal|0
expr_stmt|;
comment|/* Use old method for Phy older than IGP */
if|if
condition|(
name|hw
operator|->
name|phy_type
operator|==
name|em_phy_m88
condition|)
block|{
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_SPEC_STATUS
argument_list|,
operator|&
name|phy_data
argument_list|)
operator|)
condition|)
return|return
name|ret_val
return|;
comment|/* Convert the enum value to ranged values */
switch|switch
condition|(
operator|(
name|phy_data
operator|&
name|M88E1000_PSSR_CABLE_LENGTH
operator|)
operator|>>
name|M88E1000_PSSR_CABLE_LENGTH_SHIFT
condition|)
block|{
case|case
name|em_cable_length_50
case|:
operator|*
name|min_length
operator|=
literal|0
expr_stmt|;
operator|*
name|max_length
operator|=
name|em_igp_cable_length_50
expr_stmt|;
break|break;
case|case
name|em_cable_length_50_80
case|:
operator|*
name|min_length
operator|=
name|em_igp_cable_length_50
expr_stmt|;
operator|*
name|max_length
operator|=
name|em_igp_cable_length_80
expr_stmt|;
break|break;
case|case
name|em_cable_length_80_110
case|:
operator|*
name|min_length
operator|=
name|em_igp_cable_length_80
expr_stmt|;
operator|*
name|max_length
operator|=
name|em_igp_cable_length_110
expr_stmt|;
break|break;
case|case
name|em_cable_length_110_140
case|:
operator|*
name|min_length
operator|=
name|em_igp_cable_length_110
expr_stmt|;
operator|*
name|max_length
operator|=
name|em_igp_cable_length_140
expr_stmt|;
break|break;
case|case
name|em_cable_length_140
case|:
operator|*
name|min_length
operator|=
name|em_igp_cable_length_140
expr_stmt|;
operator|*
name|max_length
operator|=
name|em_igp_cable_length_170
expr_stmt|;
break|break;
default|default:
return|return
operator|-
name|E1000_ERR_PHY
return|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|hw
operator|->
name|phy_type
operator|==
name|em_phy_igp
condition|)
block|{
comment|/* For IGP PHY */
name|uint16_t
name|agc_reg_array
index|[
name|IGP01E1000_PHY_CHANNEL_NUM
index|]
init|=
block|{
name|IGP01E1000_PHY_AGC_A
block|,
name|IGP01E1000_PHY_AGC_B
block|,
name|IGP01E1000_PHY_AGC_C
block|,
name|IGP01E1000_PHY_AGC_D
block|}
decl_stmt|;
comment|/* Read the AGC registers for all channels */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IGP01E1000_PHY_CHANNEL_NUM
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|agc_reg_array
index|[
name|i
index|]
argument_list|,
operator|&
name|phy_data
argument_list|)
operator|)
condition|)
return|return
name|ret_val
return|;
name|cur_agc
operator|=
name|phy_data
operator|>>
name|IGP01E1000_AGC_LENGTH_SHIFT
expr_stmt|;
comment|/* Array bound check. */
if|if
condition|(
operator|(
name|cur_agc
operator|>=
name|IGP01E1000_AGC_LENGTH_TABLE_SIZE
operator|-
literal|1
operator|)
operator|||
operator|(
name|cur_agc
operator|==
literal|0
operator|)
condition|)
return|return
operator|-
name|E1000_ERR_PHY
return|;
name|agc_value
operator|+=
name|cur_agc
expr_stmt|;
comment|/* Update minimal AGC value. */
if|if
condition|(
name|min_agc
operator|>
name|cur_agc
condition|)
name|min_agc
operator|=
name|cur_agc
expr_stmt|;
block|}
comment|/* Remove the minimal AGC result for length< 50m */
if|if
condition|(
name|agc_value
operator|<
name|IGP01E1000_PHY_CHANNEL_NUM
operator|*
name|em_igp_cable_length_50
condition|)
block|{
name|agc_value
operator|-=
name|min_agc
expr_stmt|;
comment|/* Get the average length of the remaining 3 channels */
name|agc_value
operator|/=
operator|(
name|IGP01E1000_PHY_CHANNEL_NUM
operator|-
literal|1
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Get the average length of all the 4 channels. */
name|agc_value
operator|/=
name|IGP01E1000_PHY_CHANNEL_NUM
expr_stmt|;
block|}
comment|/* Set the range of the calculated length. */
operator|*
name|min_length
operator|=
operator|(
operator|(
name|em_igp_cable_length_table
index|[
name|agc_value
index|]
operator|-
name|IGP01E1000_AGC_RANGE
operator|)
operator|>
literal|0
operator|)
condition|?
operator|(
name|em_igp_cable_length_table
index|[
name|agc_value
index|]
operator|-
name|IGP01E1000_AGC_RANGE
operator|)
else|:
literal|0
expr_stmt|;
operator|*
name|max_length
operator|=
name|em_igp_cable_length_table
index|[
name|agc_value
index|]
operator|+
name|IGP01E1000_AGC_RANGE
expr_stmt|;
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Check the cable polarity  *  * hw - Struct containing variables accessed by shared code  * polarity - output parameter : 0 - Polarity is not reversed  *                               1 - Polarity is reversed.  *  * returns: - E1000_ERR_XXX  *            E1000_SUCCESS  *  * For phy's older then IGP, this function simply reads the polarity bit in the  * Phy Status register.  For IGP phy's, this bit is valid only if link speed is  * 10 Mbps.  If the link speed is 100 Mbps there is no polarity so this bit will  * return 0.  If the link speed is 1000 Mbps the polarity status is in the  * IGP01E1000_PHY_PCS_INIT_REG.  *****************************************************************************/
end_comment

begin_function
name|int32_t
name|em_check_polarity
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|uint16_t
modifier|*
name|polarity
parameter_list|)
block|{
name|int32_t
name|ret_val
decl_stmt|;
name|uint16_t
name|phy_data
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_check_polarity"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|phy_type
operator|==
name|em_phy_m88
condition|)
block|{
comment|/* return the Polarity bit in the Status register. */
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_SPEC_STATUS
argument_list|,
operator|&
name|phy_data
argument_list|)
operator|)
condition|)
return|return
name|ret_val
return|;
operator|*
name|polarity
operator|=
operator|(
name|phy_data
operator|&
name|M88E1000_PSSR_REV_POLARITY
operator|)
operator|>>
name|M88E1000_PSSR_REV_POLARITY_SHIFT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|hw
operator|->
name|phy_type
operator|==
name|em_phy_igp
condition|)
block|{
comment|/* Read the Status register to check the speed */
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_STATUS
argument_list|,
operator|&
name|phy_data
argument_list|)
operator|)
condition|)
return|return
name|ret_val
return|;
comment|/* If speed is 1000 Mbps, must read the IGP01E1000_PHY_PCS_INIT_REG to          * find the polarity status */
if|if
condition|(
operator|(
name|phy_data
operator|&
name|IGP01E1000_PSSR_SPEED_MASK
operator|)
operator|==
name|IGP01E1000_PSSR_SPEED_1000MBPS
condition|)
block|{
comment|/* Read the GIG initialization PCS register (0x00B4) */
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PCS_INIT_REG
argument_list|,
operator|&
name|phy_data
argument_list|)
operator|)
condition|)
return|return
name|ret_val
return|;
comment|/* Check the polarity bits */
operator|*
name|polarity
operator|=
operator|(
name|phy_data
operator|&
name|IGP01E1000_PHY_POLARITY_MASK
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* For 10 Mbps, read the polarity bit in the status register. (for              * 100 Mbps this bit is always 0) */
operator|*
name|polarity
operator|=
name|phy_data
operator|&
name|IGP01E1000_PSSR_POLARITY_REVERSED
expr_stmt|;
block|}
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Check if Downshift occured  *  * hw - Struct containing variables accessed by shared code  * downshift - output parameter : 0 - No Downshift ocured.  *                                1 - Downshift ocured.  *  * returns: - E1000_ERR_XXX  *            E1000_SUCCESS   *  * For phy's older then IGP, this function reads the Downshift bit in the Phy  * Specific Status register.  For IGP phy's, it reads the Downgrade bit in the  * Link Health register.  In IGP this bit is latched high, so the driver must  * read it immediately after link is established.  *****************************************************************************/
end_comment

begin_function
name|int32_t
name|em_check_downshift
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|int32_t
name|ret_val
decl_stmt|;
name|uint16_t
name|phy_data
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_check_downshift"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|phy_type
operator|==
name|em_phy_igp
condition|)
block|{
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_LINK_HEALTH
argument_list|,
operator|&
name|phy_data
argument_list|)
operator|)
condition|)
return|return
name|ret_val
return|;
name|hw
operator|->
name|speed_downgraded
operator|=
operator|(
name|phy_data
operator|&
name|IGP01E1000_PLHR_SS_DOWNGRADE
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|hw
operator|->
name|phy_type
operator|==
name|em_phy_m88
condition|)
block|{
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_SPEC_STATUS
argument_list|,
operator|&
name|phy_data
argument_list|)
operator|)
condition|)
return|return
name|ret_val
return|;
name|hw
operator|->
name|speed_downgraded
operator|=
operator|(
name|phy_data
operator|&
name|M88E1000_PSSR_DOWNSHIFT
operator|)
operator|>>
name|M88E1000_PSSR_DOWNSHIFT_SHIFT
expr_stmt|;
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************  *  * 82541_rev_2& 82547_rev_2 have the capability to configure the DSP when a  * gigabit link is achieved to improve link quality.  *  * hw: Struct containing variables accessed by shared code  *  * returns: - E1000_ERR_PHY if fail to read/write the PHY  *            E1000_SUCCESS at any other case.  *  ****************************************************************************/
end_comment

begin_function
name|int32_t
name|em_config_dsp_after_link_change
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|boolean_t
name|link_up
parameter_list|)
block|{
name|int32_t
name|ret_val
decl_stmt|;
name|uint16_t
name|phy_data
decl_stmt|,
name|speed
decl_stmt|,
name|duplex
decl_stmt|,
name|i
decl_stmt|;
name|uint16_t
name|dsp_reg_array
index|[
name|IGP01E1000_PHY_CHANNEL_NUM
index|]
init|=
block|{
name|IGP01E1000_PHY_AGC_PARAM_A
block|,
name|IGP01E1000_PHY_AGC_PARAM_B
block|,
name|IGP01E1000_PHY_AGC_PARAM_C
block|,
name|IGP01E1000_PHY_AGC_PARAM_D
block|}
decl_stmt|;
name|uint16_t
name|min_length
decl_stmt|,
name|max_length
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_config_dsp_after_link_change"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|phy_type
operator|!=
name|em_phy_igp
condition|)
return|return
name|E1000_SUCCESS
return|;
if|if
condition|(
name|link_up
condition|)
block|{
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_get_speed_and_duplex
argument_list|(
name|hw
argument_list|,
operator|&
name|speed
argument_list|,
operator|&
name|duplex
argument_list|)
operator|)
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Error getting link speed and duplex\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
if|if
condition|(
name|speed
operator|==
name|SPEED_1000
condition|)
block|{
name|em_get_cable_length
argument_list|(
name|hw
argument_list|,
operator|&
name|min_length
argument_list|,
operator|&
name|max_length
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|hw
operator|->
name|dsp_config_state
operator|==
name|em_dsp_config_enabled
operator|)
operator|&&
name|min_length
operator|>=
name|em_igp_cable_length_50
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IGP01E1000_PHY_CHANNEL_NUM
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|dsp_reg_array
index|[
name|i
index|]
argument_list|,
operator|&
name|phy_data
argument_list|)
operator|)
condition|)
return|return
name|ret_val
return|;
name|phy_data
operator|&=
operator|~
name|IGP01E1000_PHY_EDAC_MU_INDEX
expr_stmt|;
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|dsp_reg_array
index|[
name|i
index|]
argument_list|,
name|phy_data
argument_list|)
operator|)
condition|)
return|return
name|ret_val
return|;
block|}
name|hw
operator|->
name|dsp_config_state
operator|=
name|em_dsp_config_activated
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|hw
operator|->
name|ffe_config_state
operator|==
name|em_ffe_config_enabled
operator|)
operator|&&
operator|(
name|min_length
operator|<
name|em_igp_cable_length_50
operator|)
condition|)
block|{
name|uint16_t
name|ffe_idle_err_timeout
init|=
name|FFE_IDLE_ERR_COUNT_TIMEOUT_20
decl_stmt|;
name|uint32_t
name|idle_errs
init|=
literal|0
decl_stmt|;
comment|/* clear previous idle error counts */
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_1000T_STATUS
argument_list|,
operator|&
name|phy_data
argument_list|)
operator|)
condition|)
return|return
name|ret_val
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ffe_idle_err_timeout
condition|;
name|i
operator|++
control|)
block|{
name|usec_delay
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_1000T_STATUS
argument_list|,
operator|&
name|phy_data
argument_list|)
operator|)
condition|)
return|return
name|ret_val
return|;
name|idle_errs
operator|+=
operator|(
name|phy_data
operator|&
name|SR_1000T_IDLE_ERROR_CNT
operator|)
expr_stmt|;
if|if
condition|(
name|idle_errs
operator|>
name|SR_1000T_PHY_EXCESSIVE_IDLE_ERR_COUNT
condition|)
block|{
name|hw
operator|->
name|ffe_config_state
operator|=
name|em_ffe_config_active
expr_stmt|;
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_DSP_FFE
argument_list|,
name|IGP01E1000_PHY_DSP_FFE_CM_CP
argument_list|)
operator|)
condition|)
return|return
name|ret_val
return|;
break|break;
block|}
if|if
condition|(
name|idle_errs
condition|)
name|ffe_idle_err_timeout
operator|=
name|FFE_IDLE_ERR_COUNT_TIMEOUT_100
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|hw
operator|->
name|dsp_config_state
operator|==
name|em_dsp_config_activated
condition|)
block|{
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
literal|0x0000
argument_list|,
name|IGP01E1000_IEEE_FORCE_GIGA
argument_list|)
operator|)
condition|)
return|return
name|ret_val
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IGP01E1000_PHY_CHANNEL_NUM
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|dsp_reg_array
index|[
name|i
index|]
argument_list|,
operator|&
name|phy_data
argument_list|)
operator|)
condition|)
return|return
name|ret_val
return|;
name|phy_data
operator|&=
operator|~
name|IGP01E1000_PHY_EDAC_MU_INDEX
expr_stmt|;
name|phy_data
operator||=
name|IGP01E1000_PHY_EDAC_SIGN_EXT_9_BITS
expr_stmt|;
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|dsp_reg_array
index|[
name|i
index|]
argument_list|,
name|phy_data
argument_list|)
operator|)
condition|)
return|return
name|ret_val
return|;
block|}
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
literal|0x0000
argument_list|,
name|IGP01E1000_IEEE_RESTART_AUTONEG
argument_list|)
operator|)
condition|)
return|return
name|ret_val
return|;
name|hw
operator|->
name|dsp_config_state
operator|=
name|em_dsp_config_enabled
expr_stmt|;
block|}
if|if
condition|(
name|hw
operator|->
name|ffe_config_state
operator|==
name|em_ffe_config_active
condition|)
block|{
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
literal|0x0000
argument_list|,
name|IGP01E1000_IEEE_FORCE_GIGA
argument_list|)
operator|)
condition|)
return|return
name|ret_val
return|;
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_DSP_FFE
argument_list|,
name|IGP01E1000_PHY_DSP_FFE_DEFAULT
argument_list|)
operator|)
condition|)
return|return
name|ret_val
return|;
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
literal|0x0000
argument_list|,
name|IGP01E1000_IEEE_RESTART_AUTONEG
argument_list|)
operator|)
condition|)
return|return
name|ret_val
return|;
name|hw
operator|->
name|ffe_config_state
operator|=
name|em_ffe_config_enabled
expr_stmt|;
block|}
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/***************************************************************************  *  * Workaround for the 82547 long TTL on noisy 100HD hubs.  *  * This function, specific to 82547 hardware only, needs to be called every  * second.  It checks if a parallel detect fault has occurred.  If a fault  * occurred, disable/enable the DSP reset mechanism up to 5 times (once per  * second).  If link is established, stop the workaround and ensure the DSP  * reset is enabled.  *  * hw: Struct containing variables accessed by shared code  *  * returns: - E1000_ERR_PHY if fail to read/write the PHY  *            E1000_SUCCESS in any other case  *  ****************************************************************************/
end_comment

begin_function
name|int32_t
name|em_igp_ttl_workaround
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|int32_t
name|ret_val
decl_stmt|;
name|uint16_t
name|phy_data
init|=
literal|0
decl_stmt|;
name|uint16_t
name|dsp_value
init|=
name|DSP_RESET_ENABLE
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|hw
operator|->
name|mac_type
operator|!=
name|em_82541
operator|)
operator|&&
operator|(
name|hw
operator|->
name|mac_type
operator|!=
name|em_82547
operator|)
operator|)
operator|||
operator|(
operator|!
name|hw
operator|->
name|ttl_wa_activation
operator|)
condition|)
block|{
return|return
name|E1000_SUCCESS
return|;
block|}
comment|/* Check for link first */
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_STATUS
argument_list|,
operator|&
name|phy_data
argument_list|)
operator|)
condition|)
return|return
name|ret_val
return|;
if|if
condition|(
name|phy_data
operator|&
name|MII_SR_LINK_STATUS
condition|)
block|{
comment|/* If link is established during the workaround, the DSP mechanism must          * be enabled. */
if|if
condition|(
name|hw
operator|->
name|dsp_reset_counter
condition|)
block|{
name|hw
operator|->
name|dsp_reset_counter
operator|=
literal|0
expr_stmt|;
name|dsp_value
operator|=
name|DSP_RESET_ENABLE
expr_stmt|;
block|}
else|else
return|return
name|E1000_SUCCESS
return|;
block|}
else|else
block|{
if|if
condition|(
name|hw
operator|->
name|dsp_reset_counter
operator|==
literal|0
condition|)
block|{
comment|/* Workaround not activated, check if it needs activation */
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_AUTONEG_EXP
argument_list|,
operator|&
name|phy_data
argument_list|)
operator|)
condition|)
return|return
name|ret_val
return|;
comment|/* Activate the workaround if there was a parallel detect fault */
if|if
condition|(
name|phy_data
operator|&
name|NWAY_ER_PAR_DETECT_FAULT
condition|)
name|hw
operator|->
name|dsp_reset_counter
operator|++
expr_stmt|;
else|else
return|return
name|E1000_SUCCESS
return|;
block|}
if|if
condition|(
name|hw
operator|->
name|dsp_reset_counter
condition|)
block|{
comment|/* After 5 times, stop the workaround */
if|if
condition|(
name|hw
operator|->
name|dsp_reset_counter
operator|>
name|E1000_MAX_DSP_RESETS
condition|)
block|{
name|hw
operator|->
name|dsp_reset_counter
operator|=
literal|0
expr_stmt|;
name|dsp_value
operator|=
name|DSP_RESET_ENABLE
expr_stmt|;
block|}
else|else
block|{
name|dsp_value
operator|=
operator|(
name|hw
operator|->
name|dsp_reset_counter
operator|&
literal|1
operator|)
condition|?
name|DSP_RESET_DISABLE
else|:
name|DSP_RESET_ENABLE
expr_stmt|;
name|hw
operator|->
name|dsp_reset_counter
operator|++
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_DSP_RESET
argument_list|,
name|dsp_value
argument_list|)
operator|)
condition|)
return|return
name|ret_val
return|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************  *  * This function sets the lplu state according to the active flag.  When  * activating lplu this function also disables smart speed and vise versa.  * lplu will not be activated unless the device autonegotiation advertisment  * meets standards of either 10 or 10/100 or 10/100/1000 at all duplexes.  * hw: Struct containing variables accessed by shared code  * active - true to enable lplu false to disable lplu.  *  * returns: - E1000_ERR_PHY if fail to read/write the PHY  *            E1000_SUCCESS at any other case.  *  ****************************************************************************/
end_comment

begin_function
name|int32_t
name|em_set_d3_lplu_state
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|,
name|boolean_t
name|active
parameter_list|)
block|{
name|int32_t
name|ret_val
decl_stmt|;
name|uint16_t
name|phy_data
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_set_d3_lplu_state"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|hw
operator|->
name|mac_type
operator|==
name|em_82541_rev_2
operator|)
operator|||
operator|(
name|hw
operator|->
name|mac_type
operator|==
name|em_82547_rev_2
operator|)
operator|)
condition|)
return|return
name|E1000_SUCCESS
return|;
comment|/* During driver activity LPLU should not be used or it will attain link      * from the lowest speeds starting from 10Mbps. The capability is used for      * Dx transitions and states */
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_GMII_FIFO
argument_list|,
operator|&
name|phy_data
argument_list|)
operator|)
condition|)
return|return
name|ret_val
return|;
if|if
condition|(
operator|!
name|active
condition|)
block|{
name|phy_data
operator|&=
operator|~
name|IGP01E1000_GMII_FLEX_SPD
expr_stmt|;
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_GMII_FIFO
argument_list|,
name|phy_data
argument_list|)
operator|)
condition|)
return|return
name|ret_val
return|;
comment|/* LPLU and SmartSpeed are mutually exclusive.  LPLU is used during          * Dx states where the power conservation is most important.  During          * driver activity we should enable SmartSpeed, so performance is          * maintained. */
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_CONFIG
argument_list|,
operator|&
name|phy_data
argument_list|)
operator|)
condition|)
return|return
name|ret_val
return|;
name|phy_data
operator||=
name|IGP01E1000_PSCFR_SMART_SPEED
expr_stmt|;
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_CONFIG
argument_list|,
name|phy_data
argument_list|)
operator|)
condition|)
return|return
name|ret_val
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|hw
operator|->
name|autoneg_advertised
operator|==
name|AUTONEG_ADVERTISE_SPEED_DEFAULT
operator|)
operator|||
operator|(
name|hw
operator|->
name|autoneg_advertised
operator|==
name|AUTONEG_ADVERTISE_10_ALL
operator|)
operator|||
operator|(
name|hw
operator|->
name|autoneg_advertised
operator|==
name|AUTONEG_ADVERTISE_10_100_ALL
operator|)
condition|)
block|{
name|phy_data
operator||=
name|IGP01E1000_GMII_FLEX_SPD
expr_stmt|;
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_GMII_FIFO
argument_list|,
name|phy_data
argument_list|)
operator|)
condition|)
return|return
name|ret_val
return|;
comment|/* When LPLU is enabled we should disable SmartSpeed */
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_CONFIG
argument_list|,
operator|&
name|phy_data
argument_list|)
operator|)
condition|)
return|return
name|ret_val
return|;
name|phy_data
operator|&=
operator|~
name|IGP01E1000_PSCFR_SMART_SPEED
expr_stmt|;
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_CONFIG
argument_list|,
name|phy_data
argument_list|)
operator|)
condition|)
return|return
name|ret_val
return|;
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Change VCO speed register to improve Bit Error Rate performance of SERDES.  *  * hw - Struct containing variables accessed by shared code  *****************************************************************************/
end_comment

begin_function
specifier|static
name|int32_t
name|em_set_vco_speed
parameter_list|(
name|struct
name|em_hw
modifier|*
name|hw
parameter_list|)
block|{
name|int32_t
name|ret_val
decl_stmt|;
name|uint16_t
name|default_page
init|=
literal|0
decl_stmt|;
name|uint16_t
name|phy_data
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_set_vco_speed"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|hw
operator|->
name|mac_type
condition|)
block|{
case|case
name|em_82545_rev_3
case|:
case|case
name|em_82546_rev_3
case|:
break|break;
default|default:
return|return
name|E1000_SUCCESS
return|;
block|}
comment|/* Set PHY register 30, page 5, bit 8 to 0 */
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_PAGE_SELECT
argument_list|,
operator|&
name|default_page
argument_list|)
operator|)
condition|)
return|return
name|ret_val
return|;
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_PAGE_SELECT
argument_list|,
literal|0x0005
argument_list|)
operator|)
condition|)
return|return
name|ret_val
return|;
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_GEN_CONTROL
argument_list|,
operator|&
name|phy_data
argument_list|)
operator|)
condition|)
return|return
name|ret_val
return|;
name|phy_data
operator|&=
operator|~
name|M88E1000_PHY_VCO_REG_BIT8
expr_stmt|;
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_GEN_CONTROL
argument_list|,
name|phy_data
argument_list|)
operator|)
condition|)
return|return
name|ret_val
return|;
comment|/* Set PHY register 30, page 4, bit 11 to 1 */
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_PAGE_SELECT
argument_list|,
literal|0x0004
argument_list|)
operator|)
condition|)
return|return
name|ret_val
return|;
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_GEN_CONTROL
argument_list|,
operator|&
name|phy_data
argument_list|)
operator|)
condition|)
return|return
name|ret_val
return|;
name|phy_data
operator||=
name|M88E1000_PHY_VCO_REG_BIT11
expr_stmt|;
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_GEN_CONTROL
argument_list|,
name|phy_data
argument_list|)
operator|)
condition|)
return|return
name|ret_val
return|;
if|if
condition|(
operator|(
name|ret_val
operator|=
name|em_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_PAGE_SELECT
argument_list|,
name|default_page
argument_list|)
operator|)
condition|)
return|return
name|ret_val
return|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

end_unit

