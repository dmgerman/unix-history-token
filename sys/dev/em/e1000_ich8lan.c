begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*******************************************************************************    Copyright (c) 2001-2007, Intel Corporation    All rights reserved.      Redistribution and use in source and binary forms, with or without    modification, are permitted provided that the following conditions are met:       1. Redistributions of source code must retain the above copyright notice,        this list of conditions and the following disclaimer.       2. Redistributions in binary form must reproduce the above copyright        notice, this list of conditions and the following disclaimer in the        documentation and/or other materials provided with the distribution.       3. Neither the name of the Intel Corporation nor the names of its        contributors may be used to endorse or promote products derived from        this software without specific prior written permission.      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE    ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR    CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF    SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN    CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)    ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE   POSSIBILITY OF SUCH DAMAGE.  *******************************************************************************/
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* e1000_ich8lan  * e1000_ich9lan  */
end_comment

begin_include
include|#
directive|include
file|"e1000_ich8lan.h"
end_include

begin_function_decl
name|void
name|e1000_init_function_pointers_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|s32
name|e1000_init_phy_params_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|s32
name|e1000_init_nvm_params_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|s32
name|e1000_init_mac_params_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|s32
name|e1000_acquire_swflag_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|void
name|e1000_release_swflag_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|boolean_t
name|e1000_check_mng_mode_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|s32
name|e1000_check_polarity_ife_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|s32
name|e1000_check_reset_block_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|s32
name|e1000_phy_force_speed_duplex_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|s32
name|e1000_phy_hw_reset_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|s32
name|e1000_get_phy_info_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|s32
name|e1000_set_d0_lplu_state_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|boolean_t
name|active
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|s32
name|e1000_set_d3_lplu_state_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|boolean_t
name|active
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|s32
name|e1000_read_nvm_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|offset
parameter_list|,
name|u16
name|words
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|s32
name|e1000_write_nvm_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|offset
parameter_list|,
name|u16
name|words
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|s32
name|e1000_validate_nvm_checksum_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|s32
name|e1000_update_nvm_checksum_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|s32
name|e1000_valid_led_default_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|s32
name|e1000_get_bus_info_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|s32
name|e1000_reset_hw_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|s32
name|e1000_init_hw_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|s32
name|e1000_setup_link_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|s32
name|e1000_setup_copper_link_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|s32
name|e1000_get_link_up_info_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
modifier|*
name|speed
parameter_list|,
name|u16
modifier|*
name|duplex
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|s32
name|e1000_cleanup_led_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|s32
name|e1000_led_on_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|s32
name|e1000_led_off_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|void
name|e1000_clear_hw_cntrs_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|s32
name|e1000_erase_flash_bank_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|bank
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_flash_cycle_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|timeout
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_flash_cycle_init_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_get_phy_info_ife_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|e1000_initialize_hw_bits_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_kmrn_lock_loss_workaround_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_read_flash_data_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u8
name|size
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|s32
name|e1000_read_flash_word_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_retry_write_flash_byte_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u8
name|byte
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|s32
name|e1000_write_flash_byte_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u8
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_write_flash_data_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u8
name|size
parameter_list|,
name|u16
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|s32
name|e1000_get_cfg_done_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* ICH GbE Flash Hardware Sequencing Flash Status Register bit breakdown */
end_comment

begin_comment
comment|/* Offset 04h HSFSTS */
end_comment

begin_union
union|union
name|ich8_hws_flash_status
block|{
struct|struct
name|ich8_hsfsts
block|{
name|u16
name|flcdone
range|:
literal|1
decl_stmt|;
comment|/* bit 0 Flash Cycle Done */
name|u16
name|flcerr
range|:
literal|1
decl_stmt|;
comment|/* bit 1 Flash Cycle Error */
name|u16
name|dael
range|:
literal|1
decl_stmt|;
comment|/* bit 2 Direct Access error Log */
name|u16
name|berasesz
range|:
literal|2
decl_stmt|;
comment|/* bit 4:3 Sector Erase Size */
name|u16
name|flcinprog
range|:
literal|1
decl_stmt|;
comment|/* bit 5 flash cycle in Progress */
name|u16
name|reserved1
range|:
literal|2
decl_stmt|;
comment|/* bit 13:6 Reserved */
name|u16
name|reserved2
range|:
literal|6
decl_stmt|;
comment|/* bit 13:6 Reserved */
name|u16
name|fldesvalid
range|:
literal|1
decl_stmt|;
comment|/* bit 14 Flash Descriptor Valid */
name|u16
name|flockdn
range|:
literal|1
decl_stmt|;
comment|/* bit 15 Flash Config Lock-Down */
block|}
name|hsf_status
struct|;
name|u16
name|regval
decl_stmt|;
block|}
union|;
end_union

begin_comment
comment|/* ICH GbE Flash Hardware Sequencing Flash control Register bit breakdown */
end_comment

begin_comment
comment|/* Offset 06h FLCTL */
end_comment

begin_union
union|union
name|ich8_hws_flash_ctrl
block|{
struct|struct
name|ich8_hsflctl
block|{
name|u16
name|flcgo
range|:
literal|1
decl_stmt|;
comment|/* 0 Flash Cycle Go */
name|u16
name|flcycle
range|:
literal|2
decl_stmt|;
comment|/* 2:1 Flash Cycle */
name|u16
name|reserved
range|:
literal|5
decl_stmt|;
comment|/* 7:3 Reserved  */
name|u16
name|fldbcount
range|:
literal|2
decl_stmt|;
comment|/* 9:8 Flash Data Byte Count */
name|u16
name|flockdn
range|:
literal|6
decl_stmt|;
comment|/* 15:10 Reserved */
block|}
name|hsf_ctrl
struct|;
name|u16
name|regval
decl_stmt|;
block|}
union|;
end_union

begin_comment
comment|/* ICH Flash Region Access Permissions */
end_comment

begin_union
union|union
name|ich8_hws_flash_regacc
block|{
struct|struct
name|ich8_flracc
block|{
name|u32
name|grra
range|:
literal|8
decl_stmt|;
comment|/* 0:7 GbE region Read Access */
name|u32
name|grwa
range|:
literal|8
decl_stmt|;
comment|/* 8:15 GbE region Write Access */
name|u32
name|gmrag
range|:
literal|8
decl_stmt|;
comment|/* 23:16 GbE Master Read Access Grant */
name|u32
name|gmwag
range|:
literal|8
decl_stmt|;
comment|/* 31:24 GbE Master Write Access Grant */
block|}
name|hsf_flregacc
struct|;
name|u16
name|regval
decl_stmt|;
block|}
union|;
end_union

begin_struct
struct|struct
name|e1000_shadow_ram
block|{
name|u16
name|value
decl_stmt|;
name|boolean_t
name|modified
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|e1000_dev_spec_ich8lan
block|{
name|boolean_t
name|kmrn_lock_loss_workaround_enabled
decl_stmt|;
name|struct
name|e1000_shadow_ram
name|shadow_ram
index|[
name|E1000_SHADOW_RAM_WORDS
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/**  *  e1000_init_phy_params_ich8lan - Initialize PHY function pointers  *  @hw - pointer to the HW structure  *  *  Initialize family-specific PHY parameters and function pointers.  **/
end_comment

begin_function
name|STATIC
name|s32
name|e1000_init_phy_params_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|struct
name|e1000_functions
modifier|*
name|func
init|=
operator|&
name|hw
operator|->
name|func
decl_stmt|;
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_init_phy_params_ich8lan"
argument_list|)
expr_stmt|;
name|phy
operator|->
name|addr
operator|=
literal|1
expr_stmt|;
name|phy
operator|->
name|reset_delay_us
operator|=
literal|100
expr_stmt|;
name|func
operator|->
name|acquire_phy
operator|=
name|e1000_acquire_swflag_ich8lan
expr_stmt|;
name|func
operator|->
name|check_polarity
operator|=
name|e1000_check_polarity_ife_ich8lan
expr_stmt|;
name|func
operator|->
name|check_reset_block
operator|=
name|e1000_check_reset_block_ich8lan
expr_stmt|;
name|func
operator|->
name|force_speed_duplex
operator|=
name|e1000_phy_force_speed_duplex_ich8lan
expr_stmt|;
name|func
operator|->
name|get_cable_length
operator|=
name|e1000_get_cable_length_igp_2
expr_stmt|;
name|func
operator|->
name|get_cfg_done
operator|=
name|e1000_get_cfg_done_ich8lan
expr_stmt|;
name|func
operator|->
name|get_phy_info
operator|=
name|e1000_get_phy_info_ich8lan
expr_stmt|;
name|func
operator|->
name|read_phy_reg
operator|=
name|e1000_read_phy_reg_igp
expr_stmt|;
name|func
operator|->
name|release_phy
operator|=
name|e1000_release_swflag_ich8lan
expr_stmt|;
name|func
operator|->
name|reset_phy
operator|=
name|e1000_phy_hw_reset_ich8lan
expr_stmt|;
name|func
operator|->
name|set_d0_lplu_state
operator|=
name|e1000_set_d0_lplu_state_ich8lan
expr_stmt|;
name|func
operator|->
name|set_d3_lplu_state
operator|=
name|e1000_set_d3_lplu_state_ich8lan
expr_stmt|;
name|func
operator|->
name|write_phy_reg
operator|=
name|e1000_write_phy_reg_igp
expr_stmt|;
name|ret_val
operator|=
name|e1000_get_phy_id
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
comment|/* Verify phy id */
switch|switch
condition|(
name|phy
operator|->
name|id
condition|)
block|{
case|case
name|IGP03E1000_E_PHY_ID
case|:
name|phy
operator|->
name|type
operator|=
name|e1000_phy_igp_3
expr_stmt|;
name|phy
operator|->
name|autoneg_mask
operator|=
name|AUTONEG_ADVERTISE_SPEED_DEFAULT
expr_stmt|;
break|break;
case|case
name|IFE_E_PHY_ID
case|:
case|case
name|IFE_PLUS_E_PHY_ID
case|:
case|case
name|IFE_C_E_PHY_ID
case|:
name|phy
operator|->
name|type
operator|=
name|e1000_phy_ife
expr_stmt|;
name|phy
operator|->
name|autoneg_mask
operator|=
name|E1000_ALL_NOT_GIG
expr_stmt|;
break|break;
default|default:
name|ret_val
operator|=
operator|-
name|E1000_ERR_PHY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_init_nvm_params_ich8lan - Initialize NVM function pointers  *  @hw - pointer to the HW structure  *  *  Initialize family-specific NVM parameters and function  *  pointers.  **/
end_comment

begin_function
name|STATIC
name|s32
name|e1000_init_nvm_params_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_nvm_info
modifier|*
name|nvm
init|=
operator|&
name|hw
operator|->
name|nvm
decl_stmt|;
name|struct
name|e1000_functions
modifier|*
name|func
init|=
operator|&
name|hw
operator|->
name|func
decl_stmt|;
name|struct
name|e1000_dev_spec_ich8lan
modifier|*
name|dev_spec
decl_stmt|;
name|u32
name|gfpreg
decl_stmt|,
name|sector_base_addr
decl_stmt|,
name|sector_end_addr
decl_stmt|;
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|u16
name|i
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_init_nvm_params_ich8lan"
argument_list|)
expr_stmt|;
comment|/* Can't read flash registers if the register set isn't mapped. 	 */
if|if
condition|(
operator|!
name|hw
operator|->
name|flash_address
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"ERROR: Flash registers not mapped\n"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
operator|-
name|E1000_ERR_CONFIG
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|nvm
operator|->
name|type
operator|=
name|e1000_nvm_flash_sw
expr_stmt|;
name|gfpreg
operator|=
name|E1000_READ_FLASH_REG
argument_list|(
name|hw
argument_list|,
name|ICH_FLASH_GFPREG
argument_list|)
expr_stmt|;
comment|/* sector_X_addr is a "sector"-aligned address (4096 bytes) 	 * Add 1 to sector_end_addr since this sector is included in 	 * the overall size. */
name|sector_base_addr
operator|=
name|gfpreg
operator|&
name|FLASH_GFPREG_BASE_MASK
expr_stmt|;
name|sector_end_addr
operator|=
operator|(
operator|(
name|gfpreg
operator|>>
literal|16
operator|)
operator|&
name|FLASH_GFPREG_BASE_MASK
operator|)
operator|+
literal|1
expr_stmt|;
comment|/* flash_base_addr is byte-aligned */
name|nvm
operator|->
name|flash_base_addr
operator|=
name|sector_base_addr
operator|<<
name|FLASH_SECTOR_ADDR_SHIFT
expr_stmt|;
comment|/* find total size of the NVM, then cut in half since the total 	 * size represents two separate NVM banks. */
name|nvm
operator|->
name|flash_bank_size
operator|=
operator|(
name|sector_end_addr
operator|-
name|sector_base_addr
operator|)
operator|<<
name|FLASH_SECTOR_ADDR_SHIFT
expr_stmt|;
name|nvm
operator|->
name|flash_bank_size
operator|/=
literal|2
expr_stmt|;
comment|/* Adjust to word count */
name|nvm
operator|->
name|flash_bank_size
operator|/=
sizeof|sizeof
argument_list|(
name|u16
argument_list|)
expr_stmt|;
name|nvm
operator|->
name|word_size
operator|=
name|E1000_SHADOW_RAM_WORDS
expr_stmt|;
name|dev_spec
operator|=
operator|(
expr|struct
name|e1000_dev_spec_ich8lan
operator|*
operator|)
name|hw
operator|->
name|dev_spec
expr_stmt|;
if|if
condition|(
name|dev_spec
operator|==
name|NULL
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"dev_spec pointer is set to NULL.\n"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
operator|-
name|E1000_ERR_CONFIG
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Clear shadow ram */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nvm
operator|->
name|word_size
condition|;
name|i
operator|++
control|)
block|{
name|dev_spec
operator|->
name|shadow_ram
index|[
name|i
index|]
operator|.
name|modified
operator|=
name|FALSE
expr_stmt|;
name|dev_spec
operator|->
name|shadow_ram
index|[
name|i
index|]
operator|.
name|value
operator|=
literal|0xFFFF
expr_stmt|;
block|}
comment|/* Function Pointers */
name|func
operator|->
name|acquire_nvm
operator|=
name|e1000_acquire_swflag_ich8lan
expr_stmt|;
name|func
operator|->
name|read_nvm
operator|=
name|e1000_read_nvm_ich8lan
expr_stmt|;
name|func
operator|->
name|release_nvm
operator|=
name|e1000_release_swflag_ich8lan
expr_stmt|;
name|func
operator|->
name|update_nvm
operator|=
name|e1000_update_nvm_checksum_ich8lan
expr_stmt|;
name|func
operator|->
name|valid_led_default
operator|=
name|e1000_valid_led_default_ich8lan
expr_stmt|;
name|func
operator|->
name|validate_nvm
operator|=
name|e1000_validate_nvm_checksum_ich8lan
expr_stmt|;
name|func
operator|->
name|write_nvm
operator|=
name|e1000_write_nvm_ich8lan
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_init_mac_params_ich8lan - Initialize MAC function pointers  *  @hw - pointer to the HW structure  *  *  Initialize family-specific MAC parameters and function  *  pointers.  **/
end_comment

begin_function
name|STATIC
name|s32
name|e1000_init_mac_params_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_mac_info
modifier|*
name|mac
init|=
operator|&
name|hw
operator|->
name|mac
decl_stmt|;
name|struct
name|e1000_functions
modifier|*
name|func
init|=
operator|&
name|hw
operator|->
name|func
decl_stmt|;
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_init_mac_params_ich8lan"
argument_list|)
expr_stmt|;
comment|/* Set media type function pointer */
name|hw
operator|->
name|media_type
operator|=
name|e1000_media_type_copper
expr_stmt|;
comment|/* Set mta register count */
name|mac
operator|->
name|mta_reg_count
operator|=
literal|32
expr_stmt|;
comment|/* Set rar entry count */
name|mac
operator|->
name|rar_entry_count
operator|=
name|E1000_ICH_RAR_ENTRIES
expr_stmt|;
if|if
condition|(
name|mac
operator|->
name|type
operator|==
name|e1000_ich8lan
condition|)
name|mac
operator|->
name|rar_entry_count
operator|--
expr_stmt|;
comment|/* Set if part includes ASF firmware */
name|mac
operator|->
name|asf_firmware_present
operator|=
name|TRUE
expr_stmt|;
comment|/* Set if manageability features are enabled. */
name|mac
operator|->
name|arc_subsystem_valid
operator|=
name|TRUE
expr_stmt|;
comment|/* Function pointers */
comment|/* bus type/speed/width */
name|func
operator|->
name|get_bus_info
operator|=
name|e1000_get_bus_info_ich8lan
expr_stmt|;
comment|/* reset */
name|func
operator|->
name|reset_hw
operator|=
name|e1000_reset_hw_ich8lan
expr_stmt|;
comment|/* hw initialization */
name|func
operator|->
name|init_hw
operator|=
name|e1000_init_hw_ich8lan
expr_stmt|;
comment|/* link setup */
name|func
operator|->
name|setup_link
operator|=
name|e1000_setup_link_ich8lan
expr_stmt|;
comment|/* physical interface setup */
name|func
operator|->
name|setup_physical_interface
operator|=
name|e1000_setup_copper_link_ich8lan
expr_stmt|;
comment|/* check for link */
name|func
operator|->
name|check_for_link
operator|=
name|e1000_check_for_copper_link_generic
expr_stmt|;
comment|/* check management mode */
name|func
operator|->
name|check_mng_mode
operator|=
name|e1000_check_mng_mode_ich8lan
expr_stmt|;
comment|/* link info */
name|func
operator|->
name|get_link_up_info
operator|=
name|e1000_get_link_up_info_ich8lan
expr_stmt|;
comment|/* multicast address update */
name|func
operator|->
name|mc_addr_list_update
operator|=
name|e1000_mc_addr_list_update_generic
expr_stmt|;
comment|/* setting MTA */
name|func
operator|->
name|mta_set
operator|=
name|e1000_mta_set_generic
expr_stmt|;
comment|/* blink LED */
name|func
operator|->
name|blink_led
operator|=
name|e1000_blink_led_generic
expr_stmt|;
comment|/* setup LED */
name|func
operator|->
name|setup_led
operator|=
name|e1000_setup_led_generic
expr_stmt|;
comment|/* cleanup LED */
name|func
operator|->
name|cleanup_led
operator|=
name|e1000_cleanup_led_ich8lan
expr_stmt|;
comment|/* turn on/off LED */
name|func
operator|->
name|led_on
operator|=
name|e1000_led_on_ich8lan
expr_stmt|;
name|func
operator|->
name|led_off
operator|=
name|e1000_led_off_ich8lan
expr_stmt|;
comment|/* remove device */
name|func
operator|->
name|remove_device
operator|=
name|e1000_remove_device_generic
expr_stmt|;
comment|/* clear hardware counters */
name|func
operator|->
name|clear_hw_cntrs
operator|=
name|e1000_clear_hw_cntrs_ich8lan
expr_stmt|;
name|hw
operator|->
name|dev_spec_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|e1000_dev_spec_ich8lan
argument_list|)
expr_stmt|;
comment|/* Device-specific structure allocation */
name|ret_val
operator|=
name|e1000_alloc_zeroed_dev_spec_struct
argument_list|(
name|hw
argument_list|,
name|hw
operator|->
name|dev_spec_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
comment|/* Enable PCS Lock-loss workaround for ICH8 */
if|if
condition|(
name|mac
operator|->
name|type
operator|==
name|e1000_ich8lan
condition|)
name|e1000_set_kmrn_lock_loss_workaround_ich8lan
argument_list|(
name|hw
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_init_function_pointers_ich8lan - Initialize ICH8 function pointers  *  @hw - pointer to the HW structure  *  *  Initialize family-specific function pointers for PHY, MAC, and NVM.  **/
end_comment

begin_function
name|void
name|e1000_init_function_pointers_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"e1000_init_function_pointers_ich8lan"
argument_list|)
expr_stmt|;
name|hw
operator|->
name|func
operator|.
name|init_mac_params
operator|=
name|e1000_init_mac_params_ich8lan
expr_stmt|;
name|hw
operator|->
name|func
operator|.
name|init_nvm_params
operator|=
name|e1000_init_nvm_params_ich8lan
expr_stmt|;
name|hw
operator|->
name|func
operator|.
name|init_phy_params
operator|=
name|e1000_init_phy_params_ich8lan
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  e1000_acquire_swflag_ich8lan - Acquire software control flag  *  @hw - pointer to the HW structure  *  *  Acquires the software control flag for performing NVM and PHY  *  operations.  This is a function pointer entry point only called by  *  read/write routines for the PHY and NVM parts.  **/
end_comment

begin_function
name|STATIC
name|s32
name|e1000_acquire_swflag_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|extcnf_ctrl
decl_stmt|,
name|timeout
init|=
name|PHY_CFG_TIMEOUT
decl_stmt|;
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_acquire_swflag_ich8lan"
argument_list|)
expr_stmt|;
while|while
condition|(
name|timeout
condition|)
block|{
name|extcnf_ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_EXTCNF_CTRL
argument_list|)
expr_stmt|;
name|extcnf_ctrl
operator||=
name|E1000_EXTCNF_CTRL_SWFLAG
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_EXTCNF_CTRL
argument_list|,
name|extcnf_ctrl
argument_list|)
expr_stmt|;
name|extcnf_ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_EXTCNF_CTRL
argument_list|)
expr_stmt|;
if|if
condition|(
name|extcnf_ctrl
operator|&
name|E1000_EXTCNF_CTRL_SWFLAG
condition|)
break|break;
name|msec_delay_irq
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|timeout
operator|--
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|timeout
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"FW or HW has locked the resource for too long.\n"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
operator|-
name|E1000_ERR_CONFIG
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_release_swflag_ich8lan - Release software control flag  *  @hw - pointer to the HW structure  *  *  Releases the software control flag for performing NVM and PHY operations.  *  This is a function pointer entry point only called by read/write  *  routines for the PHY and NVM parts.  **/
end_comment

begin_function
name|STATIC
name|void
name|e1000_release_swflag_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|extcnf_ctrl
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_release_swflag_ich8lan"
argument_list|)
expr_stmt|;
name|extcnf_ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_EXTCNF_CTRL
argument_list|)
expr_stmt|;
name|extcnf_ctrl
operator|&=
operator|~
name|E1000_EXTCNF_CTRL_SWFLAG
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_EXTCNF_CTRL
argument_list|,
name|extcnf_ctrl
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**  *  e1000_check_mng_mode_ich8lan - Checks management mode  *  @hw - pointer to the HW structure  *  *  This checks if the adapter has manageability enabled.  *  This is a function pointer entry point only called by read/write  *  routines for the PHY and NVM parts.  **/
end_comment

begin_function
name|STATIC
name|boolean_t
name|e1000_check_mng_mode_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|fwsm
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_check_mng_mode_ich8lan"
argument_list|)
expr_stmt|;
name|fwsm
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_FWSM
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|fwsm
operator|&
name|E1000_FWSM_MODE_MASK
operator|)
operator|==
operator|(
name|E1000_ICH_MNG_IAMT_MODE
operator|<<
name|E1000_FWSM_MODE_SHIFT
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_check_reset_block_ich8lan - Check if PHY reset is blocked  *  @hw - pointer to the HW structure  *  *  Checks if firmware is blocking the reset of the PHY.  *  This is a function pointer entry point only called by  *  reset routines.  **/
end_comment

begin_function
name|STATIC
name|s32
name|e1000_check_reset_block_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|fwsm
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_check_reset_block_ich8lan"
argument_list|)
expr_stmt|;
name|fwsm
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_FWSM
argument_list|)
expr_stmt|;
return|return
operator|(
name|fwsm
operator|&
name|E1000_ICH_FWSM_RSPCIPHY
operator|)
condition|?
name|E1000_SUCCESS
else|:
name|E1000_BLK_PHY_RESET
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_phy_force_speed_duplex_ich8lan - Force PHY speed& duplex  *  @hw - pointer to the HW structure  *  *  Forces the speed and duplex settings of the PHY.  *  This is a function pointer entry point only called by  *  PHY setup routines.  **/
end_comment

begin_function
name|STATIC
name|s32
name|e1000_phy_force_speed_duplex_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|u16
name|data
decl_stmt|;
name|boolean_t
name|link
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_phy_force_speed_duplex_ich8lan"
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy
operator|->
name|type
operator|!=
name|e1000_phy_ife
condition|)
block|{
name|ret_val
operator|=
name|e1000_phy_force_speed_duplex_igp
argument_list|(
name|hw
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ret_val
operator|=
name|e1000_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_CONTROL
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|e1000_phy_force_speed_duplex_setup
argument_list|(
name|hw
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_CONTROL
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
comment|/* Disable MDI-X support for 10/100 */
name|ret_val
operator|=
name|e1000_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|IFE_PHY_MDIX_CONTROL
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|data
operator|&=
operator|~
name|IFE_PMC_AUTO_MDIX
expr_stmt|;
name|data
operator|&=
operator|~
name|IFE_PMC_FORCE_MDIX
expr_stmt|;
name|ret_val
operator|=
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|IFE_PHY_MDIX_CONTROL
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|DEBUGOUT1
argument_list|(
literal|"IFE PMC: %X\n"
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy
operator|->
name|wait_for_link
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Waiting for forced speed/duplex link on IFE phy.\n"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_phy_has_link_generic
argument_list|(
name|hw
argument_list|,
name|PHY_FORCE_LIMIT
argument_list|,
literal|100000
argument_list|,
operator|&
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|!
name|link
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Link taking longer than expected.\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Try once more */
name|ret_val
operator|=
name|e1000_phy_has_link_generic
argument_list|(
name|hw
argument_list|,
name|PHY_FORCE_LIMIT
argument_list|,
literal|100000
argument_list|,
operator|&
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
block|}
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_phy_hw_reset_ich8lan - Performs a PHY reset  *  @hw - pointer to the HW structure  *  *  Resets the PHY  *  This is a function pointer entry point called by drivers  *  or other shared routines.  **/
end_comment

begin_function
name|STATIC
name|s32
name|e1000_phy_hw_reset_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|u32
name|i
decl_stmt|,
name|data
decl_stmt|,
name|cnf_size
decl_stmt|,
name|cnf_base_addr
decl_stmt|,
name|sw_cfg_mask
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|u16
name|loop
init|=
name|E1000_ICH8_LAN_INIT_TIMEOUT
decl_stmt|;
name|u16
name|word_addr
decl_stmt|,
name|reg_data
decl_stmt|,
name|reg_addr
decl_stmt|,
name|phy_page
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_phy_hw_reset_ich8lan"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_phy_hw_reset_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
comment|/* Initialize the PHY from the NVM on ICH platforms.  This 	 * is needed due to an issue where the NVM configuration is 	 * not properly autoloaded after power transitions. 	 * Therefore, after each PHY reset, we will load the 	 * configuration data out of the NVM manually. 	 */
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_ich8lan
operator|&&
name|phy
operator|->
name|type
operator|==
name|e1000_phy_igp_3
condition|)
block|{
comment|/* Check if SW needs configure the PHY */
if|if
condition|(
operator|(
name|hw
operator|->
name|device_id
operator|==
name|E1000_DEV_ID_ICH8_IGP_M_AMT
operator|)
operator|||
operator|(
name|hw
operator|->
name|device_id
operator|==
name|E1000_DEV_ID_ICH8_IGP_M
operator|)
condition|)
name|sw_cfg_mask
operator|=
name|E1000_FEXTNVM_SW_CONFIG_ICH8M
expr_stmt|;
else|else
name|sw_cfg_mask
operator|=
name|E1000_FEXTNVM_SW_CONFIG
expr_stmt|;
name|data
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_FEXTNVM
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|data
operator|&
name|sw_cfg_mask
operator|)
condition|)
goto|goto
name|out
goto|;
comment|/* Wait for basic configuration completes before proceeding*/
do|do
block|{
name|data
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_STATUS
argument_list|)
expr_stmt|;
name|data
operator|&=
name|E1000_STATUS_LAN_INIT_DONE
expr_stmt|;
name|usec_delay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
operator|!
name|data
operator|)
operator|&&
operator|--
name|loop
condition|)
do|;
comment|/* If basic configuration is incomplete before the above loop 		 * count reaches 0, loading the configuration from NVM will 		 * leave the PHY in a bad state possibly resulting in no link. 		 */
if|if
condition|(
name|loop
operator|==
literal|0
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"LAN_INIT_DONE not set, increase timeout\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Clear the Init Done bit for the next init event */
name|data
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_STATUS
argument_list|)
expr_stmt|;
name|data
operator|&=
operator|~
name|E1000_STATUS_LAN_INIT_DONE
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_STATUS
argument_list|,
name|data
argument_list|)
expr_stmt|;
comment|/* Make sure HW does not configure LCD from PHY 		 * extended configuration before SW configuration */
name|data
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_EXTCNF_CTRL
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|&
name|E1000_EXTCNF_CTRL_LCD_WRITE_ENABLE
condition|)
goto|goto
name|out
goto|;
name|cnf_size
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_EXTCNF_SIZE
argument_list|)
expr_stmt|;
name|cnf_size
operator|&=
name|E1000_EXTCNF_SIZE_EXT_PCIE_LENGTH_MASK
expr_stmt|;
name|cnf_size
operator|>>=
name|E1000_EXTCNF_SIZE_EXT_PCIE_LENGTH_SHIFT
expr_stmt|;
if|if
condition|(
operator|!
name|cnf_size
condition|)
goto|goto
name|out
goto|;
name|cnf_base_addr
operator|=
name|data
operator|&
name|E1000_EXTCNF_CTRL_EXT_CNF_POINTER_MASK
expr_stmt|;
name|cnf_base_addr
operator|>>=
name|E1000_EXTCNF_CTRL_EXT_CNF_POINTER_SHIFT
expr_stmt|;
comment|/* Configure LCD from extended configuration 		 * region. */
comment|/* cnf_base_addr is in DWORD */
name|word_addr
operator|=
call|(
name|u16
call|)
argument_list|(
name|cnf_base_addr
operator|<<
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cnf_size
condition|;
name|i
operator|++
control|)
block|{
name|ret_val
operator|=
name|e1000_read_nvm
argument_list|(
name|hw
argument_list|,
operator|(
name|word_addr
operator|+
name|i
operator|*
literal|2
operator|)
argument_list|,
literal|1
argument_list|,
operator|&
name|reg_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|ret_val
operator|=
name|e1000_read_nvm
argument_list|(
name|hw
argument_list|,
operator|(
name|word_addr
operator|+
name|i
operator|*
literal|2
operator|+
literal|1
operator|)
argument_list|,
literal|1
argument_list|,
operator|&
name|reg_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
comment|/* Save off the PHY page for future writes. */
if|if
condition|(
name|reg_addr
operator|==
name|IGP01E1000_PHY_PAGE_SELECT
condition|)
block|{
name|phy_page
operator|=
name|reg_data
expr_stmt|;
continue|continue;
block|}
name|reg_addr
operator||=
name|phy_page
expr_stmt|;
name|ret_val
operator|=
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
operator|(
name|u32
operator|)
name|reg_addr
argument_list|,
name|reg_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
block|}
block|}
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_get_phy_info_ich8lan - Calls appropriate PHY type get_phy_info  *  @hw - pointer to the HW structure  *  *  Wrapper for calling the get_phy_info routines for the appropriate phy type.  *  This is a function pointer entry point called by drivers  *  or other shared routines.  **/
end_comment

begin_function
name|STATIC
name|s32
name|e1000_get_phy_info_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|ret_val
init|=
operator|-
name|E1000_ERR_PHY_TYPE
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_get_phy_info_ich8lan"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|hw
operator|->
name|phy
operator|.
name|type
condition|)
block|{
case|case
name|e1000_phy_ife
case|:
name|ret_val
operator|=
name|e1000_get_phy_info_ife_ich8lan
argument_list|(
name|hw
argument_list|)
expr_stmt|;
break|break;
case|case
name|e1000_phy_igp_3
case|:
name|ret_val
operator|=
name|e1000_get_phy_info_igp
argument_list|(
name|hw
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_get_phy_info_ife_ich8lan - Retrieves various IFE PHY states  *  @hw - pointer to the HW structure  *  *  Populates "phy" structure with various feature states.  *  This function is only called by other family-specific  *  routines.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_get_phy_info_ife_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|u16
name|data
decl_stmt|;
name|boolean_t
name|link
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_get_phy_info_ife_ich8lan"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_phy_has_link_generic
argument_list|(
name|hw
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
operator|&
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|!
name|link
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Phy info is only valid if link is up\n"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
operator|-
name|E1000_ERR_CONFIG
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ret_val
operator|=
name|e1000_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|IFE_PHY_SPECIAL_CONTROL
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|phy
operator|->
name|polarity_correction
operator|=
operator|(
name|data
operator|&
name|IFE_PSC_AUTO_POLARITY_DISABLE
operator|)
condition|?
name|FALSE
else|:
name|TRUE
expr_stmt|;
if|if
condition|(
name|phy
operator|->
name|polarity_correction
condition|)
block|{
name|ret_val
operator|=
name|e1000_check_polarity_ife_ich8lan
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
block|}
else|else
block|{
comment|/* Polarity is forced */
name|phy
operator|->
name|cable_polarity
operator|=
operator|(
name|data
operator|&
name|IFE_PSC_FORCE_POLARITY
operator|)
condition|?
name|e1000_rev_polarity_reversed
else|:
name|e1000_rev_polarity_normal
expr_stmt|;
block|}
name|ret_val
operator|=
name|e1000_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|IFE_PHY_MDIX_CONTROL
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|phy
operator|->
name|is_mdix
operator|=
operator|(
name|data
operator|&
name|IFE_PMC_MDIX_STATUS
operator|)
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
comment|/* The following parameters are undefined for 10/100 operation. */
name|phy
operator|->
name|cable_length
operator|=
name|E1000_CABLE_LENGTH_UNDEFINED
expr_stmt|;
name|phy
operator|->
name|local_rx
operator|=
name|e1000_1000t_rx_status_undefined
expr_stmt|;
name|phy
operator|->
name|remote_rx
operator|=
name|e1000_1000t_rx_status_undefined
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_check_polarity_ife_ich8lan - Check cable polarity for IFE PHY  *  @hw - pointer to the HW structure  *  *  Polarity is determined on the polarity reveral feature being enabled.  *  This function is only called by other family-specific  *  routines.  **/
end_comment

begin_function
name|STATIC
name|s32
name|e1000_check_polarity_ife_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|u16
name|phy_data
decl_stmt|,
name|offset
decl_stmt|,
name|mask
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_check_polarity_ife_ich8lan"
argument_list|)
expr_stmt|;
comment|/* Polarity is determined based on the reversal feature 	 * being enabled. 	 */
if|if
condition|(
name|phy
operator|->
name|polarity_correction
condition|)
block|{
name|offset
operator|=
name|IFE_PHY_EXTENDED_STATUS_CONTROL
expr_stmt|;
name|mask
operator|=
name|IFE_PESC_POLARITY_REVERSED
expr_stmt|;
block|}
else|else
block|{
name|offset
operator|=
name|IFE_PHY_SPECIAL_CONTROL
expr_stmt|;
name|mask
operator|=
name|IFE_PSC_FORCE_POLARITY
expr_stmt|;
block|}
name|ret_val
operator|=
name|e1000_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret_val
condition|)
name|phy
operator|->
name|cable_polarity
operator|=
operator|(
name|phy_data
operator|&
name|mask
operator|)
condition|?
name|e1000_rev_polarity_reversed
else|:
name|e1000_rev_polarity_normal
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_set_d0_lplu_state_ich8lan - Set Low Power Linkup D0 state  *  @hw - pointer to the HW structure  *  @active - TRUE to enable LPLU, FALSE to disable  *  *  Sets the LPLU D0 state according to the active flag.  When  *  activating LPLU this function also disables smart speed  *  and vice versa.  LPLU will not be activated unless the  *  device autonegotiation advertisement meets standards of  *  either 10 or 10/100 or 10/100/1000 at all duplexes.  *  This is a function pointer entry point only called by  *  PHY setup routines.  **/
end_comment

begin_function
name|STATIC
name|s32
name|e1000_set_d0_lplu_state_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|boolean_t
name|active
parameter_list|)
block|{
name|struct
name|e1000_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|u32
name|phy_ctrl
decl_stmt|;
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|u16
name|data
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_set_d0_lplu_state_ich8lan"
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy
operator|->
name|type
operator|!=
name|e1000_phy_igp_3
condition|)
goto|goto
name|out
goto|;
name|phy_ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PHY_CTRL
argument_list|)
expr_stmt|;
if|if
condition|(
name|active
condition|)
block|{
name|phy_ctrl
operator||=
name|E1000_PHY_CTRL_D0A_LPLU
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PHY_CTRL
argument_list|,
name|phy_ctrl
argument_list|)
expr_stmt|;
comment|/* Call gig speed drop workaround on LPLU before accessing 		 * any PHY registers */
if|if
condition|(
operator|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_ich8lan
operator|)
operator|&&
operator|(
name|hw
operator|->
name|phy
operator|.
name|type
operator|==
name|e1000_phy_igp_3
operator|)
condition|)
name|e1000_gig_downshift_workaround_ich8lan
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* When LPLU is enabled, we should disable SmartSpeed */
name|ret_val
operator|=
name|e1000_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_CONFIG
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
name|data
operator|&=
operator|~
name|IGP01E1000_PSCFR_SMART_SPEED
expr_stmt|;
name|ret_val
operator|=
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_CONFIG
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
block|}
else|else
block|{
name|phy_ctrl
operator|&=
operator|~
name|E1000_PHY_CTRL_D0A_LPLU
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PHY_CTRL
argument_list|,
name|phy_ctrl
argument_list|)
expr_stmt|;
comment|/* LPLU and SmartSpeed are mutually exclusive.  LPLU is used 		 * during Dx states where the power conservation is most 		 * important.  During driver activity we should enable 		 * SmartSpeed, so performance is maintained. */
if|if
condition|(
name|phy
operator|->
name|smart_speed
operator|==
name|e1000_smart_speed_on
condition|)
block|{
name|ret_val
operator|=
name|e1000_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_CONFIG
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|data
operator||=
name|IGP01E1000_PSCFR_SMART_SPEED
expr_stmt|;
name|ret_val
operator|=
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_CONFIG
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
block|}
elseif|else
if|if
condition|(
name|phy
operator|->
name|smart_speed
operator|==
name|e1000_smart_speed_off
condition|)
block|{
name|ret_val
operator|=
name|e1000_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_CONFIG
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|data
operator|&=
operator|~
name|IGP01E1000_PSCFR_SMART_SPEED
expr_stmt|;
name|ret_val
operator|=
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_CONFIG
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
block|}
block|}
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_set_d3_lplu_state_ich8lan - Set Low Power Linkup D3 state  *  @hw - pointer to the HW structure  *  @active - TRUE to enable LPLU, FALSE to disable  *  *  Sets the LPLU D3 state according to the active flag.  When  *  activating LPLU this function also disables smart speed  *  and vice versa.  LPLU will not be activated unless the  *  device autonegotiation advertisement meets standards of  *  either 10 or 10/100 or 10/100/1000 at all duplexes.  *  This is a function pointer entry point only called by  *  PHY setup routines.  **/
end_comment

begin_function
name|STATIC
name|s32
name|e1000_set_d3_lplu_state_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|boolean_t
name|active
parameter_list|)
block|{
name|struct
name|e1000_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|u32
name|phy_ctrl
decl_stmt|;
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|u16
name|data
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_set_d3_lplu_state_ich8lan"
argument_list|)
expr_stmt|;
name|phy_ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PHY_CTRL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|active
condition|)
block|{
name|phy_ctrl
operator|&=
operator|~
name|E1000_PHY_CTRL_NOND0A_LPLU
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PHY_CTRL
argument_list|,
name|phy_ctrl
argument_list|)
expr_stmt|;
comment|/* LPLU and SmartSpeed are mutually exclusive.  LPLU is used 		 * during Dx states where the power conservation is most 		 * important.  During driver activity we should enable 		 * SmartSpeed, so performance is maintained. */
if|if
condition|(
name|phy
operator|->
name|smart_speed
operator|==
name|e1000_smart_speed_on
condition|)
block|{
name|ret_val
operator|=
name|e1000_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_CONFIG
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|data
operator||=
name|IGP01E1000_PSCFR_SMART_SPEED
expr_stmt|;
name|ret_val
operator|=
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_CONFIG
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
block|}
elseif|else
if|if
condition|(
name|phy
operator|->
name|smart_speed
operator|==
name|e1000_smart_speed_off
condition|)
block|{
name|ret_val
operator|=
name|e1000_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_CONFIG
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|data
operator|&=
operator|~
name|IGP01E1000_PSCFR_SMART_SPEED
expr_stmt|;
name|ret_val
operator|=
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_CONFIG
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|phy
operator|->
name|autoneg_advertised
operator|==
name|E1000_ALL_SPEED_DUPLEX
operator|)
operator|||
operator|(
name|phy
operator|->
name|autoneg_advertised
operator|==
name|E1000_ALL_NOT_GIG
operator|)
operator|||
operator|(
name|phy
operator|->
name|autoneg_advertised
operator|==
name|E1000_ALL_10_SPEED
operator|)
condition|)
block|{
name|phy_ctrl
operator||=
name|E1000_PHY_CTRL_NOND0A_LPLU
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PHY_CTRL
argument_list|,
name|phy_ctrl
argument_list|)
expr_stmt|;
comment|/* Call gig speed drop workaround on LPLU before accessing 		 * any PHY registers */
if|if
condition|(
operator|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_ich8lan
operator|)
operator|&&
operator|(
name|hw
operator|->
name|phy
operator|.
name|type
operator|==
name|e1000_phy_igp_3
operator|)
condition|)
name|e1000_gig_downshift_workaround_ich8lan
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* When LPLU is enabled, we should disable SmartSpeed */
name|ret_val
operator|=
name|e1000_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_CONFIG
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|data
operator|&=
operator|~
name|IGP01E1000_PSCFR_SMART_SPEED
expr_stmt|;
name|ret_val
operator|=
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_CONFIG
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_read_nvm_ich8lan - Read word(s) from the NVM  *  @hw - pointer to the HW structure  *  @offset - The offset (in bytes) of the word(s) to read.  *  @words - Size of data to read in words  *  @data - Pointer to the word(s) to read at offset.  *  *  Reads a word(s) from the NVM using the flash access registers.  **/
end_comment

begin_function
name|STATIC
name|s32
name|e1000_read_nvm_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|offset
parameter_list|,
name|u16
name|words
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|e1000_nvm_info
modifier|*
name|nvm
init|=
operator|&
name|hw
operator|->
name|nvm
decl_stmt|;
name|struct
name|e1000_dev_spec_ich8lan
modifier|*
name|dev_spec
decl_stmt|;
name|u32
name|act_offset
decl_stmt|;
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|u16
name|i
decl_stmt|,
name|word
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_read_nvm_ich8lan"
argument_list|)
expr_stmt|;
name|dev_spec
operator|=
operator|(
expr|struct
name|e1000_dev_spec_ich8lan
operator|*
operator|)
name|hw
operator|->
name|dev_spec
expr_stmt|;
if|if
condition|(
name|dev_spec
operator|==
name|NULL
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"dev_spec pointer is set to NULL.\n"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
operator|-
name|E1000_ERR_CONFIG
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|offset
operator|>=
name|nvm
operator|->
name|word_size
operator|)
operator|||
operator|(
name|words
operator|>
name|nvm
operator|->
name|word_size
operator|-
name|offset
operator|)
operator|||
operator|(
name|words
operator|==
literal|0
operator|)
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"nvm parameter(s) out of bounds\n"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
operator|-
name|E1000_ERR_NVM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ret_val
operator|=
name|e1000_acquire_nvm
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
comment|/* Start with the bank offset, then add the relative offset. */
name|act_offset
operator|=
operator|(
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_EECD
argument_list|)
operator|&
name|E1000_EECD_SEC1VAL
operator|)
condition|?
name|nvm
operator|->
name|flash_bank_size
else|:
literal|0
expr_stmt|;
name|act_offset
operator|+=
name|offset
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|words
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|dev_spec
operator|->
name|shadow_ram
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|dev_spec
operator|->
name|shadow_ram
index|[
name|offset
operator|+
name|i
index|]
operator|.
name|modified
operator|==
name|TRUE
operator|)
condition|)
block|{
name|data
index|[
name|i
index|]
operator|=
name|dev_spec
operator|->
name|shadow_ram
index|[
name|offset
operator|+
name|i
index|]
operator|.
name|value
expr_stmt|;
block|}
else|else
block|{
name|ret_val
operator|=
name|e1000_read_flash_word_ich8lan
argument_list|(
name|hw
argument_list|,
name|act_offset
operator|+
name|i
argument_list|,
operator|&
name|word
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
break|break;
name|data
index|[
name|i
index|]
operator|=
name|word
expr_stmt|;
block|}
block|}
name|e1000_release_nvm
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_flash_cycle_init_ich8lan - Initialize flash  *  @hw - pointer to the HW structure  *  *  This function does initial flash setup so that a new read/write/erase cycle  *  can be started.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_flash_cycle_init_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|union
name|ich8_hws_flash_status
name|hsfsts
decl_stmt|;
name|s32
name|ret_val
init|=
operator|-
name|E1000_ERR_NVM
decl_stmt|;
name|s32
name|i
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_flash_cycle_init_ich8lan"
argument_list|)
expr_stmt|;
name|hsfsts
operator|.
name|regval
operator|=
name|E1000_READ_FLASH_REG16
argument_list|(
name|hw
argument_list|,
name|ICH_FLASH_HSFSTS
argument_list|)
expr_stmt|;
comment|/* Check if the flash descriptor is valid */
if|if
condition|(
name|hsfsts
operator|.
name|hsf_status
operator|.
name|fldesvalid
operator|==
literal|0
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Flash descriptor invalid.  "
literal|"SW Sequencing must be used."
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Clear FCERR and DAEL in hw status by writing 1 */
name|hsfsts
operator|.
name|hsf_status
operator|.
name|flcerr
operator|=
literal|1
expr_stmt|;
name|hsfsts
operator|.
name|hsf_status
operator|.
name|dael
operator|=
literal|1
expr_stmt|;
name|E1000_WRITE_FLASH_REG16
argument_list|(
name|hw
argument_list|,
name|ICH_FLASH_HSFSTS
argument_list|,
name|hsfsts
operator|.
name|regval
argument_list|)
expr_stmt|;
comment|/* Either we should have a hardware SPI cycle in progress 	 * bit to check against, in order to start a new cycle or 	 * FDONE bit should be changed in the hardware so that it 	 * is 1 after harware reset, which can then be used as an 	 * indication whether a cycle is in progress or has been 	 * completed. 	 */
if|if
condition|(
name|hsfsts
operator|.
name|hsf_status
operator|.
name|flcinprog
operator|==
literal|0
condition|)
block|{
comment|/* There is no cycle running at present, 		 * so we can start a cycle */
comment|/* Begin by setting Flash Cycle Done. */
name|hsfsts
operator|.
name|hsf_status
operator|.
name|flcdone
operator|=
literal|1
expr_stmt|;
name|E1000_WRITE_FLASH_REG16
argument_list|(
name|hw
argument_list|,
name|ICH_FLASH_HSFSTS
argument_list|,
name|hsfsts
operator|.
name|regval
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|E1000_SUCCESS
expr_stmt|;
block|}
else|else
block|{
comment|/* otherwise poll for sometime so the current 		 * cycle has a chance to end before giving up. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ICH_FLASH_READ_COMMAND_TIMEOUT
condition|;
name|i
operator|++
control|)
block|{
name|hsfsts
operator|.
name|regval
operator|=
name|E1000_READ_FLASH_REG16
argument_list|(
name|hw
argument_list|,
name|ICH_FLASH_HSFSTS
argument_list|)
expr_stmt|;
if|if
condition|(
name|hsfsts
operator|.
name|hsf_status
operator|.
name|flcinprog
operator|==
literal|0
condition|)
block|{
name|ret_val
operator|=
name|E1000_SUCCESS
expr_stmt|;
break|break;
block|}
name|usec_delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ret_val
operator|==
name|E1000_SUCCESS
condition|)
block|{
comment|/* Successful in waiting for previous cycle to timeout, 			 * now set the Flash Cycle Done. */
name|hsfsts
operator|.
name|hsf_status
operator|.
name|flcdone
operator|=
literal|1
expr_stmt|;
name|E1000_WRITE_FLASH_REG16
argument_list|(
name|hw
argument_list|,
name|ICH_FLASH_HSFSTS
argument_list|,
name|hsfsts
operator|.
name|regval
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DEBUGOUT
argument_list|(
literal|"Flash controller busy, cannot get access"
argument_list|)
expr_stmt|;
block|}
block|}
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_flash_cycle_ich8lan - Starts flash cycle (read/write/erase)  *  @hw - pointer to the HW structure  *  @timeout - maximum time to wait for completion  *  *  This function starts a flash cycle and waits for its completion.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_flash_cycle_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|timeout
parameter_list|)
block|{
name|union
name|ich8_hws_flash_ctrl
name|hsflctl
decl_stmt|;
name|union
name|ich8_hws_flash_status
name|hsfsts
decl_stmt|;
name|s32
name|ret_val
init|=
operator|-
name|E1000_ERR_NVM
decl_stmt|;
name|u32
name|i
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_flash_cycle_ich8lan"
argument_list|)
expr_stmt|;
comment|/* Start a cycle by writing 1 in Flash Cycle Go in Hw Flash Control */
name|hsflctl
operator|.
name|regval
operator|=
name|E1000_READ_FLASH_REG16
argument_list|(
name|hw
argument_list|,
name|ICH_FLASH_HSFCTL
argument_list|)
expr_stmt|;
name|hsflctl
operator|.
name|hsf_ctrl
operator|.
name|flcgo
operator|=
literal|1
expr_stmt|;
name|E1000_WRITE_FLASH_REG16
argument_list|(
name|hw
argument_list|,
name|ICH_FLASH_HSFCTL
argument_list|,
name|hsflctl
operator|.
name|regval
argument_list|)
expr_stmt|;
comment|/* wait till FDONE bit is set to 1 */
do|do
block|{
name|hsfsts
operator|.
name|regval
operator|=
name|E1000_READ_FLASH_REG16
argument_list|(
name|hw
argument_list|,
name|ICH_FLASH_HSFSTS
argument_list|)
expr_stmt|;
if|if
condition|(
name|hsfsts
operator|.
name|hsf_status
operator|.
name|flcdone
operator|==
literal|1
condition|)
break|break;
name|usec_delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|i
operator|++
operator|<
name|timeout
condition|)
do|;
if|if
condition|(
name|hsfsts
operator|.
name|hsf_status
operator|.
name|flcdone
operator|==
literal|1
operator|&&
name|hsfsts
operator|.
name|hsf_status
operator|.
name|flcerr
operator|==
literal|0
condition|)
name|ret_val
operator|=
name|E1000_SUCCESS
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_read_flash_word_ich8lan - Read word from flash  *  @hw - pointer to the HW structure  *  @offset - offset to data location  *  @data - pointer to the location for storing the data  *  *  Reads the flash word at offset into data.  Offset is converted  *  to bytes before read.  **/
end_comment

begin_function
name|STATIC
name|s32
name|e1000_read_flash_word_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
block|{
name|s32
name|ret_val
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_read_flash_word_ich8lan"
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|==
name|NULL
condition|)
block|{
name|ret_val
operator|=
operator|-
name|E1000_ERR_NVM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Must convert offset into bytes. */
name|offset
operator|<<=
literal|1
expr_stmt|;
name|ret_val
operator|=
name|e1000_read_flash_data_ich8lan
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
literal|2
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_read_flash_data_ich8lan - Read byte or word from NVM  *  @hw - pointer to the HW structure  *  @offset - The offset (in bytes) of the byte or word to read.  *  @size - Size of data to read, 1=byte 2=word  *  @data - Pointer to the word to store the value read.  *  *  Reads a byte or word from the NVM using the flash access registers.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_read_flash_data_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u8
name|size
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
block|{
name|union
name|ich8_hws_flash_status
name|hsfsts
decl_stmt|;
name|union
name|ich8_hws_flash_ctrl
name|hsflctl
decl_stmt|;
name|u32
name|flash_linear_addr
decl_stmt|;
name|u32
name|flash_data
init|=
literal|0
decl_stmt|;
name|s32
name|ret_val
init|=
operator|-
name|E1000_ERR_NVM
decl_stmt|;
name|u8
name|count
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_read_flash_data_ich8lan"
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|<
literal|1
operator|||
name|size
operator|>
literal|2
operator|||
name|data
operator|==
literal|0x0
operator|||
name|offset
operator|>
name|ICH_FLASH_LINEAR_ADDR_MASK
condition|)
goto|goto
name|out
goto|;
name|flash_linear_addr
operator|=
operator|(
name|ICH_FLASH_LINEAR_ADDR_MASK
operator|&
name|offset
operator|)
operator|+
name|hw
operator|->
name|nvm
operator|.
name|flash_base_addr
expr_stmt|;
do|do
block|{
name|usec_delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Steps */
name|ret_val
operator|=
name|e1000_flash_cycle_init_ich8lan
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
operator|!=
name|E1000_SUCCESS
condition|)
break|break;
name|hsflctl
operator|.
name|regval
operator|=
name|E1000_READ_FLASH_REG16
argument_list|(
name|hw
argument_list|,
name|ICH_FLASH_HSFCTL
argument_list|)
expr_stmt|;
comment|/* 0b/1b corresponds to 1 or 2 byte size, respectively. */
name|hsflctl
operator|.
name|hsf_ctrl
operator|.
name|fldbcount
operator|=
name|size
operator|-
literal|1
expr_stmt|;
name|hsflctl
operator|.
name|hsf_ctrl
operator|.
name|flcycle
operator|=
name|ICH_CYCLE_READ
expr_stmt|;
name|E1000_WRITE_FLASH_REG16
argument_list|(
name|hw
argument_list|,
name|ICH_FLASH_HSFCTL
argument_list|,
name|hsflctl
operator|.
name|regval
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLASH_REG
argument_list|(
name|hw
argument_list|,
name|ICH_FLASH_FADDR
argument_list|,
name|flash_linear_addr
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_flash_cycle_ich8lan
argument_list|(
name|hw
argument_list|,
name|ICH_FLASH_READ_COMMAND_TIMEOUT
argument_list|)
expr_stmt|;
comment|/* Check if FCERR is set to 1, if set to 1, clear it 		 * and try the whole sequence a few more times, else 		 * read in (shift in) the Flash Data0, the order is 		 * least significant byte first msb to lsb */
if|if
condition|(
name|ret_val
operator|==
name|E1000_SUCCESS
condition|)
block|{
name|flash_data
operator|=
name|E1000_READ_FLASH_REG
argument_list|(
name|hw
argument_list|,
name|ICH_FLASH_FDATA0
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|1
condition|)
block|{
operator|*
name|data
operator|=
call|(
name|u8
call|)
argument_list|(
name|flash_data
operator|&
literal|0x000000FF
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|size
operator|==
literal|2
condition|)
block|{
operator|*
name|data
operator|=
call|(
name|u16
call|)
argument_list|(
name|flash_data
operator|&
literal|0x0000FFFF
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
else|else
block|{
comment|/* If we've gotten here, then things are probably 			 * completely hosed, but if the error condition is 			 * detected, it won't hurt to give it another try... 			 * ICH_FLASH_CYCLE_REPEAT_COUNT times. 			 */
name|hsfsts
operator|.
name|regval
operator|=
name|E1000_READ_FLASH_REG16
argument_list|(
name|hw
argument_list|,
name|ICH_FLASH_HSFSTS
argument_list|)
expr_stmt|;
if|if
condition|(
name|hsfsts
operator|.
name|hsf_status
operator|.
name|flcerr
operator|==
literal|1
condition|)
block|{
comment|/* Repeat for some time before giving up. */
continue|continue;
block|}
elseif|else
if|if
condition|(
name|hsfsts
operator|.
name|hsf_status
operator|.
name|flcdone
operator|==
literal|0
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Timeout error - flash cycle "
literal|"did not complete."
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
do|while
condition|(
name|count
operator|++
operator|<
name|ICH_FLASH_CYCLE_REPEAT_COUNT
condition|)
do|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_write_nvm_ich8lan - Write word(s) to the NVM  *  @hw - pointer to the HW structure  *  @offset - The offset (in bytes) of the word(s) to write.  *  @words - Size of data to write in words  *  @data - Pointer to the word(s) to write at offset.  *  *  Writes a byte or word to the NVM using the flash access registers.  **/
end_comment

begin_function
name|STATIC
name|s32
name|e1000_write_nvm_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|offset
parameter_list|,
name|u16
name|words
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|e1000_nvm_info
modifier|*
name|nvm
init|=
operator|&
name|hw
operator|->
name|nvm
decl_stmt|;
name|struct
name|e1000_dev_spec_ich8lan
modifier|*
name|dev_spec
decl_stmt|;
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|u16
name|i
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_write_nvm_ich8lan"
argument_list|)
expr_stmt|;
name|dev_spec
operator|=
operator|(
expr|struct
name|e1000_dev_spec_ich8lan
operator|*
operator|)
name|hw
operator|->
name|dev_spec
expr_stmt|;
if|if
condition|(
name|dev_spec
operator|==
name|NULL
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"dev_spec pointer is set to NULL.\n"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
operator|-
name|E1000_ERR_CONFIG
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|offset
operator|>=
name|nvm
operator|->
name|word_size
operator|)
operator|||
operator|(
name|words
operator|>
name|nvm
operator|->
name|word_size
operator|-
name|offset
operator|)
operator|||
operator|(
name|words
operator|==
literal|0
operator|)
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"nvm parameter(s) out of bounds\n"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
operator|-
name|E1000_ERR_NVM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ret_val
operator|=
name|e1000_acquire_nvm
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|words
condition|;
name|i
operator|++
control|)
block|{
name|dev_spec
operator|->
name|shadow_ram
index|[
name|offset
operator|+
name|i
index|]
operator|.
name|modified
operator|=
name|TRUE
expr_stmt|;
name|dev_spec
operator|->
name|shadow_ram
index|[
name|offset
operator|+
name|i
index|]
operator|.
name|value
operator|=
name|data
index|[
name|i
index|]
expr_stmt|;
block|}
name|e1000_release_nvm
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_update_nvm_checksum_ich8lan - Update the checksum for NVM  *  @hw - pointer to the HW structure  *  *  The NVM checksum is updated by calling the generic update_nvm_checksum,  *  which writes the checksum to the shadow ram.  The changes in the shadow  *  ram are then committed to the EEPROM by processing each bank at a time  *  checking for the modified bit and writing only the pending changes.  *  After a succesful commit, the shadow ram is cleared and is ready for  *  future writes.  **/
end_comment

begin_function
name|STATIC
name|s32
name|e1000_update_nvm_checksum_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_nvm_info
modifier|*
name|nvm
init|=
operator|&
name|hw
operator|->
name|nvm
decl_stmt|;
name|struct
name|e1000_dev_spec_ich8lan
modifier|*
name|dev_spec
decl_stmt|;
name|u32
name|i
decl_stmt|,
name|act_offset
decl_stmt|,
name|new_bank_offset
decl_stmt|,
name|old_bank_offset
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|u16
name|data
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_update_nvm_checksum_ich8lan"
argument_list|)
expr_stmt|;
name|dev_spec
operator|=
operator|(
expr|struct
name|e1000_dev_spec_ich8lan
operator|*
operator|)
name|hw
operator|->
name|dev_spec
expr_stmt|;
name|ret_val
operator|=
name|e1000_update_nvm_checksum_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|nvm
operator|->
name|type
operator|!=
name|e1000_nvm_flash_sw
condition|)
goto|goto
name|out
goto|;
name|ret_val
operator|=
name|e1000_acquire_nvm
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
comment|/* We're writing to the opposite bank so if we're on bank 1, 	 * write to bank 0 etc.  We also need to erase the segment that 	 * is going to be written */
if|if
condition|(
operator|!
operator|(
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_EECD
argument_list|)
operator|&
name|E1000_EECD_SEC1VAL
operator|)
condition|)
block|{
name|new_bank_offset
operator|=
name|nvm
operator|->
name|flash_bank_size
expr_stmt|;
name|old_bank_offset
operator|=
literal|0
expr_stmt|;
name|e1000_erase_flash_bank_ich8lan
argument_list|(
name|hw
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|old_bank_offset
operator|=
name|nvm
operator|->
name|flash_bank_size
expr_stmt|;
name|new_bank_offset
operator|=
literal|0
expr_stmt|;
name|e1000_erase_flash_bank_ich8lan
argument_list|(
name|hw
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|E1000_SHADOW_RAM_WORDS
condition|;
name|i
operator|++
control|)
block|{
comment|/* Determine whether to write the value stored 		 * in the other NVM bank or a modified value stored 		 * in the shadow RAM */
if|if
condition|(
name|dev_spec
operator|->
name|shadow_ram
index|[
name|i
index|]
operator|.
name|modified
operator|==
name|TRUE
condition|)
block|{
name|data
operator|=
name|dev_spec
operator|->
name|shadow_ram
index|[
name|i
index|]
operator|.
name|value
expr_stmt|;
block|}
else|else
block|{
name|e1000_read_flash_word_ich8lan
argument_list|(
name|hw
argument_list|,
name|i
operator|+
name|old_bank_offset
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
block|}
comment|/* If the word is 0x13, then make sure the signature bits 		 * (15:14) are 11b until the commit has completed. 		 * This will allow us to write 10b which indicates the 		 * signature is valid.  We want to do this after the write 		 * has completed so that we don't mark the segment valid 		 * while the write is still in progress */
if|if
condition|(
name|i
operator|==
name|E1000_ICH_NVM_SIG_WORD
condition|)
name|data
operator||=
name|E1000_ICH_NVM_SIG_MASK
expr_stmt|;
comment|/* Convert offset to bytes. */
name|act_offset
operator|=
operator|(
name|i
operator|+
name|new_bank_offset
operator|)
operator|<<
literal|1
expr_stmt|;
name|usec_delay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
comment|/* Write the bytes to the new bank. */
name|ret_val
operator|=
name|e1000_retry_write_flash_byte_ich8lan
argument_list|(
name|hw
argument_list|,
name|act_offset
argument_list|,
operator|(
name|u8
operator|)
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
break|break;
name|usec_delay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_retry_write_flash_byte_ich8lan
argument_list|(
name|hw
argument_list|,
name|act_offset
operator|+
literal|1
argument_list|,
call|(
name|u8
call|)
argument_list|(
name|data
operator|>>
literal|8
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
break|break;
block|}
comment|/* Don't bother writing the segment valid bits if sector 	 * programming failed. */
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Flash commit failed.\n"
argument_list|)
expr_stmt|;
name|e1000_release_nvm
argument_list|(
name|hw
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Finally validate the new segment by setting bit 15:14 	 * to 10b in word 0x13 , this can be done without an 	 * erase as well since these bits are 11 to start with 	 * and we need to change bit 14 to 0b */
name|act_offset
operator|=
name|new_bank_offset
operator|+
name|E1000_ICH_NVM_SIG_WORD
expr_stmt|;
name|e1000_read_flash_word_ich8lan
argument_list|(
name|hw
argument_list|,
name|act_offset
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
name|data
operator|&=
literal|0xBFFF
expr_stmt|;
name|ret_val
operator|=
name|e1000_retry_write_flash_byte_ich8lan
argument_list|(
name|hw
argument_list|,
name|act_offset
operator|*
literal|2
operator|+
literal|1
argument_list|,
call|(
name|u8
call|)
argument_list|(
name|data
operator|>>
literal|8
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|e1000_release_nvm
argument_list|(
name|hw
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* And invalidate the previously valid segment by setting 	 * its signature word (0x13) high_byte to 0b. This can be 	 * done without an erase because flash erase sets all bits 	 * to 1's. We can write 1's to 0's without an erase */
name|act_offset
operator|=
operator|(
name|old_bank_offset
operator|+
name|E1000_ICH_NVM_SIG_WORD
operator|)
operator|*
literal|2
operator|+
literal|1
expr_stmt|;
name|ret_val
operator|=
name|e1000_retry_write_flash_byte_ich8lan
argument_list|(
name|hw
argument_list|,
name|act_offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|e1000_release_nvm
argument_list|(
name|hw
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Great!  Everything worked, we can now clear the cached entries. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|E1000_SHADOW_RAM_WORDS
condition|;
name|i
operator|++
control|)
block|{
name|dev_spec
operator|->
name|shadow_ram
index|[
name|i
index|]
operator|.
name|modified
operator|=
name|FALSE
expr_stmt|;
name|dev_spec
operator|->
name|shadow_ram
index|[
name|i
index|]
operator|.
name|value
operator|=
literal|0xFFFF
expr_stmt|;
block|}
name|e1000_release_nvm
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Reload the EEPROM, or else modifications will not appear 	 * until after the next adapter reset. 	 */
name|e1000_reload_nvm
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|msec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_validate_nvm_checksum_ich8lan - Validate EEPROM checksum  *  @hw - pointer to the HW structure  *  *  Check to see if checksum needs to be fixed by reading bit 6 in word 0x19.  *  If the bit is 0, that the EEPROM had been modified, but the checksum was not  *  calculated, in which case we need to calculate the checksum and set bit 6.  **/
end_comment

begin_function
name|STATIC
name|s32
name|e1000_validate_nvm_checksum_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|u16
name|data
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_validate_nvm_checksum_ich8lan"
argument_list|)
expr_stmt|;
comment|/* Read 0x19 and check bit 6.  If this bit is 0, the checksum 	 * needs to be fixed.  This bit is an indication that the NVM 	 * was prepared by OEM software and did not calculate the 	 * checksum...a likely scenario. 	 */
name|ret_val
operator|=
name|e1000_read_nvm
argument_list|(
name|hw
argument_list|,
literal|0x19
argument_list|,
literal|1
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|(
name|data
operator|&
literal|0x40
operator|)
operator|==
literal|0
condition|)
block|{
name|data
operator||=
literal|0x40
expr_stmt|;
name|ret_val
operator|=
name|e1000_write_nvm
argument_list|(
name|hw
argument_list|,
literal|0x19
argument_list|,
literal|1
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|ret_val
operator|=
name|e1000_update_nvm_checksum
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
block|}
name|ret_val
operator|=
name|e1000_validate_nvm_checksum_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_write_flash_data_ich8lan - Writes bytes to the NVM  *  @hw - pointer to the HW structure  *  @offset - The offset (in bytes) of the byte/word to read.  *  @size - Size of data to read, 1=byte 2=word  *  @data - The byte(s) to write to the NVM.  *  *  Writes one/two bytes to the NVM using the flash access registers.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_write_flash_data_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u8
name|size
parameter_list|,
name|u16
name|data
parameter_list|)
block|{
name|union
name|ich8_hws_flash_status
name|hsfsts
decl_stmt|;
name|union
name|ich8_hws_flash_ctrl
name|hsflctl
decl_stmt|;
name|u32
name|flash_linear_addr
decl_stmt|;
name|u32
name|flash_data
init|=
literal|0
decl_stmt|;
name|s32
name|ret_val
init|=
operator|-
name|E1000_ERR_NVM
decl_stmt|;
name|u8
name|count
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_write_ich8_data"
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|<
literal|1
operator|||
name|size
operator|>
literal|2
operator|||
name|data
operator|>
name|size
operator|*
literal|0xff
operator|||
name|offset
operator|>
name|ICH_FLASH_LINEAR_ADDR_MASK
condition|)
goto|goto
name|out
goto|;
name|flash_linear_addr
operator|=
operator|(
name|ICH_FLASH_LINEAR_ADDR_MASK
operator|&
name|offset
operator|)
operator|+
name|hw
operator|->
name|nvm
operator|.
name|flash_base_addr
expr_stmt|;
do|do
block|{
name|usec_delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Steps */
name|ret_val
operator|=
name|e1000_flash_cycle_init_ich8lan
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
operator|!=
name|E1000_SUCCESS
condition|)
break|break;
name|hsflctl
operator|.
name|regval
operator|=
name|E1000_READ_FLASH_REG16
argument_list|(
name|hw
argument_list|,
name|ICH_FLASH_HSFCTL
argument_list|)
expr_stmt|;
comment|/* 0b/1b corresponds to 1 or 2 byte size, respectively. */
name|hsflctl
operator|.
name|hsf_ctrl
operator|.
name|fldbcount
operator|=
name|size
operator|-
literal|1
expr_stmt|;
name|hsflctl
operator|.
name|hsf_ctrl
operator|.
name|flcycle
operator|=
name|ICH_CYCLE_WRITE
expr_stmt|;
name|E1000_WRITE_FLASH_REG16
argument_list|(
name|hw
argument_list|,
name|ICH_FLASH_HSFCTL
argument_list|,
name|hsflctl
operator|.
name|regval
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLASH_REG
argument_list|(
name|hw
argument_list|,
name|ICH_FLASH_FADDR
argument_list|,
name|flash_linear_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|1
condition|)
name|flash_data
operator|=
operator|(
name|u32
operator|)
name|data
operator|&
literal|0x00FF
expr_stmt|;
else|else
name|flash_data
operator|=
operator|(
name|u32
operator|)
name|data
expr_stmt|;
name|E1000_WRITE_FLASH_REG
argument_list|(
name|hw
argument_list|,
name|ICH_FLASH_FDATA0
argument_list|,
name|flash_data
argument_list|)
expr_stmt|;
comment|/* check if FCERR is set to 1 , if set to 1, clear it 		 * and try the whole sequence a few more times else done */
name|ret_val
operator|=
name|e1000_flash_cycle_ich8lan
argument_list|(
name|hw
argument_list|,
name|ICH_FLASH_WRITE_COMMAND_TIMEOUT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
operator|==
name|E1000_SUCCESS
condition|)
block|{
break|break;
block|}
else|else
block|{
comment|/* If we're here, then things are most likely 			 * completely hosed, but if the error condition 			 * is detected, it won't hurt to give it another 			 * try...ICH_FLASH_CYCLE_REPEAT_COUNT times. 			 */
name|hsfsts
operator|.
name|regval
operator|=
name|E1000_READ_FLASH_REG16
argument_list|(
name|hw
argument_list|,
name|ICH_FLASH_HSFSTS
argument_list|)
expr_stmt|;
if|if
condition|(
name|hsfsts
operator|.
name|hsf_status
operator|.
name|flcerr
operator|==
literal|1
condition|)
block|{
comment|/* Repeat for some time before giving up. */
continue|continue;
block|}
elseif|else
if|if
condition|(
name|hsfsts
operator|.
name|hsf_status
operator|.
name|flcdone
operator|==
literal|0
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Timeout error - flash cycle "
literal|"did not complete."
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
do|while
condition|(
name|count
operator|++
operator|<
name|ICH_FLASH_CYCLE_REPEAT_COUNT
condition|)
do|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_write_flash_byte_ich8lan - Write a single byte to NVM  *  @hw - pointer to the HW structure  *  @offset - The index of the byte to read.  *  @data - The byte to write to the NVM.  *  *  Writes a single byte to the NVM using the flash access registers.  **/
end_comment

begin_function
name|STATIC
name|s32
name|e1000_write_flash_byte_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u8
name|data
parameter_list|)
block|{
name|u16
name|word
init|=
operator|(
name|u16
operator|)
name|data
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_write_flash_byte_ich8lan"
argument_list|)
expr_stmt|;
return|return
name|e1000_write_flash_data_ich8lan
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
literal|1
argument_list|,
name|word
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_retry_write_flash_byte_ich8lan - Writes a single byte to NVM  *  @hw - pointer to the HW structure  *  @offset - The offset of the byte to write.  *  @byte - The byte to write to the NVM.  *  *  Writes a single byte to the NVM using the flash access registers.  *  Goes through a retry algorithm before giving up.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_retry_write_flash_byte_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u8
name|byte
parameter_list|)
block|{
name|s32
name|ret_val
decl_stmt|;
name|u16
name|program_retries
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_retry_write_flash_byte_ich8lan"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_write_flash_byte_ich8lan
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
name|byte
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|usec_delay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
for|for
control|(
name|program_retries
operator|=
literal|0
init|;
name|program_retries
operator|<
literal|100
condition|;
name|program_retries
operator|++
control|)
block|{
name|DEBUGOUT2
argument_list|(
literal|"Retrying Byte %2.2X at offset %u\n"
argument_list|,
name|byte
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_write_flash_byte_ich8lan
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
name|byte
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
operator|==
name|E1000_SUCCESS
condition|)
break|break;
block|}
if|if
condition|(
name|program_retries
operator|==
literal|100
condition|)
block|{
name|ret_val
operator|=
operator|-
name|E1000_ERR_NVM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_erase_flash_bank_ich8lan - Erase a bank (4k) from NVM  *  @hw - pointer to the HW structure  *  @bank - 0 for first bank, 1 for second bank, etc.  *  *  Erases the bank specified. Each bank is a 4k block. Banks are 0 based.  *  bank N is 4096 * N + flash_reg_addr.  **/
end_comment

begin_function
name|STATIC
name|s32
name|e1000_erase_flash_bank_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|bank
parameter_list|)
block|{
name|struct
name|e1000_nvm_info
modifier|*
name|nvm
init|=
operator|&
name|hw
operator|->
name|nvm
decl_stmt|;
name|union
name|ich8_hws_flash_status
name|hsfsts
decl_stmt|;
name|union
name|ich8_hws_flash_ctrl
name|hsflctl
decl_stmt|;
name|u32
name|flash_linear_addr
decl_stmt|;
name|u32
name|flash_bank_size
init|=
name|nvm
operator|->
name|flash_bank_size
operator|*
literal|2
decl_stmt|;
comment|/* bank size is in 16bit words - adjust to bytes */
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|s32
name|count
init|=
literal|0
decl_stmt|;
name|s32
name|j
decl_stmt|,
name|iteration
decl_stmt|,
name|sector_size
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_erase_flash_bank_ich8lan"
argument_list|)
expr_stmt|;
name|hsfsts
operator|.
name|regval
operator|=
name|E1000_READ_FLASH_REG16
argument_list|(
name|hw
argument_list|,
name|ICH_FLASH_HSFSTS
argument_list|)
expr_stmt|;
comment|/* Determine HW Sector size: Read BERASE bits of hw flash status 	 * register */
comment|/* 00: The Hw sector is 256 bytes, hence we need to erase 16 	 *     consecutive sectors.  The start index for the nth Hw sector 	 *     can be calculated as = bank * 4096 + n * 256 	 * 01: The Hw sector is 4K bytes, hence we need to erase 1 sector. 	 *     The start index for the nth Hw sector can be calculated 	 *     as = bank * 4096 	 * 10: The Hw sector is 8K bytes, nth sector = bank * 8192 	 *     (ich9 only, otherwise error condition) 	 * 11: The Hw sector is 64K bytes, nth sector = bank * 65536 	 */
switch|switch
condition|(
name|hsfsts
operator|.
name|hsf_status
operator|.
name|berasesz
condition|)
block|{
case|case
literal|0
case|:
comment|/* Hw sector size 256 */
name|sector_size
operator|=
name|ICH_FLASH_SEG_SIZE_256
expr_stmt|;
name|iteration
operator|=
name|flash_bank_size
operator|/
name|ICH_FLASH_SEG_SIZE_256
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|sector_size
operator|=
name|ICH_FLASH_SEG_SIZE_4K
expr_stmt|;
name|iteration
operator|=
name|flash_bank_size
operator|/
name|ICH_FLASH_SEG_SIZE_4K
expr_stmt|;
break|break;
case|case
literal|2
case|:
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_ich9lan
condition|)
block|{
name|sector_size
operator|=
name|ICH_FLASH_SEG_SIZE_8K
expr_stmt|;
name|iteration
operator|=
name|flash_bank_size
operator|/
name|ICH_FLASH_SEG_SIZE_8K
expr_stmt|;
block|}
else|else
block|{
name|ret_val
operator|=
operator|-
name|E1000_ERR_NVM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
break|break;
case|case
literal|3
case|:
name|sector_size
operator|=
name|ICH_FLASH_SEG_SIZE_64K
expr_stmt|;
name|iteration
operator|=
name|flash_bank_size
operator|/
name|ICH_FLASH_SEG_SIZE_64K
expr_stmt|;
break|break;
default|default:
name|ret_val
operator|=
operator|-
name|E1000_ERR_NVM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Start with the base address, then add the sector offset. */
name|flash_linear_addr
operator|=
name|hw
operator|->
name|nvm
operator|.
name|flash_base_addr
expr_stmt|;
name|flash_linear_addr
operator|+=
operator|(
name|bank
operator|)
condition|?
operator|(
name|sector_size
operator|*
name|iteration
operator|)
else|:
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|iteration
condition|;
name|j
operator|++
control|)
block|{
do|do
block|{
comment|/* Steps */
name|ret_val
operator|=
name|e1000_flash_cycle_init_ich8lan
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
comment|/* Write a value 11 (block Erase) in Flash 			 * Cycle field in hw flash control */
name|hsflctl
operator|.
name|regval
operator|=
name|E1000_READ_FLASH_REG16
argument_list|(
name|hw
argument_list|,
name|ICH_FLASH_HSFCTL
argument_list|)
expr_stmt|;
name|hsflctl
operator|.
name|hsf_ctrl
operator|.
name|flcycle
operator|=
name|ICH_CYCLE_ERASE
expr_stmt|;
name|E1000_WRITE_FLASH_REG16
argument_list|(
name|hw
argument_list|,
name|ICH_FLASH_HSFCTL
argument_list|,
name|hsflctl
operator|.
name|regval
argument_list|)
expr_stmt|;
comment|/* Write the last 24 bits of an index within the 			 * block into Flash Linear address field in Flash 			 * Address. 			 */
name|flash_linear_addr
operator|+=
operator|(
name|j
operator|*
name|sector_size
operator|)
expr_stmt|;
name|E1000_WRITE_FLASH_REG
argument_list|(
name|hw
argument_list|,
name|ICH_FLASH_FADDR
argument_list|,
name|flash_linear_addr
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_flash_cycle_ich8lan
argument_list|(
name|hw
argument_list|,
name|ICH_FLASH_ERASE_COMMAND_TIMEOUT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
operator|==
name|E1000_SUCCESS
condition|)
block|{
break|break;
block|}
else|else
block|{
comment|/* Check if FCERR is set to 1.  If 1, 				 * clear it and try the whole sequence 				 * a few more times else Done */
name|hsfsts
operator|.
name|regval
operator|=
name|E1000_READ_FLASH_REG16
argument_list|(
name|hw
argument_list|,
name|ICH_FLASH_HSFSTS
argument_list|)
expr_stmt|;
if|if
condition|(
name|hsfsts
operator|.
name|hsf_status
operator|.
name|flcerr
operator|==
literal|1
condition|)
block|{
comment|/* repeat for some time before 					 * giving up */
continue|continue;
block|}
elseif|else
if|if
condition|(
name|hsfsts
operator|.
name|hsf_status
operator|.
name|flcdone
operator|==
literal|0
condition|)
goto|goto
name|out
goto|;
block|}
block|}
do|while
condition|(
operator|++
name|count
operator|<
name|ICH_FLASH_CYCLE_REPEAT_COUNT
condition|)
do|;
block|}
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_valid_led_default_ich8lan - Set the default LED settings  *  @hw - pointer to the HW structure  *  @data - Pointer to the LED settings  *  *  Reads the LED default settings from the NVM to data.  If the NVM LED  *  settings is all 0's or F's, set the LED default to a valid LED default  *  setting.  **/
end_comment

begin_function
name|STATIC
name|s32
name|e1000_valid_led_default_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
block|{
name|s32
name|ret_val
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_valid_led_default_ich8lan"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_read_nvm
argument_list|(
name|hw
argument_list|,
name|NVM_ID_LED_SETTINGS
argument_list|,
literal|1
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"NVM Read Error\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|*
name|data
operator|==
name|ID_LED_RESERVED_0000
operator|||
operator|*
name|data
operator|==
name|ID_LED_RESERVED_FFFF
condition|)
operator|*
name|data
operator|=
name|ID_LED_DEFAULT_ICH8LAN
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_get_bus_info_ich8lan - Get/Set the bus type and width  *  @hw - pointer to the HW structure  *  *  ICH8 use the PCI Express bus, but does not contain a PCI Express Capability  *  register, so the the bus width is hard coded.  **/
end_comment

begin_function
name|STATIC
name|s32
name|e1000_get_bus_info_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_bus_info
modifier|*
name|bus
init|=
operator|&
name|hw
operator|->
name|bus
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_get_bus_info_ich8lan"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_get_bus_info_pcie_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* ICH devices are "PCI Express"-ish.  They have 	 * a configuration space, but do not contain 	 * PCI Express Capability registers, so bus width 	 * must be hardcoded. 	 */
if|if
condition|(
name|bus
operator|->
name|width
operator|==
name|e1000_bus_width_unknown
condition|)
name|bus
operator|->
name|width
operator|=
name|e1000_bus_width_pcie_x1
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_reset_hw_ich8lan - Reset the hardware  *  @hw - pointer to the HW structure  *  *  Does a full reset of the hardware which includes a reset of the PHY and  *  MAC.  **/
end_comment

begin_function
name|STATIC
name|s32
name|e1000_reset_hw_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|ctrl
decl_stmt|,
name|icr
decl_stmt|,
name|kab
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_reset_hw_ich8lan"
argument_list|)
expr_stmt|;
comment|/* Prevent the PCI-E bus from sticking if there is no TLP connection 	 * on the last TLP read/write transaction when MAC is reset. 	 */
name|ret_val
operator|=
name|e1000_disable_pcie_master_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"PCI-E Master disable polling has failed.\n"
argument_list|)
expr_stmt|;
block|}
name|DEBUGOUT
argument_list|(
literal|"Masking off all interrupts\n"
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_IMC
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
comment|/* Disable the Transmit and Receive units.  Then delay to allow 	 * any pending transactions to complete before we hit the MAC 	 * with the global reset. 	 */
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RCTL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TCTL
argument_list|,
name|E1000_TCTL_PSP
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|msec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
comment|/* Workaround for ICH8 bit corruption issue in FIFO memory */
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_ich8lan
condition|)
block|{
comment|/* Set Tx and Rx buffer allocation to 8k apiece. */
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PBA
argument_list|,
name|E1000_PBA_8K
argument_list|)
expr_stmt|;
comment|/* Set Packet Buffer Size to 16k. */
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PBS
argument_list|,
name|E1000_PBS_16K
argument_list|)
expr_stmt|;
block|}
name|ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|e1000_check_reset_block
argument_list|(
name|hw
argument_list|)
operator|&&
operator|!
name|hw
operator|->
name|phy
operator|.
name|reset_disable
condition|)
block|{
comment|/* PHY HW reset requires MAC CORE reset at the same 		 * time to make sure the interface between MAC and the 		 * external PHY is reset. 		 */
name|ctrl
operator||=
name|E1000_CTRL_PHY_RST
expr_stmt|;
block|}
name|ret_val
operator|=
name|e1000_acquire_swflag_ich8lan
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Issuing a global reset to ich8lan"
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|,
operator|(
name|ctrl
operator||
name|E1000_CTRL_RST
operator|)
argument_list|)
expr_stmt|;
name|msec_delay
argument_list|(
literal|20
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_get_auto_rd_done_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
comment|/*  		 * When auto config read does not complete, do not 		 * return with an error. This can happen in situations 		 * where there is no eeprom and prevents getting link. 		 */
name|DEBUGOUT
argument_list|(
literal|"Auto Read Done did not complete\n"
argument_list|)
expr_stmt|;
block|}
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_IMC
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|icr
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_ICR
argument_list|)
expr_stmt|;
name|kab
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_KABGTXD
argument_list|)
expr_stmt|;
name|kab
operator||=
name|E1000_KABGTXD_BGSQLBIAS
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_KABGTXD
argument_list|,
name|kab
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_init_hw_ich8lan - Initialize the hardware  *  @hw - pointer to the HW structure  *  *  Prepares the hardware for transmit and receive by doing the following:  *   - initialize hardware bits  *   - initialize LED identification  *   - setup receive address registers  *   - setup flow control  *   - setup transmit discriptors  *   - clear statistics  **/
end_comment

begin_function
name|STATIC
name|s32
name|e1000_init_hw_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_mac_info
modifier|*
name|mac
init|=
operator|&
name|hw
operator|->
name|mac
decl_stmt|;
name|u32
name|ctrl_ext
decl_stmt|,
name|txdctl
decl_stmt|,
name|snoop
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|u16
name|i
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_init_hw_ich8lan"
argument_list|)
expr_stmt|;
name|e1000_initialize_hw_bits_ich8lan
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Initialize identification LED */
name|ret_val
operator|=
name|e1000_id_led_init_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Error initializing identification LED\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Setup the receive address. */
name|e1000_init_rx_addrs_generic
argument_list|(
name|hw
argument_list|,
name|mac
operator|->
name|rar_entry_count
argument_list|)
expr_stmt|;
comment|/* Zero out the Multicast HASH table */
name|DEBUGOUT
argument_list|(
literal|"Zeroing the MTA\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mac
operator|->
name|mta_reg_count
condition|;
name|i
operator|++
control|)
name|E1000_WRITE_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|E1000_MTA
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Setup link and flow control */
name|ret_val
operator|=
name|e1000_setup_link
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Set the transmit descriptor write-back policy for both queues */
name|txdctl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TXDCTL
argument_list|)
expr_stmt|;
name|txdctl
operator|=
operator|(
name|txdctl
operator|&
operator|~
name|E1000_TXDCTL_WTHRESH
operator|)
operator||
name|E1000_TXDCTL_FULL_TX_DESC_WB
expr_stmt|;
name|txdctl
operator|=
operator|(
name|txdctl
operator|&
operator|~
name|E1000_TXDCTL_PTHRESH
operator|)
operator||
name|E1000_TXDCTL_MAX_TX_DESC_PREFETCH
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TXDCTL
argument_list|,
name|txdctl
argument_list|)
expr_stmt|;
name|txdctl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TXDCTL1
argument_list|)
expr_stmt|;
name|txdctl
operator|=
operator|(
name|txdctl
operator|&
operator|~
name|E1000_TXDCTL_WTHRESH
operator|)
operator||
name|E1000_TXDCTL_FULL_TX_DESC_WB
expr_stmt|;
name|txdctl
operator|=
operator|(
name|txdctl
operator|&
operator|~
name|E1000_TXDCTL_PTHRESH
operator|)
operator||
name|E1000_TXDCTL_MAX_TX_DESC_PREFETCH
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TXDCTL1
argument_list|,
name|txdctl
argument_list|)
expr_stmt|;
comment|/* ICH8 has opposite polarity of no_snoop bits. 	 * By default, we should use snoop behavior. */
if|if
condition|(
name|mac
operator|->
name|type
operator|==
name|e1000_ich8lan
condition|)
name|snoop
operator|=
name|PCIE_ICH8_SNOOP_ALL
expr_stmt|;
else|else
name|snoop
operator|=
operator|(
name|u32
operator|)
operator|~
operator|(
name|PCIE_NO_SNOOP_ALL
operator|)
expr_stmt|;
name|e1000_set_pcie_no_snoop_generic
argument_list|(
name|hw
argument_list|,
name|snoop
argument_list|)
expr_stmt|;
name|ctrl_ext
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL_EXT
argument_list|)
expr_stmt|;
name|ctrl_ext
operator||=
name|E1000_CTRL_EXT_RO_DIS
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL_EXT
argument_list|,
name|ctrl_ext
argument_list|)
expr_stmt|;
comment|/* Clear all of the statistics registers (clear on read).  It is 	 * important that we do this after we have tried to establish link 	 * because the symbol error count will increment wildly if there 	 * is no link. 	 */
name|e1000_clear_hw_cntrs_ich8lan
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_initialize_hw_bits_ich8lan - Initialize required hardware bits  *  @hw - pointer to the HW structure  *  *  Sets/Clears required hardware bits necessary for correctly setting up the  *  hardware for transmit and receive.  **/
end_comment

begin_function
specifier|static
name|void
name|e1000_initialize_hw_bits_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|reg
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_initialize_hw_bits_ich8lan"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|disable_hw_init_bits
condition|)
goto|goto
name|out
goto|;
comment|/* Extended Device Control */
name|reg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL_EXT
argument_list|)
expr_stmt|;
name|reg
operator||=
operator|(
literal|1
operator|<<
literal|22
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL_EXT
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* Transmit Descriptor Control 0 */
name|reg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TXDCTL
argument_list|)
expr_stmt|;
name|reg
operator||=
operator|(
literal|1
operator|<<
literal|22
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TXDCTL
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* Transmit Descriptor Control 1 */
name|reg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TXDCTL1
argument_list|)
expr_stmt|;
name|reg
operator||=
operator|(
literal|1
operator|<<
literal|22
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TXDCTL1
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* Transmit Arbitration Control 0 */
name|reg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TARC0
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_ich8lan
condition|)
name|reg
operator||=
operator|(
literal|1
operator|<<
literal|28
operator|)
operator||
operator|(
literal|1
operator|<<
literal|29
operator|)
expr_stmt|;
name|reg
operator||=
operator|(
literal|1
operator|<<
literal|23
operator|)
operator||
operator|(
literal|1
operator|<<
literal|24
operator|)
operator||
operator|(
literal|1
operator|<<
literal|26
operator|)
operator||
operator|(
literal|1
operator|<<
literal|27
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TARC0
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* Transmit Arbitration Control 1 */
name|reg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TARC1
argument_list|)
expr_stmt|;
if|if
condition|(
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TCTL
argument_list|)
operator|&
name|E1000_TCTL_MULR
condition|)
name|reg
operator|&=
operator|~
operator|(
literal|1
operator|<<
literal|28
operator|)
expr_stmt|;
else|else
name|reg
operator||=
operator|(
literal|1
operator|<<
literal|28
operator|)
expr_stmt|;
name|reg
operator||=
operator|(
literal|1
operator|<<
literal|24
operator|)
operator||
operator|(
literal|1
operator|<<
literal|26
operator|)
operator||
operator|(
literal|1
operator|<<
literal|30
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TARC1
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* Device Status */
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_ich8lan
condition|)
block|{
name|reg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_STATUS
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
operator|(
literal|1
operator|<<
literal|31
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_STATUS
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
name|out
label|:
return|return;
block|}
end_function

begin_comment
comment|/**  *  e1000_setup_link_ich8lan - Setup flow control and link settings  *  @hw - pointer to the HW structure  *  *  Determines which flow control settings to use, then configures flow  *  control.  Calls the appropriate media-specific link configuration  *  function.  Assuming the adapter has a valid link partner, a valid link  *  should be established.  Assumes the hardware has previously been reset  *  and the transmitter and receiver are not enabled.  **/
end_comment

begin_function
name|STATIC
name|s32
name|e1000_setup_link_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_mac_info
modifier|*
name|mac
init|=
operator|&
name|hw
operator|->
name|mac
decl_stmt|;
name|struct
name|e1000_functions
modifier|*
name|func
init|=
operator|&
name|hw
operator|->
name|func
decl_stmt|;
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_setup_link_ich8lan"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e1000_check_reset_block
argument_list|(
name|hw
argument_list|)
condition|)
goto|goto
name|out
goto|;
comment|/* ICH parts do not have a word in the NVM to determine 	 * the default flow control setting, so we explicitly 	 * set it to full. 	 */
if|if
condition|(
name|mac
operator|->
name|fc
operator|==
name|e1000_fc_default
condition|)
name|mac
operator|->
name|fc
operator|=
name|e1000_fc_full
expr_stmt|;
name|mac
operator|->
name|original_fc
operator|=
name|mac
operator|->
name|fc
expr_stmt|;
name|DEBUGOUT1
argument_list|(
literal|"After fix-ups FlowControl is now = %x\n"
argument_list|,
name|mac
operator|->
name|fc
argument_list|)
expr_stmt|;
comment|/* Continue to configure the copper link. */
name|ret_val
operator|=
name|func
operator|->
name|setup_physical_interface
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_FCTTV
argument_list|,
name|mac
operator|->
name|fc_pause_time
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_set_fc_watermarks_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_setup_copper_link_ich8lan - Configure MAC/PHY interface  *  @hw - pointer to the HW structure  *  *  Configures the kumeran interface to the PHY to wait the appropriate time  *  when polling the PHY, then call the generic setup_copper_link to finish  *  configuring the copper link.  **/
end_comment

begin_function
name|STATIC
name|s32
name|e1000_setup_copper_link_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|ctrl
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|u16
name|reg_data
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_setup_copper_link_ich8lan"
argument_list|)
expr_stmt|;
name|ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|)
expr_stmt|;
name|ctrl
operator||=
name|E1000_CTRL_SLU
expr_stmt|;
name|ctrl
operator|&=
operator|~
operator|(
name|E1000_CTRL_FRCSPD
operator||
name|E1000_CTRL_FRCDPX
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
comment|/* Set the mac to wait the maximum time between each iteration 	 * and increase the max iterations when polling the phy; 	 * this fixes erroneous timeouts at 10Mbps. */
name|ret_val
operator|=
name|e1000_write_kmrn_reg
argument_list|(
name|hw
argument_list|,
name|GG82563_REG
argument_list|(
literal|0x34
argument_list|,
literal|4
argument_list|)
argument_list|,
literal|0xFFFF
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|ret_val
operator|=
name|e1000_read_kmrn_reg
argument_list|(
name|hw
argument_list|,
name|GG82563_REG
argument_list|(
literal|0x34
argument_list|,
literal|9
argument_list|)
argument_list|,
operator|&
name|reg_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|reg_data
operator||=
literal|0x3F
expr_stmt|;
name|ret_val
operator|=
name|e1000_write_kmrn_reg
argument_list|(
name|hw
argument_list|,
name|GG82563_REG
argument_list|(
literal|0x34
argument_list|,
literal|9
argument_list|)
argument_list|,
name|reg_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|type
operator|==
name|e1000_phy_igp_3
condition|)
block|{
name|ret_val
operator|=
name|e1000_copper_link_setup_igp
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
block|}
name|ret_val
operator|=
name|e1000_setup_copper_link_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_get_link_up_info_ich8lan - Get current link speed and duplex  *  @hw - pointer to the HW structure  *  @speed - pointer to store current link speed  *  @duplex - pointer to store the current link duplex  *  *  Calls the generic get_speed_and_duplex to retreive the current link  *  information and then calls the Kumeran lock loss workaround for links at  *  gigabit speeds.  **/
end_comment

begin_function
name|STATIC
name|s32
name|e1000_get_link_up_info_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
modifier|*
name|speed
parameter_list|,
name|u16
modifier|*
name|duplex
parameter_list|)
block|{
name|s32
name|ret_val
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_get_link_up_info_ich8lan"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_get_speed_and_duplex_copper_generic
argument_list|(
name|hw
argument_list|,
name|speed
argument_list|,
name|duplex
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_ich8lan
operator|)
operator|&&
operator|(
name|hw
operator|->
name|phy
operator|.
name|type
operator|==
name|e1000_phy_igp_3
operator|)
operator|&&
operator|(
operator|*
name|speed
operator|==
name|SPEED_1000
operator|)
condition|)
block|{
name|ret_val
operator|=
name|e1000_kmrn_lock_loss_workaround_ich8lan
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_kmrn_lock_loss_workaround_ich8lan - Kumeran workaround  *  @hw - pointer to the HW structure  *  *  Work-around for 82566 Kumeran PCS lock loss:  *  On link status change (i.e. PCI reset, speed change) and link is up and  *  speed is gigabit-  *    0) if workaround is optionally disabled do nothing  *    1) wait 1ms for Kumeran link to come up  *    2) check Kumeran Diagnostic register PCS lock loss bit  *    3) if not set the link is locked (all is good), otherwise...  *    4) reset the PHY  *    5) repeat up to 10 times  *  Note: this is only called for IGP3 copper when speed is 1gb.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_kmrn_lock_loss_workaround_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_dev_spec_ich8lan
modifier|*
name|dev_spec
decl_stmt|;
name|u32
name|phy_ctrl
decl_stmt|;
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|u16
name|i
decl_stmt|,
name|data
decl_stmt|;
name|boolean_t
name|link
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_kmrn_lock_loss_workaround_ich8lan"
argument_list|)
expr_stmt|;
name|dev_spec
operator|=
operator|(
expr|struct
name|e1000_dev_spec_ich8lan
operator|*
operator|)
name|hw
operator|->
name|dev_spec
expr_stmt|;
if|if
condition|(
name|dev_spec
operator|==
name|NULL
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"dev_spec pointer is set to NULL.\n"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
operator|-
name|E1000_ERR_CONFIG
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|dev_spec
operator|->
name|kmrn_lock_loss_workaround_enabled
operator|==
name|FALSE
condition|)
goto|goto
name|out
goto|;
comment|/* Make sure link is up before proceeding.  If not just return. 	 * Attempting this while link is negotiating fouled up link 	 * stability */
name|ret_val
operator|=
name|e1000_phy_has_link_generic
argument_list|(
name|hw
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
operator|&
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|link
condition|)
block|{
name|ret_val
operator|=
name|E1000_SUCCESS
expr_stmt|;
goto|goto
name|out
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
block|{
comment|/* read once to clear */
name|ret_val
operator|=
name|e1000_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP3_KMRN_DIAG
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
comment|/* and again to get new status */
name|ret_val
operator|=
name|e1000_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP3_KMRN_DIAG
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
comment|/* check for PCS lock */
if|if
condition|(
operator|!
operator|(
name|data
operator|&
name|IGP3_KMRN_DIAG_PCS_LOCK_LOSS
operator|)
condition|)
block|{
name|ret_val
operator|=
name|E1000_SUCCESS
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Issue PHY reset */
name|e1000_phy_hw_reset
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|msec_delay_irq
argument_list|(
literal|5
argument_list|)
expr_stmt|;
block|}
comment|/* Disable GigE link negotiation */
name|phy_ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PHY_CTRL
argument_list|)
expr_stmt|;
name|phy_ctrl
operator||=
operator|(
name|E1000_PHY_CTRL_GBE_DISABLE
operator||
name|E1000_PHY_CTRL_NOND0A_GBE_DISABLE
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PHY_CTRL
argument_list|,
name|phy_ctrl
argument_list|)
expr_stmt|;
comment|/* Call gig speed drop workaround on Giga disable before accessing 	 * any PHY registers */
name|e1000_gig_downshift_workaround_ich8lan
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* unable to acquire PCS lock */
name|ret_val
operator|=
operator|-
name|E1000_ERR_PHY
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_set_kmrn_lock_loss_workaound_ich8lan - Set Kumeran workaround state  *  @hw - pointer to the HW structure  *  @state - boolean value used to set the current Kumaran workaround state  *  *  If ICH8, set the current Kumeran workaround state (enabled - TRUE  *  /disabled - FALSE).  **/
end_comment

begin_function
name|void
name|e1000_set_kmrn_lock_loss_workaround_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|boolean_t
name|state
parameter_list|)
block|{
name|struct
name|e1000_dev_spec_ich8lan
modifier|*
name|dev_spec
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_set_kmrn_lock_loss_workaround_ich8lan"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|!=
name|e1000_ich8lan
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Workaround applies to ICH8 only.\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|dev_spec
operator|=
operator|(
expr|struct
name|e1000_dev_spec_ich8lan
operator|*
operator|)
name|hw
operator|->
name|dev_spec
expr_stmt|;
if|if
condition|(
name|dev_spec
operator|==
name|NULL
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"dev_spec pointer is set to NULL.\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|dev_spec
operator|->
name|kmrn_lock_loss_workaround_enabled
operator|=
name|state
expr_stmt|;
name|out
label|:
return|return;
block|}
end_function

begin_comment
comment|/**  *  e1000_ipg3_phy_powerdown_workaround_ich8lan - Power down workaround on D3  *  @hw - pointer to the HW structure  *  *  Workaround for 82566 power-down on D3 entry:  *    1) disable gigabit link  *    2) write VR power-down enable  *    3) read it back  *  Continue if successful, else issue LCD reset and repeat  **/
end_comment

begin_function
name|void
name|e1000_igp3_phy_powerdown_workaround_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|reg
decl_stmt|;
name|u16
name|data
decl_stmt|;
name|u8
name|retry
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_igp3_phy_powerdown_workaround_ich8lan"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|type
operator|!=
name|e1000_phy_igp_3
condition|)
goto|goto
name|out
goto|;
comment|/* Try the workaround twice (if needed) */
do|do
block|{
comment|/* Disable link */
name|reg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PHY_CTRL
argument_list|)
expr_stmt|;
name|reg
operator||=
operator|(
name|E1000_PHY_CTRL_GBE_DISABLE
operator||
name|E1000_PHY_CTRL_NOND0A_GBE_DISABLE
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PHY_CTRL
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* Call gig speed drop workaround on Giga disable before 		 * accessing any PHY registers */
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_ich8lan
condition|)
name|e1000_gig_downshift_workaround_ich8lan
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Write VR power-down enable */
name|e1000_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP3_VR_CTRL
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
name|data
operator|&=
operator|~
name|IGP3_VR_CTRL_DEV_POWERDOWN_MODE_MASK
expr_stmt|;
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP3_VR_CTRL
argument_list|,
name|data
operator||
name|IGP3_VR_CTRL_MODE_SHUTDOWN
argument_list|)
expr_stmt|;
comment|/* Read it back and test */
name|e1000_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP3_VR_CTRL
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|data
operator|&
name|IGP3_VR_CTRL_MODE_SHUTDOWN
operator|)
operator|||
name|retry
condition|)
break|break;
comment|/* Issue PHY reset and repeat at most one more time */
name|reg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|,
name|reg
operator||
name|E1000_CTRL_PHY_RST
argument_list|)
expr_stmt|;
name|retry
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|retry
condition|)
do|;
name|out
label|:
return|return;
block|}
end_function

begin_comment
comment|/**  *  e1000_gig_downshift_workaround_ich8lan - WoL from S5 stops working  *  @hw - pointer to the HW structure  *  *  Steps to take when dropping from 1Gb/s (eg. link cable removal (LSC),  *  LPLU, Giga disable, MDIC PHY reset):  *    1) Set Kumeran Near-end loopback  *    2) Clear Kumeran Near-end loopback  *  Should only be called for ICH8[m] devices with IGP_3 Phy.  **/
end_comment

begin_function
name|void
name|e1000_gig_downshift_workaround_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|u16
name|reg_data
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_gig_downshift_workaround_ich8lan"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|!=
name|e1000_ich8lan
operator|)
operator|||
operator|(
name|hw
operator|->
name|phy
operator|.
name|type
operator|!=
name|e1000_phy_igp_3
operator|)
condition|)
goto|goto
name|out
goto|;
name|ret_val
operator|=
name|e1000_read_kmrn_reg
argument_list|(
name|hw
argument_list|,
name|E1000_KMRNCTRLSTA_DIAG_OFFSET
argument_list|,
operator|&
name|reg_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|reg_data
operator||=
name|E1000_KMRNCTRLSTA_DIAG_NELPBK
expr_stmt|;
name|ret_val
operator|=
name|e1000_write_kmrn_reg
argument_list|(
name|hw
argument_list|,
name|E1000_KMRNCTRLSTA_DIAG_OFFSET
argument_list|,
name|reg_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|reg_data
operator|&=
operator|~
name|E1000_KMRNCTRLSTA_DIAG_NELPBK
expr_stmt|;
name|ret_val
operator|=
name|e1000_write_kmrn_reg
argument_list|(
name|hw
argument_list|,
name|E1000_KMRNCTRLSTA_DIAG_OFFSET
argument_list|,
name|reg_data
argument_list|)
expr_stmt|;
name|out
label|:
return|return;
block|}
end_function

begin_comment
comment|/**  *  e1000_cleanup_led_ich8lan - Restore the default LED operation  *  @hw - pointer to the HW structure  *  *  Return the LED back to the default configuration.  **/
end_comment

begin_function
name|STATIC
name|s32
name|e1000_cleanup_led_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_cleanup_led_ich8lan"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|type
operator|==
name|e1000_phy_ife
condition|)
name|ret_val
operator|=
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|IFE_PHY_SPECIAL_CONTROL_LED
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_LEDCTL
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|ledctl_default
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_led_on_ich8lan - Turn LED's on  *  @hw - pointer to the HW structure  *  *  Turn on the LED's.  **/
end_comment

begin_function
name|STATIC
name|s32
name|e1000_led_on_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_led_on_ich8lan"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|type
operator|==
name|e1000_phy_ife
condition|)
name|ret_val
operator|=
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|IFE_PHY_SPECIAL_CONTROL_LED
argument_list|,
operator|(
name|IFE_PSCL_PROBE_MODE
operator||
name|IFE_PSCL_PROBE_LEDS_ON
operator|)
argument_list|)
expr_stmt|;
else|else
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_LEDCTL
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|ledctl_mode2
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_led_off_ich8lan - Turn LED's off  *  @hw - pointer to the HW structure  *  *  Turn off the LED's.  **/
end_comment

begin_function
name|STATIC
name|s32
name|e1000_led_off_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_led_off_ich8lan"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|type
operator|==
name|e1000_phy_ife
condition|)
name|ret_val
operator|=
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|IFE_PHY_SPECIAL_CONTROL_LED
argument_list|,
operator|(
name|IFE_PSCL_PROBE_MODE
operator||
name|IFE_PSCL_PROBE_LEDS_OFF
operator|)
argument_list|)
expr_stmt|;
else|else
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_LEDCTL
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|ledctl_mode1
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_get_cfg_done_ich8lan - Read config done bit  *  @hw - pointer to the HW structure  *  *  Read the management control register for the config done bit for  *  completion status.  NOTE: silicon which is EEPROM-less will fail trying  *  to read the config done bit, so an error is *ONLY* logged and returns  *  E1000_SUCCESS.  If we were to return with error, EEPROM-less silicon  *  would not be able to be reset or change link.  **/
end_comment

begin_function
name|STATIC
name|s32
name|e1000_get_cfg_done_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|e1000_get_cfg_done_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* If EEPROM is not marked present, init the IGP 3 PHY manually */
if|if
condition|(
operator|(
operator|(
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_EECD
argument_list|)
operator|&
name|E1000_EECD_PRES
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|hw
operator|->
name|phy
operator|.
name|type
operator|==
name|e1000_phy_igp_3
operator|)
condition|)
block|{
name|e1000_phy_init_script_igp3
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_clear_hw_cntrs_ich8lan - Clear statistical counters  *  @hw - pointer to the HW structure  *  *  Clears hardware counters specific to the silicon family and calls  *  clear_hw_cntrs_generic to clear all general purpose counters.  **/
end_comment

begin_function
name|STATIC
name|void
name|e1000_clear_hw_cntrs_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
specifier|volatile
name|u32
name|temp
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_clear_hw_cntrs_ich8lan"
argument_list|)
expr_stmt|;
name|e1000_clear_hw_cntrs_base_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_ALGNERRC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RXERRC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TNCRS
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CEXTERR
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TSCTC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TSCTFC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_MGTPRC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_MGTPDC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_MGTPTC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_IAC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_ICRXOC
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

