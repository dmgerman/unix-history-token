begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*******************************************************************************    Copyright (c) 2001-2007, Intel Corporation    All rights reserved.      Redistribution and use in source and binary forms, with or without    modification, are permitted provided that the following conditions are met:       1. Redistributions of source code must retain the above copyright notice,        this list of conditions and the following disclaimer.       2. Redistributions in binary form must reproduce the above copyright        notice, this list of conditions and the following disclaimer in the        documentation and/or other materials provided with the distribution.       3. Neither the name of the Intel Corporation nor the names of its        contributors may be used to endorse or promote products derived from        this software without specific prior written permission.      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE    ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR    CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF    SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN    CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)    ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE   POSSIBILITY OF SUCH DAMAGE.  *******************************************************************************/
end_comment

begin_function
name|$FreeBSD$
include|#
directive|include
file|"e1000_mac.h"
comment|/**  *  e1000_remove_device_generic - Free device specific structure  *  @hw - pointer to the HW structure  *  *  If a device specific structure was allocated, this function will  *  free it.  **/
name|void
name|e1000_remove_device_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"e1000_remove_device_generic"
argument_list|)
expr_stmt|;
comment|/* Freeing the dev_spec member of e1000_hw structure */
name|e1000_free_dev_spec_struct
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  e1000_get_bus_info_pci_generic - Get PCI(x) bus information  *  @hw - pointer to the HW structure  *  *  Determines and stores the system bus information for a particular  *  network interface.  The following bus information is determined and stored:  *  bus speed, bus width, type (PCI/PCIx), and PCI(-x) function.  **/
end_comment

begin_function
name|s32
name|e1000_get_bus_info_pci_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_bus_info
modifier|*
name|bus
init|=
operator|&
name|hw
operator|->
name|bus
decl_stmt|;
name|u32
name|status
init|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_STATUS
argument_list|)
decl_stmt|;
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|u16
name|pci_header_type
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_get_bus_info_pci_generic"
argument_list|)
expr_stmt|;
comment|/* PCI or PCI-X? */
name|bus
operator|->
name|type
operator|=
operator|(
name|status
operator|&
name|E1000_STATUS_PCIX_MODE
operator|)
condition|?
name|e1000_bus_type_pcix
else|:
name|e1000_bus_type_pci
expr_stmt|;
comment|/* Bus speed */
if|if
condition|(
name|bus
operator|->
name|type
operator|==
name|e1000_bus_type_pci
condition|)
block|{
name|bus
operator|->
name|speed
operator|=
operator|(
name|status
operator|&
name|E1000_STATUS_PCI66
operator|)
condition|?
name|e1000_bus_speed_66
else|:
name|e1000_bus_speed_33
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|status
operator|&
name|E1000_STATUS_PCIX_SPEED
condition|)
block|{
case|case
name|E1000_STATUS_PCIX_SPEED_66
case|:
name|bus
operator|->
name|speed
operator|=
name|e1000_bus_speed_66
expr_stmt|;
break|break;
case|case
name|E1000_STATUS_PCIX_SPEED_100
case|:
name|bus
operator|->
name|speed
operator|=
name|e1000_bus_speed_100
expr_stmt|;
break|break;
case|case
name|E1000_STATUS_PCIX_SPEED_133
case|:
name|bus
operator|->
name|speed
operator|=
name|e1000_bus_speed_133
expr_stmt|;
break|break;
default|default:
name|bus
operator|->
name|speed
operator|=
name|e1000_bus_speed_reserved
expr_stmt|;
break|break;
block|}
block|}
comment|/* Bus width */
name|bus
operator|->
name|width
operator|=
operator|(
name|status
operator|&
name|E1000_STATUS_BUS64
operator|)
condition|?
name|e1000_bus_width_64
else|:
name|e1000_bus_width_32
expr_stmt|;
comment|/* Which PCI(-X) function? */
name|e1000_read_pci_cfg
argument_list|(
name|hw
argument_list|,
name|PCI_HEADER_TYPE_REGISTER
argument_list|,
operator|&
name|pci_header_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|pci_header_type
operator|&
name|PCI_HEADER_TYPE_MULTIFUNC
condition|)
name|bus
operator|->
name|func
operator|=
operator|(
name|status
operator|&
name|E1000_STATUS_FUNC_MASK
operator|)
operator|>>
name|E1000_STATUS_FUNC_SHIFT
expr_stmt|;
else|else
name|bus
operator|->
name|func
operator|=
literal|0
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_get_bus_info_pcie_generic - Get PCIe bus information  *  @hw - pointer to the HW structure  *  *  Determines and stores the system bus information for a particular  *  network interface.  The following bus information is determined and stored:  *  bus speed, bus width, type (PCIe), and PCIe function.  **/
end_comment

begin_function
name|s32
name|e1000_get_bus_info_pcie_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_bus_info
modifier|*
name|bus
init|=
operator|&
name|hw
operator|->
name|bus
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|u32
name|status
decl_stmt|;
name|u16
name|pcie_link_status
decl_stmt|,
name|pci_header_type
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_get_bus_info_pcie_generic"
argument_list|)
expr_stmt|;
name|bus
operator|->
name|type
operator|=
name|e1000_bus_type_pci_express
expr_stmt|;
name|bus
operator|->
name|speed
operator|=
name|e1000_bus_speed_2500
expr_stmt|;
name|ret_val
operator|=
name|e1000_read_pcie_cap_reg
argument_list|(
name|hw
argument_list|,
name|PCIE_LINK_STATUS
argument_list|,
operator|&
name|pcie_link_status
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
name|bus
operator|->
name|width
operator|=
name|e1000_bus_width_unknown
expr_stmt|;
else|else
name|bus
operator|->
name|width
operator|=
call|(
name|e1000_bus_width
call|)
argument_list|(
operator|(
name|pcie_link_status
operator|&
name|PCIE_LINK_WIDTH_MASK
operator|)
operator|>>
name|PCIE_LINK_WIDTH_SHIFT
argument_list|)
expr_stmt|;
name|e1000_read_pci_cfg
argument_list|(
name|hw
argument_list|,
name|PCI_HEADER_TYPE_REGISTER
argument_list|,
operator|&
name|pci_header_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|pci_header_type
operator|&
name|PCI_HEADER_TYPE_MULTIFUNC
condition|)
block|{
name|status
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_STATUS
argument_list|)
expr_stmt|;
name|bus
operator|->
name|func
operator|=
operator|(
name|status
operator|&
name|E1000_STATUS_FUNC_MASK
operator|)
operator|>>
name|E1000_STATUS_FUNC_SHIFT
expr_stmt|;
block|}
else|else
name|bus
operator|->
name|func
operator|=
literal|0
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_clear_vfta_generic - Clear VLAN filter table  *  @hw - pointer to the HW structure  *  *  Clears the register array which contains the VLAN filter table by  *  setting all the values to 0.  **/
end_comment

begin_function
name|void
name|e1000_clear_vfta_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|offset
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_clear_vfta_generic"
argument_list|)
expr_stmt|;
for|for
control|(
name|offset
operator|=
literal|0
init|;
name|offset
operator|<
name|E1000_VLAN_FILTER_TBL_SIZE
condition|;
name|offset
operator|++
control|)
block|{
name|E1000_WRITE_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|E1000_VFTA
argument_list|,
name|offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  *  e1000_write_vfta_generic - Write value to VLAN filter table  *  @hw - pointer to the HW structure  *  @offset - register offset in VLAN filter table  *  @value - register value written to VLAN filter table  *  *  Writes value at the given offset in the register array which stores  *  the VLAN filter table.  **/
end_comment

begin_function
name|void
name|e1000_write_vfta_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u32
name|value
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"e1000_write_vfta_generic"
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|E1000_VFTA
argument_list|,
name|offset
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  e1000_init_rx_addrs_generic - Initialize receive address's  *  @hw - pointer to the HW structure  *  @rar_count - receive address registers  *  *  Setups the receive address registers by setting the base receive address  *  register to the devices MAC address and clearing all the other receive  *  address registers to 0.  **/
end_comment

begin_function
name|void
name|e1000_init_rx_addrs_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|rar_count
parameter_list|)
block|{
name|u32
name|i
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_init_rx_addrs_generic"
argument_list|)
expr_stmt|;
comment|/* Setup the receive address */
name|DEBUGOUT
argument_list|(
literal|"Programming MAC Address into RAR[0]\n"
argument_list|)
expr_stmt|;
name|e1000_rar_set_generic
argument_list|(
name|hw
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Zero out the other (rar_entry_count - 1) receive addresses */
name|DEBUGOUT1
argument_list|(
literal|"Clearing RAR[1-%u]\n"
argument_list|,
name|rar_count
operator|-
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|rar_count
condition|;
name|i
operator|++
control|)
block|{
name|E1000_WRITE_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|E1000_RA
argument_list|,
operator|(
name|i
operator|<<
literal|1
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|E1000_RA
argument_list|,
operator|(
operator|(
name|i
operator|<<
literal|1
operator|)
operator|+
literal|1
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  *  e1000_rar_set_generic - Set receive address register  *  @hw - pointer to the HW structure  *  @addr - pointer to the receive address  *  @index - receive address array register  *  *  Sets the receive address array register at index to the address passed  *  in by addr.  **/
end_comment

begin_function
name|void
name|e1000_rar_set_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u8
modifier|*
name|addr
parameter_list|,
name|u32
name|index
parameter_list|)
block|{
name|u32
name|rar_low
decl_stmt|,
name|rar_high
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_rar_set_generic"
argument_list|)
expr_stmt|;
comment|/* HW expects these in little endian so we reverse the byte order 	 * from network order (big endian) to little endian 	 */
name|rar_low
operator|=
operator|(
operator|(
name|u32
operator|)
name|addr
index|[
literal|0
index|]
operator||
operator|(
operator|(
name|u32
operator|)
name|addr
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
name|u32
operator|)
name|addr
index|[
literal|2
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|u32
operator|)
name|addr
index|[
literal|3
index|]
operator|<<
literal|24
operator|)
operator|)
expr_stmt|;
name|rar_high
operator|=
operator|(
operator|(
name|u32
operator|)
name|addr
index|[
literal|4
index|]
operator||
operator|(
operator|(
name|u32
operator|)
name|addr
index|[
literal|5
index|]
operator|<<
literal|8
operator|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|hw
operator|->
name|mac
operator|.
name|disable_av
condition|)
name|rar_high
operator||=
name|E1000_RAH_AV
expr_stmt|;
name|E1000_WRITE_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|E1000_RA
argument_list|,
operator|(
name|index
operator|<<
literal|1
operator|)
argument_list|,
name|rar_low
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|E1000_RA
argument_list|,
operator|(
operator|(
name|index
operator|<<
literal|1
operator|)
operator|+
literal|1
operator|)
argument_list|,
name|rar_high
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  e1000_mta_set_generic - Set multicast filter table address  *  @hw - pointer to the HW structure  *  @hash_value - determines the MTA register and bit to set  *  *  The multicast table address is a register array of 32-bit registers.  *  The hash_value is used to determine what register the bit is in, the  *  current value is read, the new bit is OR'd in and the new value is  *  written back into the register.  **/
end_comment

begin_function
name|void
name|e1000_mta_set_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|hash_value
parameter_list|)
block|{
name|u32
name|hash_bit
decl_stmt|,
name|hash_reg
decl_stmt|,
name|mta
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_mta_set_generic"
argument_list|)
expr_stmt|;
comment|/* The MTA is a register array of 32-bit registers. It is 	 * treated like an array of (32*mta_reg_count) bits.  We want to 	 * set bit BitArray[hash_value]. So we figure out what register 	 * the bit is in, read it, OR in the new bit, then write 	 * back the new value.  The (hw->mac.mta_reg_count - 1) serves as a 	 * mask to bits 31:5 of the hash value which gives us the 	 * register we're modifying.  The hash bit within that register 	 * is determined by the lower 5 bits of the hash value. 	 */
name|hash_reg
operator|=
operator|(
name|hash_value
operator|>>
literal|5
operator|)
operator|&
operator|(
name|hw
operator|->
name|mac
operator|.
name|mta_reg_count
operator|-
literal|1
operator|)
expr_stmt|;
name|hash_bit
operator|=
name|hash_value
operator|&
literal|0x1F
expr_stmt|;
name|mta
operator|=
name|E1000_READ_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|E1000_MTA
argument_list|,
name|hash_reg
argument_list|)
expr_stmt|;
name|mta
operator||=
operator|(
literal|1
operator|<<
name|hash_bit
operator|)
expr_stmt|;
name|E1000_WRITE_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|E1000_MTA
argument_list|,
name|hash_reg
argument_list|,
name|mta
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  e1000_mc_addr_list_update_generic - Update Multicast addresses  *  @hw - pointer to the HW structure  *  @mc_addr_list - array of multicast addresses to program  *  @mc_addr_count - number of multicast addresses to program  *  @rar_used_count - the first RAR register free to program  *  @rar_count - total number of supported Receive Address Registers  *  *  Updates the Receive Address Registers and Multicast Table Array.  *  The caller must have a packed mc_addr_list of multicast addresses.  *  The parameter rar_count will usually be hw->mac.rar_entry_count  *  unless there are workarounds that change this.  **/
end_comment

begin_function
name|void
name|e1000_mc_addr_list_update_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u8
modifier|*
name|mc_addr_list
parameter_list|,
name|u32
name|mc_addr_count
parameter_list|,
name|u32
name|rar_used_count
parameter_list|,
name|u32
name|rar_count
parameter_list|)
block|{
name|u32
name|hash_value
decl_stmt|;
name|u32
name|i
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_mc_addr_list_update_generic"
argument_list|)
expr_stmt|;
comment|/* Load the first set of multicast addresses into the exact 	 * filters (RAR).  If there are not enough to fill the RAR 	 * array, clear the filters. 	 */
for|for
control|(
name|i
operator|=
name|rar_used_count
init|;
name|i
operator|<
name|rar_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|mc_addr_count
condition|)
block|{
name|e1000_rar_set
argument_list|(
name|hw
argument_list|,
name|mc_addr_list
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|mc_addr_count
operator|--
expr_stmt|;
name|mc_addr_list
operator|+=
name|ETH_ADDR_LEN
expr_stmt|;
block|}
else|else
block|{
name|E1000_WRITE_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|E1000_RA
argument_list|,
name|i
operator|<<
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|E1000_RA
argument_list|,
operator|(
name|i
operator|<<
literal|1
operator|)
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Clear the old settings from the MTA */
name|DEBUGOUT
argument_list|(
literal|"Clearing MTA\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hw
operator|->
name|mac
operator|.
name|mta_reg_count
condition|;
name|i
operator|++
control|)
block|{
name|E1000_WRITE_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|E1000_MTA
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
comment|/* Load any remaining multicast addresses into the hash table. */
for|for
control|(
init|;
name|mc_addr_count
operator|>
literal|0
condition|;
name|mc_addr_count
operator|--
control|)
block|{
name|hash_value
operator|=
name|e1000_hash_mc_addr
argument_list|(
name|hw
argument_list|,
name|mc_addr_list
argument_list|)
expr_stmt|;
name|DEBUGOUT1
argument_list|(
literal|"Hash value = 0x%03X\n"
argument_list|,
name|hash_value
argument_list|)
expr_stmt|;
name|e1000_mta_set
argument_list|(
name|hw
argument_list|,
name|hash_value
argument_list|)
expr_stmt|;
name|mc_addr_list
operator|+=
name|ETH_ADDR_LEN
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  *  e1000_hash_mc_addr_generic - Generate a multicast hash value  *  @hw - pointer to the HW structure  *  @mc_addr - pointer to a multicast address  *  *  Generates a multicast address hash value which is used to determine  *  the multicast filter table array address and new table value.  See  *  e1000_mta_set_generic()  **/
end_comment

begin_function
name|u32
name|e1000_hash_mc_addr_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u8
modifier|*
name|mc_addr
parameter_list|)
block|{
name|u32
name|hash_value
decl_stmt|,
name|hash_mask
decl_stmt|;
name|u8
name|bit_shift
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_hash_mc_addr_generic"
argument_list|)
expr_stmt|;
comment|/* Register count multiplied by bits per register */
name|hash_mask
operator|=
operator|(
name|hw
operator|->
name|mac
operator|.
name|mta_reg_count
operator|*
literal|32
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* For a mc_filter_type of 0, bit_shift is the number of left-shifts 	 * where 0xFF would still fall within the hash mask. */
while|while
condition|(
name|hash_mask
operator|>>
name|bit_shift
operator|!=
literal|0xFF
condition|)
name|bit_shift
operator|++
expr_stmt|;
comment|/* The portion of the address that is used for the hash table 	 * is determined by the mc_filter_type setting. 	 * The algorithm is such that there is a total of 8 bits of shifting. 	 * The bit_shift for a mc_filter_type of 0 represents the number of 	 * left-shifts where the MSB of mc_addr[5] would still fall within 	 * the hash_mask.  Case 0 does this exactly.  Since there are a total 	 * of 8 bits of shifting, then mc_addr[4] will shift right the 	 * remaining number of bits. Thus 8 - bit_shift.  The rest of the 	 * cases are a variation of this algorithm...essentially raising the 	 * number of bits to shift mc_addr[5] left, while still keeping the 	 * 8-bit shifting total. 	 */
comment|/* For example, given the following Destination MAC Address and an 	 * mta register count of 128 (thus a 4096-bit vector and 0xFFF mask), 	 * we can see that the bit_shift for case 0 is 4.  These are the hash 	 * values resulting from each mc_filter_type... 	 * [0] [1] [2] [3] [4] [5] 	 * 01  AA  00  12  34  56 	 * LSB                 MSB 	 * 	 * case 0: hash_value = ((0x34>> 4) | (0x56<< 4))& 0xFFF = 0x563 	 * case 1: hash_value = ((0x34>> 3) | (0x56<< 5))& 0xFFF = 0xAC6 	 * case 2: hash_value = ((0x34>> 2) | (0x56<< 6))& 0xFFF = 0x163 	 * case 3: hash_value = ((0x34>> 0) | (0x56<< 8))& 0xFFF = 0x634 	 */
switch|switch
condition|(
name|hw
operator|->
name|mac
operator|.
name|mc_filter_type
condition|)
block|{
default|default:
case|case
literal|0
case|:
break|break;
case|case
literal|1
case|:
name|bit_shift
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|bit_shift
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|bit_shift
operator|+=
literal|4
expr_stmt|;
break|break;
block|}
name|hash_value
operator|=
name|hash_mask
operator|&
operator|(
operator|(
operator|(
name|mc_addr
index|[
literal|4
index|]
operator|>>
operator|(
literal|8
operator|-
name|bit_shift
operator|)
operator|)
operator||
operator|(
operator|(
operator|(
name|u16
operator|)
name|mc_addr
index|[
literal|5
index|]
operator|)
operator|<<
name|bit_shift
operator|)
operator|)
operator|)
expr_stmt|;
return|return
name|hash_value
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_pcix_mmrbc_workaround_generic - Fix incorrect MMRBC value  *  @hw - pointer to the HW structure  *  *  In certain situations, a system BIOS may report that the PCIx maximum  *  memory read byte count (MMRBC) value is higher than than the actual  *  value. We check the PCIx command regsiter with the current PCIx status  *  regsiter.  **/
end_comment

begin_function
name|void
name|e1000_pcix_mmrbc_workaround_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u16
name|cmd_mmrbc
decl_stmt|;
name|u16
name|pcix_cmd
decl_stmt|;
name|u16
name|pcix_stat_hi_word
decl_stmt|;
name|u16
name|stat_mmrbc
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_pcix_mmrbc_workaround_generic"
argument_list|)
expr_stmt|;
comment|/* Workaround for PCI-X issue when BIOS sets MMRBC incorrectly */
if|if
condition|(
name|hw
operator|->
name|bus
operator|.
name|type
operator|!=
name|e1000_bus_type_pcix
condition|)
return|return;
name|e1000_read_pci_cfg
argument_list|(
name|hw
argument_list|,
name|PCIX_COMMAND_REGISTER
argument_list|,
operator|&
name|pcix_cmd
argument_list|)
expr_stmt|;
name|e1000_read_pci_cfg
argument_list|(
name|hw
argument_list|,
name|PCIX_STATUS_REGISTER_HI
argument_list|,
operator|&
name|pcix_stat_hi_word
argument_list|)
expr_stmt|;
name|cmd_mmrbc
operator|=
operator|(
name|pcix_cmd
operator|&
name|PCIX_COMMAND_MMRBC_MASK
operator|)
operator|>>
name|PCIX_COMMAND_MMRBC_SHIFT
expr_stmt|;
name|stat_mmrbc
operator|=
operator|(
name|pcix_stat_hi_word
operator|&
name|PCIX_STATUS_HI_MMRBC_MASK
operator|)
operator|>>
name|PCIX_STATUS_HI_MMRBC_SHIFT
expr_stmt|;
if|if
condition|(
name|stat_mmrbc
operator|==
name|PCIX_STATUS_HI_MMRBC_4K
condition|)
name|stat_mmrbc
operator|=
name|PCIX_STATUS_HI_MMRBC_2K
expr_stmt|;
if|if
condition|(
name|cmd_mmrbc
operator|>
name|stat_mmrbc
condition|)
block|{
name|pcix_cmd
operator|&=
operator|~
name|PCIX_COMMAND_MMRBC_MASK
expr_stmt|;
name|pcix_cmd
operator||=
name|stat_mmrbc
operator|<<
name|PCIX_COMMAND_MMRBC_SHIFT
expr_stmt|;
name|e1000_write_pci_cfg
argument_list|(
name|hw
argument_list|,
name|PCIX_COMMAND_REGISTER
argument_list|,
operator|&
name|pcix_cmd
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  *  e1000_clear_hw_cntrs_base_generic - Clear base hardware counters  *  @hw - pointer to the HW structure  *  *  Clears the base hardware counters by reading the counter registers.  **/
end_comment

begin_function
name|void
name|e1000_clear_hw_cntrs_base_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
specifier|volatile
name|u32
name|temp
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_clear_hw_cntrs_base_generic"
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CRCERRS
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_SYMERRS
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_MPC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_SCC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_ECOL
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_MCC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_LATECOL
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_COLC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_DC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_SEC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RLEC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_XONRXC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_XONTXC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_XOFFRXC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_XOFFTXC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_FCRUC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_GPRC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_BPRC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_MPRC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_GPTC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_GORCL
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_GORCH
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_GOTCL
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_GOTCH
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RNBC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RUC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RFC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_ROC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RJC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TORL
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TORH
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TOTL
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TOTH
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TPR
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TPT
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_MPTC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_BPTC
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  e1000_check_for_copper_link_generic - Check for link (Copper)  *  @hw - pointer to the HW structure  *  *  Checks to see of the link status of the hardware has changed.  If a  *  change in link status has been detected, then we read the PHY registers  *  to get the current speed/duplex if link exists.  **/
end_comment

begin_function
name|s32
name|e1000_check_for_copper_link_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_mac_info
modifier|*
name|mac
init|=
operator|&
name|hw
operator|->
name|mac
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|boolean_t
name|link
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_check_for_copper_link"
argument_list|)
expr_stmt|;
comment|/* We only want to go out to the PHY registers to see if Auto-Neg 	 * has completed and/or if our link status has changed.  The 	 * get_link_status flag is set upon receiving a Link Status 	 * Change or Rx Sequence Error interrupt. 	 */
if|if
condition|(
operator|!
name|mac
operator|->
name|get_link_status
condition|)
block|{
name|ret_val
operator|=
name|E1000_SUCCESS
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* First we want to see if the MII Status Register reports 	 * link.  If so, then we want to get the current speed/duplex 	 * of the PHY. 	 */
name|ret_val
operator|=
name|e1000_phy_has_link_generic
argument_list|(
name|hw
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
operator|&
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|!
name|link
condition|)
goto|goto
name|out
goto|;
comment|/* No link detected */
name|mac
operator|->
name|get_link_status
operator|=
name|FALSE
expr_stmt|;
comment|/* Check if there was DownShift, must be checked 	 * immediately after link-up */
name|e1000_check_downshift_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* If we are forcing speed/duplex, then we simply return since 	 * we have already determined whether we have link or not. 	 */
if|if
condition|(
operator|!
name|mac
operator|->
name|autoneg
condition|)
block|{
name|ret_val
operator|=
operator|-
name|E1000_ERR_CONFIG
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Auto-Neg is enabled.  Auto Speed Detection takes care 	 * of MAC speed/duplex configuration.  So we only need to 	 * configure Collision Distance in the MAC. 	 */
name|e1000_config_collision_dist_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Configure Flow Control now that Auto-Neg has completed. 	 * First, we need to restore the desired flow control 	 * settings because we may have had to re-autoneg with a 	 * different link partner. 	 */
name|ret_val
operator|=
name|e1000_config_fc_after_link_up_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Error configuring flow control\n"
argument_list|)
expr_stmt|;
block|}
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_check_for_fiber_link_generic - Check for link (Fiber)  *  @hw - pointer to the HW structure  *  *  Checks for link up on the hardware.  If link is not up and we have  *  a signal, then we need to force link up.  **/
end_comment

begin_function
name|s32
name|e1000_check_for_fiber_link_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_mac_info
modifier|*
name|mac
init|=
operator|&
name|hw
operator|->
name|mac
decl_stmt|;
name|u32
name|rxcw
decl_stmt|;
name|u32
name|ctrl
decl_stmt|;
name|u32
name|status
decl_stmt|;
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_check_for_fiber_link_generic"
argument_list|)
expr_stmt|;
name|ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|)
expr_stmt|;
name|status
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_STATUS
argument_list|)
expr_stmt|;
name|rxcw
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RXCW
argument_list|)
expr_stmt|;
comment|/* If we don't have link (auto-negotiation failed or link partner 	 * cannot auto-negotiate), the cable is plugged in (we have signal), 	 * and our link partner is not trying to auto-negotiate with us (we 	 * are receiving idles or data), we need to force link up. We also 	 * need to give auto-negotiation time to complete, in case the cable 	 * was just plugged in. The autoneg_failed flag does this. 	 */
comment|/* (ctrl& E1000_CTRL_SWDPIN1) == 1 == have signal */
if|if
condition|(
operator|(
name|ctrl
operator|&
name|E1000_CTRL_SWDPIN1
operator|)
operator|&&
operator|(
operator|!
operator|(
name|status
operator|&
name|E1000_STATUS_LU
operator|)
operator|)
operator|&&
operator|(
operator|!
operator|(
name|rxcw
operator|&
name|E1000_RXCW_C
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|mac
operator|->
name|autoneg_failed
operator|==
literal|0
condition|)
block|{
name|mac
operator|->
name|autoneg_failed
operator|=
literal|1
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|DEBUGOUT
argument_list|(
literal|"NOT RXing /C/, disable AutoNeg and force link.\n"
argument_list|)
expr_stmt|;
comment|/* Disable auto-negotiation in the TXCW register */
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TXCW
argument_list|,
operator|(
name|mac
operator|->
name|txcw
operator|&
operator|~
name|E1000_TXCW_ANE
operator|)
argument_list|)
expr_stmt|;
comment|/* Force link-up and also force full-duplex. */
name|ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|)
expr_stmt|;
name|ctrl
operator||=
operator|(
name|E1000_CTRL_SLU
operator||
name|E1000_CTRL_FD
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
comment|/* Configure Flow Control after forcing link up. */
name|ret_val
operator|=
name|e1000_config_fc_after_link_up_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Error configuring flow control\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|ctrl
operator|&
name|E1000_CTRL_SLU
operator|)
operator|&&
operator|(
name|rxcw
operator|&
name|E1000_RXCW_C
operator|)
condition|)
block|{
comment|/* If we are forcing link and we are receiving /C/ ordered 		 * sets, re-enable auto-negotiation in the TXCW register 		 * and disable forced link in the Device Control register 		 * in an attempt to auto-negotiate with our link partner. 		 */
name|DEBUGOUT
argument_list|(
literal|"RXing /C/, enable AutoNeg and stop forcing link.\n"
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TXCW
argument_list|,
name|mac
operator|->
name|txcw
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|,
operator|(
name|ctrl
operator|&
operator|~
name|E1000_CTRL_SLU
operator|)
argument_list|)
expr_stmt|;
name|mac
operator|->
name|serdes_has_link
operator|=
name|TRUE
expr_stmt|;
block|}
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_check_for_serdes_link_generic - Check for link (Serdes)  *  @hw - pointer to the HW structure  *  *  Checks for link up on the hardware.  If link is not up and we have  *  a signal, then we need to force link up.  **/
end_comment

begin_function
name|s32
name|e1000_check_for_serdes_link_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_mac_info
modifier|*
name|mac
init|=
operator|&
name|hw
operator|->
name|mac
decl_stmt|;
name|u32
name|rxcw
decl_stmt|;
name|u32
name|ctrl
decl_stmt|;
name|u32
name|status
decl_stmt|;
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_check_for_serdes_link_generic"
argument_list|)
expr_stmt|;
name|ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|)
expr_stmt|;
name|status
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_STATUS
argument_list|)
expr_stmt|;
name|rxcw
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RXCW
argument_list|)
expr_stmt|;
comment|/* If we don't have link (auto-negotiation failed or link partner 	 * cannot auto-negotiate), and our link partner is not trying to 	 * auto-negotiate with us (we are receiving idles or data), 	 * we need to force link up. We also need to give auto-negotiation 	 * time to complete. 	 */
comment|/* (ctrl& E1000_CTRL_SWDPIN1) == 1 == have signal */
if|if
condition|(
operator|(
operator|!
operator|(
name|status
operator|&
name|E1000_STATUS_LU
operator|)
operator|)
operator|&&
operator|(
operator|!
operator|(
name|rxcw
operator|&
name|E1000_RXCW_C
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|mac
operator|->
name|autoneg_failed
operator|==
literal|0
condition|)
block|{
name|mac
operator|->
name|autoneg_failed
operator|=
literal|1
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|DEBUGOUT
argument_list|(
literal|"NOT RXing /C/, disable AutoNeg and force link.\n"
argument_list|)
expr_stmt|;
comment|/* Disable auto-negotiation in the TXCW register */
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TXCW
argument_list|,
operator|(
name|mac
operator|->
name|txcw
operator|&
operator|~
name|E1000_TXCW_ANE
operator|)
argument_list|)
expr_stmt|;
comment|/* Force link-up and also force full-duplex. */
name|ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|)
expr_stmt|;
name|ctrl
operator||=
operator|(
name|E1000_CTRL_SLU
operator||
name|E1000_CTRL_FD
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
comment|/* Configure Flow Control after forcing link up. */
name|ret_val
operator|=
name|e1000_config_fc_after_link_up_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Error configuring flow control\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|ctrl
operator|&
name|E1000_CTRL_SLU
operator|)
operator|&&
operator|(
name|rxcw
operator|&
name|E1000_RXCW_C
operator|)
condition|)
block|{
comment|/* If we are forcing link and we are receiving /C/ ordered 		 * sets, re-enable auto-negotiation in the TXCW register 		 * and disable forced link in the Device Control register 		 * in an attempt to auto-negotiate with our link partner. 		 */
name|DEBUGOUT
argument_list|(
literal|"RXing /C/, enable AutoNeg and stop forcing link.\n"
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TXCW
argument_list|,
name|mac
operator|->
name|txcw
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|,
operator|(
name|ctrl
operator|&
operator|~
name|E1000_CTRL_SLU
operator|)
argument_list|)
expr_stmt|;
name|mac
operator|->
name|serdes_has_link
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|E1000_TXCW_ANE
operator|&
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TXCW
argument_list|)
operator|)
condition|)
block|{
comment|/* If we force link for non-auto-negotiation switch, check 		 * link status based on MAC synchronization for internal 		 * serdes media type. 		 */
comment|/* SYNCH bit and IV bit are sticky. */
name|usec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|E1000_RXCW_SYNCH
operator|&
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RXCW
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|rxcw
operator|&
name|E1000_RXCW_IV
operator|)
condition|)
block|{
name|mac
operator|->
name|serdes_has_link
operator|=
name|TRUE
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"SERDES: Link is up.\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|mac
operator|->
name|serdes_has_link
operator|=
name|FALSE
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"SERDES: Link is down.\n"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|E1000_TXCW_ANE
operator|&
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TXCW
argument_list|)
condition|)
block|{
name|status
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_STATUS
argument_list|)
expr_stmt|;
name|mac
operator|->
name|serdes_has_link
operator|=
operator|(
name|status
operator|&
name|E1000_STATUS_LU
operator|)
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
block|}
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_setup_link_generic - Setup flow control and link settings  *  @hw - pointer to the HW structure  *  *  Determines which flow control settings to use, then configures flow  *  control.  Calls the appropriate media-specific link configuration  *  function.  Assuming the adapter has a valid link partner, a valid link  *  should be established.  Assumes the hardware has previously been reset  *  and the transmitter and receiver are not enabled.  **/
end_comment

begin_function
name|s32
name|e1000_setup_link_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_mac_info
modifier|*
name|mac
init|=
operator|&
name|hw
operator|->
name|mac
decl_stmt|;
name|struct
name|e1000_functions
modifier|*
name|func
init|=
operator|&
name|hw
operator|->
name|func
decl_stmt|;
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_setup_link_generic"
argument_list|)
expr_stmt|;
comment|/* In the case of the phy reset being blocked, we already have a link. 	 * We do not need to set it up again. 	 */
if|if
condition|(
name|e1000_check_reset_block
argument_list|(
name|hw
argument_list|)
condition|)
goto|goto
name|out
goto|;
name|ret_val
operator|=
name|e1000_set_default_fc_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
comment|/* We want to save off the original Flow Control configuration just 	 * in case we get disconnected and then reconnected into a different 	 * hub or switch with different Flow Control capabilities. 	 */
name|mac
operator|->
name|original_fc
operator|=
name|mac
operator|->
name|fc
expr_stmt|;
name|DEBUGOUT1
argument_list|(
literal|"After fix-ups FlowControl is now = %x\n"
argument_list|,
name|mac
operator|->
name|fc
argument_list|)
expr_stmt|;
comment|/* Call the necessary media_type subroutine to configure the link. */
name|ret_val
operator|=
name|func
operator|->
name|setup_physical_interface
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
comment|/* Initialize the flow control address, type, and PAUSE timer 	 * registers to their default values.  This is done even if flow 	 * control is disabled, because it does not hurt anything to 	 * initialize these registers. 	 */
name|DEBUGOUT
argument_list|(
literal|"Initializing the Flow Control address, type and timer regs\n"
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_FCT
argument_list|,
name|FLOW_CONTROL_TYPE
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_FCAH
argument_list|,
name|FLOW_CONTROL_ADDRESS_HIGH
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_FCAL
argument_list|,
name|FLOW_CONTROL_ADDRESS_LOW
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_FCTTV
argument_list|,
name|mac
operator|->
name|fc_pause_time
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_set_fc_watermarks_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_setup_fiber_serdes_link_generic - Setup link for fiber/serdes  *  @hw - pointer to the HW structure  *  *  Configures collision distance and flow control for fiber and serdes  *  links.  Upon successful setup, poll for link.  **/
end_comment

begin_function
name|s32
name|e1000_setup_fiber_serdes_link_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|ctrl
decl_stmt|;
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_setup_fiber_serdes_link_generic"
argument_list|)
expr_stmt|;
name|ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|)
expr_stmt|;
comment|/* Take the link out of reset */
name|ctrl
operator|&=
operator|~
name|E1000_CTRL_LRST
expr_stmt|;
name|e1000_config_collision_dist_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_commit_fc_settings_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
comment|/* Since auto-negotiation is enabled, take the link out of reset (the 	 * link will be in reset, because we previously reset the chip). This 	 * will restart auto-negotiation.  If auto-negotiation is successful 	 * then the link-up status bit will be set and the flow control enable 	 * bits (RFCE and TFCE) will be set according to their negotiated value. 	 */
name|DEBUGOUT
argument_list|(
literal|"Auto-negotiation enabled\n"
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|msec_delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* For these adapters, the SW defineable pin 1 is set when the optics 	 * detect a signal.  If we have a signal, then poll for a "Link-Up" 	 * indication. 	 */
if|if
condition|(
name|hw
operator|->
name|media_type
operator|==
name|e1000_media_type_internal_serdes
operator|||
operator|(
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|)
operator|&
name|E1000_CTRL_SWDPIN1
operator|)
condition|)
block|{
name|ret_val
operator|=
name|e1000_poll_fiber_serdes_link_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DEBUGOUT
argument_list|(
literal|"No signal detected\n"
argument_list|)
expr_stmt|;
block|}
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_config_collision_dist_generic - Configure collision distance  *  @hw - pointer to the HW structure  *  *  Configures the collision distance to the default value and is used  *  during link setup. Currently no func pointer exists and all  *  implementations are handled in the generic version of this function.  **/
end_comment

begin_function
name|void
name|e1000_config_collision_dist_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|tctl
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_config_collision_dist_generic"
argument_list|)
expr_stmt|;
name|tctl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TCTL
argument_list|)
expr_stmt|;
name|tctl
operator|&=
operator|~
name|E1000_TCTL_COLD
expr_stmt|;
name|tctl
operator||=
name|E1000_COLLISION_DISTANCE
operator|<<
name|E1000_COLD_SHIFT
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TCTL
argument_list|,
name|tctl
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  e1000_poll_fiber_serdes_link_generic - Poll for link up  *  @hw - pointer to the HW structure  *  *  Polls for link up by reading the status register, if link fails to come  *  up with auto-negotiation, then the link is forced if a signal is detected.  **/
end_comment

begin_function
name|s32
name|e1000_poll_fiber_serdes_link_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_mac_info
modifier|*
name|mac
init|=
operator|&
name|hw
operator|->
name|mac
decl_stmt|;
name|u32
name|i
decl_stmt|,
name|status
decl_stmt|;
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_poll_fiber_serdes_link_generic"
argument_list|)
expr_stmt|;
comment|/* If we have a signal (the cable is plugged in, or assumed true for 	 * serdes media) then poll for a "Link-Up" indication in the Device 	 * Status Register.  Time-out if a link isn't seen in 500 milliseconds 	 * seconds (Auto-negotiation should complete in less than 500 	 * milliseconds even if the other end is doing it in SW). 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIBER_LINK_UP_LIMIT
condition|;
name|i
operator|++
control|)
block|{
name|msec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|status
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|E1000_STATUS_LU
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|FIBER_LINK_UP_LIMIT
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Never got a valid link from auto-neg!!!\n"
argument_list|)
expr_stmt|;
name|mac
operator|->
name|autoneg_failed
operator|=
literal|1
expr_stmt|;
comment|/* AutoNeg failed to achieve a link, so we'll call 		 * mac->check_for_link. This routine will force the 		 * link up if we detect a signal. This will allow us to 		 * communicate with non-autonegotiating link partners. 		 */
name|ret_val
operator|=
name|e1000_check_for_link
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Error while checking for link\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|mac
operator|->
name|autoneg_failed
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|mac
operator|->
name|autoneg_failed
operator|=
literal|0
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Valid Link Found\n"
argument_list|)
expr_stmt|;
block|}
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_commit_fc_settings_generic - Configure flow control  *  @hw - pointer to the HW structure  *  *  Write the flow control settings to the Transmit Config Word Register (TXCW)  *  base on the flow control settings in e1000_mac_info.  **/
end_comment

begin_function
name|s32
name|e1000_commit_fc_settings_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_mac_info
modifier|*
name|mac
init|=
operator|&
name|hw
operator|->
name|mac
decl_stmt|;
name|u32
name|txcw
decl_stmt|;
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_commit_fc_settings_generic"
argument_list|)
expr_stmt|;
comment|/* Check for a software override of the flow control settings, and 	 * setup the device accordingly.  If auto-negotiation is enabled, then 	 * software will have to set the "PAUSE" bits to the correct value in 	 * the Transmit Config Word Register (TXCW) and re-start auto- 	 * negotiation.  However, if auto-negotiation is disabled, then 	 * software will have to manually configure the two flow control enable 	 * bits in the CTRL register. 	 * 	 * The possible values of the "fc" parameter are: 	 *      0:  Flow control is completely disabled 	 *      1:  Rx flow control is enabled (we can receive pause frames, 	 *          but not send pause frames). 	 *      2:  Tx flow control is enabled (we can send pause frames but we 	 *          do not support receiving pause frames). 	 *      3:  Both Rx and TX flow control (symmetric) are enabled. 	 */
switch|switch
condition|(
name|mac
operator|->
name|fc
condition|)
block|{
case|case
name|e1000_fc_none
case|:
comment|/* Flow control completely disabled by a software over-ride. */
name|txcw
operator|=
operator|(
name|E1000_TXCW_ANE
operator||
name|E1000_TXCW_FD
operator|)
expr_stmt|;
break|break;
case|case
name|e1000_fc_rx_pause
case|:
comment|/* RX Flow control is enabled and TX Flow control is disabled 		 * by a software over-ride. Since there really isn't a way to 		 * advertise that we are capable of RX Pause ONLY, we will 		 * advertise that we support both symmetric and asymmetric RX 		 * PAUSE.  Later, we will disable the adapter's ability to send 		 * PAUSE frames. 		 */
name|txcw
operator|=
operator|(
name|E1000_TXCW_ANE
operator||
name|E1000_TXCW_FD
operator||
name|E1000_TXCW_PAUSE_MASK
operator|)
expr_stmt|;
break|break;
case|case
name|e1000_fc_tx_pause
case|:
comment|/* TX Flow control is enabled, and RX Flow control is disabled, 		 * by a software over-ride. 		 */
name|txcw
operator|=
operator|(
name|E1000_TXCW_ANE
operator||
name|E1000_TXCW_FD
operator||
name|E1000_TXCW_ASM_DIR
operator|)
expr_stmt|;
break|break;
case|case
name|e1000_fc_full
case|:
comment|/* Flow control (both RX and TX) is enabled by a software 		 * over-ride. 		 */
name|txcw
operator|=
operator|(
name|E1000_TXCW_ANE
operator||
name|E1000_TXCW_FD
operator||
name|E1000_TXCW_PAUSE_MASK
operator|)
expr_stmt|;
break|break;
default|default:
name|DEBUGOUT
argument_list|(
literal|"Flow control param set incorrectly\n"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
operator|-
name|E1000_ERR_CONFIG
expr_stmt|;
goto|goto
name|out
goto|;
break|break;
block|}
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TXCW
argument_list|,
name|txcw
argument_list|)
expr_stmt|;
name|mac
operator|->
name|txcw
operator|=
name|txcw
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_set_fc_watermarks_generic - Set flow control high/low watermarks  *  @hw - pointer to the HW structure  *  *  Sets the flow control high/low threshold (watermark) registers.  If  *  flow control XON frame transmission is enabled, then set XON frame  *  tansmission as well.  **/
end_comment

begin_function
name|s32
name|e1000_set_fc_watermarks_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_mac_info
modifier|*
name|mac
init|=
operator|&
name|hw
operator|->
name|mac
decl_stmt|;
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|u32
name|fcrtl
init|=
literal|0
decl_stmt|,
name|fcrth
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_set_fc_watermarks_generic"
argument_list|)
expr_stmt|;
comment|/* Set the flow control receive threshold registers.  Normally, 	 * these registers will be set to a default threshold that may be 	 * adjusted later by the driver's runtime code.  However, if the 	 * ability to transmit pause frames is not enabled, then these 	 * registers will be set to 0. 	 */
if|if
condition|(
name|mac
operator|->
name|fc
operator|&
name|e1000_fc_tx_pause
condition|)
block|{
comment|/* We need to set up the Receive Threshold high and low water 		 * marks as well as (optionally) enabling the transmission of 		 * XON frames. 		 */
name|fcrtl
operator|=
name|mac
operator|->
name|fc_low_water
expr_stmt|;
if|if
condition|(
name|mac
operator|->
name|fc_send_xon
condition|)
name|fcrtl
operator||=
name|E1000_FCRTL_XONE
expr_stmt|;
name|fcrth
operator|=
name|mac
operator|->
name|fc_high_water
expr_stmt|;
block|}
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_FCRTL
argument_list|,
name|fcrtl
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_FCRTH
argument_list|,
name|fcrth
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_set_default_fc_generic - Set flow control default values  *  @hw - pointer to the HW structure  *  *  Read the EEPROM for the default values for flow control and store the  *  values.  **/
end_comment

begin_function
name|s32
name|e1000_set_default_fc_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_mac_info
modifier|*
name|mac
init|=
operator|&
name|hw
operator|->
name|mac
decl_stmt|;
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|u16
name|nvm_data
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_set_default_fc_generic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|mac
operator|->
name|fc
operator|!=
name|e1000_fc_default
condition|)
goto|goto
name|out
goto|;
comment|/* Read and store word 0x0F of the EEPROM. This word contains bits 	 * that determine the hardware's default PAUSE (flow control) mode, 	 * a bit that determines whether the HW defaults to enabling or 	 * disabling auto-negotiation, and the direction of the 	 * SW defined pins. If there is no SW over-ride of the flow 	 * control setting, then the variable hw->fc will 	 * be initialized based on a value in the EEPROM. 	 */
name|ret_val
operator|=
name|e1000_read_nvm
argument_list|(
name|hw
argument_list|,
name|NVM_INIT_CONTROL2_REG
argument_list|,
literal|1
argument_list|,
operator|&
name|nvm_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"NVM Read Error\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|nvm_data
operator|&
name|NVM_WORD0F_PAUSE_MASK
operator|)
operator|==
literal|0
condition|)
name|mac
operator|->
name|fc
operator|=
name|e1000_fc_none
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|nvm_data
operator|&
name|NVM_WORD0F_PAUSE_MASK
operator|)
operator|==
name|NVM_WORD0F_ASM_DIR
condition|)
name|mac
operator|->
name|fc
operator|=
name|e1000_fc_tx_pause
expr_stmt|;
else|else
name|mac
operator|->
name|fc
operator|=
name|e1000_fc_full
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_force_mac_fc_generic - Force the MAC's flow control settings  *  @hw - pointer to the HW structure  *  *  Force the MAC's flow control settings.  Sets the TFCE and RFCE bits in the  *  device control register to reflect the adapter settings.  TFCE and RFCE  *  need to be explicitly set by software when a copper PHY is used because  *  autonegotiation is managed by the PHY rather than the MAC.  Software must  *  also configure these bits when link is forced on a fiber connection.  **/
end_comment

begin_function
name|s32
name|e1000_force_mac_fc_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_mac_info
modifier|*
name|mac
init|=
operator|&
name|hw
operator|->
name|mac
decl_stmt|;
name|u32
name|ctrl
decl_stmt|;
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_force_mac_fc_generic"
argument_list|)
expr_stmt|;
name|ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|)
expr_stmt|;
comment|/* Because we didn't get link via the internal auto-negotiation 	 * mechanism (we either forced link or we got link via PHY 	 * auto-neg), we have to manually enable/disable transmit an 	 * receive flow control. 	 * 	 * The "Case" statement below enables/disable flow control 	 * according to the "mac->fc" parameter. 	 * 	 * The possible values of the "fc" parameter are: 	 *      0:  Flow control is completely disabled 	 *      1:  Rx flow control is enabled (we can receive pause 	 *          frames but not send pause frames). 	 *      2:  Tx flow control is enabled (we can send pause frames 	 *          frames but we do not receive pause frames). 	 *      3:  Both Rx and TX flow control (symmetric) is enabled. 	 *  other:  No other values should be possible at this point. 	 */
name|DEBUGOUT1
argument_list|(
literal|"mac->fc = %u\n"
argument_list|,
name|mac
operator|->
name|fc
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|mac
operator|->
name|fc
condition|)
block|{
case|case
name|e1000_fc_none
case|:
name|ctrl
operator|&=
operator|(
operator|~
operator|(
name|E1000_CTRL_TFCE
operator||
name|E1000_CTRL_RFCE
operator|)
operator|)
expr_stmt|;
break|break;
case|case
name|e1000_fc_rx_pause
case|:
name|ctrl
operator|&=
operator|(
operator|~
name|E1000_CTRL_TFCE
operator|)
expr_stmt|;
name|ctrl
operator||=
name|E1000_CTRL_RFCE
expr_stmt|;
break|break;
case|case
name|e1000_fc_tx_pause
case|:
name|ctrl
operator|&=
operator|(
operator|~
name|E1000_CTRL_RFCE
operator|)
expr_stmt|;
name|ctrl
operator||=
name|E1000_CTRL_TFCE
expr_stmt|;
break|break;
case|case
name|e1000_fc_full
case|:
name|ctrl
operator||=
operator|(
name|E1000_CTRL_TFCE
operator||
name|E1000_CTRL_RFCE
operator|)
expr_stmt|;
break|break;
default|default:
name|DEBUGOUT
argument_list|(
literal|"Flow control param set incorrectly\n"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
operator|-
name|E1000_ERR_CONFIG
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_config_fc_after_link_up_generic - Configures flow control after link  *  @hw - pointer to the HW structure  *  *  Checks the status of auto-negotiation after link up to ensure that the  *  speed and duplex were not forced.  If the link needed to be forced, then  *  flow control needs to be forced also.  If auto-negotiation is enabled  *  and did not fail, then we configure flow control based on our link  *  partner.  **/
end_comment

begin_function
name|s32
name|e1000_config_fc_after_link_up_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_mac_info
modifier|*
name|mac
init|=
operator|&
name|hw
operator|->
name|mac
decl_stmt|;
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|u16
name|mii_status_reg
decl_stmt|,
name|mii_nway_adv_reg
decl_stmt|,
name|mii_nway_lp_ability_reg
decl_stmt|;
name|u16
name|speed
decl_stmt|,
name|duplex
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_config_fc_after_link_up_generic"
argument_list|)
expr_stmt|;
comment|/* Check for the case where we have fiber media and auto-neg failed 	 * so we had to force link.  In this case, we need to force the 	 * configuration of the MAC to match the "fc" parameter. 	 */
if|if
condition|(
name|mac
operator|->
name|autoneg_failed
condition|)
block|{
if|if
condition|(
name|hw
operator|->
name|media_type
operator|==
name|e1000_media_type_fiber
operator|||
name|hw
operator|->
name|media_type
operator|==
name|e1000_media_type_internal_serdes
condition|)
name|ret_val
operator|=
name|e1000_force_mac_fc_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|hw
operator|->
name|media_type
operator|==
name|e1000_media_type_copper
condition|)
name|ret_val
operator|=
name|e1000_force_mac_fc_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Error forcing flow control settings\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Check for the case where we have copper media and auto-neg is 	 * enabled.  In this case, we need to check and see if Auto-Neg 	 * has completed, and if so, how the PHY and link partner has 	 * flow control configured. 	 */
if|if
condition|(
operator|(
name|hw
operator|->
name|media_type
operator|==
name|e1000_media_type_copper
operator|)
operator|&&
name|mac
operator|->
name|autoneg
condition|)
block|{
comment|/* Read the MII Status Register and check to see if AutoNeg 		 * has completed.  We read this twice because this reg has 		 * some "sticky" (latched) bits. 		 */
name|ret_val
operator|=
name|e1000_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_STATUS
argument_list|,
operator|&
name|mii_status_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|ret_val
operator|=
name|e1000_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_STATUS
argument_list|,
operator|&
name|mii_status_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|!
operator|(
name|mii_status_reg
operator|&
name|MII_SR_AUTONEG_COMPLETE
operator|)
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Copper PHY and Auto Neg "
literal|"has not completed.\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* The AutoNeg process has completed, so we now need to 		 * read both the Auto Negotiation Advertisement 		 * Register (Address 4) and the Auto_Negotiation Base 		 * Page Ability Register (Address 5) to determine how 		 * flow control was negotiated. 		 */
name|ret_val
operator|=
name|e1000_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_AUTONEG_ADV
argument_list|,
operator|&
name|mii_nway_adv_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|ret_val
operator|=
name|e1000_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|PHY_LP_ABILITY
argument_list|,
operator|&
name|mii_nway_lp_ability_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
comment|/* Two bits in the Auto Negotiation Advertisement Register 		 * (Address 4) and two bits in the Auto Negotiation Base 		 * Page Ability Register (Address 5) determine flow control 		 * for both the PHY and the link partner.  The following 		 * table, taken out of the IEEE 802.3ab/D6.0 dated March 25, 		 * 1999, describes these PAUSE resolution bits and how flow 		 * control is determined based upon these settings. 		 * NOTE:  DC = Don't Care 		 * 		 *   LOCAL DEVICE  |   LINK PARTNER 		 * PAUSE | ASM_DIR | PAUSE | ASM_DIR | NIC Resolution 		 *-------|---------|-------|---------|-------------------- 		 *   0   |    0    |  DC   |   DC    | e1000_fc_none 		 *   0   |    1    |   0   |   DC    | e1000_fc_none 		 *   0   |    1    |   1   |    0    | e1000_fc_none 		 *   0   |    1    |   1   |    1    | e1000_fc_tx_pause 		 *   1   |    0    |   0   |   DC    | e1000_fc_none 		 *   1   |   DC    |   1   |   DC    | e1000_fc_full 		 *   1   |    1    |   0   |    0    | e1000_fc_none 		 *   1   |    1    |   0   |    1    | e1000_fc_rx_pause 		 * 		 */
comment|/* Are both PAUSE bits set to 1?  If so, this implies 		 * Symmetric Flow Control is enabled at both ends.  The 		 * ASM_DIR bits are irrelevant per the spec. 		 * 		 * For Symmetric Flow Control: 		 * 		 *   LOCAL DEVICE  |   LINK PARTNER 		 * PAUSE | ASM_DIR | PAUSE | ASM_DIR | Result 		 *-------|---------|-------|---------|-------------------- 		 *   1   |   DC    |   1   |   DC    | E1000_fc_full 		 * 		 */
if|if
condition|(
operator|(
name|mii_nway_adv_reg
operator|&
name|NWAY_AR_PAUSE
operator|)
operator|&&
operator|(
name|mii_nway_lp_ability_reg
operator|&
name|NWAY_LPAR_PAUSE
operator|)
condition|)
block|{
comment|/* Now we need to check if the user selected RX ONLY 			 * of pause frames.  In this case, we had to advertise 			 * FULL flow control because we could not advertise RX 			 * ONLY. Hence, we must now check to see if we need to 			 * turn OFF  the TRANSMISSION of PAUSE frames. 			 */
if|if
condition|(
name|mac
operator|->
name|original_fc
operator|==
name|e1000_fc_full
condition|)
block|{
name|mac
operator|->
name|fc
operator|=
name|e1000_fc_full
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Flow Control = FULL.\r\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mac
operator|->
name|fc
operator|=
name|e1000_fc_rx_pause
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Flow Control = "
literal|"RX PAUSE frames only.\r\n"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* For receiving PAUSE frames ONLY. 		 * 		 *   LOCAL DEVICE  |   LINK PARTNER 		 * PAUSE | ASM_DIR | PAUSE | ASM_DIR | Result 		 *-------|---------|-------|---------|-------------------- 		 *   0   |    1    |   1   |    1    | e1000_fc_tx_pause 		 * 		 */
elseif|else
if|if
condition|(
operator|!
operator|(
name|mii_nway_adv_reg
operator|&
name|NWAY_AR_PAUSE
operator|)
operator|&&
operator|(
name|mii_nway_adv_reg
operator|&
name|NWAY_AR_ASM_DIR
operator|)
operator|&&
operator|(
name|mii_nway_lp_ability_reg
operator|&
name|NWAY_LPAR_PAUSE
operator|)
operator|&&
operator|(
name|mii_nway_lp_ability_reg
operator|&
name|NWAY_LPAR_ASM_DIR
operator|)
condition|)
block|{
name|mac
operator|->
name|fc
operator|=
name|e1000_fc_tx_pause
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Flow Control = TX PAUSE frames only.\r\n"
argument_list|)
expr_stmt|;
block|}
comment|/* For transmitting PAUSE frames ONLY. 		 * 		 *   LOCAL DEVICE  |   LINK PARTNER 		 * PAUSE | ASM_DIR | PAUSE | ASM_DIR | Result 		 *-------|---------|-------|---------|-------------------- 		 *   1   |    1    |   0   |    1    | e1000_fc_rx_pause 		 * 		 */
elseif|else
if|if
condition|(
operator|(
name|mii_nway_adv_reg
operator|&
name|NWAY_AR_PAUSE
operator|)
operator|&&
operator|(
name|mii_nway_adv_reg
operator|&
name|NWAY_AR_ASM_DIR
operator|)
operator|&&
operator|!
operator|(
name|mii_nway_lp_ability_reg
operator|&
name|NWAY_LPAR_PAUSE
operator|)
operator|&&
operator|(
name|mii_nway_lp_ability_reg
operator|&
name|NWAY_LPAR_ASM_DIR
operator|)
condition|)
block|{
name|mac
operator|->
name|fc
operator|=
name|e1000_fc_rx_pause
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Flow Control = RX PAUSE frames only.\r\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Per the IEEE spec, at this point flow control should be 		 * disabled.  However, we want to consider that we could 		 * be connected to a legacy switch that doesn't advertise 		 * desired flow control, but can be forced on the link 		 * partner.  So if we advertised no flow control, that is 		 * what we will resolve to.  If we advertised some kind of 		 * receive capability (Rx Pause Only or Full Flow Control) 		 * and the link partner advertised none, we will configure 		 * ourselves to enable Rx Flow Control only.  We can do 		 * this safely for two reasons:  If the link partner really 		 * didn't want flow control enabled, and we enable Rx, no 		 * harm done since we won't be receiving any PAUSE frames 		 * anyway.  If the intent on the link partner was to have 		 * flow control enabled, then by us enabling RX only, we 		 * can at least receive pause frames and process them. 		 * This is a good idea because in most cases, since we are 		 * predominantly a server NIC, more times than not we will 		 * be asked to delay transmission of packets than asking 		 * our link partner to pause transmission of frames. 		 */
elseif|else
if|if
condition|(
operator|(
name|mac
operator|->
name|original_fc
operator|==
name|e1000_fc_none
operator|||
name|mac
operator|->
name|original_fc
operator|==
name|e1000_fc_tx_pause
operator|)
operator|||
name|mac
operator|->
name|fc_strict_ieee
condition|)
block|{
name|mac
operator|->
name|fc
operator|=
name|e1000_fc_none
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Flow Control = NONE.\r\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mac
operator|->
name|fc
operator|=
name|e1000_fc_rx_pause
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Flow Control = RX PAUSE frames only.\r\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Now we need to do one last check...  If we auto- 		 * negotiated to HALF DUPLEX, flow control should not be 		 * enabled per IEEE 802.3 spec. 		 */
name|ret_val
operator|=
name|e1000_get_speed_and_duplex
argument_list|(
name|hw
argument_list|,
operator|&
name|speed
argument_list|,
operator|&
name|duplex
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Error getting link speed and duplex\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|duplex
operator|==
name|HALF_DUPLEX
condition|)
name|mac
operator|->
name|fc
operator|=
name|e1000_fc_none
expr_stmt|;
comment|/* Now we call a subroutine to actually force the MAC 		 * controller to use the correct flow control settings. 		 */
name|ret_val
operator|=
name|e1000_force_mac_fc_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Error forcing flow control settings\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_get_speed_and_duplex_copper_generic - Retreive current speed/duplex  *  @hw - pointer to the HW structure  *  @speed - stores the current speed  *  @duplex - stores the current duplex  *  *  Read the status register for the current speed/duplex and store the current  *  speed and duplex for copper connections.  **/
end_comment

begin_function
name|s32
name|e1000_get_speed_and_duplex_copper_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
modifier|*
name|speed
parameter_list|,
name|u16
modifier|*
name|duplex
parameter_list|)
block|{
name|u32
name|status
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_get_speed_and_duplex_copper_generic"
argument_list|)
expr_stmt|;
name|status
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|E1000_STATUS_SPEED_1000
condition|)
block|{
operator|*
name|speed
operator|=
name|SPEED_1000
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"1000 Mbs, "
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|status
operator|&
name|E1000_STATUS_SPEED_100
condition|)
block|{
operator|*
name|speed
operator|=
name|SPEED_100
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"100 Mbs, "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|speed
operator|=
name|SPEED_10
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"10 Mbs, "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|&
name|E1000_STATUS_FD
condition|)
block|{
operator|*
name|duplex
operator|=
name|FULL_DUPLEX
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Full Duplex\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|duplex
operator|=
name|HALF_DUPLEX
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Half Duplex\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_get_speed_and_duplex_fiber_generic - Retreive current speed/duplex  *  @hw - pointer to the HW structure  *  @speed - stores the current speed  *  @duplex - stores the current duplex  *  *  Sets the speed and duplex to gigabit full duplex (the only possible option)  *  for fiber/serdes links.  **/
end_comment

begin_function
name|s32
name|e1000_get_speed_and_duplex_fiber_serdes_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
modifier|*
name|speed
parameter_list|,
name|u16
modifier|*
name|duplex
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"e1000_get_speed_and_duplex_fiber_serdes_generic"
argument_list|)
expr_stmt|;
operator|*
name|speed
operator|=
name|SPEED_1000
expr_stmt|;
operator|*
name|duplex
operator|=
name|FULL_DUPLEX
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_get_hw_semaphore_generic - Acquire hardware semaphore  *  @hw - pointer to the HW structure  *  *  Request a hardware semaphore by setting the firmware semaphore bit, once  *  bit has been set, semaphore has been acquired.  **/
end_comment

begin_function
name|s32
name|e1000_get_hw_semaphore_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|swsm
decl_stmt|;
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|s32
name|timeout
init|=
name|hw
operator|->
name|nvm
operator|.
name|word_size
operator|+
literal|1
decl_stmt|;
name|s32
name|i
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_get_hw_semaphore_generic"
argument_list|)
expr_stmt|;
comment|/* Get the FW semaphore. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|timeout
condition|;
name|i
operator|++
control|)
block|{
name|swsm
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_SWSM
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_SWSM
argument_list|,
name|swsm
operator||
name|E1000_SWSM_SWESMBI
argument_list|)
expr_stmt|;
comment|/* Semaphore acquired if bit latched */
if|if
condition|(
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_SWSM
argument_list|)
operator|&
name|E1000_SWSM_SWESMBI
condition|)
break|break;
name|usec_delay
argument_list|(
literal|50
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
name|timeout
condition|)
block|{
comment|/* Release semaphores */
name|e1000_put_hw_semaphore_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Driver can't access the NVM\n"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
operator|-
name|E1000_ERR_NVM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_put_hw_semaphore_generic - Release hardware semaphore  *  @hw - pointer to the HW structure  *  *  Release hardware semaphore by clearing in the firmware semaphore bit.  **/
end_comment

begin_function
name|void
name|e1000_put_hw_semaphore_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|swsm
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_put_hw_semaphore_generic"
argument_list|)
expr_stmt|;
name|swsm
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_SWSM
argument_list|)
expr_stmt|;
name|swsm
operator|&=
operator|~
name|E1000_SWSM_SWESMBI
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_SWSM
argument_list|,
name|swsm
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  e1000_get_auto_rd_done_generic - Check for auto read completion  *  @hw - pointer to the HW structure  *  *  Check EEPROM for Auto Read done bit.  **/
end_comment

begin_function
name|s32
name|e1000_get_auto_rd_done_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|i
init|=
literal|0
decl_stmt|;
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_get_auto_rd_done_generic"
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|AUTO_READ_DONE_TIMEOUT
condition|)
block|{
if|if
condition|(
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_EECD
argument_list|)
operator|&
name|E1000_EECD_AUTO_RD
condition|)
break|break;
name|msec_delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
name|AUTO_READ_DONE_TIMEOUT
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Auto read by HW from NVM has not completed.\n"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
operator|-
name|E1000_ERR_RESET
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_valid_led_default_generic - Verify a valid default LED config  *  @hw - pointer to the HW structure  *  @data - pointer to the NVM (EEPROM)  *  *  Read the EEPROM for the current default LED configuration.  If the  *  LED configuration is not valid, set to a valid LED configuration.  **/
end_comment

begin_function
name|s32
name|e1000_valid_led_default_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
block|{
name|s32
name|ret_val
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_valid_led_default_generic"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_read_nvm
argument_list|(
name|hw
argument_list|,
name|NVM_ID_LED_SETTINGS
argument_list|,
literal|1
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"NVM Read Error\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|*
name|data
operator|==
name|ID_LED_RESERVED_0000
operator|||
operator|*
name|data
operator|==
name|ID_LED_RESERVED_FFFF
condition|)
operator|*
name|data
operator|=
name|ID_LED_DEFAULT
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_id_led_init_generic -  *  @hw - pointer to the HW structure  *  **/
end_comment

begin_function
name|s32
name|e1000_id_led_init_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_mac_info
modifier|*
name|mac
init|=
operator|&
name|hw
operator|->
name|mac
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
specifier|const
name|u32
name|ledctl_mask
init|=
literal|0x000000FF
decl_stmt|;
specifier|const
name|u32
name|ledctl_on
init|=
name|E1000_LEDCTL_MODE_LED_ON
decl_stmt|;
specifier|const
name|u32
name|ledctl_off
init|=
name|E1000_LEDCTL_MODE_LED_OFF
decl_stmt|;
name|u16
name|data
decl_stmt|,
name|i
decl_stmt|,
name|temp
decl_stmt|;
specifier|const
name|u16
name|led_mask
init|=
literal|0x0F
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_id_led_init_generic"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|hw
operator|->
name|func
operator|.
name|valid_led_default
argument_list|(
name|hw
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|mac
operator|->
name|ledctl_default
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_LEDCTL
argument_list|)
expr_stmt|;
name|mac
operator|->
name|ledctl_mode1
operator|=
name|mac
operator|->
name|ledctl_default
expr_stmt|;
name|mac
operator|->
name|ledctl_mode2
operator|=
name|mac
operator|->
name|ledctl_default
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|temp
operator|=
operator|(
name|data
operator|>>
operator|(
name|i
operator|<<
literal|2
operator|)
operator|)
operator|&
name|led_mask
expr_stmt|;
switch|switch
condition|(
name|temp
condition|)
block|{
case|case
name|ID_LED_ON1_DEF2
case|:
case|case
name|ID_LED_ON1_ON2
case|:
case|case
name|ID_LED_ON1_OFF2
case|:
name|mac
operator|->
name|ledctl_mode1
operator|&=
operator|~
operator|(
name|ledctl_mask
operator|<<
operator|(
name|i
operator|<<
literal|3
operator|)
operator|)
expr_stmt|;
name|mac
operator|->
name|ledctl_mode1
operator||=
name|ledctl_on
operator|<<
operator|(
name|i
operator|<<
literal|3
operator|)
expr_stmt|;
break|break;
case|case
name|ID_LED_OFF1_DEF2
case|:
case|case
name|ID_LED_OFF1_ON2
case|:
case|case
name|ID_LED_OFF1_OFF2
case|:
name|mac
operator|->
name|ledctl_mode1
operator|&=
operator|~
operator|(
name|ledctl_mask
operator|<<
operator|(
name|i
operator|<<
literal|3
operator|)
operator|)
expr_stmt|;
name|mac
operator|->
name|ledctl_mode1
operator||=
name|ledctl_off
operator|<<
operator|(
name|i
operator|<<
literal|3
operator|)
expr_stmt|;
break|break;
default|default:
comment|/* Do nothing */
break|break;
block|}
switch|switch
condition|(
name|temp
condition|)
block|{
case|case
name|ID_LED_DEF1_ON2
case|:
case|case
name|ID_LED_ON1_ON2
case|:
case|case
name|ID_LED_OFF1_ON2
case|:
name|mac
operator|->
name|ledctl_mode2
operator|&=
operator|~
operator|(
name|ledctl_mask
operator|<<
operator|(
name|i
operator|<<
literal|3
operator|)
operator|)
expr_stmt|;
name|mac
operator|->
name|ledctl_mode2
operator||=
name|ledctl_on
operator|<<
operator|(
name|i
operator|<<
literal|3
operator|)
expr_stmt|;
break|break;
case|case
name|ID_LED_DEF1_OFF2
case|:
case|case
name|ID_LED_ON1_OFF2
case|:
case|case
name|ID_LED_OFF1_OFF2
case|:
name|mac
operator|->
name|ledctl_mode2
operator|&=
operator|~
operator|(
name|ledctl_mask
operator|<<
operator|(
name|i
operator|<<
literal|3
operator|)
operator|)
expr_stmt|;
name|mac
operator|->
name|ledctl_mode2
operator||=
name|ledctl_off
operator|<<
operator|(
name|i
operator|<<
literal|3
operator|)
expr_stmt|;
break|break;
default|default:
comment|/* Do nothing */
break|break;
block|}
block|}
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_setup_led_generic - Configures SW controllable LED  *  @hw - pointer to the HW structure  *  *  This prepares the SW controllable LED for use and saves the current state  *  of the LED so it can be later restored.  **/
end_comment

begin_function
name|s32
name|e1000_setup_led_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|ledctl
decl_stmt|;
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_setup_led_generic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|func
operator|.
name|setup_led
operator|!=
name|e1000_setup_led_generic
condition|)
block|{
name|ret_val
operator|=
operator|-
name|E1000_ERR_CONFIG
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|hw
operator|->
name|media_type
operator|==
name|e1000_media_type_fiber
condition|)
block|{
name|ledctl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_LEDCTL
argument_list|)
expr_stmt|;
name|hw
operator|->
name|mac
operator|.
name|ledctl_default
operator|=
name|ledctl
expr_stmt|;
comment|/* Turn off LED0 */
name|ledctl
operator|&=
operator|~
operator|(
name|E1000_LEDCTL_LED0_IVRT
operator||
name|E1000_LEDCTL_LED0_BLINK
operator||
name|E1000_LEDCTL_LED0_MODE_MASK
operator|)
expr_stmt|;
name|ledctl
operator||=
operator|(
name|E1000_LEDCTL_MODE_LED_OFF
operator|<<
name|E1000_LEDCTL_LED0_MODE_SHIFT
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_LEDCTL
argument_list|,
name|ledctl
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|hw
operator|->
name|media_type
operator|==
name|e1000_media_type_copper
condition|)
block|{
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_LEDCTL
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|ledctl_mode1
argument_list|)
expr_stmt|;
block|}
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_cleanup_led_generic - Set LED config to default operation  *  @hw - pointer to the HW structure  *  *  Remove the current LED configuration and set the LED configuration  *  to the default value, saved from the EEPROM.  **/
end_comment

begin_function
name|s32
name|e1000_cleanup_led_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_cleanup_led_generic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|func
operator|.
name|cleanup_led
operator|!=
name|e1000_cleanup_led_generic
condition|)
block|{
name|ret_val
operator|=
operator|-
name|E1000_ERR_CONFIG
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_LEDCTL
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|ledctl_default
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_blink_led_generic - Blink LED  *  @hw - pointer to the HW structure  *  *  Blink the led's which are set to be on.  **/
end_comment

begin_function
name|s32
name|e1000_blink_led_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|ledctl_blink
init|=
literal|0
decl_stmt|;
name|u32
name|i
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_blink_led_generic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|media_type
operator|==
name|e1000_media_type_fiber
condition|)
block|{
comment|/* always blink LED0 for PCI-E fiber */
name|ledctl_blink
operator|=
name|E1000_LEDCTL_LED0_BLINK
operator||
operator|(
name|E1000_LEDCTL_MODE_LED_ON
operator|<<
name|E1000_LEDCTL_LED0_MODE_SHIFT
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* set the blink bit for each LED that's "on" (0x0E) 		 * in ledctl_mode2 */
name|ledctl_blink
operator|=
name|hw
operator|->
name|mac
operator|.
name|ledctl_mode2
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
operator|(
name|hw
operator|->
name|mac
operator|.
name|ledctl_mode2
operator|>>
operator|(
name|i
operator|*
literal|8
operator|)
operator|)
operator|&
literal|0xFF
operator|)
operator|==
name|E1000_LEDCTL_MODE_LED_ON
condition|)
name|ledctl_blink
operator||=
operator|(
name|E1000_LEDCTL_LED0_BLINK
operator|<<
operator|(
name|i
operator|*
literal|8
operator|)
operator|)
expr_stmt|;
block|}
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_LEDCTL
argument_list|,
name|ledctl_blink
argument_list|)
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_led_on_generic - Turn LED on  *  @hw - pointer to the HW structure  *  *  Turn LED on.  **/
end_comment

begin_function
name|s32
name|e1000_led_on_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|ctrl
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_led_on_generic"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|hw
operator|->
name|media_type
condition|)
block|{
case|case
name|e1000_media_type_fiber
case|:
name|ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|)
expr_stmt|;
name|ctrl
operator|&=
operator|~
name|E1000_CTRL_SWDPIN0
expr_stmt|;
name|ctrl
operator||=
name|E1000_CTRL_SWDPIO0
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
break|break;
case|case
name|e1000_media_type_copper
case|:
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_LEDCTL
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|ledctl_mode2
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_led_off_generic - Turn LED off  *  @hw - pointer to the HW structure  *  *  Turn LED off.  **/
end_comment

begin_function
name|s32
name|e1000_led_off_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|ctrl
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_led_off_generic"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|hw
operator|->
name|media_type
condition|)
block|{
case|case
name|e1000_media_type_fiber
case|:
name|ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|)
expr_stmt|;
name|ctrl
operator||=
name|E1000_CTRL_SWDPIN0
expr_stmt|;
name|ctrl
operator||=
name|E1000_CTRL_SWDPIO0
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
break|break;
case|case
name|e1000_media_type_copper
case|:
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_LEDCTL
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|ledctl_mode1
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_set_pcie_no_snoop_generic - Set PCI-express capabilities  *  @hw - pointer to the HW structure  *  @no_snoop - bitmap of snoop events  *  *  Set the PCI-express register to snoop for events enabled in 'no_snoop'.  **/
end_comment

begin_function
name|void
name|e1000_set_pcie_no_snoop_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|no_snoop
parameter_list|)
block|{
name|u32
name|gcr
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_set_pcie_no_snoop_generic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|bus
operator|.
name|type
operator|!=
name|e1000_bus_type_pci_express
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|no_snoop
condition|)
block|{
name|gcr
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_GCR
argument_list|)
expr_stmt|;
name|gcr
operator|&=
operator|~
operator|(
name|PCIE_NO_SNOOP_ALL
operator|)
expr_stmt|;
name|gcr
operator||=
name|no_snoop
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_GCR
argument_list|,
name|gcr
argument_list|)
expr_stmt|;
block|}
name|out
label|:
return|return;
block|}
end_function

begin_comment
comment|/**  *  e1000_disable_pcie_master_generic - Disables PCI-express master access  *  @hw - pointer to the HW structure  *  *  Returns 0 (E1000_SUCCESS) if successful, else returns -10  *  (-E1000_ERR_MASTER_REQUESTS_PENDING) if master disable bit has not casued  *  the master requests to be disabled.  *  *  Disables PCI-Express master access and verifies there are no pending  *  requests.  **/
end_comment

begin_function
name|s32
name|e1000_disable_pcie_master_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|ctrl
decl_stmt|;
name|s32
name|timeout
init|=
name|MASTER_DISABLE_TIMEOUT
decl_stmt|;
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_disable_pcie_master_generic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|bus
operator|.
name|type
operator|!=
name|e1000_bus_type_pci_express
condition|)
goto|goto
name|out
goto|;
name|ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|)
expr_stmt|;
name|ctrl
operator||=
name|E1000_CTRL_GIO_MASTER_DISABLE
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
while|while
condition|(
name|timeout
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_STATUS
argument_list|)
operator|&
name|E1000_STATUS_GIO_MASTER_ENABLE
operator|)
condition|)
break|break;
name|usec_delay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|timeout
operator|--
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|timeout
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Master requests are pending.\n"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
operator|-
name|E1000_ERR_MASTER_REQUESTS_PENDING
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_reset_adaptive_generic - Reset Adaptive Interframe Spacing  *  @hw - pointer to the HW structure  *  *  Reset the Adaptive Interframe Spacing throttle to default values.  **/
end_comment

begin_function
name|void
name|e1000_reset_adaptive_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_mac_info
modifier|*
name|mac
init|=
operator|&
name|hw
operator|->
name|mac
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_reset_adaptive_generic"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mac
operator|->
name|adaptive_ifs
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Not in Adaptive IFS mode!\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|!
name|mac
operator|->
name|ifs_params_forced
condition|)
block|{
name|mac
operator|->
name|current_ifs_val
operator|=
literal|0
expr_stmt|;
name|mac
operator|->
name|ifs_min_val
operator|=
name|IFS_MIN
expr_stmt|;
name|mac
operator|->
name|ifs_max_val
operator|=
name|IFS_MAX
expr_stmt|;
name|mac
operator|->
name|ifs_step_size
operator|=
name|IFS_STEP
expr_stmt|;
name|mac
operator|->
name|ifs_ratio
operator|=
name|IFS_RATIO
expr_stmt|;
block|}
name|mac
operator|->
name|in_ifs_mode
operator|=
name|FALSE
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_AIT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|out
label|:
return|return;
block|}
end_function

begin_comment
comment|/**  *  e1000_update_adaptive_generic - Update Adaptive Interframe Spacing  *  @hw - pointer to the HW structure  *  *  Update the Adaptive Interframe Spacing Throttle value based on the  *  time between transmitted packets and time between collisions.  **/
end_comment

begin_function
name|void
name|e1000_update_adaptive_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_mac_info
modifier|*
name|mac
init|=
operator|&
name|hw
operator|->
name|mac
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_update_adaptive_generic"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mac
operator|->
name|adaptive_ifs
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Not in Adaptive IFS mode!\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|mac
operator|->
name|collision_delta
operator|*
name|mac
operator|->
name|ifs_ratio
operator|)
operator|>
name|mac
operator|->
name|tx_packet_delta
condition|)
block|{
if|if
condition|(
name|mac
operator|->
name|tx_packet_delta
operator|>
name|MIN_NUM_XMITS
condition|)
block|{
name|mac
operator|->
name|in_ifs_mode
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|mac
operator|->
name|current_ifs_val
operator|<
name|mac
operator|->
name|ifs_max_val
condition|)
block|{
if|if
condition|(
operator|!
name|mac
operator|->
name|current_ifs_val
condition|)
name|mac
operator|->
name|current_ifs_val
operator|=
name|mac
operator|->
name|ifs_min_val
expr_stmt|;
else|else
name|mac
operator|->
name|current_ifs_val
operator|+=
name|mac
operator|->
name|ifs_step_size
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_AIT
argument_list|,
name|mac
operator|->
name|current_ifs_val
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|mac
operator|->
name|in_ifs_mode
operator|&&
operator|(
name|mac
operator|->
name|tx_packet_delta
operator|<=
name|MIN_NUM_XMITS
operator|)
condition|)
block|{
name|mac
operator|->
name|current_ifs_val
operator|=
literal|0
expr_stmt|;
name|mac
operator|->
name|in_ifs_mode
operator|=
name|FALSE
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_AIT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|out
label|:
return|return;
block|}
end_function

begin_comment
comment|/**  *  e1000_validate_mdi_setting_generic - Verify MDI/MDIx settings  *  @hw - pointer to the HW structure  *  *  Verify that when not using auto-negotitation that MDI/MDIx is correctly  *  set, which is forced to MDI mode only.  **/
end_comment

begin_function
name|s32
name|e1000_validate_mdi_setting_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_validate_mdi_setting_generic"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hw
operator|->
name|mac
operator|.
name|autoneg
operator|&&
operator|(
name|hw
operator|->
name|phy
operator|.
name|mdix
operator|==
literal|0
operator|||
name|hw
operator|->
name|phy
operator|.
name|mdix
operator|==
literal|3
operator|)
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Invalid MDI setting detected\n"
argument_list|)
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|mdix
operator|=
literal|1
expr_stmt|;
name|ret_val
operator|=
operator|-
name|E1000_ERR_CONFIG
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_write_8bit_ctrl_reg_generic - Write a 8bit CTRL register  *  @hw - pointer to the HW structure  *  @reg - 32bit register offset such as E1000_SCTL  *  @offset - register offset to write to  *  @data - data to write at register offset  *  *  Writes an address/data control type register.  There are several of these  *  and they all have the format address<< 8 | data and bit 31 is polled for  *  completion.  **/
end_comment

begin_function
name|s32
name|e1000_write_8bit_ctrl_reg_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|reg
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u8
name|data
parameter_list|)
block|{
name|u32
name|i
decl_stmt|,
name|regvalue
init|=
literal|0
decl_stmt|;
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_write_8bit_ctrl_reg_generic"
argument_list|)
expr_stmt|;
comment|/* Set up the address and data */
name|regvalue
operator|=
operator|(
operator|(
name|u32
operator|)
name|data
operator|)
operator||
operator|(
name|offset
operator|<<
name|E1000_GEN_CTL_ADDRESS_SHIFT
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|reg
argument_list|,
name|regvalue
argument_list|)
expr_stmt|;
comment|/* Poll the ready bit to see if the MDI read completed */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|E1000_GEN_POLL_TIMEOUT
condition|;
name|i
operator|++
control|)
block|{
name|usec_delay
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|regvalue
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|regvalue
operator|&
name|E1000_GEN_CTL_READY
condition|)
break|break;
block|}
if|if
condition|(
operator|!
operator|(
name|regvalue
operator|&
name|E1000_GEN_CTL_READY
operator|)
condition|)
block|{
name|DEBUGOUT1
argument_list|(
literal|"Reg %08x did not indicate ready\n"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|ret_val
operator|=
operator|-
name|E1000_ERR_PHY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

end_unit

