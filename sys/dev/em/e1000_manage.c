begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*******************************************************************************    Copyright (c) 2001-2007, Intel Corporation    All rights reserved.      Redistribution and use in source and binary forms, with or without    modification, are permitted provided that the following conditions are met:       1. Redistributions of source code must retain the above copyright notice,        this list of conditions and the following disclaimer.       2. Redistributions in binary form must reproduce the above copyright        notice, this list of conditions and the following disclaimer in the        documentation and/or other materials provided with the distribution.       3. Neither the name of the Intel Corporation nor the names of its        contributors may be used to endorse or promote products derived from        this software without specific prior written permission.      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE    ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR    CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF    SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN    CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)    ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE   POSSIBILITY OF SUCH DAMAGE.  *******************************************************************************/
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"e1000_manage.h"
end_include

begin_function_decl
specifier|static
name|u8
name|e1000_calculate_checksum
parameter_list|(
name|u8
modifier|*
name|buffer
parameter_list|,
name|u32
name|length
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  *  e1000_calculate_checksum - Calculate checksum for buffer  *  @buffer - pointer to EEPROM  *  @length - size of EEPROM to calculate a checksum for  *  *  Calculates the checksum for some buffer on a specified length.  The  *  checksum calculated is returned.  **/
end_comment

begin_function
specifier|static
name|u8
name|e1000_calculate_checksum
parameter_list|(
name|u8
modifier|*
name|buffer
parameter_list|,
name|u32
name|length
parameter_list|)
block|{
name|u32
name|i
decl_stmt|;
name|u8
name|sum
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_calculate_checksum"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buffer
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
name|sum
operator|+=
name|buffer
index|[
name|i
index|]
expr_stmt|;
return|return
call|(
name|u8
call|)
argument_list|(
literal|0
operator|-
name|sum
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_mng_enable_host_if_generic - Checks host interface is enabled  *  @hw - pointer to the HW structure  *  *  Returns E1000_success upon success, else E1000_ERR_HOST_INTERFACE_COMMAND  *  *  This function checks whether the HOST IF is enabled for command operaton  *  and also checks whether the previous command is completed.  It busy waits  *  in case of previous command is not completed.  **/
end_comment

begin_function
name|s32
name|e1000_mng_enable_host_if_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|hicr
decl_stmt|;
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|u8
name|i
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_mng_enable_host_if_generic"
argument_list|)
expr_stmt|;
comment|/* Check that the host interface is enabled. */
name|hicr
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_HICR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|hicr
operator|&
name|E1000_HICR_EN
operator|)
operator|==
literal|0
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"E1000_HOST_EN bit disabled.\n"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
operator|-
name|E1000_ERR_HOST_INTERFACE_COMMAND
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* check the previous command is completed */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|E1000_MNG_DHCP_COMMAND_TIMEOUT
condition|;
name|i
operator|++
control|)
block|{
name|hicr
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_HICR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|hicr
operator|&
name|E1000_HICR_C
operator|)
condition|)
break|break;
name|msec_delay_irq
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
name|E1000_MNG_DHCP_COMMAND_TIMEOUT
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Previous command timeout failed .\n"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
operator|-
name|E1000_ERR_HOST_INTERFACE_COMMAND
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_check_mng_mode_generic - Generic check managament mode  *  @hw - pointer to the HW structure  *  *  Reads the firmware semaphore register and returns true (>0) if  *  manageability is enabled, else false (0).  **/
end_comment

begin_function
name|boolean_t
name|e1000_check_mng_mode_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|fwsm
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_check_mng_mode_generic"
argument_list|)
expr_stmt|;
name|fwsm
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_FWSM
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|fwsm
operator|&
name|E1000_FWSM_MODE_MASK
operator|)
operator|==
operator|(
name|E1000_MNG_IAMT_MODE
operator|<<
name|E1000_FWSM_MODE_SHIFT
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_enable_tx_pkt_filtering_generic - Enable packet filtering on TX  *  @hw - pointer to the HW structure  *  *  Enables packet filtering on transmit packets if manageability is enabled  *  and host interface is enabled.  **/
end_comment

begin_function
name|boolean_t
name|e1000_enable_tx_pkt_filtering_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_host_mng_dhcp_cookie
modifier|*
name|hdr
init|=
operator|&
name|hw
operator|->
name|mng_cookie
decl_stmt|;
name|u32
modifier|*
name|buffer
init|=
operator|(
name|u32
operator|*
operator|)
operator|&
name|hw
operator|->
name|mng_cookie
decl_stmt|;
name|u32
name|offset
decl_stmt|;
name|s32
name|ret_val
decl_stmt|,
name|hdr_csum
decl_stmt|,
name|csum
decl_stmt|;
name|u8
name|i
decl_stmt|,
name|len
decl_stmt|;
name|boolean_t
name|tx_filter
init|=
name|TRUE
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_enable_tx_pkt_filtering_generic"
argument_list|)
expr_stmt|;
comment|/* No manageability, no filtering */
if|if
condition|(
operator|!
name|e1000_check_mng_mode
argument_list|(
name|hw
argument_list|)
condition|)
block|{
name|tx_filter
operator|=
name|FALSE
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* If we can't read from the host interface for whatever 	 * reason, disable filtering. 	 */
name|ret_val
operator|=
name|e1000_mng_enable_host_if
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
operator|!=
name|E1000_SUCCESS
condition|)
block|{
name|tx_filter
operator|=
name|FALSE
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Read in the header.  Length and offset are in dwords. */
name|len
operator|=
name|E1000_MNG_DHCP_COOKIE_LENGTH
operator|>>
literal|2
expr_stmt|;
name|offset
operator|=
name|E1000_MNG_DHCP_COOKIE_OFFSET
operator|>>
literal|2
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
operator|*
operator|(
name|buffer
operator|+
name|i
operator|)
operator|=
name|E1000_READ_REG_ARRAY_DWORD
argument_list|(
name|hw
argument_list|,
name|E1000_HOST_IF
argument_list|,
name|offset
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
name|hdr_csum
operator|=
name|hdr
operator|->
name|checksum
expr_stmt|;
name|hdr
operator|->
name|checksum
operator|=
literal|0
expr_stmt|;
name|csum
operator|=
name|e1000_calculate_checksum
argument_list|(
operator|(
name|u8
operator|*
operator|)
name|hdr
argument_list|,
name|E1000_MNG_DHCP_COOKIE_LENGTH
argument_list|)
expr_stmt|;
comment|/* If either the checksums or signature don't match, then 	 * the cookie area isn't considered valid, in which case we 	 * take the safe route of assuming Tx filtering is enabled. 	 */
if|if
condition|(
name|hdr_csum
operator|!=
name|csum
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|hdr
operator|->
name|signature
operator|!=
name|E1000_IAMT_SIGNATURE
condition|)
goto|goto
name|out
goto|;
comment|/* Cookie area is valid, make the final check for filtering. */
if|if
condition|(
operator|!
operator|(
name|hdr
operator|->
name|status
operator|&
name|E1000_MNG_DHCP_COOKIE_STATUS_PARSING
operator|)
condition|)
name|tx_filter
operator|=
name|FALSE
expr_stmt|;
name|out
label|:
name|hw
operator|->
name|mac
operator|.
name|tx_pkt_filtering
operator|=
name|tx_filter
expr_stmt|;
return|return
name|tx_filter
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_mng_write_dhcp_info_generic - Writes DHCP info to host interface  *  @hw - pointer to the HW structure  *  @buffer - pointer to the host interface  *  @length - size of the buffer  *  *  Writes the DHCP information to the host interface.  **/
end_comment

begin_function
name|s32
name|e1000_mng_write_dhcp_info_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u8
modifier|*
name|buffer
parameter_list|,
name|u16
name|length
parameter_list|)
block|{
name|struct
name|e1000_host_mng_command_header
name|hdr
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|u32
name|hicr
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_mng_write_dhcp_info_generic"
argument_list|)
expr_stmt|;
name|hdr
operator|.
name|command_id
operator|=
name|E1000_MNG_DHCP_TX_PAYLOAD_CMD
expr_stmt|;
name|hdr
operator|.
name|command_length
operator|=
name|length
expr_stmt|;
name|hdr
operator|.
name|reserved1
operator|=
literal|0
expr_stmt|;
name|hdr
operator|.
name|reserved2
operator|=
literal|0
expr_stmt|;
name|hdr
operator|.
name|checksum
operator|=
literal|0
expr_stmt|;
comment|/* Enable the host interface */
name|ret_val
operator|=
name|e1000_mng_enable_host_if
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
comment|/* Populate the host interface with the contents of "buffer". */
name|ret_val
operator|=
name|e1000_mng_host_if_write
argument_list|(
name|hw
argument_list|,
name|buffer
argument_list|,
name|length
argument_list|,
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
argument_list|,
operator|&
operator|(
name|hdr
operator|.
name|checksum
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
comment|/* Write the manageability command header */
name|ret_val
operator|=
name|e1000_mng_write_cmd_header
argument_list|(
name|hw
argument_list|,
operator|&
name|hdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
comment|/* Tell the ARC a new command is pending. */
name|hicr
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_HICR
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_HICR
argument_list|,
name|hicr
operator||
name|E1000_HICR_C
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_mng_write_cmd_header_generic - Writes manageability command header  *  @hw - pointer to the HW structure  *  @hdr - pointer to the host interface command header  *  *  Writes the command header after does the checksum calculation.  **/
end_comment

begin_function
name|s32
name|e1000_mng_write_cmd_header_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|struct
name|e1000_host_mng_command_header
modifier|*
name|hdr
parameter_list|)
block|{
name|u16
name|i
decl_stmt|,
name|length
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|e1000_host_mng_command_header
argument_list|)
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_mng_write_cmd_header_generic"
argument_list|)
expr_stmt|;
comment|/* Write the whole command header structure with new checksum. */
name|hdr
operator|->
name|checksum
operator|=
name|e1000_calculate_checksum
argument_list|(
operator|(
name|u8
operator|*
operator|)
name|hdr
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|length
operator|>>=
literal|2
expr_stmt|;
comment|/* Write the relevant command block into the ram area. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
name|E1000_WRITE_REG_ARRAY_DWORD
argument_list|(
name|hw
argument_list|,
name|E1000_HOST_IF
argument_list|,
name|i
argument_list|,
operator|*
operator|(
operator|(
name|u32
operator|*
operator|)
name|hdr
operator|+
name|i
operator|)
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_mng_host_if_write_generic - Writes to the manageability host interface  *  @hw - pointer to the HW structure  *  @buffer - pointer to the host interface buffer  *  @length - size of the buffer  *  @offset - location in the buffer to write to  *  @sum - sum of the data (not checksum)  *  *  This function writes the buffer content at the offset given on the host if.  *  It also does alignment considerations to do the writes in most efficient  *  way.  Also fills up the sum of the buffer in *buffer parameter.  **/
end_comment

begin_function
name|s32
name|e1000_mng_host_if_write_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u8
modifier|*
name|buffer
parameter_list|,
name|u16
name|length
parameter_list|,
name|u16
name|offset
parameter_list|,
name|u8
modifier|*
name|sum
parameter_list|)
block|{
name|u8
modifier|*
name|tmp
decl_stmt|;
name|u8
modifier|*
name|bufptr
init|=
name|buffer
decl_stmt|;
name|u32
name|data
init|=
literal|0
decl_stmt|;
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|u16
name|remaining
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|,
name|prev_bytes
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_mng_host_if_write_generic"
argument_list|)
expr_stmt|;
comment|/* sum = only sum of the data and it is not checksum */
if|if
condition|(
name|length
operator|==
literal|0
operator|||
name|offset
operator|+
name|length
operator|>
name|E1000_HI_MAX_MNG_DATA_LENGTH
condition|)
block|{
name|ret_val
operator|=
operator|-
name|E1000_ERR_PARAM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|tmp
operator|=
operator|(
name|u8
operator|*
operator|)
operator|&
name|data
expr_stmt|;
name|prev_bytes
operator|=
name|offset
operator|&
literal|0x3
expr_stmt|;
name|offset
operator|>>=
literal|2
expr_stmt|;
if|if
condition|(
name|prev_bytes
condition|)
block|{
name|data
operator|=
name|E1000_READ_REG_ARRAY_DWORD
argument_list|(
name|hw
argument_list|,
name|E1000_HOST_IF
argument_list|,
name|offset
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
name|prev_bytes
init|;
name|j
operator|<
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
operator|*
operator|(
name|tmp
operator|+
name|j
operator|)
operator|=
operator|*
name|bufptr
operator|++
expr_stmt|;
operator|*
name|sum
operator|+=
operator|*
operator|(
name|tmp
operator|+
name|j
operator|)
expr_stmt|;
block|}
name|E1000_WRITE_REG_ARRAY_DWORD
argument_list|(
name|hw
argument_list|,
name|E1000_HOST_IF
argument_list|,
name|offset
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|length
operator|-=
name|j
operator|-
name|prev_bytes
expr_stmt|;
name|offset
operator|++
expr_stmt|;
block|}
name|remaining
operator|=
name|length
operator|&
literal|0x3
expr_stmt|;
name|length
operator|-=
name|remaining
expr_stmt|;
comment|/* Calculate length in DWORDs */
name|length
operator|>>=
literal|2
expr_stmt|;
comment|/* The device driver writes the relevant command block into the 	 * ram area. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
operator|*
operator|(
name|tmp
operator|+
name|j
operator|)
operator|=
operator|*
name|bufptr
operator|++
expr_stmt|;
operator|*
name|sum
operator|+=
operator|*
operator|(
name|tmp
operator|+
name|j
operator|)
expr_stmt|;
block|}
name|E1000_WRITE_REG_ARRAY_DWORD
argument_list|(
name|hw
argument_list|,
name|E1000_HOST_IF
argument_list|,
name|offset
operator|+
name|i
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|remaining
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|j
operator|<
name|remaining
condition|)
operator|*
operator|(
name|tmp
operator|+
name|j
operator|)
operator|=
operator|*
name|bufptr
operator|++
expr_stmt|;
else|else
operator|*
operator|(
name|tmp
operator|+
name|j
operator|)
operator|=
literal|0
expr_stmt|;
operator|*
name|sum
operator|+=
operator|*
operator|(
name|tmp
operator|+
name|j
operator|)
expr_stmt|;
block|}
name|E1000_WRITE_REG_ARRAY_DWORD
argument_list|(
name|hw
argument_list|,
name|E1000_HOST_IF
argument_list|,
name|offset
operator|+
name|i
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_enable_mng_pass_thru - Enable processing of ARP's  *  @hw - pointer to the HW structure  *  *  Verifies the hardware needs to allow ARPs to be processed by the host.  **/
end_comment

begin_function
name|boolean_t
name|e1000_enable_mng_pass_thru
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|manc
decl_stmt|;
name|u32
name|fwsm
decl_stmt|,
name|factps
decl_stmt|;
name|boolean_t
name|ret_val
init|=
name|FALSE
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_enable_mng_pass_thru"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hw
operator|->
name|mac
operator|.
name|asf_firmware_present
condition|)
goto|goto
name|out
goto|;
name|manc
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_MANC
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|manc
operator|&
name|E1000_MANC_RCV_TCO_EN
operator|)
operator|||
operator|!
operator|(
name|manc
operator|&
name|E1000_MANC_EN_MAC_ADDR_FILTER
operator|)
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|arc_subsystem_valid
operator|==
name|TRUE
condition|)
block|{
name|fwsm
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_FWSM
argument_list|)
expr_stmt|;
name|factps
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_FACTPS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|factps
operator|&
name|E1000_FACTPS_MNGCG
operator|)
operator|&&
operator|(
operator|(
name|fwsm
operator|&
name|E1000_FWSM_MODE_MASK
operator|)
operator|==
operator|(
name|e1000_mng_mode_pt
operator|<<
name|E1000_FWSM_MODE_SHIFT
operator|)
operator|)
condition|)
block|{
name|ret_val
operator|=
name|TRUE
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|manc
operator|&
name|E1000_MANC_SMBUS_EN
operator|)
operator|&&
operator|!
operator|(
name|manc
operator|&
name|E1000_MANC_ASF_EN
operator|)
condition|)
block|{
name|ret_val
operator|=
name|TRUE
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

end_unit

