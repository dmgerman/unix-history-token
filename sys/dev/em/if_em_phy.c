begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*******************************************************************************    Copyright (c) 2001-2002 Intel Corporation    All rights reserved.       Redistribution and use in source and binary forms of the Software, with or    without modification, are permitted provided that the following conditions    are met:        1. Redistributions of source code of the Software may retain the above        copyright notice, this list of conditions and the following disclaimer.        2. Redistributions in binary form of the Software may reproduce the above        copyright notice, this list of conditions and the following disclaimer        in the documentation and/or other materials provided with the        distribution.        3. Neither the name of the Intel Corporation nor the names of its        contributors shall be used to endorse or promote products derived from        this Software without specific prior written permission.      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE    ARE DISCLAIMED. IN NO EVENT SHALL THE INTEL OR ITS CONTRIBUTORS BE LIABLE    FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL    DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR    SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER    CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT    LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY    OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF    SUCH DAMAGE.  *******************************************************************************/
end_comment

begin_comment
comment|/*$FreeBSD$*/
end_comment

begin_comment
comment|/* if_em_phy.c  * Shared functions for accessing and configuring the PHY  */
end_comment

begin_include
include|#
directive|include
file|<dev/em/if_em_fxhw.h>
end_include

begin_include
include|#
directive|include
file|<dev/em/if_em_phy.h>
end_include

begin_comment
comment|/****************************************************************************** * Raises the Management Data Clock * * shared - Struct containing variables accessed by shared code * ctrl_reg - Device control register's current value ******************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|em_raise_mdc
parameter_list|(
name|struct
name|em_shared_adapter
modifier|*
name|shared
parameter_list|,
name|uint32_t
modifier|*
name|ctrl_reg
parameter_list|)
block|{
comment|/* Raise the clock input to the Management Data Clock (by setting      * the MDC bit), and then delay 2 microseconds.      */
name|E1000_WRITE_REG
argument_list|(
name|shared
argument_list|,
name|CTRL
argument_list|,
operator|(
operator|*
name|ctrl_reg
operator||
name|E1000_CTRL_MDC
operator|)
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|2
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/****************************************************************************** * Lowers the Management Data Clock * * shared - Struct containing variables accessed by shared code * ctrl_reg - Device control register's current value ******************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|em_lower_mdc
parameter_list|(
name|struct
name|em_shared_adapter
modifier|*
name|shared
parameter_list|,
name|uint32_t
modifier|*
name|ctrl_reg
parameter_list|)
block|{
comment|/* Lower the clock input to the Management Data Clock (by clearing      * the MDC bit), and then delay 2 microseconds.      */
name|E1000_WRITE_REG
argument_list|(
name|shared
argument_list|,
name|CTRL
argument_list|,
operator|(
operator|*
name|ctrl_reg
operator|&
operator|~
name|E1000_CTRL_MDC
operator|)
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|2
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/****************************************************************************** * Shifts data bits out to the PHY * * shared - Struct containing variables accessed by shared code * data - Data to send out to the PHY * count - Number of bits to shift out * * Bits are shifted out in MSB to LSB order. ******************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|em_phy_shift_out
parameter_list|(
name|struct
name|em_shared_adapter
modifier|*
name|shared
parameter_list|,
name|uint32_t
name|data
parameter_list|,
name|uint16_t
name|count
parameter_list|)
block|{
name|uint32_t
name|ctrl_reg
decl_stmt|;
name|uint32_t
name|mask
decl_stmt|;
name|ASSERT
argument_list|(
name|count
operator|<=
literal|32
argument_list|)
expr_stmt|;
comment|/* We need to shift "count" number of bits out to the PHY.  So, the      * value in the "Data" parameter will be shifted out to the PHY      * one bit at a time.  In order to do this, "Data" must be broken      * down into bits, which is what the "while" logic does below.      */
name|mask
operator|=
literal|0x01
expr_stmt|;
name|mask
operator|<<=
operator|(
name|count
operator|-
literal|1
operator|)
expr_stmt|;
name|ctrl_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|shared
argument_list|,
name|CTRL
argument_list|)
expr_stmt|;
comment|/* Set MDIO_DIR (SWDPIO1) and MDC_DIR (SWDPIO2) direction bits to      * be used as output pins.      */
name|ctrl_reg
operator||=
operator|(
name|E1000_CTRL_MDIO_DIR
operator||
name|E1000_CTRL_MDC_DIR
operator|)
expr_stmt|;
while|while
condition|(
name|mask
condition|)
block|{
comment|/* A "1" is shifted out to the PHY by setting the MDIO bit to          * "1" and then raising and lowering the Management Data Clock          * (MDC).  A "0" is shifted out to the PHY by setting the MDIO          * bit to "0" and then raising and lowering the clock.          */
if|if
condition|(
name|data
operator|&
name|mask
condition|)
name|ctrl_reg
operator||=
name|E1000_CTRL_MDIO
expr_stmt|;
else|else
name|ctrl_reg
operator|&=
operator|~
name|E1000_CTRL_MDIO
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|shared
argument_list|,
name|CTRL
argument_list|,
name|ctrl_reg
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|em_raise_mdc
argument_list|(
name|shared
argument_list|,
operator|&
name|ctrl_reg
argument_list|)
expr_stmt|;
name|em_lower_mdc
argument_list|(
name|shared
argument_list|,
operator|&
name|ctrl_reg
argument_list|)
expr_stmt|;
name|mask
operator|=
name|mask
operator|>>
literal|1
expr_stmt|;
block|}
comment|/* Clear the data bit just before leaving this routine. */
name|ctrl_reg
operator|&=
operator|~
name|E1000_CTRL_MDIO
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/****************************************************************************** * Shifts data bits in from the PHY * * shared - Struct containing variables accessed by shared code * * Bits are shifted in in MSB to LSB order.  ******************************************************************************/
end_comment

begin_function
specifier|static
name|uint16_t
name|em_phy_shift_in
parameter_list|(
name|struct
name|em_shared_adapter
modifier|*
name|shared
parameter_list|)
block|{
name|uint32_t
name|ctrl_reg
decl_stmt|;
name|uint16_t
name|data
init|=
literal|0
decl_stmt|;
name|uint8_t
name|i
decl_stmt|;
comment|/* In order to read a register from the PHY, we need to shift in a      * total of 18 bits from the PHY.  The first two bit (TurnAround)      * times are used to avoid contention on the MDIO pin when a read      * operation is performed.  These two bits are ignored by us and      * thrown away.  Bits are "shifted in" by raising the clock input      * to the Management Data Clock (setting the MDC bit), and then      * reading the value of the MDIO bit.      */
name|ctrl_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|shared
argument_list|,
name|CTRL
argument_list|)
expr_stmt|;
comment|/* Clear MDIO_DIR (SWDPIO1) to indicate this bit is to be used as      * input.      */
name|ctrl_reg
operator|&=
operator|~
name|E1000_CTRL_MDIO_DIR
expr_stmt|;
name|ctrl_reg
operator|&=
operator|~
name|E1000_CTRL_MDIO
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|shared
argument_list|,
name|CTRL
argument_list|,
name|ctrl_reg
argument_list|)
expr_stmt|;
comment|/* Raise and Lower the clock before reading in the data.  This      * accounts for the TurnAround bits.  The first clock occurred      * when we clocked out the last bit of the Register Address.      */
name|em_raise_mdc
argument_list|(
name|shared
argument_list|,
operator|&
name|ctrl_reg
argument_list|)
expr_stmt|;
name|em_lower_mdc
argument_list|(
name|shared
argument_list|,
operator|&
name|ctrl_reg
argument_list|)
expr_stmt|;
for|for
control|(
name|data
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|data
operator|=
name|data
operator|<<
literal|1
expr_stmt|;
name|em_raise_mdc
argument_list|(
name|shared
argument_list|,
operator|&
name|ctrl_reg
argument_list|)
expr_stmt|;
name|ctrl_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|shared
argument_list|,
name|CTRL
argument_list|)
expr_stmt|;
comment|/* Check to see if we shifted in a "1". */
if|if
condition|(
name|ctrl_reg
operator|&
name|E1000_CTRL_MDIO
condition|)
name|data
operator||=
literal|1
expr_stmt|;
name|em_lower_mdc
argument_list|(
name|shared
argument_list|,
operator|&
name|ctrl_reg
argument_list|)
expr_stmt|;
block|}
name|em_raise_mdc
argument_list|(
name|shared
argument_list|,
operator|&
name|ctrl_reg
argument_list|)
expr_stmt|;
name|em_lower_mdc
argument_list|(
name|shared
argument_list|,
operator|&
name|ctrl_reg
argument_list|)
expr_stmt|;
comment|/* Clear the MDIO bit just before leaving this routine. */
name|ctrl_reg
operator|&=
operator|~
name|E1000_CTRL_MDIO
expr_stmt|;
return|return
operator|(
name|data
operator|)
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************** * Force PHY speed and duplex settings to shared->forced_speed_duplex * * shared - Struct containing variables accessed by shared code ******************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|em_phy_force_speed_duplex
parameter_list|(
name|struct
name|em_shared_adapter
modifier|*
name|shared
parameter_list|)
block|{
name|uint32_t
name|tctl_reg
decl_stmt|;
name|uint32_t
name|ctrl_reg
decl_stmt|;
name|uint32_t
name|shift
decl_stmt|;
name|uint16_t
name|mii_ctrl_reg
decl_stmt|;
name|uint16_t
name|mii_status_reg
decl_stmt|;
name|uint16_t
name|phy_data
decl_stmt|;
name|uint16_t
name|i
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_phy_force_speed_duplex"
argument_list|)
expr_stmt|;
comment|/* Turn off Flow control if we are forcing speed and duplex. */
name|shared
operator|->
name|fc
operator|=
name|em_fc_none
expr_stmt|;
name|DEBUGOUT1
argument_list|(
literal|"shared->fc = %d\n"
argument_list|,
name|shared
operator|->
name|fc
argument_list|)
expr_stmt|;
comment|/* Read the Device Control Register. */
name|ctrl_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|shared
argument_list|,
name|CTRL
argument_list|)
expr_stmt|;
comment|/* Set the bits to Force Speed and Duplex in the Device Ctrl Reg. */
name|ctrl_reg
operator||=
operator|(
name|E1000_CTRL_FRCSPD
operator||
name|E1000_CTRL_FRCDPX
operator|)
expr_stmt|;
name|ctrl_reg
operator|&=
operator|~
operator|(
name|DEVICE_SPEED_MASK
operator|)
expr_stmt|;
comment|/* Clear the Auto Speed Detect Enable bit. */
name|ctrl_reg
operator|&=
operator|~
name|E1000_CTRL_ASDE
expr_stmt|;
comment|/* Read the MII Control Register. */
name|mii_ctrl_reg
operator|=
name|em_read_phy_reg
argument_list|(
name|shared
argument_list|,
name|PHY_CTRL
argument_list|)
expr_stmt|;
comment|/* We need to disable autoneg in order to force link and duplex. */
name|mii_ctrl_reg
operator|&=
operator|~
name|MII_CR_AUTO_NEG_EN
expr_stmt|;
comment|/* Are we forcing Full or Half Duplex? */
if|if
condition|(
name|shared
operator|->
name|forced_speed_duplex
operator|==
name|em_100_full
operator|||
name|shared
operator|->
name|forced_speed_duplex
operator|==
name|em_10_full
condition|)
block|{
comment|/* We want to force full duplex so we SET the full duplex bits          * in the Device and MII Control Registers.          */
name|ctrl_reg
operator||=
name|E1000_CTRL_FD
expr_stmt|;
name|mii_ctrl_reg
operator||=
name|MII_CR_FULL_DUPLEX
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Full Duplex\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* We want to force half duplex so we CLEAR the full duplex          * bits in the Device and MII Control Registers.          */
name|ctrl_reg
operator|&=
operator|~
name|E1000_CTRL_FD
expr_stmt|;
name|mii_ctrl_reg
operator|&=
operator|~
name|MII_CR_FULL_DUPLEX
expr_stmt|;
comment|/* Do this implies HALF */
name|DEBUGOUT
argument_list|(
literal|"Half Duplex\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Are we forcing 100Mbps??? */
if|if
condition|(
name|shared
operator|->
name|forced_speed_duplex
operator|==
name|em_100_full
operator|||
name|shared
operator|->
name|forced_speed_duplex
operator|==
name|em_100_half
condition|)
block|{
comment|/* Set the 100Mb bit and turn off the 1000Mb and 10Mb bits. */
name|ctrl_reg
operator||=
name|E1000_CTRL_SPD_100
expr_stmt|;
name|mii_ctrl_reg
operator||=
name|MII_CR_SPEED_100
expr_stmt|;
name|mii_ctrl_reg
operator|&=
operator|~
operator|(
name|MII_CR_SPEED_1000
operator||
name|MII_CR_SPEED_10
operator|)
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Forcing 100mb "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Force 10MB Full or Half */
comment|/* Set the 10Mb bit and turn off the 1000Mb and 100Mb bits. */
name|ctrl_reg
operator|&=
operator|~
operator|(
name|E1000_CTRL_SPD_1000
operator||
name|E1000_CTRL_SPD_100
operator|)
expr_stmt|;
name|mii_ctrl_reg
operator||=
name|MII_CR_SPEED_10
expr_stmt|;
name|mii_ctrl_reg
operator|&=
operator|~
operator|(
name|MII_CR_SPEED_1000
operator||
name|MII_CR_SPEED_100
operator|)
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Forcing 10mb "
argument_list|)
expr_stmt|;
block|}
comment|/* Now we need to configure the Collision Distance.  We need to read      * the Transmit Control Register to do this.      * Note: This must be done for both Half or Full Duplex.      */
name|tctl_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|shared
argument_list|,
name|TCTL
argument_list|)
expr_stmt|;
name|DEBUGOUT1
argument_list|(
literal|"tctl_reg = %x\n"
argument_list|,
name|tctl_reg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|mii_ctrl_reg
operator|&
name|MII_CR_FULL_DUPLEX
operator|)
condition|)
block|{
comment|/* We are in Half Duplex mode so we need to set up our collision         * distance for 10/100.         */
name|tctl_reg
operator|&=
operator|~
name|E1000_TCTL_COLD
expr_stmt|;
name|shift
operator|=
name|E1000_HDX_COLLISION_DISTANCE
expr_stmt|;
name|shift
operator|<<=
name|E1000_COLD_SHIFT
expr_stmt|;
name|tctl_reg
operator||=
name|shift
expr_stmt|;
block|}
else|else
block|{
comment|/* We are in Full Duplex mode.  We have the same collision          * distance regardless of speed.          */
name|tctl_reg
operator|&=
operator|~
name|E1000_TCTL_COLD
expr_stmt|;
name|shift
operator|=
name|E1000_FDX_COLLISION_DISTANCE
expr_stmt|;
name|shift
operator|<<=
name|E1000_COLD_SHIFT
expr_stmt|;
name|tctl_reg
operator||=
name|shift
expr_stmt|;
block|}
comment|/* Write the configured values back to the Transmit Control Reg. */
name|E1000_WRITE_REG
argument_list|(
name|shared
argument_list|,
name|TCTL
argument_list|,
name|tctl_reg
argument_list|)
expr_stmt|;
comment|/* Write the configured values back to the Device Control Reg. */
name|E1000_WRITE_REG
argument_list|(
name|shared
argument_list|,
name|CTRL
argument_list|,
name|ctrl_reg
argument_list|)
expr_stmt|;
comment|/* Write the MII Control Register with the new PHY configuration. */
name|phy_data
operator|=
name|em_read_phy_reg
argument_list|(
name|shared
argument_list|,
name|M88E1000_PHY_SPEC_CTRL
argument_list|)
expr_stmt|;
comment|/* Clear Auto-Crossover to force MDI manually.      * M88E1000 requires MDI forced whenever speed/duplex is forced      */
name|phy_data
operator|&=
operator|~
name|M88E1000_PSCR_AUTO_X_MODE
expr_stmt|;
name|em_write_phy_reg
argument_list|(
name|shared
argument_list|,
name|M88E1000_PHY_SPEC_CTRL
argument_list|,
name|phy_data
argument_list|)
expr_stmt|;
name|DEBUGOUT1
argument_list|(
literal|"M88E1000 PSCR: %x \n"
argument_list|,
name|phy_data
argument_list|)
expr_stmt|;
comment|/* Need to reset the PHY or these bits will get ignored. */
name|mii_ctrl_reg
operator||=
name|MII_CR_RESET
expr_stmt|;
name|em_write_phy_reg
argument_list|(
name|shared
argument_list|,
name|PHY_CTRL
argument_list|,
name|mii_ctrl_reg
argument_list|)
expr_stmt|;
comment|/* The wait_autoneg_complete flag may be a little misleading here.      * Since we are forcing speed and duplex, Auto-Neg is not enabled.      * But we do want to delay for a period while forcing only so we      * don't generate false No Link messages.  So we will wait here      * only if the user has set wait_autoneg_complete to 1, which is      * the default.      */
if|if
condition|(
name|shared
operator|->
name|wait_autoneg_complete
condition|)
block|{
comment|/* We will wait for autoneg to complete. */
name|DEBUGOUT
argument_list|(
literal|"Waiting for forced speed/duplex link.\n"
argument_list|)
expr_stmt|;
name|mii_status_reg
operator|=
literal|0
expr_stmt|;
comment|/* We will wait for autoneg to complete or 4.5 seconds to expire. */
for|for
control|(
name|i
operator|=
name|PHY_FORCE_TIME
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
comment|/* Read the MII Status Register and wait for Auto-Neg              * Complete bit to be set.              */
name|mii_status_reg
operator|=
name|em_read_phy_reg
argument_list|(
name|shared
argument_list|,
name|PHY_STATUS
argument_list|)
expr_stmt|;
name|mii_status_reg
operator|=
name|em_read_phy_reg
argument_list|(
name|shared
argument_list|,
name|PHY_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
name|mii_status_reg
operator|&
name|MII_SR_LINK_STATUS
condition|)
break|break;
name|msec_delay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
comment|/* end for loop */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
comment|/* We didn't get link   */
comment|/* Reset the DSP and wait again for link.   */
name|em_phy_reset_dsp
argument_list|(
name|shared
argument_list|)
expr_stmt|;
block|}
comment|/* This loop will early-out if the link condition has been met.  */
for|for
control|(
name|i
operator|=
name|PHY_FORCE_TIME
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|mii_status_reg
operator|&
name|MII_SR_LINK_STATUS
condition|)
break|break;
name|msec_delay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
comment|/* Read the MII Status Register and wait for Auto-Neg              * Complete bit to be set.              */
name|mii_status_reg
operator|=
name|em_read_phy_reg
argument_list|(
name|shared
argument_list|,
name|PHY_STATUS
argument_list|)
expr_stmt|;
name|mii_status_reg
operator|=
name|em_read_phy_reg
argument_list|(
name|shared
argument_list|,
name|PHY_STATUS
argument_list|)
expr_stmt|;
block|}
comment|/* end for loop */
block|}
comment|/* end if wait_autoneg_complete */
comment|/*      * Because we reset the PHY above, we need to re-force TX_CLK in the      * Extended PHY Specific Control Register to 25MHz clock.  This      * value defaults back to a 2.5MHz clock when the PHY is reset.      */
name|phy_data
operator|=
name|em_read_phy_reg
argument_list|(
name|shared
argument_list|,
name|M88E1000_EXT_PHY_SPEC_CTRL
argument_list|)
expr_stmt|;
name|phy_data
operator||=
name|M88E1000_EPSCR_TX_CLK_25
expr_stmt|;
name|em_write_phy_reg
argument_list|(
name|shared
argument_list|,
name|M88E1000_EXT_PHY_SPEC_CTRL
argument_list|,
name|phy_data
argument_list|)
expr_stmt|;
comment|/* In addition, because of the s/w reset above, we need to enable      * CRS on TX.  This must be set for both full and half duplex      * operation.      */
name|phy_data
operator|=
name|em_read_phy_reg
argument_list|(
name|shared
argument_list|,
name|M88E1000_PHY_SPEC_CTRL
argument_list|)
expr_stmt|;
name|phy_data
operator||=
name|M88E1000_PSCR_ASSERT_CRS_ON_TX
expr_stmt|;
name|em_write_phy_reg
argument_list|(
name|shared
argument_list|,
name|M88E1000_PHY_SPEC_CTRL
argument_list|,
name|phy_data
argument_list|)
expr_stmt|;
name|DEBUGOUT1
argument_list|(
literal|"M88E1000 Phy Specific Ctrl Reg = %4x\r\n"
argument_list|,
name|phy_data
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/***************************************************************************** * Reads the value from a PHY register * * shared - Struct containing variables accessed by shared code * reg_addr - address of the PHY register to read ******************************************************************************/
end_comment

begin_function
name|uint16_t
name|em_read_phy_reg
parameter_list|(
name|struct
name|em_shared_adapter
modifier|*
name|shared
parameter_list|,
name|uint32_t
name|reg_addr
parameter_list|)
block|{
name|uint32_t
name|i
decl_stmt|;
name|uint32_t
name|data
init|=
literal|0
decl_stmt|;
name|uint32_t
name|command
init|=
literal|0
decl_stmt|;
name|ASSERT
argument_list|(
name|reg_addr
operator|<=
name|MAX_PHY_REG_ADDRESS
argument_list|)
expr_stmt|;
if|if
condition|(
name|shared
operator|->
name|mac_type
operator|>
name|em_82543
condition|)
block|{
comment|/* Set up Op-code, Phy Address, and          * register address in the MDI Control register.  The MAC will          * take care of interfacing with the PHY to retrieve the          * desired data.          */
name|command
operator|=
operator|(
operator|(
name|reg_addr
operator|<<
name|E1000_MDIC_REG_SHIFT
operator|)
operator||
operator|(
name|shared
operator|->
name|phy_addr
operator|<<
name|E1000_MDIC_PHY_SHIFT
operator|)
operator||
operator|(
name|E1000_MDIC_OP_READ
operator|)
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|shared
argument_list|,
name|MDIC
argument_list|,
name|command
argument_list|)
expr_stmt|;
comment|/* Check every 10 usec to see if the read completed.  The read          * may take as long as 64 usecs (we'll wait 100 usecs max)          * from the CPU Write to the Ready bit assertion.          */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|64
condition|;
name|i
operator|++
control|)
block|{
name|usec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|data
operator|=
name|E1000_READ_REG
argument_list|(
name|shared
argument_list|,
name|MDIC
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|&
name|E1000_MDIC_READY
condition|)
break|break;
block|}
block|}
else|else
block|{
comment|/* We must first send a preamble through the MDIO pin to signal the          * beginning of an MII instruction.  This is done by sending 32          * consecutive "1" bits.          */
name|em_phy_shift_out
argument_list|(
name|shared
argument_list|,
name|PHY_PREAMBLE
argument_list|,
name|PHY_PREAMBLE_SIZE
argument_list|)
expr_stmt|;
comment|/* Now combine the next few fields that are required for a read          * operation.  We use this method instead of calling the          * em_phy_shift_out routine five different times.  The format of          * a MII read instruction consists of a shift out of 14 bits and is          * defined as follows:          *<Preamble><SOF><Op Code><Phy Addr><Reg Addr>          * followed by a shift in of 18 bits.  This first two bits shifted          * in are TurnAround bits used to avoid contention on the MDIO pin          * when a READ operation is performed.  These two bits are thrown          * away followed by a shift in of 16 bits which contains the          * desired data.          */
name|command
operator|=
operator|(
operator|(
name|reg_addr
operator|)
operator||
operator|(
name|shared
operator|->
name|phy_addr
operator|<<
literal|5
operator|)
operator||
operator|(
name|PHY_OP_READ
operator|<<
literal|10
operator|)
operator||
operator|(
name|PHY_SOF
operator|<<
literal|12
operator|)
operator|)
expr_stmt|;
name|em_phy_shift_out
argument_list|(
name|shared
argument_list|,
name|command
argument_list|,
literal|14
argument_list|)
expr_stmt|;
comment|/* Now that we've shifted out the read command to the MII, we need          * to "shift in" the 16-bit value (18 total bits) of the requested          * PHY register address.          */
name|data
operator|=
operator|(
name|uint32_t
operator|)
name|em_phy_shift_in
argument_list|(
name|shared
argument_list|)
expr_stmt|;
block|}
name|ASSERT
argument_list|(
operator|!
operator|(
name|data
operator|&
name|E1000_MDIC_ERROR
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|uint16_t
operator|)
name|data
operator|)
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************** * Writes a value to a PHY register * * shared - Struct containing variables accessed by shared code * reg_addr - address of the PHY register to write * data - data to write to the PHY ******************************************************************************/
end_comment

begin_function
name|void
name|em_write_phy_reg
parameter_list|(
name|struct
name|em_shared_adapter
modifier|*
name|shared
parameter_list|,
name|uint32_t
name|reg_addr
parameter_list|,
name|uint16_t
name|data
parameter_list|)
block|{
name|uint32_t
name|i
decl_stmt|;
name|uint32_t
name|command
init|=
literal|0
decl_stmt|;
name|uint32_t
name|mdic_reg
decl_stmt|;
name|ASSERT
argument_list|(
name|reg_addr
operator|<=
name|MAX_PHY_REG_ADDRESS
argument_list|)
expr_stmt|;
if|if
condition|(
name|shared
operator|->
name|mac_type
operator|>
name|em_82543
condition|)
block|{
comment|/* Set up Op-code, Phy Address, register          * address, and data intended for the PHY register in the MDI          * Control register.  The MAC will take care of interfacing          * with the PHY to send the desired data.          */
name|command
operator|=
operator|(
operator|(
operator|(
name|uint32_t
operator|)
name|data
operator|)
operator||
operator|(
name|reg_addr
operator|<<
name|E1000_MDIC_REG_SHIFT
operator|)
operator||
operator|(
name|shared
operator|->
name|phy_addr
operator|<<
name|E1000_MDIC_PHY_SHIFT
operator|)
operator||
operator|(
name|E1000_MDIC_OP_WRITE
operator|)
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|shared
argument_list|,
name|MDIC
argument_list|,
name|command
argument_list|)
expr_stmt|;
comment|/* Check every 10 usec to see if the read completed.  The read          * may take as long as 64 usecs (we'll wait 100 usecs max)          * from the CPU Write to the Ready bit assertion.          */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
block|{
name|usec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|mdic_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|shared
argument_list|,
name|MDIC
argument_list|)
expr_stmt|;
if|if
condition|(
name|mdic_reg
operator|&
name|E1000_MDIC_READY
condition|)
break|break;
block|}
block|}
else|else
block|{
comment|/* We'll need to use the SW defined pins to shift the write command          *  out to the PHY. We first send a preamble to the PHY to signal the          * beginning of the MII instruction.  This is done by sending 32           * consecutive "1" bits.          */
name|em_phy_shift_out
argument_list|(
name|shared
argument_list|,
name|PHY_PREAMBLE
argument_list|,
name|PHY_PREAMBLE_SIZE
argument_list|)
expr_stmt|;
comment|/* Now combine the remaining required fields that will indicate          * a write operation.  We use this method instead of calling the          * em_phy_shift_out routine for each field in the command.  The          * format of a MII write instruction is as follows:          *<Preamble><SOF><Op Code><Phy Addr><Reg Addr><Turnaround><Data>.          */
name|command
operator|=
operator|(
operator|(
name|PHY_TURNAROUND
operator|)
operator||
operator|(
name|reg_addr
operator|<<
literal|2
operator|)
operator||
operator|(
name|shared
operator|->
name|phy_addr
operator|<<
literal|7
operator|)
operator||
operator|(
name|PHY_OP_WRITE
operator|<<
literal|12
operator|)
operator||
operator|(
name|PHY_SOF
operator|<<
literal|14
operator|)
operator|)
expr_stmt|;
name|command
operator|<<=
literal|16
expr_stmt|;
name|command
operator||=
operator|(
operator|(
name|uint32_t
operator|)
name|data
operator|)
expr_stmt|;
name|em_phy_shift_out
argument_list|(
name|shared
argument_list|,
name|command
argument_list|,
literal|32
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/****************************************************************************** * Returns the PHY to the power-on reset state * * shared - Struct containing variables accessed by shared code ******************************************************************************/
end_comment

begin_function
name|void
name|em_phy_hw_reset
parameter_list|(
name|struct
name|em_shared_adapter
modifier|*
name|shared
parameter_list|)
block|{
name|uint32_t
name|ctrl_reg
decl_stmt|;
name|uint32_t
name|ctrl_ext_reg
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_phy_hw_reset"
argument_list|)
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Resetting Phy...\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|shared
operator|->
name|mac_type
operator|>
name|em_82543
condition|)
block|{
comment|/* Read the device control register and assert the          * E1000_CTRL_PHY_RST bit.  Hold for 20ms and then take it out          * of reset.          */
name|ctrl_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|shared
argument_list|,
name|CTRL
argument_list|)
expr_stmt|;
name|ctrl_reg
operator||=
name|E1000_CTRL_PHY_RST
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|shared
argument_list|,
name|CTRL
argument_list|,
name|ctrl_reg
argument_list|)
expr_stmt|;
name|msec_delay
argument_list|(
literal|20
argument_list|)
expr_stmt|;
name|ctrl_reg
operator|&=
operator|~
name|E1000_CTRL_PHY_RST
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|shared
argument_list|,
name|CTRL
argument_list|,
name|ctrl_reg
argument_list|)
expr_stmt|;
name|msec_delay
argument_list|(
literal|20
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Read the Extended Device Control Register, assert the          * PHY_RESET_DIR bit.  Then clock it out to the PHY.          */
name|ctrl_ext_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|shared
argument_list|,
name|CTRL_EXT
argument_list|)
expr_stmt|;
name|ctrl_ext_reg
operator||=
name|E1000_CTRL_PHY_RESET_DIR4
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|shared
argument_list|,
name|CTRL_EXT
argument_list|,
name|ctrl_ext_reg
argument_list|)
expr_stmt|;
name|msec_delay
argument_list|(
literal|20
argument_list|)
expr_stmt|;
comment|/* Set the reset bit in the device control register and clock          * it out to the PHY.          */
name|ctrl_ext_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|shared
argument_list|,
name|CTRL_EXT
argument_list|)
expr_stmt|;
name|ctrl_ext_reg
operator|&=
operator|~
name|E1000_CTRL_PHY_RESET4
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|shared
argument_list|,
name|CTRL_EXT
argument_list|,
name|ctrl_ext_reg
argument_list|)
expr_stmt|;
name|msec_delay
argument_list|(
literal|20
argument_list|)
expr_stmt|;
name|ctrl_ext_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|shared
argument_list|,
name|CTRL_EXT
argument_list|)
expr_stmt|;
name|ctrl_ext_reg
operator||=
name|E1000_CTRL_PHY_RESET4
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|shared
argument_list|,
name|CTRL_EXT
argument_list|,
name|ctrl_ext_reg
argument_list|)
expr_stmt|;
name|msec_delay
argument_list|(
literal|20
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/****************************************************************************** * Resets the PHY * * shared - Struct containing variables accessed by shared code * * Sets bit 15 of the MII Control regiser ******************************************************************************/
end_comment

begin_function
name|boolean_t
name|em_phy_reset
parameter_list|(
name|struct
name|em_shared_adapter
modifier|*
name|shared
parameter_list|)
block|{
name|uint16_t
name|reg_data
decl_stmt|;
name|uint16_t
name|i
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_phy_reset"
argument_list|)
expr_stmt|;
comment|/* Read the MII control register, set the reset bit and write the      * value back by clocking it out to the PHY.      */
name|reg_data
operator|=
name|em_read_phy_reg
argument_list|(
name|shared
argument_list|,
name|PHY_CTRL
argument_list|)
expr_stmt|;
name|reg_data
operator||=
name|MII_CR_RESET
expr_stmt|;
name|em_write_phy_reg
argument_list|(
name|shared
argument_list|,
name|PHY_CTRL
argument_list|,
name|reg_data
argument_list|)
expr_stmt|;
comment|/* Wait for bit 15 of the MII Control Register to be cleared      * indicating the PHY has been reset.      */
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|reg_data
operator|&
name|MII_CR_RESET
operator|)
operator|&&
name|i
operator|++
operator|<
literal|500
condition|)
block|{
name|reg_data
operator|=
name|em_read_phy_reg
argument_list|(
name|shared
argument_list|,
name|PHY_CTRL
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>=
literal|500
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Timeout waiting for PHY to reset.\n"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************** * Detects which PHY is present and the speed and duplex * * shared - Struct containing variables accessed by shared code * ctrl_reg - current value of the device control register ******************************************************************************/
end_comment

begin_function
name|boolean_t
name|em_phy_setup
parameter_list|(
name|struct
name|em_shared_adapter
modifier|*
name|shared
parameter_list|,
name|uint32_t
name|ctrl_reg
parameter_list|)
block|{
name|uint16_t
name|mii_ctrl_reg
decl_stmt|;
name|uint16_t
name|mii_status_reg
decl_stmt|;
name|uint16_t
name|phy_specific_ctrl_reg
decl_stmt|;
name|uint16_t
name|mii_autoneg_adv_reg
decl_stmt|;
name|uint16_t
name|mii_1000t_ctrl_reg
decl_stmt|;
name|uint16_t
name|i
decl_stmt|;
name|uint16_t
name|data
decl_stmt|;
name|uint16_t
name|autoneg_hw_setting
decl_stmt|;
name|uint16_t
name|autoneg_fc_setting
decl_stmt|;
name|boolean_t
name|restart_autoneg
init|=
name|FALSE
decl_stmt|;
name|boolean_t
name|force_autoneg_restart
init|=
name|FALSE
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_phy_setup"
argument_list|)
expr_stmt|;
comment|/* We want to enable the Auto-Speed Detection bit in the Device      * Control Register.  When set to 1, the MAC automatically detects      * the resolved speed of the link and self-configures appropriately.      * The Set Link Up bit must also be set for this behavior work      * properly.      */
comment|/* Nothing but 82543 and newer */
name|ASSERT
argument_list|(
name|shared
operator|->
name|mac_type
operator|>=
name|em_82543
argument_list|)
expr_stmt|;
comment|/* With 82543, we need to force speed/duplex      * on the MAC equal to what the PHY speed/duplex configuration is.      * In addition, on 82543, we need to perform a hardware reset      * on the PHY to take it out of reset.      */
if|if
condition|(
name|shared
operator|->
name|mac_type
operator|>=
name|em_82544
condition|)
block|{
name|ctrl_reg
operator||=
name|E1000_CTRL_SLU
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|shared
argument_list|,
name|CTRL
argument_list|,
name|ctrl_reg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ctrl_reg
operator||=
operator|(
name|E1000_CTRL_FRCSPD
operator||
name|E1000_CTRL_FRCDPX
operator||
name|E1000_CTRL_SLU
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|shared
argument_list|,
name|CTRL
argument_list|,
name|ctrl_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|shared
operator|->
name|mac_type
operator|==
name|em_82543
condition|)
name|em_phy_hw_reset
argument_list|(
name|shared
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|em_detect_gig_phy
argument_list|(
name|shared
argument_list|)
condition|)
block|{
comment|/* No PHY detected, return FALSE */
name|DEBUGOUT
argument_list|(
literal|"PhySetup failure, did not detect valid phy.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|DEBUGOUT1
argument_list|(
literal|"Phy ID = %x \n"
argument_list|,
name|shared
operator|->
name|phy_id
argument_list|)
expr_stmt|;
comment|/* Read the MII Control Register. */
name|mii_ctrl_reg
operator|=
name|em_read_phy_reg
argument_list|(
name|shared
argument_list|,
name|PHY_CTRL
argument_list|)
expr_stmt|;
name|DEBUGOUT1
argument_list|(
literal|"MII Ctrl Reg contents = %x\n"
argument_list|,
name|mii_ctrl_reg
argument_list|)
expr_stmt|;
comment|/* Check to see if the Auto Neg Enable bit is set in the MII Control      * Register.  If not, we could be in a situation where a driver was      * loaded previously and was forcing speed and duplex.  Then the      * driver was unloaded but a em_phy_hw_reset was not performed, so      * link was still being forced and link was still achieved.  Then      * the driver was reloaded with the intention to auto-negotiate, but      * since link is already established we end up not restarting      * auto-neg.  So if the auto-neg bit is not enabled and the driver      * is being loaded with the desire to auto-neg, we set this flag to      * to ensure the restart of the auto-neg engine later in the logic.      */
if|if
condition|(
operator|!
operator|(
name|mii_ctrl_reg
operator|&
name|MII_CR_AUTO_NEG_EN
operator|)
condition|)
name|force_autoneg_restart
operator|=
name|TRUE
expr_stmt|;
comment|/* Clear the isolate bit for normal operation and write it back to      * the MII Control Reg.  Although the spec says this doesn't need      * to be done when the PHY address is not equal to zero, we do it      * anyway just to be safe.      */
name|mii_ctrl_reg
operator|&=
operator|~
operator|(
name|MII_CR_ISOLATE
operator|)
expr_stmt|;
name|em_write_phy_reg
argument_list|(
name|shared
argument_list|,
name|PHY_CTRL
argument_list|,
name|mii_ctrl_reg
argument_list|)
expr_stmt|;
name|data
operator|=
name|em_read_phy_reg
argument_list|(
name|shared
argument_list|,
name|M88E1000_PHY_SPEC_CTRL
argument_list|)
expr_stmt|;
comment|/* Enable CRS on TX.  This must be set for half-duplex operation. */
name|data
operator||=
name|M88E1000_PSCR_ASSERT_CRS_ON_TX
expr_stmt|;
name|DEBUGOUT1
argument_list|(
literal|"M88E1000 PSCR: %x \n"
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|em_write_phy_reg
argument_list|(
name|shared
argument_list|,
name|M88E1000_PHY_SPEC_CTRL
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|data
operator|=
name|em_read_phy_reg
argument_list|(
name|shared
argument_list|,
name|M88E1000_EXT_PHY_SPEC_CTRL
argument_list|)
expr_stmt|;
comment|/* Force TX_CLK in the Extended PHY Specific Control Register      * to 25MHz clock.      */
name|data
operator||=
name|M88E1000_EPSCR_TX_CLK_25
expr_stmt|;
name|em_write_phy_reg
argument_list|(
name|shared
argument_list|,
name|M88E1000_EXT_PHY_SPEC_CTRL
argument_list|,
name|data
argument_list|)
expr_stmt|;
comment|/* Certain PHYs will set the default of MII register 4 differently.      * We need to check this against our fc value.  If it is      * different, we need to setup up register 4 correctly and restart      * autonegotiation.      */
comment|/* Read the MII Auto-Neg Advertisement Register (Address 4). */
name|mii_autoneg_adv_reg
operator|=
name|em_read_phy_reg
argument_list|(
name|shared
argument_list|,
name|PHY_AUTONEG_ADV
argument_list|)
expr_stmt|;
comment|/* Shift right to put 10T-Half bit in bit 0      * Isolate the four bits for 100/10 Full/Half.      */
name|autoneg_hw_setting
operator|=
operator|(
name|mii_autoneg_adv_reg
operator|>>
literal|5
operator|)
operator|&
literal|0xF
expr_stmt|;
comment|/* Get the 1000T settings. */
name|mii_1000t_ctrl_reg
operator|=
name|em_read_phy_reg
argument_list|(
name|shared
argument_list|,
name|PHY_1000T_CTRL
argument_list|)
expr_stmt|;
comment|/* Isolate and OR in the 1000T settings. */
name|autoneg_hw_setting
operator||=
operator|(
operator|(
name|mii_1000t_ctrl_reg
operator|&
literal|0x0300
operator|)
operator|>>
literal|4
operator|)
expr_stmt|;
comment|/* mask all bits in the MII Auto-Neg Advertisement Register      * except for ASM_DIR and PAUSE and shift.  This value      * will be used later to see if we need to restart Auto-Negotiation.      */
name|autoneg_fc_setting
operator|=
operator|(
operator|(
name|mii_autoneg_adv_reg
operator|&
literal|0x0C00
operator|)
operator|>>
literal|10
operator|)
expr_stmt|;
comment|/* Perform some bounds checking on the shared->autoneg_advertised      * parameter.  If this variable is zero, then set it to the default.      */
name|shared
operator|->
name|autoneg_advertised
operator|&=
name|AUTONEG_ADVERTISE_SPEED_DEFAULT
expr_stmt|;
comment|/* If autoneg_advertised is zero, we assume it was not defaulted      * by the calling code so we set to advertise full capability.      */
if|if
condition|(
name|shared
operator|->
name|autoneg_advertised
operator|==
literal|0
condition|)
name|shared
operator|->
name|autoneg_advertised
operator|=
name|AUTONEG_ADVERTISE_SPEED_DEFAULT
expr_stmt|;
comment|/* We could be in the situation where Auto-Neg has already completed      * and the user has not indicated any overrides.  In this case we      * simply need to call em_get_speed_and_duplex to obtain the Auto-      * Negotiated speed and duplex, then return.      */
if|if
condition|(
operator|!
name|force_autoneg_restart
operator|&&
name|shared
operator|->
name|autoneg
operator|&&
operator|(
name|shared
operator|->
name|autoneg_advertised
operator|==
name|autoneg_hw_setting
operator|)
operator|&&
operator|(
name|shared
operator|->
name|fc
operator|==
name|autoneg_fc_setting
operator|)
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"No overrides - Reading MII Status Reg..\n"
argument_list|)
expr_stmt|;
comment|/* Read the MII Status Register.  We read this twice because          * certain bits are "sticky" and need to be read twice.          */
name|mii_status_reg
operator|=
name|em_read_phy_reg
argument_list|(
name|shared
argument_list|,
name|PHY_STATUS
argument_list|)
expr_stmt|;
name|mii_status_reg
operator|=
name|em_read_phy_reg
argument_list|(
name|shared
argument_list|,
name|PHY_STATUS
argument_list|)
expr_stmt|;
name|DEBUGOUT1
argument_list|(
literal|"MII Status Reg contents = %x\n"
argument_list|,
name|mii_status_reg
argument_list|)
expr_stmt|;
comment|/* Do we have link now? (if so, auto-neg has completed) */
if|if
condition|(
name|mii_status_reg
operator|&
name|MII_SR_LINK_STATUS
condition|)
block|{
name|data
operator|=
name|em_read_phy_reg
argument_list|(
name|shared
argument_list|,
name|M88E1000_PHY_SPEC_STATUS
argument_list|)
expr_stmt|;
name|DEBUGOUT1
argument_list|(
literal|"M88E1000 Phy Specific Status Reg contents = %x\n"
argument_list|,
name|data
argument_list|)
expr_stmt|;
comment|/* We have link, so we need to finish the config process:              *   1) Set up the MAC to the current PHY speed/duplex              *      if we are on 82543.  If we              *      are on newer silicon, we only need to configure              *      collision distance in the Transmit Control Register.              *   2) Set up flow control on the MAC to that established              *      with the link partner.              */
if|if
condition|(
name|shared
operator|->
name|mac_type
operator|>=
name|em_82544
condition|)
name|em_config_collision_dist
argument_list|(
name|shared
argument_list|)
expr_stmt|;
else|else
name|em_config_mac_to_phy
argument_list|(
name|shared
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|em_config_fc_after_link_up
argument_list|(
name|shared
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
block|}
comment|/* Options:      *   MDI/MDI-X = 0 (default)      *   0 - Auto for all speeds      *   1 - MDI mode      *   2 - MDI-X mode      *   3 - Auto for 1000Base-T only (MDI-X for 10/100Base-T modes)      */
name|phy_specific_ctrl_reg
operator|=
name|em_read_phy_reg
argument_list|(
name|shared
argument_list|,
name|M88E1000_PHY_SPEC_CTRL
argument_list|)
expr_stmt|;
name|phy_specific_ctrl_reg
operator|&=
operator|~
name|M88E1000_PSCR_AUTO_X_MODE
expr_stmt|;
switch|switch
condition|(
name|shared
operator|->
name|mdix
condition|)
block|{
case|case
literal|1
case|:
name|phy_specific_ctrl_reg
operator||=
name|M88E1000_PSCR_MDI_MANUAL_MODE
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|phy_specific_ctrl_reg
operator||=
name|M88E1000_PSCR_MDIX_MANUAL_MODE
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|phy_specific_ctrl_reg
operator||=
name|M88E1000_PSCR_AUTO_X_1000T
expr_stmt|;
break|break;
case|case
literal|0
case|:
default|default:
name|phy_specific_ctrl_reg
operator||=
name|M88E1000_PSCR_AUTO_X_MODE
expr_stmt|;
break|break;
block|}
name|em_write_phy_reg
argument_list|(
name|shared
argument_list|,
name|M88E1000_PHY_SPEC_CTRL
argument_list|,
name|phy_specific_ctrl_reg
argument_list|)
expr_stmt|;
comment|/* Options:      *   disable_polarity_correction = 0 (default)      *       Automatic Correction for Reversed Cable Polarity      *   0 - Disabled      *   1 - Enabled      */
name|phy_specific_ctrl_reg
operator|=
name|em_read_phy_reg
argument_list|(
name|shared
argument_list|,
name|M88E1000_PHY_SPEC_CTRL
argument_list|)
expr_stmt|;
name|phy_specific_ctrl_reg
operator|&=
operator|~
name|M88E1000_PSCR_POLARITY_REVERSAL
expr_stmt|;
if|if
condition|(
name|shared
operator|->
name|disable_polarity_correction
operator|==
literal|1
condition|)
name|phy_specific_ctrl_reg
operator||=
name|M88E1000_PSCR_POLARITY_REVERSAL
expr_stmt|;
name|em_write_phy_reg
argument_list|(
name|shared
argument_list|,
name|M88E1000_PHY_SPEC_CTRL
argument_list|,
name|phy_specific_ctrl_reg
argument_list|)
expr_stmt|;
comment|/* Options:      *   autoneg = 1 (default)      *      PHY will advertise value(s) parsed from      *      autoneg_advertised and fc      *   autoneg = 0      *      PHY will be set to 10H, 10F, 100H, or 100F      *      depending on value parsed from forced_speed_duplex.      */
comment|/* Is autoneg enabled?  This is enabled by default or by software override.      * If so, call em_phy_setup_autoneg routine to parse the      * autoneg_advertised and fc options. If autoneg is NOT enabled, then the      * user should have provided a speed/duplex override.  If so, then call      * em_phy_force_speed_duplex to parse and set this up.  Otherwise,      * we are in an error situation and need to bail.      */
if|if
condition|(
name|shared
operator|->
name|autoneg
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Reconfiguring auto-neg advertisement params\n"
argument_list|)
expr_stmt|;
name|restart_autoneg
operator|=
name|em_phy_setup_autoneg
argument_list|(
name|shared
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DEBUGOUT
argument_list|(
literal|"Forcing speed and duplex\n"
argument_list|)
expr_stmt|;
name|em_phy_force_speed_duplex
argument_list|(
name|shared
argument_list|)
expr_stmt|;
block|}
comment|/* Based on information parsed above, check the flag to indicate      * whether we need to restart Auto-Neg.      */
if|if
condition|(
name|restart_autoneg
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Restarting Auto-Neg\n"
argument_list|)
expr_stmt|;
comment|/* Read the MII Control Register. */
name|mii_ctrl_reg
operator|=
name|em_read_phy_reg
argument_list|(
name|shared
argument_list|,
name|PHY_CTRL
argument_list|)
expr_stmt|;
comment|/* Restart auto-negotiation by setting the Auto Neg Enable bit and          * the Auto Neg Restart bit.          */
name|mii_ctrl_reg
operator||=
operator|(
name|MII_CR_AUTO_NEG_EN
operator||
name|MII_CR_RESTART_AUTO_NEG
operator|)
expr_stmt|;
name|em_write_phy_reg
argument_list|(
name|shared
argument_list|,
name|PHY_CTRL
argument_list|,
name|mii_ctrl_reg
argument_list|)
expr_stmt|;
comment|/* Does the user want to wait for Auto-Neg to complete here, or          * check at a later time (for example, callback routine).          */
if|if
condition|(
name|shared
operator|->
name|wait_autoneg_complete
condition|)
name|em_wait_autoneg
argument_list|(
name|shared
argument_list|)
expr_stmt|;
block|}
comment|/* end if restart_autoneg */
comment|/* Read the MII Status Register. */
name|mii_status_reg
operator|=
name|em_read_phy_reg
argument_list|(
name|shared
argument_list|,
name|PHY_STATUS
argument_list|)
expr_stmt|;
name|mii_status_reg
operator|=
name|em_read_phy_reg
argument_list|(
name|shared
argument_list|,
name|PHY_STATUS
argument_list|)
expr_stmt|;
name|DEBUGOUT1
argument_list|(
literal|"Checking for link status - MII Status Reg contents = %x\n"
argument_list|,
name|mii_status_reg
argument_list|)
expr_stmt|;
comment|/* Check link status.  Wait up to 100 microseconds for link to      * become valid.      */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|mii_status_reg
operator|&
name|MII_SR_LINK_STATUS
condition|)
break|break;
name|usec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|". "
argument_list|)
expr_stmt|;
name|mii_status_reg
operator|=
name|em_read_phy_reg
argument_list|(
name|shared
argument_list|,
name|PHY_STATUS
argument_list|)
expr_stmt|;
name|mii_status_reg
operator|=
name|em_read_phy_reg
argument_list|(
name|shared
argument_list|,
name|PHY_STATUS
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mii_status_reg
operator|&
name|MII_SR_LINK_STATUS
condition|)
block|{
comment|/* Yes, so configure MAC to PHY settings as well as flow control          * registers.          */
name|data
operator|=
name|em_read_phy_reg
argument_list|(
name|shared
argument_list|,
name|M88E1000_PHY_SPEC_STATUS
argument_list|)
expr_stmt|;
name|DEBUGOUT1
argument_list|(
literal|"M88E1000 Phy Specific Status Reg contents = %x\n"
argument_list|,
name|data
argument_list|)
expr_stmt|;
comment|/* We have link, so we need to finish the config process:          *   1) Set up the MAC to the current PHY speed/duplex          *      if we are on 82543.  If we          *      are on newer silicon, we only need to configure          *      collision distance in the Transmit Control Register.          *   2) Set up flow control on the MAC to that established with          *      the link partner.          */
if|if
condition|(
name|shared
operator|->
name|mac_type
operator|>=
name|em_82544
condition|)
name|em_config_collision_dist
argument_list|(
name|shared
argument_list|)
expr_stmt|;
else|else
name|em_config_mac_to_phy
argument_list|(
name|shared
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|em_config_fc_after_link_up
argument_list|(
name|shared
argument_list|)
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Valid link established!!!\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DEBUGOUT
argument_list|(
literal|"Unable to establish link!!!\n"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************** * Configures PHY autoneg and flow control advertisement settings * * shared - Struct containing variables accessed by shared code ******************************************************************************/
end_comment

begin_function
name|boolean_t
name|em_phy_setup_autoneg
parameter_list|(
name|struct
name|em_shared_adapter
modifier|*
name|shared
parameter_list|)
block|{
name|uint16_t
name|mii_autoneg_adv_reg
decl_stmt|;
name|uint16_t
name|mii_1000t_ctrl_reg
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_phy_setup_autoneg"
argument_list|)
expr_stmt|;
comment|/* Read the MII Auto-Neg Advertisement Register (Address 4). */
name|mii_autoneg_adv_reg
operator|=
name|em_read_phy_reg
argument_list|(
name|shared
argument_list|,
name|PHY_AUTONEG_ADV
argument_list|)
expr_stmt|;
comment|/* Read the MII 1000Base-T Control Register (Address 9). */
name|mii_1000t_ctrl_reg
operator|=
name|em_read_phy_reg
argument_list|(
name|shared
argument_list|,
name|PHY_1000T_CTRL
argument_list|)
expr_stmt|;
comment|/* Need to parse both autoneg_advertised and fc and set up      * the appropriate PHY registers.  First we will parse for      * autoneg_advertised software override.  Since we can advertise      * a plethora of combinations, we need to check each bit      * individually.      */
comment|/* First we clear all the 10/100 mb speed bits in the Auto-Neg      * Advertisement Register (Address 4) and the 1000 mb speed bits in      * the  1000Base-T Control Register (Address 9).      */
name|mii_autoneg_adv_reg
operator|&=
operator|~
name|REG4_SPEED_MASK
expr_stmt|;
name|mii_1000t_ctrl_reg
operator|&=
operator|~
name|REG9_SPEED_MASK
expr_stmt|;
name|DEBUGOUT1
argument_list|(
literal|"autoneg_advertised %x\n"
argument_list|,
name|shared
operator|->
name|autoneg_advertised
argument_list|)
expr_stmt|;
comment|/* Do we want to advertise 10 Mb Half Duplex? */
if|if
condition|(
name|shared
operator|->
name|autoneg_advertised
operator|&
name|ADVERTISE_10_HALF
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Advertise 10mb Half duplex\n"
argument_list|)
expr_stmt|;
name|mii_autoneg_adv_reg
operator||=
name|NWAY_AR_10T_HD_CAPS
expr_stmt|;
block|}
comment|/* Do we want to advertise 10 Mb Full Duplex? */
if|if
condition|(
name|shared
operator|->
name|autoneg_advertised
operator|&
name|ADVERTISE_10_FULL
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Advertise 10mb Full duplex\n"
argument_list|)
expr_stmt|;
name|mii_autoneg_adv_reg
operator||=
name|NWAY_AR_10T_FD_CAPS
expr_stmt|;
block|}
comment|/* Do we want to advertise 100 Mb Half Duplex? */
if|if
condition|(
name|shared
operator|->
name|autoneg_advertised
operator|&
name|ADVERTISE_100_HALF
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Advertise 100mb Half duplex\n"
argument_list|)
expr_stmt|;
name|mii_autoneg_adv_reg
operator||=
name|NWAY_AR_100TX_HD_CAPS
expr_stmt|;
block|}
comment|/* Do we want to advertise 100 Mb Full Duplex? */
if|if
condition|(
name|shared
operator|->
name|autoneg_advertised
operator|&
name|ADVERTISE_100_FULL
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Advertise 100mb Full duplex\n"
argument_list|)
expr_stmt|;
name|mii_autoneg_adv_reg
operator||=
name|NWAY_AR_100TX_FD_CAPS
expr_stmt|;
block|}
comment|/* We do not allow the Phy to advertise 1000 Mb Half Duplex */
if|if
condition|(
name|shared
operator|->
name|autoneg_advertised
operator|&
name|ADVERTISE_1000_HALF
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Advertise 1000mb Half duplex requested, request denied!\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Do we want to advertise 1000 Mb Full Duplex? */
if|if
condition|(
name|shared
operator|->
name|autoneg_advertised
operator|&
name|ADVERTISE_1000_FULL
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Advertise 1000mb Full duplex\n"
argument_list|)
expr_stmt|;
name|mii_1000t_ctrl_reg
operator||=
name|CR_1000T_FD_CAPS
expr_stmt|;
block|}
comment|/* Check for a software override of the flow control settings, and      * setup the PHY advertisement registers accordingly.  If      * auto-negotiation is enabled, then software will have to set the      * "PAUSE" bits to the correct value in the Auto-Negotiation      * Advertisement Register (PHY_AUTONEG_ADV) and re-start auto-negotiation.      *      * The possible values of the "fc" parameter are:      *      0:  Flow control is completely disabled      *      1:  Rx flow control is enabled (we can receive pause frames      *          but not send pause frames).      *      2:  Tx flow control is enabled (we can send pause frames      *          but we do not support receiving pause frames).      *      3:  Both Rx and TX flow control (symmetric) are enabled.      *  other:  No software override.  The flow control configuration      *          in the EEPROM is used.      */
switch|switch
condition|(
name|shared
operator|->
name|fc
condition|)
block|{
case|case
name|em_fc_none
case|:
comment|/* 0 */
comment|/* Flow control (RX& TX) is completely disabled by a              * software over-ride.              */
name|mii_autoneg_adv_reg
operator|&=
operator|~
operator|(
name|NWAY_AR_ASM_DIR
operator||
name|NWAY_AR_PAUSE
operator|)
expr_stmt|;
break|break;
case|case
name|em_fc_rx_pause
case|:
comment|/* 1 */
comment|/* RX Flow control is enabled, and TX Flow control is              * disabled, by a software over-ride.              */
comment|/* Since there really isn't a way to advertise that we are              * capable of RX Pause ONLY, we will advertise that we              * support both symmetric and asymmetric RX PAUSE.  Later              * (in em_config_fc_after_link_up) we will disable the              *shared's ability to send PAUSE frames.              */
name|mii_autoneg_adv_reg
operator||=
operator|(
name|NWAY_AR_ASM_DIR
operator||
name|NWAY_AR_PAUSE
operator|)
expr_stmt|;
break|break;
case|case
name|em_fc_tx_pause
case|:
comment|/* 2 */
comment|/* TX Flow control is enabled, and RX Flow control is              * disabled, by a software over-ride.              */
name|mii_autoneg_adv_reg
operator||=
name|NWAY_AR_ASM_DIR
expr_stmt|;
name|mii_autoneg_adv_reg
operator|&=
operator|~
name|NWAY_AR_PAUSE
expr_stmt|;
break|break;
case|case
name|em_fc_full
case|:
comment|/* 3 */
comment|/* Flow control (both RX and TX) is enabled by a software              * over-ride.              */
name|mii_autoneg_adv_reg
operator||=
operator|(
name|NWAY_AR_ASM_DIR
operator||
name|NWAY_AR_PAUSE
operator|)
expr_stmt|;
break|break;
default|default:
comment|/* We should never get here.  The value should be 0-3. */
name|DEBUGOUT
argument_list|(
literal|"Flow control param set incorrectly\n"
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Write the MII Auto-Neg Advertisement Register (Address 4). */
name|em_write_phy_reg
argument_list|(
name|shared
argument_list|,
name|PHY_AUTONEG_ADV
argument_list|,
name|mii_autoneg_adv_reg
argument_list|)
expr_stmt|;
name|DEBUGOUT1
argument_list|(
literal|"Auto-Neg Advertising %x\n"
argument_list|,
name|mii_autoneg_adv_reg
argument_list|)
expr_stmt|;
comment|/* Write the MII 1000Base-T Control Register (Address 9). */
name|em_write_phy_reg
argument_list|(
name|shared
argument_list|,
name|PHY_1000T_CTRL
argument_list|,
name|mii_1000t_ctrl_reg
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************** * Sets MAC speed and duplex settings to reflect the those in the PHY * * shared - Struct containing variables accessed by shared code * mii_reg - data to write to the MII control register * * The contents of the PHY register containing the needed information need to * be passed in. ******************************************************************************/
end_comment

begin_function
name|void
name|em_config_mac_to_phy
parameter_list|(
name|struct
name|em_shared_adapter
modifier|*
name|shared
parameter_list|,
name|uint16_t
name|mii_reg
parameter_list|)
block|{
name|uint32_t
name|ctrl_reg
decl_stmt|;
name|uint32_t
name|tctl_reg
decl_stmt|;
name|uint32_t
name|shift
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_config_mac_to_phy"
argument_list|)
expr_stmt|;
comment|/* We need to read the Transmit Control register to configure the      * collision distance.      * Note: This must be done for both Half or Full Duplex.      */
name|tctl_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|shared
argument_list|,
name|TCTL
argument_list|)
expr_stmt|;
name|DEBUGOUT1
argument_list|(
literal|"tctl_reg = %x\n"
argument_list|,
name|tctl_reg
argument_list|)
expr_stmt|;
comment|/* Read the Device Control Register and set the bits to Force Speed      * and Duplex.      */
name|ctrl_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|shared
argument_list|,
name|CTRL
argument_list|)
expr_stmt|;
name|ctrl_reg
operator||=
operator|(
name|E1000_CTRL_FRCSPD
operator||
name|E1000_CTRL_FRCDPX
operator|)
expr_stmt|;
name|ctrl_reg
operator|&=
operator|~
operator|(
name|DEVICE_SPEED_MASK
operator|)
expr_stmt|;
name|DEBUGOUT1
argument_list|(
literal|"MII Register Data = %x\r\n"
argument_list|,
name|mii_reg
argument_list|)
expr_stmt|;
comment|/* Clear the ILOS bit. */
name|ctrl_reg
operator|&=
operator|~
name|E1000_CTRL_ILOS
expr_stmt|;
comment|/* Set up duplex in the Device Control and Transmit Control      * registers depending on negotiated values.      */
if|if
condition|(
name|mii_reg
operator|&
name|M88E1000_PSSR_DPLX
condition|)
block|{
name|ctrl_reg
operator||=
name|E1000_CTRL_FD
expr_stmt|;
comment|/* We are in Full Duplex mode.  We have the same collision          * distance regardless of speed.          */
name|tctl_reg
operator|&=
operator|~
name|E1000_TCTL_COLD
expr_stmt|;
name|shift
operator|=
name|E1000_FDX_COLLISION_DISTANCE
expr_stmt|;
name|shift
operator|<<=
name|E1000_COLD_SHIFT
expr_stmt|;
name|tctl_reg
operator||=
name|shift
expr_stmt|;
block|}
else|else
block|{
name|ctrl_reg
operator|&=
operator|~
name|E1000_CTRL_FD
expr_stmt|;
comment|/* We are in Half Duplex mode.  Our Half Duplex collision          * distance is different for Gigabit than for 10/100 so we will          * set accordingly.          */
if|if
condition|(
operator|(
name|mii_reg
operator|&
name|M88E1000_PSSR_SPEED
operator|)
operator|==
name|M88E1000_PSSR_1000MBS
condition|)
block|{
comment|/* 1000Mbs HDX */
name|tctl_reg
operator|&=
operator|~
name|E1000_TCTL_COLD
expr_stmt|;
name|shift
operator|=
name|E1000_GB_HDX_COLLISION_DISTANCE
expr_stmt|;
name|shift
operator|<<=
name|E1000_COLD_SHIFT
expr_stmt|;
name|tctl_reg
operator||=
name|shift
expr_stmt|;
name|tctl_reg
operator||=
name|E1000_TCTL_PBE
expr_stmt|;
comment|/* Enable Packet Bursting */
block|}
else|else
block|{
comment|/* 10/100Mbs HDX */
name|tctl_reg
operator|&=
operator|~
name|E1000_TCTL_COLD
expr_stmt|;
name|shift
operator|=
name|E1000_HDX_COLLISION_DISTANCE
expr_stmt|;
name|shift
operator|<<=
name|E1000_COLD_SHIFT
expr_stmt|;
name|tctl_reg
operator||=
name|shift
expr_stmt|;
block|}
block|}
comment|/* Set up speed in the Device Control register depending on      * negotiated values.      */
if|if
condition|(
operator|(
name|mii_reg
operator|&
name|M88E1000_PSSR_SPEED
operator|)
operator|==
name|M88E1000_PSSR_1000MBS
condition|)
name|ctrl_reg
operator||=
name|E1000_CTRL_SPD_1000
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|mii_reg
operator|&
name|M88E1000_PSSR_SPEED
operator|)
operator|==
name|M88E1000_PSSR_100MBS
condition|)
name|ctrl_reg
operator||=
name|E1000_CTRL_SPD_100
expr_stmt|;
else|else
name|ctrl_reg
operator|&=
operator|~
operator|(
name|E1000_CTRL_SPD_1000
operator||
name|E1000_CTRL_SPD_100
operator|)
expr_stmt|;
comment|/* Write the configured values back to the Transmit Control Reg. */
name|E1000_WRITE_REG
argument_list|(
name|shared
argument_list|,
name|TCTL
argument_list|,
name|tctl_reg
argument_list|)
expr_stmt|;
comment|/* Write the configured values back to the Device Control Reg. */
name|E1000_WRITE_REG
argument_list|(
name|shared
argument_list|,
name|CTRL
argument_list|,
name|ctrl_reg
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/****************************************************************************** * Sets the collision distance in the Transmit Control register * * shared - Struct containing variables accessed by shared code * * Link should have been established previously. Reads the speed and duplex * information from the Device Status register. ******************************************************************************/
end_comment

begin_function
name|void
name|em_config_collision_dist
parameter_list|(
name|struct
name|em_shared_adapter
modifier|*
name|shared
parameter_list|)
block|{
name|uint32_t
name|tctl_reg
decl_stmt|;
name|uint16_t
name|speed
decl_stmt|;
name|uint16_t
name|duplex
decl_stmt|;
name|uint32_t
name|shift
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_config_collision_dist"
argument_list|)
expr_stmt|;
comment|/* Get our current speed and duplex from the Device Status Register. */
name|em_get_speed_and_duplex
argument_list|(
name|shared
argument_list|,
operator|&
name|speed
argument_list|,
operator|&
name|duplex
argument_list|)
expr_stmt|;
comment|/* We need to configure the Collision Distance for both Full or      * Half Duplex.      */
name|tctl_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|shared
argument_list|,
name|TCTL
argument_list|)
expr_stmt|;
name|DEBUGOUT1
argument_list|(
literal|"tctl_reg = %x\n"
argument_list|,
name|tctl_reg
argument_list|)
expr_stmt|;
comment|/* mask the Collision Distance bits in the Transmit Control Reg. */
name|tctl_reg
operator|&=
operator|~
name|E1000_TCTL_COLD
expr_stmt|;
if|if
condition|(
name|duplex
operator|==
name|FULL_DUPLEX
condition|)
block|{
comment|/* We are in Full Duplex mode.  Therefore, the collision distance          * is the same regardless of speed.          */
name|shift
operator|=
name|E1000_FDX_COLLISION_DISTANCE
expr_stmt|;
name|shift
operator|<<=
name|E1000_COLD_SHIFT
expr_stmt|;
name|tctl_reg
operator||=
name|shift
expr_stmt|;
block|}
else|else
block|{
comment|/* We are in Half Duplex mode.  Half Duplex collision distance is          * different for Gigabit vs. 10/100, so we will set accordingly.          */
if|if
condition|(
name|speed
operator|==
name|SPEED_1000
condition|)
block|{
comment|/* 1000Mbs HDX */
name|shift
operator|=
name|E1000_GB_HDX_COLLISION_DISTANCE
expr_stmt|;
name|shift
operator|<<=
name|E1000_COLD_SHIFT
expr_stmt|;
name|tctl_reg
operator||=
name|shift
expr_stmt|;
name|tctl_reg
operator||=
name|E1000_TCTL_PBE
expr_stmt|;
comment|/* Enable Packet Bursting */
block|}
else|else
block|{
comment|/* 10/100Mbs HDX */
name|shift
operator|=
name|E1000_HDX_COLLISION_DISTANCE
expr_stmt|;
name|shift
operator|<<=
name|E1000_COLD_SHIFT
expr_stmt|;
name|tctl_reg
operator||=
name|shift
expr_stmt|;
block|}
block|}
comment|/* Write the configured values back to the Transmit Control Reg. */
name|E1000_WRITE_REG
argument_list|(
name|shared
argument_list|,
name|TCTL
argument_list|,
name|tctl_reg
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_if
if|#
directive|if
name|DBG
end_if

begin_comment
comment|/****************************************************************************** * Displays the contents of all of the MII registers * * shared - Struct containing variables accessed by shared code * * For debugging. ******************************************************************************/
end_comment

begin_function
name|void
name|em_display_mii
parameter_list|(
name|struct
name|em_shared_adapter
modifier|*
name|shared
parameter_list|)
block|{
name|uint16_t
name|data
decl_stmt|;
name|uint16_t
name|phy_id_high
decl_stmt|;
name|uint16_t
name|phy_id_low
decl_stmt|;
name|uint32_t
name|phy_id
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_display_mii"
argument_list|)
expr_stmt|;
name|DEBUGOUT1
argument_list|(
literal|"adapter Base Address = %x\n"
argument_list|,
name|shared
operator|->
name|hw_addr
argument_list|)
expr_stmt|;
comment|/* This will read each PHY Reg address and display its contents. */
name|data
operator|=
name|em_read_phy_reg
argument_list|(
name|shared
argument_list|,
name|PHY_CTRL
argument_list|)
expr_stmt|;
name|DEBUGOUT1
argument_list|(
literal|"MII Ctrl Reg contents = %x\n"
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|data
operator|=
name|em_read_phy_reg
argument_list|(
name|shared
argument_list|,
name|PHY_STATUS
argument_list|)
expr_stmt|;
name|data
operator|=
name|em_read_phy_reg
argument_list|(
name|shared
argument_list|,
name|PHY_STATUS
argument_list|)
expr_stmt|;
name|DEBUGOUT1
argument_list|(
literal|"MII Status Reg contents = %x\n"
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|phy_id_high
operator|=
name|em_read_phy_reg
argument_list|(
name|shared
argument_list|,
name|PHY_ID1
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|phy_id_low
operator|=
name|em_read_phy_reg
argument_list|(
name|shared
argument_list|,
name|PHY_ID2
argument_list|)
expr_stmt|;
name|phy_id
operator|=
operator|(
name|phy_id_low
operator||
operator|(
name|phy_id_high
operator|<<
literal|16
operator|)
operator|)
operator|&
name|PHY_REVISION_MASK
expr_stmt|;
name|DEBUGOUT1
argument_list|(
literal|"Phy ID = %x \n"
argument_list|,
name|phy_id
argument_list|)
expr_stmt|;
name|data
operator|=
name|em_read_phy_reg
argument_list|(
name|shared
argument_list|,
name|PHY_AUTONEG_ADV
argument_list|)
expr_stmt|;
name|DEBUGOUT1
argument_list|(
literal|"Reg 4 contents = %x\n"
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|data
operator|=
name|em_read_phy_reg
argument_list|(
name|shared
argument_list|,
name|PHY_LP_ABILITY
argument_list|)
expr_stmt|;
name|DEBUGOUT1
argument_list|(
literal|"Reg 5 contents = %x\n"
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|data
operator|=
name|em_read_phy_reg
argument_list|(
name|shared
argument_list|,
name|PHY_AUTONEG_EXP
argument_list|)
expr_stmt|;
name|DEBUGOUT1
argument_list|(
literal|"Reg 6 contents = %x\n"
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|data
operator|=
name|em_read_phy_reg
argument_list|(
name|shared
argument_list|,
name|PHY_NEXT_PAGE_TX
argument_list|)
expr_stmt|;
name|DEBUGOUT1
argument_list|(
literal|"Reg 7 contents = %x\n"
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|data
operator|=
name|em_read_phy_reg
argument_list|(
name|shared
argument_list|,
name|PHY_LP_NEXT_PAGE
argument_list|)
expr_stmt|;
name|DEBUGOUT1
argument_list|(
literal|"Reg 8 contents = %x\n"
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|data
operator|=
name|em_read_phy_reg
argument_list|(
name|shared
argument_list|,
name|PHY_1000T_CTRL
argument_list|)
expr_stmt|;
name|DEBUGOUT1
argument_list|(
literal|"Reg 9 contents = %x\n"
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|data
operator|=
name|em_read_phy_reg
argument_list|(
name|shared
argument_list|,
name|PHY_1000T_STATUS
argument_list|)
expr_stmt|;
name|DEBUGOUT1
argument_list|(
literal|"Reg A contents = %x\n"
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|data
operator|=
name|em_read_phy_reg
argument_list|(
name|shared
argument_list|,
name|PHY_EXT_STATUS
argument_list|)
expr_stmt|;
name|DEBUGOUT1
argument_list|(
literal|"Reg F contents = %x\n"
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|data
operator|=
name|em_read_phy_reg
argument_list|(
name|shared
argument_list|,
name|M88E1000_PHY_SPEC_CTRL
argument_list|)
expr_stmt|;
name|DEBUGOUT1
argument_list|(
literal|"M88E1000 Specific Control Reg (0x10) = %x\n"
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|data
operator|=
name|em_read_phy_reg
argument_list|(
name|shared
argument_list|,
name|M88E1000_PHY_SPEC_STATUS
argument_list|)
expr_stmt|;
name|DEBUGOUT1
argument_list|(
literal|"M88E1000 Specific Status Reg (0x11) = %x\n"
argument_list|,
name|data
argument_list|)
expr_stmt|;
comment|/*      * data = em_read_phy_reg(shared, M88E1000_INT_ENABLE_REG);      * DEBUGOUT1("M88E1000 Interrupt Enable Reg (0x12) = %x\n", data);      */
comment|/*      * data = em_read_phy_reg(shared, M88E1000_INT_STATUS_REG);      * DEBUGOUT1("M88E1000 Interrupt Status Reg (0x13) = %x\n", data);      */
name|data
operator|=
name|em_read_phy_reg
argument_list|(
name|shared
argument_list|,
name|M88E1000_EXT_PHY_SPEC_CTRL
argument_list|)
expr_stmt|;
name|DEBUGOUT1
argument_list|(
literal|"M88E1000 Ext. Phy Specific Control (0x14) = %x\n"
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|data
operator|=
name|em_read_phy_reg
argument_list|(
name|shared
argument_list|,
name|M88E1000_RX_ERR_CNTR
argument_list|)
expr_stmt|;
name|DEBUGOUT1
argument_list|(
literal|"M88E1000 Receive Error Counter (0x15) = %x\n"
argument_list|,
name|data
argument_list|)
expr_stmt|;
comment|/*      * data = em_read_phy_reg(shared, M88E1000_LED_CTRL_REG);      * DEBUGOUT1("M88E1000 LED control reg (0x18) = %x\n", data);      */
return|return;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// DBG
end_comment

begin_comment
comment|/****************************************************************************** * Probes the expected PHY address for known PHY IDs * * shared - Struct containing variables accessed by shared code ******************************************************************************/
end_comment

begin_function
name|boolean_t
name|em_detect_gig_phy
parameter_list|(
name|struct
name|em_shared_adapter
modifier|*
name|shared
parameter_list|)
block|{
name|uint32_t
name|phy_id_high
decl_stmt|;
name|uint16_t
name|phy_id_low
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_detect_gig_phy"
argument_list|)
expr_stmt|;
comment|/* Read the PHY ID Registers to identify which PHY is onboard. */
name|shared
operator|->
name|phy_addr
operator|=
literal|1
expr_stmt|;
name|phy_id_high
operator|=
name|em_read_phy_reg
argument_list|(
name|shared
argument_list|,
name|PHY_ID1
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|phy_id_low
operator|=
name|em_read_phy_reg
argument_list|(
name|shared
argument_list|,
name|PHY_ID2
argument_list|)
expr_stmt|;
name|shared
operator|->
name|phy_id
operator|=
operator|(
name|phy_id_low
operator||
operator|(
name|phy_id_high
operator|<<
literal|16
operator|)
operator|)
operator|&
name|PHY_REVISION_MASK
expr_stmt|;
if|if
condition|(
name|shared
operator|->
name|phy_id
operator|==
name|M88E1000_12_PHY_ID
operator|||
name|shared
operator|->
name|phy_id
operator|==
name|M88E1000_14_PHY_ID
operator|||
name|shared
operator|->
name|phy_id
operator|==
name|M88E1000_I_PHY_ID
operator|||
name|shared
operator|->
name|phy_id
operator|==
name|M88E1011_I_PHY_ID
condition|)
block|{
name|DEBUGOUT2
argument_list|(
literal|"phy_id 0x%x detected at address 0x%x\n"
argument_list|,
name|shared
operator|->
name|phy_id
argument_list|,
name|shared
operator|->
name|phy_addr
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
else|else
block|{
name|DEBUGOUT
argument_list|(
literal|"Could not auto-detect Phy!\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/****************************************************************************** * Resets the PHY's DSP * * shared - Struct containing variables accessed by shared code ******************************************************************************/
end_comment

begin_function
name|void
name|em_phy_reset_dsp
parameter_list|(
name|struct
name|em_shared_adapter
modifier|*
name|shared
parameter_list|)
block|{
name|em_write_phy_reg
argument_list|(
name|shared
argument_list|,
literal|29
argument_list|,
literal|0x1d
argument_list|)
expr_stmt|;
name|em_write_phy_reg
argument_list|(
name|shared
argument_list|,
literal|30
argument_list|,
literal|0xc1
argument_list|)
expr_stmt|;
name|em_write_phy_reg
argument_list|(
name|shared
argument_list|,
literal|30
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/****************************************************************************** * Blocks until autoneg completes or times out (~4.5 seconds) * * shared - Struct containing variables accessed by shared code ******************************************************************************/
end_comment

begin_function
name|boolean_t
name|em_wait_autoneg
parameter_list|(
name|struct
name|em_shared_adapter
modifier|*
name|shared
parameter_list|)
block|{
name|uint16_t
name|i
decl_stmt|;
name|uint16_t
name|mii_status_reg
decl_stmt|;
name|boolean_t
name|autoneg_complete
init|=
name|FALSE
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"em_wait_autoneg"
argument_list|)
expr_stmt|;
comment|/* We will wait for autoneg to complete. */
name|DEBUGOUT
argument_list|(
literal|"Waiting for Auto-Neg to complete.\n"
argument_list|)
expr_stmt|;
name|mii_status_reg
operator|=
literal|0
expr_stmt|;
comment|/* We will wait for autoneg to complete or 4.5 seconds to expire. */
for|for
control|(
name|i
operator|=
name|PHY_AUTO_NEG_TIME
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
comment|/* Read the MII Status Register and wait for Auto-Neg          * Complete bit to be set.          */
name|mii_status_reg
operator|=
name|em_read_phy_reg
argument_list|(
name|shared
argument_list|,
name|PHY_STATUS
argument_list|)
expr_stmt|;
name|mii_status_reg
operator|=
name|em_read_phy_reg
argument_list|(
name|shared
argument_list|,
name|PHY_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
name|mii_status_reg
operator|&
name|MII_SR_AUTONEG_COMPLETE
condition|)
block|{
name|autoneg_complete
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
name|msec_delay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|autoneg_complete
operator|)
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************** * Get PHY information from various PHY registers * * shared - Struct containing variables accessed by shared code * phy_status_info - PHY information structure ******************************************************************************/
end_comment

begin_function
name|boolean_t
name|em_phy_get_info
parameter_list|(
name|struct
name|em_shared_adapter
modifier|*
name|shared
parameter_list|,
name|struct
name|em_phy_info
modifier|*
name|phy_status_info
parameter_list|)
block|{
name|uint16_t
name|phy_mii_status_reg
decl_stmt|;
name|uint16_t
name|phy_specific_ctrl_reg
decl_stmt|;
name|uint16_t
name|phy_specific_status_reg
decl_stmt|;
name|uint16_t
name|phy_specific_ext_ctrl_reg
decl_stmt|;
name|uint16_t
name|phy_1000t_stat_reg
decl_stmt|;
name|phy_status_info
operator|->
name|cable_length
operator|=
name|em_cable_length_undefined
expr_stmt|;
name|phy_status_info
operator|->
name|extended_10bt_distance
operator|=
name|em_10bt_ext_dist_enable_undefined
expr_stmt|;
name|phy_status_info
operator|->
name|cable_polarity
operator|=
name|em_rev_polarity_undefined
expr_stmt|;
name|phy_status_info
operator|->
name|polarity_correction
operator|=
name|em_polarity_reversal_undefined
expr_stmt|;
name|phy_status_info
operator|->
name|link_reset
operator|=
name|em_down_no_idle_undefined
expr_stmt|;
name|phy_status_info
operator|->
name|mdix_mode
operator|=
name|em_auto_x_mode_undefined
expr_stmt|;
name|phy_status_info
operator|->
name|local_rx
operator|=
name|em_1000t_rx_status_undefined
expr_stmt|;
name|phy_status_info
operator|->
name|remote_rx
operator|=
name|em_1000t_rx_status_undefined
expr_stmt|;
comment|/* PHY info only valid for copper media. */
if|if
condition|(
name|shared
operator|==
name|NULL
operator|||
name|shared
operator|->
name|media_type
operator|!=
name|em_media_type_copper
condition|)
return|return
name|FALSE
return|;
comment|/* PHY info only valid for LINK UP.  Read MII status reg       * back-to-back to get link status.      */
name|phy_mii_status_reg
operator|=
name|em_read_phy_reg
argument_list|(
name|shared
argument_list|,
name|PHY_STATUS
argument_list|)
expr_stmt|;
name|phy_mii_status_reg
operator|=
name|em_read_phy_reg
argument_list|(
name|shared
argument_list|,
name|PHY_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|phy_mii_status_reg
operator|&
name|MII_SR_LINK_STATUS
operator|)
operator|!=
name|MII_SR_LINK_STATUS
condition|)
return|return
name|FALSE
return|;
comment|/* Read various PHY registers to get the PHY info. */
name|phy_specific_ctrl_reg
operator|=
name|em_read_phy_reg
argument_list|(
name|shared
argument_list|,
name|M88E1000_PHY_SPEC_CTRL
argument_list|)
expr_stmt|;
name|phy_specific_status_reg
operator|=
name|em_read_phy_reg
argument_list|(
name|shared
argument_list|,
name|M88E1000_PHY_SPEC_STATUS
argument_list|)
expr_stmt|;
name|phy_specific_ext_ctrl_reg
operator|=
name|em_read_phy_reg
argument_list|(
name|shared
argument_list|,
name|M88E1000_EXT_PHY_SPEC_CTRL
argument_list|)
expr_stmt|;
name|phy_1000t_stat_reg
operator|=
name|em_read_phy_reg
argument_list|(
name|shared
argument_list|,
name|PHY_1000T_STATUS
argument_list|)
expr_stmt|;
name|phy_status_info
operator|->
name|cable_length
operator|=
operator|(
operator|(
name|phy_specific_status_reg
operator|&
name|M88E1000_PSSR_CABLE_LENGTH
operator|)
operator|>>
name|M88E1000_PSSR_CABLE_LENGTH_SHIFT
operator|)
expr_stmt|;
name|phy_status_info
operator|->
name|extended_10bt_distance
operator|=
operator|(
name|phy_specific_ctrl_reg
operator|&
name|M88E1000_PSCR_10BT_EXT_DIST_ENABLE
operator|)
operator|>>
name|M88E1000_PSCR_10BT_EXT_DIST_ENABLE_SHIFT
expr_stmt|;
name|phy_status_info
operator|->
name|cable_polarity
operator|=
operator|(
name|phy_specific_status_reg
operator|&
name|M88E1000_PSSR_REV_POLARITY
operator|)
operator|>>
name|M88E1000_PSSR_REV_POLARITY_SHIFT
expr_stmt|;
name|phy_status_info
operator|->
name|polarity_correction
operator|=
operator|(
name|phy_specific_ctrl_reg
operator|&
name|M88E1000_PSCR_POLARITY_REVERSAL
operator|)
operator|>>
name|M88E1000_PSCR_POLARITY_REVERSAL_SHIFT
expr_stmt|;
name|phy_status_info
operator|->
name|link_reset
operator|=
operator|(
name|phy_specific_ext_ctrl_reg
operator|&
name|M88E1000_EPSCR_DOWN_NO_IDLE
operator|)
operator|>>
name|M88E1000_EPSCR_DOWN_NO_IDLE_SHIFT
expr_stmt|;
name|phy_status_info
operator|->
name|mdix_mode
operator|=
operator|(
name|phy_specific_status_reg
operator|&
name|M88E1000_PSSR_MDIX
operator|)
operator|>>
name|M88E1000_PSSR_MDIX_SHIFT
expr_stmt|;
name|phy_status_info
operator|->
name|local_rx
operator|=
operator|(
name|phy_1000t_stat_reg
operator|&
name|SR_1000T_LOCAL_RX_STATUS
operator|)
operator|>>
name|SR_1000T_LOCAL_RX_STATUS_SHIFT
expr_stmt|;
name|phy_status_info
operator|->
name|remote_rx
operator|=
operator|(
name|phy_1000t_stat_reg
operator|&
name|SR_1000T_REMOTE_RX_STATUS
operator|)
operator|>>
name|SR_1000T_REMOTE_RX_STATUS_SHIFT
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|boolean_t
name|em_validate_mdi_setting
parameter_list|(
name|struct
name|em_shared_adapter
modifier|*
name|shared
parameter_list|)
block|{
if|if
condition|(
operator|!
name|shared
operator|->
name|autoneg
operator|&&
operator|(
name|shared
operator|->
name|mdix
operator|==
literal|0
operator|||
name|shared
operator|->
name|mdix
operator|==
literal|3
operator|)
condition|)
block|{
name|shared
operator|->
name|mdix
operator|=
literal|1
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

end_unit

