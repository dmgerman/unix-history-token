begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  *   BSD LICENSE  *  *   Copyright (c) 2016 Broadcom, All Rights Reserved.  *   The term Broadcom refers to Broadcom Limited and/or its subsidiaries  *  *   Redistribution and use in source and binary forms, with or without  *   modification, are permitted provided that the following conditions  *   are met:  *     * Redistributions of source code must retain the above copyright  *       notice, this list of conditions and the following disclaimer.  *     * Redistributions in binary form must reproduce the above copyright  *       notice, this list of conditions and the following disclaimer in  *       the documentation and/or other materials provided with the  *       distribution.  *  *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  *   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  *   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  *   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  *   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  *   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  *   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  *   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE  *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/****************************************************************************  *  * Description: Definition of HSI data structures  *  * Date:  08/31/17 17:55:46  *  * Note:  This file is scripted generated by hsi_decode.py.  *	DO NOT modify this file manually !!!!  *  ****************************************************************************/
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_HSI_STRUCT_DEF_EXTERNAL_H_
end_ifndef

begin_define
define|#
directive|define
name|_HSI_STRUCT_DEF_EXTERNAL_H_
end_define

begin_comment
comment|/* HSI and HWRM Specification 1.8.1 */
end_comment

begin_define
define|#
directive|define
name|HWRM_VERSION_MAJOR
value|1
end_define

begin_define
define|#
directive|define
name|HWRM_VERSION_MINOR
value|8
end_define

begin_define
define|#
directive|define
name|HWRM_VERSION_UPDATE
value|1
end_define

begin_define
define|#
directive|define
name|HWRM_VERSION_RSVD
value|7
end_define

begin_define
define|#
directive|define
name|HWRM_VERSION_STR
value|"1.8.1.7"
end_define

begin_comment
comment|/*  * Following is the signature for HWRM message field that indicates not  * applicable (All F's). Need to cast it the size of the field if needed.  */
end_comment

begin_define
define|#
directive|define
name|HWRM_NA_SIGNATURE
value|((uint32_t)(-1))
end_define

begin_define
define|#
directive|define
name|HWRM_MAX_REQ_LEN
value|(128)
end_define

begin_comment
comment|/* hwrm_func_buf_rgtr */
end_comment

begin_define
define|#
directive|define
name|HWRM_MAX_RESP_LEN
value|(272)
end_define

begin_comment
comment|/* hwrm_selftest_qlist */
end_comment

begin_define
define|#
directive|define
name|HW_HASH_INDEX_SIZE
value|0x80
end_define

begin_comment
comment|/* 7 bit indirection table index. */
end_comment

begin_define
define|#
directive|define
name|HW_HASH_KEY_SIZE
value|40
end_define

begin_define
define|#
directive|define
name|HWRM_RESP_VALID_KEY
value|1
end_define

begin_comment
comment|/* valid key for HWRM response */
end_comment

begin_define
define|#
directive|define
name|ROCE_SP_HSI_VERSION_MAJOR
value|1
end_define

begin_define
define|#
directive|define
name|ROCE_SP_HSI_VERSION_MINOR
value|8
end_define

begin_define
define|#
directive|define
name|ROCE_SP_HSI_VERSION_UPDATE
value|1
end_define

begin_define
define|#
directive|define
name|ROCE_SP_HSI_VERSION_STR
value|"1.8.1"
end_define

begin_comment
comment|/*  * Following is the signature for ROCE_SP_HSI message field that indicates not  * applicable (All F's). Need to cast it the size of the field if needed.  */
end_comment

begin_define
define|#
directive|define
name|ROCE_SP_HSI_NA_SIGNATURE
value|((uint32_t)(-1))
end_define

begin_comment
comment|/*  * Note: The Host Software Interface (HSI) and Hardware Resource Manager (HWRM)  * specification describes the data structures used in Ethernet packet or RDMA  * message data transfers as well as an abstract interface for managing Ethernet  * NIC hardware resources.  */
end_comment

begin_comment
comment|/* Ethernet Data path Host Structures */
end_comment

begin_comment
comment|/*  * Description: The following three sections document the host structures used  * between device and software drivers for communicating Ethernet packets.  */
end_comment

begin_comment
comment|/* BD Ring Structures */
end_comment

begin_comment
comment|/*  * Description: This structure is used to inform the NIC of a location for and  * an aggregation buffer that will be used for packet data that is received. An  * aggregation buffer creates a different kind of completion operation for a  * packet where a variable number of BDs may be used to place the packet in the  * host. RX Rings that have aggregation buffers are known as aggregation rings  * and must contain only aggregation buffers.  */
end_comment

begin_comment
comment|/*  * Note: BD Ring structures are written by the driver to TX Rings and RX Rings  * to indicate to the chip there is more buffer space in the host that needs to  * be transmitted or is available for receive data.  */
end_comment

begin_comment
comment|/* BD Base (8 bytes) */
end_comment

begin_struct
struct|struct
name|bd_base
block|{
name|uint8_t
name|type
decl_stmt|;
comment|/* This value identifies the type of buffer descriptor. */
define|#
directive|define
name|BD_BASE_TYPE_MASK
value|UINT32_C(0x3f)
define|#
directive|define
name|BD_BASE_TYPE_SFT
value|0
comment|/* 	 * Indicates that this BD is 16B long and is used for normal L2 	 * packet transmission. 	 */
define|#
directive|define
name|BD_BASE_TYPE_TX_BD_SHORT
value|UINT32_C(0x0)
comment|/* 	 * Indicates that this BD is 1BB long and is an empty TX BD. Not 	 * valid for use by the driver. 	 */
define|#
directive|define
name|BD_BASE_TYPE_TX_BD_EMPTY
value|UINT32_C(0x1)
comment|/* 	 * Indicates that this BD is 16B long and is an RX Producer (ie. 	 * empty) buffer descriptor. 	 */
define|#
directive|define
name|BD_BASE_TYPE_RX_PROD_PKT
value|UINT32_C(0x4)
comment|/* 	 * Indicates that this BD is 16B long and is an RX Producer 	 * Buffer BD. 	 */
define|#
directive|define
name|BD_BASE_TYPE_RX_PROD_BFR
value|UINT32_C(0x5)
comment|/* 	 * Indicates that this BD is 16B long and is an RX Producer 	 * Assembly Buffer Descriptor. 	 */
define|#
directive|define
name|BD_BASE_TYPE_RX_PROD_AGG
value|UINT32_C(0x6)
comment|/* 	 * Indicates that this BD is 32B long and is used for normal L2 	 * packet transmission. 	 */
define|#
directive|define
name|BD_BASE_TYPE_TX_BD_LONG
value|UINT32_C(0x10)
name|uint8_t
name|unused_1
index|[
literal|7
index|]
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Short TX BD (16 bytes) */
end_comment

begin_struct
struct|struct
name|tx_bd_short
block|{
name|uint16_t
name|flags_type
decl_stmt|;
comment|/* 	 * All bits in this field must be valid on the first BD of a packet. 	 * Only the packet_end bit must be valid for the remaining BDs of a 	 * packet. 	 */
comment|/* This value identifies the type of buffer descriptor. */
define|#
directive|define
name|TX_BD_SHORT_TYPE_MASK
value|UINT32_C(0x3f)
define|#
directive|define
name|TX_BD_SHORT_TYPE_SFT
value|0
comment|/* 	 * Indicates that this BD is 16B long and is used for normal L2 	 * packet transmission. 	 */
define|#
directive|define
name|TX_BD_SHORT_TYPE_TX_BD_SHORT
value|UINT32_C(0x0)
comment|/* 	 * If set to 1, the packet ends with the data in the buffer pointed to 	 * by this descriptor. This flag must be valid on every BD. 	 */
define|#
directive|define
name|TX_BD_SHORT_FLAGS_PACKET_END
value|UINT32_C(0x40)
comment|/* 	 * If set to 1, the device will not generate a completion for this 	 * transmit packet unless there is an error in it's processing. If this 	 * bit is set to 0, then the packet will be completed normally. This bit 	 * must be valid only on the first BD of a packet. 	 */
define|#
directive|define
name|TX_BD_SHORT_FLAGS_NO_CMPL
value|UINT32_C(0x80)
comment|/* 	 * This value indicates how many 16B BD locations are consumed in the 	 * ring by this packet. A value of 1 indicates that this BD is the only 	 * BD (and that the it is a short BD). A value of 3 indicates either 3 	 * short BDs or 1 long BD and one short BD in the packet. A value of 0 	 * indicates that there are 32 BD locations in the packet (the maximum). 	 * This field is valid only on the first BD of a packet. 	 */
define|#
directive|define
name|TX_BD_SHORT_FLAGS_BD_CNT_MASK
value|UINT32_C(0x1f00)
define|#
directive|define
name|TX_BD_SHORT_FLAGS_BD_CNT_SFT
value|8
comment|/* 	 * This value is a hint for the length of the entire packet. It is used 	 * by the chip to optimize internal processing. The packet will be 	 * dropped if the hint is too short. This field is valid only on the 	 * first BD of a packet. 	 */
define|#
directive|define
name|TX_BD_SHORT_FLAGS_LHINT_MASK
value|UINT32_C(0x6000)
define|#
directive|define
name|TX_BD_SHORT_FLAGS_LHINT_SFT
value|13
comment|/* indicates packet length< 512B */
define|#
directive|define
name|TX_BD_SHORT_FLAGS_LHINT_LT512
value|(UINT32_C(0x0)<< 13)
comment|/* indicates 512<= packet length< 1KB */
define|#
directive|define
name|TX_BD_SHORT_FLAGS_LHINT_LT1K
value|(UINT32_C(0x1)<< 13)
comment|/* indicates 1KB<= packet length< 2KB */
define|#
directive|define
name|TX_BD_SHORT_FLAGS_LHINT_LT2K
value|(UINT32_C(0x2)<< 13)
comment|/* indicates packet length>= 2KB */
define|#
directive|define
name|TX_BD_SHORT_FLAGS_LHINT_GTE2K
value|(UINT32_C(0x3)<< 13)
define|#
directive|define
name|TX_BD_SHORT_FLAGS_LHINT_LAST
value|TX_BD_SHORT_FLAGS_LHINT_GTE2K
comment|/* 	 * If set to 1, the device immediately updates the Send Consumer Index 	 * after the buffer associated with this descriptor has been transferred 	 * via DMA to NIC memory from host memory. An interrupt may or may not 	 * be generated according to the state of the interrupt avoidance 	 * mechanisms. If this bit is set to 0, then the Consumer Index is only 	 * updated as soon as one of the host interrupt coalescing conditions 	 * has been met. This bit must be valid on the first BD of a packet. 	 */
define|#
directive|define
name|TX_BD_SHORT_FLAGS_COAL_NOW
value|UINT32_C(0x8000)
comment|/* 	 * All bits in this field must be valid on the first BD of a packet. 	 * Only the packet_end bit must be valid for the remaining BDs of a 	 * packet. 	 */
define|#
directive|define
name|TX_BD_SHORT_FLAGS_MASK
value|UINT32_C(0xffc0)
define|#
directive|define
name|TX_BD_SHORT_FLAGS_SFT
value|6
name|uint16_t
name|len
decl_stmt|;
comment|/* 	 * This is the length of the host physical buffer this BD describes in 	 * bytes. This field must be valid on all BDs of a packet. 	 */
name|uint32_t
name|opaque
decl_stmt|;
comment|/* 	 * The opaque data field is pass through to the completion and can be 	 * used for any data that the driver wants to associate with the 	 * transmit BD. This field must be valid on the first BD of a packet. 	 */
name|uint64_t
name|addr
decl_stmt|;
comment|/* 	 * This is the host physical address for the portion of the packet 	 * described by this TX BD. This value must be valid on all BDs of a 	 * packet. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Long TX BD (32 bytes split to 2 16-byte struct) */
end_comment

begin_struct
struct|struct
name|tx_bd_long
block|{
name|uint16_t
name|flags_type
decl_stmt|;
comment|/* 	 * All bits in this field must be valid on the first BD of a packet. 	 * Only the packet_end bit must be valid for the remaining BDs of a 	 * packet. 	 */
comment|/* This value identifies the type of buffer descriptor. */
define|#
directive|define
name|TX_BD_LONG_TYPE_MASK
value|UINT32_C(0x3f)
define|#
directive|define
name|TX_BD_LONG_TYPE_SFT
value|0
comment|/* 	 * Indicates that this BD is 32B long and is used for normal L2 	 * packet transmission. 	 */
define|#
directive|define
name|TX_BD_LONG_TYPE_TX_BD_LONG
value|UINT32_C(0x10)
comment|/* 	 * If set to 1, the packet ends with the data in the buffer pointed to 	 * by this descriptor. This flag must be valid on every BD. 	 */
define|#
directive|define
name|TX_BD_LONG_FLAGS_PACKET_END
value|UINT32_C(0x40)
comment|/* 	 * If set to 1, the device will not generate a completion for this 	 * transmit packet unless there is an error in it's processing. If this 	 * bit is set to 0, then the packet will be completed normally. This bit 	 * must be valid only on the first BD of a packet. 	 */
define|#
directive|define
name|TX_BD_LONG_FLAGS_NO_CMPL
value|UINT32_C(0x80)
comment|/* 	 * This value indicates how many 16B BD locations are consumed in the 	 * ring by this packet. A value of 1 indicates that this BD is the only 	 * BD (and that the it is a short BD). A value of 3 indicates either 3 	 * short BDs or 1 long BD and one short BD in the packet. A value of 0 	 * indicates that there are 32 BD locations in the packet (the maximum). 	 * This field is valid only on the first BD of a packet. 	 */
define|#
directive|define
name|TX_BD_LONG_FLAGS_BD_CNT_MASK
value|UINT32_C(0x1f00)
define|#
directive|define
name|TX_BD_LONG_FLAGS_BD_CNT_SFT
value|8
comment|/* 	 * This value is a hint for the length of the entire packet. It is used 	 * by the chip to optimize internal processing. The packet will be 	 * dropped if the hint is too short. This field is valid only on the 	 * first BD of a packet. 	 */
define|#
directive|define
name|TX_BD_LONG_FLAGS_LHINT_MASK
value|UINT32_C(0x6000)
define|#
directive|define
name|TX_BD_LONG_FLAGS_LHINT_SFT
value|13
comment|/* indicates packet length< 512B */
define|#
directive|define
name|TX_BD_LONG_FLAGS_LHINT_LT512
value|(UINT32_C(0x0)<< 13)
comment|/* indicates 512<= packet length< 1KB */
define|#
directive|define
name|TX_BD_LONG_FLAGS_LHINT_LT1K
value|(UINT32_C(0x1)<< 13)
comment|/* indicates 1KB<= packet length< 2KB */
define|#
directive|define
name|TX_BD_LONG_FLAGS_LHINT_LT2K
value|(UINT32_C(0x2)<< 13)
comment|/* indicates packet length>= 2KB */
define|#
directive|define
name|TX_BD_LONG_FLAGS_LHINT_GTE2K
value|(UINT32_C(0x3)<< 13)
define|#
directive|define
name|TX_BD_LONG_FLAGS_LHINT_LAST
value|TX_BD_LONG_FLAGS_LHINT_GTE2K
comment|/* 	 * If set to 1, the device immediately updates the Send Consumer Index 	 * after the buffer associated with this descriptor has been transferred 	 * via DMA to NIC memory from host memory. An interrupt may or may not 	 * be generated according to the state of the interrupt avoidance 	 * mechanisms. If this bit is set to 0, then the Consumer Index is only 	 * updated as soon as one of the host interrupt coalescing conditions 	 * has been met. This bit must be valid on the first BD of a packet. 	 */
define|#
directive|define
name|TX_BD_LONG_FLAGS_COAL_NOW
value|UINT32_C(0x8000)
comment|/* 	 * All bits in this field must be valid on the first BD of a packet. 	 * Only the packet_end bit must be valid for the remaining BDs of a 	 * packet. 	 */
define|#
directive|define
name|TX_BD_LONG_FLAGS_MASK
value|UINT32_C(0xffc0)
define|#
directive|define
name|TX_BD_LONG_FLAGS_SFT
value|6
name|uint16_t
name|len
decl_stmt|;
comment|/* 	 * This is the length of the host physical buffer this BD describes in 	 * bytes. This field must be valid on all BDs of a packet. 	 */
name|uint32_t
name|opaque
decl_stmt|;
comment|/* 	 * The opaque data field is pass through to the completion and can be 	 * used for any data that the driver wants to associate with the 	 * transmit BD. This field must be valid on the first BD of a packet. 	 */
name|uint64_t
name|addr
decl_stmt|;
comment|/* 	 * This is the host physical address for the portion of the packet 	 * described by this TX BD. This value must be valid on all BDs of a 	 * packet. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* last 16 bytes of Long TX BD */
end_comment

begin_struct
struct|struct
name|tx_bd_long_hi
block|{
name|uint16_t
name|lflags
decl_stmt|;
comment|/* 	 * All bits in this field must be valid on the first BD of a packet. 	 * Their value on other BDs of the packet will be ignored. 	 */
comment|/* 	 * If set to 1, the controller replaces the TCP/UPD checksum fields of 	 * normal TCP/UPD checksum, or the inner TCP/UDP checksum field of the 	 * encapsulated TCP/UDP packets with the hardware calculated TCP/UDP 	 * checksum for the packet associated with this descriptor. The flag is 	 * ignored if the LSO flag is set. This bit must be valid on the first 	 * BD of a packet. 	 */
define|#
directive|define
name|TX_BD_LONG_LFLAGS_TCP_UDP_CHKSUM
value|UINT32_C(0x1)
comment|/* 	 * If set to 1, the controller replaces the IP checksum of the normal 	 * packets, or the inner IP checksum of the encapsulated packets with 	 * the hardware calculated IP checksum for the packet associated with 	 * this descriptor. This bit must be valid on the first BD of a packet. 	 */
define|#
directive|define
name|TX_BD_LONG_LFLAGS_IP_CHKSUM
value|UINT32_C(0x2)
comment|/* 	 * If set to 1, the controller will not append an Ethernet CRC to the 	 * end of the frame. This bit must be valid on the first BD of a packet. 	 * Packet must be 64B or longer when this flag is set. It is not useful 	 * to use this bit with any form of TX offload such as CSO or LSO. The 	 * intent is that the packet from the host already has a valid Ethernet 	 * CRC on the packet. 	 */
define|#
directive|define
name|TX_BD_LONG_LFLAGS_NOCRC
value|UINT32_C(0x4)
comment|/* 	 * If set to 1, the device will record the time at which the packet was 	 * actually transmitted at the TX MAC. This bit must be valid on the 	 * first BD of a packet. 	 */
define|#
directive|define
name|TX_BD_LONG_LFLAGS_STAMP
value|UINT32_C(0x8)
comment|/* 	 * If set to 1, The controller replaces the tunnel IP checksum field 	 * with hardware calculated IP checksum for the IP header of the packet 	 * associated with this descriptor. For outer UDP checksum, global outer 	 * UDP checksum TE_NIC register needs to be enabled. If the global outer 	 * UDP checksum TE_NIC register bit is set, outer UDP checksum will be 	 * calculated for the following cases: 1. Packets with tcp_udp_chksum 	 * flag set to offload checksum for inner packet AND the inner packet is 	 * TCP/UDP. If the inner packet is ICMP for example (non-TCP/UDP), even 	 * if the tcp_udp_chksum is set, the outer UDP checksum will not be 	 * calculated. 2. Packets with lso flag set which implies inner TCP 	 * checksum calculation as part of LSO operation. 	 */
define|#
directive|define
name|TX_BD_LONG_LFLAGS_T_IP_CHKSUM
value|UINT32_C(0x10)
comment|/* 	 * If set to 1, the device will treat this packet with LSO(Large Send 	 * Offload) processing for both normal or encapsulated packets, which is 	 * a form of TCP segmentation. When this bit is 1, the hdr_size and mss 	 * fields must be valid. The driver doesn't need to set t_ip_chksum, 	 * ip_chksum, and tcp_udp_chksum flags since the controller will replace 	 * the appropriate checksum fields for segmented packets. When this bit 	 * is 1, the hdr_size and mss fields must be valid. 	 */
define|#
directive|define
name|TX_BD_LONG_LFLAGS_LSO
value|UINT32_C(0x20)
comment|/* 	 * If set to zero when LSO is '1', then the IPID will be treated as a 	 * 16b number and will be wrapped if it exceeds a value of 0xffff. If 	 * set to one when LSO is '1', then the IPID will be treated as a 15b 	 * number and will be wrapped if it exceeds a value 0f 0x7fff. 	 */
define|#
directive|define
name|TX_BD_LONG_LFLAGS_IPID_FMT
value|UINT32_C(0x40)
comment|/* 	 * If set to zero when LSO is '1', then the IPID of the tunnel IP header 	 * will not be modified during LSO operations. If set to one when LSO is 	 * '1', then the IPID of the tunnel IP header will be incremented for 	 * each subsequent segment of an LSO operation. The flag is ignored if 	 * the LSO packet is a normal (non-tunneled) TCP packet. 	 */
define|#
directive|define
name|TX_BD_LONG_LFLAGS_T_IPID
value|UINT32_C(0x80)
comment|/* 	 * If set to '1', then the RoCE ICRC will be appended to the packet. 	 * Packet must be a valid RoCE format packet. 	 */
define|#
directive|define
name|TX_BD_LONG_LFLAGS_ROCE_CRC
value|UINT32_C(0x100)
comment|/* 	 * If set to '1', then the FCoE CRC will be appended to the packet. 	 * Packet must be a valid FCoE format packet. 	 */
define|#
directive|define
name|TX_BD_LONG_LFLAGS_FCOE_CRC
value|UINT32_C(0x200)
name|uint16_t
name|hdr_size
decl_stmt|;
comment|/* 	 * When LSO is '1', this field must contain the offset of the TCP 	 * payload from the beginning of the packet in as 16b words. In case of 	 * encapsulated/tunneling packet, this field contains the offset of the 	 * inner TCP payload from beginning of the packet as 16-bit words. This 	 * value must be valid on the first BD of a packet. 	 */
define|#
directive|define
name|TX_BD_LONG_HDR_SIZE_MASK
value|UINT32_C(0x1ff)
define|#
directive|define
name|TX_BD_LONG_HDR_SIZE_SFT
value|0
name|uint32_t
name|mss
decl_stmt|;
comment|/* 	 * This is the MSS value that will be used to do the LSO processing. The 	 * value is the length in bytes of the TCP payload for each segment 	 * generated by the LSO operation. This value must be valid on the first 	 * BD of a packet. 	 */
define|#
directive|define
name|TX_BD_LONG_MSS_MASK
value|UINT32_C(0x7fff)
define|#
directive|define
name|TX_BD_LONG_MSS_SFT
value|0
name|uint16_t
name|unused_2
decl_stmt|;
name|uint16_t
name|cfa_action
decl_stmt|;
comment|/* 	 * This value selects a CFA action to perform on the packet. Set this 	 * value to zero if no CFA action is desired. This value must be valid 	 * on the first BD of a packet. 	 */
name|uint32_t
name|cfa_meta
decl_stmt|;
comment|/* 	 * This value is action meta-data that defines CFA edit operations that 	 * are done in addition to any action editing. 	 */
comment|/* When key=1, This is the VLAN tag VID value. */
define|#
directive|define
name|TX_BD_LONG_CFA_META_VLAN_VID_MASK
value|UINT32_C(0xfff)
define|#
directive|define
name|TX_BD_LONG_CFA_META_VLAN_VID_SFT
value|0
comment|/* When key=1, This is the VLAN tag DE value. */
define|#
directive|define
name|TX_BD_LONG_CFA_META_VLAN_DE
value|UINT32_C(0x1000)
comment|/* When key=1, This is the VLAN tag PRI value. */
define|#
directive|define
name|TX_BD_LONG_CFA_META_VLAN_PRI_MASK
value|UINT32_C(0xe000)
define|#
directive|define
name|TX_BD_LONG_CFA_META_VLAN_PRI_SFT
value|13
comment|/* When key=1, This is the VLAN tag TPID select value. */
define|#
directive|define
name|TX_BD_LONG_CFA_META_VLAN_TPID_MASK
value|UINT32_C(0x70000)
define|#
directive|define
name|TX_BD_LONG_CFA_META_VLAN_TPID_SFT
value|16
comment|/* 0x88a8 */
define|#
directive|define
name|TX_BD_LONG_CFA_META_VLAN_TPID_TPID88A8
value|(UINT32_C(0x0)<< 16)
comment|/* 0x8100 */
define|#
directive|define
name|TX_BD_LONG_CFA_META_VLAN_TPID_TPID8100
value|(UINT32_C(0x1)<< 16)
comment|/* 0x9100 */
define|#
directive|define
name|TX_BD_LONG_CFA_META_VLAN_TPID_TPID9100
value|(UINT32_C(0x2)<< 16)
comment|/* 0x9200 */
define|#
directive|define
name|TX_BD_LONG_CFA_META_VLAN_TPID_TPID9200
value|(UINT32_C(0x3)<< 16)
comment|/* 0x9300 */
define|#
directive|define
name|TX_BD_LONG_CFA_META_VLAN_TPID_TPID9300
value|(UINT32_C(0x4)<< 16)
comment|/* Value programmed in CFA VLANTPID register. */
define|#
directive|define
name|TX_BD_LONG_CFA_META_VLAN_TPID_TPIDCFG
value|(UINT32_C(0x5)<< 16)
define|#
directive|define
name|TX_BD_LONG_CFA_META_VLAN_TPID_LAST
value|TX_BD_LONG_CFA_META_VLAN_TPID_TPIDCFG
comment|/* When key=1, This is the VLAN tag TPID select value. */
define|#
directive|define
name|TX_BD_LONG_CFA_META_VLAN_RESERVED_MASK
value|UINT32_C(0xff80000)
define|#
directive|define
name|TX_BD_LONG_CFA_META_VLAN_RESERVED_SFT
value|19
comment|/* 	 * This field identifies the type of edit to be performed on the packet. 	 * This value must be valid on the first BD of a packet. 	 */
define|#
directive|define
name|TX_BD_LONG_CFA_META_KEY_MASK
value|UINT32_C(0xf0000000)
define|#
directive|define
name|TX_BD_LONG_CFA_META_KEY_SFT
value|28
comment|/* No editing */
define|#
directive|define
name|TX_BD_LONG_CFA_META_KEY_NONE
value|(UINT32_C(0x0)<< 28)
comment|/* 	 * - meta[17:16] - TPID select value (0 = 0x8100). - meta[15:12] 	 * - PRI/DE value. - meta[11:0] - VID value. 	 */
define|#
directive|define
name|TX_BD_LONG_CFA_META_KEY_VLAN_TAG
value|(UINT32_C(0x1)<< 28)
define|#
directive|define
name|TX_BD_LONG_CFA_META_KEY_LAST
value|TX_BD_LONG_CFA_META_KEY_VLAN_TAG
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Empty TX BD (16 bytes) */
end_comment

begin_struct
struct|struct
name|tx_bd_empty
block|{
name|uint8_t
name|type
decl_stmt|;
comment|/* This value identifies the type of buffer descriptor. */
define|#
directive|define
name|TX_BD_EMPTY_TYPE_MASK
value|UINT32_C(0x3f)
define|#
directive|define
name|TX_BD_EMPTY_TYPE_SFT
value|0
comment|/* 	 * Indicates that this BD is 1BB long and is an empty TX BD. Not 	 * valid for use by the driver. 	 */
define|#
directive|define
name|TX_BD_EMPTY_TYPE_TX_BD_EMPTY
value|UINT32_C(0x1)
name|uint8_t
name|unused_1
index|[
literal|3
index|]
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
index|[
literal|3
index|]
decl_stmt|;
name|uint64_t
name|unused_4
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* RX Producer Packet BD (16 bytes) */
end_comment

begin_struct
struct|struct
name|rx_prod_pkt_bd
block|{
name|uint16_t
name|flags_type
decl_stmt|;
comment|/* This value identifies the type of buffer descriptor. */
define|#
directive|define
name|RX_PROD_PKT_BD_TYPE_MASK
value|UINT32_C(0x3f)
define|#
directive|define
name|RX_PROD_PKT_BD_TYPE_SFT
value|0
comment|/* 	 * Indicates that this BD is 16B long and is an RX Producer (ie. 	 * empty) buffer descriptor. 	 */
define|#
directive|define
name|RX_PROD_PKT_BD_TYPE_RX_PROD_PKT
value|UINT32_C(0x4)
comment|/* 	 * If set to 1, the packet will be placed at the address plus 2B. The 2 	 * Bytes of padding will be written as zero. 	 */
comment|/* 	 * This is intended to be used when the host buffer is cache-line 	 * aligned to produce packets that are easy to parse in host memory 	 * while still allowing writes to be cache line aligned. 	 */
define|#
directive|define
name|RX_PROD_PKT_BD_FLAGS_SOP_PAD
value|UINT32_C(0x40)
comment|/* 	 * If set to 1, the packet write will be padded out to the nearest 	 * cache-line with zero value padding. 	 */
comment|/* 	 * If receive buffers start/end on cache-line boundaries, this feature 	 * will ensure that all data writes on the PCI bus start/end on cache 	 * line boundaries. 	 */
define|#
directive|define
name|RX_PROD_PKT_BD_FLAGS_EOP_PAD
value|UINT32_C(0x80)
comment|/* 	 * This value is the number of additional buffers in the ring that 	 * describe the buffer space to be consumed for the this packet. If the 	 * value is zero, then the packet must fit within the space described by 	 * this BD. If this value is 1 or more, it indicates how many additional 	 * "buffer" BDs are in the ring immediately following this BD to be used 	 * for the same network packet. Even if the packet to be placed does not 	 * need all the additional buffers, they will be consumed anyway. 	 */
define|#
directive|define
name|RX_PROD_PKT_BD_FLAGS_BUFFERS_MASK
value|UINT32_C(0x300)
define|#
directive|define
name|RX_PROD_PKT_BD_FLAGS_BUFFERS_SFT
value|8
define|#
directive|define
name|RX_PROD_PKT_BD_FLAGS_MASK
value|UINT32_C(0xffc0)
define|#
directive|define
name|RX_PROD_PKT_BD_FLAGS_SFT
value|6
name|uint16_t
name|len
decl_stmt|;
comment|/* 	 * This is the length in Bytes of the host physical buffer where data 	 * for the packet may be placed in host memory. 	 */
comment|/* 	 * While this is a Byte resolution value, it is often advantageous to 	 * ensure that the buffers provided end on a host cache line. 	 */
name|uint32_t
name|opaque
decl_stmt|;
comment|/* 	 * The opaque data field is pass through to the completion and can be 	 * used for any data that the driver wants to associate with this 	 * receive buffer set. 	 */
name|uint64_t
name|addr
decl_stmt|;
comment|/* 	 * This is the host physical address where data for the packet may by 	 * placed in host memory. 	 */
comment|/* 	 * While this is a Byte resolution value, it is often advantageous to 	 * ensure that the buffers provide start on a host cache line. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* RX Producer Buffer BD (16 bytes) */
end_comment

begin_struct
struct|struct
name|rx_prod_bfr_bd
block|{
name|uint16_t
name|flags_type
decl_stmt|;
comment|/* This value identifies the type of buffer descriptor. */
define|#
directive|define
name|RX_PROD_BFR_BD_TYPE_MASK
value|UINT32_C(0x3f)
define|#
directive|define
name|RX_PROD_BFR_BD_TYPE_SFT
value|0
comment|/* 	 * Indicates that this BD is 16B long and is an RX Producer 	 * Buffer BD. 	 */
define|#
directive|define
name|RX_PROD_BFR_BD_TYPE_RX_PROD_BFR
value|UINT32_C(0x5)
define|#
directive|define
name|RX_PROD_BFR_BD_FLAGS_MASK
value|UINT32_C(0xffc0)
define|#
directive|define
name|RX_PROD_BFR_BD_FLAGS_SFT
value|6
name|uint16_t
name|len
decl_stmt|;
comment|/* 	 * This is the length in Bytes of the host physical buffer where data 	 * for the packet may be placed in host memory. 	 */
comment|/* 	 * While this is a Byte resolution value, it is often advantageous to 	 * ensure that the buffers provided end on a host cache line. 	 */
name|uint32_t
name|opaque
decl_stmt|;
comment|/* This field is not used. */
name|uint64_t
name|addr
decl_stmt|;
comment|/* 	 * This is the host physical address where data for the packet may by 	 * placed in host memory. 	 */
comment|/* 	 * While this is a Byte resolution value, it is often advantageous to 	 * ensure that the buffers provide start on a host cache line. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* RX Producer Aggregation BD (16 bytes) */
end_comment

begin_struct
struct|struct
name|rx_prod_agg_bd
block|{
name|uint16_t
name|flags_type
decl_stmt|;
comment|/* This value identifies the type of buffer descriptor. */
define|#
directive|define
name|RX_PROD_AGG_BD_TYPE_MASK
value|UINT32_C(0x3f)
define|#
directive|define
name|RX_PROD_AGG_BD_TYPE_SFT
value|0
comment|/* 	 * Indicates that this BD is 16B long and is an RX Producer 	 * Assembly Buffer Descriptor. 	 */
define|#
directive|define
name|RX_PROD_AGG_BD_TYPE_RX_PROD_AGG
value|UINT32_C(0x6)
comment|/* 	 * If set to 1, the packet write will be padded out to the nearest 	 * cache-line with zero value padding. 	 */
comment|/* 	 * If receive buffers start/end on cache-line boundaries, this feature 	 * will ensure that all data writes on the PCI bus end on cache line 	 * boundaries. 	 */
define|#
directive|define
name|RX_PROD_AGG_BD_FLAGS_EOP_PAD
value|UINT32_C(0x40)
define|#
directive|define
name|RX_PROD_AGG_BD_FLAGS_MASK
value|UINT32_C(0xffc0)
define|#
directive|define
name|RX_PROD_AGG_BD_FLAGS_SFT
value|6
name|uint16_t
name|len
decl_stmt|;
comment|/* 	 * This is the length in Bytes of the host physical buffer where data 	 * for the packet may be placed in host memory. 	 */
comment|/* 	 * While this is a Byte resolution value, it is often advantageous to 	 * ensure that the buffers provided end on a host cache line. 	 */
name|uint32_t
name|opaque
decl_stmt|;
comment|/* 	 * The opaque data field is pass through to the completion and can be 	 * used for any data that the driver wants to associate with this 	 * receive assembly buffer. 	 */
name|uint64_t
name|addr
decl_stmt|;
comment|/* 	 * This is the host physical address where data for the packet may by 	 * placed in host memory. 	 */
comment|/* 	 * While this is a Byte resolution value, it is often advantageous to 	 * ensure that the buffers provide start on a host cache line. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Completion Ring Structures */
end_comment

begin_comment
comment|/* Note: This structure is used by the HWRM to communicate HWRM Error. */
end_comment

begin_comment
comment|/* Base Completion Record (16 bytes) */
end_comment

begin_struct
struct|struct
name|cmpl_base
block|{
name|uint16_t
name|type
decl_stmt|;
comment|/* unused is 10 b */
comment|/* 	 * This field indicates the exact type of the completion. By convention, 	 * the LSB identifies the length of the record in 16B units. Even values 	 * indicate 16B records. Odd values indicate 32B records. 	 */
define|#
directive|define
name|CMPL_BASE_TYPE_MASK
value|UINT32_C(0x3f)
define|#
directive|define
name|CMPL_BASE_TYPE_SFT
value|0
comment|/* TX L2 completion: Completion of TX packet. Length = 16B */
define|#
directive|define
name|CMPL_BASE_TYPE_TX_L2
value|UINT32_C(0x0)
comment|/* RX L2 completion: Completion of and L2 RX packet. Length = 32B */
define|#
directive|define
name|CMPL_BASE_TYPE_RX_L2
value|UINT32_C(0x11)
comment|/* 	 * RX Aggregation Buffer completion : Completion of an L2 	 * aggregation buffer in support of TPA, HDS, or Jumbo packet 	 * completion. Length = 16B 	 */
define|#
directive|define
name|CMPL_BASE_TYPE_RX_AGG
value|UINT32_C(0x12)
comment|/* 	 * RX L2 TPA Start Completion: Completion at the beginning of a 	 * TPA operation. Length = 32B 	 */
define|#
directive|define
name|CMPL_BASE_TYPE_RX_TPA_START
value|UINT32_C(0x13)
comment|/* 	 * RX L2 TPA End Completion: Completion at the end of a TPA 	 * operation. Length = 32B 	 */
define|#
directive|define
name|CMPL_BASE_TYPE_RX_TPA_END
value|UINT32_C(0x15)
comment|/* 	 * Statistics Ejection Completion: Completion of statistics data 	 * ejection buffer. Length = 16B 	 */
define|#
directive|define
name|CMPL_BASE_TYPE_STAT_EJECT
value|UINT32_C(0x1a)
comment|/* HWRM Command Completion: Completion of an HWRM command. */
define|#
directive|define
name|CMPL_BASE_TYPE_HWRM_DONE
value|UINT32_C(0x20)
comment|/* Forwarded HWRM Request */
define|#
directive|define
name|CMPL_BASE_TYPE_HWRM_FWD_REQ
value|UINT32_C(0x22)
comment|/* Forwarded HWRM Response */
define|#
directive|define
name|CMPL_BASE_TYPE_HWRM_FWD_RESP
value|UINT32_C(0x24)
comment|/* HWRM Asynchronous Event Information */
define|#
directive|define
name|CMPL_BASE_TYPE_HWRM_ASYNC_EVENT
value|UINT32_C(0x2e)
comment|/* CQ Notification */
define|#
directive|define
name|CMPL_BASE_TYPE_CQ_NOTIFICATION
value|UINT32_C(0x30)
comment|/* SRQ Threshold Event */
define|#
directive|define
name|CMPL_BASE_TYPE_SRQ_EVENT
value|UINT32_C(0x32)
comment|/* DBQ Threshold Event */
define|#
directive|define
name|CMPL_BASE_TYPE_DBQ_EVENT
value|UINT32_C(0x34)
comment|/* QP Async Notification */
define|#
directive|define
name|CMPL_BASE_TYPE_QP_EVENT
value|UINT32_C(0x38)
comment|/* Function Async Notification */
define|#
directive|define
name|CMPL_BASE_TYPE_FUNC_EVENT
value|UINT32_C(0x3a)
comment|/* unused is 10 b */
name|uint16_t
name|info1
decl_stmt|;
comment|/* info1 is 16 b */
name|uint32_t
name|info2
decl_stmt|;
comment|/* info2 is 32 b */
name|uint32_t
name|info3_v
decl_stmt|;
comment|/* info3 is 31 b */
comment|/* 	 * This value is written by the NIC such that it will be different for 	 * each pass through the completion queue. The even passes will write 1. 	 * The odd passes will write 0. 	 */
define|#
directive|define
name|CMPL_BASE_V
value|UINT32_C(0x1)
comment|/* info3 is 31 b */
define|#
directive|define
name|CMPL_BASE_INFO3_MASK
value|UINT32_C(0xfffffffe)
define|#
directive|define
name|CMPL_BASE_INFO3_SFT
value|1
name|uint32_t
name|info4
decl_stmt|;
comment|/* info4 is 32 b */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* TX Completion Record (16 bytes) */
end_comment

begin_struct
struct|struct
name|tx_cmpl
block|{
name|uint16_t
name|flags_type
decl_stmt|;
comment|/* 	 * This field indicates the exact type of the completion. By convention, 	 * the LSB identifies the length of the record in 16B units. Even values 	 * indicate 16B records. Odd values indicate 32B records. 	 */
define|#
directive|define
name|TX_CMPL_TYPE_MASK
value|UINT32_C(0x3f)
define|#
directive|define
name|TX_CMPL_TYPE_SFT
value|0
comment|/* TX L2 completion: Completion of TX packet. Length = 16B */
define|#
directive|define
name|TX_CMPL_TYPE_TX_L2
value|UINT32_C(0x0)
comment|/* 	 * When this bit is '1', it indicates a packet that has an error of some 	 * type. Type of error is indicated in error_flags. 	 */
define|#
directive|define
name|TX_CMPL_FLAGS_ERROR
value|UINT32_C(0x40)
comment|/* 	 * When this bit is '1', it indicates that the packet completed was 	 * transmitted using the push acceleration data provided by the driver. 	 * When this bit is '0', it indicates that the packet had not push 	 * acceleration data written or was executed as a normal packet even 	 * though push data was provided. 	 */
define|#
directive|define
name|TX_CMPL_FLAGS_PUSH
value|UINT32_C(0x80)
define|#
directive|define
name|TX_CMPL_FLAGS_MASK
value|UINT32_C(0xffc0)
define|#
directive|define
name|TX_CMPL_FLAGS_SFT
value|6
name|uint16_t
name|unused_0
decl_stmt|;
comment|/* unused1 is 16 b */
name|uint32_t
name|opaque
decl_stmt|;
comment|/* 	 * This is a copy of the opaque field from the first TX BD of this 	 * transmitted packet. 	 */
name|uint16_t
name|errors_v
decl_stmt|;
comment|/* 	 * This value is written by the NIC such that it will be different for 	 * each pass through the completion queue. The even passes will write 1. 	 * The odd passes will write 0. 	 */
define|#
directive|define
name|TX_CMPL_V
value|UINT32_C(0x1)
comment|/* 	 * This error indicates that there was some sort of problem with the BDs 	 * for the packet. 	 */
define|#
directive|define
name|TX_CMPL_ERRORS_BUFFER_ERROR_MASK
value|UINT32_C(0xe)
define|#
directive|define
name|TX_CMPL_ERRORS_BUFFER_ERROR_SFT
value|1
comment|/* No error */
define|#
directive|define
name|TX_CMPL_ERRORS_BUFFER_ERROR_NO_ERROR
value|(UINT32_C(0x0)<< 1)
comment|/* Bad Format: BDs were not formatted correctly. */
define|#
directive|define
name|TX_CMPL_ERRORS_BUFFER_ERROR_BAD_FMT
value|(UINT32_C(0x2)<< 1)
define|#
directive|define
name|TX_CMPL_ERRORS_BUFFER_ERROR_LAST
value|TX_CMPL_ERRORS_BUFFER_ERROR_BAD_FMT
comment|/* 	 * When this bit is '1', it indicates that the length of the packet was 	 * zero. No packet was transmitted. 	 */
define|#
directive|define
name|TX_CMPL_ERRORS_ZERO_LENGTH_PKT
value|UINT32_C(0x10)
comment|/* 	 * When this bit is '1', it indicates that the packet was longer than 	 * the programmed limit in TDI. No packet was transmitted. 	 */
define|#
directive|define
name|TX_CMPL_ERRORS_EXCESSIVE_BD_LENGTH
value|UINT32_C(0x20)
comment|/* 	 * When this bit is '1', it indicates that one or more of the BDs 	 * associated with this packet generated a PCI error. This probably 	 * means the address was not valid. 	 */
define|#
directive|define
name|TX_CMPL_ERRORS_DMA_ERROR
value|UINT32_C(0x40)
comment|/* 	 * When this bit is '1', it indicates that the packet was longer than 	 * indicated by the hint. No packet was transmitted. 	 */
define|#
directive|define
name|TX_CMPL_ERRORS_HINT_TOO_SHORT
value|UINT32_C(0x80)
comment|/* 	 * When this bit is '1', it indicates that the packet was dropped due to 	 * Poison TLP error on one or more of the TLPs in the PXP completion. 	 */
define|#
directive|define
name|TX_CMPL_ERRORS_POISON_TLP_ERROR
value|UINT32_C(0x100)
define|#
directive|define
name|TX_CMPL_ERRORS_MASK
value|UINT32_C(0xfffe)
define|#
directive|define
name|TX_CMPL_ERRORS_SFT
value|1
name|uint16_t
name|unused_1
decl_stmt|;
comment|/* unused2 is 16 b */
name|uint32_t
name|unused_2
decl_stmt|;
comment|/* unused3 is 32 b */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* RX Packet Completion Record (32 bytes split to 2 16-byte struct) */
end_comment

begin_struct
struct|struct
name|rx_pkt_cmpl
block|{
name|uint16_t
name|flags_type
decl_stmt|;
comment|/* 	 * This field indicates the exact type of the completion. By convention, 	 * the LSB identifies the length of the record in 16B units. Even values 	 * indicate 16B records. Odd values indicate 32B records. 	 */
define|#
directive|define
name|RX_PKT_CMPL_TYPE_MASK
value|UINT32_C(0x3f)
define|#
directive|define
name|RX_PKT_CMPL_TYPE_SFT
value|0
comment|/* RX L2 completion: Completion of and L2 RX packet. Length = 32B */
define|#
directive|define
name|RX_PKT_CMPL_TYPE_RX_L2
value|UINT32_C(0x11)
comment|/* 	 * When this bit is '1', it indicates a packet that has an error of some 	 * type. Type of error is indicated in error_flags. 	 */
define|#
directive|define
name|RX_PKT_CMPL_FLAGS_ERROR
value|UINT32_C(0x40)
comment|/* This field indicates how the packet was placed in the buffer. */
define|#
directive|define
name|RX_PKT_CMPL_FLAGS_PLACEMENT_MASK
value|UINT32_C(0x380)
define|#
directive|define
name|RX_PKT_CMPL_FLAGS_PLACEMENT_SFT
value|7
comment|/* Normal: Packet was placed using normal algorithm. */
define|#
directive|define
name|RX_PKT_CMPL_FLAGS_PLACEMENT_NORMAL
value|(UINT32_C(0x0)<< 7)
comment|/* Jumbo: Packet was placed using jumbo algorithm. */
define|#
directive|define
name|RX_PKT_CMPL_FLAGS_PLACEMENT_JUMBO
value|(UINT32_C(0x1)<< 7)
comment|/* 	 * Header/Data Separation: Packet was placed using Header/Data 	 * separation algorithm. The separation location is indicated by 	 * the itype field. 	 */
define|#
directive|define
name|RX_PKT_CMPL_FLAGS_PLACEMENT_HDS
value|(UINT32_C(0x2)<< 7)
define|#
directive|define
name|RX_PKT_CMPL_FLAGS_PLACEMENT_LAST
value|RX_PKT_CMPL_FLAGS_PLACEMENT_HDS
comment|/* This bit is '1' if the RSS field in this completion is valid. */
define|#
directive|define
name|RX_PKT_CMPL_FLAGS_RSS_VALID
value|UINT32_C(0x400)
comment|/* unused is 1 b */
define|#
directive|define
name|RX_PKT_CMPL_FLAGS_UNUSED
value|UINT32_C(0x800)
comment|/* 	 * This value indicates what the inner packet determined for the packet 	 * was. 	 */
define|#
directive|define
name|RX_PKT_CMPL_FLAGS_ITYPE_MASK
value|UINT32_C(0xf000)
define|#
directive|define
name|RX_PKT_CMPL_FLAGS_ITYPE_SFT
value|12
comment|/* Not Known: Indicates that the packet type was not known. */
define|#
directive|define
name|RX_PKT_CMPL_FLAGS_ITYPE_NOT_KNOWN
value|(UINT32_C(0x0)<< 12)
comment|/* 	 * IP Packet: Indicates that the packet was an IP packet, but 	 * further classification was not possible. 	 */
define|#
directive|define
name|RX_PKT_CMPL_FLAGS_ITYPE_IP
value|(UINT32_C(0x1)<< 12)
comment|/* 	 * TCP Packet: Indicates that the packet was IP and TCP. This 	 * indicates that the payload_offset field is valid. 	 */
define|#
directive|define
name|RX_PKT_CMPL_FLAGS_ITYPE_TCP
value|(UINT32_C(0x2)<< 12)
comment|/* 	 * UDP Packet: Indicates that the packet was IP and UDP. This 	 * indicates that the payload_offset field is valid. 	 */
define|#
directive|define
name|RX_PKT_CMPL_FLAGS_ITYPE_UDP
value|(UINT32_C(0x3)<< 12)
comment|/* 	 * FCoE Packet: Indicates that the packet was recognized as a 	 * FCoE. This also indicates that the payload_offset field is 	 * valid. 	 */
define|#
directive|define
name|RX_PKT_CMPL_FLAGS_ITYPE_FCOE
value|(UINT32_C(0x4)<< 12)
comment|/* 	 * RoCE Packet: Indicates that the packet was recognized as a 	 * RoCE. This also indicates that the payload_offset field is 	 * valid. 	 */
define|#
directive|define
name|RX_PKT_CMPL_FLAGS_ITYPE_ROCE
value|(UINT32_C(0x5)<< 12)
comment|/* 	 * ICMP Packet: Indicates that the packet was recognized as 	 * ICMP. This indicates that the payload_offset field is valid. 	 */
define|#
directive|define
name|RX_PKT_CMPL_FLAGS_ITYPE_ICMP
value|(UINT32_C(0x7)<< 12)
comment|/* 	 * PtP packet wo/timestamp: Indicates that the packet was 	 * recognized as a PtP packet. 	 */
define|#
directive|define
name|RX_PKT_CMPL_FLAGS_ITYPE_PTP_WO_TIMESTAMP
value|(UINT32_C(0x8)<< 12)
comment|/* 	 * PtP packet w/timestamp: Indicates that the packet was 	 * recognized as a PtP packet and that a timestamp was taken for 	 * the packet. 	 */
define|#
directive|define
name|RX_PKT_CMPL_FLAGS_ITYPE_PTP_W_TIMESTAMP
value|(UINT32_C(0x9)<< 12)
define|#
directive|define
name|RX_PKT_CMPL_FLAGS_ITYPE_LAST
value|RX_PKT_CMPL_FLAGS_ITYPE_PTP_W_TIMESTAMP
define|#
directive|define
name|RX_PKT_CMPL_FLAGS_MASK
value|UINT32_C(0xffc0)
define|#
directive|define
name|RX_PKT_CMPL_FLAGS_SFT
value|6
name|uint16_t
name|len
decl_stmt|;
comment|/* 	 * This is the length of the data for the packet stored in the buffer(s) 	 * identified by the opaque value. This includes the packet BD and any 	 * associated buffer BDs. This does not include the the length of any 	 * data places in aggregation BDs. 	 */
name|uint32_t
name|opaque
decl_stmt|;
comment|/* 	 * This is a copy of the opaque field from the RX BD this completion 	 * corresponds to. 	 */
name|uint8_t
name|agg_bufs_v1
decl_stmt|;
comment|/* unused1 is 2 b */
comment|/* 	 * This value is written by the NIC such that it will be different for 	 * each pass through the completion queue. The even passes will write 1. 	 * The odd passes will write 0. 	 */
define|#
directive|define
name|RX_PKT_CMPL_V1
value|UINT32_C(0x1)
comment|/* 	 * This value is the number of aggregation buffers that follow this 	 * entry in the completion ring that are a part of this packet. If the 	 * value is zero, then the packet is completely contained in the buffer 	 * space provided for the packet in the RX ring. 	 */
define|#
directive|define
name|RX_PKT_CMPL_AGG_BUFS_MASK
value|UINT32_C(0x3e)
define|#
directive|define
name|RX_PKT_CMPL_AGG_BUFS_SFT
value|1
comment|/* unused1 is 2 b */
name|uint8_t
name|rss_hash_type
decl_stmt|;
comment|/* 	 * This is the RSS hash type for the packet. The value is packed 	 * {tuple_extrac_op[1:0],rss_profile_id[4:0],tuple_extrac_op[2]}. The 	 * value of tuple_extrac_op provides the information about what fields 	 * the hash was computed on. * 0: The RSS hash was computed over source 	 * IP address, destination IP address, source port, and destination port 	 * of inner IP and TCP or UDP headers. Note: For non-tunneled packets, 	 * the packet headers are considered inner packet headers for the RSS 	 * hash computation purpose. * 1: The RSS hash was computed over source 	 * IP address and destination IP address of inner IP header. Note: For 	 * non-tunneled packets, the packet headers are considered inner packet 	 * headers for the RSS hash computation purpose. * 2: The RSS hash was 	 * computed over source IP address, destination IP address, source port, 	 * and destination port of IP and TCP or UDP headers of outer tunnel 	 * headers. Note: For non-tunneled packets, this value is not 	 * applicable. * 3: The RSS hash was computed over source IP address and 	 * destination IP address of IP header of outer tunnel headers. Note: 	 * For non-tunneled packets, this value is not applicable. Note that 	 * 4-tuples values listed above are applicable for layer 4 protocols 	 * supported and enabled for RSS in the hardware, HWRM firmware, and 	 * drivers. For example, if RSS hash is supported and enabled for TCP 	 * traffic only, then the values of tuple_extract_op corresponding to 	 * 4-tuples are only valid for TCP traffic. 	 */
name|uint8_t
name|payload_offset
decl_stmt|;
comment|/* 	 * This value indicates the offset in bytes from the beginning of the 	 * packet where the inner payload starts. This value is valid for TCP, 	 * UDP, FCoE, and RoCE packets. A value of zero indicates that header is 	 * 256B into the packet. 	 */
name|uint8_t
name|unused_1
decl_stmt|;
comment|/* unused2 is 8 b */
name|uint32_t
name|rss_hash
decl_stmt|;
comment|/* 	 * This value is the RSS hash value calculated for the packet based on 	 * the mode bits and key value in the VNIC. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* last 16 bytes of RX Packet Completion Record */
end_comment

begin_struct
struct|struct
name|rx_pkt_cmpl_hi
block|{
name|uint32_t
name|flags2
decl_stmt|;
comment|/* 	 * This indicates that the ip checksum was calculated for the inner 	 * packet and that the ip_cs_error field indicates if there was an 	 * error. 	 */
define|#
directive|define
name|RX_PKT_CMPL_FLAGS2_IP_CS_CALC
value|UINT32_C(0x1)
comment|/* 	 * This indicates that the TCP, UDP or ICMP checksum was calculated for 	 * the inner packet and that the l4_cs_error field indicates if there 	 * was an error. 	 */
define|#
directive|define
name|RX_PKT_CMPL_FLAGS2_L4_CS_CALC
value|UINT32_C(0x2)
comment|/* 	 * This indicates that the ip checksum was calculated for the tunnel 	 * header and that the t_ip_cs_error field indicates if there was an 	 * error. 	 */
define|#
directive|define
name|RX_PKT_CMPL_FLAGS2_T_IP_CS_CALC
value|UINT32_C(0x4)
comment|/* 	 * This indicates that the UDP checksum was calculated for the tunnel 	 * packet and that the t_l4_cs_error field indicates if there was an 	 * error. 	 */
define|#
directive|define
name|RX_PKT_CMPL_FLAGS2_T_L4_CS_CALC
value|UINT32_C(0x8)
comment|/* This value indicates what format the metadata field is. */
define|#
directive|define
name|RX_PKT_CMPL_FLAGS2_META_FORMAT_MASK
value|UINT32_C(0xf0)
define|#
directive|define
name|RX_PKT_CMPL_FLAGS2_META_FORMAT_SFT
value|4
comment|/* No metadata informtaion. Value is zero. */
define|#
directive|define
name|RX_PKT_CMPL_FLAGS2_META_FORMAT_NONE
value|(UINT32_C(0x0)<< 4)
comment|/* 	 * The metadata field contains the VLAN tag and TPID value. - 	 * metadata[11:0] contains the vlan VID value. - metadata[12] 	 * contains the vlan DE value. - metadata[15:13] contains the 	 * vlan PRI value. - metadata[31:16] contains the vlan TPID 	 * value. 	 */
define|#
directive|define
name|RX_PKT_CMPL_FLAGS2_META_FORMAT_VLAN
value|(UINT32_C(0x1)<< 4)
define|#
directive|define
name|RX_PKT_CMPL_FLAGS2_META_FORMAT_LAST
value|RX_PKT_CMPL_FLAGS2_META_FORMAT_VLAN
comment|/* 	 * This field indicates the IP type for the inner-most IP header. A 	 * value of '0' indicates IPv4. A value of '1' indicates IPv6. This 	 * value is only valid if itype indicates a packet with an IP header. 	 */
define|#
directive|define
name|RX_PKT_CMPL_FLAGS2_IP_TYPE
value|UINT32_C(0x100)
name|uint32_t
name|metadata
decl_stmt|;
comment|/* 	 * This is data from the CFA block as indicated by the meta_format 	 * field. 	 */
comment|/* When meta_format=1, this value is the VLAN VID. */
define|#
directive|define
name|RX_PKT_CMPL_METADATA_VID_MASK
value|UINT32_C(0xfff)
define|#
directive|define
name|RX_PKT_CMPL_METADATA_VID_SFT
value|0
comment|/* When meta_format=1, this value is the VLAN DE. */
define|#
directive|define
name|RX_PKT_CMPL_METADATA_DE
value|UINT32_C(0x1000)
comment|/* When meta_format=1, this value is the VLAN PRI. */
define|#
directive|define
name|RX_PKT_CMPL_METADATA_PRI_MASK
value|UINT32_C(0xe000)
define|#
directive|define
name|RX_PKT_CMPL_METADATA_PRI_SFT
value|13
comment|/* When meta_format=1, this value is the VLAN TPID. */
define|#
directive|define
name|RX_PKT_CMPL_METADATA_TPID_MASK
value|UINT32_C(0xffff0000)
define|#
directive|define
name|RX_PKT_CMPL_METADATA_TPID_SFT
value|16
name|uint16_t
name|errors_v2
decl_stmt|;
comment|/* 	 * This value is written by the NIC such that it will be different for 	 * each pass through the completion queue. The even passes will write 1. 	 * The odd passes will write 0. 	 */
define|#
directive|define
name|RX_PKT_CMPL_V2
value|UINT32_C(0x1)
comment|/* 	 * This error indicates that there was some sort of problem with the BDs 	 * for the packet that was found after part of the packet was already 	 * placed. The packet should be treated as invalid. 	 */
define|#
directive|define
name|RX_PKT_CMPL_ERRORS_BUFFER_ERROR_MASK
value|UINT32_C(0xe)
define|#
directive|define
name|RX_PKT_CMPL_ERRORS_BUFFER_ERROR_SFT
value|1
comment|/* No buffer error */
define|#
directive|define
name|RX_PKT_CMPL_ERRORS_BUFFER_ERROR_NO_BUFFER
value|(UINT32_C(0x0)<< 1)
comment|/* 	 * Did Not Fit: Packet did not fit into packet buffer provided. 	 * For regular placement, this means the packet did not fit in 	 * the buffer provided. For HDS and jumbo placement, this means 	 * that the packet could not be placed into 7 physical buffers 	 * or less. 	 */
define|#
directive|define
name|RX_PKT_CMPL_ERRORS_BUFFER_ERROR_DID_NOT_FIT
value|(UINT32_C(0x1)<< 1)
comment|/* 	 * Not On Chip: All BDs needed for the packet were not on-chip 	 * when the packet arrived. 	 */
define|#
directive|define
name|RX_PKT_CMPL_ERRORS_BUFFER_ERROR_NOT_ON_CHIP
value|(UINT32_C(0x2)<< 1)
comment|/* Bad Format: BDs were not formatted correctly. */
define|#
directive|define
name|RX_PKT_CMPL_ERRORS_BUFFER_ERROR_BAD_FORMAT
value|(UINT32_C(0x3)<< 1)
define|#
directive|define
name|RX_PKT_CMPL_ERRORS_BUFFER_ERROR_LAST
value|RX_PKT_CMPL_ERRORS_BUFFER_ERROR_BAD_FORMAT
comment|/* This indicates that there was an error in the IP header checksum. */
define|#
directive|define
name|RX_PKT_CMPL_ERRORS_IP_CS_ERROR
value|UINT32_C(0x10)
comment|/* 	 * This indicates that there was an error in the TCP, UDP or ICMP 	 * checksum. 	 */
define|#
directive|define
name|RX_PKT_CMPL_ERRORS_L4_CS_ERROR
value|UINT32_C(0x20)
comment|/* 	 * This indicates that there was an error in the tunnel IP header 	 * checksum. 	 */
define|#
directive|define
name|RX_PKT_CMPL_ERRORS_T_IP_CS_ERROR
value|UINT32_C(0x40)
comment|/* This indicates that there was an error in the tunnel UDP checksum. */
define|#
directive|define
name|RX_PKT_CMPL_ERRORS_T_L4_CS_ERROR
value|UINT32_C(0x80)
comment|/* 	 * This indicates that there was a CRC error on either an FCoE or RoCE 	 * packet. The itype indicates the packet type. 	 */
define|#
directive|define
name|RX_PKT_CMPL_ERRORS_CRC_ERROR
value|UINT32_C(0x100)
comment|/* 	 * This indicates that there was an error in the tunnel portion of the 	 * packet when this field is non-zero. 	 */
define|#
directive|define
name|RX_PKT_CMPL_ERRORS_T_PKT_ERROR_MASK
value|UINT32_C(0xe00)
define|#
directive|define
name|RX_PKT_CMPL_ERRORS_T_PKT_ERROR_SFT
value|9
comment|/* 	 * No additional error occurred on the tunnel portion of the 	 * packet of the packet does not have a tunnel. 	 */
define|#
directive|define
name|RX_PKT_CMPL_ERRORS_T_PKT_ERROR_NO_ERROR
value|(UINT32_C(0x0)<< 9)
comment|/* 	 * Indicates that IP header version does not match expectation 	 * from L2 Ethertype for IPv4 and IPv6 in the tunnel header. 	 */
define|#
directive|define
name|RX_PKT_CMPL_ERRORS_T_PKT_ERROR_T_L3_BAD_VERSION
value|(UINT32_C(0x1)<< 9)
comment|/* 	 * Indicates that header length is out of range in the tunnel 	 * header. Valid for IPv4. 	 */
define|#
directive|define
name|RX_PKT_CMPL_ERRORS_T_PKT_ERROR_T_L3_BAD_HDR_LEN
value|(UINT32_C(0x2)<< 9)
comment|/* 	 * Indicates that the physical packet is shorter than that 	 * claimed by the PPPoE header length for a tunnel PPPoE packet. 	 */
define|#
directive|define
name|RX_PKT_CMPL_ERRORS_T_PKT_ERROR_TUNNEL_TOTAL_ERROR
value|(UINT32_C(0x3)<< 9)
comment|/* 	 * Indicates that physical packet is shorter than that claimed 	 * by the tunnel l3 header length. Valid for IPv4, or IPv6 	 * tunnel packet packets. 	 */
define|#
directive|define
name|RX_PKT_CMPL_ERRORS_T_PKT_ERROR_T_IP_TOTAL_ERROR
value|(UINT32_C(0x4)<< 9)
comment|/* 	 * Indicates that the physical packet is shorter than that 	 * claimed by the tunnel UDP header length for a tunnel UDP 	 * packet that is not fragmented. 	 */
define|#
directive|define
name|RX_PKT_CMPL_ERRORS_T_PKT_ERROR_T_UDP_TOTAL_ERROR
value|(UINT32_C(0x5)<< 9)
comment|/* 	 * indicates that the IPv4 TTL or IPv6 hop limit check have 	 * failed (e.g. TTL = 0) in the tunnel header. Valid for IPv4, 	 * and IPv6. 	 */
define|#
directive|define
name|RX_PKT_CMPL_ERRORS_T_PKT_ERROR_T_L3_BAD_TTL
value|(UINT32_C(0x6)<< 9)
define|#
directive|define
name|RX_PKT_CMPL_ERRORS_T_PKT_ERROR_LAST
value|RX_PKT_CMPL_ERRORS_T_PKT_ERROR_T_L3_BAD_TTL
comment|/* 	 * This indicates that there was an error in the inner portion of the 	 * packet when this field is non-zero. 	 */
define|#
directive|define
name|RX_PKT_CMPL_ERRORS_PKT_ERROR_MASK
value|UINT32_C(0xf000)
define|#
directive|define
name|RX_PKT_CMPL_ERRORS_PKT_ERROR_SFT
value|12
comment|/* 	 * No additional error occurred on the tunnel portion of the 	 * packet of the packet does not have a tunnel. 	 */
define|#
directive|define
name|RX_PKT_CMPL_ERRORS_PKT_ERROR_NO_ERROR
value|(UINT32_C(0x0)<< 12)
comment|/* 	 * Indicates that IP header version does not match expectation 	 * from L2 Ethertype for IPv4 and IPv6 or that option other than 	 * VFT was parsed on FCoE packet. 	 */
define|#
directive|define
name|RX_PKT_CMPL_ERRORS_PKT_ERROR_L3_BAD_VERSION
value|(UINT32_C(0x1)<< 12)
comment|/* 	 * indicates that header length is out of range. Valid for IPv4 	 * and RoCE 	 */
define|#
directive|define
name|RX_PKT_CMPL_ERRORS_PKT_ERROR_L3_BAD_HDR_LEN
value|(UINT32_C(0x2)<< 12)
comment|/* 	 * indicates that the IPv4 TTL or IPv6 hop limit check have 	 * failed (e.g. TTL = 0). Valid for IPv4, and IPv6 	 */
define|#
directive|define
name|RX_PKT_CMPL_ERRORS_PKT_ERROR_L3_BAD_TTL
value|(UINT32_C(0x3)<< 12)
comment|/* 	 * Indicates that physical packet is shorter than that claimed 	 * by the l3 header length. Valid for IPv4, IPv6 packet or RoCE 	 * packets. 	 */
define|#
directive|define
name|RX_PKT_CMPL_ERRORS_PKT_ERROR_IP_TOTAL_ERROR
value|(UINT32_C(0x4)<< 12)
comment|/* 	 * Indicates that the physical packet is shorter than that 	 * claimed by the UDP header length for a UDP packet that is not 	 * fragmented. 	 */
define|#
directive|define
name|RX_PKT_CMPL_ERRORS_PKT_ERROR_UDP_TOTAL_ERROR
value|(UINT32_C(0x5)<< 12)
comment|/* 	 * Indicates that TCP header length> IP payload. Valid for TCP 	 * packets only. 	 */
define|#
directive|define
name|RX_PKT_CMPL_ERRORS_PKT_ERROR_L4_BAD_HDR_LEN
value|(UINT32_C(0x6)<< 12)
comment|/* Indicates that TCP header length< 5. Valid for TCP. */
define|#
directive|define
name|RX_PKT_CMPL_ERRORS_PKT_ERROR_L4_BAD_HDR_LEN_TOO_SMALL
value|(UINT32_C(0x7)<< 12)
comment|/* 	 * Indicates that TCP option headers result in a TCP header size 	 * that does not match data offset in TCP header. Valid for TCP. 	 */
define|#
directive|define
name|RX_PKT_CMPL_ERRORS_PKT_ERROR_L4_BAD_OPT_LEN
value|(UINT32_C(0x8)<< 12)
define|#
directive|define
name|RX_PKT_CMPL_ERRORS_PKT_ERROR_LAST
value|RX_PKT_CMPL_ERRORS_PKT_ERROR_L4_BAD_OPT_LEN
define|#
directive|define
name|RX_PKT_CMPL_ERRORS_MASK
value|UINT32_C(0xfffe)
define|#
directive|define
name|RX_PKT_CMPL_ERRORS_SFT
value|1
name|uint16_t
name|cfa_code
decl_stmt|;
comment|/* 	 * This field identifies the CFA action rule that was used for this 	 * packet. 	 */
name|uint32_t
name|reorder
decl_stmt|;
comment|/* 	 * This value holds the reordering sequence number for the packet. If 	 * the reordering sequence is not valid, then this value is zero. The 	 * reordering domain for the packet is in the bottom 8 to 10b of the 	 * rss_hash value. The bottom 20b of this value contain the ordering 	 * domain value for the packet. 	 */
define|#
directive|define
name|RX_PKT_CMPL_REORDER_MASK
value|UINT32_C(0xffffff)
define|#
directive|define
name|RX_PKT_CMPL_REORDER_SFT
value|0
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* RX L2 TPA Start Completion Record (32 bytes split to 2 16-byte struct) */
end_comment

begin_struct
struct|struct
name|rx_tpa_start_cmpl
block|{
name|uint16_t
name|flags_type
decl_stmt|;
comment|/* 	 * This field indicates the exact type of the completion. By convention, 	 * the LSB identifies the length of the record in 16B units. Even values 	 * indicate 16B records. Odd values indicate 32B records. 	 */
define|#
directive|define
name|RX_TPA_START_CMPL_TYPE_MASK
value|UINT32_C(0x3f)
define|#
directive|define
name|RX_TPA_START_CMPL_TYPE_SFT
value|0
comment|/* 	 * RX L2 TPA Start Completion: Completion at the beginning of a 	 * TPA operation. Length = 32B 	 */
define|#
directive|define
name|RX_TPA_START_CMPL_TYPE_RX_TPA_START
value|UINT32_C(0x13)
comment|/* This bit will always be '0' for TPA start completions. */
define|#
directive|define
name|RX_TPA_START_CMPL_FLAGS_ERROR
value|UINT32_C(0x40)
comment|/* This field indicates how the packet was placed in the buffer. */
define|#
directive|define
name|RX_TPA_START_CMPL_FLAGS_PLACEMENT_MASK
value|UINT32_C(0x380)
define|#
directive|define
name|RX_TPA_START_CMPL_FLAGS_PLACEMENT_SFT
value|7
comment|/* 	 * Jumbo: TPA Packet was placed using jumbo algorithm. This 	 * means that the first buffer will be filled with data before 	 * moving to aggregation buffers. Each aggregation buffer will 	 * be filled before moving to the next aggregation buffer. 	 */
define|#
directive|define
name|RX_TPA_START_CMPL_FLAGS_PLACEMENT_JUMBO
value|(UINT32_C(0x1)<< 7)
comment|/* 	 * Header/Data Separation: Packet was placed using Header/Data 	 * separation algorithm. The separation location is indicated by 	 * the itype field. 	 */
define|#
directive|define
name|RX_TPA_START_CMPL_FLAGS_PLACEMENT_HDS
value|(UINT32_C(0x2)<< 7)
comment|/* 	 * GRO/Jumbo: Packet will be placed using GRO/Jumbo where the 	 * first packet is filled with data. Subsequent packets will be 	 * placed such that any one packet does not span two aggregation 	 * buffers unless it starts at the beginning of an aggregation 	 * buffer. 	 */
define|#
directive|define
name|RX_TPA_START_CMPL_FLAGS_PLACEMENT_GRO_JUMBO
value|(UINT32_C(0x5)<< 7)
comment|/* 	 * GRO/Header-Data Separation: Packet will be placed using 	 * GRO/HDS where the header is in the first packet. Payload of 	 * each packet will be placed such that any one packet does not 	 * span two aggregation buffers unless it starts at the 	 * beginning of an aggregation buffer. 	 */
define|#
directive|define
name|RX_TPA_START_CMPL_FLAGS_PLACEMENT_GRO_HDS
value|(UINT32_C(0x6)<< 7)
define|#
directive|define
name|RX_TPA_START_CMPL_FLAGS_PLACEMENT_LAST
value|RX_TPA_START_CMPL_FLAGS_PLACEMENT_GRO_HDS
comment|/* This bit is '1' if the RSS field in this completion is valid. */
define|#
directive|define
name|RX_TPA_START_CMPL_FLAGS_RSS_VALID
value|UINT32_C(0x400)
comment|/* unused is 1 b */
define|#
directive|define
name|RX_TPA_START_CMPL_FLAGS_UNUSED
value|UINT32_C(0x800)
comment|/* 	 * This value indicates what the inner packet determined for the packet 	 * was. 	 */
define|#
directive|define
name|RX_TPA_START_CMPL_FLAGS_ITYPE_MASK
value|UINT32_C(0xf000)
define|#
directive|define
name|RX_TPA_START_CMPL_FLAGS_ITYPE_SFT
value|12
comment|/* TCP Packet: Indicates that the packet was IP and TCP. */
define|#
directive|define
name|RX_TPA_START_CMPL_FLAGS_ITYPE_TCP
value|(UINT32_C(0x2)<< 12)
define|#
directive|define
name|RX_TPA_START_CMPL_FLAGS_ITYPE_LAST
value|RX_TPA_START_CMPL_FLAGS_ITYPE_TCP
define|#
directive|define
name|RX_TPA_START_CMPL_FLAGS_MASK
value|UINT32_C(0xffc0)
define|#
directive|define
name|RX_TPA_START_CMPL_FLAGS_SFT
value|6
name|uint16_t
name|len
decl_stmt|;
comment|/* 	 * This value indicates the amount of packet data written to the buffer 	 * the opaque field in this completion corresponds to. 	 */
name|uint32_t
name|opaque
decl_stmt|;
comment|/* 	 * This is a copy of the opaque field from the RX BD this completion 	 * corresponds to. 	 */
name|uint8_t
name|v1
decl_stmt|;
comment|/* unused1 is 7 b */
comment|/* 	 * This value is written by the NIC such that it will be different for 	 * each pass through the completion queue. The even passes will write 1. 	 * The odd passes will write 0. 	 */
define|#
directive|define
name|RX_TPA_START_CMPL_V1
value|UINT32_C(0x1)
comment|/* unused1 is 7 b */
name|uint8_t
name|rss_hash_type
decl_stmt|;
comment|/* 	 * This is the RSS hash type for the packet. The value is packed 	 * {tuple_extrac_op[1:0],rss_profile_id[4:0],tuple_extrac_op[2]}. The 	 * value of tuple_extrac_op provides the information about what fields 	 * the hash was computed on. * 0: The RSS hash was computed over source 	 * IP address, destination IP address, source port, and destination port 	 * of inner IP and TCP or UDP headers. Note: For non-tunneled packets, 	 * the packet headers are considered inner packet headers for the RSS 	 * hash computation purpose. * 1: The RSS hash was computed over source 	 * IP address and destination IP address of inner IP header. Note: For 	 * non-tunneled packets, the packet headers are considered inner packet 	 * headers for the RSS hash computation purpose. * 2: The RSS hash was 	 * computed over source IP address, destination IP address, source port, 	 * and destination port of IP and TCP or UDP headers of outer tunnel 	 * headers. Note: For non-tunneled packets, this value is not 	 * applicable. * 3: The RSS hash was computed over source IP address and 	 * destination IP address of IP header of outer tunnel headers. Note: 	 * For non-tunneled packets, this value is not applicable. Note that 	 * 4-tuples values listed above are applicable for layer 4 protocols 	 * supported and enabled for RSS in the hardware, HWRM firmware, and 	 * drivers. For example, if RSS hash is supported and enabled for TCP 	 * traffic only, then the values of tuple_extract_op corresponding to 	 * 4-tuples are only valid for TCP traffic. 	 */
name|uint16_t
name|agg_id
decl_stmt|;
comment|/* 	 * This is the aggregation ID that the completion is associated with. 	 * Use this number to correlate the TPA start completion with the TPA 	 * end completion. 	 */
comment|/* unused2 is 9 b */
comment|/* 	 * This is the aggregation ID that the completion is associated with. 	 * Use this number to correlate the TPA start completion with the TPA 	 * end completion. 	 */
define|#
directive|define
name|RX_TPA_START_CMPL_AGG_ID_MASK
value|UINT32_C(0xfe00)
define|#
directive|define
name|RX_TPA_START_CMPL_AGG_ID_SFT
value|9
name|uint32_t
name|rss_hash
decl_stmt|;
comment|/* 	 * This value is the RSS hash value calculated for the packet based on 	 * the mode bits and key value in the VNIC. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* last 16 bytes of RX L2 TPA Start Completion Record */
end_comment

begin_struct
struct|struct
name|rx_tpa_start_cmpl_hi
block|{
name|uint32_t
name|flags2
decl_stmt|;
comment|/* 	 * This indicates that the ip checksum was calculated for the inner 	 * packet and that the sum passed for all segments included in the 	 * aggregation. 	 */
define|#
directive|define
name|RX_TPA_START_CMPL_FLAGS2_IP_CS_CALC
value|UINT32_C(0x1)
comment|/* 	 * This indicates that the TCP, UDP or ICMP checksum was calculated for 	 * the inner packet and that the sum passed for all segments included in 	 * the aggregation. 	 */
define|#
directive|define
name|RX_TPA_START_CMPL_FLAGS2_L4_CS_CALC
value|UINT32_C(0x2)
comment|/* 	 * This indicates that the ip checksum was calculated for the tunnel 	 * header and that the sum passed for all segments included in the 	 * aggregation. 	 */
define|#
directive|define
name|RX_TPA_START_CMPL_FLAGS2_T_IP_CS_CALC
value|UINT32_C(0x4)
comment|/* 	 * This indicates that the UDP checksum was calculated for the tunnel 	 * packet and that the sum passed for all segments included in the 	 * aggregation. 	 */
define|#
directive|define
name|RX_TPA_START_CMPL_FLAGS2_T_L4_CS_CALC
value|UINT32_C(0x8)
comment|/* This value indicates what format the metadata field is. */
define|#
directive|define
name|RX_TPA_START_CMPL_FLAGS2_META_FORMAT_MASK
value|UINT32_C(0xf0)
define|#
directive|define
name|RX_TPA_START_CMPL_FLAGS2_META_FORMAT_SFT
value|4
comment|/* No metadata informtaion. Value is zero. */
define|#
directive|define
name|RX_TPA_START_CMPL_FLAGS2_META_FORMAT_NONE
value|(UINT32_C(0x0)<< 4)
comment|/* 	 * The metadata field contains the VLAN tag and TPID value. - 	 * metadata[11:0] contains the vlan VID value. - metadata[12] 	 * contains the vlan DE value. - metadata[15:13] contains the 	 * vlan PRI value. - metadata[31:16] contains the vlan TPID 	 * value. 	 */
define|#
directive|define
name|RX_TPA_START_CMPL_FLAGS2_META_FORMAT_VLAN
value|(UINT32_C(0x1)<< 4)
define|#
directive|define
name|RX_TPA_START_CMPL_FLAGS2_META_FORMAT_LAST
value|RX_TPA_START_CMPL_FLAGS2_META_FORMAT_VLAN
comment|/* 	 * This field indicates the IP type for the inner-most IP header. A 	 * value of '0' indicates IPv4. A value of '1' indicates IPv6. 	 */
define|#
directive|define
name|RX_TPA_START_CMPL_FLAGS2_IP_TYPE
value|UINT32_C(0x100)
name|uint32_t
name|metadata
decl_stmt|;
comment|/* 	 * This is data from the CFA block as indicated by the meta_format 	 * field. 	 */
comment|/* When meta_format=1, this value is the VLAN VID. */
define|#
directive|define
name|RX_TPA_START_CMPL_METADATA_VID_MASK
value|UINT32_C(0xfff)
define|#
directive|define
name|RX_TPA_START_CMPL_METADATA_VID_SFT
value|0
comment|/* When meta_format=1, this value is the VLAN DE. */
define|#
directive|define
name|RX_TPA_START_CMPL_METADATA_DE
value|UINT32_C(0x1000)
comment|/* When meta_format=1, this value is the VLAN PRI. */
define|#
directive|define
name|RX_TPA_START_CMPL_METADATA_PRI_MASK
value|UINT32_C(0xe000)
define|#
directive|define
name|RX_TPA_START_CMPL_METADATA_PRI_SFT
value|13
comment|/* When meta_format=1, this value is the VLAN TPID. */
define|#
directive|define
name|RX_TPA_START_CMPL_METADATA_TPID_MASK
value|UINT32_C(0xffff0000)
define|#
directive|define
name|RX_TPA_START_CMPL_METADATA_TPID_SFT
value|16
name|uint16_t
name|v2
decl_stmt|;
comment|/* unused4 is 15 b */
comment|/* 	 * This value is written by the NIC such that it will be different for 	 * each pass through the completion queue. The even passes will write 1. 	 * The odd passes will write 0. 	 */
define|#
directive|define
name|RX_TPA_START_CMPL_V2
value|UINT32_C(0x1)
comment|/* unused4 is 15 b */
name|uint16_t
name|cfa_code
decl_stmt|;
comment|/* 	 * This field identifies the CFA action rule that was used for this 	 * packet. 	 */
name|uint32_t
name|inner_l4_size_inner_l3_offset_inner_l2_offset_outer_l3_offset
decl_stmt|;
comment|/* 	 * This is the size in bytes of the inner most L4 header. This can be 	 * subtracted from the payload_offset to determine the start of the 	 * inner most L4 header. 	 */
comment|/* 	 * This is the offset from the beginning of the packet in bytes for the 	 * outer L3 header. If there is no outer L3 header, then this value is 	 * zero. 	 */
define|#
directive|define
name|RX_TPA_START_CMPL_OUTER_L3_OFFSET_MASK
value|UINT32_C(0x1ff)
define|#
directive|define
name|RX_TPA_START_CMPL_OUTER_L3_OFFSET_SFT
value|0
comment|/* 	 * This is the offset from the beginning of the packet in bytes for the 	 * inner most L2 header. 	 */
define|#
directive|define
name|RX_TPA_START_CMPL_INNER_L2_OFFSET_MASK
value|UINT32_C(0x3fe00)
define|#
directive|define
name|RX_TPA_START_CMPL_INNER_L2_OFFSET_SFT
value|9
comment|/* 	 * This is the offset from the beginning of the packet in bytes for the 	 * inner most L3 header. 	 */
define|#
directive|define
name|RX_TPA_START_CMPL_INNER_L3_OFFSET_MASK
value|UINT32_C(0x7fc0000)
define|#
directive|define
name|RX_TPA_START_CMPL_INNER_L3_OFFSET_SFT
value|18
comment|/* 	 * This is the size in bytes of the inner most L4 header. This can be 	 * subtracted from the payload_offset to determine the start of the 	 * inner most L4 header. 	 */
define|#
directive|define
name|RX_TPA_START_CMPL_INNER_L4_SIZE_MASK
value|UINT32_C(0xf8000000)
define|#
directive|define
name|RX_TPA_START_CMPL_INNER_L4_SIZE_SFT
value|27
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* RX TPA End Completion Record (32 bytes split to 2 16-byte struct) */
end_comment

begin_struct
struct|struct
name|rx_tpa_end_cmpl
block|{
name|uint16_t
name|flags_type
decl_stmt|;
comment|/* 	 * This field indicates the exact type of the completion. By convention, 	 * the LSB identifies the length of the record in 16B units. Even values 	 * indicate 16B records. Odd values indicate 32B records. 	 */
define|#
directive|define
name|RX_TPA_END_CMPL_TYPE_MASK
value|UINT32_C(0x3f)
define|#
directive|define
name|RX_TPA_END_CMPL_TYPE_SFT
value|0
comment|/* 	 * RX L2 TPA End Completion: Completion at the end of a TPA 	 * operation. Length = 32B 	 */
define|#
directive|define
name|RX_TPA_END_CMPL_TYPE_RX_TPA_END
value|UINT32_C(0x15)
comment|/* 	 * When this bit is '1', it indicates a packet that has an error of some 	 * type. Type of error is indicated in error_flags. 	 */
define|#
directive|define
name|RX_TPA_END_CMPL_FLAGS_ERROR
value|UINT32_C(0x40)
comment|/* This field indicates how the packet was placed in the buffer. */
define|#
directive|define
name|RX_TPA_END_CMPL_FLAGS_PLACEMENT_MASK
value|UINT32_C(0x380)
define|#
directive|define
name|RX_TPA_END_CMPL_FLAGS_PLACEMENT_SFT
value|7
comment|/* 	 * Jumbo: TPA Packet was placed using jumbo algorithm. This 	 * means that the first buffer will be filled with data before 	 * moving to aggregation buffers. Each aggregation buffer will 	 * be filled before moving to the next aggregation buffer. 	 */
define|#
directive|define
name|RX_TPA_END_CMPL_FLAGS_PLACEMENT_JUMBO
value|(UINT32_C(0x1)<< 7)
comment|/* 	 * Header/Data Separation: Packet was placed using Header/Data 	 * separation algorithm. The separation location is indicated by 	 * the itype field. 	 */
define|#
directive|define
name|RX_TPA_END_CMPL_FLAGS_PLACEMENT_HDS
value|(UINT32_C(0x2)<< 7)
comment|/* 	 * GRO/Jumbo: Packet will be placed using GRO/Jumbo where the 	 * first packet is filled with data. Subsequent packets will be 	 * placed such that any one packet does not span two aggregation 	 * buffers unless it starts at the beginning of an aggregation 	 * buffer. 	 */
define|#
directive|define
name|RX_TPA_END_CMPL_FLAGS_PLACEMENT_GRO_JUMBO
value|(UINT32_C(0x5)<< 7)
comment|/* 	 * GRO/Header-Data Separation: Packet will be placed using 	 * GRO/HDS where the header is in the first packet. Payload of 	 * each packet will be placed such that any one packet does not 	 * span two aggregation buffers unless it starts at the 	 * beginning of an aggregation buffer. 	 */
define|#
directive|define
name|RX_TPA_END_CMPL_FLAGS_PLACEMENT_GRO_HDS
value|(UINT32_C(0x6)<< 7)
define|#
directive|define
name|RX_TPA_END_CMPL_FLAGS_PLACEMENT_LAST
value|RX_TPA_END_CMPL_FLAGS_PLACEMENT_GRO_HDS
comment|/* unused is 2 b */
define|#
directive|define
name|RX_TPA_END_CMPL_FLAGS_UNUSED_MASK
value|UINT32_C(0xc00)
define|#
directive|define
name|RX_TPA_END_CMPL_FLAGS_UNUSED_SFT
value|10
comment|/* 	 * This value indicates what the inner packet determined for the packet 	 * was. - 2 TCP Packet Indicates that the packet was IP and TCP. This 	 * indicates that the ip_cs field is valid and that the tcp_udp_cs field 	 * is valid and contains the TCP checksum. This also indicates that the 	 * payload_offset field is valid. 	 */
define|#
directive|define
name|RX_TPA_END_CMPL_FLAGS_ITYPE_MASK
value|UINT32_C(0xf000)
define|#
directive|define
name|RX_TPA_END_CMPL_FLAGS_ITYPE_SFT
value|12
define|#
directive|define
name|RX_TPA_END_CMPL_FLAGS_MASK
value|UINT32_C(0xffc0)
define|#
directive|define
name|RX_TPA_END_CMPL_FLAGS_SFT
value|6
name|uint16_t
name|len
decl_stmt|;
comment|/* 	 * This value is zero for TPA End completions. There is no data in the 	 * buffer that corresponds to the opaque value in this completion. 	 */
name|uint32_t
name|opaque
decl_stmt|;
comment|/* 	 * This is a copy of the opaque field from the RX BD this completion 	 * corresponds to. 	 */
name|uint8_t
name|agg_bufs_v1
decl_stmt|;
comment|/* unused1 is 1 b */
comment|/* 	 * This value is written by the NIC such that it will be different for 	 * each pass through the completion queue. The even passes will write 1. 	 * The odd passes will write 0. 	 */
define|#
directive|define
name|RX_TPA_END_CMPL_V1
value|UINT32_C(0x1)
comment|/* 	 * This value is the number of aggregation buffers that follow this 	 * entry in the completion ring that are a part of this aggregation 	 * packet. If the value is zero, then the packet is completely contained 	 * in the buffer space provided in the aggregation start completion. 	 */
define|#
directive|define
name|RX_TPA_END_CMPL_AGG_BUFS_MASK
value|UINT32_C(0x7e)
define|#
directive|define
name|RX_TPA_END_CMPL_AGG_BUFS_SFT
value|1
comment|/* unused1 is 1 b */
name|uint8_t
name|tpa_segs
decl_stmt|;
comment|/* This value is the number of segments in the TPA operation. */
name|uint8_t
name|payload_offset
decl_stmt|;
comment|/* 	 * This value indicates the offset in bytes from the beginning of the 	 * packet where the inner payload starts. This value is valid for TCP, 	 * UDP, FCoE, and RoCE packets. A value of zero indicates an offset of 	 * 256 bytes. 	 */
name|uint8_t
name|agg_id
decl_stmt|;
comment|/* 	 * This is the aggregation ID that the completion is associated with. 	 * Use this number to correlate the TPA start completion with the TPA 	 * end completion. 	 */
comment|/* unused2 is 1 b */
comment|/* 	 * This is the aggregation ID that the completion is associated with. 	 * Use this number to correlate the TPA start completion with the TPA 	 * end completion. 	 */
define|#
directive|define
name|RX_TPA_END_CMPL_AGG_ID_MASK
value|UINT32_C(0xfe)
define|#
directive|define
name|RX_TPA_END_CMPL_AGG_ID_SFT
value|1
name|uint32_t
name|tsdelta
decl_stmt|;
comment|/* 	 * For non-GRO packets, this value is the timestamp delta between 	 * earliest and latest timestamp values for TPA packet. If packets were 	 * not time stamped, then delta will be zero. For GRO packets, this 	 * field is zero except for the following sub-fields. - tsdelta[31] 	 * Timestamp present indication. When '0', no Timestamp option is in the 	 * packet. When '1', then a Timestamp option is present in the packet. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* last 16 bytes of RX TPA End Completion Record */
end_comment

begin_struct
struct|struct
name|rx_tpa_end_cmpl_hi
block|{
name|uint32_t
name|tpa_dup_acks
decl_stmt|;
comment|/* unused3 is 28 b */
comment|/* 	 * This value is the number of duplicate ACKs that have been received as 	 * part of the TPA operation. 	 */
define|#
directive|define
name|RX_TPA_END_CMPL_TPA_DUP_ACKS_MASK
value|UINT32_C(0xf)
define|#
directive|define
name|RX_TPA_END_CMPL_TPA_DUP_ACKS_SFT
value|0
comment|/* unused3 is 28 b */
name|uint16_t
name|tpa_seg_len
decl_stmt|;
comment|/* 	 * This value is the valid when TPA completion is active. It indicates 	 * the length of the longest segment of the TPA operation for LRO mode 	 * and the length of the first segment in GRO mode. This value may be 	 * used by GRO software to re-construct the original packet stream from 	 * the TPA packet. This is the length of all but the last segment for 	 * GRO. In LRO mode this value may be used to indicate MSS size to the 	 * stack. 	 */
name|uint16_t
name|unused_3
decl_stmt|;
comment|/* unused4 is 16 b */
name|uint16_t
name|errors_v2
decl_stmt|;
comment|/* 	 * This value is written by the NIC such that it will be different for 	 * each pass through the completion queue. The even passes will write 1. 	 * The odd passes will write 0. 	 */
define|#
directive|define
name|RX_TPA_END_CMPL_V2
value|UINT32_C(0x1)
comment|/* 	 * This error indicates that there was some sort of problem with the BDs 	 * for the packet that was found after part of the packet was already 	 * placed. The packet should be treated as invalid. 	 */
define|#
directive|define
name|RX_TPA_END_CMPL_ERRORS_BUFFER_ERROR_MASK
value|UINT32_C(0xe)
define|#
directive|define
name|RX_TPA_END_CMPL_ERRORS_BUFFER_ERROR_SFT
value|1
comment|/* 	 * This error occurs when there is a fatal HW problem in the 	 * chip only. It indicates that there were not BDs on chip but 	 * that there was adequate reservation. provided by the TPA 	 * block. 	 */
define|#
directive|define
name|RX_TPA_END_CMPL_ERRORS_BUFFER_ERROR_NOT_ON_CHIP
value|(UINT32_C(0x2)<< 1)
comment|/* 	 * This error occurs when TPA block was not configured to 	 * reserve adequate BDs for TPA operations on this RX ring. All 	 * data for the TPA operation was not placed. This error can 	 * also be generated when the number of segments is not 	 * programmed correctly in TPA and the 33 total aggregation 	 * buffers allowed for the TPA operation has been exceeded. 	 */
define|#
directive|define
name|RX_TPA_END_CMPL_ERRORS_BUFFER_ERROR_RSV_ERROR
value|(UINT32_C(0x4)<< 1)
define|#
directive|define
name|RX_TPA_END_CMPL_ERRORS_BUFFER_ERROR_LAST
value|RX_TPA_END_CMPL_ERRORS_BUFFER_ERROR_RSV_ERROR
define|#
directive|define
name|RX_TPA_END_CMPL_ERRORS_MASK
value|UINT32_C(0xfffe)
define|#
directive|define
name|RX_TPA_END_CMPL_ERRORS_SFT
value|1
name|uint16_t
name|unused_4
decl_stmt|;
comment|/* unused5 is 16 b */
name|uint32_t
name|start_opaque
decl_stmt|;
comment|/* 	 * This is the opaque value that was completed for the TPA start 	 * completion that corresponds to this TPA end completion. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* RX Aggregation Buffer Completion Record (16 bytes) */
end_comment

begin_struct
struct|struct
name|rx_abuf_cmpl
block|{
name|uint16_t
name|type
decl_stmt|;
comment|/* unused is 10 b */
comment|/* 	 * This field indicates the exact type of the completion. By convention, 	 * the LSB identifies the length of the record in 16B units. Even values 	 * indicate 16B records. Odd values indicate 32B records. 	 */
define|#
directive|define
name|RX_ABUF_CMPL_TYPE_MASK
value|UINT32_C(0x3f)
define|#
directive|define
name|RX_ABUF_CMPL_TYPE_SFT
value|0
comment|/* 	 * RX Aggregation Buffer completion : Completion of an L2 	 * aggregation buffer in support of TPA, HDS, or Jumbo packet 	 * completion. Length = 16B 	 */
define|#
directive|define
name|RX_ABUF_CMPL_TYPE_RX_AGG
value|UINT32_C(0x12)
comment|/* unused is 10 b */
name|uint16_t
name|len
decl_stmt|;
comment|/* 	 * This is the length of the data for the packet stored in this 	 * aggregation buffer identified by the opaque value. This does not 	 * include the length of any data placed in other aggregation BDs or in 	 * the packet or buffer BDs. This length does not include any space 	 * added due to hdr_offset register during HDS placement mode. 	 */
name|uint32_t
name|opaque
decl_stmt|;
comment|/* 	 * This is a copy of the opaque field from the RX BD this aggregation 	 * buffer corresponds to. 	 */
name|uint32_t
name|v
decl_stmt|;
comment|/* unused2 is 31 b */
comment|/* 	 * This value is written by the NIC such that it will be different for 	 * each pass through the completion queue. The even passes will write 1. 	 * The odd passes will write 0. 	 */
define|#
directive|define
name|RX_ABUF_CMPL_V
value|UINT32_C(0x1)
comment|/* unused2 is 31 b */
name|uint32_t
name|unused_2
decl_stmt|;
comment|/* unused3 is 32 b */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Statistics Ejection Buffer Completion Record (16 bytes) */
end_comment

begin_struct
struct|struct
name|eject_cmpl
block|{
name|uint16_t
name|type
decl_stmt|;
comment|/* unused is 10 b */
comment|/* 	 * This field indicates the exact type of the completion. By convention, 	 * the LSB identifies the length of the record in 16B units. Even values 	 * indicate 16B records. Odd values indicate 32B records. 	 */
define|#
directive|define
name|EJECT_CMPL_TYPE_MASK
value|UINT32_C(0x3f)
define|#
directive|define
name|EJECT_CMPL_TYPE_SFT
value|0
comment|/* 	 * Statistics Ejection Completion: Completion of statistics data 	 * ejection buffer. Length = 16B 	 */
define|#
directive|define
name|EJECT_CMPL_TYPE_STAT_EJECT
value|UINT32_C(0x1a)
comment|/* unused is 10 b */
name|uint16_t
name|len
decl_stmt|;
comment|/* This is the length of the statistics data stored in this buffer. */
name|uint32_t
name|opaque
decl_stmt|;
comment|/* 	 * This is a copy of the opaque field from the RX BD this ejection 	 * buffer corresponds to. 	 */
name|uint32_t
name|v
decl_stmt|;
comment|/* unused2 is 31 b */
comment|/* 	 * This value is written by the NIC such that it will be different for 	 * each pass through the completion queue. The even passes will write 1. 	 * The odd passes will write 0. 	 */
define|#
directive|define
name|EJECT_CMPL_V
value|UINT32_C(0x1)
comment|/* unused2 is 31 b */
name|uint32_t
name|unused_2
decl_stmt|;
comment|/* unused3 is 32 b */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* HWRM Completion Record (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_cmpl
block|{
name|uint16_t
name|type
decl_stmt|;
comment|/* unused is 10 b */
comment|/* 	 * This field indicates the exact type of the completion. By convention, 	 * the LSB identifies the length of the record in 16B units. Even values 	 * indicate 16B records. Odd values indicate 32B records. 	 */
define|#
directive|define
name|HWRM_CMPL_TYPE_MASK
value|UINT32_C(0x3f)
define|#
directive|define
name|HWRM_CMPL_TYPE_SFT
value|0
comment|/* HWRM Command Completion: Completion of an HWRM command. */
define|#
directive|define
name|HWRM_CMPL_TYPE_HWRM_DONE
value|UINT32_C(0x20)
comment|/* unused is 10 b */
name|uint16_t
name|sequence_id
decl_stmt|;
comment|/* This is the sequence_id of the HWRM command that has completed. */
name|uint32_t
name|unused_1
decl_stmt|;
comment|/* unused2 is 32 b */
name|uint32_t
name|v
decl_stmt|;
comment|/* unused3 is 31 b */
comment|/* 	 * This value is written by the NIC such that it will be different for 	 * each pass through the completion queue. The even passes will write 1. 	 * The odd passes will write 0. 	 */
define|#
directive|define
name|HWRM_CMPL_V
value|UINT32_C(0x1)
comment|/* unused3 is 31 b */
name|uint32_t
name|unused_3
decl_stmt|;
comment|/* unused4 is 32 b */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* HWRM Forwarded Request (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_fwd_req_cmpl
block|{
name|uint16_t
name|req_len_type
decl_stmt|;
comment|/* Length of forwarded request in bytes. */
comment|/* 	 * This field indicates the exact type of the completion. By convention, 	 * the LSB identifies the length of the record in 16B units. Even values 	 * indicate 16B records. Odd values indicate 32B records. 	 */
define|#
directive|define
name|HWRM_FWD_REQ_CMPL_TYPE_MASK
value|UINT32_C(0x3f)
define|#
directive|define
name|HWRM_FWD_REQ_CMPL_TYPE_SFT
value|0
comment|/* Forwarded HWRM Request */
define|#
directive|define
name|HWRM_FWD_REQ_CMPL_TYPE_HWRM_FWD_REQ
value|UINT32_C(0x22)
comment|/* Length of forwarded request in bytes. */
define|#
directive|define
name|HWRM_FWD_REQ_CMPL_REQ_LEN_MASK
value|UINT32_C(0xffc0)
define|#
directive|define
name|HWRM_FWD_REQ_CMPL_REQ_LEN_SFT
value|6
name|uint16_t
name|source_id
decl_stmt|;
comment|/* 	 * Source ID of this request. Typically used in forwarding requests and 	 * responses. 0x0 - 0xFFF8 - Used for function ids 0xFFF8 - 0xFFFE - 	 * Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint32_t
name|unused_0
decl_stmt|;
comment|/* unused1 is 32 b */
name|uint64_t
name|req_buf_addr_v
decl_stmt|;
comment|/* Address of forwarded request. */
comment|/* 	 * This value is written by the NIC such that it will be different for 	 * each pass through the completion queue. The even passes will write 1. 	 * The odd passes will write 0. 	 */
define|#
directive|define
name|HWRM_FWD_REQ_CMPL_V
value|UINT32_C(0x1)
comment|/* Address of forwarded request. */
define|#
directive|define
name|HWRM_FWD_REQ_CMPL_REQ_BUF_ADDR_MASK
value|UINT32_C(0xfffffffe)
define|#
directive|define
name|HWRM_FWD_REQ_CMPL_REQ_BUF_ADDR_SFT
value|1
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* HWRM Forwarded Response (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_fwd_resp_cmpl
block|{
name|uint16_t
name|type
decl_stmt|;
comment|/* unused1 is 10 b */
comment|/* 	 * This field indicates the exact type of the completion. By convention, 	 * the LSB identifies the length of the record in 16B units. Even values 	 * indicate 16B records. Odd values indicate 32B records. 	 */
define|#
directive|define
name|HWRM_FWD_RESP_CMPL_TYPE_MASK
value|UINT32_C(0x3f)
define|#
directive|define
name|HWRM_FWD_RESP_CMPL_TYPE_SFT
value|0
comment|/* Forwarded HWRM Response */
define|#
directive|define
name|HWRM_FWD_RESP_CMPL_TYPE_HWRM_FWD_RESP
value|UINT32_C(0x24)
comment|/* unused1 is 10 b */
name|uint16_t
name|source_id
decl_stmt|;
comment|/* 	 * Source ID of this response. Typically used in forwarding requests and 	 * responses. 0x0 - 0xFFF8 - Used for function ids 0xFFF8 - 0xFFFE - 	 * Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* Length of forwarded response in bytes. */
name|uint16_t
name|unused_1
decl_stmt|;
comment|/* unused2 is 16 b */
name|uint64_t
name|resp_buf_addr_v
decl_stmt|;
comment|/* Address of forwarded response. */
comment|/* 	 * This value is written by the NIC such that it will be different for 	 * each pass through the completion queue. The even passes will write 1. 	 * The odd passes will write 0. 	 */
define|#
directive|define
name|HWRM_FWD_RESP_CMPL_V
value|UINT32_C(0x1)
comment|/* Address of forwarded response. */
define|#
directive|define
name|HWRM_FWD_RESP_CMPL_RESP_BUF_ADDR_MASK
value|UINT32_C(0xfffffffe)
define|#
directive|define
name|HWRM_FWD_RESP_CMPL_RESP_BUF_ADDR_SFT
value|1
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_define
define|#
directive|define
name|GET_EVENT_ID
parameter_list|(
name|x
parameter_list|)
define|\
value|((x) == 0x30 ? "VF_FLR": \ 	((x) == 0x20 ? "PF_DRVR_UNLOAD": \ 	((x) == 0x10 ? "FUNC_DRVR_UNLOAD": \ 	((x) == 0xff ? "HWRM_ERROR": \ 	((x) == 0x32 ? "PF_VF_COMM_STATUS_CHANGE": \ 	((x) == 0x33 ? "VF_CFG_CHANGE": \ 	((x) == 0x11 ? "FUNC_DRVR_LOAD": \ 	((x) == 0x31 ? "VF_MAC_ADDR_CHANGE": \ 	((x) == 0x34 ? "LLFC_PFC_CHANGE": \ 	((x) == 0x4 ? "PORT_CONN_NOT_ALLOWED": \ 	((x) == 0x5 ? "LINK_SPEED_CFG_NOT_ALLOWED": \ 	((x) == 0x6 ? "LINK_SPEED_CFG_CHANGE": \ 	((x) == 0x7 ? "PORT_PHY_CFG_CHANGE": \ 	((x) == 0x0 ? "LINK_STATUS_CHANGE": \ 	((x) == 0x1 ? "LINK_MTU_CHANGE": \ 	((x) == 0x2 ? "LINK_SPEED_CHANGE": \ 	((x) == 0x3 ? "DCB_CONFIG_CHANGE": \ 	((x) == 0x12 ? "FUNC_FLR_PROC_CMPLT": \ 	((x) == 0x21 ? "PF_DRVR_LOAD": \ 	"Unknown event_id")))))))))))))))))))
end_define

begin_comment
comment|/* HWRM Asynchronous Event Completion Record (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_async_event_cmpl
block|{
name|uint16_t
name|type
decl_stmt|;
comment|/* unused1 is 10 b */
comment|/* 	 * This field indicates the exact type of the completion. By convention, 	 * the LSB identifies the length of the record in 16B units. Even values 	 * indicate 16B records. Odd values indicate 32B records. 	 */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_TYPE_MASK
value|UINT32_C(0x3f)
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_TYPE_SFT
value|0
comment|/* HWRM Asynchronous Event Information */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_TYPE_HWRM_ASYNC_EVENT
value|UINT32_C(0x2e)
comment|/* unused1 is 10 b */
name|uint16_t
name|event_id
decl_stmt|;
comment|/* Identifiers of events. */
comment|/* Link status changed */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_EVENT_ID_LINK_STATUS_CHANGE
value|UINT32_C(0x0)
comment|/* Link MTU changed */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_EVENT_ID_LINK_MTU_CHANGE
value|UINT32_C(0x1)
comment|/* Link speed changed */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_EVENT_ID_LINK_SPEED_CHANGE
value|UINT32_C(0x2)
comment|/* DCB Configuration changed */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_EVENT_ID_DCB_CONFIG_CHANGE
value|UINT32_C(0x3)
comment|/* Port connection not allowed */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_EVENT_ID_PORT_CONN_NOT_ALLOWED
value|UINT32_C(0x4)
comment|/* Link speed configuration was not allowed */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_EVENT_ID_LINK_SPEED_CFG_NOT_ALLOWED
value|UINT32_C(0x5)
comment|/* Link speed configuration change */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_EVENT_ID_LINK_SPEED_CFG_CHANGE
value|UINT32_C(0x6)
comment|/* Port PHY configuration change */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_EVENT_ID_PORT_PHY_CFG_CHANGE
value|UINT32_C(0x7)
comment|/* Function driver unloaded */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_EVENT_ID_FUNC_DRVR_UNLOAD
value|UINT32_C(0x10)
comment|/* Function driver loaded */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_EVENT_ID_FUNC_DRVR_LOAD
value|UINT32_C(0x11)
comment|/* Function FLR related processing has completed */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_EVENT_ID_FUNC_FLR_PROC_CMPLT
value|UINT32_C(0x12)
comment|/* PF driver unloaded */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_EVENT_ID_PF_DRVR_UNLOAD
value|UINT32_C(0x20)
comment|/* PF driver loaded */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_EVENT_ID_PF_DRVR_LOAD
value|UINT32_C(0x21)
comment|/* VF Function Level Reset (FLR) */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_EVENT_ID_VF_FLR
value|UINT32_C(0x30)
comment|/* VF MAC Address Change */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_EVENT_ID_VF_MAC_ADDR_CHANGE
value|UINT32_C(0x31)
comment|/* PF-VF communication channel status change. */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_EVENT_ID_PF_VF_COMM_STATUS_CHANGE
value|UINT32_C(0x32)
comment|/* VF Configuration Change */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_EVENT_ID_VF_CFG_CHANGE
value|UINT32_C(0x33)
comment|/* LLFC/PFC Configuration Change */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_EVENT_ID_LLFC_PFC_CHANGE
value|UINT32_C(0x34)
comment|/* HWRM Error */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_EVENT_ID_HWRM_ERROR
value|UINT32_C(0xff)
name|uint32_t
name|event_data2
decl_stmt|;
comment|/* Event specific data */
name|uint8_t
name|opaque_v
decl_stmt|;
comment|/* opaque is 7 b */
comment|/* 	 * This value is written by the NIC such that it will be different for 	 * each pass through the completion queue. The even passes will write 1. 	 * The odd passes will write 0. 	 */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_V
value|UINT32_C(0x1)
comment|/* opaque is 7 b */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_OPAQUE_MASK
value|UINT32_C(0xfe)
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_OPAQUE_SFT
value|1
name|uint8_t
name|timestamp_lo
decl_stmt|;
comment|/* 8-lsb timestamp from POR (100-msec resolution) */
name|uint16_t
name|timestamp_hi
decl_stmt|;
comment|/* 16-lsb timestamp from POR (100-msec resolution) */
name|uint32_t
name|event_data1
decl_stmt|;
comment|/* Event specific data */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* HWRM Asynchronous Event Completion Record for link status change (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_async_event_cmpl_link_status_change
block|{
name|uint16_t
name|type
decl_stmt|;
comment|/* unused1 is 10 b */
comment|/* 	 * This field indicates the exact type of the completion. By convention, 	 * the LSB identifies the length of the record in 16B units. Even values 	 * indicate 16B records. Odd values indicate 32B records. 	 */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_LINK_STATUS_CHANGE_TYPE_MASK
value|UINT32_C(0x3f)
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_LINK_STATUS_CHANGE_TYPE_SFT
value|0
comment|/* HWRM Asynchronous Event Information */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_LINK_STATUS_CHANGE_TYPE_HWRM_ASYNC_EVENT
value|UINT32_C(0x2e)
comment|/* unused1 is 10 b */
name|uint16_t
name|event_id
decl_stmt|;
comment|/* Identifiers of events. */
comment|/* Link status changed */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_LINK_STATUS_CHANGE_EVENT_ID_LINK_STATUS_CHANGE
value|UINT32_C(0x0)
name|uint32_t
name|event_data2
decl_stmt|;
comment|/* Event specific data */
name|uint8_t
name|opaque_v
decl_stmt|;
comment|/* opaque is 7 b */
comment|/* 	 * This value is written by the NIC such that it will be different for 	 * each pass through the completion queue. The even passes will write 1. 	 * The odd passes will write 0. 	 */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_LINK_STATUS_CHANGE_V
value|UINT32_C(0x1)
comment|/* opaque is 7 b */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_LINK_STATUS_CHANGE_OPAQUE_MASK
value|UINT32_C(0xfe)
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_LINK_STATUS_CHANGE_OPAQUE_SFT
value|1
name|uint8_t
name|timestamp_lo
decl_stmt|;
comment|/* 8-lsb timestamp from POR (100-msec resolution) */
name|uint16_t
name|timestamp_hi
decl_stmt|;
comment|/* 16-lsb timestamp from POR (100-msec resolution) */
name|uint32_t
name|event_data1
decl_stmt|;
comment|/* Event specific data */
comment|/* Indicates link status change */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_LINK_STATUS_CHANGE_EVENT_DATA1_LINK_CHANGE
value|UINT32_C(0x1)
comment|/* 	 * If this bit set to 0, then it indicates that the link was up 	 * and it went down. 	 */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_LINK_STATUS_CHANGE_EVENT_DATA1_LINK_CHANGE_DOWN
value|(UINT32_C(0x0)<< 0)
comment|/* 	 * If this bit is set to 1, then it indicates that the link was 	 * down and it went up. 	 */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_LINK_STATUS_CHANGE_EVENT_DATA1_LINK_CHANGE_UP
value|(UINT32_C(0x1)<< 0)
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_LINK_STATUS_CHANGE_EVENT_DATA1_LINK_CHANGE_LAST
value|HWRM_ASYNC_EVENT_CMPL_LINK_STATUS_CHANGE_EVENT_DATA1_LINK_CHANGE_UP
comment|/* Indicates the physical port this link status change occur */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_LINK_STATUS_CHANGE_EVENT_DATA1_PORT_MASK
value|UINT32_C(0xe)
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_LINK_STATUS_CHANGE_EVENT_DATA1_PORT_SFT
value|1
comment|/* PORT ID */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_LINK_STATUS_CHANGE_EVENT_DATA1_PORT_ID_MASK
value|UINT32_C(0xffff0)
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_LINK_STATUS_CHANGE_EVENT_DATA1_PORT_ID_SFT
value|4
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* HWRM Asynchronous Event Completion Record for link MTU change (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_async_event_cmpl_link_mtu_change
block|{
name|uint16_t
name|type
decl_stmt|;
comment|/* unused1 is 10 b */
comment|/* 	 * This field indicates the exact type of the completion. By convention, 	 * the LSB identifies the length of the record in 16B units. Even values 	 * indicate 16B records. Odd values indicate 32B records. 	 */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_LINK_MTU_CHANGE_TYPE_MASK
value|UINT32_C(0x3f)
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_LINK_MTU_CHANGE_TYPE_SFT
value|0
comment|/* HWRM Asynchronous Event Information */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_LINK_MTU_CHANGE_TYPE_HWRM_ASYNC_EVENT
value|UINT32_C(0x2e)
comment|/* unused1 is 10 b */
name|uint16_t
name|event_id
decl_stmt|;
comment|/* Identifiers of events. */
comment|/* Link MTU changed */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_LINK_MTU_CHANGE_EVENT_ID_LINK_MTU_CHANGE
value|UINT32_C(0x1)
name|uint32_t
name|event_data2
decl_stmt|;
comment|/* Event specific data */
name|uint8_t
name|opaque_v
decl_stmt|;
comment|/* opaque is 7 b */
comment|/* 	 * This value is written by the NIC such that it will be different for 	 * each pass through the completion queue. The even passes will write 1. 	 * The odd passes will write 0. 	 */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_LINK_MTU_CHANGE_V
value|UINT32_C(0x1)
comment|/* opaque is 7 b */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_LINK_MTU_CHANGE_OPAQUE_MASK
value|UINT32_C(0xfe)
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_LINK_MTU_CHANGE_OPAQUE_SFT
value|1
name|uint8_t
name|timestamp_lo
decl_stmt|;
comment|/* 8-lsb timestamp from POR (100-msec resolution) */
name|uint16_t
name|timestamp_hi
decl_stmt|;
comment|/* 16-lsb timestamp from POR (100-msec resolution) */
name|uint32_t
name|event_data1
decl_stmt|;
comment|/* Event specific data */
comment|/* The new MTU of the link in bytes. */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_LINK_MTU_CHANGE_EVENT_DATA1_NEW_MTU_MASK
value|UINT32_C(0xffff)
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_LINK_MTU_CHANGE_EVENT_DATA1_NEW_MTU_SFT
value|0
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* HWRM Asynchronous Event Completion Record for link speed change (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_async_event_cmpl_link_speed_change
block|{
name|uint16_t
name|type
decl_stmt|;
comment|/* unused1 is 10 b */
comment|/* 	 * This field indicates the exact type of the completion. By convention, 	 * the LSB identifies the length of the record in 16B units. Even values 	 * indicate 16B records. Odd values indicate 32B records. 	 */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CHANGE_TYPE_MASK
value|UINT32_C(0x3f)
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CHANGE_TYPE_SFT
value|0
comment|/* HWRM Asynchronous Event Information */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CHANGE_TYPE_HWRM_ASYNC_EVENT
value|UINT32_C(0x2e)
comment|/* unused1 is 10 b */
name|uint16_t
name|event_id
decl_stmt|;
comment|/* Identifiers of events. */
comment|/* Link speed changed */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CHANGE_EVENT_ID_LINK_SPEED_CHANGE
value|UINT32_C(0x2)
name|uint32_t
name|event_data2
decl_stmt|;
comment|/* Event specific data */
name|uint8_t
name|opaque_v
decl_stmt|;
comment|/* opaque is 7 b */
comment|/* 	 * This value is written by the NIC such that it will be different for 	 * each pass through the completion queue. The even passes will write 1. 	 * The odd passes will write 0. 	 */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CHANGE_V
value|UINT32_C(0x1)
comment|/* opaque is 7 b */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CHANGE_OPAQUE_MASK
value|UINT32_C(0xfe)
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CHANGE_OPAQUE_SFT
value|1
name|uint8_t
name|timestamp_lo
decl_stmt|;
comment|/* 8-lsb timestamp from POR (100-msec resolution) */
name|uint16_t
name|timestamp_hi
decl_stmt|;
comment|/* 16-lsb timestamp from POR (100-msec resolution) */
name|uint32_t
name|event_data1
decl_stmt|;
comment|/* Event specific data */
comment|/* 	 * When this bit is '1', the link was forced to the force_link_speed 	 * value. 	 */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CHANGE_EVENT_DATA1_FORCE
value|UINT32_C(0x1)
comment|/* The new link speed in 100 Mbps units. */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CHANGE_EVENT_DATA1_NEW_LINK_SPEED_100MBPS_MASK
value|UINT32_C(0xfffe)
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CHANGE_EVENT_DATA1_NEW_LINK_SPEED_100MBPS_SFT
value|1
comment|/* 100Mb link speed */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CHANGE_EVENT_DATA1_NEW_LINK_SPEED_100MBPS_100MB
value|(UINT32_C(0x1)<< 1)
comment|/* 1Gb link speed */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CHANGE_EVENT_DATA1_NEW_LINK_SPEED_100MBPS_1GB
value|(UINT32_C(0xa)<< 1)
comment|/* 2Gb link speed */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CHANGE_EVENT_DATA1_NEW_LINK_SPEED_100MBPS_2GB
value|(UINT32_C(0x14)<< 1)
comment|/* 2.5Gb link speed */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CHANGE_EVENT_DATA1_NEW_LINK_SPEED_100MBPS_2_5GB
value|(UINT32_C(0x19)<< 1)
comment|/* 10Gb link speed */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CHANGE_EVENT_DATA1_NEW_LINK_SPEED_100MBPS_10GB
value|(UINT32_C(0x64)<< 1)
comment|/* 20Mb link speed */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CHANGE_EVENT_DATA1_NEW_LINK_SPEED_100MBPS_20GB
value|(UINT32_C(0xc8)<< 1)
comment|/* 25Gb link speed */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CHANGE_EVENT_DATA1_NEW_LINK_SPEED_100MBPS_25GB
value|(UINT32_C(0xfa)<< 1)
comment|/* 40Gb link speed */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CHANGE_EVENT_DATA1_NEW_LINK_SPEED_100MBPS_40GB
value|(UINT32_C(0x190)<< 1)
comment|/* 50Gb link speed */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CHANGE_EVENT_DATA1_NEW_LINK_SPEED_100MBPS_50GB
value|(UINT32_C(0x1f4)<< 1)
comment|/* 100Gb link speed */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CHANGE_EVENT_DATA1_NEW_LINK_SPEED_100MBPS_100GB
value|(UINT32_C(0x3e8)<< 1)
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CHANGE_EVENT_DATA1_NEW_LINK_SPEED_100MBPS_LAST
value|HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CHANGE_EVENT_DATA1_NEW_LINK_SPEED_100MBPS_100GB
comment|/* PORT ID */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CHANGE_EVENT_DATA1_PORT_ID_MASK
value|UINT32_C(0xffff0000)
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CHANGE_EVENT_DATA1_PORT_ID_SFT
value|16
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* HWRM Asynchronous Event Completion Record for DCB Config change (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_async_event_cmpl_dcb_config_change
block|{
name|uint16_t
name|type
decl_stmt|;
comment|/* unused1 is 10 b */
comment|/* 	 * This field indicates the exact type of the completion. By convention, 	 * the LSB identifies the length of the record in 16B units. Even values 	 * indicate 16B records. Odd values indicate 32B records. 	 */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_DCB_CONFIG_CHANGE_TYPE_MASK
value|UINT32_C(0x3f)
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_DCB_CONFIG_CHANGE_TYPE_SFT
value|0
comment|/* HWRM Asynchronous Event Information */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_DCB_CONFIG_CHANGE_TYPE_HWRM_ASYNC_EVENT
value|UINT32_C(0x2e)
comment|/* unused1 is 10 b */
name|uint16_t
name|event_id
decl_stmt|;
comment|/* Identifiers of events. */
comment|/* DCB Configuration changed */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_DCB_CONFIG_CHANGE_EVENT_ID_DCB_CONFIG_CHANGE
value|UINT32_C(0x3)
name|uint32_t
name|event_data2
decl_stmt|;
comment|/* Event specific data */
comment|/* ETS configuration change */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_DCB_CONFIG_CHANGE_EVENT_DATA2_ETS
value|UINT32_C(0x1)
comment|/* PFC configuration change */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_DCB_CONFIG_CHANGE_EVENT_DATA2_PFC
value|UINT32_C(0x2)
comment|/* APP configuration change */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_DCB_CONFIG_CHANGE_EVENT_DATA2_APP
value|UINT32_C(0x4)
name|uint8_t
name|opaque_v
decl_stmt|;
comment|/* opaque is 7 b */
comment|/* 	 * This value is written by the NIC such that it will be different for 	 * each pass through the completion queue. The even passes will write 1. 	 * The odd passes will write 0. 	 */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_DCB_CONFIG_CHANGE_V
value|UINT32_C(0x1)
comment|/* opaque is 7 b */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_DCB_CONFIG_CHANGE_OPAQUE_MASK
value|UINT32_C(0xfe)
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_DCB_CONFIG_CHANGE_OPAQUE_SFT
value|1
name|uint8_t
name|timestamp_lo
decl_stmt|;
comment|/* 8-lsb timestamp from POR (100-msec resolution) */
name|uint16_t
name|timestamp_hi
decl_stmt|;
comment|/* 16-lsb timestamp from POR (100-msec resolution) */
name|uint32_t
name|event_data1
decl_stmt|;
comment|/* Event specific data */
comment|/* PORT ID */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_DCB_CONFIG_CHANGE_EVENT_DATA1_PORT_ID_MASK
value|UINT32_C(0xffff)
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_DCB_CONFIG_CHANGE_EVENT_DATA1_PORT_ID_SFT
value|0
comment|/* Priority recommended for RoCE traffic */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_DCB_CONFIG_CHANGE_EVENT_DATA1_RECOMMEND_ROCE_PRIORITY_MASK
value|UINT32_C(0xff0000)
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_DCB_CONFIG_CHANGE_EVENT_DATA1_RECOMMEND_ROCE_PRIORITY_SFT
value|16
comment|/* none is 255 */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_DCB_CONFIG_CHANGE_EVENT_DATA1_RECOMMEND_ROCE_PRIORITY_NONE
value|(UINT32_C(0xff)<< 16)
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_DCB_CONFIG_CHANGE_EVENT_DATA1_RECOMMEND_ROCE_PRIORITY_LAST
value|HWRM_ASYNC_EVENT_CMPL_DCB_CONFIG_CHANGE_EVENT_DATA1_RECOMMEND_ROCE_PRIORITY_NONE
comment|/* Priority recommended for L2 traffic */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_DCB_CONFIG_CHANGE_EVENT_DATA1_RECOMMEND_L2_PRIORITY_MASK
value|UINT32_C(0xff000000)
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_DCB_CONFIG_CHANGE_EVENT_DATA1_RECOMMEND_L2_PRIORITY_SFT
value|24
comment|/* none is 255 */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_DCB_CONFIG_CHANGE_EVENT_DATA1_RECOMMEND_L2_PRIORITY_NONE
value|(UINT32_C(0xff)<< 24)
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_DCB_CONFIG_CHANGE_EVENT_DATA1_RECOMMEND_L2_PRIORITY_LAST
value|HWRM_ASYNC_EVENT_CMPL_DCB_CONFIG_CHANGE_EVENT_DATA1_RECOMMEND_L2_PRIORITY_NONE
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* HWRM Asynchronous Event Completion Record for port connection not allowed (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_async_event_cmpl_port_conn_not_allowed
block|{
name|uint16_t
name|type
decl_stmt|;
comment|/* unused1 is 10 b */
comment|/* 	 * This field indicates the exact type of the completion. By convention, 	 * the LSB identifies the length of the record in 16B units. Even values 	 * indicate 16B records. Odd values indicate 32B records. 	 */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_PORT_CONN_NOT_ALLOWED_TYPE_MASK
value|UINT32_C(0x3f)
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_PORT_CONN_NOT_ALLOWED_TYPE_SFT
value|0
comment|/* HWRM Asynchronous Event Information */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_PORT_CONN_NOT_ALLOWED_TYPE_HWRM_ASYNC_EVENT
value|UINT32_C(0x2e)
comment|/* unused1 is 10 b */
name|uint16_t
name|event_id
decl_stmt|;
comment|/* Identifiers of events. */
comment|/* Port connection not allowed */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_PORT_CONN_NOT_ALLOWED_EVENT_ID_PORT_CONN_NOT_ALLOWED
value|UINT32_C(0x4)
name|uint32_t
name|event_data2
decl_stmt|;
comment|/* Event specific data */
name|uint8_t
name|opaque_v
decl_stmt|;
comment|/* opaque is 7 b */
comment|/* 	 * This value is written by the NIC such that it will be different for 	 * each pass through the completion queue. The even passes will write 1. 	 * The odd passes will write 0. 	 */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_PORT_CONN_NOT_ALLOWED_V
value|UINT32_C(0x1)
comment|/* opaque is 7 b */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_PORT_CONN_NOT_ALLOWED_OPAQUE_MASK
value|UINT32_C(0xfe)
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_PORT_CONN_NOT_ALLOWED_OPAQUE_SFT
value|1
name|uint8_t
name|timestamp_lo
decl_stmt|;
comment|/* 8-lsb timestamp from POR (100-msec resolution) */
name|uint16_t
name|timestamp_hi
decl_stmt|;
comment|/* 16-lsb timestamp from POR (100-msec resolution) */
name|uint32_t
name|event_data1
decl_stmt|;
comment|/* Event specific data */
comment|/* PORT ID */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_PORT_CONN_NOT_ALLOWED_EVENT_DATA1_PORT_ID_MASK
value|UINT32_C(0xffff)
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_PORT_CONN_NOT_ALLOWED_EVENT_DATA1_PORT_ID_SFT
value|0
comment|/* 	 * This value indicates the current port level enforcement policy for 	 * the optics module when there is an optical module mismatch and port 	 * is not connected. 	 */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_PORT_CONN_NOT_ALLOWED_EVENT_DATA1_ENFORCEMENT_POLICY_MASK
value|UINT32_C(0xff0000)
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_PORT_CONN_NOT_ALLOWED_EVENT_DATA1_ENFORCEMENT_POLICY_SFT
value|16
comment|/* No enforcement */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_PORT_CONN_NOT_ALLOWED_EVENT_DATA1_ENFORCEMENT_POLICY_NONE
value|(UINT32_C(0x0)<< 16)
comment|/* Disable Transmit side Laser. */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_PORT_CONN_NOT_ALLOWED_EVENT_DATA1_ENFORCEMENT_POLICY_DISABLETX
value|(UINT32_C(0x1)<< 16)
comment|/* Raise a warning message. */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_PORT_CONN_NOT_ALLOWED_EVENT_DATA1_ENFORCEMENT_POLICY_WARNINGMSG
value|(UINT32_C(0x2)<< 16)
comment|/* Power down the module. */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_PORT_CONN_NOT_ALLOWED_EVENT_DATA1_ENFORCEMENT_POLICY_PWRDOWN
value|(UINT32_C(0x3)<< 16)
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_PORT_CONN_NOT_ALLOWED_EVENT_DATA1_ENFORCEMENT_POLICY_LAST
value|HWRM_ASYNC_EVENT_CMPL_PORT_CONN_NOT_ALLOWED_EVENT_DATA1_ENFORCEMENT_POLICY_PWRDOWN
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* HWRM Asynchronous Event Completion Record for link speed config not allowed (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_async_event_cmpl_link_speed_cfg_not_allowed
block|{
name|uint16_t
name|type
decl_stmt|;
comment|/* unused1 is 10 b */
comment|/* 	 * This field indicates the exact type of the completion. By convention, 	 * the LSB identifies the length of the record in 16B units. Even values 	 * indicate 16B records. Odd values indicate 32B records. 	 */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CFG_NOT_ALLOWED_TYPE_MASK
value|UINT32_C(0x3f)
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CFG_NOT_ALLOWED_TYPE_SFT
value|0
comment|/* HWRM Asynchronous Event Information */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CFG_NOT_ALLOWED_TYPE_HWRM_ASYNC_EVENT
value|UINT32_C(0x2e)
comment|/* unused1 is 10 b */
name|uint16_t
name|event_id
decl_stmt|;
comment|/* Identifiers of events. */
comment|/* Link speed configuration was not allowed */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CFG_NOT_ALLOWED_EVENT_ID_LINK_SPEED_CFG_NOT_ALLOWED
value|UINT32_C(0x5)
name|uint32_t
name|event_data2
decl_stmt|;
comment|/* Event specific data */
name|uint8_t
name|opaque_v
decl_stmt|;
comment|/* opaque is 7 b */
comment|/* 	 * This value is written by the NIC such that it will be different for 	 * each pass through the completion queue. The even passes will write 1. 	 * The odd passes will write 0. 	 */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CFG_NOT_ALLOWED_V
value|UINT32_C(0x1)
comment|/* opaque is 7 b */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CFG_NOT_ALLOWED_OPAQUE_MASK
value|UINT32_C(0xfe)
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CFG_NOT_ALLOWED_OPAQUE_SFT
value|1
name|uint8_t
name|timestamp_lo
decl_stmt|;
comment|/* 8-lsb timestamp from POR (100-msec resolution) */
name|uint16_t
name|timestamp_hi
decl_stmt|;
comment|/* 16-lsb timestamp from POR (100-msec resolution) */
name|uint32_t
name|event_data1
decl_stmt|;
comment|/* Event specific data */
comment|/* PORT ID */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CFG_NOT_ALLOWED_EVENT_DATA1_PORT_ID_MASK
value|UINT32_C(0xffff)
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CFG_NOT_ALLOWED_EVENT_DATA1_PORT_ID_SFT
value|0
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* HWRM Asynchronous Event Completion Record for link speed configuration change (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_async_event_cmpl_link_speed_cfg_change
block|{
name|uint16_t
name|type
decl_stmt|;
comment|/* unused1 is 10 b */
comment|/* 	 * This field indicates the exact type of the completion. By convention, 	 * the LSB identifies the length of the record in 16B units. Even values 	 * indicate 16B records. Odd values indicate 32B records. 	 */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CFG_CHANGE_TYPE_MASK
value|UINT32_C(0x3f)
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CFG_CHANGE_TYPE_SFT
value|0
comment|/* HWRM Asynchronous Event Information */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CFG_CHANGE_TYPE_HWRM_ASYNC_EVENT
value|UINT32_C(0x2e)
comment|/* unused1 is 10 b */
name|uint16_t
name|event_id
decl_stmt|;
comment|/* Identifiers of events. */
comment|/* Link speed configuration change */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CFG_CHANGE_EVENT_ID_LINK_SPEED_CFG_CHANGE
value|UINT32_C(0x6)
name|uint32_t
name|event_data2
decl_stmt|;
comment|/* Event specific data */
name|uint8_t
name|opaque_v
decl_stmt|;
comment|/* opaque is 7 b */
comment|/* 	 * This value is written by the NIC such that it will be different for 	 * each pass through the completion queue. The even passes will write 1. 	 * The odd passes will write 0. 	 */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CFG_CHANGE_V
value|UINT32_C(0x1)
comment|/* opaque is 7 b */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CFG_CHANGE_OPAQUE_MASK
value|UINT32_C(0xfe)
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CFG_CHANGE_OPAQUE_SFT
value|1
name|uint8_t
name|timestamp_lo
decl_stmt|;
comment|/* 8-lsb timestamp from POR (100-msec resolution) */
name|uint16_t
name|timestamp_hi
decl_stmt|;
comment|/* 16-lsb timestamp from POR (100-msec resolution) */
name|uint32_t
name|event_data1
decl_stmt|;
comment|/* Event specific data */
comment|/* PORT ID */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CFG_CHANGE_EVENT_DATA1_PORT_ID_MASK
value|UINT32_C(0xffff)
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CFG_CHANGE_EVENT_DATA1_PORT_ID_SFT
value|0
comment|/* 	 * If set to 1, it indicates that the supported link speeds 	 * configuration on the port has changed. If set to 0, then there is no 	 * change in supported link speeds configuration. 	 */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CFG_CHANGE_EVENT_DATA1_SUPPORTED_LINK_SPEEDS_CHANGE
value|UINT32_C(0x10000)
comment|/* 	 * If set to 1, it indicates that the link speed configuration on the 	 * port has become illegal or invalid. If set to 0, then the link speed 	 * configuration on the port is legal or valid. 	 */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CFG_CHANGE_EVENT_DATA1_ILLEGAL_LINK_SPEED_CFG
value|UINT32_C(0x20000)
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* HWRM Asynchronous Event Completion Record for port PHY configuration change (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_async_event_cmpl_port_phy_cfg_change
block|{
name|uint16_t
name|type
decl_stmt|;
comment|/* unused1 is 10 b */
comment|/* 	 * This field indicates the exact type of the completion. By convention, 	 * the LSB identifies the length of the record in 16B units. Even values 	 * indicate 16B records. Odd values indicate 32B records. 	 */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_PORT_PHY_CFG_CHANGE_TYPE_MASK
value|UINT32_C(0x3f)
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_PORT_PHY_CFG_CHANGE_TYPE_SFT
value|0
comment|/* HWRM Asynchronous Event Information */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_PORT_PHY_CFG_CHANGE_TYPE_HWRM_ASYNC_EVENT
value|UINT32_C(0x2e)
comment|/* unused1 is 10 b */
name|uint16_t
name|event_id
decl_stmt|;
comment|/* Identifiers of events. */
comment|/* Port PHY configuration change */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_PORT_PHY_CFG_CHANGE_EVENT_ID_PORT_PHY_CFG_CHANGE
value|UINT32_C(0x7)
name|uint32_t
name|event_data2
decl_stmt|;
comment|/* Event specific data */
name|uint8_t
name|opaque_v
decl_stmt|;
comment|/* opaque is 7 b */
comment|/* 	 * This value is written by the NIC such that it will be different for 	 * each pass through the completion queue. The even passes will write 1. 	 * The odd passes will write 0. 	 */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_PORT_PHY_CFG_CHANGE_V
value|UINT32_C(0x1)
comment|/* opaque is 7 b */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_PORT_PHY_CFG_CHANGE_OPAQUE_MASK
value|UINT32_C(0xfe)
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_PORT_PHY_CFG_CHANGE_OPAQUE_SFT
value|1
name|uint8_t
name|timestamp_lo
decl_stmt|;
comment|/* 8-lsb timestamp from POR (100-msec resolution) */
name|uint16_t
name|timestamp_hi
decl_stmt|;
comment|/* 16-lsb timestamp from POR (100-msec resolution) */
name|uint32_t
name|event_data1
decl_stmt|;
comment|/* Event specific data */
comment|/* PORT ID */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_PORT_PHY_CFG_CHANGE_EVENT_DATA1_PORT_ID_MASK
value|UINT32_C(0xffff)
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_PORT_PHY_CFG_CHANGE_EVENT_DATA1_PORT_ID_SFT
value|0
comment|/* 	 * If set to 1, it indicates that the FEC configuration on the port has 	 * changed. If set to 0, then there is no change in FEC configuration. 	 */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_PORT_PHY_CFG_CHANGE_EVENT_DATA1_FEC_CFG_CHANGE
value|UINT32_C(0x10000)
comment|/* 	 * If set to 1, it indicates that the EEE configuration on the port has 	 * changed. If set to 0, then there is no change in EEE configuration on 	 * the port. 	 */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_PORT_PHY_CFG_CHANGE_EVENT_DATA1_EEE_CFG_CHANGE
value|UINT32_C(0x20000)
comment|/* 	 * If set to 1, it indicates that the pause configuration on the PHY has 	 * changed. If set to 0, then there is no change in the pause 	 * configuration on the PHY. 	 */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_PORT_PHY_CFG_CHANGE_EVENT_DATA1_PAUSE_CFG_CHANGE
value|UINT32_C(0x40000)
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* HWRM Asynchronous Event Completion Record for Function Driver Unload (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_async_event_cmpl_func_drvr_unload
block|{
name|uint16_t
name|type
decl_stmt|;
comment|/* unused1 is 10 b */
comment|/* 	 * This field indicates the exact type of the completion. By convention, 	 * the LSB identifies the length of the record in 16B units. Even values 	 * indicate 16B records. Odd values indicate 32B records. 	 */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_FUNC_DRVR_UNLOAD_TYPE_MASK
value|UINT32_C(0x3f)
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_FUNC_DRVR_UNLOAD_TYPE_SFT
value|0
comment|/* HWRM Asynchronous Event Information */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_FUNC_DRVR_UNLOAD_TYPE_HWRM_ASYNC_EVENT
value|UINT32_C(0x2e)
comment|/* unused1 is 10 b */
name|uint16_t
name|event_id
decl_stmt|;
comment|/* Identifiers of events. */
comment|/* Function driver unloaded */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_FUNC_DRVR_UNLOAD_EVENT_ID_FUNC_DRVR_UNLOAD
value|UINT32_C(0x10)
name|uint32_t
name|event_data2
decl_stmt|;
comment|/* Event specific data */
name|uint8_t
name|opaque_v
decl_stmt|;
comment|/* opaque is 7 b */
comment|/* 	 * This value is written by the NIC such that it will be different for 	 * each pass through the completion queue. The even passes will write 1. 	 * The odd passes will write 0. 	 */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_FUNC_DRVR_UNLOAD_V
value|UINT32_C(0x1)
comment|/* opaque is 7 b */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_FUNC_DRVR_UNLOAD_OPAQUE_MASK
value|UINT32_C(0xfe)
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_FUNC_DRVR_UNLOAD_OPAQUE_SFT
value|1
name|uint8_t
name|timestamp_lo
decl_stmt|;
comment|/* 8-lsb timestamp from POR (100-msec resolution) */
name|uint16_t
name|timestamp_hi
decl_stmt|;
comment|/* 16-lsb timestamp from POR (100-msec resolution) */
name|uint32_t
name|event_data1
decl_stmt|;
comment|/* Event specific data */
comment|/* Function ID */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_FUNC_DRVR_UNLOAD_EVENT_DATA1_FUNC_ID_MASK
value|UINT32_C(0xffff)
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_FUNC_DRVR_UNLOAD_EVENT_DATA1_FUNC_ID_SFT
value|0
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* HWRM Asynchronous Event Completion Record for Function Driver load (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_async_event_cmpl_func_drvr_load
block|{
name|uint16_t
name|type
decl_stmt|;
comment|/* unused1 is 10 b */
comment|/* 	 * This field indicates the exact type of the completion. By convention, 	 * the LSB identifies the length of the record in 16B units. Even values 	 * indicate 16B records. Odd values indicate 32B records. 	 */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_FUNC_DRVR_LOAD_TYPE_MASK
value|UINT32_C(0x3f)
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_FUNC_DRVR_LOAD_TYPE_SFT
value|0
comment|/* HWRM Asynchronous Event Information */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_FUNC_DRVR_LOAD_TYPE_HWRM_ASYNC_EVENT
value|UINT32_C(0x2e)
comment|/* unused1 is 10 b */
name|uint16_t
name|event_id
decl_stmt|;
comment|/* Identifiers of events. */
comment|/* Function driver loaded */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_FUNC_DRVR_LOAD_EVENT_ID_FUNC_DRVR_LOAD
value|UINT32_C(0x11)
name|uint32_t
name|event_data2
decl_stmt|;
comment|/* Event specific data */
name|uint8_t
name|opaque_v
decl_stmt|;
comment|/* opaque is 7 b */
comment|/* 	 * This value is written by the NIC such that it will be different for 	 * each pass through the completion queue. The even passes will write 1. 	 * The odd passes will write 0. 	 */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_FUNC_DRVR_LOAD_V
value|UINT32_C(0x1)
comment|/* opaque is 7 b */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_FUNC_DRVR_LOAD_OPAQUE_MASK
value|UINT32_C(0xfe)
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_FUNC_DRVR_LOAD_OPAQUE_SFT
value|1
name|uint8_t
name|timestamp_lo
decl_stmt|;
comment|/* 8-lsb timestamp from POR (100-msec resolution) */
name|uint16_t
name|timestamp_hi
decl_stmt|;
comment|/* 16-lsb timestamp from POR (100-msec resolution) */
name|uint32_t
name|event_data1
decl_stmt|;
comment|/* Event specific data */
comment|/* Function ID */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_FUNC_DRVR_LOAD_EVENT_DATA1_FUNC_ID_MASK
value|UINT32_C(0xffff)
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_FUNC_DRVR_LOAD_EVENT_DATA1_FUNC_ID_SFT
value|0
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* HWRM Asynchronous Event Completion Record to indicate completion of FLR related processing (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_async_event_cmpl_func_flr_proc_cmplt
block|{
name|uint16_t
name|type
decl_stmt|;
comment|/* unused1 is 10 b */
comment|/* 	 * This field indicates the exact type of the completion. By convention, 	 * the LSB identifies the length of the record in 16B units. Even values 	 * indicate 16B records. Odd values indicate 32B records. 	 */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_FUNC_FLR_PROC_CMPLT_TYPE_MASK
value|UINT32_C(0x3f)
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_FUNC_FLR_PROC_CMPLT_TYPE_SFT
value|0
comment|/* HWRM Asynchronous Event Information */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_FUNC_FLR_PROC_CMPLT_TYPE_HWRM_ASYNC_EVENT
value|UINT32_C(0x2e)
comment|/* unused1 is 10 b */
name|uint16_t
name|event_id
decl_stmt|;
comment|/* Identifiers of events. */
comment|/* Function FLR related processing has completed */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_FUNC_FLR_PROC_CMPLT_EVENT_ID_FUNC_FLR_PROC_CMPLT
value|UINT32_C(0x12)
name|uint32_t
name|event_data2
decl_stmt|;
comment|/* Event specific data */
name|uint8_t
name|opaque_v
decl_stmt|;
comment|/* opaque is 7 b */
comment|/* 	 * This value is written by the NIC such that it will be different for 	 * each pass through the completion queue. The even passes will write 1. 	 * The odd passes will write 0. 	 */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_FUNC_FLR_PROC_CMPLT_V
value|UINT32_C(0x1)
comment|/* opaque is 7 b */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_FUNC_FLR_PROC_CMPLT_OPAQUE_MASK
value|UINT32_C(0xfe)
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_FUNC_FLR_PROC_CMPLT_OPAQUE_SFT
value|1
name|uint8_t
name|timestamp_lo
decl_stmt|;
comment|/* 8-lsb timestamp from POR (100-msec resolution) */
name|uint16_t
name|timestamp_hi
decl_stmt|;
comment|/* 16-lsb timestamp from POR (100-msec resolution) */
name|uint32_t
name|event_data1
decl_stmt|;
comment|/* Event specific data */
comment|/* Function ID */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_FUNC_FLR_PROC_CMPLT_EVENT_DATA1_FUNC_ID_MASK
value|UINT32_C(0xffff)
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_FUNC_FLR_PROC_CMPLT_EVENT_DATA1_FUNC_ID_SFT
value|0
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* HWRM Asynchronous Event Completion Record for PF Driver Unload (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_async_event_cmpl_pf_drvr_unload
block|{
name|uint16_t
name|type
decl_stmt|;
comment|/* unused1 is 10 b */
comment|/* 	 * This field indicates the exact type of the completion. By convention, 	 * the LSB identifies the length of the record in 16B units. Even values 	 * indicate 16B records. Odd values indicate 32B records. 	 */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_PF_DRVR_UNLOAD_TYPE_MASK
value|UINT32_C(0x3f)
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_PF_DRVR_UNLOAD_TYPE_SFT
value|0
comment|/* HWRM Asynchronous Event Information */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_PF_DRVR_UNLOAD_TYPE_HWRM_ASYNC_EVENT
value|UINT32_C(0x2e)
comment|/* unused1 is 10 b */
name|uint16_t
name|event_id
decl_stmt|;
comment|/* Identifiers of events. */
comment|/* PF driver unloaded */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_PF_DRVR_UNLOAD_EVENT_ID_PF_DRVR_UNLOAD
value|UINT32_C(0x20)
name|uint32_t
name|event_data2
decl_stmt|;
comment|/* Event specific data */
name|uint8_t
name|opaque_v
decl_stmt|;
comment|/* opaque is 7 b */
comment|/* 	 * This value is written by the NIC such that it will be different for 	 * each pass through the completion queue. The even passes will write 1. 	 * The odd passes will write 0. 	 */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_PF_DRVR_UNLOAD_V
value|UINT32_C(0x1)
comment|/* opaque is 7 b */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_PF_DRVR_UNLOAD_OPAQUE_MASK
value|UINT32_C(0xfe)
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_PF_DRVR_UNLOAD_OPAQUE_SFT
value|1
name|uint8_t
name|timestamp_lo
decl_stmt|;
comment|/* 8-lsb timestamp from POR (100-msec resolution) */
name|uint16_t
name|timestamp_hi
decl_stmt|;
comment|/* 16-lsb timestamp from POR (100-msec resolution) */
name|uint32_t
name|event_data1
decl_stmt|;
comment|/* Event specific data */
comment|/* PF ID */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_PF_DRVR_UNLOAD_EVENT_DATA1_FUNC_ID_MASK
value|UINT32_C(0xffff)
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_PF_DRVR_UNLOAD_EVENT_DATA1_FUNC_ID_SFT
value|0
comment|/* Indicates the physical port this pf belongs to */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_PF_DRVR_UNLOAD_EVENT_DATA1_PORT_MASK
value|UINT32_C(0x70000)
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_PF_DRVR_UNLOAD_EVENT_DATA1_PORT_SFT
value|16
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* HWRM Asynchronous Event Completion Record for PF Driver load (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_async_event_cmpl_pf_drvr_load
block|{
name|uint16_t
name|type
decl_stmt|;
comment|/* unused1 is 10 b */
comment|/* 	 * This field indicates the exact type of the completion. By convention, 	 * the LSB identifies the length of the record in 16B units. Even values 	 * indicate 16B records. Odd values indicate 32B records. 	 */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_PF_DRVR_LOAD_TYPE_MASK
value|UINT32_C(0x3f)
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_PF_DRVR_LOAD_TYPE_SFT
value|0
comment|/* HWRM Asynchronous Event Information */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_PF_DRVR_LOAD_TYPE_HWRM_ASYNC_EVENT
value|UINT32_C(0x2e)
comment|/* unused1 is 10 b */
name|uint16_t
name|event_id
decl_stmt|;
comment|/* Identifiers of events. */
comment|/* PF driver loaded */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_PF_DRVR_LOAD_EVENT_ID_PF_DRVR_LOAD
value|UINT32_C(0x21)
name|uint32_t
name|event_data2
decl_stmt|;
comment|/* Event specific data */
name|uint8_t
name|opaque_v
decl_stmt|;
comment|/* opaque is 7 b */
comment|/* 	 * This value is written by the NIC such that it will be different for 	 * each pass through the completion queue. The even passes will write 1. 	 * The odd passes will write 0. 	 */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_PF_DRVR_LOAD_V
value|UINT32_C(0x1)
comment|/* opaque is 7 b */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_PF_DRVR_LOAD_OPAQUE_MASK
value|UINT32_C(0xfe)
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_PF_DRVR_LOAD_OPAQUE_SFT
value|1
name|uint8_t
name|timestamp_lo
decl_stmt|;
comment|/* 8-lsb timestamp from POR (100-msec resolution) */
name|uint16_t
name|timestamp_hi
decl_stmt|;
comment|/* 16-lsb timestamp from POR (100-msec resolution) */
name|uint32_t
name|event_data1
decl_stmt|;
comment|/* Event specific data */
comment|/* PF ID */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_PF_DRVR_LOAD_EVENT_DATA1_FUNC_ID_MASK
value|UINT32_C(0xffff)
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_PF_DRVR_LOAD_EVENT_DATA1_FUNC_ID_SFT
value|0
comment|/* Indicates the physical port this pf belongs to */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_PF_DRVR_LOAD_EVENT_DATA1_PORT_MASK
value|UINT32_C(0x70000)
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_PF_DRVR_LOAD_EVENT_DATA1_PORT_SFT
value|16
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* HWRM Asynchronous Event Completion Record for VF FLR (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_async_event_cmpl_vf_flr
block|{
name|uint16_t
name|type
decl_stmt|;
comment|/* unused1 is 10 b */
comment|/* 	 * This field indicates the exact type of the completion. By convention, 	 * the LSB identifies the length of the record in 16B units. Even values 	 * indicate 16B records. Odd values indicate 32B records. 	 */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_VF_FLR_TYPE_MASK
value|UINT32_C(0x3f)
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_VF_FLR_TYPE_SFT
value|0
comment|/* HWRM Asynchronous Event Information */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_VF_FLR_TYPE_HWRM_ASYNC_EVENT
value|UINT32_C(0x2e)
comment|/* unused1 is 10 b */
name|uint16_t
name|event_id
decl_stmt|;
comment|/* Identifiers of events. */
comment|/* VF Function Level Reset (FLR) */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_VF_FLR_EVENT_ID_VF_FLR
value|UINT32_C(0x30)
name|uint32_t
name|event_data2
decl_stmt|;
comment|/* Event specific data */
name|uint8_t
name|opaque_v
decl_stmt|;
comment|/* opaque is 7 b */
comment|/* 	 * This value is written by the NIC such that it will be different for 	 * each pass through the completion queue. The even passes will write 1. 	 * The odd passes will write 0. 	 */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_VF_FLR_V
value|UINT32_C(0x1)
comment|/* opaque is 7 b */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_VF_FLR_OPAQUE_MASK
value|UINT32_C(0xfe)
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_VF_FLR_OPAQUE_SFT
value|1
name|uint8_t
name|timestamp_lo
decl_stmt|;
comment|/* 8-lsb timestamp from POR (100-msec resolution) */
name|uint16_t
name|timestamp_hi
decl_stmt|;
comment|/* 16-lsb timestamp from POR (100-msec resolution) */
name|uint32_t
name|event_data1
decl_stmt|;
comment|/* Event specific data */
comment|/* VF ID */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_VF_FLR_EVENT_DATA1_VF_ID_MASK
value|UINT32_C(0xffff)
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_VF_FLR_EVENT_DATA1_VF_ID_SFT
value|0
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* HWRM Asynchronous Event Completion Record for VF MAC Addr change (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_async_event_cmpl_vf_mac_addr_change
block|{
name|uint16_t
name|type
decl_stmt|;
comment|/* unused1 is 10 b */
comment|/* 	 * This field indicates the exact type of the completion. By convention, 	 * the LSB identifies the length of the record in 16B units. Even values 	 * indicate 16B records. Odd values indicate 32B records. 	 */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_VF_MAC_ADDR_CHANGE_TYPE_MASK
value|UINT32_C(0x3f)
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_VF_MAC_ADDR_CHANGE_TYPE_SFT
value|0
comment|/* HWRM Asynchronous Event Information */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_VF_MAC_ADDR_CHANGE_TYPE_HWRM_ASYNC_EVENT
value|UINT32_C(0x2e)
comment|/* unused1 is 10 b */
name|uint16_t
name|event_id
decl_stmt|;
comment|/* Identifiers of events. */
comment|/* VF MAC Address Change */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_VF_MAC_ADDR_CHANGE_EVENT_ID_VF_MAC_ADDR_CHANGE
value|UINT32_C(0x31)
name|uint32_t
name|event_data2
decl_stmt|;
comment|/* Event specific data */
name|uint8_t
name|opaque_v
decl_stmt|;
comment|/* opaque is 7 b */
comment|/* 	 * This value is written by the NIC such that it will be different for 	 * each pass through the completion queue. The even passes will write 1. 	 * The odd passes will write 0. 	 */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_VF_MAC_ADDR_CHANGE_V
value|UINT32_C(0x1)
comment|/* opaque is 7 b */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_VF_MAC_ADDR_CHANGE_OPAQUE_MASK
value|UINT32_C(0xfe)
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_VF_MAC_ADDR_CHANGE_OPAQUE_SFT
value|1
name|uint8_t
name|timestamp_lo
decl_stmt|;
comment|/* 8-lsb timestamp from POR (100-msec resolution) */
name|uint16_t
name|timestamp_hi
decl_stmt|;
comment|/* 16-lsb timestamp from POR (100-msec resolution) */
name|uint32_t
name|event_data1
decl_stmt|;
comment|/* Event specific data */
comment|/* VF ID */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_VF_MAC_ADDR_CHANGE_EVENT_DATA1_VF_ID_MASK
value|UINT32_C(0xffff)
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_VF_MAC_ADDR_CHANGE_EVENT_DATA1_VF_ID_SFT
value|0
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* HWRM Asynchronous Event Completion Record for PF-VF communication status change (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_async_event_cmpl_pf_vf_comm_status_change
block|{
name|uint16_t
name|type
decl_stmt|;
comment|/* unused1 is 10 b */
comment|/* 	 * This field indicates the exact type of the completion. By convention, 	 * the LSB identifies the length of the record in 16B units. Even values 	 * indicate 16B records. Odd values indicate 32B records. 	 */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_PF_VF_COMM_STATUS_CHANGE_TYPE_MASK
value|UINT32_C(0x3f)
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_PF_VF_COMM_STATUS_CHANGE_TYPE_SFT
value|0
comment|/* HWRM Asynchronous Event Information */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_PF_VF_COMM_STATUS_CHANGE_TYPE_HWRM_ASYNC_EVENT
value|UINT32_C(0x2e)
comment|/* unused1 is 10 b */
name|uint16_t
name|event_id
decl_stmt|;
comment|/* Identifiers of events. */
comment|/* PF-VF communication channel status change. */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_PF_VF_COMM_STATUS_CHANGE_EVENT_ID_PF_VF_COMM_STATUS_CHANGE
value|UINT32_C(0x32)
name|uint32_t
name|event_data2
decl_stmt|;
comment|/* Event specific data */
name|uint8_t
name|opaque_v
decl_stmt|;
comment|/* opaque is 7 b */
comment|/* 	 * This value is written by the NIC such that it will be different for 	 * each pass through the completion queue. The even passes will write 1. 	 * The odd passes will write 0. 	 */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_PF_VF_COMM_STATUS_CHANGE_V
value|UINT32_C(0x1)
comment|/* opaque is 7 b */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_PF_VF_COMM_STATUS_CHANGE_OPAQUE_MASK
value|UINT32_C(0xfe)
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_PF_VF_COMM_STATUS_CHANGE_OPAQUE_SFT
value|1
name|uint8_t
name|timestamp_lo
decl_stmt|;
comment|/* 8-lsb timestamp from POR (100-msec resolution) */
name|uint16_t
name|timestamp_hi
decl_stmt|;
comment|/* 16-lsb timestamp from POR (100-msec resolution) */
name|uint32_t
name|event_data1
decl_stmt|;
comment|/* Event specific data */
comment|/* 	 * If this bit is set to 1, then it indicates that the PF-VF 	 * communication was lost and it is established. If this bit set to 0, 	 * then it indicates that the PF-VF communication was established and it 	 * is lost. 	 */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_PF_VF_COMM_STATUS_CHANGE_EVENT_DATA1_COMM_ESTABLISHED
value|UINT32_C(0x1)
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* HWRM Asynchronous Event Completion Record for VF configuration change (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_async_event_cmpl_vf_cfg_change
block|{
name|uint16_t
name|type
decl_stmt|;
comment|/* unused1 is 10 b */
comment|/* 	 * This field indicates the exact type of the completion. By convention, 	 * the LSB identifies the length of the record in 16B units. Even values 	 * indicate 16B records. Odd values indicate 32B records. 	 */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_VF_CFG_CHANGE_TYPE_MASK
value|UINT32_C(0x3f)
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_VF_CFG_CHANGE_TYPE_SFT
value|0
comment|/* HWRM Asynchronous Event Information */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_VF_CFG_CHANGE_TYPE_HWRM_ASYNC_EVENT
value|UINT32_C(0x2e)
comment|/* unused1 is 10 b */
name|uint16_t
name|event_id
decl_stmt|;
comment|/* Identifiers of events. */
comment|/* VF Configuration Change */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_VF_CFG_CHANGE_EVENT_ID_VF_CFG_CHANGE
value|UINT32_C(0x33)
name|uint32_t
name|event_data2
decl_stmt|;
comment|/* Event specific data */
name|uint8_t
name|opaque_v
decl_stmt|;
comment|/* opaque is 7 b */
comment|/* 	 * This value is written by the NIC such that it will be different for 	 * each pass through the completion queue. The even passes will write 1. 	 * The odd passes will write 0. 	 */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_VF_CFG_CHANGE_V
value|UINT32_C(0x1)
comment|/* opaque is 7 b */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_VF_CFG_CHANGE_OPAQUE_MASK
value|UINT32_C(0xfe)
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_VF_CFG_CHANGE_OPAQUE_SFT
value|1
name|uint8_t
name|timestamp_lo
decl_stmt|;
comment|/* 8-lsb timestamp from POR (100-msec resolution) */
name|uint16_t
name|timestamp_hi
decl_stmt|;
comment|/* 16-lsb timestamp from POR (100-msec resolution) */
name|uint32_t
name|event_data1
decl_stmt|;
comment|/* 	 * Each flag provided in this field indicates a specific VF 	 * configuration change. At least one of these flags shall be set to 1 	 * when an asynchronous event completion of this type is provided by the 	 * HWRM. 	 */
comment|/* 	 * If this bit is set to 1, then the value of MTU was changed on this 	 * VF. If set to 0, then this bit should be ignored. 	 */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_VF_CFG_CHANGE_EVENT_DATA1_MTU_CHANGE
value|UINT32_C(0x1)
comment|/* 	 * If this bit is set to 1, then the value of MRU was changed on this 	 * VF. If set to 0, then this bit should be ignored. 	 */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_VF_CFG_CHANGE_EVENT_DATA1_MRU_CHANGE
value|UINT32_C(0x2)
comment|/* 	 * If this bit is set to 1, then the value of default MAC address was 	 * changed on this VF. If set to 0, then this bit should be ignored. 	 */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_VF_CFG_CHANGE_EVENT_DATA1_DFLT_MAC_ADDR_CHANGE
value|UINT32_C(0x4)
comment|/* 	 * If this bit is set to 1, then the value of default VLAN was changed 	 * on this VF. If set to 0, then this bit should be ignored. 	 */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_VF_CFG_CHANGE_EVENT_DATA1_DFLT_VLAN_CHANGE
value|UINT32_C(0x8)
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* HWRM Asynchronous Event Completion Record for llfc pfc status change (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_async_event_cmpl_llfc_pfc_change
block|{
name|uint16_t
name|type
decl_stmt|;
comment|/* unused1 is 10 b */
comment|/* 	 * This field indicates the exact type of the completion. By convention, 	 * the LSB identifies the length of the record in 16B units. Even values 	 * indicate 16B records. Odd values indicate 32B records. 	 */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_LLFC_PFC_CHANGE_TYPE_MASK
value|UINT32_C(0x3f)
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_LLFC_PFC_CHANGE_TYPE_SFT
value|0
comment|/* HWRM Asynchronous Event Information */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_LLFC_PFC_CHANGE_TYPE_HWRM_ASYNC_EVENT
value|UINT32_C(0x2e)
comment|/* unused1 is 10 b */
name|uint16_t
name|event_id
decl_stmt|;
comment|/* Identifiers of events. */
comment|/* LLFC/PFC Configuration Change */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_LLFC_PFC_CHANGE_EVENT_ID_LLFC_PFC_CHANGE
value|UINT32_C(0x34)
name|uint32_t
name|event_data2
decl_stmt|;
comment|/* Event specific data */
name|uint8_t
name|opaque_v
decl_stmt|;
comment|/* opaque is 7 b */
comment|/* 	 * This value is written by the NIC such that it will be different for 	 * each pass through the completion queue. The even passes will write 1. 	 * The odd passes will write 0. 	 */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_LLFC_PFC_CHANGE_V
value|UINT32_C(0x1)
comment|/* opaque is 7 b */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_LLFC_PFC_CHANGE_OPAQUE_MASK
value|UINT32_C(0xfe)
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_LLFC_PFC_CHANGE_OPAQUE_SFT
value|1
name|uint8_t
name|timestamp_lo
decl_stmt|;
comment|/* 8-lsb timestamp from POR (100-msec resolution) */
name|uint16_t
name|timestamp_hi
decl_stmt|;
comment|/* 16-lsb timestamp from POR (100-msec resolution) */
name|uint32_t
name|event_data1
decl_stmt|;
comment|/* Event specific data */
comment|/* Indicates llfc pfc status change */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_LLFC_PFC_CHANGE_EVENT_DATA1_LLFC_PFC_MASK
value|UINT32_C(0x3)
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_LLFC_PFC_CHANGE_EVENT_DATA1_LLFC_PFC_SFT
value|0
comment|/* If this field set to 1, then it indicates that llfc is enabled. */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_LLFC_PFC_CHANGE_EVENT_DATA1_LLFC_PFC_LLFC
value|(UINT32_C(0x1)<< 0)
comment|/* If this field is set to 2, then it indicates that pfc is enabled. */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_LLFC_PFC_CHANGE_EVENT_DATA1_LLFC_PFC_PFC
value|(UINT32_C(0x2)<< 0)
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_LLFC_PFC_CHANGE_EVENT_DATA1_LLFC_PFC_LAST
value|HWRM_ASYNC_EVENT_CMPL_LLFC_PFC_CHANGE_EVENT_DATA1_LLFC_PFC_PFC
comment|/* Indicates the physical port this llfc pfc change occur */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_LLFC_PFC_CHANGE_EVENT_DATA1_PORT_MASK
value|UINT32_C(0x1c)
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_LLFC_PFC_CHANGE_EVENT_DATA1_PORT_SFT
value|2
comment|/* PORT ID */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_LLFC_PFC_CHANGE_EVENT_DATA1_PORT_ID_MASK
value|UINT32_C(0x1fffe0)
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_LLFC_PFC_CHANGE_EVENT_DATA1_PORT_ID_SFT
value|5
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* HWRM Asynchronous Event Completion Record for HWRM Error (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_async_event_cmpl_hwrm_error
block|{
name|uint16_t
name|type
decl_stmt|;
comment|/* unused1 is 10 b */
comment|/* 	 * This field indicates the exact type of the completion. By convention, 	 * the LSB identifies the length of the record in 16B units. Even values 	 * indicate 16B records. Odd values indicate 32B records. 	 */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_HWRM_ERROR_TYPE_MASK
value|UINT32_C(0x3f)
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_HWRM_ERROR_TYPE_SFT
value|0
comment|/* HWRM Asynchronous Event Information */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_HWRM_ERROR_TYPE_HWRM_ASYNC_EVENT
value|UINT32_C(0x2e)
comment|/* unused1 is 10 b */
name|uint16_t
name|event_id
decl_stmt|;
comment|/* Identifiers of events. */
comment|/* HWRM Error */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_HWRM_ERROR_EVENT_ID_HWRM_ERROR
value|UINT32_C(0xff)
name|uint32_t
name|event_data2
decl_stmt|;
comment|/* Event specific data */
comment|/* Severity of HWRM Error */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_HWRM_ERROR_EVENT_DATA2_SEVERITY_MASK
value|UINT32_C(0xff)
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_HWRM_ERROR_EVENT_DATA2_SEVERITY_SFT
value|0
comment|/* Warning */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_HWRM_ERROR_EVENT_DATA2_SEVERITY_WARNING
value|UINT32_C(0x0)
comment|/* Non-fatal Error */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_HWRM_ERROR_EVENT_DATA2_SEVERITY_NONFATAL
value|UINT32_C(0x1)
comment|/* Fatal Error */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_HWRM_ERROR_EVENT_DATA2_SEVERITY_FATAL
value|UINT32_C(0x2)
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_HWRM_ERROR_EVENT_DATA2_SEVERITY_LAST
value|HWRM_ASYNC_EVENT_CMPL_HWRM_ERROR_EVENT_DATA2_SEVERITY_FATAL
name|uint8_t
name|opaque_v
decl_stmt|;
comment|/* opaque is 7 b */
comment|/* 	 * This value is written by the NIC such that it will be different for 	 * each pass through the completion queue. The even passes will write 1. 	 * The odd passes will write 0. 	 */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_HWRM_ERROR_V
value|UINT32_C(0x1)
comment|/* opaque is 7 b */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_HWRM_ERROR_OPAQUE_MASK
value|UINT32_C(0xfe)
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_HWRM_ERROR_OPAQUE_SFT
value|1
name|uint8_t
name|timestamp_lo
decl_stmt|;
comment|/* 8-lsb timestamp from POR (100-msec resolution) */
name|uint16_t
name|timestamp_hi
decl_stmt|;
comment|/* 16-lsb timestamp from POR (100-msec resolution) */
name|uint32_t
name|event_data1
decl_stmt|;
comment|/* Event specific data */
comment|/* Time stamp for error event */
define|#
directive|define
name|HWRM_ASYNC_EVENT_CMPL_HWRM_ERROR_EVENT_DATA1_TIMESTAMP
value|UINT32_C(0x1)
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Door Bell Formats */
end_comment

begin_comment
comment|/*  * Description: The backup version of the packet must be valid in the TX ring  * before the push doorbell is written to the chip. The first 32b and the BD  * portion of the push doorbell must be written in multiples of 32b units on the  * PCI interface. The data portion of the push doorbell may be written in  * multiples of 8b units on the PCI interface. A push update must contain  * exactly one push packet. The backup version of the packet must start with a  * long (32B) BD and the BDs must be less than or equal to 16x16B units long.  */
end_comment

begin_comment
comment|/*  * Note: This door bell format is used by the driver when it wants to push a  * packet into the chip for super-fast transmission. This pushes a partial BD  * and the packet data into the chip. If the chip has room, it will transmit the  * packet. If the chip dosn't have room, it will read the BD and packet data  * from host memory as a normal packet.  */
end_comment

begin_comment
comment|/* TX Door Bell Format (4 bytes) */
end_comment

begin_struct
struct|struct
name|tx_doorbell
block|{
name|uint32_t
name|key_idx
decl_stmt|;
comment|/* 	 * This value indicates the type of door bell operation that is begin 	 * requested. This value is '0' for TX door bell operations. 	 */
comment|/* 	 * BD Index of next BD that will be used to transmit data on the TX ring 	 * mapped to this door bell. NIC may read and process all BDs up to, but 	 * not including this index. 	 */
define|#
directive|define
name|TX_DOORBELL_IDX_MASK
value|UINT32_C(0xffffff)
define|#
directive|define
name|TX_DOORBELL_IDX_SFT
value|0
comment|/* reserved is 4 b */
define|#
directive|define
name|TX_DOORBELL_RESERVED_MASK
value|UINT32_C(0xf000000)
define|#
directive|define
name|TX_DOORBELL_RESERVED_SFT
value|24
comment|/* 	 * This value indicates the type of door bell operation that is begin 	 * requested. This value is '0' for TX door bell operations. 	 */
define|#
directive|define
name|TX_DOORBELL_KEY_MASK
value|UINT32_C(0xf0000000)
define|#
directive|define
name|TX_DOORBELL_KEY_SFT
value|28
comment|/* TX Operation */
define|#
directive|define
name|TX_DOORBELL_KEY_TX
value|(UINT32_C(0x0)<< 28)
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* RX Door Bell Format (4 bytes) */
end_comment

begin_struct
struct|struct
name|rx_doorbell
block|{
name|uint32_t
name|key_idx
decl_stmt|;
comment|/* 	 * This value indicates the type of door bell operation that is begin 	 * requested. This value is '1' for RX door bell operations. 	 */
comment|/* 	 * BD Index of next BD that will be used for an empty receive buffer on 	 * the RX ring mapped to this door bell. NIC may read and process all 	 * BDs up to, but not including this index. 	 */
define|#
directive|define
name|RX_DOORBELL_IDX_MASK
value|UINT32_C(0xffffff)
define|#
directive|define
name|RX_DOORBELL_IDX_SFT
value|0
comment|/* reserved is 4 b */
define|#
directive|define
name|RX_DOORBELL_RESERVED_MASK
value|UINT32_C(0xf000000)
define|#
directive|define
name|RX_DOORBELL_RESERVED_SFT
value|24
comment|/* 	 * This value indicates the type of door bell operation that is begin 	 * requested. This value is '1' for RX door bell operations. 	 */
define|#
directive|define
name|RX_DOORBELL_KEY_MASK
value|UINT32_C(0xf0000000)
define|#
directive|define
name|RX_DOORBELL_KEY_SFT
value|28
comment|/* RX Operation */
define|#
directive|define
name|RX_DOORBELL_KEY_RX
value|(UINT32_C(0x1)<< 28)
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* CMP Door Bell Format (4 bytes) */
end_comment

begin_struct
struct|struct
name|cmpl_doorbell
block|{
name|uint32_t
name|key_mask_valid_idx
decl_stmt|;
comment|/* 	 * This value indicates the type of door bell operation that is begin 	 * requested. This value is '2' for CMP door bell operations. 	 */
comment|/* 	 * BD Index of the most recently handed completion record on the 	 * completion ring mapped to this door bell. NIC may write this location 	 * again with a new completion. 	 */
define|#
directive|define
name|CMPL_DOORBELL_IDX_MASK
value|UINT32_C(0xffffff)
define|#
directive|define
name|CMPL_DOORBELL_IDX_SFT
value|0
comment|/* reserved is 2 b */
define|#
directive|define
name|CMPL_DOORBELL_RESERVED_MASK
value|UINT32_C(0x3000000)
define|#
directive|define
name|CMPL_DOORBELL_RESERVED_SFT
value|24
comment|/* 	 * This indicates if the BDIDX value is valid for this update when it is 	 * '1'. When it is '0', the BDIDX value should be ignored. 	 */
define|#
directive|define
name|CMPL_DOORBELL_IDX_VALID
value|UINT32_C(0x4000000)
comment|/* 	 * This bit indicates the new interrupt mask state for the interrupt 	 * associated with the BDIDX. A '1', means the interrupt is to be 	 * masked. A '0' indicates the interrupt is to be unmasked. 	 */
define|#
directive|define
name|CMPL_DOORBELL_MASK
value|UINT32_C(0x8000000)
comment|/* 	 * This value indicates the type of door bell operation that is begin 	 * requested. This value is '2' for CMP door bell operations. 	 */
define|#
directive|define
name|CMPL_DOORBELL_KEY_MASK
value|UINT32_C(0xf0000000)
define|#
directive|define
name|CMPL_DOORBELL_KEY_SFT
value|28
comment|/* Completion Operation */
define|#
directive|define
name|CMPL_DOORBELL_KEY_CMPL
value|(UINT32_C(0x2)<< 28)
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Status Door Bell Format (4 bytes) */
end_comment

begin_struct
struct|struct
name|status_doorbell
block|{
name|uint32_t
name|key_idx
decl_stmt|;
comment|/* 	 * This value indicates the type of door bell operation that is begin 	 * requested. This value is '3' for Status door bell operations. 	 */
comment|/* 	 * BD Index of the status record for which space is now available to the 	 * NIC. 	 */
comment|/* 	 * While there is no actual BD associated with the index, the similar 	 * scheme is being used to communicate to the NIC that space is 	 * available for status completions. 	 */
define|#
directive|define
name|STATUS_DOORBELL_IDX_MASK
value|UINT32_C(0xffffff)
define|#
directive|define
name|STATUS_DOORBELL_IDX_SFT
value|0
comment|/* reserved is 4 b */
define|#
directive|define
name|STATUS_DOORBELL_RESERVED_MASK
value|UINT32_C(0xf000000)
define|#
directive|define
name|STATUS_DOORBELL_RESERVED_SFT
value|24
comment|/* 	 * This value indicates the type of door bell operation that is begin 	 * requested. This value is '3' for Status door bell operations. 	 */
define|#
directive|define
name|STATUS_DOORBELL_KEY_MASK
value|UINT32_C(0xf0000000)
define|#
directive|define
name|STATUS_DOORBELL_KEY_SFT
value|28
comment|/* Status Operation */
define|#
directive|define
name|STATUS_DOORBELL_KEY_STAT
value|(UINT32_C(0x3)<< 28)
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Push w/32B BD Door Bell Format (32 bytes) */
end_comment

begin_struct
struct|struct
name|push32_doorbell
block|{
name|uint32_t
name|key_sz_idx
decl_stmt|;
comment|/* 	 * This value indicates the type of door bell operation that is begin 	 * requested. This value is 4 for push door bell operations. 	 */
comment|/* 	 * This is the BD Index of last BD of the push packet that will be used 	 * to transmit data on the TX ring mapped to this door bell. 	 */
define|#
directive|define
name|PUSH32_DOORBELL_IDX_MASK
value|UINT32_C(0xffffff)
define|#
directive|define
name|PUSH32_DOORBELL_IDX_SFT
value|0
comment|/* 	 * This is the number of 16B BDs spaces consumed in the TX Ring by the 	 * "backup" version of the packet being pushed. A value of 1 is invalid 	 * since backup must start with a long 32B BE. A value of 2 indicates 	 * just the first 32B BE. A value of 3 indicates 32B+16B BD. etc. A 	 * value of 0 indicates 16x16B BD spaces are consumed. 	 */
define|#
directive|define
name|PUSH32_DOORBELL_SZ_MASK
value|UINT32_C(0xf000000)
define|#
directive|define
name|PUSH32_DOORBELL_SZ_SFT
value|24
comment|/* 	 * This value indicates the type of door bell operation that is begin 	 * requested. This value is 4 for push door bell operations. 	 */
define|#
directive|define
name|PUSH32_DOORBELL_KEY_MASK
value|UINT32_C(0xf0000000)
define|#
directive|define
name|PUSH32_DOORBELL_KEY_SFT
value|28
comment|/* Push Operation */
define|#
directive|define
name|PUSH32_DOORBELL_KEY_PUSH
value|(UINT32_C(0x4)<< 28)
name|uint16_t
name|flags_type
decl_stmt|;
comment|/* 	 * All bits in this field must be valid on the first BD of a packet. 	 * Only the packet_end bit must be valid for the remaining BDs of a 	 * packet. 	 */
comment|/* This value identifies the type of buffer descriptor. */
define|#
directive|define
name|PUSH32_DOORBELL_TYPE_MASK
value|UINT32_C(0x3f)
define|#
directive|define
name|PUSH32_DOORBELL_TYPE_SFT
value|0
comment|/* 	 * Indicates that this BD is 32B long and is used for normal L2 	 * packet transmission. 	 */
define|#
directive|define
name|PUSH32_DOORBELL_TYPE_TX_BD_LONG
value|UINT32_C(0x10)
comment|/* 	 * If set to 1, the packet ends with the data in the buffer pointed to 	 * by this descriptor. This flag must be valid on every BD. This bit 	 * must be set on all push doorbells. 	 */
define|#
directive|define
name|PUSH32_DOORBELL_FLAGS_PACKET_END
value|UINT32_C(0x40)
comment|/* 	 * If set to 1, the device will not generate a completion for this 	 * transmit packet unless there is an error in it's processing. If this 	 * bit is set to 0, then the packet will be completed normally. This bit 	 * must be valid only on the first BD of a packet. 	 */
define|#
directive|define
name|PUSH32_DOORBELL_FLAGS_NO_CMPL
value|UINT32_C(0x80)
comment|/* 	 * This value must match the sz field in the first 32b of the push 	 * operation except that if 16x16B BD locations are consumed in the ring 	 * by this packet, then this value must be 16 (not zero). 	 */
define|#
directive|define
name|PUSH32_DOORBELL_FLAGS_BD_CNT_MASK
value|UINT32_C(0x1f00)
define|#
directive|define
name|PUSH32_DOORBELL_FLAGS_BD_CNT_SFT
value|8
comment|/* 	 * This value is a hint for the length of the entire packet. It is used 	 * by the chip to optimize internal processing. The packet will be 	 * dropped if the hint is too short. This field is valid only on the 	 * first BD of a packet. 	 */
define|#
directive|define
name|PUSH32_DOORBELL_FLAGS_LHINT_MASK
value|UINT32_C(0x6000)
define|#
directive|define
name|PUSH32_DOORBELL_FLAGS_LHINT_SFT
value|13
comment|/* indicates packet length< 512B */
define|#
directive|define
name|PUSH32_DOORBELL_FLAGS_LHINT_LT512
value|(UINT32_C(0x0)<< 13)
comment|/* indicates 512<= packet length< 1KB */
define|#
directive|define
name|PUSH32_DOORBELL_FLAGS_LHINT_LT1K
value|(UINT32_C(0x1)<< 13)
comment|/* indicates 1KB<= packet length< 2KB */
define|#
directive|define
name|PUSH32_DOORBELL_FLAGS_LHINT_LT2K
value|(UINT32_C(0x2)<< 13)
comment|/* indicates packet length>= 2KB */
define|#
directive|define
name|PUSH32_DOORBELL_FLAGS_LHINT_GTE2K
value|(UINT32_C(0x3)<< 13)
define|#
directive|define
name|PUSH32_DOORBELL_FLAGS_LHINT_LAST
value|PUSH32_DOORBELL_FLAGS_LHINT_GTE2K
comment|/* 	 * If set to 1, the device immediately updates the Send Consumer Index 	 * after the buffer associated with this descriptor has been transferred 	 * via DMA to NIC memory from host memory. An interrupt may or may not 	 * be generated according to the state of the interrupt avoidance 	 * mechanisms. If this bit is set to 0, then the Consumer Index is only 	 * updated as soon as one of the host interrupt coalescing conditions 	 * has been met. This bit must be valid on the first BD of a packet. 	 */
define|#
directive|define
name|PUSH32_DOORBELL_FLAGS_COAL_NOW
value|UINT32_C(0x8000)
comment|/* 	 * All bits in this field must be valid on the first BD of a packet. 	 * Only the packet_end bit must be valid for the remaining BDs of a 	 * packet. 	 */
define|#
directive|define
name|PUSH32_DOORBELL_FLAGS_MASK
value|UINT32_C(0xffc0)
define|#
directive|define
name|PUSH32_DOORBELL_FLAGS_SFT
value|6
name|uint16_t
name|len
decl_stmt|;
comment|/* 	 * This is the length of the host physical buffer this BD describes in 	 * bytes. This field must be valid on all BDs of a packet. 	 */
name|uint32_t
name|opaque
decl_stmt|;
comment|/* 	 * The opaque data field is pass through to the completion and can be 	 * used for any data that the driver wants to associate with the 	 * transmit BD. This field must be valid on the first BD of a packet. 	 */
name|uint16_t
name|lflags
decl_stmt|;
comment|/* 	 * All bits in this field must be valid on the first BD of a packet. 	 * Their value on other BDs of the packet will be ignored. 	 */
comment|/* 	 * If set to 1, the controller replaces the TCP/UPD checksum fields of 	 * normal TCP/UPD checksum, or the inner TCP/UDP checksum field of the 	 * encapsulated TCP/UDP packets with the hardware calculated TCP/UDP 	 * checksum for the packet associated with this descriptor. The flag is 	 * ignored if the LSO flag is set. This bit must be valid on the first 	 * BD of a packet. 	 */
define|#
directive|define
name|PUSH32_DOORBELL_LFLAGS_TCP_UDP_CHKSUM
value|UINT32_C(0x1)
comment|/* 	 * If set to 1, the controller replaces the IP checksum of the normal 	 * packets, or the inner IP checksum of the encapsulated packets with 	 * the hardware calculated IP checksum for the packet associated with 	 * this descriptor. This bit must be valid on the first BD of a packet. 	 */
define|#
directive|define
name|PUSH32_DOORBELL_LFLAGS_IP_CHKSUM
value|UINT32_C(0x2)
comment|/* 	 * If set to 1, the controller will not append an Ethernet CRC to the 	 * end of the frame. This bit must be valid on the first BD of a packet. 	 * Packet must be 64B or longer when this flag is set. It is not useful 	 * to use this bit with any form of TX offload such as CSO or LSO. The 	 * intent is that the packet from the host already has a valid Ethernet 	 * CRC on the packet. 	 */
define|#
directive|define
name|PUSH32_DOORBELL_LFLAGS_NOCRC
value|UINT32_C(0x4)
comment|/* 	 * If set to 1, the device will record the time at which the packet was 	 * actually transmitted at the TX MAC. This bit must be valid on the 	 * first BD of a packet. 	 */
define|#
directive|define
name|PUSH32_DOORBELL_LFLAGS_STAMP
value|UINT32_C(0x8)
comment|/* 	 * If set to 1, The controller replaces the tunnel IP checksum field 	 * with hardware calculated IP checksum for the IP header of the packet 	 * associated with this descriptor. For outer UDP checksum, global outer 	 * UDP checksum TE_NIC register needs to be enabled. If the global outer 	 * UDP checksum TE_NIC register bit is set, outer UDP checksum will be 	 * calculated for the following cases: 1. Packets with tcp_udp_chksum 	 * flag set to offload checksum for inner packet AND the inner packet is 	 * TCP/UDP. If the inner packet is ICMP for example (non-TCP/UDP), even 	 * if the tcp_udp_chksum is set, the outer UDP checksum will not be 	 * calculated. 2. Packets with lso flag set which implies inner TCP 	 * checksum calculation as part of LSO operation. 	 */
define|#
directive|define
name|PUSH32_DOORBELL_LFLAGS_T_IP_CHKSUM
value|UINT32_C(0x10)
comment|/* 	 * If set to 1, the device will treat this packet with LSO(Large Send 	 * Offload) processing for both normal or encapsulated packets, which is 	 * a form of TCP segmentation. When this bit is 1, the hdr_size and mss 	 * fields must be valid. The driver doesn't need to set t_ip_chksum, 	 * ip_chksum, and tcp_udp_chksum flags since the controller will replace 	 * the appropriate checksum fields for segmented packets. When this bit 	 * is 1, the hdr_size and mss fields must be valid. 	 */
define|#
directive|define
name|PUSH32_DOORBELL_LFLAGS_LSO
value|UINT32_C(0x20)
comment|/* 	 * If set to zero when LSO is '1', then the IPID will be treated as a 	 * 16b number and will be wrapped if it exceeds a value of 0xffff. If 	 * set to one when LSO is '1', then the IPID will be treated as a 15b 	 * number and will be wrapped if it exceeds a value 0f 0x7fff. 	 */
define|#
directive|define
name|PUSH32_DOORBELL_LFLAGS_IPID_FMT
value|UINT32_C(0x40)
comment|/* 	 * If set to zero when LSO is '1', then the IPID of the tunnel IP header 	 * will not be modified during LSO operations. If set to one when LSO is 	 * '1', then the IPID of the tunnel IP header will be incremented for 	 * each subsequent segment of an LSO operation. The flag is ignored if 	 * the LSO packet is a normal (non-tunneled) TCP packet. 	 */
define|#
directive|define
name|PUSH32_DOORBELL_LFLAGS_T_IPID
value|UINT32_C(0x80)
comment|/* 	 * If set to '1', then the RoCE ICRC will be appended to the packet. 	 * Packet must be a valid RoCE format packet. 	 */
define|#
directive|define
name|PUSH32_DOORBELL_LFLAGS_ROCE_CRC
value|UINT32_C(0x100)
comment|/* 	 * If set to '1', then the FCoE CRC will be appended to the packet. 	 * Packet must be a valid FCoE format packet. 	 */
define|#
directive|define
name|PUSH32_DOORBELL_LFLAGS_FCOE_CRC
value|UINT32_C(0x200)
name|uint16_t
name|hdr_size
decl_stmt|;
comment|/* 	 * When LSO is '1', this field must contain the offset of the TCP 	 * payload from the beginning of the packet in as 16b words. In case of 	 * encapsulated/tunneling packet, this field contains the offset of the 	 * inner TCP payload from beginning of the packet as 16-bit words. This 	 * value must be valid on the first BD of a packet. 	 */
define|#
directive|define
name|PUSH32_DOORBELL_HDR_SIZE_MASK
value|UINT32_C(0x1ff)
define|#
directive|define
name|PUSH32_DOORBELL_HDR_SIZE_SFT
value|0
name|uint32_t
name|mss
decl_stmt|;
comment|/* 	 * This is the MSS value that will be used to do the LSO processing. The 	 * value is the length in bytes of the TCP payload for each segment 	 * generated by the LSO operation. This value must be valid on the first 	 * BD of a packet. 	 */
define|#
directive|define
name|PUSH32_DOORBELL_MSS_MASK
value|UINT32_C(0x7fff)
define|#
directive|define
name|PUSH32_DOORBELL_MSS_SFT
value|0
name|uint16_t
name|unused_2
decl_stmt|;
name|uint16_t
name|cfa_action
decl_stmt|;
comment|/* 	 * This value selects a CFA action to perform on the packet. Set this 	 * value to zero if no CFA action is desired. This value must be valid 	 * on the first BD of a packet. 	 */
name|uint32_t
name|cfa_meta
decl_stmt|;
comment|/* 	 * This value is action meta-data that defines CFA edit operations that 	 * are done in addition to any action editing. 	 */
comment|/* When key=1, This is the VLAN tag VID value. */
define|#
directive|define
name|PUSH32_DOORBELL_CFA_META_VLAN_VID_MASK
value|UINT32_C(0xfff)
define|#
directive|define
name|PUSH32_DOORBELL_CFA_META_VLAN_VID_SFT
value|0
comment|/* When key=1, This is the VLAN tag DE value. */
define|#
directive|define
name|PUSH32_DOORBELL_CFA_META_VLAN_DE
value|UINT32_C(0x1000)
comment|/* When key=1, This is the VLAN tag PRI value. */
define|#
directive|define
name|PUSH32_DOORBELL_CFA_META_VLAN_PRI_MASK
value|UINT32_C(0xe000)
define|#
directive|define
name|PUSH32_DOORBELL_CFA_META_VLAN_PRI_SFT
value|13
comment|/* When key=1, This is the VLAN tag TPID select value. */
define|#
directive|define
name|PUSH32_DOORBELL_CFA_META_VLAN_TPID_MASK
value|UINT32_C(0x70000)
define|#
directive|define
name|PUSH32_DOORBELL_CFA_META_VLAN_TPID_SFT
value|16
comment|/* 0x88a8 */
define|#
directive|define
name|PUSH32_DOORBELL_CFA_META_VLAN_TPID_TPID88A8
value|(UINT32_C(0x0)<< 16)
comment|/* 0x8100 */
define|#
directive|define
name|PUSH32_DOORBELL_CFA_META_VLAN_TPID_TPID8100
value|(UINT32_C(0x1)<< 16)
comment|/* 0x9100 */
define|#
directive|define
name|PUSH32_DOORBELL_CFA_META_VLAN_TPID_TPID9100
value|(UINT32_C(0x2)<< 16)
comment|/* 0x9200 */
define|#
directive|define
name|PUSH32_DOORBELL_CFA_META_VLAN_TPID_TPID9200
value|(UINT32_C(0x3)<< 16)
comment|/* 0x9300 */
define|#
directive|define
name|PUSH32_DOORBELL_CFA_META_VLAN_TPID_TPID9300
value|(UINT32_C(0x4)<< 16)
comment|/* Value programmed in CFA VLANTPID register. */
define|#
directive|define
name|PUSH32_DOORBELL_CFA_META_VLAN_TPID_TPIDCFG
value|(UINT32_C(0x5)<< 16)
define|#
directive|define
name|PUSH32_DOORBELL_CFA_META_VLAN_TPID_LAST
value|PUSH32_DOORBELL_CFA_META_VLAN_TPID_TPIDCFG
comment|/* When key=1, This is the VLAN tag TPID select value. */
define|#
directive|define
name|PUSH32_DOORBELL_CFA_META_VLAN_RESERVED_MASK
value|UINT32_C(0xff80000)
define|#
directive|define
name|PUSH32_DOORBELL_CFA_META_VLAN_RESERVED_SFT
value|19
comment|/* 	 * This field identifies the type of edit to be performed on the packet. 	 * This value must be valid on the first BD of a packet. 	 */
define|#
directive|define
name|PUSH32_DOORBELL_CFA_META_KEY_MASK
value|UINT32_C(0xf0000000)
define|#
directive|define
name|PUSH32_DOORBELL_CFA_META_KEY_SFT
value|28
comment|/* No editing */
define|#
directive|define
name|PUSH32_DOORBELL_CFA_META_KEY_NONE
value|(UINT32_C(0x0)<< 28)
comment|/* 	 * - meta[17:16] - TPID select value (0 = 0x8100). - meta[15:12] 	 * - PRI/DE value. - meta[11:0] - VID value. 	 */
define|#
directive|define
name|PUSH32_DOORBELL_CFA_META_KEY_VLAN_TAG
value|(UINT32_C(0x1)<< 28)
define|#
directive|define
name|PUSH32_DOORBELL_CFA_META_KEY_LAST
value|PUSH32_DOORBELL_CFA_META_KEY_VLAN_TAG
name|uint32_t
name|data
index|[
literal|25
index|]
decl_stmt|;
comment|/* 	 * This is the data for the push packet. If the packet data does not fit 	 * in the first pass, data writing can continue at offset 4 of the 	 * doorbell for up to 4 additional passes for a total data size of 512B 	 * maximum. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Doorbell Structures */
end_comment

begin_comment
comment|/*  * Description: This is the RoCE 32b Doorbell format. The host writes this  * message format directly to byte offset 8 of the appropriate doorbell page.  */
end_comment

begin_comment
comment|/* 64b Doorbell Format (8 bytes) */
end_comment

begin_struct
struct|struct
name|dbr_dbr
block|{
name|uint32_t
name|index
decl_stmt|;
comment|/* 	 * This value is the index being written. For SQ, RQ, SRQ, this is the 	 * producer index and should be the queue index of the last WQE written 	 * plus 1. For CQ, this is the consumer index and should be the index of 	 * the last CQE processed plus 1. 	 */
define|#
directive|define
name|DBR_DBR_INDEX_MASK
value|UINT32_C(0xfffff)
define|#
directive|define
name|DBR_DBR_INDEX_SFT
value|0
define|#
directive|define
name|DBR_DBR_RESERVED12_MASK
value|UINT32_C(0xfff00000)
define|#
directive|define
name|DBR_DBR_RESERVED12_SFT
value|20
name|uint32_t
name|type_xid
decl_stmt|;
comment|/* This value identifies the type of doorbell being written. */
comment|/* 	 * This value identifies the resource that the doorbell is intended to 	 * notify. For SQ and RQ, this is the QPID. For SRQ, this is the SID. 	 * For CQ, this is the CID. Bits [19:16] of this values must be zero for 	 * a SID value. 	 */
define|#
directive|define
name|DBR_DBR_XID_MASK
value|UINT32_C(0xfffff)
define|#
directive|define
name|DBR_DBR_XID_SFT
value|0
define|#
directive|define
name|DBR_DBR_RESERVED8_MASK
value|UINT32_C(0xff00000)
define|#
directive|define
name|DBR_DBR_RESERVED8_SFT
value|20
comment|/* This value identifies the type of doorbell being written. */
define|#
directive|define
name|DBR_DBR_TYPE_MASK
value|UINT32_C(0xf0000000)
define|#
directive|define
name|DBR_DBR_TYPE_SFT
value|28
comment|/* 	 * This is a SQ producer index update. It indicates one or more 	 * new entries have been written to the SQ for the QPID 	 * indicated on the xID field. 	 */
define|#
directive|define
name|DBR_DBR_TYPE_SQ
value|(UINT32_C(0x0)<< 28)
comment|/* 	 * This is a RQ producer index update. It indicates one or more 	 * new entries have been written to the RQ for the QPID 	 * indicated on the xID field. 	 */
define|#
directive|define
name|DBR_DBR_TYPE_RQ
value|(UINT32_C(0x1)<< 28)
comment|/* 	 * This is a SRQ producer index update. It indicates one or more 	 * new entries have been written to the SRQ for the SID 	 * indicated on the xID field. 	 */
define|#
directive|define
name|DBR_DBR_TYPE_SRQ
value|(UINT32_C(0x2)<< 28)
comment|/* 	 * This doorbell command arms the SRQ async event. The xID field 	 * must identify the SID that is begin armed. The index field is 	 * will set the arm threshold such that a notification will be 	 * generated if less than that number or SRQ entries are posted. 	 */
define|#
directive|define
name|DBR_DBR_TYPE_SRQ_ARM
value|(UINT32_C(0x3)<< 28)
comment|/* 	 * This is a CQ consumer index update. It indicates one or more 	 * entries have been processed off the CQ indicated on the xID 	 * field. 	 */
define|#
directive|define
name|DBR_DBR_TYPE_CQ
value|(UINT32_C(0x4)<< 28)
comment|/* 	 * this is a CQ consumer index update that also arms the CQ for 	 * solicited events. 	 */
define|#
directive|define
name|DBR_DBR_TYPE_CQ_ARMSE
value|(UINT32_C(0x5)<< 28)
comment|/* 	 * This is a CQ consumer index update that also arms the CQ for 	 * any new CQE. 	 */
define|#
directive|define
name|DBR_DBR_TYPE_CQ_ARMALL
value|(UINT32_C(0x6)<< 28)
comment|/* 	 * This is a CQ arm enable message. This message must be sent 	 * from the privileged driver before a new CQ_ARMSE or CQ_ARMALL 	 * message will be accepted. This doorbell can only be sent from 	 * the privileged (first) doorbell page of a function. 	 */
define|#
directive|define
name|DBR_DBR_TYPE_CQ_ARMENA
value|(UINT32_C(0x7)<< 28)
comment|/* 	 * This doorbell command enables the SRQ async event to be 	 * armed. This message must be setn from the privileged driver 	 * before a new SRQ_ARM message will be accepted. The xID field 	 * must identify the SID that is begin enabled for arm. This 	 * doorbell can only be sent from the privileged (first) 	 * doorbell page of a function. 	 */
define|#
directive|define
name|DBR_DBR_TYPE_SRQ_ARMENA
value|(UINT32_C(0x8)<< 28)
comment|/* 	 * This doorbell command indicates that the cutoff CQE has been 	 * processed and the driver is now processing completions from 	 * the new CQ. The index field for this doorbell type must be 	 * zero. 	 */
define|#
directive|define
name|DBR_DBR_TYPE_CQ_CUTOFF_ACK
value|(UINT32_C(0x9)<< 28)
comment|/* 	 * This doorbell command is used during doorbell moderation to 	 * consume system BW and help prevent doorbell FIFO overflow. 	 * All other fields should be zero for NULL doorbell. 	 */
define|#
directive|define
name|DBR_DBR_TYPE_NULL
value|(UINT32_C(0xf)<< 28)
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* 32b Doorbell Format (4 bytes) */
end_comment

begin_struct
struct|struct
name|dbr_dbr32
block|{
name|uint32_t
name|type_abs_incr_xid
decl_stmt|;
comment|/* This value identifies the type of doorbell being written. */
comment|/* 	 * This value identifies the resource that the doorbell is intended to 	 * notify. For SQ and RQ, this is the QPID. For SRQ, this is the SID. 	 * For CQ, this is the CID. Bits [19:16] of this values must be zero for 	 * a SID value. 	 */
define|#
directive|define
name|DBR_DBR32_XID_MASK
value|UINT32_C(0xfffff)
define|#
directive|define
name|DBR_DBR32_XID_SFT
value|0
define|#
directive|define
name|DBR_DBR32_RESERVED4_MASK
value|UINT32_C(0xf00000)
define|#
directive|define
name|DBR_DBR32_RESERVED4_SFT
value|20
comment|/* 	 * When abs=0, this value is the value to add to the appropriate index 	 * value. When abs=1, this value is the new value for the index. 	 * Absolute value is used when the queue is being wrapped. When abs=1, 	 * the incr value follows the same rules as the index value in the 64b 	 * doorbell. 	 */
define|#
directive|define
name|DBR_DBR32_INCR_MASK
value|UINT32_C(0xf000000)
define|#
directive|define
name|DBR_DBR32_INCR_SFT
value|24
comment|/* This value defines how the incr value will be interpreted. */
define|#
directive|define
name|DBR_DBR32_ABS
value|UINT32_C(0x10000000)
comment|/* This value identifies the type of doorbell being written. */
define|#
directive|define
name|DBR_DBR32_TYPE_MASK
value|UINT32_C(0xe0000000)
define|#
directive|define
name|DBR_DBR32_TYPE_SFT
value|29
comment|/* 	 * This is a SQ producer index update. It indicates one or more 	 * new entries have been written to the SQ for the QPID 	 * indicated on the xID field. 	 */
define|#
directive|define
name|DBR_DBR32_TYPE_SQ
value|(UINT32_C(0x0)<< 29)
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* SQ WQE Structures */
end_comment

begin_comment
comment|/*  * Description: This is the Bind WQE structure. This WQE can perform either: *  * type1 "bind memory window", if mw_type==Type1 * type2 "post send bind memory  * window", if mw_type==Type2  */
end_comment

begin_comment
comment|/* Base SQ WQE (8 bytes) */
end_comment

begin_struct
struct|struct
name|sq_base
block|{
name|uint8_t
name|wqe_type
decl_stmt|;
comment|/* This field defines the type of SQ WQE. */
comment|/* Send */
define|#
directive|define
name|SQ_BASE_WQE_TYPE_SEND
value|UINT32_C(0x0)
comment|/* 	 * Send with Immediate Allowed only on reliable connection (RC) 	 * and unreliable datagram (UD) SQ's. 	 */
define|#
directive|define
name|SQ_BASE_WQE_TYPE_SEND_W_IMMEAD
value|UINT32_C(0x1)
comment|/* 	 * Send with Invalidate. Allowed only on reliable connection 	 * (RC) SQ's. 	 */
define|#
directive|define
name|SQ_BASE_WQE_TYPE_SEND_W_INVALID
value|UINT32_C(0x2)
comment|/* RDMA Write. Allowed only on reliable connection (RC) SQ's. */
define|#
directive|define
name|SQ_BASE_WQE_TYPE_WRITE_WQE
value|UINT32_C(0x4)
comment|/* 	 * RDMA Write with Immediate. Allowed only on reliable 	 * connection (RC) SQ's. 	 */
define|#
directive|define
name|SQ_BASE_WQE_TYPE_WRITE_W_IMMEAD
value|UINT32_C(0x5)
comment|/* RDMA Read. Allowed only on reliable connection (RC) SQ's. */
define|#
directive|define
name|SQ_BASE_WQE_TYPE_READ_WQE
value|UINT32_C(0x6)
comment|/* 	 * Atomic Compare/Swap. Allowed only on reliable connection (RC) 	 * SQ's. 	 */
define|#
directive|define
name|SQ_BASE_WQE_TYPE_ATOMIC_CS
value|UINT32_C(0x8)
comment|/* Atomic Fetch/Add. Allowed only on reliable connection (RC) SQ's. */
define|#
directive|define
name|SQ_BASE_WQE_TYPE_ATOMIC_FA
value|UINT32_C(0xb)
comment|/* Local Invalidate. Allowed only on reliable connection (RC) SQ's. */
define|#
directive|define
name|SQ_BASE_WQE_TYPE_LOCAL_INVALID
value|UINT32_C(0xc)
comment|/* 	 * FR-PMR (Fast Register Physical Memory Region) Allowed only on 	 * reliable connection (RC) SQ's. 	 */
define|#
directive|define
name|SQ_BASE_WQE_TYPE_FR_PMR
value|UINT32_C(0xd)
comment|/* Memory Bind Allowed only on reliable connection (RC) SQ's. */
define|#
directive|define
name|SQ_BASE_WQE_TYPE_BIND
value|UINT32_C(0xe)
name|uint8_t
name|unused_0
index|[
literal|7
index|]
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* WQE SGE (16 bytes) */
end_comment

begin_struct
struct|struct
name|sq_sge
block|{
name|uint64_t
name|va_or_pa
decl_stmt|;
comment|/* 	 * The virtual address in local memory or a physical address when l_key 	 * value is a reserved value of a physical address. Driver configures 	 * this value in the chip and the chip compares l_key in SGEs with that 	 * reserved value, if equal it access the physical address specified. 	 * The chip however MUST verify that the QP allows the use reserved key. 	 */
name|uint32_t
name|l_key
decl_stmt|;
comment|/* 	 * Local Key associated with this registered MR; The 24 msb of the key 	 * used to index the MRW Table and the 8 lsb are compared with the 8 	 * bits key part stored in the MRWC. The PBL in the MRW Context is used 	 * to translate the above VA to physical address. 	 */
name|uint32_t
name|size
decl_stmt|;
comment|/* 	 * Size of SGE in bytes; Based on page size of the system the chip knows 	 * how many entries are in the PBL 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* PSN Search Structure (8 bytes) */
end_comment

begin_struct
struct|struct
name|sq_psn_search
block|{
name|uint32_t
name|opcode_start_psn
decl_stmt|;
comment|/* The opcodes are software defined. */
comment|/* Start PSN. */
define|#
directive|define
name|SQ_PSN_SEARCH_START_PSN_MASK
value|UINT32_C(0xffffff)
define|#
directive|define
name|SQ_PSN_SEARCH_START_PSN_SFT
value|0
comment|/* The opcodes are software defined. */
define|#
directive|define
name|SQ_PSN_SEARCH_OPCODE_MASK
value|UINT32_C(0xff000000)
define|#
directive|define
name|SQ_PSN_SEARCH_OPCODE_SFT
value|24
name|uint32_t
name|flags_next_psn
decl_stmt|;
comment|/* Opcode specific flags. */
comment|/* Next PSN. Equal to the start PSN of the next WQE. */
define|#
directive|define
name|SQ_PSN_SEARCH_NEXT_PSN_MASK
value|UINT32_C(0xffffff)
define|#
directive|define
name|SQ_PSN_SEARCH_NEXT_PSN_SFT
value|0
comment|/* Opcode specific flags. */
define|#
directive|define
name|SQ_PSN_SEARCH_FLAGS_MASK
value|UINT32_C(0xff000000)
define|#
directive|define
name|SQ_PSN_SEARCH_FLAGS_SFT
value|24
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Send SQ WQE (40 bytes) */
end_comment

begin_struct
struct|struct
name|sq_send
block|{
name|uint8_t
name|wqe_type
decl_stmt|;
comment|/* This field defines the type of SQ WQE. */
comment|/* Send */
define|#
directive|define
name|SQ_SEND_WQE_TYPE_SEND
value|UINT32_C(0x0)
comment|/* 	 * Send with Immediate Allowed only on reliable connection (RC) 	 * and unreliable datagram (UD) SQ's. 	 */
define|#
directive|define
name|SQ_SEND_WQE_TYPE_SEND_W_IMMEAD
value|UINT32_C(0x1)
comment|/* 	 * Send with Invalidate. Allowed only on reliable connection 	 * (RC) SQ's. 	 */
define|#
directive|define
name|SQ_SEND_WQE_TYPE_SEND_W_INVALID
value|UINT32_C(0x2)
name|uint8_t
name|flags
decl_stmt|;
comment|/* 	 * Set if completion signaling is requested. If this bit is 0, and the 	 * SQ is configured to support Unsignaled completion the controller 	 * should not generate a CQE unless there was an error. This refers to 	 * the CQE on the sender side. (The se flag refers to the receiver 	 * side). 	 */
define|#
directive|define
name|SQ_SEND_FLAGS_SIGNAL_COMP
value|UINT32_C(0x1)
comment|/* 	 * Indication to complete all previous RDMA Read or Atomic WQEs on the 	 * SQ before executing this WQE. This flag must be zero for a UD send. 	 */
define|#
directive|define
name|SQ_SEND_FLAGS_RD_OR_ATOMIC_FENCE
value|UINT32_C(0x2)
comment|/* 	 * For local invalidate request. Indicate to complete all previous SQ's 	 * WQEs before executing this WQE. This flag must be zero for a UD send. 	 */
define|#
directive|define
name|SQ_SEND_FLAGS_UC_FENCE
value|UINT32_C(0x4)
comment|/* 	 * Solicit event flag. Indication sent in BTH header to the receiver to 	 * generate a Completion Event Notification, i.e. CNQE. This bit should 	 * be set only in the last (or only) packet of the message. 	 */
define|#
directive|define
name|SQ_SEND_FLAGS_SE
value|UINT32_C(0x8)
comment|/* 	 * Indicate that inline data is posted to the SQ in the data area of 	 * this WQE. 	 */
define|#
directive|define
name|SQ_SEND_FLAGS_INLINE
value|UINT32_C(0x10)
name|uint8_t
name|wqe_size
decl_stmt|;
comment|/* 	 * The number of 16 bytes chunks of data including this first word of 	 * the request that are a valid part of the request. The valid 16 bytes 	 * units other than the WQE structure can be SGEs (Scatter Gather 	 * Elements) OR inline data. While this field defines the valid WQE 	 * size. The actual total WQE size is always 128B. 	 */
name|uint8_t
name|reserved8_1
decl_stmt|;
name|uint32_t
name|inv_key_or_imm_data
decl_stmt|;
comment|/* 	 * Either invalidate key (R_Key of the remote host) that will be send 	 * with IETH (Invalidate ETH) if wqe_type is of Send with Invalidate, or 	 * immediate value that will be sent with ImmDt header if wqe_type is 	 * Send with Immediate. 	 */
name|uint32_t
name|length
decl_stmt|;
comment|/* This field represents a 32-bit total data length, in bytes. */
name|uint32_t
name|q_key
decl_stmt|;
comment|/* 	 * When in the SQ of a UD QP, indicates the q_key to be used in the 	 * transmitted packet. However, if the most significant bit of this 	 * field is set, then the q_key will be taken from QP context, rather 	 * than from this field. When in the SQ of a non-UD QP, this field is 	 * reserved and should be filled with zeros. 	 */
name|uint32_t
name|dst_qp
decl_stmt|;
comment|/* 	 * When in the SQ of a UD QP, indicates the destination QP to be used in 	 * the transmitted packet. When in the SQ of a non-UD QP, this field is 	 * reserved and should be filled with zeros. 	 */
define|#
directive|define
name|SQ_SEND_DST_QP_MASK
value|UINT32_C(0xffffff)
define|#
directive|define
name|SQ_SEND_DST_QP_SFT
value|0
define|#
directive|define
name|SQ_SEND_RESERVED8_2_MASK
value|UINT32_C(0xff000000)
define|#
directive|define
name|SQ_SEND_RESERVED8_2_SFT
value|24
name|uint32_t
name|avid
decl_stmt|;
comment|/* This field is reserved for future expansion of the AVID. */
comment|/* 	 * If the serv_type is 'UD', then this field supplies the AVID (Address 	 * Vector ID). 	 */
define|#
directive|define
name|SQ_SEND_AVID_MASK
value|UINT32_C(0xfffff)
define|#
directive|define
name|SQ_SEND_AVID_SFT
value|0
comment|/* This field is reserved for future expansion of the AVID. */
define|#
directive|define
name|SQ_SEND_RESERVED_AVID_MASK
value|UINT32_C(0xfff00000)
define|#
directive|define
name|SQ_SEND_RESERVED_AVID_SFT
value|20
name|uint64_t
name|reserved64
decl_stmt|;
name|uint32_t
name|data
index|[
literal|24
index|]
decl_stmt|;
comment|/* 	 * When inline=0, then this area is filled with from 1 to 6 SGEs based 	 * on the wqe_size field. When inline=1, this area is filled with 	 * payload data for the send based on the length_or_AVID field. Bits 	 * [7:0] of word 0 hold the first byte to go out on the wire. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Send Raw Ethernet and QP1 SQ WQE (40 bytes) */
end_comment

begin_struct
struct|struct
name|sq_send_raweth_qp1
block|{
name|uint8_t
name|wqe_type
decl_stmt|;
comment|/* This field defines the type of SQ WQE. */
comment|/* Send */
define|#
directive|define
name|SQ_SEND_RAWETH_QP1_WQE_TYPE_SEND
value|UINT32_C(0x0)
name|uint8_t
name|flags
decl_stmt|;
comment|/* 	 * Set if completion signaling is requested. If this bit is 0, and the 	 * SQ is configured to support Unsignaled completion the controller 	 * should not generate a CQE unless there was an error. This refers to 	 * the CQE on the sender side. (The se flag refers to the receiver 	 * side). 	 */
define|#
directive|define
name|SQ_SEND_RAWETH_QP1_FLAGS_SIGNAL_COMP
value|UINT32_C(0x1)
comment|/* This flag must be zero for a Raweth or QP1 send. */
define|#
directive|define
name|SQ_SEND_RAWETH_QP1_FLAGS_RD_OR_ATOMIC_FENCE
value|UINT32_C(0x2)
comment|/* This flag must be zero for a Raweth or QP1 send. */
define|#
directive|define
name|SQ_SEND_RAWETH_QP1_FLAGS_UC_FENCE
value|UINT32_C(0x4)
comment|/* This flag must be zero for a Raweth or QP1 send. */
define|#
directive|define
name|SQ_SEND_RAWETH_QP1_FLAGS_SE
value|UINT32_C(0x8)
comment|/* 	 * Indicate that inline data is posted to the SQ in the data area of 	 * this WQE. 	 */
define|#
directive|define
name|SQ_SEND_RAWETH_QP1_FLAGS_INLINE
value|UINT32_C(0x10)
name|uint8_t
name|wqe_size
decl_stmt|;
comment|/* 	 * The number of 16 bytes chunks of data including this first word of 	 * the request that are a valid part of the request. The valid 16 bytes 	 * units other than the WQE structure can be SGEs (Scatter Gather 	 * Elements) OR inline data. While this field defines the valid WQE 	 * size. The actual total WQE size is always 128B. 	 */
name|uint8_t
name|reserved8
decl_stmt|;
name|uint16_t
name|lflags
decl_stmt|;
comment|/* 	 * All bits in this field must be valid on the first BD of a packet. 	 * Their value on other BDs of the packet will be ignored. 	 */
comment|/* 	 * If set to 1, the controller replaces the TCP/UPD checksum fields of 	 * normal TCP/UPD checksum, or the inner TCP/UDP checksum field of the 	 * encapsulated TCP/UDP packets with the hardware calculated TCP/UDP 	 * checksum for the packet associated with this descriptor. This bit 	 * must be valid on the first BD of a packet. 	 */
define|#
directive|define
name|SQ_SEND_RAWETH_QP1_LFLAGS_TCP_UDP_CHKSUM
value|UINT32_C(0x1)
comment|/* 	 * If set to 1, the controller replaces the IP checksum of the normal 	 * packets, or the inner IP checksum of the encapsulated packets with 	 * the hardware calculated IP checksum for the packet associated with 	 * this descriptor. This bit must be valid on the first BD of a packet. 	 */
define|#
directive|define
name|SQ_SEND_RAWETH_QP1_LFLAGS_IP_CHKSUM
value|UINT32_C(0x2)
comment|/* 	 * If set to 1, the controller will not append an Ethernet CRC to the 	 * end of the frame. This bit must be valid on the first BD of a packet. 	 * Packet must be 64B or longer when this flag is set. It is not usefull 	 * to use this bit with any form of TX offload such as CSO or LSO. The 	 * intent is that the packet from the host already has a valid Ethernet 	 * CRC on the packet. 	 */
define|#
directive|define
name|SQ_SEND_RAWETH_QP1_LFLAGS_NOCRC
value|UINT32_C(0x4)
comment|/* 	 * If set to 1, the device will record the time at which the packet was 	 * actually transmitted at the TX MAC. This bit must be valid on the 	 * first BD of a packet. 	 */
define|#
directive|define
name|SQ_SEND_RAWETH_QP1_LFLAGS_STAMP
value|UINT32_C(0x8)
comment|/* 	 * If set to 1, The controller replaces the tunnel IP checksum field 	 * with hardware calculated IP checksum for the IP header of the packet 	 * associated with this descriptor. In case of VXLAN, the controller 	 * also replaces the outer header UDP checksum with hardware calculated 	 * UDP checksum for the packet associated with this descriptor. 	 */
define|#
directive|define
name|SQ_SEND_RAWETH_QP1_LFLAGS_T_IP_CHKSUM
value|UINT32_C(0x10)
comment|/* This bit is reserved and should be zero. */
define|#
directive|define
name|SQ_SEND_RAWETH_QP1_LFLAGS_RESERVED1_1
value|UINT32_C(0x20)
comment|/* This bit is reserved and should be zero. */
define|#
directive|define
name|SQ_SEND_RAWETH_QP1_LFLAGS_RESERVED1_2
value|UINT32_C(0x40)
comment|/* This bit is reserved and should be zero. */
define|#
directive|define
name|SQ_SEND_RAWETH_QP1_LFLAGS_RESERVED1_3
value|UINT32_C(0x80)
comment|/* 	 * If set to '1', then the RoCE ICRC will be appended to the packet. 	 * Packet must be a valid RoCE format packet. 	 */
define|#
directive|define
name|SQ_SEND_RAWETH_QP1_LFLAGS_ROCE_CRC
value|UINT32_C(0x100)
comment|/* 	 * If set to '1', then the FCoE CRC will be appended to the packet. 	 * Packet must be a valid FCoE format packet. 	 */
define|#
directive|define
name|SQ_SEND_RAWETH_QP1_LFLAGS_FCOE_CRC
value|UINT32_C(0x200)
name|uint16_t
name|cfa_action
decl_stmt|;
comment|/* 	 * This value selects a CFA action to perform on the packet. Set this 	 * value to zero if no CFA action is desired. This value must be valid 	 * on the first BD of a packet. 	 */
name|uint32_t
name|length
decl_stmt|;
comment|/* 	 * This field represents a 32-bit total data length, in bytes. Note, 	 * however, that the length cannot exceed the MTU. 	 */
name|uint32_t
name|reserved32_1
decl_stmt|;
name|uint32_t
name|cfa_meta
decl_stmt|;
comment|/* 	 * This value is action meta-data that defines CFA edit operations that 	 * are done in addition to any action editing. 	 */
comment|/* When key=1, This is the VLAN tag VID value. */
define|#
directive|define
name|SQ_SEND_RAWETH_QP1_CFA_META_VLAN_VID_MASK
value|UINT32_C(0xfff)
define|#
directive|define
name|SQ_SEND_RAWETH_QP1_CFA_META_VLAN_VID_SFT
value|0
comment|/* When key=1, This is the VLAN tag DE value. */
define|#
directive|define
name|SQ_SEND_RAWETH_QP1_CFA_META_VLAN_DE
value|UINT32_C(0x1000)
comment|/* When key=1, This is the VLAN tag PRI value. */
define|#
directive|define
name|SQ_SEND_RAWETH_QP1_CFA_META_VLAN_PRI_MASK
value|UINT32_C(0xe000)
define|#
directive|define
name|SQ_SEND_RAWETH_QP1_CFA_META_VLAN_PRI_SFT
value|13
comment|/* When key=1, This is the VLAN tag TPID select value. */
define|#
directive|define
name|SQ_SEND_RAWETH_QP1_CFA_META_VLAN_TPID_MASK
value|UINT32_C(0x70000)
define|#
directive|define
name|SQ_SEND_RAWETH_QP1_CFA_META_VLAN_TPID_SFT
value|16
comment|/* 0x88a8 */
define|#
directive|define
name|SQ_SEND_RAWETH_QP1_CFA_META_VLAN_TPID_TPID88A8
value|(UINT32_C(0x0)<< 16)
comment|/* 0x8100 */
define|#
directive|define
name|SQ_SEND_RAWETH_QP1_CFA_META_VLAN_TPID_TPID8100
value|(UINT32_C(0x1)<< 16)
comment|/* 0x9100 */
define|#
directive|define
name|SQ_SEND_RAWETH_QP1_CFA_META_VLAN_TPID_TPID9100
value|(UINT32_C(0x2)<< 16)
comment|/* 0x9200 */
define|#
directive|define
name|SQ_SEND_RAWETH_QP1_CFA_META_VLAN_TPID_TPID9200
value|(UINT32_C(0x3)<< 16)
comment|/* 0x9300 */
define|#
directive|define
name|SQ_SEND_RAWETH_QP1_CFA_META_VLAN_TPID_TPID9300
value|(UINT32_C(0x4)<< 16)
comment|/* Value programmed in CFA VLANTPID register. */
define|#
directive|define
name|SQ_SEND_RAWETH_QP1_CFA_META_VLAN_TPID_TPIDCFG
value|(UINT32_C(0x5)<< 16)
define|#
directive|define
name|SQ_SEND_RAWETH_QP1_CFA_META_VLAN_TPID_LAST
value|SQ_SEND_RAWETH_QP1_CFA_META_VLAN_TPID_TPIDCFG
comment|/* When key=1, This is the VLAN tag TPID select value. */
define|#
directive|define
name|SQ_SEND_RAWETH_QP1_CFA_META_VLAN_RESERVED_MASK
value|UINT32_C(0xff80000)
define|#
directive|define
name|SQ_SEND_RAWETH_QP1_CFA_META_VLAN_RESERVED_SFT
value|19
comment|/* 	 * This field identifies the type of edit to be performed on the packet. 	 * This value must be valid on the first BD of a packet. 	 */
define|#
directive|define
name|SQ_SEND_RAWETH_QP1_CFA_META_KEY_MASK
value|UINT32_C(0xf0000000)
define|#
directive|define
name|SQ_SEND_RAWETH_QP1_CFA_META_KEY_SFT
value|28
comment|/* No editing */
define|#
directive|define
name|SQ_SEND_RAWETH_QP1_CFA_META_KEY_NONE
value|(UINT32_C(0x0)<< 28)
comment|/* 	 * - meta[17:16] - TPID select value (0 = 0x8100). - meta[15:12] 	 * - PRI/DE value. - meta[11:0] - VID value. 	 */
define|#
directive|define
name|SQ_SEND_RAWETH_QP1_CFA_META_KEY_VLAN_TAG
value|(UINT32_C(0x1)<< 28)
define|#
directive|define
name|SQ_SEND_RAWETH_QP1_CFA_META_KEY_LAST
value|SQ_SEND_RAWETH_QP1_CFA_META_KEY_VLAN_TAG
name|uint32_t
name|reserved32_2
decl_stmt|;
name|uint64_t
name|reserved64
decl_stmt|;
name|uint32_t
name|data
index|[
literal|24
index|]
decl_stmt|;
comment|/* 	 * When inline=0, then this area is filled with from 1 to 6 SGEs based 	 * on the wqe_size field. When inline=1, this area is filled with 	 * payload data for the send based on the length_or_AVID field. Bits 	 * [7:0] of word 0 hold the first byte to go out on the wire. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* RDMA SQ WQE (40 bytes) */
end_comment

begin_struct
struct|struct
name|sq_rdma
block|{
name|uint8_t
name|wqe_type
decl_stmt|;
comment|/* This field defines the type of SQ WQE. */
comment|/* RDMA Write. Allowed only on reliable connection (RC) SQ's. */
define|#
directive|define
name|SQ_RDMA_WQE_TYPE_WRITE_WQE
value|UINT32_C(0x4)
comment|/* 	 * RDMA Write with Immediate. Allowed only on reliable 	 * connection (RC) SQ's. 	 */
define|#
directive|define
name|SQ_RDMA_WQE_TYPE_WRITE_W_IMMEAD
value|UINT32_C(0x5)
comment|/* RDMA Read. Allowed only on reliable connection (RC) SQ's. */
define|#
directive|define
name|SQ_RDMA_WQE_TYPE_READ_WQE
value|UINT32_C(0x6)
name|uint8_t
name|flags
decl_stmt|;
comment|/* 	 * Set if completion signaling is requested. If this bit is 0, and the 	 * SQ is configured to support Unsignaled completion the controller 	 * should not generate a CQE unless there was an error. This refer to 	 * CQE on the sender side (se_flag refer to the receiver side) 	 */
define|#
directive|define
name|SQ_RDMA_FLAGS_SIGNAL_COMP
value|UINT32_C(0x1)
comment|/* 	 * Indication to complete all previous RDMA Read or Atomic WQEs on the 	 * SQ before executing this WQE 	 */
define|#
directive|define
name|SQ_RDMA_FLAGS_RD_OR_ATOMIC_FENCE
value|UINT32_C(0x2)
comment|/* 	 * Unconditional fence. Indicate to complete all previous SQ's WQEs 	 * before executing this WQE. 	 */
define|#
directive|define
name|SQ_RDMA_FLAGS_UC_FENCE
value|UINT32_C(0x4)
comment|/* 	 * Solicit event. Indication sent in BTH header to the receiver to 	 * generate a Completion Event Notification, i.e. CNQE. This bit should 	 * be set only in the last (or only) packet of the message. 	 */
define|#
directive|define
name|SQ_RDMA_FLAGS_SE
value|UINT32_C(0x8)
comment|/* 	 * Indicate that inline data is posted to the SQ following this WQE. 	 * This bit may be 1 only for write operations. 	 */
define|#
directive|define
name|SQ_RDMA_FLAGS_INLINE
value|UINT32_C(0x10)
name|uint8_t
name|wqe_size
decl_stmt|;
comment|/* 	 * The number of 16 bytes chunks of data including this first wqe of the 	 * request that are a valid part of the request. The valid 16 bytes 	 * units other than the WQE structure can be SGEs (Scatter Gather 	 * Elements) OR inline data. While this field defines the valid WQE 	 * size. The actual total WQE size is always 128B. 	 */
name|uint8_t
name|reserved8
decl_stmt|;
name|uint32_t
name|imm_data
decl_stmt|;
comment|/* 	 * Immediate data - valid for RDMA Write with immediate and causes the 	 * controller to add immDt header with this value 	 */
name|uint32_t
name|length
decl_stmt|;
comment|/* Total data length in bytes */
name|uint32_t
name|reserved32_1
decl_stmt|;
name|uint64_t
name|remote_va
decl_stmt|;
comment|/* Remote VA sent to the destination QP */
name|uint32_t
name|remote_key
decl_stmt|;
comment|/* 	 * R_Key provided by remote node when the connection was established and 	 * placed in the RETH header. It identify the MRW on the remote host 	 */
name|uint32_t
name|reserved32_2
decl_stmt|;
name|uint32_t
name|data
index|[
literal|24
index|]
decl_stmt|;
comment|/* 	 * When inline=0, then this area is filled with from 1 to 6 SGEs based 	 * on the wqe_size field. When inline=1, this area is filled with 	 * payload data for the write based on the length field. Bits [7:0] of 	 * word 0 hold the first byte to go out on the wire. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Atomic SQ WQE (40 bytes) */
end_comment

begin_struct
struct|struct
name|sq_atomic
block|{
name|uint8_t
name|wqe_type
decl_stmt|;
comment|/* This field defines the type of SQ WQE. */
comment|/* 	 * Atomic Compare/Swap. Allowed only on reliable connection (RC) 	 * SQ's. 	 */
define|#
directive|define
name|SQ_ATOMIC_WQE_TYPE_ATOMIC_CS
value|UINT32_C(0x8)
comment|/* Atomic Fetch/Add. Allowed only on reliable connection (RC) SQ's. */
define|#
directive|define
name|SQ_ATOMIC_WQE_TYPE_ATOMIC_FA
value|UINT32_C(0xb)
name|uint8_t
name|flags
decl_stmt|;
comment|/* 	 * Set if completion signaling is requested. If this bit is 0, and the 	 * SQ is configured to support Unsignaled completion the controller 	 * should not generate a CQE unless there was an error. This refer to 	 * CQE on the sender side (se_flag refer to the receiver side) 	 */
define|#
directive|define
name|SQ_ATOMIC_FLAGS_SIGNAL_COMP
value|UINT32_C(0x1)
comment|/* 	 * Indication to complete all previous RDMA Read or Atomic WQEs on the 	 * SQ before executing this WQE 	 */
define|#
directive|define
name|SQ_ATOMIC_FLAGS_RD_OR_ATOMIC_FENCE
value|UINT32_C(0x2)
comment|/* 	 * Unconditional fence. Indicate to complete all previous SQ's WQEs 	 * before executing this WQE. 	 */
define|#
directive|define
name|SQ_ATOMIC_FLAGS_UC_FENCE
value|UINT32_C(0x4)
comment|/* 	 * Solicit event. Indication sent in BTH header to the receiver to 	 * generate a Completion Event Notification, i.e. CNQE. This bit should 	 * be set only in the last (or only) packet of the message. 	 */
define|#
directive|define
name|SQ_ATOMIC_FLAGS_SE
value|UINT32_C(0x8)
comment|/* NA for this WQE. */
define|#
directive|define
name|SQ_ATOMIC_FLAGS_INLINE
value|UINT32_C(0x10)
name|uint16_t
name|reserved16
decl_stmt|;
name|uint32_t
name|remote_key
decl_stmt|;
comment|/* 	 * R_Key provided by remote node when the connection was established and 	 * placed in the AETH header. It identify the MRW on the remote host 	 */
name|uint64_t
name|remote_va
decl_stmt|;
comment|/* Remote VA sent to the destination QP */
name|uint64_t
name|swap_data
decl_stmt|;
comment|/* Data value to be placed in remote host specified address */
name|uint64_t
name|cmp_data
decl_stmt|;
comment|/* 	 * Data value to be compared with the value in the remote host specified 	 * address 	 */
name|uint32_t
name|data
index|[
literal|24
index|]
decl_stmt|;
comment|/* 	 * The first 16B of the data field must be filled with a single SGE. 	 * This will be used to store the return value from the Atomic Ack 	 * response. The size of the single SGE must be 8B. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Local Invalidate SQ WQE (40 bytes) */
end_comment

begin_struct
struct|struct
name|sq_localinvalidate
block|{
name|uint8_t
name|wqe_type
decl_stmt|;
comment|/* This field defines the type of SQ WQE. */
comment|/* Local Invalidate. Allowed only on reliable connection (RC) SQ's. */
define|#
directive|define
name|SQ_LOCALINVALIDATE_WQE_TYPE_LOCAL_INVALID
value|UINT32_C(0xc)
name|uint8_t
name|flags
decl_stmt|;
comment|/* 	 * Set if completion signaling is requested. If this bit is 0, and the 	 * SQ is configured to support Unsignaled completion the controller 	 * should not generate a CQE unless there was an error. This refer to 	 * CQE on the sender side (se_flag refer to the receiver side) 	 */
define|#
directive|define
name|SQ_LOCALINVALIDATE_FLAGS_SIGNAL_COMP
value|UINT32_C(0x1)
comment|/* 	 * Indication to complete all previous RDMA Read or Atomic WQEs on the 	 * SQ before executing this WQE 	 */
define|#
directive|define
name|SQ_LOCALINVALIDATE_FLAGS_RD_OR_ATOMIC_FENCE
value|UINT32_C(0x2)
comment|/* 	 * Unconditional fence. Indicate to complete all previous SQ's WQEs 	 * before executing this WQE. 	 */
define|#
directive|define
name|SQ_LOCALINVALIDATE_FLAGS_UC_FENCE
value|UINT32_C(0x4)
comment|/* 	 * Solicit event. Indication sent in BTH header to the receiver to 	 * generate a Completion Event Notification, i.e. CNQE. This bit should 	 * be set only in the last (or only) packet of the message. 	 */
define|#
directive|define
name|SQ_LOCALINVALIDATE_FLAGS_SE
value|UINT32_C(0x8)
comment|/* NA for this WQE */
define|#
directive|define
name|SQ_LOCALINVALIDATE_FLAGS_INLINE
value|UINT32_C(0x10)
name|uint16_t
name|reserved16
decl_stmt|;
name|uint32_t
name|inv_l_key
decl_stmt|;
comment|/* 	 * The local key for the MR/W to invalidate; 24 msb of the key are used 	 * to index the MRW table, 8 lsb are compared with the 8 bit key in the 	 * MRWC 	 */
name|uint64_t
name|reserved64
decl_stmt|;
name|uint32_t
name|reserved128
index|[
literal|4
index|]
decl_stmt|;
name|uint32_t
name|data
index|[
literal|24
index|]
decl_stmt|;
comment|/* The data field for local invalidate is not used. */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* FR-PMR SQ WQE (40 bytes) */
end_comment

begin_struct
struct|struct
name|sq_fr_pmr
block|{
name|uint8_t
name|wqe_type
decl_stmt|;
comment|/* This field defines the type of SQ WQE. */
comment|/* 	 * FR-PMR (Fast Register Physical Memory Region) Allowed only on 	 * reliable connection (RC) SQ's. 	 */
define|#
directive|define
name|SQ_FR_PMR_WQE_TYPE_FR_PMR
value|UINT32_C(0xd)
name|uint8_t
name|flags
decl_stmt|;
comment|/* 	 * Set if completion signaling is requested. If this bit is 0, and the 	 * SQ is configured to support Unsignaled completion the controller 	 * should not generate a CQE unless there was an error. This refer to 	 * CQE on the sender side (se_flag refer to the receiver side) 	 */
define|#
directive|define
name|SQ_FR_PMR_FLAGS_SIGNAL_COMP
value|UINT32_C(0x1)
comment|/* 	 * Indication to complete all previous RDMA Read or Atomic WQEs on the 	 * SQ before executing this WQE 	 */
define|#
directive|define
name|SQ_FR_PMR_FLAGS_RD_OR_ATOMIC_FENCE
value|UINT32_C(0x2)
comment|/* 	 * Unconditional fence. Indicate to complete all previous SQ's WQEs 	 * before executing this WQE. 	 */
define|#
directive|define
name|SQ_FR_PMR_FLAGS_UC_FENCE
value|UINT32_C(0x4)
comment|/* Not Applicable for FR_PMR. Nothing is sent */
define|#
directive|define
name|SQ_FR_PMR_FLAGS_SE
value|UINT32_C(0x8)
comment|/* NA. */
define|#
directive|define
name|SQ_FR_PMR_FLAGS_INLINE
value|UINT32_C(0x10)
name|uint8_t
name|access_cntl
decl_stmt|;
comment|/* 	 * This is the new access control for the MR. '1' means the operation is 	 * allowed. '0' means operation is not allowed. 	 */
comment|/* Local Write Access */
define|#
directive|define
name|SQ_FR_PMR_ACCESS_CNTL_LOCAL_WRITE
value|UINT32_C(0x1)
comment|/* Remote Read Access */
define|#
directive|define
name|SQ_FR_PMR_ACCESS_CNTL_REMOTE_READ
value|UINT32_C(0x2)
comment|/* Remote Write Access */
define|#
directive|define
name|SQ_FR_PMR_ACCESS_CNTL_REMOTE_WRITE
value|UINT32_C(0x4)
comment|/* Remote Atomic Access */
define|#
directive|define
name|SQ_FR_PMR_ACCESS_CNTL_REMOTE_ATOMIC
value|UINT32_C(0x8)
comment|/* Window Binding Allowed */
define|#
directive|define
name|SQ_FR_PMR_ACCESS_CNTL_WINDOW_BIND
value|UINT32_C(0x10)
name|uint8_t
name|zero_based_page_size_log
decl_stmt|;
comment|/* 0 for 4KB page size, ... to 8GB */
define|#
directive|define
name|SQ_FR_PMR_PAGE_SIZE_LOG_MASK
value|UINT32_C(0x1f)
define|#
directive|define
name|SQ_FR_PMR_PAGE_SIZE_LOG_SFT
value|0
comment|/* Page size is 4KB. */
define|#
directive|define
name|SQ_FR_PMR_PAGE_SIZE_LOG_PGSZ_4K
value|UINT32_C(0x0)
comment|/* Page size is 8KB. */
define|#
directive|define
name|SQ_FR_PMR_PAGE_SIZE_LOG_PGSZ_8K
value|UINT32_C(0x1)
comment|/* Page size is 64KB. */
define|#
directive|define
name|SQ_FR_PMR_PAGE_SIZE_LOG_PGSZ_64K
value|UINT32_C(0x4)
comment|/* Page size is 256KB. */
define|#
directive|define
name|SQ_FR_PMR_PAGE_SIZE_LOG_PGSZ_256K
value|UINT32_C(0x6)
comment|/* Page size is 1MB. */
define|#
directive|define
name|SQ_FR_PMR_PAGE_SIZE_LOG_PGSZ_1M
value|UINT32_C(0x8)
comment|/* Page size is 2MB. */
define|#
directive|define
name|SQ_FR_PMR_PAGE_SIZE_LOG_PGSZ_2M
value|UINT32_C(0x9)
comment|/* Page size is 4MB. */
define|#
directive|define
name|SQ_FR_PMR_PAGE_SIZE_LOG_PGSZ_4M
value|UINT32_C(0xa)
comment|/* Page size is 1GB. */
define|#
directive|define
name|SQ_FR_PMR_PAGE_SIZE_LOG_PGSZ_1G
value|UINT32_C(0x12)
comment|/* Indicate the MR is ZBVA (Zero Base VA) */
define|#
directive|define
name|SQ_FR_PMR_ZERO_BASED
value|UINT32_C(0x20)
define|#
directive|define
name|SQ_FR_PMR_RESERVED2_MASK
value|UINT32_C(0xc0)
define|#
directive|define
name|SQ_FR_PMR_RESERVED2_SFT
value|6
name|uint32_t
name|l_key
decl_stmt|;
comment|/* 	 * Local Key; 24 msb of the key are used to index the MRW table, 8 lsb 	 * are assigned to the 8 bit key_lsb field in the MRWC. 	 */
name|uint8_t
name|length
index|[
literal|5
index|]
decl_stmt|;
comment|/* Length in bytes of registered MR */
name|uint8_t
name|reserved8_1
decl_stmt|;
name|uint8_t
name|reserved8_2
decl_stmt|;
name|uint8_t
name|numlevels_pbl_page_size_log
decl_stmt|;
comment|/* Number of levels of PBL for translation */
comment|/* PBL page size. 0 for 4KB page size. */
define|#
directive|define
name|SQ_FR_PMR_PBL_PAGE_SIZE_LOG_MASK
value|UINT32_C(0x1f)
define|#
directive|define
name|SQ_FR_PMR_PBL_PAGE_SIZE_LOG_SFT
value|0
comment|/* Page size is 4KB. */
define|#
directive|define
name|SQ_FR_PMR_PBL_PAGE_SIZE_LOG_PGSZ_4K
value|UINT32_C(0x0)
comment|/* Page size is 8KB. */
define|#
directive|define
name|SQ_FR_PMR_PBL_PAGE_SIZE_LOG_PGSZ_8K
value|UINT32_C(0x1)
comment|/* Page size is 64KB. */
define|#
directive|define
name|SQ_FR_PMR_PBL_PAGE_SIZE_LOG_PGSZ_64K
value|UINT32_C(0x4)
comment|/* Page size is 256KB. */
define|#
directive|define
name|SQ_FR_PMR_PBL_PAGE_SIZE_LOG_PGSZ_256K
value|UINT32_C(0x6)
comment|/* Page size is 1MB. */
define|#
directive|define
name|SQ_FR_PMR_PBL_PAGE_SIZE_LOG_PGSZ_1M
value|UINT32_C(0x8)
comment|/* Page size is 2MB. */
define|#
directive|define
name|SQ_FR_PMR_PBL_PAGE_SIZE_LOG_PGSZ_2M
value|UINT32_C(0x9)
comment|/* Page size is 4MB. */
define|#
directive|define
name|SQ_FR_PMR_PBL_PAGE_SIZE_LOG_PGSZ_4M
value|UINT32_C(0xa)
comment|/* Page size is 1GB. */
define|#
directive|define
name|SQ_FR_PMR_PBL_PAGE_SIZE_LOG_PGSZ_1G
value|UINT32_C(0x12)
define|#
directive|define
name|SQ_FR_PMR_RESERVED1
value|UINT32_C(0x20)
comment|/* Number of levels of PBL for translation */
define|#
directive|define
name|SQ_FR_PMR_NUMLEVELS_MASK
value|UINT32_C(0xc0)
define|#
directive|define
name|SQ_FR_PMR_NUMLEVELS_SFT
value|6
comment|/* 	 * A zero level PBL means that the VA is the physical address 	 * used for the operation. No translation is done by the PTU. 	 */
define|#
directive|define
name|SQ_FR_PMR_NUMLEVELS_PHYSICAL
value|(UINT32_C(0x0)<< 6)
comment|/* 	 * A one layer translation is provided between the logical and 	 * physical address. The PBL points to a physical page that 	 * contains PBE values that point to actual pg_size physical 	 * pages. 	 */
define|#
directive|define
name|SQ_FR_PMR_NUMLEVELS_LAYER1
value|(UINT32_C(0x1)<< 6)
comment|/* 	 * A two layer translation is provided between the logical and 	 * physical address. The PBL points to a physical page that 	 * contains PDE values that in turn point to pbl_pg_size 	 * physical pages that contain PBE values that point to actual 	 * physical pages. 	 */
define|#
directive|define
name|SQ_FR_PMR_NUMLEVELS_LAYER2
value|(UINT32_C(0x2)<< 6)
name|uint64_t
name|pblptr
decl_stmt|;
comment|/* Pointer to the PBL, or PDL depending on number of levels */
name|uint64_t
name|va
decl_stmt|;
comment|/* Local Virtual Address */
name|uint32_t
name|data
index|[
literal|24
index|]
decl_stmt|;
comment|/* The data field for FR-PRM is not used. */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Bind SQ WQE (40 bytes) */
end_comment

begin_struct
struct|struct
name|sq_bind
block|{
name|uint8_t
name|wqe_type
decl_stmt|;
comment|/* This field defines the type of SQ WQE. */
comment|/* Memory Bind Allowed only on reliable connection (RC) SQ's. */
define|#
directive|define
name|SQ_BIND_WQE_TYPE_BIND
value|UINT32_C(0xe)
name|uint8_t
name|flags
decl_stmt|;
comment|/* 	 * Set if completion signaling is requested. If this bit is 0, and the 	 * SQ is configured to support Unsignaled completion the controller 	 * should not generate a CQE unless there was an error. This refer to 	 * CQE on the sender side (se_flag refer to the receiver side) 	 */
define|#
directive|define
name|SQ_BIND_FLAGS_SIGNAL_COMP
value|UINT32_C(0x1)
comment|/* 	 * Indication to complete all previous RDMA Read or Atomic WQEs on the 	 * SQ before executing this WQE 	 */
define|#
directive|define
name|SQ_BIND_FLAGS_RD_OR_ATOMIC_FENCE
value|UINT32_C(0x2)
comment|/* 	 * Unconditional fence. Indicate to complete all previous SQ's WQEs 	 * before executing this WQE. 	 */
define|#
directive|define
name|SQ_BIND_FLAGS_UC_FENCE
value|UINT32_C(0x4)
comment|/* NA, nothing is sent. */
define|#
directive|define
name|SQ_BIND_FLAGS_SE
value|UINT32_C(0x8)
comment|/* NA */
define|#
directive|define
name|SQ_BIND_FLAGS_INLINE
value|UINT32_C(0x10)
name|uint8_t
name|access_cntl
decl_stmt|;
comment|/* 	 * This is the new access control for the MR. '1' means the operation is 	 * allowed. '0' means operation is not allowed. 	 */
comment|/* 	 * Local Write Access. Local accesses are never allowed for memory 	 * windows, so this bit must always be zero in a bind WQE. If this bit 	 * is ever set, the bind will fail with an errored completion. 	 */
define|#
directive|define
name|SQ_BIND_ACCESS_CNTL_LOCAL_WRITE
value|UINT32_C(0x1)
comment|/* Remote Read Access */
define|#
directive|define
name|SQ_BIND_ACCESS_CNTL_REMOTE_READ
value|UINT32_C(0x2)
comment|/* 	 * Remote Write Access. Note that, if this bit is set, then the parent 	 * region to which the window is being bound must allow local writes. If 	 * this is not the case, then the bind will fail with an errored 	 * completion. 	 */
define|#
directive|define
name|SQ_BIND_ACCESS_CNTL_REMOTE_WRITE
value|UINT32_C(0x4)
comment|/* 	 * Remote Atomic Access. Note that, if this bit is set, then the parent 	 * region to which the window is being bound must allow local writes. If 	 * this is not the case, then the bind will fail with an errored 	 * completion. 	 */
define|#
directive|define
name|SQ_BIND_ACCESS_CNTL_REMOTE_ATOMIC
value|UINT32_C(0x8)
comment|/* 	 * Window Binding Allowed. It is never allowed to bind windows to 	 * windows, so this bit must always be zero in a bind WQE. If this bit 	 * is ever set, the bind will fail with an errored completion. 	 */
define|#
directive|define
name|SQ_BIND_ACCESS_CNTL_WINDOW_BIND
value|UINT32_C(0x10)
name|uint8_t
name|reserved8_1
decl_stmt|;
comment|/* reserved8_1 is 8 b */
name|uint8_t
name|mw_type_zero_based
decl_stmt|;
comment|/* 	 * If this bit is set, then the newly-bound memory window will be zero- 	 * based. If clear, then the newly-bound memory window will be non-zero- 	 * based. 	 */
define|#
directive|define
name|SQ_BIND_ZERO_BASED
value|UINT32_C(0x1)
comment|/* 	 * If type1 is specified, then this WQE performs a "bind memory window" 	 * operation on a type1 window. If type2 is specified, then this WQE 	 * performs a "post send bind memory window" operation on a type2 	 * window. Note that the bind WQE cannot change the type of the memory 	 * window. If a "bind memory window" operation is attempted on a memory 	 * window that was allocated as type2, then the bind will fail with an 	 * errored completion, as "bind memory window" is allowed only on type1 	 * memory windows. Similarly, if a "post send bind memory window" 	 * operation is attempted on a memory window that was allocated as 	 * type1, then the bind will fail with an errored completions, as "post 	 * send bind memory window" is allowed only on type2 memory windows. 	 */
define|#
directive|define
name|SQ_BIND_MW_TYPE
value|UINT32_C(0x2)
comment|/* Type 1 Bind Memory Window */
define|#
directive|define
name|SQ_BIND_MW_TYPE_TYPE1
value|(UINT32_C(0x0)<< 1)
comment|/* Type 2 Post Send Bind Memory Window */
define|#
directive|define
name|SQ_BIND_MW_TYPE_TYPE2
value|(UINT32_C(0x1)<< 1)
define|#
directive|define
name|SQ_BIND_RESERVED6_MASK
value|UINT32_C(0xfc)
define|#
directive|define
name|SQ_BIND_RESERVED6_SFT
value|2
name|uint8_t
name|reserved8_2
decl_stmt|;
name|uint16_t
name|reserved16
decl_stmt|;
name|uint32_t
name|parent_l_key
decl_stmt|;
comment|/* 	 * The L_Key of the parent MR; 24 msb of the key are used to index the 	 * MRW table, 8 lsb are compared with the 8 bit key in the MRWC. 	 */
name|uint32_t
name|l_key
decl_stmt|;
comment|/* 	 * Local Key; 24 msb of the key are used to index the memory window 	 * being bound in the MRW table, 8 lsb are assign to the 8 bit key_lsb 	 * field in the MRWC. 	 */
name|uint64_t
name|va
decl_stmt|;
comment|/* Local Virtual Address */
name|uint8_t
name|length
index|[
literal|5
index|]
decl_stmt|;
comment|/* 	 * Length in bytes of registered MW; 40 bits as this is the max size of 	 * an MR/W 	 */
name|uint8_t
name|data_reserved24
index|[
literal|99
index|]
decl_stmt|;
comment|/* The data field for Bind is not used. */
define|#
directive|define
name|SQ_BIND_RESERVED24_MASK
value|UINT32_C(0xffffff00)
define|#
directive|define
name|SQ_BIND_RESERVED24_SFT
value|8
comment|/* The data field for Bind is not used. */
define|#
directive|define
name|SQ_BIND_DATA_MASK
value|UINT32_C(0xffffffff)
define|#
directive|define
name|SQ_BIND_DATA_SFT
value|0
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* RQ/SRQ WQE Structures */
end_comment

begin_comment
comment|/* Description: This is the RQ/SRQ WQE structure. */
end_comment

begin_comment
comment|/* RQ/SRQ WQE (40 bytes) */
end_comment

begin_struct
struct|struct
name|rq_wqe
block|{
name|uint8_t
name|wqe_type
decl_stmt|;
comment|/* wqe_type is 8 b */
comment|/* RQ/SRQ WQE. This WQE is used for posting buffers on an RQ or SRQ. */
define|#
directive|define
name|RQ_WQE_WQE_TYPE_RCV
value|UINT32_C(0x80)
name|uint8_t
name|flags
decl_stmt|;
comment|/* No flags supported for this WQE type. */
name|uint8_t
name|wqe_size
decl_stmt|;
comment|/* 	 * Specify the total number 16B chunks that make up the valid portion of 	 * the WQE. This includes the first chunk that is the WQE structure and 	 * up to 6 SGE structures. While the valid area is defined by the 	 * wqe_size field, the actual WQE size is fixed at 128B. 	 */
name|uint8_t
name|reserved8
decl_stmt|;
name|uint32_t
name|reserved32
decl_stmt|;
name|uint64_t
name|wr_id
decl_stmt|;
comment|/* 	 * Opaque value used by upper layer SW to identify the id of the WR 	 * which generated the WQE. Used in CQE. Valid in the first SGE of an 	 * SRQ WQE. 	 */
define|#
directive|define
name|RQ_WQE_WR_ID_MASK
value|UINT32_C(0xfffff)
define|#
directive|define
name|RQ_WQE_WR_ID_SFT
value|0
define|#
directive|define
name|RQ_WQE_RESERVED44_MASK
value|UINT32_C(0xfff00000)
define|#
directive|define
name|RQ_WQE_RESERVED44_SFT
value|20
name|uint32_t
name|reserved128
index|[
literal|4
index|]
decl_stmt|;
name|uint32_t
name|data
index|[
literal|24
index|]
decl_stmt|;
comment|/* 	 * The data field for RQ WQE is filled with from 1 to 6 SGE structures 	 * as defined by the wqe_size field. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* CQ CQE Structures */
end_comment

begin_comment
comment|/* Description: This is the Cutoff CQE structure. */
end_comment

begin_comment
comment|/* Base CQE (32 bytes) */
end_comment

begin_struct
struct|struct
name|cq_base
block|{
name|uint64_t
name|reserved64_1
decl_stmt|;
name|uint64_t
name|reserved64_2
decl_stmt|;
name|uint64_t
name|reserved64_3
decl_stmt|;
name|uint8_t
name|cqe_type_toggle
decl_stmt|;
comment|/* 	 * Indicate valid completion - written by the chip. Cumulus toggle this 	 * bit each time it finished consuming all PBL entries 	 */
define|#
directive|define
name|CQ_BASE_TOGGLE
value|UINT32_C(0x1)
comment|/* This field defines the type of SQ WQE. */
define|#
directive|define
name|CQ_BASE_CQE_TYPE_MASK
value|UINT32_C(0x1e)
define|#
directive|define
name|CQ_BASE_CQE_TYPE_SFT
value|1
comment|/* 	 * Requester completion - This is used for both RC and UD SQ 	 * completions. 	 */
define|#
directive|define
name|CQ_BASE_CQE_TYPE_REQ
value|(UINT32_C(0x0)<< 1)
comment|/* 	 * Responder RC Completion - This is used for both RQ and SRQ 	 * completions for RC service QPs. 	 */
define|#
directive|define
name|CQ_BASE_CQE_TYPE_RES_RC
value|(UINT32_C(0x1)<< 1)
comment|/* 	 * Responder UD Completion - This is used for both RQ and SRQ 	 * completion for UD service QPs. 	 */
define|#
directive|define
name|CQ_BASE_CQE_TYPE_RES_UD
value|(UINT32_C(0x2)<< 1)
comment|/* 	 * Responder RawEth and QP1 Completion - This is used for RQ 	 * completion for RawEth service and QP1 service QPs. 	 */
define|#
directive|define
name|CQ_BASE_CQE_TYPE_RES_RAWETH_QP1
value|(UINT32_C(0x3)<< 1)
comment|/* 	 * Terminal completion - This is used to indicate that no 	 * further completions will be made for this QP on this CQ. 	 */
define|#
directive|define
name|CQ_BASE_CQE_TYPE_TERMINAL
value|(UINT32_C(0xe)<< 1)
comment|/* Cut off CQE; for CQ resize see CQ and SRQ Resize */
define|#
directive|define
name|CQ_BASE_CQE_TYPE_CUT_OFF
value|(UINT32_C(0xf)<< 1)
define|#
directive|define
name|CQ_BASE_RESERVED3_MASK
value|UINT32_C(0xe0)
define|#
directive|define
name|CQ_BASE_RESERVED3_SFT
value|5
name|uint8_t
name|status
decl_stmt|;
comment|/* This field indicates the status for the CQE. */
name|uint16_t
name|reserved16
decl_stmt|;
name|uint32_t
name|reserved32
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Requester CQ CQE (32 bytes) */
end_comment

begin_struct
struct|struct
name|cq_req
block|{
name|uint64_t
name|qp_handle
decl_stmt|;
comment|/* 	 * This is an application level ID used to identify the QP and its SQ 	 * and RQ. 	 */
name|uint16_t
name|sq_cons_idx
decl_stmt|;
comment|/* 	 * SQ Consumer Index - points to the entry just past the last WQE that 	 * has been completed by the chip. Wraps around at QPC.sq_size (i.e. the 	 * valid range of the SQ Consumer Index is 0 to (QPC.sq_size - 1)). 	 */
name|uint16_t
name|reserved16_1
decl_stmt|;
name|uint32_t
name|reserved32_2
decl_stmt|;
name|uint64_t
name|reserved64
decl_stmt|;
name|uint8_t
name|cqe_type_toggle
decl_stmt|;
comment|/* 	 * Indicate valid completion - written by the chip. Cumulus toggle this 	 * bit each time it finished consuming all PBL entries 	 */
define|#
directive|define
name|CQ_REQ_TOGGLE
value|UINT32_C(0x1)
comment|/* This field defines the type of SQ WQE. */
define|#
directive|define
name|CQ_REQ_CQE_TYPE_MASK
value|UINT32_C(0x1e)
define|#
directive|define
name|CQ_REQ_CQE_TYPE_SFT
value|1
comment|/* 	 * Requester completion - This is used for both RC and UD SQ 	 * completions. 	 */
define|#
directive|define
name|CQ_REQ_CQE_TYPE_REQ
value|(UINT32_C(0x0)<< 1)
define|#
directive|define
name|CQ_REQ_RESERVED3_MASK
value|UINT32_C(0xe0)
define|#
directive|define
name|CQ_REQ_RESERVED3_SFT
value|5
name|uint8_t
name|status
decl_stmt|;
comment|/* This field indicates the status for the CQE. */
comment|/* OK is 0 */
define|#
directive|define
name|CQ_REQ_STATUS_OK
value|UINT32_C(0x0)
comment|/* BAD_RESPONSE_ERR is 1 */
define|#
directive|define
name|CQ_REQ_STATUS_BAD_RESPONSE_ERR
value|UINT32_C(0x1)
comment|/* LOCAL_LENGTH_ERR is 2 */
define|#
directive|define
name|CQ_REQ_STATUS_LOCAL_LENGTH_ERR
value|UINT32_C(0x2)
comment|/* LOCAL_QP_OPERATION_ERR is 3 */
define|#
directive|define
name|CQ_REQ_STATUS_LOCAL_QP_OPERATION_ERR
value|UINT32_C(0x3)
comment|/* LOCAL_PROTECTION_ERR is 4 */
define|#
directive|define
name|CQ_REQ_STATUS_LOCAL_PROTECTION_ERR
value|UINT32_C(0x4)
comment|/* MEMORY_MGT_OPERATION_ERR is 5 */
define|#
directive|define
name|CQ_REQ_STATUS_MEMORY_MGT_OPERATION_ERR
value|UINT32_C(0x5)
comment|/* REMOTE_INVALID_REQUEST_ERR is 6 */
define|#
directive|define
name|CQ_REQ_STATUS_REMOTE_INVALID_REQUEST_ERR
value|UINT32_C(0x6)
comment|/* REMOTE_ACCESS_ERR is 7 */
define|#
directive|define
name|CQ_REQ_STATUS_REMOTE_ACCESS_ERR
value|UINT32_C(0x7)
comment|/* REMOTE_OPERATION_ERR is 8 */
define|#
directive|define
name|CQ_REQ_STATUS_REMOTE_OPERATION_ERR
value|UINT32_C(0x8)
comment|/* RNR_NAK_RETRY_CNT_ERR is 9 */
define|#
directive|define
name|CQ_REQ_STATUS_RNR_NAK_RETRY_CNT_ERR
value|UINT32_C(0x9)
comment|/* TRANSPORT_RETRY_CNT_ERR is 10 */
define|#
directive|define
name|CQ_REQ_STATUS_TRANSPORT_RETRY_CNT_ERR
value|UINT32_C(0xa)
comment|/* WORK_REQUEST_FLUSHED_ERR is 11 */
define|#
directive|define
name|CQ_REQ_STATUS_WORK_REQUEST_FLUSHED_ERR
value|UINT32_C(0xb)
name|uint16_t
name|reserved16_2
decl_stmt|;
name|uint32_t
name|reserved32_1
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Responder RC CQE (32 bytes) */
end_comment

begin_struct
struct|struct
name|cq_res_rc
block|{
name|uint32_t
name|length
decl_stmt|;
comment|/* The length of the message's payload in bytes, stored in the SGEs */
name|uint32_t
name|imm_data_or_inv_r_key
decl_stmt|;
comment|/* 	 * Immediate data in case the imm_flag set, R_Key to be invalidated in 	 * case inv_flag is set. 	 */
name|uint64_t
name|qp_handle
decl_stmt|;
comment|/* 	 * This is an application level ID used to identify the QP and its SQ 	 * and RQ. 	 */
name|uint64_t
name|mr_handle
decl_stmt|;
comment|/* 	 * Opaque value - valid when inv_flag is set. Used by driver to 	 * reference the buffer used to store PBL when the MR was fast 	 * registered. The driver can reclaim this buffer after an MR was 	 * remotely invalidated. The controller take that value from the MR 	 * referenced by R_Key 	 */
name|uint8_t
name|cqe_type_toggle
decl_stmt|;
comment|/* 	 * Indicate valid completion - written by the chip. Cumulus toggle this 	 * bit each time it finished consuming all PBL entries 	 */
define|#
directive|define
name|CQ_RES_RC_TOGGLE
value|UINT32_C(0x1)
comment|/* This field defines the type of SQ WQE. */
define|#
directive|define
name|CQ_RES_RC_CQE_TYPE_MASK
value|UINT32_C(0x1e)
define|#
directive|define
name|CQ_RES_RC_CQE_TYPE_SFT
value|1
comment|/* 	 * Responder RC Completion - This is used for both RQ and SRQ 	 * completions for RC service QPs. 	 */
define|#
directive|define
name|CQ_RES_RC_CQE_TYPE_RES_RC
value|(UINT32_C(0x1)<< 1)
define|#
directive|define
name|CQ_RES_RC_RESERVED3_MASK
value|UINT32_C(0xe0)
define|#
directive|define
name|CQ_RES_RC_RESERVED3_SFT
value|5
name|uint8_t
name|status
decl_stmt|;
comment|/* This field indicates the status for the CQE. */
comment|/* OK is 0 */
define|#
directive|define
name|CQ_RES_RC_STATUS_OK
value|UINT32_C(0x0)
comment|/* LOCAL_ACCESS_ERROR is 1 */
define|#
directive|define
name|CQ_RES_RC_STATUS_LOCAL_ACCESS_ERROR
value|UINT32_C(0x1)
comment|/* LOCAL_LENGTH_ERR is 2 */
define|#
directive|define
name|CQ_RES_RC_STATUS_LOCAL_LENGTH_ERR
value|UINT32_C(0x2)
comment|/* LOCAL_PROTECTION_ERR is 3 */
define|#
directive|define
name|CQ_RES_RC_STATUS_LOCAL_PROTECTION_ERR
value|UINT32_C(0x3)
comment|/* LOCAL_QP_OPERATION_ERR is 4 */
define|#
directive|define
name|CQ_RES_RC_STATUS_LOCAL_QP_OPERATION_ERR
value|UINT32_C(0x4)
comment|/* MEMORY_MGT_OPERATION_ERR is 5 */
define|#
directive|define
name|CQ_RES_RC_STATUS_MEMORY_MGT_OPERATION_ERR
value|UINT32_C(0x5)
comment|/* REMOTE_INVALID_REQUEST_ERR is 6 */
define|#
directive|define
name|CQ_RES_RC_STATUS_REMOTE_INVALID_REQUEST_ERR
value|UINT32_C(0x6)
comment|/* WORK_REQUEST_FLUSHED_ERR is 7 */
define|#
directive|define
name|CQ_RES_RC_STATUS_WORK_REQUEST_FLUSHED_ERR
value|UINT32_C(0x7)
comment|/* HW_FLUSH_ERR is 8 */
define|#
directive|define
name|CQ_RES_RC_STATUS_HW_FLUSH_ERR
value|UINT32_C(0x8)
name|uint16_t
name|flags
decl_stmt|;
comment|/* 	 * This flag indicates that the completion is for a SRQ entry rather 	 * than for an RQ entry. 	 */
define|#
directive|define
name|CQ_RES_RC_FLAGS_SRQ
value|UINT32_C(0x1)
comment|/* CQE relates to RQ WQE. */
define|#
directive|define
name|CQ_RES_RC_FLAGS_SRQ_RQ
value|(UINT32_C(0x0)<< 0)
comment|/* CQE relates to SRQ WQE. */
define|#
directive|define
name|CQ_RES_RC_FLAGS_SRQ_SRQ
value|(UINT32_C(0x1)<< 0)
define|#
directive|define
name|CQ_RES_RC_FLAGS_SRQ_LAST
value|CQ_RES_RC_FLAGS_SRQ_SRQ
comment|/* Immediate data indicator */
define|#
directive|define
name|CQ_RES_RC_FLAGS_IMM
value|UINT32_C(0x2)
comment|/* R_Key invalidate indicator */
define|#
directive|define
name|CQ_RES_RC_FLAGS_INV
value|UINT32_C(0x4)
define|#
directive|define
name|CQ_RES_RC_FLAGS_RDMA
value|UINT32_C(0x8)
comment|/* CQE relates to an incoming Send request */
define|#
directive|define
name|CQ_RES_RC_FLAGS_RDMA_SEND
value|(UINT32_C(0x0)<< 3)
comment|/* CQE relates to incoming RDMA Write request */
define|#
directive|define
name|CQ_RES_RC_FLAGS_RDMA_RDMA_WRITE
value|(UINT32_C(0x1)<< 3)
define|#
directive|define
name|CQ_RES_RC_FLAGS_RDMA_LAST
value|CQ_RES_RC_FLAGS_RDMA_RDMA_WRITE
name|uint32_t
name|srq_or_rq_wr_id
decl_stmt|;
comment|/* 	 * Opaque value from RQ or SRQ WQE. Used by driver/lib to reference the 	 * WQE in order to claim the received data and reuse the WQE space 	 */
define|#
directive|define
name|CQ_RES_RC_SRQ_OR_RQ_WR_ID_MASK
value|UINT32_C(0xfffff)
define|#
directive|define
name|CQ_RES_RC_SRQ_OR_RQ_WR_ID_SFT
value|0
define|#
directive|define
name|CQ_RES_RC_RESERVED12_MASK
value|UINT32_C(0xfff00000)
define|#
directive|define
name|CQ_RES_RC_RESERVED12_SFT
value|20
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Responder UD CQE (32 bytes) */
end_comment

begin_struct
struct|struct
name|cq_res_ud
block|{
name|uint32_t
name|length
decl_stmt|;
comment|/* The length of the message's payload in bytes, stored in the SGEs */
define|#
directive|define
name|CQ_RES_UD_LENGTH_MASK
value|UINT32_C(0x3fff)
define|#
directive|define
name|CQ_RES_UD_LENGTH_SFT
value|0
define|#
directive|define
name|CQ_RES_UD_RESERVED18_MASK
value|UINT32_C(0xffffc000)
define|#
directive|define
name|CQ_RES_UD_RESERVED18_SFT
value|14
name|uint32_t
name|imm_data
decl_stmt|;
comment|/* Immediate data in case the imm_flag set. */
name|uint64_t
name|qp_handle
decl_stmt|;
comment|/* 	 * This is an application level ID used to identify the QP and its SQ 	 * and RQ. 	 */
name|uint16_t
name|src_mac
index|[
literal|3
index|]
decl_stmt|;
comment|/* 	 * Source MAC address for the UD message placed in the WQE that is 	 * completed by this CQE. 	 */
name|uint16_t
name|src_qp_low
decl_stmt|;
comment|/* Lower 16b of the Source QP value from the DETH header. */
name|uint8_t
name|cqe_type_toggle
decl_stmt|;
comment|/* 	 * Indicate valid completion - written by the chip. Cumulus toggle this 	 * bit each time it finished consuming all PBL entries 	 */
define|#
directive|define
name|CQ_RES_UD_TOGGLE
value|UINT32_C(0x1)
comment|/* This field defines the type of SQ WQE. */
define|#
directive|define
name|CQ_RES_UD_CQE_TYPE_MASK
value|UINT32_C(0x1e)
define|#
directive|define
name|CQ_RES_UD_CQE_TYPE_SFT
value|1
comment|/* 	 * Responder UD Completion - This is used for both RQ and SRQ 	 * completion for UD service QPs. 	 */
define|#
directive|define
name|CQ_RES_UD_CQE_TYPE_RES_UD
value|(UINT32_C(0x2)<< 1)
define|#
directive|define
name|CQ_RES_UD_RESERVED3_MASK
value|UINT32_C(0xe0)
define|#
directive|define
name|CQ_RES_UD_RESERVED3_SFT
value|5
name|uint8_t
name|status
decl_stmt|;
comment|/* This field indicates the status for the CQE. */
comment|/* 	 * This indicates that the completion is without error. All 	 * fields are valid. 	 */
define|#
directive|define
name|CQ_RES_UD_STATUS_OK
value|UINT32_C(0x0)
comment|/* 	 * This indicates that write access was not allowed for at least 	 * one of the SGEs in the WQE. This is a fatal error. Only the 	 * srq_or_rq_wr_id is field is valid. 	 */
define|#
directive|define
name|CQ_RES_UD_STATUS_LOCAL_ACCESS_ERROR
value|UINT32_C(0x1)
comment|/* 	 * This indicates that the packet was too long for the WQE 	 * provided on the SRQ/RQ. This is not a fatal error. All the 	 * fields are valid. 	 */
define|#
directive|define
name|CQ_RES_UD_STATUS_HW_LOCAL_LENGTH_ERR
value|UINT32_C(0x2)
comment|/* LOCAL_PROTECTION_ERR is 3 */
define|#
directive|define
name|CQ_RES_UD_STATUS_LOCAL_PROTECTION_ERR
value|UINT32_C(0x3)
comment|/* LOCAL_QP_OPERATION_ERR is 4 */
define|#
directive|define
name|CQ_RES_UD_STATUS_LOCAL_QP_OPERATION_ERR
value|UINT32_C(0x4)
comment|/* MEMORY_MGT_OPERATION_ERR is 5 */
define|#
directive|define
name|CQ_RES_UD_STATUS_MEMORY_MGT_OPERATION_ERR
value|UINT32_C(0x5)
comment|/* WORK_REQUEST_FLUSHED_ERR is 7 */
define|#
directive|define
name|CQ_RES_UD_STATUS_WORK_REQUEST_FLUSHED_ERR
value|UINT32_C(0x7)
comment|/* HW_FLUSH_ERR is 8 */
define|#
directive|define
name|CQ_RES_UD_STATUS_HW_FLUSH_ERR
value|UINT32_C(0x8)
name|uint16_t
name|flags
decl_stmt|;
comment|/* 	 * This flag indicates that the completion is for a SRQ entry rather 	 * than for an RQ entry. 	 */
define|#
directive|define
name|CQ_RES_UD_FLAGS_SRQ
value|UINT32_C(0x1)
comment|/* CQE relates to RQ WQE. */
define|#
directive|define
name|CQ_RES_UD_FLAGS_SRQ_RQ
value|(UINT32_C(0x0)<< 0)
comment|/* CQE relates to SRQ WQE. */
define|#
directive|define
name|CQ_RES_UD_FLAGS_SRQ_SRQ
value|(UINT32_C(0x1)<< 0)
define|#
directive|define
name|CQ_RES_UD_FLAGS_SRQ_LAST
value|CQ_RES_UD_FLAGS_SRQ_SRQ
comment|/* Immediate data indicator */
define|#
directive|define
name|CQ_RES_UD_FLAGS_IMM
value|UINT32_C(0x2)
define|#
directive|define
name|CQ_RES_UD_FLAGS_ROCE_IP_VER_MASK
value|UINT32_C(0xc)
define|#
directive|define
name|CQ_RES_UD_FLAGS_ROCE_IP_VER_SFT
value|2
comment|/* RoCEv1 Message */
define|#
directive|define
name|CQ_RES_UD_FLAGS_ROCE_IP_VER_V1
value|(UINT32_C(0x0)<< 2)
comment|/* RoCEv2 IPv4 Message */
define|#
directive|define
name|CQ_RES_UD_FLAGS_ROCE_IP_VER_V2IPV4
value|(UINT32_C(0x2)<< 2)
comment|/* RoCEv2 IPv6 Message */
define|#
directive|define
name|CQ_RES_UD_FLAGS_ROCE_IP_VER_V2IPV6
value|(UINT32_C(0x3)<< 2)
define|#
directive|define
name|CQ_RES_UD_FLAGS_ROCE_IP_VER_LAST
value|CQ_RES_UD_FLAGS_ROCE_IP_VER_V2IPV6
name|uint32_t
name|src_qp_high_srq_or_rq_wr_id
decl_stmt|;
comment|/* Upper 8b of the Source QP value from the DETH header. */
comment|/* 	 * Opaque value from RQ or SRQ WQE. Used by driver/lib to reference the 	 * WQE in order to claim the received data and reuse the WQE space 	 */
define|#
directive|define
name|CQ_RES_UD_SRQ_OR_RQ_WR_ID_MASK
value|UINT32_C(0xfffff)
define|#
directive|define
name|CQ_RES_UD_SRQ_OR_RQ_WR_ID_SFT
value|0
define|#
directive|define
name|CQ_RES_UD_RESERVED4_MASK
value|UINT32_C(0xf00000)
define|#
directive|define
name|CQ_RES_UD_RESERVED4_SFT
value|20
comment|/* Upper 8b of the Source QP value from the DETH header. */
define|#
directive|define
name|CQ_RES_UD_SRC_QP_HIGH_MASK
value|UINT32_C(0xff000000)
define|#
directive|define
name|CQ_RES_UD_SRC_QP_HIGH_SFT
value|24
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Responder RawEth and QP1 CQE (32 bytes) */
end_comment

begin_struct
struct|struct
name|cq_res_raweth_qp1
block|{
name|uint16_t
name|length
decl_stmt|;
comment|/* The length of the message's payload in bytes, stored in the SGEs */
define|#
directive|define
name|CQ_RES_RAWETH_QP1_LENGTH_MASK
value|UINT32_C(0x3fff)
define|#
directive|define
name|CQ_RES_RAWETH_QP1_LENGTH_SFT
value|0
define|#
directive|define
name|CQ_RES_RAWETH_QP1_RESERVED2_MASK
value|UINT32_C(0xc000)
define|#
directive|define
name|CQ_RES_RAWETH_QP1_RESERVED2_SFT
value|14
name|uint16_t
name|raweth_qp1_flags
decl_stmt|;
comment|/* 	 * When this bit is '1', it indicates a packet that has an error of some 	 * type. Type of error is indicated in raweth_qp1_errors. 	 */
define|#
directive|define
name|CQ_RES_RAWETH_QP1_RAWETH_QP1_FLAGS_ERROR
value|UINT32_C(0x1)
define|#
directive|define
name|CQ_RES_RAWETH_QP1_RAWETH_QP1_FLAGS_RESERVED5_1_MASK
value|UINT32_C(0x3e)
define|#
directive|define
name|CQ_RES_RAWETH_QP1_RAWETH_QP1_FLAGS_RESERVED5_1_SFT
value|1
comment|/* 	 * This value indicates what the inner packet determined for the packet 	 * was. 	 */
define|#
directive|define
name|CQ_RES_RAWETH_QP1_RAWETH_QP1_FLAGS_ITYPE_MASK
value|UINT32_C(0x3c0)
define|#
directive|define
name|CQ_RES_RAWETH_QP1_RAWETH_QP1_FLAGS_ITYPE_SFT
value|6
comment|/* Not Known: Indicates that the packet type was not known. */
define|#
directive|define
name|CQ_RES_RAWETH_QP1_RAWETH_QP1_FLAGS_ITYPE_NOT_KNOWN
value|(UINT32_C(0x0)<< 6)
comment|/* 	 * IP Packet: Indicates that the packet was an IP packet, but 	 * further classification was not possible. 	 */
define|#
directive|define
name|CQ_RES_RAWETH_QP1_RAWETH_QP1_FLAGS_ITYPE_IP
value|(UINT32_C(0x1)<< 6)
comment|/* 	 * TCP Packet: Indicates that the packet was IP and TCP. This 	 * indicates that the raweth_qp1_payload_offset field is valid. 	 */
define|#
directive|define
name|CQ_RES_RAWETH_QP1_RAWETH_QP1_FLAGS_ITYPE_TCP
value|(UINT32_C(0x2)<< 6)
comment|/* 	 * UDP Packet: Indicates that the packet was IP and UDP. This 	 * indicates that the raweth_qp1_payload_offset field is valid. 	 */
define|#
directive|define
name|CQ_RES_RAWETH_QP1_RAWETH_QP1_FLAGS_ITYPE_UDP
value|(UINT32_C(0x3)<< 6)
comment|/* 	 * FCoE Packet: Indicates that the packet was recognized as a 	 * FCoE. This also indicates that the raweth_qp1_payload_offset 	 * field is valid. 	 */
define|#
directive|define
name|CQ_RES_RAWETH_QP1_RAWETH_QP1_FLAGS_ITYPE_FCOE
value|(UINT32_C(0x4)<< 6)
comment|/* 	 * RoCE Packet: Indicates that the packet was recognized as a 	 * RoCE. This also indicates that the raweth_qp1_payload_offset 	 * field is valid. 	 */
define|#
directive|define
name|CQ_RES_RAWETH_QP1_RAWETH_QP1_FLAGS_ITYPE_ROCE
value|(UINT32_C(0x5)<< 6)
comment|/* 	 * ICMP Packet: Indicates that the packet was recognized as 	 * ICMP. This indicates that the raweth_qp1_payload_offset field 	 * is valid. 	 */
define|#
directive|define
name|CQ_RES_RAWETH_QP1_RAWETH_QP1_FLAGS_ITYPE_ICMP
value|(UINT32_C(0x7)<< 6)
comment|/* 	 * PtP packet wo/timestamp: Indicates that the packet was 	 * recognized as a PtP packet. 	 */
define|#
directive|define
name|CQ_RES_RAWETH_QP1_RAWETH_QP1_FLAGS_ITYPE_PTP_WO_TIMESTAMP
value|(UINT32_C(0x8)<< 6)
comment|/* 	 * PtP packet w/timestamp: Indicates that the packet was 	 * recognized as a PtP packet and that a timestamp was taken for 	 * the packet. 	 */
define|#
directive|define
name|CQ_RES_RAWETH_QP1_RAWETH_QP1_FLAGS_ITYPE_PTP_W_TIMESTAMP
value|(UINT32_C(0x9)<< 6)
define|#
directive|define
name|CQ_RES_RAWETH_QP1_RAWETH_QP1_FLAGS_ITYPE_LAST
value|CQ_RES_RAWETH_QP1_RAWETH_QP1_FLAGS_ITYPE_PTP_W_TIMESTAMP
define|#
directive|define
name|CQ_RES_RAWETH_QP1_RAWETH_QP1_FLAGS_MASK
value|UINT32_C(0x3ff)
define|#
directive|define
name|CQ_RES_RAWETH_QP1_RAWETH_QP1_FLAGS_SFT
value|0
define|#
directive|define
name|CQ_RES_RAWETH_QP1_RESERVED6_MASK
value|UINT32_C(0xfc00)
define|#
directive|define
name|CQ_RES_RAWETH_QP1_RESERVED6_SFT
value|10
name|uint16_t
name|raweth_qp1_errors
decl_stmt|;
define|#
directive|define
name|CQ_RES_RAWETH_QP1_RAWETH_QP1_ERRORS_RESERVED4_MASK
value|UINT32_C(0xf)
define|#
directive|define
name|CQ_RES_RAWETH_QP1_RAWETH_QP1_ERRORS_RESERVED4_SFT
value|0
comment|/* This indicates that there was an error in the IP header checksum. */
define|#
directive|define
name|CQ_RES_RAWETH_QP1_RAWETH_QP1_ERRORS_IP_CS_ERROR
value|UINT32_C(0x10)
comment|/* 	 * This indicates that there was an error in the TCP, UDP or ICMP 	 * checksum. 	 */
define|#
directive|define
name|CQ_RES_RAWETH_QP1_RAWETH_QP1_ERRORS_L4_CS_ERROR
value|UINT32_C(0x20)
comment|/* 	 * This indicates that there was an error in the tunnel IP header 	 * checksum. 	 */
define|#
directive|define
name|CQ_RES_RAWETH_QP1_RAWETH_QP1_ERRORS_T_IP_CS_ERROR
value|UINT32_C(0x40)
comment|/* This indicates that there was an error in the tunnel UDP checksum. */
define|#
directive|define
name|CQ_RES_RAWETH_QP1_RAWETH_QP1_ERRORS_T_L4_CS_ERROR
value|UINT32_C(0x80)
comment|/* 	 * This indicates that there was a CRC error on either an FCoE or RoCE 	 * packet. The itype indicates the packet type. 	 */
define|#
directive|define
name|CQ_RES_RAWETH_QP1_RAWETH_QP1_ERRORS_CRC_ERROR
value|UINT32_C(0x100)
comment|/* 	 * This indicates that there was an error in the tunnel portion of the 	 * packet when this field is non-zero. 	 */
define|#
directive|define
name|CQ_RES_RAWETH_QP1_RAWETH_QP1_ERRORS_T_PKT_ERROR_MASK
value|UINT32_C(0xe00)
define|#
directive|define
name|CQ_RES_RAWETH_QP1_RAWETH_QP1_ERRORS_T_PKT_ERROR_SFT
value|9
comment|/* 	 * No additional error occurred on the tunnel portion of the 	 * packet of the packet does not have a tunnel. 	 */
define|#
directive|define
name|CQ_RES_RAWETH_QP1_RAWETH_QP1_ERRORS_T_PKT_ERROR_NO_ERROR
value|(UINT32_C(0x0)<< 9)
comment|/* 	 * Indicates that IP header version does not match expectation 	 * from L2 Ethertype for IPv4 and IPv6 in the tunnel header. 	 */
define|#
directive|define
name|CQ_RES_RAWETH_QP1_RAWETH_QP1_ERRORS_T_PKT_ERROR_T_L3_BAD_VERSION
value|(UINT32_C(0x1)<< 9)
comment|/* 	 * Indicates that header length is out of range in the tunnel 	 * header. Valid for IPv4. 	 */
define|#
directive|define
name|CQ_RES_RAWETH_QP1_RAWETH_QP1_ERRORS_T_PKT_ERROR_T_L3_BAD_HDR_LEN
value|(UINT32_C(0x2)<< 9)
comment|/* 	 * Indicates that the physical packet is shorter than that 	 * claimed by the PPPoE header length for a tunnel PPPoE packet. 	 */
define|#
directive|define
name|CQ_RES_RAWETH_QP1_RAWETH_QP1_ERRORS_T_PKT_ERROR_TUNNEL_TOTAL_ERROR
value|(UINT32_C(0x3)<< 9)
comment|/* 	 * Indicates that physical packet is shorter than that claimed 	 * by the tunnel l3 header length. Valid for IPv4, or IPv6 	 * tunnel packet packets. 	 */
define|#
directive|define
name|CQ_RES_RAWETH_QP1_RAWETH_QP1_ERRORS_T_PKT_ERROR_T_IP_TOTAL_ERROR
value|(UINT32_C(0x4)<< 9)
comment|/* 	 * Indicates that the physical packet is shorter than that 	 * claimed by the tunnel UDP header length for a tunnel UDP 	 * packet that is not fragmented. 	 */
define|#
directive|define
name|CQ_RES_RAWETH_QP1_RAWETH_QP1_ERRORS_T_PKT_ERROR_T_UDP_TOTAL_ERROR
value|(UINT32_C(0x5)<< 9)
comment|/* 	 * indicates that the IPv4 TTL or IPv6 hop limit check have 	 * failed (e.g. TTL = 0) in the tunnel header. Valid for IPv4, 	 * and IPv6. 	 */
define|#
directive|define
name|CQ_RES_RAWETH_QP1_RAWETH_QP1_ERRORS_T_PKT_ERROR_T_L3_BAD_TTL
value|(UINT32_C(0x6)<< 9)
define|#
directive|define
name|CQ_RES_RAWETH_QP1_RAWETH_QP1_ERRORS_T_PKT_ERROR_LAST
value|CQ_RES_RAWETH_QP1_RAWETH_QP1_ERRORS_T_PKT_ERROR_T_L3_BAD_TTL
comment|/* 	 * This indicates that there was an error in the inner portion of the 	 * packet when this field is non-zero. 	 */
define|#
directive|define
name|CQ_RES_RAWETH_QP1_RAWETH_QP1_ERRORS_PKT_ERROR_MASK
value|UINT32_C(0xf000)
define|#
directive|define
name|CQ_RES_RAWETH_QP1_RAWETH_QP1_ERRORS_PKT_ERROR_SFT
value|12
comment|/* 	 * No additional error occurred on the tunnel portion of the 	 * packet of the packet does not have a tunnel. 	 */
define|#
directive|define
name|CQ_RES_RAWETH_QP1_RAWETH_QP1_ERRORS_PKT_ERROR_NO_ERROR
value|(UINT32_C(0x0)<< 12)
comment|/* 	 * Indicates that IP header version does not match expectation 	 * from L2 Ethertype for IPv4 and IPv6 or that option other than 	 * VFT was parsed on FCoE packet. 	 */
define|#
directive|define
name|CQ_RES_RAWETH_QP1_RAWETH_QP1_ERRORS_PKT_ERROR_L3_BAD_VERSION
value|(UINT32_C(0x1)<< 12)
comment|/* 	 * indicates that header length is out of range. Valid for IPv4 	 * and RoCE 	 */
define|#
directive|define
name|CQ_RES_RAWETH_QP1_RAWETH_QP1_ERRORS_PKT_ERROR_L3_BAD_HDR_LEN
value|(UINT32_C(0x2)<< 12)
comment|/* 	 * indicates that the IPv4 TTL or IPv6 hop limit check have 	 * failed (e.g. TTL = 0). Valid for IPv4, and IPv6 	 */
define|#
directive|define
name|CQ_RES_RAWETH_QP1_RAWETH_QP1_ERRORS_PKT_ERROR_L3_BAD_TTL
value|(UINT32_C(0x3)<< 12)
comment|/* 	 * Indicates that physical packet is shorter than that claimed 	 * by the l3 header length. Valid for IPv4, IPv6 packet or RoCE 	 * packets. 	 */
define|#
directive|define
name|CQ_RES_RAWETH_QP1_RAWETH_QP1_ERRORS_PKT_ERROR_IP_TOTAL_ERROR
value|(UINT32_C(0x4)<< 12)
comment|/* 	 * Indicates that the physical packet is shorter than that 	 * claimed by the UDP header length for a UDP packet that is not 	 * fragmented. 	 */
define|#
directive|define
name|CQ_RES_RAWETH_QP1_RAWETH_QP1_ERRORS_PKT_ERROR_UDP_TOTAL_ERROR
value|(UINT32_C(0x5)<< 12)
comment|/* 	 * Indicates that TCP header length> IP payload. Valid for TCP 	 * packets only. 	 */
define|#
directive|define
name|CQ_RES_RAWETH_QP1_RAWETH_QP1_ERRORS_PKT_ERROR_L4_BAD_HDR_LEN
value|(UINT32_C(0x6)<< 12)
comment|/* Indicates that TCP header length< 5. Valid for TCP. */
define|#
directive|define
name|CQ_RES_RAWETH_QP1_RAWETH_QP1_ERRORS_PKT_ERROR_L4_BAD_HDR_LEN_TOO_SMALL
value|(UINT32_C(0x7)<< 12)
comment|/* 	 * Indicates that TCP option headers result in a TCP header size 	 * that does not match data offset in TCP header. Valid for TCP. 	 */
define|#
directive|define
name|CQ_RES_RAWETH_QP1_RAWETH_QP1_ERRORS_PKT_ERROR_L4_BAD_OPT_LEN
value|(UINT32_C(0x8)<< 12)
define|#
directive|define
name|CQ_RES_RAWETH_QP1_RAWETH_QP1_ERRORS_PKT_ERROR_LAST
value|CQ_RES_RAWETH_QP1_RAWETH_QP1_ERRORS_PKT_ERROR_L4_BAD_OPT_LEN
name|uint16_t
name|raweth_qp1_cfa_code
decl_stmt|;
comment|/* 	 * This field identifies the CFA action rule that was used for this 	 * packet. 	 */
name|uint64_t
name|qp_handle
decl_stmt|;
comment|/* 	 * This is an application level ID used to identify the QP and its SQ 	 * and RQ. 	 */
name|uint32_t
name|raweth_qp1_flags2
decl_stmt|;
comment|/* 	 * This indicates that the ip checksum was calculated for the inner 	 * packet and that the ip_cs_error field indicates if there was an 	 * error. 	 */
define|#
directive|define
name|CQ_RES_RAWETH_QP1_RAWETH_QP1_FLAGS2_IP_CS_CALC
value|UINT32_C(0x1)
comment|/* 	 * This indicates that the TCP, UDP or ICMP checksum was calculated for 	 * the inner packet and that the l4_cs_error field indicates if there 	 * was an error. 	 */
define|#
directive|define
name|CQ_RES_RAWETH_QP1_RAWETH_QP1_FLAGS2_L4_CS_CALC
value|UINT32_C(0x2)
comment|/* 	 * This indicates that the ip checksum was calculated for the tunnel 	 * header and that the t_ip_cs_error field indicates if there was an 	 * error. 	 */
define|#
directive|define
name|CQ_RES_RAWETH_QP1_RAWETH_QP1_FLAGS2_T_IP_CS_CALC
value|UINT32_C(0x4)
comment|/* 	 * This indicates that the UDP checksum was calculated for the tunnel 	 * packet and that the t_l4_cs_error field indicates if there was an 	 * error. 	 */
define|#
directive|define
name|CQ_RES_RAWETH_QP1_RAWETH_QP1_FLAGS2_T_L4_CS_CALC
value|UINT32_C(0x8)
comment|/* This value indicates what format the raweth_qp1_metadata field is. */
define|#
directive|define
name|CQ_RES_RAWETH_QP1_RAWETH_QP1_FLAGS2_META_FORMAT_MASK
value|UINT32_C(0xf0)
define|#
directive|define
name|CQ_RES_RAWETH_QP1_RAWETH_QP1_FLAGS2_META_FORMAT_SFT
value|4
comment|/* No metadata information. Value is zero. */
define|#
directive|define
name|CQ_RES_RAWETH_QP1_RAWETH_QP1_FLAGS2_META_FORMAT_NONE
value|(UINT32_C(0x0)<< 4)
comment|/* 	 * The raweth_qp1_metadata field contains the VLAN tag and TPID 	 * value. - raweth_qp1_metadata[11:0] contains the vlan VID 	 * value. - raweth_qp1_metadata[12] contains the vlan DE value. 	 * - raweth_qp1_metadata[15:13] contains the vlan PRI value. - 	 * raweth_qp1_metadata[31:16] contains the vlan TPID value. 	 */
define|#
directive|define
name|CQ_RES_RAWETH_QP1_RAWETH_QP1_FLAGS2_META_FORMAT_VLAN
value|(UINT32_C(0x1)<< 4)
define|#
directive|define
name|CQ_RES_RAWETH_QP1_RAWETH_QP1_FLAGS2_META_FORMAT_LAST
value|CQ_RES_RAWETH_QP1_RAWETH_QP1_FLAGS2_META_FORMAT_VLAN
comment|/* 	 * This field indicates the IP type for the inner-most IP header. A 	 * value of '0' indicates IPv4. A value of '1' indicates IPv6. This 	 * value is only valid if itype indicates a packet with an IP header. 	 */
define|#
directive|define
name|CQ_RES_RAWETH_QP1_RAWETH_QP1_FLAGS2_IP_TYPE
value|UINT32_C(0x100)
name|uint32_t
name|raweth_qp1_metadata
decl_stmt|;
comment|/* 	 * This is data from the CFA block as indicated by the meta_format 	 * field. 	 */
comment|/* When meta_format=1, this value is the VLAN VID. */
define|#
directive|define
name|CQ_RES_RAWETH_QP1_RAWETH_QP1_METADATA_VID_MASK
value|UINT32_C(0xfff)
define|#
directive|define
name|CQ_RES_RAWETH_QP1_RAWETH_QP1_METADATA_VID_SFT
value|0
comment|/* When meta_format=1, this value is the VLAN DE. */
define|#
directive|define
name|CQ_RES_RAWETH_QP1_RAWETH_QP1_METADATA_DE
value|UINT32_C(0x1000)
comment|/* When meta_format=1, this value is the VLAN PRI. */
define|#
directive|define
name|CQ_RES_RAWETH_QP1_RAWETH_QP1_METADATA_PRI_MASK
value|UINT32_C(0xe000)
define|#
directive|define
name|CQ_RES_RAWETH_QP1_RAWETH_QP1_METADATA_PRI_SFT
value|13
comment|/* When meta_format=1, this value is the VLAN TPID. */
define|#
directive|define
name|CQ_RES_RAWETH_QP1_RAWETH_QP1_METADATA_TPID_MASK
value|UINT32_C(0xffff0000)
define|#
directive|define
name|CQ_RES_RAWETH_QP1_RAWETH_QP1_METADATA_TPID_SFT
value|16
name|uint8_t
name|cqe_type_toggle
decl_stmt|;
comment|/* 	 * Indicate valid completion - written by the chip. Cumulus toggle this 	 * bit each time it finished consuming all PBL entries 	 */
define|#
directive|define
name|CQ_RES_RAWETH_QP1_TOGGLE
value|UINT32_C(0x1)
comment|/* This field defines the type of SQ WQE. */
define|#
directive|define
name|CQ_RES_RAWETH_QP1_CQE_TYPE_MASK
value|UINT32_C(0x1e)
define|#
directive|define
name|CQ_RES_RAWETH_QP1_CQE_TYPE_SFT
value|1
comment|/* 	 * Responder RawEth and QP1 Completion - This is used for RQ 	 * completion for RawEth service and QP1 service QPs. 	 */
define|#
directive|define
name|CQ_RES_RAWETH_QP1_CQE_TYPE_RES_RAWETH_QP1
value|(UINT32_C(0x3)<< 1)
define|#
directive|define
name|CQ_RES_RAWETH_QP1_RESERVED3_MASK
value|UINT32_C(0xe0)
define|#
directive|define
name|CQ_RES_RAWETH_QP1_RESERVED3_SFT
value|5
name|uint8_t
name|status
decl_stmt|;
comment|/* This field indicates the status for the CQE. */
comment|/* 	 * This indicates that the completion is without error. All 	 * fields are valid. 	 */
define|#
directive|define
name|CQ_RES_RAWETH_QP1_STATUS_OK
value|UINT32_C(0x0)
comment|/* 	 * This indicates that write access was not allowed for at least 	 * one of the SGEs in the WQE. This is a fatal error. Only the 	 * srq_or_rq_wr_id is field is valid. 	 */
define|#
directive|define
name|CQ_RES_RAWETH_QP1_STATUS_LOCAL_ACCESS_ERROR
value|UINT32_C(0x1)
comment|/* 	 * This indicates that the packet was too long for the WQE 	 * provided on the RQ. This is not a fatal error. All the fields 	 * are valid. 	 */
define|#
directive|define
name|CQ_RES_RAWETH_QP1_STATUS_HW_LOCAL_LENGTH_ERR
value|UINT32_C(0x2)
comment|/* LOCAL_PROTECTION_ERR is 3 */
define|#
directive|define
name|CQ_RES_RAWETH_QP1_STATUS_LOCAL_PROTECTION_ERR
value|UINT32_C(0x3)
comment|/* LOCAL_QP_OPERATION_ERR is 4 */
define|#
directive|define
name|CQ_RES_RAWETH_QP1_STATUS_LOCAL_QP_OPERATION_ERR
value|UINT32_C(0x4)
comment|/* MEMORY_MGT_OPERATION_ERR is 5 */
define|#
directive|define
name|CQ_RES_RAWETH_QP1_STATUS_MEMORY_MGT_OPERATION_ERR
value|UINT32_C(0x5)
comment|/* WORK_REQUEST_FLUSHED_ERR is 7 */
define|#
directive|define
name|CQ_RES_RAWETH_QP1_STATUS_WORK_REQUEST_FLUSHED_ERR
value|UINT32_C(0x7)
comment|/* HW_FLUSH_ERR is 8 */
define|#
directive|define
name|CQ_RES_RAWETH_QP1_STATUS_HW_FLUSH_ERR
value|UINT32_C(0x8)
name|uint16_t
name|flags
decl_stmt|;
comment|/* 	 * This flag indicates that the completion is for a SRQ entry rather 	 * than for an RQ entry. 	 */
define|#
directive|define
name|CQ_RES_RAWETH_QP1_FLAGS_SRQ
value|UINT32_C(0x1)
comment|/* CQE relates to RQ WQE. */
define|#
directive|define
name|CQ_RES_RAWETH_QP1_FLAGS_SRQ_RQ
value|UINT32_C(0x0)
comment|/* CQE relates to SRQ WQE. */
define|#
directive|define
name|CQ_RES_RAWETH_QP1_FLAGS_SRQ_SRQ
value|UINT32_C(0x1)
define|#
directive|define
name|CQ_RES_RAWETH_QP1_FLAGS_SRQ_LAST
value|CQ_RES_RAWETH_QP1_FLAGS_SRQ_SRQ
name|uint32_t
name|raweth_qp1_payload_offset_srq_or_rq_wr_id
decl_stmt|;
comment|/* 	 * This value indicates the offset in bytes from the beginning of the 	 * packet where the inner payload starts. This value is valid for TCP, 	 * UDP, FCoE, and RoCE packets. A value of zero indicates an offset of 	 * 256 bytes. 	 */
comment|/* 	 * Opaque value from RQ or SRQ WQE. Used by driver/lib to reference the 	 * WQE in order to claim the received data and reuse the WQE space 	 */
define|#
directive|define
name|CQ_RES_RAWETH_QP1_SRQ_OR_RQ_WR_ID_MASK
value|UINT32_C(0xfffff)
define|#
directive|define
name|CQ_RES_RAWETH_QP1_SRQ_OR_RQ_WR_ID_SFT
value|0
define|#
directive|define
name|CQ_RES_RAWETH_QP1_RESERVED4_MASK
value|UINT32_C(0xf00000)
define|#
directive|define
name|CQ_RES_RAWETH_QP1_RESERVED4_SFT
value|20
comment|/* 	 * This value indicates the offset in bytes from the beginning of the 	 * packet where the inner payload starts. This value is valid for TCP, 	 * UDP, FCoE, and RoCE packets. A value of zero indicates an offset of 	 * 256 bytes. 	 */
define|#
directive|define
name|CQ_RES_RAWETH_QP1_RAWETH_QP1_PAYLOAD_OFFSET_MASK
value|UINT32_C(0xff000000)
define|#
directive|define
name|CQ_RES_RAWETH_QP1_RAWETH_QP1_PAYLOAD_OFFSET_SFT
value|24
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Terminal CQE (32 bytes) */
end_comment

begin_struct
struct|struct
name|cq_terminal
block|{
name|uint64_t
name|qp_handle
decl_stmt|;
comment|/* 	 * This is an application level ID used to identify the QP and its SQ 	 * and RQ. 	 */
name|uint16_t
name|sq_cons_idx
decl_stmt|;
comment|/* 	 * Final SQ Consumer Index value. Any additional SQ WQEs will have to be 	 * completed by the user provider. 	 */
name|uint16_t
name|rq_cons_idx
decl_stmt|;
comment|/* 	 * Final RQ Consumer Index value. Any additional RQ WQEs will have to be 	 * completed by the user provider. 	 */
name|uint32_t
name|reserved32_1
decl_stmt|;
name|uint64_t
name|reserved64_3
decl_stmt|;
name|uint8_t
name|cqe_type_toggle
decl_stmt|;
comment|/* 	 * Indicate valid completion - written by the chip. Cumulus toggle this 	 * bit each time it finished consuming all PBL entries 	 */
define|#
directive|define
name|CQ_TERMINAL_TOGGLE
value|UINT32_C(0x1)
comment|/* This field defines the type of SQ WQE. */
define|#
directive|define
name|CQ_TERMINAL_CQE_TYPE_MASK
value|UINT32_C(0x1e)
define|#
directive|define
name|CQ_TERMINAL_CQE_TYPE_SFT
value|1
comment|/* 	 * Terminal completion - This is used to indicate that no 	 * further completions will be made for this QP on this CQ. 	 */
define|#
directive|define
name|CQ_TERMINAL_CQE_TYPE_TERMINAL
value|(UINT32_C(0xe)<< 1)
define|#
directive|define
name|CQ_TERMINAL_RESERVED3_MASK
value|UINT32_C(0xe0)
define|#
directive|define
name|CQ_TERMINAL_RESERVED3_SFT
value|5
name|uint8_t
name|status
decl_stmt|;
comment|/* This field indicates the status for the CQE. */
comment|/* OK is 0 */
define|#
directive|define
name|CQ_TERMINAL_STATUS_OK
value|UINT32_C(0x0)
name|uint16_t
name|reserved16
decl_stmt|;
name|uint32_t
name|reserved32_2
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Cutoff CQE (32 bytes) */
end_comment

begin_struct
struct|struct
name|cq_cutoff
block|{
name|uint64_t
name|reserved64_1
decl_stmt|;
name|uint64_t
name|reserved64_2
decl_stmt|;
name|uint64_t
name|reserved64_3
decl_stmt|;
name|uint8_t
name|cqe_type_toggle
decl_stmt|;
comment|/* 	 * Indicate valid completion - written by the chip. Cumulus toggle this 	 * bit each time it finished consuming all PBL entries 	 */
define|#
directive|define
name|CQ_CUTOFF_TOGGLE
value|UINT32_C(0x1)
comment|/* This field defines the type of SQ WQE. */
define|#
directive|define
name|CQ_CUTOFF_CQE_TYPE_MASK
value|UINT32_C(0x1e)
define|#
directive|define
name|CQ_CUTOFF_CQE_TYPE_SFT
value|1
comment|/* Cut off CQE; for CQ resize see CQ and SRQ Resize */
define|#
directive|define
name|CQ_CUTOFF_CQE_TYPE_CUT_OFF
value|(UINT32_C(0xf)<< 1)
define|#
directive|define
name|CQ_CUTOFF_RESERVED3_MASK
value|UINT32_C(0xe0)
define|#
directive|define
name|CQ_CUTOFF_RESERVED3_SFT
value|5
name|uint8_t
name|status
decl_stmt|;
comment|/* This field indicates the status for the CQE. */
comment|/* OK is 0 */
define|#
directive|define
name|CQ_CUTOFF_STATUS_OK
value|UINT32_C(0x0)
name|uint16_t
name|reserved16
decl_stmt|;
name|uint32_t
name|reserved32
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Notification Queue (NQ) Structures */
end_comment

begin_comment
comment|/*  * Description: This completion indicates that the DBQ has reached the  * programmed threshold value.  */
end_comment

begin_comment
comment|/* Base NQ Record (16 bytes) */
end_comment

begin_struct
struct|struct
name|nq_base
block|{
name|uint16_t
name|info10_type
decl_stmt|;
comment|/* info10 is 10 b */
comment|/* 	 * This field indicates the exact type of the completion. By convention, 	 * the LSB identifies the length of the record in 16B units. Even values 	 * indicate 16B records. Odd values indicate 32B records. 	 */
define|#
directive|define
name|NQ_BASE_TYPE_MASK
value|UINT32_C(0x3f)
define|#
directive|define
name|NQ_BASE_TYPE_SFT
value|0
comment|/* CQ Notification */
define|#
directive|define
name|NQ_BASE_TYPE_CQ_NOTIFICATION
value|UINT32_C(0x30)
comment|/* SRQ Threshold Event */
define|#
directive|define
name|NQ_BASE_TYPE_SRQ_EVENT
value|UINT32_C(0x32)
comment|/* DBQ Threshold Event */
define|#
directive|define
name|NQ_BASE_TYPE_DBQ_EVENT
value|UINT32_C(0x34)
comment|/* QP Async Notification */
define|#
directive|define
name|NQ_BASE_TYPE_QP_EVENT
value|UINT32_C(0x38)
comment|/* Function Async Notification */
define|#
directive|define
name|NQ_BASE_TYPE_FUNC_EVENT
value|UINT32_C(0x3a)
comment|/* info10 is 10 b */
define|#
directive|define
name|NQ_BASE_INFO10_MASK
value|UINT32_C(0xffc0)
define|#
directive|define
name|NQ_BASE_INFO10_SFT
value|6
name|uint16_t
name|info16
decl_stmt|;
comment|/* info16 is 16 b */
name|uint32_t
name|info32
decl_stmt|;
comment|/* info32 is 32 b */
name|uint64_t
name|info63_v
decl_stmt|;
comment|/* info63 is 63 b */
comment|/* 	 * This value is written by the NIC such that it will be different for 	 * each pass through the completion queue. The even passes will write 1. 	 * The odd passes will write 0. 	 */
define|#
directive|define
name|NQ_BASE_V
value|UINT32_C(0x1)
comment|/* info63 is 63 b */
define|#
directive|define
name|NQ_BASE_INFO63_MASK
value|UINT32_C(0xfffffffe)
define|#
directive|define
name|NQ_BASE_INFO63_SFT
value|1
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Completion Queue Notification (16 bytes) */
end_comment

begin_struct
struct|struct
name|nq_cn
block|{
name|uint16_t
name|type
decl_stmt|;
comment|/* 	 * This field indicates the exact type of the completion. By convention, 	 * the LSB identifies the length of the record in 16B units. Even values 	 * indicate 16B records. Odd values indicate 32B records. 	 */
define|#
directive|define
name|NQ_CN_TYPE_MASK
value|UINT32_C(0x3f)
define|#
directive|define
name|NQ_CN_TYPE_SFT
value|0
comment|/* CQ Notification */
define|#
directive|define
name|NQ_CN_TYPE_CQ_NOTIFICATION
value|UINT32_C(0x30)
define|#
directive|define
name|NQ_CN_RESERVED9_MASK
value|UINT32_C(0xffc0)
define|#
directive|define
name|NQ_CN_RESERVED9_SFT
value|6
name|uint16_t
name|reserved16
decl_stmt|;
name|uint32_t
name|cq_handle_low
decl_stmt|;
comment|/* 	 * This is an application level ID used to identify the CQ. This field 	 * carries the lower 32b of the value. 	 */
name|uint32_t
name|v
decl_stmt|;
comment|/* 	 * This value is written by the NIC such that it will be different for 	 * each pass through the completion queue. The even passes will write 1. 	 * The odd passes will write 0. 	 */
define|#
directive|define
name|NQ_CN_V
value|UINT32_C(0x1)
define|#
directive|define
name|NQ_CN_RESERVED31_MASK
value|UINT32_C(0xfffffffe)
define|#
directive|define
name|NQ_CN_RESERVED31_SFT
value|1
name|uint32_t
name|cq_handle_high
decl_stmt|;
comment|/* 	 * This is an application level ID used to identify the CQ. This field 	 * carries the upper 32b of the value. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* SRQ Event Notification (16 bytes) */
end_comment

begin_struct
struct|struct
name|nq_srq_event
block|{
name|uint8_t
name|type
decl_stmt|;
comment|/* 	 * This field indicates the exact type of the completion. By convention, 	 * the LSB identifies the length of the record in 16B units. Even values 	 * indicate 16B records. Odd values indicate 32B records. 	 */
define|#
directive|define
name|NQ_SRQ_EVENT_TYPE_MASK
value|UINT32_C(0x3f)
define|#
directive|define
name|NQ_SRQ_EVENT_TYPE_SFT
value|0
comment|/* SRQ Threshold Event */
define|#
directive|define
name|NQ_SRQ_EVENT_TYPE_SRQ_EVENT
value|UINT32_C(0x32)
define|#
directive|define
name|NQ_SRQ_EVENT_RESERVED1_MASK
value|UINT32_C(0xc0)
define|#
directive|define
name|NQ_SRQ_EVENT_RESERVED1_SFT
value|6
name|uint8_t
name|event
decl_stmt|;
comment|/* This value define what type of async event has occurred on the SRQ. */
comment|/* The threshold event has occurred on the specified SRQ. */
define|#
directive|define
name|NQ_SRQ_EVENT_EVENT_SRQ_THRESHOLD_EVENT
value|UINT32_C(0x1)
name|uint16_t
name|reserved16
decl_stmt|;
name|uint32_t
name|srq_handle_low
decl_stmt|;
comment|/* 	 * This is the SRQ handle value for the queue that has reached it's 	 * event threshold. This field carries the lower 32b of the value. 	 */
name|uint32_t
name|v
decl_stmt|;
comment|/* 	 * This value is written by the NIC such that it will be different for 	 * each pass through the completion queue. The even passes will write 1. 	 * The odd passes will write 0. 	 */
define|#
directive|define
name|NQ_SRQ_EVENT_V
value|UINT32_C(0x1)
define|#
directive|define
name|NQ_SRQ_EVENT_RESERVED31_MASK
value|UINT32_C(0xfffffffe)
define|#
directive|define
name|NQ_SRQ_EVENT_RESERVED31_SFT
value|1
name|uint32_t
name|srq_handle_high
decl_stmt|;
comment|/* 	 * This is the SRQ handle value for the queue that has reached it's 	 * event threshold. This field carries the upper 32b of the value. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* DBQ Async Event Notification (16 bytes) */
end_comment

begin_struct
struct|struct
name|nq_dbq_event
block|{
name|uint8_t
name|type
decl_stmt|;
comment|/* 	 * This field indicates the exact type of the completion. By convention, 	 * the LSB identifies the length of the record in 16B units. Even values 	 * indicate 16B records. Odd values indicate 32B records. 	 */
define|#
directive|define
name|NQ_DBQ_EVENT_TYPE_MASK
value|UINT32_C(0x3f)
define|#
directive|define
name|NQ_DBQ_EVENT_TYPE_SFT
value|0
comment|/* DBQ Threshold Event */
define|#
directive|define
name|NQ_DBQ_EVENT_TYPE_DBQ_EVENT
value|UINT32_C(0x34)
define|#
directive|define
name|NQ_DBQ_EVENT_RESERVED1_MASK
value|UINT32_C(0xc0)
define|#
directive|define
name|NQ_DBQ_EVENT_RESERVED1_SFT
value|6
name|uint8_t
name|event
decl_stmt|;
comment|/* This value define what type of action the driver should take. */
comment|/* 	 * The driver should start writing dummy values to the the 	 * doorbell in an attempt to consume all the PCIE posted write 	 * resources and prevent doorbell overflow. 	 */
define|#
directive|define
name|NQ_DBQ_EVENT_EVENT_DBQ_THRESHOLD_EVENT
value|UINT32_C(0x1)
name|uint16_t
name|db_pfid
decl_stmt|;
comment|/* 	 * This is the PFID of function that wrote the doorbell that crossed the 	 * async event threshold. 	 */
define|#
directive|define
name|NQ_DBQ_EVENT_DB_PFID_MASK
value|UINT32_C(0xf)
define|#
directive|define
name|NQ_DBQ_EVENT_DB_PFID_SFT
value|0
define|#
directive|define
name|NQ_DBQ_EVENT_RESERVED12_MASK
value|UINT32_C(0xfff0)
define|#
directive|define
name|NQ_DBQ_EVENT_RESERVED12_SFT
value|4
name|uint32_t
name|db_dpi
decl_stmt|;
comment|/* 	 * This is the DPI of the doorbell write that crossed the async event 	 * threshold. 	 */
define|#
directive|define
name|NQ_DBQ_EVENT_DB_DPI_MASK
value|UINT32_C(0xfffff)
define|#
directive|define
name|NQ_DBQ_EVENT_DB_DPI_SFT
value|0
define|#
directive|define
name|NQ_DBQ_EVENT_RESERVED12_2_MASK
value|UINT32_C(0xfff00000)
define|#
directive|define
name|NQ_DBQ_EVENT_RESERVED12_2_SFT
value|20
name|uint32_t
name|v
decl_stmt|;
comment|/* 	 * This value is written by the NIC such that it will be different for 	 * each pass through the completion queue. The even passes will write 1. 	 * The odd passes will write 0. 	 */
define|#
directive|define
name|NQ_DBQ_EVENT_V
value|UINT32_C(0x1)
define|#
directive|define
name|NQ_DBQ_EVENT_RESERVED32_MASK
value|UINT32_C(0xfffffffe)
define|#
directive|define
name|NQ_DBQ_EVENT_RESERVED32_SFT
value|1
name|uint32_t
name|db_type_db_xid
decl_stmt|;
comment|/* DB 'type' field from doorbell that crossed the async event threshold. */
comment|/* 	 * DB 'XID' field from doorbell that crossed the async event threshold. 	 * This is a QPID, SID, or CID, depending on the db_type field. 	 */
define|#
directive|define
name|NQ_DBQ_EVENT_DB_XID_MASK
value|UINT32_C(0xfffff)
define|#
directive|define
name|NQ_DBQ_EVENT_DB_XID_SFT
value|0
define|#
directive|define
name|NQ_DBQ_EVENT_RESERVED8_MASK
value|UINT32_C(0xff00000)
define|#
directive|define
name|NQ_DBQ_EVENT_RESERVED8_SFT
value|20
comment|/* DB 'type' field from doorbell that crossed the async event threshold. */
define|#
directive|define
name|NQ_DBQ_EVENT_DB_TYPE_MASK
value|UINT32_C(0xf0000000)
define|#
directive|define
name|NQ_DBQ_EVENT_DB_TYPE_SFT
value|28
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Read Request/Response Queue Structures */
end_comment

begin_comment
comment|/*  * Description: This queue messages is used on the ORRQ to indicate output read  * requests to the RX side of the chip.  */
end_comment

begin_comment
comment|/* Input Read Request Queue (IRRQ) Message (32 bytes) */
end_comment

begin_struct
struct|struct
name|xrrq_irrq
block|{
name|uint16_t
name|credits_type
decl_stmt|;
comment|/* 	 * The credit code calculated by Rx path when receiving the request. It 	 * will be placed in the syndrome credit code with the acks on first and 	 * last response. 	 */
comment|/* Type indication */
define|#
directive|define
name|XRRQ_IRRQ_TYPE
value|UINT32_C(0x1)
comment|/* RDMA Read */
define|#
directive|define
name|XRRQ_IRRQ_TYPE_READ_REQ
value|UINT32_C(0x0)
comment|/* Atomic */
define|#
directive|define
name|XRRQ_IRRQ_TYPE_ATOMIC_REQ
value|UINT32_C(0x1)
define|#
directive|define
name|XRRQ_IRRQ_RESERVED10_MASK
value|UINT32_C(0x7fe)
define|#
directive|define
name|XRRQ_IRRQ_RESERVED10_SFT
value|1
comment|/* 	 * The credit code calculated by Rx path when receiving the request. It 	 * will be placed in the syndrome credit code with the acks on first and 	 * last response. 	 */
define|#
directive|define
name|XRRQ_IRRQ_CREDITS_MASK
value|UINT32_C(0xf800)
define|#
directive|define
name|XRRQ_IRRQ_CREDITS_SFT
value|11
name|uint16_t
name|reserved16
decl_stmt|;
name|uint32_t
name|reserved32
decl_stmt|;
name|uint32_t
name|psn
decl_stmt|;
comment|/* The PSN of the outstanding incoming request */
define|#
directive|define
name|XRRQ_IRRQ_PSN_MASK
value|UINT32_C(0xffffff)
define|#
directive|define
name|XRRQ_IRRQ_PSN_SFT
value|0
define|#
directive|define
name|XRRQ_IRRQ_RESERVED8_1_MASK
value|UINT32_C(0xff000000)
define|#
directive|define
name|XRRQ_IRRQ_RESERVED8_1_SFT
value|24
name|uint32_t
name|msn
decl_stmt|;
comment|/* 	 * The value of QPC.pending_ack_msn after it is incremented as a result 	 * of receiving the read/atomic request. IRRQ.msn-1 will be placed in 	 * the MSN field of the first response and IRRQ.msn will placed in the 	 * MSN field of the last or only response. 	 */
define|#
directive|define
name|XRRQ_IRRQ_MSN_MASK
value|UINT32_C(0xffffff)
define|#
directive|define
name|XRRQ_IRRQ_MSN_SFT
value|0
define|#
directive|define
name|XRRQ_IRRQ_RESERVED8_2_MASK
value|UINT32_C(0xff000000)
define|#
directive|define
name|XRRQ_IRRQ_RESERVED8_2_SFT
value|24
name|uint64_t
name|va_or_atomic_result
decl_stmt|;
comment|/* 	 * Virtual address on local host for RDMA READ In case of duplicate 	 * Atomic, the VA is not required to be validated, only the PSN is, thus 	 * this field is used to store the value returned in the Ack to the 	 * atomic request, and if duplicate arrives, this value is used again 	 * for resending the ack. 	 */
name|uint32_t
name|rdma_r_key
decl_stmt|;
comment|/* The key to the MR/W in the request */
name|uint32_t
name|length
decl_stmt|;
comment|/* 	 * Length in bytes of the data requested. Length must be 8 if type is 	 * atomic. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output Read Request Queue (ORRQ) Message (32 bytes) */
end_comment

begin_struct
struct|struct
name|xrrq_orrq
block|{
name|uint16_t
name|num_sges_type
decl_stmt|;
comment|/* 	 * Up to 6 SGEs. This value is 1 if type is atomic as one SGE is 	 * required to store Atomic response result field. 2 more bits allocated 	 * for future growth. Note that, if num_sges is 1 for an RDMA Read 	 * request, then the first_sge_phy_or_sing_sge_va, single_sge_l_key, and 	 * single_sge_size fields will be populated from the single SGE. If 	 * num_sges is 2 or more for an RDMA Read request, then the 	 * first_sge_phy_or_sing_sge_va field carries the physical address in 	 * host memory where the first sge is stored. The single_sge_l_key and 	 * single_sge_size fields are unused in this case. A special case is a 	 * zero-length, zero-sge RDMA read request WQE. In this situation, 	 * num_sges will be 1. However, first_sge_phy_or_sing_sge_va, 	 * single_sge_l_key, and single_sge_size will all be populated with 	 * zeros. 	 */
comment|/* Type indication */
define|#
directive|define
name|XRRQ_ORRQ_TYPE
value|UINT32_C(0x1)
comment|/* RDMA Read */
define|#
directive|define
name|XRRQ_ORRQ_TYPE_READ_REQ
value|UINT32_C(0x0)
comment|/* Atomic */
define|#
directive|define
name|XRRQ_ORRQ_TYPE_ATOMIC_REQ
value|UINT32_C(0x1)
define|#
directive|define
name|XRRQ_ORRQ_RESERVED10_MASK
value|UINT32_C(0x7fe)
define|#
directive|define
name|XRRQ_ORRQ_RESERVED10_SFT
value|1
comment|/* 	 * Up to 6 SGEs. This value is 1 if type is atomic as one SGE is 	 * required to store Atomic response result field. 2 more bits allocated 	 * for future growth. Note that, if num_sges is 1 for an RDMA Read 	 * request, then the first_sge_phy_or_sing_sge_va, single_sge_l_key, and 	 * single_sge_size fields will be populated from the single SGE. If 	 * num_sges is 2 or more for an RDMA Read request, then the 	 * first_sge_phy_or_sing_sge_va field carries the physical address in 	 * host memory where the first sge is stored. The single_sge_l_key and 	 * single_sge_size fields are unused in this case. A special case is a 	 * zero-length, zero-sge RDMA read request WQE. In this situation, 	 * num_sges will be 1. However, first_sge_phy_or_sing_sge_va, 	 * single_sge_l_key, and single_sge_size will all be populated with 	 * zeros. 	 */
define|#
directive|define
name|XRRQ_ORRQ_NUM_SGES_MASK
value|UINT32_C(0xf800)
define|#
directive|define
name|XRRQ_ORRQ_NUM_SGES_SFT
value|11
name|uint16_t
name|reserved16
decl_stmt|;
name|uint32_t
name|length
decl_stmt|;
comment|/* 	 * Length in bytes of the data requested. Length must be 8 if type is 	 * atomic. 	 */
name|uint32_t
name|psn
decl_stmt|;
comment|/* The PSN of the outstanding outgoing request */
define|#
directive|define
name|XRRQ_ORRQ_PSN_MASK
value|UINT32_C(0xffffff)
define|#
directive|define
name|XRRQ_ORRQ_PSN_SFT
value|0
define|#
directive|define
name|XRRQ_ORRQ_RESERVED8_1_MASK
value|UINT32_C(0xff000000)
define|#
directive|define
name|XRRQ_ORRQ_RESERVED8_1_SFT
value|24
name|uint32_t
name|end_psn
decl_stmt|;
comment|/* 	 * The expected last PSN on a response to this request where an ack with 	 * response, rather than just response, should arrive. If ack arrive 	 * with smaller PSN than end_psn then it is considered a NAK. 	 */
define|#
directive|define
name|XRRQ_ORRQ_END_PSN_MASK
value|UINT32_C(0xffffff)
define|#
directive|define
name|XRRQ_ORRQ_END_PSN_SFT
value|0
define|#
directive|define
name|XRRQ_ORRQ_RESERVED8_2_MASK
value|UINT32_C(0xff000000)
define|#
directive|define
name|XRRQ_ORRQ_RESERVED8_2_SFT
value|24
name|uint64_t
name|first_sge_phy_or_sing_sge_va
decl_stmt|;
comment|/* 	 * If num_sges == 1 this is the va of that SGE. Otherwise, physical 	 * address to the first SGE specified by the WQE. Points to the first 	 * SGE in the Request's WQE in the SQ. It is assumed that WQE does not 	 * cross page boundaries! Driver is responsible to enforce that. SGEs 	 * are 16B aligned 0b0000 lsb added to get 64 bit address. 	 */
name|uint32_t
name|single_sge_l_key
decl_stmt|;
comment|/* The L_Key of a single SGE if used */
name|uint32_t
name|single_sge_size
decl_stmt|;
comment|/* The size in bytes of the single SGE if used */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Page Buffer List Memory Structures (PBL) */
end_comment

begin_comment
comment|/*  * Description: Page directory entries point to a page directories made up of  * PTE values.  */
end_comment

begin_comment
comment|/* Page Table Entry (PTE) (8 bytes) */
end_comment

begin_struct
struct|struct
name|ptu_pte
block|{
name|uint64_t
name|page_next_to_last_last_valid
decl_stmt|;
comment|/* 	 * This is the upper bits of the physical page controlled by this PTE. 	 * If the page is larger than 4KB, then the unused lower bits of the 	 * page address should be zero. 	 */
comment|/* 	 * This field indicates if the PTE is valid. A value of '0' indicates 	 * that the page is not valid. A value of '1' indicates that the page is 	 * valid. A reference to an invalid page will return a PTU error. 	 */
define|#
directive|define
name|PTU_PTE_VALID
value|UINT32_C(0x1)
comment|/* 	 * This field is used only for "ring" PBLs that are used for SQ, RQ, 	 * SRQ, or CQ structures. For all other PBL structures, this bit should 	 * be zero. When this bit is '1', it indicates that the page pointed to 	 * by this PTE is the last page in the ring. A prefetch for the ring 	 * should use the first PTE in the PBL. 	 */
define|#
directive|define
name|PTU_PTE_LAST
value|UINT32_C(0x2)
comment|/* 	 * This field is used only for "ring" PBLs that are used for SQ, RQ, 	 * SRQ, or CQ structures. For all other PBL structures, this bit should 	 * be zero. When this bit is '1', it indicates that this is the next-to- 	 * last page of the PBL. 	 */
define|#
directive|define
name|PTU_PTE_NEXT_TO_LAST
value|UINT32_C(0x4)
comment|/* These bits should be programmed to zero. */
comment|/* 	 * This is the upper bits of the physical page controlled by this PTE. 	 * If the page is larger than 4KB, then the unused lower bits of the 	 * page address should be zero. 	 */
define|#
directive|define
name|PTU_PTE_PAGE_MASK
value|UINT32_C(0xfffff000)
define|#
directive|define
name|PTU_PTE_PAGE_SFT
value|12
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Page Directory Entry (PDE) (8 bytes) */
end_comment

begin_struct
struct|struct
name|ptu_pde
block|{
name|uint64_t
name|page_valid
decl_stmt|;
comment|/* 	 * This is the upper bits of the physical page controlled by this PTE. 	 * If the page is larger than 4KB, then the unused lower bits of the 	 * page address should be zero. 	 */
comment|/* 	 * This field indicates if the PTE is valid. A value of '0' indicates 	 * that the page is not valid. A value of '1' indicates that the page is 	 * valid. A reference to an invalid page will return a PTU error. 	 */
define|#
directive|define
name|PTU_PDE_VALID
value|UINT32_C(0x1)
comment|/* These bits should be programmed to zero. */
comment|/* 	 * This is the upper bits of the physical page controlled by this PTE. 	 * If the page is larger than 4KB, then the unused lower bits of the 	 * page address should be zero. 	 */
define|#
directive|define
name|PTU_PDE_PAGE_MASK
value|UINT32_C(0xfffff000)
define|#
directive|define
name|PTU_PDE_PAGE_SFT
value|12
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* RoCE Fastpath Host Structures */
end_comment

begin_comment
comment|/*  * Note: This section documents the host structures used between RoCE state  * machines and RoCE drivers/libraries.  */
end_comment

begin_comment
comment|/* hwrm_ver_get */
end_comment

begin_comment
comment|/*  * Description: This function is called by a driver to determine the HWRM  * interface version supported by the HWRM firmware, the version of HWRM  * firmware implementation, the name of HWRM firmware, the versions of other  * embedded firmwares, and the names of other embedded firmwares, etc. Any  * interface or firmware version with major = 0, minor = 0, and update = 0 shall  * be considered an invalid version.  */
end_comment

begin_comment
comment|/* Input (24 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_ver_get_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint8_t
name|hwrm_intf_maj
decl_stmt|;
comment|/* 	 * This field represents the major version of HWRM interface 	 * specification supported by the driver HWRM implementation. The 	 * interface major version is intended to change only when non backward 	 * compatible changes are made to the HWRM interface specification. 	 */
name|uint8_t
name|hwrm_intf_min
decl_stmt|;
comment|/* 	 * This field represents the minor version of HWRM interface 	 * specification supported by the driver HWRM implementation. A change 	 * in interface minor version is used to reflect significant backward 	 * compatible modification to HWRM interface specification. This can be 	 * due to addition or removal of functionality. HWRM interface 	 * specifications with the same major version but different minor 	 * versions are compatible. 	 */
name|uint8_t
name|hwrm_intf_upd
decl_stmt|;
comment|/* 	 * This field represents the update version of HWRM interface 	 * specification supported by the driver HWRM implementation. The 	 * interface update version is used to reflect minor changes or bug 	 * fixes to a released HWRM interface specification. 	 */
name|uint8_t
name|unused_0
index|[
literal|5
index|]
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (128 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_ver_get_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint8_t
name|hwrm_intf_maj
decl_stmt|;
comment|/* 	 * This field represents the major version of HWRM interface 	 * specification supported by the HWRM implementation. The interface 	 * major version is intended to change only when non backward compatible 	 * changes are made to the HWRM interface specification. A HWRM 	 * implementation that is compliant with this specification shall 	 * provide value of 1 in this field. 	 */
name|uint8_t
name|hwrm_intf_min
decl_stmt|;
comment|/* 	 * This field represents the minor version of HWRM interface 	 * specification supported by the HWRM implementation. A change in 	 * interface minor version is used to reflect significant backward 	 * compatible modification to HWRM interface specification. This can be 	 * due to addition or removal of functionality. HWRM interface 	 * specifications with the same major version but different minor 	 * versions are compatible. A HWRM implementation that is compliant with 	 * this specification shall provide value of 2 in this field. 	 */
name|uint8_t
name|hwrm_intf_upd
decl_stmt|;
comment|/* 	 * This field represents the update version of HWRM interface 	 * specification supported by the HWRM implementation. The interface 	 * update version is used to reflect minor changes or bug fixes to a 	 * released HWRM interface specification. A HWRM implementation that is 	 * compliant with this specification shall provide value of 2 in this 	 * field. 	 */
name|uint8_t
name|hwrm_intf_rsvd
decl_stmt|;
name|uint8_t
name|hwrm_fw_maj
decl_stmt|;
comment|/* 	 * This field represents the major version of HWRM firmware. A change in 	 * firmware major version represents a major firmware release. 	 */
name|uint8_t
name|hwrm_fw_min
decl_stmt|;
comment|/* 	 * This field represents the minor version of HWRM firmware. A change in 	 * firmware minor version represents significant firmware functionality 	 * changes. 	 */
name|uint8_t
name|hwrm_fw_bld
decl_stmt|;
comment|/* 	 * This field represents the build version of HWRM firmware. A change in 	 * firmware build version represents bug fixes to a released firmware. 	 */
name|uint8_t
name|hwrm_fw_rsvd
decl_stmt|;
comment|/* 	 * This field is a reserved field. This field can be used to represent 	 * firmware branches or customer specific releases tied to a specific 	 * (major,minor,update) version of the HWRM firmware. 	 */
name|uint8_t
name|mgmt_fw_maj
decl_stmt|;
comment|/* 	 * This field represents the major version of mgmt firmware. A change in 	 * major version represents a major release. 	 */
name|uint8_t
name|mgmt_fw_min
decl_stmt|;
comment|/* 	 * This field represents the minor version of mgmt firmware. A change in 	 * minor version represents significant functionality changes. 	 */
name|uint8_t
name|mgmt_fw_bld
decl_stmt|;
comment|/* 	 * This field represents the build version of mgmt firmware. A change in 	 * update version represents bug fixes. 	 */
name|uint8_t
name|mgmt_fw_rsvd
decl_stmt|;
comment|/* 	 * This field is a reserved field. This field can be used to represent 	 * firmware branches or customer specific releases tied to a specific 	 * (major,minor,update) version 	 */
name|uint8_t
name|netctrl_fw_maj
decl_stmt|;
comment|/* 	 * This field represents the major version of network control firmware. 	 * A change in major version represents a major release. 	 */
name|uint8_t
name|netctrl_fw_min
decl_stmt|;
comment|/* 	 * This field represents the minor version of network control firmware. 	 * A change in minor version represents significant functionality 	 * changes. 	 */
name|uint8_t
name|netctrl_fw_bld
decl_stmt|;
comment|/* 	 * This field represents the build version of network control firmware. 	 * A change in update version represents bug fixes. 	 */
name|uint8_t
name|netctrl_fw_rsvd
decl_stmt|;
comment|/* 	 * This field is a reserved field. This field can be used to represent 	 * firmware branches or customer specific releases tied to a specific 	 * (major,minor,update) version 	 */
name|uint32_t
name|dev_caps_cfg
decl_stmt|;
comment|/* 	 * This field is used to indicate device's capabilities and 	 * configurations. 	 */
comment|/* 	 * If set to 1, then secure firmware update behavior is supported. If 	 * set to 0, then secure firmware update behavior is not supported. 	 */
define|#
directive|define
name|HWRM_VER_GET_OUTPUT_DEV_CAPS_CFG_SECURE_FW_UPD_SUPPORTED
value|UINT32_C(0x1)
comment|/* 	 * If set to 1, then firmware based DCBX agent is supported. If set to 	 * 0, then firmware based DCBX agent capability is not supported on this 	 * device. 	 */
define|#
directive|define
name|HWRM_VER_GET_OUTPUT_DEV_CAPS_CFG_FW_DCBX_AGENT_SUPPORTED
value|UINT32_C(0x2)
comment|/* 	 * If set to 1, then HWRM short command format is supported. If set to 	 * 0, then HWRM short command format is not supported. 	 */
define|#
directive|define
name|HWRM_VER_GET_OUTPUT_DEV_CAPS_CFG_SHORT_CMD_SUPPORTED
value|UINT32_C(0x4)
comment|/* 	 * If set to 1, then HWRM short command format is required. If set to 0, 	 * then HWRM short command format is not required. 	 */
define|#
directive|define
name|HWRM_VER_GET_OUTPUT_DEV_CAPS_CFG_SHORT_CMD_REQUIRED
value|UINT32_C(0x8)
name|uint8_t
name|roce_fw_maj
decl_stmt|;
comment|/* 	 * This field represents the major version of RoCE firmware. A change in 	 * major version represents a major release. 	 */
name|uint8_t
name|roce_fw_min
decl_stmt|;
comment|/* 	 * This field represents the minor version of RoCE firmware. A change in 	 * minor version represents significant functionality changes. 	 */
name|uint8_t
name|roce_fw_bld
decl_stmt|;
comment|/* 	 * This field represents the build version of RoCE firmware. A change in 	 * update version represents bug fixes. 	 */
name|uint8_t
name|roce_fw_rsvd
decl_stmt|;
comment|/* 	 * This field is a reserved field. This field can be used to represent 	 * firmware branches or customer specific releases tied to a specific 	 * (major,minor,update) version 	 */
name|char
name|hwrm_fw_name
index|[
literal|16
index|]
decl_stmt|;
comment|/* 	 * This field represents the name of HWRM FW (ASCII chars with NULL at 	 * the end). 	 */
name|char
name|mgmt_fw_name
index|[
literal|16
index|]
decl_stmt|;
comment|/* 	 * This field represents the name of mgmt FW (ASCII chars with NULL at 	 * the end). 	 */
name|char
name|netctrl_fw_name
index|[
literal|16
index|]
decl_stmt|;
comment|/* 	 * This field represents the name of network control firmware (ASCII 	 * chars with NULL at the end). 	 */
name|uint32_t
name|reserved2
index|[
literal|4
index|]
decl_stmt|;
comment|/* 	 * This field is reserved for future use. The responder should set it to 	 * 0. The requester should ignore this field. 	 */
name|char
name|roce_fw_name
index|[
literal|16
index|]
decl_stmt|;
comment|/* 	 * This field represents the name of RoCE FW (ASCII chars with NULL at 	 * the end). 	 */
name|uint16_t
name|chip_num
decl_stmt|;
comment|/* This field returns the chip number. */
name|uint8_t
name|chip_rev
decl_stmt|;
comment|/* This field returns the revision of chip. */
name|uint8_t
name|chip_metal
decl_stmt|;
comment|/* This field returns the chip metal number. */
name|uint8_t
name|chip_bond_id
decl_stmt|;
comment|/* This field returns the bond id of the chip. */
name|uint8_t
name|chip_platform_type
decl_stmt|;
comment|/* 	 * This value indicates the type of platform used for chip 	 * implementation. 	 */
comment|/* ASIC */
define|#
directive|define
name|HWRM_VER_GET_OUTPUT_CHIP_PLATFORM_TYPE_ASIC
value|UINT32_C(0x0)
comment|/* FPGA platform of the chip. */
define|#
directive|define
name|HWRM_VER_GET_OUTPUT_CHIP_PLATFORM_TYPE_FPGA
value|UINT32_C(0x1)
comment|/* Palladium platform of the chip. */
define|#
directive|define
name|HWRM_VER_GET_OUTPUT_CHIP_PLATFORM_TYPE_PALLADIUM
value|UINT32_C(0x2)
name|uint16_t
name|max_req_win_len
decl_stmt|;
comment|/* 	 * This field returns the maximum value of request window that is 	 * supported by the HWRM. The request window is mapped into device 	 * address space using MMIO. 	 */
name|uint16_t
name|max_resp_len
decl_stmt|;
comment|/* This field returns the maximum value of response buffer in bytes. */
name|uint16_t
name|def_req_timeout
decl_stmt|;
comment|/* This field returns the default request timeout value in milliseconds. */
name|uint8_t
name|init_pending
decl_stmt|;
comment|/* This field will indicate if any subsystems is not fully initialized. */
comment|/* 	 * If set to 1, device is not ready. If set to 0, device is ready to 	 * accept all HWRM commands. 	 */
define|#
directive|define
name|HWRM_VER_GET_OUTPUT_INIT_PENDING_DEV_NOT_RDY
value|UINT32_C(0x1)
name|uint8_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_func_reset */
end_comment

begin_comment
comment|/*  * Description: This command resets a hardware function (PCIe function) and  * frees any resources used by the function. This command shall be initiated by  * the driver after an FLR has occurred to prepare the function for re-use. This  * command may also be initiated by a driver prior to doing it's own  * configuration. This command puts the function into the reset state. In the  * reset state, global and port related features of the chip are not available.  */
end_comment

begin_comment
comment|/*  * Note: This command will reset a function that has already been disabled or  * idled. The command returns all the resources owned by the function so a new  * driver may allocate and configure resources normally.  */
end_comment

begin_comment
comment|/* Input (24 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_func_reset_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint32_t
name|enables
decl_stmt|;
comment|/* This bit must be '1' for the vf_id_valid field to be configured. */
define|#
directive|define
name|HWRM_FUNC_RESET_INPUT_ENABLES_VF_ID_VALID
value|UINT32_C(0x1)
name|uint16_t
name|vf_id
decl_stmt|;
comment|/* 	 * The ID of the VF that this PF is trying to reset. Only the parent PF 	 * shall be allowed to reset a child VF. A parent PF driver shall use 	 * this field only when a specific child VF is requested to be reset. 	 */
name|uint8_t
name|func_reset_level
decl_stmt|;
comment|/* This value indicates the level of a function reset. */
comment|/* 	 * Reset the caller function and its children VFs (if any). If 	 * no children functions exist, then reset the caller function 	 * only. 	 */
define|#
directive|define
name|HWRM_FUNC_RESET_INPUT_FUNC_RESET_LEVEL_RESETALL
value|UINT32_C(0x0)
comment|/* Reset the caller function only */
define|#
directive|define
name|HWRM_FUNC_RESET_INPUT_FUNC_RESET_LEVEL_RESETME
value|UINT32_C(0x1)
comment|/* 	 * Reset all children VFs of the caller function driver if the 	 * caller is a PF driver. It is an error to specify this level 	 * by a VF driver. It is an error to specify this level by a PF 	 * driver with no children VFs. 	 */
define|#
directive|define
name|HWRM_FUNC_RESET_INPUT_FUNC_RESET_LEVEL_RESETCHILDREN
value|UINT32_C(0x2)
comment|/* 	 * Reset a specific VF of the caller function driver if the 	 * caller is the parent PF driver. It is an error to specify 	 * this level by a VF driver. It is an error to specify this 	 * level by a PF driver that is not the parent of the VF that is 	 * being requested to reset. 	 */
define|#
directive|define
name|HWRM_FUNC_RESET_INPUT_FUNC_RESET_LEVEL_RESETVF
value|UINT32_C(0x3)
name|uint8_t
name|unused_0
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_func_reset_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint32_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_func_getfid */
end_comment

begin_comment
comment|/*  * Description: This command returns the FID value for the function. If a valid  * pci_id is provided, then this function returns fid for that PCI function.  * Otherwise, it returns FID of the requesting function. This value is needed to  * configure Rings and MSI-X vectors so their DMA operations appear correctly on  * the PCI bus. For PF-HWRM commands, there is no need for FID. Similarly there  * is no need for FID for VF-HWRM commands. In the PF-VF communication, only PF  * needs to know FIDs.  */
end_comment

begin_comment
comment|/* Input (24 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_func_getfid_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint32_t
name|enables
decl_stmt|;
comment|/* This bit must be '1' for the pci_id field to be configured. */
define|#
directive|define
name|HWRM_FUNC_GETFID_INPUT_ENABLES_PCI_ID
value|UINT32_C(0x1)
name|uint16_t
name|pci_id
decl_stmt|;
comment|/* 	 * This value is the PCI ID of the queried function. If ARI is enabled, 	 * then it is Bus Number (8b):Function Number(8b). Otherwise, it is Bus 	 * Number (8b):Device Number (5b):Function Number(3b). 	 */
name|uint16_t
name|unused_0
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_func_getfid_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint16_t
name|fid
decl_stmt|;
comment|/* 	 * FID value. This value is used to identify operations on the PCI bus 	 * as belonging to a particular PCI function. 	 */
name|uint8_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint8_t
name|unused_4
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_func_vf_alloc */
end_comment

begin_comment
comment|/*  * Description: This command is used to allocate requested number of virtual  * functions on a physical function. It will return the FID value of the first  * virtual function. The FIDs of the remaining virtual functions can be derived  * by sequentially incrementing the FID value of the first VF. This command  * supports the following models for VF allocation: # Allocation of one or more  * VFs from a PF without specifying the first VF ID # Allocation of multiple VFs  * from a PF starting with a specific VF # Allocation of a specific VF from a PF  * If this command is called on a virtual function or a physical function that  * is not enabled for SR-IOV, the HWRM shall return an error. The VF IDs  * returned by this function remain valid after the VF is disabled or reset.  */
end_comment

begin_comment
comment|/* Input (24 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_func_vf_alloc_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint32_t
name|enables
decl_stmt|;
comment|/* This bit must be '1' for the first_vf_id field to be configured. */
define|#
directive|define
name|HWRM_FUNC_VF_ALLOC_INPUT_ENABLES_FIRST_VF_ID
value|UINT32_C(0x1)
name|uint16_t
name|first_vf_id
decl_stmt|;
comment|/* 	 * This value is used to identify a Virtual Function (VF). The scope of 	 * VF ID is local within a PF. 	 */
name|uint16_t
name|num_vfs
decl_stmt|;
comment|/* The number of virtual functions requested. */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_func_vf_alloc_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint16_t
name|first_vf_id
decl_stmt|;
comment|/* The ID of the first VF allocated. */
name|uint8_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint8_t
name|unused_4
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_func_vf_free */
end_comment

begin_comment
comment|/*  * Description: This command will free allocated virtual functions on a physical  * function. If this command is called on a virtual function or a physical  * function that is not enabled for SR-IOV, the HWRM shall return an error.  * After the successful completion of this command, the VF IDs of the VFs that  * are freed on the PF are invalid.  */
end_comment

begin_comment
comment|/* Input (24 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_func_vf_free_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint32_t
name|enables
decl_stmt|;
comment|/* This bit must be '1' for the first_vf_id field to be configured. */
define|#
directive|define
name|HWRM_FUNC_VF_FREE_INPUT_ENABLES_FIRST_VF_ID
value|UINT32_C(0x1)
name|uint16_t
name|first_vf_id
decl_stmt|;
comment|/* 	 * This value is used to identify a Virtual Function (VF). The scope of 	 * VF ID is local within a PF. 	 */
name|uint16_t
name|num_vfs
decl_stmt|;
comment|/* 	 * The number of virtual functions requested. 0xFFFF - Cleanup all 	 * children of this PF. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_func_vf_free_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint32_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_func_vf_cfg */
end_comment

begin_comment
comment|/*  * Description: This command allows configuration of a VF by its driver. If this  * function is called by a PF driver, then the HWRM shall fail this command. If  * guest VLAN and/or MAC address are provided in this command, then the HWRM  * shall set up appropriate MAC/VLAN filters for the VF that is being  * configured. A VF driver should set VF MTU/MRU using this command prior to  * allocating RX VNICs or TX rings for the corresponding VF.  */
end_comment

begin_comment
comment|/* Input (32 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_func_vf_cfg_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint32_t
name|enables
decl_stmt|;
comment|/* This bit must be '1' for the mtu field to be configured. */
define|#
directive|define
name|HWRM_FUNC_VF_CFG_INPUT_ENABLES_MTU
value|UINT32_C(0x1)
comment|/* This bit must be '1' for the guest_vlan field to be configured. */
define|#
directive|define
name|HWRM_FUNC_VF_CFG_INPUT_ENABLES_GUEST_VLAN
value|UINT32_C(0x2)
comment|/* This bit must be '1' for the async_event_cr field to be configured. */
define|#
directive|define
name|HWRM_FUNC_VF_CFG_INPUT_ENABLES_ASYNC_EVENT_CR
value|UINT32_C(0x4)
comment|/* This bit must be '1' for the dflt_mac_addr field to be configured. */
define|#
directive|define
name|HWRM_FUNC_VF_CFG_INPUT_ENABLES_DFLT_MAC_ADDR
value|UINT32_C(0x8)
name|uint16_t
name|mtu
decl_stmt|;
comment|/* 	 * The maximum transmission unit requested on the function. The HWRM 	 * should make sure that the mtu of the function does not exceed the mtu 	 * of the physical port that this function is associated with. In 	 * addition to requesting mtu per function, it is possible to configure 	 * mtu per transmit ring. By default, the mtu of each transmit ring 	 * associated with a function is equal to the mtu of the function. The 	 * HWRM should make sure that the mtu of each transmit ring that is 	 * assigned to a function has a valid mtu. 	 */
name|uint16_t
name|guest_vlan
decl_stmt|;
comment|/* 	 * The guest VLAN for the function being configured. This field's format 	 * is same as 802.1Q Tag's Tag Control Information (TCI) format that 	 * includes both Priority Code Point (PCP) and VLAN Identifier (VID). 	 */
name|uint16_t
name|async_event_cr
decl_stmt|;
comment|/* 	 * ID of the target completion ring for receiving asynchronous event 	 * completions. If this field is not valid, then the HWRM shall use the 	 * default completion ring of the function that is being configured as 	 * the target completion ring for providing any asynchronous event 	 * completions for that function. If this field is valid, then the HWRM 	 * shall use the completion ring identified by this ID as the target 	 * completion ring for providing any asynchronous event completions for 	 * the function that is being configured. 	 */
name|uint8_t
name|dflt_mac_addr
index|[
literal|6
index|]
decl_stmt|;
comment|/* 	 * This value is the current MAC address requested by the VF driver to 	 * be configured on this VF. A value of 00-00-00-00-00-00 indicates no 	 * MAC address configuration is requested by the VF driver. The parent 	 * PF driver may reject or overwrite this MAC address. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_func_vf_cfg_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint32_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_func_qcaps */
end_comment

begin_comment
comment|/*  * Description: This command returns capabilities of a function. The input FID  * value is used to indicate what function is being queried. This allows a  * physical function driver to query virtual functions that are children of the  * physical function. The output FID value is needed to configure Rings and  * MSI-X vectors so their DMA operations appear correctly on the PCI bus.  */
end_comment

begin_comment
comment|/* Input (24 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_func_qcaps_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint16_t
name|fid
decl_stmt|;
comment|/* 	 * Function ID of the function that is being queried. 0xFF... (All Fs) 	 * if the query is for the requesting function. 	 */
name|uint16_t
name|unused_0
index|[
literal|3
index|]
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (80 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_func_qcaps_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint16_t
name|fid
decl_stmt|;
comment|/* 	 * FID value. This value is used to identify operations on the PCI bus 	 * as belonging to a particular PCI function. 	 */
name|uint16_t
name|port_id
decl_stmt|;
comment|/* 	 * Port ID of port that this function is associated with. Valid only for 	 * the PF. 0xFF... (All Fs) if this function is not associated with any 	 * port. 0xFF... (All Fs) if this function is called from a VF. 	 */
name|uint32_t
name|flags
decl_stmt|;
comment|/* If 1, then Push mode is supported on this function. */
define|#
directive|define
name|HWRM_FUNC_QCAPS_OUTPUT_FLAGS_PUSH_MODE_SUPPORTED
value|UINT32_C(0x1)
comment|/* If 1, then the global MSI-X auto-masking is enabled for the device. */
define|#
directive|define
name|HWRM_FUNC_QCAPS_OUTPUT_FLAGS_GLOBAL_MSIX_AUTOMASKING
value|UINT32_C(0x2)
comment|/* 	 * If 1, then the Precision Time Protocol (PTP) processing is supported 	 * on this function. The HWRM should enable PTP on only a single 	 * Physical Function (PF) per port. 	 */
define|#
directive|define
name|HWRM_FUNC_QCAPS_OUTPUT_FLAGS_PTP_SUPPORTED
value|UINT32_C(0x4)
comment|/* 	 * If 1, then RDMA over Converged Ethernet (RoCE) v1 is supported on 	 * this function. 	 */
define|#
directive|define
name|HWRM_FUNC_QCAPS_OUTPUT_FLAGS_ROCE_V1_SUPPORTED
value|UINT32_C(0x8)
comment|/* 	 * If 1, then RDMA over Converged Ethernet (RoCE) v2 is supported on 	 * this function. 	 */
define|#
directive|define
name|HWRM_FUNC_QCAPS_OUTPUT_FLAGS_ROCE_V2_SUPPORTED
value|UINT32_C(0x10)
comment|/* 	 * If 1, then control and configuration of WoL magic packet are 	 * supported on this function. 	 */
define|#
directive|define
name|HWRM_FUNC_QCAPS_OUTPUT_FLAGS_WOL_MAGICPKT_SUPPORTED
value|UINT32_C(0x20)
comment|/* 	 * If 1, then control and configuration of bitmap pattern packet are 	 * supported on this function. 	 */
define|#
directive|define
name|HWRM_FUNC_QCAPS_OUTPUT_FLAGS_WOL_BMP_SUPPORTED
value|UINT32_C(0x40)
comment|/* 	 * If set to 1, then the control and configuration of rate limit of an 	 * allocated TX ring on the queried function is supported. 	 */
define|#
directive|define
name|HWRM_FUNC_QCAPS_OUTPUT_FLAGS_TX_RING_RL_SUPPORTED
value|UINT32_C(0x80)
comment|/* 	 * If 1, then control and configuration of minimum and maximum 	 * bandwidths are supported on the queried function. 	 */
define|#
directive|define
name|HWRM_FUNC_QCAPS_OUTPUT_FLAGS_TX_BW_CFG_SUPPORTED
value|UINT32_C(0x100)
comment|/* 	 * If the query is for a VF, then this flag shall be ignored. If this 	 * query is for a PF and this flag is set to 1, then the PF has the 	 * capability to set the rate limits on the TX rings of its children 	 * VFs. If this query is for a PF and this flag is set to 0, then the PF 	 * does not have the capability to set the rate limits on the TX rings 	 * of its children VFs. 	 */
define|#
directive|define
name|HWRM_FUNC_QCAPS_OUTPUT_FLAGS_VF_TX_RING_RL_SUPPORTED
value|UINT32_C(0x200)
comment|/* 	 * If the query is for a VF, then this flag shall be ignored. If this 	 * query is for a PF and this flag is set to 1, then the PF has the 	 * capability to set the minimum and/or maximum bandwidths for its 	 * children VFs. If this query is for a PF and this flag is set to 0, 	 * then the PF does not have the capability to set the minimum or 	 * maximum bandwidths for its children VFs. 	 */
define|#
directive|define
name|HWRM_FUNC_QCAPS_OUTPUT_FLAGS_VF_BW_CFG_SUPPORTED
value|UINT32_C(0x400)
comment|/* 	 * Standard TX Ring mode is used for the allocation of TX ring and 	 * underlying scheduling resources that allow bandwidth reservation and 	 * limit settings on the queried function. If set to 1, then standard TX 	 * ring mode is supported on the queried function. If set to 0, then 	 * standard TX ring mode is not available on the queried function. 	 */
define|#
directive|define
name|HWRM_FUNC_QCAPS_OUTPUT_FLAGS_STD_TX_RING_MODE_SUPPORTED
value|UINT32_C(0x800)
name|uint8_t
name|mac_address
index|[
literal|6
index|]
decl_stmt|;
comment|/* 	 * This value is current MAC address configured for this function. A 	 * value of 00-00-00-00-00-00 indicates no MAC address is currently 	 * configured. 	 */
name|uint16_t
name|max_rsscos_ctx
decl_stmt|;
comment|/* 	 * The maximum number of RSS/COS contexts that can be allocated to the 	 * function. 	 */
name|uint16_t
name|max_cmpl_rings
decl_stmt|;
comment|/* 	 * The maximum number of completion rings that can be allocated to the 	 * function. 	 */
name|uint16_t
name|max_tx_rings
decl_stmt|;
comment|/* 	 * The maximum number of transmit rings that can be allocated to the 	 * function. 	 */
name|uint16_t
name|max_rx_rings
decl_stmt|;
comment|/* 	 * The maximum number of receive rings that can be allocated to the 	 * function. 	 */
name|uint16_t
name|max_l2_ctxs
decl_stmt|;
comment|/* 	 * The maximum number of L2 contexts that can be allocated to the 	 * function. 	 */
name|uint16_t
name|max_vnics
decl_stmt|;
comment|/* The maximum number of VNICs that can be allocated to the function. */
name|uint16_t
name|first_vf_id
decl_stmt|;
comment|/* 	 * The identifier for the first VF enabled on a PF. This is valid only 	 * on the PF with SR-IOV enabled. 0xFF... (All Fs) if this command is 	 * called on a PF with SR-IOV disabled or on a VF. 	 */
name|uint16_t
name|max_vfs
decl_stmt|;
comment|/* 	 * The maximum number of VFs that can be allocated to the function. This 	 * is valid only on the PF with SR-IOV enabled. 0xFF... (All Fs) if this 	 * command is called on a PF with SR-IOV disabled or on a VF. 	 */
name|uint16_t
name|max_stat_ctx
decl_stmt|;
comment|/* 	 * The maximum number of statistic contexts that can be allocated to the 	 * function. 	 */
name|uint32_t
name|max_encap_records
decl_stmt|;
comment|/* 	 * The maximum number of Encapsulation records that can be offloaded by 	 * this function. 	 */
name|uint32_t
name|max_decap_records
decl_stmt|;
comment|/* 	 * The maximum number of decapsulation records that can be offloaded by 	 * this function. 	 */
name|uint32_t
name|max_tx_em_flows
decl_stmt|;
comment|/* 	 * The maximum number of Exact Match (EM) flows that can be offloaded by 	 * this function on the TX side. 	 */
name|uint32_t
name|max_tx_wm_flows
decl_stmt|;
comment|/* 	 * The maximum number of Wildcard Match (WM) flows that can be offloaded 	 * by this function on the TX side. 	 */
name|uint32_t
name|max_rx_em_flows
decl_stmt|;
comment|/* 	 * The maximum number of Exact Match (EM) flows that can be offloaded by 	 * this function on the RX side. 	 */
name|uint32_t
name|max_rx_wm_flows
decl_stmt|;
comment|/* 	 * The maximum number of Wildcard Match (WM) flows that can be offloaded 	 * by this function on the RX side. 	 */
name|uint32_t
name|max_mcast_filters
decl_stmt|;
comment|/* 	 * The maximum number of multicast filters that can be supported by this 	 * function on the RX side. 	 */
name|uint32_t
name|max_flow_id
decl_stmt|;
comment|/* 	 * The maximum value of flow_id that can be supported in completion 	 * records. 	 */
name|uint32_t
name|max_hw_ring_grps
decl_stmt|;
comment|/* 	 * The maximum number of HW ring groups that can be supported on this 	 * function. 	 */
name|uint16_t
name|max_sp_tx_rings
decl_stmt|;
comment|/* 	 * The maximum number of strict priority transmit rings that can be 	 * allocated to the function. This number indicates the maximum number 	 * of TX rings that can be assigned strict priorities out of the maximum 	 * number of TX rings that can be allocated (max_tx_rings) to the 	 * function. 	 */
name|uint8_t
name|unused_0
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_func_qcfg */
end_comment

begin_comment
comment|/*  * Description: This command returns the current configuration of a function.  * The input FID value is used to indicate what function is being queried. This  * allows a physical function driver to query virtual functions that are  * children of the physical function. The output FID value is needed to  * configure Rings and MSI-X vectors so their DMA operations appear correctly on  * the PCI bus. This command should be called by every driver after  * 'hwrm_func_cfg' to get the actual number of resources allocated by the HWRM.  * The values returned by hwrm_func_qcfg are the values the driver shall use.  * These values may be different than what was originally requested in the  * 'hwrm_func_cfg' command.  */
end_comment

begin_comment
comment|/* Input (24 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_func_qcfg_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint16_t
name|fid
decl_stmt|;
comment|/* 	 * Function ID of the function that is being queried. 0xFF... (All Fs) 	 * if the query is for the requesting function. 	 */
name|uint16_t
name|unused_0
index|[
literal|3
index|]
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (72 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_func_qcfg_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint16_t
name|fid
decl_stmt|;
comment|/* 	 * FID value. This value is used to identify operations on the PCI bus 	 * as belonging to a particular PCI function. 	 */
name|uint16_t
name|port_id
decl_stmt|;
comment|/* 	 * Port ID of port that this function is associated with. 0xFF... (All 	 * Fs) if this function is not associated with any port. 	 */
name|uint16_t
name|vlan
decl_stmt|;
comment|/* 	 * This value is the current VLAN setting for this function. The value 	 * of 0 for this field indicates no priority tagging or VLAN is used. 	 * This field's format is same as 802.1Q Tag's Tag Control Information 	 * (TCI) format that includes both Priority Code Point (PCP) and VLAN 	 * Identifier (VID). 	 */
name|uint16_t
name|flags
decl_stmt|;
comment|/* 	 * If 1, then magic packet based Out-Of-Box WoL is enabled on the port 	 * associated with this function. 	 */
define|#
directive|define
name|HWRM_FUNC_QCFG_OUTPUT_FLAGS_OOB_WOL_MAGICPKT_ENABLED
value|UINT32_C(0x1)
comment|/* 	 * If 1, then bitmap pattern based Out-Of-Box WoL packet is enabled on 	 * the port associated with this function. 	 */
define|#
directive|define
name|HWRM_FUNC_QCFG_OUTPUT_FLAGS_OOB_WOL_BMP_ENABLED
value|UINT32_C(0x2)
comment|/* 	 * If set to 1, then FW based DCBX agent is enabled and running on the 	 * port associated with this function. If set to 0, then DCBX agent is 	 * not running in the firmware. 	 */
define|#
directive|define
name|HWRM_FUNC_QCFG_OUTPUT_FLAGS_FW_DCBX_AGENT_ENABLED
value|UINT32_C(0x4)
comment|/* 	 * Standard TX Ring mode is used for the allocation of TX ring and 	 * underlying scheduling resources that allow bandwidth reservation and 	 * limit settings on the queried function. If set to 1, then standard TX 	 * ring mode is enabled on the queried function. If set to 0, then the 	 * standard TX ring mode is disabled on the queried function. In this 	 * extended TX ring resource mode, the minimum and maximum bandwidth 	 * settings are not supported to allow the allocation of TX rings to 	 * span multiple scheduler nodes. 	 */
define|#
directive|define
name|HWRM_FUNC_QCFG_OUTPUT_FLAGS_STD_TX_RING_MODE_ENABLED
value|UINT32_C(0x8)
comment|/* 	 * If set to 1 then FW based LLDP agent is enabled and running on the 	 * port associated with this function. If set to 0 then the LLDP agent 	 * is not running in the firmware. 	 */
define|#
directive|define
name|HWRM_FUNC_QCFG_OUTPUT_FLAGS_FW_LLDP_AGENT_ENABLED
value|UINT32_C(0x10)
comment|/* 	 * If set to 1, then multi-host mode is active for this function. If set 	 * to 0, then multi-host mode is inactive for this function or not 	 * applicable for this device. 	 */
define|#
directive|define
name|HWRM_FUNC_QCFG_OUTPUT_FLAGS_MULTI_HOST
value|UINT32_C(0x20)
name|uint8_t
name|mac_address
index|[
literal|6
index|]
decl_stmt|;
comment|/* 	 * This value is current MAC address configured for this function. A 	 * value of 00-00-00-00-00-00 indicates no MAC address is currently 	 * configured. 	 */
name|uint16_t
name|pci_id
decl_stmt|;
comment|/* 	 * This value is current PCI ID of this function. If ARI is enabled, 	 * then it is Bus Number (8b):Function Number(8b). Otherwise, it is Bus 	 * Number (8b):Device Number (4b):Function Number(4b). If multi-host 	 * mode is active, the 4 lsb will indicate the PF index for this 	 * function. 	 */
name|uint16_t
name|alloc_rsscos_ctx
decl_stmt|;
comment|/* The number of RSS/COS contexts currently allocated to the function. */
name|uint16_t
name|alloc_cmpl_rings
decl_stmt|;
comment|/* 	 * The number of completion rings currently allocated to the function. 	 * This does not include the rings allocated to any children functions 	 * if any. 	 */
name|uint16_t
name|alloc_tx_rings
decl_stmt|;
comment|/* 	 * The number of transmit rings currently allocated to the function. 	 * This does not include the rings allocated to any children functions 	 * if any. 	 */
name|uint16_t
name|alloc_rx_rings
decl_stmt|;
comment|/* 	 * The number of receive rings currently allocated to the function. This 	 * does not include the rings allocated to any children functions if 	 * any. 	 */
name|uint16_t
name|alloc_l2_ctx
decl_stmt|;
comment|/* The allocated number of L2 contexts to the function. */
name|uint16_t
name|alloc_vnics
decl_stmt|;
comment|/* The allocated number of vnics to the function. */
name|uint16_t
name|mtu
decl_stmt|;
comment|/* 	 * The maximum transmission unit of the function. For rings allocated on 	 * this function, this default value is used if ring MTU is not 	 * specified. 	 */
name|uint16_t
name|mru
decl_stmt|;
comment|/* 	 * The maximum receive unit of the function. For vnics allocated on this 	 * function, this default value is used if vnic MRU is not specified. 	 */
name|uint16_t
name|stat_ctx_id
decl_stmt|;
comment|/* The statistics context assigned to a function. */
name|uint8_t
name|port_partition_type
decl_stmt|;
comment|/* 	 * The HWRM shall return Unknown value for this field when this command 	 * is used to query VF's configuration. 	 */
comment|/* Single physical function */
define|#
directive|define
name|HWRM_FUNC_QCFG_OUTPUT_PORT_PARTITION_TYPE_SPF
value|UINT32_C(0x0)
comment|/* Multiple physical functions */
define|#
directive|define
name|HWRM_FUNC_QCFG_OUTPUT_PORT_PARTITION_TYPE_MPFS
value|UINT32_C(0x1)
comment|/* Network Partitioning 1.0 */
define|#
directive|define
name|HWRM_FUNC_QCFG_OUTPUT_PORT_PARTITION_TYPE_NPAR1_0
value|UINT32_C(0x2)
comment|/* Network Partitioning 1.5 */
define|#
directive|define
name|HWRM_FUNC_QCFG_OUTPUT_PORT_PARTITION_TYPE_NPAR1_5
value|UINT32_C(0x3)
comment|/* Network Partitioning 2.0 */
define|#
directive|define
name|HWRM_FUNC_QCFG_OUTPUT_PORT_PARTITION_TYPE_NPAR2_0
value|UINT32_C(0x4)
comment|/* Unknown */
define|#
directive|define
name|HWRM_FUNC_QCFG_OUTPUT_PORT_PARTITION_TYPE_UNKNOWN
value|UINT32_C(0xff)
name|uint8_t
name|port_pf_cnt
decl_stmt|;
comment|/* 	 * This field will indicate number of physical functions on this 	 * port_partition. HWRM shall return unavail (i.e. value of 0) for this 	 * field when this command is used to query VF's configuration or from 	 * older firmware that doesn't support this field. 	 */
comment|/* number of PFs is not available */
define|#
directive|define
name|HWRM_FUNC_QCFG_OUTPUT_PORT_PF_CNT_UNAVAIL
value|UINT32_C(0x0)
name|uint16_t
name|dflt_vnic_id
decl_stmt|;
comment|/* The default VNIC ID assigned to a function that is being queried. */
name|uint8_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint32_t
name|min_bw
decl_stmt|;
comment|/* 	 * Minimum BW allocated for this function. The HWRM will translate this 	 * value into byte counter and time interval used for the scheduler 	 * inside the device. A value of 0 indicates the minimum bandwidth is 	 * not configured. 	 */
comment|/* The bandwidth value. */
define|#
directive|define
name|HWRM_FUNC_QCFG_OUTPUT_MIN_BW_BW_VALUE_MASK
value|UINT32_C(0xfffffff)
define|#
directive|define
name|HWRM_FUNC_QCFG_OUTPUT_MIN_BW_BW_VALUE_SFT
value|0
comment|/* The granularity of the value (bits or bytes). */
define|#
directive|define
name|HWRM_FUNC_QCFG_OUTPUT_MIN_BW_SCALE
value|UINT32_C(0x10000000)
comment|/* Value is in bits. */
define|#
directive|define
name|HWRM_FUNC_QCFG_OUTPUT_MIN_BW_SCALE_BITS
value|(UINT32_C(0x0)<< 28)
comment|/* Value is in bytes. */
define|#
directive|define
name|HWRM_FUNC_QCFG_OUTPUT_MIN_BW_SCALE_BYTES
value|(UINT32_C(0x1)<< 28)
define|#
directive|define
name|HWRM_FUNC_QCFG_OUTPUT_MIN_BW_SCALE_LAST
value|HWRM_FUNC_QCFG_OUTPUT_MIN_BW_SCALE_BYTES
comment|/* bw_value_unit is 3 b */
define|#
directive|define
name|HWRM_FUNC_QCFG_OUTPUT_MIN_BW_BW_VALUE_UNIT_MASK
value|UINT32_C(0xe0000000)
define|#
directive|define
name|HWRM_FUNC_QCFG_OUTPUT_MIN_BW_BW_VALUE_UNIT_SFT
value|29
comment|/* Value is in Mb or MB (base 10). */
define|#
directive|define
name|HWRM_FUNC_QCFG_OUTPUT_MIN_BW_BW_VALUE_UNIT_MEGA
value|(UINT32_C(0x0)<< 29)
comment|/* Value is in Kb or KB (base 10). */
define|#
directive|define
name|HWRM_FUNC_QCFG_OUTPUT_MIN_BW_BW_VALUE_UNIT_KILO
value|(UINT32_C(0x2)<< 29)
comment|/* Value is in bits or bytes. */
define|#
directive|define
name|HWRM_FUNC_QCFG_OUTPUT_MIN_BW_BW_VALUE_UNIT_BASE
value|(UINT32_C(0x4)<< 29)
comment|/* Value is in Gb or GB (base 10). */
define|#
directive|define
name|HWRM_FUNC_QCFG_OUTPUT_MIN_BW_BW_VALUE_UNIT_GIGA
value|(UINT32_C(0x6)<< 29)
comment|/* Value is in 1/100th of a percentage of total bandwidth. */
define|#
directive|define
name|HWRM_FUNC_QCFG_OUTPUT_MIN_BW_BW_VALUE_UNIT_PERCENT1_100
value|(UINT32_C(0x1)<< 29)
comment|/* Invalid unit */
define|#
directive|define
name|HWRM_FUNC_QCFG_OUTPUT_MIN_BW_BW_VALUE_UNIT_INVALID
value|(UINT32_C(0x7)<< 29)
define|#
directive|define
name|HWRM_FUNC_QCFG_OUTPUT_MIN_BW_BW_VALUE_UNIT_LAST
value|HWRM_FUNC_QCFG_OUTPUT_MIN_BW_BW_VALUE_UNIT_INVALID
name|uint32_t
name|max_bw
decl_stmt|;
comment|/* 	 * Maximum BW allocated for this function. The HWRM will translate this 	 * value into byte counter and time interval used for the scheduler 	 * inside the device. A value of 0 indicates that the maximum bandwidth 	 * is not configured. 	 */
comment|/* The bandwidth value. */
define|#
directive|define
name|HWRM_FUNC_QCFG_OUTPUT_MAX_BW_BW_VALUE_MASK
value|UINT32_C(0xfffffff)
define|#
directive|define
name|HWRM_FUNC_QCFG_OUTPUT_MAX_BW_BW_VALUE_SFT
value|0
comment|/* The granularity of the value (bits or bytes). */
define|#
directive|define
name|HWRM_FUNC_QCFG_OUTPUT_MAX_BW_SCALE
value|UINT32_C(0x10000000)
comment|/* Value is in bits. */
define|#
directive|define
name|HWRM_FUNC_QCFG_OUTPUT_MAX_BW_SCALE_BITS
value|(UINT32_C(0x0)<< 28)
comment|/* Value is in bytes. */
define|#
directive|define
name|HWRM_FUNC_QCFG_OUTPUT_MAX_BW_SCALE_BYTES
value|(UINT32_C(0x1)<< 28)
define|#
directive|define
name|HWRM_FUNC_QCFG_OUTPUT_MAX_BW_SCALE_LAST
value|HWRM_FUNC_QCFG_OUTPUT_MAX_BW_SCALE_BYTES
comment|/* bw_value_unit is 3 b */
define|#
directive|define
name|HWRM_FUNC_QCFG_OUTPUT_MAX_BW_BW_VALUE_UNIT_MASK
value|UINT32_C(0xe0000000)
define|#
directive|define
name|HWRM_FUNC_QCFG_OUTPUT_MAX_BW_BW_VALUE_UNIT_SFT
value|29
comment|/* Value is in Mb or MB (base 10). */
define|#
directive|define
name|HWRM_FUNC_QCFG_OUTPUT_MAX_BW_BW_VALUE_UNIT_MEGA
value|(UINT32_C(0x0)<< 29)
comment|/* Value is in Kb or KB (base 10). */
define|#
directive|define
name|HWRM_FUNC_QCFG_OUTPUT_MAX_BW_BW_VALUE_UNIT_KILO
value|(UINT32_C(0x2)<< 29)
comment|/* Value is in bits or bytes. */
define|#
directive|define
name|HWRM_FUNC_QCFG_OUTPUT_MAX_BW_BW_VALUE_UNIT_BASE
value|(UINT32_C(0x4)<< 29)
comment|/* Value is in Gb or GB (base 10). */
define|#
directive|define
name|HWRM_FUNC_QCFG_OUTPUT_MAX_BW_BW_VALUE_UNIT_GIGA
value|(UINT32_C(0x6)<< 29)
comment|/* Value is in 1/100th of a percentage of total bandwidth. */
define|#
directive|define
name|HWRM_FUNC_QCFG_OUTPUT_MAX_BW_BW_VALUE_UNIT_PERCENT1_100
value|(UINT32_C(0x1)<< 29)
comment|/* Invalid unit */
define|#
directive|define
name|HWRM_FUNC_QCFG_OUTPUT_MAX_BW_BW_VALUE_UNIT_INVALID
value|(UINT32_C(0x7)<< 29)
define|#
directive|define
name|HWRM_FUNC_QCFG_OUTPUT_MAX_BW_BW_VALUE_UNIT_LAST
value|HWRM_FUNC_QCFG_OUTPUT_MAX_BW_BW_VALUE_UNIT_INVALID
name|uint8_t
name|evb_mode
decl_stmt|;
comment|/* 	 * This value indicates the Edge virtual bridge mode for the domain that 	 * this function belongs to. 	 */
comment|/* No Edge Virtual Bridging (EVB) */
define|#
directive|define
name|HWRM_FUNC_QCFG_OUTPUT_EVB_MODE_NO_EVB
value|UINT32_C(0x0)
comment|/* Virtual Ethernet Bridge (VEB) */
define|#
directive|define
name|HWRM_FUNC_QCFG_OUTPUT_EVB_MODE_VEB
value|UINT32_C(0x1)
comment|/* Virtual Ethernet Port Aggregator (VEPA) */
define|#
directive|define
name|HWRM_FUNC_QCFG_OUTPUT_EVB_MODE_VEPA
value|UINT32_C(0x2)
name|uint8_t
name|unused_2
decl_stmt|;
name|uint16_t
name|alloc_vfs
decl_stmt|;
comment|/* 	 * The number of VFs that are allocated to the function. This is valid 	 * only on the PF with SR-IOV enabled. 0xFF... (All Fs) if this command 	 * is called on a PF with SR-IOV disabled or on a VF. 	 */
name|uint32_t
name|alloc_mcast_filters
decl_stmt|;
comment|/* 	 * The number of allocated multicast filters for this function on the RX 	 * side. 	 */
name|uint32_t
name|alloc_hw_ring_grps
decl_stmt|;
comment|/* The number of allocated HW ring groups for this function. */
name|uint16_t
name|alloc_sp_tx_rings
decl_stmt|;
comment|/* 	 * The number of strict priority transmit rings out of currently 	 * allocated TX rings to the function (alloc_tx_rings). 	 */
name|uint8_t
name|unused_3
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_func_vlan_qcfg */
end_comment

begin_comment
comment|/*  * Description: This command should be called by PF driver to get the current  * C-TAG, S-TAG and correcponsing PCP and TPID values configured for the  * function.  */
end_comment

begin_comment
comment|/* Input (24 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_func_vlan_qcfg_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint16_t
name|fid
decl_stmt|;
comment|/* 	 * Function ID of the function that is being configured. If set to 	 * 0xFF... (All Fs), then the configuration is for the requesting 	 * function. 	 */
name|uint16_t
name|unused_0
index|[
literal|3
index|]
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (40 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_func_vlan_qcfg_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint32_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
name|uint16_t
name|stag_vid
decl_stmt|;
comment|/* S-TAG VLAN identifier configured for the function. */
name|uint8_t
name|stag_pcp
decl_stmt|;
comment|/* S-TAG PCP value configured for the function. */
name|uint8_t
name|unused_4
decl_stmt|;
name|uint16_t
name|stag_tpid
decl_stmt|;
comment|/* big endian */
comment|/* 	 * S-TAG TPID value configured for the function. This field is specified 	 * in network byte order. 	 */
name|uint16_t
name|ctag_vid
decl_stmt|;
comment|/* C-TAG VLAN identifier configured for the function. */
name|uint8_t
name|ctag_pcp
decl_stmt|;
comment|/* C-TAG PCP value configured for the function. */
name|uint8_t
name|unused_5
decl_stmt|;
name|uint16_t
name|ctag_tpid
decl_stmt|;
comment|/* big endian */
comment|/* 	 * C-TAG TPID value configured for the function. This field is specified 	 * in network byte order. 	 */
name|uint32_t
name|rsvd2
decl_stmt|;
comment|/* Future use. */
name|uint32_t
name|rsvd3
decl_stmt|;
comment|/* Future use. */
name|uint32_t
name|unused_6
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_func_vlan_cfg */
end_comment

begin_comment
comment|/*  * Description: This command allows PF driver to configure C-TAG, S-TAG and  * corresponding PCP and TPID values for a function.  */
end_comment

begin_comment
comment|/* Input (48 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_func_vlan_cfg_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint16_t
name|fid
decl_stmt|;
comment|/* 	 * Function ID of the function that is being configured. If set to 	 * 0xFF... (All Fs), then the configuration is for the requesting 	 * function. 	 */
name|uint8_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint32_t
name|enables
decl_stmt|;
comment|/* This bit must be '1' for the stag_vid field to be configured. */
define|#
directive|define
name|HWRM_FUNC_VLAN_CFG_INPUT_ENABLES_STAG_VID
value|UINT32_C(0x1)
comment|/* This bit must be '1' for the ctag_vid field to be configured. */
define|#
directive|define
name|HWRM_FUNC_VLAN_CFG_INPUT_ENABLES_CTAG_VID
value|UINT32_C(0x2)
comment|/* This bit must be '1' for the stag_pcp field to be configured. */
define|#
directive|define
name|HWRM_FUNC_VLAN_CFG_INPUT_ENABLES_STAG_PCP
value|UINT32_C(0x4)
comment|/* This bit must be '1' for the ctag_pcp field to be configured. */
define|#
directive|define
name|HWRM_FUNC_VLAN_CFG_INPUT_ENABLES_CTAG_PCP
value|UINT32_C(0x8)
comment|/* This bit must be '1' for the stag_tpid field to be configured. */
define|#
directive|define
name|HWRM_FUNC_VLAN_CFG_INPUT_ENABLES_STAG_TPID
value|UINT32_C(0x10)
comment|/* This bit must be '1' for the ctag_tpid field to be configured. */
define|#
directive|define
name|HWRM_FUNC_VLAN_CFG_INPUT_ENABLES_CTAG_TPID
value|UINT32_C(0x20)
name|uint16_t
name|stag_vid
decl_stmt|;
comment|/* S-TAG VLAN identifier configured for the function. */
name|uint8_t
name|stag_pcp
decl_stmt|;
comment|/* S-TAG PCP value configured for the function. */
name|uint8_t
name|unused_2
decl_stmt|;
name|uint16_t
name|stag_tpid
decl_stmt|;
comment|/* big endian */
comment|/* 	 * S-TAG TPID value configured for the function. This field is specified 	 * in network byte order. 	 */
name|uint16_t
name|ctag_vid
decl_stmt|;
comment|/* C-TAG VLAN identifier configured for the function. */
name|uint8_t
name|ctag_pcp
decl_stmt|;
comment|/* C-TAG PCP value configured for the function. */
name|uint8_t
name|unused_3
decl_stmt|;
name|uint16_t
name|ctag_tpid
decl_stmt|;
comment|/* big endian */
comment|/* 	 * C-TAG TPID value configured for the function. This field is specified 	 * in network byte order. 	 */
name|uint32_t
name|rsvd1
decl_stmt|;
comment|/* Future use. */
name|uint32_t
name|rsvd2
decl_stmt|;
comment|/* Future use. */
name|uint32_t
name|unused_4
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_func_vlan_cfg_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint32_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_func_cfg */
end_comment

begin_comment
comment|/*  * Description: This command allows configuration of a PF by the corresponding  * PF driver. This command also allows configuration of a child VF by its parent  * PF driver. The input FID value is used to indicate what function is being  * configured. This allows a PF driver to configure the PF owned by itself or a  * virtual function that is a child of the PF. This command allows to reserve  * resources for a VF by its parent PF. To reverse the process, the command  * should be called with all enables flags cleared for resources. This will free  * allocated resources for the VF and return them to the resource pool. If this  * command is requested by a VF driver to configure or reserve resources, then  * the HWRM shall fail this command. If default MAC address and/or VLAN are  * provided in this command, then the HWRM shall set up appropriate MAC/VLAN  * filters for the function that is being configured. If source properties  * checks are enabled and default MAC address and/or IP address are provided in  * this command, then the HWRM shall set appropriate source property checks  * based on provided MAC and/or IP addresses. The parent PF driver should not  * set MTU/MRU for a VF using this command. This is to allow MTU/MRU setting by  * the VF driver. If the MTU or MRU for a VF is set by the PF driver, then the  * HWRM should ignore it. A function's MTU/MRU should be set prior to allocating  * RX VNICs or TX rings. A PF driver calls hwrm_func_cfg to allocate resources  * for itself or its children VFs. All function drivers shall call hwrm_func_cfg  * to reserve resources. A request to hwrm_func_cfg may not be fully granted;  * that is, a request for resources may be larger than what can be supported by  * the device and the HWRM will allocate the best set of resources available,  * but that may be less than requested. If all the amounts requested could not  * be fulfilled, the HWRM shall allocate what it could and return a status code  * of success. A function driver should call hwrm_func_qcfg immediately after  * hwrm_func_cfg to determine what resources were assigned to the configured  * function. A call by a PF driver to hwrm_func_cfg to allocate resources for  * itself shall only allocate resources for the PF driver to use, not for its  * children VFs. Likewise, a call to hwrm_func_qcfg shall return the resources  * available for the PF driver to use, not what is available to its children  * VFs.  */
end_comment

begin_comment
comment|/* Input (88 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_func_cfg_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint16_t
name|fid
decl_stmt|;
comment|/* 	 * Function ID of the function that is being configured. If set to 	 * 0xFF... (All Fs), then the the configuration is for the requesting 	 * function. 	 */
name|uint8_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint32_t
name|flags
decl_stmt|;
comment|/* 	 * When this bit is '1', the function is disabled with source MAC 	 * address check. This is an anti-spoofing check. If this flag is set, 	 * then the function shall be configured to disallow transmission of 	 * frames with the source MAC address that is configured for this 	 * function. 	 */
define|#
directive|define
name|HWRM_FUNC_CFG_INPUT_FLAGS_SRC_MAC_ADDR_CHECK_DISABLE
value|UINT32_C(0x1)
comment|/* 	 * When this bit is '1', the function is enabled with source MAC address 	 * check. This is an anti-spoofing check. If this flag is set, then the 	 * function shall be configured to allow transmission of frames with the 	 * source MAC address that is configured for this function. 	 */
define|#
directive|define
name|HWRM_FUNC_CFG_INPUT_FLAGS_SRC_MAC_ADDR_CHECK_ENABLE
value|UINT32_C(0x2)
comment|/* reserved */
define|#
directive|define
name|HWRM_FUNC_CFG_INPUT_FLAGS_RSVD_MASK
value|UINT32_C(0x1fc)
define|#
directive|define
name|HWRM_FUNC_CFG_INPUT_FLAGS_RSVD_SFT
value|2
comment|/* 	 * Standard TX Ring mode is used for the allocation of TX ring and 	 * underlying scheduling resources that allow bandwidth reservation and 	 * limit settings on the queried function. If set to 1, then standard TX 	 * ring mode is requested to be enabled on the function being 	 * configured. 	 */
define|#
directive|define
name|HWRM_FUNC_CFG_INPUT_FLAGS_STD_TX_RING_MODE_ENABLE
value|UINT32_C(0x200)
comment|/* 	 * Standard TX Ring mode is used for the allocation of TX ring and 	 * underlying scheduling resources that allow bandwidth reservation and 	 * limit settings on the queried function. If set to 1, then the 	 * standard TX ring mode is requested to be disabled on the function 	 * being configured. In this extended TX ring resource mode, the minimum 	 * and maximum bandwidth settings are not supported to allow the 	 * allocation of TX rings to span multiple scheduler nodes. 	 */
define|#
directive|define
name|HWRM_FUNC_CFG_INPUT_FLAGS_STD_TX_RING_MODE_DISABLE
value|UINT32_C(0x400)
comment|/* 	 * If this bit is set, virtual mac address configured in this command 	 * will be persistent over warm boot. 	 */
define|#
directive|define
name|HWRM_FUNC_CFG_INPUT_FLAGS_VIRT_MAC_PERSIST
value|UINT32_C(0x800)
comment|/* 	 * This bit only applies to the VF. If this bit is set, the statistic 	 * context counters will not be cleared when the statistic context is 	 * freed or a function reset is called on VF. This bit will be cleared 	 * when the PF is unloaded or a function reset is called on the PF. 	 */
define|#
directive|define
name|HWRM_FUNC_CFG_INPUT_FLAGS_NO_AUTOCLEAR_STATISTIC
value|UINT32_C(0x1000)
comment|/* 	 * This bit requests that the firmware test to see if all the assets 	 * requested in this command (i.e. number of TX rings) are available. 	 * The firmware will return an error if the requested assets are not 	 * available. The firwmare will NOT reserve the assets if they are 	 * available. 	 */
define|#
directive|define
name|HWRM_FUNC_CFG_INPUT_FLAGS_TX_ASSETS_TEST
value|UINT32_C(0x2000)
name|uint32_t
name|enables
decl_stmt|;
comment|/* This bit must be '1' for the mtu field to be configured. */
define|#
directive|define
name|HWRM_FUNC_CFG_INPUT_ENABLES_MTU
value|UINT32_C(0x1)
comment|/* This bit must be '1' for the mru field to be configured. */
define|#
directive|define
name|HWRM_FUNC_CFG_INPUT_ENABLES_MRU
value|UINT32_C(0x2)
comment|/* This bit must be '1' for the num_rsscos_ctxs field to be configured. */
define|#
directive|define
name|HWRM_FUNC_CFG_INPUT_ENABLES_NUM_RSSCOS_CTXS
value|UINT32_C(0x4)
comment|/* This bit must be '1' for the num_cmpl_rings field to be configured. */
define|#
directive|define
name|HWRM_FUNC_CFG_INPUT_ENABLES_NUM_CMPL_RINGS
value|UINT32_C(0x8)
comment|/* This bit must be '1' for the num_tx_rings field to be configured. */
define|#
directive|define
name|HWRM_FUNC_CFG_INPUT_ENABLES_NUM_TX_RINGS
value|UINT32_C(0x10)
comment|/* This bit must be '1' for the num_rx_rings field to be configured. */
define|#
directive|define
name|HWRM_FUNC_CFG_INPUT_ENABLES_NUM_RX_RINGS
value|UINT32_C(0x20)
comment|/* This bit must be '1' for the num_l2_ctxs field to be configured. */
define|#
directive|define
name|HWRM_FUNC_CFG_INPUT_ENABLES_NUM_L2_CTXS
value|UINT32_C(0x40)
comment|/* This bit must be '1' for the num_vnics field to be configured. */
define|#
directive|define
name|HWRM_FUNC_CFG_INPUT_ENABLES_NUM_VNICS
value|UINT32_C(0x80)
comment|/* This bit must be '1' for the num_stat_ctxs field to be configured. */
define|#
directive|define
name|HWRM_FUNC_CFG_INPUT_ENABLES_NUM_STAT_CTXS
value|UINT32_C(0x100)
comment|/* This bit must be '1' for the dflt_mac_addr field to be configured. */
define|#
directive|define
name|HWRM_FUNC_CFG_INPUT_ENABLES_DFLT_MAC_ADDR
value|UINT32_C(0x200)
comment|/* This bit must be '1' for the dflt_vlan field to be configured. */
define|#
directive|define
name|HWRM_FUNC_CFG_INPUT_ENABLES_DFLT_VLAN
value|UINT32_C(0x400)
comment|/* This bit must be '1' for the dflt_ip_addr field to be configured. */
define|#
directive|define
name|HWRM_FUNC_CFG_INPUT_ENABLES_DFLT_IP_ADDR
value|UINT32_C(0x800)
comment|/* This bit must be '1' for the min_bw field to be configured. */
define|#
directive|define
name|HWRM_FUNC_CFG_INPUT_ENABLES_MIN_BW
value|UINT32_C(0x1000)
comment|/* This bit must be '1' for the max_bw field to be configured. */
define|#
directive|define
name|HWRM_FUNC_CFG_INPUT_ENABLES_MAX_BW
value|UINT32_C(0x2000)
comment|/* This bit must be '1' for the async_event_cr field to be configured. */
define|#
directive|define
name|HWRM_FUNC_CFG_INPUT_ENABLES_ASYNC_EVENT_CR
value|UINT32_C(0x4000)
comment|/* 	 * This bit must be '1' for the vlan_antispoof_mode field to be 	 * configured. 	 */
define|#
directive|define
name|HWRM_FUNC_CFG_INPUT_ENABLES_VLAN_ANTISPOOF_MODE
value|UINT32_C(0x8000)
comment|/* 	 * This bit must be '1' for the allowed_vlan_pris field to be 	 * configured. 	 */
define|#
directive|define
name|HWRM_FUNC_CFG_INPUT_ENABLES_ALLOWED_VLAN_PRIS
value|UINT32_C(0x10000)
comment|/* This bit must be '1' for the evb_mode field to be configured. */
define|#
directive|define
name|HWRM_FUNC_CFG_INPUT_ENABLES_EVB_MODE
value|UINT32_C(0x20000)
comment|/* 	 * This bit must be '1' for the num_mcast_filters field to be 	 * configured. 	 */
define|#
directive|define
name|HWRM_FUNC_CFG_INPUT_ENABLES_NUM_MCAST_FILTERS
value|UINT32_C(0x40000)
comment|/* This bit must be '1' for the num_hw_ring_grps field to be configured. */
define|#
directive|define
name|HWRM_FUNC_CFG_INPUT_ENABLES_NUM_HW_RING_GRPS
value|UINT32_C(0x80000)
name|uint16_t
name|mtu
decl_stmt|;
comment|/* 	 * The maximum transmission unit of the function. The HWRM should make 	 * sure that the mtu of the function does not exceed the mtu of the 	 * physical port that this function is associated with. In addition to 	 * configuring mtu per function, it is possible to configure mtu per 	 * transmit ring. By default, the mtu of each transmit ring associated 	 * with a function is equal to the mtu of the function. The HWRM should 	 * make sure that the mtu of each transmit ring that is assigned to a 	 * function has a valid mtu. 	 */
name|uint16_t
name|mru
decl_stmt|;
comment|/* 	 * The maximum receive unit of the function. The HWRM should make sure 	 * that the mru of the function does not exceed the mru of the physical 	 * port that this function is associated with. In addition to 	 * configuring mru per function, it is possible to configure mru per 	 * vnic. By default, the mru of each vnic associated with a function is 	 * equal to the mru of the function. The HWRM should make sure that the 	 * mru of each vnic that is assigned to a function has a valid mru. 	 */
name|uint16_t
name|num_rsscos_ctxs
decl_stmt|;
comment|/* The number of RSS/COS contexts requested for the function. */
name|uint16_t
name|num_cmpl_rings
decl_stmt|;
comment|/* 	 * The number of completion rings requested for the function. This does 	 * not include the rings allocated to any children functions if any. 	 */
name|uint16_t
name|num_tx_rings
decl_stmt|;
comment|/* 	 * The number of transmit rings requested for the function. This does 	 * not include the rings allocated to any children functions if any. 	 */
name|uint16_t
name|num_rx_rings
decl_stmt|;
comment|/* 	 * The number of receive rings requested for the function. This does not 	 * include the rings allocated to any children functions if any. 	 */
name|uint16_t
name|num_l2_ctxs
decl_stmt|;
comment|/* The requested number of L2 contexts for the function. */
name|uint16_t
name|num_vnics
decl_stmt|;
comment|/* The requested number of vnics for the function. */
name|uint16_t
name|num_stat_ctxs
decl_stmt|;
comment|/* The requested number of statistic contexts for the function. */
name|uint16_t
name|num_hw_ring_grps
decl_stmt|;
comment|/* 	 * The number of HW ring groups that should be reserved for this 	 * function. 	 */
name|uint8_t
name|dflt_mac_addr
index|[
literal|6
index|]
decl_stmt|;
comment|/* The default MAC address for the function being configured. */
name|uint16_t
name|dflt_vlan
decl_stmt|;
comment|/* 	 * The default VLAN for the function being configured. This field's 	 * format is same as 802.1Q Tag's Tag Control Information (TCI) format 	 * that includes both Priority Code Point (PCP) and VLAN Identifier 	 * (VID). 	 */
name|uint32_t
name|dflt_ip_addr
index|[
literal|4
index|]
decl_stmt|;
comment|/* big endian */
comment|/* 	 * The default IP address for the function being configured. This 	 * address is only used in enabling source property check. 	 */
name|uint32_t
name|min_bw
decl_stmt|;
comment|/* 	 * Minimum BW allocated for this function. The HWRM will translate this 	 * value into byte counter and time interval used for the scheduler 	 * inside the device. 	 */
comment|/* The bandwidth value. */
define|#
directive|define
name|HWRM_FUNC_CFG_INPUT_MIN_BW_BW_VALUE_MASK
value|UINT32_C(0xfffffff)
define|#
directive|define
name|HWRM_FUNC_CFG_INPUT_MIN_BW_BW_VALUE_SFT
value|0
comment|/* The granularity of the value (bits or bytes). */
define|#
directive|define
name|HWRM_FUNC_CFG_INPUT_MIN_BW_SCALE
value|UINT32_C(0x10000000)
comment|/* Value is in bits. */
define|#
directive|define
name|HWRM_FUNC_CFG_INPUT_MIN_BW_SCALE_BITS
value|(UINT32_C(0x0)<< 28)
comment|/* Value is in bytes. */
define|#
directive|define
name|HWRM_FUNC_CFG_INPUT_MIN_BW_SCALE_BYTES
value|(UINT32_C(0x1)<< 28)
define|#
directive|define
name|HWRM_FUNC_CFG_INPUT_MIN_BW_SCALE_LAST
value|HWRM_FUNC_CFG_INPUT_MIN_BW_SCALE_BYTES
comment|/* bw_value_unit is 3 b */
define|#
directive|define
name|HWRM_FUNC_CFG_INPUT_MIN_BW_BW_VALUE_UNIT_MASK
value|UINT32_C(0xe0000000)
define|#
directive|define
name|HWRM_FUNC_CFG_INPUT_MIN_BW_BW_VALUE_UNIT_SFT
value|29
comment|/* Value is in Mb or MB (base 10). */
define|#
directive|define
name|HWRM_FUNC_CFG_INPUT_MIN_BW_BW_VALUE_UNIT_MEGA
value|(UINT32_C(0x0)<< 29)
comment|/* Value is in Kb or KB (base 10). */
define|#
directive|define
name|HWRM_FUNC_CFG_INPUT_MIN_BW_BW_VALUE_UNIT_KILO
value|(UINT32_C(0x2)<< 29)
comment|/* Value is in bits or bytes. */
define|#
directive|define
name|HWRM_FUNC_CFG_INPUT_MIN_BW_BW_VALUE_UNIT_BASE
value|(UINT32_C(0x4)<< 29)
comment|/* Value is in Gb or GB (base 10). */
define|#
directive|define
name|HWRM_FUNC_CFG_INPUT_MIN_BW_BW_VALUE_UNIT_GIGA
value|(UINT32_C(0x6)<< 29)
comment|/* Value is in 1/100th of a percentage of total bandwidth. */
define|#
directive|define
name|HWRM_FUNC_CFG_INPUT_MIN_BW_BW_VALUE_UNIT_PERCENT1_100
value|(UINT32_C(0x1)<< 29)
comment|/* Invalid unit */
define|#
directive|define
name|HWRM_FUNC_CFG_INPUT_MIN_BW_BW_VALUE_UNIT_INVALID
value|(UINT32_C(0x7)<< 29)
define|#
directive|define
name|HWRM_FUNC_CFG_INPUT_MIN_BW_BW_VALUE_UNIT_LAST
value|HWRM_FUNC_CFG_INPUT_MIN_BW_BW_VALUE_UNIT_INVALID
name|uint32_t
name|max_bw
decl_stmt|;
comment|/* 	 * Maximum BW allocated for this function. The HWRM will translate this 	 * value into byte counter and time interval used for the scheduler 	 * inside the device. 	 */
comment|/* The bandwidth value. */
define|#
directive|define
name|HWRM_FUNC_CFG_INPUT_MAX_BW_BW_VALUE_MASK
value|UINT32_C(0xfffffff)
define|#
directive|define
name|HWRM_FUNC_CFG_INPUT_MAX_BW_BW_VALUE_SFT
value|0
comment|/* The granularity of the value (bits or bytes). */
define|#
directive|define
name|HWRM_FUNC_CFG_INPUT_MAX_BW_SCALE
value|UINT32_C(0x10000000)
comment|/* Value is in bits. */
define|#
directive|define
name|HWRM_FUNC_CFG_INPUT_MAX_BW_SCALE_BITS
value|(UINT32_C(0x0)<< 28)
comment|/* Value is in bytes. */
define|#
directive|define
name|HWRM_FUNC_CFG_INPUT_MAX_BW_SCALE_BYTES
value|(UINT32_C(0x1)<< 28)
define|#
directive|define
name|HWRM_FUNC_CFG_INPUT_MAX_BW_SCALE_LAST
value|HWRM_FUNC_CFG_INPUT_MAX_BW_SCALE_BYTES
comment|/* bw_value_unit is 3 b */
define|#
directive|define
name|HWRM_FUNC_CFG_INPUT_MAX_BW_BW_VALUE_UNIT_MASK
value|UINT32_C(0xe0000000)
define|#
directive|define
name|HWRM_FUNC_CFG_INPUT_MAX_BW_BW_VALUE_UNIT_SFT
value|29
comment|/* Value is in Mb or MB (base 10). */
define|#
directive|define
name|HWRM_FUNC_CFG_INPUT_MAX_BW_BW_VALUE_UNIT_MEGA
value|(UINT32_C(0x0)<< 29)
comment|/* Value is in Kb or KB (base 10). */
define|#
directive|define
name|HWRM_FUNC_CFG_INPUT_MAX_BW_BW_VALUE_UNIT_KILO
value|(UINT32_C(0x2)<< 29)
comment|/* Value is in bits or bytes. */
define|#
directive|define
name|HWRM_FUNC_CFG_INPUT_MAX_BW_BW_VALUE_UNIT_BASE
value|(UINT32_C(0x4)<< 29)
comment|/* Value is in Gb or GB (base 10). */
define|#
directive|define
name|HWRM_FUNC_CFG_INPUT_MAX_BW_BW_VALUE_UNIT_GIGA
value|(UINT32_C(0x6)<< 29)
comment|/* Value is in 1/100th of a percentage of total bandwidth. */
define|#
directive|define
name|HWRM_FUNC_CFG_INPUT_MAX_BW_BW_VALUE_UNIT_PERCENT1_100
value|(UINT32_C(0x1)<< 29)
comment|/* Invalid unit */
define|#
directive|define
name|HWRM_FUNC_CFG_INPUT_MAX_BW_BW_VALUE_UNIT_INVALID
value|(UINT32_C(0x7)<< 29)
define|#
directive|define
name|HWRM_FUNC_CFG_INPUT_MAX_BW_BW_VALUE_UNIT_LAST
value|HWRM_FUNC_CFG_INPUT_MAX_BW_BW_VALUE_UNIT_INVALID
name|uint16_t
name|async_event_cr
decl_stmt|;
comment|/* 	 * ID of the target completion ring for receiving asynchronous event 	 * completions. If this field is not valid, then the HWRM shall use the 	 * default completion ring of the function that is being configured as 	 * the target completion ring for providing any asynchronous event 	 * completions for that function. If this field is valid, then the HWRM 	 * shall use the completion ring identified by this ID as the target 	 * completion ring for providing any asynchronous event completions for 	 * the function that is being configured. 	 */
name|uint8_t
name|vlan_antispoof_mode
decl_stmt|;
comment|/* VLAN Anti-spoofing mode. */
comment|/* No VLAN anti-spoofing checks are enabled */
define|#
directive|define
name|HWRM_FUNC_CFG_INPUT_VLAN_ANTISPOOF_MODE_NOCHECK
value|UINT32_C(0x0)
comment|/* Validate VLAN against the configured VLAN(s) */
define|#
directive|define
name|HWRM_FUNC_CFG_INPUT_VLAN_ANTISPOOF_MODE_VALIDATE_VLAN
value|UINT32_C(0x1)
comment|/* Insert VLAN if it does not exist, otherwise discard */
define|#
directive|define
name|HWRM_FUNC_CFG_INPUT_VLAN_ANTISPOOF_MODE_INSERT_IF_VLANDNE
value|UINT32_C(0x2)
comment|/* Insert VLAN if it does not exist, override VLAN if it exists */
define|#
directive|define
name|HWRM_FUNC_CFG_INPUT_VLAN_ANTISPOOF_MODE_INSERT_OR_OVERRIDE_VLAN
value|UINT32_C(0x3)
name|uint8_t
name|allowed_vlan_pris
decl_stmt|;
comment|/* 	 * This bit field defines VLAN PRIs that are allowed on this function. 	 * If nth bit is set, then VLAN PRI n is allowed on this function. 	 */
name|uint8_t
name|evb_mode
decl_stmt|;
comment|/* 	 * The HWRM shall allow a PF driver to change EVB mode for the partition 	 * it belongs to. The HWRM shall not allow a VF driver to change the EVB 	 * mode. The HWRM shall take into account the switching of EVB mode from 	 * one to another and reconfigure hardware resources as appropriately. 	 * The switching from VEB to VEPA mode requires the disabling of the 	 * loopback traffic. Additionally, source knock outs are handled 	 * differently in VEB and VEPA modes. 	 */
comment|/* No Edge Virtual Bridging (EVB) */
define|#
directive|define
name|HWRM_FUNC_CFG_INPUT_EVB_MODE_NO_EVB
value|UINT32_C(0x0)
comment|/* Virtual Ethernet Bridge (VEB) */
define|#
directive|define
name|HWRM_FUNC_CFG_INPUT_EVB_MODE_VEB
value|UINT32_C(0x1)
comment|/* Virtual Ethernet Port Aggregator (VEPA) */
define|#
directive|define
name|HWRM_FUNC_CFG_INPUT_EVB_MODE_VEPA
value|UINT32_C(0x2)
name|uint8_t
name|unused_2
decl_stmt|;
name|uint16_t
name|num_mcast_filters
decl_stmt|;
comment|/* 	 * The number of multicast filters that should be reserved for this 	 * function on the RX side. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_func_cfg_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint32_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_func_qstats */
end_comment

begin_comment
comment|/*  * Description: This command returns statistics of a function. The input FID  * value is used to indicate what function is being queried. This allows a  * physical function driver to query virtual functions that are children of the  * physical function. The HWRM shall return any unsupported counter with a value  * of 0xFFFFFFFF for 32-bit counters and 0xFFFFFFFFFFFFFFFF for 64-bit counters.  */
end_comment

begin_comment
comment|/* Input (24 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_func_qstats_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint16_t
name|fid
decl_stmt|;
comment|/* 	 * Function ID of the function that is being queried. 0xFF... (All Fs) 	 * if the query is for the requesting function. 	 */
name|uint16_t
name|unused_0
index|[
literal|3
index|]
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (176 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_func_qstats_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint64_t
name|tx_ucast_pkts
decl_stmt|;
comment|/* Number of transmitted unicast packets on the function. */
name|uint64_t
name|tx_mcast_pkts
decl_stmt|;
comment|/* Number of transmitted multicast packets on the function. */
name|uint64_t
name|tx_bcast_pkts
decl_stmt|;
comment|/* Number of transmitted broadcast packets on the function. */
name|uint64_t
name|tx_discard_pkts
decl_stmt|;
comment|/* 	 * Number of transmitted packets that were discarded due to internal NIC 	 * resource problems. For transmit, this can only happen if TMP is 	 * configured to allow dropping in HOL blocking conditions, which is not 	 * a normal configuration. 	 */
name|uint64_t
name|tx_drop_pkts
decl_stmt|;
comment|/* 	 * Number of dropped packets on transmit path on the function. These are 	 * packets that have been marked for drop by the TE CFA block or are 	 * packets that exceeded the transmit MTU limit for the function. 	 */
name|uint64_t
name|tx_ucast_bytes
decl_stmt|;
comment|/* Number of transmitted bytes for unicast traffic on the function. */
name|uint64_t
name|tx_mcast_bytes
decl_stmt|;
comment|/* Number of transmitted bytes for multicast traffic on the function. */
name|uint64_t
name|tx_bcast_bytes
decl_stmt|;
comment|/* Number of transmitted bytes for broadcast traffic on the function. */
name|uint64_t
name|rx_ucast_pkts
decl_stmt|;
comment|/* Number of received unicast packets on the function. */
name|uint64_t
name|rx_mcast_pkts
decl_stmt|;
comment|/* Number of received multicast packets on the function. */
name|uint64_t
name|rx_bcast_pkts
decl_stmt|;
comment|/* Number of received broadcast packets on the function. */
name|uint64_t
name|rx_discard_pkts
decl_stmt|;
comment|/* 	 * Number of received packets that were discarded on the function due to 	 * resource limitations. This can happen for 3 reasons. # The BD used 	 * for the packet has a bad format. # There were no BDs available in the 	 * ring for the packet. # There were no BDs available on-chip for the 	 * packet. 	 */
name|uint64_t
name|rx_drop_pkts
decl_stmt|;
comment|/* 	 * Number of dropped packets on received path on the function. These are 	 * packets that have been marked for drop by the RE CFA. 	 */
name|uint64_t
name|rx_ucast_bytes
decl_stmt|;
comment|/* Number of received bytes for unicast traffic on the function. */
name|uint64_t
name|rx_mcast_bytes
decl_stmt|;
comment|/* Number of received bytes for multicast traffic on the function. */
name|uint64_t
name|rx_bcast_bytes
decl_stmt|;
comment|/* Number of received bytes for broadcast traffic on the function. */
name|uint64_t
name|rx_agg_pkts
decl_stmt|;
comment|/* Number of aggregated unicast packets on the function. */
name|uint64_t
name|rx_agg_bytes
decl_stmt|;
comment|/* Number of aggregated unicast bytes on the function. */
name|uint64_t
name|rx_agg_events
decl_stmt|;
comment|/* Number of aggregation events on the function. */
name|uint64_t
name|rx_agg_aborts
decl_stmt|;
comment|/* Number of aborted aggregations on the function. */
name|uint32_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_func_clr_stats */
end_comment

begin_comment
comment|/*  * Description: This command clears statistics of a function. The input FID  * value is used to indicate what function's statistics is being cleared. This  * allows a physical function driver to clear statistics of virtual functions  * that are children of the physical function.  */
end_comment

begin_comment
comment|/* Input (24 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_func_clr_stats_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint16_t
name|fid
decl_stmt|;
comment|/* 	 * Function ID of the function. 0xFF... (All Fs) if the query is for the 	 * requesting function. 	 */
name|uint16_t
name|unused_0
index|[
literal|3
index|]
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_func_clr_stats_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint32_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_func_vf_resc_free */
end_comment

begin_comment
comment|/* Description: This command frees resources of a vf. */
end_comment

begin_comment
comment|/* Input (24 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_func_vf_resc_free_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint16_t
name|vf_id
decl_stmt|;
comment|/* 	 * This value is used to identify a Virtual Function (VF). The scope of 	 * VF ID is local within a PF. 	 */
name|uint16_t
name|unused_0
index|[
literal|3
index|]
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_func_vf_resc_free_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint32_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_func_vf_vnic_ids_query */
end_comment

begin_comment
comment|/* Description: This command is used to query vf vnic ids. */
end_comment

begin_comment
comment|/* Input (32 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_func_vf_vnic_ids_query_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint16_t
name|vf_id
decl_stmt|;
comment|/* 	 * This value is used to identify a Virtual Function (VF). The scope of 	 * VF ID is local within a PF. 	 */
name|uint8_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint32_t
name|max_vnic_id_cnt
decl_stmt|;
comment|/* Max number of vnic ids in vnic id table */
name|uint64_t
name|vnic_id_tbl_addr
decl_stmt|;
comment|/* This is the address for VF VNIC ID table */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_func_vf_vnic_ids_query_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint32_t
name|vnic_id_cnt
decl_stmt|;
comment|/* Actual number of vnic ids Each VNIC ID is written as a 32-bit number. */
name|uint8_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_func_drv_rgtr */
end_comment

begin_comment
comment|/*  * Description: This command is used by the function driver to register its  * information with the HWRM. A function driver shall implement this command. A  * function driver shall use this command during the driver initialization right  * after the HWRM version discovery and default ring resources allocation.  */
end_comment

begin_comment
comment|/* Input (80 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_func_drv_rgtr_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint32_t
name|flags
decl_stmt|;
comment|/* 	 * When this bit is '1', the function driver is requesting all requests 	 * from its children VF drivers to be forwarded to itself. This flag can 	 * only be set by the PF driver. If a VF driver sets this flag, it 	 * should be ignored by the HWRM. 	 */
define|#
directive|define
name|HWRM_FUNC_DRV_RGTR_INPUT_FLAGS_FWD_ALL_MODE
value|UINT32_C(0x1)
comment|/* 	 * When this bit is '1', the function is requesting none of the requests 	 * from its children VF drivers to be forwarded to itself. This flag can 	 * only be set by the PF driver. If a VF driver sets this flag, it 	 * should be ignored by the HWRM. 	 */
define|#
directive|define
name|HWRM_FUNC_DRV_RGTR_INPUT_FLAGS_FWD_NONE_MODE
value|UINT32_C(0x2)
name|uint32_t
name|enables
decl_stmt|;
comment|/* This bit must be '1' for the os_type field to be configured. */
define|#
directive|define
name|HWRM_FUNC_DRV_RGTR_INPUT_ENABLES_OS_TYPE
value|UINT32_C(0x1)
comment|/* This bit must be '1' for the ver field to be configured. */
define|#
directive|define
name|HWRM_FUNC_DRV_RGTR_INPUT_ENABLES_VER
value|UINT32_C(0x2)
comment|/* This bit must be '1' for the timestamp field to be configured. */
define|#
directive|define
name|HWRM_FUNC_DRV_RGTR_INPUT_ENABLES_TIMESTAMP
value|UINT32_C(0x4)
comment|/* This bit must be '1' for the vf_req_fwd field to be configured. */
define|#
directive|define
name|HWRM_FUNC_DRV_RGTR_INPUT_ENABLES_VF_REQ_FWD
value|UINT32_C(0x8)
comment|/* This bit must be '1' for the async_event_fwd field to be configured. */
define|#
directive|define
name|HWRM_FUNC_DRV_RGTR_INPUT_ENABLES_ASYNC_EVENT_FWD
value|UINT32_C(0x10)
name|uint16_t
name|os_type
decl_stmt|;
comment|/* 	 * This value indicates the type of OS. The values are based on 	 * CIM_OperatingSystem.mof file as published by the DMTF. 	 */
comment|/* Unknown */
define|#
directive|define
name|HWRM_FUNC_DRV_RGTR_INPUT_OS_TYPE_UNKNOWN
value|UINT32_C(0x0)
comment|/* Other OS not listed below. */
define|#
directive|define
name|HWRM_FUNC_DRV_RGTR_INPUT_OS_TYPE_OTHER
value|UINT32_C(0x1)
comment|/* MSDOS OS. */
define|#
directive|define
name|HWRM_FUNC_DRV_RGTR_INPUT_OS_TYPE_MSDOS
value|UINT32_C(0xe)
comment|/* Windows OS. */
define|#
directive|define
name|HWRM_FUNC_DRV_RGTR_INPUT_OS_TYPE_WINDOWS
value|UINT32_C(0x12)
comment|/* Solaris OS. */
define|#
directive|define
name|HWRM_FUNC_DRV_RGTR_INPUT_OS_TYPE_SOLARIS
value|UINT32_C(0x1d)
comment|/* Linux OS. */
define|#
directive|define
name|HWRM_FUNC_DRV_RGTR_INPUT_OS_TYPE_LINUX
value|UINT32_C(0x24)
comment|/* FreeBSD OS. */
define|#
directive|define
name|HWRM_FUNC_DRV_RGTR_INPUT_OS_TYPE_FREEBSD
value|UINT32_C(0x2a)
comment|/* VMware ESXi OS. */
define|#
directive|define
name|HWRM_FUNC_DRV_RGTR_INPUT_OS_TYPE_ESXI
value|UINT32_C(0x68)
comment|/* Microsoft Windows 8 64-bit OS. */
define|#
directive|define
name|HWRM_FUNC_DRV_RGTR_INPUT_OS_TYPE_WIN864
value|UINT32_C(0x73)
comment|/* Microsoft Windows Server 2012 R2 OS. */
define|#
directive|define
name|HWRM_FUNC_DRV_RGTR_INPUT_OS_TYPE_WIN2012R2
value|UINT32_C(0x74)
name|uint8_t
name|ver_maj
decl_stmt|;
comment|/* This is the major version of the driver. */
name|uint8_t
name|ver_min
decl_stmt|;
comment|/* This is the minor version of the driver. */
name|uint8_t
name|ver_upd
decl_stmt|;
comment|/* This is the update version of the driver. */
name|uint8_t
name|unused_0
decl_stmt|;
name|uint16_t
name|unused_1
decl_stmt|;
name|uint32_t
name|timestamp
decl_stmt|;
comment|/* 	 * This is a 32-bit timestamp provided by the driver for keep alive. The 	 * timestamp is in multiples of 1ms. 	 */
name|uint32_t
name|unused_2
decl_stmt|;
name|uint32_t
name|vf_req_fwd
index|[
literal|8
index|]
decl_stmt|;
comment|/* 	 * This is a 256-bit bit mask provided by the PF driver for letting the 	 * HWRM know what commands issued by the VF driver to the HWRM should be 	 * forwarded to the PF driver. Nth bit refers to the Nth req_type. 	 * Setting Nth bit to 1 indicates that requests from the VF driver with 	 * req_type equal to N shall be forwarded to the parent PF driver. This 	 * field is not valid for the VF driver. 	 */
name|uint32_t
name|async_event_fwd
index|[
literal|8
index|]
decl_stmt|;
comment|/* 	 * This is a 256-bit bit mask provided by the function driver (PF or VF 	 * driver) to indicate the list of asynchronous event completions to be 	 * forwarded. Nth bit refers to the Nth event_id. Setting Nth bit to 1 	 * by the function driver shall result in the HWRM forwarding 	 * asynchronous event completion with event_id equal to N. If all bits 	 * are set to 0 (value of 0), then the HWRM shall not forward any 	 * asynchronous event completion to this function driver. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_func_drv_rgtr_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint32_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_func_drv_unrgtr */
end_comment

begin_comment
comment|/*  * Description: This command is used by the function driver to un register with  * the HWRM. A function driver shall implement this command. A function driver  * shall use this command during the driver unloading.  */
end_comment

begin_comment
comment|/* Input (24 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_func_drv_unrgtr_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint32_t
name|flags
decl_stmt|;
comment|/* 	 * When this bit is '1', the function driver is notifying the HWRM to 	 * prepare for the shutdown. 	 */
define|#
directive|define
name|HWRM_FUNC_DRV_UNRGTR_INPUT_FLAGS_PREPARE_FOR_SHUTDOWN
value|UINT32_C(0x1)
name|uint32_t
name|unused_0
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_func_drv_unrgtr_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint32_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_func_buf_rgtr */
end_comment

begin_comment
comment|/*  * Description: This command is used by the PF driver to register buffers used  * in the PF-VF communication with the HWRM. The PF driver uses this command to  * register buffers for each PF-VF channel. A parent PF may issue this command  * per child VF. If VF ID is not valid, then this command is used to register  * buffers for all children VFs of the PF.  */
end_comment

begin_comment
comment|/* Input (128 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_func_buf_rgtr_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint32_t
name|enables
decl_stmt|;
comment|/* This bit must be '1' for the vf_id field to be configured. */
define|#
directive|define
name|HWRM_FUNC_BUF_RGTR_INPUT_ENABLES_VF_ID
value|UINT32_C(0x1)
comment|/* This bit must be '1' for the err_buf_addr field to be configured. */
define|#
directive|define
name|HWRM_FUNC_BUF_RGTR_INPUT_ENABLES_ERR_BUF_ADDR
value|UINT32_C(0x2)
name|uint16_t
name|vf_id
decl_stmt|;
comment|/* 	 * This value is used to identify a Virtual Function (VF). The scope of 	 * VF ID is local within a PF. 	 */
name|uint16_t
name|req_buf_num_pages
decl_stmt|;
comment|/* This field represents the number of pages used for request buffer(s). */
name|uint16_t
name|req_buf_page_size
decl_stmt|;
comment|/* This field represents the page size used for request buffer(s). */
comment|/* 16 bytes */
define|#
directive|define
name|HWRM_FUNC_BUF_RGTR_INPUT_REQ_BUF_PAGE_SIZE_16B
value|UINT32_C(0x4)
comment|/* 4 Kbytes */
define|#
directive|define
name|HWRM_FUNC_BUF_RGTR_INPUT_REQ_BUF_PAGE_SIZE_4K
value|UINT32_C(0xc)
comment|/* 8 Kbytes */
define|#
directive|define
name|HWRM_FUNC_BUF_RGTR_INPUT_REQ_BUF_PAGE_SIZE_8K
value|UINT32_C(0xd)
comment|/* 64 Kbytes */
define|#
directive|define
name|HWRM_FUNC_BUF_RGTR_INPUT_REQ_BUF_PAGE_SIZE_64K
value|UINT32_C(0x10)
comment|/* 2 Mbytes */
define|#
directive|define
name|HWRM_FUNC_BUF_RGTR_INPUT_REQ_BUF_PAGE_SIZE_2M
value|UINT32_C(0x15)
comment|/* 4 Mbytes */
define|#
directive|define
name|HWRM_FUNC_BUF_RGTR_INPUT_REQ_BUF_PAGE_SIZE_4M
value|UINT32_C(0x16)
comment|/* 1 Gbytes */
define|#
directive|define
name|HWRM_FUNC_BUF_RGTR_INPUT_REQ_BUF_PAGE_SIZE_1G
value|UINT32_C(0x1e)
name|uint16_t
name|req_buf_len
decl_stmt|;
comment|/* The length of the request buffer per VF in bytes. */
name|uint16_t
name|resp_buf_len
decl_stmt|;
comment|/* The length of the response buffer in bytes. */
name|uint8_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint64_t
name|req_buf_page_addr0
decl_stmt|;
comment|/* This field represents the page address of page #0. */
name|uint64_t
name|req_buf_page_addr1
decl_stmt|;
comment|/* This field represents the page address of page #1. */
name|uint64_t
name|req_buf_page_addr2
decl_stmt|;
comment|/* This field represents the page address of page #2. */
name|uint64_t
name|req_buf_page_addr3
decl_stmt|;
comment|/* This field represents the page address of page #3. */
name|uint64_t
name|req_buf_page_addr4
decl_stmt|;
comment|/* This field represents the page address of page #4. */
name|uint64_t
name|req_buf_page_addr5
decl_stmt|;
comment|/* This field represents the page address of page #5. */
name|uint64_t
name|req_buf_page_addr6
decl_stmt|;
comment|/* This field represents the page address of page #6. */
name|uint64_t
name|req_buf_page_addr7
decl_stmt|;
comment|/* This field represents the page address of page #7. */
name|uint64_t
name|req_buf_page_addr8
decl_stmt|;
comment|/* This field represents the page address of page #8. */
name|uint64_t
name|req_buf_page_addr9
decl_stmt|;
comment|/* This field represents the page address of page #9. */
name|uint64_t
name|error_buf_addr
decl_stmt|;
comment|/* 	 * This field is used to receive the error reporting from the chipset. 	 * Only applicable for PFs. 	 */
name|uint64_t
name|resp_buf_addr
decl_stmt|;
comment|/* This field is used to receive the response forwarded by the HWRM. */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_func_buf_rgtr_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint32_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_func_buf_unrgtr */
end_comment

begin_comment
comment|/*  * Description: This command is used by the PF driver to unregister buffers used  * in the PF-VF communication with the HWRM. The PF driver uses this command to  * unregister buffers for PF-VF communication. A parent PF may issue this  * command to unregister buffers for communication between the PF and a specific  * VF. If the VF ID is not valid, then this command is used to unregister  * buffers used for communications with all children VFs of the PF.  */
end_comment

begin_comment
comment|/* Input (24 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_func_buf_unrgtr_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint32_t
name|enables
decl_stmt|;
comment|/* This bit must be '1' for the vf_id field to be configured. */
define|#
directive|define
name|HWRM_FUNC_BUF_UNRGTR_INPUT_ENABLES_VF_ID
value|UINT32_C(0x1)
name|uint16_t
name|vf_id
decl_stmt|;
comment|/* 	 * This value is used to identify a Virtual Function (VF). The scope of 	 * VF ID is local within a PF. 	 */
name|uint16_t
name|unused_0
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_func_buf_unrgtr_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint32_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_func_drv_qver */
end_comment

begin_comment
comment|/*  * Description: This command is used to query the version of the driver. Any  * driver version with major = 0, minor = 0, and update = 0 shall be considered  * an invalid or unknown version.  */
end_comment

begin_comment
comment|/* Input (24 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_func_drv_qver_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint32_t
name|reserved
decl_stmt|;
comment|/* Reserved for future use */
name|uint16_t
name|fid
decl_stmt|;
comment|/* 	 * Function ID of the function that is being queried. 0xFF... (All Fs) 	 * if the query is for the requesting function. 	 */
name|uint16_t
name|unused_0
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_func_drv_qver_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint16_t
name|os_type
decl_stmt|;
comment|/* 	 * This value indicates the type of OS. The values are based on 	 * CIM_OperatingSystem.mof file as published by the DMTF. 	 */
comment|/* Unknown */
define|#
directive|define
name|HWRM_FUNC_DRV_QVER_OUTPUT_OS_TYPE_UNKNOWN
value|UINT32_C(0x0)
comment|/* Other OS not listed below. */
define|#
directive|define
name|HWRM_FUNC_DRV_QVER_OUTPUT_OS_TYPE_OTHER
value|UINT32_C(0x1)
comment|/* MSDOS OS. */
define|#
directive|define
name|HWRM_FUNC_DRV_QVER_OUTPUT_OS_TYPE_MSDOS
value|UINT32_C(0xe)
comment|/* Windows OS. */
define|#
directive|define
name|HWRM_FUNC_DRV_QVER_OUTPUT_OS_TYPE_WINDOWS
value|UINT32_C(0x12)
comment|/* Solaris OS. */
define|#
directive|define
name|HWRM_FUNC_DRV_QVER_OUTPUT_OS_TYPE_SOLARIS
value|UINT32_C(0x1d)
comment|/* Linux OS. */
define|#
directive|define
name|HWRM_FUNC_DRV_QVER_OUTPUT_OS_TYPE_LINUX
value|UINT32_C(0x24)
comment|/* FreeBSD OS. */
define|#
directive|define
name|HWRM_FUNC_DRV_QVER_OUTPUT_OS_TYPE_FREEBSD
value|UINT32_C(0x2a)
comment|/* VMware ESXi OS. */
define|#
directive|define
name|HWRM_FUNC_DRV_QVER_OUTPUT_OS_TYPE_ESXI
value|UINT32_C(0x68)
comment|/* Microsoft Windows 8 64-bit OS. */
define|#
directive|define
name|HWRM_FUNC_DRV_QVER_OUTPUT_OS_TYPE_WIN864
value|UINT32_C(0x73)
comment|/* Microsoft Windows Server 2012 R2 OS. */
define|#
directive|define
name|HWRM_FUNC_DRV_QVER_OUTPUT_OS_TYPE_WIN2012R2
value|UINT32_C(0x74)
name|uint8_t
name|ver_maj
decl_stmt|;
comment|/* This is the major version of the driver. */
name|uint8_t
name|ver_min
decl_stmt|;
comment|/* This is the minor version of the driver. */
name|uint8_t
name|ver_upd
decl_stmt|;
comment|/* This is the update version of the driver. */
name|uint8_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_port_phy_cfg */
end_comment

begin_comment
comment|/*  * Description: This command configures the PHY device for the port. It allows  * setting of the most generic settings for the PHY. The HWRM shall complete  * this command as soon as PHY settings are configured. They may not be applied  * when the command response is provided. A VF driver shall not be allowed to  * configure PHY using this command. In a network partition mode, a PF driver  * shall not be allowed to configure PHY using this command.  */
end_comment

begin_comment
comment|/* Input (56 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_port_phy_cfg_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint32_t
name|flags
decl_stmt|;
comment|/* 	 * When this bit is set to '1', the PHY for the port shall be reset. # 	 * If this bit is set to 1, then the HWRM shall reset the PHY after 	 * applying PHY configuration changes specified in this command. # In 	 * order to guarantee that PHY configuration changes specified in this 	 * command take effect, the HWRM client should set this flag to 1. # If 	 * this bit is not set to 1, then the HWRM may reset the PHY depending 	 * on the current PHY configuration and settings specified in this 	 * command. 	 */
define|#
directive|define
name|HWRM_PORT_PHY_CFG_INPUT_FLAGS_RESET_PHY
value|UINT32_C(0x1)
comment|/* deprecated bit. Do not use!!! */
define|#
directive|define
name|HWRM_PORT_PHY_CFG_INPUT_FLAGS_DEPRECATED
value|UINT32_C(0x2)
comment|/* 	 * When this bit is set to '1', the link shall be forced to the 	 * force_link_speed value. When this bit is set to '1', the HWRM client 	 * should not enable any of the auto negotiation related fields 	 * represented by auto_XXX fields in this command. When this bit is set 	 * to '1' and the HWRM client has enabled a auto_XXX field in this 	 * command, then the HWRM shall ignore the enabled auto_XXX field. When 	 * this bit is set to zero, the link shall be allowed to autoneg. 	 */
define|#
directive|define
name|HWRM_PORT_PHY_CFG_INPUT_FLAGS_FORCE
value|UINT32_C(0x4)
comment|/* 	 * When this bit is set to '1', the auto-negotiation process shall be 	 * restarted on the link. 	 */
define|#
directive|define
name|HWRM_PORT_PHY_CFG_INPUT_FLAGS_RESTART_AUTONEG
value|UINT32_C(0x8)
comment|/* 	 * When this bit is set to '1', Energy Efficient Ethernet (EEE) is 	 * requested to be enabled on this link. If EEE is not supported on this 	 * port, then this flag shall be ignored by the HWRM. 	 */
define|#
directive|define
name|HWRM_PORT_PHY_CFG_INPUT_FLAGS_EEE_ENABLE
value|UINT32_C(0x10)
comment|/* 	 * When this bit is set to '1', Energy Efficient Ethernet (EEE) is 	 * requested to be disabled on this link. If EEE is not supported on 	 * this port, then this flag shall be ignored by the HWRM. 	 */
define|#
directive|define
name|HWRM_PORT_PHY_CFG_INPUT_FLAGS_EEE_DISABLE
value|UINT32_C(0x20)
comment|/* 	 * When this bit is set to '1' and EEE is enabled on this link, then TX 	 * LPI is requested to be enabled on the link. If EEE is not supported 	 * on this port, then this flag shall be ignored by the HWRM. If EEE is 	 * disabled on this port, then this flag shall be ignored by the HWRM. 	 */
define|#
directive|define
name|HWRM_PORT_PHY_CFG_INPUT_FLAGS_EEE_TX_LPI_ENABLE
value|UINT32_C(0x40)
comment|/* 	 * When this bit is set to '1' and EEE is enabled on this link, then TX 	 * LPI is requested to be disabled on the link. If EEE is not supported 	 * on this port, then this flag shall be ignored by the HWRM. If EEE is 	 * disabled on this port, then this flag shall be ignored by the HWRM. 	 */
define|#
directive|define
name|HWRM_PORT_PHY_CFG_INPUT_FLAGS_EEE_TX_LPI_DISABLE
value|UINT32_C(0x80)
comment|/* 	 * When set to 1, then the HWRM shall enable FEC autonegotitation on 	 * this port if supported. When set to 0, then this flag shall be 	 * ignored. If FEC autonegotiation is not supported, then the HWRM shall 	 * ignore this flag. 	 */
define|#
directive|define
name|HWRM_PORT_PHY_CFG_INPUT_FLAGS_FEC_AUTONEG_ENABLE
value|UINT32_C(0x100)
comment|/* 	 * When set to 1, then the HWRM shall disable FEC autonegotiation on 	 * this port if supported. When set to 0, then this flag shall be 	 * ignored. If FEC autonegotiation is not supported, then the HWRM shall 	 * ignore this flag. 	 */
define|#
directive|define
name|HWRM_PORT_PHY_CFG_INPUT_FLAGS_FEC_AUTONEG_DISABLE
value|UINT32_C(0x200)
comment|/* 	 * When set to 1, then the HWRM shall enable FEC CLAUSE 74 (Fire Code) 	 * on this port if supported. When set to 0, then this flag shall be 	 * ignored. If FEC CLAUSE 74 is not supported, then the HWRM shall 	 * ignore this flag. 	 */
define|#
directive|define
name|HWRM_PORT_PHY_CFG_INPUT_FLAGS_FEC_CLAUSE74_ENABLE
value|UINT32_C(0x400)
comment|/* 	 * When set to 1, then the HWRM shall disable FEC CLAUSE 74 (Fire Code) 	 * on this port if supported. When set to 0, then this flag shall be 	 * ignored. If FEC CLAUSE 74 is not supported, then the HWRM shall 	 * ignore this flag. 	 */
define|#
directive|define
name|HWRM_PORT_PHY_CFG_INPUT_FLAGS_FEC_CLAUSE74_DISABLE
value|UINT32_C(0x800)
comment|/* 	 * When set to 1, then the HWRM shall enable FEC CLAUSE 91 (Reed 	 * Solomon) on this port if supported. When set to 0, then this flag 	 * shall be ignored. If FEC CLAUSE 91 is not supported, then the HWRM 	 * shall ignore this flag. 	 */
define|#
directive|define
name|HWRM_PORT_PHY_CFG_INPUT_FLAGS_FEC_CLAUSE91_ENABLE
value|UINT32_C(0x1000)
comment|/* 	 * When set to 1, then the HWRM shall disable FEC CLAUSE 91 (Reed 	 * Solomon) on this port if supported. When set to 0, then this flag 	 * shall be ignored. If FEC CLAUSE 91 is not supported, then the HWRM 	 * shall ignore this flag. 	 */
define|#
directive|define
name|HWRM_PORT_PHY_CFG_INPUT_FLAGS_FEC_CLAUSE91_DISABLE
value|UINT32_C(0x2000)
comment|/* 	 * When this bit is set to '1', the link shall be forced to be taken 	 * down. # When this bit is set to '1", all other command input settings 	 * related to the link speed shall be ignored. Once the link state is 	 * forced down, it can be explicitly cleared from that state by setting 	 * this flag to '0'. # If this flag is set to '0', then the link shall 	 * be cleared from forced down state if the link is in forced down 	 * state. There may be conditions (e.g. out-of-band or sideband 	 * configuration changes for the link) outside the scope of the HWRM 	 * implementation that may clear forced down link state. 	 */
define|#
directive|define
name|HWRM_PORT_PHY_CFG_INPUT_FLAGS_FORCE_LINK_DWN
value|UINT32_C(0x4000)
name|uint32_t
name|enables
decl_stmt|;
comment|/* This bit must be '1' for the auto_mode field to be configured. */
define|#
directive|define
name|HWRM_PORT_PHY_CFG_INPUT_ENABLES_AUTO_MODE
value|UINT32_C(0x1)
comment|/* This bit must be '1' for the auto_duplex field to be configured. */
define|#
directive|define
name|HWRM_PORT_PHY_CFG_INPUT_ENABLES_AUTO_DUPLEX
value|UINT32_C(0x2)
comment|/* This bit must be '1' for the auto_pause field to be configured. */
define|#
directive|define
name|HWRM_PORT_PHY_CFG_INPUT_ENABLES_AUTO_PAUSE
value|UINT32_C(0x4)
comment|/* This bit must be '1' for the auto_link_speed field to be configured. */
define|#
directive|define
name|HWRM_PORT_PHY_CFG_INPUT_ENABLES_AUTO_LINK_SPEED
value|UINT32_C(0x8)
comment|/* 	 * This bit must be '1' for the auto_link_speed_mask field to be 	 * configured. 	 */
define|#
directive|define
name|HWRM_PORT_PHY_CFG_INPUT_ENABLES_AUTO_LINK_SPEED_MASK
value|UINT32_C(0x10)
comment|/* This bit must be '1' for the wirespeed field to be configured. */
define|#
directive|define
name|HWRM_PORT_PHY_CFG_INPUT_ENABLES_WIRESPEED
value|UINT32_C(0x20)
comment|/* This bit must be '1' for the lpbk field to be configured. */
define|#
directive|define
name|HWRM_PORT_PHY_CFG_INPUT_ENABLES_LPBK
value|UINT32_C(0x40)
comment|/* This bit must be '1' for the preemphasis field to be configured. */
define|#
directive|define
name|HWRM_PORT_PHY_CFG_INPUT_ENABLES_PREEMPHASIS
value|UINT32_C(0x80)
comment|/* This bit must be '1' for the force_pause field to be configured. */
define|#
directive|define
name|HWRM_PORT_PHY_CFG_INPUT_ENABLES_FORCE_PAUSE
value|UINT32_C(0x100)
comment|/* 	 * This bit must be '1' for the eee_link_speed_mask field to be 	 * configured. 	 */
define|#
directive|define
name|HWRM_PORT_PHY_CFG_INPUT_ENABLES_EEE_LINK_SPEED_MASK
value|UINT32_C(0x200)
comment|/* This bit must be '1' for the tx_lpi_timer field to be configured. */
define|#
directive|define
name|HWRM_PORT_PHY_CFG_INPUT_ENABLES_TX_LPI_TIMER
value|UINT32_C(0x400)
name|uint16_t
name|port_id
decl_stmt|;
comment|/* Port ID of port that is to be configured. */
name|uint16_t
name|force_link_speed
decl_stmt|;
comment|/* 	 * This is the speed that will be used if the force bit is '1'. If 	 * unsupported speed is selected, an error will be generated. 	 */
comment|/* 100Mb link speed */
define|#
directive|define
name|HWRM_PORT_PHY_CFG_INPUT_FORCE_LINK_SPEED_100MB
value|UINT32_C(0x1)
comment|/* 1Gb link speed */
define|#
directive|define
name|HWRM_PORT_PHY_CFG_INPUT_FORCE_LINK_SPEED_1GB
value|UINT32_C(0xa)
comment|/* 2Gb link speed */
define|#
directive|define
name|HWRM_PORT_PHY_CFG_INPUT_FORCE_LINK_SPEED_2GB
value|UINT32_C(0x14)
comment|/* 2.5Gb link speed */
define|#
directive|define
name|HWRM_PORT_PHY_CFG_INPUT_FORCE_LINK_SPEED_2_5GB
value|UINT32_C(0x19)
comment|/* 10Gb link speed */
define|#
directive|define
name|HWRM_PORT_PHY_CFG_INPUT_FORCE_LINK_SPEED_10GB
value|UINT32_C(0x64)
comment|/* 20Mb link speed */
define|#
directive|define
name|HWRM_PORT_PHY_CFG_INPUT_FORCE_LINK_SPEED_20GB
value|UINT32_C(0xc8)
comment|/* 25Gb link speed */
define|#
directive|define
name|HWRM_PORT_PHY_CFG_INPUT_FORCE_LINK_SPEED_25GB
value|UINT32_C(0xfa)
comment|/* 40Gb link speed */
define|#
directive|define
name|HWRM_PORT_PHY_CFG_INPUT_FORCE_LINK_SPEED_40GB
value|UINT32_C(0x190)
comment|/* 50Gb link speed */
define|#
directive|define
name|HWRM_PORT_PHY_CFG_INPUT_FORCE_LINK_SPEED_50GB
value|UINT32_C(0x1f4)
comment|/* 100Gb link speed */
define|#
directive|define
name|HWRM_PORT_PHY_CFG_INPUT_FORCE_LINK_SPEED_100GB
value|UINT32_C(0x3e8)
comment|/* 10Mb link speed */
define|#
directive|define
name|HWRM_PORT_PHY_CFG_INPUT_FORCE_LINK_SPEED_10MB
value|UINT32_C(0xffff)
name|uint8_t
name|auto_mode
decl_stmt|;
comment|/* 	 * This value is used to identify what autoneg mode is used when the 	 * link speed is not being forced. 	 */
comment|/* Disable autoneg or autoneg disabled. No speeds are selected. */
define|#
directive|define
name|HWRM_PORT_PHY_CFG_INPUT_AUTO_MODE_NONE
value|UINT32_C(0x0)
comment|/* Select all possible speeds for autoneg mode. */
define|#
directive|define
name|HWRM_PORT_PHY_CFG_INPUT_AUTO_MODE_ALL_SPEEDS
value|UINT32_C(0x1)
comment|/* 	 * Select only the auto_link_speed speed for autoneg mode. This 	 * mode has been DEPRECATED. An HWRM client should not use this 	 * mode. 	 */
define|#
directive|define
name|HWRM_PORT_PHY_CFG_INPUT_AUTO_MODE_ONE_SPEED
value|UINT32_C(0x2)
comment|/* 	 * Select the auto_link_speed or any speed below that speed for 	 * autoneg. This mode has been DEPRECATED. An HWRM client should 	 * not use this mode. 	 */
define|#
directive|define
name|HWRM_PORT_PHY_CFG_INPUT_AUTO_MODE_ONE_OR_BELOW
value|UINT32_C(0x3)
comment|/* 	 * Select the speeds based on the corresponding link speed mask 	 * value that is provided. 	 */
define|#
directive|define
name|HWRM_PORT_PHY_CFG_INPUT_AUTO_MODE_SPEED_MASK
value|UINT32_C(0x4)
name|uint8_t
name|auto_duplex
decl_stmt|;
comment|/* 	 * This is the duplex setting that will be used if the autoneg_mode is 	 * "one_speed" or "one_or_below". 	 */
comment|/* Half Duplex will be requested. */
define|#
directive|define
name|HWRM_PORT_PHY_CFG_INPUT_AUTO_DUPLEX_HALF
value|UINT32_C(0x0)
comment|/* Full duplex will be requested. */
define|#
directive|define
name|HWRM_PORT_PHY_CFG_INPUT_AUTO_DUPLEX_FULL
value|UINT32_C(0x1)
comment|/* Both Half and Full dupex will be requested. */
define|#
directive|define
name|HWRM_PORT_PHY_CFG_INPUT_AUTO_DUPLEX_BOTH
value|UINT32_C(0x2)
name|uint8_t
name|auto_pause
decl_stmt|;
comment|/* 	 * This value is used to configure the pause that will be used for 	 * autonegotiation. Add text on the usage of auto_pause and force_pause. 	 */
comment|/* 	 * When this bit is '1', Generation of tx pause messages has been 	 * requested. Disabled otherwise. 	 */
define|#
directive|define
name|HWRM_PORT_PHY_CFG_INPUT_AUTO_PAUSE_TX
value|UINT32_C(0x1)
comment|/* 	 * When this bit is '1', Reception of rx pause messages has been 	 * requested. Disabled otherwise. 	 */
define|#
directive|define
name|HWRM_PORT_PHY_CFG_INPUT_AUTO_PAUSE_RX
value|UINT32_C(0x2)
comment|/* 	 * When set to 1, the advertisement of pause is enabled. # When the 	 * auto_mode is not set to none and this flag is set to 1, then the 	 * auto_pause bits on this port are being advertised and autoneg pause 	 * results are being interpreted. # When the auto_mode is not set to 	 * none and this flag is set to 0, the pause is forced as indicated in 	 * force_pause, and also advertised as auto_pause bits, but the autoneg 	 * results are not interpreted since the pause configuration is being 	 * forced. # When the auto_mode is set to none and this flag is set to 	 * 1, auto_pause bits should be ignored and should be set to 0. 	 */
define|#
directive|define
name|HWRM_PORT_PHY_CFG_INPUT_AUTO_PAUSE_AUTONEG_PAUSE
value|UINT32_C(0x4)
name|uint8_t
name|unused_0
decl_stmt|;
name|uint16_t
name|auto_link_speed
decl_stmt|;
comment|/* 	 * This is the speed that will be used if the autoneg_mode is 	 * "one_speed" or "one_or_below". If an unsupported speed is selected, 	 * an error will be generated. 	 */
comment|/* 100Mb link speed */
define|#
directive|define
name|HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEED_100MB
value|UINT32_C(0x1)
comment|/* 1Gb link speed */
define|#
directive|define
name|HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEED_1GB
value|UINT32_C(0xa)
comment|/* 2Gb link speed */
define|#
directive|define
name|HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEED_2GB
value|UINT32_C(0x14)
comment|/* 2.5Gb link speed */
define|#
directive|define
name|HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEED_2_5GB
value|UINT32_C(0x19)
comment|/* 10Gb link speed */
define|#
directive|define
name|HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEED_10GB
value|UINT32_C(0x64)
comment|/* 20Mb link speed */
define|#
directive|define
name|HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEED_20GB
value|UINT32_C(0xc8)
comment|/* 25Gb link speed */
define|#
directive|define
name|HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEED_25GB
value|UINT32_C(0xfa)
comment|/* 40Gb link speed */
define|#
directive|define
name|HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEED_40GB
value|UINT32_C(0x190)
comment|/* 50Gb link speed */
define|#
directive|define
name|HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEED_50GB
value|UINT32_C(0x1f4)
comment|/* 100Gb link speed */
define|#
directive|define
name|HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEED_100GB
value|UINT32_C(0x3e8)
comment|/* 10Mb link speed */
define|#
directive|define
name|HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEED_10MB
value|UINT32_C(0xffff)
name|uint16_t
name|auto_link_speed_mask
decl_stmt|;
comment|/* 	 * This is a mask of link speeds that will be used if autoneg_mode is 	 * "mask". If unsupported speed is enabled an error will be generated. 	 */
comment|/* 100Mb link speed (Half-duplex) */
define|#
directive|define
name|HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEED_MASK_100MBHD
value|UINT32_C(0x1)
comment|/* 100Mb link speed (Full-duplex) */
define|#
directive|define
name|HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEED_MASK_100MB
value|UINT32_C(0x2)
comment|/* 1Gb link speed (Half-duplex) */
define|#
directive|define
name|HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEED_MASK_1GBHD
value|UINT32_C(0x4)
comment|/* 1Gb link speed (Full-duplex) */
define|#
directive|define
name|HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEED_MASK_1GB
value|UINT32_C(0x8)
comment|/* 2Gb link speed */
define|#
directive|define
name|HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEED_MASK_2GB
value|UINT32_C(0x10)
comment|/* 2.5Gb link speed */
define|#
directive|define
name|HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEED_MASK_2_5GB
value|UINT32_C(0x20)
comment|/* 10Gb link speed */
define|#
directive|define
name|HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEED_MASK_10GB
value|UINT32_C(0x40)
comment|/* 20Gb link speed */
define|#
directive|define
name|HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEED_MASK_20GB
value|UINT32_C(0x80)
comment|/* 25Gb link speed */
define|#
directive|define
name|HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEED_MASK_25GB
value|UINT32_C(0x100)
comment|/* 40Gb link speed */
define|#
directive|define
name|HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEED_MASK_40GB
value|UINT32_C(0x200)
comment|/* 50Gb link speed */
define|#
directive|define
name|HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEED_MASK_50GB
value|UINT32_C(0x400)
comment|/* 100Gb link speed */
define|#
directive|define
name|HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEED_MASK_100GB
value|UINT32_C(0x800)
comment|/* 10Mb link speed (Half-duplex) */
define|#
directive|define
name|HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEED_MASK_10MBHD
value|UINT32_C(0x1000)
comment|/* 10Mb link speed (Full-duplex) */
define|#
directive|define
name|HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEED_MASK_10MB
value|UINT32_C(0x2000)
name|uint8_t
name|wirespeed
decl_stmt|;
comment|/* This value controls the wirespeed feature. */
comment|/* Wirespeed feature is disabled. */
define|#
directive|define
name|HWRM_PORT_PHY_CFG_INPUT_WIRESPEED_OFF
value|UINT32_C(0x0)
comment|/* Wirespeed feature is enabled. */
define|#
directive|define
name|HWRM_PORT_PHY_CFG_INPUT_WIRESPEED_ON
value|UINT32_C(0x1)
name|uint8_t
name|lpbk
decl_stmt|;
comment|/* This value controls the loopback setting for the PHY. */
comment|/* No loopback is selected. Normal operation. */
define|#
directive|define
name|HWRM_PORT_PHY_CFG_INPUT_LPBK_NONE
value|UINT32_C(0x0)
comment|/* 	 * The HW will be configured with local loopback such that host 	 * data is sent back to the host without modification. 	 */
define|#
directive|define
name|HWRM_PORT_PHY_CFG_INPUT_LPBK_LOCAL
value|UINT32_C(0x1)
comment|/* 	 * The HW will be configured with remote loopback such that port 	 * logic will send packets back out the transmitter that are 	 * received. 	 */
define|#
directive|define
name|HWRM_PORT_PHY_CFG_INPUT_LPBK_REMOTE
value|UINT32_C(0x2)
name|uint8_t
name|force_pause
decl_stmt|;
comment|/* 	 * This value is used to configure the pause that will be used for force 	 * mode. 	 */
comment|/* 	 * When this bit is '1', Generation of tx pause messages is supported. 	 * Disabled otherwise. 	 */
define|#
directive|define
name|HWRM_PORT_PHY_CFG_INPUT_FORCE_PAUSE_TX
value|UINT32_C(0x1)
comment|/* 	 * When this bit is '1', Reception of rx pause messages is supported. 	 * Disabled otherwise. 	 */
define|#
directive|define
name|HWRM_PORT_PHY_CFG_INPUT_FORCE_PAUSE_RX
value|UINT32_C(0x2)
name|uint8_t
name|unused_1
decl_stmt|;
name|uint32_t
name|preemphasis
decl_stmt|;
comment|/* 	 * This value controls the pre-emphasis to be used for the link. Driver 	 * should not set this value (use enable.preemphasis = 0) unless driver 	 * is sure of setting. Normally HWRM FW will determine proper pre- 	 * emphasis. 	 */
name|uint16_t
name|eee_link_speed_mask
decl_stmt|;
comment|/* 	 * Setting for link speed mask that is used to advertise speeds during 	 * autonegotiation when EEE is enabled. This field is valid only when 	 * EEE is enabled. The speeds specified in this field shall be a subset 	 * of speeds specified in auto_link_speed_mask. If EEE is enabled,then 	 * at least one speed shall be provided in this mask. 	 */
comment|/* Reserved */
define|#
directive|define
name|HWRM_PORT_PHY_CFG_INPUT_EEE_LINK_SPEED_MASK_RSVD1
value|UINT32_C(0x1)
comment|/* 100Mb link speed (Full-duplex) */
define|#
directive|define
name|HWRM_PORT_PHY_CFG_INPUT_EEE_LINK_SPEED_MASK_100MB
value|UINT32_C(0x2)
comment|/* Reserved */
define|#
directive|define
name|HWRM_PORT_PHY_CFG_INPUT_EEE_LINK_SPEED_MASK_RSVD2
value|UINT32_C(0x4)
comment|/* 1Gb link speed (Full-duplex) */
define|#
directive|define
name|HWRM_PORT_PHY_CFG_INPUT_EEE_LINK_SPEED_MASK_1GB
value|UINT32_C(0x8)
comment|/* Reserved */
define|#
directive|define
name|HWRM_PORT_PHY_CFG_INPUT_EEE_LINK_SPEED_MASK_RSVD3
value|UINT32_C(0x10)
comment|/* Reserved */
define|#
directive|define
name|HWRM_PORT_PHY_CFG_INPUT_EEE_LINK_SPEED_MASK_RSVD4
value|UINT32_C(0x20)
comment|/* 10Gb link speed */
define|#
directive|define
name|HWRM_PORT_PHY_CFG_INPUT_EEE_LINK_SPEED_MASK_10GB
value|UINT32_C(0x40)
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint32_t
name|tx_lpi_timer
decl_stmt|;
name|uint32_t
name|unused_4
decl_stmt|;
comment|/* 	 * Reuested setting of TX LPI timer in microseconds. This field is valid 	 * only when EEE is enabled and TX LPI is enabled. 	 */
define|#
directive|define
name|HWRM_PORT_PHY_CFG_INPUT_TX_LPI_TIMER_MASK
value|UINT32_C(0xffffff)
define|#
directive|define
name|HWRM_PORT_PHY_CFG_INPUT_TX_LPI_TIMER_SFT
value|0
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_port_phy_cfg_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint32_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_port_phy_qcfg */
end_comment

begin_comment
comment|/* Description: This command queries the PHY configuration for the port. */
end_comment

begin_comment
comment|/* Input (24 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_port_phy_qcfg_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint16_t
name|port_id
decl_stmt|;
comment|/* Port ID of port that is to be queried. */
name|uint16_t
name|unused_0
index|[
literal|3
index|]
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (96 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_port_phy_qcfg_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint8_t
name|link
decl_stmt|;
comment|/* This value indicates the current link status. */
comment|/* There is no link or cable detected. */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_LINK_NO_LINK
value|UINT32_C(0x0)
comment|/* There is no link, but a cable has been detected. */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_LINK_SIGNAL
value|UINT32_C(0x1)
comment|/* There is a link. */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_LINK_LINK
value|UINT32_C(0x2)
name|uint8_t
name|unused_0
decl_stmt|;
name|uint16_t
name|link_speed
decl_stmt|;
comment|/* This value indicates the current link speed of the connection. */
comment|/* 100Mb link speed */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_LINK_SPEED_100MB
value|UINT32_C(0x1)
comment|/* 1Gb link speed */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_LINK_SPEED_1GB
value|UINT32_C(0xa)
comment|/* 2Gb link speed */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_LINK_SPEED_2GB
value|UINT32_C(0x14)
comment|/* 2.5Gb link speed */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_LINK_SPEED_2_5GB
value|UINT32_C(0x19)
comment|/* 10Gb link speed */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_LINK_SPEED_10GB
value|UINT32_C(0x64)
comment|/* 20Mb link speed */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_LINK_SPEED_20GB
value|UINT32_C(0xc8)
comment|/* 25Gb link speed */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_LINK_SPEED_25GB
value|UINT32_C(0xfa)
comment|/* 40Gb link speed */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_LINK_SPEED_40GB
value|UINT32_C(0x190)
comment|/* 50Gb link speed */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_LINK_SPEED_50GB
value|UINT32_C(0x1f4)
comment|/* 100Gb link speed */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_LINK_SPEED_100GB
value|UINT32_C(0x3e8)
comment|/* 10Mb link speed */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_LINK_SPEED_10MB
value|UINT32_C(0xffff)
name|uint8_t
name|duplex_cfg
decl_stmt|;
comment|/* This value is indicates the duplex of the current configuration. */
comment|/* Half Duplex connection. */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_DUPLEX_CFG_HALF
value|UINT32_C(0x0)
comment|/* Full duplex connection. */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_DUPLEX_CFG_FULL
value|UINT32_C(0x1)
name|uint8_t
name|pause
decl_stmt|;
comment|/* 	 * This value is used to indicate the current pause configuration. When 	 * autoneg is enabled, this value represents the autoneg results of 	 * pause configuration. 	 */
comment|/* 	 * When this bit is '1', Generation of tx pause messages is supported. 	 * Disabled otherwise. 	 */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_PAUSE_TX
value|UINT32_C(0x1)
comment|/* 	 * When this bit is '1', Reception of rx pause messages is supported. 	 * Disabled otherwise. 	 */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_PAUSE_RX
value|UINT32_C(0x2)
name|uint16_t
name|support_speeds
decl_stmt|;
comment|/* 	 * The supported speeds for the port. This is a bit mask. For each speed 	 * that is supported, the corrresponding bit will be set to '1'. 	 */
comment|/* 100Mb link speed (Half-duplex) */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_SUPPORT_SPEEDS_100MBHD
value|UINT32_C(0x1)
comment|/* 100Mb link speed (Full-duplex) */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_SUPPORT_SPEEDS_100MB
value|UINT32_C(0x2)
comment|/* 1Gb link speed (Half-duplex) */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_SUPPORT_SPEEDS_1GBHD
value|UINT32_C(0x4)
comment|/* 1Gb link speed (Full-duplex) */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_SUPPORT_SPEEDS_1GB
value|UINT32_C(0x8)
comment|/* 2Gb link speed */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_SUPPORT_SPEEDS_2GB
value|UINT32_C(0x10)
comment|/* 2.5Gb link speed */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_SUPPORT_SPEEDS_2_5GB
value|UINT32_C(0x20)
comment|/* 10Gb link speed */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_SUPPORT_SPEEDS_10GB
value|UINT32_C(0x40)
comment|/* 20Gb link speed */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_SUPPORT_SPEEDS_20GB
value|UINT32_C(0x80)
comment|/* 25Gb link speed */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_SUPPORT_SPEEDS_25GB
value|UINT32_C(0x100)
comment|/* 40Gb link speed */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_SUPPORT_SPEEDS_40GB
value|UINT32_C(0x200)
comment|/* 50Gb link speed */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_SUPPORT_SPEEDS_50GB
value|UINT32_C(0x400)
comment|/* 100Gb link speed */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_SUPPORT_SPEEDS_100GB
value|UINT32_C(0x800)
comment|/* 10Mb link speed (Half-duplex) */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_SUPPORT_SPEEDS_10MBHD
value|UINT32_C(0x1000)
comment|/* 10Mb link speed (Full-duplex) */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_SUPPORT_SPEEDS_10MB
value|UINT32_C(0x2000)
name|uint16_t
name|force_link_speed
decl_stmt|;
comment|/* 	 * Current setting of forced link speed. When the link speed is not 	 * being forced, this value shall be set to 0. 	 */
comment|/* 100Mb link speed */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_FORCE_LINK_SPEED_100MB
value|UINT32_C(0x1)
comment|/* 1Gb link speed */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_FORCE_LINK_SPEED_1GB
value|UINT32_C(0xa)
comment|/* 2Gb link speed */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_FORCE_LINK_SPEED_2GB
value|UINT32_C(0x14)
comment|/* 2.5Gb link speed */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_FORCE_LINK_SPEED_2_5GB
value|UINT32_C(0x19)
comment|/* 10Gb link speed */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_FORCE_LINK_SPEED_10GB
value|UINT32_C(0x64)
comment|/* 20Mb link speed */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_FORCE_LINK_SPEED_20GB
value|UINT32_C(0xc8)
comment|/* 25Gb link speed */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_FORCE_LINK_SPEED_25GB
value|UINT32_C(0xfa)
comment|/* 40Gb link speed */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_FORCE_LINK_SPEED_40GB
value|UINT32_C(0x190)
comment|/* 50Gb link speed */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_FORCE_LINK_SPEED_50GB
value|UINT32_C(0x1f4)
comment|/* 100Gb link speed */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_FORCE_LINK_SPEED_100GB
value|UINT32_C(0x3e8)
comment|/* 10Mb link speed */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_FORCE_LINK_SPEED_10MB
value|UINT32_C(0xffff)
name|uint8_t
name|auto_mode
decl_stmt|;
comment|/* Current setting of auto negotiation mode. */
comment|/* Disable autoneg or autoneg disabled. No speeds are selected. */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_MODE_NONE
value|UINT32_C(0x0)
comment|/* Select all possible speeds for autoneg mode. */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_MODE_ALL_SPEEDS
value|UINT32_C(0x1)
comment|/* 	 * Select only the auto_link_speed speed for autoneg mode. This 	 * mode has been DEPRECATED. An HWRM client should not use this 	 * mode. 	 */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_MODE_ONE_SPEED
value|UINT32_C(0x2)
comment|/* 	 * Select the auto_link_speed or any speed below that speed for 	 * autoneg. This mode has been DEPRECATED. An HWRM client should 	 * not use this mode. 	 */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_MODE_ONE_OR_BELOW
value|UINT32_C(0x3)
comment|/* 	 * Select the speeds based on the corresponding link speed mask 	 * value that is provided. 	 */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_MODE_SPEED_MASK
value|UINT32_C(0x4)
name|uint8_t
name|auto_pause
decl_stmt|;
comment|/* 	 * Current setting of pause autonegotiation. Move autoneg_pause flag 	 * here. 	 */
comment|/* 	 * When this bit is '1', Generation of tx pause messages has been 	 * requested. Disabled otherwise. 	 */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_PAUSE_TX
value|UINT32_C(0x1)
comment|/* 	 * When this bit is '1', Reception of rx pause messages has been 	 * requested. Disabled otherwise. 	 */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_PAUSE_RX
value|UINT32_C(0x2)
comment|/* 	 * When set to 1, the advertisement of pause is enabled. # When the 	 * auto_mode is not set to none and this flag is set to 1, then the 	 * auto_pause bits on this port are being advertised and autoneg pause 	 * results are being interpreted. # When the auto_mode is not set to 	 * none and this flag is set to 0, the pause is forced as indicated in 	 * force_pause, and also advertised as auto_pause bits, but the autoneg 	 * results are not interpreted since the pause configuration is being 	 * forced. # When the auto_mode is set to none and this flag is set to 	 * 1, auto_pause bits should be ignored and should be set to 0. 	 */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_PAUSE_AUTONEG_PAUSE
value|UINT32_C(0x4)
name|uint16_t
name|auto_link_speed
decl_stmt|;
comment|/* 	 * Current setting for auto_link_speed. This field is only valid when 	 * auto_mode is set to "one_speed" or "one_or_below". 	 */
comment|/* 100Mb link speed */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEED_100MB
value|UINT32_C(0x1)
comment|/* 1Gb link speed */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEED_1GB
value|UINT32_C(0xa)
comment|/* 2Gb link speed */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEED_2GB
value|UINT32_C(0x14)
comment|/* 2.5Gb link speed */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEED_2_5GB
value|UINT32_C(0x19)
comment|/* 10Gb link speed */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEED_10GB
value|UINT32_C(0x64)
comment|/* 20Mb link speed */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEED_20GB
value|UINT32_C(0xc8)
comment|/* 25Gb link speed */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEED_25GB
value|UINT32_C(0xfa)
comment|/* 40Gb link speed */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEED_40GB
value|UINT32_C(0x190)
comment|/* 50Gb link speed */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEED_50GB
value|UINT32_C(0x1f4)
comment|/* 100Gb link speed */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEED_100GB
value|UINT32_C(0x3e8)
comment|/* 10Mb link speed */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEED_10MB
value|UINT32_C(0xffff)
name|uint16_t
name|auto_link_speed_mask
decl_stmt|;
comment|/* 	 * Current setting for auto_link_speed_mask that is used to advertise 	 * speeds during autonegotiation. This field is only valid when 	 * auto_mode is set to "mask". The speeds specified in this field shall 	 * be a subset of supported speeds on this port. 	 */
comment|/* 100Mb link speed (Half-duplex) */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEED_MASK_100MBHD
value|UINT32_C(0x1)
comment|/* 100Mb link speed (Full-duplex) */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEED_MASK_100MB
value|UINT32_C(0x2)
comment|/* 1Gb link speed (Half-duplex) */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEED_MASK_1GBHD
value|UINT32_C(0x4)
comment|/* 1Gb link speed (Full-duplex) */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEED_MASK_1GB
value|UINT32_C(0x8)
comment|/* 2Gb link speed */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEED_MASK_2GB
value|UINT32_C(0x10)
comment|/* 2.5Gb link speed */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEED_MASK_2_5GB
value|UINT32_C(0x20)
comment|/* 10Gb link speed */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEED_MASK_10GB
value|UINT32_C(0x40)
comment|/* 20Gb link speed */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEED_MASK_20GB
value|UINT32_C(0x80)
comment|/* 25Gb link speed */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEED_MASK_25GB
value|UINT32_C(0x100)
comment|/* 40Gb link speed */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEED_MASK_40GB
value|UINT32_C(0x200)
comment|/* 50Gb link speed */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEED_MASK_50GB
value|UINT32_C(0x400)
comment|/* 100Gb link speed */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEED_MASK_100GB
value|UINT32_C(0x800)
comment|/* 10Mb link speed (Half-duplex) */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEED_MASK_10MBHD
value|UINT32_C(0x1000)
comment|/* 10Mb link speed (Full-duplex) */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEED_MASK_10MB
value|UINT32_C(0x2000)
name|uint8_t
name|wirespeed
decl_stmt|;
comment|/* Current setting for wirespeed. */
comment|/* Wirespeed feature is disabled. */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_WIRESPEED_OFF
value|UINT32_C(0x0)
comment|/* Wirespeed feature is enabled. */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_WIRESPEED_ON
value|UINT32_C(0x1)
name|uint8_t
name|lpbk
decl_stmt|;
comment|/* Current setting for loopback. */
comment|/* No loopback is selected. Normal operation. */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_LPBK_NONE
value|UINT32_C(0x0)
comment|/* 	 * The HW will be configured with local loopback such that host 	 * data is sent back to the host without modification. 	 */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_LPBK_LOCAL
value|UINT32_C(0x1)
comment|/* 	 * The HW will be configured with remote loopback such that port 	 * logic will send packets back out the transmitter that are 	 * received. 	 */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_LPBK_REMOTE
value|UINT32_C(0x2)
name|uint8_t
name|force_pause
decl_stmt|;
comment|/* 	 * Current setting of forced pause. When the pause configuration is not 	 * being forced, then this value shall be set to 0. 	 */
comment|/* 	 * When this bit is '1', Generation of tx pause messages is supported. 	 * Disabled otherwise. 	 */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_FORCE_PAUSE_TX
value|UINT32_C(0x1)
comment|/* 	 * When this bit is '1', Reception of rx pause messages is supported. 	 * Disabled otherwise. 	 */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_FORCE_PAUSE_RX
value|UINT32_C(0x2)
name|uint8_t
name|module_status
decl_stmt|;
comment|/* 	 * This value indicates the current status of the optics module on this 	 * port. 	 */
comment|/* Module is inserted and accepted */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_MODULE_STATUS_NONE
value|UINT32_C(0x0)
comment|/* Module is rejected and transmit side Laser is disabled. */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_MODULE_STATUS_DISABLETX
value|UINT32_C(0x1)
comment|/* Module mismatch warning. */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_MODULE_STATUS_WARNINGMSG
value|UINT32_C(0x2)
comment|/* Module is rejected and powered down. */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_MODULE_STATUS_PWRDOWN
value|UINT32_C(0x3)
comment|/* Module is not inserted. */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_MODULE_STATUS_NOTINSERTED
value|UINT32_C(0x4)
comment|/* Module status is not applicable. */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_MODULE_STATUS_NOTAPPLICABLE
value|UINT32_C(0xff)
name|uint32_t
name|preemphasis
decl_stmt|;
comment|/* Current setting for preemphasis. */
name|uint8_t
name|phy_maj
decl_stmt|;
comment|/* This field represents the major version of the PHY. */
name|uint8_t
name|phy_min
decl_stmt|;
comment|/* This field represents the minor version of the PHY. */
name|uint8_t
name|phy_bld
decl_stmt|;
comment|/* This field represents the build version of the PHY. */
name|uint8_t
name|phy_type
decl_stmt|;
comment|/* This value represents a PHY type. */
comment|/* Unknown */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_UNKNOWN
value|UINT32_C(0x0)
comment|/* BASE-CR */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_BASECR
value|UINT32_C(0x1)
comment|/* BASE-KR4 (Deprecated) */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_BASEKR4
value|UINT32_C(0x2)
comment|/* BASE-LR */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_BASELR
value|UINT32_C(0x3)
comment|/* BASE-SR */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_BASESR
value|UINT32_C(0x4)
comment|/* BASE-KR2 (Deprecated) */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_BASEKR2
value|UINT32_C(0x5)
comment|/* BASE-KX */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_BASEKX
value|UINT32_C(0x6)
comment|/* BASE-KR */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_BASEKR
value|UINT32_C(0x7)
comment|/* BASE-T */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_BASET
value|UINT32_C(0x8)
comment|/* EEE capable BASE-T */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_BASETE
value|UINT32_C(0x9)
comment|/* SGMII connected external PHY */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_SGMIIEXTPHY
value|UINT32_C(0xa)
comment|/* 25G_BASECR_CA_L */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_25G_BASECR_CA_L
value|UINT32_C(0xb)
comment|/* 25G_BASECR_CA_S */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_25G_BASECR_CA_S
value|UINT32_C(0xc)
comment|/* 25G_BASECR_CA_N */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_25G_BASECR_CA_N
value|UINT32_C(0xd)
comment|/* 25G_BASESR */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_25G_BASESR
value|UINT32_C(0xe)
comment|/* 100G_BASECR4 */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_100G_BASECR4
value|UINT32_C(0xf)
comment|/* 100G_BASESR4 */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_100G_BASESR4
value|UINT32_C(0x10)
comment|/* 100G_BASELR4 */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_100G_BASELR4
value|UINT32_C(0x11)
comment|/* 100G_BASEER4 */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_100G_BASEER4
value|UINT32_C(0x12)
comment|/* 100G_BASESR10 */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_100G_BASESR10
value|UINT32_C(0x13)
comment|/* 40G_BASECR4 */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_40G_BASECR4
value|UINT32_C(0x14)
comment|/* 40G_BASESR4 */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_40G_BASESR4
value|UINT32_C(0x15)
comment|/* 40G_BASELR4 */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_40G_BASELR4
value|UINT32_C(0x16)
comment|/* 40G_BASEER4 */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_40G_BASEER4
value|UINT32_C(0x17)
comment|/* 40G_ACTIVE_CABLE */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_40G_ACTIVE_CABLE
value|UINT32_C(0x18)
comment|/* 1G_baseT */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_1G_BASET
value|UINT32_C(0x19)
comment|/* 1G_baseSX */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_1G_BASESX
value|UINT32_C(0x1a)
comment|/* 1G_baseCX */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_1G_BASECX
value|UINT32_C(0x1b)
name|uint8_t
name|media_type
decl_stmt|;
comment|/* This value represents a media type. */
comment|/* Unknown */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_MEDIA_TYPE_UNKNOWN
value|UINT32_C(0x0)
comment|/* Twisted Pair */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_MEDIA_TYPE_TP
value|UINT32_C(0x1)
comment|/* Direct Attached Copper */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_MEDIA_TYPE_DAC
value|UINT32_C(0x2)
comment|/* Fiber */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_MEDIA_TYPE_FIBRE
value|UINT32_C(0x3)
name|uint8_t
name|xcvr_pkg_type
decl_stmt|;
comment|/* This value represents a transceiver type. */
comment|/* PHY and MAC are in the same package */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_XCVR_PKG_TYPE_XCVR_INTERNAL
value|UINT32_C(0x1)
comment|/* PHY and MAC are in different packages */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_XCVR_PKG_TYPE_XCVR_EXTERNAL
value|UINT32_C(0x2)
name|uint8_t
name|eee_config_phy_addr
decl_stmt|;
comment|/* 	 * This field represents flags related to EEE configuration. These EEE 	 * configuration flags are valid only when the auto_mode is not set to 	 * none (in other words autonegotiation is enabled). 	 */
comment|/* This field represents PHY address. */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_PHY_ADDR_MASK
value|UINT32_C(0x1f)
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_PHY_ADDR_SFT
value|0
comment|/* 	 * When set to 1, Energy Efficient Ethernet (EEE) mode is enabled. 	 * Speeds for autoneg with EEE mode enabled are based on 	 * eee_link_speed_mask. 	 */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_EEE_CONFIG_EEE_ENABLED
value|UINT32_C(0x20)
comment|/* 	 * This flag is valid only when eee_enabled is set to 1. # If 	 * eee_enabled is set to 0, then EEE mode is disabled and this flag 	 * shall be ignored. # If eee_enabled is set to 1 and this flag is set 	 * to 1, then Energy Efficient Ethernet (EEE) mode is enabled and in 	 * use. # If eee_enabled is set to 1 and this flag is set to 0, then 	 * Energy Efficient Ethernet (EEE) mode is enabled but is currently not 	 * in use. 	 */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_EEE_CONFIG_EEE_ACTIVE
value|UINT32_C(0x40)
comment|/* 	 * This flag is valid only when eee_enabled is set to 1. # If 	 * eee_enabled is set to 0, then EEE mode is disabled and this flag 	 * shall be ignored. # If eee_enabled is set to 1 and this flag is set 	 * to 1, then Energy Efficient Ethernet (EEE) mode is enabled and TX LPI 	 * is enabled. # If eee_enabled is set to 1 and this flag is set to 0, 	 * then Energy Efficient Ethernet (EEE) mode is enabled but TX LPI is 	 * disabled. 	 */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_EEE_CONFIG_EEE_TX_LPI
value|UINT32_C(0x80)
comment|/* 	 * This field represents flags related to EEE configuration. These EEE 	 * configuration flags are valid only when the auto_mode is not set to 	 * none (in other words autonegotiation is enabled). 	 */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_EEE_CONFIG_MASK
value|UINT32_C(0xe0)
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_EEE_CONFIG_SFT
value|5
name|uint8_t
name|parallel_detect
decl_stmt|;
comment|/* Reserved field, set to 0 */
comment|/* 	 * When set to 1, the parallel detection is used to determine the speed 	 * of the link partner. Parallel detection is used when a 	 * autonegotiation capable device is connected to a link parter that is 	 * not capable of autonegotiation. 	 */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_PARALLEL_DETECT
value|UINT32_C(0x1)
comment|/* Reserved field, set to 0 */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_RESERVED_MASK
value|UINT32_C(0xfe)
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_RESERVED_SFT
value|1
name|uint16_t
name|link_partner_adv_speeds
decl_stmt|;
comment|/* 	 * The advertised speeds for the port by the link partner. Each 	 * advertised speed will be set to '1'. 	 */
comment|/* 100Mb link speed (Half-duplex) */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_SPEEDS_100MBHD
value|UINT32_C(0x1)
comment|/* 100Mb link speed (Full-duplex) */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_SPEEDS_100MB
value|UINT32_C(0x2)
comment|/* 1Gb link speed (Half-duplex) */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_SPEEDS_1GBHD
value|UINT32_C(0x4)
comment|/* 1Gb link speed (Full-duplex) */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_SPEEDS_1GB
value|UINT32_C(0x8)
comment|/* 2Gb link speed */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_SPEEDS_2GB
value|UINT32_C(0x10)
comment|/* 2.5Gb link speed */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_SPEEDS_2_5GB
value|UINT32_C(0x20)
comment|/* 10Gb link speed */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_SPEEDS_10GB
value|UINT32_C(0x40)
comment|/* 20Gb link speed */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_SPEEDS_20GB
value|UINT32_C(0x80)
comment|/* 25Gb link speed */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_SPEEDS_25GB
value|UINT32_C(0x100)
comment|/* 40Gb link speed */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_SPEEDS_40GB
value|UINT32_C(0x200)
comment|/* 50Gb link speed */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_SPEEDS_50GB
value|UINT32_C(0x400)
comment|/* 100Gb link speed */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_SPEEDS_100GB
value|UINT32_C(0x800)
comment|/* 10Mb link speed (Half-duplex) */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_SPEEDS_10MBHD
value|UINT32_C(0x1000)
comment|/* 10Mb link speed (Full-duplex) */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_SPEEDS_10MB
value|UINT32_C(0x2000)
name|uint8_t
name|link_partner_adv_auto_mode
decl_stmt|;
comment|/* 	 * The advertised autoneg for the port by the link partner. This field 	 * is deprecated and should be set to 0. 	 */
comment|/* Disable autoneg or autoneg disabled. No speeds are selected. */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_AUTO_MODE_NONE
value|UINT32_C(0x0)
comment|/* Select all possible speeds for autoneg mode. */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_AUTO_MODE_ALL_SPEEDS
value|UINT32_C(0x1)
comment|/* 	 * Select only the auto_link_speed speed for autoneg mode. This 	 * mode has been DEPRECATED. An HWRM client should not use this 	 * mode. 	 */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_AUTO_MODE_ONE_SPEED
value|UINT32_C(0x2)
comment|/* 	 * Select the auto_link_speed or any speed below that speed for 	 * autoneg. This mode has been DEPRECATED. An HWRM client should 	 * not use this mode. 	 */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_AUTO_MODE_ONE_OR_BELOW
value|UINT32_C(0x3)
comment|/* 	 * Select the speeds based on the corresponding link speed mask 	 * value that is provided. 	 */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_AUTO_MODE_SPEED_MASK
value|UINT32_C(0x4)
name|uint8_t
name|link_partner_adv_pause
decl_stmt|;
comment|/* The advertised pause settings on the port by the link partner. */
comment|/* 	 * When this bit is '1', Generation of tx pause messages is supported. 	 * Disabled otherwise. 	 */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_PAUSE_TX
value|UINT32_C(0x1)
comment|/* 	 * When this bit is '1', Reception of rx pause messages is supported. 	 * Disabled otherwise. 	 */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_PAUSE_RX
value|UINT32_C(0x2)
name|uint16_t
name|adv_eee_link_speed_mask
decl_stmt|;
comment|/* 	 * Current setting for link speed mask that is used to advertise speeds 	 * during autonegotiation when EEE is enabled. This field is valid only 	 * when eee_enabled flags is set to 1. The speeds specified in this 	 * field shall be a subset of speeds specified in auto_link_speed_mask. 	 */
comment|/* Reserved */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_ADV_EEE_LINK_SPEED_MASK_RSVD1
value|UINT32_C(0x1)
comment|/* 100Mb link speed (Full-duplex) */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_ADV_EEE_LINK_SPEED_MASK_100MB
value|UINT32_C(0x2)
comment|/* Reserved */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_ADV_EEE_LINK_SPEED_MASK_RSVD2
value|UINT32_C(0x4)
comment|/* 1Gb link speed (Full-duplex) */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_ADV_EEE_LINK_SPEED_MASK_1GB
value|UINT32_C(0x8)
comment|/* Reserved */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_ADV_EEE_LINK_SPEED_MASK_RSVD3
value|UINT32_C(0x10)
comment|/* Reserved */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_ADV_EEE_LINK_SPEED_MASK_RSVD4
value|UINT32_C(0x20)
comment|/* 10Gb link speed */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_ADV_EEE_LINK_SPEED_MASK_10GB
value|UINT32_C(0x40)
name|uint16_t
name|link_partner_adv_eee_link_speed_mask
decl_stmt|;
comment|/* 	 * Current setting for link speed mask that is advertised by the link 	 * partner when EEE is enabled. This field is valid only when 	 * eee_enabled flags is set to 1. 	 */
comment|/* Reserved */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_EEE_LINK_SPEED_MASK_RSVD1
value|UINT32_C(0x1)
comment|/* 100Mb link speed (Full-duplex) */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_EEE_LINK_SPEED_MASK_100MB
value|UINT32_C(0x2)
comment|/* Reserved */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_EEE_LINK_SPEED_MASK_RSVD2
value|UINT32_C(0x4)
comment|/* 1Gb link speed (Full-duplex) */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_EEE_LINK_SPEED_MASK_1GB
value|UINT32_C(0x8)
comment|/* Reserved */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_EEE_LINK_SPEED_MASK_RSVD3
value|UINT32_C(0x10)
comment|/* Reserved */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_EEE_LINK_SPEED_MASK_RSVD4
value|UINT32_C(0x20)
comment|/* 10Gb link speed */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_EEE_LINK_SPEED_MASK_10GB
value|UINT32_C(0x40)
name|uint32_t
name|xcvr_identifier_type_tx_lpi_timer
decl_stmt|;
comment|/* This value represents transceiver identifier type. */
comment|/* 	 * Current setting of TX LPI timer in microseconds. This field is valid 	 * only when_eee_enabled flag is set to 1 and tx_lpi_enabled is set to 	 * 1. 	 */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_TX_LPI_TIMER_MASK
value|UINT32_C(0xffffff)
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_TX_LPI_TIMER_SFT
value|0
comment|/* This value represents transceiver identifier type. */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_XCVR_IDENTIFIER_TYPE_MASK
value|UINT32_C(0xff000000)
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_XCVR_IDENTIFIER_TYPE_SFT
value|24
comment|/* Unknown */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_XCVR_IDENTIFIER_TYPE_UNKNOWN
value|(UINT32_C(0x0)<< 24)
comment|/* SFP/SFP+/SFP28 */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_XCVR_IDENTIFIER_TYPE_SFP
value|(UINT32_C(0x3)<< 24)
comment|/* QSFP */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_XCVR_IDENTIFIER_TYPE_QSFP
value|(UINT32_C(0xc)<< 24)
comment|/* QSFP+ */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_XCVR_IDENTIFIER_TYPE_QSFPPLUS
value|(UINT32_C(0xd)<< 24)
comment|/* QSFP28 */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_XCVR_IDENTIFIER_TYPE_QSFP28
value|(UINT32_C(0x11)<< 24)
name|uint16_t
name|fec_cfg
decl_stmt|;
comment|/* 	 * This value represents the current configuration of Forward Error 	 * Correction (FEC) on the port. 	 */
comment|/* 	 * When set to 1, then FEC is not supported on this port. If this flag 	 * is set to 1, then all other FEC configuration flags shall be ignored. 	 * When set to 0, then FEC is supported as indicated by other 	 * configuration flags. If no cable is attached and the HWRM does not 	 * yet know the FEC capability, then the HWRM shall set this flag to 1 	 * when reporting FEC capability. 	 */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_FEC_CFG_FEC_NONE_SUPPORTED
value|UINT32_C(0x1)
comment|/* 	 * When set to 1, then FEC autonegotiation is supported on this port. 	 * When set to 0, then FEC autonegotiation is not supported on this 	 * port. 	 */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_FEC_CFG_FEC_AUTONEG_SUPPORTED
value|UINT32_C(0x2)
comment|/* 	 * When set to 1, then FEC autonegotiation is enabled on this port. When 	 * set to 0, then FEC autonegotiation is disabled if supported. This 	 * flag should be ignored if FEC autonegotiation is not supported on 	 * this port. 	 */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_FEC_CFG_FEC_AUTONEG_ENABLED
value|UINT32_C(0x4)
comment|/* 	 * When set to 1, then FEC CLAUSE 74 (Fire Code) is supported on this 	 * port. When set to 0, then FEC CLAUSE 74 (Fire Code) is not supported 	 * on this port. 	 */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_FEC_CFG_FEC_CLAUSE74_SUPPORTED
value|UINT32_C(0x8)
comment|/* 	 * When set to 1, then FEC CLAUSE 74 (Fire Code) is enabled on this 	 * port. When set to 0, then FEC CLAUSE 74 (Fire Code) is disabled if 	 * supported. This flag should be ignored if FEC CLAUSE 74 is not 	 * supported on this port. 	 */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_FEC_CFG_FEC_CLAUSE74_ENABLED
value|UINT32_C(0x10)
comment|/* 	 * When set to 1, then FEC CLAUSE 91 (Reed Solomon) is supported on this 	 * port. When set to 0, then FEC CLAUSE 91 (Reed Solomon) is not 	 * supported on this port. 	 */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_FEC_CFG_FEC_CLAUSE91_SUPPORTED
value|UINT32_C(0x20)
comment|/* 	 * When set to 1, then FEC CLAUSE 91 (Reed Solomon) is enabled on this 	 * port. When set to 0, then FEC CLAUSE 91 (Reed Solomon) is disabled if 	 * supported. This flag should be ignored if FEC CLAUSE 91 is not 	 * supported on this port. 	 */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_FEC_CFG_FEC_CLAUSE91_ENABLED
value|UINT32_C(0x40)
name|uint8_t
name|duplex_state
decl_stmt|;
comment|/* This value is indicates the duplex of the current connection state. */
comment|/* Half Duplex connection. */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_DUPLEX_STATE_HALF
value|UINT32_C(0x0)
comment|/* Full duplex connection. */
define|#
directive|define
name|HWRM_PORT_PHY_QCFG_OUTPUT_DUPLEX_STATE_FULL
value|UINT32_C(0x1)
name|uint8_t
name|unused_1
decl_stmt|;
name|char
name|phy_vendor_name
index|[
literal|16
index|]
decl_stmt|;
comment|/* 	 * Up to 16 bytes of null padded ASCII string representing PHY vendor. 	 * If the string is set to null, then the vendor name is not available. 	 */
name|char
name|phy_vendor_partnumber
index|[
literal|16
index|]
decl_stmt|;
comment|/* 	 * Up to 16 bytes of null padded ASCII string that identifies vendor 	 * specific part number of the PHY. If the string is set to null, then 	 * the vendor specific part number is not available. 	 */
name|uint32_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint8_t
name|unused_4
decl_stmt|;
name|uint8_t
name|unused_5
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_port_mac_cfg */
end_comment

begin_comment
comment|/*  * Description: This command configures the MAC block for the port. # Only PF  * drivers shall be allowed to configure MAC. # A VF driver should not be  * allowed to configure MAC using this command. # In a network partition mode, a  * PF driver should not be allowed to configure MAC using this command. The QoS  * settings in port_mac_cfg() are global for all ports/functions. If multiple PF  * drivers on different ports are configuring QoS settings, then the HWRM is not  * responsible for maintaining consistency between them. A PF driver changing  * global QoS settings using this command may impact other PF drivers on  * different ports.  */
end_comment

begin_comment
comment|/* Input (40 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_port_mac_cfg_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint32_t
name|flags
decl_stmt|;
comment|/* 	 * In this field, there are a number of CoS mappings related flags that 	 * are used to configure CoS mappings and their corresponding priorities 	 * in the hardware. For the priorities of CoS mappings, the HWRM uses 	 * the following priority order (high to low) by default: # vlan pri # 	 * ip_dscp # tunnel_vlan_pri # default cos A subset of CoS mappings can 	 * be enabled. If a priority is not specified for an enabled CoS 	 * mapping, the priority will be assigned in the above order for the 	 * enabled CoS mappings. For example, if vlan_pri and ip_dscp CoS 	 * mappings are enabled and their priorities are not specified, the 	 * following priority order (high to low) will be used by the HWRM: # 	 * vlan_pri # ip_dscp # default cos vlan_pri CoS mapping together with 	 * default CoS with lower priority are enabled by default by the HWRM. 	 */
comment|/* 	 * When this bit is '1', this command will configure the MAC to match 	 * the current link state of the PHY. If the link is not established on 	 * the PHY, then this bit has no effect. 	 */
define|#
directive|define
name|HWRM_PORT_MAC_CFG_INPUT_FLAGS_MATCH_LINK
value|UINT32_C(0x1)
comment|/* 	 * When this bit is set to '1', the inner VLAN PRI to CoS mapping is 	 * requested to be enabled. 	 */
define|#
directive|define
name|HWRM_PORT_MAC_CFG_INPUT_FLAGS_VLAN_PRI2COS_ENABLE
value|UINT32_C(0x2)
comment|/* 	 * When this bit is set to '1', tunnel VLAN PRI field to CoS mapping is 	 * requested to be enabled. 	 */
define|#
directive|define
name|HWRM_PORT_MAC_CFG_INPUT_FLAGS_TUNNEL_PRI2COS_ENABLE
value|UINT32_C(0x4)
comment|/* 	 * When this bit is set to '1', the IP DSCP to CoS mapping is requested 	 * to be enabled. 	 */
define|#
directive|define
name|HWRM_PORT_MAC_CFG_INPUT_FLAGS_IP_DSCP2COS_ENABLE
value|UINT32_C(0x8)
comment|/* 	 * When this bit is '1', the HWRM is requested to enable timestamp 	 * capture capability on the receive side of this port. 	 */
define|#
directive|define
name|HWRM_PORT_MAC_CFG_INPUT_FLAGS_PTP_RX_TS_CAPTURE_ENABLE
value|UINT32_C(0x10)
comment|/* 	 * When this bit is '1', the HWRM is requested to disable timestamp 	 * capture capability on the receive side of this port. 	 */
define|#
directive|define
name|HWRM_PORT_MAC_CFG_INPUT_FLAGS_PTP_RX_TS_CAPTURE_DISABLE
value|UINT32_C(0x20)
comment|/* 	 * When this bit is '1', the HWRM is requested to enable timestamp 	 * capture capability on the transmit side of this port. 	 */
define|#
directive|define
name|HWRM_PORT_MAC_CFG_INPUT_FLAGS_PTP_TX_TS_CAPTURE_ENABLE
value|UINT32_C(0x40)
comment|/* 	 * When this bit is '1', the HWRM is requested to disable timestamp 	 * capture capability on the transmit side of this port. 	 */
define|#
directive|define
name|HWRM_PORT_MAC_CFG_INPUT_FLAGS_PTP_TX_TS_CAPTURE_DISABLE
value|UINT32_C(0x80)
comment|/* 	 * When this bit is '1', the Out-Of-Box WoL is requested to be enabled 	 * on this port. 	 */
define|#
directive|define
name|HWRM_PORT_MAC_CFG_INPUT_FLAGS_OOB_WOL_ENABLE
value|UINT32_C(0x100)
comment|/* 	 * When this bit is '1', the the Out-Of-Box WoL is requested to be 	 * disabled on this port. 	 */
define|#
directive|define
name|HWRM_PORT_MAC_CFG_INPUT_FLAGS_OOB_WOL_DISABLE
value|UINT32_C(0x200)
comment|/* 	 * When this bit is set to '1', the inner VLAN PRI to CoS mapping is 	 * requested to be disabled. 	 */
define|#
directive|define
name|HWRM_PORT_MAC_CFG_INPUT_FLAGS_VLAN_PRI2COS_DISABLE
value|UINT32_C(0x400)
comment|/* 	 * When this bit is set to '1', tunnel VLAN PRI field to CoS mapping is 	 * requested to be disabled. 	 */
define|#
directive|define
name|HWRM_PORT_MAC_CFG_INPUT_FLAGS_TUNNEL_PRI2COS_DISABLE
value|UINT32_C(0x800)
comment|/* 	 * When this bit is set to '1', the IP DSCP to CoS mapping is requested 	 * to be disabled. 	 */
define|#
directive|define
name|HWRM_PORT_MAC_CFG_INPUT_FLAGS_IP_DSCP2COS_DISABLE
value|UINT32_C(0x1000)
name|uint32_t
name|enables
decl_stmt|;
comment|/* This bit must be '1' for the ipg field to be configured. */
define|#
directive|define
name|HWRM_PORT_MAC_CFG_INPUT_ENABLES_IPG
value|UINT32_C(0x1)
comment|/* This bit must be '1' for the lpbk field to be configured. */
define|#
directive|define
name|HWRM_PORT_MAC_CFG_INPUT_ENABLES_LPBK
value|UINT32_C(0x2)
comment|/* 	 * This bit must be '1' for the vlan_pri2cos_map_pri field to be 	 * configured. 	 */
define|#
directive|define
name|HWRM_PORT_MAC_CFG_INPUT_ENABLES_VLAN_PRI2COS_MAP_PRI
value|UINT32_C(0x4)
comment|/* This bit must be '1' for the Reserved1 field to be configured. */
define|#
directive|define
name|HWRM_PORT_MAC_CFG_INPUT_ENABLES_RESERVED1
value|UINT32_C(0x8)
comment|/* 	 * This bit must be '1' for the tunnel_pri2cos_map_pri field to be 	 * configured. 	 */
define|#
directive|define
name|HWRM_PORT_MAC_CFG_INPUT_ENABLES_TUNNEL_PRI2COS_MAP_PRI
value|UINT32_C(0x10)
comment|/* This bit must be '1' for the dscp2cos_map_pri field to be configured. */
define|#
directive|define
name|HWRM_PORT_MAC_CFG_INPUT_ENABLES_DSCP2COS_MAP_PRI
value|UINT32_C(0x20)
comment|/* 	 * This bit must be '1' for the rx_ts_capture_ptp_msg_type field to be 	 * configured. 	 */
define|#
directive|define
name|HWRM_PORT_MAC_CFG_INPUT_ENABLES_RX_TS_CAPTURE_PTP_MSG_TYPE
value|UINT32_C(0x40)
comment|/* 	 * This bit must be '1' for the tx_ts_capture_ptp_msg_type field to be 	 * configured. 	 */
define|#
directive|define
name|HWRM_PORT_MAC_CFG_INPUT_ENABLES_TX_TS_CAPTURE_PTP_MSG_TYPE
value|UINT32_C(0x80)
comment|/* This bit must be '1' for the cos_field_cfg field to be configured. */
define|#
directive|define
name|HWRM_PORT_MAC_CFG_INPUT_ENABLES_COS_FIELD_CFG
value|UINT32_C(0x100)
name|uint16_t
name|port_id
decl_stmt|;
comment|/* Port ID of port that is to be configured. */
name|uint8_t
name|ipg
decl_stmt|;
comment|/* 	 * This value is used to configure the minimum IPG that will be sent 	 * between packets by this port. 	 */
name|uint8_t
name|lpbk
decl_stmt|;
comment|/* This value controls the loopback setting for the MAC. */
comment|/* No loopback is selected. Normal operation. */
define|#
directive|define
name|HWRM_PORT_MAC_CFG_INPUT_LPBK_NONE
value|UINT32_C(0x0)
comment|/* 	 * The HW will be configured with local loopback such that host 	 * data is sent back to the host without modification. 	 */
define|#
directive|define
name|HWRM_PORT_MAC_CFG_INPUT_LPBK_LOCAL
value|UINT32_C(0x1)
comment|/* 	 * The HW will be configured with remote loopback such that port 	 * logic will send packets back out the transmitter that are 	 * received. 	 */
define|#
directive|define
name|HWRM_PORT_MAC_CFG_INPUT_LPBK_REMOTE
value|UINT32_C(0x2)
name|uint8_t
name|vlan_pri2cos_map_pri
decl_stmt|;
comment|/* 	 * This value controls the priority setting of VLAN PRI to CoS mapping 	 * based on VLAN Tags of inner packet headers of tunneled packets or 	 * packet headers of non-tunneled packets. # Each XXX_pri variable shall 	 * have a unique priority value when it is being specified. # When 	 * comparing priorities of mappings, higher value indicates higher 	 * priority. For example, a value of 0-3 is returned where 0 is being 	 * the lowest priority and 3 is being the highest priority. 	 */
name|uint8_t
name|reserved1
decl_stmt|;
comment|/* Reserved field */
name|uint8_t
name|tunnel_pri2cos_map_pri
decl_stmt|;
comment|/* 	 * This value controls the priority setting of VLAN PRI to CoS mapping 	 * based on VLAN Tags of tunneled header. This mapping only applies when 	 * tunneled headers are present. # Each XXX_pri variable shall have a 	 * unique priority value when it is being specified. # When comparing 	 * priorities of mappings, higher value indicates higher priority. For 	 * example, a value of 0-3 is returned where 0 is being the lowest 	 * priority and 3 is being the highest priority. 	 */
name|uint8_t
name|dscp2pri_map_pri
decl_stmt|;
comment|/* 	 * This value controls the priority setting of IP DSCP to CoS mapping 	 * based on inner IP header of tunneled packets or IP header of non- 	 * tunneled packets. # Each XXX_pri variable shall have a unique 	 * priority value when it is being specified. # When comparing 	 * priorities of mappings, higher value indicates higher priority. For 	 * example, a value of 0-3 is returned where 0 is being the lowest 	 * priority and 3 is being the highest priority. 	 */
name|uint16_t
name|rx_ts_capture_ptp_msg_type
decl_stmt|;
comment|/* 	 * This is a 16-bit bit mask that is used to request a specific 	 * configuration of time stamp capture of PTP messages on the receive 	 * side of this port. This field shall be ignored if the 	 * ptp_rx_ts_capture_enable flag is not set in this command. Otherwise, 	 * if bit 'i' is set, then the HWRM is being requested to configure the 	 * receive side of the port to capture the time stamp of every received 	 * PTP message with messageType field value set to i. 	 */
name|uint16_t
name|tx_ts_capture_ptp_msg_type
decl_stmt|;
comment|/* 	 * This is a 16-bit bit mask that is used to request a specific 	 * configuration of time stamp capture of PTP messages on the transmit 	 * side of this port. This field shall be ignored if the 	 * ptp_tx_ts_capture_enable flag is not set in this command. Otherwise, 	 * if bit 'i' is set, then the HWRM is being requested to configure the 	 * transmit sied of the port to capture the time stamp of every 	 * transmitted PTP message with messageType field value set to i. 	 */
name|uint8_t
name|cos_field_cfg
decl_stmt|;
comment|/* Configuration of CoS fields. */
comment|/* Reserved. */
define|#
directive|define
name|HWRM_PORT_MAC_CFG_INPUT_COS_FIELD_CFG_RSVD1
value|UINT32_C(0x1)
comment|/* 	 * This field is used to specify selection of VLAN PRI value based on 	 * whether one or two VLAN Tags are present in the inner packet headers 	 * of tunneled packets or non-tunneled packets. This field is valid only 	 * if inner VLAN PRI to CoS mapping is enabled. If VLAN PRI to CoS 	 * mapping is not enabled, then this field shall be ignored. 	 */
define|#
directive|define
name|HWRM_PORT_MAC_CFG_INPUT_COS_FIELD_CFG_VLAN_PRI_SEL_MASK
value|UINT32_C(0x6)
define|#
directive|define
name|HWRM_PORT_MAC_CFG_INPUT_COS_FIELD_CFG_VLAN_PRI_SEL_SFT
value|1
comment|/* 	 * Select inner VLAN PRI when 1 or 2 VLAN Tags are present in 	 * the inner packet headers 	 */
define|#
directive|define
name|HWRM_PORT_MAC_CFG_INPUT_COS_FIELD_CFG_VLAN_PRI_SEL_INNERMOST
value|(UINT32_C(0x0)<< 1)
comment|/* 	 * Select outer VLAN Tag PRI when 2 VLAN Tags are present in the 	 * inner packet headers. No VLAN PRI shall be selected for this 	 * configuration if only one VLAN Tag is present in the inner 	 * packet headers. 	 */
define|#
directive|define
name|HWRM_PORT_MAC_CFG_INPUT_COS_FIELD_CFG_VLAN_PRI_SEL_OUTER
value|(UINT32_C(0x1)<< 1)
comment|/* 	 * Select outermost VLAN PRI when 1 or 2 VLAN Tags are present 	 * in the inner packet headers 	 */
define|#
directive|define
name|HWRM_PORT_MAC_CFG_INPUT_COS_FIELD_CFG_VLAN_PRI_SEL_OUTERMOST
value|(UINT32_C(0x2)<< 1)
comment|/* Unspecified */
define|#
directive|define
name|HWRM_PORT_MAC_CFG_INPUT_COS_FIELD_CFG_VLAN_PRI_SEL_UNSPECIFIED
value|(UINT32_C(0x3)<< 1)
define|#
directive|define
name|HWRM_PORT_MAC_CFG_INPUT_COS_FIELD_CFG_VLAN_PRI_SEL_LAST
value|HWRM_PORT_MAC_CFG_INPUT_COS_FIELD_CFG_VLAN_PRI_SEL_UNSPECIFIED
comment|/* 	 * This field is used to specify selection of tunnel VLAN PRI value 	 * based on whether one or two VLAN Tags are present in tunnel headers. 	 * This field is valid only if tunnel VLAN PRI to CoS mapping is 	 * enabled. If tunnel VLAN PRI to CoS mapping is not enabled, then this 	 * field shall be ignored. 	 */
define|#
directive|define
name|HWRM_PORT_MAC_CFG_INPUT_COS_FIELD_CFG_T_VLAN_PRI_SEL_MASK
value|UINT32_C(0x18)
define|#
directive|define
name|HWRM_PORT_MAC_CFG_INPUT_COS_FIELD_CFG_T_VLAN_PRI_SEL_SFT
value|3
comment|/* 	 * Select inner VLAN PRI when 1 or 2 VLAN Tags are present in 	 * the tunnel packet headers 	 */
define|#
directive|define
name|HWRM_PORT_MAC_CFG_INPUT_COS_FIELD_CFG_T_VLAN_PRI_SEL_INNERMOST
value|(UINT32_C(0x0)<< 3)
comment|/* 	 * Select outer VLAN Tag PRI when 2 VLAN Tags are present in the 	 * tunnel packet headers. No tunnel VLAN PRI shall be selected 	 * for this configuration if only one VLAN Tag is present in the 	 * tunnel packet headers. 	 */
define|#
directive|define
name|HWRM_PORT_MAC_CFG_INPUT_COS_FIELD_CFG_T_VLAN_PRI_SEL_OUTER
value|(UINT32_C(0x1)<< 3)
comment|/* 	 * Select outermost VLAN PRI when 1 or 2 VLAN Tags are present 	 * in the tunnel packet headers 	 */
define|#
directive|define
name|HWRM_PORT_MAC_CFG_INPUT_COS_FIELD_CFG_T_VLAN_PRI_SEL_OUTERMOST
value|(UINT32_C(0x2)<< 3)
comment|/* Unspecified */
define|#
directive|define
name|HWRM_PORT_MAC_CFG_INPUT_COS_FIELD_CFG_T_VLAN_PRI_SEL_UNSPECIFIED
value|(UINT32_C(0x3)<< 3)
define|#
directive|define
name|HWRM_PORT_MAC_CFG_INPUT_COS_FIELD_CFG_T_VLAN_PRI_SEL_LAST
value|HWRM_PORT_MAC_CFG_INPUT_COS_FIELD_CFG_T_VLAN_PRI_SEL_UNSPECIFIED
comment|/* 	 * This field shall be used to provide default CoS value that has been 	 * configured on this port. This field is valid only if default CoS 	 * mapping is enabled. If default CoS mapping is not enabled, then this 	 * field shall be ignored. 	 */
define|#
directive|define
name|HWRM_PORT_MAC_CFG_INPUT_COS_FIELD_CFG_DEFAULT_COS_MASK
value|UINT32_C(0xe0)
define|#
directive|define
name|HWRM_PORT_MAC_CFG_INPUT_COS_FIELD_CFG_DEFAULT_COS_SFT
value|5
name|uint8_t
name|unused_0
index|[
literal|3
index|]
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_port_mac_cfg_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint16_t
name|mru
decl_stmt|;
comment|/* 	 * This is the configured maximum length of Ethernet packet payload that 	 * is allowed to be received on the port. This value does not include 	 * the number of bytes used by Ethernet header and trailer (CRC). 	 */
name|uint16_t
name|mtu
decl_stmt|;
comment|/* 	 * This is the configured maximum length of Ethernet packet payload that 	 * is allowed to be transmitted on the port. This value does not include 	 * the number of bytes used by Ethernet header and trailer (CRC). 	 */
name|uint8_t
name|ipg
decl_stmt|;
comment|/* Current configuration of the IPG value. */
name|uint8_t
name|lpbk
decl_stmt|;
comment|/* Current value of the loopback value. */
comment|/* No loopback is selected. Normal operation. */
define|#
directive|define
name|HWRM_PORT_MAC_CFG_OUTPUT_LPBK_NONE
value|UINT32_C(0x0)
comment|/* 	 * The HW will be configured with local loopback such that host 	 * data is sent back to the host without modification. 	 */
define|#
directive|define
name|HWRM_PORT_MAC_CFG_OUTPUT_LPBK_LOCAL
value|UINT32_C(0x1)
comment|/* 	 * The HW will be configured with remote loopback such that port 	 * logic will send packets back out the transmitter that are 	 * received. 	 */
define|#
directive|define
name|HWRM_PORT_MAC_CFG_OUTPUT_LPBK_REMOTE
value|UINT32_C(0x2)
name|uint8_t
name|unused_0
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_port_mac_qcfg */
end_comment

begin_comment
comment|/* Description: This command queries the MAC block for the port. */
end_comment

begin_comment
comment|/* Input (24 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_port_mac_qcfg_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint16_t
name|port_id
decl_stmt|;
comment|/* Port ID of port that is to be configured. */
name|uint16_t
name|unused_0
index|[
literal|3
index|]
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (24 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_port_mac_qcfg_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint16_t
name|mru
decl_stmt|;
comment|/* 	 * This is the configured maximum length of Ethernet packet payload that 	 * is allowed to be received on the port. This value does not include 	 * the number of bytes used by the Ethernet header and trailer (CRC). 	 */
name|uint16_t
name|mtu
decl_stmt|;
comment|/* 	 * This is the configured maximum length of Ethernet packet payload that 	 * is allowed to be transmitted on the port. This value does not include 	 * the number of bytes used by the Ethernet header and trailer (CRC). 	 */
name|uint8_t
name|ipg
decl_stmt|;
comment|/* The minimum IPG that will be sent between packets by this port. */
name|uint8_t
name|lpbk
decl_stmt|;
comment|/* The loopback setting for the MAC. */
comment|/* No loopback is selected. Normal operation. */
define|#
directive|define
name|HWRM_PORT_MAC_QCFG_OUTPUT_LPBK_NONE
value|UINT32_C(0x0)
comment|/* 	 * The HW will be configured with local loopback such that host 	 * data is sent back to the host without modification. 	 */
define|#
directive|define
name|HWRM_PORT_MAC_QCFG_OUTPUT_LPBK_LOCAL
value|UINT32_C(0x1)
comment|/* 	 * The HW will be configured with remote loopback such that port 	 * logic will send packets back out the transmitter that are 	 * received. 	 */
define|#
directive|define
name|HWRM_PORT_MAC_QCFG_OUTPUT_LPBK_REMOTE
value|UINT32_C(0x2)
name|uint8_t
name|vlan_pri2cos_map_pri
decl_stmt|;
comment|/* 	 * Priority setting for VLAN PRI to CoS mapping. # Each XXX_pri variable 	 * shall have a unique priority value when it is being used. # When 	 * comparing priorities of mappings, higher value indicates higher 	 * priority. For example, a value of 0-3 is returned where 0 is being 	 * the lowest priority and 3 is being the highest priority. # If the 	 * correspoding CoS mapping is not enabled, then this field should be 	 * ignored. # This value indicates the normalized priority value 	 * retained in the HWRM. 	 */
name|uint8_t
name|flags
decl_stmt|;
comment|/* 	 * In this field, a number of CoS mappings related flags are used to 	 * indicate configured CoS mappings. 	 */
comment|/* 	 * When this bit is set to '1', the inner VLAN PRI to CoS mapping is 	 * enabled. 	 */
define|#
directive|define
name|HWRM_PORT_MAC_QCFG_OUTPUT_FLAGS_VLAN_PRI2COS_ENABLE
value|UINT32_C(0x1)
comment|/* 	 * When this bit is set to '1', tunnel VLAN PRI field to CoS mapping is 	 * enabled. 	 */
define|#
directive|define
name|HWRM_PORT_MAC_QCFG_OUTPUT_FLAGS_TUNNEL_PRI2COS_ENABLE
value|UINT32_C(0x2)
comment|/* When this bit is set to '1', the IP DSCP to CoS mapping is enabled. */
define|#
directive|define
name|HWRM_PORT_MAC_QCFG_OUTPUT_FLAGS_IP_DSCP2COS_ENABLE
value|UINT32_C(0x4)
comment|/* When this bit is '1', the Out-Of-Box WoL is enabled on this port. */
define|#
directive|define
name|HWRM_PORT_MAC_QCFG_OUTPUT_FLAGS_OOB_WOL_ENABLE
value|UINT32_C(0x8)
comment|/* When this bit is '1', PTP is enabled for RX on this port. */
define|#
directive|define
name|HWRM_PORT_MAC_QCFG_OUTPUT_FLAGS_PTP_RX_TS_CAPTURE_ENABLE
value|UINT32_C(0x10)
comment|/* When this bit is '1', PTP is enabled for TX on this port. */
define|#
directive|define
name|HWRM_PORT_MAC_QCFG_OUTPUT_FLAGS_PTP_TX_TS_CAPTURE_ENABLE
value|UINT32_C(0x20)
name|uint8_t
name|tunnel_pri2cos_map_pri
decl_stmt|;
comment|/* 	 * Priority setting for tunnel VLAN PRI to CoS mapping. # Each XXX_pri 	 * variable shall have a unique priority value when it is being used. # 	 * When comparing priorities of mappings, higher value indicates higher 	 * priority. For example, a value of 0-3 is returned where 0 is being 	 * the lowest priority and 3 is being the highest priority. # If the 	 * correspoding CoS mapping is not enabled, then this field should be 	 * ignored. # This value indicates the normalized priority value 	 * retained in the HWRM. 	 */
name|uint8_t
name|dscp2pri_map_pri
decl_stmt|;
comment|/* 	 * Priority setting for DSCP to PRI mapping. # Each XXX_pri variable 	 * shall have a unique priority value when it is being used. # When 	 * comparing priorities of mappings, higher value indicates higher 	 * priority. For example, a value of 0-3 is returned where 0 is being 	 * the lowest priority and 3 is being the highest priority. # If the 	 * correspoding CoS mapping is not enabled, then this field should be 	 * ignored. # This value indicates the normalized priority value 	 * retained in the HWRM. 	 */
name|uint16_t
name|rx_ts_capture_ptp_msg_type
decl_stmt|;
comment|/* 	 * This is a 16-bit bit mask that represents the current configuration 	 * of time stamp capture of PTP messages on the receive side of this 	 * port. If bit 'i' is set, then the receive side of the port is 	 * configured to capture the time stamp of every received PTP message 	 * with messageType field value set to i. If all bits are set to 0 (i.e. 	 * field value set 0), then the receive side of the port is not 	 * configured to capture timestamp for PTP messages. If all bits are set 	 * to 1, then the receive side of the port is configured to capture 	 * timestamp for all PTP messages. 	 */
name|uint16_t
name|tx_ts_capture_ptp_msg_type
decl_stmt|;
comment|/* 	 * This is a 16-bit bit mask that represents the current configuration 	 * of time stamp capture of PTP messages on the transmit side of this 	 * port. If bit 'i' is set, then the transmit side of the port is 	 * configured to capture the time stamp of every received PTP message 	 * with messageType field value set to i. If all bits are set to 0 (i.e. 	 * field value set 0), then the transmit side of the port is not 	 * configured to capture timestamp for PTP messages. If all bits are set 	 * to 1, then the transmit side of the port is configured to capture 	 * timestamp for all PTP messages. 	 */
name|uint8_t
name|cos_field_cfg
decl_stmt|;
comment|/* Configuration of CoS fields. */
comment|/* Reserved */
define|#
directive|define
name|HWRM_PORT_MAC_QCFG_OUTPUT_COS_FIELD_CFG_RSVD
value|UINT32_C(0x1)
comment|/* 	 * This field is used for selecting VLAN PRI value based on whether one 	 * or two VLAN Tags are present in the inner packet headers of tunneled 	 * packets or non-tunneled packets. 	 */
define|#
directive|define
name|HWRM_PORT_MAC_QCFG_OUTPUT_COS_FIELD_CFG_VLAN_PRI_SEL_MASK
value|UINT32_C(0x6)
define|#
directive|define
name|HWRM_PORT_MAC_QCFG_OUTPUT_COS_FIELD_CFG_VLAN_PRI_SEL_SFT
value|1
comment|/* 	 * Select inner VLAN PRI when 1 or 2 VLAN Tags are present in 	 * the inner packet headers 	 */
define|#
directive|define
name|HWRM_PORT_MAC_QCFG_OUTPUT_COS_FIELD_CFG_VLAN_PRI_SEL_INNERMOST
value|(UINT32_C(0x0)<< 1)
comment|/* 	 * Select outer VLAN Tag PRI when 2 VLAN Tags are present in the 	 * inner packet headers. No VLAN PRI is selected for this 	 * configuration if only one VLAN Tag is present in the inner 	 * packet headers. 	 */
define|#
directive|define
name|HWRM_PORT_MAC_QCFG_OUTPUT_COS_FIELD_CFG_VLAN_PRI_SEL_OUTER
value|(UINT32_C(0x1)<< 1)
comment|/* 	 * Select outermost VLAN PRI when 1 or 2 VLAN Tags are present 	 * in the inner packet headers 	 */
define|#
directive|define
name|HWRM_PORT_MAC_QCFG_OUTPUT_COS_FIELD_CFG_VLAN_PRI_SEL_OUTERMOST
value|(UINT32_C(0x2)<< 1)
comment|/* Unspecified */
define|#
directive|define
name|HWRM_PORT_MAC_QCFG_OUTPUT_COS_FIELD_CFG_VLAN_PRI_SEL_UNSPECIFIED
value|(UINT32_C(0x3)<< 1)
define|#
directive|define
name|HWRM_PORT_MAC_QCFG_OUTPUT_COS_FIELD_CFG_VLAN_PRI_SEL_LAST
value|HWRM_PORT_MAC_QCFG_OUTPUT_COS_FIELD_CFG_VLAN_PRI_SEL_UNSPECIFIED
comment|/* 	 * This field is used for selecting tunnel VLAN PRI value based on 	 * whether one or two VLAN Tags are present in the tunnel headers of 	 * tunneled packets. This selection does not apply to non-tunneled 	 * packets. 	 */
define|#
directive|define
name|HWRM_PORT_MAC_QCFG_OUTPUT_COS_FIELD_CFG_T_VLAN_PRI_SEL_MASK
value|UINT32_C(0x18)
define|#
directive|define
name|HWRM_PORT_MAC_QCFG_OUTPUT_COS_FIELD_CFG_T_VLAN_PRI_SEL_SFT
value|3
comment|/* 	 * Select inner VLAN PRI when 1 or 2 VLAN Tags are present in 	 * the tunnel packet headers 	 */
define|#
directive|define
name|HWRM_PORT_MAC_QCFG_OUTPUT_COS_FIELD_CFG_T_VLAN_PRI_SEL_INNERMOST
value|(UINT32_C(0x0)<< 3)
comment|/* 	 * Select outer VLAN Tag PRI when 2 VLAN Tags are present in the 	 * tunnel packet headers. No VLAN PRI is selected for this 	 * configuration if only one VLAN Tag is present in the tunnel 	 * packet headers. 	 */
define|#
directive|define
name|HWRM_PORT_MAC_QCFG_OUTPUT_COS_FIELD_CFG_T_VLAN_PRI_SEL_OUTER
value|(UINT32_C(0x1)<< 3)
comment|/* 	 * Select outermost VLAN PRI when 1 or 2 VLAN Tags are present 	 * in the tunnel packet headers 	 */
define|#
directive|define
name|HWRM_PORT_MAC_QCFG_OUTPUT_COS_FIELD_CFG_T_VLAN_PRI_SEL_OUTERMOST
value|(UINT32_C(0x2)<< 3)
comment|/* Unspecified */
define|#
directive|define
name|HWRM_PORT_MAC_QCFG_OUTPUT_COS_FIELD_CFG_T_VLAN_PRI_SEL_UNSPECIFIED
value|(UINT32_C(0x3)<< 3)
define|#
directive|define
name|HWRM_PORT_MAC_QCFG_OUTPUT_COS_FIELD_CFG_T_VLAN_PRI_SEL_LAST
value|HWRM_PORT_MAC_QCFG_OUTPUT_COS_FIELD_CFG_T_VLAN_PRI_SEL_UNSPECIFIED
comment|/* 	 * This field is used to provide default CoS value that has been 	 * configured on this port. 	 */
define|#
directive|define
name|HWRM_PORT_MAC_QCFG_OUTPUT_COS_FIELD_CFG_DEFAULT_COS_MASK
value|UINT32_C(0xe0)
define|#
directive|define
name|HWRM_PORT_MAC_QCFG_OUTPUT_COS_FIELD_CFG_DEFAULT_COS_SFT
value|5
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_port_mac_ptp_qcfg */
end_comment

begin_comment
comment|/* Description: This command queries the PTP information for the port. */
end_comment

begin_comment
comment|/* Input (24 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_port_mac_ptp_qcfg_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint16_t
name|port_id
decl_stmt|;
comment|/* Port ID of port that is being queried. */
name|uint16_t
name|unused_0
index|[
literal|3
index|]
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (80 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_port_mac_ptp_qcfg_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint8_t
name|flags
decl_stmt|;
comment|/* 	 * In this field, a number of PTP related flags are used to indicate 	 * configured PTP capabilities. 	 */
comment|/* 	 * When this bit is set to '1', the PTP related registers are directly 	 * accessible by the host. 	 */
define|#
directive|define
name|HWRM_PORT_MAC_PTP_QCFG_OUTPUT_FLAGS_DIRECT_ACCESS
value|UINT32_C(0x1)
comment|/* 	 * When this bit is set to '1', the PTP information is accessible via 	 * HWRM commands. 	 */
define|#
directive|define
name|HWRM_PORT_MAC_PTP_QCFG_OUTPUT_FLAGS_HWRM_ACCESS
value|UINT32_C(0x2)
name|uint8_t
name|unused_0
decl_stmt|;
name|uint16_t
name|unused_1
decl_stmt|;
name|uint32_t
name|rx_ts_reg_off_lower
decl_stmt|;
comment|/* Offset of the PTP register for the lower 32 bits of timestamp for RX. */
name|uint32_t
name|rx_ts_reg_off_upper
decl_stmt|;
comment|/* Offset of the PTP register for the upper 32 bits of timestamp for RX. */
name|uint32_t
name|rx_ts_reg_off_seq_id
decl_stmt|;
comment|/* Offset of the PTP register for the sequence ID for RX. */
name|uint32_t
name|rx_ts_reg_off_src_id_0
decl_stmt|;
comment|/* Offset of the first PTP source ID for RX. */
name|uint32_t
name|rx_ts_reg_off_src_id_1
decl_stmt|;
comment|/* Offset of the second PTP source ID for RX. */
name|uint32_t
name|rx_ts_reg_off_src_id_2
decl_stmt|;
comment|/* Offset of the third PTP source ID for RX. */
name|uint32_t
name|rx_ts_reg_off_domain_id
decl_stmt|;
comment|/* Offset of the domain ID for RX. */
name|uint32_t
name|rx_ts_reg_off_fifo
decl_stmt|;
comment|/* Offset of the PTP FIFO register for RX. */
name|uint32_t
name|rx_ts_reg_off_fifo_adv
decl_stmt|;
comment|/* Offset of the PTP advance FIFO register for RX. */
name|uint32_t
name|rx_ts_reg_off_granularity
decl_stmt|;
comment|/* PTP timestamp granularity for RX. */
name|uint32_t
name|tx_ts_reg_off_lower
decl_stmt|;
comment|/* Offset of the PTP register for the lower 32 bits of timestamp for TX. */
name|uint32_t
name|tx_ts_reg_off_upper
decl_stmt|;
comment|/* Offset of the PTP register for the upper 32 bits of timestamp for TX. */
name|uint32_t
name|tx_ts_reg_off_seq_id
decl_stmt|;
comment|/* Offset of the PTP register for the sequence ID for TX. */
name|uint32_t
name|tx_ts_reg_off_fifo
decl_stmt|;
comment|/* Offset of the PTP FIFO register for TX. */
name|uint32_t
name|tx_ts_reg_off_granularity
decl_stmt|;
comment|/* PTP timestamp granularity for TX. */
name|uint32_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint8_t
name|unused_4
decl_stmt|;
name|uint8_t
name|unused_5
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_port_qstats */
end_comment

begin_comment
comment|/* Description: This function returns per port Ethernet statistics. */
end_comment

begin_comment
comment|/* Input (40 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_port_qstats_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint16_t
name|port_id
decl_stmt|;
comment|/* Port ID of port that is being queried. */
name|uint8_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
index|[
literal|3
index|]
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint64_t
name|tx_stat_host_addr
decl_stmt|;
comment|/* This is the host address where Tx port statistics will be stored */
name|uint64_t
name|rx_stat_host_addr
decl_stmt|;
comment|/* This is the host address where Rx port statistics will be stored */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_port_qstats_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint16_t
name|tx_stat_size
decl_stmt|;
comment|/* The size of TX port statistics block in bytes. */
name|uint16_t
name|rx_stat_size
decl_stmt|;
comment|/* The size of RX port statistics block in bytes. */
name|uint8_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_port_lpbk_qstats */
end_comment

begin_comment
comment|/* Description: This function returns loopback statistics. */
end_comment

begin_comment
comment|/* Input (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_port_lpbk_qstats_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (96 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_port_lpbk_qstats_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint64_t
name|lpbk_ucast_frames
decl_stmt|;
comment|/* Number of transmitted unicast frames */
name|uint64_t
name|lpbk_mcast_frames
decl_stmt|;
comment|/* Number of transmitted multicast frames */
name|uint64_t
name|lpbk_bcast_frames
decl_stmt|;
comment|/* Number of transmitted broadcast frames */
name|uint64_t
name|lpbk_ucast_bytes
decl_stmt|;
comment|/* Number of transmitted bytes for unicast traffic */
name|uint64_t
name|lpbk_mcast_bytes
decl_stmt|;
comment|/* Number of transmitted bytes for multicast traffic */
name|uint64_t
name|lpbk_bcast_bytes
decl_stmt|;
comment|/* Number of transmitted bytes for broadcast traffic */
name|uint64_t
name|tx_stat_discard
decl_stmt|;
comment|/* Total Tx Drops for loopback traffic reported by STATS block */
name|uint64_t
name|tx_stat_error
decl_stmt|;
comment|/* Total Tx Error Drops for loopback traffic reported by STATS block */
name|uint64_t
name|rx_stat_discard
decl_stmt|;
comment|/* Total Rx Drops for loopback traffic reported by STATS block */
name|uint64_t
name|rx_stat_error
decl_stmt|;
comment|/* Total Rx Error Drops for loopback traffic reported by STATS block */
name|uint32_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_port_clr_stats */
end_comment

begin_comment
comment|/*  * Description: This function clears per port statistics. The HWRM shall not  * allow a VF driver to clear port statistics. The HWRM shall not allow a PF  * driver to clear port statistics in a partitioning mode. The HWRM may allow a  * PF driver to clear port statistics in the non-partitioning mode.  */
end_comment

begin_comment
comment|/* Input (24 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_port_clr_stats_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint16_t
name|port_id
decl_stmt|;
comment|/* Port ID of port that is being queried. */
name|uint16_t
name|unused_0
index|[
literal|3
index|]
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_port_clr_stats_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint32_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_port_lpbk_clr_stats */
end_comment

begin_comment
comment|/*  * Description: This function clears loopback statistics. The HWRM shall not  * allow a VF driver to clear loopback statistics. The HWRM shall not allow a PF  * driver to clear loopback statistics in a partitioning mode. The HWRM may  * allow a PF driver to clear loopback statistics in the non-partitioning mode.  */
end_comment

begin_comment
comment|/* Input (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_port_lpbk_clr_stats_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_port_lpbk_clr_stats_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint32_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_port_ts_query */
end_comment

begin_comment
comment|/*  * Description: This function is used to read timestamp information captured for  * PTP messages on this port.  */
end_comment

begin_comment
comment|/* Input (24 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_port_ts_query_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint32_t
name|flags
decl_stmt|;
comment|/* 	 * Enumeration denoting the RX, TX type of the resource. This 	 * enumeration is used for resources that are similar for both TX and RX 	 * paths of the chip. 	 */
define|#
directive|define
name|HWRM_PORT_TS_QUERY_INPUT_FLAGS_PATH
value|UINT32_C(0x1)
comment|/* tx path */
define|#
directive|define
name|HWRM_PORT_TS_QUERY_INPUT_FLAGS_PATH_TX
value|UINT32_C(0x0)
comment|/* rx path */
define|#
directive|define
name|HWRM_PORT_TS_QUERY_INPUT_FLAGS_PATH_RX
value|UINT32_C(0x1)
define|#
directive|define
name|HWRM_PORT_TS_QUERY_INPUT_FLAGS_PATH_LAST
value|HWRM_PORT_TS_QUERY_INPUT_FLAGS_PATH_RX
name|uint16_t
name|port_id
decl_stmt|;
comment|/* Port ID of port that is being queried. */
name|uint16_t
name|unused_0
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (24 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_port_ts_query_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint64_t
name|ptp_msg_ts
decl_stmt|;
comment|/* Timestamp value of PTP message captured. */
name|uint16_t
name|ptp_msg_seqid
decl_stmt|;
comment|/* Sequence ID of the PTP message captured. */
name|uint8_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint8_t
name|unused_4
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_port_phy_qcaps */
end_comment

begin_comment
comment|/*  * Description: This function is used to query the current capabilities of PHY  * on this link.  */
end_comment

begin_comment
comment|/* Input (24 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_port_phy_qcaps_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint16_t
name|port_id
decl_stmt|;
comment|/* Port ID of port that is being queried. */
name|uint16_t
name|unused_0
index|[
literal|3
index|]
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (24 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_port_phy_qcaps_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint8_t
name|flags
decl_stmt|;
comment|/* PHY capability flags */
comment|/* 	 * If set to 1, then this field indicates that the link is capable of 	 * supporting EEE. 	 */
define|#
directive|define
name|HWRM_PORT_PHY_QCAPS_OUTPUT_FLAGS_EEE_SUPPORTED
value|UINT32_C(0x1)
comment|/* 	 * Reserved field. The HWRM shall set this field to 0. An HWRM client 	 * shall ignore this field. 	 */
define|#
directive|define
name|HWRM_PORT_PHY_QCAPS_OUTPUT_FLAGS_RSVD1_MASK
value|UINT32_C(0xfe)
define|#
directive|define
name|HWRM_PORT_PHY_QCAPS_OUTPUT_FLAGS_RSVD1_SFT
value|1
name|uint8_t
name|port_cnt
decl_stmt|;
comment|/* Number of front panel ports for this device. */
comment|/* Not supported or unknown */
define|#
directive|define
name|HWRM_PORT_PHY_QCAPS_OUTPUT_PORT_CNT_UNKNOWN
value|UINT32_C(0x0)
comment|/* single port device */
define|#
directive|define
name|HWRM_PORT_PHY_QCAPS_OUTPUT_PORT_CNT_1
value|UINT32_C(0x1)
comment|/* 2-port device */
define|#
directive|define
name|HWRM_PORT_PHY_QCAPS_OUTPUT_PORT_CNT_2
value|UINT32_C(0x2)
comment|/* 3-port device */
define|#
directive|define
name|HWRM_PORT_PHY_QCAPS_OUTPUT_PORT_CNT_3
value|UINT32_C(0x3)
comment|/* 4-port device */
define|#
directive|define
name|HWRM_PORT_PHY_QCAPS_OUTPUT_PORT_CNT_4
value|UINT32_C(0x4)
name|uint16_t
name|supported_speeds_force_mode
decl_stmt|;
comment|/* 	 * This is a bit mask to indicate what speeds are supported as forced 	 * speeds on this link. For each speed that can be forced on this link, 	 * the corresponding mask bit shall be set to '1'. 	 */
comment|/* 100Mb link speed (Half-duplex) */
define|#
directive|define
name|HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_FORCE_MODE_100MBHD
value|UINT32_C(0x1)
comment|/* 100Mb link speed (Full-duplex) */
define|#
directive|define
name|HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_FORCE_MODE_100MB
value|UINT32_C(0x2)
comment|/* 1Gb link speed (Half-duplex) */
define|#
directive|define
name|HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_FORCE_MODE_1GBHD
value|UINT32_C(0x4)
comment|/* 1Gb link speed (Full-duplex) */
define|#
directive|define
name|HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_FORCE_MODE_1GB
value|UINT32_C(0x8)
comment|/* 2Gb link speed */
define|#
directive|define
name|HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_FORCE_MODE_2GB
value|UINT32_C(0x10)
comment|/* 2.5Gb link speed */
define|#
directive|define
name|HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_FORCE_MODE_2_5GB
value|UINT32_C(0x20)
comment|/* 10Gb link speed */
define|#
directive|define
name|HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_FORCE_MODE_10GB
value|UINT32_C(0x40)
comment|/* 20Gb link speed */
define|#
directive|define
name|HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_FORCE_MODE_20GB
value|UINT32_C(0x80)
comment|/* 25Gb link speed */
define|#
directive|define
name|HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_FORCE_MODE_25GB
value|UINT32_C(0x100)
comment|/* 40Gb link speed */
define|#
directive|define
name|HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_FORCE_MODE_40GB
value|UINT32_C(0x200)
comment|/* 50Gb link speed */
define|#
directive|define
name|HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_FORCE_MODE_50GB
value|UINT32_C(0x400)
comment|/* 100Gb link speed */
define|#
directive|define
name|HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_FORCE_MODE_100GB
value|UINT32_C(0x800)
comment|/* 10Mb link speed (Half-duplex) */
define|#
directive|define
name|HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_FORCE_MODE_10MBHD
value|UINT32_C(0x1000)
comment|/* 10Mb link speed (Full-duplex) */
define|#
directive|define
name|HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_FORCE_MODE_10MB
value|UINT32_C(0x2000)
name|uint16_t
name|supported_speeds_auto_mode
decl_stmt|;
comment|/* 	 * This is a bit mask to indicate what speeds are supported for 	 * autonegotiation on this link. For each speed that can be 	 * autonegotiated on this link, the corresponding mask bit shall be set 	 * to '1'. 	 */
comment|/* 100Mb link speed (Half-duplex) */
define|#
directive|define
name|HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_AUTO_MODE_100MBHD
value|UINT32_C(0x1)
comment|/* 100Mb link speed (Full-duplex) */
define|#
directive|define
name|HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_AUTO_MODE_100MB
value|UINT32_C(0x2)
comment|/* 1Gb link speed (Half-duplex) */
define|#
directive|define
name|HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_AUTO_MODE_1GBHD
value|UINT32_C(0x4)
comment|/* 1Gb link speed (Full-duplex) */
define|#
directive|define
name|HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_AUTO_MODE_1GB
value|UINT32_C(0x8)
comment|/* 2Gb link speed */
define|#
directive|define
name|HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_AUTO_MODE_2GB
value|UINT32_C(0x10)
comment|/* 2.5Gb link speed */
define|#
directive|define
name|HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_AUTO_MODE_2_5GB
value|UINT32_C(0x20)
comment|/* 10Gb link speed */
define|#
directive|define
name|HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_AUTO_MODE_10GB
value|UINT32_C(0x40)
comment|/* 20Gb link speed */
define|#
directive|define
name|HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_AUTO_MODE_20GB
value|UINT32_C(0x80)
comment|/* 25Gb link speed */
define|#
directive|define
name|HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_AUTO_MODE_25GB
value|UINT32_C(0x100)
comment|/* 40Gb link speed */
define|#
directive|define
name|HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_AUTO_MODE_40GB
value|UINT32_C(0x200)
comment|/* 50Gb link speed */
define|#
directive|define
name|HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_AUTO_MODE_50GB
value|UINT32_C(0x400)
comment|/* 100Gb link speed */
define|#
directive|define
name|HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_AUTO_MODE_100GB
value|UINT32_C(0x800)
comment|/* 10Mb link speed (Half-duplex) */
define|#
directive|define
name|HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_AUTO_MODE_10MBHD
value|UINT32_C(0x1000)
comment|/* 10Mb link speed (Full-duplex) */
define|#
directive|define
name|HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_AUTO_MODE_10MB
value|UINT32_C(0x2000)
name|uint16_t
name|supported_speeds_eee_mode
decl_stmt|;
comment|/* 	 * This is a bit mask to indicate what speeds are supported for EEE on 	 * this link. For each speed that can be autonegotiated when EEE is 	 * enabled on this link, the corresponding mask bit shall be set to '1'. 	 * This field is only valid when the eee_suppotred is set to '1'. 	 */
comment|/* Reserved */
define|#
directive|define
name|HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_EEE_MODE_RSVD1
value|UINT32_C(0x1)
comment|/* 100Mb link speed (Full-duplex) */
define|#
directive|define
name|HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_EEE_MODE_100MB
value|UINT32_C(0x2)
comment|/* Reserved */
define|#
directive|define
name|HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_EEE_MODE_RSVD2
value|UINT32_C(0x4)
comment|/* 1Gb link speed (Full-duplex) */
define|#
directive|define
name|HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_EEE_MODE_1GB
value|UINT32_C(0x8)
comment|/* Reserved */
define|#
directive|define
name|HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_EEE_MODE_RSVD3
value|UINT32_C(0x10)
comment|/* Reserved */
define|#
directive|define
name|HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_EEE_MODE_RSVD4
value|UINT32_C(0x20)
comment|/* 10Gb link speed */
define|#
directive|define
name|HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_EEE_MODE_10GB
value|UINT32_C(0x40)
name|uint32_t
name|tx_lpi_timer_low
decl_stmt|;
comment|/* 	 * Reserved field. The HWRM shall set this field to 0. An HWRM client 	 * shall ignore this field. 	 */
comment|/* 	 * The lowest value of TX LPI timer that can be set on this link when 	 * EEE is enabled. This value is in microseconds. This field is valid 	 * only when_eee_supported is set to '1'. 	 */
define|#
directive|define
name|HWRM_PORT_PHY_QCAPS_OUTPUT_TX_LPI_TIMER_LOW_MASK
value|UINT32_C(0xffffff)
define|#
directive|define
name|HWRM_PORT_PHY_QCAPS_OUTPUT_TX_LPI_TIMER_LOW_SFT
value|0
comment|/* 	 * Reserved field. The HWRM shall set this field to 0. An HWRM client 	 * shall ignore this field. 	 */
define|#
directive|define
name|HWRM_PORT_PHY_QCAPS_OUTPUT_RSVD2_MASK
value|UINT32_C(0xff000000)
define|#
directive|define
name|HWRM_PORT_PHY_QCAPS_OUTPUT_RSVD2_SFT
value|24
name|uint32_t
name|valid_tx_lpi_timer_high
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
comment|/* 	 * The highest value of TX LPI timer that can be set on this link when 	 * EEE is enabled. This value is in microseconds. This field is valid 	 * only when_eee_supported is set to '1'. 	 */
define|#
directive|define
name|HWRM_PORT_PHY_QCAPS_OUTPUT_TX_LPI_TIMER_HIGH_MASK
value|UINT32_C(0xffffff)
define|#
directive|define
name|HWRM_PORT_PHY_QCAPS_OUTPUT_TX_LPI_TIMER_HIGH_SFT
value|0
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
define|#
directive|define
name|HWRM_PORT_PHY_QCAPS_OUTPUT_VALID_MASK
value|UINT32_C(0xff000000)
define|#
directive|define
name|HWRM_PORT_PHY_QCAPS_OUTPUT_VALID_SFT
value|24
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_port_led_cfg */
end_comment

begin_comment
comment|/*  * Description: This function is used to configure LEDs on a given port. Each  * port has individual set of LEDs associated with it. These LEDs are used for  * speed/link configuration as well as activity indicator configuration. Up to  * three LEDs can be configured, one for activity and two for speeds.  */
end_comment

begin_comment
comment|/* Input (64 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_port_led_cfg_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint32_t
name|enables
decl_stmt|;
comment|/* This bit must be '1' for the led0_id field to be configured. */
define|#
directive|define
name|HWRM_PORT_LED_CFG_INPUT_ENABLES_LED0_ID
value|UINT32_C(0x1)
comment|/* This bit must be '1' for the led0_state field to be configured. */
define|#
directive|define
name|HWRM_PORT_LED_CFG_INPUT_ENABLES_LED0_STATE
value|UINT32_C(0x2)
comment|/* This bit must be '1' for the led0_color field to be configured. */
define|#
directive|define
name|HWRM_PORT_LED_CFG_INPUT_ENABLES_LED0_COLOR
value|UINT32_C(0x4)
comment|/* This bit must be '1' for the led0_blink_on field to be configured. */
define|#
directive|define
name|HWRM_PORT_LED_CFG_INPUT_ENABLES_LED0_BLINK_ON
value|UINT32_C(0x8)
comment|/* This bit must be '1' for the led0_blink_off field to be configured. */
define|#
directive|define
name|HWRM_PORT_LED_CFG_INPUT_ENABLES_LED0_BLINK_OFF
value|UINT32_C(0x10)
comment|/* This bit must be '1' for the led0_group_id field to be configured. */
define|#
directive|define
name|HWRM_PORT_LED_CFG_INPUT_ENABLES_LED0_GROUP_ID
value|UINT32_C(0x20)
comment|/* This bit must be '1' for the led1_id field to be configured. */
define|#
directive|define
name|HWRM_PORT_LED_CFG_INPUT_ENABLES_LED1_ID
value|UINT32_C(0x40)
comment|/* This bit must be '1' for the led1_state field to be configured. */
define|#
directive|define
name|HWRM_PORT_LED_CFG_INPUT_ENABLES_LED1_STATE
value|UINT32_C(0x80)
comment|/* This bit must be '1' for the led1_color field to be configured. */
define|#
directive|define
name|HWRM_PORT_LED_CFG_INPUT_ENABLES_LED1_COLOR
value|UINT32_C(0x100)
comment|/* This bit must be '1' for the led1_blink_on field to be configured. */
define|#
directive|define
name|HWRM_PORT_LED_CFG_INPUT_ENABLES_LED1_BLINK_ON
value|UINT32_C(0x200)
comment|/* This bit must be '1' for the led1_blink_off field to be configured. */
define|#
directive|define
name|HWRM_PORT_LED_CFG_INPUT_ENABLES_LED1_BLINK_OFF
value|UINT32_C(0x400)
comment|/* This bit must be '1' for the led1_group_id field to be configured. */
define|#
directive|define
name|HWRM_PORT_LED_CFG_INPUT_ENABLES_LED1_GROUP_ID
value|UINT32_C(0x800)
comment|/* This bit must be '1' for the led2_id field to be configured. */
define|#
directive|define
name|HWRM_PORT_LED_CFG_INPUT_ENABLES_LED2_ID
value|UINT32_C(0x1000)
comment|/* This bit must be '1' for the led2_state field to be configured. */
define|#
directive|define
name|HWRM_PORT_LED_CFG_INPUT_ENABLES_LED2_STATE
value|UINT32_C(0x2000)
comment|/* This bit must be '1' for the led2_color field to be configured. */
define|#
directive|define
name|HWRM_PORT_LED_CFG_INPUT_ENABLES_LED2_COLOR
value|UINT32_C(0x4000)
comment|/* This bit must be '1' for the led2_blink_on field to be configured. */
define|#
directive|define
name|HWRM_PORT_LED_CFG_INPUT_ENABLES_LED2_BLINK_ON
value|UINT32_C(0x8000)
comment|/* This bit must be '1' for the led2_blink_off field to be configured. */
define|#
directive|define
name|HWRM_PORT_LED_CFG_INPUT_ENABLES_LED2_BLINK_OFF
value|UINT32_C(0x10000)
comment|/* This bit must be '1' for the led2_group_id field to be configured. */
define|#
directive|define
name|HWRM_PORT_LED_CFG_INPUT_ENABLES_LED2_GROUP_ID
value|UINT32_C(0x20000)
comment|/* This bit must be '1' for the led3_id field to be configured. */
define|#
directive|define
name|HWRM_PORT_LED_CFG_INPUT_ENABLES_LED3_ID
value|UINT32_C(0x40000)
comment|/* This bit must be '1' for the led3_state field to be configured. */
define|#
directive|define
name|HWRM_PORT_LED_CFG_INPUT_ENABLES_LED3_STATE
value|UINT32_C(0x80000)
comment|/* This bit must be '1' for the led3_color field to be configured. */
define|#
directive|define
name|HWRM_PORT_LED_CFG_INPUT_ENABLES_LED3_COLOR
value|UINT32_C(0x100000)
comment|/* This bit must be '1' for the led3_blink_on field to be configured. */
define|#
directive|define
name|HWRM_PORT_LED_CFG_INPUT_ENABLES_LED3_BLINK_ON
value|UINT32_C(0x200000)
comment|/* This bit must be '1' for the led3_blink_off field to be configured. */
define|#
directive|define
name|HWRM_PORT_LED_CFG_INPUT_ENABLES_LED3_BLINK_OFF
value|UINT32_C(0x400000)
comment|/* This bit must be '1' for the led3_group_id field to be configured. */
define|#
directive|define
name|HWRM_PORT_LED_CFG_INPUT_ENABLES_LED3_GROUP_ID
value|UINT32_C(0x800000)
name|uint16_t
name|port_id
decl_stmt|;
comment|/* Port ID of port whose LEDs are configured. */
name|uint8_t
name|num_leds
decl_stmt|;
comment|/* 	 * The number of LEDs that are being configured. Up to 4 LEDs can be 	 * configured with this command. 	 */
name|uint8_t
name|rsvd
decl_stmt|;
comment|/* Reserved field. */
name|uint8_t
name|led0_id
decl_stmt|;
comment|/* An identifier for the LED #0. */
name|uint8_t
name|led0_state
decl_stmt|;
comment|/* The requested state of the LED #0. */
comment|/* Default state of the LED */
define|#
directive|define
name|HWRM_PORT_LED_CFG_INPUT_LED0_STATE_DEFAULT
value|UINT32_C(0x0)
comment|/* Off */
define|#
directive|define
name|HWRM_PORT_LED_CFG_INPUT_LED0_STATE_OFF
value|UINT32_C(0x1)
comment|/* On */
define|#
directive|define
name|HWRM_PORT_LED_CFG_INPUT_LED0_STATE_ON
value|UINT32_C(0x2)
comment|/* Blink */
define|#
directive|define
name|HWRM_PORT_LED_CFG_INPUT_LED0_STATE_BLINK
value|UINT32_C(0x3)
comment|/* Blink Alternately */
define|#
directive|define
name|HWRM_PORT_LED_CFG_INPUT_LED0_STATE_BLINKALT
value|UINT32_C(0x4)
name|uint8_t
name|led0_color
decl_stmt|;
comment|/* The requested color of LED #0. */
comment|/* Default */
define|#
directive|define
name|HWRM_PORT_LED_CFG_INPUT_LED0_COLOR_DEFAULT
value|UINT32_C(0x0)
comment|/* Amber */
define|#
directive|define
name|HWRM_PORT_LED_CFG_INPUT_LED0_COLOR_AMBER
value|UINT32_C(0x1)
comment|/* Green */
define|#
directive|define
name|HWRM_PORT_LED_CFG_INPUT_LED0_COLOR_GREEN
value|UINT32_C(0x2)
comment|/* Green or Amber */
define|#
directive|define
name|HWRM_PORT_LED_CFG_INPUT_LED0_COLOR_GREENAMBER
value|UINT32_C(0x3)
name|uint8_t
name|unused_0
decl_stmt|;
name|uint16_t
name|led0_blink_on
decl_stmt|;
comment|/* 	 * If the LED #0 state is "blink" or "blinkalt", then this field 	 * represents the requested time in milliseconds to keep LED on between 	 * cycles. 	 */
name|uint16_t
name|led0_blink_off
decl_stmt|;
comment|/* 	 * If the LED #0 state is "blink" or "blinkalt", then this field 	 * represents the requested time in milliseconds to keep LED off between 	 * cycles. 	 */
name|uint8_t
name|led0_group_id
decl_stmt|;
comment|/* 	 * An identifier for the group of LEDs that LED #0 belongs to. If set to 	 * 0, then the LED #0 shall not be grouped and shall be treated as an 	 * individual resource. For all other non-zero values of this field, LED 	 * #0 shall be grouped together with the LEDs with the same group ID 	 * value. 	 */
name|uint8_t
name|rsvd0
decl_stmt|;
comment|/* Reserved field. */
name|uint8_t
name|led1_id
decl_stmt|;
comment|/* An identifier for the LED #1. */
name|uint8_t
name|led1_state
decl_stmt|;
comment|/* The requested state of the LED #1. */
comment|/* Default state of the LED */
define|#
directive|define
name|HWRM_PORT_LED_CFG_INPUT_LED1_STATE_DEFAULT
value|UINT32_C(0x0)
comment|/* Off */
define|#
directive|define
name|HWRM_PORT_LED_CFG_INPUT_LED1_STATE_OFF
value|UINT32_C(0x1)
comment|/* On */
define|#
directive|define
name|HWRM_PORT_LED_CFG_INPUT_LED1_STATE_ON
value|UINT32_C(0x2)
comment|/* Blink */
define|#
directive|define
name|HWRM_PORT_LED_CFG_INPUT_LED1_STATE_BLINK
value|UINT32_C(0x3)
comment|/* Blink Alternately */
define|#
directive|define
name|HWRM_PORT_LED_CFG_INPUT_LED1_STATE_BLINKALT
value|UINT32_C(0x4)
name|uint8_t
name|led1_color
decl_stmt|;
comment|/* The requested color of LED #1. */
comment|/* Default */
define|#
directive|define
name|HWRM_PORT_LED_CFG_INPUT_LED1_COLOR_DEFAULT
value|UINT32_C(0x0)
comment|/* Amber */
define|#
directive|define
name|HWRM_PORT_LED_CFG_INPUT_LED1_COLOR_AMBER
value|UINT32_C(0x1)
comment|/* Green */
define|#
directive|define
name|HWRM_PORT_LED_CFG_INPUT_LED1_COLOR_GREEN
value|UINT32_C(0x2)
comment|/* Green or Amber */
define|#
directive|define
name|HWRM_PORT_LED_CFG_INPUT_LED1_COLOR_GREENAMBER
value|UINT32_C(0x3)
name|uint8_t
name|unused_1
decl_stmt|;
name|uint16_t
name|led1_blink_on
decl_stmt|;
comment|/* 	 * If the LED #1 state is "blink" or "blinkalt", then this field 	 * represents the requested time in milliseconds to keep LED on between 	 * cycles. 	 */
name|uint16_t
name|led1_blink_off
decl_stmt|;
comment|/* 	 * If the LED #1 state is "blink" or "blinkalt", then this field 	 * represents the requested time in milliseconds to keep LED off between 	 * cycles. 	 */
name|uint8_t
name|led1_group_id
decl_stmt|;
comment|/* 	 * An identifier for the group of LEDs that LED #1 belongs to. If set to 	 * 0, then the LED #1 shall not be grouped and shall be treated as an 	 * individual resource. For all other non-zero values of this field, LED 	 * #1 shall be grouped together with the LEDs with the same group ID 	 * value. 	 */
name|uint8_t
name|rsvd1
decl_stmt|;
comment|/* Reserved field. */
name|uint8_t
name|led2_id
decl_stmt|;
comment|/* An identifier for the LED #2. */
name|uint8_t
name|led2_state
decl_stmt|;
comment|/* The requested state of the LED #2. */
comment|/* Default state of the LED */
define|#
directive|define
name|HWRM_PORT_LED_CFG_INPUT_LED2_STATE_DEFAULT
value|UINT32_C(0x0)
comment|/* Off */
define|#
directive|define
name|HWRM_PORT_LED_CFG_INPUT_LED2_STATE_OFF
value|UINT32_C(0x1)
comment|/* On */
define|#
directive|define
name|HWRM_PORT_LED_CFG_INPUT_LED2_STATE_ON
value|UINT32_C(0x2)
comment|/* Blink */
define|#
directive|define
name|HWRM_PORT_LED_CFG_INPUT_LED2_STATE_BLINK
value|UINT32_C(0x3)
comment|/* Blink Alternately */
define|#
directive|define
name|HWRM_PORT_LED_CFG_INPUT_LED2_STATE_BLINKALT
value|UINT32_C(0x4)
name|uint8_t
name|led2_color
decl_stmt|;
comment|/* The requested color of LED #2. */
comment|/* Default */
define|#
directive|define
name|HWRM_PORT_LED_CFG_INPUT_LED2_COLOR_DEFAULT
value|UINT32_C(0x0)
comment|/* Amber */
define|#
directive|define
name|HWRM_PORT_LED_CFG_INPUT_LED2_COLOR_AMBER
value|UINT32_C(0x1)
comment|/* Green */
define|#
directive|define
name|HWRM_PORT_LED_CFG_INPUT_LED2_COLOR_GREEN
value|UINT32_C(0x2)
comment|/* Green or Amber */
define|#
directive|define
name|HWRM_PORT_LED_CFG_INPUT_LED2_COLOR_GREENAMBER
value|UINT32_C(0x3)
name|uint8_t
name|unused_2
decl_stmt|;
name|uint16_t
name|led2_blink_on
decl_stmt|;
comment|/* 	 * If the LED #2 state is "blink" or "blinkalt", then this field 	 * represents the requested time in milliseconds to keep LED on between 	 * cycles. 	 */
name|uint16_t
name|led2_blink_off
decl_stmt|;
comment|/* 	 * If the LED #2 state is "blink" or "blinkalt", then this field 	 * represents the requested time in milliseconds to keep LED off between 	 * cycles. 	 */
name|uint8_t
name|led2_group_id
decl_stmt|;
comment|/* 	 * An identifier for the group of LEDs that LED #2 belongs to. If set to 	 * 0, then the LED #2 shall not be grouped and shall be treated as an 	 * individual resource. For all other non-zero values of this field, LED 	 * #2 shall be grouped together with the LEDs with the same group ID 	 * value. 	 */
name|uint8_t
name|rsvd2
decl_stmt|;
comment|/* Reserved field. */
name|uint8_t
name|led3_id
decl_stmt|;
comment|/* An identifier for the LED #3. */
name|uint8_t
name|led3_state
decl_stmt|;
comment|/* The requested state of the LED #3. */
comment|/* Default state of the LED */
define|#
directive|define
name|HWRM_PORT_LED_CFG_INPUT_LED3_STATE_DEFAULT
value|UINT32_C(0x0)
comment|/* Off */
define|#
directive|define
name|HWRM_PORT_LED_CFG_INPUT_LED3_STATE_OFF
value|UINT32_C(0x1)
comment|/* On */
define|#
directive|define
name|HWRM_PORT_LED_CFG_INPUT_LED3_STATE_ON
value|UINT32_C(0x2)
comment|/* Blink */
define|#
directive|define
name|HWRM_PORT_LED_CFG_INPUT_LED3_STATE_BLINK
value|UINT32_C(0x3)
comment|/* Blink Alternately */
define|#
directive|define
name|HWRM_PORT_LED_CFG_INPUT_LED3_STATE_BLINKALT
value|UINT32_C(0x4)
name|uint8_t
name|led3_color
decl_stmt|;
comment|/* The requested color of LED #3. */
comment|/* Default */
define|#
directive|define
name|HWRM_PORT_LED_CFG_INPUT_LED3_COLOR_DEFAULT
value|UINT32_C(0x0)
comment|/* Amber */
define|#
directive|define
name|HWRM_PORT_LED_CFG_INPUT_LED3_COLOR_AMBER
value|UINT32_C(0x1)
comment|/* Green */
define|#
directive|define
name|HWRM_PORT_LED_CFG_INPUT_LED3_COLOR_GREEN
value|UINT32_C(0x2)
comment|/* Green or Amber */
define|#
directive|define
name|HWRM_PORT_LED_CFG_INPUT_LED3_COLOR_GREENAMBER
value|UINT32_C(0x3)
name|uint8_t
name|unused_3
decl_stmt|;
name|uint16_t
name|led3_blink_on
decl_stmt|;
comment|/* 	 * If the LED #3 state is "blink" or "blinkalt", then this field 	 * represents the requested time in milliseconds to keep LED on between 	 * cycles. 	 */
name|uint16_t
name|led3_blink_off
decl_stmt|;
comment|/* 	 * If the LED #3 state is "blink" or "blinkalt", then this field 	 * represents the requested time in milliseconds to keep LED off between 	 * cycles. 	 */
name|uint8_t
name|led3_group_id
decl_stmt|;
comment|/* 	 * An identifier for the group of LEDs that LED #3 belongs to. If set to 	 * 0, then the LED #3 shall not be grouped and shall be treated as an 	 * individual resource. For all other non-zero values of this field, LED 	 * #3 shall be grouped together with the LEDs with the same group ID 	 * value. 	 */
name|uint8_t
name|rsvd3
decl_stmt|;
comment|/* Reserved field. */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_port_led_cfg_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint32_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_port_led_qcfg */
end_comment

begin_comment
comment|/*  * Description: This function is used to query configuration of LEDs on a given  * port. Each port has individual set of LEDs associated with it. These LEDs are  * used for speed/link configuration as well as activity indicator  * configuration. Up to three LEDs can be configured, one for activity and two  * for speeds.  */
end_comment

begin_comment
comment|/* Input (24 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_port_led_qcfg_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint16_t
name|port_id
decl_stmt|;
comment|/* Port ID of port whose LED configuration is being queried. */
name|uint16_t
name|unused_0
index|[
literal|3
index|]
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (56 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_port_led_qcfg_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint8_t
name|num_leds
decl_stmt|;
comment|/* 	 * The number of LEDs that are configured on this port. Up to 4 LEDs can 	 * be returned in the response. 	 */
name|uint8_t
name|led0_id
decl_stmt|;
comment|/* An identifier for the LED #0. */
name|uint8_t
name|led0_type
decl_stmt|;
comment|/* The type of LED #0. */
comment|/* Speed LED */
define|#
directive|define
name|HWRM_PORT_LED_QCFG_OUTPUT_LED0_TYPE_SPEED
value|UINT32_C(0x0)
comment|/* Activity LED */
define|#
directive|define
name|HWRM_PORT_LED_QCFG_OUTPUT_LED0_TYPE_ACTIVITY
value|UINT32_C(0x1)
comment|/* Invalid */
define|#
directive|define
name|HWRM_PORT_LED_QCFG_OUTPUT_LED0_TYPE_INVALID
value|UINT32_C(0xff)
name|uint8_t
name|led0_state
decl_stmt|;
comment|/* The current state of the LED #0. */
comment|/* Default state of the LED */
define|#
directive|define
name|HWRM_PORT_LED_QCFG_OUTPUT_LED0_STATE_DEFAULT
value|UINT32_C(0x0)
comment|/* Off */
define|#
directive|define
name|HWRM_PORT_LED_QCFG_OUTPUT_LED0_STATE_OFF
value|UINT32_C(0x1)
comment|/* On */
define|#
directive|define
name|HWRM_PORT_LED_QCFG_OUTPUT_LED0_STATE_ON
value|UINT32_C(0x2)
comment|/* Blink */
define|#
directive|define
name|HWRM_PORT_LED_QCFG_OUTPUT_LED0_STATE_BLINK
value|UINT32_C(0x3)
comment|/* Blink Alternately */
define|#
directive|define
name|HWRM_PORT_LED_QCFG_OUTPUT_LED0_STATE_BLINKALT
value|UINT32_C(0x4)
name|uint8_t
name|led0_color
decl_stmt|;
comment|/* The color of LED #0. */
comment|/* Default */
define|#
directive|define
name|HWRM_PORT_LED_QCFG_OUTPUT_LED0_COLOR_DEFAULT
value|UINT32_C(0x0)
comment|/* Amber */
define|#
directive|define
name|HWRM_PORT_LED_QCFG_OUTPUT_LED0_COLOR_AMBER
value|UINT32_C(0x1)
comment|/* Green */
define|#
directive|define
name|HWRM_PORT_LED_QCFG_OUTPUT_LED0_COLOR_GREEN
value|UINT32_C(0x2)
comment|/* Green or Amber */
define|#
directive|define
name|HWRM_PORT_LED_QCFG_OUTPUT_LED0_COLOR_GREENAMBER
value|UINT32_C(0x3)
name|uint8_t
name|unused_0
decl_stmt|;
name|uint16_t
name|led0_blink_on
decl_stmt|;
comment|/* 	 * If the LED #0 state is "blink" or "blinkalt", then this field 	 * represents the requested time in milliseconds to keep LED on between 	 * cycles. 	 */
name|uint16_t
name|led0_blink_off
decl_stmt|;
comment|/* 	 * If the LED #0 state is "blink" or "blinkalt", then this field 	 * represents the requested time in milliseconds to keep LED off between 	 * cycles. 	 */
name|uint8_t
name|led0_group_id
decl_stmt|;
comment|/* 	 * An identifier for the group of LEDs that LED #0 belongs to. If set to 	 * 0, then the LED #0 is not grouped. For all other non-zero values of 	 * this field, LED #0 is grouped together with the LEDs with the same 	 * group ID value. 	 */
name|uint8_t
name|led1_id
decl_stmt|;
comment|/* An identifier for the LED #1. */
name|uint8_t
name|led1_type
decl_stmt|;
comment|/* The type of LED #1. */
comment|/* Speed LED */
define|#
directive|define
name|HWRM_PORT_LED_QCFG_OUTPUT_LED1_TYPE_SPEED
value|UINT32_C(0x0)
comment|/* Activity LED */
define|#
directive|define
name|HWRM_PORT_LED_QCFG_OUTPUT_LED1_TYPE_ACTIVITY
value|UINT32_C(0x1)
comment|/* Invalid */
define|#
directive|define
name|HWRM_PORT_LED_QCFG_OUTPUT_LED1_TYPE_INVALID
value|UINT32_C(0xff)
name|uint8_t
name|led1_state
decl_stmt|;
comment|/* The current state of the LED #1. */
comment|/* Default state of the LED */
define|#
directive|define
name|HWRM_PORT_LED_QCFG_OUTPUT_LED1_STATE_DEFAULT
value|UINT32_C(0x0)
comment|/* Off */
define|#
directive|define
name|HWRM_PORT_LED_QCFG_OUTPUT_LED1_STATE_OFF
value|UINT32_C(0x1)
comment|/* On */
define|#
directive|define
name|HWRM_PORT_LED_QCFG_OUTPUT_LED1_STATE_ON
value|UINT32_C(0x2)
comment|/* Blink */
define|#
directive|define
name|HWRM_PORT_LED_QCFG_OUTPUT_LED1_STATE_BLINK
value|UINT32_C(0x3)
comment|/* Blink Alternately */
define|#
directive|define
name|HWRM_PORT_LED_QCFG_OUTPUT_LED1_STATE_BLINKALT
value|UINT32_C(0x4)
name|uint8_t
name|led1_color
decl_stmt|;
comment|/* The color of LED #1. */
comment|/* Default */
define|#
directive|define
name|HWRM_PORT_LED_QCFG_OUTPUT_LED1_COLOR_DEFAULT
value|UINT32_C(0x0)
comment|/* Amber */
define|#
directive|define
name|HWRM_PORT_LED_QCFG_OUTPUT_LED1_COLOR_AMBER
value|UINT32_C(0x1)
comment|/* Green */
define|#
directive|define
name|HWRM_PORT_LED_QCFG_OUTPUT_LED1_COLOR_GREEN
value|UINT32_C(0x2)
comment|/* Green or Amber */
define|#
directive|define
name|HWRM_PORT_LED_QCFG_OUTPUT_LED1_COLOR_GREENAMBER
value|UINT32_C(0x3)
name|uint8_t
name|unused_1
decl_stmt|;
name|uint16_t
name|led1_blink_on
decl_stmt|;
comment|/* 	 * If the LED #1 state is "blink" or "blinkalt", then this field 	 * represents the requested time in milliseconds to keep LED on between 	 * cycles. 	 */
name|uint16_t
name|led1_blink_off
decl_stmt|;
comment|/* 	 * If the LED #1 state is "blink" or "blinkalt", then this field 	 * represents the requested time in milliseconds to keep LED off between 	 * cycles. 	 */
name|uint8_t
name|led1_group_id
decl_stmt|;
comment|/* 	 * An identifier for the group of LEDs that LED #1 belongs to. If set to 	 * 0, then the LED #1 is not grouped. For all other non-zero values of 	 * this field, LED #1 is grouped together with the LEDs with the same 	 * group ID value. 	 */
name|uint8_t
name|led2_id
decl_stmt|;
comment|/* An identifier for the LED #2. */
name|uint8_t
name|led2_type
decl_stmt|;
comment|/* The type of LED #2. */
comment|/* Speed LED */
define|#
directive|define
name|HWRM_PORT_LED_QCFG_OUTPUT_LED2_TYPE_SPEED
value|UINT32_C(0x0)
comment|/* Activity LED */
define|#
directive|define
name|HWRM_PORT_LED_QCFG_OUTPUT_LED2_TYPE_ACTIVITY
value|UINT32_C(0x1)
comment|/* Invalid */
define|#
directive|define
name|HWRM_PORT_LED_QCFG_OUTPUT_LED2_TYPE_INVALID
value|UINT32_C(0xff)
name|uint8_t
name|led2_state
decl_stmt|;
comment|/* The current state of the LED #2. */
comment|/* Default state of the LED */
define|#
directive|define
name|HWRM_PORT_LED_QCFG_OUTPUT_LED2_STATE_DEFAULT
value|UINT32_C(0x0)
comment|/* Off */
define|#
directive|define
name|HWRM_PORT_LED_QCFG_OUTPUT_LED2_STATE_OFF
value|UINT32_C(0x1)
comment|/* On */
define|#
directive|define
name|HWRM_PORT_LED_QCFG_OUTPUT_LED2_STATE_ON
value|UINT32_C(0x2)
comment|/* Blink */
define|#
directive|define
name|HWRM_PORT_LED_QCFG_OUTPUT_LED2_STATE_BLINK
value|UINT32_C(0x3)
comment|/* Blink Alternately */
define|#
directive|define
name|HWRM_PORT_LED_QCFG_OUTPUT_LED2_STATE_BLINKALT
value|UINT32_C(0x4)
name|uint8_t
name|led2_color
decl_stmt|;
comment|/* The color of LED #2. */
comment|/* Default */
define|#
directive|define
name|HWRM_PORT_LED_QCFG_OUTPUT_LED2_COLOR_DEFAULT
value|UINT32_C(0x0)
comment|/* Amber */
define|#
directive|define
name|HWRM_PORT_LED_QCFG_OUTPUT_LED2_COLOR_AMBER
value|UINT32_C(0x1)
comment|/* Green */
define|#
directive|define
name|HWRM_PORT_LED_QCFG_OUTPUT_LED2_COLOR_GREEN
value|UINT32_C(0x2)
comment|/* Green or Amber */
define|#
directive|define
name|HWRM_PORT_LED_QCFG_OUTPUT_LED2_COLOR_GREENAMBER
value|UINT32_C(0x3)
name|uint8_t
name|unused_2
decl_stmt|;
name|uint16_t
name|led2_blink_on
decl_stmt|;
comment|/* 	 * If the LED #2 state is "blink" or "blinkalt", then this field 	 * represents the requested time in milliseconds to keep LED on between 	 * cycles. 	 */
name|uint16_t
name|led2_blink_off
decl_stmt|;
comment|/* 	 * If the LED #2 state is "blink" or "blinkalt", then this field 	 * represents the requested time in milliseconds to keep LED off between 	 * cycles. 	 */
name|uint8_t
name|led2_group_id
decl_stmt|;
comment|/* 	 * An identifier for the group of LEDs that LED #2 belongs to. If set to 	 * 0, then the LED #2 is not grouped. For all other non-zero values of 	 * this field, LED #2 is grouped together with the LEDs with the same 	 * group ID value. 	 */
name|uint8_t
name|led3_id
decl_stmt|;
comment|/* An identifier for the LED #3. */
name|uint8_t
name|led3_type
decl_stmt|;
comment|/* The type of LED #3. */
comment|/* Speed LED */
define|#
directive|define
name|HWRM_PORT_LED_QCFG_OUTPUT_LED3_TYPE_SPEED
value|UINT32_C(0x0)
comment|/* Activity LED */
define|#
directive|define
name|HWRM_PORT_LED_QCFG_OUTPUT_LED3_TYPE_ACTIVITY
value|UINT32_C(0x1)
comment|/* Invalid */
define|#
directive|define
name|HWRM_PORT_LED_QCFG_OUTPUT_LED3_TYPE_INVALID
value|UINT32_C(0xff)
name|uint8_t
name|led3_state
decl_stmt|;
comment|/* The current state of the LED #3. */
comment|/* Default state of the LED */
define|#
directive|define
name|HWRM_PORT_LED_QCFG_OUTPUT_LED3_STATE_DEFAULT
value|UINT32_C(0x0)
comment|/* Off */
define|#
directive|define
name|HWRM_PORT_LED_QCFG_OUTPUT_LED3_STATE_OFF
value|UINT32_C(0x1)
comment|/* On */
define|#
directive|define
name|HWRM_PORT_LED_QCFG_OUTPUT_LED3_STATE_ON
value|UINT32_C(0x2)
comment|/* Blink */
define|#
directive|define
name|HWRM_PORT_LED_QCFG_OUTPUT_LED3_STATE_BLINK
value|UINT32_C(0x3)
comment|/* Blink Alternately */
define|#
directive|define
name|HWRM_PORT_LED_QCFG_OUTPUT_LED3_STATE_BLINKALT
value|UINT32_C(0x4)
name|uint8_t
name|led3_color
decl_stmt|;
comment|/* The color of LED #3. */
comment|/* Default */
define|#
directive|define
name|HWRM_PORT_LED_QCFG_OUTPUT_LED3_COLOR_DEFAULT
value|UINT32_C(0x0)
comment|/* Amber */
define|#
directive|define
name|HWRM_PORT_LED_QCFG_OUTPUT_LED3_COLOR_AMBER
value|UINT32_C(0x1)
comment|/* Green */
define|#
directive|define
name|HWRM_PORT_LED_QCFG_OUTPUT_LED3_COLOR_GREEN
value|UINT32_C(0x2)
comment|/* Green or Amber */
define|#
directive|define
name|HWRM_PORT_LED_QCFG_OUTPUT_LED3_COLOR_GREENAMBER
value|UINT32_C(0x3)
name|uint8_t
name|unused_3
decl_stmt|;
name|uint16_t
name|led3_blink_on
decl_stmt|;
comment|/* 	 * If the LED #3 state is "blink" or "blinkalt", then this field 	 * represents the requested time in milliseconds to keep LED on between 	 * cycles. 	 */
name|uint16_t
name|led3_blink_off
decl_stmt|;
comment|/* 	 * If the LED #3 state is "blink" or "blinkalt", then this field 	 * represents the requested time in milliseconds to keep LED off between 	 * cycles. 	 */
name|uint8_t
name|led3_group_id
decl_stmt|;
comment|/* 	 * An identifier for the group of LEDs that LED #3 belongs to. If set to 	 * 0, then the LED #3 is not grouped. For all other non-zero values of 	 * this field, LED #3 is grouped together with the LEDs with the same 	 * group ID value. 	 */
name|uint8_t
name|unused_4
decl_stmt|;
name|uint16_t
name|unused_5
decl_stmt|;
name|uint8_t
name|unused_6
decl_stmt|;
name|uint8_t
name|unused_7
decl_stmt|;
name|uint8_t
name|unused_8
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_port_led_qcaps */
end_comment

begin_comment
comment|/*  * Description: This function is used to query capabilities of LEDs on a given  * port. Each port has individual set of LEDs associated with it. These LEDs are  * used for speed/link configuration as well as activity indicator  * configuration.  */
end_comment

begin_comment
comment|/* Input (24 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_port_led_qcaps_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint16_t
name|port_id
decl_stmt|;
comment|/* Port ID of port whose LED configuration is being queried. */
name|uint16_t
name|unused_0
index|[
literal|3
index|]
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (48 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_port_led_qcaps_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint8_t
name|num_leds
decl_stmt|;
comment|/* 	 * The number of LEDs that are configured on this port. Up to 4 LEDs can 	 * be returned in the response. 	 */
name|uint8_t
name|unused_0
index|[
literal|3
index|]
decl_stmt|;
comment|/* Reserved for future use. */
name|uint8_t
name|led0_id
decl_stmt|;
comment|/* An identifier for the LED #0. */
name|uint8_t
name|led0_type
decl_stmt|;
comment|/* The type of LED #0. */
comment|/* Speed LED */
define|#
directive|define
name|HWRM_PORT_LED_QCAPS_OUTPUT_LED0_TYPE_SPEED
value|UINT32_C(0x0)
comment|/* Activity LED */
define|#
directive|define
name|HWRM_PORT_LED_QCAPS_OUTPUT_LED0_TYPE_ACTIVITY
value|UINT32_C(0x1)
comment|/* Invalid */
define|#
directive|define
name|HWRM_PORT_LED_QCAPS_OUTPUT_LED0_TYPE_INVALID
value|UINT32_C(0xff)
name|uint8_t
name|led0_group_id
decl_stmt|;
comment|/* 	 * An identifier for the group of LEDs that LED #0 belongs to. If set to 	 * 0, then the LED #0 cannot be grouped. For all other non-zero values 	 * of this field, LED #0 is grouped together with the LEDs with the same 	 * group ID value. 	 */
name|uint8_t
name|unused_1
decl_stmt|;
name|uint16_t
name|led0_state_caps
decl_stmt|;
comment|/* The states supported by LED #0. */
comment|/* If set to 1, this LED is enabled. If set to 0, this LED is disabled. */
define|#
directive|define
name|HWRM_PORT_LED_QCAPS_OUTPUT_LED0_STATE_CAPS_ENABLED
value|UINT32_C(0x1)
comment|/* 	 * If set to 1, off state is supported on this LED. If set to 0, off 	 * state is not supported on this LED. 	 */
define|#
directive|define
name|HWRM_PORT_LED_QCAPS_OUTPUT_LED0_STATE_CAPS_OFF_SUPPORTED
value|UINT32_C(0x2)
comment|/* 	 * If set to 1, on state is supported on this LED. If set to 0, on state 	 * is not supported on this LED. 	 */
define|#
directive|define
name|HWRM_PORT_LED_QCAPS_OUTPUT_LED0_STATE_CAPS_ON_SUPPORTED
value|UINT32_C(0x4)
comment|/* 	 * If set to 1, blink state is supported on this LED. If set to 0, blink 	 * state is not supported on this LED. 	 */
define|#
directive|define
name|HWRM_PORT_LED_QCAPS_OUTPUT_LED0_STATE_CAPS_BLINK_SUPPORTED
value|UINT32_C(0x8)
comment|/* 	 * If set to 1, blink_alt state is supported on this LED. If set to 0, 	 * blink_alt state is not supported on this LED. 	 */
define|#
directive|define
name|HWRM_PORT_LED_QCAPS_OUTPUT_LED0_STATE_CAPS_BLINK_ALT_SUPPORTED
value|UINT32_C(0x10)
name|uint16_t
name|led0_color_caps
decl_stmt|;
comment|/* The colors supported by LED #0. */
comment|/* reserved */
define|#
directive|define
name|HWRM_PORT_LED_QCAPS_OUTPUT_LED0_COLOR_CAPS_RSVD
value|UINT32_C(0x1)
comment|/* 	 * If set to 1, Amber color is supported on this LED. If set to 0, Amber 	 * color is not supported on this LED. 	 */
define|#
directive|define
name|HWRM_PORT_LED_QCAPS_OUTPUT_LED0_COLOR_CAPS_AMBER_SUPPORTED
value|UINT32_C(0x2)
comment|/* 	 * If set to 1, Green color is supported on this LED. If set to 0, Green 	 * color is not supported on this LED. 	 */
define|#
directive|define
name|HWRM_PORT_LED_QCAPS_OUTPUT_LED0_COLOR_CAPS_GREEN_SUPPORTED
value|UINT32_C(0x4)
name|uint8_t
name|led1_id
decl_stmt|;
comment|/* An identifier for the LED #1. */
name|uint8_t
name|led1_type
decl_stmt|;
comment|/* The type of LED #1. */
comment|/* Speed LED */
define|#
directive|define
name|HWRM_PORT_LED_QCAPS_OUTPUT_LED1_TYPE_SPEED
value|UINT32_C(0x0)
comment|/* Activity LED */
define|#
directive|define
name|HWRM_PORT_LED_QCAPS_OUTPUT_LED1_TYPE_ACTIVITY
value|UINT32_C(0x1)
comment|/* Invalid */
define|#
directive|define
name|HWRM_PORT_LED_QCAPS_OUTPUT_LED1_TYPE_INVALID
value|UINT32_C(0xff)
name|uint8_t
name|led1_group_id
decl_stmt|;
comment|/* 	 * An identifier for the group of LEDs that LED #1 belongs to. If set to 	 * 0, then the LED #0 cannot be grouped. For all other non-zero values 	 * of this field, LED #0 is grouped together with the LEDs with the same 	 * group ID value. 	 */
name|uint8_t
name|unused_2
decl_stmt|;
name|uint16_t
name|led1_state_caps
decl_stmt|;
comment|/* The states supported by LED #1. */
comment|/* If set to 1, this LED is enabled. If set to 0, this LED is disabled. */
define|#
directive|define
name|HWRM_PORT_LED_QCAPS_OUTPUT_LED1_STATE_CAPS_ENABLED
value|UINT32_C(0x1)
comment|/* 	 * If set to 1, off state is supported on this LED. If set to 0, off 	 * state is not supported on this LED. 	 */
define|#
directive|define
name|HWRM_PORT_LED_QCAPS_OUTPUT_LED1_STATE_CAPS_OFF_SUPPORTED
value|UINT32_C(0x2)
comment|/* 	 * If set to 1, on state is supported on this LED. If set to 0, on state 	 * is not supported on this LED. 	 */
define|#
directive|define
name|HWRM_PORT_LED_QCAPS_OUTPUT_LED1_STATE_CAPS_ON_SUPPORTED
value|UINT32_C(0x4)
comment|/* 	 * If set to 1, blink state is supported on this LED. If set to 0, blink 	 * state is not supported on this LED. 	 */
define|#
directive|define
name|HWRM_PORT_LED_QCAPS_OUTPUT_LED1_STATE_CAPS_BLINK_SUPPORTED
value|UINT32_C(0x8)
comment|/* 	 * If set to 1, blink_alt state is supported on this LED. If set to 0, 	 * blink_alt state is not supported on this LED. 	 */
define|#
directive|define
name|HWRM_PORT_LED_QCAPS_OUTPUT_LED1_STATE_CAPS_BLINK_ALT_SUPPORTED
value|UINT32_C(0x10)
name|uint16_t
name|led1_color_caps
decl_stmt|;
comment|/* The colors supported by LED #1. */
comment|/* reserved */
define|#
directive|define
name|HWRM_PORT_LED_QCAPS_OUTPUT_LED1_COLOR_CAPS_RSVD
value|UINT32_C(0x1)
comment|/* 	 * If set to 1, Amber color is supported on this LED. If set to 0, Amber 	 * color is not supported on this LED. 	 */
define|#
directive|define
name|HWRM_PORT_LED_QCAPS_OUTPUT_LED1_COLOR_CAPS_AMBER_SUPPORTED
value|UINT32_C(0x2)
comment|/* 	 * If set to 1, Green color is supported on this LED. If set to 0, Green 	 * color is not supported on this LED. 	 */
define|#
directive|define
name|HWRM_PORT_LED_QCAPS_OUTPUT_LED1_COLOR_CAPS_GREEN_SUPPORTED
value|UINT32_C(0x4)
name|uint8_t
name|led2_id
decl_stmt|;
comment|/* An identifier for the LED #2. */
name|uint8_t
name|led2_type
decl_stmt|;
comment|/* The type of LED #2. */
comment|/* Speed LED */
define|#
directive|define
name|HWRM_PORT_LED_QCAPS_OUTPUT_LED2_TYPE_SPEED
value|UINT32_C(0x0)
comment|/* Activity LED */
define|#
directive|define
name|HWRM_PORT_LED_QCAPS_OUTPUT_LED2_TYPE_ACTIVITY
value|UINT32_C(0x1)
comment|/* Invalid */
define|#
directive|define
name|HWRM_PORT_LED_QCAPS_OUTPUT_LED2_TYPE_INVALID
value|UINT32_C(0xff)
name|uint8_t
name|led2_group_id
decl_stmt|;
comment|/* 	 * An identifier for the group of LEDs that LED #0 belongs to. If set to 	 * 0, then the LED #0 cannot be grouped. For all other non-zero values 	 * of this field, LED #0 is grouped together with the LEDs with the same 	 * group ID value. 	 */
name|uint8_t
name|unused_3
decl_stmt|;
name|uint16_t
name|led2_state_caps
decl_stmt|;
comment|/* The states supported by LED #2. */
comment|/* If set to 1, this LED is enabled. If set to 0, this LED is disabled. */
define|#
directive|define
name|HWRM_PORT_LED_QCAPS_OUTPUT_LED2_STATE_CAPS_ENABLED
value|UINT32_C(0x1)
comment|/* 	 * If set to 1, off state is supported on this LED. If set to 0, off 	 * state is not supported on this LED. 	 */
define|#
directive|define
name|HWRM_PORT_LED_QCAPS_OUTPUT_LED2_STATE_CAPS_OFF_SUPPORTED
value|UINT32_C(0x2)
comment|/* 	 * If set to 1, on state is supported on this LED. If set to 0, on state 	 * is not supported on this LED. 	 */
define|#
directive|define
name|HWRM_PORT_LED_QCAPS_OUTPUT_LED2_STATE_CAPS_ON_SUPPORTED
value|UINT32_C(0x4)
comment|/* 	 * If set to 1, blink state is supported on this LED. If set to 0, blink 	 * state is not supported on this LED. 	 */
define|#
directive|define
name|HWRM_PORT_LED_QCAPS_OUTPUT_LED2_STATE_CAPS_BLINK_SUPPORTED
value|UINT32_C(0x8)
comment|/* 	 * If set to 1, blink_alt state is supported on this LED. If set to 0, 	 * blink_alt state is not supported on this LED. 	 */
define|#
directive|define
name|HWRM_PORT_LED_QCAPS_OUTPUT_LED2_STATE_CAPS_BLINK_ALT_SUPPORTED
value|UINT32_C(0x10)
name|uint16_t
name|led2_color_caps
decl_stmt|;
comment|/* The colors supported by LED #2. */
comment|/* reserved */
define|#
directive|define
name|HWRM_PORT_LED_QCAPS_OUTPUT_LED2_COLOR_CAPS_RSVD
value|UINT32_C(0x1)
comment|/* 	 * If set to 1, Amber color is supported on this LED. If set to 0, Amber 	 * color is not supported on this LED. 	 */
define|#
directive|define
name|HWRM_PORT_LED_QCAPS_OUTPUT_LED2_COLOR_CAPS_AMBER_SUPPORTED
value|UINT32_C(0x2)
comment|/* 	 * If set to 1, Green color is supported on this LED. If set to 0, Green 	 * color is not supported on this LED. 	 */
define|#
directive|define
name|HWRM_PORT_LED_QCAPS_OUTPUT_LED2_COLOR_CAPS_GREEN_SUPPORTED
value|UINT32_C(0x4)
name|uint8_t
name|led3_id
decl_stmt|;
comment|/* An identifier for the LED #3. */
name|uint8_t
name|led3_type
decl_stmt|;
comment|/* The type of LED #3. */
comment|/* Speed LED */
define|#
directive|define
name|HWRM_PORT_LED_QCAPS_OUTPUT_LED3_TYPE_SPEED
value|UINT32_C(0x0)
comment|/* Activity LED */
define|#
directive|define
name|HWRM_PORT_LED_QCAPS_OUTPUT_LED3_TYPE_ACTIVITY
value|UINT32_C(0x1)
comment|/* Invalid */
define|#
directive|define
name|HWRM_PORT_LED_QCAPS_OUTPUT_LED3_TYPE_INVALID
value|UINT32_C(0xff)
name|uint8_t
name|led3_group_id
decl_stmt|;
comment|/* 	 * An identifier for the group of LEDs that LED #3 belongs to. If set to 	 * 0, then the LED #0 cannot be grouped. For all other non-zero values 	 * of this field, LED #0 is grouped together with the LEDs with the same 	 * group ID value. 	 */
name|uint8_t
name|unused_4
decl_stmt|;
name|uint16_t
name|led3_state_caps
decl_stmt|;
comment|/* The states supported by LED #3. */
comment|/* If set to 1, this LED is enabled. If set to 0, this LED is disabled. */
define|#
directive|define
name|HWRM_PORT_LED_QCAPS_OUTPUT_LED3_STATE_CAPS_ENABLED
value|UINT32_C(0x1)
comment|/* 	 * If set to 1, off state is supported on this LED. If set to 0, off 	 * state is not supported on this LED. 	 */
define|#
directive|define
name|HWRM_PORT_LED_QCAPS_OUTPUT_LED3_STATE_CAPS_OFF_SUPPORTED
value|UINT32_C(0x2)
comment|/* 	 * If set to 1, on state is supported on this LED. If set to 0, on state 	 * is not supported on this LED. 	 */
define|#
directive|define
name|HWRM_PORT_LED_QCAPS_OUTPUT_LED3_STATE_CAPS_ON_SUPPORTED
value|UINT32_C(0x4)
comment|/* 	 * If set to 1, blink state is supported on this LED. If set to 0, blink 	 * state is not supported on this LED. 	 */
define|#
directive|define
name|HWRM_PORT_LED_QCAPS_OUTPUT_LED3_STATE_CAPS_BLINK_SUPPORTED
value|UINT32_C(0x8)
comment|/* 	 * If set to 1, blink_alt state is supported on this LED. If set to 0, 	 * blink_alt state is not supported on this LED. 	 */
define|#
directive|define
name|HWRM_PORT_LED_QCAPS_OUTPUT_LED3_STATE_CAPS_BLINK_ALT_SUPPORTED
value|UINT32_C(0x10)
name|uint16_t
name|led3_color_caps
decl_stmt|;
comment|/* The colors supported by LED #3. */
comment|/* reserved */
define|#
directive|define
name|HWRM_PORT_LED_QCAPS_OUTPUT_LED3_COLOR_CAPS_RSVD
value|UINT32_C(0x1)
comment|/* 	 * If set to 1, Amber color is supported on this LED. If set to 0, Amber 	 * color is not supported on this LED. 	 */
define|#
directive|define
name|HWRM_PORT_LED_QCAPS_OUTPUT_LED3_COLOR_CAPS_AMBER_SUPPORTED
value|UINT32_C(0x2)
comment|/* 	 * If set to 1, Green color is supported on this LED. If set to 0, Green 	 * color is not supported on this LED. 	 */
define|#
directive|define
name|HWRM_PORT_LED_QCAPS_OUTPUT_LED3_COLOR_CAPS_GREEN_SUPPORTED
value|UINT32_C(0x4)
name|uint8_t
name|unused_5
decl_stmt|;
name|uint8_t
name|unused_6
decl_stmt|;
name|uint8_t
name|unused_7
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_queue_qportcfg */
end_comment

begin_comment
comment|/*  * Description: This function is called by a driver to query queue configuration  * of a port. # The HWRM shall at least advertise one queue with lossy service  * profile. # The driver shall use this command to query queue ids before  * configuring or using any queues. # If a service profile is not set for a  * queue, then the driver shall not use that queue without configuring a service  * profile for it. # If the driver is not allowed to configure service profiles,  * then the driver shall only use queues for which service profiles are pre-  * configured.  */
end_comment

begin_comment
comment|/* Input (24 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_queue_qportcfg_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint32_t
name|flags
decl_stmt|;
comment|/* 	 * Enumeration denoting the RX, TX type of the resource. This 	 * enumeration is used for resources that are similar for both TX and RX 	 * paths of the chip. 	 */
define|#
directive|define
name|HWRM_QUEUE_QPORTCFG_INPUT_FLAGS_PATH
value|UINT32_C(0x1)
comment|/* tx path */
define|#
directive|define
name|HWRM_QUEUE_QPORTCFG_INPUT_FLAGS_PATH_TX
value|UINT32_C(0x0)
comment|/* rx path */
define|#
directive|define
name|HWRM_QUEUE_QPORTCFG_INPUT_FLAGS_PATH_RX
value|UINT32_C(0x1)
define|#
directive|define
name|HWRM_QUEUE_QPORTCFG_INPUT_FLAGS_PATH_LAST
value|HWRM_QUEUE_QPORTCFG_INPUT_FLAGS_PATH_RX
name|uint16_t
name|port_id
decl_stmt|;
comment|/* 	 * Port ID of port for which the queue configuration is being queried. 	 * This field is only required when sent by IPC. 	 */
name|uint16_t
name|unused_0
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (32 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_queue_qportcfg_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint8_t
name|max_configurable_queues
decl_stmt|;
comment|/* 	 * The maximum number of queues that can be configured on this port. 	 * Valid values range from 1 through 8. 	 */
name|uint8_t
name|max_configurable_lossless_queues
decl_stmt|;
comment|/* 	 * The maximum number of lossless queues that can be configured on this 	 * port. Valid values range from 0 through 8. 	 */
name|uint8_t
name|queue_cfg_allowed
decl_stmt|;
comment|/* 	 * Bitmask indicating which queues can be configured by the 	 * hwrm_queue_cfg command. Each bit represents a specific queue where 	 * bit 0 represents queue 0 and bit 7 represents queue 7. # A value of 0 	 * indicates that the queue is not configurable by the hwrm_queue_cfg 	 * command. # A value of 1 indicates that the queue is configurable. # A 	 * hwrm_queue_cfg command shall return error when trying to configure a 	 * queue not configurable. 	 */
name|uint8_t
name|queue_cfg_info
decl_stmt|;
comment|/* Information about queue configuration. */
comment|/* 	 * If this flag is set to '1', then the queues are configured 	 * asymmetrically on TX and RX sides. If this flag is set to '0', then 	 * the queues are configured symmetrically on TX and RX sides. For 	 * symmetric configuration, the queue configuration including queue ids 	 * and service profiles on the TX side is the same as the corresponding 	 * queue configuration on the RX side. 	 */
define|#
directive|define
name|HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_CFG_INFO_ASYM_CFG
value|UINT32_C(0x1)
name|uint8_t
name|queue_pfcenable_cfg_allowed
decl_stmt|;
comment|/* 	 * Bitmask indicating which queues can be configured by the 	 * hwrm_queue_pfcenable_cfg command. Each bit represents a specific 	 * priority where bit 0 represents priority 0 and bit 7 represents 	 * priority 7. # A value of 0 indicates that the priority is not 	 * configurable by the hwrm_queue_pfcenable_cfg command. # A value of 1 	 * indicates that the priority is configurable. # A 	 * hwrm_queue_pfcenable_cfg command shall return error when trying to 	 * configure a priority that is not configurable. 	 */
name|uint8_t
name|queue_pri2cos_cfg_allowed
decl_stmt|;
comment|/* 	 * Bitmask indicating which queues can be configured by the 	 * hwrm_queue_pri2cos_cfg command. Each bit represents a specific queue 	 * where bit 0 represents queue 0 and bit 7 represents queue 7. # A 	 * value of 0 indicates that the queue is not configurable by the 	 * hwrm_queue_pri2cos_cfg command. # A value of 1 indicates that the 	 * queue is configurable. # A hwrm_queue_pri2cos_cfg command shall 	 * return error when trying to configure a queue that is not 	 * configurable. 	 */
name|uint8_t
name|queue_cos2bw_cfg_allowed
decl_stmt|;
comment|/* 	 * Bitmask indicating which queues can be configured by the 	 * hwrm_queue_pri2cos_cfg command. Each bit represents a specific queue 	 * where bit 0 represents queue 0 and bit 7 represents queue 7. # A 	 * value of 0 indicates that the queue is not configurable by the 	 * hwrm_queue_pri2cos_cfg command. # A value of 1 indicates that the 	 * queue is configurable. # A hwrm_queue_pri2cos_cfg command shall 	 * return error when trying to configure a queue not configurable. 	 */
name|uint8_t
name|queue_id0
decl_stmt|;
comment|/* 	 * ID of CoS Queue 0. FF - Invalid id # This ID can be used on any 	 * subsequent call to an hwrm command that takes a queue id. # IDs must 	 * always be queried by this command before any use by the driver or 	 * software. # Any driver or software should not make any assumptions 	 * about queue IDs. # A value of 0xff indicates that the queue is not 	 * available. # Available queues may not be in sequential order. 	 */
name|uint8_t
name|queue_id0_service_profile
decl_stmt|;
comment|/* This value is applicable to CoS queues only. */
comment|/* Lossy (best-effort) */
define|#
directive|define
name|HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID0_SERVICE_PROFILE_LOSSY
value|UINT32_C(0x0)
comment|/* Lossless */
define|#
directive|define
name|HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID0_SERVICE_PROFILE_LOSSLESS
value|UINT32_C(0x1)
comment|/* Set to 0xFF... (All Fs) if there is no service profile specified */
define|#
directive|define
name|HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID0_SERVICE_PROFILE_UNKNOWN
value|UINT32_C(0xff)
name|uint8_t
name|queue_id1
decl_stmt|;
comment|/* 	 * ID of CoS Queue 1. FF - Invalid id # This ID can be used on any 	 * subsequent call to an hwrm command that takes a queue id. # IDs must 	 * always be queried by this command before any use by the driver or 	 * software. # Any driver or software should not make any assumptions 	 * about queue IDs. # A value of 0xff indicates that the queue is not 	 * available. # Available queues may not be in sequential order. 	 */
name|uint8_t
name|queue_id1_service_profile
decl_stmt|;
comment|/* This value is applicable to CoS queues only. */
comment|/* Lossy (best-effort) */
define|#
directive|define
name|HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID1_SERVICE_PROFILE_LOSSY
value|UINT32_C(0x0)
comment|/* Lossless */
define|#
directive|define
name|HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID1_SERVICE_PROFILE_LOSSLESS
value|UINT32_C(0x1)
comment|/* Set to 0xFF... (All Fs) if there is no service profile specified */
define|#
directive|define
name|HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID1_SERVICE_PROFILE_UNKNOWN
value|UINT32_C(0xff)
name|uint8_t
name|queue_id2
decl_stmt|;
comment|/* 	 * ID of CoS Queue 2. FF - Invalid id # This ID can be used on any 	 * subsequent call to an hwrm command that takes a queue id. # IDs must 	 * always be queried by this command before any use by the driver or 	 * software. # Any driver or software should not make any assumptions 	 * about queue IDs. # A value of 0xff indicates that the queue is not 	 * available. # Available queues may not be in sequential order. 	 */
name|uint8_t
name|queue_id2_service_profile
decl_stmt|;
comment|/* This value is applicable to CoS queues only. */
comment|/* Lossy (best-effort) */
define|#
directive|define
name|HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID2_SERVICE_PROFILE_LOSSY
value|UINT32_C(0x0)
comment|/* Lossless */
define|#
directive|define
name|HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID2_SERVICE_PROFILE_LOSSLESS
value|UINT32_C(0x1)
comment|/* Set to 0xFF... (All Fs) if there is no service profile specified */
define|#
directive|define
name|HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID2_SERVICE_PROFILE_UNKNOWN
value|UINT32_C(0xff)
name|uint8_t
name|queue_id3
decl_stmt|;
comment|/* 	 * ID of CoS Queue 3. FF - Invalid id # This ID can be used on any 	 * subsequent call to an hwrm command that takes a queue id. # IDs must 	 * always be queried by this command before any use by the driver or 	 * software. # Any driver or software should not make any assumptions 	 * about queue IDs. # A value of 0xff indicates that the queue is not 	 * available. # Available queues may not be in sequential order. 	 */
name|uint8_t
name|queue_id3_service_profile
decl_stmt|;
comment|/* This value is applicable to CoS queues only. */
comment|/* Lossy (best-effort) */
define|#
directive|define
name|HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID3_SERVICE_PROFILE_LOSSY
value|UINT32_C(0x0)
comment|/* Lossless */
define|#
directive|define
name|HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID3_SERVICE_PROFILE_LOSSLESS
value|UINT32_C(0x1)
comment|/* Set to 0xFF... (All Fs) if there is no service profile specified */
define|#
directive|define
name|HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID3_SERVICE_PROFILE_UNKNOWN
value|UINT32_C(0xff)
name|uint8_t
name|queue_id4
decl_stmt|;
comment|/* 	 * ID of CoS Queue 4. FF - Invalid id # This ID can be used on any 	 * subsequent call to an hwrm command that takes a queue id. # IDs must 	 * always be queried by this command before any use by the driver or 	 * software. # Any driver or software should not make any assumptions 	 * about queue IDs. # A value of 0xff indicates that the queue is not 	 * available. # Available queues may not be in sequential order. 	 */
name|uint8_t
name|queue_id4_service_profile
decl_stmt|;
comment|/* This value is applicable to CoS queues only. */
comment|/* Lossy (best-effort) */
define|#
directive|define
name|HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID4_SERVICE_PROFILE_LOSSY
value|UINT32_C(0x0)
comment|/* Lossless */
define|#
directive|define
name|HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID4_SERVICE_PROFILE_LOSSLESS
value|UINT32_C(0x1)
comment|/* Set to 0xFF... (All Fs) if there is no service profile specified */
define|#
directive|define
name|HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID4_SERVICE_PROFILE_UNKNOWN
value|UINT32_C(0xff)
name|uint8_t
name|queue_id5
decl_stmt|;
comment|/* 	 * ID of CoS Queue 5. FF - Invalid id # This ID can be used on any 	 * subsequent call to an hwrm command that takes a queue id. # IDs must 	 * always be queried by this command before any use by the driver or 	 * software. # Any driver or software should not make any assumptions 	 * about queue IDs. # A value of 0xff indicates that the queue is not 	 * available. # Available queues may not be in sequential order. 	 */
name|uint8_t
name|queue_id5_service_profile
decl_stmt|;
comment|/* This value is applicable to CoS queues only. */
comment|/* Lossy (best-effort) */
define|#
directive|define
name|HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID5_SERVICE_PROFILE_LOSSY
value|UINT32_C(0x0)
comment|/* Lossless */
define|#
directive|define
name|HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID5_SERVICE_PROFILE_LOSSLESS
value|UINT32_C(0x1)
comment|/* Set to 0xFF... (All Fs) if there is no service profile specified */
define|#
directive|define
name|HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID5_SERVICE_PROFILE_UNKNOWN
value|UINT32_C(0xff)
name|uint8_t
name|queue_id6
decl_stmt|;
comment|/* 	 * ID of CoS Queue 6. FF - Invalid id # This ID can be used on any 	 * subsequent call to an hwrm command that takes a queue id. # IDs must 	 * always be queried by this command before any use by the driver or 	 * software. # Any driver or software should not make any assumptions 	 * about queue IDs. # A value of 0xff indicates that the queue is not 	 * available. # Available queues may not be in sequential order. 	 */
name|uint8_t
name|queue_id6_service_profile
decl_stmt|;
comment|/* This value is applicable to CoS queues only. */
comment|/* Lossy (best-effort) */
define|#
directive|define
name|HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID6_SERVICE_PROFILE_LOSSY
value|UINT32_C(0x0)
comment|/* Lossless */
define|#
directive|define
name|HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID6_SERVICE_PROFILE_LOSSLESS
value|UINT32_C(0x1)
comment|/* Set to 0xFF... (All Fs) if there is no service profile specified */
define|#
directive|define
name|HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID6_SERVICE_PROFILE_UNKNOWN
value|UINT32_C(0xff)
name|uint8_t
name|queue_id7
decl_stmt|;
comment|/* 	 * ID of CoS Queue 7. FF - Invalid id # This ID can be used on any 	 * subsequent call to an hwrm command that takes a queue id. # IDs must 	 * always be queried by this command before any use by the driver or 	 * software. # Any driver or software should not make any assumptions 	 * about queue IDs. # A value of 0xff indicates that the queue is not 	 * available. # Available queues may not be in sequential order. 	 */
name|uint8_t
name|queue_id7_service_profile
decl_stmt|;
comment|/* This value is applicable to CoS queues only. */
comment|/* Lossy (best-effort) */
define|#
directive|define
name|HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID7_SERVICE_PROFILE_LOSSY
value|UINT32_C(0x0)
comment|/* Lossless */
define|#
directive|define
name|HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID7_SERVICE_PROFILE_LOSSLESS
value|UINT32_C(0x1)
comment|/* Set to 0xFF... (All Fs) if there is no service profile specified */
define|#
directive|define
name|HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID7_SERVICE_PROFILE_UNKNOWN
value|UINT32_C(0xff)
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_queue_qcfg */
end_comment

begin_comment
comment|/*  * Description: This function is called by a driver to query a queue  * configuration.  */
end_comment

begin_comment
comment|/* Input (24 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_queue_qcfg_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint32_t
name|flags
decl_stmt|;
comment|/* 	 * Enumeration denoting the RX, TX type of the resource. This 	 * enumeration is used for resources that are similar for both TX and RX 	 * paths of the chip. 	 */
define|#
directive|define
name|HWRM_QUEUE_QCFG_INPUT_FLAGS_PATH
value|UINT32_C(0x1)
comment|/* tx path */
define|#
directive|define
name|HWRM_QUEUE_QCFG_INPUT_FLAGS_PATH_TX
value|UINT32_C(0x0)
comment|/* rx path */
define|#
directive|define
name|HWRM_QUEUE_QCFG_INPUT_FLAGS_PATH_RX
value|UINT32_C(0x1)
define|#
directive|define
name|HWRM_QUEUE_QCFG_INPUT_FLAGS_PATH_LAST
value|HWRM_QUEUE_QCFG_INPUT_FLAGS_PATH_RX
name|uint32_t
name|queue_id
decl_stmt|;
comment|/* Queue ID of the queue. */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_queue_qcfg_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint32_t
name|queue_len
decl_stmt|;
comment|/* This value is a the estimate packet length used in the TX arbiter. */
name|uint8_t
name|service_profile
decl_stmt|;
comment|/* This value is applicable to CoS queues only. */
comment|/* Lossy (best-effort) */
define|#
directive|define
name|HWRM_QUEUE_QCFG_OUTPUT_SERVICE_PROFILE_LOSSY
value|UINT32_C(0x0)
comment|/* Lossless */
define|#
directive|define
name|HWRM_QUEUE_QCFG_OUTPUT_SERVICE_PROFILE_LOSSLESS
value|UINT32_C(0x1)
comment|/* Set to 0xFF... (All Fs) if there is no service profile specified */
define|#
directive|define
name|HWRM_QUEUE_QCFG_OUTPUT_SERVICE_PROFILE_UNKNOWN
value|UINT32_C(0xff)
name|uint8_t
name|queue_cfg_info
decl_stmt|;
comment|/* Information about queue configuration. */
comment|/* 	 * If this flag is set to '1', then the queue is configured 	 * asymmetrically on TX and RX sides. If this flag is set to '0', then 	 * this queue is configured symmetrically on TX and RX sides. 	 */
define|#
directive|define
name|HWRM_QUEUE_QCFG_OUTPUT_QUEUE_CFG_INFO_ASYM_CFG
value|UINT32_C(0x1)
name|uint8_t
name|unused_0
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_queue_cfg */
end_comment

begin_comment
comment|/* Description: This function is called by a driver to configure a queue. */
end_comment

begin_comment
comment|/* Input (40 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_queue_cfg_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint32_t
name|flags
decl_stmt|;
comment|/* 	 * Enumeration denoting the RX, TX, or both directions applicable to the 	 * resource. This enumeration is used for resources that are similar for 	 * both TX and RX paths of the chip. 	 */
define|#
directive|define
name|HWRM_QUEUE_CFG_INPUT_FLAGS_PATH_MASK
value|UINT32_C(0x3)
define|#
directive|define
name|HWRM_QUEUE_CFG_INPUT_FLAGS_PATH_SFT
value|0
comment|/* tx path */
define|#
directive|define
name|HWRM_QUEUE_CFG_INPUT_FLAGS_PATH_TX
value|UINT32_C(0x0)
comment|/* rx path */
define|#
directive|define
name|HWRM_QUEUE_CFG_INPUT_FLAGS_PATH_RX
value|UINT32_C(0x1)
comment|/* Bi-directional (Symmetrically applicable to TX and RX paths) */
define|#
directive|define
name|HWRM_QUEUE_CFG_INPUT_FLAGS_PATH_BIDIR
value|UINT32_C(0x2)
define|#
directive|define
name|HWRM_QUEUE_CFG_INPUT_FLAGS_PATH_LAST
value|HWRM_QUEUE_CFG_INPUT_FLAGS_PATH_BIDIR
name|uint32_t
name|enables
decl_stmt|;
comment|/* This bit must be '1' for the dflt_len field to be configured. */
define|#
directive|define
name|HWRM_QUEUE_CFG_INPUT_ENABLES_DFLT_LEN
value|UINT32_C(0x1)
comment|/* This bit must be '1' for the service_profile field to be configured. */
define|#
directive|define
name|HWRM_QUEUE_CFG_INPUT_ENABLES_SERVICE_PROFILE
value|UINT32_C(0x2)
name|uint32_t
name|queue_id
decl_stmt|;
comment|/* Queue ID of queue that is to be configured by this function. */
name|uint32_t
name|dflt_len
decl_stmt|;
comment|/* 	 * This value is a the estimate packet length used in the TX arbiter. 	 * Set to 0xFF... (All Fs) to not adjust this value. 	 */
name|uint8_t
name|service_profile
decl_stmt|;
comment|/* This value is applicable to CoS queues only. */
comment|/* Lossy (best-effort) */
define|#
directive|define
name|HWRM_QUEUE_CFG_INPUT_SERVICE_PROFILE_LOSSY
value|UINT32_C(0x0)
comment|/* Lossless */
define|#
directive|define
name|HWRM_QUEUE_CFG_INPUT_SERVICE_PROFILE_LOSSLESS
value|UINT32_C(0x1)
comment|/* Set to 0xFF... (All Fs) if there is no service profile specified */
define|#
directive|define
name|HWRM_QUEUE_CFG_INPUT_SERVICE_PROFILE_UNKNOWN
value|UINT32_C(0xff)
name|uint8_t
name|unused_0
index|[
literal|7
index|]
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_queue_cfg_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint32_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_queue_pfcenable_qcfg */
end_comment

begin_comment
comment|/*  * Description: This function is called by a driver to query PFC configuration  * for different priorities on that port. This mapping can be different on  * different ports.  */
end_comment

begin_comment
comment|/* Input (24 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_queue_pfcenable_qcfg_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint16_t
name|port_id
decl_stmt|;
comment|/* 	 * Port ID of port for which the table is being configured. The HWRM 	 * needs to check whether this function is allowed to configure pri2cos 	 * mapping on this port. 	 */
name|uint16_t
name|unused_0
index|[
literal|3
index|]
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_queue_pfcenable_qcfg_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint32_t
name|flags
decl_stmt|;
comment|/* If set to 1, then PFC is enabled on PRI 0. */
define|#
directive|define
name|HWRM_QUEUE_PFCENABLE_QCFG_OUTPUT_FLAGS_PRI0_PFC_ENABLED
value|UINT32_C(0x1)
comment|/* If set to 1, then PFC is enabled on PRI 1. */
define|#
directive|define
name|HWRM_QUEUE_PFCENABLE_QCFG_OUTPUT_FLAGS_PRI1_PFC_ENABLED
value|UINT32_C(0x2)
comment|/* If set to 1, then PFC is enabled on PRI 2. */
define|#
directive|define
name|HWRM_QUEUE_PFCENABLE_QCFG_OUTPUT_FLAGS_PRI2_PFC_ENABLED
value|UINT32_C(0x4)
comment|/* If set to 1, then PFC is enabled on PRI 3. */
define|#
directive|define
name|HWRM_QUEUE_PFCENABLE_QCFG_OUTPUT_FLAGS_PRI3_PFC_ENABLED
value|UINT32_C(0x8)
comment|/* If set to 1, then PFC is enabled on PRI 4. */
define|#
directive|define
name|HWRM_QUEUE_PFCENABLE_QCFG_OUTPUT_FLAGS_PRI4_PFC_ENABLED
value|UINT32_C(0x10)
comment|/* If set to 1, then PFC is enabled on PRI 5. */
define|#
directive|define
name|HWRM_QUEUE_PFCENABLE_QCFG_OUTPUT_FLAGS_PRI5_PFC_ENABLED
value|UINT32_C(0x20)
comment|/* If set to 1, then PFC is enabled on PRI 6. */
define|#
directive|define
name|HWRM_QUEUE_PFCENABLE_QCFG_OUTPUT_FLAGS_PRI6_PFC_ENABLED
value|UINT32_C(0x40)
comment|/* If set to 1, then PFC is enabled on PRI 7. */
define|#
directive|define
name|HWRM_QUEUE_PFCENABLE_QCFG_OUTPUT_FLAGS_PRI7_PFC_ENABLED
value|UINT32_C(0x80)
name|uint8_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_queue_pfcenable_cfg */
end_comment

begin_comment
comment|/*  * Description: This function is called by a driver to configure the PFC enabled  * for different priorities on that port. This mapping can be different on  * different ports.  */
end_comment

begin_comment
comment|/* Input (24 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_queue_pfcenable_cfg_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint32_t
name|flags
decl_stmt|;
comment|/* If set to 1, then PFC is requested to be enabled on PRI 0. */
define|#
directive|define
name|HWRM_QUEUE_PFCENABLE_CFG_INPUT_FLAGS_PRI0_PFC_ENABLED
value|UINT32_C(0x1)
comment|/* If set to 1, then PFC is requested to be enabled on PRI 1. */
define|#
directive|define
name|HWRM_QUEUE_PFCENABLE_CFG_INPUT_FLAGS_PRI1_PFC_ENABLED
value|UINT32_C(0x2)
comment|/* If set to 1, then PFC is requested to be enabled on PRI 2. */
define|#
directive|define
name|HWRM_QUEUE_PFCENABLE_CFG_INPUT_FLAGS_PRI2_PFC_ENABLED
value|UINT32_C(0x4)
comment|/* If set to 1, then PFC is requested to be enabled on PRI 3. */
define|#
directive|define
name|HWRM_QUEUE_PFCENABLE_CFG_INPUT_FLAGS_PRI3_PFC_ENABLED
value|UINT32_C(0x8)
comment|/* If set to 1, then PFC is requested to be enabled on PRI 4. */
define|#
directive|define
name|HWRM_QUEUE_PFCENABLE_CFG_INPUT_FLAGS_PRI4_PFC_ENABLED
value|UINT32_C(0x10)
comment|/* If set to 1, then PFC is requested to be enabled on PRI 5. */
define|#
directive|define
name|HWRM_QUEUE_PFCENABLE_CFG_INPUT_FLAGS_PRI5_PFC_ENABLED
value|UINT32_C(0x20)
comment|/* If set to 1, then PFC is requested to be enabled on PRI 6. */
define|#
directive|define
name|HWRM_QUEUE_PFCENABLE_CFG_INPUT_FLAGS_PRI6_PFC_ENABLED
value|UINT32_C(0x40)
comment|/* If set to 1, then PFC is requested to be enabled on PRI 7. */
define|#
directive|define
name|HWRM_QUEUE_PFCENABLE_CFG_INPUT_FLAGS_PRI7_PFC_ENABLED
value|UINT32_C(0x80)
name|uint16_t
name|port_id
decl_stmt|;
comment|/* 	 * Port ID of port for which the table is being configured. The HWRM 	 * needs to check whether this function is allowed to configure pri2cos 	 * mapping on this port. 	 */
name|uint16_t
name|unused_0
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_queue_pfcenable_cfg_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint32_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_queue_pri2cos_qcfg */
end_comment

begin_comment
comment|/*  * Description: This function is called by a driver to query configuration of  * the priority to CoS queue mapping on the transmit side and receive side. This  * mapping can be different in each direction (TX or RX). This mapping can be  * different on different ports. Each CoS queue represents a Traffic Class (TC)  * on that port.  */
end_comment

begin_comment
comment|/* Input (24 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_queue_pri2cos_qcfg_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint32_t
name|flags
decl_stmt|;
comment|/* 	 * Enumeration denoting the RX, TX type of the resource. This 	 * enumeration is used for resources that are similar for both TX and RX 	 * paths of the chip. 	 */
define|#
directive|define
name|HWRM_QUEUE_PRI2COS_QCFG_INPUT_FLAGS_PATH
value|UINT32_C(0x1)
comment|/* tx path */
define|#
directive|define
name|HWRM_QUEUE_PRI2COS_QCFG_INPUT_FLAGS_PATH_TX
value|(UINT32_C(0x0)<< 0)
comment|/* rx path */
define|#
directive|define
name|HWRM_QUEUE_PRI2COS_QCFG_INPUT_FLAGS_PATH_RX
value|(UINT32_C(0x1)<< 0)
define|#
directive|define
name|HWRM_QUEUE_PRI2COS_QCFG_INPUT_FLAGS_PATH_LAST
value|HWRM_QUEUE_PRI2COS_QCFG_INPUT_FLAGS_PATH_RX
comment|/* 	 * When this bit is set to '0', the query is for VLAN PRI field in 	 * tunnel headers. When this bit is set to '1', the query is for VLAN 	 * PRI field in inner packet headers. 	 */
define|#
directive|define
name|HWRM_QUEUE_PRI2COS_QCFG_INPUT_FLAGS_IVLAN
value|UINT32_C(0x2)
name|uint8_t
name|port_id
decl_stmt|;
comment|/* 	 * Port ID of port for which the table is being configured. The HWRM 	 * needs to check whether this function is allowed to configure pri2cos 	 * mapping on this port. 	 */
name|uint8_t
name|unused_0
index|[
literal|3
index|]
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (24 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_queue_pri2cos_qcfg_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint8_t
name|pri0_cos_queue_id
decl_stmt|;
comment|/* 	 * CoS Queue assigned to priority 0. This value can only be changed 	 * before traffic has started. A value of 0xff indicates that no CoS 	 * queue is assigned to the specified priority. 	 */
name|uint8_t
name|pri1_cos_queue_id
decl_stmt|;
comment|/* 	 * CoS Queue assigned to priority 1. This value can only be changed 	 * before traffic has started. A value of 0xff indicates that no CoS 	 * queue is assigned to the specified priority. 	 */
name|uint8_t
name|pri2_cos_queue_id
decl_stmt|;
comment|/* 	 * CoS Queue assigned to priority 2 This value can only be changed 	 * before traffic has started. A value of 0xff indicates that no CoS 	 * queue is assigned to the specified priority. 	 */
name|uint8_t
name|pri3_cos_queue_id
decl_stmt|;
comment|/* 	 * CoS Queue assigned to priority 3. This value can only be changed 	 * before traffic has started. A value of 0xff indicates that no CoS 	 * queue is assigned to the specified priority. 	 */
name|uint8_t
name|pri4_cos_queue_id
decl_stmt|;
comment|/* 	 * CoS Queue assigned to priority 4. This value can only be changed 	 * before traffic has started. A value of 0xff indicates that no CoS 	 * queue is assigned to the specified priority. 	 */
name|uint8_t
name|pri5_cos_queue_id
decl_stmt|;
comment|/* 	 * CoS Queue assigned to priority 5. This value can only be changed 	 * before traffic has started. A value of 0xff indicates that no CoS 	 * queue is assigned to the specified priority. 	 */
name|uint8_t
name|pri6_cos_queue_id
decl_stmt|;
comment|/* 	 * CoS Queue assigned to priority 6. This value can only be changed 	 * before traffic has started. A value of 0xff indicates that no CoS 	 * queue is assigned to the specified priority. 	 */
name|uint8_t
name|pri7_cos_queue_id
decl_stmt|;
comment|/* 	 * CoS Queue assigned to priority 7. This value can only be changed 	 * before traffic has started. A value of 0xff indicates that no CoS 	 * queue is assigned to the specified priority. 	 */
name|uint8_t
name|queue_cfg_info
decl_stmt|;
comment|/* Information about queue configuration. */
comment|/* 	 * If this flag is set to '1', then the PRI to CoS configuration is 	 * asymmetric on TX and RX sides. If this flag is set to '0', then PRI 	 * to CoS configuration is symmetric on TX and RX sides. 	 */
define|#
directive|define
name|HWRM_QUEUE_PRI2COS_QCFG_OUTPUT_QUEUE_CFG_INFO_ASYM_CFG
value|UINT32_C(0x1)
name|uint8_t
name|unused_0
decl_stmt|;
name|uint16_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint8_t
name|unused_4
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_queue_pri2cos_cfg */
end_comment

begin_comment
comment|/*  * Description: This function is called by a driver to configure the priority to  * CoS queue mapping on the transmit side and receive side. This mapping can be  * different in each direction (TX or RX). This mapping can be different on  * different ports. Each CoS queue represents a Traffic Class (TC) on that port.  * This command configures the VLAN PRI-to-TC mapping for a specific port in  * specific direction.  */
end_comment

begin_comment
comment|/* Input (40 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_queue_pri2cos_cfg_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint32_t
name|flags
decl_stmt|;
comment|/* 	 * Enumeration denoting the RX, TX, or both directions applicable to the 	 * resource. This enumeration is used for resources that are similar for 	 * both TX and RX paths of the chip. 	 */
define|#
directive|define
name|HWRM_QUEUE_PRI2COS_CFG_INPUT_FLAGS_PATH_MASK
value|UINT32_C(0x3)
define|#
directive|define
name|HWRM_QUEUE_PRI2COS_CFG_INPUT_FLAGS_PATH_SFT
value|0
comment|/* tx path */
define|#
directive|define
name|HWRM_QUEUE_PRI2COS_CFG_INPUT_FLAGS_PATH_TX
value|(UINT32_C(0x0)<< 0)
comment|/* rx path */
define|#
directive|define
name|HWRM_QUEUE_PRI2COS_CFG_INPUT_FLAGS_PATH_RX
value|(UINT32_C(0x1)<< 0)
comment|/* Bi-directional (Symmetrically applicable to TX and RX paths) */
define|#
directive|define
name|HWRM_QUEUE_PRI2COS_CFG_INPUT_FLAGS_PATH_BIDIR
value|(UINT32_C(0x2)<< 0)
define|#
directive|define
name|HWRM_QUEUE_PRI2COS_CFG_INPUT_FLAGS_PATH_LAST
value|HWRM_QUEUE_PRI2COS_CFG_INPUT_FLAGS_PATH_BIDIR
comment|/* 	 * When this bit is set to '0', the mapping is requested for VLAN PRI 	 * field in tunnel headers. When this bit is set to '1', the mapping is 	 * requested for VLAN PRI field in inner packet headers. 	 */
define|#
directive|define
name|HWRM_QUEUE_PRI2COS_CFG_INPUT_FLAGS_IVLAN
value|UINT32_C(0x4)
name|uint32_t
name|enables
decl_stmt|;
comment|/* 	 * This bit must be '1' for the pri0_cos_queue_id field to be 	 * configured. 	 */
define|#
directive|define
name|HWRM_QUEUE_PRI2COS_CFG_INPUT_ENABLES_PRI0_COS_QUEUE_ID
value|UINT32_C(0x1)
comment|/* 	 * This bit must be '1' for the pri1_cos_queue_id field to be 	 * configured. 	 */
define|#
directive|define
name|HWRM_QUEUE_PRI2COS_CFG_INPUT_ENABLES_PRI1_COS_QUEUE_ID
value|UINT32_C(0x2)
comment|/* 	 * This bit must be '1' for the pri2_cos_queue_id field to be 	 * configured. 	 */
define|#
directive|define
name|HWRM_QUEUE_PRI2COS_CFG_INPUT_ENABLES_PRI2_COS_QUEUE_ID
value|UINT32_C(0x4)
comment|/* 	 * This bit must be '1' for the pri3_cos_queue_id field to be 	 * configured. 	 */
define|#
directive|define
name|HWRM_QUEUE_PRI2COS_CFG_INPUT_ENABLES_PRI3_COS_QUEUE_ID
value|UINT32_C(0x8)
comment|/* 	 * This bit must be '1' for the pri4_cos_queue_id field to be 	 * configured. 	 */
define|#
directive|define
name|HWRM_QUEUE_PRI2COS_CFG_INPUT_ENABLES_PRI4_COS_QUEUE_ID
value|UINT32_C(0x10)
comment|/* 	 * This bit must be '1' for the pri5_cos_queue_id field to be 	 * configured. 	 */
define|#
directive|define
name|HWRM_QUEUE_PRI2COS_CFG_INPUT_ENABLES_PRI5_COS_QUEUE_ID
value|UINT32_C(0x20)
comment|/* 	 * This bit must be '1' for the pri6_cos_queue_id field to be 	 * configured. 	 */
define|#
directive|define
name|HWRM_QUEUE_PRI2COS_CFG_INPUT_ENABLES_PRI6_COS_QUEUE_ID
value|UINT32_C(0x40)
comment|/* 	 * This bit must be '1' for the pri7_cos_queue_id field to be 	 * configured. 	 */
define|#
directive|define
name|HWRM_QUEUE_PRI2COS_CFG_INPUT_ENABLES_PRI7_COS_QUEUE_ID
value|UINT32_C(0x80)
name|uint8_t
name|port_id
decl_stmt|;
comment|/* 	 * Port ID of port for which the table is being configured. The HWRM 	 * needs to check whether this function is allowed to configure pri2cos 	 * mapping on this port. 	 */
name|uint8_t
name|pri0_cos_queue_id
decl_stmt|;
comment|/* 	 * CoS Queue assigned to priority 0. This value can only be changed 	 * before traffic has started. 	 */
name|uint8_t
name|pri1_cos_queue_id
decl_stmt|;
comment|/* 	 * CoS Queue assigned to priority 1. This value can only be changed 	 * before traffic has started. 	 */
name|uint8_t
name|pri2_cos_queue_id
decl_stmt|;
comment|/* 	 * CoS Queue assigned to priority 2 This value can only be changed 	 * before traffic has started. 	 */
name|uint8_t
name|pri3_cos_queue_id
decl_stmt|;
comment|/* 	 * CoS Queue assigned to priority 3. This value can only be changed 	 * before traffic has started. 	 */
name|uint8_t
name|pri4_cos_queue_id
decl_stmt|;
comment|/* 	 * CoS Queue assigned to priority 4. This value can only be changed 	 * before traffic has started. 	 */
name|uint8_t
name|pri5_cos_queue_id
decl_stmt|;
comment|/* 	 * CoS Queue assigned to priority 5. This value can only be changed 	 * before traffic has started. 	 */
name|uint8_t
name|pri6_cos_queue_id
decl_stmt|;
comment|/* 	 * CoS Queue assigned to priority 6. This value can only be changed 	 * before traffic has started. 	 */
name|uint8_t
name|pri7_cos_queue_id
decl_stmt|;
comment|/* 	 * CoS Queue assigned to priority 7. This value can only be changed 	 * before traffic has started. 	 */
name|uint8_t
name|unused_0
index|[
literal|7
index|]
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_queue_pri2cos_cfg_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint32_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_queue_cos2bw_qcfg */
end_comment

begin_comment
comment|/*  * Description: This function is called by a driver to query the BW to CoS queue  * mapping on the transmit side of a specific port. This mapping can be  * different on different ports. Each CoS queue represents a Traffic Class (TC)  * on that port. Each traffic class can be assigned a valid combination of the  * following: - Minimum bandwidth - Maximum bandwidth - Transmission selection  * algorithm (TSA) - Priority Level (only applies to strict priority COS) -  * Bandwidth weight # A CoS can be SP or non-SP: A SP CoS always gets the strict  * priority. Is an COS min BW is set to 0x0 then it is considered to be non-SP;  * this is a valid configuration. Note: SP provides lower latency in addition to  * reserved bandwidth # For both SP CoS and non-SP CoS, min BW can be specified  * to reserve specific amount of the port BW. # The min BW specified for a CoS  * shall not exceed max port bandwidth. # The total of min BWs specified for all  * CoS shall not exceed max port bandwidth. # For any non-SP CoS, the minimum  * bandwidth guarantees are subject to round-robin scheduling. This allows BW  * reservation with anti-starvation; one CoS will not block another CoS using  * RR. Note: The bandwidth guarantees for any non-SP CoS are met after servicing  * all SP CoS. # An SP CoS can potentially starve other lower priority SP CoS  * and non-SP CoS queues. This can occur to the extent the SP min exceeds the  * available port BW. # For any CoS, max BW can be specified to limit the BW  * consumed by the CoS. # The max BW specified for a CoS shall not exceed the  * max port bandwidth. # The WFQ provides a mechanism for sharing available  * bandwidth beyond the reserved minimums configured for each CoS. The WFQ  * scheduler is used to provide the percentages of remaining bandwidth after: *  * first servicing the reserved bandwidth for all SP CoS, * followed by the  * reserved bandwidth for all non-SP CoS * All CoS may participate in the WFQ #  * If a CoS does not have a configured max BW it may use all available bandwidth  * up to the max port bandwidth Minimum Bandwidth (min BW): # This is the  * guaranteed bandwidth for the COS. # A value of 0x0 is valid and it means that  * this COS is not guaranteed any bandwidth. A value of 0xFF.. (all Fs) means  * min BW is not specified. When the min BW is not specified, the HWRM can set  * it to any value it considers appropriate. Note: For a non-SP COS, the HWRM  * should set min BW to 0 when the min BW is not specified. For an SP COS, the  * HWRM should set min BW to some small value when the min BW is not specified.  * Maximum Bandwidth: # This is the bandwidth limit of the COS. # Values 0x0 and  * 0xFF.. (all Fs) are considered unspecified and the HWRM will set the maximum  * bandwidth to maximum port bandwidth. Priority Level: # It applies only to SP.  * # This parameter is ignored for non-SP. # 0-7 are valid values (higher value  * means higher priority) # A priority level can be assigned to at most one SP.  * # Invalid priority levels assignment for SPs shall result in failure.  * Additional notes: # The HWRM may have to use min and (max - min) to set  * appropriate counters of hardware rate limiters. # The bandwidth percentage as  * specified in the DCB TC BW assignment should be used by the driver to specify  * maximum bandwidth and bandwidth weight for a COS. For example, the driver  * should set max BW to 20 Gbps and weight to 50 for two COSs when these two  * COSs are assigned 50% share of 40 Gbps max port bandwidth.  */
end_comment

begin_comment
comment|/* Input (24 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_queue_cos2bw_qcfg_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint16_t
name|port_id
decl_stmt|;
comment|/* 	 * Port ID of port for which the table is being configured. The HWRM 	 * needs to check whether this function is allowed to configure TC BW 	 * assignment on this port. 	 */
name|uint16_t
name|unused_0
index|[
literal|3
index|]
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (112 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_queue_cos2bw_qcfg_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint8_t
name|queue_id0
decl_stmt|;
comment|/* ID of CoS Queue 0. */
name|uint8_t
name|unused_0
decl_stmt|;
name|uint16_t
name|unused_1
decl_stmt|;
name|uint32_t
name|queue_id0_min_bw
decl_stmt|;
comment|/* 	 * Minimum BW allocated to CoS Queue. The HWRM will translate this value 	 * into byte counter and time interval used for this COS inside the 	 * device. 	 */
comment|/* The bandwidth value. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MIN_BW_BW_VALUE_MASK
value|UINT32_C(0xfffffff)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MIN_BW_BW_VALUE_SFT
value|0
comment|/* The granularity of the value (bits or bytes). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MIN_BW_SCALE
value|UINT32_C(0x10000000)
comment|/* Value is in bits. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MIN_BW_SCALE_BITS
value|(UINT32_C(0x0)<< 28)
comment|/* Value is in bytes. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MIN_BW_SCALE_BYTES
value|(UINT32_C(0x1)<< 28)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MIN_BW_SCALE_LAST
value|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MIN_BW_SCALE_BYTES
comment|/* bw_value_unit is 3 b */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MIN_BW_BW_VALUE_UNIT_MASK
value|UINT32_C(0xe0000000)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MIN_BW_BW_VALUE_UNIT_SFT
value|29
comment|/* Value is in Mb or MB (base 10). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MIN_BW_BW_VALUE_UNIT_MEGA
value|(UINT32_C(0x0)<< 29)
comment|/* Value is in Kb or KB (base 10). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MIN_BW_BW_VALUE_UNIT_KILO
value|(UINT32_C(0x2)<< 29)
comment|/* Value is in bits or bytes. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MIN_BW_BW_VALUE_UNIT_BASE
value|(UINT32_C(0x4)<< 29)
comment|/* Value is in Gb or GB (base 10). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MIN_BW_BW_VALUE_UNIT_GIGA
value|(UINT32_C(0x6)<< 29)
comment|/* Value is in 1/100th of a percentage of total bandwidth. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MIN_BW_BW_VALUE_UNIT_PERCENT1_100
value|(UINT32_C(0x1)<< 29)
comment|/* Invalid unit */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MIN_BW_BW_VALUE_UNIT_INVALID
value|(UINT32_C(0x7)<< 29)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MIN_BW_BW_VALUE_UNIT_LAST
value|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MIN_BW_BW_VALUE_UNIT_INVALID
name|uint32_t
name|queue_id0_max_bw
decl_stmt|;
comment|/* 	 * Maximum BW allocated to CoS Queue. The HWRM will translate this value 	 * into byte counter and time interval used for this COS inside the 	 * device. 	 */
comment|/* The bandwidth value. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MAX_BW_BW_VALUE_MASK
value|UINT32_C(0xfffffff)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MAX_BW_BW_VALUE_SFT
value|0
comment|/* The granularity of the value (bits or bytes). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MAX_BW_SCALE
value|UINT32_C(0x10000000)
comment|/* Value is in bits. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MAX_BW_SCALE_BITS
value|(UINT32_C(0x0)<< 28)
comment|/* Value is in bytes. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MAX_BW_SCALE_BYTES
value|(UINT32_C(0x1)<< 28)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MAX_BW_SCALE_LAST
value|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MAX_BW_SCALE_BYTES
comment|/* bw_value_unit is 3 b */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MAX_BW_BW_VALUE_UNIT_MASK
value|UINT32_C(0xe0000000)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MAX_BW_BW_VALUE_UNIT_SFT
value|29
comment|/* Value is in Mb or MB (base 10). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MAX_BW_BW_VALUE_UNIT_MEGA
value|(UINT32_C(0x0)<< 29)
comment|/* Value is in Kb or KB (base 10). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MAX_BW_BW_VALUE_UNIT_KILO
value|(UINT32_C(0x2)<< 29)
comment|/* Value is in bits or bytes. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MAX_BW_BW_VALUE_UNIT_BASE
value|(UINT32_C(0x4)<< 29)
comment|/* Value is in Gb or GB (base 10). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MAX_BW_BW_VALUE_UNIT_GIGA
value|(UINT32_C(0x6)<< 29)
comment|/* Value is in 1/100th of a percentage of total bandwidth. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MAX_BW_BW_VALUE_UNIT_PERCENT1_100
value|(UINT32_C(0x1)<< 29)
comment|/* Invalid unit */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MAX_BW_BW_VALUE_UNIT_INVALID
value|(UINT32_C(0x7)<< 29)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MAX_BW_BW_VALUE_UNIT_LAST
value|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MAX_BW_BW_VALUE_UNIT_INVALID
name|uint8_t
name|queue_id0_tsa_assign
decl_stmt|;
comment|/* Transmission Selection Algorithm (TSA) for CoS Queue. */
comment|/* Strict Priority */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_TSA_ASSIGN_SP
value|UINT32_C(0x0)
comment|/* Enhanced Transmission Selection */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_TSA_ASSIGN_ETS
value|UINT32_C(0x1)
comment|/* reserved */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_TSA_ASSIGN_RESERVED_FIRST
value|UINT32_C(0x2)
comment|/* reserved */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_TSA_ASSIGN_RESERVED_LAST
value|UINT32_C(0xff)
name|uint8_t
name|queue_id0_pri_lvl
decl_stmt|;
comment|/* 	 * Priority level for strict priority. Valid only when the tsa_assign is 	 * 0 - Strict Priority (SP) 0..7 - Valid values. 8..255 - Reserved. 	 */
name|uint8_t
name|queue_id0_bw_weight
decl_stmt|;
comment|/* 	 * Weight used to allocate remaining BW for this COS after servicing 	 * guaranteed bandwidths for all COS. 	 */
name|uint8_t
name|queue_id1
decl_stmt|;
comment|/* ID of CoS Queue 1. */
name|uint32_t
name|queue_id1_min_bw
decl_stmt|;
comment|/* 	 * Minimum BW allocated to CoS Queue. The HWRM will translate this value 	 * into byte counter and time interval used for this COS inside the 	 * device. 	 */
comment|/* The bandwidth value. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MIN_BW_BW_VALUE_MASK
value|UINT32_C(0xfffffff)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MIN_BW_BW_VALUE_SFT
value|0
comment|/* The granularity of the value (bits or bytes). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MIN_BW_SCALE
value|UINT32_C(0x10000000)
comment|/* Value is in bits. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MIN_BW_SCALE_BITS
value|(UINT32_C(0x0)<< 28)
comment|/* Value is in bytes. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MIN_BW_SCALE_BYTES
value|(UINT32_C(0x1)<< 28)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MIN_BW_SCALE_LAST
value|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MIN_BW_SCALE_BYTES
comment|/* bw_value_unit is 3 b */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MIN_BW_BW_VALUE_UNIT_MASK
value|UINT32_C(0xe0000000)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MIN_BW_BW_VALUE_UNIT_SFT
value|29
comment|/* Value is in Mb or MB (base 10). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MIN_BW_BW_VALUE_UNIT_MEGA
value|(UINT32_C(0x0)<< 29)
comment|/* Value is in Kb or KB (base 10). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MIN_BW_BW_VALUE_UNIT_KILO
value|(UINT32_C(0x2)<< 29)
comment|/* Value is in bits or bytes. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MIN_BW_BW_VALUE_UNIT_BASE
value|(UINT32_C(0x4)<< 29)
comment|/* Value is in Gb or GB (base 10). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MIN_BW_BW_VALUE_UNIT_GIGA
value|(UINT32_C(0x6)<< 29)
comment|/* Value is in 1/100th of a percentage of total bandwidth. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MIN_BW_BW_VALUE_UNIT_PERCENT1_100
value|(UINT32_C(0x1)<< 29)
comment|/* Invalid unit */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MIN_BW_BW_VALUE_UNIT_INVALID
value|(UINT32_C(0x7)<< 29)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MIN_BW_BW_VALUE_UNIT_LAST
value|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MIN_BW_BW_VALUE_UNIT_INVALID
name|uint32_t
name|queue_id1_max_bw
decl_stmt|;
comment|/* 	 * Maximum BW allocated to CoS queue. The HWRM will translate this value 	 * into byte counter and time interval used for this COS inside the 	 * device. 	 */
comment|/* The bandwidth value. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MAX_BW_BW_VALUE_MASK
value|UINT32_C(0xfffffff)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MAX_BW_BW_VALUE_SFT
value|0
comment|/* The granularity of the value (bits or bytes). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MAX_BW_SCALE
value|UINT32_C(0x10000000)
comment|/* Value is in bits. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MAX_BW_SCALE_BITS
value|(UINT32_C(0x0)<< 28)
comment|/* Value is in bytes. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MAX_BW_SCALE_BYTES
value|(UINT32_C(0x1)<< 28)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MAX_BW_SCALE_LAST
value|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MAX_BW_SCALE_BYTES
comment|/* bw_value_unit is 3 b */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MAX_BW_BW_VALUE_UNIT_MASK
value|UINT32_C(0xe0000000)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MAX_BW_BW_VALUE_UNIT_SFT
value|29
comment|/* Value is in Mb or MB (base 10). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MAX_BW_BW_VALUE_UNIT_MEGA
value|(UINT32_C(0x0)<< 29)
comment|/* Value is in Kb or KB (base 10). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MAX_BW_BW_VALUE_UNIT_KILO
value|(UINT32_C(0x2)<< 29)
comment|/* Value is in bits or bytes. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MAX_BW_BW_VALUE_UNIT_BASE
value|(UINT32_C(0x4)<< 29)
comment|/* Value is in Gb or GB (base 10). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MAX_BW_BW_VALUE_UNIT_GIGA
value|(UINT32_C(0x6)<< 29)
comment|/* Value is in 1/100th of a percentage of total bandwidth. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MAX_BW_BW_VALUE_UNIT_PERCENT1_100
value|(UINT32_C(0x1)<< 29)
comment|/* Invalid unit */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MAX_BW_BW_VALUE_UNIT_INVALID
value|(UINT32_C(0x7)<< 29)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MAX_BW_BW_VALUE_UNIT_LAST
value|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MAX_BW_BW_VALUE_UNIT_INVALID
name|uint8_t
name|queue_id1_tsa_assign
decl_stmt|;
comment|/* Transmission Selection Algorithm (TSA) for CoS Queue. */
comment|/* Strict Priority */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_TSA_ASSIGN_SP
value|UINT32_C(0x0)
comment|/* Enhanced Transmission Selection */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_TSA_ASSIGN_ETS
value|UINT32_C(0x1)
comment|/* reserved */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_TSA_ASSIGN_RESERVED_FIRST
value|UINT32_C(0x2)
comment|/* reserved */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_TSA_ASSIGN_RESERVED_LAST
value|UINT32_C(0xff)
name|uint8_t
name|queue_id1_pri_lvl
decl_stmt|;
comment|/* 	 * Priority level for strict priority. Valid only when the tsa_assign is 	 * 0 - Strict Priority (SP) 0..7 - Valid values. 8..255 - Reserved. 	 */
name|uint8_t
name|queue_id1_bw_weight
decl_stmt|;
comment|/* 	 * Weight used to allocate remaining BW for this COS after servicing 	 * guaranteed bandwidths for all COS. 	 */
name|uint8_t
name|queue_id2
decl_stmt|;
comment|/* ID of CoS Queue 2. */
name|uint32_t
name|queue_id2_min_bw
decl_stmt|;
comment|/* 	 * Minimum BW allocated to CoS Queue. The HWRM will translate this value 	 * into byte counter and time interval used for this COS inside the 	 * device. 	 */
comment|/* The bandwidth value. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MIN_BW_BW_VALUE_MASK
value|UINT32_C(0xfffffff)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MIN_BW_BW_VALUE_SFT
value|0
comment|/* The granularity of the value (bits or bytes). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MIN_BW_SCALE
value|UINT32_C(0x10000000)
comment|/* Value is in bits. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MIN_BW_SCALE_BITS
value|(UINT32_C(0x0)<< 28)
comment|/* Value is in bytes. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MIN_BW_SCALE_BYTES
value|(UINT32_C(0x1)<< 28)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MIN_BW_SCALE_LAST
value|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MIN_BW_SCALE_BYTES
comment|/* bw_value_unit is 3 b */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MIN_BW_BW_VALUE_UNIT_MASK
value|UINT32_C(0xe0000000)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MIN_BW_BW_VALUE_UNIT_SFT
value|29
comment|/* Value is in Mb or MB (base 10). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MIN_BW_BW_VALUE_UNIT_MEGA
value|(UINT32_C(0x0)<< 29)
comment|/* Value is in Kb or KB (base 10). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MIN_BW_BW_VALUE_UNIT_KILO
value|(UINT32_C(0x2)<< 29)
comment|/* Value is in bits or bytes. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MIN_BW_BW_VALUE_UNIT_BASE
value|(UINT32_C(0x4)<< 29)
comment|/* Value is in Gb or GB (base 10). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MIN_BW_BW_VALUE_UNIT_GIGA
value|(UINT32_C(0x6)<< 29)
comment|/* Value is in 1/100th of a percentage of total bandwidth. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MIN_BW_BW_VALUE_UNIT_PERCENT1_100
value|(UINT32_C(0x1)<< 29)
comment|/* Invalid unit */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MIN_BW_BW_VALUE_UNIT_INVALID
value|(UINT32_C(0x7)<< 29)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MIN_BW_BW_VALUE_UNIT_LAST
value|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MIN_BW_BW_VALUE_UNIT_INVALID
name|uint32_t
name|queue_id2_max_bw
decl_stmt|;
comment|/* 	 * Maximum BW allocated to CoS queue. The HWRM will translate this value 	 * into byte counter and time interval used for this COS inside the 	 * device. 	 */
comment|/* The bandwidth value. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MAX_BW_BW_VALUE_MASK
value|UINT32_C(0xfffffff)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MAX_BW_BW_VALUE_SFT
value|0
comment|/* The granularity of the value (bits or bytes). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MAX_BW_SCALE
value|UINT32_C(0x10000000)
comment|/* Value is in bits. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MAX_BW_SCALE_BITS
value|(UINT32_C(0x0)<< 28)
comment|/* Value is in bytes. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MAX_BW_SCALE_BYTES
value|(UINT32_C(0x1)<< 28)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MAX_BW_SCALE_LAST
value|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MAX_BW_SCALE_BYTES
comment|/* bw_value_unit is 3 b */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MAX_BW_BW_VALUE_UNIT_MASK
value|UINT32_C(0xe0000000)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MAX_BW_BW_VALUE_UNIT_SFT
value|29
comment|/* Value is in Mb or MB (base 10). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MAX_BW_BW_VALUE_UNIT_MEGA
value|(UINT32_C(0x0)<< 29)
comment|/* Value is in Kb or KB (base 10). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MAX_BW_BW_VALUE_UNIT_KILO
value|(UINT32_C(0x2)<< 29)
comment|/* Value is in bits or bytes. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MAX_BW_BW_VALUE_UNIT_BASE
value|(UINT32_C(0x4)<< 29)
comment|/* Value is in Gb or GB (base 10). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MAX_BW_BW_VALUE_UNIT_GIGA
value|(UINT32_C(0x6)<< 29)
comment|/* Value is in 1/100th of a percentage of total bandwidth. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MAX_BW_BW_VALUE_UNIT_PERCENT1_100
value|(UINT32_C(0x1)<< 29)
comment|/* Invalid unit */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MAX_BW_BW_VALUE_UNIT_INVALID
value|(UINT32_C(0x7)<< 29)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MAX_BW_BW_VALUE_UNIT_LAST
value|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MAX_BW_BW_VALUE_UNIT_INVALID
name|uint8_t
name|queue_id2_tsa_assign
decl_stmt|;
comment|/* Transmission Selection Algorithm (TSA) for CoS Queue. */
comment|/* Strict Priority */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_TSA_ASSIGN_SP
value|UINT32_C(0x0)
comment|/* Enhanced Transmission Selection */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_TSA_ASSIGN_ETS
value|UINT32_C(0x1)
comment|/* reserved */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_TSA_ASSIGN_RESERVED_FIRST
value|UINT32_C(0x2)
comment|/* reserved */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_TSA_ASSIGN_RESERVED_LAST
value|UINT32_C(0xff)
name|uint8_t
name|queue_id2_pri_lvl
decl_stmt|;
comment|/* 	 * Priority level for strict priority. Valid only when the tsa_assign is 	 * 0 - Strict Priority (SP) 0..7 - Valid values. 8..255 - Reserved. 	 */
name|uint8_t
name|queue_id2_bw_weight
decl_stmt|;
comment|/* 	 * Weight used to allocate remaining BW for this COS after servicing 	 * guaranteed bandwidths for all COS. 	 */
name|uint8_t
name|queue_id3
decl_stmt|;
comment|/* ID of CoS Queue 3. */
name|uint32_t
name|queue_id3_min_bw
decl_stmt|;
comment|/* 	 * Minimum BW allocated to CoS Queue. The HWRM will translate this value 	 * into byte counter and time interval used for this COS inside the 	 * device. 	 */
comment|/* The bandwidth value. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MIN_BW_BW_VALUE_MASK
value|UINT32_C(0xfffffff)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MIN_BW_BW_VALUE_SFT
value|0
comment|/* The granularity of the value (bits or bytes). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MIN_BW_SCALE
value|UINT32_C(0x10000000)
comment|/* Value is in bits. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MIN_BW_SCALE_BITS
value|(UINT32_C(0x0)<< 28)
comment|/* Value is in bytes. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MIN_BW_SCALE_BYTES
value|(UINT32_C(0x1)<< 28)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MIN_BW_SCALE_LAST
value|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MIN_BW_SCALE_BYTES
comment|/* bw_value_unit is 3 b */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MIN_BW_BW_VALUE_UNIT_MASK
value|UINT32_C(0xe0000000)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MIN_BW_BW_VALUE_UNIT_SFT
value|29
comment|/* Value is in Mb or MB (base 10). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MIN_BW_BW_VALUE_UNIT_MEGA
value|(UINT32_C(0x0)<< 29)
comment|/* Value is in Kb or KB (base 10). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MIN_BW_BW_VALUE_UNIT_KILO
value|(UINT32_C(0x2)<< 29)
comment|/* Value is in bits or bytes. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MIN_BW_BW_VALUE_UNIT_BASE
value|(UINT32_C(0x4)<< 29)
comment|/* Value is in Gb or GB (base 10). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MIN_BW_BW_VALUE_UNIT_GIGA
value|(UINT32_C(0x6)<< 29)
comment|/* Value is in 1/100th of a percentage of total bandwidth. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MIN_BW_BW_VALUE_UNIT_PERCENT1_100
value|(UINT32_C(0x1)<< 29)
comment|/* Invalid unit */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MIN_BW_BW_VALUE_UNIT_INVALID
value|(UINT32_C(0x7)<< 29)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MIN_BW_BW_VALUE_UNIT_LAST
value|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MIN_BW_BW_VALUE_UNIT_INVALID
name|uint32_t
name|queue_id3_max_bw
decl_stmt|;
comment|/* 	 * Maximum BW allocated to CoS queue. The HWRM will translate this value 	 * into byte counter and time interval used for this COS inside the 	 * device. 	 */
comment|/* The bandwidth value. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MAX_BW_BW_VALUE_MASK
value|UINT32_C(0xfffffff)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MAX_BW_BW_VALUE_SFT
value|0
comment|/* The granularity of the value (bits or bytes). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MAX_BW_SCALE
value|UINT32_C(0x10000000)
comment|/* Value is in bits. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MAX_BW_SCALE_BITS
value|(UINT32_C(0x0)<< 28)
comment|/* Value is in bytes. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MAX_BW_SCALE_BYTES
value|(UINT32_C(0x1)<< 28)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MAX_BW_SCALE_LAST
value|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MAX_BW_SCALE_BYTES
comment|/* bw_value_unit is 3 b */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MAX_BW_BW_VALUE_UNIT_MASK
value|UINT32_C(0xe0000000)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MAX_BW_BW_VALUE_UNIT_SFT
value|29
comment|/* Value is in Mb or MB (base 10). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MAX_BW_BW_VALUE_UNIT_MEGA
value|(UINT32_C(0x0)<< 29)
comment|/* Value is in Kb or KB (base 10). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MAX_BW_BW_VALUE_UNIT_KILO
value|(UINT32_C(0x2)<< 29)
comment|/* Value is in bits or bytes. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MAX_BW_BW_VALUE_UNIT_BASE
value|(UINT32_C(0x4)<< 29)
comment|/* Value is in Gb or GB (base 10). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MAX_BW_BW_VALUE_UNIT_GIGA
value|(UINT32_C(0x6)<< 29)
comment|/* Value is in 1/100th of a percentage of total bandwidth. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MAX_BW_BW_VALUE_UNIT_PERCENT1_100
value|(UINT32_C(0x1)<< 29)
comment|/* Invalid unit */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MAX_BW_BW_VALUE_UNIT_INVALID
value|(UINT32_C(0x7)<< 29)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MAX_BW_BW_VALUE_UNIT_LAST
value|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MAX_BW_BW_VALUE_UNIT_INVALID
name|uint8_t
name|queue_id3_tsa_assign
decl_stmt|;
comment|/* Transmission Selection Algorithm (TSA) for CoS Queue. */
comment|/* Strict Priority */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_TSA_ASSIGN_SP
value|UINT32_C(0x0)
comment|/* Enhanced Transmission Selection */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_TSA_ASSIGN_ETS
value|UINT32_C(0x1)
comment|/* reserved */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_TSA_ASSIGN_RESERVED_FIRST
value|UINT32_C(0x2)
comment|/* reserved */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_TSA_ASSIGN_RESERVED_LAST
value|UINT32_C(0xff)
name|uint8_t
name|queue_id3_pri_lvl
decl_stmt|;
comment|/* 	 * Priority level for strict priority. Valid only when the tsa_assign is 	 * 0 - Strict Priority (SP) 0..7 - Valid values. 8..255 - Reserved. 	 */
name|uint8_t
name|queue_id3_bw_weight
decl_stmt|;
comment|/* 	 * Weight used to allocate remaining BW for this COS after servicing 	 * guaranteed bandwidths for all COS. 	 */
name|uint8_t
name|queue_id4
decl_stmt|;
comment|/* ID of CoS Queue 4. */
name|uint32_t
name|queue_id4_min_bw
decl_stmt|;
comment|/* 	 * Minimum BW allocated to CoS Queue. The HWRM will translate this value 	 * into byte counter and time interval used for this COS inside the 	 * device. 	 */
comment|/* The bandwidth value. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MIN_BW_BW_VALUE_MASK
value|UINT32_C(0xfffffff)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MIN_BW_BW_VALUE_SFT
value|0
comment|/* The granularity of the value (bits or bytes). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MIN_BW_SCALE
value|UINT32_C(0x10000000)
comment|/* Value is in bits. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MIN_BW_SCALE_BITS
value|(UINT32_C(0x0)<< 28)
comment|/* Value is in bytes. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MIN_BW_SCALE_BYTES
value|(UINT32_C(0x1)<< 28)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MIN_BW_SCALE_LAST
value|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MIN_BW_SCALE_BYTES
comment|/* bw_value_unit is 3 b */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MIN_BW_BW_VALUE_UNIT_MASK
value|UINT32_C(0xe0000000)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MIN_BW_BW_VALUE_UNIT_SFT
value|29
comment|/* Value is in Mb or MB (base 10). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MIN_BW_BW_VALUE_UNIT_MEGA
value|(UINT32_C(0x0)<< 29)
comment|/* Value is in Kb or KB (base 10). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MIN_BW_BW_VALUE_UNIT_KILO
value|(UINT32_C(0x2)<< 29)
comment|/* Value is in bits or bytes. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MIN_BW_BW_VALUE_UNIT_BASE
value|(UINT32_C(0x4)<< 29)
comment|/* Value is in Gb or GB (base 10). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MIN_BW_BW_VALUE_UNIT_GIGA
value|(UINT32_C(0x6)<< 29)
comment|/* Value is in 1/100th of a percentage of total bandwidth. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MIN_BW_BW_VALUE_UNIT_PERCENT1_100
value|(UINT32_C(0x1)<< 29)
comment|/* Invalid unit */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MIN_BW_BW_VALUE_UNIT_INVALID
value|(UINT32_C(0x7)<< 29)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MIN_BW_BW_VALUE_UNIT_LAST
value|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MIN_BW_BW_VALUE_UNIT_INVALID
name|uint32_t
name|queue_id4_max_bw
decl_stmt|;
comment|/* 	 * Maximum BW allocated to CoS queue. The HWRM will translate this value 	 * into byte counter and time interval used for this COS inside the 	 * device. 	 */
comment|/* The bandwidth value. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MAX_BW_BW_VALUE_MASK
value|UINT32_C(0xfffffff)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MAX_BW_BW_VALUE_SFT
value|0
comment|/* The granularity of the value (bits or bytes). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MAX_BW_SCALE
value|UINT32_C(0x10000000)
comment|/* Value is in bits. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MAX_BW_SCALE_BITS
value|(UINT32_C(0x0)<< 28)
comment|/* Value is in bytes. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MAX_BW_SCALE_BYTES
value|(UINT32_C(0x1)<< 28)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MAX_BW_SCALE_LAST
value|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MAX_BW_SCALE_BYTES
comment|/* bw_value_unit is 3 b */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MAX_BW_BW_VALUE_UNIT_MASK
value|UINT32_C(0xe0000000)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MAX_BW_BW_VALUE_UNIT_SFT
value|29
comment|/* Value is in Mb or MB (base 10). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MAX_BW_BW_VALUE_UNIT_MEGA
value|(UINT32_C(0x0)<< 29)
comment|/* Value is in Kb or KB (base 10). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MAX_BW_BW_VALUE_UNIT_KILO
value|(UINT32_C(0x2)<< 29)
comment|/* Value is in bits or bytes. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MAX_BW_BW_VALUE_UNIT_BASE
value|(UINT32_C(0x4)<< 29)
comment|/* Value is in Gb or GB (base 10). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MAX_BW_BW_VALUE_UNIT_GIGA
value|(UINT32_C(0x6)<< 29)
comment|/* Value is in 1/100th of a percentage of total bandwidth. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MAX_BW_BW_VALUE_UNIT_PERCENT1_100
value|(UINT32_C(0x1)<< 29)
comment|/* Invalid unit */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MAX_BW_BW_VALUE_UNIT_INVALID
value|(UINT32_C(0x7)<< 29)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MAX_BW_BW_VALUE_UNIT_LAST
value|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MAX_BW_BW_VALUE_UNIT_INVALID
name|uint8_t
name|queue_id4_tsa_assign
decl_stmt|;
comment|/* Transmission Selection Algorithm (TSA) for CoS Queue. */
comment|/* Strict Priority */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_TSA_ASSIGN_SP
value|UINT32_C(0x0)
comment|/* Enhanced Transmission Selection */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_TSA_ASSIGN_ETS
value|UINT32_C(0x1)
comment|/* reserved */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_TSA_ASSIGN_RESERVED_FIRST
value|UINT32_C(0x2)
comment|/* reserved */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_TSA_ASSIGN_RESERVED_LAST
value|UINT32_C(0xff)
name|uint8_t
name|queue_id4_pri_lvl
decl_stmt|;
comment|/* 	 * Priority level for strict priority. Valid only when the tsa_assign is 	 * 0 - Strict Priority (SP) 0..7 - Valid values. 8..255 - Reserved. 	 */
name|uint8_t
name|queue_id4_bw_weight
decl_stmt|;
comment|/* 	 * Weight used to allocate remaining BW for this COS after servicing 	 * guaranteed bandwidths for all COS. 	 */
name|uint8_t
name|queue_id5
decl_stmt|;
comment|/* ID of CoS Queue 5. */
name|uint32_t
name|queue_id5_min_bw
decl_stmt|;
comment|/* 	 * Minimum BW allocated to CoS Queue. The HWRM will translate this value 	 * into byte counter and time interval used for this COS inside the 	 * device. 	 */
comment|/* The bandwidth value. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MIN_BW_BW_VALUE_MASK
value|UINT32_C(0xfffffff)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MIN_BW_BW_VALUE_SFT
value|0
comment|/* The granularity of the value (bits or bytes). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MIN_BW_SCALE
value|UINT32_C(0x10000000)
comment|/* Value is in bits. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MIN_BW_SCALE_BITS
value|(UINT32_C(0x0)<< 28)
comment|/* Value is in bytes. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MIN_BW_SCALE_BYTES
value|(UINT32_C(0x1)<< 28)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MIN_BW_SCALE_LAST
value|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MIN_BW_SCALE_BYTES
comment|/* bw_value_unit is 3 b */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MIN_BW_BW_VALUE_UNIT_MASK
value|UINT32_C(0xe0000000)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MIN_BW_BW_VALUE_UNIT_SFT
value|29
comment|/* Value is in Mb or MB (base 10). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MIN_BW_BW_VALUE_UNIT_MEGA
value|(UINT32_C(0x0)<< 29)
comment|/* Value is in Kb or KB (base 10). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MIN_BW_BW_VALUE_UNIT_KILO
value|(UINT32_C(0x2)<< 29)
comment|/* Value is in bits or bytes. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MIN_BW_BW_VALUE_UNIT_BASE
value|(UINT32_C(0x4)<< 29)
comment|/* Value is in Gb or GB (base 10). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MIN_BW_BW_VALUE_UNIT_GIGA
value|(UINT32_C(0x6)<< 29)
comment|/* Value is in 1/100th of a percentage of total bandwidth. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MIN_BW_BW_VALUE_UNIT_PERCENT1_100
value|(UINT32_C(0x1)<< 29)
comment|/* Invalid unit */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MIN_BW_BW_VALUE_UNIT_INVALID
value|(UINT32_C(0x7)<< 29)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MIN_BW_BW_VALUE_UNIT_LAST
value|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MIN_BW_BW_VALUE_UNIT_INVALID
name|uint32_t
name|queue_id5_max_bw
decl_stmt|;
comment|/* 	 * Maximum BW allocated to CoS queue. The HWRM will translate this value 	 * into byte counter and time interval used for this COS inside the 	 * device. 	 */
comment|/* The bandwidth value. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MAX_BW_BW_VALUE_MASK
value|UINT32_C(0xfffffff)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MAX_BW_BW_VALUE_SFT
value|0
comment|/* The granularity of the value (bits or bytes). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MAX_BW_SCALE
value|UINT32_C(0x10000000)
comment|/* Value is in bits. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MAX_BW_SCALE_BITS
value|(UINT32_C(0x0)<< 28)
comment|/* Value is in bytes. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MAX_BW_SCALE_BYTES
value|(UINT32_C(0x1)<< 28)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MAX_BW_SCALE_LAST
value|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MAX_BW_SCALE_BYTES
comment|/* bw_value_unit is 3 b */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MAX_BW_BW_VALUE_UNIT_MASK
value|UINT32_C(0xe0000000)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MAX_BW_BW_VALUE_UNIT_SFT
value|29
comment|/* Value is in Mb or MB (base 10). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MAX_BW_BW_VALUE_UNIT_MEGA
value|(UINT32_C(0x0)<< 29)
comment|/* Value is in Kb or KB (base 10). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MAX_BW_BW_VALUE_UNIT_KILO
value|(UINT32_C(0x2)<< 29)
comment|/* Value is in bits or bytes. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MAX_BW_BW_VALUE_UNIT_BASE
value|(UINT32_C(0x4)<< 29)
comment|/* Value is in Gb or GB (base 10). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MAX_BW_BW_VALUE_UNIT_GIGA
value|(UINT32_C(0x6)<< 29)
comment|/* Value is in 1/100th of a percentage of total bandwidth. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MAX_BW_BW_VALUE_UNIT_PERCENT1_100
value|(UINT32_C(0x1)<< 29)
comment|/* Invalid unit */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MAX_BW_BW_VALUE_UNIT_INVALID
value|(UINT32_C(0x7)<< 29)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MAX_BW_BW_VALUE_UNIT_LAST
value|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MAX_BW_BW_VALUE_UNIT_INVALID
name|uint8_t
name|queue_id5_tsa_assign
decl_stmt|;
comment|/* Transmission Selection Algorithm (TSA) for CoS Queue. */
comment|/* Strict Priority */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_TSA_ASSIGN_SP
value|UINT32_C(0x0)
comment|/* Enhanced Transmission Selection */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_TSA_ASSIGN_ETS
value|UINT32_C(0x1)
comment|/* reserved */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_TSA_ASSIGN_RESERVED_FIRST
value|UINT32_C(0x2)
comment|/* reserved */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_TSA_ASSIGN_RESERVED_LAST
value|UINT32_C(0xff)
name|uint8_t
name|queue_id5_pri_lvl
decl_stmt|;
comment|/* 	 * Priority level for strict priority. Valid only when the tsa_assign is 	 * 0 - Strict Priority (SP) 0..7 - Valid values. 8..255 - Reserved. 	 */
name|uint8_t
name|queue_id5_bw_weight
decl_stmt|;
comment|/* 	 * Weight used to allocate remaining BW for this COS after servicing 	 * guaranteed bandwidths for all COS. 	 */
name|uint8_t
name|queue_id6
decl_stmt|;
comment|/* ID of CoS Queue 6. */
name|uint32_t
name|queue_id6_min_bw
decl_stmt|;
comment|/* 	 * Minimum BW allocated to CoS Queue. The HWRM will translate this value 	 * into byte counter and time interval used for this COS inside the 	 * device. 	 */
comment|/* The bandwidth value. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MIN_BW_BW_VALUE_MASK
value|UINT32_C(0xfffffff)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MIN_BW_BW_VALUE_SFT
value|0
comment|/* The granularity of the value (bits or bytes). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MIN_BW_SCALE
value|UINT32_C(0x10000000)
comment|/* Value is in bits. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MIN_BW_SCALE_BITS
value|(UINT32_C(0x0)<< 28)
comment|/* Value is in bytes. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MIN_BW_SCALE_BYTES
value|(UINT32_C(0x1)<< 28)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MIN_BW_SCALE_LAST
value|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MIN_BW_SCALE_BYTES
comment|/* bw_value_unit is 3 b */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MIN_BW_BW_VALUE_UNIT_MASK
value|UINT32_C(0xe0000000)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MIN_BW_BW_VALUE_UNIT_SFT
value|29
comment|/* Value is in Mb or MB (base 10). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MIN_BW_BW_VALUE_UNIT_MEGA
value|(UINT32_C(0x0)<< 29)
comment|/* Value is in Kb or KB (base 10). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MIN_BW_BW_VALUE_UNIT_KILO
value|(UINT32_C(0x2)<< 29)
comment|/* Value is in bits or bytes. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MIN_BW_BW_VALUE_UNIT_BASE
value|(UINT32_C(0x4)<< 29)
comment|/* Value is in Gb or GB (base 10). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MIN_BW_BW_VALUE_UNIT_GIGA
value|(UINT32_C(0x6)<< 29)
comment|/* Value is in 1/100th of a percentage of total bandwidth. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MIN_BW_BW_VALUE_UNIT_PERCENT1_100
value|(UINT32_C(0x1)<< 29)
comment|/* Invalid unit */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MIN_BW_BW_VALUE_UNIT_INVALID
value|(UINT32_C(0x7)<< 29)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MIN_BW_BW_VALUE_UNIT_LAST
value|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MIN_BW_BW_VALUE_UNIT_INVALID
name|uint32_t
name|queue_id6_max_bw
decl_stmt|;
comment|/* 	 * Maximum BW allocated to CoS queue. The HWRM will translate this value 	 * into byte counter and time interval used for this COS inside the 	 * device. 	 */
comment|/* The bandwidth value. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MAX_BW_BW_VALUE_MASK
value|UINT32_C(0xfffffff)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MAX_BW_BW_VALUE_SFT
value|0
comment|/* The granularity of the value (bits or bytes). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MAX_BW_SCALE
value|UINT32_C(0x10000000)
comment|/* Value is in bits. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MAX_BW_SCALE_BITS
value|(UINT32_C(0x0)<< 28)
comment|/* Value is in bytes. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MAX_BW_SCALE_BYTES
value|(UINT32_C(0x1)<< 28)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MAX_BW_SCALE_LAST
value|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MAX_BW_SCALE_BYTES
comment|/* bw_value_unit is 3 b */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MAX_BW_BW_VALUE_UNIT_MASK
value|UINT32_C(0xe0000000)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MAX_BW_BW_VALUE_UNIT_SFT
value|29
comment|/* Value is in Mb or MB (base 10). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MAX_BW_BW_VALUE_UNIT_MEGA
value|(UINT32_C(0x0)<< 29)
comment|/* Value is in Kb or KB (base 10). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MAX_BW_BW_VALUE_UNIT_KILO
value|(UINT32_C(0x2)<< 29)
comment|/* Value is in bits or bytes. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MAX_BW_BW_VALUE_UNIT_BASE
value|(UINT32_C(0x4)<< 29)
comment|/* Value is in Gb or GB (base 10). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MAX_BW_BW_VALUE_UNIT_GIGA
value|(UINT32_C(0x6)<< 29)
comment|/* Value is in 1/100th of a percentage of total bandwidth. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MAX_BW_BW_VALUE_UNIT_PERCENT1_100
value|(UINT32_C(0x1)<< 29)
comment|/* Invalid unit */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MAX_BW_BW_VALUE_UNIT_INVALID
value|(UINT32_C(0x7)<< 29)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MAX_BW_BW_VALUE_UNIT_LAST
value|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MAX_BW_BW_VALUE_UNIT_INVALID
name|uint8_t
name|queue_id6_tsa_assign
decl_stmt|;
comment|/* Transmission Selection Algorithm (TSA) for CoS Queue. */
comment|/* Strict Priority */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_TSA_ASSIGN_SP
value|UINT32_C(0x0)
comment|/* Enhanced Transmission Selection */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_TSA_ASSIGN_ETS
value|UINT32_C(0x1)
comment|/* reserved */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_TSA_ASSIGN_RESERVED_FIRST
value|UINT32_C(0x2)
comment|/* reserved */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_TSA_ASSIGN_RESERVED_LAST
value|UINT32_C(0xff)
name|uint8_t
name|queue_id6_pri_lvl
decl_stmt|;
comment|/* 	 * Priority level for strict priority. Valid only when the tsa_assign is 	 * 0 - Strict Priority (SP) 0..7 - Valid values. 8..255 - Reserved. 	 */
name|uint8_t
name|queue_id6_bw_weight
decl_stmt|;
comment|/* 	 * Weight used to allocate remaining BW for this COS after servicing 	 * guaranteed bandwidths for all COS. 	 */
name|uint8_t
name|queue_id7
decl_stmt|;
comment|/* ID of CoS Queue 7. */
name|uint32_t
name|queue_id7_min_bw
decl_stmt|;
comment|/* 	 * Minimum BW allocated to CoS Queue. The HWRM will translate this value 	 * into byte counter and time interval used for this COS inside the 	 * device. 	 */
comment|/* The bandwidth value. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MIN_BW_BW_VALUE_MASK
value|UINT32_C(0xfffffff)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MIN_BW_BW_VALUE_SFT
value|0
comment|/* The granularity of the value (bits or bytes). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MIN_BW_SCALE
value|UINT32_C(0x10000000)
comment|/* Value is in bits. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MIN_BW_SCALE_BITS
value|(UINT32_C(0x0)<< 28)
comment|/* Value is in bytes. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MIN_BW_SCALE_BYTES
value|(UINT32_C(0x1)<< 28)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MIN_BW_SCALE_LAST
value|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MIN_BW_SCALE_BYTES
comment|/* bw_value_unit is 3 b */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MIN_BW_BW_VALUE_UNIT_MASK
value|UINT32_C(0xe0000000)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MIN_BW_BW_VALUE_UNIT_SFT
value|29
comment|/* Value is in Mb or MB (base 10). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MIN_BW_BW_VALUE_UNIT_MEGA
value|(UINT32_C(0x0)<< 29)
comment|/* Value is in Kb or KB (base 10). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MIN_BW_BW_VALUE_UNIT_KILO
value|(UINT32_C(0x2)<< 29)
comment|/* Value is in bits or bytes. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MIN_BW_BW_VALUE_UNIT_BASE
value|(UINT32_C(0x4)<< 29)
comment|/* Value is in Gb or GB (base 10). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MIN_BW_BW_VALUE_UNIT_GIGA
value|(UINT32_C(0x6)<< 29)
comment|/* Value is in 1/100th of a percentage of total bandwidth. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MIN_BW_BW_VALUE_UNIT_PERCENT1_100
value|(UINT32_C(0x1)<< 29)
comment|/* Invalid unit */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MIN_BW_BW_VALUE_UNIT_INVALID
value|(UINT32_C(0x7)<< 29)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MIN_BW_BW_VALUE_UNIT_LAST
value|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MIN_BW_BW_VALUE_UNIT_INVALID
name|uint32_t
name|queue_id7_max_bw
decl_stmt|;
comment|/* 	 * Maximum BW allocated to CoS queue. The HWRM will translate this value 	 * into byte counter and time interval used for this COS inside the 	 * device. 	 */
comment|/* The bandwidth value. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MAX_BW_BW_VALUE_MASK
value|UINT32_C(0xfffffff)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MAX_BW_BW_VALUE_SFT
value|0
comment|/* The granularity of the value (bits or bytes). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MAX_BW_SCALE
value|UINT32_C(0x10000000)
comment|/* Value is in bits. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MAX_BW_SCALE_BITS
value|(UINT32_C(0x0)<< 28)
comment|/* Value is in bytes. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MAX_BW_SCALE_BYTES
value|(UINT32_C(0x1)<< 28)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MAX_BW_SCALE_LAST
value|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MAX_BW_SCALE_BYTES
comment|/* bw_value_unit is 3 b */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MAX_BW_BW_VALUE_UNIT_MASK
value|UINT32_C(0xe0000000)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MAX_BW_BW_VALUE_UNIT_SFT
value|29
comment|/* Value is in Mb or MB (base 10). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MAX_BW_BW_VALUE_UNIT_MEGA
value|(UINT32_C(0x0)<< 29)
comment|/* Value is in Kb or KB (base 10). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MAX_BW_BW_VALUE_UNIT_KILO
value|(UINT32_C(0x2)<< 29)
comment|/* Value is in bits or bytes. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MAX_BW_BW_VALUE_UNIT_BASE
value|(UINT32_C(0x4)<< 29)
comment|/* Value is in Gb or GB (base 10). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MAX_BW_BW_VALUE_UNIT_GIGA
value|(UINT32_C(0x6)<< 29)
comment|/* Value is in 1/100th of a percentage of total bandwidth. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MAX_BW_BW_VALUE_UNIT_PERCENT1_100
value|(UINT32_C(0x1)<< 29)
comment|/* Invalid unit */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MAX_BW_BW_VALUE_UNIT_INVALID
value|(UINT32_C(0x7)<< 29)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MAX_BW_BW_VALUE_UNIT_LAST
value|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MAX_BW_BW_VALUE_UNIT_INVALID
name|uint8_t
name|queue_id7_tsa_assign
decl_stmt|;
comment|/* Transmission Selection Algorithm (TSA) for CoS Queue. */
comment|/* Strict Priority */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_TSA_ASSIGN_SP
value|UINT32_C(0x0)
comment|/* Enhanced Transmission Selection */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_TSA_ASSIGN_ETS
value|UINT32_C(0x1)
comment|/* reserved */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_TSA_ASSIGN_RESERVED_FIRST
value|UINT32_C(0x2)
comment|/* reserved */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_TSA_ASSIGN_RESERVED_LAST
value|UINT32_C(0xff)
name|uint8_t
name|queue_id7_pri_lvl
decl_stmt|;
comment|/* 	 * Priority level for strict priority. Valid only when the tsa_assign is 	 * 0 - Strict Priority (SP) 0..7 - Valid values. 8..255 - Reserved. 	 */
name|uint8_t
name|queue_id7_bw_weight
decl_stmt|;
comment|/* 	 * Weight used to allocate remaining BW for this COS after servicing 	 * guaranteed bandwidths for all COS. 	 */
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint8_t
name|unused_4
decl_stmt|;
name|uint8_t
name|unused_5
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_queue_cos2bw_cfg */
end_comment

begin_comment
comment|/*  * Description: This function is called by a driver to configure the BW to CoS  * queue mapping on the transmit side of a specific port. This mapping can be  * different on different ports. Each CoS queue represents a Traffic Class (TC)  * on that port. Each traffic class can be assigned a valid combination of the  * following: - Minimum bandwidth - Maximum bandwidth - Transmission selection  * algorithm (TSA) - Priority Level (only applies to strict priority COS) -  * Bandwidth weight # A CoS can be SP or non-SP: A SP CoS always gets the strict  * priority. Note: SP provides lower latency in addition to reserved bandwidth #  * For non-SP CoS, min BW can be specified to reserve specific amount of the  * port BW. # The min BW specified for a CoS shall not exceed max port  * bandwidth. # The total of min BWs specified for all CoS shall not exceed max  * port bandwidth. # For any non-SP CoS, the minimum bandwidth guarantees are  * subject to round-robin scheduling. This allows BW reservation with anti-  * starvation; one CoS will not block another CoS using RR. Note: The bandwidth  * guarantees for any non-SP CoS are met after servicing all SP CoS. # An SP CoS  * can potentially starve other lower priority SP CoS and non-SP CoS queues.  * This can occur to the extent the SP min exceeds the available port BW. # For  * any CoS, max BW can be specified to limit the BW consumed by the CoS. # A max  * BW can be used for a SP CoS to limit the starvation of other CoS, but using  * this will cause some characteristics of any ETS CoS to be violated. # The max  * BW specified for a CoS shall not exceed the max port bandwidth. # For SP CoS,  * it is recommended to set min and max BW to 0. This instructs the adapter to  * use default values. # The WFQ provides a mechanism for sharing available  * bandwidth beyond the reserved minimums configured for each CoS. The WFQ  * scheduler is used to provide the percentages of remaining bandwidth after: -  * first servicing the reserved bandwidth for all SP CoS, - followed by the  * reserved bandwidth for all non-SP CoS - All CoS may participate in the WFQ #  * If a CoS does not have a configured max BW it may use all available bandwidth  * up to the max port bandwidth Minimum Bandwidth (min BW): # This is the  * guaranteed bandwidth for the COS. # A value of 0x0 is valid and it means that  * this COS is not guaranteed any bandwidth. A value of 0xFF.. (all Fs) means  * min BW is not specified. When the min BW is not specified, the HWRM can set  * it to any value it considers appropriate. Note: For a non-SP COS, the HWRM  * should set min BW to 0 when the min BW is not specified. For an SP COS, min  * BW value is ignored. Maximum Bandwidth: # This is the bandwidth limit of the  * COS. # Values 0x0 and 0xFF.. (all Fs) are considered unspecified and the HWRM  * will set the maximum bandwidth to maximum port bandwidth. Priority Level: #  * It applies only to SP. # This parameter is ignored for non-SP. # 0-7 are  * valid values (higher value means higher priority) # A priority level can be  * assigned to at most one SP. # Invalid priority levels assignment for SPs  * shall result in failure. Additional notes: # The HWRM may have to use min and  * (max - min) to set appropriate counters of hardware rate limiters. # The  * bandwidth percentage as specified in the DCB TC BW assignment should be used  * by the driver to specify minimum bandwidth and bandwidth weight for a COS.  * For example, the driver should set max BW to 20 Gbps and weight to 50 for two  * COSs when these two COSs are assigned 50% share of 40 Gbps max port  * bandwidth. DCBX use cases should always use max BW of 100% for all ETS CoS  * queues.  */
end_comment

begin_comment
comment|/* Input (128 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_queue_cos2bw_cfg_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint32_t
name|flags
decl_stmt|;
name|uint32_t
name|enables
decl_stmt|;
comment|/* 	 * If this bit is set to 1, then all queue_id0 related parameters in 	 * this command are valid. 	 */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_ENABLES_COS_QUEUE_ID0_VALID
value|UINT32_C(0x1)
comment|/* 	 * If this bit is set to 1, then all queue_id1 related parameters in 	 * this command are valid. 	 */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_ENABLES_COS_QUEUE_ID1_VALID
value|UINT32_C(0x2)
comment|/* 	 * If this bit is set to 1, then all queue_id2 related parameters in 	 * this command are valid. 	 */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_ENABLES_COS_QUEUE_ID2_VALID
value|UINT32_C(0x4)
comment|/* 	 * If this bit is set to 1, then all queue_id3 related parameters in 	 * this command are valid. 	 */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_ENABLES_COS_QUEUE_ID3_VALID
value|UINT32_C(0x8)
comment|/* 	 * If this bit is set to 1, then all queue_id4 related parameters in 	 * this command are valid. 	 */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_ENABLES_COS_QUEUE_ID4_VALID
value|UINT32_C(0x10)
comment|/* 	 * If this bit is set to 1, then all queue_id5 related parameters in 	 * this command are valid. 	 */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_ENABLES_COS_QUEUE_ID5_VALID
value|UINT32_C(0x20)
comment|/* 	 * If this bit is set to 1, then all queue_id6 related parameters in 	 * this command are valid. 	 */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_ENABLES_COS_QUEUE_ID6_VALID
value|UINT32_C(0x40)
comment|/* 	 * If this bit is set to 1, then all queue_id7 related parameters in 	 * this command are valid. 	 */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_ENABLES_COS_QUEUE_ID7_VALID
value|UINT32_C(0x80)
name|uint16_t
name|port_id
decl_stmt|;
comment|/* 	 * Port ID of port for which the table is being configured. The HWRM 	 * needs to check whether this function is allowed to configure TC BW 	 * assignment on this port. 	 */
name|uint8_t
name|queue_id0
decl_stmt|;
comment|/* ID of CoS Queue 0. */
name|uint8_t
name|unused_0
decl_stmt|;
name|uint32_t
name|queue_id0_min_bw
decl_stmt|;
comment|/* 	 * Minimum BW allocated to CoS Queue. The HWRM will translate this value 	 * into byte counter and time interval used for this COS inside the 	 * device. 	 */
comment|/* The bandwidth value. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MIN_BW_BW_VALUE_MASK
value|UINT32_C(0xfffffff)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MIN_BW_BW_VALUE_SFT
value|0
comment|/* The granularity of the value (bits or bytes). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MIN_BW_SCALE
value|UINT32_C(0x10000000)
comment|/* Value is in bits. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MIN_BW_SCALE_BITS
value|(UINT32_C(0x0)<< 28)
comment|/* Value is in bytes. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MIN_BW_SCALE_BYTES
value|(UINT32_C(0x1)<< 28)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MIN_BW_SCALE_LAST
value|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MIN_BW_SCALE_BYTES
comment|/* bw_value_unit is 3 b */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MIN_BW_BW_VALUE_UNIT_MASK
value|UINT32_C(0xe0000000)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MIN_BW_BW_VALUE_UNIT_SFT
value|29
comment|/* Value is in Mb or MB (base 10). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MIN_BW_BW_VALUE_UNIT_MEGA
value|(UINT32_C(0x0)<< 29)
comment|/* Value is in Kb or KB (base 10). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MIN_BW_BW_VALUE_UNIT_KILO
value|(UINT32_C(0x2)<< 29)
comment|/* Value is in bits or bytes. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MIN_BW_BW_VALUE_UNIT_BASE
value|(UINT32_C(0x4)<< 29)
comment|/* Value is in Gb or GB (base 10). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MIN_BW_BW_VALUE_UNIT_GIGA
value|(UINT32_C(0x6)<< 29)
comment|/* Value is in 1/100th of a percentage of total bandwidth. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MIN_BW_BW_VALUE_UNIT_PERCENT1_100
value|(UINT32_C(0x1)<< 29)
comment|/* Invalid unit */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MIN_BW_BW_VALUE_UNIT_INVALID
value|(UINT32_C(0x7)<< 29)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MIN_BW_BW_VALUE_UNIT_LAST
value|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MIN_BW_BW_VALUE_UNIT_INVALID
name|uint32_t
name|queue_id0_max_bw
decl_stmt|;
comment|/* 	 * Maximum BW allocated to CoS Queue. The HWRM will translate this value 	 * into byte counter and time interval used for this COS inside the 	 * device. 	 */
comment|/* The bandwidth value. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MAX_BW_BW_VALUE_MASK
value|UINT32_C(0xfffffff)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MAX_BW_BW_VALUE_SFT
value|0
comment|/* The granularity of the value (bits or bytes). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MAX_BW_SCALE
value|UINT32_C(0x10000000)
comment|/* Value is in bits. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MAX_BW_SCALE_BITS
value|(UINT32_C(0x0)<< 28)
comment|/* Value is in bytes. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MAX_BW_SCALE_BYTES
value|(UINT32_C(0x1)<< 28)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MAX_BW_SCALE_LAST
value|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MAX_BW_SCALE_BYTES
comment|/* bw_value_unit is 3 b */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MAX_BW_BW_VALUE_UNIT_MASK
value|UINT32_C(0xe0000000)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MAX_BW_BW_VALUE_UNIT_SFT
value|29
comment|/* Value is in Mb or MB (base 10). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MAX_BW_BW_VALUE_UNIT_MEGA
value|(UINT32_C(0x0)<< 29)
comment|/* Value is in Kb or KB (base 10). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MAX_BW_BW_VALUE_UNIT_KILO
value|(UINT32_C(0x2)<< 29)
comment|/* Value is in bits or bytes. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MAX_BW_BW_VALUE_UNIT_BASE
value|(UINT32_C(0x4)<< 29)
comment|/* Value is in Gb or GB (base 10). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MAX_BW_BW_VALUE_UNIT_GIGA
value|(UINT32_C(0x6)<< 29)
comment|/* Value is in 1/100th of a percentage of total bandwidth. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MAX_BW_BW_VALUE_UNIT_PERCENT1_100
value|(UINT32_C(0x1)<< 29)
comment|/* Invalid unit */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MAX_BW_BW_VALUE_UNIT_INVALID
value|(UINT32_C(0x7)<< 29)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MAX_BW_BW_VALUE_UNIT_LAST
value|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MAX_BW_BW_VALUE_UNIT_INVALID
name|uint8_t
name|queue_id0_tsa_assign
decl_stmt|;
comment|/* Transmission Selection Algorithm (TSA) for CoS Queue. */
comment|/* Strict Priority */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_TSA_ASSIGN_SP
value|UINT32_C(0x0)
comment|/* Enhanced Transmission Selection */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_TSA_ASSIGN_ETS
value|UINT32_C(0x1)
comment|/* reserved */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_TSA_ASSIGN_RESERVED_FIRST
value|UINT32_C(0x2)
comment|/* reserved */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_TSA_ASSIGN_RESERVED_LAST
value|UINT32_C(0xff)
name|uint8_t
name|queue_id0_pri_lvl
decl_stmt|;
comment|/* 	 * Priority level for strict priority. Valid only when the tsa_assign is 	 * 0 - Strict Priority (SP) 0..7 - Valid values. 8..255 - Reserved. 	 */
name|uint8_t
name|queue_id0_bw_weight
decl_stmt|;
comment|/* 	 * Weight used to allocate remaining BW for this COS after servicing 	 * guaranteed bandwidths for all COS. 	 */
name|uint8_t
name|queue_id1
decl_stmt|;
comment|/* ID of CoS Queue 1. */
name|uint32_t
name|queue_id1_min_bw
decl_stmt|;
comment|/* 	 * Minimum BW allocated to CoS Queue. The HWRM will translate this value 	 * into byte counter and time interval used for this COS inside the 	 * device. 	 */
comment|/* The bandwidth value. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MIN_BW_BW_VALUE_MASK
value|UINT32_C(0xfffffff)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MIN_BW_BW_VALUE_SFT
value|0
comment|/* The granularity of the value (bits or bytes). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MIN_BW_SCALE
value|UINT32_C(0x10000000)
comment|/* Value is in bits. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MIN_BW_SCALE_BITS
value|(UINT32_C(0x0)<< 28)
comment|/* Value is in bytes. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MIN_BW_SCALE_BYTES
value|(UINT32_C(0x1)<< 28)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MIN_BW_SCALE_LAST
value|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MIN_BW_SCALE_BYTES
comment|/* bw_value_unit is 3 b */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MIN_BW_BW_VALUE_UNIT_MASK
value|UINT32_C(0xe0000000)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MIN_BW_BW_VALUE_UNIT_SFT
value|29
comment|/* Value is in Mb or MB (base 10). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MIN_BW_BW_VALUE_UNIT_MEGA
value|(UINT32_C(0x0)<< 29)
comment|/* Value is in Kb or KB (base 10). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MIN_BW_BW_VALUE_UNIT_KILO
value|(UINT32_C(0x2)<< 29)
comment|/* Value is in bits or bytes. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MIN_BW_BW_VALUE_UNIT_BASE
value|(UINT32_C(0x4)<< 29)
comment|/* Value is in Gb or GB (base 10). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MIN_BW_BW_VALUE_UNIT_GIGA
value|(UINT32_C(0x6)<< 29)
comment|/* Value is in 1/100th of a percentage of total bandwidth. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MIN_BW_BW_VALUE_UNIT_PERCENT1_100
value|(UINT32_C(0x1)<< 29)
comment|/* Invalid unit */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MIN_BW_BW_VALUE_UNIT_INVALID
value|(UINT32_C(0x7)<< 29)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MIN_BW_BW_VALUE_UNIT_LAST
value|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MIN_BW_BW_VALUE_UNIT_INVALID
name|uint32_t
name|queue_id1_max_bw
decl_stmt|;
comment|/* 	 * Maximum BW allocated to CoS queue. The HWRM will translate this value 	 * into byte counter and time interval used for this COS inside the 	 * device. 	 */
comment|/* The bandwidth value. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MAX_BW_BW_VALUE_MASK
value|UINT32_C(0xfffffff)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MAX_BW_BW_VALUE_SFT
value|0
comment|/* The granularity of the value (bits or bytes). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MAX_BW_SCALE
value|UINT32_C(0x10000000)
comment|/* Value is in bits. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MAX_BW_SCALE_BITS
value|(UINT32_C(0x0)<< 28)
comment|/* Value is in bytes. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MAX_BW_SCALE_BYTES
value|(UINT32_C(0x1)<< 28)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MAX_BW_SCALE_LAST
value|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MAX_BW_SCALE_BYTES
comment|/* bw_value_unit is 3 b */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MAX_BW_BW_VALUE_UNIT_MASK
value|UINT32_C(0xe0000000)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MAX_BW_BW_VALUE_UNIT_SFT
value|29
comment|/* Value is in Mb or MB (base 10). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MAX_BW_BW_VALUE_UNIT_MEGA
value|(UINT32_C(0x0)<< 29)
comment|/* Value is in Kb or KB (base 10). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MAX_BW_BW_VALUE_UNIT_KILO
value|(UINT32_C(0x2)<< 29)
comment|/* Value is in bits or bytes. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MAX_BW_BW_VALUE_UNIT_BASE
value|(UINT32_C(0x4)<< 29)
comment|/* Value is in Gb or GB (base 10). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MAX_BW_BW_VALUE_UNIT_GIGA
value|(UINT32_C(0x6)<< 29)
comment|/* Value is in 1/100th of a percentage of total bandwidth. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MAX_BW_BW_VALUE_UNIT_PERCENT1_100
value|(UINT32_C(0x1)<< 29)
comment|/* Invalid unit */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MAX_BW_BW_VALUE_UNIT_INVALID
value|(UINT32_C(0x7)<< 29)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MAX_BW_BW_VALUE_UNIT_LAST
value|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MAX_BW_BW_VALUE_UNIT_INVALID
name|uint8_t
name|queue_id1_tsa_assign
decl_stmt|;
comment|/* Transmission Selection Algorithm (TSA) for CoS Queue. */
comment|/* Strict Priority */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_TSA_ASSIGN_SP
value|UINT32_C(0x0)
comment|/* Enhanced Transmission Selection */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_TSA_ASSIGN_ETS
value|UINT32_C(0x1)
comment|/* reserved */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_TSA_ASSIGN_RESERVED_FIRST
value|UINT32_C(0x2)
comment|/* reserved */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_TSA_ASSIGN_RESERVED_LAST
value|UINT32_C(0xff)
name|uint8_t
name|queue_id1_pri_lvl
decl_stmt|;
comment|/* 	 * Priority level for strict priority. Valid only when the tsa_assign is 	 * 0 - Strict Priority (SP) 0..7 - Valid values. 8..255 - Reserved. 	 */
name|uint8_t
name|queue_id1_bw_weight
decl_stmt|;
comment|/* 	 * Weight used to allocate remaining BW for this COS after servicing 	 * guaranteed bandwidths for all COS. 	 */
name|uint8_t
name|queue_id2
decl_stmt|;
comment|/* ID of CoS Queue 2. */
name|uint32_t
name|queue_id2_min_bw
decl_stmt|;
comment|/* 	 * Minimum BW allocated to CoS Queue. The HWRM will translate this value 	 * into byte counter and time interval used for this COS inside the 	 * device. 	 */
comment|/* The bandwidth value. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MIN_BW_BW_VALUE_MASK
value|UINT32_C(0xfffffff)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MIN_BW_BW_VALUE_SFT
value|0
comment|/* The granularity of the value (bits or bytes). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MIN_BW_SCALE
value|UINT32_C(0x10000000)
comment|/* Value is in bits. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MIN_BW_SCALE_BITS
value|(UINT32_C(0x0)<< 28)
comment|/* Value is in bytes. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MIN_BW_SCALE_BYTES
value|(UINT32_C(0x1)<< 28)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MIN_BW_SCALE_LAST
value|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MIN_BW_SCALE_BYTES
comment|/* bw_value_unit is 3 b */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MIN_BW_BW_VALUE_UNIT_MASK
value|UINT32_C(0xe0000000)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MIN_BW_BW_VALUE_UNIT_SFT
value|29
comment|/* Value is in Mb or MB (base 10). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MIN_BW_BW_VALUE_UNIT_MEGA
value|(UINT32_C(0x0)<< 29)
comment|/* Value is in Kb or KB (base 10). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MIN_BW_BW_VALUE_UNIT_KILO
value|(UINT32_C(0x2)<< 29)
comment|/* Value is in bits or bytes. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MIN_BW_BW_VALUE_UNIT_BASE
value|(UINT32_C(0x4)<< 29)
comment|/* Value is in Gb or GB (base 10). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MIN_BW_BW_VALUE_UNIT_GIGA
value|(UINT32_C(0x6)<< 29)
comment|/* Value is in 1/100th of a percentage of total bandwidth. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MIN_BW_BW_VALUE_UNIT_PERCENT1_100
value|(UINT32_C(0x1)<< 29)
comment|/* Invalid unit */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MIN_BW_BW_VALUE_UNIT_INVALID
value|(UINT32_C(0x7)<< 29)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MIN_BW_BW_VALUE_UNIT_LAST
value|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MIN_BW_BW_VALUE_UNIT_INVALID
name|uint32_t
name|queue_id2_max_bw
decl_stmt|;
comment|/* 	 * Maximum BW allocated to CoS queue. The HWRM will translate this value 	 * into byte counter and time interval used for this COS inside the 	 * device. 	 */
comment|/* The bandwidth value. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MAX_BW_BW_VALUE_MASK
value|UINT32_C(0xfffffff)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MAX_BW_BW_VALUE_SFT
value|0
comment|/* The granularity of the value (bits or bytes). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MAX_BW_SCALE
value|UINT32_C(0x10000000)
comment|/* Value is in bits. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MAX_BW_SCALE_BITS
value|(UINT32_C(0x0)<< 28)
comment|/* Value is in bytes. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MAX_BW_SCALE_BYTES
value|(UINT32_C(0x1)<< 28)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MAX_BW_SCALE_LAST
value|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MAX_BW_SCALE_BYTES
comment|/* bw_value_unit is 3 b */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MAX_BW_BW_VALUE_UNIT_MASK
value|UINT32_C(0xe0000000)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MAX_BW_BW_VALUE_UNIT_SFT
value|29
comment|/* Value is in Mb or MB (base 10). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MAX_BW_BW_VALUE_UNIT_MEGA
value|(UINT32_C(0x0)<< 29)
comment|/* Value is in Kb or KB (base 10). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MAX_BW_BW_VALUE_UNIT_KILO
value|(UINT32_C(0x2)<< 29)
comment|/* Value is in bits or bytes. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MAX_BW_BW_VALUE_UNIT_BASE
value|(UINT32_C(0x4)<< 29)
comment|/* Value is in Gb or GB (base 10). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MAX_BW_BW_VALUE_UNIT_GIGA
value|(UINT32_C(0x6)<< 29)
comment|/* Value is in 1/100th of a percentage of total bandwidth. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MAX_BW_BW_VALUE_UNIT_PERCENT1_100
value|(UINT32_C(0x1)<< 29)
comment|/* Invalid unit */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MAX_BW_BW_VALUE_UNIT_INVALID
value|(UINT32_C(0x7)<< 29)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MAX_BW_BW_VALUE_UNIT_LAST
value|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MAX_BW_BW_VALUE_UNIT_INVALID
name|uint8_t
name|queue_id2_tsa_assign
decl_stmt|;
comment|/* Transmission Selection Algorithm (TSA) for CoS Queue. */
comment|/* Strict Priority */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_TSA_ASSIGN_SP
value|UINT32_C(0x0)
comment|/* Enhanced Transmission Selection */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_TSA_ASSIGN_ETS
value|UINT32_C(0x1)
comment|/* reserved */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_TSA_ASSIGN_RESERVED_FIRST
value|UINT32_C(0x2)
comment|/* reserved */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_TSA_ASSIGN_RESERVED_LAST
value|UINT32_C(0xff)
name|uint8_t
name|queue_id2_pri_lvl
decl_stmt|;
comment|/* 	 * Priority level for strict priority. Valid only when the tsa_assign is 	 * 0 - Strict Priority (SP) 0..7 - Valid values. 8..255 - Reserved. 	 */
name|uint8_t
name|queue_id2_bw_weight
decl_stmt|;
comment|/* 	 * Weight used to allocate remaining BW for this COS after servicing 	 * guaranteed bandwidths for all COS. 	 */
name|uint8_t
name|queue_id3
decl_stmt|;
comment|/* ID of CoS Queue 3. */
name|uint32_t
name|queue_id3_min_bw
decl_stmt|;
comment|/* 	 * Minimum BW allocated to CoS Queue. The HWRM will translate this value 	 * into byte counter and time interval used for this COS inside the 	 * device. 	 */
comment|/* The bandwidth value. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MIN_BW_BW_VALUE_MASK
value|UINT32_C(0xfffffff)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MIN_BW_BW_VALUE_SFT
value|0
comment|/* The granularity of the value (bits or bytes). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MIN_BW_SCALE
value|UINT32_C(0x10000000)
comment|/* Value is in bits. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MIN_BW_SCALE_BITS
value|(UINT32_C(0x0)<< 28)
comment|/* Value is in bytes. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MIN_BW_SCALE_BYTES
value|(UINT32_C(0x1)<< 28)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MIN_BW_SCALE_LAST
value|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MIN_BW_SCALE_BYTES
comment|/* bw_value_unit is 3 b */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MIN_BW_BW_VALUE_UNIT_MASK
value|UINT32_C(0xe0000000)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MIN_BW_BW_VALUE_UNIT_SFT
value|29
comment|/* Value is in Mb or MB (base 10). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MIN_BW_BW_VALUE_UNIT_MEGA
value|(UINT32_C(0x0)<< 29)
comment|/* Value is in Kb or KB (base 10). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MIN_BW_BW_VALUE_UNIT_KILO
value|(UINT32_C(0x2)<< 29)
comment|/* Value is in bits or bytes. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MIN_BW_BW_VALUE_UNIT_BASE
value|(UINT32_C(0x4)<< 29)
comment|/* Value is in Gb or GB (base 10). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MIN_BW_BW_VALUE_UNIT_GIGA
value|(UINT32_C(0x6)<< 29)
comment|/* Value is in 1/100th of a percentage of total bandwidth. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MIN_BW_BW_VALUE_UNIT_PERCENT1_100
value|(UINT32_C(0x1)<< 29)
comment|/* Invalid unit */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MIN_BW_BW_VALUE_UNIT_INVALID
value|(UINT32_C(0x7)<< 29)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MIN_BW_BW_VALUE_UNIT_LAST
value|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MIN_BW_BW_VALUE_UNIT_INVALID
name|uint32_t
name|queue_id3_max_bw
decl_stmt|;
comment|/* 	 * Maximum BW allocated to CoS queue. The HWRM will translate this value 	 * into byte counter and time interval used for this COS inside the 	 * device. 	 */
comment|/* The bandwidth value. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MAX_BW_BW_VALUE_MASK
value|UINT32_C(0xfffffff)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MAX_BW_BW_VALUE_SFT
value|0
comment|/* The granularity of the value (bits or bytes). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MAX_BW_SCALE
value|UINT32_C(0x10000000)
comment|/* Value is in bits. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MAX_BW_SCALE_BITS
value|(UINT32_C(0x0)<< 28)
comment|/* Value is in bytes. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MAX_BW_SCALE_BYTES
value|(UINT32_C(0x1)<< 28)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MAX_BW_SCALE_LAST
value|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MAX_BW_SCALE_BYTES
comment|/* bw_value_unit is 3 b */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MAX_BW_BW_VALUE_UNIT_MASK
value|UINT32_C(0xe0000000)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MAX_BW_BW_VALUE_UNIT_SFT
value|29
comment|/* Value is in Mb or MB (base 10). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MAX_BW_BW_VALUE_UNIT_MEGA
value|(UINT32_C(0x0)<< 29)
comment|/* Value is in Kb or KB (base 10). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MAX_BW_BW_VALUE_UNIT_KILO
value|(UINT32_C(0x2)<< 29)
comment|/* Value is in bits or bytes. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MAX_BW_BW_VALUE_UNIT_BASE
value|(UINT32_C(0x4)<< 29)
comment|/* Value is in Gb or GB (base 10). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MAX_BW_BW_VALUE_UNIT_GIGA
value|(UINT32_C(0x6)<< 29)
comment|/* Value is in 1/100th of a percentage of total bandwidth. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MAX_BW_BW_VALUE_UNIT_PERCENT1_100
value|(UINT32_C(0x1)<< 29)
comment|/* Invalid unit */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MAX_BW_BW_VALUE_UNIT_INVALID
value|(UINT32_C(0x7)<< 29)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MAX_BW_BW_VALUE_UNIT_LAST
value|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MAX_BW_BW_VALUE_UNIT_INVALID
name|uint8_t
name|queue_id3_tsa_assign
decl_stmt|;
comment|/* Transmission Selection Algorithm (TSA) for CoS Queue. */
comment|/* Strict Priority */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_TSA_ASSIGN_SP
value|UINT32_C(0x0)
comment|/* Enhanced Transmission Selection */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_TSA_ASSIGN_ETS
value|UINT32_C(0x1)
comment|/* reserved */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_TSA_ASSIGN_RESERVED_FIRST
value|UINT32_C(0x2)
comment|/* reserved */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_TSA_ASSIGN_RESERVED_LAST
value|UINT32_C(0xff)
name|uint8_t
name|queue_id3_pri_lvl
decl_stmt|;
comment|/* 	 * Priority level for strict priority. Valid only when the tsa_assign is 	 * 0 - Strict Priority (SP) 0..7 - Valid values. 8..255 - Reserved. 	 */
name|uint8_t
name|queue_id3_bw_weight
decl_stmt|;
comment|/* 	 * Weight used to allocate remaining BW for this COS after servicing 	 * guaranteed bandwidths for all COS. 	 */
name|uint8_t
name|queue_id4
decl_stmt|;
comment|/* ID of CoS Queue 4. */
name|uint32_t
name|queue_id4_min_bw
decl_stmt|;
comment|/* 	 * Minimum BW allocated to CoS Queue. The HWRM will translate this value 	 * into byte counter and time interval used for this COS inside the 	 * device. 	 */
comment|/* The bandwidth value. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MIN_BW_BW_VALUE_MASK
value|UINT32_C(0xfffffff)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MIN_BW_BW_VALUE_SFT
value|0
comment|/* The granularity of the value (bits or bytes). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MIN_BW_SCALE
value|UINT32_C(0x10000000)
comment|/* Value is in bits. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MIN_BW_SCALE_BITS
value|(UINT32_C(0x0)<< 28)
comment|/* Value is in bytes. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MIN_BW_SCALE_BYTES
value|(UINT32_C(0x1)<< 28)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MIN_BW_SCALE_LAST
value|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MIN_BW_SCALE_BYTES
comment|/* bw_value_unit is 3 b */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MIN_BW_BW_VALUE_UNIT_MASK
value|UINT32_C(0xe0000000)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MIN_BW_BW_VALUE_UNIT_SFT
value|29
comment|/* Value is in Mb or MB (base 10). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MIN_BW_BW_VALUE_UNIT_MEGA
value|(UINT32_C(0x0)<< 29)
comment|/* Value is in Kb or KB (base 10). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MIN_BW_BW_VALUE_UNIT_KILO
value|(UINT32_C(0x2)<< 29)
comment|/* Value is in bits or bytes. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MIN_BW_BW_VALUE_UNIT_BASE
value|(UINT32_C(0x4)<< 29)
comment|/* Value is in Gb or GB (base 10). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MIN_BW_BW_VALUE_UNIT_GIGA
value|(UINT32_C(0x6)<< 29)
comment|/* Value is in 1/100th of a percentage of total bandwidth. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MIN_BW_BW_VALUE_UNIT_PERCENT1_100
value|(UINT32_C(0x1)<< 29)
comment|/* Invalid unit */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MIN_BW_BW_VALUE_UNIT_INVALID
value|(UINT32_C(0x7)<< 29)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MIN_BW_BW_VALUE_UNIT_LAST
value|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MIN_BW_BW_VALUE_UNIT_INVALID
name|uint32_t
name|queue_id4_max_bw
decl_stmt|;
comment|/* 	 * Maximum BW allocated to CoS queue. The HWRM will translate this value 	 * into byte counter and time interval used for this COS inside the 	 * device. 	 */
comment|/* The bandwidth value. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MAX_BW_BW_VALUE_MASK
value|UINT32_C(0xfffffff)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MAX_BW_BW_VALUE_SFT
value|0
comment|/* The granularity of the value (bits or bytes). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MAX_BW_SCALE
value|UINT32_C(0x10000000)
comment|/* Value is in bits. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MAX_BW_SCALE_BITS
value|(UINT32_C(0x0)<< 28)
comment|/* Value is in bytes. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MAX_BW_SCALE_BYTES
value|(UINT32_C(0x1)<< 28)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MAX_BW_SCALE_LAST
value|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MAX_BW_SCALE_BYTES
comment|/* bw_value_unit is 3 b */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MAX_BW_BW_VALUE_UNIT_MASK
value|UINT32_C(0xe0000000)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MAX_BW_BW_VALUE_UNIT_SFT
value|29
comment|/* Value is in Mb or MB (base 10). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MAX_BW_BW_VALUE_UNIT_MEGA
value|(UINT32_C(0x0)<< 29)
comment|/* Value is in Kb or KB (base 10). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MAX_BW_BW_VALUE_UNIT_KILO
value|(UINT32_C(0x2)<< 29)
comment|/* Value is in bits or bytes. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MAX_BW_BW_VALUE_UNIT_BASE
value|(UINT32_C(0x4)<< 29)
comment|/* Value is in Gb or GB (base 10). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MAX_BW_BW_VALUE_UNIT_GIGA
value|(UINT32_C(0x6)<< 29)
comment|/* Value is in 1/100th of a percentage of total bandwidth. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MAX_BW_BW_VALUE_UNIT_PERCENT1_100
value|(UINT32_C(0x1)<< 29)
comment|/* Invalid unit */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MAX_BW_BW_VALUE_UNIT_INVALID
value|(UINT32_C(0x7)<< 29)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MAX_BW_BW_VALUE_UNIT_LAST
value|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MAX_BW_BW_VALUE_UNIT_INVALID
name|uint8_t
name|queue_id4_tsa_assign
decl_stmt|;
comment|/* Transmission Selection Algorithm (TSA) for CoS Queue. */
comment|/* Strict Priority */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_TSA_ASSIGN_SP
value|UINT32_C(0x0)
comment|/* Enhanced Transmission Selection */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_TSA_ASSIGN_ETS
value|UINT32_C(0x1)
comment|/* reserved */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_TSA_ASSIGN_RESERVED_FIRST
value|UINT32_C(0x2)
comment|/* reserved */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_TSA_ASSIGN_RESERVED_LAST
value|UINT32_C(0xff)
name|uint8_t
name|queue_id4_pri_lvl
decl_stmt|;
comment|/* 	 * Priority level for strict priority. Valid only when the tsa_assign is 	 * 0 - Strict Priority (SP) 0..7 - Valid values. 8..255 - Reserved. 	 */
name|uint8_t
name|queue_id4_bw_weight
decl_stmt|;
comment|/* 	 * Weight used to allocate remaining BW for this COS after servicing 	 * guaranteed bandwidths for all COS. 	 */
name|uint8_t
name|queue_id5
decl_stmt|;
comment|/* ID of CoS Queue 5. */
name|uint32_t
name|queue_id5_min_bw
decl_stmt|;
comment|/* 	 * Minimum BW allocated to CoS Queue. The HWRM will translate this value 	 * into byte counter and time interval used for this COS inside the 	 * device. 	 */
comment|/* The bandwidth value. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MIN_BW_BW_VALUE_MASK
value|UINT32_C(0xfffffff)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MIN_BW_BW_VALUE_SFT
value|0
comment|/* The granularity of the value (bits or bytes). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MIN_BW_SCALE
value|UINT32_C(0x10000000)
comment|/* Value is in bits. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MIN_BW_SCALE_BITS
value|(UINT32_C(0x0)<< 28)
comment|/* Value is in bytes. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MIN_BW_SCALE_BYTES
value|(UINT32_C(0x1)<< 28)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MIN_BW_SCALE_LAST
value|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MIN_BW_SCALE_BYTES
comment|/* bw_value_unit is 3 b */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MIN_BW_BW_VALUE_UNIT_MASK
value|UINT32_C(0xe0000000)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MIN_BW_BW_VALUE_UNIT_SFT
value|29
comment|/* Value is in Mb or MB (base 10). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MIN_BW_BW_VALUE_UNIT_MEGA
value|(UINT32_C(0x0)<< 29)
comment|/* Value is in Kb or KB (base 10). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MIN_BW_BW_VALUE_UNIT_KILO
value|(UINT32_C(0x2)<< 29)
comment|/* Value is in bits or bytes. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MIN_BW_BW_VALUE_UNIT_BASE
value|(UINT32_C(0x4)<< 29)
comment|/* Value is in Gb or GB (base 10). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MIN_BW_BW_VALUE_UNIT_GIGA
value|(UINT32_C(0x6)<< 29)
comment|/* Value is in 1/100th of a percentage of total bandwidth. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MIN_BW_BW_VALUE_UNIT_PERCENT1_100
value|(UINT32_C(0x1)<< 29)
comment|/* Invalid unit */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MIN_BW_BW_VALUE_UNIT_INVALID
value|(UINT32_C(0x7)<< 29)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MIN_BW_BW_VALUE_UNIT_LAST
value|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MIN_BW_BW_VALUE_UNIT_INVALID
name|uint32_t
name|queue_id5_max_bw
decl_stmt|;
comment|/* 	 * Maximum BW allocated to CoS queue. The HWRM will translate this value 	 * into byte counter and time interval used for this COS inside the 	 * device. 	 */
comment|/* The bandwidth value. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MAX_BW_BW_VALUE_MASK
value|UINT32_C(0xfffffff)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MAX_BW_BW_VALUE_SFT
value|0
comment|/* The granularity of the value (bits or bytes). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MAX_BW_SCALE
value|UINT32_C(0x10000000)
comment|/* Value is in bits. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MAX_BW_SCALE_BITS
value|(UINT32_C(0x0)<< 28)
comment|/* Value is in bytes. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MAX_BW_SCALE_BYTES
value|(UINT32_C(0x1)<< 28)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MAX_BW_SCALE_LAST
value|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MAX_BW_SCALE_BYTES
comment|/* bw_value_unit is 3 b */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MAX_BW_BW_VALUE_UNIT_MASK
value|UINT32_C(0xe0000000)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MAX_BW_BW_VALUE_UNIT_SFT
value|29
comment|/* Value is in Mb or MB (base 10). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MAX_BW_BW_VALUE_UNIT_MEGA
value|(UINT32_C(0x0)<< 29)
comment|/* Value is in Kb or KB (base 10). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MAX_BW_BW_VALUE_UNIT_KILO
value|(UINT32_C(0x2)<< 29)
comment|/* Value is in bits or bytes. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MAX_BW_BW_VALUE_UNIT_BASE
value|(UINT32_C(0x4)<< 29)
comment|/* Value is in Gb or GB (base 10). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MAX_BW_BW_VALUE_UNIT_GIGA
value|(UINT32_C(0x6)<< 29)
comment|/* Value is in 1/100th of a percentage of total bandwidth. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MAX_BW_BW_VALUE_UNIT_PERCENT1_100
value|(UINT32_C(0x1)<< 29)
comment|/* Invalid unit */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MAX_BW_BW_VALUE_UNIT_INVALID
value|(UINT32_C(0x7)<< 29)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MAX_BW_BW_VALUE_UNIT_LAST
value|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MAX_BW_BW_VALUE_UNIT_INVALID
name|uint8_t
name|queue_id5_tsa_assign
decl_stmt|;
comment|/* Transmission Selection Algorithm (TSA) for CoS Queue. */
comment|/* Strict Priority */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_TSA_ASSIGN_SP
value|UINT32_C(0x0)
comment|/* Enhanced Transmission Selection */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_TSA_ASSIGN_ETS
value|UINT32_C(0x1)
comment|/* reserved */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_TSA_ASSIGN_RESERVED_FIRST
value|UINT32_C(0x2)
comment|/* reserved */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_TSA_ASSIGN_RESERVED_LAST
value|UINT32_C(0xff)
name|uint8_t
name|queue_id5_pri_lvl
decl_stmt|;
comment|/* 	 * Priority level for strict priority. Valid only when the tsa_assign is 	 * 0 - Strict Priority (SP) 0..7 - Valid values. 8..255 - Reserved. 	 */
name|uint8_t
name|queue_id5_bw_weight
decl_stmt|;
comment|/* 	 * Weight used to allocate remaining BW for this COS after servicing 	 * guaranteed bandwidths for all COS. 	 */
name|uint8_t
name|queue_id6
decl_stmt|;
comment|/* ID of CoS Queue 6. */
name|uint32_t
name|queue_id6_min_bw
decl_stmt|;
comment|/* 	 * Minimum BW allocated to CoS Queue. The HWRM will translate this value 	 * into byte counter and time interval used for this COS inside the 	 * device. 	 */
comment|/* The bandwidth value. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MIN_BW_BW_VALUE_MASK
value|UINT32_C(0xfffffff)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MIN_BW_BW_VALUE_SFT
value|0
comment|/* The granularity of the value (bits or bytes). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MIN_BW_SCALE
value|UINT32_C(0x10000000)
comment|/* Value is in bits. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MIN_BW_SCALE_BITS
value|(UINT32_C(0x0)<< 28)
comment|/* Value is in bytes. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MIN_BW_SCALE_BYTES
value|(UINT32_C(0x1)<< 28)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MIN_BW_SCALE_LAST
value|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MIN_BW_SCALE_BYTES
comment|/* bw_value_unit is 3 b */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MIN_BW_BW_VALUE_UNIT_MASK
value|UINT32_C(0xe0000000)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MIN_BW_BW_VALUE_UNIT_SFT
value|29
comment|/* Value is in Mb or MB (base 10). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MIN_BW_BW_VALUE_UNIT_MEGA
value|(UINT32_C(0x0)<< 29)
comment|/* Value is in Kb or KB (base 10). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MIN_BW_BW_VALUE_UNIT_KILO
value|(UINT32_C(0x2)<< 29)
comment|/* Value is in bits or bytes. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MIN_BW_BW_VALUE_UNIT_BASE
value|(UINT32_C(0x4)<< 29)
comment|/* Value is in Gb or GB (base 10). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MIN_BW_BW_VALUE_UNIT_GIGA
value|(UINT32_C(0x6)<< 29)
comment|/* Value is in 1/100th of a percentage of total bandwidth. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MIN_BW_BW_VALUE_UNIT_PERCENT1_100
value|(UINT32_C(0x1)<< 29)
comment|/* Invalid unit */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MIN_BW_BW_VALUE_UNIT_INVALID
value|(UINT32_C(0x7)<< 29)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MIN_BW_BW_VALUE_UNIT_LAST
value|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MIN_BW_BW_VALUE_UNIT_INVALID
name|uint32_t
name|queue_id6_max_bw
decl_stmt|;
comment|/* 	 * Maximum BW allocated to CoS queue. The HWRM will translate this value 	 * into byte counter and time interval used for this COS inside the 	 * device. 	 */
comment|/* The bandwidth value. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MAX_BW_BW_VALUE_MASK
value|UINT32_C(0xfffffff)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MAX_BW_BW_VALUE_SFT
value|0
comment|/* The granularity of the value (bits or bytes). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MAX_BW_SCALE
value|UINT32_C(0x10000000)
comment|/* Value is in bits. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MAX_BW_SCALE_BITS
value|(UINT32_C(0x0)<< 28)
comment|/* Value is in bytes. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MAX_BW_SCALE_BYTES
value|(UINT32_C(0x1)<< 28)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MAX_BW_SCALE_LAST
value|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MAX_BW_SCALE_BYTES
comment|/* bw_value_unit is 3 b */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MAX_BW_BW_VALUE_UNIT_MASK
value|UINT32_C(0xe0000000)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MAX_BW_BW_VALUE_UNIT_SFT
value|29
comment|/* Value is in Mb or MB (base 10). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MAX_BW_BW_VALUE_UNIT_MEGA
value|(UINT32_C(0x0)<< 29)
comment|/* Value is in Kb or KB (base 10). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MAX_BW_BW_VALUE_UNIT_KILO
value|(UINT32_C(0x2)<< 29)
comment|/* Value is in bits or bytes. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MAX_BW_BW_VALUE_UNIT_BASE
value|(UINT32_C(0x4)<< 29)
comment|/* Value is in Gb or GB (base 10). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MAX_BW_BW_VALUE_UNIT_GIGA
value|(UINT32_C(0x6)<< 29)
comment|/* Value is in 1/100th of a percentage of total bandwidth. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MAX_BW_BW_VALUE_UNIT_PERCENT1_100
value|(UINT32_C(0x1)<< 29)
comment|/* Invalid unit */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MAX_BW_BW_VALUE_UNIT_INVALID
value|(UINT32_C(0x7)<< 29)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MAX_BW_BW_VALUE_UNIT_LAST
value|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MAX_BW_BW_VALUE_UNIT_INVALID
name|uint8_t
name|queue_id6_tsa_assign
decl_stmt|;
comment|/* Transmission Selection Algorithm (TSA) for CoS Queue. */
comment|/* Strict Priority */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_TSA_ASSIGN_SP
value|UINT32_C(0x0)
comment|/* Enhanced Transmission Selection */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_TSA_ASSIGN_ETS
value|UINT32_C(0x1)
comment|/* reserved */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_TSA_ASSIGN_RESERVED_FIRST
value|UINT32_C(0x2)
comment|/* reserved */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_TSA_ASSIGN_RESERVED_LAST
value|UINT32_C(0xff)
name|uint8_t
name|queue_id6_pri_lvl
decl_stmt|;
comment|/* 	 * Priority level for strict priority. Valid only when the tsa_assign is 	 * 0 - Strict Priority (SP) 0..7 - Valid values. 8..255 - Reserved. 	 */
name|uint8_t
name|queue_id6_bw_weight
decl_stmt|;
comment|/* 	 * Weight used to allocate remaining BW for this COS after servicing 	 * guaranteed bandwidths for all COS. 	 */
name|uint8_t
name|queue_id7
decl_stmt|;
comment|/* ID of CoS Queue 7. */
name|uint32_t
name|queue_id7_min_bw
decl_stmt|;
comment|/* 	 * Minimum BW allocated to CoS Queue. The HWRM will translate this value 	 * into byte counter and time interval used for this COS inside the 	 * device. 	 */
comment|/* The bandwidth value. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MIN_BW_BW_VALUE_MASK
value|UINT32_C(0xfffffff)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MIN_BW_BW_VALUE_SFT
value|0
comment|/* The granularity of the value (bits or bytes). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MIN_BW_SCALE
value|UINT32_C(0x10000000)
comment|/* Value is in bits. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MIN_BW_SCALE_BITS
value|(UINT32_C(0x0)<< 28)
comment|/* Value is in bytes. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MIN_BW_SCALE_BYTES
value|(UINT32_C(0x1)<< 28)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MIN_BW_SCALE_LAST
value|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MIN_BW_SCALE_BYTES
comment|/* bw_value_unit is 3 b */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MIN_BW_BW_VALUE_UNIT_MASK
value|UINT32_C(0xe0000000)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MIN_BW_BW_VALUE_UNIT_SFT
value|29
comment|/* Value is in Mb or MB (base 10). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MIN_BW_BW_VALUE_UNIT_MEGA
value|(UINT32_C(0x0)<< 29)
comment|/* Value is in Kb or KB (base 10). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MIN_BW_BW_VALUE_UNIT_KILO
value|(UINT32_C(0x2)<< 29)
comment|/* Value is in bits or bytes. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MIN_BW_BW_VALUE_UNIT_BASE
value|(UINT32_C(0x4)<< 29)
comment|/* Value is in Gb or GB (base 10). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MIN_BW_BW_VALUE_UNIT_GIGA
value|(UINT32_C(0x6)<< 29)
comment|/* Value is in 1/100th of a percentage of total bandwidth. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MIN_BW_BW_VALUE_UNIT_PERCENT1_100
value|(UINT32_C(0x1)<< 29)
comment|/* Invalid unit */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MIN_BW_BW_VALUE_UNIT_INVALID
value|(UINT32_C(0x7)<< 29)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MIN_BW_BW_VALUE_UNIT_LAST
value|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MIN_BW_BW_VALUE_UNIT_INVALID
name|uint32_t
name|queue_id7_max_bw
decl_stmt|;
comment|/* 	 * Maximum BW allocated to CoS queue. The HWRM will translate this value 	 * into byte counter and time interval used for this COS inside the 	 * device. 	 */
comment|/* The bandwidth value. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MAX_BW_BW_VALUE_MASK
value|UINT32_C(0xfffffff)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MAX_BW_BW_VALUE_SFT
value|0
comment|/* The granularity of the value (bits or bytes). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MAX_BW_SCALE
value|UINT32_C(0x10000000)
comment|/* Value is in bits. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MAX_BW_SCALE_BITS
value|(UINT32_C(0x0)<< 28)
comment|/* Value is in bytes. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MAX_BW_SCALE_BYTES
value|(UINT32_C(0x1)<< 28)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MAX_BW_SCALE_LAST
value|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MAX_BW_SCALE_BYTES
comment|/* bw_value_unit is 3 b */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MAX_BW_BW_VALUE_UNIT_MASK
value|UINT32_C(0xe0000000)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MAX_BW_BW_VALUE_UNIT_SFT
value|29
comment|/* Value is in Mb or MB (base 10). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MAX_BW_BW_VALUE_UNIT_MEGA
value|(UINT32_C(0x0)<< 29)
comment|/* Value is in Kb or KB (base 10). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MAX_BW_BW_VALUE_UNIT_KILO
value|(UINT32_C(0x2)<< 29)
comment|/* Value is in bits or bytes. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MAX_BW_BW_VALUE_UNIT_BASE
value|(UINT32_C(0x4)<< 29)
comment|/* Value is in Gb or GB (base 10). */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MAX_BW_BW_VALUE_UNIT_GIGA
value|(UINT32_C(0x6)<< 29)
comment|/* Value is in 1/100th of a percentage of total bandwidth. */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MAX_BW_BW_VALUE_UNIT_PERCENT1_100
value|(UINT32_C(0x1)<< 29)
comment|/* Invalid unit */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MAX_BW_BW_VALUE_UNIT_INVALID
value|(UINT32_C(0x7)<< 29)
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MAX_BW_BW_VALUE_UNIT_LAST
value|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MAX_BW_BW_VALUE_UNIT_INVALID
name|uint8_t
name|queue_id7_tsa_assign
decl_stmt|;
comment|/* Transmission Selection Algorithm (TSA) for CoS Queue. */
comment|/* Strict Priority */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_TSA_ASSIGN_SP
value|UINT32_C(0x0)
comment|/* Enhanced Transmission Selection */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_TSA_ASSIGN_ETS
value|UINT32_C(0x1)
comment|/* reserved */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_TSA_ASSIGN_RESERVED_FIRST
value|UINT32_C(0x2)
comment|/* reserved */
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_TSA_ASSIGN_RESERVED_LAST
value|UINT32_C(0xff)
name|uint8_t
name|queue_id7_pri_lvl
decl_stmt|;
comment|/* 	 * Priority level for strict priority. Valid only when the tsa_assign is 	 * 0 - Strict Priority (SP) 0..7 - Valid values. 8..255 - Reserved. 	 */
name|uint8_t
name|queue_id7_bw_weight
decl_stmt|;
comment|/* 	 * Weight used to allocate remaining BW for this COS after servicing 	 * guaranteed bandwidths for all COS. 	 */
name|uint8_t
name|unused_1
index|[
literal|5
index|]
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_queue_cos2bw_cfg_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint32_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_queue_dscp_qcaps */
end_comment

begin_comment
comment|/*  * Description: This command is called by a driver to query the DSCP  * capabilities for a port.  */
end_comment

begin_comment
comment|/* Input (24 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_queue_dscp_qcaps_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint8_t
name|port_id
decl_stmt|;
comment|/* 	 * Port ID of port for which the table is being configured. The HWRM 	 * needs to check whether this function is allowed to configure pri2cos 	 * mapping on this port. 	 */
name|uint8_t
name|unused_0
index|[
literal|7
index|]
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_queue_dscp_qcaps_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint8_t
name|num_dscp_bits
decl_stmt|;
comment|/* The number of bits provided by the hardware for the DSCP value. */
name|uint8_t
name|unused_0
decl_stmt|;
name|uint16_t
name|max_entries
decl_stmt|;
comment|/* Max number of DSCP-MASK-PRI entries supported. */
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_queue_dscp2pri_qcfg */
end_comment

begin_comment
comment|/*  * Description: This command is called by a driver to query configuration of the  * DSCP to PRI mapping on the receive side. This mapping can be different on  * different ports.  */
end_comment

begin_comment
comment|/* Input (32 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_queue_dscp2pri_qcfg_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint64_t
name|dest_data_addr
decl_stmt|;
comment|/* 	 * This is the host address where the 24-bits DSCP-MASK-PRI tuple(s) 	 * will be copied to. 	 */
name|uint8_t
name|port_id
decl_stmt|;
comment|/* 	 * Port ID of port for which the table is being configured. The HWRM 	 * needs to check whether this function is allowed to configure pri2cos 	 * mapping on this port. 	 */
name|uint8_t
name|unused_0
decl_stmt|;
name|uint16_t
name|dest_data_buffer_size
decl_stmt|;
comment|/* Size of the buffer pointed to by dest_data_addr. */
name|uint32_t
name|unused_1
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_queue_dscp2pri_qcfg_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint16_t
name|entry_cnt
decl_stmt|;
comment|/* 	 * A count of the number of DSCP-MASK-PRI tuple(s) pointed to by the 	 * dest_data_addr. 	 */
name|uint8_t
name|default_pri
decl_stmt|;
comment|/* 	 * This is the default PRI which un-initialized DSCP values are mapped 	 * to. 	 */
name|uint8_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_queue_dscp2pri_cfg */
end_comment

begin_comment
comment|/*  * Description: This command is called by a driver to configure the DSCP to PRI  * mapping on the receive side. This mapping can be different on different  * ports.  */
end_comment

begin_comment
comment|/* Input (40 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_queue_dscp2pri_cfg_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint64_t
name|src_data_addr
decl_stmt|;
comment|/* 	 * This is the host address where the 24-bits DSCP-MASK-PRI tuple will 	 * be copied from. 	 */
name|uint32_t
name|flags
decl_stmt|;
comment|/* use_hw_default_pri is 1 b */
define|#
directive|define
name|HWRM_QUEUE_DSCP2PRI_CFG_INPUT_FLAGS_USE_HW_DEFAULT_PRI
value|UINT32_C(0x1)
name|uint32_t
name|enables
decl_stmt|;
comment|/* This bit must be '1' for the default_pri field to be configured. */
define|#
directive|define
name|HWRM_QUEUE_DSCP2PRI_CFG_INPUT_ENABLES_DEFAULT_PRI
value|UINT32_C(0x1)
name|uint8_t
name|port_id
decl_stmt|;
comment|/* 	 * Port ID of port for which the table is being configured. The HWRM 	 * needs to check whether this function is allowed to configure pri2cos 	 * mapping on this port. 	 */
name|uint8_t
name|default_pri
decl_stmt|;
comment|/* 	 * This is the default PRI which un-initialized DSCP values will be 	 * mapped to. 	 */
name|uint16_t
name|entry_cnt
decl_stmt|;
comment|/* 	 * A count of the number of DSCP-MASK-PRI tuple(s) in the data pointed 	 * to by src_data_addr. 	 */
name|uint32_t
name|unused_0
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_queue_dscp2pri_cfg_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint32_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_vnic_alloc */
end_comment

begin_comment
comment|/*  * Description: This VNIC is a resource in the RX side of the chip that is used  * to represent a virtual host "interface". # At the time of VNIC allocation or  * configuration, the function can specify whether it wants the requested VNIC  * to be the default VNIC for the function or not. # If a function requests  * allocation of a VNIC for the first time and a VNIC is successfully allocated  * by the HWRM, then the HWRM shall make the allocated VNIC as the default VNIC  * for that function. # The default VNIC shall be used for the default action  * for a partition or function. # For each VNIC allocated on a function, a  * mapping on the RX side to map the allocated VNIC to source virtual interface  * shall be performed by the HWRM. This should be hidden to the function driver  * requesting the VNIC allocation. This enables broadcast/multicast replication  * with source knockout. # If multicast replication with source knockout is  * enabled, then the internal VNIC to SVIF mapping data structures shall be  * programmed at the time of VNIC allocation.  */
end_comment

begin_comment
comment|/* Input (24 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_vnic_alloc_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint32_t
name|flags
decl_stmt|;
comment|/* 	 * When this bit is '1', this VNIC is requested to be the default VNIC 	 * for this function. 	 */
define|#
directive|define
name|HWRM_VNIC_ALLOC_INPUT_FLAGS_DEFAULT
value|UINT32_C(0x1)
name|uint32_t
name|unused_0
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_vnic_alloc_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint32_t
name|vnic_id
decl_stmt|;
comment|/* Logical vnic ID */
name|uint8_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_vnic_free */
end_comment

begin_comment
comment|/*  * Description: Free a VNIC resource. Idle any resources associated with the  * VNIC as well as the VNIC. Reset and release all resources associated with the  * VNIC.  */
end_comment

begin_comment
comment|/* Input (24 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_vnic_free_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint32_t
name|vnic_id
decl_stmt|;
comment|/* Logical vnic ID */
name|uint32_t
name|unused_0
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_vnic_free_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint32_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_vnic_cfg */
end_comment

begin_comment
comment|/* Description: Configure the RX VNIC structure. */
end_comment

begin_comment
comment|/* Input (40 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_vnic_cfg_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint32_t
name|flags
decl_stmt|;
comment|/* 	 * When this bit is '1', the VNIC is requested to be the default VNIC 	 * for the function. 	 */
define|#
directive|define
name|HWRM_VNIC_CFG_INPUT_FLAGS_DEFAULT
value|UINT32_C(0x1)
comment|/* 	 * When this bit is '1', the VNIC is being configured to strip VLAN in 	 * the RX path. If set to '0', then VLAN stripping is disabled on this 	 * VNIC. 	 */
define|#
directive|define
name|HWRM_VNIC_CFG_INPUT_FLAGS_VLAN_STRIP_MODE
value|UINT32_C(0x2)
comment|/* 	 * When this bit is '1', the VNIC is being configured to buffer receive 	 * packets in the hardware until the host posts new receive buffers. If 	 * set to '0', then bd_stall is being configured to be disabled on this 	 * VNIC. 	 */
define|#
directive|define
name|HWRM_VNIC_CFG_INPUT_FLAGS_BD_STALL_MODE
value|UINT32_C(0x4)
comment|/* 	 * When this bit is '1', the VNIC is being configured to receive both 	 * RoCE and non-RoCE traffic. If set to '0', then this VNIC is not 	 * configured to be operating in dual VNIC mode. 	 */
define|#
directive|define
name|HWRM_VNIC_CFG_INPUT_FLAGS_ROCE_DUAL_VNIC_MODE
value|UINT32_C(0x8)
comment|/* 	 * When this flag is set to '1', the VNIC is requested to be configured 	 * to receive only RoCE traffic. If this flag is set to '0', then this 	 * flag shall be ignored by the HWRM. If roce_dual_vnic_mode flag is set 	 * to '1', then the HWRM client shall not set this flag to '1'. 	 */
define|#
directive|define
name|HWRM_VNIC_CFG_INPUT_FLAGS_ROCE_ONLY_VNIC_MODE
value|UINT32_C(0x10)
comment|/* 	 * When a VNIC uses one destination ring group for certain application 	 * (e.g. Receive Flow Steering) where exact match is used to direct 	 * packets to a VNIC with one destination ring group only, there is no 	 * need to configure RSS indirection table for that VNIC as only one 	 * destination ring group is used. This flag is used to enable a mode 	 * where RSS is enabled in the VNIC using a RSS context for computing 	 * RSS hash but the RSS indirection table is not configured using 	 * hwrm_vnic_rss_cfg. If this mode is enabled, then the driver should 	 * not program RSS indirection table for the RSS context that is used 	 * for computing RSS hash only. 	 */
define|#
directive|define
name|HWRM_VNIC_CFG_INPUT_FLAGS_RSS_DFLT_CR_MODE
value|UINT32_C(0x20)
name|uint32_t
name|enables
decl_stmt|;
comment|/* This bit must be '1' for the dflt_ring_grp field to be configured. */
define|#
directive|define
name|HWRM_VNIC_CFG_INPUT_ENABLES_DFLT_RING_GRP
value|UINT32_C(0x1)
comment|/* This bit must be '1' for the rss_rule field to be configured. */
define|#
directive|define
name|HWRM_VNIC_CFG_INPUT_ENABLES_RSS_RULE
value|UINT32_C(0x2)
comment|/* This bit must be '1' for the cos_rule field to be configured. */
define|#
directive|define
name|HWRM_VNIC_CFG_INPUT_ENABLES_COS_RULE
value|UINT32_C(0x4)
comment|/* This bit must be '1' for the lb_rule field to be configured. */
define|#
directive|define
name|HWRM_VNIC_CFG_INPUT_ENABLES_LB_RULE
value|UINT32_C(0x8)
comment|/* This bit must be '1' for the mru field to be configured. */
define|#
directive|define
name|HWRM_VNIC_CFG_INPUT_ENABLES_MRU
value|UINT32_C(0x10)
name|uint16_t
name|vnic_id
decl_stmt|;
comment|/* Logical vnic ID */
name|uint16_t
name|dflt_ring_grp
decl_stmt|;
comment|/* 	 * Default Completion ring for the VNIC. This ring will be chosen if 	 * packet does not match any RSS rules and if there is no COS rule. 	 */
name|uint16_t
name|rss_rule
decl_stmt|;
comment|/* 	 * RSS ID for RSS rule/table structure. 0xFF... (All Fs) if there is no 	 * RSS rule. 	 */
name|uint16_t
name|cos_rule
decl_stmt|;
comment|/* 	 * RSS ID for COS rule/table structure. 0xFF... (All Fs) if there is no 	 * COS rule. 	 */
name|uint16_t
name|lb_rule
decl_stmt|;
comment|/* 	 * RSS ID for load balancing rule/table structure. 0xFF... (All Fs) if 	 * there is no LB rule. 	 */
name|uint16_t
name|mru
decl_stmt|;
comment|/* 	 * The maximum receive unit of the vnic. Each vnic is associated with a 	 * function. The vnic mru value overwrites the mru setting of the 	 * associated function. The HWRM shall make sure that vnic mru does not 	 * exceed the mru of the port the function is associated with. 	 */
name|uint32_t
name|unused_0
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_vnic_cfg_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint32_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_vnic_qcfg */
end_comment

begin_comment
comment|/*  * Description: Query the RX VNIC structure. This function can be used by a PF  * driver to query its own VNIC resource or VNIC resource of its child VF. This  * function can also be used by a VF driver to query its own VNIC resource.  */
end_comment

begin_comment
comment|/* Input (32 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_vnic_qcfg_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint32_t
name|enables
decl_stmt|;
comment|/* This bit must be '1' for the vf_id_valid field to be configured. */
define|#
directive|define
name|HWRM_VNIC_QCFG_INPUT_ENABLES_VF_ID_VALID
value|UINT32_C(0x1)
name|uint32_t
name|vnic_id
decl_stmt|;
comment|/* Logical vnic ID */
name|uint16_t
name|vf_id
decl_stmt|;
comment|/* ID of Virtual Function whose VNIC resource is being queried. */
name|uint16_t
name|unused_0
index|[
literal|3
index|]
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (32 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_vnic_qcfg_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint16_t
name|dflt_ring_grp
decl_stmt|;
comment|/* Default Completion ring for the VNIC. */
name|uint16_t
name|rss_rule
decl_stmt|;
comment|/* 	 * RSS ID for RSS rule/table structure. 0xFF... (All Fs) if there is no 	 * RSS rule. 	 */
name|uint16_t
name|cos_rule
decl_stmt|;
comment|/* 	 * RSS ID for COS rule/table structure. 0xFF... (All Fs) if there is no 	 * COS rule. 	 */
name|uint16_t
name|lb_rule
decl_stmt|;
comment|/* 	 * RSS ID for load balancing rule/table structure. 0xFF... (All Fs) if 	 * there is no LB rule. 	 */
name|uint16_t
name|mru
decl_stmt|;
comment|/* The maximum receive unit of the vnic. */
name|uint8_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint32_t
name|flags
decl_stmt|;
comment|/* When this bit is '1', the VNIC is the default VNIC for the function. */
define|#
directive|define
name|HWRM_VNIC_QCFG_OUTPUT_FLAGS_DEFAULT
value|UINT32_C(0x1)
comment|/* 	 * When this bit is '1', the VNIC is configured to strip VLAN in the RX 	 * path. If set to '0', then VLAN stripping is disabled on this VNIC. 	 */
define|#
directive|define
name|HWRM_VNIC_QCFG_OUTPUT_FLAGS_VLAN_STRIP_MODE
value|UINT32_C(0x2)
comment|/* 	 * When this bit is '1', the VNIC is configured to buffer receive 	 * packets in the hardware until the host posts new receive buffers. If 	 * set to '0', then bd_stall is disabled on this VNIC. 	 */
define|#
directive|define
name|HWRM_VNIC_QCFG_OUTPUT_FLAGS_BD_STALL_MODE
value|UINT32_C(0x4)
comment|/* 	 * When this bit is '1', the VNIC is configured to receive both RoCE and 	 * non-RoCE traffic. If set to '0', then this VNIC is not configured to 	 * operate in dual VNIC mode. 	 */
define|#
directive|define
name|HWRM_VNIC_QCFG_OUTPUT_FLAGS_ROCE_DUAL_VNIC_MODE
value|UINT32_C(0x8)
comment|/* 	 * When this flag is set to '1', the VNIC is configured to receive only 	 * RoCE traffic. When this flag is set to '0', the VNIC is not 	 * configured to receive only RoCE traffic. If roce_dual_vnic_mode flag 	 * and this flag both are set to '1', then it is an invalid 	 * configuration of the VNIC. The HWRM should not allow that type of 	 * mis-configuration by HWRM clients. 	 */
define|#
directive|define
name|HWRM_VNIC_QCFG_OUTPUT_FLAGS_ROCE_ONLY_VNIC_MODE
value|UINT32_C(0x10)
comment|/* 	 * When a VNIC uses one destination ring group for certain application 	 * (e.g. Receive Flow Steering) where exact match is used to direct 	 * packets to a VNIC with one destination ring group only, there is no 	 * need to configure RSS indirection table for that VNIC as only one 	 * destination ring group is used. When this bit is set to '1', then the 	 * VNIC is enabled in a mode where RSS is enabled in the VNIC using a 	 * RSS context for computing RSS hash but the RSS indirection table is 	 * not configured. 	 */
define|#
directive|define
name|HWRM_VNIC_QCFG_OUTPUT_FLAGS_RSS_DFLT_CR_MODE
value|UINT32_C(0x20)
name|uint32_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint8_t
name|unused_4
decl_stmt|;
name|uint8_t
name|unused_5
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_vnic_qcaps */
end_comment

begin_comment
comment|/*  * Description: This function is used to query the capabilities of VNIC  * resources.  */
end_comment

begin_comment
comment|/* Input (24 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_vnic_qcaps_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint32_t
name|enables
decl_stmt|;
name|uint32_t
name|unused_0
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (24 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_vnic_qcaps_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint16_t
name|mru
decl_stmt|;
comment|/* The maximum receive unit that is settable on a vnic. */
name|uint8_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint32_t
name|flags
decl_stmt|;
comment|/* Unused. */
define|#
directive|define
name|HWRM_VNIC_QCAPS_OUTPUT_FLAGS_UNUSED
value|UINT32_C(0x1)
comment|/* 	 * When this bit is '1', the capability of stripping VLAN in the RX path 	 * is supported on VNIC(s). If set to '0', then VLAN stripping 	 * capability is not supported on VNIC(s). 	 */
define|#
directive|define
name|HWRM_VNIC_QCAPS_OUTPUT_FLAGS_VLAN_STRIP_CAP
value|UINT32_C(0x2)
comment|/* 	 * When this bit is '1', the capability to buffer receive packets in the 	 * hardware until the host posts new receive buffers is supported on 	 * VNIC(s). If set to '0', then bd_stall capability is not supported on 	 * VNIC(s). 	 */
define|#
directive|define
name|HWRM_VNIC_QCAPS_OUTPUT_FLAGS_BD_STALL_CAP
value|UINT32_C(0x4)
comment|/* 	 * When this bit is '1', the capability to receive both RoCE and non- 	 * RoCE traffic on VNIC(s) is supported. If set to '0', then the 	 * capability to receive both RoCE and non-RoCE traffic on VNIC(s) is 	 * not supported. 	 */
define|#
directive|define
name|HWRM_VNIC_QCAPS_OUTPUT_FLAGS_ROCE_DUAL_VNIC_CAP
value|UINT32_C(0x8)
comment|/* 	 * When this bit is set to '1', the capability to configure a VNIC to 	 * receive only RoCE traffic is supported. When this flag is set to '0', 	 * the VNIC capability to configure to receive only RoCE traffic is not 	 * supported. 	 */
define|#
directive|define
name|HWRM_VNIC_QCAPS_OUTPUT_FLAGS_ROCE_ONLY_VNIC_CAP
value|UINT32_C(0x10)
comment|/* 	 * When this bit is set to '1', then the capability to enable a VNIC in 	 * a mode where RSS context without configuring RSS indirection table is 	 * supported (for RSS hash computation). When this bit is set to '0', 	 * then a VNIC can not be configured with a mode to enable RSS context 	 * without configuring RSS indirection table. 	 */
define|#
directive|define
name|HWRM_VNIC_QCAPS_OUTPUT_FLAGS_RSS_DFLT_CR_CAP
value|UINT32_C(0x20)
name|uint32_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint8_t
name|unused_4
decl_stmt|;
name|uint8_t
name|unused_5
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_vnic_tpa_cfg */
end_comment

begin_comment
comment|/* Description: This function is used to enable/configure TPA on the VNIC. */
end_comment

begin_comment
comment|/* Input (40 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_vnic_tpa_cfg_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint32_t
name|flags
decl_stmt|;
comment|/* 	 * When this bit is '1', the VNIC shall be configured to perform 	 * transparent packet aggregation (TPA) of non-tunneled TCP packets. 	 */
define|#
directive|define
name|HWRM_VNIC_TPA_CFG_INPUT_FLAGS_TPA
value|UINT32_C(0x1)
comment|/* 	 * When this bit is '1', the VNIC shall be configured to perform 	 * transparent packet aggregation (TPA) of tunneled TCP packets. 	 */
define|#
directive|define
name|HWRM_VNIC_TPA_CFG_INPUT_FLAGS_ENCAP_TPA
value|UINT32_C(0x2)
comment|/* 	 * When this bit is '1', the VNIC shall be configured to perform 	 * transparent packet aggregation (TPA) according to Windows Receive 	 * Segment Coalescing (RSC) rules. 	 */
define|#
directive|define
name|HWRM_VNIC_TPA_CFG_INPUT_FLAGS_RSC_WND_UPDATE
value|UINT32_C(0x4)
comment|/* 	 * When this bit is '1', the VNIC shall be configured to perform 	 * transparent packet aggregation (TPA) according to Linux Generic 	 * Receive Offload (GRO) rules. 	 */
define|#
directive|define
name|HWRM_VNIC_TPA_CFG_INPUT_FLAGS_GRO
value|UINT32_C(0x8)
comment|/* 	 * When this bit is '1', the VNIC shall be configured to perform 	 * transparent packet aggregation (TPA) for TCP packets with IP ECN set 	 * to non-zero. 	 */
define|#
directive|define
name|HWRM_VNIC_TPA_CFG_INPUT_FLAGS_AGG_WITH_ECN
value|UINT32_C(0x10)
comment|/* 	 * When this bit is '1', the VNIC shall be configured to perform 	 * transparent packet aggregation (TPA) for GRE tunneled TCP packets 	 * only if all packets have the same GRE sequence. 	 */
define|#
directive|define
name|HWRM_VNIC_TPA_CFG_INPUT_FLAGS_AGG_WITH_SAME_GRE_SEQ
value|UINT32_C(0x20)
comment|/* 	 * When this bit is '1' and the GRO mode is enabled, the VNIC shall be 	 * configured to perform transparent packet aggregation (TPA) for 	 * TCP/IPv4 packets with consecutively increasing IPIDs. In other words, 	 * the last packet that is being aggregated to an already existing 	 * aggregation context shall have IPID 1 more than the IPID of the last 	 * packet that was aggregated in that aggregation context. 	 */
define|#
directive|define
name|HWRM_VNIC_TPA_CFG_INPUT_FLAGS_GRO_IPID_CHECK
value|UINT32_C(0x40)
comment|/* 	 * When this bit is '1' and the GRO mode is enabled, the VNIC shall be 	 * configured to perform transparent packet aggregation (TPA) for TCP 	 * packets with the same TTL (IPv4) or Hop limit (IPv6) value. 	 */
define|#
directive|define
name|HWRM_VNIC_TPA_CFG_INPUT_FLAGS_GRO_TTL_CHECK
value|UINT32_C(0x80)
name|uint32_t
name|enables
decl_stmt|;
comment|/* This bit must be '1' for the max_agg_segs field to be configured. */
define|#
directive|define
name|HWRM_VNIC_TPA_CFG_INPUT_ENABLES_MAX_AGG_SEGS
value|UINT32_C(0x1)
comment|/* This bit must be '1' for the max_aggs field to be configured. */
define|#
directive|define
name|HWRM_VNIC_TPA_CFG_INPUT_ENABLES_MAX_AGGS
value|UINT32_C(0x2)
comment|/* This bit must be '1' for the max_agg_timer field to be configured. */
define|#
directive|define
name|HWRM_VNIC_TPA_CFG_INPUT_ENABLES_MAX_AGG_TIMER
value|UINT32_C(0x4)
comment|/* This bit must be '1' for the min_agg_len field to be configured. */
define|#
directive|define
name|HWRM_VNIC_TPA_CFG_INPUT_ENABLES_MIN_AGG_LEN
value|UINT32_C(0x8)
name|uint16_t
name|vnic_id
decl_stmt|;
comment|/* Logical vnic ID */
name|uint16_t
name|max_agg_segs
decl_stmt|;
comment|/* 	 * This is the maximum number of TCP segments that can be aggregated 	 * (unit is Log2). Max value is 31. 	 */
comment|/* 1 segment */
define|#
directive|define
name|HWRM_VNIC_TPA_CFG_INPUT_MAX_AGG_SEGS_1
value|UINT32_C(0x0)
comment|/* 2 segments */
define|#
directive|define
name|HWRM_VNIC_TPA_CFG_INPUT_MAX_AGG_SEGS_2
value|UINT32_C(0x1)
comment|/* 4 segments */
define|#
directive|define
name|HWRM_VNIC_TPA_CFG_INPUT_MAX_AGG_SEGS_4
value|UINT32_C(0x2)
comment|/* 8 segments */
define|#
directive|define
name|HWRM_VNIC_TPA_CFG_INPUT_MAX_AGG_SEGS_8
value|UINT32_C(0x3)
comment|/* Any segment size larger than this is not valid */
define|#
directive|define
name|HWRM_VNIC_TPA_CFG_INPUT_MAX_AGG_SEGS_MAX
value|UINT32_C(0x1f)
name|uint16_t
name|max_aggs
decl_stmt|;
comment|/* 	 * This is the maximum number of aggregations this VNIC is allowed (unit 	 * is Log2). Max value is 7 	 */
comment|/* 1 aggregation */
define|#
directive|define
name|HWRM_VNIC_TPA_CFG_INPUT_MAX_AGGS_1
value|UINT32_C(0x0)
comment|/* 2 aggregations */
define|#
directive|define
name|HWRM_VNIC_TPA_CFG_INPUT_MAX_AGGS_2
value|UINT32_C(0x1)
comment|/* 4 aggregations */
define|#
directive|define
name|HWRM_VNIC_TPA_CFG_INPUT_MAX_AGGS_4
value|UINT32_C(0x2)
comment|/* 8 aggregations */
define|#
directive|define
name|HWRM_VNIC_TPA_CFG_INPUT_MAX_AGGS_8
value|UINT32_C(0x3)
comment|/* 16 aggregations */
define|#
directive|define
name|HWRM_VNIC_TPA_CFG_INPUT_MAX_AGGS_16
value|UINT32_C(0x4)
comment|/* Any aggregation size larger than this is not valid */
define|#
directive|define
name|HWRM_VNIC_TPA_CFG_INPUT_MAX_AGGS_MAX
value|UINT32_C(0x7)
name|uint8_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint32_t
name|max_agg_timer
decl_stmt|;
comment|/* 	 * This is the maximum amount of time allowed for an aggregation context 	 * to complete after it was initiated. 	 */
name|uint32_t
name|min_agg_len
decl_stmt|;
comment|/* 	 * This is the minimum amount of payload length required to start an 	 * aggregation context. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_vnic_tpa_cfg_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint32_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_vnic_tpa_qcfg */
end_comment

begin_comment
comment|/*  * Description: This function can be used to query TPA configuration on the  * VNIC.  */
end_comment

begin_comment
comment|/* Input (24 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_vnic_tpa_qcfg_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint16_t
name|vnic_id
decl_stmt|;
comment|/* Logical vnic ID */
name|uint16_t
name|unused_0
index|[
literal|3
index|]
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (32 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_vnic_tpa_qcfg_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint32_t
name|flags
decl_stmt|;
comment|/* 	 * When this bit is '1', the VNIC is configured to perform transparent 	 * packet aggregation (TPA) of non-tunneled TCP packets. 	 */
define|#
directive|define
name|HWRM_VNIC_TPA_QCFG_OUTPUT_FLAGS_TPA
value|UINT32_C(0x1)
comment|/* 	 * When this bit is '1', the VNIC is configured to perform transparent 	 * packet aggregation (TPA) of tunneled TCP packets. 	 */
define|#
directive|define
name|HWRM_VNIC_TPA_QCFG_OUTPUT_FLAGS_ENCAP_TPA
value|UINT32_C(0x2)
comment|/* 	 * When this bit is '1', the VNIC is configured to perform transparent 	 * packet aggregation (TPA) according to Windows Receive Segment 	 * Coalescing (RSC) rules. 	 */
define|#
directive|define
name|HWRM_VNIC_TPA_QCFG_OUTPUT_FLAGS_RSC_WND_UPDATE
value|UINT32_C(0x4)
comment|/* 	 * When this bit is '1', the VNIC is configured to perform transparent 	 * packet aggregation (TPA) according to Linux Generic Receive Offload 	 * (GRO) rules. 	 */
define|#
directive|define
name|HWRM_VNIC_TPA_QCFG_OUTPUT_FLAGS_GRO
value|UINT32_C(0x8)
comment|/* 	 * When this bit is '1', the VNIC is configured to perform transparent 	 * packet aggregation (TPA) for TCP packets with IP ECN set to non-zero. 	 */
define|#
directive|define
name|HWRM_VNIC_TPA_QCFG_OUTPUT_FLAGS_AGG_WITH_ECN
value|UINT32_C(0x10)
comment|/* 	 * When this bit is '1', the VNIC is configured to perform transparent 	 * packet aggregation (TPA) for GRE tunneled TCP packets only if all 	 * packets have the same GRE sequence. 	 */
define|#
directive|define
name|HWRM_VNIC_TPA_QCFG_OUTPUT_FLAGS_AGG_WITH_SAME_GRE_SEQ
value|UINT32_C(0x20)
comment|/* 	 * When this bit is '1' and the GRO mode is enabled, the VNIC is 	 * configured to perform transparent packet aggregation (TPA) for 	 * TCP/IPv4 packets with consecutively increasing IPIDs. In other words, 	 * the last packet that is being aggregated to an already existing 	 * aggregation context shall have IPID 1 more than the IPID of the last 	 * packet that was aggregated in that aggregation context. 	 */
define|#
directive|define
name|HWRM_VNIC_TPA_QCFG_OUTPUT_FLAGS_GRO_IPID_CHECK
value|UINT32_C(0x40)
comment|/* 	 * When this bit is '1' and the GRO mode is enabled, the VNIC is 	 * configured to perform transparent packet aggregation (TPA) for TCP 	 * packets with the same TTL (IPv4) or Hop limit (IPv6) value. 	 */
define|#
directive|define
name|HWRM_VNIC_TPA_QCFG_OUTPUT_FLAGS_GRO_TTL_CHECK
value|UINT32_C(0x80)
name|uint16_t
name|max_agg_segs
decl_stmt|;
comment|/* 	 * This is the maximum number of TCP segments that can be aggregated 	 * (unit is Log2). Max value is 31. 	 */
comment|/* 1 segment */
define|#
directive|define
name|HWRM_VNIC_TPA_QCFG_OUTPUT_MAX_AGG_SEGS_1
value|UINT32_C(0x0)
comment|/* 2 segments */
define|#
directive|define
name|HWRM_VNIC_TPA_QCFG_OUTPUT_MAX_AGG_SEGS_2
value|UINT32_C(0x1)
comment|/* 4 segments */
define|#
directive|define
name|HWRM_VNIC_TPA_QCFG_OUTPUT_MAX_AGG_SEGS_4
value|UINT32_C(0x2)
comment|/* 8 segments */
define|#
directive|define
name|HWRM_VNIC_TPA_QCFG_OUTPUT_MAX_AGG_SEGS_8
value|UINT32_C(0x3)
comment|/* Any segment size larger than this is not valid */
define|#
directive|define
name|HWRM_VNIC_TPA_QCFG_OUTPUT_MAX_AGG_SEGS_MAX
value|UINT32_C(0x1f)
name|uint16_t
name|max_aggs
decl_stmt|;
comment|/* 	 * This is the maximum number of aggregations this VNIC is allowed (unit 	 * is Log2). Max value is 7 	 */
comment|/* 1 aggregation */
define|#
directive|define
name|HWRM_VNIC_TPA_QCFG_OUTPUT_MAX_AGGS_1
value|UINT32_C(0x0)
comment|/* 2 aggregations */
define|#
directive|define
name|HWRM_VNIC_TPA_QCFG_OUTPUT_MAX_AGGS_2
value|UINT32_C(0x1)
comment|/* 4 aggregations */
define|#
directive|define
name|HWRM_VNIC_TPA_QCFG_OUTPUT_MAX_AGGS_4
value|UINT32_C(0x2)
comment|/* 8 aggregations */
define|#
directive|define
name|HWRM_VNIC_TPA_QCFG_OUTPUT_MAX_AGGS_8
value|UINT32_C(0x3)
comment|/* 16 aggregations */
define|#
directive|define
name|HWRM_VNIC_TPA_QCFG_OUTPUT_MAX_AGGS_16
value|UINT32_C(0x4)
comment|/* Any aggregation size larger than this is not valid */
define|#
directive|define
name|HWRM_VNIC_TPA_QCFG_OUTPUT_MAX_AGGS_MAX
value|UINT32_C(0x7)
name|uint32_t
name|max_agg_timer
decl_stmt|;
comment|/* 	 * This is the maximum amount of time allowed for an aggregation context 	 * to complete after it was initiated. 	 */
name|uint32_t
name|min_agg_len
decl_stmt|;
comment|/* 	 * This is the minimum amount of payload length required to start an 	 * aggregation context. 	 */
name|uint32_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_vnic_rss_cfg */
end_comment

begin_comment
comment|/* Description: This function is used to enable RSS configuration. */
end_comment

begin_comment
comment|/* Input (48 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_vnic_rss_cfg_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint32_t
name|hash_type
decl_stmt|;
comment|/* 	 * When this bit is '1', the RSS hash shall be computed over source and 	 * destination IPv4 addresses of IPv4 packets. 	 */
define|#
directive|define
name|HWRM_VNIC_RSS_CFG_INPUT_HASH_TYPE_IPV4
value|UINT32_C(0x1)
comment|/* 	 * When this bit is '1', the RSS hash shall be computed over 	 * source/destination IPv4 addresses and source/destination ports of 	 * TCP/IPv4 packets. 	 */
define|#
directive|define
name|HWRM_VNIC_RSS_CFG_INPUT_HASH_TYPE_TCP_IPV4
value|UINT32_C(0x2)
comment|/* 	 * When this bit is '1', the RSS hash shall be computed over 	 * source/destination IPv4 addresses and source/destination ports of 	 * UDP/IPv4 packets. 	 */
define|#
directive|define
name|HWRM_VNIC_RSS_CFG_INPUT_HASH_TYPE_UDP_IPV4
value|UINT32_C(0x4)
comment|/* 	 * When this bit is '1', the RSS hash shall be computed over source and 	 * destination IPv4 addresses of IPv6 packets. 	 */
define|#
directive|define
name|HWRM_VNIC_RSS_CFG_INPUT_HASH_TYPE_IPV6
value|UINT32_C(0x8)
comment|/* 	 * When this bit is '1', the RSS hash shall be computed over 	 * source/destination IPv6 addresses and source/destination ports of 	 * TCP/IPv6 packets. 	 */
define|#
directive|define
name|HWRM_VNIC_RSS_CFG_INPUT_HASH_TYPE_TCP_IPV6
value|UINT32_C(0x10)
comment|/* 	 * When this bit is '1', the RSS hash shall be computed over 	 * source/destination IPv6 addresses and source/destination ports of 	 * UDP/IPv6 packets. 	 */
define|#
directive|define
name|HWRM_VNIC_RSS_CFG_INPUT_HASH_TYPE_UDP_IPV6
value|UINT32_C(0x20)
name|uint32_t
name|unused_0
decl_stmt|;
name|uint64_t
name|ring_grp_tbl_addr
decl_stmt|;
comment|/* This is the address for rss ring group table */
name|uint64_t
name|hash_key_tbl_addr
decl_stmt|;
comment|/* This is the address for rss hash key table */
name|uint16_t
name|rss_ctx_idx
decl_stmt|;
comment|/* Index to the rss indirection table. */
name|uint16_t
name|unused_1
index|[
literal|3
index|]
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_vnic_rss_cfg_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint32_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_vnic_rss_qcfg */
end_comment

begin_comment
comment|/* Description: This function is used to query RSS context configuration. */
end_comment

begin_comment
comment|/* Input (24 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_vnic_rss_qcfg_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint16_t
name|rss_ctx_idx
decl_stmt|;
comment|/* Index to the rss indirection table. */
name|uint16_t
name|unused_0
index|[
literal|3
index|]
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (64 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_vnic_rss_qcfg_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint32_t
name|hash_type
decl_stmt|;
comment|/* 	 * When this bit is '1', the RSS hash shall be computed over source and 	 * destination IPv4 addresses of IPv4 packets. 	 */
define|#
directive|define
name|HWRM_VNIC_RSS_QCFG_OUTPUT_HASH_TYPE_IPV4
value|UINT32_C(0x1)
comment|/* 	 * When this bit is '1', the RSS hash shall be computed over 	 * source/destination IPv4 addresses and source/destination ports of 	 * TCP/IPv4 packets. 	 */
define|#
directive|define
name|HWRM_VNIC_RSS_QCFG_OUTPUT_HASH_TYPE_TCP_IPV4
value|UINT32_C(0x2)
comment|/* 	 * When this bit is '1', the RSS hash shall be computed over 	 * source/destination IPv4 addresses and source/destination ports of 	 * UDP/IPv4 packets. 	 */
define|#
directive|define
name|HWRM_VNIC_RSS_QCFG_OUTPUT_HASH_TYPE_UDP_IPV4
value|UINT32_C(0x4)
comment|/* 	 * When this bit is '1', the RSS hash shall be computed over source and 	 * destination IPv4 addresses of IPv6 packets. 	 */
define|#
directive|define
name|HWRM_VNIC_RSS_QCFG_OUTPUT_HASH_TYPE_IPV6
value|UINT32_C(0x8)
comment|/* 	 * When this bit is '1', the RSS hash shall be computed over 	 * source/destination IPv6 addresses and source/destination ports of 	 * TCP/IPv6 packets. 	 */
define|#
directive|define
name|HWRM_VNIC_RSS_QCFG_OUTPUT_HASH_TYPE_TCP_IPV6
value|UINT32_C(0x10)
comment|/* 	 * When this bit is '1', the RSS hash shall be computed over 	 * source/destination IPv6 addresses and source/destination ports of 	 * UDP/IPv6 packets. 	 */
define|#
directive|define
name|HWRM_VNIC_RSS_QCFG_OUTPUT_HASH_TYPE_UDP_IPV6
value|UINT32_C(0x20)
name|uint32_t
name|unused_0
decl_stmt|;
name|uint32_t
name|hash_key
index|[
literal|10
index|]
decl_stmt|;
comment|/* This is the value of rss hash key */
name|uint32_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint8_t
name|unused_4
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_vnic_plcmodes_cfg */
end_comment

begin_comment
comment|/*  * Description: This function can be used to set placement mode configuration of  * the VNIC.  */
end_comment

begin_comment
comment|/* Input (40 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_vnic_plcmodes_cfg_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint32_t
name|flags
decl_stmt|;
comment|/* 	 * When this bit is '1', the VNIC shall be configured to use regular 	 * placement algorithm. By default, the regular placement algorithm 	 * shall be enabled on the VNIC. 	 */
define|#
directive|define
name|HWRM_VNIC_PLCMODES_CFG_INPUT_FLAGS_REGULAR_PLACEMENT
value|UINT32_C(0x1)
comment|/* 	 * When this bit is '1', the VNIC shall be configured use the jumbo 	 * placement algorithm. 	 */
define|#
directive|define
name|HWRM_VNIC_PLCMODES_CFG_INPUT_FLAGS_JUMBO_PLACEMENT
value|UINT32_C(0x2)
comment|/* 	 * When this bit is '1', the VNIC shall be configured to enable Header- 	 * Data split for IPv4 packets according to the following rules: # If 	 * the packet is identified as TCP/IPv4, then the packet is split at the 	 * beginning of the TCP payload. # If the packet is identified as 	 * UDP/IPv4, then the packet is split at the beginning of UDP payload. # 	 * If the packet is identified as non-TCP and non-UDP IPv4 packet, then 	 * the packet is split at the beginning of the upper layer protocol 	 * header carried in the IPv4 packet. 	 */
define|#
directive|define
name|HWRM_VNIC_PLCMODES_CFG_INPUT_FLAGS_HDS_IPV4
value|UINT32_C(0x4)
comment|/* 	 * When this bit is '1', the VNIC shall be configured to enable Header- 	 * Data split for IPv6 packets according to the following rules: # If 	 * the packet is identified as TCP/IPv6, then the packet is split at the 	 * beginning of the TCP payload. # If the packet is identified as 	 * UDP/IPv6, then the packet is split at the beginning of UDP payload. # 	 * If the packet is identified as non-TCP and non-UDP IPv6 packet, then 	 * the packet is split at the beginning of the upper layer protocol 	 * header carried in the IPv6 packet. 	 */
define|#
directive|define
name|HWRM_VNIC_PLCMODES_CFG_INPUT_FLAGS_HDS_IPV6
value|UINT32_C(0x8)
comment|/* 	 * When this bit is '1', the VNIC shall be configured to enable Header- 	 * Data split for FCoE packets at the beginning of FC payload. 	 */
define|#
directive|define
name|HWRM_VNIC_PLCMODES_CFG_INPUT_FLAGS_HDS_FCOE
value|UINT32_C(0x10)
comment|/* 	 * When this bit is '1', the VNIC shall be configured to enable Header- 	 * Data split for RoCE packets at the beginning of RoCE payload (after 	 * BTH/GRH headers). 	 */
define|#
directive|define
name|HWRM_VNIC_PLCMODES_CFG_INPUT_FLAGS_HDS_ROCE
value|UINT32_C(0x20)
name|uint32_t
name|enables
decl_stmt|;
comment|/* 	 * This bit must be '1' for the jumbo_thresh_valid field to be 	 * configured. 	 */
define|#
directive|define
name|HWRM_VNIC_PLCMODES_CFG_INPUT_ENABLES_JUMBO_THRESH_VALID
value|UINT32_C(0x1)
comment|/* This bit must be '1' for the hds_offset_valid field to be configured. */
define|#
directive|define
name|HWRM_VNIC_PLCMODES_CFG_INPUT_ENABLES_HDS_OFFSET_VALID
value|UINT32_C(0x2)
comment|/* 	 * This bit must be '1' for the hds_threshold_valid field to be 	 * configured. 	 */
define|#
directive|define
name|HWRM_VNIC_PLCMODES_CFG_INPUT_ENABLES_HDS_THRESHOLD_VALID
value|UINT32_C(0x4)
name|uint32_t
name|vnic_id
decl_stmt|;
comment|/* Logical vnic ID */
name|uint16_t
name|jumbo_thresh
decl_stmt|;
comment|/* 	 * When jumbo placement algorithm is enabled, this value is used to 	 * determine the threshold for jumbo placement. Packets with length 	 * larger than this value will be placed according to the jumbo 	 * placement algorithm. 	 */
name|uint16_t
name|hds_offset
decl_stmt|;
comment|/* 	 * This value is used to determine the offset into packet buffer where 	 * the split data (payload) will be placed according to one of of HDS 	 * placement algorithm. The lengths of packet buffers provided for split 	 * data shall be larger than this value. 	 */
name|uint16_t
name|hds_threshold
decl_stmt|;
comment|/* 	 * When one of the HDS placement algorithm is enabled, this value is 	 * used to determine the threshold for HDS placement. Packets with 	 * length larger than this value will be placed according to the HDS 	 * placement algorithm. This value shall be in multiple of 4 bytes. 	 */
name|uint16_t
name|unused_0
index|[
literal|3
index|]
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_vnic_plcmodes_cfg_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint32_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_vnic_plcmodes_qcfg */
end_comment

begin_comment
comment|/*  * Description: This function can be used to query placement mode configuration  * of the VNIC.  */
end_comment

begin_comment
comment|/* Input (24 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_vnic_plcmodes_qcfg_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint32_t
name|vnic_id
decl_stmt|;
comment|/* Logical vnic ID */
name|uint32_t
name|unused_0
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (24 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_vnic_plcmodes_qcfg_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint32_t
name|flags
decl_stmt|;
comment|/* 	 * When this bit is '1', the VNIC is configured to use regular placement 	 * algorithm. 	 */
define|#
directive|define
name|HWRM_VNIC_PLCMODES_QCFG_OUTPUT_FLAGS_REGULAR_PLACEMENT
value|UINT32_C(0x1)
comment|/* 	 * When this bit is '1', the VNIC is configured to use the jumbo 	 * placement algorithm. 	 */
define|#
directive|define
name|HWRM_VNIC_PLCMODES_QCFG_OUTPUT_FLAGS_JUMBO_PLACEMENT
value|UINT32_C(0x2)
comment|/* 	 * When this bit is '1', the VNIC is configured to enable Header-Data 	 * split for IPv4 packets. 	 */
define|#
directive|define
name|HWRM_VNIC_PLCMODES_QCFG_OUTPUT_FLAGS_HDS_IPV4
value|UINT32_C(0x4)
comment|/* 	 * When this bit is '1', the VNIC is configured to enable Header-Data 	 * split for IPv6 packets. 	 */
define|#
directive|define
name|HWRM_VNIC_PLCMODES_QCFG_OUTPUT_FLAGS_HDS_IPV6
value|UINT32_C(0x8)
comment|/* 	 * When this bit is '1', the VNIC is configured to enable Header-Data 	 * split for FCoE packets. 	 */
define|#
directive|define
name|HWRM_VNIC_PLCMODES_QCFG_OUTPUT_FLAGS_HDS_FCOE
value|UINT32_C(0x10)
comment|/* 	 * When this bit is '1', the VNIC is configured to enable Header-Data 	 * split for RoCE packets. 	 */
define|#
directive|define
name|HWRM_VNIC_PLCMODES_QCFG_OUTPUT_FLAGS_HDS_ROCE
value|UINT32_C(0x20)
comment|/* 	 * When this bit is '1', the VNIC is configured to be the default VNIC 	 * of the requesting function. 	 */
define|#
directive|define
name|HWRM_VNIC_PLCMODES_QCFG_OUTPUT_FLAGS_DFLT_VNIC
value|UINT32_C(0x40)
name|uint16_t
name|jumbo_thresh
decl_stmt|;
comment|/* 	 * When jumbo placement algorithm is enabled, this value is used to 	 * determine the threshold for jumbo placement. Packets with length 	 * larger than this value will be placed according to the jumbo 	 * placement algorithm. 	 */
name|uint16_t
name|hds_offset
decl_stmt|;
comment|/* 	 * This value is used to determine the offset into packet buffer where 	 * the split data (payload) will be placed according to one of of HDS 	 * placement algorithm. The lengths of packet buffers provided for split 	 * data shall be larger than this value. 	 */
name|uint16_t
name|hds_threshold
decl_stmt|;
comment|/* 	 * When one of the HDS placement algorithm is enabled, this value is 	 * used to determine the threshold for HDS placement. Packets with 	 * length larger than this value will be placed according to the HDS 	 * placement algorithm. This value shall be in multiple of 4 bytes. 	 */
name|uint8_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint8_t
name|unused_4
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_vnic_rss_cos_lb_ctx_alloc */
end_comment

begin_comment
comment|/* Description: This function is used to allocate COS/Load Balance context. */
end_comment

begin_comment
comment|/* Input (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_vnic_rss_cos_lb_ctx_alloc_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_vnic_rss_cos_lb_ctx_alloc_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint16_t
name|rss_cos_lb_ctx_id
decl_stmt|;
comment|/* rss_cos_lb_ctx_id is 16 b */
name|uint8_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint8_t
name|unused_4
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_vnic_rss_cos_lb_ctx_free */
end_comment

begin_comment
comment|/* Description: This function can be used to free COS/Load Balance context. */
end_comment

begin_comment
comment|/* Input (24 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_vnic_rss_cos_lb_ctx_free_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint16_t
name|rss_cos_lb_ctx_id
decl_stmt|;
comment|/* rss_cos_lb_ctx_id is 16 b */
name|uint16_t
name|unused_0
index|[
literal|3
index|]
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_vnic_rss_cos_lb_ctx_free_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint32_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_ring_alloc */
end_comment

begin_comment
comment|/*  * Description: This command allocates and does basic preparation for a ring.  */
end_comment

begin_comment
comment|/* Input (80 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_ring_alloc_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint32_t
name|enables
decl_stmt|;
comment|/* This bit must be '1' for the Reserved1 field to be configured. */
define|#
directive|define
name|HWRM_RING_ALLOC_INPUT_ENABLES_RESERVED1
value|UINT32_C(0x1)
comment|/* This bit must be '1' for the ring_arb_cfg field to be configured. */
define|#
directive|define
name|HWRM_RING_ALLOC_INPUT_ENABLES_RING_ARB_CFG
value|UINT32_C(0x2)
comment|/* This bit must be '1' for the Reserved3 field to be configured. */
define|#
directive|define
name|HWRM_RING_ALLOC_INPUT_ENABLES_RESERVED3
value|UINT32_C(0x4)
comment|/* 	 * This bit must be '1' for the stat_ctx_id_valid field to be 	 * configured. 	 */
define|#
directive|define
name|HWRM_RING_ALLOC_INPUT_ENABLES_STAT_CTX_ID_VALID
value|UINT32_C(0x8)
comment|/* This bit must be '1' for the Reserved4 field to be configured. */
define|#
directive|define
name|HWRM_RING_ALLOC_INPUT_ENABLES_RESERVED4
value|UINT32_C(0x10)
comment|/* This bit must be '1' for the max_bw_valid field to be configured. */
define|#
directive|define
name|HWRM_RING_ALLOC_INPUT_ENABLES_MAX_BW_VALID
value|UINT32_C(0x20)
name|uint8_t
name|ring_type
decl_stmt|;
comment|/* Ring Type. */
comment|/* L2 Completion Ring (CR) */
define|#
directive|define
name|HWRM_RING_ALLOC_INPUT_RING_TYPE_L2_CMPL
value|UINT32_C(0x0)
comment|/* TX Ring (TR) */
define|#
directive|define
name|HWRM_RING_ALLOC_INPUT_RING_TYPE_TX
value|UINT32_C(0x1)
comment|/* RX Ring (RR) */
define|#
directive|define
name|HWRM_RING_ALLOC_INPUT_RING_TYPE_RX
value|UINT32_C(0x2)
comment|/* RoCE Notification Completion Ring (ROCE_CR) */
define|#
directive|define
name|HWRM_RING_ALLOC_INPUT_RING_TYPE_ROCE_CMPL
value|UINT32_C(0x3)
name|uint8_t
name|unused_0
decl_stmt|;
name|uint16_t
name|unused_1
decl_stmt|;
name|uint64_t
name|page_tbl_addr
decl_stmt|;
comment|/* This value is a pointer to the page table for the Ring. */
name|uint32_t
name|fbo
decl_stmt|;
comment|/* First Byte Offset of the first entry in the first page. */
name|uint8_t
name|page_size
decl_stmt|;
comment|/* 	 * Actual page size in 2^page_size. The supported range is increments in 	 * powers of 2 from 16 bytes to 1GB. - 4 = 16 B Page size is 16 B. - 12 	 * = 4 KB Page size is 4 KB. - 13 = 8 KB Page size is 8 KB. - 16 = 64 KB 	 * Page size is 64 KB. - 21 = 2 MB Page size is 2 MB. - 22 = 4 MB Page 	 * size is 4 MB. - 30 = 1 GB Page size is 1 GB. 	 */
name|uint8_t
name|page_tbl_depth
decl_stmt|;
comment|/* 	 * This value indicates the depth of page table. For this version of the 	 * specification, value other than 0 or 1 shall be considered as an 	 * invalid value. When the page_tbl_depth = 0, then it is treated as a 	 * special case with the following. 1. FBO and page size fields are not 	 * valid. 2. page_tbl_addr is the physical address of the first element 	 * of the ring. 	 */
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint32_t
name|length
decl_stmt|;
comment|/* 	 * Number of 16B units in the ring. Minimum size for a ring is 16 16B 	 * entries. 	 */
name|uint16_t
name|logical_id
decl_stmt|;
comment|/* 	 * Logical ring number for the ring to be allocated. This value 	 * determines the position in the doorbell area where the update to the 	 * ring will be made. For completion rings, this value is also the MSI-X 	 * vector number for the function the completion ring is associated 	 * with. 	 */
name|uint16_t
name|cmpl_ring_id
decl_stmt|;
comment|/* 	 * This field is used only when ring_type is a TX ring. This value 	 * indicates what completion ring the TX ring is associated with. 	 */
name|uint16_t
name|queue_id
decl_stmt|;
comment|/* 	 * This field is used only when ring_type is a TX ring. This value 	 * indicates what CoS queue the TX ring is associated with. 	 */
name|uint8_t
name|unused_4
decl_stmt|;
name|uint8_t
name|unused_5
decl_stmt|;
name|uint32_t
name|reserved1
decl_stmt|;
comment|/* This field is reserved for the future use. It shall be set to 0. */
name|uint16_t
name|ring_arb_cfg
decl_stmt|;
comment|/* 	 * This field is used only when ring_type is a TX ring. This field is 	 * used to configure arbitration related parameters for a TX ring. 	 */
comment|/* Arbitration policy used for the ring. */
define|#
directive|define
name|HWRM_RING_ALLOC_INPUT_RING_ARB_CFG_ARB_POLICY_MASK
value|UINT32_C(0xf)
define|#
directive|define
name|HWRM_RING_ALLOC_INPUT_RING_ARB_CFG_ARB_POLICY_SFT
value|0
comment|/* 	 * Use strict priority for the TX ring. Priority value is 	 * specified in arb_policy_param 	 */
define|#
directive|define
name|HWRM_RING_ALLOC_INPUT_RING_ARB_CFG_ARB_POLICY_SP
value|(UINT32_C(0x1)<< 0)
comment|/* 	 * Use weighted fair queue arbitration for the TX ring. Weight 	 * is specified in arb_policy_param 	 */
define|#
directive|define
name|HWRM_RING_ALLOC_INPUT_RING_ARB_CFG_ARB_POLICY_WFQ
value|(UINT32_C(0x2)<< 0)
define|#
directive|define
name|HWRM_RING_ALLOC_INPUT_RING_ARB_CFG_ARB_POLICY_LAST
value|HWRM_RING_ALLOC_INPUT_RING_ARB_CFG_ARB_POLICY_WFQ
comment|/* Reserved field. */
define|#
directive|define
name|HWRM_RING_ALLOC_INPUT_RING_ARB_CFG_RSVD_MASK
value|UINT32_C(0xf0)
define|#
directive|define
name|HWRM_RING_ALLOC_INPUT_RING_ARB_CFG_RSVD_SFT
value|4
comment|/* 	 * Arbitration policy specific parameter. # For strict priority 	 * arbitration policy, this field represents a priority value. If set to 	 * 0, then the priority is not specified and the HWRM is allowed to 	 * select any priority for this TX ring. # For weighted fair queue 	 * arbitration policy, this field represents a weight value. If set to 	 * 0, then the weight is not specified and the HWRM is allowed to select 	 * any weight for this TX ring. 	 */
define|#
directive|define
name|HWRM_RING_ALLOC_INPUT_RING_ARB_CFG_ARB_POLICY_PARAM_MASK
value|UINT32_C(0xff00)
define|#
directive|define
name|HWRM_RING_ALLOC_INPUT_RING_ARB_CFG_ARB_POLICY_PARAM_SFT
value|8
name|uint8_t
name|unused_6
decl_stmt|;
name|uint8_t
name|unused_7
decl_stmt|;
name|uint32_t
name|reserved3
decl_stmt|;
comment|/* This field is reserved for the future use. It shall be set to 0. */
name|uint32_t
name|stat_ctx_id
decl_stmt|;
comment|/* 	 * This field is used only when ring_type is a TX ring. This input 	 * indicates what statistics context this ring should be associated 	 * with. 	 */
name|uint32_t
name|reserved4
decl_stmt|;
comment|/* This field is reserved for the future use. It shall be set to 0. */
name|uint32_t
name|max_bw
decl_stmt|;
comment|/* 	 * This field is used only when ring_type is a TX ring to specify 	 * maximum BW allocated to the TX ring. The HWRM will translate this 	 * value into byte counter and time interval used for this ring inside 	 * the device. 	 */
comment|/* The bandwidth value. */
define|#
directive|define
name|HWRM_RING_ALLOC_INPUT_MAX_BW_BW_VALUE_MASK
value|UINT32_C(0xfffffff)
define|#
directive|define
name|HWRM_RING_ALLOC_INPUT_MAX_BW_BW_VALUE_SFT
value|0
comment|/* The granularity of the value (bits or bytes). */
define|#
directive|define
name|HWRM_RING_ALLOC_INPUT_MAX_BW_SCALE
value|UINT32_C(0x10000000)
comment|/* Value is in bits. */
define|#
directive|define
name|HWRM_RING_ALLOC_INPUT_MAX_BW_SCALE_BITS
value|(UINT32_C(0x0)<< 28)
comment|/* Value is in bytes. */
define|#
directive|define
name|HWRM_RING_ALLOC_INPUT_MAX_BW_SCALE_BYTES
value|(UINT32_C(0x1)<< 28)
define|#
directive|define
name|HWRM_RING_ALLOC_INPUT_MAX_BW_SCALE_LAST
value|HWRM_RING_ALLOC_INPUT_MAX_BW_SCALE_BYTES
comment|/* bw_value_unit is 3 b */
define|#
directive|define
name|HWRM_RING_ALLOC_INPUT_MAX_BW_BW_VALUE_UNIT_MASK
value|UINT32_C(0xe0000000)
define|#
directive|define
name|HWRM_RING_ALLOC_INPUT_MAX_BW_BW_VALUE_UNIT_SFT
value|29
comment|/* Value is in Mb or MB (base 10). */
define|#
directive|define
name|HWRM_RING_ALLOC_INPUT_MAX_BW_BW_VALUE_UNIT_MEGA
value|(UINT32_C(0x0)<< 29)
comment|/* Value is in Kb or KB (base 10). */
define|#
directive|define
name|HWRM_RING_ALLOC_INPUT_MAX_BW_BW_VALUE_UNIT_KILO
value|(UINT32_C(0x2)<< 29)
comment|/* Value is in bits or bytes. */
define|#
directive|define
name|HWRM_RING_ALLOC_INPUT_MAX_BW_BW_VALUE_UNIT_BASE
value|(UINT32_C(0x4)<< 29)
comment|/* Value is in Gb or GB (base 10). */
define|#
directive|define
name|HWRM_RING_ALLOC_INPUT_MAX_BW_BW_VALUE_UNIT_GIGA
value|(UINT32_C(0x6)<< 29)
comment|/* Value is in 1/100th of a percentage of total bandwidth. */
define|#
directive|define
name|HWRM_RING_ALLOC_INPUT_MAX_BW_BW_VALUE_UNIT_PERCENT1_100
value|(UINT32_C(0x1)<< 29)
comment|/* Invalid unit */
define|#
directive|define
name|HWRM_RING_ALLOC_INPUT_MAX_BW_BW_VALUE_UNIT_INVALID
value|(UINT32_C(0x7)<< 29)
define|#
directive|define
name|HWRM_RING_ALLOC_INPUT_MAX_BW_BW_VALUE_UNIT_LAST
value|HWRM_RING_ALLOC_INPUT_MAX_BW_BW_VALUE_UNIT_INVALID
name|uint8_t
name|int_mode
decl_stmt|;
comment|/* 	 * This field is used only when ring_type is a Completion ring. This 	 * value indicates what interrupt mode should be used on this completion 	 * ring. Note: In the legacy interrupt mode, no more than 16 completion 	 * rings are allowed. 	 */
comment|/* Legacy INTA */
define|#
directive|define
name|HWRM_RING_ALLOC_INPUT_INT_MODE_LEGACY
value|UINT32_C(0x0)
comment|/* Reserved */
define|#
directive|define
name|HWRM_RING_ALLOC_INPUT_INT_MODE_RSVD
value|UINT32_C(0x1)
comment|/* MSI-X */
define|#
directive|define
name|HWRM_RING_ALLOC_INPUT_INT_MODE_MSIX
value|UINT32_C(0x2)
comment|/* No Interrupt - Polled mode */
define|#
directive|define
name|HWRM_RING_ALLOC_INPUT_INT_MODE_POLL
value|UINT32_C(0x3)
name|uint8_t
name|unused_8
index|[
literal|3
index|]
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_ring_alloc_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint16_t
name|ring_id
decl_stmt|;
comment|/* 	 * Physical number of ring allocated. This value shall be unique for a 	 * ring type. 	 */
name|uint16_t
name|logical_ring_id
decl_stmt|;
comment|/* Logical number of ring allocated. */
name|uint8_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_ring_free */
end_comment

begin_comment
comment|/*  * Description: This command is used to free a ring and associated resources.  * With QoS and DCBx agents, it is possible the traffic classes will be moved  * from one CoS queue to another. When this occurs, the driver shall call  * 'hwrm_ring_free' to free the allocated rings and then call 'hwrm_ring_alloc'  * to re-allocate each ring and assign it to a new CoS queue. hwrm_ring_free  * shall be called on a ring only after it has been idle for 500ms or more and  * no frames have been posted to the ring during this time. All frames queued  * for transmission shall be completed and at least 500ms time elapsed from the  * last completion before calling this command.  */
end_comment

begin_comment
comment|/* Input (24 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_ring_free_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint8_t
name|ring_type
decl_stmt|;
comment|/* Ring Type. */
comment|/* L2 Completion Ring (CR) */
define|#
directive|define
name|HWRM_RING_FREE_INPUT_RING_TYPE_L2_CMPL
value|UINT32_C(0x0)
comment|/* TX Ring (TR) */
define|#
directive|define
name|HWRM_RING_FREE_INPUT_RING_TYPE_TX
value|UINT32_C(0x1)
comment|/* RX Ring (RR) */
define|#
directive|define
name|HWRM_RING_FREE_INPUT_RING_TYPE_RX
value|UINT32_C(0x2)
comment|/* RoCE Notification Completion Ring (ROCE_CR) */
define|#
directive|define
name|HWRM_RING_FREE_INPUT_RING_TYPE_ROCE_CMPL
value|UINT32_C(0x3)
name|uint8_t
name|unused_0
decl_stmt|;
name|uint16_t
name|ring_id
decl_stmt|;
comment|/* Physical number of ring allocated. */
name|uint32_t
name|unused_1
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_ring_free_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint32_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_ring_cmpl_ring_qaggint_params */
end_comment

begin_comment
comment|/*  * Description: This command is used to query aggregation and interrupt related  * parameters specified on a given completion ring.  */
end_comment

begin_comment
comment|/* Input (24 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_ring_cmpl_ring_qaggint_params_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint16_t
name|ring_id
decl_stmt|;
comment|/* Physical number of completion ring. */
name|uint16_t
name|unused_0
index|[
literal|3
index|]
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (32 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_ring_cmpl_ring_qaggint_params_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint16_t
name|flags
decl_stmt|;
comment|/* 	 * When this bit is set to '1', interrupt max timer is reset whenever a 	 * completion is received. 	 */
define|#
directive|define
name|HWRM_RING_CMPL_RING_QAGGINT_PARAMS_OUTPUT_FLAGS_TIMER_RESET
value|UINT32_C(0x1)
comment|/* 	 * When this bit is set to '1', ring idle mode aggregation will be 	 * enabled. 	 */
define|#
directive|define
name|HWRM_RING_CMPL_RING_QAGGINT_PARAMS_OUTPUT_FLAGS_RING_IDLE
value|UINT32_C(0x2)
name|uint16_t
name|num_cmpl_dma_aggr
decl_stmt|;
comment|/* Number of completions to aggregate before DMA during the normal mode. */
name|uint16_t
name|num_cmpl_dma_aggr_during_int
decl_stmt|;
comment|/* 	 * Number of completions to aggregate before DMA during the interrupt 	 * mode. 	 */
name|uint16_t
name|cmpl_aggr_dma_tmr
decl_stmt|;
comment|/* 	 * Timer in unit of 80-nsec used to aggregate completions before DMA 	 * during the normal mode (not in interrupt mode). 	 */
name|uint16_t
name|cmpl_aggr_dma_tmr_during_int
decl_stmt|;
comment|/* 	 * Timer in unit of 80-nsec used to aggregate completions before DMA 	 * during the interrupt mode. 	 */
name|uint16_t
name|int_lat_tmr_min
decl_stmt|;
comment|/* Minimum time (in unit of 80-nsec) between two interrupts. */
name|uint16_t
name|int_lat_tmr_max
decl_stmt|;
comment|/* 	 * Maximum wait time (in unit of 80-nsec) spent aggregating completions 	 * before signaling the interrupt after the interrupt is enabled. 	 */
name|uint16_t
name|num_cmpl_aggr_int
decl_stmt|;
comment|/* 	 * Minimum number of completions aggregated before signaling an 	 * interrupt. 	 */
name|uint32_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_ring_cmpl_ring_cfg_aggint_params */
end_comment

begin_comment
comment|/*  * Description: This command is used to configure aggregation and interrupt  * related parameters specified on a given completion ring.  */
end_comment

begin_comment
comment|/* Input (40 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_ring_cmpl_ring_cfg_aggint_params_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint16_t
name|ring_id
decl_stmt|;
comment|/* Physical number of completion ring. */
name|uint16_t
name|flags
decl_stmt|;
comment|/* 	 * When this bit is set to '1', interrupt latency max timer is reset 	 * whenever a completion is received. 	 */
define|#
directive|define
name|HWRM_RING_CMPL_RING_CFG_AGGINT_PARAMS_INPUT_FLAGS_TIMER_RESET
value|UINT32_C(0x1)
comment|/* 	 * When this bit is set to '1', ring idle mode aggregation will be 	 * enabled. 	 */
define|#
directive|define
name|HWRM_RING_CMPL_RING_CFG_AGGINT_PARAMS_INPUT_FLAGS_RING_IDLE
value|UINT32_C(0x2)
name|uint16_t
name|num_cmpl_dma_aggr
decl_stmt|;
comment|/* Number of completions to aggregate before DMA during the normal mode. */
name|uint16_t
name|num_cmpl_dma_aggr_during_int
decl_stmt|;
comment|/* 	 * Number of completions to aggregate before DMA during the interrupt 	 * mode. 	 */
name|uint16_t
name|cmpl_aggr_dma_tmr
decl_stmt|;
comment|/* 	 * Timer in unit of 80-nsec used to aggregate completions before DMA 	 * during the normal mode (not in interrupt mode). 	 */
name|uint16_t
name|cmpl_aggr_dma_tmr_during_int
decl_stmt|;
comment|/* 	 * Timer in unit of 80-nsec used to aggregate completions before DMA 	 * during the interrupt mode. 	 */
name|uint16_t
name|int_lat_tmr_min
decl_stmt|;
comment|/* Minimum time (in unit of 80-nsec) between two interrupts. */
name|uint16_t
name|int_lat_tmr_max
decl_stmt|;
comment|/* 	 * Maximum wait time (in unit of 80-nsec) spent aggregating cmpls before 	 * signaling the interrupt after the interrupt is enabled. 	 */
name|uint16_t
name|num_cmpl_aggr_int
decl_stmt|;
comment|/* 	 * Minimum number of completions aggregated before signaling an 	 * interrupt. 	 */
name|uint16_t
name|unused_0
index|[
literal|3
index|]
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_ring_cmpl_ring_cfg_aggint_params_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint32_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_ring_reset */
end_comment

begin_comment
comment|/*  * Description: This command is used to reset a given ring. When an RX ring is  * being reset, the HWRM shall perform TPA flush on all VNICs associated with  * the RX ring that is being reset.  */
end_comment

begin_comment
comment|/* Input (24 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_ring_reset_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint8_t
name|ring_type
decl_stmt|;
comment|/* Ring Type. */
comment|/* L2 Completion Ring (CR) */
define|#
directive|define
name|HWRM_RING_RESET_INPUT_RING_TYPE_L2_CMPL
value|UINT32_C(0x0)
comment|/* TX Ring (TR) */
define|#
directive|define
name|HWRM_RING_RESET_INPUT_RING_TYPE_TX
value|UINT32_C(0x1)
comment|/* RX Ring (RR) */
define|#
directive|define
name|HWRM_RING_RESET_INPUT_RING_TYPE_RX
value|UINT32_C(0x2)
comment|/* RoCE Notification Completion Ring (ROCE_CR) */
define|#
directive|define
name|HWRM_RING_RESET_INPUT_RING_TYPE_ROCE_CMPL
value|UINT32_C(0x3)
name|uint8_t
name|unused_0
decl_stmt|;
name|uint16_t
name|ring_id
decl_stmt|;
comment|/* Physical number of the ring. */
name|uint32_t
name|unused_1
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_ring_reset_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint32_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_ring_grp_alloc */
end_comment

begin_comment
comment|/*  * Description: This API allocates and does basic preparation for a ring group.  */
end_comment

begin_comment
comment|/* Input (24 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_ring_grp_alloc_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint16_t
name|cr
decl_stmt|;
comment|/* This value identifies the CR associated with the ring group. */
name|uint16_t
name|rr
decl_stmt|;
comment|/* This value identifies the main RR associated with the ring group. */
name|uint16_t
name|ar
decl_stmt|;
comment|/* 	 * This value identifies the aggregation RR associated with the ring 	 * group. If this value is 0xFF... (All Fs), then no Aggregation ring 	 * will be set. 	 */
name|uint16_t
name|sc
decl_stmt|;
comment|/* 	 * This value identifies the statistics context associated with the ring 	 * group. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_ring_grp_alloc_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint32_t
name|ring_group_id
decl_stmt|;
comment|/* 	 * This is the ring group ID value. Use this value to program the 	 * default ring group for the VNIC or as table entries in an RSS/COS 	 * context. 	 */
name|uint8_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_ring_grp_free */
end_comment

begin_comment
comment|/*  * Description: This API frees a ring group and associated resources. # If a  * ring in the ring group is reset or free, then the associated rings in the  * ring group shall also be reset/free using hwrm_ring_free. # A function driver  * shall always use hwrm_ring_grp_free after freeing all rings in a group. # As  * a part of executing this command, the HWRM shall reset all associated ring  * group resources.  */
end_comment

begin_comment
comment|/* Input (24 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_ring_grp_free_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint32_t
name|ring_group_id
decl_stmt|;
comment|/* This is the ring group ID value. */
name|uint32_t
name|unused_0
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_ring_grp_free_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint32_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_cfa_l2_filter_alloc */
end_comment

begin_comment
comment|/*  * Description: An L2 filter is a filter resource that is used to identify a  * vnic or ring for a packet based on layer 2 fields. Layer 2 fields for  * encapsulated packets include both outer L2 header and/or inner l2 header of  * encapsulated packet. The L2 filter resource covers the following OS specific  * L2 filters. Linux/FreeBSD (per function): # Broadcast enable/disable # List  * of individual multicast filters # All multicast enable/disable filter #  * Unicast filters # Promiscuous mode VMware: # Broadcast enable/disable (per  * physical function) # All multicast enable/disable (per function) # Unicast  * filters per ring or vnic # Promiscuous mode per PF Windows: # Broadcast  * enable/disable (per physical function) # List of individual multicast filters  * (Driver needs to advertise the maximum number of filters supported) # All  * multicast enable/disable per physical function # Unicast filters per vnic #  * Promiscuous mode per PF Implementation notes on the use of VNIC in this  * command: # By default, these filters belong to default vnic for the function.  * # Once these filters are set up, only destination VNIC can be modified. # If  * the destination VNIC is not specified in this command, then the HWRM shall  * only create an l2 context id. HWRM Implementation notes for multicast  * filters: # The hwrm_filter_alloc command can be used to set up multicast  * filters (perfect match or partial match). Each individual function driver can  * set up multicast filters independently. # The HWRM needs to keep track of  * multicast filters set up by function drivers and maintain multicast group  * replication records to enable a subset of functions to receive traffic for a  * specific multicast address. # When a specific multicast filter cannot be set,  * the HWRM shall return an error. In this error case, the driver should fall  * back to using one general filter (rather than specific) for all multicast  * traffic. # When the SR-IOV is enabled, the HWRM needs to additionally track  * source knockout per multicast group record. Examples of setting unicast  * filters: For a unicast MAC based filter, one can use a combination of the  * fields and masks provided in this command to set up the filter. Below are  * some examples: # MAC + no VLAN filter: This filter is used to identify  * traffic that does not contain any VLAN tags and matches destination (or  * source) MAC address. This filter can be set up by setting only l2_addr field  * to be a valid field. All other fields are not valid. The following value is  * set for l2_addr. l2_addr = MAC # MAC + Any VLAN filter: This filter is used  * to identify traffic that carries single VLAN tag and matches (destination or  * source) MAC address. This filter can be set up by setting only l2_addr and  * l2_ovlan_mask fields to be valid fields. All other fields are not valid. The  * following values are set for those two valid fields. l2_addr = MAC,  * l2_ovlan_mask = 0xFFFF # MAC + no VLAN or VLAN ID=0: This filter is used to  * identify untagged traffic that does not contain any VLAN tags or a VLAN tag  * with VLAN ID = 0 and matches destination (or source) MAC address. This filter  * can be set up by setting only l2_addr and l2_ovlan fields to be valid fields.  * All other fields are not valid. The following value are set for l2_addr and  * l2_ovlan. l2_addr = MAC, l2_ovlan = 0x0 # MAC + no VLAN or any VLAN: This  * filter is used to identify traffic that contains zero or 1 VLAN tag and  * matches destination (or source) MAC address. This filter can be set up by  * setting only l2_addr, l2_ovlan, and l2_mask fields to be valid fields. All  * other fields are not valid. The following value are set for l2_addr,  * l2_ovlan, and l2_mask fields. l2_addr = MAC, l2_ovlan = 0x0, l2_ovlan_mask =  * 0xFFFF # MAC + VLAN ID filter: This filter can be set up by setting only  * l2_addr, l2_ovlan, and l2_ovlan_mask fields to be valid fields. All other  * fields are not valid. The following values are set for those three valid  * fields. l2_addr = MAC, l2_ovlan = VLAN ID, l2_ovlan_mask = 0xF000  */
end_comment

begin_comment
comment|/* Input (96 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_cfa_l2_filter_alloc_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint32_t
name|flags
decl_stmt|;
comment|/* 	 * Enumeration denoting the RX, TX type of the resource. This 	 * enumeration is used for resources that are similar for both TX and RX 	 * paths of the chip. 	 */
define|#
directive|define
name|HWRM_CFA_L2_FILTER_ALLOC_INPUT_FLAGS_PATH
value|UINT32_C(0x1)
comment|/* tx path */
define|#
directive|define
name|HWRM_CFA_L2_FILTER_ALLOC_INPUT_FLAGS_PATH_TX
value|(UINT32_C(0x0)<< 0)
comment|/* rx path */
define|#
directive|define
name|HWRM_CFA_L2_FILTER_ALLOC_INPUT_FLAGS_PATH_RX
value|(UINT32_C(0x1)<< 0)
define|#
directive|define
name|HWRM_CFA_L2_FILTER_ALLOC_INPUT_FLAGS_PATH_LAST
value|HWRM_CFA_L2_FILTER_ALLOC_INPUT_FLAGS_PATH_RX
comment|/* 	 * Setting of this flag indicates the applicability to the loopback 	 * path. 	 */
define|#
directive|define
name|HWRM_CFA_L2_FILTER_ALLOC_INPUT_FLAGS_LOOPBACK
value|UINT32_C(0x2)
comment|/* 	 * Setting of this flag indicates drop action. If this flag is not set, 	 * then it should be considered accept action. 	 */
define|#
directive|define
name|HWRM_CFA_L2_FILTER_ALLOC_INPUT_FLAGS_DROP
value|UINT32_C(0x4)
comment|/* 	 * If this flag is set, all t_l2_* fields are invalid and they should 	 * not be specified. If this flag is set, then l2_* fields refer to 	 * fields of outermost L2 header. 	 */
define|#
directive|define
name|HWRM_CFA_L2_FILTER_ALLOC_INPUT_FLAGS_OUTERMOST
value|UINT32_C(0x8)
name|uint32_t
name|enables
decl_stmt|;
comment|/* This bit must be '1' for the l2_addr field to be configured. */
define|#
directive|define
name|HWRM_CFA_L2_FILTER_ALLOC_INPUT_ENABLES_L2_ADDR
value|UINT32_C(0x1)
comment|/* This bit must be '1' for the l2_addr_mask field to be configured. */
define|#
directive|define
name|HWRM_CFA_L2_FILTER_ALLOC_INPUT_ENABLES_L2_ADDR_MASK
value|UINT32_C(0x2)
comment|/* This bit must be '1' for the l2_ovlan field to be configured. */
define|#
directive|define
name|HWRM_CFA_L2_FILTER_ALLOC_INPUT_ENABLES_L2_OVLAN
value|UINT32_C(0x4)
comment|/* This bit must be '1' for the l2_ovlan_mask field to be configured. */
define|#
directive|define
name|HWRM_CFA_L2_FILTER_ALLOC_INPUT_ENABLES_L2_OVLAN_MASK
value|UINT32_C(0x8)
comment|/* This bit must be '1' for the l2_ivlan field to be configured. */
define|#
directive|define
name|HWRM_CFA_L2_FILTER_ALLOC_INPUT_ENABLES_L2_IVLAN
value|UINT32_C(0x10)
comment|/* This bit must be '1' for the l2_ivlan_mask field to be configured. */
define|#
directive|define
name|HWRM_CFA_L2_FILTER_ALLOC_INPUT_ENABLES_L2_IVLAN_MASK
value|UINT32_C(0x20)
comment|/* This bit must be '1' for the t_l2_addr field to be configured. */
define|#
directive|define
name|HWRM_CFA_L2_FILTER_ALLOC_INPUT_ENABLES_T_L2_ADDR
value|UINT32_C(0x40)
comment|/* This bit must be '1' for the t_l2_addr_mask field to be configured. */
define|#
directive|define
name|HWRM_CFA_L2_FILTER_ALLOC_INPUT_ENABLES_T_L2_ADDR_MASK
value|UINT32_C(0x80)
comment|/* This bit must be '1' for the t_l2_ovlan field to be configured. */
define|#
directive|define
name|HWRM_CFA_L2_FILTER_ALLOC_INPUT_ENABLES_T_L2_OVLAN
value|UINT32_C(0x100)
comment|/* This bit must be '1' for the t_l2_ovlan_mask field to be configured. */
define|#
directive|define
name|HWRM_CFA_L2_FILTER_ALLOC_INPUT_ENABLES_T_L2_OVLAN_MASK
value|UINT32_C(0x200)
comment|/* This bit must be '1' for the t_l2_ivlan field to be configured. */
define|#
directive|define
name|HWRM_CFA_L2_FILTER_ALLOC_INPUT_ENABLES_T_L2_IVLAN
value|UINT32_C(0x400)
comment|/* This bit must be '1' for the t_l2_ivlan_mask field to be configured. */
define|#
directive|define
name|HWRM_CFA_L2_FILTER_ALLOC_INPUT_ENABLES_T_L2_IVLAN_MASK
value|UINT32_C(0x800)
comment|/* This bit must be '1' for the src_type field to be configured. */
define|#
directive|define
name|HWRM_CFA_L2_FILTER_ALLOC_INPUT_ENABLES_SRC_TYPE
value|UINT32_C(0x1000)
comment|/* This bit must be '1' for the src_id field to be configured. */
define|#
directive|define
name|HWRM_CFA_L2_FILTER_ALLOC_INPUT_ENABLES_SRC_ID
value|UINT32_C(0x2000)
comment|/* This bit must be '1' for the tunnel_type field to be configured. */
define|#
directive|define
name|HWRM_CFA_L2_FILTER_ALLOC_INPUT_ENABLES_TUNNEL_TYPE
value|UINT32_C(0x4000)
comment|/* This bit must be '1' for the dst_id field to be configured. */
define|#
directive|define
name|HWRM_CFA_L2_FILTER_ALLOC_INPUT_ENABLES_DST_ID
value|UINT32_C(0x8000)
comment|/* This bit must be '1' for the mirror_vnic_id field to be configured. */
define|#
directive|define
name|HWRM_CFA_L2_FILTER_ALLOC_INPUT_ENABLES_MIRROR_VNIC_ID
value|UINT32_C(0x10000)
name|uint8_t
name|l2_addr
index|[
literal|6
index|]
decl_stmt|;
comment|/* 	 * This value sets the match value for the L2 MAC address. Destination 	 * MAC address for RX path. Source MAC address for TX path. 	 */
name|uint8_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|l2_addr_mask
index|[
literal|6
index|]
decl_stmt|;
comment|/* 	 * This value sets the mask value for the L2 address. A value of 0 will 	 * mask the corresponding bit from compare. 	 */
name|uint16_t
name|l2_ovlan
decl_stmt|;
comment|/* This value sets VLAN ID value for outer VLAN. */
name|uint16_t
name|l2_ovlan_mask
decl_stmt|;
comment|/* 	 * This value sets the mask value for the ovlan id. A value of 0 will 	 * mask the corresponding bit from compare. 	 */
name|uint16_t
name|l2_ivlan
decl_stmt|;
comment|/* This value sets VLAN ID value for inner VLAN. */
name|uint16_t
name|l2_ivlan_mask
decl_stmt|;
comment|/* 	 * This value sets the mask value for the ivlan id. A value of 0 will 	 * mask the corresponding bit from compare. 	 */
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint8_t
name|t_l2_addr
index|[
literal|6
index|]
decl_stmt|;
comment|/* 	 * This value sets the match value for the tunnel L2 MAC address. 	 * Destination MAC address for RX path. Source MAC address for TX path. 	 */
name|uint8_t
name|unused_4
decl_stmt|;
name|uint8_t
name|unused_5
decl_stmt|;
name|uint8_t
name|t_l2_addr_mask
index|[
literal|6
index|]
decl_stmt|;
comment|/* 	 * This value sets the mask value for the tunnel L2 address. A value of 	 * 0 will mask the corresponding bit from compare. 	 */
name|uint16_t
name|t_l2_ovlan
decl_stmt|;
comment|/* This value sets VLAN ID value for tunnel outer VLAN. */
name|uint16_t
name|t_l2_ovlan_mask
decl_stmt|;
comment|/* 	 * This value sets the mask value for the tunnel ovlan id. A value of 0 	 * will mask the corresponding bit from compare. 	 */
name|uint16_t
name|t_l2_ivlan
decl_stmt|;
comment|/* This value sets VLAN ID value for tunnel inner VLAN. */
name|uint16_t
name|t_l2_ivlan_mask
decl_stmt|;
comment|/* 	 * This value sets the mask value for the tunnel ivlan id. A value of 0 	 * will mask the corresponding bit from compare. 	 */
name|uint8_t
name|src_type
decl_stmt|;
comment|/* This value identifies the type of source of the packet. */
comment|/* Network port */
define|#
directive|define
name|HWRM_CFA_L2_FILTER_ALLOC_INPUT_SRC_TYPE_NPORT
value|UINT32_C(0x0)
comment|/* Physical function */
define|#
directive|define
name|HWRM_CFA_L2_FILTER_ALLOC_INPUT_SRC_TYPE_PF
value|UINT32_C(0x1)
comment|/* Virtual function */
define|#
directive|define
name|HWRM_CFA_L2_FILTER_ALLOC_INPUT_SRC_TYPE_VF
value|UINT32_C(0x2)
comment|/* Virtual NIC of a function */
define|#
directive|define
name|HWRM_CFA_L2_FILTER_ALLOC_INPUT_SRC_TYPE_VNIC
value|UINT32_C(0x3)
comment|/* Embedded processor for CFA management */
define|#
directive|define
name|HWRM_CFA_L2_FILTER_ALLOC_INPUT_SRC_TYPE_KONG
value|UINT32_C(0x4)
comment|/* Embedded processor for OOB management */
define|#
directive|define
name|HWRM_CFA_L2_FILTER_ALLOC_INPUT_SRC_TYPE_APE
value|UINT32_C(0x5)
comment|/* Embedded processor for RoCE */
define|#
directive|define
name|HWRM_CFA_L2_FILTER_ALLOC_INPUT_SRC_TYPE_BONO
value|UINT32_C(0x6)
comment|/* Embedded processor for network proxy functions */
define|#
directive|define
name|HWRM_CFA_L2_FILTER_ALLOC_INPUT_SRC_TYPE_TANG
value|UINT32_C(0x7)
name|uint8_t
name|unused_6
decl_stmt|;
name|uint32_t
name|src_id
decl_stmt|;
comment|/* 	 * This value is the id of the source. For a network port, it represents 	 * port_id. For a physical function, it represents fid. For a virtual 	 * function, it represents vf_id. For a vnic, it represents vnic_id. For 	 * embedded processors, this id is not valid. Notes: 1. The function ID 	 * is implied if it src_id is not provided for a src_type that is either 	 */
name|uint8_t
name|tunnel_type
decl_stmt|;
comment|/* Tunnel Type. */
comment|/* Non-tunnel */
define|#
directive|define
name|HWRM_CFA_L2_FILTER_ALLOC_INPUT_TUNNEL_TYPE_NONTUNNEL
value|UINT32_C(0x0)
comment|/* Virtual eXtensible Local Area Network (VXLAN) */
define|#
directive|define
name|HWRM_CFA_L2_FILTER_ALLOC_INPUT_TUNNEL_TYPE_VXLAN
value|UINT32_C(0x1)
comment|/* Network Virtualization Generic Routing Encapsulation (NVGRE) */
define|#
directive|define
name|HWRM_CFA_L2_FILTER_ALLOC_INPUT_TUNNEL_TYPE_NVGRE
value|UINT32_C(0x2)
comment|/* Generic Routing Encapsulation (GRE) inside Ethernet payload */
define|#
directive|define
name|HWRM_CFA_L2_FILTER_ALLOC_INPUT_TUNNEL_TYPE_L2GRE
value|UINT32_C(0x3)
comment|/* IP in IP */
define|#
directive|define
name|HWRM_CFA_L2_FILTER_ALLOC_INPUT_TUNNEL_TYPE_IPIP
value|UINT32_C(0x4)
comment|/* Generic Network Virtualization Encapsulation (Geneve) */
define|#
directive|define
name|HWRM_CFA_L2_FILTER_ALLOC_INPUT_TUNNEL_TYPE_GENEVE
value|UINT32_C(0x5)
comment|/* Multi-Protocol Lable Switching (MPLS) */
define|#
directive|define
name|HWRM_CFA_L2_FILTER_ALLOC_INPUT_TUNNEL_TYPE_MPLS
value|UINT32_C(0x6)
comment|/* Stateless Transport Tunnel (STT) */
define|#
directive|define
name|HWRM_CFA_L2_FILTER_ALLOC_INPUT_TUNNEL_TYPE_STT
value|UINT32_C(0x7)
comment|/* Generic Routing Encapsulation (GRE) inside IP datagram payload */
define|#
directive|define
name|HWRM_CFA_L2_FILTER_ALLOC_INPUT_TUNNEL_TYPE_IPGRE
value|UINT32_C(0x8)
comment|/* Any tunneled traffic */
define|#
directive|define
name|HWRM_CFA_L2_FILTER_ALLOC_INPUT_TUNNEL_TYPE_ANYTUNNEL
value|UINT32_C(0xff)
name|uint8_t
name|unused_7
decl_stmt|;
name|uint16_t
name|dst_id
decl_stmt|;
comment|/* 	 * If set, this value shall represent the Logical VNIC ID of the 	 * destination VNIC for the RX path and network port id of the 	 * destination port for the TX path. 	 */
name|uint16_t
name|mirror_vnic_id
decl_stmt|;
comment|/* Logical VNIC ID of the VNIC where traffic is mirrored. */
name|uint8_t
name|pri_hint
decl_stmt|;
comment|/* 	 * This hint is provided to help in placing the filter in the filter 	 * table. 	 */
comment|/* No preference */
define|#
directive|define
name|HWRM_CFA_L2_FILTER_ALLOC_INPUT_PRI_HINT_NO_PREFER
value|UINT32_C(0x0)
comment|/* Above the given filter */
define|#
directive|define
name|HWRM_CFA_L2_FILTER_ALLOC_INPUT_PRI_HINT_ABOVE_FILTER
value|UINT32_C(0x1)
comment|/* Below the given filter */
define|#
directive|define
name|HWRM_CFA_L2_FILTER_ALLOC_INPUT_PRI_HINT_BELOW_FILTER
value|UINT32_C(0x2)
comment|/* As high as possible */
define|#
directive|define
name|HWRM_CFA_L2_FILTER_ALLOC_INPUT_PRI_HINT_MAX
value|UINT32_C(0x3)
comment|/* As low as possible */
define|#
directive|define
name|HWRM_CFA_L2_FILTER_ALLOC_INPUT_PRI_HINT_MIN
value|UINT32_C(0x4)
name|uint8_t
name|unused_8
decl_stmt|;
name|uint32_t
name|unused_9
decl_stmt|;
name|uint64_t
name|l2_filter_id_hint
decl_stmt|;
comment|/* 	 * This is the ID of the filter that goes along with the pri_hint. This 	 * field is valid only for the following values. 1 - Above the given 	 * filter 2 - Below the given filter 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (24 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_cfa_l2_filter_alloc_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint64_t
name|l2_filter_id
decl_stmt|;
comment|/* 	 * This value identifies a set of CFA data structures used for an L2 	 * context. 	 */
name|uint32_t
name|flow_id
decl_stmt|;
comment|/* 	 * This is the ID of the flow associated with this filter. This value 	 * shall be used to match and associate the flow identifier returned in 	 * completion records. A value of 0xFFFFFFFF shall indicate no flow id. 	 */
name|uint8_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_cfa_l2_filter_free */
end_comment

begin_comment
comment|/*  * Description: Free a L2 filter. The HWRM shall free all associated filter  * resources with the L2 filter.  */
end_comment

begin_comment
comment|/* Input (24 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_cfa_l2_filter_free_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint64_t
name|l2_filter_id
decl_stmt|;
comment|/* 	 * This value identifies a set of CFA data structures used for an L2 	 * context. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_cfa_l2_filter_free_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint32_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_cfa_l2_filter_cfg */
end_comment

begin_comment
comment|/* Description: Change the configuration of an existing L2 filter */
end_comment

begin_comment
comment|/* Input (40 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_cfa_l2_filter_cfg_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint32_t
name|flags
decl_stmt|;
comment|/* 	 * Enumeration denoting the RX, TX type of the resource. This 	 * enumeration is used for resources that are similar for both TX and RX 	 * paths of the chip. 	 */
define|#
directive|define
name|HWRM_CFA_L2_FILTER_CFG_INPUT_FLAGS_PATH
value|UINT32_C(0x1)
comment|/* tx path */
define|#
directive|define
name|HWRM_CFA_L2_FILTER_CFG_INPUT_FLAGS_PATH_TX
value|(UINT32_C(0x0)<< 0)
comment|/* rx path */
define|#
directive|define
name|HWRM_CFA_L2_FILTER_CFG_INPUT_FLAGS_PATH_RX
value|(UINT32_C(0x1)<< 0)
define|#
directive|define
name|HWRM_CFA_L2_FILTER_CFG_INPUT_FLAGS_PATH_LAST
value|HWRM_CFA_L2_FILTER_CFG_INPUT_FLAGS_PATH_RX
comment|/* 	 * Setting of this flag indicates drop action. If this flag is not set, 	 * then it should be considered accept action. 	 */
define|#
directive|define
name|HWRM_CFA_L2_FILTER_CFG_INPUT_FLAGS_DROP
value|UINT32_C(0x2)
name|uint32_t
name|enables
decl_stmt|;
comment|/* This bit must be '1' for the dst_id field to be configured. */
define|#
directive|define
name|HWRM_CFA_L2_FILTER_CFG_INPUT_ENABLES_DST_ID
value|UINT32_C(0x1)
comment|/* 	 * This bit must be '1' for the new_mirror_vnic_id field to be 	 * configured. 	 */
define|#
directive|define
name|HWRM_CFA_L2_FILTER_CFG_INPUT_ENABLES_NEW_MIRROR_VNIC_ID
value|UINT32_C(0x2)
name|uint64_t
name|l2_filter_id
decl_stmt|;
comment|/* 	 * This value identifies a set of CFA data structures used for an L2 	 * context. 	 */
name|uint32_t
name|dst_id
decl_stmt|;
comment|/* 	 * If set, this value shall represent the Logical VNIC ID of the 	 * destination VNIC for the RX path and network port id of the 	 * destination port for the TX path. 	 */
name|uint32_t
name|new_mirror_vnic_id
decl_stmt|;
comment|/* New Logical VNIC ID of the VNIC where traffic is mirrored. */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_cfa_l2_filter_cfg_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint32_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_cfa_l2_set_rx_mask */
end_comment

begin_comment
comment|/* Description: This command will set rx mask of the function. */
end_comment

begin_comment
comment|/* Input (56 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_cfa_l2_set_rx_mask_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint32_t
name|vnic_id
decl_stmt|;
comment|/* VNIC ID */
name|uint32_t
name|mask
decl_stmt|;
comment|/* Reserved for future use. */
define|#
directive|define
name|HWRM_CFA_L2_SET_RX_MASK_INPUT_MASK_RESERVED
value|UINT32_C(0x1)
comment|/* 	 * When this bit is '1', the function is requested to accept multi-cast 	 * packets specified by the multicast addr table. 	 */
define|#
directive|define
name|HWRM_CFA_L2_SET_RX_MASK_INPUT_MASK_MCAST
value|UINT32_C(0x2)
comment|/* 	 * When this bit is '1', the function is requested to accept all multi- 	 * cast packets. 	 */
define|#
directive|define
name|HWRM_CFA_L2_SET_RX_MASK_INPUT_MASK_ALL_MCAST
value|UINT32_C(0x4)
comment|/* 	 * When this bit is '1', the function is requested to accept broadcast 	 * packets. 	 */
define|#
directive|define
name|HWRM_CFA_L2_SET_RX_MASK_INPUT_MASK_BCAST
value|UINT32_C(0x8)
comment|/* 	 * When this bit is '1', the function is requested to be put in the 	 * promiscuous mode. The HWRM should accept any function to set up 	 * promiscuous mode. The HWRM shall follow the semantics below for the 	 * promiscuous mode support. # When partitioning is not enabled on a 	 * port (i.e. single PF on the port), then the PF shall be allowed to be 	 * in the promiscuous mode. When the PF is in the promiscuous mode, then 	 * it shall receive all host bound traffic on that port. # When 	 * partitioning is enabled on a port (i.e. multiple PFs per port) and a 	 * PF on that port is in the promiscuous mode, then the PF receives all 	 * traffic within that partition as identified by a unique identifier 	 * for the PF (e.g. S-Tag). If a unique outer VLAN for the PF is 	 * specified, then the setting of promiscuous mode on that PF shall 	 * result in the PF receiving all host bound traffic with matching outer 	 * VLAN. # A VF shall can be set in the promiscuous mode. In the 	 * promiscuous mode, the VF does not receive any traffic unless a unique 	 * outer VLAN for the VF is specified. If a unique outer VLAN for the VF 	 * is specified, then the setting of promiscuous mode on that VF shall 	 * result in the VF receiving all host bound traffic with the matching 	 * outer VLAN. # The HWRM shall allow the setting of promiscuous mode on 	 * a function independently from the promiscuous mode settings on other 	 * functions. 	 */
define|#
directive|define
name|HWRM_CFA_L2_SET_RX_MASK_INPUT_MASK_PROMISCUOUS
value|UINT32_C(0x10)
comment|/* 	 * If this flag is set, the corresponding RX filters shall be set up to 	 * cover multicast/broadcast filters for the outermost Layer 2 	 * destination MAC address field. 	 */
define|#
directive|define
name|HWRM_CFA_L2_SET_RX_MASK_INPUT_MASK_OUTERMOST
value|UINT32_C(0x20)
comment|/* 	 * If this flag is set, the corresponding RX filters shall be set up to 	 * cover multicast/broadcast filters for the VLAN-tagged packets that 	 * match the TPID and VID fields of VLAN tags in the VLAN tag table 	 * specified in this command. 	 */
define|#
directive|define
name|HWRM_CFA_L2_SET_RX_MASK_INPUT_MASK_VLANONLY
value|UINT32_C(0x40)
comment|/* 	 * If this flag is set, the corresponding RX filters shall be set up to 	 * cover multicast/broadcast filters for non-VLAN tagged packets and 	 * VLAN-tagged packets that match the TPID and VID fields of VLAN tags 	 * in the VLAN tag table specified in this command. 	 */
define|#
directive|define
name|HWRM_CFA_L2_SET_RX_MASK_INPUT_MASK_VLAN_NONVLAN
value|UINT32_C(0x80)
comment|/* 	 * If this flag is set, the corresponding RX filters shall be set up to 	 * cover multicast/broadcast filters for non-VLAN tagged packets and 	 * VLAN-tagged packets matching any VLAN tag. If this flag is set, then 	 * the HWRM shall ignore VLAN tags specified in vlan_tag_tbl. If none of 	 * vlanonly, vlan_nonvlan, and anyvlan_nonvlan flags is set, then the 	 * HWRM shall ignore VLAN tags specified in vlan_tag_tbl. The HWRM 	 * client shall set at most one flag out of vlanonly, vlan_nonvlan, and 	 * anyvlan_nonvlan. 	 */
define|#
directive|define
name|HWRM_CFA_L2_SET_RX_MASK_INPUT_MASK_ANYVLAN_NONVLAN
value|UINT32_C(0x100)
name|uint64_t
name|mc_tbl_addr
decl_stmt|;
comment|/* This is the address for mcast address tbl. */
name|uint32_t
name|num_mc_entries
decl_stmt|;
comment|/* 	 * This value indicates how many entries in mc_tbl are valid. Each entry 	 * is 6 bytes. 	 */
name|uint32_t
name|unused_0
decl_stmt|;
name|uint64_t
name|vlan_tag_tbl_addr
decl_stmt|;
comment|/* 	 * This is the address for VLAN tag table. Each VLAN entry in the table 	 * is 4 bytes of a VLAN tag including TPID, PCP, DEI, and VID fields in 	 * network byte order. 	 */
name|uint32_t
name|num_vlan_tags
decl_stmt|;
comment|/* 	 * This value indicates how many entries in vlan_tag_tbl are valid. Each 	 * entry is 4 bytes. 	 */
name|uint32_t
name|unused_1
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_cfa_l2_set_rx_mask_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint32_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Command specific Error Codes (8 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_cfa_l2_set_rx_mask_cmd_err
block|{
name|uint8_t
name|code
decl_stmt|;
comment|/* 	 * command specific error codes that goes to the cmd_err field in Common 	 * HWRM Error Response. 	 */
comment|/* Unknown error */
define|#
directive|define
name|HWRM_CFA_L2_SET_RX_MASK_CMD_ERR_CODE_UNKNOWN
value|UINT32_C(0x0)
comment|/* Unable to complete operation due to conflict with Ntuple Filter */
define|#
directive|define
name|HWRM_CFA_L2_SET_RX_MASK_CMD_ERR_CODE_NTUPLE_FILTER_CONFLICT_ERR
value|UINT32_C(0x1)
name|uint8_t
name|unused_0
index|[
literal|7
index|]
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_cfa_vlan_antispoof_cfg */
end_comment

begin_comment
comment|/* Description: Configures vlan anti-spoof filters for VF. */
end_comment

begin_comment
comment|/* Input (32 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_cfa_vlan_antispoof_cfg_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint16_t
name|fid
decl_stmt|;
comment|/* 	 * Function ID of the function that is being configured. Only valid for 	 * a VF FID configured by the PF. 	 */
name|uint8_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint32_t
name|num_vlan_entries
decl_stmt|;
comment|/* Number of VLAN entries in the vlan_tag_mask_tbl. */
name|uint64_t
name|vlan_tag_mask_tbl_addr
decl_stmt|;
comment|/* 	 * The vlan_tag_mask_tbl_addr is the DMA address of the VLAN antispoof 	 * table. Each table entry contains the 16-bit TPID (0x8100 or 0x88a8 	 * only), 16-bit VLAN ID, and a 16-bit mask, all in network order to 	 * match hwrm_cfa_l2_set_rx_mask. For an individual VLAN entry, the mask 	 * value should be 0xfff for the 12-bit VLAN ID. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_cfa_vlan_antispoof_cfg_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint32_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_cfa_vlan_antispoof_qcfg */
end_comment

begin_comment
comment|/*  * Description: Returns the current configuration of the vlan anti-spoof filters  * for VF.  */
end_comment

begin_comment
comment|/* Input (32 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_cfa_vlan_antispoof_qcfg_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint16_t
name|fid
decl_stmt|;
comment|/* 	 * Function ID of the function that is being queried. Only valid for a 	 * VF FID queried by the PF. 	 */
name|uint8_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint32_t
name|max_vlan_entries
decl_stmt|;
comment|/* 	 * Maximum number of VLAN entries the firmware is allowed to DMA to 	 * vlan_tag_mask_tbl. 	 */
name|uint64_t
name|vlan_tag_mask_tbl_addr
decl_stmt|;
comment|/* 	 * The vlan_tag_mask_tbl_addr is the DMA address of the VLAN antispoof 	 * table to which firmware will DMA to. Each table entry will contain 	 * the 16-bit TPID (0x8100 or 0x88a8 only), 16-bit VLAN ID, and a 16-bit 	 * mask, all in network order to match hwrm_cfa_l2_set_rx_mask. For an 	 * individual VLAN entry, the mask value should be 0xfff for the 12-bit 	 * VLAN ID. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_cfa_vlan_antispoof_qcfg_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint32_t
name|num_vlan_entries
decl_stmt|;
comment|/* Number of valid entries DMAd by firmware to vlan_tag_mask_tbl. */
name|uint8_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_cfa_tunnel_filter_alloc */
end_comment

begin_comment
comment|/*  * Description: This is a tunnel filter that uses fields from tunnel header in  * addition to l2 context. The tunnel filter applies to receive side only. The  * l2_* fields in this command represent fields of inner L2 header. They are  * optional to be specified. It allows l2_filter_id to be created with outer L2  * header fields that can be shared with multiple tunnel filters specified as  * combinations of inner L2 header fields, tunnel type, and VNI.  */
end_comment

begin_comment
comment|/* Input (88 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_cfa_tunnel_filter_alloc_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint32_t
name|flags
decl_stmt|;
comment|/* 	 * Setting of this flag indicates the applicability to the loopback 	 * path. 	 */
define|#
directive|define
name|HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_FLAGS_LOOPBACK
value|UINT32_C(0x1)
name|uint32_t
name|enables
decl_stmt|;
comment|/* This bit must be '1' for the l2_filter_id field to be configured. */
define|#
directive|define
name|HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_ENABLES_L2_FILTER_ID
value|UINT32_C(0x1)
comment|/* This bit must be '1' for the l2_addr field to be configured. */
define|#
directive|define
name|HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_ENABLES_L2_ADDR
value|UINT32_C(0x2)
comment|/* This bit must be '1' for the l2_ivlan field to be configured. */
define|#
directive|define
name|HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_ENABLES_L2_IVLAN
value|UINT32_C(0x4)
comment|/* This bit must be '1' for the l3_addr field to be configured. */
define|#
directive|define
name|HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_ENABLES_L3_ADDR
value|UINT32_C(0x8)
comment|/* This bit must be '1' for the l3_addr_type field to be configured. */
define|#
directive|define
name|HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_ENABLES_L3_ADDR_TYPE
value|UINT32_C(0x10)
comment|/* This bit must be '1' for the t_l3_addr_type field to be configured. */
define|#
directive|define
name|HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_ENABLES_T_L3_ADDR_TYPE
value|UINT32_C(0x20)
comment|/* This bit must be '1' for the t_l3_addr field to be configured. */
define|#
directive|define
name|HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_ENABLES_T_L3_ADDR
value|UINT32_C(0x40)
comment|/* This bit must be '1' for the tunnel_type field to be configured. */
define|#
directive|define
name|HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_ENABLES_TUNNEL_TYPE
value|UINT32_C(0x80)
comment|/* This bit must be '1' for the vni field to be configured. */
define|#
directive|define
name|HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_ENABLES_VNI
value|UINT32_C(0x100)
comment|/* This bit must be '1' for the dst_vnic_id field to be configured. */
define|#
directive|define
name|HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_ENABLES_DST_VNIC_ID
value|UINT32_C(0x200)
comment|/* This bit must be '1' for the mirror_vnic_id field to be configured. */
define|#
directive|define
name|HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_ENABLES_MIRROR_VNIC_ID
value|UINT32_C(0x400)
name|uint64_t
name|l2_filter_id
decl_stmt|;
comment|/* 	 * This value identifies a set of CFA data structures used for an L2 	 * context. 	 */
name|uint8_t
name|l2_addr
index|[
literal|6
index|]
decl_stmt|;
comment|/* 	 * This value sets the match value for the inner L2 MAC address. 	 * Destination MAC address for RX path. Source MAC address for TX path. 	 */
name|uint16_t
name|l2_ivlan
decl_stmt|;
comment|/* 	 * This value sets VLAN ID value for inner VLAN. Only 12-bits of VLAN ID 	 * are used in setting the filter. 	 */
name|uint32_t
name|l3_addr
index|[
literal|4
index|]
decl_stmt|;
comment|/* 	 * The value of inner destination IP address to be used in filtering. 	 * For IPv4, first four bytes represent the IP address. 	 */
name|uint32_t
name|t_l3_addr
index|[
literal|4
index|]
decl_stmt|;
comment|/* 	 * The value of tunnel destination IP address to be used in filtering. 	 * For IPv4, first four bytes represent the IP address. 	 */
name|uint8_t
name|l3_addr_type
decl_stmt|;
comment|/* 	 * This value indicates the type of inner IP address. 4 - IPv4 6 - IPv6 	 * All others are invalid. 	 */
name|uint8_t
name|t_l3_addr_type
decl_stmt|;
comment|/* 	 * This value indicates the type of tunnel IP address. 4 - IPv4 6 - IPv6 	 * All others are invalid. 	 */
name|uint8_t
name|tunnel_type
decl_stmt|;
comment|/* Tunnel Type. */
comment|/* Non-tunnel */
define|#
directive|define
name|HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_TUNNEL_TYPE_NONTUNNEL
value|UINT32_C(0x0)
comment|/* Virtual eXtensible Local Area Network (VXLAN) */
define|#
directive|define
name|HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_TUNNEL_TYPE_VXLAN
value|UINT32_C(0x1)
comment|/* Network Virtualization Generic Routing Encapsulation (NVGRE) */
define|#
directive|define
name|HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_TUNNEL_TYPE_NVGRE
value|UINT32_C(0x2)
comment|/* Generic Routing Encapsulation (GRE) inside Ethernet payload */
define|#
directive|define
name|HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_TUNNEL_TYPE_L2GRE
value|UINT32_C(0x3)
comment|/* IP in IP */
define|#
directive|define
name|HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_TUNNEL_TYPE_IPIP
value|UINT32_C(0x4)
comment|/* Generic Network Virtualization Encapsulation (Geneve) */
define|#
directive|define
name|HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_TUNNEL_TYPE_GENEVE
value|UINT32_C(0x5)
comment|/* Multi-Protocol Lable Switching (MPLS) */
define|#
directive|define
name|HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_TUNNEL_TYPE_MPLS
value|UINT32_C(0x6)
comment|/* Stateless Transport Tunnel (STT) */
define|#
directive|define
name|HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_TUNNEL_TYPE_STT
value|UINT32_C(0x7)
comment|/* Generic Routing Encapsulation (GRE) inside IP datagram payload */
define|#
directive|define
name|HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_TUNNEL_TYPE_IPGRE
value|UINT32_C(0x8)
comment|/* Any tunneled traffic */
define|#
directive|define
name|HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_TUNNEL_TYPE_ANYTUNNEL
value|UINT32_C(0xff)
name|uint8_t
name|unused_0
decl_stmt|;
name|uint32_t
name|vni
decl_stmt|;
comment|/* 	 * Virtual Network Identifier (VNI). Only valid with tunnel_types VXLAN, 	 * NVGRE, and Geneve. Only lower 24-bits of VNI field are used in 	 * setting up the filter. 	 */
name|uint32_t
name|dst_vnic_id
decl_stmt|;
comment|/* Logical VNIC ID of the destination VNIC. */
name|uint32_t
name|mirror_vnic_id
decl_stmt|;
comment|/* Logical VNIC ID of the VNIC where traffic is mirrored. */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (24 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_cfa_tunnel_filter_alloc_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint64_t
name|tunnel_filter_id
decl_stmt|;
comment|/* This value is an opaque id into CFA data structures. */
name|uint32_t
name|flow_id
decl_stmt|;
comment|/* 	 * This is the ID of the flow associated with this filter. This value 	 * shall be used to match and associate the flow identifier returned in 	 * completion records. A value of 0xFFFFFFFF shall indicate no flow id. 	 */
name|uint8_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_cfa_tunnel_filter_free */
end_comment

begin_comment
comment|/* Description: Free a tunnel filter */
end_comment

begin_comment
comment|/* Input (24 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_cfa_tunnel_filter_free_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint64_t
name|tunnel_filter_id
decl_stmt|;
comment|/* This value is an opaque id into CFA data structures. */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_cfa_tunnel_filter_free_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint32_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_cfa_encap_record_alloc */
end_comment

begin_comment
comment|/*  * Description: This command is used to create an encapsulation record. The  * source MAC address and source IP address specified for the source property  * checks shall be used in the encapsulation where applicable.  */
end_comment

begin_comment
comment|/* Input (32 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_cfa_encap_record_alloc_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint32_t
name|flags
decl_stmt|;
comment|/* 	 * Setting of this flag indicates the applicability to the loopback 	 * path. 	 */
define|#
directive|define
name|HWRM_CFA_ENCAP_RECORD_ALLOC_INPUT_FLAGS_LOOPBACK
value|UINT32_C(0x1)
name|uint8_t
name|encap_type
decl_stmt|;
comment|/* Encapsulation Type. */
comment|/* Virtual eXtensible Local Area Network (VXLAN) */
define|#
directive|define
name|HWRM_CFA_ENCAP_RECORD_ALLOC_INPUT_ENCAP_TYPE_VXLAN
value|UINT32_C(0x1)
comment|/* Network Virtualization Generic Routing Encapsulation (NVGRE) */
define|#
directive|define
name|HWRM_CFA_ENCAP_RECORD_ALLOC_INPUT_ENCAP_TYPE_NVGRE
value|UINT32_C(0x2)
comment|/* Generic Routing Encapsulation (GRE) after inside Ethernet payload */
define|#
directive|define
name|HWRM_CFA_ENCAP_RECORD_ALLOC_INPUT_ENCAP_TYPE_L2GRE
value|UINT32_C(0x3)
comment|/* IP in IP */
define|#
directive|define
name|HWRM_CFA_ENCAP_RECORD_ALLOC_INPUT_ENCAP_TYPE_IPIP
value|UINT32_C(0x4)
comment|/* Generic Network Virtualization Encapsulation (Geneve) */
define|#
directive|define
name|HWRM_CFA_ENCAP_RECORD_ALLOC_INPUT_ENCAP_TYPE_GENEVE
value|UINT32_C(0x5)
comment|/* Multi-Protocol Lable Switching (MPLS) */
define|#
directive|define
name|HWRM_CFA_ENCAP_RECORD_ALLOC_INPUT_ENCAP_TYPE_MPLS
value|UINT32_C(0x6)
comment|/* VLAN */
define|#
directive|define
name|HWRM_CFA_ENCAP_RECORD_ALLOC_INPUT_ENCAP_TYPE_VLAN
value|UINT32_C(0x7)
comment|/* Generic Routing Encapsulation (GRE) inside IP datagram payload */
define|#
directive|define
name|HWRM_CFA_ENCAP_RECORD_ALLOC_INPUT_ENCAP_TYPE_IPGRE
value|UINT32_C(0x8)
name|uint8_t
name|unused_0
decl_stmt|;
name|uint16_t
name|unused_1
decl_stmt|;
name|uint32_t
name|encap_data
index|[
literal|20
index|]
decl_stmt|;
comment|/* This value is encap data used for the given encap type. */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_cfa_encap_record_alloc_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint32_t
name|encap_record_id
decl_stmt|;
comment|/* This value is an opaque id into CFA data structures. */
name|uint8_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_cfa_encap_record_free */
end_comment

begin_comment
comment|/* Description: Free an encap record */
end_comment

begin_comment
comment|/* Input (24 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_cfa_encap_record_free_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint32_t
name|encap_record_id
decl_stmt|;
comment|/* This value is an opaque id into CFA data structures. */
name|uint32_t
name|unused_0
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_cfa_encap_record_free_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint32_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_cfa_ntuple_filter_alloc */
end_comment

begin_comment
comment|/*  * Description: This is a ntuple filter that uses fields from L4/L3 header and  * optionally fields from L2. The ntuple filters apply to receive traffic only.  * All L2/L3/L4 header fields are specified in network byte order. These filters  * can be used for Receive Flow Steering (RFS). # For ethertype value, only  * 0x0800 (IPv4) and 0x86dd (IPv6) shall be supported for ntuple filters. # If a  * field specified in this command is not enabled as a valid field, then that  * field shall not be used in matching packet header fields against this filter.  */
end_comment

begin_comment
comment|/* Input (128 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_cfa_ntuple_filter_alloc_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint32_t
name|flags
decl_stmt|;
comment|/* 	 * Setting of this flag indicates the applicability to the loopback 	 * path. 	 */
define|#
directive|define
name|HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_FLAGS_LOOPBACK
value|UINT32_C(0x1)
comment|/* 	 * Setting of this flag indicates drop action. If this flag is not set, 	 * then it should be considered accept action. 	 */
define|#
directive|define
name|HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_FLAGS_DROP
value|UINT32_C(0x2)
comment|/* 	 * Setting of this flag indicates that a meter is expected to be 	 * attached to this flow. This hint can be used when choosing the action 	 * record format required for the flow. 	 */
define|#
directive|define
name|HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_FLAGS_METER
value|UINT32_C(0x4)
name|uint32_t
name|enables
decl_stmt|;
comment|/* This bit must be '1' for the l2_filter_id field to be configured. */
define|#
directive|define
name|HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_ENABLES_L2_FILTER_ID
value|UINT32_C(0x1)
comment|/* This bit must be '1' for the ethertype field to be configured. */
define|#
directive|define
name|HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_ENABLES_ETHERTYPE
value|UINT32_C(0x2)
comment|/* This bit must be '1' for the tunnel_type field to be configured. */
define|#
directive|define
name|HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_ENABLES_TUNNEL_TYPE
value|UINT32_C(0x4)
comment|/* This bit must be '1' for the src_macaddr field to be configured. */
define|#
directive|define
name|HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_ENABLES_SRC_MACADDR
value|UINT32_C(0x8)
comment|/* This bit must be '1' for the ipaddr_type field to be configured. */
define|#
directive|define
name|HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_ENABLES_IPADDR_TYPE
value|UINT32_C(0x10)
comment|/* This bit must be '1' for the src_ipaddr field to be configured. */
define|#
directive|define
name|HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_ENABLES_SRC_IPADDR
value|UINT32_C(0x20)
comment|/* This bit must be '1' for the src_ipaddr_mask field to be configured. */
define|#
directive|define
name|HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_ENABLES_SRC_IPADDR_MASK
value|UINT32_C(0x40)
comment|/* This bit must be '1' for the dst_ipaddr field to be configured. */
define|#
directive|define
name|HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_ENABLES_DST_IPADDR
value|UINT32_C(0x80)
comment|/* This bit must be '1' for the dst_ipaddr_mask field to be configured. */
define|#
directive|define
name|HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_ENABLES_DST_IPADDR_MASK
value|UINT32_C(0x100)
comment|/* This bit must be '1' for the ip_protocol field to be configured. */
define|#
directive|define
name|HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_ENABLES_IP_PROTOCOL
value|UINT32_C(0x200)
comment|/* This bit must be '1' for the src_port field to be configured. */
define|#
directive|define
name|HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_ENABLES_SRC_PORT
value|UINT32_C(0x400)
comment|/* This bit must be '1' for the src_port_mask field to be configured. */
define|#
directive|define
name|HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_ENABLES_SRC_PORT_MASK
value|UINT32_C(0x800)
comment|/* This bit must be '1' for the dst_port field to be configured. */
define|#
directive|define
name|HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_ENABLES_DST_PORT
value|UINT32_C(0x1000)
comment|/* This bit must be '1' for the dst_port_mask field to be configured. */
define|#
directive|define
name|HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_ENABLES_DST_PORT_MASK
value|UINT32_C(0x2000)
comment|/* This bit must be '1' for the pri_hint field to be configured. */
define|#
directive|define
name|HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_ENABLES_PRI_HINT
value|UINT32_C(0x4000)
comment|/* This bit must be '1' for the ntuple_filter_id field to be configured. */
define|#
directive|define
name|HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_ENABLES_NTUPLE_FILTER_ID
value|UINT32_C(0x8000)
comment|/* This bit must be '1' for the dst_id field to be configured. */
define|#
directive|define
name|HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_ENABLES_DST_ID
value|UINT32_C(0x10000)
comment|/* This bit must be '1' for the mirror_vnic_id field to be configured. */
define|#
directive|define
name|HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_ENABLES_MIRROR_VNIC_ID
value|UINT32_C(0x20000)
comment|/* This bit must be '1' for the dst_macaddr field to be configured. */
define|#
directive|define
name|HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_ENABLES_DST_MACADDR
value|UINT32_C(0x40000)
name|uint64_t
name|l2_filter_id
decl_stmt|;
comment|/* 	 * This value identifies a set of CFA data structures used for an L2 	 * context. 	 */
name|uint8_t
name|src_macaddr
index|[
literal|6
index|]
decl_stmt|;
comment|/* This value indicates the source MAC address in the Ethernet header. */
name|uint16_t
name|ethertype
decl_stmt|;
comment|/* big endian */
comment|/* This value indicates the ethertype in the Ethernet header. */
name|uint8_t
name|ip_addr_type
decl_stmt|;
comment|/* 	 * This value indicates the type of IP address. 4 - IPv4 6 - IPv6 All 	 * others are invalid. 	 */
comment|/* invalid */
define|#
directive|define
name|HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_IP_ADDR_TYPE_UNKNOWN
value|UINT32_C(0x0)
comment|/* IPv4 */
define|#
directive|define
name|HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_IP_ADDR_TYPE_IPV4
value|UINT32_C(0x4)
comment|/* IPv6 */
define|#
directive|define
name|HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_IP_ADDR_TYPE_IPV6
value|UINT32_C(0x6)
name|uint8_t
name|ip_protocol
decl_stmt|;
comment|/* 	 * The value of protocol filed in IP header. Applies to UDP and TCP 	 * traffic. 6 - TCP 17 - UDP 	 */
comment|/* invalid */
define|#
directive|define
name|HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_IP_PROTOCOL_UNKNOWN
value|UINT32_C(0x0)
comment|/* TCP */
define|#
directive|define
name|HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_IP_PROTOCOL_TCP
value|UINT32_C(0x6)
comment|/* UDP */
define|#
directive|define
name|HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_IP_PROTOCOL_UDP
value|UINT32_C(0x11)
name|uint16_t
name|dst_id
decl_stmt|;
comment|/* 	 * If set, this value shall represent the Logical VNIC ID of the 	 * destination VNIC for the RX path and network port id of the 	 * destination port for the TX path. 	 */
name|uint16_t
name|mirror_vnic_id
decl_stmt|;
comment|/* Logical VNIC ID of the VNIC where traffic is mirrored. */
name|uint8_t
name|tunnel_type
decl_stmt|;
comment|/* 	 * This value indicates the tunnel type for this filter. If this field 	 * is not specified, then the filter shall apply to both non-tunneled 	 * and tunneled packets. If this field conflicts with the tunnel_type 	 * specified in the l2_filter_id, then the HWRM shall return an error 	 * for this command. 	 */
comment|/* Non-tunnel */
define|#
directive|define
name|HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_TUNNEL_TYPE_NONTUNNEL
value|UINT32_C(0x0)
comment|/* Virtual eXtensible Local Area Network (VXLAN) */
define|#
directive|define
name|HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_TUNNEL_TYPE_VXLAN
value|UINT32_C(0x1)
comment|/* Network Virtualization Generic Routing Encapsulation (NVGRE) */
define|#
directive|define
name|HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_TUNNEL_TYPE_NVGRE
value|UINT32_C(0x2)
comment|/* Generic Routing Encapsulation (GRE) inside Ethernet payload */
define|#
directive|define
name|HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_TUNNEL_TYPE_L2GRE
value|UINT32_C(0x3)
comment|/* IP in IP */
define|#
directive|define
name|HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_TUNNEL_TYPE_IPIP
value|UINT32_C(0x4)
comment|/* Generic Network Virtualization Encapsulation (Geneve) */
define|#
directive|define
name|HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_TUNNEL_TYPE_GENEVE
value|UINT32_C(0x5)
comment|/* Multi-Protocol Lable Switching (MPLS) */
define|#
directive|define
name|HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_TUNNEL_TYPE_MPLS
value|UINT32_C(0x6)
comment|/* Stateless Transport Tunnel (STT) */
define|#
directive|define
name|HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_TUNNEL_TYPE_STT
value|UINT32_C(0x7)
comment|/* Generic Routing Encapsulation (GRE) inside IP datagram payload */
define|#
directive|define
name|HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_TUNNEL_TYPE_IPGRE
value|UINT32_C(0x8)
comment|/* Any tunneled traffic */
define|#
directive|define
name|HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_TUNNEL_TYPE_ANYTUNNEL
value|UINT32_C(0xff)
name|uint8_t
name|pri_hint
decl_stmt|;
comment|/* 	 * This hint is provided to help in placing the filter in the filter 	 * table. 	 */
comment|/* No preference */
define|#
directive|define
name|HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_PRI_HINT_NO_PREFER
value|UINT32_C(0x0)
comment|/* Above the given filter */
define|#
directive|define
name|HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_PRI_HINT_ABOVE
value|UINT32_C(0x1)
comment|/* Below the given filter */
define|#
directive|define
name|HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_PRI_HINT_BELOW
value|UINT32_C(0x2)
comment|/* As high as possible */
define|#
directive|define
name|HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_PRI_HINT_HIGHEST
value|UINT32_C(0x3)
comment|/* As low as possible */
define|#
directive|define
name|HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_PRI_HINT_LOWEST
value|UINT32_C(0x4)
name|uint32_t
name|src_ipaddr
index|[
literal|4
index|]
decl_stmt|;
comment|/* big endian */
comment|/* 	 * The value of source IP address to be used in filtering. For IPv4, 	 * first four bytes represent the IP address. 	 */
name|uint32_t
name|src_ipaddr_mask
index|[
literal|4
index|]
decl_stmt|;
comment|/* big endian */
comment|/* 	 * The value of source IP address mask to be used in filtering. For 	 * IPv4, first four bytes represent the IP address mask. 	 */
name|uint32_t
name|dst_ipaddr
index|[
literal|4
index|]
decl_stmt|;
comment|/* big endian */
comment|/* 	 * The value of destination IP address to be used in filtering. For 	 * IPv4, first four bytes represent the IP address. 	 */
name|uint32_t
name|dst_ipaddr_mask
index|[
literal|4
index|]
decl_stmt|;
comment|/* big endian */
comment|/* 	 * The value of destination IP address mask to be used in filtering. For 	 * IPv4, first four bytes represent the IP address mask. 	 */
name|uint16_t
name|src_port
decl_stmt|;
comment|/* big endian */
comment|/* 	 * The value of source port to be used in filtering. Applies to UDP and 	 * TCP traffic. 	 */
name|uint16_t
name|src_port_mask
decl_stmt|;
comment|/* big endian */
comment|/* 	 * The value of source port mask to be used in filtering. Applies to UDP 	 * and TCP traffic. 	 */
name|uint16_t
name|dst_port
decl_stmt|;
comment|/* big endian */
comment|/* 	 * The value of destination port to be used in filtering. Applies to UDP 	 * and TCP traffic. 	 */
name|uint16_t
name|dst_port_mask
decl_stmt|;
comment|/* big endian */
comment|/* 	 * The value of destination port mask to be used in filtering. Applies 	 * to UDP and TCP traffic. 	 */
name|uint64_t
name|ntuple_filter_id_hint
decl_stmt|;
comment|/* This is the ID of the filter that goes along with the pri_hint. */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (24 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_cfa_ntuple_filter_alloc_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint64_t
name|ntuple_filter_id
decl_stmt|;
comment|/* This value is an opaque id into CFA data structures. */
name|uint32_t
name|flow_id
decl_stmt|;
comment|/* 	 * This is the ID of the flow associated with this filter. This value 	 * shall be used to match and associate the flow identifier returned in 	 * completion records. A value of 0xFFFFFFFF shall indicate no flow id. 	 */
name|uint8_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Command specific Error Codes (8 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_cfa_ntuple_filter_alloc_cmd_err
block|{
name|uint8_t
name|code
decl_stmt|;
comment|/* 	 * command specific error codes that goes to the cmd_err field in Common 	 * HWRM Error Response. 	 */
comment|/* Unknown error */
define|#
directive|define
name|HWRM_CFA_NTUPLE_FILTER_ALLOC_CMD_ERR_CODE_UNKNOWN
value|UINT32_C(0x0)
comment|/* Unable to complete operation due to conflict with Rx Mask VLAN */
define|#
directive|define
name|HWRM_CFA_NTUPLE_FILTER_ALLOC_CMD_ERR_CODE_RX_MASK_VLAN_CONFLICT_ERR
value|UINT32_C(0x1)
name|uint8_t
name|unused_0
index|[
literal|7
index|]
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_cfa_ntuple_filter_free */
end_comment

begin_comment
comment|/* Description: Free an ntuple filter */
end_comment

begin_comment
comment|/* Input (24 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_cfa_ntuple_filter_free_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint64_t
name|ntuple_filter_id
decl_stmt|;
comment|/* This value is an opaque id into CFA data structures. */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_cfa_ntuple_filter_free_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint32_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_cfa_ntuple_filter_cfg */
end_comment

begin_comment
comment|/*  * Description: Configure an ntuple filter with a new destination VNIC and/or  * meter.  */
end_comment

begin_comment
comment|/* Input (48 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_cfa_ntuple_filter_cfg_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint32_t
name|enables
decl_stmt|;
comment|/* This bit must be '1' for the new_dst_id field to be configured. */
define|#
directive|define
name|HWRM_CFA_NTUPLE_FILTER_CFG_INPUT_ENABLES_NEW_DST_ID
value|UINT32_C(0x1)
comment|/* 	 * This bit must be '1' for the new_mirror_vnic_id field to be 	 * configured. 	 */
define|#
directive|define
name|HWRM_CFA_NTUPLE_FILTER_CFG_INPUT_ENABLES_NEW_MIRROR_VNIC_ID
value|UINT32_C(0x2)
comment|/* 	 * This bit must be '1' for the new_meter_instance_id field to be 	 * configured. 	 */
define|#
directive|define
name|HWRM_CFA_NTUPLE_FILTER_CFG_INPUT_ENABLES_NEW_METER_INSTANCE_ID
value|UINT32_C(0x4)
name|uint32_t
name|unused_0
decl_stmt|;
name|uint64_t
name|ntuple_filter_id
decl_stmt|;
comment|/* This value is an opaque id into CFA data structures. */
name|uint32_t
name|new_dst_id
decl_stmt|;
comment|/* 	 * If set, this value shall represent the new Logical VNIC ID of the 	 * destination VNIC for the RX path and new network port id of the 	 * destination port for the TX path. 	 */
name|uint32_t
name|new_mirror_vnic_id
decl_stmt|;
comment|/* New Logical VNIC ID of the VNIC where traffic is mirrored. */
name|uint16_t
name|new_meter_instance_id
decl_stmt|;
comment|/* 	 * New meter to attach to the flow. Specifying the invalid instance ID 	 * is used to remove any existing meter from the flow. 	 */
comment|/* 	 * A value of 0xfff is considered invalid and implies the 	 * instance is not configured. 	 */
define|#
directive|define
name|HWRM_CFA_NTUPLE_FILTER_CFG_INPUT_NEW_METER_INSTANCE_ID_INVALID
value|UINT32_C(0xffff)
name|uint16_t
name|unused_1
index|[
literal|3
index|]
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_cfa_ntuple_filter_cfg_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint32_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_cfa_em_flow_alloc */
end_comment

begin_comment
comment|/*  * Description: This is a generic Exact Match (EM) flow that uses fields from  * L4/L3/L2 headers. The EM flows apply to transmit and receive traffic. All  * L2/L3/L4 header fields are specified in network byte order. For each EM flow,  * there is an associated set of actions specified. For tunneled packets, all  * L2/L3/L4 fields specified are fields of inner headers unless otherwise  * specified. # If a field specified in this command is not enabled as a valid  * field, then that field shall not be used in matching packet header fields  * against this EM flow entry.  */
end_comment

begin_comment
comment|/* Input (112 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_cfa_em_flow_alloc_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint32_t
name|flags
decl_stmt|;
comment|/* 	 * Enumeration denoting the RX, TX type of the resource. This 	 * enumeration is used for resources that are similar for both TX and RX 	 * paths of the chip. 	 */
define|#
directive|define
name|HWRM_CFA_EM_FLOW_ALLOC_INPUT_FLAGS_PATH
value|UINT32_C(0x1)
comment|/* tx path */
define|#
directive|define
name|HWRM_CFA_EM_FLOW_ALLOC_INPUT_FLAGS_PATH_TX
value|(UINT32_C(0x0)<< 0)
comment|/* rx path */
define|#
directive|define
name|HWRM_CFA_EM_FLOW_ALLOC_INPUT_FLAGS_PATH_RX
value|(UINT32_C(0x1)<< 0)
define|#
directive|define
name|HWRM_CFA_EM_FLOW_ALLOC_INPUT_FLAGS_PATH_LAST
value|HWRM_CFA_EM_FLOW_ALLOC_INPUT_FLAGS_PATH_RX
comment|/* 	 * Setting of this flag indicates enabling of a byte counter for a given 	 * flow. 	 */
define|#
directive|define
name|HWRM_CFA_EM_FLOW_ALLOC_INPUT_FLAGS_BYTE_CTR
value|UINT32_C(0x2)
comment|/* 	 * Setting of this flag indicates enabling of a packet counter for a 	 * given flow. 	 */
define|#
directive|define
name|HWRM_CFA_EM_FLOW_ALLOC_INPUT_FLAGS_PKT_CTR
value|UINT32_C(0x4)
comment|/* 	 * Setting of this flag indicates de-capsulation action for the given 	 * flow. 	 */
define|#
directive|define
name|HWRM_CFA_EM_FLOW_ALLOC_INPUT_FLAGS_DECAP
value|UINT32_C(0x8)
comment|/* 	 * Setting of this flag indicates encapsulation action for the given 	 * flow. 	 */
define|#
directive|define
name|HWRM_CFA_EM_FLOW_ALLOC_INPUT_FLAGS_ENCAP
value|UINT32_C(0x10)
comment|/* 	 * Setting of this flag indicates drop action. If this flag is not set, 	 * then it should be considered accept action. 	 */
define|#
directive|define
name|HWRM_CFA_EM_FLOW_ALLOC_INPUT_FLAGS_DROP
value|UINT32_C(0x20)
comment|/* 	 * Setting of this flag indicates that a meter is expected to be 	 * attached to this flow. This hint can be used when choosing the action 	 * record format required for the flow. 	 */
define|#
directive|define
name|HWRM_CFA_EM_FLOW_ALLOC_INPUT_FLAGS_METER
value|UINT32_C(0x40)
name|uint32_t
name|enables
decl_stmt|;
comment|/* This bit must be '1' for the l2_filter_id field to be configured. */
define|#
directive|define
name|HWRM_CFA_EM_FLOW_ALLOC_INPUT_ENABLES_L2_FILTER_ID
value|UINT32_C(0x1)
comment|/* This bit must be '1' for the tunnel_type field to be configured. */
define|#
directive|define
name|HWRM_CFA_EM_FLOW_ALLOC_INPUT_ENABLES_TUNNEL_TYPE
value|UINT32_C(0x2)
comment|/* This bit must be '1' for the tunnel_id field to be configured. */
define|#
directive|define
name|HWRM_CFA_EM_FLOW_ALLOC_INPUT_ENABLES_TUNNEL_ID
value|UINT32_C(0x4)
comment|/* This bit must be '1' for the src_macaddr field to be configured. */
define|#
directive|define
name|HWRM_CFA_EM_FLOW_ALLOC_INPUT_ENABLES_SRC_MACADDR
value|UINT32_C(0x8)
comment|/* This bit must be '1' for the dst_macaddr field to be configured. */
define|#
directive|define
name|HWRM_CFA_EM_FLOW_ALLOC_INPUT_ENABLES_DST_MACADDR
value|UINT32_C(0x10)
comment|/* This bit must be '1' for the ovlan_vid field to be configured. */
define|#
directive|define
name|HWRM_CFA_EM_FLOW_ALLOC_INPUT_ENABLES_OVLAN_VID
value|UINT32_C(0x20)
comment|/* This bit must be '1' for the ivlan_vid field to be configured. */
define|#
directive|define
name|HWRM_CFA_EM_FLOW_ALLOC_INPUT_ENABLES_IVLAN_VID
value|UINT32_C(0x40)
comment|/* This bit must be '1' for the ethertype field to be configured. */
define|#
directive|define
name|HWRM_CFA_EM_FLOW_ALLOC_INPUT_ENABLES_ETHERTYPE
value|UINT32_C(0x80)
comment|/* This bit must be '1' for the src_ipaddr field to be configured. */
define|#
directive|define
name|HWRM_CFA_EM_FLOW_ALLOC_INPUT_ENABLES_SRC_IPADDR
value|UINT32_C(0x100)
comment|/* This bit must be '1' for the dst_ipaddr field to be configured. */
define|#
directive|define
name|HWRM_CFA_EM_FLOW_ALLOC_INPUT_ENABLES_DST_IPADDR
value|UINT32_C(0x200)
comment|/* This bit must be '1' for the ipaddr_type field to be configured. */
define|#
directive|define
name|HWRM_CFA_EM_FLOW_ALLOC_INPUT_ENABLES_IPADDR_TYPE
value|UINT32_C(0x400)
comment|/* This bit must be '1' for the ip_protocol field to be configured. */
define|#
directive|define
name|HWRM_CFA_EM_FLOW_ALLOC_INPUT_ENABLES_IP_PROTOCOL
value|UINT32_C(0x800)
comment|/* This bit must be '1' for the src_port field to be configured. */
define|#
directive|define
name|HWRM_CFA_EM_FLOW_ALLOC_INPUT_ENABLES_SRC_PORT
value|UINT32_C(0x1000)
comment|/* This bit must be '1' for the dst_port field to be configured. */
define|#
directive|define
name|HWRM_CFA_EM_FLOW_ALLOC_INPUT_ENABLES_DST_PORT
value|UINT32_C(0x2000)
comment|/* This bit must be '1' for the dst_id field to be configured. */
define|#
directive|define
name|HWRM_CFA_EM_FLOW_ALLOC_INPUT_ENABLES_DST_ID
value|UINT32_C(0x4000)
comment|/* This bit must be '1' for the mirror_vnic_id field to be configured. */
define|#
directive|define
name|HWRM_CFA_EM_FLOW_ALLOC_INPUT_ENABLES_MIRROR_VNIC_ID
value|UINT32_C(0x8000)
comment|/* This bit must be '1' for the encap_record_id field to be configured. */
define|#
directive|define
name|HWRM_CFA_EM_FLOW_ALLOC_INPUT_ENABLES_ENCAP_RECORD_ID
value|UINT32_C(0x10000)
comment|/* 	 * This bit must be '1' for the meter_instance_id field to be 	 * configured. 	 */
define|#
directive|define
name|HWRM_CFA_EM_FLOW_ALLOC_INPUT_ENABLES_METER_INSTANCE_ID
value|UINT32_C(0x20000)
name|uint64_t
name|l2_filter_id
decl_stmt|;
comment|/* 	 * This value identifies a set of CFA data structures used for an L2 	 * context. 	 */
name|uint8_t
name|tunnel_type
decl_stmt|;
comment|/* Tunnel Type. */
comment|/* Non-tunnel */
define|#
directive|define
name|HWRM_CFA_EM_FLOW_ALLOC_INPUT_TUNNEL_TYPE_NONTUNNEL
value|UINT32_C(0x0)
comment|/* Virtual eXtensible Local Area Network (VXLAN) */
define|#
directive|define
name|HWRM_CFA_EM_FLOW_ALLOC_INPUT_TUNNEL_TYPE_VXLAN
value|UINT32_C(0x1)
comment|/* Network Virtualization Generic Routing Encapsulation (NVGRE) */
define|#
directive|define
name|HWRM_CFA_EM_FLOW_ALLOC_INPUT_TUNNEL_TYPE_NVGRE
value|UINT32_C(0x2)
comment|/* Generic Routing Encapsulation (GRE) inside Ethernet payload */
define|#
directive|define
name|HWRM_CFA_EM_FLOW_ALLOC_INPUT_TUNNEL_TYPE_L2GRE
value|UINT32_C(0x3)
comment|/* IP in IP */
define|#
directive|define
name|HWRM_CFA_EM_FLOW_ALLOC_INPUT_TUNNEL_TYPE_IPIP
value|UINT32_C(0x4)
comment|/* Generic Network Virtualization Encapsulation (Geneve) */
define|#
directive|define
name|HWRM_CFA_EM_FLOW_ALLOC_INPUT_TUNNEL_TYPE_GENEVE
value|UINT32_C(0x5)
comment|/* Multi-Protocol Lable Switching (MPLS) */
define|#
directive|define
name|HWRM_CFA_EM_FLOW_ALLOC_INPUT_TUNNEL_TYPE_MPLS
value|UINT32_C(0x6)
comment|/* Stateless Transport Tunnel (STT) */
define|#
directive|define
name|HWRM_CFA_EM_FLOW_ALLOC_INPUT_TUNNEL_TYPE_STT
value|UINT32_C(0x7)
comment|/* Generic Routing Encapsulation (GRE) inside IP datagram payload */
define|#
directive|define
name|HWRM_CFA_EM_FLOW_ALLOC_INPUT_TUNNEL_TYPE_IPGRE
value|UINT32_C(0x8)
comment|/* Any tunneled traffic */
define|#
directive|define
name|HWRM_CFA_EM_FLOW_ALLOC_INPUT_TUNNEL_TYPE_ANYTUNNEL
value|UINT32_C(0xff)
name|uint8_t
name|unused_0
decl_stmt|;
name|uint16_t
name|unused_1
decl_stmt|;
name|uint32_t
name|tunnel_id
decl_stmt|;
comment|/* 	 * Tunnel identifier. Virtual Network Identifier (VNI). Only valid with 	 * tunnel_types VXLAN, NVGRE, and Geneve. Only lower 24-bits of VNI 	 * field are used in setting up the filter. 	 */
name|uint8_t
name|src_macaddr
index|[
literal|6
index|]
decl_stmt|;
comment|/* This value indicates the source MAC address in the Ethernet header. */
name|uint16_t
name|meter_instance_id
decl_stmt|;
comment|/* The meter instance to attach to the flow. */
comment|/* 	 * A value of 0xfff is considered invalid and implies the 	 * instance is not configured. 	 */
define|#
directive|define
name|HWRM_CFA_EM_FLOW_ALLOC_INPUT_METER_INSTANCE_ID_INVALID
value|UINT32_C(0xffff)
name|uint8_t
name|dst_macaddr
index|[
literal|6
index|]
decl_stmt|;
comment|/* 	 * This value indicates the destination MAC address in the Ethernet 	 * header. 	 */
name|uint16_t
name|ovlan_vid
decl_stmt|;
comment|/* 	 * This value indicates the VLAN ID of the outer VLAN tag in the 	 * Ethernet header. 	 */
name|uint16_t
name|ivlan_vid
decl_stmt|;
comment|/* 	 * This value indicates the VLAN ID of the inner VLAN tag in the 	 * Ethernet header. 	 */
name|uint16_t
name|ethertype
decl_stmt|;
comment|/* big endian */
comment|/* This value indicates the ethertype in the Ethernet header. */
name|uint8_t
name|ip_addr_type
decl_stmt|;
comment|/* 	 * This value indicates the type of IP address. 4 - IPv4 6 - IPv6 All 	 * others are invalid. 	 */
comment|/* invalid */
define|#
directive|define
name|HWRM_CFA_EM_FLOW_ALLOC_INPUT_IP_ADDR_TYPE_UNKNOWN
value|UINT32_C(0x0)
comment|/* IPv4 */
define|#
directive|define
name|HWRM_CFA_EM_FLOW_ALLOC_INPUT_IP_ADDR_TYPE_IPV4
value|UINT32_C(0x4)
comment|/* IPv6 */
define|#
directive|define
name|HWRM_CFA_EM_FLOW_ALLOC_INPUT_IP_ADDR_TYPE_IPV6
value|UINT32_C(0x6)
name|uint8_t
name|ip_protocol
decl_stmt|;
comment|/* 	 * The value of protocol filed in IP header. Applies to UDP and TCP 	 * traffic. 6 - TCP 17 - UDP 	 */
comment|/* invalid */
define|#
directive|define
name|HWRM_CFA_EM_FLOW_ALLOC_INPUT_IP_PROTOCOL_UNKNOWN
value|UINT32_C(0x0)
comment|/* TCP */
define|#
directive|define
name|HWRM_CFA_EM_FLOW_ALLOC_INPUT_IP_PROTOCOL_TCP
value|UINT32_C(0x6)
comment|/* UDP */
define|#
directive|define
name|HWRM_CFA_EM_FLOW_ALLOC_INPUT_IP_PROTOCOL_UDP
value|UINT32_C(0x11)
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint32_t
name|src_ipaddr
index|[
literal|4
index|]
decl_stmt|;
comment|/* big endian */
comment|/* 	 * The value of source IP address to be used in filtering. For IPv4, 	 * first four bytes represent the IP address. 	 */
name|uint32_t
name|dst_ipaddr
index|[
literal|4
index|]
decl_stmt|;
comment|/* big endian */
comment|/* 	 * big_endian = True The value of destination IP address to be used in 	 * filtering. For IPv4, first four bytes represent the IP address. 	 */
name|uint16_t
name|src_port
decl_stmt|;
comment|/* big endian */
comment|/* 	 * The value of source port to be used in filtering. Applies to UDP and 	 * TCP traffic. 	 */
name|uint16_t
name|dst_port
decl_stmt|;
comment|/* big endian */
comment|/* 	 * The value of destination port to be used in filtering. Applies to UDP 	 * and TCP traffic. 	 */
name|uint16_t
name|dst_id
decl_stmt|;
comment|/* 	 * If set, this value shall represent the Logical VNIC ID of the 	 * destination VNIC for the RX path and network port id of the 	 * destination port for the TX path. 	 */
name|uint16_t
name|mirror_vnic_id
decl_stmt|;
comment|/* Logical VNIC ID of the VNIC where traffic is mirrored. */
name|uint32_t
name|encap_record_id
decl_stmt|;
comment|/* Logical ID of the encapsulation record. */
name|uint32_t
name|unused_4
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (24 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_cfa_em_flow_alloc_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint64_t
name|em_filter_id
decl_stmt|;
comment|/* This value is an opaque id into CFA data structures. */
name|uint32_t
name|flow_id
decl_stmt|;
comment|/* 	 * This is the ID of the flow associated with this filter. This value 	 * shall be used to match and associate the flow identifier returned in 	 * completion records. A value of 0xFFFFFFFF shall indicate no flow id. 	 */
name|uint8_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_cfa_em_flow_free */
end_comment

begin_comment
comment|/* Description: Free an EM flow table entry */
end_comment

begin_comment
comment|/* Input (24 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_cfa_em_flow_free_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint64_t
name|em_filter_id
decl_stmt|;
comment|/* This value is an opaque id into CFA data structures. */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_cfa_em_flow_free_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint32_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_cfa_em_flow_cfg */
end_comment

begin_comment
comment|/*  * Description: Configure an EM flow with a new destination VNIC and/or meter.  */
end_comment

begin_comment
comment|/* Input (48 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_cfa_em_flow_cfg_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint32_t
name|enables
decl_stmt|;
comment|/* This bit must be '1' for the new_dst_id field to be configured. */
define|#
directive|define
name|HWRM_CFA_EM_FLOW_CFG_INPUT_ENABLES_NEW_DST_ID
value|UINT32_C(0x1)
comment|/* 	 * This bit must be '1' for the new_mirror_vnic_id field to be 	 * configured. 	 */
define|#
directive|define
name|HWRM_CFA_EM_FLOW_CFG_INPUT_ENABLES_NEW_MIRROR_VNIC_ID
value|UINT32_C(0x2)
comment|/* 	 * This bit must be '1' for the new_meter_instance_id field to be 	 * configured. 	 */
define|#
directive|define
name|HWRM_CFA_EM_FLOW_CFG_INPUT_ENABLES_NEW_METER_INSTANCE_ID
value|UINT32_C(0x4)
name|uint32_t
name|unused_0
decl_stmt|;
name|uint64_t
name|em_filter_id
decl_stmt|;
comment|/* This value is an opaque id into CFA data structures. */
name|uint32_t
name|new_dst_id
decl_stmt|;
comment|/* 	 * If set, this value shall represent the new Logical VNIC ID of the 	 * destination VNIC for the RX path and network port id of the 	 * destination port for the TX path. 	 */
name|uint32_t
name|new_mirror_vnic_id
decl_stmt|;
comment|/* New Logical VNIC ID of the VNIC where traffic is mirrored. */
name|uint16_t
name|new_meter_instance_id
decl_stmt|;
comment|/* 	 * New meter to attach to the flow. Specifying the invalid instance ID 	 * is used to remove any existing meter from the flow. 	 */
comment|/* 	 * A value of 0xfff is considered invalid and implies the 	 * instance is not configured. 	 */
define|#
directive|define
name|HWRM_CFA_EM_FLOW_CFG_INPUT_NEW_METER_INSTANCE_ID_INVALID
value|UINT32_C(0xffff)
name|uint16_t
name|unused_1
index|[
literal|3
index|]
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_cfa_em_flow_cfg_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint32_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_cfa_meter_profile_alloc */
end_comment

begin_comment
comment|/*  * Description: This is a meter profile that defines the characteristics of the  * meter. This includes the algorithm, information rates, and burst sizes. No  * running state is kept in a profile and instead meter instances are allocated  * that reference a profile.  */
end_comment

begin_comment
comment|/* Input (40 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_cfa_meter_profile_alloc_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint8_t
name|flags
decl_stmt|;
comment|/* 	 * Enumeration denoting the RX, TX type of the resource. This 	 * enumeration is used for resources that are similar for both TX and RX 	 * paths of the chip. 	 */
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_ALLOC_INPUT_FLAGS_PATH
value|UINT32_C(0x1)
comment|/* tx path */
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_ALLOC_INPUT_FLAGS_PATH_TX
value|UINT32_C(0x0)
comment|/* rx path */
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_ALLOC_INPUT_FLAGS_PATH_RX
value|UINT32_C(0x1)
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_ALLOC_INPUT_FLAGS_PATH_LAST
value|HWRM_CFA_METER_PROFILE_ALLOC_INPUT_FLAGS_PATH_RX
name|uint8_t
name|meter_type
decl_stmt|;
comment|/* The meter algorithm type. */
comment|/* RFC 2697 (srTCM) */
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_ALLOC_INPUT_METER_TYPE_RFC2697
value|UINT32_C(0x0)
comment|/* RFC 2698 (trTCM) */
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_ALLOC_INPUT_METER_TYPE_RFC2698
value|UINT32_C(0x1)
comment|/* RFC 4115 (trTCM) */
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_ALLOC_INPUT_METER_TYPE_RFC4115
value|UINT32_C(0x2)
name|uint16_t
name|reserved1
decl_stmt|;
comment|/* This field is reserved for the future use. It shall be set to 0. */
name|uint32_t
name|reserved2
decl_stmt|;
comment|/* This field is reserved for the future use. It shall be set to 0. */
name|uint32_t
name|commit_rate
decl_stmt|;
comment|/* A meter rate specified in bytes-per-second. */
comment|/* The bandwidth value. */
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_RATE_BW_VALUE_MASK
value|UINT32_C(0xfffffff)
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_RATE_BW_VALUE_SFT
value|0
comment|/* The granularity of the value (bits or bytes). */
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_RATE_SCALE
value|UINT32_C(0x10000000)
comment|/* Value is in bits. */
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_RATE_SCALE_BITS
value|(UINT32_C(0x0)<< 28)
comment|/* Value is in bytes. */
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_RATE_SCALE_BYTES
value|(UINT32_C(0x1)<< 28)
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_RATE_SCALE_LAST
value|HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_RATE_SCALE_BYTES
comment|/* bw_value_unit is 3 b */
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_RATE_BW_VALUE_UNIT_MASK
value|UINT32_C(0xe0000000)
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_RATE_BW_VALUE_UNIT_SFT
value|29
comment|/* Value is in Mb or MB (base 10). */
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_RATE_BW_VALUE_UNIT_MEGA
value|(UINT32_C(0x0)<< 29)
comment|/* Value is in Kb or KB (base 10). */
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_RATE_BW_VALUE_UNIT_KILO
value|(UINT32_C(0x2)<< 29)
comment|/* Value is in bits or bytes. */
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_RATE_BW_VALUE_UNIT_BASE
value|(UINT32_C(0x4)<< 29)
comment|/* Value is in Gb or GB (base 10). */
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_RATE_BW_VALUE_UNIT_GIGA
value|(UINT32_C(0x6)<< 29)
comment|/* Value is in 1/100th of a percentage of total bandwidth. */
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_RATE_BW_VALUE_UNIT_PERCENT1_100
value|(UINT32_C(0x1)<< 29)
comment|/* Invalid unit */
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_RATE_BW_VALUE_UNIT_INVALID
value|(UINT32_C(0x7)<< 29)
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_RATE_BW_VALUE_UNIT_LAST
value|HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_RATE_BW_VALUE_UNIT_INVALID
name|uint32_t
name|commit_burst
decl_stmt|;
comment|/* A meter burst size specified in bytes. */
comment|/* The bandwidth value. */
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_BURST_BW_VALUE_MASK
value|UINT32_C(0xfffffff)
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_BURST_BW_VALUE_SFT
value|0
comment|/* The granularity of the value (bits or bytes). */
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_BURST_SCALE
value|UINT32_C(0x10000000)
comment|/* Value is in bits. */
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_BURST_SCALE_BITS
value|(UINT32_C(0x0)<< 28)
comment|/* Value is in bytes. */
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_BURST_SCALE_BYTES
value|(UINT32_C(0x1)<< 28)
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_BURST_SCALE_LAST
value|HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_BURST_SCALE_BYTES
comment|/* bw_value_unit is 3 b */
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_BURST_BW_VALUE_UNIT_MASK
value|UINT32_C(0xe0000000)
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_BURST_BW_VALUE_UNIT_SFT
value|29
comment|/* Value is in Mb or MB (base 10). */
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_BURST_BW_VALUE_UNIT_MEGA
value|(UINT32_C(0x0)<< 29)
comment|/* Value is in Kb or KB (base 10). */
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_BURST_BW_VALUE_UNIT_KILO
value|(UINT32_C(0x2)<< 29)
comment|/* Value is in bits or bytes. */
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_BURST_BW_VALUE_UNIT_BASE
value|(UINT32_C(0x4)<< 29)
comment|/* Value is in Gb or GB (base 10). */
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_BURST_BW_VALUE_UNIT_GIGA
value|(UINT32_C(0x6)<< 29)
comment|/* Value is in 1/100th of a percentage of total bandwidth. */
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_BURST_BW_VALUE_UNIT_PERCENT1_100
value|(UINT32_C(0x1)<< 29)
comment|/* Invalid unit */
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_BURST_BW_VALUE_UNIT_INVALID
value|(UINT32_C(0x7)<< 29)
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_BURST_BW_VALUE_UNIT_LAST
value|HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_BURST_BW_VALUE_UNIT_INVALID
name|uint32_t
name|excess_peak_rate
decl_stmt|;
comment|/* A meter rate specified in bytes-per-second. */
comment|/* The bandwidth value. */
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_RATE_BW_VALUE_MASK
value|UINT32_C(0xfffffff)
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_RATE_BW_VALUE_SFT
value|0
comment|/* The granularity of the value (bits or bytes). */
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_RATE_SCALE
value|UINT32_C(0x10000000)
comment|/* Value is in bits. */
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_RATE_SCALE_BITS
value|(UINT32_C(0x0)<< 28)
comment|/* Value is in bytes. */
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_RATE_SCALE_BYTES
value|(UINT32_C(0x1)<< 28)
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_RATE_SCALE_LAST
value|HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_RATE_SCALE_BYTES
comment|/* bw_value_unit is 3 b */
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_RATE_BW_VALUE_UNIT_MASK
value|UINT32_C(0xe0000000)
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_RATE_BW_VALUE_UNIT_SFT
value|29
comment|/* Value is in Mb or MB (base 10). */
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_RATE_BW_VALUE_UNIT_MEGA
value|(UINT32_C(0x0)<< 29)
comment|/* Value is in Kb or KB (base 10). */
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_RATE_BW_VALUE_UNIT_KILO
value|(UINT32_C(0x2)<< 29)
comment|/* Value is in bits or bytes. */
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_RATE_BW_VALUE_UNIT_BASE
value|(UINT32_C(0x4)<< 29)
comment|/* Value is in Gb or GB (base 10). */
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_RATE_BW_VALUE_UNIT_GIGA
value|(UINT32_C(0x6)<< 29)
comment|/* Value is in 1/100th of a percentage of total bandwidth. */
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_RATE_BW_VALUE_UNIT_PERCENT1_100
value|(UINT32_C(0x1)<< 29)
comment|/* Invalid unit */
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_RATE_BW_VALUE_UNIT_INVALID
value|(UINT32_C(0x7)<< 29)
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_RATE_BW_VALUE_UNIT_LAST
value|HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_RATE_BW_VALUE_UNIT_INVALID
name|uint32_t
name|excess_peak_burst
decl_stmt|;
comment|/* A meter burst size specified in bytes. */
comment|/* The bandwidth value. */
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_BURST_BW_VALUE_MASK
value|UINT32_C(0xfffffff)
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_BURST_BW_VALUE_SFT
value|0
comment|/* The granularity of the value (bits or bytes). */
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_BURST_SCALE
value|UINT32_C(0x10000000)
comment|/* Value is in bits. */
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_BURST_SCALE_BITS
value|(UINT32_C(0x0)<< 28)
comment|/* Value is in bytes. */
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_BURST_SCALE_BYTES
value|(UINT32_C(0x1)<< 28)
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_BURST_SCALE_LAST
value|HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_BURST_SCALE_BYTES
comment|/* bw_value_unit is 3 b */
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_BURST_BW_VALUE_UNIT_MASK
value|UINT32_C(0xe0000000)
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_BURST_BW_VALUE_UNIT_SFT
value|29
comment|/* Value is in Mb or MB (base 10). */
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_BURST_BW_VALUE_UNIT_MEGA
value|(UINT32_C(0x0)<< 29)
comment|/* Value is in Kb or KB (base 10). */
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_BURST_BW_VALUE_UNIT_KILO
value|(UINT32_C(0x2)<< 29)
comment|/* Value is in bits or bytes. */
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_BURST_BW_VALUE_UNIT_BASE
value|(UINT32_C(0x4)<< 29)
comment|/* Value is in Gb or GB (base 10). */
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_BURST_BW_VALUE_UNIT_GIGA
value|(UINT32_C(0x6)<< 29)
comment|/* Value is in 1/100th of a percentage of total bandwidth. */
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_BURST_BW_VALUE_UNIT_PERCENT1_100
value|(UINT32_C(0x1)<< 29)
comment|/* Invalid unit */
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_BURST_BW_VALUE_UNIT_INVALID
value|(UINT32_C(0x7)<< 29)
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_BURST_BW_VALUE_UNIT_LAST
value|HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_BURST_BW_VALUE_UNIT_INVALID
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_cfa_meter_profile_alloc_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint16_t
name|meter_profile_id
decl_stmt|;
comment|/* This value identifies a meter profile in CFA. */
comment|/* 	 * A value of 0xfff is considered invalid and implies the 	 * profile is not configured. 	 */
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_ALLOC_OUTPUT_METER_PROFILE_ID_INVALID
value|UINT32_C(0xffff)
name|uint8_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint8_t
name|unused_4
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_cfa_meter_profile_free */
end_comment

begin_comment
comment|/* Description: Free a meter profile. */
end_comment

begin_comment
comment|/* Input (24 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_cfa_meter_profile_free_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint8_t
name|flags
decl_stmt|;
comment|/* 	 * Enumeration denoting the RX, TX type of the resource. This 	 * enumeration is used for resources that are similar for both TX and RX 	 * paths of the chip. 	 */
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_FREE_INPUT_FLAGS_PATH
value|UINT32_C(0x1)
comment|/* tx path */
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_FREE_INPUT_FLAGS_PATH_TX
value|UINT32_C(0x0)
comment|/* rx path */
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_FREE_INPUT_FLAGS_PATH_RX
value|UINT32_C(0x1)
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_FREE_INPUT_FLAGS_PATH_LAST
value|HWRM_CFA_METER_PROFILE_FREE_INPUT_FLAGS_PATH_RX
name|uint8_t
name|unused_0
decl_stmt|;
name|uint16_t
name|meter_profile_id
decl_stmt|;
comment|/* This value identifies a meter profile in CFA. */
comment|/* 	 * A value of 0xfff is considered invalid and implies the 	 * profile is not configured. 	 */
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_FREE_INPUT_METER_PROFILE_ID_INVALID
value|UINT32_C(0xffff)
name|uint32_t
name|unused_1
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_cfa_meter_profile_free_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint32_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_cfa_meter_profile_cfg */
end_comment

begin_comment
comment|/* Description: Reconfigure a meter profile. */
end_comment

begin_comment
comment|/* Input (40 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_cfa_meter_profile_cfg_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint8_t
name|flags
decl_stmt|;
comment|/* 	 * Enumeration denoting the RX, TX type of the resource. This 	 * enumeration is used for resources that are similar for both TX and RX 	 * paths of the chip. 	 */
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_CFG_INPUT_FLAGS_PATH
value|UINT32_C(0x1)
comment|/* tx path */
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_CFG_INPUT_FLAGS_PATH_TX
value|UINT32_C(0x0)
comment|/* rx path */
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_CFG_INPUT_FLAGS_PATH_RX
value|UINT32_C(0x1)
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_CFG_INPUT_FLAGS_PATH_LAST
value|HWRM_CFA_METER_PROFILE_CFG_INPUT_FLAGS_PATH_RX
name|uint8_t
name|meter_type
decl_stmt|;
comment|/* The meter algorithm type. */
comment|/* RFC 2697 (srTCM) */
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_CFG_INPUT_METER_TYPE_RFC2697
value|UINT32_C(0x0)
comment|/* RFC 2698 (trTCM) */
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_CFG_INPUT_METER_TYPE_RFC2698
value|UINT32_C(0x1)
comment|/* RFC 4115 (trTCM) */
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_CFG_INPUT_METER_TYPE_RFC4115
value|UINT32_C(0x2)
name|uint16_t
name|meter_profile_id
decl_stmt|;
comment|/* This value identifies a meter profile in CFA. */
comment|/* 	 * A value of 0xfff is considered invalid and implies the 	 * profile is not configured. 	 */
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_CFG_INPUT_METER_PROFILE_ID_INVALID
value|UINT32_C(0xffff)
name|uint32_t
name|reserved
decl_stmt|;
comment|/* This field is reserved for the future use. It shall be set to 0. */
name|uint32_t
name|commit_rate
decl_stmt|;
comment|/* A meter rate specified in bytes-per-second. */
comment|/* The bandwidth value. */
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_RATE_BW_VALUE_MASK
value|UINT32_C(0xfffffff)
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_RATE_BW_VALUE_SFT
value|0
comment|/* The granularity of the value (bits or bytes). */
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_RATE_SCALE
value|UINT32_C(0x10000000)
comment|/* Value is in bits. */
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_RATE_SCALE_BITS
value|(UINT32_C(0x0)<< 28)
comment|/* Value is in bytes. */
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_RATE_SCALE_BYTES
value|(UINT32_C(0x1)<< 28)
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_RATE_SCALE_LAST
value|HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_RATE_SCALE_BYTES
comment|/* bw_value_unit is 3 b */
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_RATE_BW_VALUE_UNIT_MASK
value|UINT32_C(0xe0000000)
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_RATE_BW_VALUE_UNIT_SFT
value|29
comment|/* Value is in Mb or MB (base 10). */
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_RATE_BW_VALUE_UNIT_MEGA
value|(UINT32_C(0x0)<< 29)
comment|/* Value is in Kb or KB (base 10). */
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_RATE_BW_VALUE_UNIT_KILO
value|(UINT32_C(0x2)<< 29)
comment|/* Value is in bits or bytes. */
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_RATE_BW_VALUE_UNIT_BASE
value|(UINT32_C(0x4)<< 29)
comment|/* Value is in Gb or GB (base 10). */
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_RATE_BW_VALUE_UNIT_GIGA
value|(UINT32_C(0x6)<< 29)
comment|/* Value is in 1/100th of a percentage of total bandwidth. */
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_RATE_BW_VALUE_UNIT_PERCENT1_100
value|(UINT32_C(0x1)<< 29)
comment|/* Invalid unit */
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_RATE_BW_VALUE_UNIT_INVALID
value|(UINT32_C(0x7)<< 29)
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_RATE_BW_VALUE_UNIT_LAST
value|HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_RATE_BW_VALUE_UNIT_INVALID
name|uint32_t
name|commit_burst
decl_stmt|;
comment|/* A meter burst size specified in bytes. */
comment|/* The bandwidth value. */
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_BURST_BW_VALUE_MASK
value|UINT32_C(0xfffffff)
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_BURST_BW_VALUE_SFT
value|0
comment|/* The granularity of the value (bits or bytes). */
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_BURST_SCALE
value|UINT32_C(0x10000000)
comment|/* Value is in bits. */
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_BURST_SCALE_BITS
value|(UINT32_C(0x0)<< 28)
comment|/* Value is in bytes. */
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_BURST_SCALE_BYTES
value|(UINT32_C(0x1)<< 28)
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_BURST_SCALE_LAST
value|HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_BURST_SCALE_BYTES
comment|/* bw_value_unit is 3 b */
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_BURST_BW_VALUE_UNIT_MASK
value|UINT32_C(0xe0000000)
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_BURST_BW_VALUE_UNIT_SFT
value|29
comment|/* Value is in Mb or MB (base 10). */
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_BURST_BW_VALUE_UNIT_MEGA
value|(UINT32_C(0x0)<< 29)
comment|/* Value is in Kb or KB (base 10). */
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_BURST_BW_VALUE_UNIT_KILO
value|(UINT32_C(0x2)<< 29)
comment|/* Value is in bits or bytes. */
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_BURST_BW_VALUE_UNIT_BASE
value|(UINT32_C(0x4)<< 29)
comment|/* Value is in Gb or GB (base 10). */
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_BURST_BW_VALUE_UNIT_GIGA
value|(UINT32_C(0x6)<< 29)
comment|/* Value is in 1/100th of a percentage of total bandwidth. */
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_BURST_BW_VALUE_UNIT_PERCENT1_100
value|(UINT32_C(0x1)<< 29)
comment|/* Invalid unit */
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_BURST_BW_VALUE_UNIT_INVALID
value|(UINT32_C(0x7)<< 29)
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_BURST_BW_VALUE_UNIT_LAST
value|HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_BURST_BW_VALUE_UNIT_INVALID
name|uint32_t
name|excess_peak_rate
decl_stmt|;
comment|/* A meter rate specified in bytes-per-second. */
comment|/* The bandwidth value. */
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_RATE_BW_VALUE_MASK
value|UINT32_C(0xfffffff)
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_RATE_BW_VALUE_SFT
value|0
comment|/* The granularity of the value (bits or bytes). */
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_RATE_SCALE
value|UINT32_C(0x10000000)
comment|/* Value is in bits. */
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_RATE_SCALE_BITS
value|(UINT32_C(0x0)<< 28)
comment|/* Value is in bytes. */
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_RATE_SCALE_BYTES
value|(UINT32_C(0x1)<< 28)
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_RATE_SCALE_LAST
value|HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_RATE_SCALE_BYTES
comment|/* bw_value_unit is 3 b */
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_RATE_BW_VALUE_UNIT_MASK
value|UINT32_C(0xe0000000)
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_RATE_BW_VALUE_UNIT_SFT
value|29
comment|/* Value is in Mb or MB (base 10). */
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_RATE_BW_VALUE_UNIT_MEGA
value|(UINT32_C(0x0)<< 29)
comment|/* Value is in Kb or KB (base 10). */
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_RATE_BW_VALUE_UNIT_KILO
value|(UINT32_C(0x2)<< 29)
comment|/* Value is in bits or bytes. */
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_RATE_BW_VALUE_UNIT_BASE
value|(UINT32_C(0x4)<< 29)
comment|/* Value is in Gb or GB (base 10). */
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_RATE_BW_VALUE_UNIT_GIGA
value|(UINT32_C(0x6)<< 29)
comment|/* Value is in 1/100th of a percentage of total bandwidth. */
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_RATE_BW_VALUE_UNIT_PERCENT1_100
value|(UINT32_C(0x1)<< 29)
comment|/* Invalid unit */
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_RATE_BW_VALUE_UNIT_INVALID
value|(UINT32_C(0x7)<< 29)
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_RATE_BW_VALUE_UNIT_LAST
value|HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_RATE_BW_VALUE_UNIT_INVALID
name|uint32_t
name|excess_peak_burst
decl_stmt|;
comment|/* A meter burst size specified in bytes. */
comment|/* The bandwidth value. */
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_BURST_BW_VALUE_MASK
value|UINT32_C(0xfffffff)
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_BURST_BW_VALUE_SFT
value|0
comment|/* The granularity of the value (bits or bytes). */
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_BURST_SCALE
value|UINT32_C(0x10000000)
comment|/* Value is in bits. */
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_BURST_SCALE_BITS
value|(UINT32_C(0x0)<< 28)
comment|/* Value is in bytes. */
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_BURST_SCALE_BYTES
value|(UINT32_C(0x1)<< 28)
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_BURST_SCALE_LAST
value|HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_BURST_SCALE_BYTES
comment|/* bw_value_unit is 3 b */
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_BURST_BW_VALUE_UNIT_MASK
value|UINT32_C(0xe0000000)
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_BURST_BW_VALUE_UNIT_SFT
value|29
comment|/* Value is in Mb or MB (base 10). */
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_BURST_BW_VALUE_UNIT_MEGA
value|(UINT32_C(0x0)<< 29)
comment|/* Value is in Kb or KB (base 10). */
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_BURST_BW_VALUE_UNIT_KILO
value|(UINT32_C(0x2)<< 29)
comment|/* Value is in bits or bytes. */
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_BURST_BW_VALUE_UNIT_BASE
value|(UINT32_C(0x4)<< 29)
comment|/* Value is in Gb or GB (base 10). */
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_BURST_BW_VALUE_UNIT_GIGA
value|(UINT32_C(0x6)<< 29)
comment|/* Value is in 1/100th of a percentage of total bandwidth. */
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_BURST_BW_VALUE_UNIT_PERCENT1_100
value|(UINT32_C(0x1)<< 29)
comment|/* Invalid unit */
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_BURST_BW_VALUE_UNIT_INVALID
value|(UINT32_C(0x7)<< 29)
define|#
directive|define
name|HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_BURST_BW_VALUE_UNIT_LAST
value|HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_BURST_BW_VALUE_UNIT_INVALID
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_cfa_meter_profile_cfg_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint32_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_cfa_meter_instance_alloc */
end_comment

begin_comment
comment|/*  * Description: This is a meter instance which is used to track a meter's bucket  * fill values for a flow. Each meter instance references a meter profile that  * defines the meter algorithm in use.  */
end_comment

begin_comment
comment|/* Input (24 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_cfa_meter_instance_alloc_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint8_t
name|flags
decl_stmt|;
comment|/* 	 * Enumeration denoting the RX, TX type of the resource. This 	 * enumeration is used for resources that are similar for both TX and RX 	 * paths of the chip. 	 */
define|#
directive|define
name|HWRM_CFA_METER_INSTANCE_ALLOC_INPUT_FLAGS_PATH
value|UINT32_C(0x1)
comment|/* tx path */
define|#
directive|define
name|HWRM_CFA_METER_INSTANCE_ALLOC_INPUT_FLAGS_PATH_TX
value|UINT32_C(0x0)
comment|/* rx path */
define|#
directive|define
name|HWRM_CFA_METER_INSTANCE_ALLOC_INPUT_FLAGS_PATH_RX
value|UINT32_C(0x1)
define|#
directive|define
name|HWRM_CFA_METER_INSTANCE_ALLOC_INPUT_FLAGS_PATH_LAST
value|HWRM_CFA_METER_INSTANCE_ALLOC_INPUT_FLAGS_PATH_RX
name|uint8_t
name|unused_0
decl_stmt|;
name|uint16_t
name|meter_profile_id
decl_stmt|;
comment|/* This value identifies a meter profile in CFA. */
comment|/* 	 * A value of 0xfff is considered invalid and implies the 	 * profile is not configured. 	 */
define|#
directive|define
name|HWRM_CFA_METER_INSTANCE_ALLOC_INPUT_METER_PROFILE_ID_INVALID
value|UINT32_C(0xffff)
name|uint32_t
name|unused_1
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_cfa_meter_instance_alloc_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint16_t
name|meter_instance_id
decl_stmt|;
comment|/* This value identifies a meter instance in CFA. */
comment|/* 	 * A value of 0xfff is considered invalid and implies the 	 * instance is not configured. 	 */
define|#
directive|define
name|HWRM_CFA_METER_INSTANCE_ALLOC_OUTPUT_METER_INSTANCE_ID_INVALID
value|UINT32_C(0xffff)
name|uint8_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint8_t
name|unused_4
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_cfa_meter_instance_free */
end_comment

begin_comment
comment|/* Description: Free a meter instance. */
end_comment

begin_comment
comment|/* Input (24 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_cfa_meter_instance_free_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint8_t
name|flags
decl_stmt|;
comment|/* 	 * Enumeration denoting the RX, TX type of the resource. This 	 * enumeration is used for resources that are similar for both TX and RX 	 * paths of the chip. 	 */
define|#
directive|define
name|HWRM_CFA_METER_INSTANCE_FREE_INPUT_FLAGS_PATH
value|UINT32_C(0x1)
comment|/* tx path */
define|#
directive|define
name|HWRM_CFA_METER_INSTANCE_FREE_INPUT_FLAGS_PATH_TX
value|UINT32_C(0x0)
comment|/* rx path */
define|#
directive|define
name|HWRM_CFA_METER_INSTANCE_FREE_INPUT_FLAGS_PATH_RX
value|UINT32_C(0x1)
define|#
directive|define
name|HWRM_CFA_METER_INSTANCE_FREE_INPUT_FLAGS_PATH_LAST
value|HWRM_CFA_METER_INSTANCE_FREE_INPUT_FLAGS_PATH_RX
name|uint8_t
name|unused_0
decl_stmt|;
name|uint16_t
name|meter_instance_id
decl_stmt|;
comment|/* This value identifies a meter instance in CFA. */
comment|/* 	 * A value of 0xfff is considered invalid and implies the 	 * instance is not configured. 	 */
define|#
directive|define
name|HWRM_CFA_METER_INSTANCE_FREE_INPUT_METER_INSTANCE_ID_INVALID
value|UINT32_C(0xffff)
name|uint32_t
name|unused_1
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_cfa_meter_instance_free_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint32_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_cfa_decap_filter_alloc */
end_comment

begin_comment
comment|/*  * Description: This command uses fields from L4/L3/L2 headers. All L2/L3/L4  * header fields are specified in network byte order.  */
end_comment

begin_comment
comment|/* Input (104 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_cfa_decap_filter_alloc_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint32_t
name|flags
decl_stmt|;
comment|/* ovs_tunnel is 1 b */
define|#
directive|define
name|HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_FLAGS_OVS_TUNNEL
value|UINT32_C(0x1)
name|uint32_t
name|enables
decl_stmt|;
comment|/* This bit must be '1' for the tunnel_type field to be configured. */
define|#
directive|define
name|HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_ENABLES_TUNNEL_TYPE
value|UINT32_C(0x1)
comment|/* This bit must be '1' for the tunnel_id field to be configured. */
define|#
directive|define
name|HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_ENABLES_TUNNEL_ID
value|UINT32_C(0x2)
comment|/* This bit must be '1' for the src_macaddr field to be configured. */
define|#
directive|define
name|HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_ENABLES_SRC_MACADDR
value|UINT32_C(0x4)
comment|/* This bit must be '1' for the dst_macaddr field to be configured. */
define|#
directive|define
name|HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_ENABLES_DST_MACADDR
value|UINT32_C(0x8)
comment|/* This bit must be '1' for the ovlan_vid field to be configured. */
define|#
directive|define
name|HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_ENABLES_OVLAN_VID
value|UINT32_C(0x10)
comment|/* This bit must be '1' for the ivlan_vid field to be configured. */
define|#
directive|define
name|HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_ENABLES_IVLAN_VID
value|UINT32_C(0x20)
comment|/* This bit must be '1' for the t_ovlan_vid field to be configured. */
define|#
directive|define
name|HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_ENABLES_T_OVLAN_VID
value|UINT32_C(0x40)
comment|/* This bit must be '1' for the t_ivlan_vid field to be configured. */
define|#
directive|define
name|HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_ENABLES_T_IVLAN_VID
value|UINT32_C(0x80)
comment|/* This bit must be '1' for the ethertype field to be configured. */
define|#
directive|define
name|HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_ENABLES_ETHERTYPE
value|UINT32_C(0x100)
comment|/* This bit must be '1' for the src_ipaddr field to be configured. */
define|#
directive|define
name|HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_ENABLES_SRC_IPADDR
value|UINT32_C(0x200)
comment|/* This bit must be '1' for the dst_ipaddr field to be configured. */
define|#
directive|define
name|HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_ENABLES_DST_IPADDR
value|UINT32_C(0x400)
comment|/* This bit must be '1' for the ipaddr_type field to be configured. */
define|#
directive|define
name|HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_ENABLES_IPADDR_TYPE
value|UINT32_C(0x800)
comment|/* This bit must be '1' for the ip_protocol field to be configured. */
define|#
directive|define
name|HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_ENABLES_IP_PROTOCOL
value|UINT32_C(0x1000)
comment|/* This bit must be '1' for the src_port field to be configured. */
define|#
directive|define
name|HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_ENABLES_SRC_PORT
value|UINT32_C(0x2000)
comment|/* This bit must be '1' for the dst_port field to be configured. */
define|#
directive|define
name|HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_ENABLES_DST_PORT
value|UINT32_C(0x4000)
comment|/* This bit must be '1' for the dst_id field to be configured. */
define|#
directive|define
name|HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_ENABLES_DST_ID
value|UINT32_C(0x8000)
comment|/* This bit must be '1' for the mirror_vnic_id field to be configured. */
define|#
directive|define
name|HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_ENABLES_MIRROR_VNIC_ID
value|UINT32_C(0x10000)
name|uint32_t
name|tunnel_id
decl_stmt|;
comment|/* 	 * Tunnel identifier. Virtual Network Identifier (VNI). Only valid with 	 * tunnel_types VXLAN, NVGRE, and Geneve. Only lower 24-bits of VNI 	 * field are used in setting up the filter. 	 */
name|uint8_t
name|tunnel_type
decl_stmt|;
comment|/* Tunnel Type. */
comment|/* Non-tunnel */
define|#
directive|define
name|HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_TUNNEL_TYPE_NONTUNNEL
value|UINT32_C(0x0)
comment|/* Virtual eXtensible Local Area Network (VXLAN) */
define|#
directive|define
name|HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_TUNNEL_TYPE_VXLAN
value|UINT32_C(0x1)
comment|/* Network Virtualization Generic Routing Encapsulation (NVGRE) */
define|#
directive|define
name|HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_TUNNEL_TYPE_NVGRE
value|UINT32_C(0x2)
comment|/* Generic Routing Encapsulation (GRE) inside Ethernet payload */
define|#
directive|define
name|HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_TUNNEL_TYPE_L2GRE
value|UINT32_C(0x3)
comment|/* IP in IP */
define|#
directive|define
name|HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_TUNNEL_TYPE_IPIP
value|UINT32_C(0x4)
comment|/* Generic Network Virtualization Encapsulation (Geneve) */
define|#
directive|define
name|HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_TUNNEL_TYPE_GENEVE
value|UINT32_C(0x5)
comment|/* Multi-Protocol Lable Switching (MPLS) */
define|#
directive|define
name|HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_TUNNEL_TYPE_MPLS
value|UINT32_C(0x6)
comment|/* Stateless Transport Tunnel (STT) */
define|#
directive|define
name|HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_TUNNEL_TYPE_STT
value|UINT32_C(0x7)
comment|/* Generic Routing Encapsulation (GRE) inside IP datagram payload */
define|#
directive|define
name|HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_TUNNEL_TYPE_IPGRE
value|UINT32_C(0x8)
comment|/* Any tunneled traffic */
define|#
directive|define
name|HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_TUNNEL_TYPE_ANYTUNNEL
value|UINT32_C(0xff)
name|uint8_t
name|unused_0
decl_stmt|;
name|uint16_t
name|unused_1
decl_stmt|;
name|uint8_t
name|src_macaddr
index|[
literal|6
index|]
decl_stmt|;
comment|/* This value indicates the source MAC address in the Ethernet header. */
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint8_t
name|dst_macaddr
index|[
literal|6
index|]
decl_stmt|;
comment|/* 	 * This value indicates the destination MAC address in the Ethernet 	 * header. 	 */
name|uint16_t
name|ovlan_vid
decl_stmt|;
comment|/* 	 * This value indicates the VLAN ID of the outer VLAN tag in the 	 * Ethernet header. 	 */
name|uint16_t
name|ivlan_vid
decl_stmt|;
comment|/* 	 * This value indicates the VLAN ID of the inner VLAN tag in the 	 * Ethernet header. 	 */
name|uint16_t
name|t_ovlan_vid
decl_stmt|;
comment|/* 	 * This value indicates the VLAN ID of the outer VLAN tag in the tunnel 	 * Ethernet header. 	 */
name|uint16_t
name|t_ivlan_vid
decl_stmt|;
comment|/* 	 * This value indicates the VLAN ID of the inner VLAN tag in the tunnel 	 * Ethernet header. 	 */
name|uint16_t
name|ethertype
decl_stmt|;
comment|/* big endian */
comment|/* This value indicates the ethertype in the Ethernet header. */
name|uint8_t
name|ip_addr_type
decl_stmt|;
comment|/* 	 * This value indicates the type of IP address. 4 - IPv4 6 - IPv6 All 	 * others are invalid. 	 */
comment|/* invalid */
define|#
directive|define
name|HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_IP_ADDR_TYPE_UNKNOWN
value|UINT32_C(0x0)
comment|/* IPv4 */
define|#
directive|define
name|HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_IP_ADDR_TYPE_IPV4
value|UINT32_C(0x4)
comment|/* IPv6 */
define|#
directive|define
name|HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_IP_ADDR_TYPE_IPV6
value|UINT32_C(0x6)
name|uint8_t
name|ip_protocol
decl_stmt|;
comment|/* 	 * The value of protocol filed in IP header. Applies to UDP and TCP 	 * traffic. 6 - TCP 17 - UDP 	 */
comment|/* invalid */
define|#
directive|define
name|HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_IP_PROTOCOL_UNKNOWN
value|UINT32_C(0x0)
comment|/* TCP */
define|#
directive|define
name|HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_IP_PROTOCOL_TCP
value|UINT32_C(0x6)
comment|/* UDP */
define|#
directive|define
name|HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_IP_PROTOCOL_UDP
value|UINT32_C(0x11)
name|uint8_t
name|unused_4
decl_stmt|;
name|uint8_t
name|unused_5
decl_stmt|;
name|uint8_t
name|unused_6
index|[
literal|3
index|]
decl_stmt|;
name|uint8_t
name|unused_7
decl_stmt|;
name|uint32_t
name|src_ipaddr
index|[
literal|4
index|]
decl_stmt|;
comment|/* big endian */
comment|/* 	 * The value of source IP address to be used in filtering. For IPv4, 	 * first four bytes represent the IP address. 	 */
name|uint32_t
name|dst_ipaddr
index|[
literal|4
index|]
decl_stmt|;
comment|/* big endian */
comment|/* 	 * The value of destination IP address to be used in filtering. For 	 * IPv4, first four bytes represent the IP address. 	 */
name|uint16_t
name|src_port
decl_stmt|;
comment|/* big endian */
comment|/* 	 * The value of source port to be used in filtering. Applies to UDP and 	 * TCP traffic. 	 */
name|uint16_t
name|dst_port
decl_stmt|;
comment|/* big endian */
comment|/* 	 * The value of destination port to be used in filtering. Applies to UDP 	 * and TCP traffic. 	 */
name|uint16_t
name|dst_id
decl_stmt|;
comment|/* 	 * If set, this value shall represent the Logical VNIC ID of the 	 * destination VNIC for the RX path. 	 */
name|uint16_t
name|l2_ctxt_ref_id
decl_stmt|;
comment|/* 	 * If set, this value shall represent the L2 context that matches the L2 	 * information of the decap filter. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_cfa_decap_filter_alloc_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint32_t
name|decap_filter_id
decl_stmt|;
comment|/* This value is an opaque id into CFA data structures. */
name|uint8_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_cfa_decap_filter_free */
end_comment

begin_comment
comment|/* Description: Free an decap filter table entry */
end_comment

begin_comment
comment|/* Input (24 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_cfa_decap_filter_free_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint32_t
name|decap_filter_id
decl_stmt|;
comment|/* This value is an opaque id into CFA data structures. */
name|uint32_t
name|unused_0
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_cfa_decap_filter_free_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint32_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_cfa_flow_alloc */
end_comment

begin_comment
comment|/* Description: Flow is added to table and resources are allocated. */
end_comment

begin_comment
comment|/* Input (128 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_cfa_flow_alloc_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint16_t
name|flags
decl_stmt|;
comment|/* tunnel is 1 b */
define|#
directive|define
name|HWRM_CFA_FLOW_ALLOC_INPUT_FLAGS_TUNNEL
value|UINT32_C(0x1)
comment|/* num_vlan is 2 b */
define|#
directive|define
name|HWRM_CFA_FLOW_ALLOC_INPUT_FLAGS_NUM_VLAN_MASK
value|UINT32_C(0x6)
define|#
directive|define
name|HWRM_CFA_FLOW_ALLOC_INPUT_FLAGS_NUM_VLAN_SFT
value|1
comment|/* no tags */
define|#
directive|define
name|HWRM_CFA_FLOW_ALLOC_INPUT_FLAGS_NUM_VLAN_NONE
value|(UINT32_C(0x0)<< 1)
comment|/* 1 tag */
define|#
directive|define
name|HWRM_CFA_FLOW_ALLOC_INPUT_FLAGS_NUM_VLAN_ONE
value|(UINT32_C(0x1)<< 1)
comment|/* 2 tags */
define|#
directive|define
name|HWRM_CFA_FLOW_ALLOC_INPUT_FLAGS_NUM_VLAN_TWO
value|(UINT32_C(0x2)<< 1)
define|#
directive|define
name|HWRM_CFA_FLOW_ALLOC_INPUT_FLAGS_NUM_VLAN_LAST
value|HWRM_CFA_FLOW_ALLOC_INPUT_FLAGS_NUM_VLAN_TWO
comment|/* Enumeration denoting the Flow Type. */
define|#
directive|define
name|HWRM_CFA_FLOW_ALLOC_INPUT_FLAGS_FLOWTYPE_MASK
value|UINT32_C(0x38)
define|#
directive|define
name|HWRM_CFA_FLOW_ALLOC_INPUT_FLAGS_FLOWTYPE_SFT
value|3
comment|/* L2 flow */
define|#
directive|define
name|HWRM_CFA_FLOW_ALLOC_INPUT_FLAGS_FLOWTYPE_L2
value|(UINT32_C(0x0)<< 3)
comment|/* IPV4 flow */
define|#
directive|define
name|HWRM_CFA_FLOW_ALLOC_INPUT_FLAGS_FLOWTYPE_IPV4
value|(UINT32_C(0x1)<< 3)
comment|/* IPV6 flow */
define|#
directive|define
name|HWRM_CFA_FLOW_ALLOC_INPUT_FLAGS_FLOWTYPE_IPV6
value|(UINT32_C(0x2)<< 3)
define|#
directive|define
name|HWRM_CFA_FLOW_ALLOC_INPUT_FLAGS_FLOWTYPE_LAST
value|HWRM_CFA_FLOW_ALLOC_INPUT_FLAGS_FLOWTYPE_IPV6
name|uint16_t
name|src_fid
decl_stmt|;
comment|/* Tx Flow: vf fid. Rx Flow: pf fid. */
name|uint32_t
name|tunnel_handle
decl_stmt|;
comment|/* Tunnel handle valid when tunnel flag is set. */
name|uint16_t
name|action_flags
decl_stmt|;
comment|/* 	 * Setting of this flag indicates drop action. If this flag is not set, 	 * then it should be considered accept action. 	 */
define|#
directive|define
name|HWRM_CFA_FLOW_ALLOC_INPUT_ACTION_FLAGS_FWD
value|UINT32_C(0x1)
comment|/* recycle is 1 b */
define|#
directive|define
name|HWRM_CFA_FLOW_ALLOC_INPUT_ACTION_FLAGS_RECYCLE
value|UINT32_C(0x2)
comment|/* 	 * Setting of this flag indicates drop action. If this flag is not set, 	 * then it should be considered accept action. 	 */
define|#
directive|define
name|HWRM_CFA_FLOW_ALLOC_INPUT_ACTION_FLAGS_DROP
value|UINT32_C(0x4)
comment|/* meter is 1 b */
define|#
directive|define
name|HWRM_CFA_FLOW_ALLOC_INPUT_ACTION_FLAGS_METER
value|UINT32_C(0x8)
comment|/* tunnel is 1 b */
define|#
directive|define
name|HWRM_CFA_FLOW_ALLOC_INPUT_ACTION_FLAGS_TUNNEL
value|UINT32_C(0x10)
comment|/* nat_src is 1 b */
define|#
directive|define
name|HWRM_CFA_FLOW_ALLOC_INPUT_ACTION_FLAGS_NAT_SRC
value|UINT32_C(0x20)
comment|/* nat_dest is 1 b */
define|#
directive|define
name|HWRM_CFA_FLOW_ALLOC_INPUT_ACTION_FLAGS_NAT_DEST
value|UINT32_C(0x40)
comment|/* nat_ipv4_address is 1 b */
define|#
directive|define
name|HWRM_CFA_FLOW_ALLOC_INPUT_ACTION_FLAGS_NAT_IPV4_ADDRESS
value|UINT32_C(0x80)
comment|/* l2_header_rewrite is 1 b */
define|#
directive|define
name|HWRM_CFA_FLOW_ALLOC_INPUT_ACTION_FLAGS_L2_HEADER_REWRITE
value|UINT32_C(0x100)
comment|/* ttl_decrement is 1 b */
define|#
directive|define
name|HWRM_CFA_FLOW_ALLOC_INPUT_ACTION_FLAGS_TTL_DECREMENT
value|UINT32_C(0x200)
name|uint16_t
name|dst_fid
decl_stmt|;
comment|/* Tx Flow: pf or vf fid. Rx Flow: vf fid. */
name|uint16_t
name|l2_rewrite_vlan_tpid
decl_stmt|;
comment|/* big endian */
comment|/* VLAN tpid, valid when push_vlan flag is set. */
name|uint16_t
name|l2_rewrite_vlan_tci
decl_stmt|;
comment|/* big endian */
comment|/* VLAN tci, valid when push_vlan flag is set. */
name|uint16_t
name|act_meter_id
decl_stmt|;
comment|/* Meter id, valid when meter flag is set. */
name|uint16_t
name|ref_flow_handle
decl_stmt|;
comment|/* Flow with the same l2 context tcam key. */
name|uint16_t
name|ethertype
decl_stmt|;
comment|/* big endian */
comment|/* This value sets the match value for the ethertype. */
name|uint16_t
name|outer_vlan_tci
decl_stmt|;
comment|/* big endian */
comment|/* valid when num tags is 1 or 2. */
name|uint16_t
name|dmac
index|[
literal|3
index|]
decl_stmt|;
comment|/* big endian */
comment|/* This value sets the match value for the Destination MAC address. */
name|uint16_t
name|inner_vlan_tci
decl_stmt|;
comment|/* big endian */
comment|/* valid when num tags is 2. */
name|uint16_t
name|smac
index|[
literal|3
index|]
decl_stmt|;
comment|/* big endian */
comment|/* This value sets the match value for the Source MAC address. */
name|uint8_t
name|ip_dst_mask_len
decl_stmt|;
comment|/* The bit length of destination IP address mask. */
name|uint8_t
name|ip_src_mask_len
decl_stmt|;
comment|/* The bit length of source IP address mask. */
name|uint32_t
name|ip_dst
index|[
literal|4
index|]
decl_stmt|;
comment|/* big endian */
comment|/* The value of destination IPv4/IPv6 address. */
name|uint32_t
name|ip_src
index|[
literal|4
index|]
decl_stmt|;
comment|/* big endian */
comment|/* The source IPv4/IPv6 address. */
name|uint16_t
name|l4_src_port
decl_stmt|;
comment|/* big endian */
comment|/* The value of source port. Applies to UDP and TCP traffic. */
name|uint16_t
name|l4_src_port_mask
decl_stmt|;
comment|/* big endian */
comment|/* The value of source port mask. Applies to UDP and TCP traffic. */
name|uint16_t
name|l4_dst_port
decl_stmt|;
comment|/* big endian */
comment|/* The value of destination port. Applies to UDP and TCP traffic. */
name|uint16_t
name|l4_dst_port_mask
decl_stmt|;
comment|/* big endian */
comment|/* The value of destination port mask. Applies to UDP and TCP traffic. */
name|uint32_t
name|nat_ip_address
index|[
literal|4
index|]
decl_stmt|;
comment|/* big endian */
comment|/* NAT IPv4/6 address based on address type flag. 0 values are ignored. */
name|uint16_t
name|l2_rewrite_dmac
index|[
literal|3
index|]
decl_stmt|;
comment|/* big endian */
comment|/* L2 header re-write Destination MAC address. */
name|uint16_t
name|nat_port
decl_stmt|;
comment|/* big endian */
comment|/* 	 * The NAT source/destination port based on direction flag. Applies to 	 * UDP and TCP traffic. 0 values are ignored. 	 */
name|uint16_t
name|l2_rewrite_smac
index|[
literal|3
index|]
decl_stmt|;
comment|/* big endian */
comment|/* L2 header re-write Source MAC address. */
name|uint8_t
name|ip_proto
decl_stmt|;
comment|/* The value of ip protocol. */
name|uint8_t
name|unused_0
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_cfa_flow_alloc_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint16_t
name|flow_handle
decl_stmt|;
comment|/* Flow record index. */
name|uint8_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint8_t
name|unused_4
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_cfa_flow_free */
end_comment

begin_comment
comment|/* Description: Flow is removed from table and resources are released. */
end_comment

begin_comment
comment|/* Input (24 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_cfa_flow_free_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint16_t
name|flow_handle
decl_stmt|;
comment|/* Flow record index. */
name|uint16_t
name|unused_0
index|[
literal|3
index|]
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (32 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_cfa_flow_free_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint64_t
name|packet
decl_stmt|;
comment|/* packet is 64 b */
name|uint64_t
name|byte
decl_stmt|;
comment|/* byte is 64 b */
name|uint32_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_cfa_flow_info */
end_comment

begin_comment
comment|/* Description: Flow record content for specified flow is returned. */
end_comment

begin_comment
comment|/* Input (24 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_cfa_flow_info_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint16_t
name|flow_handle
decl_stmt|;
comment|/* Flow record index. */
comment|/* Max flow handle */
define|#
directive|define
name|HWRM_CFA_FLOW_INFO_INPUT_FLOW_HANDLE_MAX_MASK
value|UINT32_C(0xfff)
define|#
directive|define
name|HWRM_CFA_FLOW_INFO_INPUT_FLOW_HANDLE_MAX_SFT
value|0
comment|/* CNP flow handle */
define|#
directive|define
name|HWRM_CFA_FLOW_INFO_INPUT_FLOW_HANDLE_CNP_CNT
value|UINT32_C(0x1000)
comment|/* Reserved */
define|#
directive|define
name|HWRM_CFA_FLOW_INFO_INPUT_FLOW_HANDLE_RESERVED_MASK
value|UINT32_C(0x6000)
define|#
directive|define
name|HWRM_CFA_FLOW_INFO_INPUT_FLOW_HANDLE_RESERVED_SFT
value|13
comment|/* Direction rx = 1 */
define|#
directive|define
name|HWRM_CFA_FLOW_INFO_INPUT_FLOW_HANDLE_DIR_RX
value|UINT32_C(0x8000)
name|uint16_t
name|unused_0
index|[
literal|3
index|]
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (56 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_cfa_flow_info_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint8_t
name|flags
decl_stmt|;
comment|/* flags is 8 b */
name|uint8_t
name|profile
decl_stmt|;
comment|/* profile is 8 b */
name|uint16_t
name|src_fid
decl_stmt|;
comment|/* src_fid is 16 b */
name|uint16_t
name|dst_fid
decl_stmt|;
comment|/* dst_fid is 16 b */
name|uint16_t
name|l2_ctxt_id
decl_stmt|;
comment|/* l2_ctxt_id is 16 b */
name|uint64_t
name|em_info
decl_stmt|;
comment|/* em_info is 64 b */
name|uint64_t
name|tcam_info
decl_stmt|;
comment|/* tcam_info is 64 b */
name|uint64_t
name|vfp_tcam_info
decl_stmt|;
comment|/* vfp_tcam_info is 64 b */
name|uint16_t
name|ar_id
decl_stmt|;
comment|/* ar_id is 16 b */
name|uint16_t
name|flow_handle
decl_stmt|;
comment|/* flow_handle is 16 b */
name|uint32_t
name|tunnel_handle
decl_stmt|;
comment|/* tunnel_handle is 32 b */
name|uint32_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_cfa_flow_flush */
end_comment

begin_comment
comment|/* Description: All flows are removed from table and resources are released. */
end_comment

begin_comment
comment|/* Input (24 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_cfa_flow_flush_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint32_t
name|flags
decl_stmt|;
name|uint32_t
name|unused_0
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_cfa_flow_flush_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint32_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_cfa_flow_stats */
end_comment

begin_comment
comment|/* Description: Flow is removed from table and resources are released. */
end_comment

begin_comment
comment|/* Input (40 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_cfa_flow_stats_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint16_t
name|num_flows
decl_stmt|;
comment|/* Flow handle. */
name|uint16_t
name|flow_handle_0
decl_stmt|;
comment|/* Flow handle. */
name|uint16_t
name|flow_handle_1
decl_stmt|;
comment|/* Flow handle. */
name|uint16_t
name|flow_handle_2
decl_stmt|;
comment|/* Flow handle. */
name|uint16_t
name|flow_handle_3
decl_stmt|;
comment|/* Flow handle. */
name|uint16_t
name|flow_handle_4
decl_stmt|;
comment|/* Flow handle. */
name|uint16_t
name|flow_handle_5
decl_stmt|;
comment|/* Flow handle. */
name|uint16_t
name|flow_handle_6
decl_stmt|;
comment|/* Flow handle. */
name|uint16_t
name|flow_handle_7
decl_stmt|;
comment|/* Flow handle. */
name|uint16_t
name|flow_handle_8
decl_stmt|;
comment|/* Flow handle. */
name|uint16_t
name|flow_handle_9
decl_stmt|;
comment|/* Flow handle. */
name|uint16_t
name|unused_0
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (176 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_cfa_flow_stats_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint64_t
name|packet_0
decl_stmt|;
comment|/* packet_0 is 64 b */
name|uint64_t
name|packet_1
decl_stmt|;
comment|/* packet_1 is 64 b */
name|uint64_t
name|packet_2
decl_stmt|;
comment|/* packet_2 is 64 b */
name|uint64_t
name|packet_3
decl_stmt|;
comment|/* packet_3 is 64 b */
name|uint64_t
name|packet_4
decl_stmt|;
comment|/* packet_4 is 64 b */
name|uint64_t
name|packet_5
decl_stmt|;
comment|/* packet_5 is 64 b */
name|uint64_t
name|packet_6
decl_stmt|;
comment|/* packet_6 is 64 b */
name|uint64_t
name|packet_7
decl_stmt|;
comment|/* packet_7 is 64 b */
name|uint64_t
name|packet_8
decl_stmt|;
comment|/* packet_8 is 64 b */
name|uint64_t
name|packet_9
decl_stmt|;
comment|/* packet_9 is 64 b */
name|uint64_t
name|byte_0
decl_stmt|;
comment|/* byte_0 is 64 b */
name|uint64_t
name|byte_1
decl_stmt|;
comment|/* byte_1 is 64 b */
name|uint64_t
name|byte_2
decl_stmt|;
comment|/* byte_2 is 64 b */
name|uint64_t
name|byte_3
decl_stmt|;
comment|/* byte_3 is 64 b */
name|uint64_t
name|byte_4
decl_stmt|;
comment|/* byte_4 is 64 b */
name|uint64_t
name|byte_5
decl_stmt|;
comment|/* byte_5 is 64 b */
name|uint64_t
name|byte_6
decl_stmt|;
comment|/* byte_6 is 64 b */
name|uint64_t
name|byte_7
decl_stmt|;
comment|/* byte_7 is 64 b */
name|uint64_t
name|byte_8
decl_stmt|;
comment|/* byte_8 is 64 b */
name|uint64_t
name|byte_9
decl_stmt|;
comment|/* byte_9 is 64 b */
name|uint32_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_cfa_vf_pair_alloc */
end_comment

begin_comment
comment|/* Description: VF pair is added to table and resources are allocated. */
end_comment

begin_comment
comment|/* Input (32 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_cfa_vf_pair_alloc_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint16_t
name|vf_a_id
decl_stmt|;
comment|/* Logical VF number (range: 0 -> MAX_VFS -1). */
name|uint16_t
name|vf_b_id
decl_stmt|;
comment|/* Logical VF number (range: 0 -> MAX_VFS -1). */
name|uint32_t
name|unused_0
decl_stmt|;
name|char
name|pair_name
index|[
literal|32
index|]
decl_stmt|;
comment|/* VF Pair name (32 byte string). */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_cfa_vf_pair_alloc_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint32_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_cfa_vf_pair_free */
end_comment

begin_comment
comment|/* Description: VF Pair is removed from table and resources are released. */
end_comment

begin_comment
comment|/* Input (24 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_cfa_vf_pair_free_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|char
name|pair_name
index|[
literal|32
index|]
decl_stmt|;
comment|/* VF Pair name (32 byte string). */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_cfa_vf_pair_free_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint32_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_cfa_vf_pair_info */
end_comment

begin_comment
comment|/* Description: VF pair information is returned. */
end_comment

begin_comment
comment|/* Input (32 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_cfa_vf_pair_info_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint32_t
name|flags
decl_stmt|;
comment|/* If this flag is set, lookup by name else lookup by index. */
define|#
directive|define
name|HWRM_CFA_VF_PAIR_INFO_INPUT_FLAGS_LOOKUP_TYPE
value|UINT32_C(0x1)
name|uint16_t
name|vf_pair_index
decl_stmt|;
comment|/* vf pair table index. */
name|uint8_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|char
name|vf_pair_name
index|[
literal|32
index|]
decl_stmt|;
comment|/* VF Pair name (32 byte string). */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (64 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_cfa_vf_pair_info_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint16_t
name|next_vf_pair_index
decl_stmt|;
comment|/* vf pair table index. */
name|uint16_t
name|vf_a_fid
decl_stmt|;
comment|/* vf pair member a's vf_fid. */
name|uint16_t
name|vf_a_index
decl_stmt|;
comment|/* vf pair member a's Linux logical VF number. */
name|uint16_t
name|vf_b_fid
decl_stmt|;
comment|/* vf pair member b's vf_fid. */
name|uint16_t
name|vf_b_index
decl_stmt|;
comment|/* vf pair member a's Linux logical VF number. */
name|uint8_t
name|pair_state
decl_stmt|;
comment|/* vf pair state. */
comment|/* Pair has been allocated */
define|#
directive|define
name|HWRM_CFA_VF_PAIR_INFO_OUTPUT_PAIR_STATE_ALLOCATED
value|UINT32_C(0x1)
comment|/* Both pair members are active */
define|#
directive|define
name|HWRM_CFA_VF_PAIR_INFO_OUTPUT_PAIR_STATE_ACTIVE
value|UINT32_C(0x2)
name|uint8_t
name|unused_0
decl_stmt|;
name|uint32_t
name|unused_1
decl_stmt|;
name|char
name|pair_name
index|[
literal|32
index|]
decl_stmt|;
comment|/* VF Pair name (32 byte string). */
name|uint32_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint8_t
name|unused_4
decl_stmt|;
name|uint8_t
name|unused_5
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_cfa_vfr_alloc */
end_comment

begin_comment
comment|/* Description: VF-R is added to table and resources are allocated. */
end_comment

begin_comment
comment|/* Input (32 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_cfa_vfr_alloc_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint16_t
name|vf_id
decl_stmt|;
comment|/* Logical VF number (range: 0 -> MAX_VFS -1). */
name|uint16_t
name|reserved
decl_stmt|;
comment|/* This field is reserved for the future use. It shall be set to 0. */
name|uint32_t
name|unused_0
decl_stmt|;
name|char
name|vfr_name
index|[
literal|32
index|]
decl_stmt|;
comment|/* VF Representor name (32 byte string). */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_cfa_vfr_alloc_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint16_t
name|rx_cfa_code
decl_stmt|;
comment|/* Rx CFA code. */
name|uint16_t
name|tx_cfa_action
decl_stmt|;
comment|/* Tx CFA action. */
name|uint8_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_cfa_vfr_free */
end_comment

begin_comment
comment|/* Description: VF-R is removed from table and resources are released. */
end_comment

begin_comment
comment|/* Input (24 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_cfa_vfr_free_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|char
name|vfr_name
index|[
literal|32
index|]
decl_stmt|;
comment|/* VF Representor name (32 byte string). */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_cfa_vfr_free_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint32_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_tunnel_dst_port_query */
end_comment

begin_comment
comment|/*  * Description: This function is called by a driver to query tunnel type  * specific destination port configuration.  */
end_comment

begin_comment
comment|/* Input (24 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_tunnel_dst_port_query_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint8_t
name|tunnel_type
decl_stmt|;
comment|/* Tunnel Type. */
comment|/* Virtual eXtensible Local Area Network (VXLAN) */
define|#
directive|define
name|HWRM_TUNNEL_DST_PORT_QUERY_INPUT_TUNNEL_TYPE_VXLAN
value|UINT32_C(0x1)
comment|/* Generic Network Virtualization Encapsulation (Geneve) */
define|#
directive|define
name|HWRM_TUNNEL_DST_PORT_QUERY_INPUT_TUNNEL_TYPE_GENEVE
value|UINT32_C(0x5)
name|uint8_t
name|unused_0
index|[
literal|7
index|]
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_tunnel_dst_port_query_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint16_t
name|tunnel_dst_port_id
decl_stmt|;
comment|/* 	 * This field represents the identifier of L4 destination port used for 	 * the given tunnel type. This field is valid for specific tunnel types 	 * that use layer 4 (e.g. UDP) transports for tunneling. 	 */
name|uint16_t
name|tunnel_dst_port_val
decl_stmt|;
comment|/* big endian */
comment|/* 	 * This field represents the value of L4 destination port identified by 	 * tunnel_dst_port_id. This field is valid for specific tunnel types 	 * that use layer 4 (e.g. UDP) transports for tunneling. This field is 	 * in network byte order. A value of 0 means that the destination port 	 * is not configured. 	 */
name|uint8_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_tunnel_dst_port_alloc */
end_comment

begin_comment
comment|/*  * Description: This function is called by a driver to allocate l4 destination  * port for a specific tunnel type. The destination port value is provided in  * the input. If the HWRM supports only one global destination port for a tunnel  * type, then the HWRM shall keep track of its usage as described below. # The  * first caller that allocates a destination port shall always succeed and the  * HWRM shall save the destination port configuration for that tunnel type and  * increment the usage count to 1. # Subsequent callers allocating the same  * destination port for that tunnel type shall succeed and the HWRM shall  * increment the usage count for that port for each subsequent caller that  * succeeds. # Any subsequent caller trying to allocate a different destination  * port for that tunnel type shall fail until the usage count for the original  * destination port goes to zero. # A caller that frees a port will cause the  * usage count for that port to decrement.  */
end_comment

begin_comment
comment|/* Input (24 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_tunnel_dst_port_alloc_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint8_t
name|tunnel_type
decl_stmt|;
comment|/* Tunnel Type. */
comment|/* Virtual eXtensible Local Area Network (VXLAN) */
define|#
directive|define
name|HWRM_TUNNEL_DST_PORT_ALLOC_INPUT_TUNNEL_TYPE_VXLAN
value|UINT32_C(0x1)
comment|/* Generic Network Virtualization Encapsulation (Geneve) */
define|#
directive|define
name|HWRM_TUNNEL_DST_PORT_ALLOC_INPUT_TUNNEL_TYPE_GENEVE
value|UINT32_C(0x5)
name|uint8_t
name|unused_0
decl_stmt|;
name|uint16_t
name|tunnel_dst_port_val
decl_stmt|;
comment|/* big endian */
comment|/* 	 * This field represents the value of L4 destination port used for the 	 * given tunnel type. This field is valid for specific tunnel types that 	 * use layer 4 (e.g. UDP) transports for tunneling. This field is in 	 * network byte order. A value of 0 shall fail the command. 	 */
name|uint32_t
name|unused_1
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_tunnel_dst_port_alloc_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint16_t
name|tunnel_dst_port_id
decl_stmt|;
comment|/* 	 * Identifier of a tunnel L4 destination port value. Only applies to 	 * tunnel types that has l4 destination port parameters. 	 */
name|uint8_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint8_t
name|unused_4
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_tunnel_dst_port_free */
end_comment

begin_comment
comment|/*  * Description: This function is called by a driver to free l4 destination port  * for a specific tunnel type.  */
end_comment

begin_comment
comment|/* Input (24 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_tunnel_dst_port_free_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint8_t
name|tunnel_type
decl_stmt|;
comment|/* Tunnel Type. */
comment|/* Virtual eXtensible Local Area Network (VXLAN) */
define|#
directive|define
name|HWRM_TUNNEL_DST_PORT_FREE_INPUT_TUNNEL_TYPE_VXLAN
value|UINT32_C(0x1)
comment|/* Generic Network Virtualization Encapsulation (Geneve) */
define|#
directive|define
name|HWRM_TUNNEL_DST_PORT_FREE_INPUT_TUNNEL_TYPE_GENEVE
value|UINT32_C(0x5)
name|uint8_t
name|unused_0
decl_stmt|;
name|uint16_t
name|tunnel_dst_port_id
decl_stmt|;
comment|/* 	 * Identifier of a tunnel L4 destination port value. Only applies to 	 * tunnel types that has l4 destination port parameters. 	 */
name|uint32_t
name|unused_1
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_tunnel_dst_port_free_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint32_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_stat_ctx_alloc */
end_comment

begin_comment
comment|/*  * Description: This command allocates and does basic preparation for a stat  * context.  */
end_comment

begin_comment
comment|/* Input (32 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_stat_ctx_alloc_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint64_t
name|stats_dma_addr
decl_stmt|;
comment|/* This is the address for statistic block. */
name|uint32_t
name|update_period_ms
decl_stmt|;
comment|/* 	 * The statistic block update period in ms. e.g. 250ms, 500ms, 750ms, 	 * 1000ms. If update_period_ms is 0, then the stats update shall be 	 * never done and the DMA address shall not be used. In this case, the 	 * stat block can only be read by hwrm_stat_ctx_query command. 	 */
name|uint8_t
name|stat_ctx_flags
decl_stmt|;
comment|/* 	 * This field is used to specify statistics context specific 	 * configuration flags. 	 */
comment|/* 	 * When this bit is set to '1', the statistics context shall be 	 * allocated for RoCE traffic only. In this case, traffic other than 	 * offloaded RoCE traffic shall not be included in this statistic 	 * context. When this bit is set to '0', the statistics context shall be 	 * used for the network traffic other than offloaded RoCE traffic. 	 */
define|#
directive|define
name|HWRM_STAT_CTX_ALLOC_INPUT_STAT_CTX_FLAGS_ROCE
value|UINT32_C(0x1)
name|uint8_t
name|unused_0
index|[
literal|3
index|]
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_stat_ctx_alloc_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint32_t
name|stat_ctx_id
decl_stmt|;
comment|/* This is the statistics context ID value. */
name|uint8_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_stat_ctx_free */
end_comment

begin_comment
comment|/* Description: This command is used to free a stat context. */
end_comment

begin_comment
comment|/* Input (24 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_stat_ctx_free_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint32_t
name|stat_ctx_id
decl_stmt|;
comment|/* ID of the statistics context that is being queried. */
name|uint32_t
name|unused_0
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_stat_ctx_free_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint32_t
name|stat_ctx_id
decl_stmt|;
comment|/* This is the statistics context ID value. */
name|uint8_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_stat_ctx_query */
end_comment

begin_comment
comment|/* Description: This command returns statistics of a context. */
end_comment

begin_comment
comment|/* Input (24 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_stat_ctx_query_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint32_t
name|stat_ctx_id
decl_stmt|;
comment|/* ID of the statistics context that is being queried. */
name|uint32_t
name|unused_0
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (176 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_stat_ctx_query_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint64_t
name|tx_ucast_pkts
decl_stmt|;
comment|/* Number of transmitted unicast packets */
name|uint64_t
name|tx_mcast_pkts
decl_stmt|;
comment|/* Number of transmitted multicast packets */
name|uint64_t
name|tx_bcast_pkts
decl_stmt|;
comment|/* Number of transmitted broadcast packets */
name|uint64_t
name|tx_err_pkts
decl_stmt|;
comment|/* Number of transmitted packets with error */
name|uint64_t
name|tx_drop_pkts
decl_stmt|;
comment|/* Number of dropped packets on transmit path */
name|uint64_t
name|tx_ucast_bytes
decl_stmt|;
comment|/* Number of transmitted bytes for unicast traffic */
name|uint64_t
name|tx_mcast_bytes
decl_stmt|;
comment|/* Number of transmitted bytes for multicast traffic */
name|uint64_t
name|tx_bcast_bytes
decl_stmt|;
comment|/* Number of transmitted bytes for broadcast traffic */
name|uint64_t
name|rx_ucast_pkts
decl_stmt|;
comment|/* Number of received unicast packets */
name|uint64_t
name|rx_mcast_pkts
decl_stmt|;
comment|/* Number of received multicast packets */
name|uint64_t
name|rx_bcast_pkts
decl_stmt|;
comment|/* Number of received broadcast packets */
name|uint64_t
name|rx_err_pkts
decl_stmt|;
comment|/* Number of received packets with error */
name|uint64_t
name|rx_drop_pkts
decl_stmt|;
comment|/* Number of dropped packets on received path */
name|uint64_t
name|rx_ucast_bytes
decl_stmt|;
comment|/* Number of received bytes for unicast traffic */
name|uint64_t
name|rx_mcast_bytes
decl_stmt|;
comment|/* Number of received bytes for multicast traffic */
name|uint64_t
name|rx_bcast_bytes
decl_stmt|;
comment|/* Number of received bytes for broadcast traffic */
name|uint64_t
name|rx_agg_pkts
decl_stmt|;
comment|/* Number of aggregated unicast packets */
name|uint64_t
name|rx_agg_bytes
decl_stmt|;
comment|/* Number of aggregated unicast bytes */
name|uint64_t
name|rx_agg_events
decl_stmt|;
comment|/* Number of aggregation events */
name|uint64_t
name|rx_agg_aborts
decl_stmt|;
comment|/* Number of aborted aggregations */
name|uint32_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_stat_ctx_clr_stats */
end_comment

begin_comment
comment|/* Description: This command clears statistics of a context. */
end_comment

begin_comment
comment|/* Input (24 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_stat_ctx_clr_stats_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint32_t
name|stat_ctx_id
decl_stmt|;
comment|/* ID of the statistics context that is being queried. */
name|uint32_t
name|unused_0
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_stat_ctx_clr_stats_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint32_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_fw_reset */
end_comment

begin_comment
comment|/*  * Description: This function is called by a driver to self reset the firmware  * running on the processor indicated by the embedded_proc_type.  */
end_comment

begin_comment
comment|/* Input (24 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_fw_reset_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint8_t
name|embedded_proc_type
decl_stmt|;
comment|/* Type of embedded processor. */
comment|/* Boot Processor */
define|#
directive|define
name|HWRM_FW_RESET_INPUT_EMBEDDED_PROC_TYPE_BOOT
value|UINT32_C(0x0)
comment|/* Management Processor */
define|#
directive|define
name|HWRM_FW_RESET_INPUT_EMBEDDED_PROC_TYPE_MGMT
value|UINT32_C(0x1)
comment|/* Network control processor */
define|#
directive|define
name|HWRM_FW_RESET_INPUT_EMBEDDED_PROC_TYPE_NETCTRL
value|UINT32_C(0x2)
comment|/* RoCE control processor */
define|#
directive|define
name|HWRM_FW_RESET_INPUT_EMBEDDED_PROC_TYPE_ROCE
value|UINT32_C(0x3)
comment|/* 	 * Host (in multi-host environment): This is only valid if 	 * requester is IPC 	 */
define|#
directive|define
name|HWRM_FW_RESET_INPUT_EMBEDDED_PROC_TYPE_HOST
value|UINT32_C(0x4)
name|uint8_t
name|selfrst_status
decl_stmt|;
comment|/* Type of self reset. */
comment|/* No Self Reset */
define|#
directive|define
name|HWRM_FW_RESET_INPUT_SELFRST_STATUS_SELFRSTNONE
value|UINT32_C(0x0)
comment|/* Self Reset as soon as possible to do so safely */
define|#
directive|define
name|HWRM_FW_RESET_INPUT_SELFRST_STATUS_SELFRSTASAP
value|UINT32_C(0x1)
comment|/* Self Reset on PCIe Reset */
define|#
directive|define
name|HWRM_FW_RESET_INPUT_SELFRST_STATUS_SELFRSTPCIERST
value|UINT32_C(0x2)
name|uint8_t
name|host_idx
decl_stmt|;
comment|/* 	 * Indicate which host is being reset. 0 means first host. Only valid 	 * when embedded_proc_type is host in multihost environment 	 */
name|uint8_t
name|unused_0
index|[
literal|5
index|]
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_fw_reset_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint8_t
name|selfrst_status
decl_stmt|;
comment|/* Type of self reset. */
comment|/* No Self Reset */
define|#
directive|define
name|HWRM_FW_RESET_OUTPUT_SELFRST_STATUS_SELFRSTNONE
value|UINT32_C(0x0)
comment|/* Self Reset as soon as possible to do so safely */
define|#
directive|define
name|HWRM_FW_RESET_OUTPUT_SELFRST_STATUS_SELFRSTASAP
value|UINT32_C(0x1)
comment|/* Self Reset on PCIe Reset */
define|#
directive|define
name|HWRM_FW_RESET_OUTPUT_SELFRST_STATUS_SELFRSTPCIERST
value|UINT32_C(0x2)
name|uint8_t
name|unused_0
decl_stmt|;
name|uint16_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint8_t
name|unused_4
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_fw_qstatus */
end_comment

begin_comment
comment|/*  * Description: This function is called by a driver to query the status of the  * firmware running on the processor indicated by the embedded_proc_type.  */
end_comment

begin_comment
comment|/* Input (24 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_fw_qstatus_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint8_t
name|embedded_proc_type
decl_stmt|;
comment|/* Type of embedded processor. */
comment|/* Boot Processor */
define|#
directive|define
name|HWRM_FW_QSTATUS_INPUT_EMBEDDED_PROC_TYPE_BOOT
value|UINT32_C(0x0)
comment|/* Management Processor */
define|#
directive|define
name|HWRM_FW_QSTATUS_INPUT_EMBEDDED_PROC_TYPE_MGMT
value|UINT32_C(0x1)
comment|/* Network control processor */
define|#
directive|define
name|HWRM_FW_QSTATUS_INPUT_EMBEDDED_PROC_TYPE_NETCTRL
value|UINT32_C(0x2)
comment|/* RoCE control processor */
define|#
directive|define
name|HWRM_FW_QSTATUS_INPUT_EMBEDDED_PROC_TYPE_ROCE
value|UINT32_C(0x3)
comment|/* 	 * Host (in multi-host environment): This is only valid if 	 * requester is IPC 	 */
define|#
directive|define
name|HWRM_FW_QSTATUS_INPUT_EMBEDDED_PROC_TYPE_HOST
value|UINT32_C(0x4)
name|uint8_t
name|unused_0
index|[
literal|7
index|]
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_fw_qstatus_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint8_t
name|selfrst_status
decl_stmt|;
comment|/* Type of self reset. */
comment|/* No Self Reset */
define|#
directive|define
name|HWRM_FW_QSTATUS_OUTPUT_SELFRST_STATUS_SELFRSTNONE
value|UINT32_C(0x0)
comment|/* Self Reset as soon as possible to do so safely */
define|#
directive|define
name|HWRM_FW_QSTATUS_OUTPUT_SELFRST_STATUS_SELFRSTASAP
value|UINT32_C(0x1)
comment|/* Self Reset on PCIe Reset */
define|#
directive|define
name|HWRM_FW_QSTATUS_OUTPUT_SELFRST_STATUS_SELFRSTPCIERST
value|UINT32_C(0x2)
name|uint8_t
name|unused_0
decl_stmt|;
name|uint16_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint8_t
name|unused_4
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_fw_set_time */
end_comment

begin_comment
comment|/*  * Description: Inform the HWRM firmware of the current date/time. Ideally, the  * date/time will be current time in GMT/UTC and the zone value will be 0  * (indicating UTC). If the time zone is not known, the zone value shall be  * 0xffff. Other values for zone are discouraged, but if specified, they  * indicate the number of minutes east of UTC, while zones west of UTC are  * represented with a 2's complement negative value (e.g. PST would be -480  * while PDT would be -420).  */
end_comment

begin_comment
comment|/* Input (32 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_fw_set_time_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint16_t
name|year
decl_stmt|;
comment|/* Current year */
comment|/* Date/time is not known */
define|#
directive|define
name|HWRM_FW_SET_TIME_INPUT_YEAR_UNKNOWN
value|UINT32_C(0x0)
name|uint8_t
name|month
decl_stmt|;
comment|/* Current month of year (1-12) */
name|uint8_t
name|day
decl_stmt|;
comment|/* Current day of month (1-31) */
name|uint8_t
name|hour
decl_stmt|;
comment|/* Current hour (0-23) */
name|uint8_t
name|minute
decl_stmt|;
comment|/* Current minute (0-59) */
name|uint8_t
name|second
decl_stmt|;
comment|/* Current second (0-59) */
name|uint8_t
name|unused_0
decl_stmt|;
name|uint16_t
name|millisecond
decl_stmt|;
comment|/* Current millisecond (0-999) */
name|uint16_t
name|zone
decl_stmt|;
comment|/* Minutes east of UTC, 0xffff if TZ is not known */
comment|/* Time zone is Coordinated Universal Time (UTC) */
define|#
directive|define
name|HWRM_FW_SET_TIME_INPUT_ZONE_UTC
value|UINT32_C(0x0)
comment|/* Time zone is not known */
define|#
directive|define
name|HWRM_FW_SET_TIME_INPUT_ZONE_UNKNOWN
value|UINT32_C(0xffff)
name|uint32_t
name|unused_1
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_fw_set_time_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint32_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_fw_get_time */
end_comment

begin_comment
comment|/* Description: Query the HWRM firmware's notion of the current date/time. */
end_comment

begin_comment
comment|/* Input (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_fw_get_time_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (24 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_fw_get_time_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint16_t
name|year
decl_stmt|;
comment|/* Current year */
comment|/* Date/time is not known */
define|#
directive|define
name|HWRM_FW_GET_TIME_OUTPUT_YEAR_UNKNOWN
value|UINT32_C(0x0)
name|uint8_t
name|month
decl_stmt|;
comment|/* Current month of year (1-12) */
name|uint8_t
name|day
decl_stmt|;
comment|/* Current day of month (1-31) */
name|uint8_t
name|hour
decl_stmt|;
comment|/* Current hour (0-23) */
name|uint8_t
name|minute
decl_stmt|;
comment|/* Current minute (0-59) */
name|uint8_t
name|second
decl_stmt|;
comment|/* Current second (0-59) */
name|uint8_t
name|unused_0
decl_stmt|;
name|uint16_t
name|millisecond
decl_stmt|;
comment|/* Current millisecond (0-999) */
name|uint16_t
name|zone
decl_stmt|;
comment|/* Minutes east of UTC, 0xffff if TZ is not known */
comment|/* Time zone is Coordinated Universal Time (UTC) */
define|#
directive|define
name|HWRM_FW_GET_TIME_OUTPUT_ZONE_UTC
value|UINT32_C(0x0)
comment|/* Time zone is not known */
define|#
directive|define
name|HWRM_FW_GET_TIME_OUTPUT_ZONE_UNKNOWN
value|UINT32_C(0xffff)
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_fw_set_structured_data */
end_comment

begin_comment
comment|/*  * Description: There can be a variable number of Structure Data Headers (SDH)  * between offset 0x0 and the 'valid' field to handle customizable return  * values. Each Structure Data Header will include one defined structure. The  * number of returned structures can be 0, in which case the 'valid' field  * starts at offset 0x8. The 'valid' field offset is adjusted based on the  * Structure Data Header length and the length of the structured data it  * contains.  */
end_comment

begin_comment
comment|/* Input (32 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_fw_set_structured_data_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint64_t
name|src_data_addr
decl_stmt|;
comment|/* This is the host address where structured data will be copied from */
name|uint16_t
name|data_len
decl_stmt|;
comment|/* size of data in bytes */
name|uint8_t
name|hdr_cnt
decl_stmt|;
comment|/* 	 * a count of the number of Structured Data Headers in the data pointed 	 * by src_data_addr. 	 */
name|uint8_t
name|unused_0
index|[
literal|5
index|]
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_fw_set_structured_data_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint32_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Command specific Error Codes (8 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_fw_set_structured_data_cmd_err
block|{
name|uint8_t
name|code
decl_stmt|;
comment|/* 	 * command specific error codes that goes to the cmd_err field in Common 	 * HWRM Error Response. 	 */
comment|/* Unknown error */
define|#
directive|define
name|HWRM_FW_SET_STRUCTURED_DATA_CMD_ERR_CODE_UNKNOWN
value|UINT32_C(0x0)
comment|/* count_of_headers is incorrect */
define|#
directive|define
name|HWRM_FW_SET_STRUCTURED_DATA_CMD_ERR_CODE_BAD_HDR_CNT
value|UINT32_C(0x1)
comment|/* data improperly formatted */
define|#
directive|define
name|HWRM_FW_SET_STRUCTURED_DATA_CMD_ERR_CODE_BAD_FMT
value|UINT32_C(0x2)
comment|/* unknown structure ID(s) */
define|#
directive|define
name|HWRM_FW_SET_STRUCTURED_DATA_CMD_ERR_CODE_BAD_ID
value|UINT32_C(0x3)
name|uint8_t
name|unused_0
index|[
literal|7
index|]
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_fw_get_structured_data */
end_comment

begin_comment
comment|/* Input (32 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_fw_get_structured_data_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint64_t
name|dest_data_addr
decl_stmt|;
comment|/* This is the host address where structured data will be copied to */
name|uint16_t
name|data_len
decl_stmt|;
comment|/* size of data in bytes */
name|uint16_t
name|structure_id
decl_stmt|;
comment|/* 	 * Structure_id is the id of the structure data requesting and count is 	 * a requested number of instances of this data requested. The actual 	 * number will be returned in count_of_headers 	 */
name|uint16_t
name|subtype
decl_stmt|;
comment|/* 	 * Subtype is an optional field used to specify additional information 	 * of the data being retrieved. For example, if data can be categorized 	 * as "live" vs "saved" then this field can be used to provide an 	 * indication of "saved" vs "live" data. Not all structured data 	 * supports subtypes and if they are supported then the structured data 	 * will specify the valid values. If structured data is requested that 	 * supports subtypes but no subtype is given then it is implementation 	 * specific what will be returned. Some structure data can support a 	 * subtype of "All" which would cause a list of structures to be 	 * returned for all supported subtypes. "All" is only used on the 	 * hwrm_get_structured_data command. 	 */
define|#
directive|define
name|HWRM_FW_GET_STRUCTURED_DATA_INPUT_SUBTYPE_ALL
value|UINT32_C(0xffff)
define|#
directive|define
name|HWRM_FW_GET_STRUCTURED_DATA_INPUT_SUBTYPE_NEAR_BRIDGE_ADMIN
value|UINT32_C(0x100)
define|#
directive|define
name|HWRM_FW_GET_STRUCTURED_DATA_INPUT_SUBTYPE_NEAR_BRIDGE_PEER
value|UINT32_C(0x101)
define|#
directive|define
name|HWRM_FW_GET_STRUCTURED_DATA_INPUT_SUBTYPE_NEAR_BRIDGE_OPERATIONAL
value|UINT32_C(0x102)
define|#
directive|define
name|HWRM_FW_GET_STRUCTURED_DATA_INPUT_SUBTYPE_NON_TPMR_ADMIN
value|UINT32_C(0x200)
define|#
directive|define
name|HWRM_FW_GET_STRUCTURED_DATA_INPUT_SUBTYPE_NON_TPMR_PEER
value|UINT32_C(0x201)
define|#
directive|define
name|HWRM_FW_GET_STRUCTURED_DATA_INPUT_SUBTYPE_NON_TPMR_OPERATIONAL
value|UINT32_C(0x202)
define|#
directive|define
name|HWRM_FW_GET_STRUCTURED_DATA_INPUT_SUBTYPE_HOST_OPERATIONAL
value|UINT32_C(0x300)
name|uint8_t
name|count
decl_stmt|;
comment|/* Number of elements. This allows support of arrayed data */
name|uint8_t
name|unused_0
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_fw_get_structured_data_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint8_t
name|hdr_cnt
decl_stmt|;
comment|/* 	 * a count of the number of Structured Data Headers in the data pointed 	 * by dest_data_addr. 	 */
name|uint8_t
name|unused_0
decl_stmt|;
name|uint16_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint8_t
name|unused_4
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Command specific Error Codes (8 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_fw_get_structured_data_cmd_err
block|{
name|uint8_t
name|code
decl_stmt|;
comment|/* 	 * command specific error codes that goes to the cmd_err field in Common 	 * HWRM Error Response. 	 */
comment|/* Unknown error */
define|#
directive|define
name|HWRM_FW_GET_STRUCTURED_DATA_CMD_ERR_CODE_UNKNOWN
value|UINT32_C(0x0)
comment|/* unknown structure ID(s) */
define|#
directive|define
name|HWRM_FW_GET_STRUCTURED_DATA_CMD_ERR_CODE_BAD_ID
value|UINT32_C(0x3)
name|uint8_t
name|unused_0
index|[
literal|7
index|]
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_fw_ipc_mailbox */
end_comment

begin_comment
comment|/* Input (32 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_fw_ipc_mailbox_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint8_t
name|flags
decl_stmt|;
name|uint8_t
name|unused_0
decl_stmt|;
comment|/* unused is 8 b */
name|uint8_t
name|event_id
decl_stmt|;
comment|/* asynchronous event to hosts. */
name|uint8_t
name|port_id
decl_stmt|;
comment|/* PORT ID */
name|uint32_t
name|event_data1
decl_stmt|;
comment|/* event data1 of asynchronous event */
name|uint32_t
name|event_data2
decl_stmt|;
comment|/* event data2 of asynchronous event */
name|uint32_t
name|unused_1
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_fw_ipc_mailbox_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint32_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Command specific Error Codes (8 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_fw_ipc_mailbox_cmd_err
block|{
name|uint8_t
name|code
decl_stmt|;
comment|/* 	 * command specific error codes that goes to the cmd_err field in Common 	 * HWRM Error Response. 	 */
comment|/* Unknown error */
define|#
directive|define
name|HWRM_FW_IPC_MAILBOX_CMD_ERR_CODE_UNKNOWN
value|UINT32_C(0x0)
comment|/* invalid event */
define|#
directive|define
name|HWRM_FW_IPC_MAILBOX_CMD_ERR_CODE_BAD_ID
value|UINT32_C(0x3)
name|uint8_t
name|unused_0
index|[
literal|7
index|]
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_exec_fwd_resp */
end_comment

begin_comment
comment|/*  * Description: This command is used to send an encapsulated request to the  * HWRM. This command instructs the HWRM to execute the request and forward the  * response of the encapsulated request to the location specified in the  * original request that is encapsulated. The target id of this command shall be  * set to 0xFFFF (HWRM). The response location in this command shall be used to  * acknowledge the receipt of the encapsulated request and forwarding of the  * response.  */
end_comment

begin_comment
comment|/* Input (128 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_exec_fwd_resp_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint32_t
name|encap_request
index|[
literal|26
index|]
decl_stmt|;
comment|/* 	 * This is an encapsulated request. This request should be executed by 	 * the HWRM and the response should be provided in the response buffer 	 * inside the encapsulated request. 	 */
name|uint16_t
name|encap_resp_target_id
decl_stmt|;
comment|/* 	 * This value indicates the target id of the response to the 	 * encapsulated request. 0x0 - 0xFFF8 - Used for function ids 0xFFF8 - 	 * 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint16_t
name|unused_0
index|[
literal|3
index|]
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_exec_fwd_resp_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint32_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_reject_fwd_resp */
end_comment

begin_comment
comment|/*  * Description: This command is used to send an encapsulated request to the  * HWRM. This command instructs the HWRM to reject the request and forward the  * error response of the encapsulated request to the location specified in the  * original request that is encapsulated. The target id of this command shall be  * set to 0xFFFF (HWRM). The response location in this command shall be used to  * acknowledge the receipt of the encapsulated request and forwarding of the  * response.  */
end_comment

begin_comment
comment|/* Input (128 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_reject_fwd_resp_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint32_t
name|encap_request
index|[
literal|26
index|]
decl_stmt|;
comment|/* 	 * This is an encapsulated request. This request should be rejected by 	 * the HWRM and the error response should be provided in the response 	 * buffer inside the encapsulated request. 	 */
name|uint16_t
name|encap_resp_target_id
decl_stmt|;
comment|/* 	 * This value indicates the target id of the response to the 	 * encapsulated request. 0x0 - 0xFFF8 - Used for function ids 0xFFF8 - 	 * 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint16_t
name|unused_0
index|[
literal|3
index|]
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_reject_fwd_resp_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint32_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_fwd_resp */
end_comment

begin_comment
comment|/*  * Description: This command is used to send an encapsulated response to the  * HWRM. The HWRM shall forward this response based on the target id. The  * response address provided in this command shall be used to acknowledge the  * receipt of the encapsulated response. The encapsulated response address  * provided in this command shall be used to provide the encapsulated response.  */
end_comment

begin_comment
comment|/* Input (40 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_fwd_resp_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint16_t
name|encap_resp_target_id
decl_stmt|;
comment|/* 	 * This value indicates the target id of the encapsulated response. 0x0 	 * - 0xFFF8 - Used for function ids 0xFFF8 - 0xFFFE - Reserved for 	 * internal processors 0xFFFF - HWRM 	 */
name|uint16_t
name|encap_resp_cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the completion ring the encapsulated response 	 * will be optionally completed on. If the value is -1, then no CR 	 * completion shall be generated for the encapsulated response. Any 	 * other value must be a valid CR ring_id value. If a valid 	 * encap_resp_cmpl_ring is provided, then a CR completion shall be 	 * generated for the encapsulated response. 	 */
name|uint16_t
name|encap_resp_len
decl_stmt|;
comment|/* This field indicates the length of encapsulated response. */
name|uint8_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint64_t
name|encap_resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the encapsulated response will be 	 * written. This area must be 16B aligned and must be cleared to zero 	 * before the original request is made. 	 */
name|uint32_t
name|encap_resp
index|[
literal|24
index|]
decl_stmt|;
comment|/* This is an encapsulated response. */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_fwd_resp_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint32_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_fwd_async_event_cmpl */
end_comment

begin_comment
comment|/*  * Description: This command is used to send an encapsulated asynchronous event  * completion to the HWRM. The HWRM shall forward this asynchronous event  * completion to target(s) specified in the command. The HWRM shall complete  * this command only after forwarding asynchronous event completion to specified  * targets.  */
end_comment

begin_comment
comment|/* Input (32 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_fwd_async_event_cmpl_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint16_t
name|encap_async_event_target_id
decl_stmt|;
comment|/* 	 * This value indicates the target id of the encapsulated asynchronous 	 * event. 0x0 - 0xFFF8 - Used for function ids 0xFFF8 - 0xFFFE - 	 * Reserved for internal processors 0xFFFF - Broadcast to all children 	 * VFs (only applicable when a PF is the requester) 	 */
name|uint8_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
index|[
literal|3
index|]
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint32_t
name|encap_async_event_cmpl
index|[
literal|4
index|]
decl_stmt|;
comment|/* This is an encapsulated asynchronous event completion. */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_fwd_async_event_cmpl_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint32_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_temp_monitor_query */
end_comment

begin_comment
comment|/*  * Description: A temperature monitor is used to query the device temperature.  */
end_comment

begin_comment
comment|/* Input (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_temp_monitor_query_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_temp_monitor_query_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint8_t
name|temp
decl_stmt|;
comment|/* The HWRM shall provide the current temperature of device in Celsius. */
name|uint8_t
name|unused_0
decl_stmt|;
name|uint16_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint8_t
name|unused_4
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_wol_filter_alloc */
end_comment

begin_comment
comment|/*  * Description: A Wake-On-LAN (WoL) filter is a filter resource that is used to  * identify a WoL packet. # Among all function drivers, the HWRM shall only  * allow PF drivers to allocate WoL filters. # The HWRM shall not allow VF  * drivers to allocate any WoL filters. # When partitioning is enabled and WoL  * is supported, the HWRM shall support at least one WoL filter per partition. #  * The HWRM shall retain a WoL filter setting until the filter is freed. # If  * the HWRM client is a function driver, then the HWRM shall not allow the HWRM  * client to set up WoL filters on the port that the function is not associated  * with. # If the HWRM client is one of the trusted embedded services (e.g.  * management service), the the HWRM shall allow the HWRM client to set up WoL  * filters on any port of the device.  */
end_comment

begin_comment
comment|/* Input (64 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_wol_filter_alloc_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint32_t
name|flags
decl_stmt|;
name|uint32_t
name|enables
decl_stmt|;
comment|/* This bit must be '1' for the mac_address field to be configured. */
define|#
directive|define
name|HWRM_WOL_FILTER_ALLOC_INPUT_ENABLES_MAC_ADDRESS
value|UINT32_C(0x1)
comment|/* This bit must be '1' for the pattern_offset field to be configured. */
define|#
directive|define
name|HWRM_WOL_FILTER_ALLOC_INPUT_ENABLES_PATTERN_OFFSET
value|UINT32_C(0x2)
comment|/* This bit must be '1' for the pattern_buf_size field to be configured. */
define|#
directive|define
name|HWRM_WOL_FILTER_ALLOC_INPUT_ENABLES_PATTERN_BUF_SIZE
value|UINT32_C(0x4)
comment|/* This bit must be '1' for the pattern_buf_addr field to be configured. */
define|#
directive|define
name|HWRM_WOL_FILTER_ALLOC_INPUT_ENABLES_PATTERN_BUF_ADDR
value|UINT32_C(0x8)
comment|/* 	 * This bit must be '1' for the pattern_mask_addr field to be 	 * configured. 	 */
define|#
directive|define
name|HWRM_WOL_FILTER_ALLOC_INPUT_ENABLES_PATTERN_MASK_ADDR
value|UINT32_C(0x10)
comment|/* 	 * This bit must be '1' for the pattern_mask_size field to be 	 * configured. 	 */
define|#
directive|define
name|HWRM_WOL_FILTER_ALLOC_INPUT_ENABLES_PATTERN_MASK_SIZE
value|UINT32_C(0x20)
name|uint16_t
name|port_id
decl_stmt|;
comment|/* Port ID of port on which WoL filter is configured. */
name|uint8_t
name|wol_type
decl_stmt|;
comment|/* This value represents a Wake-on-LAN type. */
comment|/* Magic Paket */
define|#
directive|define
name|HWRM_WOL_FILTER_ALLOC_INPUT_WOL_TYPE_MAGICPKT
value|UINT32_C(0x0)
comment|/* Bitmap */
define|#
directive|define
name|HWRM_WOL_FILTER_ALLOC_INPUT_WOL_TYPE_BMP
value|UINT32_C(0x1)
comment|/* Invalid */
define|#
directive|define
name|HWRM_WOL_FILTER_ALLOC_INPUT_WOL_TYPE_INVALID
value|UINT32_C(0xff)
name|uint8_t
name|unused_0
decl_stmt|;
name|uint32_t
name|unused_1
decl_stmt|;
name|uint8_t
name|mac_address
index|[
literal|6
index|]
decl_stmt|;
comment|/* 	 * # If this field is enabled and magic packet WoL filter type is 	 * specified in this command, the value set in this field shall be used 	 * in setting the magic packet based WoL filter. # If this field is not 	 * enabled and magic packet WoL filter type is specified and port id is 	 * specified to 0xFF in this command, then the HWRM shall use default 	 * MAC address configured on the function associated with the HWRM 	 * client. # If this field is not enabled and magic packet WoL filter 	 * type is specified and port id is not specified to 0xFF in this 	 * command, then the HWRM shall use default MAC address configured on 	 * the port. 	 */
name|uint16_t
name|pattern_offset
decl_stmt|;
comment|/* 	 * The offset from the beginning of MAC header where pattern should be 	 * matched. Applies to bitmap WoL. 	 */
name|uint16_t
name|pattern_buf_size
decl_stmt|;
comment|/* The size of the pattern that is being matched. Applies to bitmap WoL. */
name|uint16_t
name|pattern_mask_size
decl_stmt|;
comment|/* The size of the pattern mask. Applies to bitmap WoL. */
name|uint32_t
name|unused_2
decl_stmt|;
name|uint64_t
name|pattern_buf_addr
decl_stmt|;
comment|/* Physical address of the pattern buffer. Applies to bitmap WoL. */
name|uint64_t
name|pattern_mask_addr
decl_stmt|;
comment|/* Physical address of the pattern mask. Applies to bitmap WoL. */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_wol_filter_alloc_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint8_t
name|wol_filter_id
decl_stmt|;
comment|/* This value identifies a Wake-on-LAN (WoL) filter. */
name|uint8_t
name|unused_0
decl_stmt|;
name|uint16_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint8_t
name|unused_4
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_wol_filter_free */
end_comment

begin_comment
comment|/*  * Description: Free a WoL filter. # Among all function drivers, the HWRM shall  * only allow PF drivers to free WoL filters. # The HWRM shall not allow VF  * drivers to free any WoL filters. # The HWRM shall not allow a function driver  * to free an Out-Of-Box WoL filter. # The HWRM shall not allow a function  * driver to free a WoL filter on a port that the corresponding function is not  * associated with. # The HWRM shall not allow a function driver to free a WoL  * filter on a function that the function driver is not associated with.  */
end_comment

begin_comment
comment|/* Input (32 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_wol_filter_free_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint32_t
name|flags
decl_stmt|;
comment|/* 	 * # When this bit is set to '1', then all active WoL filters on the 	 * port are requested to be freed. # If the a function driver sets this 	 * flag to '1', then the HWRM shall free all active WoL filters that are 	 * not set by other function drivers on that port. 	 */
define|#
directive|define
name|HWRM_WOL_FILTER_FREE_INPUT_FLAGS_FREE_ALL_WOL_FILTERS
value|UINT32_C(0x1)
name|uint32_t
name|enables
decl_stmt|;
comment|/* This bit must be '1' for the wol_filter_id field to be configured. */
define|#
directive|define
name|HWRM_WOL_FILTER_FREE_INPUT_ENABLES_WOL_FILTER_ID
value|UINT32_C(0x1)
name|uint16_t
name|port_id
decl_stmt|;
comment|/* Port ID of the port on which WoL filter(s) is (are) being freed. */
name|uint8_t
name|wol_filter_id
decl_stmt|;
comment|/* The HWRM shall ignore this field if free_all_wol_filters flag is set. */
name|uint8_t
name|unused_0
index|[
literal|5
index|]
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_wol_filter_free_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint32_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_wol_filter_qcfg */
end_comment

begin_comment
comment|/*  * Description: Query WoL filter configuration. # Among all function drivers,  * the HWRM shall only allow PF drivers to query WoL filters. # The HWRM shall  * not allow VF drivers to query any WoL filters. # The HWRM shall return WoL  * filters that are active on the associated port for which this query is being  * performed. # If the HWRM client is a function driver, then the HWRM shall not  * allow the HWRM client to query WoL filters that are set up by other function  * drivers. # If the HWRM client is a function driver, then the HWRM shall not  * allow the HWRM client to query WoL filters on the port that the function is  * not associated with. # If the HWRM client is one of the trusted embedded  * service (e.g. management service), the the HWRM shall allow the HWRM client  * to query WoL filters on any port of the device.  */
end_comment

begin_comment
comment|/* Input (56 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_wol_filter_qcfg_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint16_t
name|port_id
decl_stmt|;
comment|/* Port ID of port on which WoL filter that is being queried. */
name|uint16_t
name|handle
decl_stmt|;
comment|/* 	 * This is an opaque handle used to access filters. # The HWRM client 	 * shall set this field to 0x0000 to begin the query. # After the first 	 * query, the HWRM client shall retrieve next filters (if they exist) 	 * using the HWRM provided handle in the response. 	 */
name|uint32_t
name|unused_0
decl_stmt|;
name|uint64_t
name|pattern_buf_addr
decl_stmt|;
comment|/* 	 * Physical address of the pattern buffer. Applies to bitmap WoL filter 	 * only. # Value of 0 indicates an invalid buffer address. If this field 	 * is set to 0, then HWRM shall ignore pattern_buf_size. # If the HWRM 	 * client provides an invalid buffer address for the pattern, then the 	 * HWRM is not required to provide pattern when the response contains a 	 * bitmap WoL filter. 	 */
name|uint16_t
name|pattern_buf_size
decl_stmt|;
comment|/* The size of the pattern buffer. Applies to bitmap WoL filter only. */
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
index|[
literal|3
index|]
decl_stmt|;
name|uint8_t
name|unused_4
decl_stmt|;
name|uint64_t
name|pattern_mask_addr
decl_stmt|;
comment|/* 	 * Physical address of the pattern mask. Applies to bitmap WoL filter 	 * only. # Value of 0 indicates an invalid pattern mask address. If this 	 * field is set to 0, then HWRM shall ignore pattern_mask_size. # If the 	 * HWRM client provides an invalid mask address for the pattern, then 	 * the HWRM is not required to provide mask when the response contains a 	 * bitmap WoL filter. 	 */
name|uint16_t
name|pattern_mask_size
decl_stmt|;
comment|/* 	 * The size of the buffer for pattern mask. Applies to bitmap WoL filter 	 * only. 	 */
name|uint16_t
name|unused_5
index|[
literal|3
index|]
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (32 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_wol_filter_qcfg_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint16_t
name|next_handle
decl_stmt|;
comment|/* 	 * This is the next handle that is used to access filters. # If this 	 * field is set to 0x0000, then no WoL filters are currently configured 	 * on this port and all other fields in the output shall be ignored by 	 * the HWRM client. # If this field is set to neither 0x0000 nor 0xFFFF, 	 * then the wol_filter_id is valid and the parameters provided in the 	 * response are based on the wol_type. # If this field is set to 0xFFFF, 	 * then there are no remaining configured WoL filters to be queried for 	 * the queried function after this response, wol_filter_id is valid and 	 * the parameters provided in the response are based on the wol_type. 	 */
name|uint8_t
name|wol_filter_id
decl_stmt|;
comment|/* This value identifies the filter returned in this response. */
name|uint8_t
name|wol_type
decl_stmt|;
comment|/* 	 * This value identifies the type of WoL filter returned in this 	 * response. 	 */
comment|/* Magic Paket */
define|#
directive|define
name|HWRM_WOL_FILTER_QCFG_OUTPUT_WOL_TYPE_MAGICPKT
value|UINT32_C(0x0)
comment|/* Bitmap */
define|#
directive|define
name|HWRM_WOL_FILTER_QCFG_OUTPUT_WOL_TYPE_BMP
value|UINT32_C(0x1)
comment|/* Invalid */
define|#
directive|define
name|HWRM_WOL_FILTER_QCFG_OUTPUT_WOL_TYPE_INVALID
value|UINT32_C(0xff)
name|uint32_t
name|unused_0
decl_stmt|;
name|uint8_t
name|mac_address
index|[
literal|6
index|]
decl_stmt|;
comment|/* 	 * The MAC address value used by the WoL filter. Applies to magic packet 	 * based WoL. 	 */
name|uint16_t
name|pattern_offset
decl_stmt|;
comment|/* 	 * The offset from the beginning of MAC header where pattern should be 	 * matched. Applies to bitmap WoL. 	 */
name|uint16_t
name|pattern_size
decl_stmt|;
comment|/* 	 * The actual size of the pattern that is being returned. Applies to 	 * bitmap WoL. 	 */
name|uint16_t
name|pattern_mask_size
decl_stmt|;
comment|/* 	 * The actual size of the pattern mask that is being returned. Applies 	 * to bitmap WoL. 	 */
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_wol_reason_qcfg */
end_comment

begin_comment
comment|/* Description: Query WoL reason for the last system wake up. */
end_comment

begin_comment
comment|/* Input (40 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_wol_reason_qcfg_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint16_t
name|port_id
decl_stmt|;
comment|/* Port ID of port for which this query is for. */
name|uint8_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
index|[
literal|3
index|]
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint64_t
name|wol_pkt_buf_addr
decl_stmt|;
comment|/* Physical address of the packet buffer for querying WoL packet. */
name|uint16_t
name|wol_pkt_buf_size
decl_stmt|;
comment|/* The size of the buffer for the WoL packet. */
name|uint16_t
name|unused_4
index|[
literal|3
index|]
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_wol_reason_qcfg_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint8_t
name|wol_filter_id
decl_stmt|;
comment|/* 	 * This value identifies the filter that matched the last WoL packet. 	 * This id is only valid with valid WoL reason. 	 */
name|uint8_t
name|wol_reason
decl_stmt|;
comment|/* 	 * This value identifies the type of WoL reason returned in this 	 * response. When the wol_type is set to invalid, then there is no WoL 	 * event that happened during last system wake-up. 	 */
comment|/* Magic Paket */
define|#
directive|define
name|HWRM_WOL_REASON_QCFG_OUTPUT_WOL_REASON_MAGICPKT
value|UINT32_C(0x0)
comment|/* Bitmap */
define|#
directive|define
name|HWRM_WOL_REASON_QCFG_OUTPUT_WOL_REASON_BMP
value|UINT32_C(0x1)
comment|/* Invalid */
define|#
directive|define
name|HWRM_WOL_REASON_QCFG_OUTPUT_WOL_REASON_INVALID
value|UINT32_C(0xff)
name|uint8_t
name|wol_pkt_len
decl_stmt|;
comment|/* The value identifies the length of the WoL packet in bytes. */
name|uint8_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_dbg_dump */
end_comment

begin_comment
comment|/*  * Description: This command is used by to initiate the dump of debug  * information to a driver specified address.  */
end_comment

begin_comment
comment|/* Input (40 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_dbg_dump_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint32_t
name|handle
decl_stmt|;
comment|/* 	 * Handle used to dump debug data. handle = 0 indicates the beginning of 	 * the dump. handle != 0 indicates the request to dump the next part. 	 */
name|uint32_t
name|unused_0
decl_stmt|;
name|uint64_t
name|host_dbg_dump_addr
decl_stmt|;
comment|/* 	 * Address of the host buffer where the debug data is requested to be 	 * dumped. 	 */
name|uint64_t
name|host_dbg_dump_addr_len
decl_stmt|;
comment|/* Length of host buffer used for transferring debug data. */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (24 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_dbg_dump_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint32_t
name|nexthandle
decl_stmt|;
comment|/* 	 * Handle used to indicate availability of additional debug data. 	 * nexthandle = 0 indicates that there is no more debug data available. 	 * nexthandle != 0 indicates the handle value that should be used to 	 * request the next part of debug data. 	 */
name|uint32_t
name|dbg_data_len
decl_stmt|;
comment|/* The number of bytes of debug data written to debug dump buffer. */
name|uint32_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_nvm_raw_write_blk */
end_comment

begin_comment
comment|/*  * Note: Write an unmanaged block of data at any physical offset within the  * NVRAM. Used for initial provisioning/manufacturing purposes only. Implemented  * in the ChiMP boot-strap firmware (fwutil.bin) only.  */
end_comment

begin_comment
comment|/* Input (32 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_nvm_raw_write_blk_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint64_t
name|host_src_addr
decl_stmt|;
comment|/* 	 * 64-bit Host Source Address. This is the loation of the source data to 	 * be written. 	 */
name|uint32_t
name|dest_addr
decl_stmt|;
comment|/* 	 * 32-bit Destination Address. This is the NVRAM byte-offset where the 	 * source data will be written to. 	 */
name|uint32_t
name|len
decl_stmt|;
comment|/* Length of data to be written, in bytes. */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_nvm_raw_write_blk_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint32_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_nvm_read */
end_comment

begin_comment
comment|/*  * Note: Read the contents of an NVRAM item as referenced (indexed) by an  * existing directory entry.  */
end_comment

begin_comment
comment|/* Input (40 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_nvm_read_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint64_t
name|host_dest_addr
decl_stmt|;
comment|/* 	 * 64-bit Host Destination Address. This is the host address where the 	 * data will be written to. 	 */
name|uint16_t
name|dir_idx
decl_stmt|;
comment|/* The 0-based index of the directory entry. */
name|uint8_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint32_t
name|offset
decl_stmt|;
comment|/* The NVRAM byte-offset to read from. */
name|uint32_t
name|len
decl_stmt|;
comment|/* The length of the data to be read, in bytes. */
name|uint32_t
name|unused_2
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_nvm_read_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint32_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_nvm_raw_dump */
end_comment

begin_comment
comment|/* Note: Dump a raw block of data from NVRAM. */
end_comment

begin_comment
comment|/* Input (32 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_nvm_raw_dump_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint64_t
name|host_dest_addr
decl_stmt|;
comment|/* 	 * 64-bit Host Destination Address. This is the host address where the 	 * data will be written to. 	 */
name|uint32_t
name|offset
decl_stmt|;
comment|/* 32-bit NVRAM byte-offset to read from. */
name|uint32_t
name|len
decl_stmt|;
comment|/* Total length of NVRAM contents to be read, in bytes. */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_nvm_raw_dump_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint32_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_nvm_get_dir_entries */
end_comment

begin_comment
comment|/*  * Description: Read the NVRAM directory. Each directory entry is at least 24  * bytes in length and contains the: - 16-bit directory entry type  * (BNX_DIR_TYPE_* value) - 16-bit ordinal (instance of this directory entry  * type) - 16-bit extension flags (identifies inactive entries and entries for  * firmware update) - 16-bit attribute flags (identifies entries with a  * purposely invalid chksum value) - 32-bit byte-offset into NVRAM where this  * item data is located - 32-bit length of allocated NVRAM for item, in bytes  * (multiple of block size) - 32-bit length of data (excluding padding), in  * bytes (may be 0) - 32-bit data checksum (CRC-32) See the  * bnxnvm_directory_entry_t definition in the file bnxnvm_defs.h.  */
end_comment

begin_comment
comment|/* Input (24 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_nvm_get_dir_entries_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint64_t
name|host_dest_addr
decl_stmt|;
comment|/* 	 * 64-bit Host Destination Address. This is the host address where the 	 * directory will be written. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_nvm_get_dir_entries_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint32_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_nvm_get_dir_info */
end_comment

begin_comment
comment|/* Note: Get Directory Header info. */
end_comment

begin_comment
comment|/* Input (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_nvm_get_dir_info_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (24 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_nvm_get_dir_info_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint32_t
name|entries
decl_stmt|;
comment|/* Number of directory entries in the directory. */
name|uint32_t
name|entry_length
decl_stmt|;
comment|/* Size of each directory entry, in bytes. */
name|uint32_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_nvm_write */
end_comment

begin_comment
comment|/*  * Note: Write to the allocated NVRAM of an item referenced by an existing  * directory entry.  */
end_comment

begin_comment
comment|/* Input (48 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_nvm_write_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint64_t
name|host_src_addr
decl_stmt|;
comment|/* 64-bit Host Source Address. This is where the source data is. */
name|uint16_t
name|dir_type
decl_stmt|;
comment|/* 	 * The Directory Entry Type (valid values are defined in the 	 * bnxnvm_directory_type enum defined in the file bnxnvm_defs.h). 	 */
name|uint16_t
name|dir_ordinal
decl_stmt|;
comment|/* 	 * Directory ordinal. The 0-based instance of the combined Directory 	 * Entry Type and Extension. 	 */
name|uint16_t
name|dir_ext
decl_stmt|;
comment|/* 	 * The Directory Entry Extension flags (see BNX_DIR_EXT_* in the file 	 * bnxnvm_defs.h). 	 */
name|uint16_t
name|dir_attr
decl_stmt|;
comment|/* 	 * Directory Entry Attribute flags (see BNX_DIR_ATTR_* in the file 	 * bnxnvm_defs.h). 	 */
name|uint32_t
name|dir_data_length
decl_stmt|;
comment|/* 	 * Length of data to write, in bytes. May be less than or equal to the 	 * allocated size for the directory entry. The data length stored in the 	 * directory entry will be updated to reflect this value once the write 	 * is complete. 	 */
name|uint16_t
name|option
decl_stmt|;
comment|/* Option. */
name|uint16_t
name|flags
decl_stmt|;
comment|/* 	 * When this bit is '1', the original active image will not be removed. 	 * TBD: what purpose is this? 	 */
define|#
directive|define
name|HWRM_NVM_WRITE_INPUT_FLAGS_KEEP_ORIG_ACTIVE_IMG
value|UINT32_C(0x1)
name|uint32_t
name|dir_item_length
decl_stmt|;
comment|/* 	 * The requested length of the allocated NVM for the item, in bytes. 	 * This value may be greater than or equal to the specified data length 	 * (dir_data_length). If this value is less than the specified data 	 * length, it will be ignored. The response will contain the actual 	 * allocated item length, which may be greater than the requested item 	 * length. The purpose for allocating more than the required number of 	 * bytes for an item's data is to pre-allocate extra storage (padding) 	 * to accomodate the potential future growth of an item (e.g. upgraded 	 * firmware with a size increase, log growth, expanded configuration 	 * data). 	 */
name|uint32_t
name|unused_0
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_nvm_write_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint32_t
name|dir_item_length
decl_stmt|;
comment|/* 	 * Length of the allocated NVM for the item, in bytes. The value may be 	 * greater than or equal to the specified data length or the requested 	 * item length. The actual item length used when creating a new 	 * directory entry will be a multiple of an NVM block size. 	 */
name|uint16_t
name|dir_idx
decl_stmt|;
comment|/* The directory index of the created or modified item. */
name|uint8_t
name|unused_0
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Command specific Error Codes (8 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_nvm_write_cmd_err
block|{
name|uint8_t
name|code
decl_stmt|;
comment|/* 	 * command specific error codes that goes to the cmd_err field in Common 	 * HWRM Error Response. 	 */
comment|/* Unknown error */
define|#
directive|define
name|HWRM_NVM_WRITE_CMD_ERR_CODE_UNKNOWN
value|UINT32_C(0x0)
comment|/* Unable to complete operation due to fragmentation */
define|#
directive|define
name|HWRM_NVM_WRITE_CMD_ERR_CODE_FRAG_ERR
value|UINT32_C(0x1)
comment|/* nvm is completely full. */
define|#
directive|define
name|HWRM_NVM_WRITE_CMD_ERR_CODE_NO_SPACE
value|UINT32_C(0x2)
name|uint8_t
name|unused_0
index|[
literal|7
index|]
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_nvm_modify */
end_comment

begin_comment
comment|/*  * Note: Modify the contents of an NVRAM item as referenced (indexed) by an  * existing directory entry.  */
end_comment

begin_comment
comment|/* Input (40 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_nvm_modify_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint64_t
name|host_src_addr
decl_stmt|;
comment|/* 64-bit Host Source Address. This is where the modified data is. */
name|uint16_t
name|dir_idx
decl_stmt|;
comment|/* 16-bit directory entry index. */
name|uint8_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint32_t
name|offset
decl_stmt|;
comment|/* 32-bit NVRAM byte-offset to modify content from. */
name|uint32_t
name|len
decl_stmt|;
comment|/* 	 * Length of data to be modified, in bytes. The length shall be non- 	 * zero. 	 */
name|uint32_t
name|unused_2
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_nvm_modify_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint32_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_nvm_find_dir_entry */
end_comment

begin_comment
comment|/*  * Note: Search a directory entry in the directory by either directory entry  * index or directory entry parameters.  */
end_comment

begin_comment
comment|/* Input (32 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_nvm_find_dir_entry_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint32_t
name|enables
decl_stmt|;
comment|/* This bit must be '1' for the dir_idx_valid field to be configured. */
define|#
directive|define
name|HWRM_NVM_FIND_DIR_ENTRY_INPUT_ENABLES_DIR_IDX_VALID
value|UINT32_C(0x1)
name|uint16_t
name|dir_idx
decl_stmt|;
comment|/* Directory Entry Index */
name|uint16_t
name|dir_type
decl_stmt|;
comment|/* Directory Entry (Image) Type */
name|uint16_t
name|dir_ordinal
decl_stmt|;
comment|/* Directory ordinal. The instance of this Directory Type */
name|uint16_t
name|dir_ext
decl_stmt|;
comment|/* The Directory Entry Extension flags. */
name|uint8_t
name|opt_ordinal
decl_stmt|;
comment|/* This value indicates the search option using dir_ordinal. */
define|#
directive|define
name|HWRM_NVM_FIND_DIR_ENTRY_INPUT_OPT_ORDINAL_MASK
value|UINT32_C(0x3)
define|#
directive|define
name|HWRM_NVM_FIND_DIR_ENTRY_INPUT_OPT_ORDINAL_SFT
value|0
comment|/* Equal to specified ordinal value. */
define|#
directive|define
name|HWRM_NVM_FIND_DIR_ENTRY_INPUT_OPT_ORDINAL_EQ
value|UINT32_C(0x0)
comment|/* Greater than or equal to specified ordinal value */
define|#
directive|define
name|HWRM_NVM_FIND_DIR_ENTRY_INPUT_OPT_ORDINAL_GE
value|UINT32_C(0x1)
comment|/* Greater than specified ordinal value */
define|#
directive|define
name|HWRM_NVM_FIND_DIR_ENTRY_INPUT_OPT_ORDINAL_GT
value|UINT32_C(0x2)
name|uint8_t
name|unused_1
index|[
literal|3
index|]
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (32 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_nvm_find_dir_entry_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint32_t
name|dir_item_length
decl_stmt|;
comment|/* Allocated NVRAM for this directory entry, in bytes. */
name|uint32_t
name|dir_data_length
decl_stmt|;
comment|/* Size of the stored data for this directory entry, in bytes. */
name|uint32_t
name|fw_ver
decl_stmt|;
comment|/* 	 * Firmware version. Only valid if the directory entry is for embedded 	 * firmware stored in APE_BIN Format. 	 */
name|uint16_t
name|dir_ordinal
decl_stmt|;
comment|/* Directory ordinal. */
name|uint16_t
name|dir_idx
decl_stmt|;
comment|/* Directory Entry Index */
name|uint32_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_nvm_erase_dir_entry */
end_comment

begin_comment
comment|/*  * Note: Remove a directory entry specified by the directory entry index from  * the directory.  */
end_comment

begin_comment
comment|/* Input (24 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_nvm_erase_dir_entry_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint16_t
name|dir_idx
decl_stmt|;
comment|/* Directory Entry Index */
name|uint16_t
name|unused_0
index|[
literal|3
index|]
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_nvm_erase_dir_entry_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint32_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_nvm_get_dev_info */
end_comment

begin_comment
comment|/*  * Note: Get device info. Return Manufacturer_ID, Device_ID, block_size,  * nvram_size, reserved_size and available_size.  */
end_comment

begin_comment
comment|/* Input (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_nvm_get_dev_info_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (32 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_nvm_get_dev_info_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint16_t
name|manufacturer_id
decl_stmt|;
comment|/* Manufacturer ID. */
name|uint16_t
name|device_id
decl_stmt|;
comment|/* Device ID. */
name|uint32_t
name|sector_size
decl_stmt|;
comment|/* Sector size of the NVRAM device. */
name|uint32_t
name|nvram_size
decl_stmt|;
comment|/* Total size, in bytes of the NVRAM device. */
name|uint32_t
name|reserved_size
decl_stmt|;
name|uint32_t
name|available_size
decl_stmt|;
comment|/* 	 * Available size that can be used, in bytes. Available size is the 	 * NVRAM size take away the used size and reserved size. 	 */
name|uint8_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_nvm_mod_dir_entry */
end_comment

begin_comment
comment|/* Note: Modify a directory entry parameters in the directory. */
end_comment

begin_comment
comment|/* Input (32 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_nvm_mod_dir_entry_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint32_t
name|enables
decl_stmt|;
comment|/* This bit must be '1' for the checksum field to be configured. */
define|#
directive|define
name|HWRM_NVM_MOD_DIR_ENTRY_INPUT_ENABLES_CHECKSUM
value|UINT32_C(0x1)
name|uint16_t
name|dir_idx
decl_stmt|;
comment|/* Directory Entry Index */
name|uint16_t
name|dir_ordinal
decl_stmt|;
comment|/* Directory ordinal. The (0-based) instance of this Directory Type. */
name|uint16_t
name|dir_ext
decl_stmt|;
comment|/* 	 * The Directory Entry Extension flags (see BNX_DIR_EXT_* for extension 	 * flag definitions). 	 */
name|uint16_t
name|dir_attr
decl_stmt|;
comment|/* 	 * Directory Entry Attribute flags (see BNX_DIR_ATTR_* for attribute 	 * flag definitions). 	 */
name|uint32_t
name|checksum
decl_stmt|;
comment|/* 	 * If valid, then this field updates the checksum value of the content 	 * in the directory entry. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_nvm_mod_dir_entry_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint32_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_nvm_verify_update */
end_comment

begin_comment
comment|/*  * Description: Verify updated content of a directory entry. Before this  * verification, there should be two valid directory entries of the given  * directory type (one with "UPDATE" directory extension flag and the current  * one "ACTIVE"). Below are steps the HWRM performs for executing this command:  * # The HWRM finds the directory entry with "UDPATE" extension flag based on  * input parameters. The new directory entry should already have updated  * contents. # The HWRM performs signature verification of the updated content.  * # If the signature verification is successful, the two directory entries are  * switched (the verified updated entry is made active and the current "ACTIVE"  * entry is marked with "UPDATE" extension flag). Implementation notes: # The  * HWRM shall allow this command to be requested against any dir_type value (and  * not limit it to a subset). # In the case of an updated HWRM firmware, the new  * firmware version shall not automatically take effect (i.e. be executed).  */
end_comment

begin_comment
comment|/* Input (24 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_nvm_verify_update_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint16_t
name|dir_type
decl_stmt|;
comment|/* Directory Entry Type, to be verified. */
name|uint16_t
name|dir_ordinal
decl_stmt|;
comment|/* Directory ordinal. The instance of the Directory Type to be verified. */
name|uint16_t
name|dir_ext
decl_stmt|;
comment|/* 	 * The Directory Entry Extension flags. The "UPDATE" extension flag must 	 * be set in this value. A corresponding directory entry with the same 	 * type and ordinal values but *without* the "UPDATE" extension flag 	 * must also exist. The other flags of the extension must be identical 	 * between the active and update entries. 	 */
name|uint16_t
name|unused_0
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_nvm_verify_update_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint32_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_nvm_install_update */
end_comment

begin_comment
comment|/*  * Description: Install a staged NVM package. A package file must first be  * staged into the "UPDATE" NVM item. This staging is accomplished using the  * nvm_write and/or nvm_modify HWRM commands.  */
end_comment

begin_comment
comment|/* Input (24 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_nvm_install_update_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint32_t
name|install_type
decl_stmt|;
comment|/* 	 * Installation type. If the value 3 through 0xffff is used, only 	 * packaged items with that type value will be installed and conditional 	 * installation directives for those packaged items will be over-ridden 	 * (i.e. 'create' or 'replace' will be treated as 'install'). 	 */
comment|/* 	 * Perform a normal package installation. Conditional 	 * installation directives (e.g. 'create' and 'replace') of 	 * packaged items will be followed. 	 */
define|#
directive|define
name|HWRM_NVM_INSTALL_UPDATE_INPUT_INSTALL_TYPE_NORMAL
value|UINT32_C(0x0)
comment|/* 	 * Install all packaged items regardless of installation 	 * directive (i.e. treat all packaged items as though they have 	 * an installation directive of 'install'). 	 */
define|#
directive|define
name|HWRM_NVM_INSTALL_UPDATE_INPUT_INSTALL_TYPE_ALL
value|UINT32_C(0xffffffff)
name|uint16_t
name|flags
decl_stmt|;
comment|/* 	 * If set to 1, then securely erase all unused locations in persistent 	 * storage. 	 */
define|#
directive|define
name|HWRM_NVM_INSTALL_UPDATE_INPUT_FLAGS_ERASE_UNUSED_SPACE
value|UINT32_C(0x1)
comment|/* 	 * If set to 1, then unspecifed images, images not in the package file, 	 * will be safely deleted. When combined with erase_unused_space then 	 * unspecified images will be securely erased. 	 */
define|#
directive|define
name|HWRM_NVM_INSTALL_UPDATE_INPUT_FLAGS_REMOVE_UNUSED_PKG
value|UINT32_C(0x2)
comment|/* 	 * If set to 1, FW will defragment the NVM if defragmentation is 	 * required for the update. Allow additional time for this command to 	 * complete if this bit is set to 1. 	 */
define|#
directive|define
name|HWRM_NVM_INSTALL_UPDATE_INPUT_FLAGS_ALLOWED_TO_DEFRAG
value|UINT32_C(0x4)
name|uint16_t
name|unused_0
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (24 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_nvm_install_update_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint64_t
name|installed_items
decl_stmt|;
comment|/* 	 * Bit-mask of successfully installed items. Bit-0 corresponding to the 	 * first packaged item, Bit-1 for the second item, etc. A value of 0 	 * indicates that no items were successfully installed. 	 */
name|uint8_t
name|result
decl_stmt|;
comment|/* result is 8 b */
comment|/* There was no problem with the package installation. */
define|#
directive|define
name|HWRM_NVM_INSTALL_UPDATE_OUTPUT_RESULT_SUCCESS
value|UINT32_C(0x0)
name|uint8_t
name|problem_item
decl_stmt|;
comment|/* problem_item is 8 b */
comment|/* There was no problem with any packaged items. */
define|#
directive|define
name|HWRM_NVM_INSTALL_UPDATE_OUTPUT_PROBLEM_ITEM_NONE
value|UINT32_C(0x0)
comment|/* There was a problem with the NVM package itself. */
define|#
directive|define
name|HWRM_NVM_INSTALL_UPDATE_OUTPUT_PROBLEM_ITEM_PACKAGE
value|UINT32_C(0xff)
name|uint8_t
name|reset_required
decl_stmt|;
comment|/* reset_required is 8 b */
comment|/* 	 * No reset is required for installed/updated firmware or 	 * microcode to take effect. 	 */
define|#
directive|define
name|HWRM_NVM_INSTALL_UPDATE_OUTPUT_RESET_REQUIRED_NONE
value|UINT32_C(0x0)
comment|/* 	 * A PCIe reset (e.g. system reboot) is required for newly 	 * installed/updated firmware or microcode to take effect. 	 */
define|#
directive|define
name|HWRM_NVM_INSTALL_UPDATE_OUTPUT_RESET_REQUIRED_PCI
value|UINT32_C(0x1)
comment|/* 	 * A controller power reset (e.g. system power-cycle) is 	 * required for newly installed/updated firmware or microcode to 	 * take effect. Some newly installed/updated firmware or 	 * microcode may still take effect upon the next PCIe reset. 	 */
define|#
directive|define
name|HWRM_NVM_INSTALL_UPDATE_OUTPUT_RESET_REQUIRED_POWER
value|UINT32_C(0x2)
name|uint8_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Command specific Error Codes (8 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_nvm_install_update_cmd_err
block|{
name|uint8_t
name|code
decl_stmt|;
comment|/* 	 * command specific error codes that goes to the cmd_err field in Common 	 * HWRM Error Response. 	 */
comment|/* Unknown error */
define|#
directive|define
name|HWRM_NVM_INSTALL_UPDATE_CMD_ERR_CODE_UNKNOWN
value|UINT32_C(0x0)
comment|/* Unable to complete operation due to fragmentation */
define|#
directive|define
name|HWRM_NVM_INSTALL_UPDATE_CMD_ERR_CODE_FRAG_ERR
value|UINT32_C(0x1)
comment|/* nvm is completely full. */
define|#
directive|define
name|HWRM_NVM_INSTALL_UPDATE_CMD_ERR_CODE_NO_SPACE
value|UINT32_C(0x2)
name|uint8_t
name|unused_0
index|[
literal|7
index|]
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_nvm_flush */
end_comment

begin_comment
comment|/* Input (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_nvm_flush_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_nvm_flush_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint32_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Command specific Error Codes (8 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_nvm_flush_cmd_err
block|{
name|uint8_t
name|code
decl_stmt|;
comment|/* 	 * command specific error codes that goes to the cmd_err field in Common 	 * HWRM Error Response. 	 */
comment|/* Unknown error */
define|#
directive|define
name|HWRM_NVM_FLUSH_CMD_ERR_CODE_UNKNOWN
value|UINT32_C(0x0)
comment|/* flush could not be performed */
define|#
directive|define
name|HWRM_NVM_FLUSH_CMD_ERR_CODE_FAIL
value|UINT32_C(0x1)
name|uint8_t
name|unused_0
index|[
literal|7
index|]
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_nvm_get_variable */
end_comment

begin_comment
comment|/* Input (40 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_nvm_get_variable_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint64_t
name|dest_data_addr
decl_stmt|;
comment|/* This is the host address where nvm variable will be stored */
name|uint16_t
name|data_len
decl_stmt|;
comment|/* size of data in bits */
name|uint16_t
name|option_num
decl_stmt|;
comment|/* nvm cfg option number */
comment|/* reserved. */
define|#
directive|define
name|HWRM_NVM_GET_VARIABLE_INPUT_OPTION_NUM_RSVD_0
value|UINT32_C(0x0)
comment|/* reserved. */
define|#
directive|define
name|HWRM_NVM_GET_VARIABLE_INPUT_OPTION_NUM_RSVD_FFFF
value|UINT32_C(0xffff)
name|uint16_t
name|dimensions
decl_stmt|;
comment|/* 	 * Number of dimensions for this nvm configuration variable. This value 	 * indicates how many of the indexN values to use. A value of 0 means 	 * that none of the indexN values are valid. A value of 1 requires at 	 * index0 is valued, a value of 2 requires that index0 and index1 are 	 * valid, and so forth 	 */
name|uint16_t
name|index_0
decl_stmt|;
comment|/* index for the 1st dimensions */
name|uint16_t
name|index_1
decl_stmt|;
comment|/* index for the 2nd dimensions */
name|uint16_t
name|index_2
decl_stmt|;
comment|/* index for the 3rd dimensions */
name|uint16_t
name|index_3
decl_stmt|;
comment|/* index for the 4th dimensions */
name|uint8_t
name|flags
decl_stmt|;
comment|/* 	 * When this bit is set to 1, the factory default value will be 	 * returned, 0 returns the operational value. 	 */
define|#
directive|define
name|HWRM_NVM_GET_VARIABLE_INPUT_FLAGS_FACTORY_DFLT
value|UINT32_C(0x1)
name|uint8_t
name|unused_0
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_nvm_get_variable_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint16_t
name|data_len
decl_stmt|;
comment|/* size of data of the actual variable retrieved in bits */
name|uint16_t
name|option_num
decl_stmt|;
comment|/* 	 * option_num is the option number for the data retrieved. It is 	 * possible in the future that the option number returned would be 	 * different than requested. This condition could occur if an option is 	 * deprecated and a new option id is defined with similar 	 * characteristics, but has a slightly different definition. This also 	 * makes it convenient for the caller to identify the variable result 	 * with the option id from the response. 	 */
comment|/* reserved. */
define|#
directive|define
name|HWRM_NVM_GET_VARIABLE_OUTPUT_OPTION_NUM_RSVD_0
value|UINT32_C(0x0)
comment|/* reserved. */
define|#
directive|define
name|HWRM_NVM_GET_VARIABLE_OUTPUT_OPTION_NUM_RSVD_FFFF
value|UINT32_C(0xffff)
name|uint8_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Command specific Error Codes (8 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_nvm_get_variable_cmd_err
block|{
name|uint8_t
name|code
decl_stmt|;
comment|/* 	 * command specific error codes that goes to the cmd_err field in Common 	 * HWRM Error Response. 	 */
comment|/* Unknown error */
define|#
directive|define
name|HWRM_NVM_GET_VARIABLE_CMD_ERR_CODE_UNKNOWN
value|UINT32_C(0x0)
comment|/* variable does not exist */
define|#
directive|define
name|HWRM_NVM_GET_VARIABLE_CMD_ERR_CODE_VAR_NOT_EXIST
value|UINT32_C(0x1)
comment|/* configuration is corrupted and the variable cannot be saved */
define|#
directive|define
name|HWRM_NVM_GET_VARIABLE_CMD_ERR_CODE_CORRUPT_VAR
value|UINT32_C(0x2)
comment|/* length specified is too small */
define|#
directive|define
name|HWRM_NVM_GET_VARIABLE_CMD_ERR_CODE_LEN_TOO_SHORT
value|UINT32_C(0x3)
name|uint8_t
name|unused_0
index|[
literal|7
index|]
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_nvm_set_variable */
end_comment

begin_comment
comment|/* Input (40 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_nvm_set_variable_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint64_t
name|src_data_addr
decl_stmt|;
comment|/* This is the host address where nvm variable will be copied from */
name|uint16_t
name|data_len
decl_stmt|;
comment|/* size of data in bits */
name|uint16_t
name|option_num
decl_stmt|;
comment|/* nvm cfg option number */
comment|/* reserved. */
define|#
directive|define
name|HWRM_NVM_SET_VARIABLE_INPUT_OPTION_NUM_RSVD_0
value|UINT32_C(0x0)
comment|/* reserved. */
define|#
directive|define
name|HWRM_NVM_SET_VARIABLE_INPUT_OPTION_NUM_RSVD_FFFF
value|UINT32_C(0xffff)
name|uint16_t
name|dimensions
decl_stmt|;
comment|/* 	 * Number of dimensions for this nvm configuration variable. This value 	 * indicates how many of the indexN values to use. A value of 0 means 	 * that none of the indexN values are valid. A value of 1 requires at 	 * index0 is valued, a value of 2 requires that index0 and index1 are 	 * valid, and so forth 	 */
name|uint16_t
name|index_0
decl_stmt|;
comment|/* index for the 1st dimensions */
name|uint16_t
name|index_1
decl_stmt|;
comment|/* index for the 2nd dimensions */
name|uint16_t
name|index_2
decl_stmt|;
comment|/* index for the 3rd dimensions */
name|uint16_t
name|index_3
decl_stmt|;
comment|/* index for the 4th dimensions */
name|uint8_t
name|flags
decl_stmt|;
comment|/* 	 * When this bit is 1, flush internal cache after this write operation 	 * (see hwrm_nvm_flush command.) 	 */
define|#
directive|define
name|HWRM_NVM_SET_VARIABLE_INPUT_FLAGS_FORCE_FLUSH
value|UINT32_C(0x1)
comment|/* encryption method */
define|#
directive|define
name|HWRM_NVM_SET_VARIABLE_INPUT_FLAGS_ENCRYPT_MODE_MASK
value|UINT32_C(0xe)
define|#
directive|define
name|HWRM_NVM_SET_VARIABLE_INPUT_FLAGS_ENCRYPT_MODE_SFT
value|1
comment|/* No encryption. */
define|#
directive|define
name|HWRM_NVM_SET_VARIABLE_INPUT_FLAGS_ENCRYPT_MODE_NONE
value|(UINT32_C(0x0)<< 1)
comment|/* one-way encryption. */
define|#
directive|define
name|HWRM_NVM_SET_VARIABLE_INPUT_FLAGS_ENCRYPT_MODE_HMAC_SHA1
value|(UINT32_C(0x1)<< 1)
define|#
directive|define
name|HWRM_NVM_SET_VARIABLE_INPUT_FLAGS_ENCRYPT_MODE_LAST
value|HWRM_NVM_SET_VARIABLE_INPUT_FLAGS_ENCRYPT_MODE_HMAC_SHA1
name|uint8_t
name|unused_0
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_nvm_set_variable_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint32_t
name|unused_0
decl_stmt|;
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Command specific Error Codes (8 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_nvm_set_variable_cmd_err
block|{
name|uint8_t
name|code
decl_stmt|;
comment|/* 	 * command specific error codes that goes to the cmd_err field in Common 	 * HWRM Error Response. 	 */
comment|/* Unknown error */
define|#
directive|define
name|HWRM_NVM_SET_VARIABLE_CMD_ERR_CODE_UNKNOWN
value|UINT32_C(0x0)
comment|/* variable does not exist */
define|#
directive|define
name|HWRM_NVM_SET_VARIABLE_CMD_ERR_CODE_VAR_NOT_EXIST
value|UINT32_C(0x1)
comment|/* configuration is corrupted and the variable cannot be saved */
define|#
directive|define
name|HWRM_NVM_SET_VARIABLE_CMD_ERR_CODE_CORRUPT_VAR
value|UINT32_C(0x2)
name|uint8_t
name|unused_0
index|[
literal|7
index|]
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_nvm_validate_option */
end_comment

begin_comment
comment|/* Input (40 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_nvm_validate_option_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint64_t
name|src_data_addr
decl_stmt|;
comment|/* This is the host address where nvm variable will be copied from */
name|uint16_t
name|data_len
decl_stmt|;
comment|/* size of data in bits */
name|uint16_t
name|option_num
decl_stmt|;
comment|/* nvm cfg option number */
comment|/* reserved. */
define|#
directive|define
name|HWRM_NVM_VALIDATE_OPTION_INPUT_OPTION_NUM_RSVD_0
value|UINT32_C(0x0)
comment|/* reserved. */
define|#
directive|define
name|HWRM_NVM_VALIDATE_OPTION_INPUT_OPTION_NUM_RSVD_FFFF
value|UINT32_C(0xffff)
name|uint16_t
name|dimensions
decl_stmt|;
comment|/* 	 * Number of dimensions for this nvm configuration variable. This value 	 * indicates how many of the indexN values to use. A value of 0 means 	 * that none of the indexN values are valid. A value of 1 requires at 	 * index0 is valued, a value of 2 requires that index0 and index1 are 	 * valid, and so forth 	 */
name|uint16_t
name|index_0
decl_stmt|;
comment|/* index for the 1st dimensions */
name|uint16_t
name|index_1
decl_stmt|;
comment|/* index for the 2nd dimensions */
name|uint16_t
name|index_2
decl_stmt|;
comment|/* index for the 3rd dimensions */
name|uint16_t
name|index_3
decl_stmt|;
comment|/* index for the 4th dimensions */
name|uint16_t
name|unused_0
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_nvm_validate_option_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint8_t
name|result
decl_stmt|;
comment|/* 	 * indicates that the value provided for the option is not 	 * matching with the saved data. 	 */
define|#
directive|define
name|HWRM_NVM_VALIDATE_OPTION_OUTPUT_RESULT_NOT_MATCH
value|UINT32_C(0x0)
comment|/* 	 * indicates that the value provided for the option is matching 	 * the saved data. 	 */
define|#
directive|define
name|HWRM_NVM_VALIDATE_OPTION_OUTPUT_RESULT_MATCH
value|UINT32_C(0x1)
name|uint8_t
name|unused_0
decl_stmt|;
name|uint16_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint8_t
name|unused_3
decl_stmt|;
name|uint8_t
name|unused_4
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Command specific Error Codes (8 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_nvm_validate_option_cmd_err
block|{
name|uint8_t
name|code
decl_stmt|;
comment|/* 	 * command specific error codes that goes to the cmd_err field in Common 	 * HWRM Error Response. 	 */
comment|/* Unknown error */
define|#
directive|define
name|HWRM_NVM_VALIDATE_OPTION_CMD_ERR_CODE_UNKNOWN
value|UINT32_C(0x0)
name|uint8_t
name|unused_0
index|[
literal|7
index|]
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Command Queue (CMDQ) Interface */
end_comment

begin_comment
comment|/* Description: This command queries congestion control settings. */
end_comment

begin_comment
comment|/* Init CMDQ (16 bytes) */
end_comment

begin_struct
struct|struct
name|cmdq_init
block|{
name|uint64_t
name|cmdq_pbl
decl_stmt|;
comment|/* CMDQ PBL physical address. */
name|uint16_t
name|cmdq_size_cmdq_lvl
decl_stmt|;
comment|/* CMDQ size. */
comment|/* CMDQ PBL indirection levels. */
define|#
directive|define
name|CMDQ_INIT_CMDQ_LVL_MASK
value|UINT32_C(0x3)
define|#
directive|define
name|CMDQ_INIT_CMDQ_LVL_SFT
value|0
comment|/* CMDQ size. */
define|#
directive|define
name|CMDQ_INIT_CMDQ_SIZE_MASK
value|UINT32_C(0xfffc)
define|#
directive|define
name|CMDQ_INIT_CMDQ_SIZE_SFT
value|2
name|uint16_t
name|creq_ring_id
decl_stmt|;
comment|/* CREQ completion ring id. */
name|uint32_t
name|prod_idx
decl_stmt|;
comment|/* Mailbox producer index. MSB must also be set. */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Update CMDQ producer index (16 bytes) */
end_comment

begin_struct
struct|struct
name|cmdq_update
block|{
name|uint64_t
name|reserved64
decl_stmt|;
comment|/* reserved64 is 64 b */
name|uint32_t
name|reserved32
decl_stmt|;
comment|/* reserved32 is 32 b */
name|uint32_t
name|prod_idx
decl_stmt|;
comment|/* Mailbox producer index. */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* CMDQ common header structure (16 bytes) */
end_comment

begin_struct
struct|struct
name|cmdq_base
block|{
name|uint8_t
name|opcode
decl_stmt|;
comment|/* Command opcode. */
comment|/* 	 * Create QP command allocates QP context with the specified SQ, 	 * RQ/SRQ, CQ and other parameters. 	 */
define|#
directive|define
name|CMDQ_BASE_OPCODE_CREATE_QP
value|UINT32_C(0x1)
comment|/* 	 * Destroy QP command deletes the QP context and ceases any 	 * further reference. 	 */
define|#
directive|define
name|CMDQ_BASE_OPCODE_DESTROY_QP
value|UINT32_C(0x2)
comment|/* 	 * Modify QP command changes QP states and other QP specific 	 * parameters. 	 */
define|#
directive|define
name|CMDQ_BASE_OPCODE_MODIFY_QP
value|UINT32_C(0x3)
comment|/* Query QP command retrieves info about the specified QP. */
define|#
directive|define
name|CMDQ_BASE_OPCODE_QUERY_QP
value|UINT32_C(0x4)
comment|/* Create SRQ command allocates a SRQ with the specified parameters. */
define|#
directive|define
name|CMDQ_BASE_OPCODE_CREATE_SRQ
value|UINT32_C(0x5)
comment|/* Destroy SRQ command deletes and flushes the specified SRQ. */
define|#
directive|define
name|CMDQ_BASE_OPCODE_DESTROY_SRQ
value|UINT32_C(0x6)
comment|/* Query SRP command retrieves info about the specified SRQ. */
define|#
directive|define
name|CMDQ_BASE_OPCODE_QUERY_SRQ
value|UINT32_C(0x8)
comment|/* Create CQ command allocates a CQ with the specified parameters. */
define|#
directive|define
name|CMDQ_BASE_OPCODE_CREATE_CQ
value|UINT32_C(0x9)
comment|/* Destroy CQ command deletes and flushes the specified CQ. */
define|#
directive|define
name|CMDQ_BASE_OPCODE_DESTROY_CQ
value|UINT32_C(0xa)
comment|/* Resize CQ command resizes the specified CQ. */
define|#
directive|define
name|CMDQ_BASE_OPCODE_RESIZE_CQ
value|UINT32_C(0xc)
comment|/* 	 * Allocate MRW command allocates a MR/MW with the specified 	 * parameters and returns the region's L_KEY/R_KEY 	 */
define|#
directive|define
name|CMDQ_BASE_OPCODE_ALLOCATE_MRW
value|UINT32_C(0xd)
comment|/* 	 * De-allocate key command frees a MR/MW entry associated with 	 * the specified key. 	 */
define|#
directive|define
name|CMDQ_BASE_OPCODE_DEALLOCATE_KEY
value|UINT32_C(0xe)
comment|/* Register MR command registers memory to the specified MR. */
define|#
directive|define
name|CMDQ_BASE_OPCODE_REGISTER_MR
value|UINT32_C(0xf)
comment|/* Deregister MR command de-registers memory from the specified MR. */
define|#
directive|define
name|CMDQ_BASE_OPCODE_DEREGISTER_MR
value|UINT32_C(0x10)
comment|/* Add GID command adds a GID to the local address table. */
define|#
directive|define
name|CMDQ_BASE_OPCODE_ADD_GID
value|UINT32_C(0x11)
comment|/* Delete GID command deletes a GID from the local address table. */
define|#
directive|define
name|CMDQ_BASE_OPCODE_DELETE_GID
value|UINT32_C(0x12)
comment|/* Modify GID command modifies a GID in the local address table. */
define|#
directive|define
name|CMDQ_BASE_OPCODE_MODIFY_GID
value|UINT32_C(0x17)
comment|/* Query GID command queries a GID in the local address table. */
define|#
directive|define
name|CMDQ_BASE_OPCODE_QUERY_GID
value|UINT32_C(0x18)
comment|/* Create QP1 command allocates a QP1 only. */
define|#
directive|define
name|CMDQ_BASE_OPCODE_CREATE_QP1
value|UINT32_C(0x13)
comment|/* Destroy QP1 command deletes and flushes the specified QP1. */
define|#
directive|define
name|CMDQ_BASE_OPCODE_DESTROY_QP1
value|UINT32_C(0x14)
comment|/* Create AH command allocates an AH with the specified parameters. */
define|#
directive|define
name|CMDQ_BASE_OPCODE_CREATE_AH
value|UINT32_C(0x15)
comment|/* Destroy AH command deletes the specified AH. */
define|#
directive|define
name|CMDQ_BASE_OPCODE_DESTROY_AH
value|UINT32_C(0x16)
comment|/* 	 * Initialize firmware command initializes the firmware with the 	 * specified parameters. 	 */
define|#
directive|define
name|CMDQ_BASE_OPCODE_INITIALIZE_FW
value|UINT32_C(0x80)
comment|/* De-initialize firmware command deinitializes the firmware. */
define|#
directive|define
name|CMDQ_BASE_OPCODE_DEINITIALIZE_FW
value|UINT32_C(0x81)
comment|/* Stop the function */
define|#
directive|define
name|CMDQ_BASE_OPCODE_STOP_FUNC
value|UINT32_C(0x82)
comment|/* Query the HW capabilities for the function. */
define|#
directive|define
name|CMDQ_BASE_OPCODE_QUERY_FUNC
value|UINT32_C(0x83)
comment|/* 	 * Set the following resources for the function: - Max QP, CQ, 	 * MR+MW, SRQ per PF - Max QP, CQ, MR+MW, SRQ per VF 	 */
define|#
directive|define
name|CMDQ_BASE_OPCODE_SET_FUNC_RESOURCES
value|UINT32_C(0x84)
comment|/* 	 * Read the current state of any internal resource context. Can 	 * only be issued from a PF. 	 */
define|#
directive|define
name|CMDQ_BASE_OPCODE_READ_CONTEXT
value|UINT32_C(0x85)
comment|/* 	 * Send a request from VF to pass a command to the PF. VF HSI is 	 * suspended until the PF returns the response 	 */
define|#
directive|define
name|CMDQ_BASE_OPCODE_VF_BACKCHANNEL_REQUEST
value|UINT32_C(0x86)
comment|/* 	 * Read VF memory (primarily to get the backchannel request 	 * blob). Can only be issued from a PF. 	 */
define|#
directive|define
name|CMDQ_BASE_OPCODE_READ_VF_MEMORY
value|UINT32_C(0x87)
comment|/* 	 * Write VF memory (primarily to put the backchannel response 	 * blob), and reenable VF HSI (post a CAG completion to it). Can 	 * only be issued from a PF. 	 */
define|#
directive|define
name|CMDQ_BASE_OPCODE_COMPLETE_VF_REQUEST
value|UINT32_C(0x88)
comment|/* 	 * Extend resource (QPC, MRW, CQ, SRQ) array, after the host 	 * allocates more. Can only be issued from a PF. 	 */
define|#
directive|define
name|CMDQ_BASE_OPCODE_EXTEND_CONTEXT_ARRRAY
value|UINT32_C(0x89)
comment|/* Map TC to COS. Can only be issued from a PF. */
define|#
directive|define
name|CMDQ_BASE_OPCODE_MAP_TC_TO_COS
value|UINT32_C(0x8a)
comment|/* Query version. */
define|#
directive|define
name|CMDQ_BASE_OPCODE_QUERY_VERSION
value|UINT32_C(0x8b)
comment|/* Modify congestion control. Can only be issued from a PF. */
define|#
directive|define
name|CMDQ_BASE_OPCODE_MODIFY_ROCE_CC
value|UINT32_C(0x8c)
comment|/* Query congestion control. */
define|#
directive|define
name|CMDQ_BASE_OPCODE_QUERY_ROCE_CC
value|UINT32_C(0x8d)
name|uint8_t
name|cmd_size
decl_stmt|;
comment|/* Size of the command in 16-byte units. */
name|uint16_t
name|flags
decl_stmt|;
comment|/* Flags and attribs of the command. */
name|uint16_t
name|cookie
decl_stmt|;
comment|/* Driver supplied handle to associate the command and the response. */
name|uint8_t
name|resp_size
decl_stmt|;
comment|/* Size of the response buffer in 16-byte units. */
name|uint8_t
name|reserved8
decl_stmt|;
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* Host address of the response. */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Create QP command (96 bytes) */
end_comment

begin_struct
struct|struct
name|cmdq_create_qp
block|{
name|uint8_t
name|opcode
decl_stmt|;
comment|/* Command opcode. */
comment|/* 	 * Create QP command allocates QP context with the specified SQ, 	 * RQ/SRQ, CQ and other parameters. 	 */
define|#
directive|define
name|CMDQ_CREATE_QP_OPCODE_CREATE_QP
value|UINT32_C(0x1)
name|uint8_t
name|cmd_size
decl_stmt|;
comment|/* Size of the command in 16-byte units. */
name|uint16_t
name|flags
decl_stmt|;
comment|/* Flags and attribs of the command. */
name|uint16_t
name|cookie
decl_stmt|;
comment|/* Driver supplied handle to associate the command and the response. */
name|uint8_t
name|resp_size
decl_stmt|;
comment|/* Size of the response buffer in 16-byte units. */
name|uint8_t
name|reserved8
decl_stmt|;
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* Host address of the response. */
name|uint64_t
name|qp_handle
decl_stmt|;
comment|/* QP handle. */
name|uint32_t
name|qp_flags
decl_stmt|;
comment|/* Create QP flags. */
comment|/* SRQ is used. */
define|#
directive|define
name|CMDQ_CREATE_QP_QP_FLAGS_SRQ_USED
value|UINT32_C(0x1)
comment|/* post CQE for all SQ WQEs. */
define|#
directive|define
name|CMDQ_CREATE_QP_QP_FLAGS_FORCE_COMPLETION
value|UINT32_C(0x2)
comment|/* This QP can use reserved L_Key */
define|#
directive|define
name|CMDQ_CREATE_QP_QP_FLAGS_RESERVED_LKEY_ENABLE
value|UINT32_C(0x4)
comment|/* This QP can fast register physical memory */
define|#
directive|define
name|CMDQ_CREATE_QP_QP_FLAGS_FR_PMR_ENABLED
value|UINT32_C(0x8)
name|uint8_t
name|type
decl_stmt|;
comment|/* Supported QP types. */
comment|/* Reliable Connection. */
define|#
directive|define
name|CMDQ_CREATE_QP_TYPE_RC
value|UINT32_C(0x2)
comment|/* Unreliable Datagram. */
define|#
directive|define
name|CMDQ_CREATE_QP_TYPE_UD
value|UINT32_C(0x4)
comment|/* Raw Ethertype. */
define|#
directive|define
name|CMDQ_CREATE_QP_TYPE_RAW_ETHERTYPE
value|UINT32_C(0x6)
name|uint8_t
name|sq_pg_size_sq_lvl
decl_stmt|;
comment|/* SQ page size. */
comment|/* SQ PBL indirect levels. */
define|#
directive|define
name|CMDQ_CREATE_QP_SQ_LVL_MASK
value|UINT32_C(0xf)
define|#
directive|define
name|CMDQ_CREATE_QP_SQ_LVL_SFT
value|0
comment|/* PBL pointer is physical start address. */
define|#
directive|define
name|CMDQ_CREATE_QP_SQ_LVL_LVL_0
value|UINT32_C(0x0)
comment|/* PBL pointer points to PTE table. */
define|#
directive|define
name|CMDQ_CREATE_QP_SQ_LVL_LVL_1
value|UINT32_C(0x1)
comment|/* 	 * PBL pointer points to PDE table with each entry pointing to 	 * PTE tables. 	 */
define|#
directive|define
name|CMDQ_CREATE_QP_SQ_LVL_LVL_2
value|UINT32_C(0x2)
comment|/* SQ page size. */
define|#
directive|define
name|CMDQ_CREATE_QP_SQ_PG_SIZE_MASK
value|UINT32_C(0xf0)
define|#
directive|define
name|CMDQ_CREATE_QP_SQ_PG_SIZE_SFT
value|4
comment|/* 4KB. */
define|#
directive|define
name|CMDQ_CREATE_QP_SQ_PG_SIZE_PG_4K
value|(UINT32_C(0x0)<< 4)
comment|/* 8KB. */
define|#
directive|define
name|CMDQ_CREATE_QP_SQ_PG_SIZE_PG_8K
value|(UINT32_C(0x1)<< 4)
comment|/* 64KB. */
define|#
directive|define
name|CMDQ_CREATE_QP_SQ_PG_SIZE_PG_64K
value|(UINT32_C(0x2)<< 4)
comment|/* 2MB. */
define|#
directive|define
name|CMDQ_CREATE_QP_SQ_PG_SIZE_PG_2M
value|(UINT32_C(0x3)<< 4)
comment|/* 8MB. */
define|#
directive|define
name|CMDQ_CREATE_QP_SQ_PG_SIZE_PG_8M
value|(UINT32_C(0x4)<< 4)
comment|/* 1GB. */
define|#
directive|define
name|CMDQ_CREATE_QP_SQ_PG_SIZE_PG_1G
value|(UINT32_C(0x5)<< 4)
name|uint8_t
name|rq_pg_size_rq_lvl
decl_stmt|;
comment|/* RQ page size. */
comment|/* RQ PBL indirect levels. */
define|#
directive|define
name|CMDQ_CREATE_QP_RQ_LVL_MASK
value|UINT32_C(0xf)
define|#
directive|define
name|CMDQ_CREATE_QP_RQ_LVL_SFT
value|0
comment|/* PBL pointer is physical start address. */
define|#
directive|define
name|CMDQ_CREATE_QP_RQ_LVL_LVL_0
value|UINT32_C(0x0)
comment|/* PBL pointer points to PTE table. */
define|#
directive|define
name|CMDQ_CREATE_QP_RQ_LVL_LVL_1
value|UINT32_C(0x1)
comment|/* 	 * PBL pointer points to PDE table with each entry pointing to 	 * PTE tables. 	 */
define|#
directive|define
name|CMDQ_CREATE_QP_RQ_LVL_LVL_2
value|UINT32_C(0x2)
comment|/* RQ page size. */
define|#
directive|define
name|CMDQ_CREATE_QP_RQ_PG_SIZE_MASK
value|UINT32_C(0xf0)
define|#
directive|define
name|CMDQ_CREATE_QP_RQ_PG_SIZE_SFT
value|4
comment|/* 4KB. */
define|#
directive|define
name|CMDQ_CREATE_QP_RQ_PG_SIZE_PG_4K
value|(UINT32_C(0x0)<< 4)
comment|/* 8KB. */
define|#
directive|define
name|CMDQ_CREATE_QP_RQ_PG_SIZE_PG_8K
value|(UINT32_C(0x1)<< 4)
comment|/* 64KB. */
define|#
directive|define
name|CMDQ_CREATE_QP_RQ_PG_SIZE_PG_64K
value|(UINT32_C(0x2)<< 4)
comment|/* 2MB. */
define|#
directive|define
name|CMDQ_CREATE_QP_RQ_PG_SIZE_PG_2M
value|(UINT32_C(0x3)<< 4)
comment|/* 8MB. */
define|#
directive|define
name|CMDQ_CREATE_QP_RQ_PG_SIZE_PG_8M
value|(UINT32_C(0x4)<< 4)
comment|/* 1GB. */
define|#
directive|define
name|CMDQ_CREATE_QP_RQ_PG_SIZE_PG_1G
value|(UINT32_C(0x5)<< 4)
name|uint8_t
name|unused_0
decl_stmt|;
name|uint32_t
name|dpi
decl_stmt|;
comment|/* Doorbell page index. */
name|uint32_t
name|sq_size
decl_stmt|;
comment|/* Max number of SQ wqes. */
name|uint32_t
name|rq_size
decl_stmt|;
comment|/* Max number of RQ wqes. */
name|uint16_t
name|sq_fwo_sq_sge
decl_stmt|;
comment|/* Offset of First WQE in the first SQ page, in 128 byte units */
comment|/* Max send SGEs per SWQE. */
define|#
directive|define
name|CMDQ_CREATE_QP_SQ_SGE_MASK
value|UINT32_C(0xf)
define|#
directive|define
name|CMDQ_CREATE_QP_SQ_SGE_SFT
value|0
comment|/* Offset of First WQE in the first SQ page, in 128 byte units */
define|#
directive|define
name|CMDQ_CREATE_QP_SQ_FWO_MASK
value|UINT32_C(0xfff0)
define|#
directive|define
name|CMDQ_CREATE_QP_SQ_FWO_SFT
value|4
name|uint16_t
name|rq_fwo_rq_sge
decl_stmt|;
comment|/* Offset of First WQE in the first RQ page, in 128 byte units */
comment|/* Max recv SGEs per RWQE (NOT SUPPORTED BY HARDWARE). */
define|#
directive|define
name|CMDQ_CREATE_QP_RQ_SGE_MASK
value|UINT32_C(0xf)
define|#
directive|define
name|CMDQ_CREATE_QP_RQ_SGE_SFT
value|0
comment|/* Offset of First WQE in the first RQ page, in 128 byte units */
define|#
directive|define
name|CMDQ_CREATE_QP_RQ_FWO_MASK
value|UINT32_C(0xfff0)
define|#
directive|define
name|CMDQ_CREATE_QP_RQ_FWO_SFT
value|4
name|uint32_t
name|scq_cid
decl_stmt|;
comment|/* Send CQ context id. */
name|uint32_t
name|rcq_cid
decl_stmt|;
comment|/* Receive CQ context id. */
name|uint32_t
name|srq_cid
decl_stmt|;
comment|/* SRQ CQ context id. */
name|uint32_t
name|pd_id
decl_stmt|;
comment|/* Protection domain id. */
name|uint64_t
name|sq_pbl
decl_stmt|;
comment|/* SQ PBL physical address. */
name|uint64_t
name|rq_pbl
decl_stmt|;
comment|/* RQ PBL physical address. */
name|uint64_t
name|irrq_addr
decl_stmt|;
comment|/* IRRQ address. */
name|uint64_t
name|orrq_addr
decl_stmt|;
comment|/* ORRQ address. */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Destroy QP command (24 bytes) */
end_comment

begin_struct
struct|struct
name|cmdq_destroy_qp
block|{
name|uint8_t
name|opcode
decl_stmt|;
comment|/* Command opcode. */
comment|/* 	 * Destroy QP command deletes the QP context and ceases any 	 * further reference. 	 */
define|#
directive|define
name|CMDQ_DESTROY_QP_OPCODE_DESTROY_QP
value|UINT32_C(0x2)
name|uint8_t
name|cmd_size
decl_stmt|;
comment|/* Size of the command in 16-byte units. */
name|uint16_t
name|flags
decl_stmt|;
comment|/* Flags and attribs of the command. */
name|uint16_t
name|cookie
decl_stmt|;
comment|/* Driver supplied handle to associate the command and the response. */
name|uint8_t
name|resp_size
decl_stmt|;
comment|/* Size of the response buffer in 16-byte units. */
name|uint8_t
name|reserved8
decl_stmt|;
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* Host address of the response. */
name|uint32_t
name|qp_cid
decl_stmt|;
comment|/* QP context id */
name|uint32_t
name|unused_0
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Modify QP command (112 bytes) */
end_comment

begin_struct
struct|struct
name|cmdq_modify_qp
block|{
name|uint8_t
name|opcode
decl_stmt|;
comment|/* Command opcode. */
comment|/* 	 * Modify QP command changes QP states and other QP specific 	 * parameters. 	 */
define|#
directive|define
name|CMDQ_MODIFY_QP_OPCODE_MODIFY_QP
value|UINT32_C(0x3)
name|uint8_t
name|cmd_size
decl_stmt|;
comment|/* Size of the command in 16-byte units. */
name|uint16_t
name|flags
decl_stmt|;
comment|/* Flags and attribs of the command. */
name|uint16_t
name|cookie
decl_stmt|;
comment|/* Driver supplied handle to associate the command and the response. */
name|uint8_t
name|resp_size
decl_stmt|;
comment|/* Size of the response buffer in 16-byte units. */
name|uint8_t
name|reserved8
decl_stmt|;
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* Host address of the response. */
name|uint32_t
name|modify_mask
decl_stmt|;
comment|/* Modify mask signifies the field that is requesting the change. */
comment|/* QP state change. */
define|#
directive|define
name|CMDQ_MODIFY_QP_MODIFY_MASK_STATE
value|UINT32_C(0x1)
comment|/* Enable SQ drain asynchronous notification change. */
define|#
directive|define
name|CMDQ_MODIFY_QP_MODIFY_MASK_EN_SQD_ASYNC_NOTIFY
value|UINT32_C(0x2)
comment|/* Access change. */
define|#
directive|define
name|CMDQ_MODIFY_QP_MODIFY_MASK_ACCESS
value|UINT32_C(0x4)
comment|/* P_KEY change. */
define|#
directive|define
name|CMDQ_MODIFY_QP_MODIFY_MASK_PKEY
value|UINT32_C(0x8)
comment|/* Q_KEY index change. */
define|#
directive|define
name|CMDQ_MODIFY_QP_MODIFY_MASK_QKEY
value|UINT32_C(0x10)
comment|/* Destination GID change. */
define|#
directive|define
name|CMDQ_MODIFY_QP_MODIFY_MASK_DGID
value|UINT32_C(0x20)
comment|/* Flow label change. */
define|#
directive|define
name|CMDQ_MODIFY_QP_MODIFY_MASK_FLOW_LABEL
value|UINT32_C(0x40)
comment|/* SGID change. */
define|#
directive|define
name|CMDQ_MODIFY_QP_MODIFY_MASK_SGID_INDEX
value|UINT32_C(0x80)
comment|/* Hop limit change. */
define|#
directive|define
name|CMDQ_MODIFY_QP_MODIFY_MASK_HOP_LIMIT
value|UINT32_C(0x100)
comment|/* Traffic class change. */
define|#
directive|define
name|CMDQ_MODIFY_QP_MODIFY_MASK_TRAFFIC_CLASS
value|UINT32_C(0x200)
comment|/* destination MAC change. */
define|#
directive|define
name|CMDQ_MODIFY_QP_MODIFY_MASK_DEST_MAC
value|UINT32_C(0x400)
comment|/* unused is 1 b */
define|#
directive|define
name|CMDQ_MODIFY_QP_MODIFY_MASK_UNUSED
value|UINT32_C(0x800)
comment|/* Path MTU change. */
define|#
directive|define
name|CMDQ_MODIFY_QP_MODIFY_MASK_PATH_MTU
value|UINT32_C(0x1000)
comment|/* Timeout change. */
define|#
directive|define
name|CMDQ_MODIFY_QP_MODIFY_MASK_TIMEOUT
value|UINT32_C(0x2000)
comment|/* Retry count change. */
define|#
directive|define
name|CMDQ_MODIFY_QP_MODIFY_MASK_RETRY_CNT
value|UINT32_C(0x4000)
comment|/* RNR Retry change. */
define|#
directive|define
name|CMDQ_MODIFY_QP_MODIFY_MASK_RNR_RETRY
value|UINT32_C(0x8000)
comment|/* RQ start packet sequence number change. */
define|#
directive|define
name|CMDQ_MODIFY_QP_MODIFY_MASK_RQ_PSN
value|UINT32_C(0x10000)
comment|/* Max outstanding RDMA read atomic change. */
define|#
directive|define
name|CMDQ_MODIFY_QP_MODIFY_MASK_MAX_RD_ATOMIC
value|UINT32_C(0x20000)
comment|/* RNR minimum timer change. */
define|#
directive|define
name|CMDQ_MODIFY_QP_MODIFY_MASK_MIN_RNR_TIMER
value|UINT32_C(0x40000)
comment|/* SQ start packet sequence number change. */
define|#
directive|define
name|CMDQ_MODIFY_QP_MODIFY_MASK_SQ_PSN
value|UINT32_C(0x80000)
comment|/* Max destination outstanding RDMA read atomic change. */
define|#
directive|define
name|CMDQ_MODIFY_QP_MODIFY_MASK_MAX_DEST_RD_ATOMIC
value|UINT32_C(0x100000)
comment|/* Max send WQE change. */
define|#
directive|define
name|CMDQ_MODIFY_QP_MODIFY_MASK_SQ_SIZE
value|UINT32_C(0x200000)
comment|/* Max recv WQE change. */
define|#
directive|define
name|CMDQ_MODIFY_QP_MODIFY_MASK_RQ_SIZE
value|UINT32_C(0x400000)
comment|/* Max recv SGEs per SWQE change. */
define|#
directive|define
name|CMDQ_MODIFY_QP_MODIFY_MASK_SQ_SGE
value|UINT32_C(0x800000)
comment|/* Max send SGEs per RWQE change. */
define|#
directive|define
name|CMDQ_MODIFY_QP_MODIFY_MASK_RQ_SGE
value|UINT32_C(0x1000000)
comment|/* Max inline data length change. */
define|#
directive|define
name|CMDQ_MODIFY_QP_MODIFY_MASK_MAX_INLINE_DATA
value|UINT32_C(0x2000000)
comment|/* Destination QP id change. */
define|#
directive|define
name|CMDQ_MODIFY_QP_MODIFY_MASK_DEST_QP_ID
value|UINT32_C(0x4000000)
comment|/* Source MAC change. */
define|#
directive|define
name|CMDQ_MODIFY_QP_MODIFY_MASK_SRC_MAC
value|UINT32_C(0x8000000)
comment|/* Source VLAN id change. */
define|#
directive|define
name|CMDQ_MODIFY_QP_MODIFY_MASK_VLAN_ID
value|UINT32_C(0x10000000)
comment|/* Congestion control RoCE v2 change. */
define|#
directive|define
name|CMDQ_MODIFY_QP_MODIFY_MASK_ENABLE_CC
value|UINT32_C(0x20000000)
comment|/* IP TOS ECN change */
define|#
directive|define
name|CMDQ_MODIFY_QP_MODIFY_MASK_TOS_ECN
value|UINT32_C(0x40000000)
comment|/* IP TOS DSCP change */
define|#
directive|define
name|CMDQ_MODIFY_QP_MODIFY_MASK_TOS_DSCP
value|UINT32_C(0x80000000)
name|uint32_t
name|qp_cid
decl_stmt|;
comment|/* QP context id. */
name|uint8_t
name|network_type_en_sqd_async_notify_new_state
decl_stmt|;
comment|/* network type. */
comment|/* New QP state. */
define|#
directive|define
name|CMDQ_MODIFY_QP_NEW_STATE_MASK
value|UINT32_C(0xf)
define|#
directive|define
name|CMDQ_MODIFY_QP_NEW_STATE_SFT
value|0
comment|/* Reset. */
define|#
directive|define
name|CMDQ_MODIFY_QP_NEW_STATE_RESET
value|UINT32_C(0x0)
comment|/* Init. */
define|#
directive|define
name|CMDQ_MODIFY_QP_NEW_STATE_INIT
value|UINT32_C(0x1)
comment|/* Ready To Receive. */
define|#
directive|define
name|CMDQ_MODIFY_QP_NEW_STATE_RTR
value|UINT32_C(0x2)
comment|/* Ready To Send. */
define|#
directive|define
name|CMDQ_MODIFY_QP_NEW_STATE_RTS
value|UINT32_C(0x3)
comment|/* SQ Drain. */
define|#
directive|define
name|CMDQ_MODIFY_QP_NEW_STATE_SQD
value|UINT32_C(0x4)
comment|/* SQ Error. */
define|#
directive|define
name|CMDQ_MODIFY_QP_NEW_STATE_SQE
value|UINT32_C(0x5)
comment|/* Error. */
define|#
directive|define
name|CMDQ_MODIFY_QP_NEW_STATE_ERR
value|UINT32_C(0x6)
comment|/* Enable SQ drain asynchronous notification. */
define|#
directive|define
name|CMDQ_MODIFY_QP_EN_SQD_ASYNC_NOTIFY
value|UINT32_C(0x10)
comment|/* unused1 is 1 b */
comment|/* network type. */
define|#
directive|define
name|CMDQ_MODIFY_QP_NETWORK_TYPE_MASK
value|UINT32_C(0xc0)
define|#
directive|define
name|CMDQ_MODIFY_QP_NETWORK_TYPE_SFT
value|6
comment|/* RoCEv1. */
define|#
directive|define
name|CMDQ_MODIFY_QP_NETWORK_TYPE_ROCEV1
value|(UINT32_C(0x0)<< 6)
comment|/* RoCEv2 IPv4. */
define|#
directive|define
name|CMDQ_MODIFY_QP_NETWORK_TYPE_ROCEV2_IPV4
value|(UINT32_C(0x2)<< 6)
comment|/* RoCEv2 IPv6. */
define|#
directive|define
name|CMDQ_MODIFY_QP_NETWORK_TYPE_ROCEV2_IPV6
value|(UINT32_C(0x3)<< 6)
name|uint8_t
name|access
decl_stmt|;
comment|/* Access flags. */
comment|/* Local write access. */
define|#
directive|define
name|CMDQ_MODIFY_QP_ACCESS_LOCAL_WRITE
value|UINT32_C(0x1)
comment|/* Remote write access. */
define|#
directive|define
name|CMDQ_MODIFY_QP_ACCESS_REMOTE_WRITE
value|UINT32_C(0x2)
comment|/* Remote read access. */
define|#
directive|define
name|CMDQ_MODIFY_QP_ACCESS_REMOTE_READ
value|UINT32_C(0x4)
comment|/* Remote atomic access. */
define|#
directive|define
name|CMDQ_MODIFY_QP_ACCESS_REMOTE_ATOMIC
value|UINT32_C(0x8)
name|uint16_t
name|pkey
decl_stmt|;
comment|/* P_KEY. */
name|uint32_t
name|qkey
decl_stmt|;
comment|/* Q_KEY. */
name|uint32_t
name|dgid
index|[
literal|4
index|]
decl_stmt|;
comment|/* Destination GID. */
name|uint32_t
name|flow_label
decl_stmt|;
comment|/* Flow label. */
name|uint16_t
name|sgid_index
decl_stmt|;
comment|/* Source GID index. */
name|uint8_t
name|hop_limit
decl_stmt|;
comment|/* Hop limit. */
name|uint8_t
name|traffic_class
decl_stmt|;
comment|/* Traffic class. */
name|uint16_t
name|dest_mac
index|[
literal|3
index|]
decl_stmt|;
comment|/* Destination MAC address. */
name|uint8_t
name|tos_dscp_tos_ecn
decl_stmt|;
comment|/* IP TOS DSCP. */
comment|/* IP TOS ECN. Valid values are 1 or 2 when ECN is enabled. */
define|#
directive|define
name|CMDQ_MODIFY_QP_TOS_ECN_MASK
value|UINT32_C(0x3)
define|#
directive|define
name|CMDQ_MODIFY_QP_TOS_ECN_SFT
value|0
comment|/* IP TOS DSCP. */
define|#
directive|define
name|CMDQ_MODIFY_QP_TOS_DSCP_MASK
value|UINT32_C(0xfc)
define|#
directive|define
name|CMDQ_MODIFY_QP_TOS_DSCP_SFT
value|2
name|uint8_t
name|path_mtu
decl_stmt|;
comment|/* Path MTU. */
comment|/* unused4 is 4 b */
comment|/* Path MTU. */
define|#
directive|define
name|CMDQ_MODIFY_QP_PATH_MTU_MASK
value|UINT32_C(0xf0)
define|#
directive|define
name|CMDQ_MODIFY_QP_PATH_MTU_SFT
value|4
comment|/* 256. */
define|#
directive|define
name|CMDQ_MODIFY_QP_PATH_MTU_MTU_256
value|(UINT32_C(0x0)<< 4)
comment|/* 512. */
define|#
directive|define
name|CMDQ_MODIFY_QP_PATH_MTU_MTU_512
value|(UINT32_C(0x1)<< 4)
comment|/* 1024. */
define|#
directive|define
name|CMDQ_MODIFY_QP_PATH_MTU_MTU_1024
value|(UINT32_C(0x2)<< 4)
comment|/* 2048. */
define|#
directive|define
name|CMDQ_MODIFY_QP_PATH_MTU_MTU_2048
value|(UINT32_C(0x3)<< 4)
comment|/* 4096. */
define|#
directive|define
name|CMDQ_MODIFY_QP_PATH_MTU_MTU_4096
value|(UINT32_C(0x4)<< 4)
comment|/* 8192. */
define|#
directive|define
name|CMDQ_MODIFY_QP_PATH_MTU_MTU_8192
value|(UINT32_C(0x5)<< 4)
name|uint8_t
name|timeout
decl_stmt|;
comment|/* Timeout value for SWQEs. */
name|uint8_t
name|retry_cnt
decl_stmt|;
comment|/* Max retry count for WQEs. */
name|uint8_t
name|rnr_retry
decl_stmt|;
comment|/* Max RNR retry count for WQEs. */
name|uint8_t
name|min_rnr_timer
decl_stmt|;
comment|/* Min RNR timer that the QP will report to the remote. */
name|uint32_t
name|rq_psn
decl_stmt|;
comment|/* RQ start packet sequence number. */
name|uint32_t
name|sq_psn
decl_stmt|;
comment|/* SQ start packet sequence number. */
name|uint8_t
name|max_rd_atomic
decl_stmt|;
comment|/* Max outstanding RDMA read atomic. */
name|uint8_t
name|max_dest_rd_atomic
decl_stmt|;
comment|/* Max destination outstanding RDMA read atomic. */
name|uint16_t
name|enable_cc
decl_stmt|;
comment|/* unused15 is 15 b */
comment|/* Enable congestion control. */
define|#
directive|define
name|CMDQ_MODIFY_QP_ENABLE_CC
value|UINT32_C(0x1)
comment|/* unused15 is 15 b */
name|uint32_t
name|sq_size
decl_stmt|;
comment|/* Max send WQE. */
name|uint32_t
name|rq_size
decl_stmt|;
comment|/* Max recv WQE. */
name|uint16_t
name|sq_sge
decl_stmt|;
comment|/* Max send SGEs per SWQE. */
name|uint16_t
name|rq_sge
decl_stmt|;
comment|/* Max recv SGEs per RWQE. */
name|uint32_t
name|max_inline_data
decl_stmt|;
comment|/* Max inline data length (upto 120 bytes). */
name|uint32_t
name|dest_qp_id
decl_stmt|;
comment|/* Destination QP id. */
name|uint32_t
name|unused_3
decl_stmt|;
name|uint16_t
name|src_mac
index|[
literal|3
index|]
decl_stmt|;
comment|/* Source MAC. (Unused. Comes from Source GID index) */
name|uint16_t
name|vlan_pcp_vlan_dei_vlan_id
decl_stmt|;
comment|/* VLAN PCP field - Priority Code Point. */
comment|/* VLAN id. (Unused. Comes from Source GID index) */
define|#
directive|define
name|CMDQ_MODIFY_QP_VLAN_ID_MASK
value|UINT32_C(0xfff)
define|#
directive|define
name|CMDQ_MODIFY_QP_VLAN_ID_SFT
value|0
comment|/* VLAN DEI field - Drop Eligibility Indicator. */
define|#
directive|define
name|CMDQ_MODIFY_QP_VLAN_DEI
value|UINT32_C(0x1000)
comment|/* VLAN PCP field - Priority Code Point. */
define|#
directive|define
name|CMDQ_MODIFY_QP_VLAN_PCP_MASK
value|UINT32_C(0xe000)
define|#
directive|define
name|CMDQ_MODIFY_QP_VLAN_PCP_SFT
value|13
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Query QP command (24 bytes) */
end_comment

begin_struct
struct|struct
name|cmdq_query_qp
block|{
name|uint8_t
name|opcode
decl_stmt|;
comment|/* Command opcode. */
comment|/* Query QP command retrieves info about the specified QP. */
define|#
directive|define
name|CMDQ_QUERY_QP_OPCODE_QUERY_QP
value|UINT32_C(0x4)
name|uint8_t
name|cmd_size
decl_stmt|;
comment|/* Size of the command in 16-byte units. */
name|uint16_t
name|flags
decl_stmt|;
comment|/* Flags and attribs of the command. */
name|uint16_t
name|cookie
decl_stmt|;
comment|/* Driver supplied handle to associate the command and the response. */
name|uint8_t
name|resp_size
decl_stmt|;
comment|/* Size of the response buffer in 16-byte units. */
name|uint8_t
name|reserved8
decl_stmt|;
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* Host address of the response. */
name|uint32_t
name|qp_cid
decl_stmt|;
comment|/* QP context id */
name|uint32_t
name|unused_0
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Create SRQ command (48 bytes) */
end_comment

begin_struct
struct|struct
name|cmdq_create_srq
block|{
name|uint8_t
name|opcode
decl_stmt|;
comment|/* Command opcode. */
comment|/* Create SRQ command allocates a SRQ with the specified parameters. */
define|#
directive|define
name|CMDQ_CREATE_SRQ_OPCODE_CREATE_SRQ
value|UINT32_C(0x5)
name|uint8_t
name|cmd_size
decl_stmt|;
comment|/* Size of the command in 16-byte units. */
name|uint16_t
name|flags
decl_stmt|;
comment|/* Flags and attribs of the command. */
name|uint16_t
name|cookie
decl_stmt|;
comment|/* Driver supplied handle to associate the command and the response. */
name|uint8_t
name|resp_size
decl_stmt|;
comment|/* Size of the response buffer in 16-byte units. */
name|uint8_t
name|reserved8
decl_stmt|;
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* Host address of the response. */
name|uint64_t
name|srq_handle
decl_stmt|;
comment|/* SRQ handle. */
name|uint16_t
name|pg_size_lvl
decl_stmt|;
comment|/* unused11 is 11 b */
comment|/* SRQ PBL indirect levels. */
define|#
directive|define
name|CMDQ_CREATE_SRQ_LVL_MASK
value|UINT32_C(0x3)
define|#
directive|define
name|CMDQ_CREATE_SRQ_LVL_SFT
value|0
comment|/* PBL pointer is physical start address. */
define|#
directive|define
name|CMDQ_CREATE_SRQ_LVL_LVL_0
value|UINT32_C(0x0)
comment|/* PBL pointer points to PTE table. */
define|#
directive|define
name|CMDQ_CREATE_SRQ_LVL_LVL_1
value|UINT32_C(0x1)
comment|/* 	 * PBL pointer points to PDE table with each entry pointing to 	 * PTE tables. 	 */
define|#
directive|define
name|CMDQ_CREATE_SRQ_LVL_LVL_2
value|UINT32_C(0x2)
comment|/* page size. */
define|#
directive|define
name|CMDQ_CREATE_SRQ_PG_SIZE_MASK
value|UINT32_C(0x1c)
define|#
directive|define
name|CMDQ_CREATE_SRQ_PG_SIZE_SFT
value|2
comment|/* 4KB. */
define|#
directive|define
name|CMDQ_CREATE_SRQ_PG_SIZE_PG_4K
value|(UINT32_C(0x0)<< 2)
comment|/* 8KB. */
define|#
directive|define
name|CMDQ_CREATE_SRQ_PG_SIZE_PG_8K
value|(UINT32_C(0x1)<< 2)
comment|/* 64KB. */
define|#
directive|define
name|CMDQ_CREATE_SRQ_PG_SIZE_PG_64K
value|(UINT32_C(0x2)<< 2)
comment|/* 2MB. */
define|#
directive|define
name|CMDQ_CREATE_SRQ_PG_SIZE_PG_2M
value|(UINT32_C(0x3)<< 2)
comment|/* 8MB. */
define|#
directive|define
name|CMDQ_CREATE_SRQ_PG_SIZE_PG_8M
value|(UINT32_C(0x4)<< 2)
comment|/* 1GB. */
define|#
directive|define
name|CMDQ_CREATE_SRQ_PG_SIZE_PG_1G
value|(UINT32_C(0x5)<< 2)
comment|/* unused11 is 11 b */
name|uint16_t
name|eventq_id
decl_stmt|;
comment|/* unused4 is 4 b */
comment|/* eventq_id is 12 b */
define|#
directive|define
name|CMDQ_CREATE_SRQ_EVENTQ_ID_MASK
value|UINT32_C(0xfff)
define|#
directive|define
name|CMDQ_CREATE_SRQ_EVENTQ_ID_SFT
value|0
comment|/* unused4 is 4 b */
name|uint16_t
name|srq_size
decl_stmt|;
comment|/* Max number of SRQ wqes. */
name|uint16_t
name|srq_fwo
decl_stmt|;
comment|/* Offsetof first WQE in the first page of SRQ, in 128 byte units */
name|uint32_t
name|dpi
decl_stmt|;
comment|/* Doorbell page index. */
name|uint32_t
name|pd_id
decl_stmt|;
comment|/* Protection domain id. */
name|uint64_t
name|pbl
decl_stmt|;
comment|/* RQ PBL physical address. */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Destroy SRQ command (24 bytes) */
end_comment

begin_struct
struct|struct
name|cmdq_destroy_srq
block|{
name|uint8_t
name|opcode
decl_stmt|;
comment|/* Command opcode. */
comment|/* Destroy SRQ command deletes and flushes the specified SRQ. */
define|#
directive|define
name|CMDQ_DESTROY_SRQ_OPCODE_DESTROY_SRQ
value|UINT32_C(0x6)
name|uint8_t
name|cmd_size
decl_stmt|;
comment|/* Size of the command in 16-byte units. */
name|uint16_t
name|flags
decl_stmt|;
comment|/* Flags and attribs of the command. */
name|uint16_t
name|cookie
decl_stmt|;
comment|/* Driver supplied handle to associate the command and the response. */
name|uint8_t
name|resp_size
decl_stmt|;
comment|/* Size of the response buffer in 16-byte units. */
name|uint8_t
name|reserved8
decl_stmt|;
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* Host address of the response. */
name|uint32_t
name|srq_cid
decl_stmt|;
comment|/* SRQ context id */
name|uint32_t
name|unused_0
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Query SRQ command (24 bytes) */
end_comment

begin_struct
struct|struct
name|cmdq_query_srq
block|{
name|uint8_t
name|opcode
decl_stmt|;
comment|/* Command opcode. */
comment|/* Query SRP command retrieves info about the specified SRQ. */
define|#
directive|define
name|CMDQ_QUERY_SRQ_OPCODE_QUERY_SRQ
value|UINT32_C(0x8)
name|uint8_t
name|cmd_size
decl_stmt|;
comment|/* Size of the command in 16-byte units. */
name|uint16_t
name|flags
decl_stmt|;
comment|/* Flags and attribs of the command. */
name|uint16_t
name|cookie
decl_stmt|;
comment|/* Driver supplied handle to associate the command and the response. */
name|uint8_t
name|resp_size
decl_stmt|;
comment|/* Size of the response buffer in 16-byte units. */
name|uint8_t
name|reserved8
decl_stmt|;
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* Host address of the response. */
name|uint32_t
name|srq_cid
decl_stmt|;
comment|/* SRQ context id */
name|uint32_t
name|unused_0
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Create CQ command (48 bytes) */
end_comment

begin_struct
struct|struct
name|cmdq_create_cq
block|{
name|uint8_t
name|opcode
decl_stmt|;
comment|/* Command opcode. */
comment|/* Create CQ command allocates a CQ with the specified parameters. */
define|#
directive|define
name|CMDQ_CREATE_CQ_OPCODE_CREATE_CQ
value|UINT32_C(0x9)
name|uint8_t
name|cmd_size
decl_stmt|;
comment|/* Size of the command in 16-byte units. */
name|uint16_t
name|flags
decl_stmt|;
comment|/* Flags and attribs of the command. */
name|uint16_t
name|cookie
decl_stmt|;
comment|/* Driver supplied handle to associate the command and the response. */
name|uint8_t
name|resp_size
decl_stmt|;
comment|/* Size of the response buffer in 16-byte units. */
name|uint8_t
name|reserved8
decl_stmt|;
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* Host address of the response. */
name|uint64_t
name|cq_handle
decl_stmt|;
comment|/* CQ handle. */
name|uint32_t
name|pg_size_lvl
decl_stmt|;
comment|/* unused27 is 27 b */
comment|/* PBL indirect levels. */
define|#
directive|define
name|CMDQ_CREATE_CQ_LVL_MASK
value|UINT32_C(0x3)
define|#
directive|define
name|CMDQ_CREATE_CQ_LVL_SFT
value|0
comment|/* PBL pointer is physical start address. */
define|#
directive|define
name|CMDQ_CREATE_CQ_LVL_LVL_0
value|UINT32_C(0x0)
comment|/* PBL pointer points to PTE table. */
define|#
directive|define
name|CMDQ_CREATE_CQ_LVL_LVL_1
value|UINT32_C(0x1)
comment|/* 	 * PBL pointer points to PDE table with each entry pointing to 	 * PTE tables. 	 */
define|#
directive|define
name|CMDQ_CREATE_CQ_LVL_LVL_2
value|UINT32_C(0x2)
comment|/* page size. */
define|#
directive|define
name|CMDQ_CREATE_CQ_PG_SIZE_MASK
value|UINT32_C(0x1c)
define|#
directive|define
name|CMDQ_CREATE_CQ_PG_SIZE_SFT
value|2
comment|/* 4KB. */
define|#
directive|define
name|CMDQ_CREATE_CQ_PG_SIZE_PG_4K
value|(UINT32_C(0x0)<< 2)
comment|/* 8KB. */
define|#
directive|define
name|CMDQ_CREATE_CQ_PG_SIZE_PG_8K
value|(UINT32_C(0x1)<< 2)
comment|/* 64KB. */
define|#
directive|define
name|CMDQ_CREATE_CQ_PG_SIZE_PG_64K
value|(UINT32_C(0x2)<< 2)
comment|/* 2MB. */
define|#
directive|define
name|CMDQ_CREATE_CQ_PG_SIZE_PG_2M
value|(UINT32_C(0x3)<< 2)
comment|/* 8MB. */
define|#
directive|define
name|CMDQ_CREATE_CQ_PG_SIZE_PG_8M
value|(UINT32_C(0x4)<< 2)
comment|/* 1GB. */
define|#
directive|define
name|CMDQ_CREATE_CQ_PG_SIZE_PG_1G
value|(UINT32_C(0x5)<< 2)
comment|/* unused27 is 27 b */
name|uint32_t
name|cq_fco_cnq_id
decl_stmt|;
comment|/* Offset of first CQE in the first Page, in 32 byte units */
comment|/* cnq_id is 12 b */
define|#
directive|define
name|CMDQ_CREATE_CQ_CNQ_ID_MASK
value|UINT32_C(0xfff)
define|#
directive|define
name|CMDQ_CREATE_CQ_CNQ_ID_SFT
value|0
comment|/* Offset of first CQE in the first Page, in 32 byte units */
define|#
directive|define
name|CMDQ_CREATE_CQ_CQ_FCO_MASK
value|UINT32_C(0xfffff000)
define|#
directive|define
name|CMDQ_CREATE_CQ_CQ_FCO_SFT
value|12
name|uint32_t
name|dpi
decl_stmt|;
comment|/* Doorbell page index. */
name|uint32_t
name|cq_size
decl_stmt|;
comment|/* Max number of CQ wqes. */
name|uint64_t
name|pbl
decl_stmt|;
comment|/* CQ PBL physical address. */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Destroy CQ command (24 bytes) */
end_comment

begin_struct
struct|struct
name|cmdq_destroy_cq
block|{
name|uint8_t
name|opcode
decl_stmt|;
comment|/* Command opcode. */
comment|/* Destroy CQ command deletes and flushes the specified CQ. */
define|#
directive|define
name|CMDQ_DESTROY_CQ_OPCODE_DESTROY_CQ
value|UINT32_C(0xa)
name|uint8_t
name|cmd_size
decl_stmt|;
comment|/* Size of the command in 16-byte units. */
name|uint16_t
name|flags
decl_stmt|;
comment|/* Flags and attribs of the command. */
name|uint16_t
name|cookie
decl_stmt|;
comment|/* Driver supplied handle to associate the command and the response. */
name|uint8_t
name|resp_size
decl_stmt|;
comment|/* Size of the response buffer in 16-byte units. */
name|uint8_t
name|reserved8
decl_stmt|;
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* Host address of the response. */
name|uint32_t
name|cq_cid
decl_stmt|;
comment|/* CQ context id */
name|uint32_t
name|unused_0
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Resize CQ command (40 bytes) */
end_comment

begin_struct
struct|struct
name|cmdq_resize_cq
block|{
name|uint8_t
name|opcode
decl_stmt|;
comment|/* Command opcode. */
comment|/* Resize CQ command resizes the specified CQ. */
define|#
directive|define
name|CMDQ_RESIZE_CQ_OPCODE_RESIZE_CQ
value|UINT32_C(0xc)
name|uint8_t
name|cmd_size
decl_stmt|;
comment|/* Size of the command in 16-byte units. */
name|uint16_t
name|flags
decl_stmt|;
comment|/* Flags and attribs of the command. */
name|uint16_t
name|cookie
decl_stmt|;
comment|/* Driver supplied handle to associate the command and the response. */
name|uint8_t
name|resp_size
decl_stmt|;
comment|/* Size of the response buffer in 16-byte units. */
name|uint8_t
name|reserved8
decl_stmt|;
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* Host address of the response. */
name|uint32_t
name|cq_cid
decl_stmt|;
comment|/* CQ context id */
name|uint32_t
name|new_cq_size_pg_size_lvl
decl_stmt|;
comment|/* PBL indirect levels. */
define|#
directive|define
name|CMDQ_RESIZE_CQ_LVL_MASK
value|UINT32_C(0x3)
define|#
directive|define
name|CMDQ_RESIZE_CQ_LVL_SFT
value|0
comment|/* PBL pointer is physical start address. */
define|#
directive|define
name|CMDQ_RESIZE_CQ_LVL_LVL_0
value|UINT32_C(0x0)
comment|/* PBL pointer points to PTE table. */
define|#
directive|define
name|CMDQ_RESIZE_CQ_LVL_LVL_1
value|UINT32_C(0x1)
comment|/* 	 * PBL pointer points to PDE table with each entry pointing to 	 * PTE tables. 	 */
define|#
directive|define
name|CMDQ_RESIZE_CQ_LVL_LVL_2
value|UINT32_C(0x2)
comment|/* page size. */
define|#
directive|define
name|CMDQ_RESIZE_CQ_PG_SIZE_MASK
value|UINT32_C(0x1c)
define|#
directive|define
name|CMDQ_RESIZE_CQ_PG_SIZE_SFT
value|2
comment|/* 4KB. */
define|#
directive|define
name|CMDQ_RESIZE_CQ_PG_SIZE_PG_4K
value|(UINT32_C(0x0)<< 2)
comment|/* 8KB. */
define|#
directive|define
name|CMDQ_RESIZE_CQ_PG_SIZE_PG_8K
value|(UINT32_C(0x1)<< 2)
comment|/* 64KB. */
define|#
directive|define
name|CMDQ_RESIZE_CQ_PG_SIZE_PG_64K
value|(UINT32_C(0x2)<< 2)
comment|/* 2MB. */
define|#
directive|define
name|CMDQ_RESIZE_CQ_PG_SIZE_PG_2M
value|(UINT32_C(0x3)<< 2)
comment|/* 8MB. */
define|#
directive|define
name|CMDQ_RESIZE_CQ_PG_SIZE_PG_8M
value|(UINT32_C(0x4)<< 2)
comment|/* 1GB. */
define|#
directive|define
name|CMDQ_RESIZE_CQ_PG_SIZE_PG_1G
value|(UINT32_C(0x5)<< 2)
comment|/* New max number of CQ wqes. */
define|#
directive|define
name|CMDQ_RESIZE_CQ_NEW_CQ_SIZE_MASK
value|UINT32_C(0x1fffe0)
define|#
directive|define
name|CMDQ_RESIZE_CQ_NEW_CQ_SIZE_SFT
value|5
name|uint64_t
name|new_pbl
decl_stmt|;
comment|/* CQ PBL physical address. */
name|uint32_t
name|new_cq_fco
decl_stmt|;
comment|/* Offset of first CQE in the first Page, in 32 byte units */
name|uint32_t
name|unused_2
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Allocate MRW command (32 bytes) */
end_comment

begin_struct
struct|struct
name|cmdq_allocate_mrw
block|{
name|uint8_t
name|opcode
decl_stmt|;
comment|/* Command opcode. */
comment|/* 	 * Allocate MRW command allocates a MR/MW with the specified 	 * parameters and returns the region's L_KEY/R_KEY 	 */
define|#
directive|define
name|CMDQ_ALLOCATE_MRW_OPCODE_ALLOCATE_MRW
value|UINT32_C(0xd)
name|uint8_t
name|cmd_size
decl_stmt|;
comment|/* Size of the command in 16-byte units. */
name|uint16_t
name|flags
decl_stmt|;
comment|/* Flags and attribs of the command. */
name|uint16_t
name|cookie
decl_stmt|;
comment|/* Driver supplied handle to associate the command and the response. */
name|uint8_t
name|resp_size
decl_stmt|;
comment|/* Size of the response buffer in 16-byte units. */
name|uint8_t
name|reserved8
decl_stmt|;
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* Host address of the response. */
name|uint64_t
name|mrw_handle
decl_stmt|;
comment|/* MRW handle. */
name|uint8_t
name|mrw_flags
decl_stmt|;
comment|/* unused4 is 4 b */
comment|/* Allocate MRW flags. */
define|#
directive|define
name|CMDQ_ALLOCATE_MRW_MRW_FLAGS_MASK
value|UINT32_C(0xf)
define|#
directive|define
name|CMDQ_ALLOCATE_MRW_MRW_FLAGS_SFT
value|0
comment|/* Allocate Memory Region */
define|#
directive|define
name|CMDQ_ALLOCATE_MRW_MRW_FLAGS_MR
value|UINT32_C(0x0)
comment|/* Allocate Physical Memory Region */
define|#
directive|define
name|CMDQ_ALLOCATE_MRW_MRW_FLAGS_PMR
value|UINT32_C(0x1)
comment|/* Allocate Memory Window (type 1) */
define|#
directive|define
name|CMDQ_ALLOCATE_MRW_MRW_FLAGS_MW_TYPE1
value|UINT32_C(0x2)
comment|/* Allocate Memory Window (type 2A) */
define|#
directive|define
name|CMDQ_ALLOCATE_MRW_MRW_FLAGS_MW_TYPE2A
value|UINT32_C(0x3)
comment|/* Allocate Memory Window (type 2B) */
define|#
directive|define
name|CMDQ_ALLOCATE_MRW_MRW_FLAGS_MW_TYPE2B
value|UINT32_C(0x4)
comment|/* unused4 is 4 b */
name|uint8_t
name|access
decl_stmt|;
comment|/* Access flags. */
define|#
directive|define
name|CMDQ_ALLOCATE_MRW_ACCESS_RESERVED_MASK
value|UINT32_C(0x1f)
define|#
directive|define
name|CMDQ_ALLOCATE_MRW_ACCESS_RESERVED_SFT
value|0
comment|/* Consumer owns the key */
define|#
directive|define
name|CMDQ_ALLOCATE_MRW_ACCESS_CONSUMER_OWNED_KEY
value|UINT32_C(0x20)
name|uint16_t
name|unused_1
decl_stmt|;
comment|/* unused16 is 16 b */
name|uint32_t
name|pd_id
decl_stmt|;
comment|/* Protection domain id. */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* De-allocate key command (24 bytes) */
end_comment

begin_struct
struct|struct
name|cmdq_deallocate_key
block|{
name|uint8_t
name|opcode
decl_stmt|;
comment|/* Command opcode. */
comment|/* 	 * De-allocate key command frees a MR/MW entry associated with 	 * the specified key. 	 */
define|#
directive|define
name|CMDQ_DEALLOCATE_KEY_OPCODE_DEALLOCATE_KEY
value|UINT32_C(0xe)
name|uint8_t
name|cmd_size
decl_stmt|;
comment|/* Size of the command in 16-byte units. */
name|uint16_t
name|flags
decl_stmt|;
comment|/* Flags and attribs of the command. */
name|uint16_t
name|cookie
decl_stmt|;
comment|/* Driver supplied handle to associate the command and the response. */
name|uint8_t
name|resp_size
decl_stmt|;
comment|/* Size of the response buffer in 16-byte units. */
name|uint8_t
name|reserved8
decl_stmt|;
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* Host address of the response. */
name|uint8_t
name|mrw_flags
decl_stmt|;
comment|/* unused4 is 4 b */
comment|/* Deallocate MRW flags. */
define|#
directive|define
name|CMDQ_DEALLOCATE_KEY_MRW_FLAGS_MASK
value|UINT32_C(0xf)
define|#
directive|define
name|CMDQ_DEALLOCATE_KEY_MRW_FLAGS_SFT
value|0
comment|/* Deallocate Memory Region */
define|#
directive|define
name|CMDQ_DEALLOCATE_KEY_MRW_FLAGS_MR
value|UINT32_C(0x0)
comment|/* Deallocate Physical Memory Region */
define|#
directive|define
name|CMDQ_DEALLOCATE_KEY_MRW_FLAGS_PMR
value|UINT32_C(0x1)
comment|/* Deallocate Memory Window (type 1) */
define|#
directive|define
name|CMDQ_DEALLOCATE_KEY_MRW_FLAGS_MW_TYPE1
value|UINT32_C(0x2)
comment|/* Deallocate Memory Window (type 2A) */
define|#
directive|define
name|CMDQ_DEALLOCATE_KEY_MRW_FLAGS_MW_TYPE2A
value|UINT32_C(0x3)
comment|/* Deallocate Memory Window (type 2B) */
define|#
directive|define
name|CMDQ_DEALLOCATE_KEY_MRW_FLAGS_MW_TYPE2B
value|UINT32_C(0x4)
comment|/* unused4 is 4 b */
name|uint8_t
name|unused_1
index|[
literal|3
index|]
decl_stmt|;
comment|/* unused24 is 24 b */
name|uint32_t
name|key
decl_stmt|;
comment|/* key is 32 b */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Register MR command (48 bytes) */
end_comment

begin_struct
struct|struct
name|cmdq_register_mr
block|{
name|uint8_t
name|opcode
decl_stmt|;
comment|/* Command opcode. */
comment|/* Register MR command registers memory to the specified MR. */
define|#
directive|define
name|CMDQ_REGISTER_MR_OPCODE_REGISTER_MR
value|UINT32_C(0xf)
name|uint8_t
name|cmd_size
decl_stmt|;
comment|/* Size of the command in 16-byte units. */
name|uint16_t
name|flags
decl_stmt|;
comment|/* Flags and attribs of the command. */
name|uint16_t
name|cookie
decl_stmt|;
comment|/* Driver supplied handle to associate the command and the response. */
name|uint8_t
name|resp_size
decl_stmt|;
comment|/* Size of the response buffer in 16-byte units. */
name|uint8_t
name|reserved8
decl_stmt|;
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* Host address of the response. */
name|uint8_t
name|log2_pg_size_lvl
decl_stmt|;
comment|/* unused1 is 1 b */
comment|/* PBL indirect levels. */
define|#
directive|define
name|CMDQ_REGISTER_MR_LVL_MASK
value|UINT32_C(0x3)
define|#
directive|define
name|CMDQ_REGISTER_MR_LVL_SFT
value|0
comment|/* PBL pointer is physical start address. */
define|#
directive|define
name|CMDQ_REGISTER_MR_LVL_LVL_0
value|UINT32_C(0x0)
comment|/* PBL pointer points to PTE table. */
define|#
directive|define
name|CMDQ_REGISTER_MR_LVL_LVL_1
value|UINT32_C(0x1)
comment|/* 	 * PBL pointer points to PDE table with each entry pointing to 	 * PTE tables. 	 */
define|#
directive|define
name|CMDQ_REGISTER_MR_LVL_LVL_2
value|UINT32_C(0x2)
comment|/* 	 * Log base 2 of page size; 12 is the minimum for 4KB. HW supported 	 * values are enumerated below. 	 */
define|#
directive|define
name|CMDQ_REGISTER_MR_LOG2_PG_SIZE_MASK
value|UINT32_C(0x7c)
define|#
directive|define
name|CMDQ_REGISTER_MR_LOG2_PG_SIZE_SFT
value|2
comment|/* 4KB. */
define|#
directive|define
name|CMDQ_REGISTER_MR_LOG2_PG_SIZE_PG_4K
value|(UINT32_C(0xc)<< 2)
comment|/* 8KB. */
define|#
directive|define
name|CMDQ_REGISTER_MR_LOG2_PG_SIZE_PG_8K
value|(UINT32_C(0xd)<< 2)
comment|/* 64KB. */
define|#
directive|define
name|CMDQ_REGISTER_MR_LOG2_PG_SIZE_PG_64K
value|(UINT32_C(0x10)<< 2)
comment|/* 256KB. */
define|#
directive|define
name|CMDQ_REGISTER_MR_LOG2_PG_SIZE_PG_256K
value|(UINT32_C(0x12)<< 2)
comment|/* 1MB. */
define|#
directive|define
name|CMDQ_REGISTER_MR_LOG2_PG_SIZE_PG_1M
value|(UINT32_C(0x14)<< 2)
comment|/* 2MB. */
define|#
directive|define
name|CMDQ_REGISTER_MR_LOG2_PG_SIZE_PG_2M
value|(UINT32_C(0x15)<< 2)
comment|/* 4MB. */
define|#
directive|define
name|CMDQ_REGISTER_MR_LOG2_PG_SIZE_PG_4M
value|(UINT32_C(0x16)<< 2)
comment|/* 1GB. */
define|#
directive|define
name|CMDQ_REGISTER_MR_LOG2_PG_SIZE_PG_1G
value|(UINT32_C(0x1e)<< 2)
comment|/* unused1 is 1 b */
name|uint8_t
name|access
decl_stmt|;
comment|/* Access flags. */
comment|/* Local write access. */
define|#
directive|define
name|CMDQ_REGISTER_MR_ACCESS_LOCAL_WRITE
value|UINT32_C(0x1)
comment|/* Remote read access. */
define|#
directive|define
name|CMDQ_REGISTER_MR_ACCESS_REMOTE_READ
value|UINT32_C(0x2)
comment|/* Remote write access. */
define|#
directive|define
name|CMDQ_REGISTER_MR_ACCESS_REMOTE_WRITE
value|UINT32_C(0x4)
comment|/* Remote atomic access. */
define|#
directive|define
name|CMDQ_REGISTER_MR_ACCESS_REMOTE_ATOMIC
value|UINT32_C(0x8)
comment|/* Bind access allowed. */
define|#
directive|define
name|CMDQ_REGISTER_MR_ACCESS_MW_BIND
value|UINT32_C(0x10)
comment|/* Indicate Zero Based Virtual Address (ZBVA). */
define|#
directive|define
name|CMDQ_REGISTER_MR_ACCESS_ZERO_BASED
value|UINT32_C(0x20)
name|uint16_t
name|log2_pbl_pg_size
decl_stmt|;
comment|/* unused11 is 11 b */
comment|/* 	 * Log base 2 of PBL page size; 12 is the minimum for 4KB. HW supported 	 * values are enumerated below 	 */
define|#
directive|define
name|CMDQ_REGISTER_MR_LOG2_PBL_PG_SIZE_MASK
value|UINT32_C(0x1f)
define|#
directive|define
name|CMDQ_REGISTER_MR_LOG2_PBL_PG_SIZE_SFT
value|0
comment|/* 4KB. */
define|#
directive|define
name|CMDQ_REGISTER_MR_LOG2_PBL_PG_SIZE_PG_4K
value|UINT32_C(0xc)
comment|/* 8KB. */
define|#
directive|define
name|CMDQ_REGISTER_MR_LOG2_PBL_PG_SIZE_PG_8K
value|UINT32_C(0xd)
comment|/* 64KB. */
define|#
directive|define
name|CMDQ_REGISTER_MR_LOG2_PBL_PG_SIZE_PG_64K
value|UINT32_C(0x10)
comment|/* 256KB. */
define|#
directive|define
name|CMDQ_REGISTER_MR_LOG2_PBL_PG_SIZE_PG_256K
value|UINT32_C(0x12)
comment|/* 1MB. */
define|#
directive|define
name|CMDQ_REGISTER_MR_LOG2_PBL_PG_SIZE_PG_1M
value|UINT32_C(0x14)
comment|/* 2MB. */
define|#
directive|define
name|CMDQ_REGISTER_MR_LOG2_PBL_PG_SIZE_PG_2M
value|UINT32_C(0x15)
comment|/* 4MB. */
define|#
directive|define
name|CMDQ_REGISTER_MR_LOG2_PBL_PG_SIZE_PG_4M
value|UINT32_C(0x16)
comment|/* 1GB. */
define|#
directive|define
name|CMDQ_REGISTER_MR_LOG2_PBL_PG_SIZE_PG_1G
value|UINT32_C(0x1e)
comment|/* unused11 is 11 b */
name|uint32_t
name|key
decl_stmt|;
comment|/* KEY of the MR. */
name|uint64_t
name|pbl
decl_stmt|;
comment|/* Page table of the MR memory. */
name|uint64_t
name|va
decl_stmt|;
comment|/* Virtual address of the MR. */
name|uint64_t
name|mr_size
decl_stmt|;
comment|/* Size of the MR. */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Deregister MR command (24 bytes) */
end_comment

begin_struct
struct|struct
name|cmdq_deregister_mr
block|{
name|uint8_t
name|opcode
decl_stmt|;
comment|/* Command opcode. */
comment|/* Deregister MR command de-registers memory from the specified MR. */
define|#
directive|define
name|CMDQ_DEREGISTER_MR_OPCODE_DEREGISTER_MR
value|UINT32_C(0x10)
name|uint8_t
name|cmd_size
decl_stmt|;
comment|/* Size of the command in 16-byte units. */
name|uint16_t
name|flags
decl_stmt|;
comment|/* Flags and attribs of the command. */
name|uint16_t
name|cookie
decl_stmt|;
comment|/* Driver supplied handle to associate the command and the response. */
name|uint8_t
name|resp_size
decl_stmt|;
comment|/* Size of the response buffer in 16-byte units. */
name|uint8_t
name|reserved8
decl_stmt|;
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* Host address of the response. */
name|uint32_t
name|lkey
decl_stmt|;
comment|/* L_KEY of the MR. */
name|uint32_t
name|unused_0
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Add GID command (48 bytes) */
end_comment

begin_struct
struct|struct
name|cmdq_add_gid
block|{
name|uint8_t
name|opcode
decl_stmt|;
comment|/* Command opcode. */
comment|/* Add GID command adds a GID to the local address table. */
define|#
directive|define
name|CMDQ_ADD_GID_OPCODE_ADD_GID
value|UINT32_C(0x11)
name|uint8_t
name|cmd_size
decl_stmt|;
comment|/* Size of the command in 16-byte units. */
name|uint16_t
name|flags
decl_stmt|;
comment|/* Flags and attribs of the command. */
name|uint16_t
name|cookie
decl_stmt|;
comment|/* Driver supplied handle to associate the command and the response. */
name|uint8_t
name|resp_size
decl_stmt|;
comment|/* Size of the response buffer in 16-byte units. */
name|uint8_t
name|reserved8
decl_stmt|;
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* Host address of the response. */
name|uint32_t
name|gid
index|[
literal|4
index|]
decl_stmt|;
comment|/* GID */
name|uint16_t
name|src_mac
index|[
literal|3
index|]
decl_stmt|;
comment|/* Source MAC. */
name|uint16_t
name|vlan
decl_stmt|;
comment|/* flags. */
comment|/* Source VLAN id. */
define|#
directive|define
name|CMDQ_ADD_GID_VLAN_VLAN_ID_MASK
value|UINT32_C(0xfff)
define|#
directive|define
name|CMDQ_ADD_GID_VLAN_VLAN_ID_SFT
value|0
comment|/* This set of bits select the TPID of the VLAN Tag. */
define|#
directive|define
name|CMDQ_ADD_GID_VLAN_TPID_MASK
value|UINT32_C(0x7000)
define|#
directive|define
name|CMDQ_ADD_GID_VLAN_TPID_SFT
value|12
comment|/* TPID = 0x88A8. */
define|#
directive|define
name|CMDQ_ADD_GID_VLAN_TPID_TPID_88A8
value|(UINT32_C(0x0)<< 12)
comment|/* TPID = 0x8100. */
define|#
directive|define
name|CMDQ_ADD_GID_VLAN_TPID_TPID_8100
value|(UINT32_C(0x1)<< 12)
comment|/* TPID = 0x9100. */
define|#
directive|define
name|CMDQ_ADD_GID_VLAN_TPID_TPID_9100
value|(UINT32_C(0x2)<< 12)
comment|/* TPID = 0x9200. */
define|#
directive|define
name|CMDQ_ADD_GID_VLAN_TPID_TPID_9200
value|(UINT32_C(0x3)<< 12)
comment|/* TPID = 0x9300. */
define|#
directive|define
name|CMDQ_ADD_GID_VLAN_TPID_TPID_9300
value|(UINT32_C(0x4)<< 12)
comment|/* TPID = Configurable 1. */
define|#
directive|define
name|CMDQ_ADD_GID_VLAN_TPID_TPID_CFG1
value|(UINT32_C(0x5)<< 12)
comment|/* TPID = Configurable 2. */
define|#
directive|define
name|CMDQ_ADD_GID_VLAN_TPID_TPID_CFG2
value|(UINT32_C(0x6)<< 12)
comment|/* TPID = Configurable 3. */
define|#
directive|define
name|CMDQ_ADD_GID_VLAN_TPID_TPID_CFG3
value|(UINT32_C(0x7)<< 12)
define|#
directive|define
name|CMDQ_ADD_GID_VLAN_TPID_LAST
value|CMDQ_ADD_GID_VLAN_TPID_TPID_CFG3
comment|/* 	 * Setting this bit to 1 enables insertion of a VLAN Tag to a RoCE 	 * header. 	 */
define|#
directive|define
name|CMDQ_ADD_GID_VLAN_VLAN_EN
value|UINT32_C(0x8000)
name|uint16_t
name|ipid
decl_stmt|;
comment|/* Identifier field in the IP header. */
name|uint16_t
name|stats_ctx
decl_stmt|;
comment|/* Stats context ID to use with this SGID */
comment|/* stats_ctx_id is 15 b */
define|#
directive|define
name|CMDQ_ADD_GID_STATS_CTX_STATS_CTX_ID_MASK
value|UINT32_C(0x7fff)
define|#
directive|define
name|CMDQ_ADD_GID_STATS_CTX_STATS_CTX_ID_SFT
value|0
comment|/* 	 * Setting this bit to 1 enables use of own stats context ID instead of 	 * per-function 	 */
define|#
directive|define
name|CMDQ_ADD_GID_STATS_CTX_STATS_CTX_VALID
value|UINT32_C(0x8000)
name|uint32_t
name|unused_0
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Delete GID command (24 bytes) */
end_comment

begin_struct
struct|struct
name|cmdq_delete_gid
block|{
name|uint8_t
name|opcode
decl_stmt|;
comment|/* Command opcode. */
comment|/* Delete GID command deletes a GID from the local address table. */
define|#
directive|define
name|CMDQ_DELETE_GID_OPCODE_DELETE_GID
value|UINT32_C(0x12)
name|uint8_t
name|cmd_size
decl_stmt|;
comment|/* Size of the command in 16-byte units. */
name|uint16_t
name|flags
decl_stmt|;
comment|/* Flags and attribs of the command. */
name|uint16_t
name|cookie
decl_stmt|;
comment|/* Driver supplied handle to associate the command and the response. */
name|uint8_t
name|resp_size
decl_stmt|;
comment|/* Size of the response buffer in 16-byte units. */
name|uint8_t
name|reserved8
decl_stmt|;
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* Host address of the response. */
name|uint16_t
name|gid_index
decl_stmt|;
comment|/* GID index */
name|uint16_t
name|unused_0
decl_stmt|;
comment|/* unused16 is 16 b */
name|uint32_t
name|unused_1
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Modify GID command (48 bytes) */
end_comment

begin_struct
struct|struct
name|cmdq_modify_gid
block|{
name|uint8_t
name|opcode
decl_stmt|;
comment|/* Command opcode. */
comment|/* Modify GID command modifies a GID in the local address table. */
define|#
directive|define
name|CMDQ_MODIFY_GID_OPCODE_MODIFY_GID
value|UINT32_C(0x17)
name|uint8_t
name|cmd_size
decl_stmt|;
comment|/* Size of the command in 16-byte units. */
name|uint16_t
name|flags
decl_stmt|;
comment|/* Flags and attribs of the command. */
name|uint16_t
name|cookie
decl_stmt|;
comment|/* Driver supplied handle to associate the command and the response. */
name|uint8_t
name|resp_size
decl_stmt|;
comment|/* Size of the response buffer in 16-byte units. */
name|uint8_t
name|reserved8
decl_stmt|;
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* Host address of the response. */
name|uint32_t
name|gid
index|[
literal|4
index|]
decl_stmt|;
comment|/* GID */
name|uint16_t
name|src_mac
index|[
literal|3
index|]
decl_stmt|;
comment|/* Source MAC. */
name|uint16_t
name|vlan
decl_stmt|;
comment|/* flags. */
comment|/* Source VLAN id. */
define|#
directive|define
name|CMDQ_MODIFY_GID_VLAN_VLAN_ID_MASK
value|UINT32_C(0xfff)
define|#
directive|define
name|CMDQ_MODIFY_GID_VLAN_VLAN_ID_SFT
value|0
comment|/* This set of bits select the TPID of the VLAN Tag. */
define|#
directive|define
name|CMDQ_MODIFY_GID_VLAN_TPID_MASK
value|UINT32_C(0x7000)
define|#
directive|define
name|CMDQ_MODIFY_GID_VLAN_TPID_SFT
value|12
comment|/* TPID = 0x88A8. */
define|#
directive|define
name|CMDQ_MODIFY_GID_VLAN_TPID_TPID_88A8
value|(UINT32_C(0x0)<< 12)
comment|/* TPID = 0x8100. */
define|#
directive|define
name|CMDQ_MODIFY_GID_VLAN_TPID_TPID_8100
value|(UINT32_C(0x1)<< 12)
comment|/* TPID = 0x9100. */
define|#
directive|define
name|CMDQ_MODIFY_GID_VLAN_TPID_TPID_9100
value|(UINT32_C(0x2)<< 12)
comment|/* TPID = 0x9200. */
define|#
directive|define
name|CMDQ_MODIFY_GID_VLAN_TPID_TPID_9200
value|(UINT32_C(0x3)<< 12)
comment|/* TPID = 0x9300. */
define|#
directive|define
name|CMDQ_MODIFY_GID_VLAN_TPID_TPID_9300
value|(UINT32_C(0x4)<< 12)
comment|/* TPID = Configurable 1. */
define|#
directive|define
name|CMDQ_MODIFY_GID_VLAN_TPID_TPID_CFG1
value|(UINT32_C(0x5)<< 12)
comment|/* TPID = Configurable 2. */
define|#
directive|define
name|CMDQ_MODIFY_GID_VLAN_TPID_TPID_CFG2
value|(UINT32_C(0x6)<< 12)
comment|/* TPID = Configurable 3. */
define|#
directive|define
name|CMDQ_MODIFY_GID_VLAN_TPID_TPID_CFG3
value|(UINT32_C(0x7)<< 12)
define|#
directive|define
name|CMDQ_MODIFY_GID_VLAN_TPID_LAST
value|CMDQ_MODIFY_GID_VLAN_TPID_TPID_CFG3
comment|/* 	 * Setting this bit to 1 enables insertion of a VLAN Tag to a RoCE 	 * header. 	 */
define|#
directive|define
name|CMDQ_MODIFY_GID_VLAN_VLAN_EN
value|UINT32_C(0x8000)
name|uint16_t
name|ipid
decl_stmt|;
comment|/* Identifier field in the IP header. */
name|uint16_t
name|gid_index
decl_stmt|;
comment|/* GID index */
name|uint16_t
name|stats_ctx
decl_stmt|;
comment|/* Stats context ID to use with this SGID */
comment|/* stats_ctx_id is 15 b */
define|#
directive|define
name|CMDQ_MODIFY_GID_STATS_CTX_STATS_CTX_ID_MASK
value|UINT32_C(0x7fff)
define|#
directive|define
name|CMDQ_MODIFY_GID_STATS_CTX_STATS_CTX_ID_SFT
value|0
comment|/* 	 * Setting this bit to 1 enables use of own stats context ID instead of 	 * per-function 	 */
define|#
directive|define
name|CMDQ_MODIFY_GID_STATS_CTX_STATS_CTX_VALID
value|UINT32_C(0x8000)
name|uint16_t
name|unused_0
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Query GID command (24 bytes) */
end_comment

begin_struct
struct|struct
name|cmdq_query_gid
block|{
name|uint8_t
name|opcode
decl_stmt|;
comment|/* Command opcode. */
comment|/* Query GID command queries a GID in the local address table. */
define|#
directive|define
name|CMDQ_QUERY_GID_OPCODE_QUERY_GID
value|UINT32_C(0x18)
name|uint8_t
name|cmd_size
decl_stmt|;
comment|/* Size of the command in 16-byte units. */
name|uint16_t
name|flags
decl_stmt|;
comment|/* Flags and attribs of the command. */
name|uint16_t
name|cookie
decl_stmt|;
comment|/* Driver supplied handle to associate the command and the response. */
name|uint8_t
name|resp_size
decl_stmt|;
comment|/* Size of the response buffer in 16-byte units. */
name|uint8_t
name|reserved8
decl_stmt|;
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* Host address of the response. */
name|uint16_t
name|gid_index
decl_stmt|;
comment|/* GID index */
name|uint16_t
name|unused_0
decl_stmt|;
comment|/* unused16 is 16 b */
name|uint32_t
name|unused_1
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Create QP1 command (80 bytes) */
end_comment

begin_struct
struct|struct
name|cmdq_create_qp1
block|{
name|uint8_t
name|opcode
decl_stmt|;
comment|/* Command opcode. */
comment|/* Create QP1 command allocates a QP1 only. */
define|#
directive|define
name|CMDQ_CREATE_QP1_OPCODE_CREATE_QP1
value|UINT32_C(0x13)
name|uint8_t
name|cmd_size
decl_stmt|;
comment|/* Size of the command in 16-byte units. */
name|uint16_t
name|flags
decl_stmt|;
comment|/* Flags and attribs of the command. */
name|uint16_t
name|cookie
decl_stmt|;
comment|/* Driver supplied handle to associate the command and the response. */
name|uint8_t
name|resp_size
decl_stmt|;
comment|/* Size of the response buffer in 16-byte units. */
name|uint8_t
name|reserved8
decl_stmt|;
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* Host address of the response. */
name|uint64_t
name|qp_handle
decl_stmt|;
comment|/* QP1 handle. */
name|uint32_t
name|qp_flags
decl_stmt|;
comment|/* Create QP1 flags. */
comment|/* SRQ is used. */
define|#
directive|define
name|CMDQ_CREATE_QP1_QP_FLAGS_SRQ_USED
value|UINT32_C(0x1)
comment|/* post CQE for all SQ WQEs. */
define|#
directive|define
name|CMDQ_CREATE_QP1_QP_FLAGS_FORCE_COMPLETION
value|UINT32_C(0x2)
comment|/* This QP can use reserved L_Key */
define|#
directive|define
name|CMDQ_CREATE_QP1_QP_FLAGS_RESERVED_LKEY_ENABLE
value|UINT32_C(0x4)
name|uint8_t
name|type
decl_stmt|;
comment|/* Supported QP1 types. */
comment|/* General Services Interface on QP 1. */
define|#
directive|define
name|CMDQ_CREATE_QP1_TYPE_GSI
value|UINT32_C(0x1)
name|uint8_t
name|sq_pg_size_sq_lvl
decl_stmt|;
comment|/* SQ page size. */
comment|/* SQ PBL indirect levels. */
define|#
directive|define
name|CMDQ_CREATE_QP1_SQ_LVL_MASK
value|UINT32_C(0xf)
define|#
directive|define
name|CMDQ_CREATE_QP1_SQ_LVL_SFT
value|0
comment|/* PBL pointer is physical start address. */
define|#
directive|define
name|CMDQ_CREATE_QP1_SQ_LVL_LVL_0
value|UINT32_C(0x0)
comment|/* PBL pointer points to PTE table. */
define|#
directive|define
name|CMDQ_CREATE_QP1_SQ_LVL_LVL_1
value|UINT32_C(0x1)
comment|/* 	 * PBL pointer points to PDE table with each entry pointing to 	 * PTE tables. 	 */
define|#
directive|define
name|CMDQ_CREATE_QP1_SQ_LVL_LVL_2
value|UINT32_C(0x2)
comment|/* SQ page size. */
define|#
directive|define
name|CMDQ_CREATE_QP1_SQ_PG_SIZE_MASK
value|UINT32_C(0xf0)
define|#
directive|define
name|CMDQ_CREATE_QP1_SQ_PG_SIZE_SFT
value|4
comment|/* 4KB. */
define|#
directive|define
name|CMDQ_CREATE_QP1_SQ_PG_SIZE_PG_4K
value|(UINT32_C(0x0)<< 4)
comment|/* 8KB. */
define|#
directive|define
name|CMDQ_CREATE_QP1_SQ_PG_SIZE_PG_8K
value|(UINT32_C(0x1)<< 4)
comment|/* 64KB. */
define|#
directive|define
name|CMDQ_CREATE_QP1_SQ_PG_SIZE_PG_64K
value|(UINT32_C(0x2)<< 4)
comment|/* 2MB. */
define|#
directive|define
name|CMDQ_CREATE_QP1_SQ_PG_SIZE_PG_2M
value|(UINT32_C(0x3)<< 4)
comment|/* 8MB. */
define|#
directive|define
name|CMDQ_CREATE_QP1_SQ_PG_SIZE_PG_8M
value|(UINT32_C(0x4)<< 4)
comment|/* 1GB. */
define|#
directive|define
name|CMDQ_CREATE_QP1_SQ_PG_SIZE_PG_1G
value|(UINT32_C(0x5)<< 4)
name|uint8_t
name|rq_pg_size_rq_lvl
decl_stmt|;
comment|/* RQ page size. */
comment|/* RQ PBL indirect levels. */
define|#
directive|define
name|CMDQ_CREATE_QP1_RQ_LVL_MASK
value|UINT32_C(0xf)
define|#
directive|define
name|CMDQ_CREATE_QP1_RQ_LVL_SFT
value|0
comment|/* PBL pointer is physical start address. */
define|#
directive|define
name|CMDQ_CREATE_QP1_RQ_LVL_LVL_0
value|UINT32_C(0x0)
comment|/* PBL pointer points to PTE table. */
define|#
directive|define
name|CMDQ_CREATE_QP1_RQ_LVL_LVL_1
value|UINT32_C(0x1)
comment|/* 	 * PBL pointer points to PDE table with each entry pointing to 	 * PTE tables. 	 */
define|#
directive|define
name|CMDQ_CREATE_QP1_RQ_LVL_LVL_2
value|UINT32_C(0x2)
comment|/* RQ page size. */
define|#
directive|define
name|CMDQ_CREATE_QP1_RQ_PG_SIZE_MASK
value|UINT32_C(0xf0)
define|#
directive|define
name|CMDQ_CREATE_QP1_RQ_PG_SIZE_SFT
value|4
comment|/* 4KB. */
define|#
directive|define
name|CMDQ_CREATE_QP1_RQ_PG_SIZE_PG_4K
value|(UINT32_C(0x0)<< 4)
comment|/* 8KB. */
define|#
directive|define
name|CMDQ_CREATE_QP1_RQ_PG_SIZE_PG_8K
value|(UINT32_C(0x1)<< 4)
comment|/* 64KB. */
define|#
directive|define
name|CMDQ_CREATE_QP1_RQ_PG_SIZE_PG_64K
value|(UINT32_C(0x2)<< 4)
comment|/* 2MB. */
define|#
directive|define
name|CMDQ_CREATE_QP1_RQ_PG_SIZE_PG_2M
value|(UINT32_C(0x3)<< 4)
comment|/* 8MB. */
define|#
directive|define
name|CMDQ_CREATE_QP1_RQ_PG_SIZE_PG_8M
value|(UINT32_C(0x4)<< 4)
comment|/* 1GB. */
define|#
directive|define
name|CMDQ_CREATE_QP1_RQ_PG_SIZE_PG_1G
value|(UINT32_C(0x5)<< 4)
name|uint8_t
name|unused_0
decl_stmt|;
name|uint32_t
name|dpi
decl_stmt|;
comment|/* Doorbell page index. */
name|uint32_t
name|sq_size
decl_stmt|;
comment|/* Max number of SQ wqes. */
name|uint32_t
name|rq_size
decl_stmt|;
comment|/* Max number of RQ wqes. */
name|uint16_t
name|sq_fwo_sq_sge
decl_stmt|;
comment|/* Offset of First WQE in the first SQ page, in 128 byte units */
comment|/* Max send SGEs per SWQE. */
define|#
directive|define
name|CMDQ_CREATE_QP1_SQ_SGE_MASK
value|UINT32_C(0xf)
define|#
directive|define
name|CMDQ_CREATE_QP1_SQ_SGE_SFT
value|0
comment|/* Offset of First WQE in the first SQ page, in 128 byte units */
define|#
directive|define
name|CMDQ_CREATE_QP1_SQ_FWO_MASK
value|UINT32_C(0xfff0)
define|#
directive|define
name|CMDQ_CREATE_QP1_SQ_FWO_SFT
value|4
name|uint16_t
name|rq_fwo_rq_sge
decl_stmt|;
comment|/* Offset of First WQE in the first RQ page, in 128 byte units */
comment|/* Max recv SGEs per RWQE (NOT SUPPORTED BY HARDWARE). */
define|#
directive|define
name|CMDQ_CREATE_QP1_RQ_SGE_MASK
value|UINT32_C(0xf)
define|#
directive|define
name|CMDQ_CREATE_QP1_RQ_SGE_SFT
value|0
comment|/* Offset of First WQE in the first RQ page, in 128 byte units */
define|#
directive|define
name|CMDQ_CREATE_QP1_RQ_FWO_MASK
value|UINT32_C(0xfff0)
define|#
directive|define
name|CMDQ_CREATE_QP1_RQ_FWO_SFT
value|4
name|uint32_t
name|scq_cid
decl_stmt|;
comment|/* Send CQ context id. */
name|uint32_t
name|rcq_cid
decl_stmt|;
comment|/* Receive CQ context id. */
name|uint32_t
name|srq_cid
decl_stmt|;
comment|/* SRQ CQ context id. */
name|uint32_t
name|pd_id
decl_stmt|;
comment|/* Protection domain id. */
name|uint64_t
name|sq_pbl
decl_stmt|;
comment|/* SQ PBL physical address. */
name|uint64_t
name|rq_pbl
decl_stmt|;
comment|/* RQ PBL physical address. */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Destroy QP1 command (24 bytes) */
end_comment

begin_struct
struct|struct
name|cmdq_destroy_qp1
block|{
name|uint8_t
name|opcode
decl_stmt|;
comment|/* Command opcode. */
comment|/* Destroy QP1 command deletes and flushes the specified QP1. */
define|#
directive|define
name|CMDQ_DESTROY_QP1_OPCODE_DESTROY_QP1
value|UINT32_C(0x14)
name|uint8_t
name|cmd_size
decl_stmt|;
comment|/* Size of the command in 16-byte units. */
name|uint16_t
name|flags
decl_stmt|;
comment|/* Flags and attribs of the command. */
name|uint16_t
name|cookie
decl_stmt|;
comment|/* Driver supplied handle to associate the command and the response. */
name|uint8_t
name|resp_size
decl_stmt|;
comment|/* Size of the response buffer in 16-byte units. */
name|uint8_t
name|reserved8
decl_stmt|;
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* Host address of the response. */
name|uint32_t
name|qp1_cid
decl_stmt|;
comment|/* QP1 context id */
name|uint32_t
name|unused_0
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Create AH command (64 bytes) */
end_comment

begin_struct
struct|struct
name|cmdq_create_ah
block|{
name|uint8_t
name|opcode
decl_stmt|;
comment|/* Command opcode. */
comment|/* Create AH command allocates an AH with the specified parameters. */
define|#
directive|define
name|CMDQ_CREATE_AH_OPCODE_CREATE_AH
value|UINT32_C(0x15)
name|uint8_t
name|cmd_size
decl_stmt|;
comment|/* Size of the command in 16-byte units. */
name|uint16_t
name|flags
decl_stmt|;
comment|/* Flags and attribs of the command. */
name|uint16_t
name|cookie
decl_stmt|;
comment|/* Driver supplied handle to associate the command and the response. */
name|uint8_t
name|resp_size
decl_stmt|;
comment|/* Size of the response buffer in 16-byte units. */
name|uint8_t
name|reserved8
decl_stmt|;
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* Host address of the response. */
name|uint64_t
name|ah_handle
decl_stmt|;
comment|/* AH handle. */
name|uint32_t
name|dgid
index|[
literal|4
index|]
decl_stmt|;
comment|/* Destination GID. */
name|uint8_t
name|type
decl_stmt|;
comment|/* V1, V2IPv4 or V2IPv6. */
comment|/* V2IPv4. */
define|#
directive|define
name|CMDQ_CREATE_AH_TYPE_V1
value|UINT32_C(0x0)
comment|/* V2IPv4. */
define|#
directive|define
name|CMDQ_CREATE_AH_TYPE_V2IPV4
value|UINT32_C(0x2)
comment|/* V2IPv6. */
define|#
directive|define
name|CMDQ_CREATE_AH_TYPE_V2IPV6
value|UINT32_C(0x3)
name|uint8_t
name|hop_limit
decl_stmt|;
comment|/* IPv6 Hop limit. */
name|uint16_t
name|sgid_index
decl_stmt|;
comment|/* SGID index. */
name|uint32_t
name|dest_vlan_id_flow_label
decl_stmt|;
comment|/* Destination VLAN ID. */
comment|/* Flow label. */
define|#
directive|define
name|CMDQ_CREATE_AH_FLOW_LABEL_MASK
value|UINT32_C(0xfffff)
define|#
directive|define
name|CMDQ_CREATE_AH_FLOW_LABEL_SFT
value|0
comment|/* Destination VLAN ID. */
define|#
directive|define
name|CMDQ_CREATE_AH_DEST_VLAN_ID_MASK
value|UINT32_C(0xfff00000)
define|#
directive|define
name|CMDQ_CREATE_AH_DEST_VLAN_ID_SFT
value|20
name|uint32_t
name|pd_id
decl_stmt|;
comment|/* Protection domain id. */
name|uint32_t
name|unused_0
decl_stmt|;
name|uint16_t
name|dest_mac
index|[
literal|3
index|]
decl_stmt|;
comment|/* Destination MAC address. */
name|uint8_t
name|traffic_class
decl_stmt|;
comment|/* Traffic class. */
name|uint8_t
name|enable_cc
decl_stmt|;
comment|/* Enable congestion control. */
define|#
directive|define
name|CMDQ_CREATE_AH_ENABLE_CC
value|UINT32_C(0x1)
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Destroy AH command (24 bytes) */
end_comment

begin_struct
struct|struct
name|cmdq_destroy_ah
block|{
name|uint8_t
name|opcode
decl_stmt|;
comment|/* Command opcode. */
comment|/* Destroy AH command deletes the specified AH. */
define|#
directive|define
name|CMDQ_DESTROY_AH_OPCODE_DESTROY_AH
value|UINT32_C(0x16)
name|uint8_t
name|cmd_size
decl_stmt|;
comment|/* Size of the command in 16-byte units. */
name|uint16_t
name|flags
decl_stmt|;
comment|/* Flags and attribs of the command. */
name|uint16_t
name|cookie
decl_stmt|;
comment|/* Driver supplied handle to associate the command and the response. */
name|uint8_t
name|resp_size
decl_stmt|;
comment|/* Size of the response buffer in 16-byte units. */
name|uint8_t
name|reserved8
decl_stmt|;
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* Host address of the response. */
name|uint32_t
name|ah_cid
decl_stmt|;
comment|/* AH context id */
name|uint32_t
name|unused_0
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Initialize Firmware command (112 bytes) */
end_comment

begin_struct
struct|struct
name|cmdq_initialize_fw
block|{
name|uint8_t
name|opcode
decl_stmt|;
comment|/* Command opcode. */
comment|/* 	 * Initialize firmware command initializes the firmware with the 	 * specified parameters. 	 */
define|#
directive|define
name|CMDQ_INITIALIZE_FW_OPCODE_INITIALIZE_FW
value|UINT32_C(0x80)
name|uint8_t
name|cmd_size
decl_stmt|;
comment|/* Size of the command in 16-byte units. */
name|uint16_t
name|flags
decl_stmt|;
comment|/* Flags and attribs of the command. */
name|uint16_t
name|cookie
decl_stmt|;
comment|/* Driver supplied handle to associate the command and the response. */
name|uint8_t
name|resp_size
decl_stmt|;
comment|/* Size of the response buffer in 16-byte units. */
name|uint8_t
name|reserved8
decl_stmt|;
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* Host address of the response. */
name|uint8_t
name|qpc_pg_size_qpc_lvl
decl_stmt|;
comment|/* QPC page size. */
comment|/* QPC PBL indirect levels. */
define|#
directive|define
name|CMDQ_INITIALIZE_FW_QPC_LVL_MASK
value|UINT32_C(0xf)
define|#
directive|define
name|CMDQ_INITIALIZE_FW_QPC_LVL_SFT
value|0
comment|/* PBL pointer is physical start address. */
define|#
directive|define
name|CMDQ_INITIALIZE_FW_QPC_LVL_LVL_0
value|UINT32_C(0x0)
comment|/* PBL pointer points to PTE table. */
define|#
directive|define
name|CMDQ_INITIALIZE_FW_QPC_LVL_LVL_1
value|UINT32_C(0x1)
comment|/* 	 * PBL pointer points to PDE table with each entry pointing to 	 * PTE tables. 	 */
define|#
directive|define
name|CMDQ_INITIALIZE_FW_QPC_LVL_LVL_2
value|UINT32_C(0x2)
comment|/* QPC page size. */
define|#
directive|define
name|CMDQ_INITIALIZE_FW_QPC_PG_SIZE_MASK
value|UINT32_C(0xf0)
define|#
directive|define
name|CMDQ_INITIALIZE_FW_QPC_PG_SIZE_SFT
value|4
comment|/* 4KB. */
define|#
directive|define
name|CMDQ_INITIALIZE_FW_QPC_PG_SIZE_PG_4K
value|(UINT32_C(0x0)<< 4)
comment|/* 8KB. */
define|#
directive|define
name|CMDQ_INITIALIZE_FW_QPC_PG_SIZE_PG_8K
value|(UINT32_C(0x1)<< 4)
comment|/* 64KB. */
define|#
directive|define
name|CMDQ_INITIALIZE_FW_QPC_PG_SIZE_PG_64K
value|(UINT32_C(0x2)<< 4)
comment|/* 2MB. */
define|#
directive|define
name|CMDQ_INITIALIZE_FW_QPC_PG_SIZE_PG_2M
value|(UINT32_C(0x3)<< 4)
comment|/* 8MB. */
define|#
directive|define
name|CMDQ_INITIALIZE_FW_QPC_PG_SIZE_PG_8M
value|(UINT32_C(0x4)<< 4)
comment|/* 1GB. */
define|#
directive|define
name|CMDQ_INITIALIZE_FW_QPC_PG_SIZE_PG_1G
value|(UINT32_C(0x5)<< 4)
name|uint8_t
name|mrw_pg_size_mrw_lvl
decl_stmt|;
comment|/* MRW page size. */
comment|/* MRW PBL indirect levels. */
define|#
directive|define
name|CMDQ_INITIALIZE_FW_MRW_LVL_MASK
value|UINT32_C(0xf)
define|#
directive|define
name|CMDQ_INITIALIZE_FW_MRW_LVL_SFT
value|0
comment|/* PBL pointer is physical start address. */
define|#
directive|define
name|CMDQ_INITIALIZE_FW_MRW_LVL_LVL_0
value|UINT32_C(0x0)
comment|/* PBL pointer points to PTE table. */
define|#
directive|define
name|CMDQ_INITIALIZE_FW_MRW_LVL_LVL_1
value|UINT32_C(0x1)
comment|/* 	 * PBL pointer points to PDE table with each entry pointing to 	 * PTE tables. 	 */
define|#
directive|define
name|CMDQ_INITIALIZE_FW_MRW_LVL_LVL_2
value|UINT32_C(0x2)
comment|/* MRW page size. */
define|#
directive|define
name|CMDQ_INITIALIZE_FW_MRW_PG_SIZE_MASK
value|UINT32_C(0xf0)
define|#
directive|define
name|CMDQ_INITIALIZE_FW_MRW_PG_SIZE_SFT
value|4
comment|/* 4KB. */
define|#
directive|define
name|CMDQ_INITIALIZE_FW_MRW_PG_SIZE_PG_4K
value|(UINT32_C(0x0)<< 4)
comment|/* 8KB. */
define|#
directive|define
name|CMDQ_INITIALIZE_FW_MRW_PG_SIZE_PG_8K
value|(UINT32_C(0x1)<< 4)
comment|/* 64KB. */
define|#
directive|define
name|CMDQ_INITIALIZE_FW_MRW_PG_SIZE_PG_64K
value|(UINT32_C(0x2)<< 4)
comment|/* 2MB. */
define|#
directive|define
name|CMDQ_INITIALIZE_FW_MRW_PG_SIZE_PG_2M
value|(UINT32_C(0x3)<< 4)
comment|/* 8MB. */
define|#
directive|define
name|CMDQ_INITIALIZE_FW_MRW_PG_SIZE_PG_8M
value|(UINT32_C(0x4)<< 4)
comment|/* 1GB. */
define|#
directive|define
name|CMDQ_INITIALIZE_FW_MRW_PG_SIZE_PG_1G
value|(UINT32_C(0x5)<< 4)
name|uint8_t
name|srq_pg_size_srq_lvl
decl_stmt|;
comment|/* SRQ page size. */
comment|/* SRQ PBL indirect levels. */
define|#
directive|define
name|CMDQ_INITIALIZE_FW_SRQ_LVL_MASK
value|UINT32_C(0xf)
define|#
directive|define
name|CMDQ_INITIALIZE_FW_SRQ_LVL_SFT
value|0
comment|/* PBL pointer is physical start address. */
define|#
directive|define
name|CMDQ_INITIALIZE_FW_SRQ_LVL_LVL_0
value|UINT32_C(0x0)
comment|/* PBL pointer points to PTE table. */
define|#
directive|define
name|CMDQ_INITIALIZE_FW_SRQ_LVL_LVL_1
value|UINT32_C(0x1)
comment|/* 	 * PBL pointer points to PDE table with each entry pointing to 	 * PTE tables. 	 */
define|#
directive|define
name|CMDQ_INITIALIZE_FW_SRQ_LVL_LVL_2
value|UINT32_C(0x2)
comment|/* SRQ page size. */
define|#
directive|define
name|CMDQ_INITIALIZE_FW_SRQ_PG_SIZE_MASK
value|UINT32_C(0xf0)
define|#
directive|define
name|CMDQ_INITIALIZE_FW_SRQ_PG_SIZE_SFT
value|4
comment|/* 4KB. */
define|#
directive|define
name|CMDQ_INITIALIZE_FW_SRQ_PG_SIZE_PG_4K
value|(UINT32_C(0x0)<< 4)
comment|/* 8KB. */
define|#
directive|define
name|CMDQ_INITIALIZE_FW_SRQ_PG_SIZE_PG_8K
value|(UINT32_C(0x1)<< 4)
comment|/* 64KB. */
define|#
directive|define
name|CMDQ_INITIALIZE_FW_SRQ_PG_SIZE_PG_64K
value|(UINT32_C(0x2)<< 4)
comment|/* 2MB. */
define|#
directive|define
name|CMDQ_INITIALIZE_FW_SRQ_PG_SIZE_PG_2M
value|(UINT32_C(0x3)<< 4)
comment|/* 8MB. */
define|#
directive|define
name|CMDQ_INITIALIZE_FW_SRQ_PG_SIZE_PG_8M
value|(UINT32_C(0x4)<< 4)
comment|/* 1GB. */
define|#
directive|define
name|CMDQ_INITIALIZE_FW_SRQ_PG_SIZE_PG_1G
value|(UINT32_C(0x5)<< 4)
name|uint8_t
name|cq_pg_size_cq_lvl
decl_stmt|;
comment|/* CQ page size. */
comment|/* CQ PBL indirect levels. */
define|#
directive|define
name|CMDQ_INITIALIZE_FW_CQ_LVL_MASK
value|UINT32_C(0xf)
define|#
directive|define
name|CMDQ_INITIALIZE_FW_CQ_LVL_SFT
value|0
comment|/* PBL pointer is physical start address. */
define|#
directive|define
name|CMDQ_INITIALIZE_FW_CQ_LVL_LVL_0
value|UINT32_C(0x0)
comment|/* PBL pointer points to PTE table. */
define|#
directive|define
name|CMDQ_INITIALIZE_FW_CQ_LVL_LVL_1
value|UINT32_C(0x1)
comment|/* 	 * PBL pointer points to PDE table with each entry pointing to 	 * PTE tables. 	 */
define|#
directive|define
name|CMDQ_INITIALIZE_FW_CQ_LVL_LVL_2
value|UINT32_C(0x2)
comment|/* CQ page size. */
define|#
directive|define
name|CMDQ_INITIALIZE_FW_CQ_PG_SIZE_MASK
value|UINT32_C(0xf0)
define|#
directive|define
name|CMDQ_INITIALIZE_FW_CQ_PG_SIZE_SFT
value|4
comment|/* 4KB. */
define|#
directive|define
name|CMDQ_INITIALIZE_FW_CQ_PG_SIZE_PG_4K
value|(UINT32_C(0x0)<< 4)
comment|/* 8KB. */
define|#
directive|define
name|CMDQ_INITIALIZE_FW_CQ_PG_SIZE_PG_8K
value|(UINT32_C(0x1)<< 4)
comment|/* 64KB. */
define|#
directive|define
name|CMDQ_INITIALIZE_FW_CQ_PG_SIZE_PG_64K
value|(UINT32_C(0x2)<< 4)
comment|/* 2MB. */
define|#
directive|define
name|CMDQ_INITIALIZE_FW_CQ_PG_SIZE_PG_2M
value|(UINT32_C(0x3)<< 4)
comment|/* 8MB. */
define|#
directive|define
name|CMDQ_INITIALIZE_FW_CQ_PG_SIZE_PG_8M
value|(UINT32_C(0x4)<< 4)
comment|/* 1GB. */
define|#
directive|define
name|CMDQ_INITIALIZE_FW_CQ_PG_SIZE_PG_1G
value|(UINT32_C(0x5)<< 4)
name|uint8_t
name|tqm_pg_size_tqm_lvl
decl_stmt|;
comment|/* TQM page size. */
comment|/* TQM PBL indirect levels. */
define|#
directive|define
name|CMDQ_INITIALIZE_FW_TQM_LVL_MASK
value|UINT32_C(0xf)
define|#
directive|define
name|CMDQ_INITIALIZE_FW_TQM_LVL_SFT
value|0
comment|/* PBL pointer is physical start address. */
define|#
directive|define
name|CMDQ_INITIALIZE_FW_TQM_LVL_LVL_0
value|UINT32_C(0x0)
comment|/* PBL pointer points to PTE table. */
define|#
directive|define
name|CMDQ_INITIALIZE_FW_TQM_LVL_LVL_1
value|UINT32_C(0x1)
comment|/* 	 * PBL pointer points to PDE table with each entry pointing to 	 * PTE tables. 	 */
define|#
directive|define
name|CMDQ_INITIALIZE_FW_TQM_LVL_LVL_2
value|UINT32_C(0x2)
comment|/* TQM page size. */
define|#
directive|define
name|CMDQ_INITIALIZE_FW_TQM_PG_SIZE_MASK
value|UINT32_C(0xf0)
define|#
directive|define
name|CMDQ_INITIALIZE_FW_TQM_PG_SIZE_SFT
value|4
comment|/* 4KB. */
define|#
directive|define
name|CMDQ_INITIALIZE_FW_TQM_PG_SIZE_PG_4K
value|(UINT32_C(0x0)<< 4)
comment|/* 8KB. */
define|#
directive|define
name|CMDQ_INITIALIZE_FW_TQM_PG_SIZE_PG_8K
value|(UINT32_C(0x1)<< 4)
comment|/* 64KB. */
define|#
directive|define
name|CMDQ_INITIALIZE_FW_TQM_PG_SIZE_PG_64K
value|(UINT32_C(0x2)<< 4)
comment|/* 2MB. */
define|#
directive|define
name|CMDQ_INITIALIZE_FW_TQM_PG_SIZE_PG_2M
value|(UINT32_C(0x3)<< 4)
comment|/* 8MB. */
define|#
directive|define
name|CMDQ_INITIALIZE_FW_TQM_PG_SIZE_PG_8M
value|(UINT32_C(0x4)<< 4)
comment|/* 1GB. */
define|#
directive|define
name|CMDQ_INITIALIZE_FW_TQM_PG_SIZE_PG_1G
value|(UINT32_C(0x5)<< 4)
name|uint8_t
name|tim_pg_size_tim_lvl
decl_stmt|;
comment|/* TIM page size. */
comment|/* TIM PBL indirect levels. */
define|#
directive|define
name|CMDQ_INITIALIZE_FW_TIM_LVL_MASK
value|UINT32_C(0xf)
define|#
directive|define
name|CMDQ_INITIALIZE_FW_TIM_LVL_SFT
value|0
comment|/* PBL pointer is physical start address. */
define|#
directive|define
name|CMDQ_INITIALIZE_FW_TIM_LVL_LVL_0
value|UINT32_C(0x0)
comment|/* PBL pointer points to PTE table. */
define|#
directive|define
name|CMDQ_INITIALIZE_FW_TIM_LVL_LVL_1
value|UINT32_C(0x1)
comment|/* 	 * PBL pointer points to PDE table with each entry pointing to 	 * PTE tables. 	 */
define|#
directive|define
name|CMDQ_INITIALIZE_FW_TIM_LVL_LVL_2
value|UINT32_C(0x2)
comment|/* TIM page size. */
define|#
directive|define
name|CMDQ_INITIALIZE_FW_TIM_PG_SIZE_MASK
value|UINT32_C(0xf0)
define|#
directive|define
name|CMDQ_INITIALIZE_FW_TIM_PG_SIZE_SFT
value|4
comment|/* 4KB. */
define|#
directive|define
name|CMDQ_INITIALIZE_FW_TIM_PG_SIZE_PG_4K
value|(UINT32_C(0x0)<< 4)
comment|/* 8KB. */
define|#
directive|define
name|CMDQ_INITIALIZE_FW_TIM_PG_SIZE_PG_8K
value|(UINT32_C(0x1)<< 4)
comment|/* 64KB. */
define|#
directive|define
name|CMDQ_INITIALIZE_FW_TIM_PG_SIZE_PG_64K
value|(UINT32_C(0x2)<< 4)
comment|/* 2MB. */
define|#
directive|define
name|CMDQ_INITIALIZE_FW_TIM_PG_SIZE_PG_2M
value|(UINT32_C(0x3)<< 4)
comment|/* 8MB. */
define|#
directive|define
name|CMDQ_INITIALIZE_FW_TIM_PG_SIZE_PG_8M
value|(UINT32_C(0x4)<< 4)
comment|/* 1GB. */
define|#
directive|define
name|CMDQ_INITIALIZE_FW_TIM_PG_SIZE_PG_1G
value|(UINT32_C(0x5)<< 4)
name|uint16_t
name|reserved16
decl_stmt|;
name|uint64_t
name|qpc_page_dir
decl_stmt|;
comment|/* Kernel notification queue page directory. */
name|uint64_t
name|mrw_page_dir
decl_stmt|;
comment|/* MRW page directory. */
name|uint64_t
name|srq_page_dir
decl_stmt|;
comment|/* SRQ page directory. */
name|uint64_t
name|cq_page_dir
decl_stmt|;
comment|/* CQ page directory. */
name|uint64_t
name|tqm_page_dir
decl_stmt|;
comment|/* TQM page directory. */
name|uint64_t
name|tim_page_dir
decl_stmt|;
comment|/* TIM page directory. */
name|uint32_t
name|number_of_qp
decl_stmt|;
comment|/* Number of QPs. */
name|uint32_t
name|number_of_mrw
decl_stmt|;
comment|/* Number of MRWs. */
name|uint32_t
name|number_of_srq
decl_stmt|;
comment|/* Number of SRQs. */
name|uint32_t
name|number_of_cq
decl_stmt|;
comment|/* Number of CQs. */
name|uint32_t
name|max_qp_per_vf
decl_stmt|;
comment|/* Number of QPs per VF. */
name|uint32_t
name|max_mrw_per_vf
decl_stmt|;
comment|/* Number of MRWs per VF. */
name|uint32_t
name|max_srq_per_vf
decl_stmt|;
comment|/* Number of SRQs per VF. */
name|uint32_t
name|max_cq_per_vf
decl_stmt|;
comment|/* Number of CQs per VF. */
name|uint32_t
name|max_gid_per_vf
decl_stmt|;
comment|/* Number of GIDs per VF. */
name|uint32_t
name|stat_ctx_id
decl_stmt|;
comment|/* Statistics context index for this function. */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* De-initialize Firmware command (16 bytes) */
end_comment

begin_struct
struct|struct
name|cmdq_deinitialize_fw
block|{
name|uint8_t
name|opcode
decl_stmt|;
comment|/* Command opcode. */
comment|/* De-initialize firmware command deinitializes the firmware. */
define|#
directive|define
name|CMDQ_DEINITIALIZE_FW_OPCODE_DEINITIALIZE_FW
value|UINT32_C(0x81)
name|uint8_t
name|cmd_size
decl_stmt|;
comment|/* Size of the command in 16-byte units. */
name|uint16_t
name|flags
decl_stmt|;
comment|/* Flags and attribs of the command. */
name|uint16_t
name|cookie
decl_stmt|;
comment|/* Driver supplied handle to associate the command and the response. */
name|uint8_t
name|resp_size
decl_stmt|;
comment|/* Size of the response buffer in 16-byte units. */
name|uint8_t
name|reserved8
decl_stmt|;
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* Host address of the response. */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Stop function command (16 bytes) */
end_comment

begin_struct
struct|struct
name|cmdq_stop_func
block|{
name|uint8_t
name|opcode
decl_stmt|;
comment|/* Command opcode. */
comment|/* Stop the function */
define|#
directive|define
name|CMDQ_STOP_FUNC_OPCODE_STOP_FUNC
value|UINT32_C(0x82)
name|uint8_t
name|cmd_size
decl_stmt|;
comment|/* Size of the command in 16-byte units. */
name|uint16_t
name|flags
decl_stmt|;
comment|/* Flags and attribs of the command. */
name|uint16_t
name|cookie
decl_stmt|;
comment|/* Driver supplied handle to associate the command and the response. */
name|uint8_t
name|resp_size
decl_stmt|;
comment|/* Size of the response buffer in 16-byte units. */
name|uint8_t
name|reserved8
decl_stmt|;
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* Host address of the response. */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Query function command (16 bytes) */
end_comment

begin_struct
struct|struct
name|cmdq_query_func
block|{
name|uint8_t
name|opcode
decl_stmt|;
comment|/* Command opcode. */
comment|/* Query the HW capabilities for the function. */
define|#
directive|define
name|CMDQ_QUERY_FUNC_OPCODE_QUERY_FUNC
value|UINT32_C(0x83)
name|uint8_t
name|cmd_size
decl_stmt|;
comment|/* Size of the command in 16-byte units. */
name|uint16_t
name|flags
decl_stmt|;
comment|/* Flags and attribs of the command. */
name|uint16_t
name|cookie
decl_stmt|;
comment|/* Driver supplied handle to associate the command and the response. */
name|uint8_t
name|resp_size
decl_stmt|;
comment|/* Size of the response buffer in 16-byte units. */
name|uint8_t
name|reserved8
decl_stmt|;
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* Host address of the response. */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Set function resources command (56 bytes) */
end_comment

begin_struct
struct|struct
name|cmdq_set_func_resources
block|{
name|uint8_t
name|opcode
decl_stmt|;
comment|/* Command opcode. */
comment|/* 	 * Set the following resources for the function: - Max QP, CQ, 	 * MR+MW, SRQ per PF - Max QP, CQ, MR+MW, SRQ per VF 	 */
define|#
directive|define
name|CMDQ_SET_FUNC_RESOURCES_OPCODE_SET_FUNC_RESOURCES
value|UINT32_C(0x84)
name|uint8_t
name|cmd_size
decl_stmt|;
comment|/* Size of the command in 16-byte units. */
name|uint16_t
name|flags
decl_stmt|;
comment|/* Flags and attribs of the command. */
name|uint16_t
name|cookie
decl_stmt|;
comment|/* Driver supplied handle to associate the command and the response. */
name|uint8_t
name|resp_size
decl_stmt|;
comment|/* Size of the response buffer in 16-byte units. */
name|uint8_t
name|reserved8
decl_stmt|;
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* Host address of the response. */
name|uint32_t
name|number_of_qp
decl_stmt|;
comment|/* 	 * Number of QPs. It is the responsibility of the host to first extend 	 * the existing PBL with new addresses to pages to handle the 	 * adjustment. Must be greater or equal to current. 	 */
name|uint32_t
name|number_of_mrw
decl_stmt|;
comment|/* 	 * Number of MRWs. It is the responsibility of the host to first extend 	 * the existing PBL with new addresses to pages to handle the 	 * adjustment. Must be greater or equal to current. 	 */
name|uint32_t
name|number_of_srq
decl_stmt|;
comment|/* 	 * Number of SRQs. It is the responsibility of the host to first extend 	 * the existing PBL with new addresses to pages to handle the 	 * adjustment. Must be greater or equal to current. 	 */
name|uint32_t
name|number_of_cq
decl_stmt|;
comment|/* 	 * Number of CQs. It is the responsibility of the host to first extend 	 * the existing PBL with new addresses to pages to handle the 	 * adjustment. Must be greater or equal to current. 	 */
name|uint32_t
name|max_qp_per_vf
decl_stmt|;
comment|/* Number of QPs per VF. */
name|uint32_t
name|max_mrw_per_vf
decl_stmt|;
comment|/* Number of MRWs per VF. */
name|uint32_t
name|max_srq_per_vf
decl_stmt|;
comment|/* Number of SRQs per VF. */
name|uint32_t
name|max_cq_per_vf
decl_stmt|;
comment|/* Number of CQs per VF. */
name|uint32_t
name|max_gid_per_vf
decl_stmt|;
comment|/* Number of GIDs per VF. */
name|uint32_t
name|stat_ctx_id
decl_stmt|;
comment|/* Statistics context index for this function. */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Read hardware resource context command (24 bytes) */
end_comment

begin_struct
struct|struct
name|cmdq_read_context
block|{
name|uint8_t
name|opcode
decl_stmt|;
comment|/* Command opcode. */
comment|/* 	 * Read the current state of any internal resource context. Can 	 * only be issued from a PF. 	 */
define|#
directive|define
name|CMDQ_READ_CONTEXT_OPCODE_READ_CONTEXT
value|UINT32_C(0x85)
name|uint8_t
name|cmd_size
decl_stmt|;
comment|/* Size of the command in 16-byte units. */
name|uint16_t
name|flags
decl_stmt|;
comment|/* Flags and attribs of the command. */
name|uint16_t
name|cookie
decl_stmt|;
comment|/* Driver supplied handle to associate the command and the response. */
name|uint8_t
name|resp_size
decl_stmt|;
comment|/* Size of the response buffer in 16-byte units. */
name|uint8_t
name|reserved8
decl_stmt|;
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* Host address of the response. */
name|uint32_t
name|type_xid
decl_stmt|;
comment|/* Context type */
comment|/* Context ID */
define|#
directive|define
name|CMDQ_READ_CONTEXT_XID_MASK
value|UINT32_C(0xffffff)
define|#
directive|define
name|CMDQ_READ_CONTEXT_XID_SFT
value|0
comment|/* Context type */
define|#
directive|define
name|CMDQ_READ_CONTEXT_TYPE_MASK
value|UINT32_C(0xff000000)
define|#
directive|define
name|CMDQ_READ_CONTEXT_TYPE_SFT
value|24
comment|/* 	 * Read QPC. The context (448 bytes) goes to resp_addr (as is, 	 * without a header), and resp_size should be set to 28 (448/16) 	 */
define|#
directive|define
name|CMDQ_READ_CONTEXT_TYPE_QPC
value|(UINT32_C(0x0)<< 24)
comment|/* 	 * Read CQ. The context (64 bytes) goes to resp_addr (as is, 	 * without a header), and resp_size should be set to 4 (64/16) 	 */
define|#
directive|define
name|CMDQ_READ_CONTEXT_TYPE_CQ
value|(UINT32_C(0x1)<< 24)
comment|/* 	 * Read MRW. The context (128 bytes) goes to resp_addr (as is, 	 * without a header), and resp_size should be set to 8 (128/16) 	 */
define|#
directive|define
name|CMDQ_READ_CONTEXT_TYPE_MRW
value|(UINT32_C(0x2)<< 24)
comment|/* 	 * Read SRQ. The context (64 bytes) goes to resp_addr (as is, 	 * without a header), and resp_size should be set to 4 (64/16) 	 */
define|#
directive|define
name|CMDQ_READ_CONTEXT_TYPE_SRQ
value|(UINT32_C(0x3)<< 24)
name|uint32_t
name|unused_0
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Send a request from VF to pass a command to the PF. VF HSI is suspended until the PF returns the response (32 bytes) */
end_comment

begin_struct
struct|struct
name|cmdq_vf_backchannel_request
block|{
name|uint8_t
name|opcode
decl_stmt|;
comment|/* Command opcode. */
comment|/* 	 * Send a request from VF to pass a command to the PF. VF HSI is 	 * suspended until the PF returns the response 	 */
define|#
directive|define
name|CMDQ_VF_BACKCHANNEL_REQUEST_OPCODE_VF_BACKCHANNEL_REQUEST
value|UINT32_C(0x86)
name|uint8_t
name|cmd_size
decl_stmt|;
comment|/* Size of the command in 16-byte units. */
name|uint16_t
name|flags
decl_stmt|;
comment|/* Flags and attribs of the command. */
name|uint16_t
name|cookie
decl_stmt|;
comment|/* Driver supplied handle to associate the command and the response. */
name|uint8_t
name|resp_size
decl_stmt|;
comment|/* Size of the response buffer in 16-byte units. */
name|uint8_t
name|reserved8
decl_stmt|;
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* Host address of the response. */
name|uint64_t
name|command_addr
decl_stmt|;
comment|/* Address of command request structure in VF space */
name|uint16_t
name|command_length
decl_stmt|;
comment|/* 	 * Command request length (up to 4K). An optional address of the 	 * extended response buffer should be provided in the request 	 */
name|uint16_t
name|unused_0
index|[
literal|3
index|]
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Read VF memory (primarily to get the backchannel request blob). Can only be issued from a PF. (32 bytes) */
end_comment

begin_struct
struct|struct
name|cmdq_read_vf_memory
block|{
name|uint8_t
name|opcode
decl_stmt|;
comment|/* Command opcode. */
comment|/* 	 * Read VF memory (primarily to get the backchannel request 	 * blob). Can only be issued from a PF. 	 */
define|#
directive|define
name|CMDQ_READ_VF_MEMORY_OPCODE_READ_VF_MEMORY
value|UINT32_C(0x87)
name|uint8_t
name|cmd_size
decl_stmt|;
comment|/* Size of the command in 16-byte units. */
name|uint16_t
name|flags
decl_stmt|;
comment|/* Flags and attribs of the command. */
name|uint16_t
name|cookie
decl_stmt|;
comment|/* Driver supplied handle to associate the command and the response. */
name|uint8_t
name|resp_size
decl_stmt|;
comment|/* Size of the response buffer in 16-byte units. */
name|uint8_t
name|reserved8
decl_stmt|;
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* Host address of the response. */
name|uint64_t
name|addr
decl_stmt|;
comment|/* Address of memory in VF space to read */
name|uint16_t
name|vf_id
decl_stmt|;
comment|/* VF id, as provided in 0xC0 VF request notification */
name|uint16_t
name|length
decl_stmt|;
comment|/* Length to read, up to 4K */
name|uint32_t
name|unused_0
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Write VF memory (primarily to put the backchannel response blob), and reenable VF HSI (post a CAG completion to it). Can only be issued from a PF. (40 bytes) */
end_comment

begin_struct
struct|struct
name|cmdq_complete_vf_request
block|{
name|uint8_t
name|opcode
decl_stmt|;
comment|/* Command opcode. */
comment|/* 	 * Write VF memory (primarily to put the backchannel response 	 * blob), and reenable VF HSI (post a CAG completion to it). Can 	 * only be issued from a PF. 	 */
define|#
directive|define
name|CMDQ_COMPLETE_VF_REQUEST_OPCODE_COMPLETE_VF_REQUEST
value|UINT32_C(0x88)
name|uint8_t
name|cmd_size
decl_stmt|;
comment|/* Size of the command in 16-byte units. */
name|uint16_t
name|flags
decl_stmt|;
comment|/* Flags and attribs of the command. */
name|uint16_t
name|cookie
decl_stmt|;
comment|/* Driver supplied handle to associate the command and the response. */
name|uint8_t
name|resp_size
decl_stmt|;
comment|/* Size of the response buffer in 16-byte units. */
name|uint8_t
name|reserved8
decl_stmt|;
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* Host address of the response. */
name|uint64_t
name|addr
decl_stmt|;
comment|/* 	 * Optional address of extended response in VF space to write. Length is 	 * in resp_size in 16 byte units. 	 */
name|uint32_t
name|vf_misc
decl_stmt|;
comment|/* Completion misc field to VF CREQ */
name|uint16_t
name|vf_id
decl_stmt|;
comment|/* VF id, as provided in 0xC0 VF request notification */
name|uint16_t
name|vf_cookie
decl_stmt|;
comment|/* Completion cookie for the VF command, goes to VF CREQ */
name|uint8_t
name|vf_status
decl_stmt|;
comment|/* Completion status for the VF command, goes to VF CREQ */
name|uint8_t
name|unused_0
index|[
literal|7
index|]
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Map TC to COS. Can only be issued from a PF (24 bytes) */
end_comment

begin_struct
struct|struct
name|cmdq_map_tc_to_cos
block|{
name|uint8_t
name|opcode
decl_stmt|;
comment|/* Command opcode. */
comment|/* Map TC to COS. Can only be issued from a PF. */
define|#
directive|define
name|CMDQ_MAP_TC_TO_COS_OPCODE_MAP_TC_TO_COS
value|UINT32_C(0x8a)
name|uint8_t
name|cmd_size
decl_stmt|;
comment|/* Size of the command in 16-byte units. */
name|uint16_t
name|flags
decl_stmt|;
comment|/* Flags and attribs of the command. */
name|uint16_t
name|cookie
decl_stmt|;
comment|/* Driver supplied handle to associate the command and the response. */
name|uint8_t
name|resp_size
decl_stmt|;
comment|/* Size of the response buffer in 16-byte units. */
name|uint8_t
name|reserved8
decl_stmt|;
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* Host address of the response. */
name|uint16_t
name|cos0
decl_stmt|;
comment|/* 1st COS index mapped to RoCE */
comment|/* Don't change this COS. */
define|#
directive|define
name|CMDQ_MAP_TC_TO_COS_COS0_NO_CHANGE
value|UINT32_C(0xffff)
name|uint16_t
name|cos1
decl_stmt|;
comment|/* 2nd COS index mapped to RoCE */
comment|/* Disable this COS. */
define|#
directive|define
name|CMDQ_MAP_TC_TO_COS_COS1_DISABLE
value|UINT32_C(0x8000)
comment|/* Don't change this COS. */
define|#
directive|define
name|CMDQ_MAP_TC_TO_COS_COS1_NO_CHANGE
value|UINT32_C(0xffff)
name|uint32_t
name|unused_0
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Query version command (16 bytes) */
end_comment

begin_struct
struct|struct
name|cmdq_query_version
block|{
name|uint8_t
name|opcode
decl_stmt|;
comment|/* Command opcode. */
comment|/* Query version. */
define|#
directive|define
name|CMDQ_QUERY_VERSION_OPCODE_QUERY_VERSION
value|UINT32_C(0x8b)
name|uint8_t
name|cmd_size
decl_stmt|;
comment|/* Size of the command in 16-byte units. */
name|uint16_t
name|flags
decl_stmt|;
comment|/* Flags and attribs of the command. */
name|uint16_t
name|cookie
decl_stmt|;
comment|/* Driver supplied handle to associate the command and the response. */
name|uint8_t
name|resp_size
decl_stmt|;
comment|/* Size of the response buffer in 16-byte units. */
name|uint8_t
name|reserved8
decl_stmt|;
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* Host address of the response. */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Modify congestion control command (56 bytes) */
end_comment

begin_struct
struct|struct
name|cmdq_modify_roce_cc
block|{
name|uint8_t
name|opcode
decl_stmt|;
comment|/* Command opcode. */
comment|/* Modify congestion control. Can only be issued from a PF. */
define|#
directive|define
name|CMDQ_MODIFY_ROCE_CC_OPCODE_MODIFY_ROCE_CC
value|UINT32_C(0x8c)
name|uint8_t
name|cmd_size
decl_stmt|;
comment|/* Size of the command in 16-byte units. */
name|uint16_t
name|flags
decl_stmt|;
comment|/* Flags and attribs of the command. */
name|uint16_t
name|cookie
decl_stmt|;
comment|/* Driver supplied handle to associate the command and the response. */
name|uint8_t
name|resp_size
decl_stmt|;
comment|/* Size of the response buffer in 16-byte units. */
name|uint8_t
name|reserved8
decl_stmt|;
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* Host address of the response. */
name|uint32_t
name|modify_mask
decl_stmt|;
comment|/* Modify mask signifies the field that is requesting the change. */
comment|/* Enable change. */
define|#
directive|define
name|CMDQ_MODIFY_ROCE_CC_MODIFY_MASK_ENABLE_CC
value|UINT32_C(0x1)
comment|/* Running average weight change. */
define|#
directive|define
name|CMDQ_MODIFY_ROCE_CC_MODIFY_MASK_G
value|UINT32_C(0x2)
comment|/* Number of phases in Fast Recovery. */
define|#
directive|define
name|CMDQ_MODIFY_ROCE_CC_MODIFY_MASK_NUMPHASEPERSTATE
value|UINT32_C(0x4)
comment|/* The starting value of rate change. */
define|#
directive|define
name|CMDQ_MODIFY_ROCE_CC_MODIFY_MASK_INIT_CR
value|UINT32_C(0x8)
comment|/* The starting value of target rate change. */
define|#
directive|define
name|CMDQ_MODIFY_ROCE_CC_MODIFY_MASK_INIT_TR
value|UINT32_C(0x10)
comment|/* IP TOS ECN change */
define|#
directive|define
name|CMDQ_MODIFY_ROCE_CC_MODIFY_MASK_TOS_ECN
value|UINT32_C(0x20)
comment|/* IP TOS DSCP change */
define|#
directive|define
name|CMDQ_MODIFY_ROCE_CC_MODIFY_MASK_TOS_DSCP
value|UINT32_C(0x40)
comment|/* Alternate IP TOS ECN change */
define|#
directive|define
name|CMDQ_MODIFY_ROCE_CC_MODIFY_MASK_ALT_VLAN_PCP
value|UINT32_C(0x80)
comment|/* Alternate IP TOS DSCP change */
define|#
directive|define
name|CMDQ_MODIFY_ROCE_CC_MODIFY_MASK_ALT_TOS_DSCP
value|UINT32_C(0x100)
comment|/* Round trip time in units of usecs */
define|#
directive|define
name|CMDQ_MODIFY_ROCE_CC_MODIFY_MASK_RTT
value|UINT32_C(0x200)
comment|/* 0 for DCTCP , 1 for TCP */
define|#
directive|define
name|CMDQ_MODIFY_ROCE_CC_MODIFY_MASK_CC_MODE
value|UINT32_C(0x400)
comment|/* The value used as CP when cc_mode is 1(TCP) */
define|#
directive|define
name|CMDQ_MODIFY_ROCE_CC_MODIFY_MASK_TCP_CP
value|UINT32_C(0x800)
comment|/* Specifies the RoCE Tx Queue ( o to 3) to use for sending CNP packets */
define|#
directive|define
name|CMDQ_MODIFY_ROCE_CC_MODIFY_MASK_TX_QUEUE
value|UINT32_C(0x1000)
comment|/* Inactivity time after which QP CC parameters are initialized */
define|#
directive|define
name|CMDQ_MODIFY_ROCE_CC_MODIFY_MASK_INACTIVITY_CP
value|UINT32_C(0x2000)
name|uint8_t
name|enable_cc
decl_stmt|;
comment|/* rsvd1 is 7 b */
comment|/* Enable. */
define|#
directive|define
name|CMDQ_MODIFY_ROCE_CC_ENABLE_CC
value|UINT32_C(0x1)
comment|/* rsvd1 is 7 b */
define|#
directive|define
name|CMDQ_MODIFY_ROCE_CC_RSVD1_MASK
value|UINT32_C(0xfe)
define|#
directive|define
name|CMDQ_MODIFY_ROCE_CC_RSVD1_SFT
value|1
name|uint8_t
name|g
decl_stmt|;
comment|/* rsvd2 is 5 b */
comment|/* Congestion Probability averaging factor. */
define|#
directive|define
name|CMDQ_MODIFY_ROCE_CC_G_MASK
value|UINT32_C(0x7)
define|#
directive|define
name|CMDQ_MODIFY_ROCE_CC_G_SFT
value|0
comment|/* rsvd2 is 5 b */
define|#
directive|define
name|CMDQ_MODIFY_ROCE_CC_RSVD2_MASK
value|UINT32_C(0xf8)
define|#
directive|define
name|CMDQ_MODIFY_ROCE_CC_RSVD2_SFT
value|3
name|uint8_t
name|num_phases_per_state
decl_stmt|;
comment|/* Number of phases in Fast Recovery. */
name|uint8_t
name|rsvd9
decl_stmt|;
comment|/* rsvd9 is 8 b */
name|uint16_t
name|init_cr
decl_stmt|;
comment|/* The starting value of rate. */
name|uint16_t
name|init_tr
decl_stmt|;
comment|/* The starting value of target rate. */
name|uint8_t
name|tos_dscp_tos_ecn
decl_stmt|;
comment|/* IP TOS DSCP. */
comment|/* IP TOS ECN. Valid values are 1 or 2 when ECN is enabled. */
define|#
directive|define
name|CMDQ_MODIFY_ROCE_CC_TOS_ECN_MASK
value|UINT32_C(0x3)
define|#
directive|define
name|CMDQ_MODIFY_ROCE_CC_TOS_ECN_SFT
value|0
comment|/* IP TOS DSCP. */
define|#
directive|define
name|CMDQ_MODIFY_ROCE_CC_TOS_DSCP_MASK
value|UINT32_C(0xfc)
define|#
directive|define
name|CMDQ_MODIFY_ROCE_CC_TOS_DSCP_SFT
value|2
name|uint8_t
name|alt_vlan_pcp
decl_stmt|;
comment|/* rsvd3 is 5 b */
comment|/* Alternate vlan pcp value for CNP packets. */
define|#
directive|define
name|CMDQ_MODIFY_ROCE_CC_ALT_VLAN_PCP_MASK
value|UINT32_C(0x7)
define|#
directive|define
name|CMDQ_MODIFY_ROCE_CC_ALT_VLAN_PCP_SFT
value|0
comment|/* rsvd3 is 5 b */
define|#
directive|define
name|CMDQ_MODIFY_ROCE_CC_RSVD3_MASK
value|UINT32_C(0xf8)
define|#
directive|define
name|CMDQ_MODIFY_ROCE_CC_RSVD3_SFT
value|3
name|uint16_t
name|alt_tos_dscp
decl_stmt|;
comment|/* rsvd4 is 10 b */
comment|/* Alternate IP TOS DSCP. */
define|#
directive|define
name|CMDQ_MODIFY_ROCE_CC_ALT_TOS_DSCP_MASK
value|UINT32_C(0x3f)
define|#
directive|define
name|CMDQ_MODIFY_ROCE_CC_ALT_TOS_DSCP_SFT
value|0
comment|/* rsvd4 is 10 b */
define|#
directive|define
name|CMDQ_MODIFY_ROCE_CC_RSVD4_MASK
value|UINT32_C(0xffc0)
define|#
directive|define
name|CMDQ_MODIFY_ROCE_CC_RSVD4_SFT
value|6
name|uint16_t
name|rtt
decl_stmt|;
comment|/* rsvd5 is 2 b */
comment|/* Round trip time in units of usecs */
define|#
directive|define
name|CMDQ_MODIFY_ROCE_CC_RTT_MASK
value|UINT32_C(0x3fff)
define|#
directive|define
name|CMDQ_MODIFY_ROCE_CC_RTT_SFT
value|0
comment|/* rsvd5 is 2 b */
define|#
directive|define
name|CMDQ_MODIFY_ROCE_CC_RSVD5_MASK
value|UINT32_C(0xc000)
define|#
directive|define
name|CMDQ_MODIFY_ROCE_CC_RSVD5_SFT
value|14
name|uint16_t
name|tcp_cp
decl_stmt|;
comment|/* rsvd6 is 6 b */
comment|/* The value used as CP when cc_mode is 1(TCP) */
define|#
directive|define
name|CMDQ_MODIFY_ROCE_CC_TCP_CP_MASK
value|UINT32_C(0x3ff)
define|#
directive|define
name|CMDQ_MODIFY_ROCE_CC_TCP_CP_SFT
value|0
comment|/* rsvd6 is 6 b */
define|#
directive|define
name|CMDQ_MODIFY_ROCE_CC_RSVD6_MASK
value|UINT32_C(0xfc00)
define|#
directive|define
name|CMDQ_MODIFY_ROCE_CC_RSVD6_SFT
value|10
name|uint8_t
name|cc_mode
decl_stmt|;
comment|/* rsvd7 is 7 b */
comment|/* 0 for DCTCP , 1 for TCP */
define|#
directive|define
name|CMDQ_MODIFY_ROCE_CC_CC_MODE
value|UINT32_C(0x1)
comment|/* rsvd7 is 7 b */
define|#
directive|define
name|CMDQ_MODIFY_ROCE_CC_RSVD7_MASK
value|UINT32_C(0xfe)
define|#
directive|define
name|CMDQ_MODIFY_ROCE_CC_RSVD7_SFT
value|1
name|uint8_t
name|tx_queue
decl_stmt|;
comment|/* rsvd8 is 6 b */
comment|/* Specifies the RoCE Tx Queue ( o to 3) to use for sending CNP packets */
define|#
directive|define
name|CMDQ_MODIFY_ROCE_CC_TX_QUEUE_MASK
value|UINT32_C(0x3)
define|#
directive|define
name|CMDQ_MODIFY_ROCE_CC_TX_QUEUE_SFT
value|0
comment|/* rsvd8 is 6 b */
define|#
directive|define
name|CMDQ_MODIFY_ROCE_CC_RSVD8_MASK
value|UINT32_C(0xfc)
define|#
directive|define
name|CMDQ_MODIFY_ROCE_CC_RSVD8_SFT
value|2
name|uint16_t
name|inactivity_th
decl_stmt|;
comment|/* Inactivity time after which QP CC parameters are initialized */
name|uint64_t
name|reserved64
decl_stmt|;
name|uint64_t
name|reserved64_1
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Query congestion control command (16 bytes) */
end_comment

begin_struct
struct|struct
name|cmdq_query_roce_cc
block|{
name|uint8_t
name|opcode
decl_stmt|;
comment|/* Command opcode. */
comment|/* Query congestion control. */
define|#
directive|define
name|CMDQ_QUERY_ROCE_CC_OPCODE_QUERY_ROCE_CC
value|UINT32_C(0x8d)
name|uint8_t
name|cmd_size
decl_stmt|;
comment|/* Size of the command in 16-byte units. */
name|uint16_t
name|flags
decl_stmt|;
comment|/* Flags and attribs of the command. */
name|uint16_t
name|cookie
decl_stmt|;
comment|/* Driver supplied handle to associate the command and the response. */
name|uint8_t
name|resp_size
decl_stmt|;
comment|/* Size of the response buffer in 16-byte units. */
name|uint8_t
name|reserved8
decl_stmt|;
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* Host address of the response. */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Command-Response Event Queue (CREQ) Structures */
end_comment

begin_comment
comment|/* Description: This is an async event indicating error happened on a QP. */
end_comment

begin_comment
comment|/* Base CREQ Record (16 bytes) */
end_comment

begin_struct
struct|struct
name|creq_base
block|{
name|uint8_t
name|type
decl_stmt|;
comment|/* 	 * This field indicates the exact type of the completion. By convention, 	 * the LSB identifies the length of the record in 16B units. Even values 	 * indicate 16B records. Odd values indicate 32B records. 	 */
define|#
directive|define
name|CREQ_BASE_TYPE_MASK
value|UINT32_C(0x3f)
define|#
directive|define
name|CREQ_BASE_TYPE_SFT
value|0
comment|/* QP Async Notification */
define|#
directive|define
name|CREQ_BASE_TYPE_QP_EVENT
value|UINT32_C(0x38)
comment|/* Function Async Notification */
define|#
directive|define
name|CREQ_BASE_TYPE_FUNC_EVENT
value|UINT32_C(0x3a)
define|#
directive|define
name|CREQ_BASE_RESERVED2_MASK
value|UINT32_C(0xc0)
define|#
directive|define
name|CREQ_BASE_RESERVED2_SFT
value|6
name|uint8_t
name|reserved56
index|[
literal|7
index|]
decl_stmt|;
name|uint8_t
name|v
decl_stmt|;
comment|/* 	 * This value is written by the NIC such that it will be different for 	 * each pass through the completion queue. The even passes will write 1. 	 * The odd passes will write 0. 	 */
define|#
directive|define
name|CREQ_BASE_V
value|UINT32_C(0x1)
define|#
directive|define
name|CREQ_BASE_RESERVED7_MASK
value|UINT32_C(0xfe)
define|#
directive|define
name|CREQ_BASE_RESERVED7_SFT
value|1
name|uint8_t
name|event
decl_stmt|;
comment|/* This is the modifier on to the type field. */
name|uint16_t
name|reserved48
index|[
literal|3
index|]
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* RoCE Function Async Event Notification (16 bytes) */
end_comment

begin_struct
struct|struct
name|creq_func_event
block|{
name|uint8_t
name|type
decl_stmt|;
comment|/* 	 * This field indicates the exact type of the completion. By convention, 	 * the LSB identifies the length of the record in 16B units. Even values 	 * indicate 16B records. Odd values indicate 32B records. 	 */
define|#
directive|define
name|CREQ_FUNC_EVENT_TYPE_MASK
value|UINT32_C(0x3f)
define|#
directive|define
name|CREQ_FUNC_EVENT_TYPE_SFT
value|0
comment|/* Function Async Notification */
define|#
directive|define
name|CREQ_FUNC_EVENT_TYPE_FUNC_EVENT
value|UINT32_C(0x3a)
define|#
directive|define
name|CREQ_FUNC_EVENT_RESERVED2_MASK
value|UINT32_C(0xc0)
define|#
directive|define
name|CREQ_FUNC_EVENT_RESERVED2_SFT
value|6
name|uint8_t
name|reserved56
index|[
literal|7
index|]
decl_stmt|;
name|uint8_t
name|v
decl_stmt|;
comment|/* 	 * This value is written by the NIC such that it will be different for 	 * each pass through the completion queue. The even passes will write 1. 	 * The odd passes will write 0. 	 */
define|#
directive|define
name|CREQ_FUNC_EVENT_V
value|UINT32_C(0x1)
define|#
directive|define
name|CREQ_FUNC_EVENT_RESERVED7_MASK
value|UINT32_C(0xfe)
define|#
directive|define
name|CREQ_FUNC_EVENT_RESERVED7_SFT
value|1
name|uint8_t
name|event
decl_stmt|;
comment|/* 	 * This value defines what type of async event has occurred on the 	 * function. 	 */
comment|/* 	 * Invalid PBL or PCIE UR response occurred in SQ WQE or IRRQ 	 * read access. 	 */
define|#
directive|define
name|CREQ_FUNC_EVENT_EVENT_TX_WQE_ERROR
value|UINT32_C(0x1)
comment|/* Invalid PBL or PCIE UR response occurred during data read access. */
define|#
directive|define
name|CREQ_FUNC_EVENT_EVENT_TX_DATA_ERROR
value|UINT32_C(0x2)
comment|/* 	 * Invalid PBL or PCIE UR response occurred in RQ/SRQ WQE or 	 * ORRQ read access. 	 */
define|#
directive|define
name|CREQ_FUNC_EVENT_EVENT_RX_WQE_ERROR
value|UINT32_C(0x3)
comment|/* Invalid PBL occurred during data write access. */
define|#
directive|define
name|CREQ_FUNC_EVENT_EVENT_RX_DATA_ERROR
value|UINT32_C(0x4)
comment|/* Invalid PBL occurred during CQ write access. */
define|#
directive|define
name|CREQ_FUNC_EVENT_EVENT_CQ_ERROR
value|UINT32_C(0x5)
comment|/* Invalid PBL or PCIE UR response occurred in TQM read access. */
define|#
directive|define
name|CREQ_FUNC_EVENT_EVENT_TQM_ERROR
value|UINT32_C(0x6)
comment|/* PCIE UR response occurred in CFC read access. */
define|#
directive|define
name|CREQ_FUNC_EVENT_EVENT_CFCQ_ERROR
value|UINT32_C(0x7)
comment|/* PCIE UR response occurred in CFC read access. */
define|#
directive|define
name|CREQ_FUNC_EVENT_EVENT_CFCS_ERROR
value|UINT32_C(0x8)
comment|/* PCIE UR response occurred in CFC read access. */
define|#
directive|define
name|CREQ_FUNC_EVENT_EVENT_CFCC_ERROR
value|UINT32_C(0x9)
comment|/* PCIE UR response occurred in CFC read access. */
define|#
directive|define
name|CREQ_FUNC_EVENT_EVENT_CFCM_ERROR
value|UINT32_C(0xa)
comment|/* Invalid PBL or PCIE UR response occurred on timer read access. */
define|#
directive|define
name|CREQ_FUNC_EVENT_EVENT_TIM_ERROR
value|UINT32_C(0xb)
comment|/* A VF sent a backchannel command request */
define|#
directive|define
name|CREQ_FUNC_EVENT_EVENT_VF_COMM_REQUEST
value|UINT32_C(0x80)
comment|/* 	 * Communication resource (QPC, CQ, SRQ, MRW) exhausted, and 	 * resource array extension is enabled 	 */
define|#
directive|define
name|CREQ_FUNC_EVENT_EVENT_RESOURCE_EXHAUSTED
value|UINT32_C(0x81)
name|uint16_t
name|reserved48
index|[
literal|3
index|]
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* RoCE Slowpath Command Completion (16 bytes) */
end_comment

begin_struct
struct|struct
name|creq_qp_event
block|{
name|uint8_t
name|type
decl_stmt|;
comment|/* 	 * This field indicates the exact type of the completion. By convention, 	 * the LSB identifies the length of the record in 16B units. Even values 	 * indicate 16B records. Odd values indicate 32B records. 	 */
define|#
directive|define
name|CREQ_QP_EVENT_TYPE_MASK
value|UINT32_C(0x3f)
define|#
directive|define
name|CREQ_QP_EVENT_TYPE_SFT
value|0
comment|/* QP Async Notification */
define|#
directive|define
name|CREQ_QP_EVENT_TYPE_QP_EVENT
value|UINT32_C(0x38)
define|#
directive|define
name|CREQ_QP_EVENT_RESERVED2_MASK
value|UINT32_C(0xc0)
define|#
directive|define
name|CREQ_QP_EVENT_RESERVED2_SFT
value|6
name|uint8_t
name|status
decl_stmt|;
comment|/* Status of the response. */
comment|/* Success. */
define|#
directive|define
name|CREQ_QP_EVENT_STATUS_SUCCESS
value|UINT32_C(0x0)
comment|/* Fail. */
define|#
directive|define
name|CREQ_QP_EVENT_STATUS_FAIL
value|UINT32_C(0x1)
comment|/* Resources. */
define|#
directive|define
name|CREQ_QP_EVENT_STATUS_RESOURCES
value|UINT32_C(0x2)
comment|/* Invalid command. */
define|#
directive|define
name|CREQ_QP_EVENT_STATUS_INVALID_CMD
value|UINT32_C(0x3)
comment|/* Not implemented. */
define|#
directive|define
name|CREQ_QP_EVENT_STATUS_NOT_IMPLEMENTED
value|UINT32_C(0x4)
comment|/* Invalid parameter. */
define|#
directive|define
name|CREQ_QP_EVENT_STATUS_INVALID_PARAMETER
value|UINT32_C(0x5)
comment|/* Hardware operation failed. */
define|#
directive|define
name|CREQ_QP_EVENT_STATUS_HARDWARE_ERROR
value|UINT32_C(0x6)
comment|/* Firmware operation failed due to internal error. */
define|#
directive|define
name|CREQ_QP_EVENT_STATUS_INTERNAL_ERROR
value|UINT32_C(0x7)
name|uint16_t
name|cookie
decl_stmt|;
comment|/* Driver supplied handle to associate the command and the response. */
name|uint32_t
name|reserved32
decl_stmt|;
name|uint8_t
name|v
decl_stmt|;
comment|/* 	 * This value is written by the NIC such that it will be different for 	 * each pass through the completion queue. The even passes will write 1. 	 * The odd passes will write 0. 	 */
define|#
directive|define
name|CREQ_QP_EVENT_V
value|UINT32_C(0x1)
define|#
directive|define
name|CREQ_QP_EVENT_RESERVED7_MASK
value|UINT32_C(0xfe)
define|#
directive|define
name|CREQ_QP_EVENT_RESERVED7_SFT
value|1
name|uint8_t
name|event
decl_stmt|;
comment|/* Event or command opcode. */
comment|/* Create QP command response. */
define|#
directive|define
name|CREQ_QP_EVENT_EVENT_CREATE_QP
value|UINT32_C(0x1)
comment|/* Destroy QP command response. */
define|#
directive|define
name|CREQ_QP_EVENT_EVENT_DESTROY_QP
value|UINT32_C(0x2)
comment|/* Modify QP command response. */
define|#
directive|define
name|CREQ_QP_EVENT_EVENT_MODIFY_QP
value|UINT32_C(0x3)
comment|/* Query QP command response. */
define|#
directive|define
name|CREQ_QP_EVENT_EVENT_QUERY_QP
value|UINT32_C(0x4)
comment|/* Create SRQ command response. */
define|#
directive|define
name|CREQ_QP_EVENT_EVENT_CREATE_SRQ
value|UINT32_C(0x5)
comment|/* Destroy SRQ command response. */
define|#
directive|define
name|CREQ_QP_EVENT_EVENT_DESTROY_SRQ
value|UINT32_C(0x6)
comment|/* Query SRQ command response. */
define|#
directive|define
name|CREQ_QP_EVENT_EVENT_QUERY_SRQ
value|UINT32_C(0x8)
comment|/* Create CQ command response. */
define|#
directive|define
name|CREQ_QP_EVENT_EVENT_CREATE_CQ
value|UINT32_C(0x9)
comment|/* Destroy CQ command response. */
define|#
directive|define
name|CREQ_QP_EVENT_EVENT_DESTROY_CQ
value|UINT32_C(0xa)
comment|/* Resize CQ command response. */
define|#
directive|define
name|CREQ_QP_EVENT_EVENT_RESIZE_CQ
value|UINT32_C(0xc)
comment|/* Allocate MRW command response. */
define|#
directive|define
name|CREQ_QP_EVENT_EVENT_ALLOCATE_MRW
value|UINT32_C(0xd)
comment|/* De-allocate key command response. */
define|#
directive|define
name|CREQ_QP_EVENT_EVENT_DEALLOCATE_KEY
value|UINT32_C(0xe)
comment|/* Register MR command response. */
define|#
directive|define
name|CREQ_QP_EVENT_EVENT_REGISTER_MR
value|UINT32_C(0xf)
comment|/* Deregister MR command response. */
define|#
directive|define
name|CREQ_QP_EVENT_EVENT_DEREGISTER_MR
value|UINT32_C(0x10)
comment|/* Add GID command response. */
define|#
directive|define
name|CREQ_QP_EVENT_EVENT_ADD_GID
value|UINT32_C(0x11)
comment|/* Delete GID command response. */
define|#
directive|define
name|CREQ_QP_EVENT_EVENT_DELETE_GID
value|UINT32_C(0x12)
comment|/* Modify GID command response. */
define|#
directive|define
name|CREQ_QP_EVENT_EVENT_MODIFY_GID
value|UINT32_C(0x17)
comment|/* Query GID command response. */
define|#
directive|define
name|CREQ_QP_EVENT_EVENT_QUERY_GID
value|UINT32_C(0x18)
comment|/* Create QP1 command response. */
define|#
directive|define
name|CREQ_QP_EVENT_EVENT_CREATE_QP1
value|UINT32_C(0x13)
comment|/* Destroy QP1 command response. */
define|#
directive|define
name|CREQ_QP_EVENT_EVENT_DESTROY_QP1
value|UINT32_C(0x14)
comment|/* Create AH command response. */
define|#
directive|define
name|CREQ_QP_EVENT_EVENT_CREATE_AH
value|UINT32_C(0x15)
comment|/* Destroy AH command response. */
define|#
directive|define
name|CREQ_QP_EVENT_EVENT_DESTROY_AH
value|UINT32_C(0x16)
comment|/* Initialize firmware command response. */
define|#
directive|define
name|CREQ_QP_EVENT_EVENT_INITIALIZE_FW
value|UINT32_C(0x80)
comment|/* De-initialize firmware command response. */
define|#
directive|define
name|CREQ_QP_EVENT_EVENT_DEINITIALIZE_FW
value|UINT32_C(0x81)
comment|/* Stop PF command response. */
define|#
directive|define
name|CREQ_QP_EVENT_EVENT_STOP_FUNC
value|UINT32_C(0x82)
comment|/* Query info PF command response. */
define|#
directive|define
name|CREQ_QP_EVENT_EVENT_QUERY_FUNC
value|UINT32_C(0x83)
comment|/* Set function resources command response. */
define|#
directive|define
name|CREQ_QP_EVENT_EVENT_SET_FUNC_RESOURCES
value|UINT32_C(0x84)
comment|/* Map TC to COS response. */
define|#
directive|define
name|CREQ_QP_EVENT_EVENT_MAP_TC_TO_COS
value|UINT32_C(0x8a)
comment|/* Query firmware and interface version response. */
define|#
directive|define
name|CREQ_QP_EVENT_EVENT_QUERY_VERSION
value|UINT32_C(0x8b)
comment|/* Modify congestion control response. */
define|#
directive|define
name|CREQ_QP_EVENT_EVENT_MODIFY_ROCE_CC
value|UINT32_C(0x8c)
comment|/* Query congestion control response. */
define|#
directive|define
name|CREQ_QP_EVENT_EVENT_QUERY_ROCE_CC
value|UINT32_C(0x8d)
comment|/* QP error notification event. */
define|#
directive|define
name|CREQ_QP_EVENT_EVENT_QP_ERROR_NOTIFICATION
value|UINT32_C(0xc0)
name|uint16_t
name|reserved48
index|[
literal|3
index|]
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Create QP command response (16 bytes) */
end_comment

begin_struct
struct|struct
name|creq_create_qp_resp
block|{
name|uint8_t
name|type
decl_stmt|;
comment|/* 	 * This field indicates the exact type of the completion. By convention, 	 * the LSB identifies the length of the record in 16B units. Even values 	 * indicate 16B records. Odd values indicate 32B records. 	 */
define|#
directive|define
name|CREQ_CREATE_QP_RESP_TYPE_MASK
value|UINT32_C(0x3f)
define|#
directive|define
name|CREQ_CREATE_QP_RESP_TYPE_SFT
value|0
comment|/* QP Async Notification */
define|#
directive|define
name|CREQ_CREATE_QP_RESP_TYPE_QP_EVENT
value|UINT32_C(0x38)
define|#
directive|define
name|CREQ_CREATE_QP_RESP_RESERVED2_MASK
value|UINT32_C(0xc0)
define|#
directive|define
name|CREQ_CREATE_QP_RESP_RESERVED2_SFT
value|6
name|uint8_t
name|status
decl_stmt|;
comment|/* Status of the response. */
name|uint16_t
name|cookie
decl_stmt|;
comment|/* Driver supplied handle to associate the command and the response. */
name|uint32_t
name|xid
decl_stmt|;
comment|/* QP context id */
name|uint8_t
name|v
decl_stmt|;
comment|/* 	 * This value is written by the NIC such that it will be different for 	 * each pass through the completion queue. The even passes will write 1. 	 * The odd passes will write 0. 	 */
define|#
directive|define
name|CREQ_CREATE_QP_RESP_V
value|UINT32_C(0x1)
define|#
directive|define
name|CREQ_CREATE_QP_RESP_RESERVED7_MASK
value|UINT32_C(0xfe)
define|#
directive|define
name|CREQ_CREATE_QP_RESP_RESERVED7_SFT
value|1
name|uint8_t
name|event
decl_stmt|;
comment|/* Event or command opcode. */
comment|/* Create QP command response. */
define|#
directive|define
name|CREQ_CREATE_QP_RESP_EVENT_CREATE_QP
value|UINT32_C(0x1)
name|uint16_t
name|reserved48
index|[
literal|3
index|]
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Destroy QP command response (16 bytes) */
end_comment

begin_struct
struct|struct
name|creq_destroy_qp_resp
block|{
name|uint8_t
name|type
decl_stmt|;
comment|/* 	 * This field indicates the exact type of the completion. By convention, 	 * the LSB identifies the length of the record in 16B units. Even values 	 * indicate 16B records. Odd values indicate 32B records. 	 */
define|#
directive|define
name|CREQ_DESTROY_QP_RESP_TYPE_MASK
value|UINT32_C(0x3f)
define|#
directive|define
name|CREQ_DESTROY_QP_RESP_TYPE_SFT
value|0
comment|/* QP Async Notification */
define|#
directive|define
name|CREQ_DESTROY_QP_RESP_TYPE_QP_EVENT
value|UINT32_C(0x38)
define|#
directive|define
name|CREQ_DESTROY_QP_RESP_RESERVED2_MASK
value|UINT32_C(0xc0)
define|#
directive|define
name|CREQ_DESTROY_QP_RESP_RESERVED2_SFT
value|6
name|uint8_t
name|status
decl_stmt|;
comment|/* Status of the response. */
name|uint16_t
name|cookie
decl_stmt|;
comment|/* Driver supplied handle to associate the command and the response. */
name|uint32_t
name|xid
decl_stmt|;
comment|/* QP context id */
name|uint8_t
name|v
decl_stmt|;
comment|/* 	 * This value is written by the NIC such that it will be different for 	 * each pass through the completion queue. The even passes will write 1. 	 * The odd passes will write 0. 	 */
define|#
directive|define
name|CREQ_DESTROY_QP_RESP_V
value|UINT32_C(0x1)
define|#
directive|define
name|CREQ_DESTROY_QP_RESP_RESERVED7_MASK
value|UINT32_C(0xfe)
define|#
directive|define
name|CREQ_DESTROY_QP_RESP_RESERVED7_SFT
value|1
name|uint8_t
name|event
decl_stmt|;
comment|/* Event or command opcode. */
comment|/* Destroy QP command response. */
define|#
directive|define
name|CREQ_DESTROY_QP_RESP_EVENT_DESTROY_QP
value|UINT32_C(0x2)
name|uint16_t
name|reserved48
index|[
literal|3
index|]
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Modify QP command response (16 bytes) */
end_comment

begin_struct
struct|struct
name|creq_modify_qp_resp
block|{
name|uint8_t
name|type
decl_stmt|;
comment|/* 	 * This field indicates the exact type of the completion. By convention, 	 * the LSB identifies the length of the record in 16B units. Even values 	 * indicate 16B records. Odd values indicate 32B records. 	 */
define|#
directive|define
name|CREQ_MODIFY_QP_RESP_TYPE_MASK
value|UINT32_C(0x3f)
define|#
directive|define
name|CREQ_MODIFY_QP_RESP_TYPE_SFT
value|0
comment|/* QP Async Notification */
define|#
directive|define
name|CREQ_MODIFY_QP_RESP_TYPE_QP_EVENT
value|UINT32_C(0x38)
define|#
directive|define
name|CREQ_MODIFY_QP_RESP_RESERVED2_MASK
value|UINT32_C(0xc0)
define|#
directive|define
name|CREQ_MODIFY_QP_RESP_RESERVED2_SFT
value|6
name|uint8_t
name|status
decl_stmt|;
comment|/* Status of the response. */
name|uint16_t
name|cookie
decl_stmt|;
comment|/* Driver supplied handle to associate the command and the response. */
name|uint32_t
name|xid
decl_stmt|;
comment|/* QP context id */
name|uint8_t
name|v
decl_stmt|;
comment|/* 	 * This value is written by the NIC such that it will be different for 	 * each pass through the completion queue. The even passes will write 1. 	 * The odd passes will write 0. 	 */
define|#
directive|define
name|CREQ_MODIFY_QP_RESP_V
value|UINT32_C(0x1)
define|#
directive|define
name|CREQ_MODIFY_QP_RESP_RESERVED7_MASK
value|UINT32_C(0xfe)
define|#
directive|define
name|CREQ_MODIFY_QP_RESP_RESERVED7_SFT
value|1
name|uint8_t
name|event
decl_stmt|;
comment|/* Event or command opcode. */
comment|/* Modify QP command response. */
define|#
directive|define
name|CREQ_MODIFY_QP_RESP_EVENT_MODIFY_QP
value|UINT32_C(0x3)
name|uint16_t
name|reserved48
index|[
literal|3
index|]
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Query QP command response (16 bytes) */
end_comment

begin_struct
struct|struct
name|creq_query_qp_resp
block|{
name|uint8_t
name|type
decl_stmt|;
comment|/* 	 * This field indicates the exact type of the completion. By convention, 	 * the LSB identifies the length of the record in 16B units. Even values 	 * indicate 16B records. Odd values indicate 32B records. 	 */
define|#
directive|define
name|CREQ_QUERY_QP_RESP_TYPE_MASK
value|UINT32_C(0x3f)
define|#
directive|define
name|CREQ_QUERY_QP_RESP_TYPE_SFT
value|0
comment|/* QP Async Notification */
define|#
directive|define
name|CREQ_QUERY_QP_RESP_TYPE_QP_EVENT
value|UINT32_C(0x38)
define|#
directive|define
name|CREQ_QUERY_QP_RESP_RESERVED2_MASK
value|UINT32_C(0xc0)
define|#
directive|define
name|CREQ_QUERY_QP_RESP_RESERVED2_SFT
value|6
name|uint8_t
name|status
decl_stmt|;
comment|/* Status of the response. */
name|uint16_t
name|cookie
decl_stmt|;
comment|/* Driver supplied handle to associate the command and the response. */
name|uint32_t
name|size
decl_stmt|;
comment|/* Side buffer size in 16-byte units */
name|uint8_t
name|v
decl_stmt|;
comment|/* 	 * This value is written by the NIC such that it will be different for 	 * each pass through the completion queue. The even passes will write 1. 	 * The odd passes will write 0. 	 */
define|#
directive|define
name|CREQ_QUERY_QP_RESP_V
value|UINT32_C(0x1)
define|#
directive|define
name|CREQ_QUERY_QP_RESP_RESERVED7_MASK
value|UINT32_C(0xfe)
define|#
directive|define
name|CREQ_QUERY_QP_RESP_RESERVED7_SFT
value|1
name|uint8_t
name|event
decl_stmt|;
comment|/* Event or command opcode. */
comment|/* Query QP command response. */
define|#
directive|define
name|CREQ_QUERY_QP_RESP_EVENT_QUERY_QP
value|UINT32_C(0x4)
name|uint16_t
name|reserved48
index|[
literal|3
index|]
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Query QP command response side buffer structure (104 bytes) */
end_comment

begin_struct
struct|struct
name|creq_query_qp_resp_sb
block|{
name|uint8_t
name|opcode
decl_stmt|;
comment|/* Command opcode. */
comment|/* Query QP command response. */
define|#
directive|define
name|CREQ_QUERY_QP_RESP_SB_OPCODE_QUERY_QP
value|UINT32_C(0x4)
name|uint8_t
name|status
decl_stmt|;
comment|/* Status of the response. */
name|uint16_t
name|cookie
decl_stmt|;
comment|/* Driver supplied handle to associate the command and the response. */
name|uint16_t
name|flags
decl_stmt|;
comment|/* Flags and attribs of the command. */
name|uint8_t
name|resp_size
decl_stmt|;
comment|/* Size of the response buffer in 16-byte units. */
name|uint8_t
name|reserved8
decl_stmt|;
name|uint32_t
name|xid
decl_stmt|;
comment|/* QP context id */
name|uint8_t
name|en_sqd_async_notify_state
decl_stmt|;
comment|/* Enable congestion control. */
comment|/* QP state */
define|#
directive|define
name|CREQ_QUERY_QP_RESP_SB_STATE_MASK
value|UINT32_C(0xf)
define|#
directive|define
name|CREQ_QUERY_QP_RESP_SB_STATE_SFT
value|0
comment|/* Reset. */
define|#
directive|define
name|CREQ_QUERY_QP_RESP_SB_STATE_RESET
value|UINT32_C(0x0)
comment|/* Init. */
define|#
directive|define
name|CREQ_QUERY_QP_RESP_SB_STATE_INIT
value|UINT32_C(0x1)
comment|/* Ready To Receive. */
define|#
directive|define
name|CREQ_QUERY_QP_RESP_SB_STATE_RTR
value|UINT32_C(0x2)
comment|/* Ready To Send. */
define|#
directive|define
name|CREQ_QUERY_QP_RESP_SB_STATE_RTS
value|UINT32_C(0x3)
comment|/* SQ Drain. */
define|#
directive|define
name|CREQ_QUERY_QP_RESP_SB_STATE_SQD
value|UINT32_C(0x4)
comment|/* SQ Error. */
define|#
directive|define
name|CREQ_QUERY_QP_RESP_SB_STATE_SQE
value|UINT32_C(0x5)
comment|/* Error. */
define|#
directive|define
name|CREQ_QUERY_QP_RESP_SB_STATE_ERR
value|UINT32_C(0x6)
comment|/* SQ drain asynchronous notification. */
define|#
directive|define
name|CREQ_QUERY_QP_RESP_SB_EN_SQD_ASYNC_NOTIFY
value|UINT32_C(0x10)
comment|/* Enable congestion control. */
name|uint8_t
name|access
decl_stmt|;
comment|/* Access flags. */
comment|/* Local write access. */
define|#
directive|define
name|CREQ_QUERY_QP_RESP_SB_ACCESS_LOCAL_WRITE
value|UINT32_C(0x1)
comment|/* Remote write access. */
define|#
directive|define
name|CREQ_QUERY_QP_RESP_SB_ACCESS_REMOTE_WRITE
value|UINT32_C(0x2)
comment|/* Remote read access. */
define|#
directive|define
name|CREQ_QUERY_QP_RESP_SB_ACCESS_REMOTE_READ
value|UINT32_C(0x4)
comment|/* Remote atomic access. */
define|#
directive|define
name|CREQ_QUERY_QP_RESP_SB_ACCESS_REMOTE_ATOMIC
value|UINT32_C(0x8)
name|uint16_t
name|pkey
decl_stmt|;
comment|/* P_KEY index. */
name|uint32_t
name|qkey
decl_stmt|;
comment|/* Q_KEY. */
name|uint32_t
name|reserved32
decl_stmt|;
name|uint32_t
name|dgid
index|[
literal|4
index|]
decl_stmt|;
comment|/* Destination GID. */
name|uint32_t
name|flow_label
decl_stmt|;
comment|/* Flow label. */
name|uint16_t
name|sgid_index
decl_stmt|;
comment|/* Source GID index. */
name|uint8_t
name|hop_limit
decl_stmt|;
comment|/* Hop limit. */
name|uint8_t
name|traffic_class
decl_stmt|;
comment|/* Traffic class. */
name|uint16_t
name|dest_mac
index|[
literal|3
index|]
decl_stmt|;
comment|/* Destination MAC address. */
name|uint16_t
name|path_mtu_dest_vlan_id
decl_stmt|;
comment|/* Path MTU. */
comment|/* Destination VLAN ID. */
define|#
directive|define
name|CREQ_QUERY_QP_RESP_SB_DEST_VLAN_ID_MASK
value|UINT32_C(0xfff)
define|#
directive|define
name|CREQ_QUERY_QP_RESP_SB_DEST_VLAN_ID_SFT
value|0
comment|/* Path MTU. */
define|#
directive|define
name|CREQ_QUERY_QP_RESP_SB_PATH_MTU_MASK
value|UINT32_C(0xf000)
define|#
directive|define
name|CREQ_QUERY_QP_RESP_SB_PATH_MTU_SFT
value|12
comment|/* 256. */
define|#
directive|define
name|CREQ_QUERY_QP_RESP_SB_PATH_MTU_MTU_256
value|(UINT32_C(0x0)<< 12)
comment|/* 512. */
define|#
directive|define
name|CREQ_QUERY_QP_RESP_SB_PATH_MTU_MTU_512
value|(UINT32_C(0x1)<< 12)
comment|/* 1024. */
define|#
directive|define
name|CREQ_QUERY_QP_RESP_SB_PATH_MTU_MTU_1024
value|(UINT32_C(0x2)<< 12)
comment|/* 2048. */
define|#
directive|define
name|CREQ_QUERY_QP_RESP_SB_PATH_MTU_MTU_2048
value|(UINT32_C(0x3)<< 12)
comment|/* 4096. */
define|#
directive|define
name|CREQ_QUERY_QP_RESP_SB_PATH_MTU_MTU_4096
value|(UINT32_C(0x4)<< 12)
comment|/* 8192. */
define|#
directive|define
name|CREQ_QUERY_QP_RESP_SB_PATH_MTU_MTU_8192
value|(UINT32_C(0x5)<< 12)
name|uint8_t
name|timeout
decl_stmt|;
comment|/* Timeout value for SWQEs. */
name|uint8_t
name|retry_cnt
decl_stmt|;
comment|/* Max retry count for WQEs. */
name|uint8_t
name|rnr_retry
decl_stmt|;
comment|/* Max RNR retry count for WQEs. */
name|uint8_t
name|min_rnr_timer
decl_stmt|;
comment|/* Min RNR timer that the QP will report to the remote. */
name|uint32_t
name|rq_psn
decl_stmt|;
comment|/* RQ start packet sequence number. */
name|uint32_t
name|sq_psn
decl_stmt|;
comment|/* SQ start packet sequence number. */
name|uint8_t
name|max_rd_atomic
decl_stmt|;
comment|/* Max outstanding RDMA read atomic. */
name|uint8_t
name|max_dest_rd_atomic
decl_stmt|;
comment|/* Max destination outstanding RDMA read atomic. */
name|uint8_t
name|tos_dscp_tos_ecn
decl_stmt|;
comment|/* IP TOS DSCP. */
comment|/* IP TOS ECN. */
define|#
directive|define
name|CREQ_QUERY_QP_RESP_SB_TOS_ECN_MASK
value|UINT32_C(0x3)
define|#
directive|define
name|CREQ_QUERY_QP_RESP_SB_TOS_ECN_SFT
value|0
comment|/* IP TOS DSCP. */
define|#
directive|define
name|CREQ_QUERY_QP_RESP_SB_TOS_DSCP_MASK
value|UINT32_C(0xfc)
define|#
directive|define
name|CREQ_QUERY_QP_RESP_SB_TOS_DSCP_SFT
value|2
name|uint8_t
name|enable_cc
decl_stmt|;
comment|/* enable_cc is 1 b */
define|#
directive|define
name|CREQ_QUERY_QP_RESP_SB_ENABLE_CC
value|UINT32_C(0x1)
define|#
directive|define
name|CREQ_QUERY_QP_RESP_SB_RESERVED7_MASK
value|UINT32_C(0xfe)
define|#
directive|define
name|CREQ_QUERY_QP_RESP_SB_RESERVED7_SFT
value|1
name|uint32_t
name|sq_size
decl_stmt|;
comment|/* Max send WQE. */
name|uint32_t
name|rq_size
decl_stmt|;
comment|/* Max recv WQE. */
name|uint16_t
name|sq_sge
decl_stmt|;
comment|/* Max send SGEs per SWQE. */
name|uint16_t
name|rq_sge
decl_stmt|;
comment|/* Max recv SGEs per RWQE (NOT SUPPORTED BY HARDWARE). */
name|uint32_t
name|max_inline_data
decl_stmt|;
comment|/* Max inline data length (upto 120 bytes). */
name|uint32_t
name|dest_qp_id
decl_stmt|;
comment|/* Destination QP id. */
name|uint32_t
name|unused_1
decl_stmt|;
name|uint16_t
name|src_mac
index|[
literal|3
index|]
decl_stmt|;
comment|/* Source MAC. */
name|uint16_t
name|vlan_pcp_vlan_dei_vlan_id
decl_stmt|;
comment|/* VLAN PCP field - Priority Code Point. */
comment|/* Source VLAN id. */
define|#
directive|define
name|CREQ_QUERY_QP_RESP_SB_VLAN_ID_MASK
value|UINT32_C(0xfff)
define|#
directive|define
name|CREQ_QUERY_QP_RESP_SB_VLAN_ID_SFT
value|0
comment|/* VLAN DEI field - Drop Eligibility Indicator. */
define|#
directive|define
name|CREQ_QUERY_QP_RESP_SB_VLAN_DEI
value|UINT32_C(0x1000)
comment|/* VLAN PCP field - Priority Code Point. */
define|#
directive|define
name|CREQ_QUERY_QP_RESP_SB_VLAN_PCP_MASK
value|UINT32_C(0xe000)
define|#
directive|define
name|CREQ_QUERY_QP_RESP_SB_VLAN_PCP_SFT
value|13
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Create SRQ command response (16 bytes) */
end_comment

begin_struct
struct|struct
name|creq_create_srq_resp
block|{
name|uint8_t
name|type
decl_stmt|;
comment|/* 	 * This field indicates the exact type of the completion. By convention, 	 * the LSB identifies the length of the record in 16B units. Even values 	 * indicate 16B records. Odd values indicate 32B records. 	 */
define|#
directive|define
name|CREQ_CREATE_SRQ_RESP_TYPE_MASK
value|UINT32_C(0x3f)
define|#
directive|define
name|CREQ_CREATE_SRQ_RESP_TYPE_SFT
value|0
comment|/* QP Async Notification */
define|#
directive|define
name|CREQ_CREATE_SRQ_RESP_TYPE_QP_EVENT
value|UINT32_C(0x38)
define|#
directive|define
name|CREQ_CREATE_SRQ_RESP_RESERVED2_MASK
value|UINT32_C(0xc0)
define|#
directive|define
name|CREQ_CREATE_SRQ_RESP_RESERVED2_SFT
value|6
name|uint8_t
name|status
decl_stmt|;
comment|/* Status of the response. */
name|uint16_t
name|cookie
decl_stmt|;
comment|/* Driver supplied handle to associate the command and the response. */
name|uint32_t
name|xid
decl_stmt|;
comment|/* SRQ context id */
name|uint8_t
name|v
decl_stmt|;
comment|/* 	 * This value is written by the NIC such that it will be different for 	 * each pass through the completion queue. The even passes will write 1. 	 * The odd passes will write 0. 	 */
define|#
directive|define
name|CREQ_CREATE_SRQ_RESP_V
value|UINT32_C(0x1)
define|#
directive|define
name|CREQ_CREATE_SRQ_RESP_RESERVED7_MASK
value|UINT32_C(0xfe)
define|#
directive|define
name|CREQ_CREATE_SRQ_RESP_RESERVED7_SFT
value|1
name|uint8_t
name|event
decl_stmt|;
comment|/* Event or command opcode. */
comment|/* Create SRQ command response. */
define|#
directive|define
name|CREQ_CREATE_SRQ_RESP_EVENT_CREATE_SRQ
value|UINT32_C(0x5)
name|uint16_t
name|reserved48
index|[
literal|3
index|]
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Destroy SRQ command response (16 bytes) */
end_comment

begin_struct
struct|struct
name|creq_destroy_srq_resp
block|{
name|uint8_t
name|type
decl_stmt|;
comment|/* 	 * This field indicates the exact type of the completion. By convention, 	 * the LSB identifies the length of the record in 16B units. Even values 	 * indicate 16B records. Odd values indicate 32B records. 	 */
define|#
directive|define
name|CREQ_DESTROY_SRQ_RESP_TYPE_MASK
value|UINT32_C(0x3f)
define|#
directive|define
name|CREQ_DESTROY_SRQ_RESP_TYPE_SFT
value|0
comment|/* QP Async Notification */
define|#
directive|define
name|CREQ_DESTROY_SRQ_RESP_TYPE_QP_EVENT
value|UINT32_C(0x38)
define|#
directive|define
name|CREQ_DESTROY_SRQ_RESP_RESERVED2_MASK
value|UINT32_C(0xc0)
define|#
directive|define
name|CREQ_DESTROY_SRQ_RESP_RESERVED2_SFT
value|6
name|uint8_t
name|status
decl_stmt|;
comment|/* Status of the response. */
name|uint16_t
name|cookie
decl_stmt|;
comment|/* Driver supplied handle to associate the command and the response. */
name|uint32_t
name|xid
decl_stmt|;
comment|/* SRQ context id */
name|uint8_t
name|v
decl_stmt|;
comment|/* 	 * This value is written by the NIC such that it will be different for 	 * each pass through the completion queue. The even passes will write 1. 	 * The odd passes will write 0. 	 */
define|#
directive|define
name|CREQ_DESTROY_SRQ_RESP_V
value|UINT32_C(0x1)
define|#
directive|define
name|CREQ_DESTROY_SRQ_RESP_RESERVED7_MASK
value|UINT32_C(0xfe)
define|#
directive|define
name|CREQ_DESTROY_SRQ_RESP_RESERVED7_SFT
value|1
name|uint8_t
name|event
decl_stmt|;
comment|/* Event or command opcode. */
comment|/* Destroy SRQ command response. */
define|#
directive|define
name|CREQ_DESTROY_SRQ_RESP_EVENT_DESTROY_SRQ
value|UINT32_C(0x6)
name|uint16_t
name|enable_for_arm
index|[
literal|3
index|]
decl_stmt|;
comment|/* Set to 1 if this SRQ is allowed to be armed for threshold async event */
define|#
directive|define
name|CREQ_DESTROY_SRQ_RESP_ENABLE_FOR_ARM_MASK
value|UINT32_C(0x30000)
define|#
directive|define
name|CREQ_DESTROY_SRQ_RESP_ENABLE_FOR_ARM_SFT
value|16
define|#
directive|define
name|CREQ_DESTROY_SRQ_RESP_RESERVED46_MASK
value|UINT32_C(0xfffc0000)
define|#
directive|define
name|CREQ_DESTROY_SRQ_RESP_RESERVED46_SFT
value|18
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Query SRQ command response (16 bytes) */
end_comment

begin_struct
struct|struct
name|creq_query_srq_resp
block|{
name|uint8_t
name|type
decl_stmt|;
comment|/* 	 * This field indicates the exact type of the completion. By convention, 	 * the LSB identifies the length of the record in 16B units. Even values 	 * indicate 16B records. Odd values indicate 32B records. 	 */
define|#
directive|define
name|CREQ_QUERY_SRQ_RESP_TYPE_MASK
value|UINT32_C(0x3f)
define|#
directive|define
name|CREQ_QUERY_SRQ_RESP_TYPE_SFT
value|0
comment|/* QP Async Notification */
define|#
directive|define
name|CREQ_QUERY_SRQ_RESP_TYPE_QP_EVENT
value|UINT32_C(0x38)
define|#
directive|define
name|CREQ_QUERY_SRQ_RESP_RESERVED2_MASK
value|UINT32_C(0xc0)
define|#
directive|define
name|CREQ_QUERY_SRQ_RESP_RESERVED2_SFT
value|6
name|uint8_t
name|status
decl_stmt|;
comment|/* Status of the response. */
name|uint16_t
name|cookie
decl_stmt|;
comment|/* Driver supplied handle to associate the command and the response. */
name|uint32_t
name|size
decl_stmt|;
comment|/* Side buffer size in 16-byte units */
name|uint8_t
name|v
decl_stmt|;
comment|/* 	 * This value is written by the NIC such that it will be different for 	 * each pass through the completion queue. The even passes will write 1. 	 * The odd passes will write 0. 	 */
define|#
directive|define
name|CREQ_QUERY_SRQ_RESP_V
value|UINT32_C(0x1)
define|#
directive|define
name|CREQ_QUERY_SRQ_RESP_RESERVED7_MASK
value|UINT32_C(0xfe)
define|#
directive|define
name|CREQ_QUERY_SRQ_RESP_RESERVED7_SFT
value|1
name|uint8_t
name|event
decl_stmt|;
comment|/* Event or command opcode. */
comment|/* Query SRQ command response. */
define|#
directive|define
name|CREQ_QUERY_SRQ_RESP_EVENT_QUERY_SRQ
value|UINT32_C(0x8)
name|uint16_t
name|reserved48
index|[
literal|3
index|]
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Query SRQ command response side buffer structure (24 bytes) */
end_comment

begin_struct
struct|struct
name|creq_query_srq_resp_sb
block|{
name|uint8_t
name|opcode
decl_stmt|;
comment|/* Command opcode. */
comment|/* Query SRQ command response. */
define|#
directive|define
name|CREQ_QUERY_SRQ_RESP_SB_OPCODE_QUERY_SRQ
value|UINT32_C(0x8)
name|uint8_t
name|status
decl_stmt|;
comment|/* Status of the response. */
name|uint16_t
name|cookie
decl_stmt|;
comment|/* Driver supplied handle to associate the command and the response. */
name|uint16_t
name|flags
decl_stmt|;
comment|/* Flags and attribs of the command. */
name|uint8_t
name|resp_size
decl_stmt|;
comment|/* Size of the response buffer in 16-byte units. */
name|uint8_t
name|reserved8
decl_stmt|;
name|uint32_t
name|xid
decl_stmt|;
comment|/* SRQ context id */
name|uint16_t
name|srq_limit
decl_stmt|;
comment|/* Watermark value to generate a SRQ limit event. */
name|uint16_t
name|reserved16
decl_stmt|;
name|uint32_t
name|data
index|[
literal|4
index|]
decl_stmt|;
comment|/* data is 128 b */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Create CQ command Response (16 bytes) */
end_comment

begin_struct
struct|struct
name|creq_create_cq_resp
block|{
name|uint8_t
name|type
decl_stmt|;
comment|/* 	 * This field indicates the exact type of the completion. By convention, 	 * the LSB identifies the length of the record in 16B units. Even values 	 * indicate 16B records. Odd values indicate 32B records. 	 */
define|#
directive|define
name|CREQ_CREATE_CQ_RESP_TYPE_MASK
value|UINT32_C(0x3f)
define|#
directive|define
name|CREQ_CREATE_CQ_RESP_TYPE_SFT
value|0
comment|/* QP Async Notification */
define|#
directive|define
name|CREQ_CREATE_CQ_RESP_TYPE_QP_EVENT
value|UINT32_C(0x38)
define|#
directive|define
name|CREQ_CREATE_CQ_RESP_RESERVED2_MASK
value|UINT32_C(0xc0)
define|#
directive|define
name|CREQ_CREATE_CQ_RESP_RESERVED2_SFT
value|6
name|uint8_t
name|status
decl_stmt|;
comment|/* Status of the response. */
name|uint16_t
name|cookie
decl_stmt|;
comment|/* Driver supplied handle to associate the command and the response. */
name|uint32_t
name|xid
decl_stmt|;
comment|/* CQ context id */
name|uint8_t
name|v
decl_stmt|;
comment|/* 	 * This value is written by the NIC such that it will be different for 	 * each pass through the completion queue. The even passes will write 1. 	 * The odd passes will write 0. 	 */
define|#
directive|define
name|CREQ_CREATE_CQ_RESP_V
value|UINT32_C(0x1)
define|#
directive|define
name|CREQ_CREATE_CQ_RESP_RESERVED7_MASK
value|UINT32_C(0xfe)
define|#
directive|define
name|CREQ_CREATE_CQ_RESP_RESERVED7_SFT
value|1
name|uint8_t
name|event
decl_stmt|;
comment|/* Event or command opcode. */
comment|/* Create CQ command response. */
define|#
directive|define
name|CREQ_CREATE_CQ_RESP_EVENT_CREATE_CQ
value|UINT32_C(0x9)
name|uint16_t
name|reserved48
index|[
literal|3
index|]
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Destroy CQ command response (16 bytes) */
end_comment

begin_struct
struct|struct
name|creq_destroy_cq_resp
block|{
name|uint8_t
name|type
decl_stmt|;
comment|/* 	 * This field indicates the exact type of the completion. By convention, 	 * the LSB identifies the length of the record in 16B units. Even values 	 * indicate 16B records. Odd values indicate 32B records. 	 */
define|#
directive|define
name|CREQ_DESTROY_CQ_RESP_TYPE_MASK
value|UINT32_C(0x3f)
define|#
directive|define
name|CREQ_DESTROY_CQ_RESP_TYPE_SFT
value|0
comment|/* QP Async Notification */
define|#
directive|define
name|CREQ_DESTROY_CQ_RESP_TYPE_QP_EVENT
value|UINT32_C(0x38)
define|#
directive|define
name|CREQ_DESTROY_CQ_RESP_RESERVED2_MASK
value|UINT32_C(0xc0)
define|#
directive|define
name|CREQ_DESTROY_CQ_RESP_RESERVED2_SFT
value|6
name|uint8_t
name|status
decl_stmt|;
comment|/* Status of the response. */
name|uint16_t
name|cookie
decl_stmt|;
comment|/* Driver supplied handle to associate the command and the response. */
name|uint32_t
name|xid
decl_stmt|;
comment|/* CQ context id */
name|uint8_t
name|v
decl_stmt|;
comment|/* 	 * This value is written by the NIC such that it will be different for 	 * each pass through the completion queue. The even passes will write 1. 	 * The odd passes will write 0. 	 */
define|#
directive|define
name|CREQ_DESTROY_CQ_RESP_V
value|UINT32_C(0x1)
define|#
directive|define
name|CREQ_DESTROY_CQ_RESP_RESERVED7_MASK
value|UINT32_C(0xfe)
define|#
directive|define
name|CREQ_DESTROY_CQ_RESP_RESERVED7_SFT
value|1
name|uint8_t
name|event
decl_stmt|;
comment|/* Event or command opcode. */
comment|/* Destroy CQ command response. */
define|#
directive|define
name|CREQ_DESTROY_CQ_RESP_EVENT_DESTROY_CQ
value|UINT32_C(0xa)
name|uint16_t
name|cq_arm_lvl
decl_stmt|;
comment|/* 	 * CQ ARM Level: 0 ? Not Armed 1 ? Arm SE Only, Generate CNQE only for 	 * incoming Solicted Events 2 ? Arm all, Generate CNQE for Rx and Tx 	 */
define|#
directive|define
name|CREQ_DESTROY_CQ_RESP_CQ_ARM_LVL_MASK
value|UINT32_C(0x3)
define|#
directive|define
name|CREQ_DESTROY_CQ_RESP_CQ_ARM_LVL_SFT
value|0
define|#
directive|define
name|CREQ_DESTROY_CQ_RESP_RESERVED14_MASK
value|UINT32_C(0xfffc)
define|#
directive|define
name|CREQ_DESTROY_CQ_RESP_RESERVED14_SFT
value|2
name|uint16_t
name|total_cnq_events
decl_stmt|;
comment|/* 	 * The total number of CNQ events for the CQ, incremented on each CNQ 	 * event for the CQ (including firmware-generated CQ error 	 * notification). 	 */
name|uint16_t
name|reserved16
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Resize CQ command response (16 bytes) */
end_comment

begin_struct
struct|struct
name|creq_resize_cq_resp
block|{
name|uint8_t
name|type
decl_stmt|;
comment|/* 	 * This field indicates the exact type of the completion. By convention, 	 * the LSB identifies the length of the record in 16B units. Even values 	 * indicate 16B records. Odd values indicate 32B records. 	 */
define|#
directive|define
name|CREQ_RESIZE_CQ_RESP_TYPE_MASK
value|UINT32_C(0x3f)
define|#
directive|define
name|CREQ_RESIZE_CQ_RESP_TYPE_SFT
value|0
comment|/* QP Async Notification */
define|#
directive|define
name|CREQ_RESIZE_CQ_RESP_TYPE_QP_EVENT
value|UINT32_C(0x38)
define|#
directive|define
name|CREQ_RESIZE_CQ_RESP_RESERVED2_MASK
value|UINT32_C(0xc0)
define|#
directive|define
name|CREQ_RESIZE_CQ_RESP_RESERVED2_SFT
value|6
name|uint8_t
name|status
decl_stmt|;
comment|/* Status of the response. */
name|uint16_t
name|cookie
decl_stmt|;
comment|/* Driver supplied handle to associate the command and the response. */
name|uint32_t
name|xid
decl_stmt|;
comment|/* CQ context id */
name|uint8_t
name|v
decl_stmt|;
comment|/* 	 * This value is written by the NIC such that it will be different for 	 * each pass through the completion queue. The even passes will write 1. 	 * The odd passes will write 0. 	 */
define|#
directive|define
name|CREQ_RESIZE_CQ_RESP_V
value|UINT32_C(0x1)
define|#
directive|define
name|CREQ_RESIZE_CQ_RESP_RESERVED7_MASK
value|UINT32_C(0xfe)
define|#
directive|define
name|CREQ_RESIZE_CQ_RESP_RESERVED7_SFT
value|1
name|uint8_t
name|event
decl_stmt|;
comment|/* Event or command opcode. */
comment|/* Resize CQ command response. */
define|#
directive|define
name|CREQ_RESIZE_CQ_RESP_EVENT_RESIZE_CQ
value|UINT32_C(0xc)
name|uint16_t
name|reserved48
index|[
literal|3
index|]
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Allocate MRW command response (16 bytes) */
end_comment

begin_struct
struct|struct
name|creq_allocate_mrw_resp
block|{
name|uint8_t
name|type
decl_stmt|;
comment|/* 	 * This field indicates the exact type of the completion. By convention, 	 * the LSB identifies the length of the record in 16B units. Even values 	 * indicate 16B records. Odd values indicate 32B records. 	 */
define|#
directive|define
name|CREQ_ALLOCATE_MRW_RESP_TYPE_MASK
value|UINT32_C(0x3f)
define|#
directive|define
name|CREQ_ALLOCATE_MRW_RESP_TYPE_SFT
value|0
comment|/* QP Async Notification */
define|#
directive|define
name|CREQ_ALLOCATE_MRW_RESP_TYPE_QP_EVENT
value|UINT32_C(0x38)
define|#
directive|define
name|CREQ_ALLOCATE_MRW_RESP_RESERVED2_MASK
value|UINT32_C(0xc0)
define|#
directive|define
name|CREQ_ALLOCATE_MRW_RESP_RESERVED2_SFT
value|6
name|uint8_t
name|status
decl_stmt|;
comment|/* Status of the response. */
name|uint16_t
name|cookie
decl_stmt|;
comment|/* Driver supplied handle to associate the command and the response. */
name|uint32_t
name|xid
decl_stmt|;
comment|/* L_KEY for MR, R_KEY for MW */
name|uint8_t
name|v
decl_stmt|;
comment|/* 	 * This value is written by the NIC such that it will be different for 	 * each pass through the completion queue. The even passes will write 1. 	 * The odd passes will write 0. 	 */
define|#
directive|define
name|CREQ_ALLOCATE_MRW_RESP_V
value|UINT32_C(0x1)
define|#
directive|define
name|CREQ_ALLOCATE_MRW_RESP_RESERVED7_MASK
value|UINT32_C(0xfe)
define|#
directive|define
name|CREQ_ALLOCATE_MRW_RESP_RESERVED7_SFT
value|1
name|uint8_t
name|event
decl_stmt|;
comment|/* Event or command opcode. */
comment|/* Allocate MRW command response. */
define|#
directive|define
name|CREQ_ALLOCATE_MRW_RESP_EVENT_ALLOCATE_MRW
value|UINT32_C(0xd)
name|uint16_t
name|reserved48
index|[
literal|3
index|]
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* De-allocate key command response (16 bytes) */
end_comment

begin_struct
struct|struct
name|creq_deallocate_key_resp
block|{
name|uint8_t
name|type
decl_stmt|;
comment|/* 	 * This field indicates the exact type of the completion. By convention, 	 * the LSB identifies the length of the record in 16B units. Even values 	 * indicate 16B records. Odd values indicate 32B records. 	 */
define|#
directive|define
name|CREQ_DEALLOCATE_KEY_RESP_TYPE_MASK
value|UINT32_C(0x3f)
define|#
directive|define
name|CREQ_DEALLOCATE_KEY_RESP_TYPE_SFT
value|0
comment|/* QP Async Notification */
define|#
directive|define
name|CREQ_DEALLOCATE_KEY_RESP_TYPE_QP_EVENT
value|UINT32_C(0x38)
define|#
directive|define
name|CREQ_DEALLOCATE_KEY_RESP_RESERVED2_MASK
value|UINT32_C(0xc0)
define|#
directive|define
name|CREQ_DEALLOCATE_KEY_RESP_RESERVED2_SFT
value|6
name|uint8_t
name|status
decl_stmt|;
comment|/* Status of the response. */
name|uint16_t
name|cookie
decl_stmt|;
comment|/* Driver supplied handle to associate the command and the response. */
name|uint32_t
name|xid
decl_stmt|;
comment|/* L_KEY for MR, R_KEY for MW */
name|uint8_t
name|v
decl_stmt|;
comment|/* 	 * This value is written by the NIC such that it will be different for 	 * each pass through the completion queue. The even passes will write 1. 	 * The odd passes will write 0. 	 */
define|#
directive|define
name|CREQ_DEALLOCATE_KEY_RESP_V
value|UINT32_C(0x1)
define|#
directive|define
name|CREQ_DEALLOCATE_KEY_RESP_RESERVED7_MASK
value|UINT32_C(0xfe)
define|#
directive|define
name|CREQ_DEALLOCATE_KEY_RESP_RESERVED7_SFT
value|1
name|uint8_t
name|event
decl_stmt|;
comment|/* Event or command opcode. */
comment|/* De-allocate key command response. */
define|#
directive|define
name|CREQ_DEALLOCATE_KEY_RESP_EVENT_DEALLOCATE_KEY
value|UINT32_C(0xe)
name|uint16_t
name|reserved16
decl_stmt|;
name|uint32_t
name|bound_window_info
decl_stmt|;
comment|/* 	 * This is advisory data to facilitate eventual descruction of lingering 	 * memory regions in Windows. For memory window, it contains non-zero 	 * HWID of a region this window was bound to (without the 8-bit key 	 * portion). The host may check if the region is lingering in destroyed 	 * state and try to destroy it now. For memory region, if deallocation 	 * fails because there are windows bound to this region, this field will 	 * contain approximate number of those windows. This number is read from 	 * the context right before the deregistration is attempted and can 	 * potentially be slightly different from the current number. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Register MR command response (16 bytes) */
end_comment

begin_struct
struct|struct
name|creq_register_mr_resp
block|{
name|uint8_t
name|type
decl_stmt|;
comment|/* 	 * This field indicates the exact type of the completion. By convention, 	 * the LSB identifies the length of the record in 16B units. Even values 	 * indicate 16B records. Odd values indicate 32B records. 	 */
define|#
directive|define
name|CREQ_REGISTER_MR_RESP_TYPE_MASK
value|UINT32_C(0x3f)
define|#
directive|define
name|CREQ_REGISTER_MR_RESP_TYPE_SFT
value|0
comment|/* QP Async Notification */
define|#
directive|define
name|CREQ_REGISTER_MR_RESP_TYPE_QP_EVENT
value|UINT32_C(0x38)
define|#
directive|define
name|CREQ_REGISTER_MR_RESP_RESERVED2_MASK
value|UINT32_C(0xc0)
define|#
directive|define
name|CREQ_REGISTER_MR_RESP_RESERVED2_SFT
value|6
name|uint8_t
name|status
decl_stmt|;
comment|/* Status of the response. */
name|uint16_t
name|cookie
decl_stmt|;
comment|/* Driver supplied handle to associate the command and the response. */
name|uint32_t
name|xid
decl_stmt|;
comment|/* L_KEY */
name|uint8_t
name|v
decl_stmt|;
comment|/* 	 * This value is written by the NIC such that it will be different for 	 * each pass through the completion queue. The even passes will write 1. 	 * The odd passes will write 0. 	 */
define|#
directive|define
name|CREQ_REGISTER_MR_RESP_V
value|UINT32_C(0x1)
define|#
directive|define
name|CREQ_REGISTER_MR_RESP_RESERVED7_MASK
value|UINT32_C(0xfe)
define|#
directive|define
name|CREQ_REGISTER_MR_RESP_RESERVED7_SFT
value|1
name|uint8_t
name|event
decl_stmt|;
comment|/* Event or command opcode. */
comment|/* Register MR command response. */
define|#
directive|define
name|CREQ_REGISTER_MR_RESP_EVENT_REGISTER_MR
value|UINT32_C(0xf)
name|uint16_t
name|reserved48
index|[
literal|3
index|]
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Deregister MR command response (16 bytes) */
end_comment

begin_struct
struct|struct
name|creq_deregister_mr_resp
block|{
name|uint8_t
name|type
decl_stmt|;
comment|/* 	 * This field indicates the exact type of the completion. By convention, 	 * the LSB identifies the length of the record in 16B units. Even values 	 * indicate 16B records. Odd values indicate 32B records. 	 */
define|#
directive|define
name|CREQ_DEREGISTER_MR_RESP_TYPE_MASK
value|UINT32_C(0x3f)
define|#
directive|define
name|CREQ_DEREGISTER_MR_RESP_TYPE_SFT
value|0
comment|/* QP Async Notification */
define|#
directive|define
name|CREQ_DEREGISTER_MR_RESP_TYPE_QP_EVENT
value|UINT32_C(0x38)
define|#
directive|define
name|CREQ_DEREGISTER_MR_RESP_RESERVED2_MASK
value|UINT32_C(0xc0)
define|#
directive|define
name|CREQ_DEREGISTER_MR_RESP_RESERVED2_SFT
value|6
name|uint8_t
name|status
decl_stmt|;
comment|/* Status of the response. */
name|uint16_t
name|cookie
decl_stmt|;
comment|/* Driver supplied handle to associate the command and the response. */
name|uint32_t
name|xid
decl_stmt|;
comment|/* L_KEY */
name|uint8_t
name|v
decl_stmt|;
comment|/* 	 * This value is written by the NIC such that it will be different for 	 * each pass through the completion queue. The even passes will write 1. 	 * The odd passes will write 0. 	 */
define|#
directive|define
name|CREQ_DEREGISTER_MR_RESP_V
value|UINT32_C(0x1)
define|#
directive|define
name|CREQ_DEREGISTER_MR_RESP_RESERVED7_MASK
value|UINT32_C(0xfe)
define|#
directive|define
name|CREQ_DEREGISTER_MR_RESP_RESERVED7_SFT
value|1
name|uint8_t
name|event
decl_stmt|;
comment|/* Event or command opcode. */
comment|/* Deregister MR command response. */
define|#
directive|define
name|CREQ_DEREGISTER_MR_RESP_EVENT_DEREGISTER_MR
value|UINT32_C(0x10)
name|uint16_t
name|reserved16
decl_stmt|;
name|uint32_t
name|bound_windows
decl_stmt|;
comment|/* 	 * If deregister fails because there are windows bound to this region, 	 * this field will contain approximate number of those windows. This 	 * number is read from the context right before the deregistration is 	 * attempted and can potentially be slightly different from the current 	 * number. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Add GID command response (16 bytes) */
end_comment

begin_struct
struct|struct
name|creq_add_gid_resp
block|{
name|uint8_t
name|type
decl_stmt|;
comment|/* 	 * This field indicates the exact type of the completion. By convention, 	 * the LSB identifies the length of the record in 16B units. Even values 	 * indicate 16B records. Odd values indicate 32B records. 	 */
define|#
directive|define
name|CREQ_ADD_GID_RESP_TYPE_MASK
value|UINT32_C(0x3f)
define|#
directive|define
name|CREQ_ADD_GID_RESP_TYPE_SFT
value|0
comment|/* QP Async Notification */
define|#
directive|define
name|CREQ_ADD_GID_RESP_TYPE_QP_EVENT
value|UINT32_C(0x38)
define|#
directive|define
name|CREQ_ADD_GID_RESP_RESERVED2_MASK
value|UINT32_C(0xc0)
define|#
directive|define
name|CREQ_ADD_GID_RESP_RESERVED2_SFT
value|6
name|uint8_t
name|status
decl_stmt|;
comment|/* Status of the response. */
name|uint16_t
name|cookie
decl_stmt|;
comment|/* Driver supplied handle to associate the command and the response. */
name|uint32_t
name|xid
decl_stmt|;
comment|/* GID index */
name|uint8_t
name|v
decl_stmt|;
comment|/* 	 * This value is written by the NIC such that it will be different for 	 * each pass through the completion queue. The even passes will write 1. 	 * The odd passes will write 0. 	 */
define|#
directive|define
name|CREQ_ADD_GID_RESP_V
value|UINT32_C(0x1)
define|#
directive|define
name|CREQ_ADD_GID_RESP_RESERVED7_MASK
value|UINT32_C(0xfe)
define|#
directive|define
name|CREQ_ADD_GID_RESP_RESERVED7_SFT
value|1
name|uint8_t
name|event
decl_stmt|;
comment|/* Event or command opcode. */
comment|/* Add GID command response. */
define|#
directive|define
name|CREQ_ADD_GID_RESP_EVENT_ADD_GID
value|UINT32_C(0x11)
name|uint16_t
name|reserved48
index|[
literal|3
index|]
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Delete GID command response (16 bytes) */
end_comment

begin_struct
struct|struct
name|creq_delete_gid_resp
block|{
name|uint8_t
name|type
decl_stmt|;
comment|/* 	 * This field indicates the exact type of the completion. By convention, 	 * the LSB identifies the length of the record in 16B units. Even values 	 * indicate 16B records. Odd values indicate 32B records. 	 */
define|#
directive|define
name|CREQ_DELETE_GID_RESP_TYPE_MASK
value|UINT32_C(0x3f)
define|#
directive|define
name|CREQ_DELETE_GID_RESP_TYPE_SFT
value|0
comment|/* QP Async Notification */
define|#
directive|define
name|CREQ_DELETE_GID_RESP_TYPE_QP_EVENT
value|UINT32_C(0x38)
define|#
directive|define
name|CREQ_DELETE_GID_RESP_RESERVED2_MASK
value|UINT32_C(0xc0)
define|#
directive|define
name|CREQ_DELETE_GID_RESP_RESERVED2_SFT
value|6
name|uint8_t
name|status
decl_stmt|;
comment|/* Status of the response. */
name|uint16_t
name|cookie
decl_stmt|;
comment|/* Driver supplied handle to associate the command and the response. */
name|uint32_t
name|xid
decl_stmt|;
comment|/* GID index */
name|uint8_t
name|v
decl_stmt|;
comment|/* 	 * This value is written by the NIC such that it will be different for 	 * each pass through the completion queue. The even passes will write 1. 	 * The odd passes will write 0. 	 */
define|#
directive|define
name|CREQ_DELETE_GID_RESP_V
value|UINT32_C(0x1)
define|#
directive|define
name|CREQ_DELETE_GID_RESP_RESERVED7_MASK
value|UINT32_C(0xfe)
define|#
directive|define
name|CREQ_DELETE_GID_RESP_RESERVED7_SFT
value|1
name|uint8_t
name|event
decl_stmt|;
comment|/* Event or command opcode. */
comment|/* Delete GID command response. */
define|#
directive|define
name|CREQ_DELETE_GID_RESP_EVENT_DELETE_GID
value|UINT32_C(0x12)
name|uint16_t
name|reserved48
index|[
literal|3
index|]
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Modify GID command response (16 bytes) */
end_comment

begin_struct
struct|struct
name|creq_modify_gid_resp
block|{
name|uint8_t
name|type
decl_stmt|;
comment|/* 	 * This field indicates the exact type of the completion. By convention, 	 * the LSB identifies the length of the record in 16B units. Even values 	 * indicate 16B records. Odd values indicate 32B records. 	 */
define|#
directive|define
name|CREQ_MODIFY_GID_RESP_TYPE_MASK
value|UINT32_C(0x3f)
define|#
directive|define
name|CREQ_MODIFY_GID_RESP_TYPE_SFT
value|0
comment|/* QP Async Notification */
define|#
directive|define
name|CREQ_MODIFY_GID_RESP_TYPE_QP_EVENT
value|UINT32_C(0x38)
define|#
directive|define
name|CREQ_MODIFY_GID_RESP_RESERVED2_MASK
value|UINT32_C(0xc0)
define|#
directive|define
name|CREQ_MODIFY_GID_RESP_RESERVED2_SFT
value|6
name|uint8_t
name|status
decl_stmt|;
comment|/* Status of the response. */
name|uint16_t
name|cookie
decl_stmt|;
comment|/* Driver supplied handle to associate the command and the response. */
name|uint32_t
name|xid
decl_stmt|;
comment|/* GID index */
name|uint8_t
name|v
decl_stmt|;
comment|/* 	 * This value is written by the NIC such that it will be different for 	 * each pass through the completion queue. The even passes will write 1. 	 * The odd passes will write 0. 	 */
define|#
directive|define
name|CREQ_MODIFY_GID_RESP_V
value|UINT32_C(0x1)
define|#
directive|define
name|CREQ_MODIFY_GID_RESP_RESERVED7_MASK
value|UINT32_C(0xfe)
define|#
directive|define
name|CREQ_MODIFY_GID_RESP_RESERVED7_SFT
value|1
name|uint8_t
name|event
decl_stmt|;
comment|/* Event or command opcode. */
comment|/* Add GID command response. */
define|#
directive|define
name|CREQ_MODIFY_GID_RESP_EVENT_ADD_GID
value|UINT32_C(0x11)
name|uint16_t
name|reserved48
index|[
literal|3
index|]
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Query GID command response (16 bytes) */
end_comment

begin_struct
struct|struct
name|creq_query_gid_resp
block|{
name|uint8_t
name|type
decl_stmt|;
comment|/* 	 * This field indicates the exact type of the completion. By convention, 	 * the LSB identifies the length of the record in 16B units. Even values 	 * indicate 16B records. Odd values indicate 32B records. 	 */
define|#
directive|define
name|CREQ_QUERY_GID_RESP_TYPE_MASK
value|UINT32_C(0x3f)
define|#
directive|define
name|CREQ_QUERY_GID_RESP_TYPE_SFT
value|0
comment|/* QP Async Notification */
define|#
directive|define
name|CREQ_QUERY_GID_RESP_TYPE_QP_EVENT
value|UINT32_C(0x38)
define|#
directive|define
name|CREQ_QUERY_GID_RESP_RESERVED2_MASK
value|UINT32_C(0xc0)
define|#
directive|define
name|CREQ_QUERY_GID_RESP_RESERVED2_SFT
value|6
name|uint8_t
name|status
decl_stmt|;
comment|/* Status of the response. */
name|uint16_t
name|cookie
decl_stmt|;
comment|/* Driver supplied handle to associate the command and the response. */
name|uint32_t
name|size
decl_stmt|;
comment|/* Side buffer size in 16-byte units */
name|uint8_t
name|v
decl_stmt|;
comment|/* 	 * This value is written by the NIC such that it will be different for 	 * each pass through the completion queue. The even passes will write 1. 	 * The odd passes will write 0. 	 */
define|#
directive|define
name|CREQ_QUERY_GID_RESP_V
value|UINT32_C(0x1)
define|#
directive|define
name|CREQ_QUERY_GID_RESP_RESERVED7_MASK
value|UINT32_C(0xfe)
define|#
directive|define
name|CREQ_QUERY_GID_RESP_RESERVED7_SFT
value|1
name|uint8_t
name|event
decl_stmt|;
comment|/* Event or command opcode. */
comment|/* Query GID command response. */
define|#
directive|define
name|CREQ_QUERY_GID_RESP_EVENT_QUERY_GID
value|UINT32_C(0x18)
name|uint16_t
name|reserved48
index|[
literal|3
index|]
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Query GID command response side buffer structure (40 bytes) */
end_comment

begin_struct
struct|struct
name|creq_query_gid_resp_sb
block|{
name|uint8_t
name|opcode
decl_stmt|;
comment|/* Command opcode. */
comment|/* Query GID command response. */
define|#
directive|define
name|CREQ_QUERY_GID_RESP_SB_OPCODE_QUERY_GID
value|UINT32_C(0x18)
name|uint8_t
name|status
decl_stmt|;
comment|/* Status of the response. */
name|uint16_t
name|cookie
decl_stmt|;
comment|/* Driver supplied handle to associate the command and the response. */
name|uint16_t
name|flags
decl_stmt|;
comment|/* Flags and attribs of the command. */
name|uint8_t
name|resp_size
decl_stmt|;
comment|/* Size of the response buffer in 16-byte units. */
name|uint8_t
name|reserved8
decl_stmt|;
name|uint32_t
name|gid
index|[
literal|4
index|]
decl_stmt|;
comment|/* GID */
name|uint16_t
name|src_mac
index|[
literal|3
index|]
decl_stmt|;
comment|/* Source MAC. */
name|uint16_t
name|vlan
decl_stmt|;
comment|/* flags. */
comment|/* Source VLAN id. */
define|#
directive|define
name|CREQ_QUERY_GID_RESP_SB_VLAN_VLAN_ID_MASK
value|UINT32_C(0xfff)
define|#
directive|define
name|CREQ_QUERY_GID_RESP_SB_VLAN_VLAN_ID_SFT
value|0
comment|/* This set of bits select the TPID of the VLAN Tag. */
define|#
directive|define
name|CREQ_QUERY_GID_RESP_SB_VLAN_TPID_MASK
value|UINT32_C(0x7000)
define|#
directive|define
name|CREQ_QUERY_GID_RESP_SB_VLAN_TPID_SFT
value|12
comment|/* TPID = 0x88A8. */
define|#
directive|define
name|CREQ_QUERY_GID_RESP_SB_VLAN_TPID_TPID_88A8
value|(UINT32_C(0x0)<< 12)
comment|/* TPID = 0x8100. */
define|#
directive|define
name|CREQ_QUERY_GID_RESP_SB_VLAN_TPID_TPID_8100
value|(UINT32_C(0x1)<< 12)
comment|/* TPID = 0x9100. */
define|#
directive|define
name|CREQ_QUERY_GID_RESP_SB_VLAN_TPID_TPID_9100
value|(UINT32_C(0x2)<< 12)
comment|/* TPID = 0x9200. */
define|#
directive|define
name|CREQ_QUERY_GID_RESP_SB_VLAN_TPID_TPID_9200
value|(UINT32_C(0x3)<< 12)
comment|/* TPID = 0x9300. */
define|#
directive|define
name|CREQ_QUERY_GID_RESP_SB_VLAN_TPID_TPID_9300
value|(UINT32_C(0x4)<< 12)
comment|/* TPID = Configurable 1. */
define|#
directive|define
name|CREQ_QUERY_GID_RESP_SB_VLAN_TPID_TPID_CFG1
value|(UINT32_C(0x5)<< 12)
comment|/* TPID = Configurable 2. */
define|#
directive|define
name|CREQ_QUERY_GID_RESP_SB_VLAN_TPID_TPID_CFG2
value|(UINT32_C(0x6)<< 12)
comment|/* TPID = Configurable 3. */
define|#
directive|define
name|CREQ_QUERY_GID_RESP_SB_VLAN_TPID_TPID_CFG3
value|(UINT32_C(0x7)<< 12)
define|#
directive|define
name|CREQ_QUERY_GID_RESP_SB_VLAN_TPID_LAST
value|CREQ_QUERY_GID_RESP_SB_VLAN_TPID_TPID_CFG3
comment|/* 	 * Setting this bit to 1 enables insertion of a VLAN Tag to a RoCE 	 * header. 	 */
define|#
directive|define
name|CREQ_QUERY_GID_RESP_SB_VLAN_VLAN_EN
value|UINT32_C(0x8000)
name|uint16_t
name|ipid
decl_stmt|;
comment|/* Identifier field in the IP header. */
name|uint16_t
name|gid_index
decl_stmt|;
comment|/* GID index */
name|uint32_t
name|unused_0
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Create QP1 command response (16 bytes) */
end_comment

begin_struct
struct|struct
name|creq_create_qp1_resp
block|{
name|uint8_t
name|type
decl_stmt|;
comment|/* 	 * This field indicates the exact type of the completion. By convention, 	 * the LSB identifies the length of the record in 16B units. Even values 	 * indicate 16B records. Odd values indicate 32B records. 	 */
define|#
directive|define
name|CREQ_CREATE_QP1_RESP_TYPE_MASK
value|UINT32_C(0x3f)
define|#
directive|define
name|CREQ_CREATE_QP1_RESP_TYPE_SFT
value|0
comment|/* QP Async Notification */
define|#
directive|define
name|CREQ_CREATE_QP1_RESP_TYPE_QP_EVENT
value|UINT32_C(0x38)
define|#
directive|define
name|CREQ_CREATE_QP1_RESP_RESERVED2_MASK
value|UINT32_C(0xc0)
define|#
directive|define
name|CREQ_CREATE_QP1_RESP_RESERVED2_SFT
value|6
name|uint8_t
name|status
decl_stmt|;
comment|/* Status of the response. */
name|uint16_t
name|cookie
decl_stmt|;
comment|/* Driver supplied handle to associate the command and the response. */
name|uint32_t
name|xid
decl_stmt|;
comment|/* QP1 context id */
name|uint8_t
name|v
decl_stmt|;
comment|/* 	 * This value is written by the NIC such that it will be different for 	 * each pass through the completion queue. The even passes will write 1. 	 * The odd passes will write 0. 	 */
define|#
directive|define
name|CREQ_CREATE_QP1_RESP_V
value|UINT32_C(0x1)
define|#
directive|define
name|CREQ_CREATE_QP1_RESP_RESERVED7_MASK
value|UINT32_C(0xfe)
define|#
directive|define
name|CREQ_CREATE_QP1_RESP_RESERVED7_SFT
value|1
name|uint8_t
name|event
decl_stmt|;
comment|/* Event or command opcode. */
comment|/* Create QP1 command response. */
define|#
directive|define
name|CREQ_CREATE_QP1_RESP_EVENT_CREATE_QP1
value|UINT32_C(0x13)
name|uint16_t
name|reserved48
index|[
literal|3
index|]
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Destroy QP1 command response (16 bytes) */
end_comment

begin_struct
struct|struct
name|creq_destroy_qp1_resp
block|{
name|uint8_t
name|type
decl_stmt|;
comment|/* 	 * This field indicates the exact type of the completion. By convention, 	 * the LSB identifies the length of the record in 16B units. Even values 	 * indicate 16B records. Odd values indicate 32B records. 	 */
define|#
directive|define
name|CREQ_DESTROY_QP1_RESP_TYPE_MASK
value|UINT32_C(0x3f)
define|#
directive|define
name|CREQ_DESTROY_QP1_RESP_TYPE_SFT
value|0
comment|/* QP Async Notification */
define|#
directive|define
name|CREQ_DESTROY_QP1_RESP_TYPE_QP_EVENT
value|UINT32_C(0x38)
define|#
directive|define
name|CREQ_DESTROY_QP1_RESP_RESERVED2_MASK
value|UINT32_C(0xc0)
define|#
directive|define
name|CREQ_DESTROY_QP1_RESP_RESERVED2_SFT
value|6
name|uint8_t
name|status
decl_stmt|;
comment|/* Status of the response. */
name|uint16_t
name|cookie
decl_stmt|;
comment|/* Driver supplied handle to associate the command and the response. */
name|uint32_t
name|xid
decl_stmt|;
comment|/* QP1 context id */
name|uint8_t
name|v
decl_stmt|;
comment|/* 	 * This value is written by the NIC such that it will be different for 	 * each pass through the completion queue. The even passes will write 1. 	 * The odd passes will write 0. 	 */
define|#
directive|define
name|CREQ_DESTROY_QP1_RESP_V
value|UINT32_C(0x1)
define|#
directive|define
name|CREQ_DESTROY_QP1_RESP_RESERVED7_MASK
value|UINT32_C(0xfe)
define|#
directive|define
name|CREQ_DESTROY_QP1_RESP_RESERVED7_SFT
value|1
name|uint8_t
name|event
decl_stmt|;
comment|/* Event or command opcode. */
comment|/* Destroy QP1 command response. */
define|#
directive|define
name|CREQ_DESTROY_QP1_RESP_EVENT_DESTROY_QP1
value|UINT32_C(0x14)
name|uint16_t
name|reserved48
index|[
literal|3
index|]
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Create AH command response (16 bytes) */
end_comment

begin_struct
struct|struct
name|creq_create_ah_resp
block|{
name|uint8_t
name|type
decl_stmt|;
comment|/* 	 * This field indicates the exact type of the completion. By convention, 	 * the LSB identifies the length of the record in 16B units. Even values 	 * indicate 16B records. Odd values indicate 32B records. 	 */
define|#
directive|define
name|CREQ_CREATE_AH_RESP_TYPE_MASK
value|UINT32_C(0x3f)
define|#
directive|define
name|CREQ_CREATE_AH_RESP_TYPE_SFT
value|0
comment|/* QP Async Notification */
define|#
directive|define
name|CREQ_CREATE_AH_RESP_TYPE_QP_EVENT
value|UINT32_C(0x38)
define|#
directive|define
name|CREQ_CREATE_AH_RESP_RESERVED2_MASK
value|UINT32_C(0xc0)
define|#
directive|define
name|CREQ_CREATE_AH_RESP_RESERVED2_SFT
value|6
name|uint8_t
name|status
decl_stmt|;
comment|/* Status of the response. */
name|uint16_t
name|cookie
decl_stmt|;
comment|/* Driver supplied handle to associate the command and the response. */
name|uint32_t
name|xid
decl_stmt|;
comment|/* AH context id */
name|uint8_t
name|v
decl_stmt|;
comment|/* 	 * This value is written by the NIC such that it will be different for 	 * each pass through the completion queue. The even passes will write 1. 	 * The odd passes will write 0. 	 */
define|#
directive|define
name|CREQ_CREATE_AH_RESP_V
value|UINT32_C(0x1)
define|#
directive|define
name|CREQ_CREATE_AH_RESP_RESERVED7_MASK
value|UINT32_C(0xfe)
define|#
directive|define
name|CREQ_CREATE_AH_RESP_RESERVED7_SFT
value|1
name|uint8_t
name|event
decl_stmt|;
comment|/* Event or command opcode. */
comment|/* Create AH command response. */
define|#
directive|define
name|CREQ_CREATE_AH_RESP_EVENT_CREATE_AH
value|UINT32_C(0x15)
name|uint16_t
name|reserved48
index|[
literal|3
index|]
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Destroy AH command response (16 bytes) */
end_comment

begin_struct
struct|struct
name|creq_destroy_ah_resp
block|{
name|uint8_t
name|type
decl_stmt|;
comment|/* 	 * This field indicates the exact type of the completion. By convention, 	 * the LSB identifies the length of the record in 16B units. Even values 	 * indicate 16B records. Odd values indicate 32B records. 	 */
define|#
directive|define
name|CREQ_DESTROY_AH_RESP_TYPE_MASK
value|UINT32_C(0x3f)
define|#
directive|define
name|CREQ_DESTROY_AH_RESP_TYPE_SFT
value|0
comment|/* QP Async Notification */
define|#
directive|define
name|CREQ_DESTROY_AH_RESP_TYPE_QP_EVENT
value|UINT32_C(0x38)
define|#
directive|define
name|CREQ_DESTROY_AH_RESP_RESERVED2_MASK
value|UINT32_C(0xc0)
define|#
directive|define
name|CREQ_DESTROY_AH_RESP_RESERVED2_SFT
value|6
name|uint8_t
name|status
decl_stmt|;
comment|/* Status of the response. */
name|uint16_t
name|cookie
decl_stmt|;
comment|/* Driver supplied handle to associate the command and the response. */
name|uint32_t
name|xid
decl_stmt|;
comment|/* AH context id */
name|uint8_t
name|v
decl_stmt|;
comment|/* 	 * This value is written by the NIC such that it will be different for 	 * each pass through the completion queue. The even passes will write 1. 	 * The odd passes will write 0. 	 */
define|#
directive|define
name|CREQ_DESTROY_AH_RESP_V
value|UINT32_C(0x1)
define|#
directive|define
name|CREQ_DESTROY_AH_RESP_RESERVED7_MASK
value|UINT32_C(0xfe)
define|#
directive|define
name|CREQ_DESTROY_AH_RESP_RESERVED7_SFT
value|1
name|uint8_t
name|event
decl_stmt|;
comment|/* Event or command opcode. */
comment|/* Destroy AH command response. */
define|#
directive|define
name|CREQ_DESTROY_AH_RESP_EVENT_DESTROY_AH
value|UINT32_C(0x16)
name|uint16_t
name|reserved48
index|[
literal|3
index|]
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Initialize Firmware command response (16 bytes) */
end_comment

begin_struct
struct|struct
name|creq_initialize_fw_resp
block|{
name|uint8_t
name|type
decl_stmt|;
comment|/* 	 * This field indicates the exact type of the completion. By convention, 	 * the LSB identifies the length of the record in 16B units. Even values 	 * indicate 16B records. Odd values indicate 32B records. 	 */
define|#
directive|define
name|CREQ_INITIALIZE_FW_RESP_TYPE_MASK
value|UINT32_C(0x3f)
define|#
directive|define
name|CREQ_INITIALIZE_FW_RESP_TYPE_SFT
value|0
comment|/* QP Async Notification */
define|#
directive|define
name|CREQ_INITIALIZE_FW_RESP_TYPE_QP_EVENT
value|UINT32_C(0x38)
define|#
directive|define
name|CREQ_INITIALIZE_FW_RESP_RESERVED2_MASK
value|UINT32_C(0xc0)
define|#
directive|define
name|CREQ_INITIALIZE_FW_RESP_RESERVED2_SFT
value|6
name|uint8_t
name|status
decl_stmt|;
comment|/* Status of the response. */
name|uint16_t
name|cookie
decl_stmt|;
comment|/* Driver supplied handle to associate the command and the response. */
name|uint32_t
name|reserved32
decl_stmt|;
name|uint8_t
name|v
decl_stmt|;
comment|/* 	 * This value is written by the NIC such that it will be different for 	 * each pass through the completion queue. The even passes will write 1. 	 * The odd passes will write 0. 	 */
define|#
directive|define
name|CREQ_INITIALIZE_FW_RESP_V
value|UINT32_C(0x1)
define|#
directive|define
name|CREQ_INITIALIZE_FW_RESP_RESERVED7_MASK
value|UINT32_C(0xfe)
define|#
directive|define
name|CREQ_INITIALIZE_FW_RESP_RESERVED7_SFT
value|1
name|uint8_t
name|event
decl_stmt|;
comment|/* Event or command opcode. */
comment|/* Initialize firmware command response. */
define|#
directive|define
name|CREQ_INITIALIZE_FW_RESP_EVENT_INITIALIZE_FW
value|UINT32_C(0x80)
name|uint16_t
name|reserved48
index|[
literal|3
index|]
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* De-initialize Firmware command response (16 bytes) */
end_comment

begin_struct
struct|struct
name|creq_deinitialize_fw_resp
block|{
name|uint8_t
name|type
decl_stmt|;
comment|/* 	 * This field indicates the exact type of the completion. By convention, 	 * the LSB identifies the length of the record in 16B units. Even values 	 * indicate 16B records. Odd values indicate 32B records. 	 */
define|#
directive|define
name|CREQ_DEINITIALIZE_FW_RESP_TYPE_MASK
value|UINT32_C(0x3f)
define|#
directive|define
name|CREQ_DEINITIALIZE_FW_RESP_TYPE_SFT
value|0
comment|/* QP Async Notification */
define|#
directive|define
name|CREQ_DEINITIALIZE_FW_RESP_TYPE_QP_EVENT
value|UINT32_C(0x38)
define|#
directive|define
name|CREQ_DEINITIALIZE_FW_RESP_RESERVED2_MASK
value|UINT32_C(0xc0)
define|#
directive|define
name|CREQ_DEINITIALIZE_FW_RESP_RESERVED2_SFT
value|6
name|uint8_t
name|status
decl_stmt|;
comment|/* Status of the response. */
name|uint16_t
name|cookie
decl_stmt|;
comment|/* Driver supplied handle to associate the command and the response. */
name|uint32_t
name|reserved32
decl_stmt|;
name|uint8_t
name|v
decl_stmt|;
comment|/* 	 * This value is written by the NIC such that it will be different for 	 * each pass through the completion queue. The even passes will write 1. 	 * The odd passes will write 0. 	 */
define|#
directive|define
name|CREQ_DEINITIALIZE_FW_RESP_V
value|UINT32_C(0x1)
define|#
directive|define
name|CREQ_DEINITIALIZE_FW_RESP_RESERVED7_MASK
value|UINT32_C(0xfe)
define|#
directive|define
name|CREQ_DEINITIALIZE_FW_RESP_RESERVED7_SFT
value|1
name|uint8_t
name|event
decl_stmt|;
comment|/* Event or command opcode. */
comment|/* De-initialize firmware command response. */
define|#
directive|define
name|CREQ_DEINITIALIZE_FW_RESP_EVENT_DEINITIALIZE_FW
value|UINT32_C(0x81)
name|uint16_t
name|reserved48
index|[
literal|3
index|]
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Stop function command response (16 bytes) */
end_comment

begin_struct
struct|struct
name|creq_stop_func_resp
block|{
name|uint8_t
name|type
decl_stmt|;
comment|/* 	 * This field indicates the exact type of the completion. By convention, 	 * the LSB identifies the length of the record in 16B units. Even values 	 * indicate 16B records. Odd values indicate 32B records. 	 */
define|#
directive|define
name|CREQ_STOP_FUNC_RESP_TYPE_MASK
value|UINT32_C(0x3f)
define|#
directive|define
name|CREQ_STOP_FUNC_RESP_TYPE_SFT
value|0
comment|/* QP Async Notification */
define|#
directive|define
name|CREQ_STOP_FUNC_RESP_TYPE_QP_EVENT
value|UINT32_C(0x38)
define|#
directive|define
name|CREQ_STOP_FUNC_RESP_RESERVED2_MASK
value|UINT32_C(0xc0)
define|#
directive|define
name|CREQ_STOP_FUNC_RESP_RESERVED2_SFT
value|6
name|uint8_t
name|status
decl_stmt|;
comment|/* Status of the response. */
name|uint16_t
name|cookie
decl_stmt|;
comment|/* Driver supplied handle to associate the command and the response. */
name|uint32_t
name|reserved32
decl_stmt|;
name|uint8_t
name|v
decl_stmt|;
comment|/* 	 * This value is written by the NIC such that it will be different for 	 * each pass through the completion queue. The even passes will write 1. 	 * The odd passes will write 0. 	 */
define|#
directive|define
name|CREQ_STOP_FUNC_RESP_V
value|UINT32_C(0x1)
define|#
directive|define
name|CREQ_STOP_FUNC_RESP_RESERVED7_MASK
value|UINT32_C(0xfe)
define|#
directive|define
name|CREQ_STOP_FUNC_RESP_RESERVED7_SFT
value|1
name|uint8_t
name|event
decl_stmt|;
comment|/* Event or command opcode. */
comment|/* Stop PF command response. */
define|#
directive|define
name|CREQ_STOP_FUNC_RESP_EVENT_STOP_FUNC
value|UINT32_C(0x82)
name|uint16_t
name|reserved48
index|[
literal|3
index|]
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Query function command response (16 bytes) */
end_comment

begin_struct
struct|struct
name|creq_query_func_resp
block|{
name|uint8_t
name|type
decl_stmt|;
comment|/* 	 * This field indicates the exact type of the completion. By convention, 	 * the LSB identifies the length of the record in 16B units. Even values 	 * indicate 16B records. Odd values indicate 32B records. 	 */
define|#
directive|define
name|CREQ_QUERY_FUNC_RESP_TYPE_MASK
value|UINT32_C(0x3f)
define|#
directive|define
name|CREQ_QUERY_FUNC_RESP_TYPE_SFT
value|0
comment|/* QP Async Notification */
define|#
directive|define
name|CREQ_QUERY_FUNC_RESP_TYPE_QP_EVENT
value|UINT32_C(0x38)
define|#
directive|define
name|CREQ_QUERY_FUNC_RESP_RESERVED2_MASK
value|UINT32_C(0xc0)
define|#
directive|define
name|CREQ_QUERY_FUNC_RESP_RESERVED2_SFT
value|6
name|uint8_t
name|status
decl_stmt|;
comment|/* Status of the response. */
name|uint16_t
name|cookie
decl_stmt|;
comment|/* Driver supplied handle to associate the command and the response. */
name|uint32_t
name|size
decl_stmt|;
comment|/* Side buffer size in 16-byte units */
name|uint8_t
name|v
decl_stmt|;
comment|/* 	 * This value is written by the NIC such that it will be different for 	 * each pass through the completion queue. The even passes will write 1. 	 * The odd passes will write 0. 	 */
define|#
directive|define
name|CREQ_QUERY_FUNC_RESP_V
value|UINT32_C(0x1)
define|#
directive|define
name|CREQ_QUERY_FUNC_RESP_RESERVED7_MASK
value|UINT32_C(0xfe)
define|#
directive|define
name|CREQ_QUERY_FUNC_RESP_RESERVED7_SFT
value|1
name|uint8_t
name|event
decl_stmt|;
comment|/* Event or command opcode. */
comment|/* Query info PF command response. */
define|#
directive|define
name|CREQ_QUERY_FUNC_RESP_EVENT_QUERY_FUNC
value|UINT32_C(0x83)
name|uint16_t
name|reserved48
index|[
literal|3
index|]
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Query function command response side buffer structure (88 bytes) */
end_comment

begin_struct
struct|struct
name|creq_query_func_resp_sb
block|{
name|uint8_t
name|opcode
decl_stmt|;
comment|/* Command opcode. */
comment|/* Query info PF command response. */
define|#
directive|define
name|CREQ_QUERY_FUNC_RESP_SB_OPCODE_QUERY_FUNC
value|UINT32_C(0x83)
name|uint8_t
name|status
decl_stmt|;
comment|/* Status of the response. */
name|uint16_t
name|cookie
decl_stmt|;
comment|/* Driver supplied handle to associate the command and the response. */
name|uint16_t
name|flags
decl_stmt|;
comment|/* Flags and attribs of the command. */
name|uint8_t
name|resp_size
decl_stmt|;
comment|/* Size of the response buffer in 16-byte units. */
name|uint8_t
name|reserved8
decl_stmt|;
name|uint64_t
name|max_mr_size
decl_stmt|;
comment|/* Max MR size supported. */
name|uint32_t
name|max_qp
decl_stmt|;
comment|/* Max QP supported. */
name|uint16_t
name|max_qp_wr
decl_stmt|;
comment|/* Max WQEs per QP. */
name|uint16_t
name|dev_cap_flags
decl_stmt|;
comment|/* Device capability flags. */
comment|/* Allow QP resizing. */
define|#
directive|define
name|CREQ_QUERY_FUNC_RESP_SB_DEV_CAP_FLAGS_RESIZE_QP
value|UINT32_C(0x1)
name|uint32_t
name|max_cq
decl_stmt|;
comment|/* Max CQs supported. */
name|uint32_t
name|max_cqe
decl_stmt|;
comment|/* Max CQEs per CQ supported. */
name|uint32_t
name|max_pd
decl_stmt|;
comment|/* Max PDs supported. */
name|uint8_t
name|max_sge
decl_stmt|;
comment|/* Max SGEs per QP WQE supported. */
name|uint8_t
name|max_srq_sge
decl_stmt|;
comment|/* Max SGEs per SRQ WQE supported. */
name|uint8_t
name|max_qp_rd_atom
decl_stmt|;
comment|/* Max outstanding RDMA read& atomic supported. */
name|uint8_t
name|max_qp_init_rd_atom
decl_stmt|;
comment|/* 	 * Max outstanding RDMA read& atomic that can be sent from an 	 * initiator. 	 */
name|uint32_t
name|max_mr
decl_stmt|;
comment|/* Max MRs supported. */
name|uint32_t
name|max_mw
decl_stmt|;
comment|/* Max MWs supported. */
name|uint32_t
name|max_raw_eth_qp
decl_stmt|;
comment|/* Max Raw Ethertype QPs supported. */
name|uint32_t
name|max_ah
decl_stmt|;
comment|/* Max AHs supported. */
name|uint32_t
name|max_fmr
decl_stmt|;
comment|/* Max FMRs supported. */
name|uint32_t
name|max_srq_wr
decl_stmt|;
comment|/* Max WQEs per SRQ supported. */
name|uint32_t
name|max_pkeys
decl_stmt|;
comment|/* Max PKEYs supported. */
name|uint32_t
name|max_inline_data
decl_stmt|;
comment|/* Max inline data supported. */
name|uint8_t
name|max_map_per_fmr
decl_stmt|;
comment|/* Max mappings per FMR supported. */
name|uint8_t
name|l2_db_space_size
decl_stmt|;
comment|/* L2 DB space size in pages. */
name|uint16_t
name|max_srq
decl_stmt|;
comment|/* Max SRQs supported. */
name|uint32_t
name|max_gid
decl_stmt|;
comment|/* Max GIDs supported. */
name|uint32_t
name|tqm_alloc_reqs
index|[
literal|12
index|]
decl_stmt|;
comment|/* 	 * An array of 48 8-bit values to specify allocation multiplier for TQM 	 * host buffer regions. Each region occupies 16 MB of TQM PBL address 	 * space: 0x00000000, 0x01000000, 0x02000000, etc. The host needs to 	 * allocate (<Number of QPs>*multiplier, rounded up to page size) of 	 * physical memory for non-zero slots and map the pages to the 	 * corresponding 16MB regions. Typically there are total 3 non-zero 	 * values in this array, their values are 16, 16, 12. Cu+ will only 	 * populate up to index 11. SR may populate up to index 47. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Set resources command response (16 bytes) */
end_comment

begin_struct
struct|struct
name|creq_set_func_resources_resp
block|{
name|uint8_t
name|type
decl_stmt|;
comment|/* 	 * This field indicates the exact type of the completion. By convention, 	 * the LSB identifies the length of the record in 16B units. Even values 	 * indicate 16B records. Odd values indicate 32B records. 	 */
define|#
directive|define
name|CREQ_SET_FUNC_RESOURCES_RESP_TYPE_MASK
value|UINT32_C(0x3f)
define|#
directive|define
name|CREQ_SET_FUNC_RESOURCES_RESP_TYPE_SFT
value|0
comment|/* QP Async Notification */
define|#
directive|define
name|CREQ_SET_FUNC_RESOURCES_RESP_TYPE_QP_EVENT
value|UINT32_C(0x38)
define|#
directive|define
name|CREQ_SET_FUNC_RESOURCES_RESP_RESERVED2_MASK
value|UINT32_C(0xc0)
define|#
directive|define
name|CREQ_SET_FUNC_RESOURCES_RESP_RESERVED2_SFT
value|6
name|uint8_t
name|status
decl_stmt|;
comment|/* Status of the response. */
name|uint16_t
name|cookie
decl_stmt|;
comment|/* Driver supplied handle to associate the command and the response. */
name|uint32_t
name|reserved32
decl_stmt|;
name|uint8_t
name|v
decl_stmt|;
comment|/* 	 * This value is written by the NIC such that it will be different for 	 * each pass through the completion queue. The even passes will write 1. 	 * The odd passes will write 0. 	 */
define|#
directive|define
name|CREQ_SET_FUNC_RESOURCES_RESP_V
value|UINT32_C(0x1)
define|#
directive|define
name|CREQ_SET_FUNC_RESOURCES_RESP_RESERVED7_MASK
value|UINT32_C(0xfe)
define|#
directive|define
name|CREQ_SET_FUNC_RESOURCES_RESP_RESERVED7_SFT
value|1
name|uint8_t
name|event
decl_stmt|;
comment|/* Event or command opcode. */
comment|/* Set function resources command response. */
define|#
directive|define
name|CREQ_SET_FUNC_RESOURCES_RESP_EVENT_SET_FUNC_RESOURCES
value|UINT32_C(0x84)
name|uint16_t
name|reserved48
index|[
literal|3
index|]
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Map TC to COS response (16 bytes) */
end_comment

begin_struct
struct|struct
name|creq_map_tc_to_cos_resp
block|{
name|uint8_t
name|type
decl_stmt|;
comment|/* 	 * This field indicates the exact type of the completion. By convention, 	 * the LSB identifies the length of the record in 16B units. Even values 	 * indicate 16B records. Odd values indicate 32B records. 	 */
define|#
directive|define
name|CREQ_MAP_TC_TO_COS_RESP_TYPE_MASK
value|UINT32_C(0x3f)
define|#
directive|define
name|CREQ_MAP_TC_TO_COS_RESP_TYPE_SFT
value|0
comment|/* QP Async Notification */
define|#
directive|define
name|CREQ_MAP_TC_TO_COS_RESP_TYPE_QP_EVENT
value|UINT32_C(0x38)
define|#
directive|define
name|CREQ_MAP_TC_TO_COS_RESP_RESERVED2_MASK
value|UINT32_C(0xc0)
define|#
directive|define
name|CREQ_MAP_TC_TO_COS_RESP_RESERVED2_SFT
value|6
name|uint8_t
name|status
decl_stmt|;
comment|/* Status of the response. */
name|uint16_t
name|cookie
decl_stmt|;
comment|/* Driver supplied handle to associate the command and the response. */
name|uint32_t
name|reserved32
decl_stmt|;
name|uint8_t
name|v
decl_stmt|;
comment|/* 	 * This value is written by the NIC such that it will be different for 	 * each pass through the completion queue. The even passes will write 1. 	 * The odd passes will write 0. 	 */
define|#
directive|define
name|CREQ_MAP_TC_TO_COS_RESP_V
value|UINT32_C(0x1)
define|#
directive|define
name|CREQ_MAP_TC_TO_COS_RESP_RESERVED7_MASK
value|UINT32_C(0xfe)
define|#
directive|define
name|CREQ_MAP_TC_TO_COS_RESP_RESERVED7_SFT
value|1
name|uint8_t
name|event
decl_stmt|;
comment|/* Event or command opcode. */
comment|/* Map TC to COS response. */
define|#
directive|define
name|CREQ_MAP_TC_TO_COS_RESP_EVENT_MAP_TC_TO_COS
value|UINT32_C(0x8a)
name|uint16_t
name|reserved48
index|[
literal|3
index|]
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Query version response (16 bytes) */
end_comment

begin_struct
struct|struct
name|creq_query_version_resp
block|{
name|uint8_t
name|type
decl_stmt|;
comment|/* 	 * This field indicates the exact type of the completion. By convention, 	 * the LSB identifies the length of the record in 16B units. Even values 	 * indicate 16B records. Odd values indicate 32B records. 	 */
define|#
directive|define
name|CREQ_QUERY_VERSION_RESP_TYPE_MASK
value|UINT32_C(0x3f)
define|#
directive|define
name|CREQ_QUERY_VERSION_RESP_TYPE_SFT
value|0
comment|/* QP Async Notification */
define|#
directive|define
name|CREQ_QUERY_VERSION_RESP_TYPE_QP_EVENT
value|UINT32_C(0x38)
define|#
directive|define
name|CREQ_QUERY_VERSION_RESP_RESERVED2_MASK
value|UINT32_C(0xc0)
define|#
directive|define
name|CREQ_QUERY_VERSION_RESP_RESERVED2_SFT
value|6
name|uint8_t
name|status
decl_stmt|;
comment|/* Status of the response. */
name|uint16_t
name|cookie
decl_stmt|;
comment|/* Driver supplied handle to associate the command and the response. */
name|uint8_t
name|fw_maj
decl_stmt|;
comment|/* firmware major version */
name|uint8_t
name|fw_minor
decl_stmt|;
comment|/* firmware minor version */
name|uint8_t
name|fw_bld
decl_stmt|;
comment|/* firmware build version */
name|uint8_t
name|fw_rsvd
decl_stmt|;
comment|/* firmware reserved version */
name|uint8_t
name|v
decl_stmt|;
comment|/* 	 * This value is written by the NIC such that it will be different for 	 * each pass through the completion queue. The even passes will write 1. 	 * The odd passes will write 0. 	 */
define|#
directive|define
name|CREQ_QUERY_VERSION_RESP_V
value|UINT32_C(0x1)
define|#
directive|define
name|CREQ_QUERY_VERSION_RESP_RESERVED7_MASK
value|UINT32_C(0xfe)
define|#
directive|define
name|CREQ_QUERY_VERSION_RESP_RESERVED7_SFT
value|1
name|uint8_t
name|event
decl_stmt|;
comment|/* Event or command opcode. */
comment|/* Query firmware and interface version response. */
define|#
directive|define
name|CREQ_QUERY_VERSION_RESP_EVENT_QUERY_VERSION
value|UINT32_C(0x8b)
name|uint16_t
name|reserved16
decl_stmt|;
name|uint8_t
name|intf_maj
decl_stmt|;
comment|/* interface major version */
name|uint8_t
name|intf_minor
decl_stmt|;
comment|/* interface minor version */
name|uint8_t
name|intf_bld
decl_stmt|;
comment|/* interface build version */
name|uint8_t
name|intf_rsvd
decl_stmt|;
comment|/* interface reserved version */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Modify congestion control command response (16 bytes) */
end_comment

begin_struct
struct|struct
name|creq_modify_roce_cc_resp
block|{
name|uint8_t
name|type
decl_stmt|;
comment|/* 	 * This field indicates the exact type of the completion. By convention, 	 * the LSB identifies the length of the record in 16B units. Even values 	 * indicate 16B records. Odd values indicate 32B records. 	 */
define|#
directive|define
name|CREQ_MODIFY_ROCE_CC_RESP_TYPE_MASK
value|UINT32_C(0x3f)
define|#
directive|define
name|CREQ_MODIFY_ROCE_CC_RESP_TYPE_SFT
value|0
comment|/* QP Async Notification */
define|#
directive|define
name|CREQ_MODIFY_ROCE_CC_RESP_TYPE_QP_EVENT
value|UINT32_C(0x38)
define|#
directive|define
name|CREQ_MODIFY_ROCE_CC_RESP_RESERVED2_MASK
value|UINT32_C(0xc0)
define|#
directive|define
name|CREQ_MODIFY_ROCE_CC_RESP_RESERVED2_SFT
value|6
name|uint8_t
name|status
decl_stmt|;
comment|/* Status of the response. */
name|uint16_t
name|cookie
decl_stmt|;
comment|/* Driver supplied handle to associate the command and the response. */
name|uint32_t
name|reserved32
decl_stmt|;
name|uint8_t
name|v
decl_stmt|;
comment|/* 	 * This value is written by the NIC such that it will be different for 	 * each pass through the completion queue. The even passes will write 1. 	 * The odd passes will write 0. 	 */
define|#
directive|define
name|CREQ_MODIFY_ROCE_CC_RESP_V
value|UINT32_C(0x1)
define|#
directive|define
name|CREQ_MODIFY_ROCE_CC_RESP_RESERVED7_MASK
value|UINT32_C(0xfe)
define|#
directive|define
name|CREQ_MODIFY_ROCE_CC_RESP_RESERVED7_SFT
value|1
name|uint8_t
name|event
decl_stmt|;
comment|/* Event or command opcode. */
comment|/* Modify congestion control response. */
define|#
directive|define
name|CREQ_MODIFY_ROCE_CC_RESP_EVENT_MODIFY_ROCE_CC
value|UINT32_C(0x8c)
name|uint16_t
name|reserved48
index|[
literal|3
index|]
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Query congestion control command response (16 bytes) */
end_comment

begin_struct
struct|struct
name|creq_query_roce_cc_resp
block|{
name|uint8_t
name|type
decl_stmt|;
comment|/* 	 * This field indicates the exact type of the completion. By convention, 	 * the LSB identifies the length of the record in 16B units. Even values 	 * indicate 16B records. Odd values indicate 32B records. 	 */
define|#
directive|define
name|CREQ_QUERY_ROCE_CC_RESP_TYPE_MASK
value|UINT32_C(0x3f)
define|#
directive|define
name|CREQ_QUERY_ROCE_CC_RESP_TYPE_SFT
value|0
comment|/* QP Async Notification */
define|#
directive|define
name|CREQ_QUERY_ROCE_CC_RESP_TYPE_QP_EVENT
value|UINT32_C(0x38)
define|#
directive|define
name|CREQ_QUERY_ROCE_CC_RESP_RESERVED2_MASK
value|UINT32_C(0xc0)
define|#
directive|define
name|CREQ_QUERY_ROCE_CC_RESP_RESERVED2_SFT
value|6
name|uint8_t
name|status
decl_stmt|;
comment|/* Status of the response. */
name|uint16_t
name|cookie
decl_stmt|;
comment|/* Driver supplied handle to associate the command and the response. */
name|uint32_t
name|size
decl_stmt|;
comment|/* Side buffer size in 16-byte units */
name|uint8_t
name|v
decl_stmt|;
comment|/* 	 * This value is written by the NIC such that it will be different for 	 * each pass through the completion queue. The even passes will write 1. 	 * The odd passes will write 0. 	 */
define|#
directive|define
name|CREQ_QUERY_ROCE_CC_RESP_V
value|UINT32_C(0x1)
define|#
directive|define
name|CREQ_QUERY_ROCE_CC_RESP_RESERVED7_MASK
value|UINT32_C(0xfe)
define|#
directive|define
name|CREQ_QUERY_ROCE_CC_RESP_RESERVED7_SFT
value|1
name|uint8_t
name|event
decl_stmt|;
comment|/* Event or command opcode. */
comment|/* Query congestion control response. */
define|#
directive|define
name|CREQ_QUERY_ROCE_CC_RESP_EVENT_QUERY_ROCE_CC
value|UINT32_C(0x8d)
name|uint16_t
name|reserved48
index|[
literal|3
index|]
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Query congestion control command response side buffer structure (32 bytes) */
end_comment

begin_struct
struct|struct
name|creq_query_roce_cc_resp_sb
block|{
name|uint8_t
name|opcode
decl_stmt|;
comment|/* Command opcode. */
comment|/* Query congestion control response. */
define|#
directive|define
name|CREQ_QUERY_ROCE_CC_RESP_SB_OPCODE_QUERY_ROCE_CC
value|UINT32_C(0x8d)
name|uint8_t
name|status
decl_stmt|;
comment|/* Status of the response. */
name|uint16_t
name|cookie
decl_stmt|;
comment|/* Driver supplied handle to associate the command and the response. */
name|uint16_t
name|flags
decl_stmt|;
comment|/* Flags and attribs of the command. */
name|uint8_t
name|resp_size
decl_stmt|;
comment|/* Size of the response buffer in 16-byte units. */
name|uint8_t
name|reserved8
decl_stmt|;
name|uint8_t
name|enable_cc
decl_stmt|;
comment|/* unused7 is 7 b */
comment|/* Enable. */
define|#
directive|define
name|CREQ_QUERY_ROCE_CC_RESP_SB_ENABLE_CC
value|UINT32_C(0x1)
comment|/* unused7 is 7 b */
name|uint8_t
name|tos_dscp_tos_ecn
decl_stmt|;
comment|/* IP TOS DSCP. */
comment|/* IP TOS ECN. */
define|#
directive|define
name|CREQ_QUERY_ROCE_CC_RESP_SB_TOS_ECN_MASK
value|UINT32_C(0x3)
define|#
directive|define
name|CREQ_QUERY_ROCE_CC_RESP_SB_TOS_ECN_SFT
value|0
comment|/* IP TOS DSCP. */
define|#
directive|define
name|CREQ_QUERY_ROCE_CC_RESP_SB_TOS_DSCP_MASK
value|UINT32_C(0xfc)
define|#
directive|define
name|CREQ_QUERY_ROCE_CC_RESP_SB_TOS_DSCP_SFT
value|2
name|uint8_t
name|g
decl_stmt|;
comment|/* unused5 is 5 b */
comment|/* Congestion Probability averaging factor. */
define|#
directive|define
name|CREQ_QUERY_ROCE_CC_RESP_SB_G_MASK
value|UINT32_C(0x7)
define|#
directive|define
name|CREQ_QUERY_ROCE_CC_RESP_SB_G_SFT
value|0
comment|/* unused5 is 5 b */
name|uint8_t
name|num_phases_per_state
decl_stmt|;
comment|/* Number of phases in Fast Recovery and Active Increase. */
name|uint16_t
name|init_cr
decl_stmt|;
comment|/* The starting value of rate. */
name|uint16_t
name|init_tr
decl_stmt|;
comment|/* The starting value of target rate. */
name|uint8_t
name|alt_vlan_pcp
decl_stmt|;
comment|/* rsvd1 is 5 b */
comment|/* Alternate vlan pcp value for CNP packets. */
define|#
directive|define
name|CREQ_QUERY_ROCE_CC_RESP_SB_ALT_VLAN_PCP_MASK
value|UINT32_C(0x7)
define|#
directive|define
name|CREQ_QUERY_ROCE_CC_RESP_SB_ALT_VLAN_PCP_SFT
value|0
comment|/* rsvd1 is 5 b */
define|#
directive|define
name|CREQ_QUERY_ROCE_CC_RESP_SB_RSVD1_MASK
value|UINT32_C(0xf8)
define|#
directive|define
name|CREQ_QUERY_ROCE_CC_RESP_SB_RSVD1_SFT
value|3
name|uint8_t
name|alt_tos_dscp
decl_stmt|;
comment|/* rsvd4 is 2 b */
comment|/* Alternate IP TOS DSCP. */
define|#
directive|define
name|CREQ_QUERY_ROCE_CC_RESP_SB_ALT_TOS_DSCP_MASK
value|UINT32_C(0x3f)
define|#
directive|define
name|CREQ_QUERY_ROCE_CC_RESP_SB_ALT_TOS_DSCP_SFT
value|0
comment|/* rsvd4 is 2 b */
define|#
directive|define
name|CREQ_QUERY_ROCE_CC_RESP_SB_RSVD4_MASK
value|UINT32_C(0xc0)
define|#
directive|define
name|CREQ_QUERY_ROCE_CC_RESP_SB_RSVD4_SFT
value|6
name|uint8_t
name|cc_mode
decl_stmt|;
comment|/* rsvd2 is 7 b */
comment|/* 0 for DCTCP , 1 for TCP */
define|#
directive|define
name|CREQ_QUERY_ROCE_CC_RESP_SB_CC_MODE
value|UINT32_C(0x1)
comment|/* rsvd2 is 7 b */
define|#
directive|define
name|CREQ_QUERY_ROCE_CC_RESP_SB_RSVD2_MASK
value|UINT32_C(0xfe)
define|#
directive|define
name|CREQ_QUERY_ROCE_CC_RESP_SB_RSVD2_SFT
value|1
name|uint8_t
name|tx_queue
decl_stmt|;
comment|/* rsvd3 is 6 b */
comment|/* Specifies the RoCE Tx Queue ( o to 3) to use for sending CNP packets */
define|#
directive|define
name|CREQ_QUERY_ROCE_CC_RESP_SB_TX_QUEUE_MASK
value|UINT32_C(0x3)
define|#
directive|define
name|CREQ_QUERY_ROCE_CC_RESP_SB_TX_QUEUE_SFT
value|0
comment|/* rsvd3 is 6 b */
define|#
directive|define
name|CREQ_QUERY_ROCE_CC_RESP_SB_RSVD3_MASK
value|UINT32_C(0xfc)
define|#
directive|define
name|CREQ_QUERY_ROCE_CC_RESP_SB_RSVD3_SFT
value|2
name|uint16_t
name|rtt
decl_stmt|;
comment|/* rsvd5 is 2 b */
comment|/* Round trip time in units of usecs */
define|#
directive|define
name|CREQ_QUERY_ROCE_CC_RESP_SB_RTT_MASK
value|UINT32_C(0x3fff)
define|#
directive|define
name|CREQ_QUERY_ROCE_CC_RESP_SB_RTT_SFT
value|0
comment|/* rsvd5 is 2 b */
define|#
directive|define
name|CREQ_QUERY_ROCE_CC_RESP_SB_RSVD5_MASK
value|UINT32_C(0xc000)
define|#
directive|define
name|CREQ_QUERY_ROCE_CC_RESP_SB_RSVD5_SFT
value|14
name|uint16_t
name|tcp_cp
decl_stmt|;
comment|/* rsvd6 is 6 b */
comment|/* The value used as CP when cc_mode is 1(TCP) */
define|#
directive|define
name|CREQ_QUERY_ROCE_CC_RESP_SB_TCP_CP_MASK
value|UINT32_C(0x3ff)
define|#
directive|define
name|CREQ_QUERY_ROCE_CC_RESP_SB_TCP_CP_SFT
value|0
comment|/* rsvd6 is 6 b */
define|#
directive|define
name|CREQ_QUERY_ROCE_CC_RESP_SB_RSVD6_MASK
value|UINT32_C(0xfc00)
define|#
directive|define
name|CREQ_QUERY_ROCE_CC_RESP_SB_RSVD6_SFT
value|10
name|uint16_t
name|inactivity_th
decl_stmt|;
comment|/* Inactivity time after which QP CC parameters are initialized */
name|uint16_t
name|reserved16
decl_stmt|;
name|uint32_t
name|reserved32
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* QP error notification event (16 bytes) */
end_comment

begin_struct
struct|struct
name|creq_qp_error_notification
block|{
name|uint8_t
name|type
decl_stmt|;
comment|/* 	 * This field indicates the exact type of the completion. By convention, 	 * the LSB identifies the length of the record in 16B units. Even values 	 * indicate 16B records. Odd values indicate 32B records. 	 */
define|#
directive|define
name|CREQ_QP_ERROR_NOTIFICATION_TYPE_MASK
value|UINT32_C(0x3f)
define|#
directive|define
name|CREQ_QP_ERROR_NOTIFICATION_TYPE_SFT
value|0
comment|/* QP Async Notification */
define|#
directive|define
name|CREQ_QP_ERROR_NOTIFICATION_TYPE_QP_EVENT
value|UINT32_C(0x38)
define|#
directive|define
name|CREQ_QP_ERROR_NOTIFICATION_RESERVED2_MASK
value|UINT32_C(0xc0)
define|#
directive|define
name|CREQ_QP_ERROR_NOTIFICATION_RESERVED2_SFT
value|6
name|uint8_t
name|status
decl_stmt|;
comment|/* Status of the response. */
name|uint8_t
name|req_slow_path_state
decl_stmt|;
comment|/* requestor slow path state */
name|uint8_t
name|req_err_state_reason
decl_stmt|;
comment|/* requestor error reason */
name|uint32_t
name|xid
decl_stmt|;
comment|/* QP context id */
name|uint8_t
name|v
decl_stmt|;
comment|/* 	 * This value is written by the NIC such that it will be different for 	 * each pass through the completion queue. The even passes will write 1. 	 * The odd passes will write 0. 	 */
define|#
directive|define
name|CREQ_QP_ERROR_NOTIFICATION_V
value|UINT32_C(0x1)
define|#
directive|define
name|CREQ_QP_ERROR_NOTIFICATION_RESERVED7_MASK
value|UINT32_C(0xfe)
define|#
directive|define
name|CREQ_QP_ERROR_NOTIFICATION_RESERVED7_SFT
value|1
name|uint8_t
name|event
decl_stmt|;
comment|/* Event or command opcode. */
comment|/* QP error notification event. */
define|#
directive|define
name|CREQ_QP_ERROR_NOTIFICATION_EVENT_QP_ERROR_NOTIFICATION
value|UINT32_C(0xc0)
name|uint8_t
name|res_slow_path_state
decl_stmt|;
comment|/* responder slow path state */
name|uint8_t
name|res_err_state_reason
decl_stmt|;
name|uint16_t
name|sq_cons_idx
decl_stmt|;
comment|/* 	 * Final SQ Consumer Index value. Any additional SQ WQEs will have to be 	 * completed by the user provider. 	 */
name|uint16_t
name|rq_cons_idx
decl_stmt|;
comment|/* 	 * Final RQ Consumer Index value. Any additional RQ WQEs will have to be 	 * completed by the user provider. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* RoCE Slowpath Data Structures */
end_comment

begin_comment
comment|/*  * Note: This section documents the Host Structures used between software and  * RoCE control firmware.  */
end_comment

begin_comment
comment|/* hwrm_selftest_qlist */
end_comment

begin_comment
comment|/*  * Description: This function is called by a driver to determine which selftests  * are available to be run against the requested function.  */
end_comment

begin_comment
comment|/* Input (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_selftest_qlist_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (272 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_selftest_qlist_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint8_t
name|num_tests
decl_stmt|;
comment|/* 	 * This field represents the number of tests available to be requested 	 * by a driver. 	 */
name|uint8_t
name|available_tests
decl_stmt|;
comment|/* This field indicates which self-test is available to be run. */
comment|/* Can run the NVM test. */
define|#
directive|define
name|HWRM_SELFTEST_QLIST_OUTPUT_AVAILABLE_TESTS_NVM_TEST
value|UINT32_C(0x1)
comment|/* Can run the link test. */
define|#
directive|define
name|HWRM_SELFTEST_QLIST_OUTPUT_AVAILABLE_TESTS_LINK_TEST
value|UINT32_C(0x2)
comment|/* Can run the register test. */
define|#
directive|define
name|HWRM_SELFTEST_QLIST_OUTPUT_AVAILABLE_TESTS_REGISTER_TEST
value|UINT32_C(0x4)
comment|/* Can run the memory test. */
define|#
directive|define
name|HWRM_SELFTEST_QLIST_OUTPUT_AVAILABLE_TESTS_MEMORY_TEST
value|UINT32_C(0x8)
comment|/* Can run the PCIe serdes test. */
define|#
directive|define
name|HWRM_SELFTEST_QLIST_OUTPUT_AVAILABLE_TESTS_PCIE_SERDES_TEST
value|UINT32_C(0x10)
comment|/* Can run the Ethernet serdes test. */
define|#
directive|define
name|HWRM_SELFTEST_QLIST_OUTPUT_AVAILABLE_TESTS_ETHERNET_SERDES_TEST
value|UINT32_C(0x20)
name|uint8_t
name|offline_tests
decl_stmt|;
comment|/* The NVM test is an offline test. */
define|#
directive|define
name|HWRM_SELFTEST_QLIST_OUTPUT_OFFLINE_TESTS_NVM_TEST
value|UINT32_C(0x1)
comment|/* The link test is an offline test. */
define|#
directive|define
name|HWRM_SELFTEST_QLIST_OUTPUT_OFFLINE_TESTS_LINK_TEST
value|UINT32_C(0x2)
comment|/* The register test is an offline test. */
define|#
directive|define
name|HWRM_SELFTEST_QLIST_OUTPUT_OFFLINE_TESTS_REGISTER_TEST
value|UINT32_C(0x4)
comment|/* The memory test is an offline test. */
define|#
directive|define
name|HWRM_SELFTEST_QLIST_OUTPUT_OFFLINE_TESTS_MEMORY_TEST
value|UINT32_C(0x8)
comment|/* The PCIe serdes test is an offline test. */
define|#
directive|define
name|HWRM_SELFTEST_QLIST_OUTPUT_OFFLINE_TESTS_PCIE_SERDES_TEST
value|UINT32_C(0x10)
comment|/* The Ethernet serdes test is an offline test. */
define|#
directive|define
name|HWRM_SELFTEST_QLIST_OUTPUT_OFFLINE_TESTS_ETHERNET_SERDES_TEST
value|UINT32_C(0x20)
name|uint8_t
name|unused_0
decl_stmt|;
name|uint16_t
name|test_timeout
decl_stmt|;
comment|/* 	 * This field represents the the maximum timeout for all the tests to 	 * complete in milliseconds. 	 */
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|char
name|test0_name
index|[
literal|32
index|]
decl_stmt|;
comment|/* 	 * This field represents the name of the NVM test (ASCII chars with NULL 	 * at the end). 	 */
name|char
name|test1_name
index|[
literal|32
index|]
decl_stmt|;
comment|/* 	 * This field represents the name of the link test (ASCII chars with 	 * NULL at the end). 	 */
name|char
name|test2_name
index|[
literal|32
index|]
decl_stmt|;
comment|/* 	 * This field represents the name of the register test (ASCII chars with 	 * NULL at the end). 	 */
name|char
name|test3_name
index|[
literal|32
index|]
decl_stmt|;
comment|/* 	 * This field represents the name of the memory test (ASCII chars with 	 * NULL at the end). 	 */
name|char
name|test4_name
index|[
literal|32
index|]
decl_stmt|;
comment|/* 	 * This field represents the name of the PCIe serdes test (ASCII chars 	 * with NULL at the end). 	 */
name|char
name|test5_name
index|[
literal|32
index|]
decl_stmt|;
comment|/* 	 * This field represents the name of the Ethernet serdes test (ASCII 	 * chars with NULL at the end). 	 */
name|char
name|test6_name
index|[
literal|32
index|]
decl_stmt|;
comment|/* 	 * This field represents the name of some future test (ASCII chars with 	 * NULL at the end). 	 */
name|char
name|test7_name
index|[
literal|32
index|]
decl_stmt|;
comment|/* 	 * This field represents the name of some future test (ASCII chars with 	 * NULL at the end). 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_selftest_exec */
end_comment

begin_comment
comment|/*  * Description: This function is called by a driver to request which self tests  * are to be run.  */
end_comment

begin_comment
comment|/* Input (24 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_selftest_exec_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint8_t
name|flags
decl_stmt|;
comment|/* This field indicates which self-test is being requested to run. */
comment|/* Run the NVM test. */
define|#
directive|define
name|HWRM_SELFTEST_EXEC_INPUT_FLAGS_NVM_TEST
value|UINT32_C(0x1)
comment|/* Run the link test. */
define|#
directive|define
name|HWRM_SELFTEST_EXEC_INPUT_FLAGS_LINK_TEST
value|UINT32_C(0x2)
comment|/* Run the register test. */
define|#
directive|define
name|HWRM_SELFTEST_EXEC_INPUT_FLAGS_REGISTER_TEST
value|UINT32_C(0x4)
comment|/* Run the memory test. */
define|#
directive|define
name|HWRM_SELFTEST_EXEC_INPUT_FLAGS_MEMORY_TEST
value|UINT32_C(0x8)
comment|/* Run the PCIe serdes test. */
define|#
directive|define
name|HWRM_SELFTEST_EXEC_INPUT_FLAGS_PCIE_SERDES_TEST
value|UINT32_C(0x10)
comment|/* Run the Ethernet serdes test. */
define|#
directive|define
name|HWRM_SELFTEST_EXEC_INPUT_FLAGS_ETHERNET_SERDES_TEST
value|UINT32_C(0x20)
name|uint8_t
name|unused_0
index|[
literal|7
index|]
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_selftest_exec_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint8_t
name|requested_tests
decl_stmt|;
comment|/* The following tests were requested to be run. */
comment|/* A reqeust was made to run the NVM test. */
define|#
directive|define
name|HWRM_SELFTEST_EXEC_OUTPUT_REQUESTED_TESTS_NVM_TEST
value|UINT32_C(0x1)
comment|/* A request was made to run the link test. */
define|#
directive|define
name|HWRM_SELFTEST_EXEC_OUTPUT_REQUESTED_TESTS_LINK_TEST
value|UINT32_C(0x2)
comment|/* A request was made to run the register test. */
define|#
directive|define
name|HWRM_SELFTEST_EXEC_OUTPUT_REQUESTED_TESTS_REGISTER_TEST
value|UINT32_C(0x4)
comment|/* A request was made to run the memory test. */
define|#
directive|define
name|HWRM_SELFTEST_EXEC_OUTPUT_REQUESTED_TESTS_MEMORY_TEST
value|UINT32_C(0x8)
comment|/* A request was made to run the PCIe serdes test. */
define|#
directive|define
name|HWRM_SELFTEST_EXEC_OUTPUT_REQUESTED_TESTS_PCIE_SERDES_TEST
value|UINT32_C(0x10)
comment|/* A request was made to run the Ethernet serdes test. */
define|#
directive|define
name|HWRM_SELFTEST_EXEC_OUTPUT_REQUESTED_TESTS_ETHERNET_SERDES_TEST
value|UINT32_C(0x20)
name|uint8_t
name|test_success
decl_stmt|;
comment|/* 	 * If a test was requested to be run as seen in the requested_tests 	 * field, this bit indicates whether the test was successful(1) or 	 * failed(0). 	 */
comment|/* 	 * If requested, a value of 1 indicates the NVM test completed 	 * successfully. 	 */
define|#
directive|define
name|HWRM_SELFTEST_EXEC_OUTPUT_TEST_SUCCESS_NVM_TEST
value|UINT32_C(0x1)
comment|/* 	 * If requested, a value of 1 indicates the link test completed 	 * successfully. 	 */
define|#
directive|define
name|HWRM_SELFTEST_EXEC_OUTPUT_TEST_SUCCESS_LINK_TEST
value|UINT32_C(0x2)
comment|/* 	 * If requested, a value of 1 indicates the register test completed 	 * successfully. 	 */
define|#
directive|define
name|HWRM_SELFTEST_EXEC_OUTPUT_TEST_SUCCESS_REGISTER_TEST
value|UINT32_C(0x4)
comment|/* 	 * If requested, a value of 1 indicates the memory test completed 	 * successfully. 	 */
define|#
directive|define
name|HWRM_SELFTEST_EXEC_OUTPUT_TEST_SUCCESS_MEMORY_TEST
value|UINT32_C(0x8)
comment|/* 	 * If requested, a value of 1 indicates the PCIe serdes test completed 	 * successfully. 	 */
define|#
directive|define
name|HWRM_SELFTEST_EXEC_OUTPUT_TEST_SUCCESS_PCIE_SERDES_TEST
value|UINT32_C(0x10)
comment|/* 	 * If requested, a value of 1 indicates the Ethernet serdes test 	 * completed successfully. 	 */
define|#
directive|define
name|HWRM_SELFTEST_EXEC_OUTPUT_TEST_SUCCESS_ETHERNET_SERDES_TEST
value|UINT32_C(0x20)
name|uint16_t
name|unused_0
index|[
literal|3
index|]
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_selftest_irq */
end_comment

begin_comment
comment|/*  * Description: This function is called by a driver to request the interrupt  * test be run. In response to this request the interrupt associated with the  * completion ring specified in the cmpl_ring field will be asserted to the  * host.  */
end_comment

begin_comment
comment|/* Input (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_selftest_irq_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (8 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_selftest_irq_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* hwrm_selftest_retreive_serdes_data */
end_comment

begin_comment
comment|/*  * Description: This function is called by a driver to retreieve the data  * collected when running the previous PCIe or Ethernet serdes test. The driver  * can use multiple calls to this command to retreive the entire stored buffer  * in the event it cannot do so with a single call.  */
end_comment

begin_comment
comment|/* Input (32 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_selftest_retreive_serdes_data_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
name|uint64_t
name|resp_data_addr
decl_stmt|;
comment|/* Host address data is to DMA'd to. */
name|uint32_t
name|resp_data_offset
decl_stmt|;
comment|/* 	 * This field contains the offset into the captured data to begin 	 * copying the data to the host from. This should be set to 0 on the 	 * initial call to this command. 	 */
name|uint16_t
name|data_len
decl_stmt|;
comment|/* 	 * Size of the buffer pointed to by resp_data_addr. The firmware may use 	 * this entire buffer or less than the entire buffer, but never more. 	 */
name|uint8_t
name|flags
decl_stmt|;
comment|/* 	 * This field allows this command to request the individual serdes tests 	 * to be run using this command. 	 */
comment|/* Unused. */
define|#
directive|define
name|HWRM_SELFTEST_RETREIVE_SERDES_DATA_INPUT_FLAGS_UNUSED_TEST_MASK
value|UINT32_C(0xf)
define|#
directive|define
name|HWRM_SELFTEST_RETREIVE_SERDES_DATA_INPUT_FLAGS_UNUSED_TEST_SFT
value|0
comment|/* Run the PCIe serdes test. */
define|#
directive|define
name|HWRM_SELFTEST_RETREIVE_SERDES_DATA_INPUT_FLAGS_PCIE_SERDES_TEST
value|UINT32_C(0x10)
comment|/* Run the Ethernet serdes test. */
define|#
directive|define
name|HWRM_SELFTEST_RETREIVE_SERDES_DATA_INPUT_FLAGS_ETHERNET_SERDES_TEST
value|UINT32_C(0x20)
name|uint8_t
name|unused_0
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_selftest_retreive_serdes_data_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint16_t
name|total_data_len
decl_stmt|;
comment|/* Total length of stored data. */
name|uint16_t
name|copied_data_len
decl_stmt|;
comment|/* 	 * Amount of data DMA'd to host by this call. The driver can use this 	 * field along with the total_data_len field above to determine the 	 * value to write to the resp_data_offset field in the next call if more 	 * than one call to these commands is required to retreive all the 	 * stored data. 	 */
name|uint32_t
name|unused_0
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Hardware Resource Manager Specification */
end_comment

begin_comment
comment|/* Description: This structure is used to configure a RSS Context. */
end_comment

begin_comment
comment|/*  * Note: The Hardware Resource Manager (HWRM) manages various hardware resources  * inside the chip. The HWRM is implemented in firmware, and runs on embedded  * processors inside the chip. This firmware service is vital part of the chip.  * The chip can not be used by a driver or HWRM client without the HWRM.  */
end_comment

begin_comment
comment|/* Input (16 bytes) */
end_comment

begin_struct
struct|struct
name|input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This value indicates what type of request this is. The format for the 	 * rest of the command is determined by this field. 	 */
name|uint16_t
name|cmpl_ring
decl_stmt|;
comment|/* 	 * This value indicates the what completion ring the request will be 	 * optionally completed on. If the value is -1, then no CR completion 	 * will be generated. Any other value must be a valid CR ring_id value 	 * for this function. 	 */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This value indicates the command sequence number. */
name|uint16_t
name|target_id
decl_stmt|;
comment|/* 	 * Target ID of this command. 0x0 - 0xFFF8 - Used for function ids 	 * 0xFFF8 - 0xFFFE - Reserved for internal processors 0xFFFF - HWRM 	 */
name|uint64_t
name|resp_addr
decl_stmt|;
comment|/* 	 * This is the host address where the response will be written when the 	 * request is complete. This area must be 16B aligned and must be 	 * cleared to zero before the request is made. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (8 bytes) */
end_comment

begin_struct
struct|struct
name|output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Short Command Structure (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_short_input
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This field indicates the type of request in the request buffer. The 	 * format for the rest of the command (request) is determined by this 	 * field. 	 */
name|uint16_t
name|signature
decl_stmt|;
comment|/* 	 * This field indicates a signature that is used to identify short form 	 * of the command listed here. This field shall be set to 17185 	 * (0x4321). 	 */
comment|/* Signature indicating this is a short form of HWRM command */
define|#
directive|define
name|HWRM_SHORT_INPUT_SIGNATURE_SHORT_CMD
value|UINT32_C(0x4321)
name|uint16_t
name|unused_0
decl_stmt|;
comment|/* Reserved for future use. */
name|uint16_t
name|size
decl_stmt|;
comment|/* This value indicates the length of the request. */
name|uint64_t
name|req_addr
decl_stmt|;
comment|/* 	 * This is the host address where the request was written. This area 	 * must be 16B aligned. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_define
define|#
directive|define
name|GET_HWRM_REQ_TYPE
parameter_list|(
name|x
parameter_list|)
define|\
value|((x) == 0x99 ? "HWRM_CFA_NTUPLE_FILTER_ALLOC": \ 	((x) == 0x90 ? "HWRM_CFA_L2_FILTER_ALLOC": \ 	((x) == 0x91 ? "HWRM_CFA_L2_FILTER_FREE": \ 	((x) == 0x92 ? "HWRM_CFA_L2_FILTER_CFG": \ 	((x) == 0x93 ? "HWRM_CFA_L2_SET_RX_MASK": \ 	((x) == 0x94 ? "HWRM_CFA_VLAN_ANTISPOOF_CFG": \ 	((x) == 0x95 ? "HWRM_CFA_TUNNEL_FILTER_ALLOC": \ 	((x) == 0x96 ? "HWRM_CFA_TUNNEL_FILTER_FREE": \ 	((x) == 0x10 ? "RESERVED1": \ 	((x) == 0x11 ? "HWRM_FUNC_RESET": \ 	((x) == 0x12 ? "HWRM_FUNC_GETFID": \ 	((x) == 0x13 ? "HWRM_FUNC_VF_ALLOC": \ 	((x) == 0x14 ? "HWRM_FUNC_VF_FREE": \ 	((x) == 0x15 ? "HWRM_FUNC_QCAPS": \ 	((x) == 0x16 ? "HWRM_FUNC_QCFG": \ 	((x) == 0x17 ? "HWRM_FUNC_CFG": \ 	((x) == 0x18 ? "HWRM_FUNC_QSTATS": \ 	((x) == 0x19 ? "HWRM_FUNC_CLR_STATS": \ 	((x) == 0xe0 ? "HWRM_TEMP_MONITOR_QUERY": \ 	((x) == 0x1a ? "HWRM_FUNC_DRV_UNRGTR": \ 	((x) == 0x1b ? "HWRM_FUNC_VF_RESC_FREE": \ 	((x) == 0x1c ? "HWRM_FUNC_VF_VNIC_IDS_QUERY": \ 	((x) == 0x1d ? "HWRM_FUNC_DRV_RGTR": \ 	((x) == 0x1e ? "HWRM_FUNC_DRV_QVER": \ 	((x) == 0x1f ? "HWRM_FUNC_BUF_RGTR": \ 	((x) == 0x9a ? "HWRM_CFA_NTUPLE_FILTER_FREE": \ 	((x) == 0x9b ? "HWRM_CFA_NTUPLE_FILTER_CFG": \ 	((x) == 0xd3 ? "HWRM_FWD_ASYNC_EVENT_CMPL": \ 	((x) == 0xd2 ? "HWRM_FWD_RESP": \ 	((x) == 0xd1 ? "HWRM_REJECT_FWD_RESP": \ 	((x) == 0xd0 ? "HWRM_EXEC_FWD_RESP": \ 	((x) == 0xc0 ? "HWRM_FW_RESET": \ 	((x) == 0xc1 ? "HWRM_FW_QSTATUS": \ 	((x) == 0x70 ? "HWRM_VNIC_RSS_COS_LB_CTX_ALLOC": \ 	((x) == 0x71 ? "HWRM_VNIC_RSS_COS_LB_CTX_FREE": \ 	((x) == 0xb1 ? "HWRM_STAT_CTX_FREE": \ 	((x) == 0xb0 ? "HWRM_STAT_CTX_ALLOC": \ 	((x) == 0xb3 ? "HWRM_STAT_CTX_CLR_STATS": \ 	((x) == 0xb2 ? "HWRM_STAT_CTX_QUERY": \ 	((x) == 0xfff6 ? "HWRM_NVM_GET_DEV_INFO": \ 	((x) == 0x61 ? "HWRM_RING_GRP_FREE": \ 	((x) == 0x60 ? "HWRM_RING_GRP_ALLOC": \ 	((x) == 0x24 ? "HWRM_PORT_LPBK_QSTATS": \ 	((x) == 0xf3 ? "HWRM_WOL_REASON_QCFG": \ 	((x) == 0xa0 ? "HWRM_TUNNEL_DST_PORT_QUERY": \ 	((x) == 0xa1 ? "HWRM_TUNNEL_DST_PORT_ALLOC": \ 	((x) == 0xa2 ? "HWRM_TUNNEL_DST_PORT_FREE": \ 	((x) == 0xfffc ? "HWRM_NVM_RAW_DUMP": \ 	((x) == 0xfffb ? "HWRM_NVM_GET_DIR_INFO": \ 	((x) == 0xfffa ? "HWRM_NVM_GET_DIR_ENTRIES": \ 	((x) == 0x10a ? "HWRM_CFA_VLAN_ANTISPOOF_QCFG": \ 	((x) == 0xe ? "HWRM_FUNC_BUF_UNRGTR": \ 	((x) == 0xf ? "HWRM_FUNC_VF_CFG": \ 	((x) == 0xffff ? "HWRM_NVM_RAW_WRITE_BLK": \ 	((x) == 0xfffe ? "HWRM_NVM_WRITE": \ 	((x) == 0xfffd ? "HWRM_NVM_READ": \ 	((x) == 0x50 ? "HWRM_RING_ALLOC": \ 	((x) == 0x51 ? "HWRM_RING_FREE": \ 	((x) == 0x52 ? "HWRM_RING_CMPL_RING_QAGGINT_PARAMS": \ 	((x) == 0x53 ? "HWRM_RING_CMPL_RING_CFG_AGGINT_PARAMS": \ 	((x) == 0x4a ? "HWRM_VNIC_QCAPS": \ 	((x) == 0x49 ? "HWRM_VNIC_PLCMODES_QCFG": \ 	((x) == 0x48 ? "HWRM_VNIC_PLCMODES_CFG": \ 	((x) == 0x47 ? "HWRM_VNIC_RSS_QCFG": \ 	((x) == 0x46 ? "HWRM_VNIC_RSS_CFG": \ 	((x) == 0x44 ? "HWRM_VNIC_TPA_CFG": \ 	((x) == 0x43 ? "HWRM_VNIC_QCFG": \ 	((x) == 0x42 ? "HWRM_VNIC_CFG": \ 	((x) == 0x41 ? "HWRM_VNIC_FREE": \ 	((x) == 0x40 ? "HWRM_VNIC_ALLOC": \ 	((x) == 0x0 ? "HWRM_VER_GET": \ 	((x) == 0xfff9 ? "HWRM_NVM_FIND_DIR_ENTRY": \ 	((x) == 0xfff8 ? "HWRM_NVM_MOD_DIR_ENTRY": \ 	((x) == 0xfff7 ? "HWRM_NVM_ERASE_DIR_ENTRY": \ 	((x) == 0x5e ? "HWRM_RING_RESET": \ 	((x) == 0xfff5 ? "HWRM_NVM_VERIFY_UPDATE": \ 	((x) == 0xfff4 ? "HWRM_NVM_MODIFY": \ 	((x) == 0xfff3 ? "HWRM_NVM_INSTALL_UPDATE": \ 	((x) == 0xfff2 ? "HWRM_NVM_SET_VARIABLE": \ 	((x) == 0xfff1 ? "HWRM_NVM_GET_VARIABLE": \ 	((x) == 0xfff0 ? "HWRM_NVM_FLUSH": \ 	((x) == 0x2e ? "HWRM_PORT_LED_QCFG": \ 	((x) == 0x2d ? "HWRM_PORT_LED_CFG": \ 	((x) == 0x2f ? "HWRM_PORT_LED_QCAPS": \ 	((x) == 0x2a ? "HWRM_PORT_PHY_QCAPS": \ 	((x) == 0x38 ? "HWRM_QUEUE_PRI2COS_CFG": \ 	((x) == 0x39 ? "HWRM_QUEUE_COS2BW_QCFG": \ 	((x) == 0x32 ? "HWRM_QUEUE_CFG": \ 	((x) == 0x33 ? "HWRM_FUNC_VLAN_CFG": \ 	((x) == 0x30 ? "HWRM_QUEUE_QPORTCFG": \ 	((x) == 0x31 ? "HWRM_QUEUE_QCFG": \ 	((x) == 0x36 ? "HWRM_QUEUE_PFCENABLE_CFG": \ 	((x) == 0x37 ? "HWRM_QUEUE_PRI2COS_QCFG": \ 	((x) == 0x34 ? "HWRM_FUNC_VLAN_QCFG": \ 	((x) == 0x35 ? "HWRM_QUEUE_PFCENABLE_QCFG": \ 	((x) == 0xff14 ? "HWRM_DBG_DUMP": \ 	((x) == 0xc8 ? "HWRM_FW_SET_TIME": \ 	((x) == 0xc9 ? "HWRM_FW_GET_TIME": \ 	((x) == 0xf1 ? "HWRM_WOL_FILTER_FREE": \ 	((x) == 0xf0 ? "HWRM_WOL_FILTER_ALLOC": \ 	((x) == 0x27 ? "HWRM_PORT_PHY_QCFG": \ 	((x) == 0xf2 ? "HWRM_WOL_FILTER_QCFG": \ 	((x) == 0x21 ? "HWRM_PORT_MAC_CFG": \ 	((x) == 0x20 ? "HWRM_PORT_PHY_CFG": \ 	((x) == 0x23 ? "HWRM_PORT_QSTATS": \ 	((x) == 0x28 ? "HWRM_PORT_MAC_QCFG": \ 	((x) == 0xffef ? "HWRM_NVM_VALIDATE_OPTION": \ 	((x) == 0x3a ? "HWRM_QUEUE_COS2BW_CFG": \ 	"Unknown req_type"))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
end_define

begin_comment
comment|/* Command numbering (8 bytes) */
end_comment

begin_struct
struct|struct
name|cmd_nums
block|{
name|uint16_t
name|req_type
decl_stmt|;
comment|/* 	 * This version of the specification defines the commands listed in the 	 * table below. The following are general implementation requirements 	 * for these commands: # All commands listed below that are marked 	 * neither reserved nor experimental shall be implemented by the HWRM. # 	 * A HWRM client compliant to this specification should not use commands 	 * outside of the list below. # A HWRM client compliant to this 	 * specification should not use command numbers marked reserved below. # 	 * A command marked experimental below may not be implemented by the 	 * HWRM. # A command marked experimental may change in the future 	 * version of the HWRM specification. # A command not listed below may 	 * be implemented by the HWRM. The behavior of commands that are not 	 * listed below is outside the scope of this specification. 	 */
define|#
directive|define
name|HWRM_VER_GET
value|(UINT32_C(0x0))
define|#
directive|define
name|HWRM_FUNC_BUF_UNRGTR
value|(UINT32_C(0xe))
define|#
directive|define
name|HWRM_FUNC_VF_CFG
value|(UINT32_C(0xf))
comment|/* Reserved for future use */
define|#
directive|define
name|RESERVED1
value|(UINT32_C(0x10))
define|#
directive|define
name|HWRM_FUNC_RESET
value|(UINT32_C(0x11))
define|#
directive|define
name|HWRM_FUNC_GETFID
value|(UINT32_C(0x12))
define|#
directive|define
name|HWRM_FUNC_VF_ALLOC
value|(UINT32_C(0x13))
define|#
directive|define
name|HWRM_FUNC_VF_FREE
value|(UINT32_C(0x14))
define|#
directive|define
name|HWRM_FUNC_QCAPS
value|(UINT32_C(0x15))
define|#
directive|define
name|HWRM_FUNC_QCFG
value|(UINT32_C(0x16))
define|#
directive|define
name|HWRM_FUNC_CFG
value|(UINT32_C(0x17))
define|#
directive|define
name|HWRM_FUNC_QSTATS
value|(UINT32_C(0x18))
define|#
directive|define
name|HWRM_FUNC_CLR_STATS
value|(UINT32_C(0x19))
define|#
directive|define
name|HWRM_FUNC_DRV_UNRGTR
value|(UINT32_C(0x1a))
define|#
directive|define
name|HWRM_FUNC_VF_RESC_FREE
value|(UINT32_C(0x1b))
define|#
directive|define
name|HWRM_FUNC_VF_VNIC_IDS_QUERY
value|(UINT32_C(0x1c))
define|#
directive|define
name|HWRM_FUNC_DRV_RGTR
value|(UINT32_C(0x1d))
define|#
directive|define
name|HWRM_FUNC_DRV_QVER
value|(UINT32_C(0x1e))
define|#
directive|define
name|HWRM_FUNC_BUF_RGTR
value|(UINT32_C(0x1f))
define|#
directive|define
name|HWRM_PORT_PHY_CFG
value|(UINT32_C(0x20))
define|#
directive|define
name|HWRM_PORT_MAC_CFG
value|(UINT32_C(0x21))
define|#
directive|define
name|HWRM_PORT_QSTATS
value|(UINT32_C(0x23))
define|#
directive|define
name|HWRM_PORT_LPBK_QSTATS
value|(UINT32_C(0x24))
define|#
directive|define
name|HWRM_PORT_PHY_QCFG
value|(UINT32_C(0x27))
define|#
directive|define
name|HWRM_PORT_MAC_QCFG
value|(UINT32_C(0x28))
define|#
directive|define
name|HWRM_PORT_PHY_QCAPS
value|(UINT32_C(0x2a))
define|#
directive|define
name|HWRM_PORT_LED_CFG
value|(UINT32_C(0x2d))
define|#
directive|define
name|HWRM_PORT_LED_QCFG
value|(UINT32_C(0x2e))
define|#
directive|define
name|HWRM_PORT_LED_QCAPS
value|(UINT32_C(0x2f))
define|#
directive|define
name|HWRM_QUEUE_QPORTCFG
value|(UINT32_C(0x30))
define|#
directive|define
name|HWRM_QUEUE_QCFG
value|(UINT32_C(0x31))
define|#
directive|define
name|HWRM_QUEUE_CFG
value|(UINT32_C(0x32))
define|#
directive|define
name|HWRM_FUNC_VLAN_CFG
value|(UINT32_C(0x33))
define|#
directive|define
name|HWRM_FUNC_VLAN_QCFG
value|(UINT32_C(0x34))
define|#
directive|define
name|HWRM_QUEUE_PFCENABLE_QCFG
value|(UINT32_C(0x35))
define|#
directive|define
name|HWRM_QUEUE_PFCENABLE_CFG
value|(UINT32_C(0x36))
define|#
directive|define
name|HWRM_QUEUE_PRI2COS_QCFG
value|(UINT32_C(0x37))
define|#
directive|define
name|HWRM_QUEUE_PRI2COS_CFG
value|(UINT32_C(0x38))
define|#
directive|define
name|HWRM_QUEUE_COS2BW_QCFG
value|(UINT32_C(0x39))
define|#
directive|define
name|HWRM_QUEUE_COS2BW_CFG
value|(UINT32_C(0x3a))
define|#
directive|define
name|HWRM_VNIC_ALLOC
value|(UINT32_C(0x40))
define|#
directive|define
name|HWRM_VNIC_FREE
value|(UINT32_C(0x41))
define|#
directive|define
name|HWRM_VNIC_CFG
value|(UINT32_C(0x42))
define|#
directive|define
name|HWRM_VNIC_QCFG
value|(UINT32_C(0x43))
define|#
directive|define
name|HWRM_VNIC_TPA_CFG
value|(UINT32_C(0x44))
define|#
directive|define
name|HWRM_VNIC_RSS_CFG
value|(UINT32_C(0x46))
define|#
directive|define
name|HWRM_VNIC_RSS_QCFG
value|(UINT32_C(0x47))
define|#
directive|define
name|HWRM_VNIC_PLCMODES_CFG
value|(UINT32_C(0x48))
define|#
directive|define
name|HWRM_VNIC_PLCMODES_QCFG
value|(UINT32_C(0x49))
define|#
directive|define
name|HWRM_VNIC_QCAPS
value|(UINT32_C(0x4a))
define|#
directive|define
name|HWRM_RING_ALLOC
value|(UINT32_C(0x50))
define|#
directive|define
name|HWRM_RING_FREE
value|(UINT32_C(0x51))
define|#
directive|define
name|HWRM_RING_CMPL_RING_QAGGINT_PARAMS
value|(UINT32_C(0x52))
define|#
directive|define
name|HWRM_RING_CMPL_RING_CFG_AGGINT_PARAMS
value|(UINT32_C(0x53))
define|#
directive|define
name|HWRM_RING_RESET
value|(UINT32_C(0x5e))
define|#
directive|define
name|HWRM_RING_GRP_ALLOC
value|(UINT32_C(0x60))
define|#
directive|define
name|HWRM_RING_GRP_FREE
value|(UINT32_C(0x61))
define|#
directive|define
name|HWRM_VNIC_RSS_COS_LB_CTX_ALLOC
value|(UINT32_C(0x70))
define|#
directive|define
name|HWRM_VNIC_RSS_COS_LB_CTX_FREE
value|(UINT32_C(0x71))
define|#
directive|define
name|HWRM_CFA_L2_FILTER_ALLOC
value|(UINT32_C(0x90))
define|#
directive|define
name|HWRM_CFA_L2_FILTER_FREE
value|(UINT32_C(0x91))
define|#
directive|define
name|HWRM_CFA_L2_FILTER_CFG
value|(UINT32_C(0x92))
define|#
directive|define
name|HWRM_CFA_L2_SET_RX_MASK
value|(UINT32_C(0x93))
define|#
directive|define
name|HWRM_CFA_VLAN_ANTISPOOF_CFG
value|(UINT32_C(0x94))
define|#
directive|define
name|HWRM_CFA_TUNNEL_FILTER_ALLOC
value|(UINT32_C(0x95))
define|#
directive|define
name|HWRM_CFA_TUNNEL_FILTER_FREE
value|(UINT32_C(0x96))
define|#
directive|define
name|HWRM_CFA_NTUPLE_FILTER_ALLOC
value|(UINT32_C(0x99))
define|#
directive|define
name|HWRM_CFA_NTUPLE_FILTER_FREE
value|(UINT32_C(0x9a))
define|#
directive|define
name|HWRM_CFA_NTUPLE_FILTER_CFG
value|(UINT32_C(0x9b))
define|#
directive|define
name|HWRM_TUNNEL_DST_PORT_QUERY
value|(UINT32_C(0xa0))
define|#
directive|define
name|HWRM_TUNNEL_DST_PORT_ALLOC
value|(UINT32_C(0xa1))
define|#
directive|define
name|HWRM_TUNNEL_DST_PORT_FREE
value|(UINT32_C(0xa2))
define|#
directive|define
name|HWRM_STAT_CTX_ALLOC
value|(UINT32_C(0xb0))
define|#
directive|define
name|HWRM_STAT_CTX_FREE
value|(UINT32_C(0xb1))
define|#
directive|define
name|HWRM_STAT_CTX_QUERY
value|(UINT32_C(0xb2))
define|#
directive|define
name|HWRM_STAT_CTX_CLR_STATS
value|(UINT32_C(0xb3))
define|#
directive|define
name|HWRM_FW_RESET
value|(UINT32_C(0xc0))
define|#
directive|define
name|HWRM_FW_QSTATUS
value|(UINT32_C(0xc1))
define|#
directive|define
name|HWRM_FW_SET_TIME
value|(UINT32_C(0xc8))
define|#
directive|define
name|HWRM_FW_GET_TIME
value|(UINT32_C(0xc9))
define|#
directive|define
name|HWRM_EXEC_FWD_RESP
value|(UINT32_C(0xd0))
define|#
directive|define
name|HWRM_REJECT_FWD_RESP
value|(UINT32_C(0xd1))
define|#
directive|define
name|HWRM_FWD_RESP
value|(UINT32_C(0xd2))
define|#
directive|define
name|HWRM_FWD_ASYNC_EVENT_CMPL
value|(UINT32_C(0xd3))
define|#
directive|define
name|HWRM_TEMP_MONITOR_QUERY
value|(UINT32_C(0xe0))
define|#
directive|define
name|HWRM_WOL_FILTER_ALLOC
value|(UINT32_C(0xf0))
define|#
directive|define
name|HWRM_WOL_FILTER_FREE
value|(UINT32_C(0xf1))
define|#
directive|define
name|HWRM_WOL_FILTER_QCFG
value|(UINT32_C(0xf2))
define|#
directive|define
name|HWRM_WOL_REASON_QCFG
value|(UINT32_C(0xf3))
define|#
directive|define
name|HWRM_CFA_VLAN_ANTISPOOF_QCFG
value|(UINT32_C(0x10a))
define|#
directive|define
name|HWRM_DBG_DUMP
value|(UINT32_C(0xff14))
define|#
directive|define
name|HWRM_NVM_VALIDATE_OPTION
value|(UINT32_C(0xffef))
define|#
directive|define
name|HWRM_NVM_FLUSH
value|(UINT32_C(0xfff0))
define|#
directive|define
name|HWRM_NVM_GET_VARIABLE
value|(UINT32_C(0xfff1))
define|#
directive|define
name|HWRM_NVM_SET_VARIABLE
value|(UINT32_C(0xfff2))
define|#
directive|define
name|HWRM_NVM_INSTALL_UPDATE
value|(UINT32_C(0xfff3))
define|#
directive|define
name|HWRM_NVM_MODIFY
value|(UINT32_C(0xfff4))
define|#
directive|define
name|HWRM_NVM_VERIFY_UPDATE
value|(UINT32_C(0xfff5))
define|#
directive|define
name|HWRM_NVM_GET_DEV_INFO
value|(UINT32_C(0xfff6))
define|#
directive|define
name|HWRM_NVM_ERASE_DIR_ENTRY
value|(UINT32_C(0xfff7))
define|#
directive|define
name|HWRM_NVM_MOD_DIR_ENTRY
value|(UINT32_C(0xfff8))
define|#
directive|define
name|HWRM_NVM_FIND_DIR_ENTRY
value|(UINT32_C(0xfff9))
define|#
directive|define
name|HWRM_NVM_GET_DIR_ENTRIES
value|(UINT32_C(0xfffa))
define|#
directive|define
name|HWRM_NVM_GET_DIR_INFO
value|(UINT32_C(0xfffb))
define|#
directive|define
name|HWRM_NVM_RAW_DUMP
value|(UINT32_C(0xfffc))
define|#
directive|define
name|HWRM_NVM_READ
value|(UINT32_C(0xfffd))
define|#
directive|define
name|HWRM_NVM_WRITE
value|(UINT32_C(0xfffe))
define|#
directive|define
name|HWRM_NVM_RAW_WRITE_BLK
value|(UINT32_C(0xffff))
name|uint16_t
name|unused_0
index|[
literal|3
index|]
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_define
define|#
directive|define
name|GET_HWRM_ERROR_CODE
parameter_list|(
name|x
parameter_list|)
define|\
value|((x) == 0xf ? "HWRM_ERROR": \ 	((x) == 0xffff ? "CMD_NOT_SUPPORTED": \ 	((x) == 0xfffe ? "UNKNOWN_ERR": \ 	((x) == 0x4 ? "RESOURCE_ALLOC_ERROR": \ 	((x) == 0x5 ? "INVALID_FLAGS": \ 	((x) == 0x6 ? "INVALID_ENABLES": \ 	((x) == 0x0 ? "SUCCESS": \ 	((x) == 0x1 ? "FAIL": \ 	((x) == 0x2 ? "INVALID_PARAMS": \ 	((x) == 0x3 ? "RESOURCE_ACCESS_DENIED": \ 	"Unknown error_code"))))))))))
end_define

begin_comment
comment|/* Return Codes (8 bytes) */
end_comment

begin_struct
struct|struct
name|ret_codes
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* These are numbers assigned to return/error codes. */
comment|/* Request was successfully executed by the HWRM. */
define|#
directive|define
name|HWRM_ERR_CODE_SUCCESS
value|(UINT32_C(0x0))
comment|/* THe HWRM failed to execute the request. */
define|#
directive|define
name|HWRM_ERR_CODE_FAIL
value|(UINT32_C(0x1))
comment|/* The request contains invalid argument(s) or input parameters. */
define|#
directive|define
name|HWRM_ERR_CODE_INVALID_PARAMS
value|(UINT32_C(0x2))
comment|/* 	 * The requester is not allowed to access the requested 	 * resource. This error code shall be provided in a response to 	 * a request to query or modify an existing resource that is not 	 * accessible by the requester. 	 */
define|#
directive|define
name|HWRM_ERR_CODE_RESOURCE_ACCESS_DENIED
value|(UINT32_C(0x3))
comment|/* 	 * The HWRM is unable to allocate the requested resource. This 	 * code only applies to requests for HWRM resource allocations. 	 */
define|#
directive|define
name|HWRM_ERR_CODE_RESOURCE_ALLOC_ERROR
value|(UINT32_C(0x4))
comment|/* Invalid combination of flags is specified in the request. */
define|#
directive|define
name|HWRM_ERR_CODE_INVALID_FLAGS
value|(UINT32_C(0x5))
comment|/* 	 * Invalid combination of enables fields is specified in the 	 * request. 	 */
define|#
directive|define
name|HWRM_ERR_CODE_INVALID_ENABLES
value|(UINT32_C(0x6))
comment|/* Generic HWRM execution error that represents an internal error. */
define|#
directive|define
name|HWRM_ERR_CODE_HWRM_ERROR
value|(UINT32_C(0xf))
comment|/* Unknown error */
define|#
directive|define
name|HWRM_ERR_CODE_UNKNOWN_ERR
value|(UINT32_C(0xfffe))
comment|/* Unsupported or invalid command */
define|#
directive|define
name|HWRM_ERR_CODE_CMD_NOT_SUPPORTED
value|(UINT32_C(0xffff))
name|uint16_t
name|unused_0
index|[
literal|3
index|]
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Output (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_err_output
block|{
name|uint16_t
name|error_code
decl_stmt|;
comment|/* 	 * Pass/Fail or error type Note: receiver to verify the in parameters, 	 * and fail the call with an error when appropriate 	 */
name|uint16_t
name|req_type
decl_stmt|;
comment|/* This field returns the type of original request. */
name|uint16_t
name|seq_id
decl_stmt|;
comment|/* This field provides original sequence number of the command. */
name|uint16_t
name|resp_len
decl_stmt|;
comment|/* 	 * This field is the length of the response in bytes. The last byte of 	 * the response is a valid flag that will read as '1' when the command 	 * has been completely written to memory. 	 */
name|uint32_t
name|opaque_0
decl_stmt|;
comment|/* debug info for this error response. */
name|uint16_t
name|opaque_1
decl_stmt|;
comment|/* debug info for this error response. */
name|uint8_t
name|cmd_err
decl_stmt|;
comment|/* 	 * In the case of an error response, command specific error code is 	 * returned in this field. 	 */
name|uint8_t
name|valid
decl_stmt|;
comment|/* 	 * This field is used in Output records to indicate that the output is 	 * completely written to RAM. This field should be read as '1' to 	 * indicate that the output has been completely written. When writing a 	 * command completion or response to an internal processor, the order of 	 * writes has to be such that this field is written last. 	 */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Port Tx Statistics Formats (408 bytes) */
end_comment

begin_struct
struct|struct
name|tx_port_stats
block|{
name|uint64_t
name|tx_64b_frames
decl_stmt|;
comment|/* Total Number of 64 Bytes frames transmitted */
name|uint64_t
name|tx_65b_127b_frames
decl_stmt|;
comment|/* Total Number of 65-127 Bytes frames transmitted */
name|uint64_t
name|tx_128b_255b_frames
decl_stmt|;
comment|/* Total Number of 128-255 Bytes frames transmitted */
name|uint64_t
name|tx_256b_511b_frames
decl_stmt|;
comment|/* Total Number of 256-511 Bytes frames transmitted */
name|uint64_t
name|tx_512b_1023b_frames
decl_stmt|;
comment|/* Total Number of 512-1023 Bytes frames transmitted */
name|uint64_t
name|tx_1024b_1518_frames
decl_stmt|;
comment|/* Total Number of 1024-1518 Bytes frames transmitted */
name|uint64_t
name|tx_good_vlan_frames
decl_stmt|;
comment|/* 	 * Total Number of each good VLAN (exludes FCS errors) frame transmitted 	 * which is 1519 to 1522 bytes in length inclusive (excluding framing 	 * bits but including FCS bytes). 	 */
name|uint64_t
name|tx_1519b_2047_frames
decl_stmt|;
comment|/* Total Number of 1519-2047 Bytes frames transmitted */
name|uint64_t
name|tx_2048b_4095b_frames
decl_stmt|;
comment|/* Total Number of 2048-4095 Bytes frames transmitted */
name|uint64_t
name|tx_4096b_9216b_frames
decl_stmt|;
comment|/* Total Number of 4096-9216 Bytes frames transmitted */
name|uint64_t
name|tx_9217b_16383b_frames
decl_stmt|;
comment|/* Total Number of 9217-16383 Bytes frames transmitted */
name|uint64_t
name|tx_good_frames
decl_stmt|;
comment|/* Total Number of good frames transmitted */
name|uint64_t
name|tx_total_frames
decl_stmt|;
comment|/* Total Number of frames transmitted */
name|uint64_t
name|tx_ucast_frames
decl_stmt|;
comment|/* Total number of unicast frames transmitted */
name|uint64_t
name|tx_mcast_frames
decl_stmt|;
comment|/* Total number of multicast frames transmitted */
name|uint64_t
name|tx_bcast_frames
decl_stmt|;
comment|/* Total number of broadcast frames transmitted */
name|uint64_t
name|tx_pause_frames
decl_stmt|;
comment|/* Total number of PAUSE control frames transmitted */
name|uint64_t
name|tx_pfc_frames
decl_stmt|;
comment|/* Total number of PFC/per-priority PAUSE control frames transmitted */
name|uint64_t
name|tx_jabber_frames
decl_stmt|;
comment|/* Total number of jabber frames transmitted */
name|uint64_t
name|tx_fcs_err_frames
decl_stmt|;
comment|/* Total number of frames transmitted with FCS error */
name|uint64_t
name|tx_control_frames
decl_stmt|;
comment|/* Total number of control frames transmitted */
name|uint64_t
name|tx_oversz_frames
decl_stmt|;
comment|/* Total number of over-sized frames transmitted */
name|uint64_t
name|tx_single_dfrl_frames
decl_stmt|;
comment|/* Total number of frames with single deferral */
name|uint64_t
name|tx_multi_dfrl_frames
decl_stmt|;
comment|/* Total number of frames with multiple deferrals */
name|uint64_t
name|tx_single_coll_frames
decl_stmt|;
comment|/* Total number of frames with single collision */
name|uint64_t
name|tx_multi_coll_frames
decl_stmt|;
comment|/* Total number of frames with multiple collisions */
name|uint64_t
name|tx_late_coll_frames
decl_stmt|;
comment|/* Total number of frames with late collisions */
name|uint64_t
name|tx_excessive_coll_frames
decl_stmt|;
comment|/* Total number of frames with excessive collisions */
name|uint64_t
name|tx_frag_frames
decl_stmt|;
comment|/* Total number of fragmented frames transmitted */
name|uint64_t
name|tx_err
decl_stmt|;
comment|/* Total number of transmit errors */
name|uint64_t
name|tx_tagged_frames
decl_stmt|;
comment|/* Total number of single VLAN tagged frames transmitted */
name|uint64_t
name|tx_dbl_tagged_frames
decl_stmt|;
comment|/* Total number of double VLAN tagged frames transmitted */
name|uint64_t
name|tx_runt_frames
decl_stmt|;
comment|/* Total number of runt frames transmitted */
name|uint64_t
name|tx_fifo_underruns
decl_stmt|;
comment|/* Total number of TX FIFO under runs */
name|uint64_t
name|tx_pfc_ena_frames_pri0
decl_stmt|;
comment|/* Total number of PFC frames with PFC enabled bit for Pri 0 transmitted */
name|uint64_t
name|tx_pfc_ena_frames_pri1
decl_stmt|;
comment|/* Total number of PFC frames with PFC enabled bit for Pri 1 transmitted */
name|uint64_t
name|tx_pfc_ena_frames_pri2
decl_stmt|;
comment|/* Total number of PFC frames with PFC enabled bit for Pri 2 transmitted */
name|uint64_t
name|tx_pfc_ena_frames_pri3
decl_stmt|;
comment|/* Total number of PFC frames with PFC enabled bit for Pri 3 transmitted */
name|uint64_t
name|tx_pfc_ena_frames_pri4
decl_stmt|;
comment|/* Total number of PFC frames with PFC enabled bit for Pri 4 transmitted */
name|uint64_t
name|tx_pfc_ena_frames_pri5
decl_stmt|;
comment|/* Total number of PFC frames with PFC enabled bit for Pri 5 transmitted */
name|uint64_t
name|tx_pfc_ena_frames_pri6
decl_stmt|;
comment|/* Total number of PFC frames with PFC enabled bit for Pri 6 transmitted */
name|uint64_t
name|tx_pfc_ena_frames_pri7
decl_stmt|;
comment|/* Total number of PFC frames with PFC enabled bit for Pri 7 transmitted */
name|uint64_t
name|tx_eee_lpi_events
decl_stmt|;
comment|/* Total number of EEE LPI Events on TX */
name|uint64_t
name|tx_eee_lpi_duration
decl_stmt|;
comment|/* EEE LPI Duration Counter on TX */
name|uint64_t
name|tx_llfc_logical_msgs
decl_stmt|;
comment|/* Total number of Link Level Flow Control (LLFC) messages transmitted */
name|uint64_t
name|tx_hcfc_msgs
decl_stmt|;
comment|/* Total number of HCFC messages transmitted */
name|uint64_t
name|tx_total_collisions
decl_stmt|;
comment|/* Total number of TX collisions */
name|uint64_t
name|tx_bytes
decl_stmt|;
comment|/* Total number of transmitted bytes */
name|uint64_t
name|tx_xthol_frames
decl_stmt|;
comment|/* Total number of end-to-end HOL frames */
name|uint64_t
name|tx_stat_discard
decl_stmt|;
comment|/* Total Tx Drops per Port reported by STATS block */
name|uint64_t
name|tx_stat_error
decl_stmt|;
comment|/* Total Tx Error Drops per Port reported by STATS block */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Port Rx Statistics Formats (528 bytes) */
end_comment

begin_struct
struct|struct
name|rx_port_stats
block|{
name|uint64_t
name|rx_64b_frames
decl_stmt|;
comment|/* Total Number of 64 Bytes frames received */
name|uint64_t
name|rx_65b_127b_frames
decl_stmt|;
comment|/* Total Number of 65-127 Bytes frames received */
name|uint64_t
name|rx_128b_255b_frames
decl_stmt|;
comment|/* Total Number of 128-255 Bytes frames received */
name|uint64_t
name|rx_256b_511b_frames
decl_stmt|;
comment|/* Total Number of 256-511 Bytes frames received */
name|uint64_t
name|rx_512b_1023b_frames
decl_stmt|;
comment|/* Total Number of 512-1023 Bytes frames received */
name|uint64_t
name|rx_1024b_1518_frames
decl_stmt|;
comment|/* Total Number of 1024-1518 Bytes frames received */
name|uint64_t
name|rx_good_vlan_frames
decl_stmt|;
comment|/* 	 * Total Number of each good VLAN (exludes FCS errors) frame received 	 * which is 1519 to 1522 bytes in length inclusive (excluding framing 	 * bits but including FCS bytes). 	 */
name|uint64_t
name|rx_1519b_2047b_frames
decl_stmt|;
comment|/* Total Number of 1519-2047 Bytes frames received */
name|uint64_t
name|rx_2048b_4095b_frames
decl_stmt|;
comment|/* Total Number of 2048-4095 Bytes frames received */
name|uint64_t
name|rx_4096b_9216b_frames
decl_stmt|;
comment|/* Total Number of 4096-9216 Bytes frames received */
name|uint64_t
name|rx_9217b_16383b_frames
decl_stmt|;
comment|/* Total Number of 9217-16383 Bytes frames received */
name|uint64_t
name|rx_total_frames
decl_stmt|;
comment|/* Total number of frames received */
name|uint64_t
name|rx_ucast_frames
decl_stmt|;
comment|/* Total number of unicast frames received */
name|uint64_t
name|rx_mcast_frames
decl_stmt|;
comment|/* Total number of multicast frames received */
name|uint64_t
name|rx_bcast_frames
decl_stmt|;
comment|/* Total number of broadcast frames received */
name|uint64_t
name|rx_fcs_err_frames
decl_stmt|;
comment|/* Total number of received frames with FCS error */
name|uint64_t
name|rx_ctrl_frames
decl_stmt|;
comment|/* Total number of control frames received */
name|uint64_t
name|rx_pause_frames
decl_stmt|;
comment|/* Total number of PAUSE frames received */
name|uint64_t
name|rx_pfc_frames
decl_stmt|;
comment|/* Total number of PFC frames received */
name|uint64_t
name|rx_unsupported_opcode_frames
decl_stmt|;
comment|/* Total number of frames received with an unsupported opcode */
name|uint64_t
name|rx_unsupported_da_pausepfc_frames
decl_stmt|;
comment|/* 	 * Total number of frames received with an unsupported DA for pause and 	 * PFC 	 */
name|uint64_t
name|rx_wrong_sa_frames
decl_stmt|;
comment|/* Total number of frames received with an unsupported SA */
name|uint64_t
name|rx_align_err_frames
decl_stmt|;
comment|/* Total number of received packets with alignment error */
name|uint64_t
name|rx_oor_len_frames
decl_stmt|;
comment|/* Total number of received frames with out-of-range length */
name|uint64_t
name|rx_code_err_frames
decl_stmt|;
comment|/* Total number of received frames with error termination */
name|uint64_t
name|rx_false_carrier_frames
decl_stmt|;
comment|/* 	 * Total number of received frames with a false carrier is detected 	 * during idle, as defined by RX_ER samples active and RXD is 0xE. The 	 * event is reported along with the statistics generated on the next 	 * received frame. Only one false carrier condition can be detected and 	 * logged between frames. Carrier event, valid for 10M/100M speed modes 	 * only. 	 */
name|uint64_t
name|rx_ovrsz_frames
decl_stmt|;
comment|/* Total number of over-sized frames received */
name|uint64_t
name|rx_jbr_frames
decl_stmt|;
comment|/* Total number of jabber packets received */
name|uint64_t
name|rx_mtu_err_frames
decl_stmt|;
comment|/* Total number of received frames with MTU error */
name|uint64_t
name|rx_match_crc_frames
decl_stmt|;
comment|/* Total number of received frames with CRC match */
name|uint64_t
name|rx_promiscuous_frames
decl_stmt|;
comment|/* Total number of frames received promiscuously */
name|uint64_t
name|rx_tagged_frames
decl_stmt|;
comment|/* Total number of received frames with one or two VLAN tags */
name|uint64_t
name|rx_double_tagged_frames
decl_stmt|;
comment|/* Total number of received frames with two VLAN tags */
name|uint64_t
name|rx_trunc_frames
decl_stmt|;
comment|/* Total number of truncated frames received */
name|uint64_t
name|rx_good_frames
decl_stmt|;
comment|/* Total number of good frames (without errors) received */
name|uint64_t
name|rx_pfc_xon2xoff_frames_pri0
decl_stmt|;
comment|/* 	 * Total number of received PFC frames with transition from XON to XOFF 	 * on Pri 0 	 */
name|uint64_t
name|rx_pfc_xon2xoff_frames_pri1
decl_stmt|;
comment|/* 	 * Total number of received PFC frames with transition from XON to XOFF 	 * on Pri 1 	 */
name|uint64_t
name|rx_pfc_xon2xoff_frames_pri2
decl_stmt|;
comment|/* 	 * Total number of received PFC frames with transition from XON to XOFF 	 * on Pri 2 	 */
name|uint64_t
name|rx_pfc_xon2xoff_frames_pri3
decl_stmt|;
comment|/* 	 * Total number of received PFC frames with transition from XON to XOFF 	 * on Pri 3 	 */
name|uint64_t
name|rx_pfc_xon2xoff_frames_pri4
decl_stmt|;
comment|/* 	 * Total number of received PFC frames with transition from XON to XOFF 	 * on Pri 4 	 */
name|uint64_t
name|rx_pfc_xon2xoff_frames_pri5
decl_stmt|;
comment|/* 	 * Total number of received PFC frames with transition from XON to XOFF 	 * on Pri 5 	 */
name|uint64_t
name|rx_pfc_xon2xoff_frames_pri6
decl_stmt|;
comment|/* 	 * Total number of received PFC frames with transition from XON to XOFF 	 * on Pri 6 	 */
name|uint64_t
name|rx_pfc_xon2xoff_frames_pri7
decl_stmt|;
comment|/* 	 * Total number of received PFC frames with transition from XON to XOFF 	 * on Pri 7 	 */
name|uint64_t
name|rx_pfc_ena_frames_pri0
decl_stmt|;
comment|/* Total number of received PFC frames with PFC enabled bit for Pri 0 */
name|uint64_t
name|rx_pfc_ena_frames_pri1
decl_stmt|;
comment|/* Total number of received PFC frames with PFC enabled bit for Pri 1 */
name|uint64_t
name|rx_pfc_ena_frames_pri2
decl_stmt|;
comment|/* Total number of received PFC frames with PFC enabled bit for Pri 2 */
name|uint64_t
name|rx_pfc_ena_frames_pri3
decl_stmt|;
comment|/* Total number of received PFC frames with PFC enabled bit for Pri 3 */
name|uint64_t
name|rx_pfc_ena_frames_pri4
decl_stmt|;
comment|/* Total number of received PFC frames with PFC enabled bit for Pri 4 */
name|uint64_t
name|rx_pfc_ena_frames_pri5
decl_stmt|;
comment|/* Total number of received PFC frames with PFC enabled bit for Pri 5 */
name|uint64_t
name|rx_pfc_ena_frames_pri6
decl_stmt|;
comment|/* Total number of received PFC frames with PFC enabled bit for Pri 6 */
name|uint64_t
name|rx_pfc_ena_frames_pri7
decl_stmt|;
comment|/* Total number of received PFC frames with PFC enabled bit for Pri 7 */
name|uint64_t
name|rx_sch_crc_err_frames
decl_stmt|;
comment|/* Total Number of frames received with SCH CRC error */
name|uint64_t
name|rx_undrsz_frames
decl_stmt|;
comment|/* Total Number of under-sized frames received */
name|uint64_t
name|rx_frag_frames
decl_stmt|;
comment|/* Total Number of fragmented frames received */
name|uint64_t
name|rx_eee_lpi_events
decl_stmt|;
comment|/* Total number of RX EEE LPI Events */
name|uint64_t
name|rx_eee_lpi_duration
decl_stmt|;
comment|/* EEE LPI Duration Counter on RX */
name|uint64_t
name|rx_llfc_physical_msgs
decl_stmt|;
comment|/* 	 * Total number of physical type Link Level Flow Control (LLFC) messages 	 * received 	 */
name|uint64_t
name|rx_llfc_logical_msgs
decl_stmt|;
comment|/* 	 * Total number of logical type Link Level Flow Control (LLFC) messages 	 * received 	 */
name|uint64_t
name|rx_llfc_msgs_with_crc_err
decl_stmt|;
comment|/* 	 * Total number of logical type Link Level Flow Control (LLFC) messages 	 * received with CRC error 	 */
name|uint64_t
name|rx_hcfc_msgs
decl_stmt|;
comment|/* Total number of HCFC messages received */
name|uint64_t
name|rx_hcfc_msgs_with_crc_err
decl_stmt|;
comment|/* Total number of HCFC messages received with CRC error */
name|uint64_t
name|rx_bytes
decl_stmt|;
comment|/* Total number of received bytes */
name|uint64_t
name|rx_runt_bytes
decl_stmt|;
comment|/* Total number of bytes received in runt frames */
name|uint64_t
name|rx_runt_frames
decl_stmt|;
comment|/* Total number of runt frames received */
name|uint64_t
name|rx_stat_discard
decl_stmt|;
comment|/* Total Rx Discards per Port reported by STATS block */
name|uint64_t
name|rx_stat_err
decl_stmt|;
comment|/* Total Rx Error Drops per Port reported by STATS block */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Periodic Statistics Context DMA to host (160 bytes) */
end_comment

begin_struct
struct|struct
name|ctx_hw_stats
block|{
name|uint64_t
name|rx_ucast_pkts
decl_stmt|;
comment|/* Number of received unicast packets */
name|uint64_t
name|rx_mcast_pkts
decl_stmt|;
comment|/* Number of received multicast packets */
name|uint64_t
name|rx_bcast_pkts
decl_stmt|;
comment|/* Number of received broadcast packets */
name|uint64_t
name|rx_discard_pkts
decl_stmt|;
comment|/* Number of discarded packets on received path */
name|uint64_t
name|rx_drop_pkts
decl_stmt|;
comment|/* Number of dropped packets on received path */
name|uint64_t
name|rx_ucast_bytes
decl_stmt|;
comment|/* Number of received bytes for unicast traffic */
name|uint64_t
name|rx_mcast_bytes
decl_stmt|;
comment|/* Number of received bytes for multicast traffic */
name|uint64_t
name|rx_bcast_bytes
decl_stmt|;
comment|/* Number of received bytes for broadcast traffic */
name|uint64_t
name|tx_ucast_pkts
decl_stmt|;
comment|/* Number of transmitted unicast packets */
name|uint64_t
name|tx_mcast_pkts
decl_stmt|;
comment|/* Number of transmitted multicast packets */
name|uint64_t
name|tx_bcast_pkts
decl_stmt|;
comment|/* Number of transmitted broadcast packets */
name|uint64_t
name|tx_discard_pkts
decl_stmt|;
comment|/* Number of discarded packets on transmit path */
name|uint64_t
name|tx_drop_pkts
decl_stmt|;
comment|/* Number of dropped packets on transmit path */
name|uint64_t
name|tx_ucast_bytes
decl_stmt|;
comment|/* Number of transmitted bytes for unicast traffic */
name|uint64_t
name|tx_mcast_bytes
decl_stmt|;
comment|/* Number of transmitted bytes for multicast traffic */
name|uint64_t
name|tx_bcast_bytes
decl_stmt|;
comment|/* Number of transmitted bytes for broadcast traffic */
name|uint64_t
name|tpa_pkts
decl_stmt|;
comment|/* Number of TPA packets */
name|uint64_t
name|tpa_bytes
decl_stmt|;
comment|/* Number of TPA bytes */
name|uint64_t
name|tpa_events
decl_stmt|;
comment|/* Number of TPA events */
name|uint64_t
name|tpa_aborts
decl_stmt|;
comment|/* Number of TPA aborts */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* Structure data header (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_struct_hdr
block|{
name|uint16_t
name|struct_id
decl_stmt|;
comment|/* This value indicates the structured data ID. */
comment|/* LLDP configuration structured data ID. */
define|#
directive|define
name|HWRM_STRUCT_HDR_STRUCT_ID_LLDP_CFG
value|UINT32_C(0x41b)
comment|/* DCBX ETS configuration structured data ID. */
define|#
directive|define
name|HWRM_STRUCT_HDR_STRUCT_ID_DCBX_ETS
value|UINT32_C(0x41d)
comment|/* DCBX PFC configuration structured data ID. */
define|#
directive|define
name|HWRM_STRUCT_HDR_STRUCT_ID_DCBX_PFC
value|UINT32_C(0x41f)
comment|/* DCBX APP configuration structured data ID. */
define|#
directive|define
name|HWRM_STRUCT_HDR_STRUCT_ID_DCBX_APP
value|UINT32_C(0x421)
comment|/* 	 * DCBX state configuration structured data ID for all DCBX 	 * features. 	 */
define|#
directive|define
name|HWRM_STRUCT_HDR_STRUCT_ID_DCBX_FEATURE_STATE
value|UINT32_C(0x422)
comment|/* 	 * LLDP generic structured data ID. This is used with 	 * GET_STRUCTURED_DATA only. 	 */
define|#
directive|define
name|HWRM_STRUCT_HDR_STRUCT_ID_LLDP_GENERIC
value|UINT32_C(0x424)
comment|/* 	 * LLDP device structured data ID. This is used with 	 * GET_STRUCTURED_DATA only. 	 */
define|#
directive|define
name|HWRM_STRUCT_HDR_STRUCT_ID_LLDP_DEVICE
value|UINT32_C(0x426)
comment|/* reserved for AFM usage. */
define|#
directive|define
name|HWRM_STRUCT_HDR_STRUCT_ID_AFM_OPAQUE
value|UINT32_C(0x1)
comment|/* Port description. */
define|#
directive|define
name|HWRM_STRUCT_HDR_STRUCT_ID_PORT_DESCRIPTION
value|UINT32_C(0xa)
comment|/* RSSv2 Configuration. */
define|#
directive|define
name|HWRM_STRUCT_HDR_STRUCT_ID_RSS_V2
value|UINT32_C(0x64)
name|uint16_t
name|len
decl_stmt|;
comment|/* This value indicates the length of structured data. */
name|uint8_t
name|version
decl_stmt|;
comment|/* This value indicates the version of structured data. */
name|uint8_t
name|count
decl_stmt|;
comment|/* This value indicates the number of structured data elements. */
name|uint16_t
name|subtype
decl_stmt|;
comment|/* This value indicates the subtype. */
name|uint16_t
name|next_offset
decl_stmt|;
comment|/* 	 * This value indicates the count of 64-bit values that point to the 	 * next header. A value of 0 means that this is the last element. The 	 * value is a count of 64-bit words from the beginning of the current 	 * header. 	 */
comment|/* This value indicates this is the last element */
define|#
directive|define
name|HWRM_STRUCT_HDR_NEXT_OFFSET_LAST
value|UINT32_C(0x0)
name|uint16_t
name|unused_0
index|[
literal|3
index|]
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* DCBX ETS configuration structure (1053) (32 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_struct_data_dcbx_ets
block|{
name|uint8_t
name|destination
decl_stmt|;
comment|/* 	 * This field indicates if this configuration is ETS recommendation or 	 * ETS configuration. A value 1 means it is ETS configuration, A value 	 * of 2 means it is a ETS recommendation. 	 */
comment|/* ETS configuration */
define|#
directive|define
name|HWRM_STRUCT_DATA_DCBX_ETS_DESTINATION_CONFIGURATION
value|UINT32_C(0x1)
comment|/* ETS recommendation */
define|#
directive|define
name|HWRM_STRUCT_DATA_DCBX_ETS_DESTINATION_RECOMMMENDATION
value|UINT32_C(0x2)
name|uint8_t
name|max_tcs
decl_stmt|;
comment|/* This value indicates maximum ETS TCs supported. */
name|uint16_t
name|unused_0
decl_stmt|;
comment|/* unused. */
name|uint8_t
name|pri0_to_tc_map
decl_stmt|;
comment|/* ETS priority 0 to TC map. */
name|uint8_t
name|pri1_to_tc_map
decl_stmt|;
comment|/* ETS priority 1 to TC map. */
name|uint8_t
name|pri2_to_tc_map
decl_stmt|;
comment|/* ETS priority 2 to TC map. */
name|uint8_t
name|pri3_to_tc_map
decl_stmt|;
comment|/* ETS priority 3 to TC map. */
name|uint8_t
name|pri4_to_tc_map
decl_stmt|;
comment|/* ETS priority 4 to TC map. */
name|uint8_t
name|pri5_to_tc_map
decl_stmt|;
comment|/* ETS priority 5 to TC map. */
name|uint8_t
name|pri6_to_tc_map
decl_stmt|;
comment|/* ETS priority 6 to TC map. */
name|uint8_t
name|pri7_to_tc_map
decl_stmt|;
comment|/* ETS priority 7 to TC map. */
name|uint8_t
name|tc0_to_bw_map
decl_stmt|;
comment|/* ETS TC 0 to bandwidth map. */
name|uint8_t
name|tc1_to_bw_map
decl_stmt|;
comment|/* ETS TC 1 to bandwidth map. */
name|uint8_t
name|tc2_to_bw_map
decl_stmt|;
comment|/* ETS TC 2 to bandwidth map. */
name|uint8_t
name|tc3_to_bw_map
decl_stmt|;
comment|/* ETS TC 3 to bandwidth map. */
name|uint8_t
name|tc4_to_bw_map
decl_stmt|;
comment|/* ETS TC 4 to bandwidth map. */
name|uint8_t
name|tc5_to_bw_map
decl_stmt|;
comment|/* ETS TC 5 to bandwidth map. */
name|uint8_t
name|tc6_to_bw_map
decl_stmt|;
comment|/* ETS TC 6 to bandwidth map. */
name|uint8_t
name|tc7_to_bw_map
decl_stmt|;
comment|/* ETS TC 7 to bandwidth map. */
name|uint8_t
name|tc0_to_tsa_map
decl_stmt|;
comment|/* ETS TC 0 to TSA map. */
comment|/* strict priority */
define|#
directive|define
name|HWRM_STRUCT_DATA_DCBX_ETS_TC0_TO_TSA_MAP_TSA_TYPE_SP
value|UINT32_C(0x0)
comment|/* credit based shaper */
define|#
directive|define
name|HWRM_STRUCT_DATA_DCBX_ETS_TC0_TO_TSA_MAP_TSA_TYPE_CBS
value|UINT32_C(0x1)
comment|/* ETS */
define|#
directive|define
name|HWRM_STRUCT_DATA_DCBX_ETS_TC0_TO_TSA_MAP_TSA_TYPE_ETS
value|UINT32_C(0x2)
comment|/* vendor specific */
define|#
directive|define
name|HWRM_STRUCT_DATA_DCBX_ETS_TC0_TO_TSA_MAP_TSA_TYPE_VENDOR_SPECIFIC
value|UINT32_C(0xff)
name|uint8_t
name|tc1_to_tsa_map
decl_stmt|;
comment|/* ETS TC 1 to TSA map. */
name|uint8_t
name|tc2_to_tsa_map
decl_stmt|;
comment|/* ETS TC 2 to TSA map. */
name|uint8_t
name|tc3_to_tsa_map
decl_stmt|;
comment|/* ETS TC 3 to TSA map. */
name|uint8_t
name|tc4_to_tsa_map
decl_stmt|;
comment|/* ETS TC 4 to TSA map. */
name|uint8_t
name|tc5_to_tsa_map
decl_stmt|;
comment|/* ETS TC 5 to TSA map. */
name|uint8_t
name|tc6_to_tsa_map
decl_stmt|;
comment|/* ETS TC 6 to TSA map. */
name|uint8_t
name|tc7_to_tsa_map
decl_stmt|;
comment|/* ETS TC 7 to TSA map. */
name|uint32_t
name|unused_1
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* DCBX PFC configuration structure (1055) (8 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_struct_data_dcbx_pfc
block|{
name|uint8_t
name|pfc_priority_bitmap
decl_stmt|;
comment|/* 	 * This field indicates PFC priority bit map. A value of '0' indicates 	 * PFC is disabled. A value of '1' indicates PFC is enabled on that 	 * priority. 	 */
name|uint8_t
name|max_pfc_tcs
decl_stmt|;
comment|/* 	 * This field indicates max PFC TCs supported. Each PFC TC will map to a 	 * lossless CoS queue. 	 */
name|uint8_t
name|mbc
decl_stmt|;
comment|/* 	 * This field indicates if MACSec bypass capability is enabled. A value 	 * of '1' indicates MBC is enabled. A value of '0' indicates MBC is 	 * disabled. 	 */
name|uint8_t
name|unused_0
index|[
literal|5
index|]
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* DCBX Application configuration structure (1057) (8 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_struct_data_dcbx_app
block|{
name|uint16_t
name|protocol_id
decl_stmt|;
comment|/* big endian */
comment|/* 	 * This field indicates the protocol identifier. This should be 	 * specified in big endian format. 	 */
name|uint8_t
name|protocol_selector
decl_stmt|;
comment|/* 	 * This field indicates the protocol selector. The valid values are 	 * mentioned below. 	 */
comment|/* ether type */
define|#
directive|define
name|HWRM_STRUCT_DATA_DCBX_APP_PROTOCOL_SELECTOR_ETHER_TYPE
value|UINT32_C(0x1)
comment|/* TCP port */
define|#
directive|define
name|HWRM_STRUCT_DATA_DCBX_APP_PROTOCOL_SELECTOR_TCP_PORT
value|UINT32_C(0x2)
comment|/* UDP port */
define|#
directive|define
name|HWRM_STRUCT_DATA_DCBX_APP_PROTOCOL_SELECTOR_UDP_PORT
value|UINT32_C(0x3)
comment|/* TCP& UDP port */
define|#
directive|define
name|HWRM_STRUCT_DATA_DCBX_APP_PROTOCOL_SELECTOR_TCP_UDP_PORT
value|UINT32_C(0x4)
name|uint8_t
name|priority
decl_stmt|;
comment|/* This field indicates application priority. */
name|uint8_t
name|valid
decl_stmt|;
comment|/* This field indicates this entry is valid. */
name|uint8_t
name|unused_0
index|[
literal|3
index|]
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* DCBX feature states configuration structure (1058) (8 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_struct_data_dcbx_feature_state
block|{
name|uint8_t
name|dcbx_mode
decl_stmt|;
comment|/* DCBX mode - IEEE or CEE. This is read only field. */
comment|/* DCBX disabled mode. */
define|#
directive|define
name|HWRM_STRUCT_DATA_DCBX_FEATURE_STATE_DCBX_MODE_DCBX_DISABLED
value|UINT32_C(0x0)
comment|/* DCBX IEEE mode. */
define|#
directive|define
name|HWRM_STRUCT_DATA_DCBX_FEATURE_STATE_DCBX_MODE_DCBX_IEEE
value|UINT32_C(0x1)
comment|/* DCBX CEE mode. */
define|#
directive|define
name|HWRM_STRUCT_DATA_DCBX_FEATURE_STATE_DCBX_MODE_DCBX_CEE
value|UINT32_C(0x2)
name|uint8_t
name|ets_state
decl_stmt|;
comment|/* ETS TLV state. */
name|uint8_t
name|pfc_state
decl_stmt|;
comment|/* PFC TLV state. */
name|uint8_t
name|app_state
decl_stmt|;
comment|/* App TLV state. */
comment|/* Feature enable bit position. */
define|#
directive|define
name|HWRM_STRUCT_DATA_DCBX_FEATURE_STATE_APP_STATE_ENABLE_BIT_POS
value|UINT32_C(0x7)
comment|/* Feature willing bit position. */
define|#
directive|define
name|HWRM_STRUCT_DATA_DCBX_FEATURE_STATE_APP_STATE_WILLING_BIT_POS
value|UINT32_C(0x6)
comment|/* Feature advertise bit position. */
define|#
directive|define
name|HWRM_STRUCT_DATA_DCBX_FEATURE_STATE_APP_STATE_ADVERTISE_BIT_POS
value|UINT32_C(0x5)
name|uint8_t
name|unused_0
index|[
literal|3
index|]
decl_stmt|;
comment|/* unused. */
name|uint8_t
name|resets
decl_stmt|;
comment|/* 	 * This field is used to reset the DCBX configuration to factory 	 * defaults. 	 */
comment|/* reset ETS configuration. */
define|#
directive|define
name|HWRM_STRUCT_DATA_DCBX_FEATURE_STATE_RESETS_RESET_ETS
value|UINT32_C(0x1)
comment|/* reset PFC configuration. */
define|#
directive|define
name|HWRM_STRUCT_DATA_DCBX_FEATURE_STATE_RESETS_RESET_PFC
value|UINT32_C(0x2)
comment|/* reset application configuration. */
define|#
directive|define
name|HWRM_STRUCT_DATA_DCBX_FEATURE_STATE_RESETS_RESET_APP
value|UINT32_C(0x4)
comment|/* reset DCBX state configuration. */
define|#
directive|define
name|HWRM_STRUCT_DATA_DCBX_FEATURE_STATE_RESETS_RESET_STATE
value|UINT32_C(0x8)
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* LLDP TLVs transmit configuration structure (1051) (8 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_struct_data_lldp
block|{
name|uint8_t
name|admin_state
decl_stmt|;
comment|/* Port admin state */
comment|/* Disable both Tx and Rx */
define|#
directive|define
name|HWRM_STRUCT_DATA_LLDP_ADMIN_STATE_DISABLE
value|UINT32_C(0x0)
comment|/* Enable Tx only */
define|#
directive|define
name|HWRM_STRUCT_DATA_LLDP_ADMIN_STATE_TX
value|UINT32_C(0x1)
comment|/* Enable Rx only */
define|#
directive|define
name|HWRM_STRUCT_DATA_LLDP_ADMIN_STATE_RX
value|UINT32_C(0x2)
comment|/* Enable both Tx and Rx */
define|#
directive|define
name|HWRM_STRUCT_DATA_LLDP_ADMIN_STATE_ENABLE
value|UINT32_C(0x3)
name|uint8_t
name|port_description_state
decl_stmt|;
comment|/* Port desciption TLV transmit state (enable(1)/disable(0)). */
comment|/* Disable */
define|#
directive|define
name|HWRM_STRUCT_DATA_LLDP_PORT_DESCRIPTION_STATE_DISABLE
value|UINT32_C(0x0)
comment|/* Enable */
define|#
directive|define
name|HWRM_STRUCT_DATA_LLDP_PORT_DESCRIPTION_STATE_ENABLE
value|UINT32_C(0x1)
name|uint8_t
name|system_name_state
decl_stmt|;
comment|/* System name TLV transmit state (enable(1)/disable(0)). */
comment|/* Disable */
define|#
directive|define
name|HWRM_STRUCT_DATA_LLDP_SYSTEM_NAME_STATE_DISABLE
value|UINT32_C(0x0)
comment|/* Enable */
define|#
directive|define
name|HWRM_STRUCT_DATA_LLDP_SYSTEM_NAME_STATE_ENABLE
value|UINT32_C(0x1)
name|uint8_t
name|system_desc_state
decl_stmt|;
comment|/* System desciption TLV transmit state (enable(1)/disable(0)). */
comment|/* Disable */
define|#
directive|define
name|HWRM_STRUCT_DATA_LLDP_SYSTEM_DESC_STATE_DISABLE
value|UINT32_C(0x0)
comment|/* Enable */
define|#
directive|define
name|HWRM_STRUCT_DATA_LLDP_SYSTEM_DESC_STATE_ENABLE
value|UINT32_C(0x1)
name|uint8_t
name|system_cap_state
decl_stmt|;
comment|/* System capabilities TLV transmit state (enable(1)/disable(0)). */
comment|/* Disable */
define|#
directive|define
name|HWRM_STRUCT_DATA_LLDP_SYSTEM_CAP_STATE_DISABLE
value|UINT32_C(0x0)
comment|/* Enable */
define|#
directive|define
name|HWRM_STRUCT_DATA_LLDP_SYSTEM_CAP_STATE_ENABLE
value|UINT32_C(0x1)
name|uint8_t
name|mgmt_addr_state
decl_stmt|;
comment|/* Management address TLV transmit state (enable(1)/disable(0)). */
comment|/* Disable */
define|#
directive|define
name|HWRM_STRUCT_DATA_LLDP_MGMT_ADDR_STATE_DISABLE
value|UINT32_C(0x0)
comment|/* Enable */
define|#
directive|define
name|HWRM_STRUCT_DATA_LLDP_MGMT_ADDR_STATE_ENABLE
value|UINT32_C(0x1)
name|uint8_t
name|async_event_notification_state
decl_stmt|;
comment|/* Async event notification state (enable(1)/disable(0)). */
comment|/* Disable */
define|#
directive|define
name|HWRM_STRUCT_DATA_LLDP_ASYNC_EVENT_NOTIFICATION_STATE_DISABLE
value|UINT32_C(0x0)
comment|/* Enable */
define|#
directive|define
name|HWRM_STRUCT_DATA_LLDP_ASYNC_EVENT_NOTIFICATION_STATE_ENABLE
value|UINT32_C(0x1)
name|uint8_t
name|unused_0
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* LLDP generic TLV configuration (1060) (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_struct_data_lldp_generic
block|{
name|uint8_t
name|tlv_type
decl_stmt|;
comment|/* TLV type. */
comment|/* Chassis ID TLV */
define|#
directive|define
name|HWRM_STRUCT_DATA_LLDP_GENERIC_TLV_TYPE_CHASSIS
value|UINT32_C(0x1)
comment|/* Port ID TLV */
define|#
directive|define
name|HWRM_STRUCT_DATA_LLDP_GENERIC_TLV_TYPE_PORT
value|UINT32_C(0x2)
comment|/* System name TLV */
define|#
directive|define
name|HWRM_STRUCT_DATA_LLDP_GENERIC_TLV_TYPE_SYSTEM_NAME
value|UINT32_C(0x3)
comment|/* System description TLV */
define|#
directive|define
name|HWRM_STRUCT_DATA_LLDP_GENERIC_TLV_TYPE_SYSTEM_DESCRIPTION
value|UINT32_C(0x4)
comment|/* Port name TLV */
define|#
directive|define
name|HWRM_STRUCT_DATA_LLDP_GENERIC_TLV_TYPE_PORT_NAME
value|UINT32_C(0x5)
comment|/* Port description TLV */
define|#
directive|define
name|HWRM_STRUCT_DATA_LLDP_GENERIC_TLV_TYPE_PORT_DESCRIPTION
value|UINT32_C(0x6)
name|uint8_t
name|subtype
decl_stmt|;
comment|/* TLV sub-type. */
name|uint8_t
name|length
decl_stmt|;
comment|/* Length. */
name|uint8_t
name|unused_0
decl_stmt|;
comment|/* unused. */
name|uint32_t
name|unused_1
decl_stmt|;
name|uint32_t
name|tlv_value
index|[
literal|64
index|]
decl_stmt|;
comment|/* TLV value. */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* LLDP device TLV configuration (1062) (64 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_struct_data_lldp_device
block|{
name|uint16_t
name|ttl
decl_stmt|;
comment|/* Time to Live. */
name|uint8_t
name|mgmt_addr_len
decl_stmt|;
comment|/* Management address length. */
name|uint8_t
name|mgmt_addr_type
decl_stmt|;
comment|/* Management address type. */
name|uint32_t
name|unused_0
decl_stmt|;
name|uint32_t
name|mgmt_addr
index|[
literal|8
index|]
decl_stmt|;
comment|/* Management address. */
name|uint32_t
name|system_caps
decl_stmt|;
comment|/* System capabilities. */
name|uint8_t
name|intf_num_type
decl_stmt|;
comment|/* Interface number type. */
name|uint8_t
name|mgmt_addr_oid_length
decl_stmt|;
comment|/* Management address OID length. */
name|uint8_t
name|unused_1
decl_stmt|;
name|uint8_t
name|unused_2
decl_stmt|;
name|uint32_t
name|intf_num
decl_stmt|;
comment|/* Interface number. */
name|uint32_t
name|unused_3
decl_stmt|;
name|uint32_t
name|mgmt_addr_oid
index|[
literal|32
index|]
decl_stmt|;
comment|/* Management address OID. */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* port description (10) (8 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_struct_data_port_description
block|{
name|uint8_t
name|port_id
decl_stmt|;
comment|/* 	 * Port #. Port number starts at 0 and anything greater than number of 	 * ports minus 1 is an error. 	 */
name|uint8_t
name|unused_0
index|[
literal|7
index|]
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* RSSv2 Configuration (100) (16 bytes) */
end_comment

begin_struct
struct|struct
name|hwrm_struct_data_rss_v2
block|{
name|uint16_t
name|flags
decl_stmt|;
comment|/* When this bit is '1', the hash type and hash key are included. */
define|#
directive|define
name|HWRM_STRUCT_DATA_RSS_V2_FLAGS_HASH_VALID
value|UINT32_C(0x1)
name|uint16_t
name|rss_ctx_id
decl_stmt|;
comment|/* RSS Context index. */
name|uint16_t
name|num_ring_groups
decl_stmt|;
comment|/* Number ring group IDs. */
name|uint16_t
name|hash_type
decl_stmt|;
comment|/* 	 * When this bit is '1', the RSS hash shall be computed over source and 	 * destination IPv4 addresses of IPv4 packets. 	 */
define|#
directive|define
name|HWRM_STRUCT_DATA_RSS_V2_HASH_TYPE_IPV4
value|UINT32_C(0x1)
comment|/* 	 * When this bit is '1', the RSS hash shall be computed over 	 * source/destination IPv4 addresses and source/destination ports of 	 * TCP/IPv4 packets. 	 */
define|#
directive|define
name|HWRM_STRUCT_DATA_RSS_V2_HASH_TYPE_TCP_IPV4
value|UINT32_C(0x2)
comment|/* 	 * When this bit is '1', the RSS hash shall be computed over 	 * source/destination IPv4 addresses and source/destination ports of 	 * UDP/IPv4 packets. 	 */
define|#
directive|define
name|HWRM_STRUCT_DATA_RSS_V2_HASH_TYPE_UDP_IPV4
value|UINT32_C(0x4)
comment|/* 	 * When this bit is '1', the RSS hash shall be computed over source and 	 * destination IPv4 addresses of IPv6 packets. 	 */
define|#
directive|define
name|HWRM_STRUCT_DATA_RSS_V2_HASH_TYPE_IPV6
value|UINT32_C(0x8)
comment|/* 	 * When this bit is '1', the RSS hash shall be computed over 	 * source/destination IPv6 addresses and source/destination ports of 	 * TCP/IPv6 packets. 	 */
define|#
directive|define
name|HWRM_STRUCT_DATA_RSS_V2_HASH_TYPE_TCP_IPV6
value|UINT32_C(0x10)
comment|/* 	 * When this bit is '1', the RSS hash shall be computed over 	 * source/destination IPv6 addresses and source/destination ports of 	 * UDP/IPv6 packets. 	 */
define|#
directive|define
name|HWRM_STRUCT_DATA_RSS_V2_HASH_TYPE_UDP_IPV6
value|UINT32_C(0x20)
name|uint64_t
name|hash_key_ring_group_ids
decl_stmt|;
comment|/* Variable size data. Hash key (optional) followed by ring_group_ids. */
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _HSI_STRUCT_DEF_EXTERNAL_H_ */
end_comment

end_unit

