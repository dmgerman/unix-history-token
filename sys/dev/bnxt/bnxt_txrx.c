begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Broadcom NetXtreme-C/E network driver.  *  * Copyright (c) 2016 Broadcom, All Rights Reserved.  * The term Broadcom refers to Broadcom Limited and/or its subsidiaries  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS'  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  * THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/iflib.h>
end_include

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_inet6.h"
end_include

begin_include
include|#
directive|include
file|"opt_rss.h"
end_include

begin_include
include|#
directive|include
file|"bnxt.h"
end_include

begin_comment
comment|/*  * Function prototypes  */
end_comment

begin_function_decl
specifier|static
name|int
name|bnxt_isc_txd_encap
parameter_list|(
name|void
modifier|*
name|sc
parameter_list|,
name|if_pkt_info_t
name|pi
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bnxt_isc_txd_flush
parameter_list|(
name|void
modifier|*
name|sc
parameter_list|,
name|uint16_t
name|txqid
parameter_list|,
name|uint32_t
name|pidx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bnxt_isc_txd_credits_update
parameter_list|(
name|void
modifier|*
name|sc
parameter_list|,
name|uint16_t
name|txqid
parameter_list|,
name|uint32_t
name|cidx
parameter_list|,
name|bool
name|clear
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bnxt_isc_rxd_refill
parameter_list|(
name|void
modifier|*
name|sc
parameter_list|,
name|uint16_t
name|rxqid
parameter_list|,
name|uint8_t
name|flid
parameter_list|,
name|uint32_t
name|pidx
parameter_list|,
name|uint64_t
modifier|*
name|paddrs
parameter_list|,
name|caddr_t
modifier|*
name|vaddrs
parameter_list|,
name|uint16_t
name|count
parameter_list|,
name|uint16_t
name|buf_size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bnxt_isc_rxd_flush
parameter_list|(
name|void
modifier|*
name|sc
parameter_list|,
name|uint16_t
name|rxqid
parameter_list|,
name|uint8_t
name|flid
parameter_list|,
name|uint32_t
name|pidx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bnxt_isc_rxd_available
parameter_list|(
name|void
modifier|*
name|sc
parameter_list|,
name|uint16_t
name|rxqid
parameter_list|,
name|uint32_t
name|idx
parameter_list|,
name|int
name|budget
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bnxt_isc_rxd_pkt_get
parameter_list|(
name|void
modifier|*
name|sc
parameter_list|,
name|if_rxd_info_t
name|ri
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bnxt_intr
parameter_list|(
name|void
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|if_txrx
name|bnxt_txrx
init|=
block|{
name|bnxt_isc_txd_encap
block|,
name|bnxt_isc_txd_flush
block|,
name|bnxt_isc_txd_credits_update
block|,
name|bnxt_isc_rxd_available
block|,
name|bnxt_isc_rxd_pkt_get
block|,
name|bnxt_isc_rxd_refill
block|,
name|bnxt_isc_rxd_flush
block|,
name|bnxt_intr
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Device Dependent Packet Transmit and Receive Functions  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|uint16_t
name|bnxt_tx_lhint
index|[]
init|=
block|{
name|TX_BD_SHORT_FLAGS_LHINT_LT512
block|,
name|TX_BD_SHORT_FLAGS_LHINT_LT1K
block|,
name|TX_BD_SHORT_FLAGS_LHINT_LT2K
block|,
name|TX_BD_SHORT_FLAGS_LHINT_LT2K
block|,
name|TX_BD_SHORT_FLAGS_LHINT_GTE2K
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|bnxt_isc_txd_encap
parameter_list|(
name|void
modifier|*
name|sc
parameter_list|,
name|if_pkt_info_t
name|pi
parameter_list|)
block|{
name|struct
name|bnxt_softc
modifier|*
name|softc
init|=
operator|(
expr|struct
name|bnxt_softc
operator|*
operator|)
name|sc
decl_stmt|;
name|struct
name|bnxt_ring
modifier|*
name|txr
init|=
operator|&
name|softc
operator|->
name|tx_rings
index|[
name|pi
operator|->
name|ipi_qsidx
index|]
decl_stmt|;
name|struct
name|tx_bd_long
modifier|*
name|tbd
decl_stmt|;
name|struct
name|tx_bd_long_hi
modifier|*
name|tbdh
decl_stmt|;
name|bool
name|need_hi
init|=
name|false
decl_stmt|;
name|uint16_t
name|flags_type
decl_stmt|;
name|uint16_t
name|lflags
decl_stmt|;
name|uint32_t
name|cfa_meta
decl_stmt|;
name|int
name|seg
init|=
literal|0
decl_stmt|;
comment|/* If we have offloads enabled, we need to use two BDs. */
if|if
condition|(
operator|(
name|pi
operator|->
name|ipi_csum_flags
operator|&
operator|(
name|CSUM_OFFLOAD
operator||
name|CSUM_TSO
operator||
name|CSUM_IP
operator|)
operator|)
operator|||
name|pi
operator|->
name|ipi_mflags
operator|&
name|M_VLANTAG
condition|)
name|need_hi
operator|=
name|true
expr_stmt|;
comment|/* TODO: Devices before Cu+B1 need to not mix long and short BDs */
name|need_hi
operator|=
name|true
expr_stmt|;
name|pi
operator|->
name|ipi_new_pidx
operator|=
name|pi
operator|->
name|ipi_pidx
expr_stmt|;
name|tbd
operator|=
operator|&
operator|(
operator|(
expr|struct
name|tx_bd_long
operator|*
operator|)
name|txr
operator|->
name|vaddr
operator|)
index|[
name|pi
operator|->
name|ipi_new_pidx
index|]
expr_stmt|;
name|pi
operator|->
name|ipi_ndescs
operator|=
literal|0
expr_stmt|;
comment|/* No need to byte-swap the opaque value */
name|tbd
operator|->
name|opaque
operator|=
operator|(
operator|(
name|pi
operator|->
name|ipi_nsegs
operator|+
name|need_hi
operator|)
operator|<<
literal|24
operator|)
operator||
name|pi
operator|->
name|ipi_new_pidx
expr_stmt|;
name|tbd
operator|->
name|len
operator|=
name|htole16
argument_list|(
name|pi
operator|->
name|ipi_segs
index|[
name|seg
index|]
operator|.
name|ds_len
argument_list|)
expr_stmt|;
name|tbd
operator|->
name|addr
operator|=
name|htole64
argument_list|(
name|pi
operator|->
name|ipi_segs
index|[
name|seg
operator|++
index|]
operator|.
name|ds_addr
argument_list|)
expr_stmt|;
name|flags_type
operator|=
operator|(
operator|(
name|pi
operator|->
name|ipi_nsegs
operator|+
name|need_hi
operator|)
operator|<<
name|TX_BD_SHORT_FLAGS_BD_CNT_SFT
operator|)
operator|&
name|TX_BD_SHORT_FLAGS_BD_CNT_MASK
expr_stmt|;
if|if
condition|(
name|pi
operator|->
name|ipi_len
operator|>=
literal|2048
condition|)
name|flags_type
operator||=
name|TX_BD_SHORT_FLAGS_LHINT_GTE2K
expr_stmt|;
else|else
name|flags_type
operator||=
name|bnxt_tx_lhint
index|[
name|pi
operator|->
name|ipi_len
operator|>>
literal|9
index|]
expr_stmt|;
if|if
condition|(
name|need_hi
condition|)
block|{
name|flags_type
operator||=
name|TX_BD_LONG_TYPE_TX_BD_LONG
expr_stmt|;
name|pi
operator|->
name|ipi_new_pidx
operator|=
name|RING_NEXT
argument_list|(
name|txr
argument_list|,
name|pi
operator|->
name|ipi_new_pidx
argument_list|)
expr_stmt|;
name|tbdh
operator|=
operator|&
operator|(
operator|(
expr|struct
name|tx_bd_long_hi
operator|*
operator|)
name|txr
operator|->
name|vaddr
operator|)
index|[
name|pi
operator|->
name|ipi_new_pidx
index|]
expr_stmt|;
name|tbdh
operator|->
name|mss
operator|=
name|htole16
argument_list|(
name|pi
operator|->
name|ipi_tso_segsz
argument_list|)
expr_stmt|;
name|tbdh
operator|->
name|hdr_size
operator|=
name|htole16
argument_list|(
operator|(
name|pi
operator|->
name|ipi_ehdrlen
operator|+
name|pi
operator|->
name|ipi_ip_hlen
operator|+
name|pi
operator|->
name|ipi_tcp_hlen
operator|)
operator|>>
literal|1
argument_list|)
expr_stmt|;
name|tbdh
operator|->
name|cfa_action
operator|=
literal|0
expr_stmt|;
name|lflags
operator|=
literal|0
expr_stmt|;
name|cfa_meta
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pi
operator|->
name|ipi_mflags
operator|&
name|M_VLANTAG
condition|)
block|{
comment|/* TODO: Do we need to byte-swap the vtag here? */
name|cfa_meta
operator|=
name|TX_BD_LONG_CFA_META_KEY_VLAN_TAG
operator||
name|pi
operator|->
name|ipi_vtag
expr_stmt|;
name|cfa_meta
operator||=
name|TX_BD_LONG_CFA_META_VLAN_TPID_TPID8100
expr_stmt|;
block|}
name|tbdh
operator|->
name|cfa_meta
operator|=
name|htole32
argument_list|(
name|cfa_meta
argument_list|)
expr_stmt|;
if|if
condition|(
name|pi
operator|->
name|ipi_csum_flags
operator|&
name|CSUM_TSO
condition|)
block|{
name|lflags
operator||=
name|TX_BD_LONG_LFLAGS_LSO
operator||
name|TX_BD_LONG_LFLAGS_T_IPID
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pi
operator|->
name|ipi_csum_flags
operator|&
name|CSUM_OFFLOAD
condition|)
block|{
name|lflags
operator||=
name|TX_BD_LONG_LFLAGS_TCP_UDP_CHKSUM
operator||
name|TX_BD_LONG_LFLAGS_IP_CHKSUM
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pi
operator|->
name|ipi_csum_flags
operator|&
name|CSUM_IP
condition|)
block|{
name|lflags
operator||=
name|TX_BD_LONG_LFLAGS_IP_CHKSUM
expr_stmt|;
block|}
name|tbdh
operator|->
name|lflags
operator|=
name|htole16
argument_list|(
name|lflags
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|flags_type
operator||=
name|TX_BD_SHORT_TYPE_TX_BD_SHORT
expr_stmt|;
block|}
for|for
control|(
init|;
name|seg
operator|<
name|pi
operator|->
name|ipi_nsegs
condition|;
name|seg
operator|++
control|)
block|{
name|tbd
operator|->
name|flags_type
operator|=
name|htole16
argument_list|(
name|flags_type
argument_list|)
expr_stmt|;
name|pi
operator|->
name|ipi_new_pidx
operator|=
name|RING_NEXT
argument_list|(
name|txr
argument_list|,
name|pi
operator|->
name|ipi_new_pidx
argument_list|)
expr_stmt|;
name|tbd
operator|=
operator|&
operator|(
operator|(
expr|struct
name|tx_bd_long
operator|*
operator|)
name|txr
operator|->
name|vaddr
operator|)
index|[
name|pi
operator|->
name|ipi_new_pidx
index|]
expr_stmt|;
name|tbd
operator|->
name|len
operator|=
name|htole16
argument_list|(
name|pi
operator|->
name|ipi_segs
index|[
name|seg
index|]
operator|.
name|ds_len
argument_list|)
expr_stmt|;
name|tbd
operator|->
name|addr
operator|=
name|htole64
argument_list|(
name|pi
operator|->
name|ipi_segs
index|[
name|seg
index|]
operator|.
name|ds_addr
argument_list|)
expr_stmt|;
name|flags_type
operator|=
name|TX_BD_SHORT_TYPE_TX_BD_SHORT
expr_stmt|;
block|}
name|flags_type
operator||=
name|TX_BD_SHORT_FLAGS_PACKET_END
expr_stmt|;
name|tbd
operator|->
name|flags_type
operator|=
name|htole16
argument_list|(
name|flags_type
argument_list|)
expr_stmt|;
name|pi
operator|->
name|ipi_new_pidx
operator|=
name|RING_NEXT
argument_list|(
name|txr
argument_list|,
name|pi
operator|->
name|ipi_new_pidx
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bnxt_isc_txd_flush
parameter_list|(
name|void
modifier|*
name|sc
parameter_list|,
name|uint16_t
name|txqid
parameter_list|,
name|uint32_t
name|pidx
parameter_list|)
block|{
name|struct
name|bnxt_softc
modifier|*
name|softc
init|=
operator|(
expr|struct
name|bnxt_softc
operator|*
operator|)
name|sc
decl_stmt|;
name|struct
name|bnxt_ring
modifier|*
name|tx_ring
init|=
operator|&
name|softc
operator|->
name|tx_rings
index|[
name|txqid
index|]
decl_stmt|;
comment|/* pidx is what we last set ipi_new_pidx to */
name|BNXT_TX_DB
argument_list|(
name|tx_ring
argument_list|,
name|pidx
argument_list|)
expr_stmt|;
comment|/* TODO: Cumulus+ doesn't need the double doorbell */
name|BNXT_TX_DB
argument_list|(
name|tx_ring
argument_list|,
name|pidx
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|bnxt_isc_txd_credits_update
parameter_list|(
name|void
modifier|*
name|sc
parameter_list|,
name|uint16_t
name|txqid
parameter_list|,
name|uint32_t
name|idx
parameter_list|,
name|bool
name|clear
parameter_list|)
block|{
name|struct
name|bnxt_softc
modifier|*
name|softc
init|=
operator|(
expr|struct
name|bnxt_softc
operator|*
operator|)
name|sc
decl_stmt|;
name|struct
name|bnxt_cp_ring
modifier|*
name|cpr
init|=
operator|&
name|softc
operator|->
name|tx_cp_rings
index|[
name|txqid
index|]
decl_stmt|;
name|struct
name|tx_cmpl
modifier|*
name|cmpl
init|=
operator|(
expr|struct
name|tx_cmpl
operator|*
operator|)
name|cpr
operator|->
name|ring
operator|.
name|vaddr
decl_stmt|;
name|int
name|avail
init|=
literal|0
decl_stmt|;
name|uint32_t
name|cons
init|=
name|cpr
operator|->
name|cons
decl_stmt|;
name|bool
name|v_bit
init|=
name|cpr
operator|->
name|v_bit
decl_stmt|;
name|bool
name|last_v_bit
decl_stmt|;
name|uint32_t
name|last_cons
decl_stmt|;
name|uint16_t
name|type
decl_stmt|;
name|uint16_t
name|err
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|last_cons
operator|=
name|cons
expr_stmt|;
name|last_v_bit
operator|=
name|v_bit
expr_stmt|;
name|NEXT_CP_CONS_V
argument_list|(
operator|&
name|cpr
operator|->
name|ring
argument_list|,
name|cons
argument_list|,
name|v_bit
argument_list|)
expr_stmt|;
name|CMPL_PREFETCH_NEXT
argument_list|(
name|cpr
argument_list|,
name|cons
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CMP_VALID
argument_list|(
operator|&
name|cmpl
index|[
name|cons
index|]
argument_list|,
name|v_bit
argument_list|)
condition|)
goto|goto
name|done
goto|;
name|type
operator|=
name|cmpl
index|[
name|cons
index|]
operator|.
name|flags_type
operator|&
name|TX_CMPL_TYPE_MASK
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|TX_CMPL_TYPE_TX_L2
case|:
name|err
operator|=
operator|(
name|le16toh
argument_list|(
name|cmpl
index|[
name|cons
index|]
operator|.
name|errors_v
argument_list|)
operator|&
name|TX_CMPL_ERRORS_BUFFER_ERROR_MASK
operator|)
operator|>>
name|TX_CMPL_ERRORS_BUFFER_ERROR_SFT
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|device_printf
argument_list|(
name|softc
operator|->
name|dev
argument_list|,
literal|"TX completion error %u\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
comment|/* No need to byte-swap the opaque value */
name|avail
operator|+=
name|cmpl
index|[
name|cons
index|]
operator|.
name|opaque
operator|>>
literal|24
expr_stmt|;
comment|/* 			 * If we're not clearing, iflib only cares if there's 			 * at least one buffer.  Don't scan the whole ring in 			 * this case. 			 */
if|if
condition|(
operator|!
name|clear
condition|)
goto|goto
name|done
goto|;
break|break;
default|default:
if|if
condition|(
name|type
operator|&
literal|1
condition|)
block|{
name|NEXT_CP_CONS_V
argument_list|(
operator|&
name|cpr
operator|->
name|ring
argument_list|,
name|cons
argument_list|,
name|v_bit
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CMP_VALID
argument_list|(
operator|&
name|cmpl
index|[
name|cons
index|]
argument_list|,
name|v_bit
argument_list|)
condition|)
goto|goto
name|done
goto|;
block|}
name|device_printf
argument_list|(
name|softc
operator|->
name|dev
argument_list|,
literal|"Unhandled TX completion type %u\n"
argument_list|,
name|type
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|done
label|:
if|if
condition|(
name|clear
operator|&&
name|avail
condition|)
block|{
name|cpr
operator|->
name|cons
operator|=
name|last_cons
expr_stmt|;
name|cpr
operator|->
name|v_bit
operator|=
name|last_v_bit
expr_stmt|;
name|BNXT_CP_IDX_DISABLE_DB
argument_list|(
operator|&
name|cpr
operator|->
name|ring
argument_list|,
name|cpr
operator|->
name|cons
argument_list|)
expr_stmt|;
block|}
return|return
name|avail
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bnxt_isc_rxd_refill
parameter_list|(
name|void
modifier|*
name|sc
parameter_list|,
name|uint16_t
name|rxqid
parameter_list|,
name|uint8_t
name|flid
parameter_list|,
name|uint32_t
name|pidx
parameter_list|,
name|uint64_t
modifier|*
name|paddrs
parameter_list|,
name|caddr_t
modifier|*
name|vaddrs
parameter_list|,
name|uint16_t
name|count
parameter_list|,
name|uint16_t
name|len
parameter_list|)
block|{
name|struct
name|bnxt_softc
modifier|*
name|softc
init|=
operator|(
expr|struct
name|bnxt_softc
operator|*
operator|)
name|sc
decl_stmt|;
name|struct
name|bnxt_ring
modifier|*
name|rx_ring
decl_stmt|;
name|struct
name|rx_prod_pkt_bd
modifier|*
name|rxbd
decl_stmt|;
name|uint16_t
name|type
decl_stmt|;
name|uint16_t
name|i
decl_stmt|;
if|if
condition|(
name|flid
operator|==
literal|0
condition|)
block|{
name|rx_ring
operator|=
operator|&
name|softc
operator|->
name|rx_rings
index|[
name|rxqid
index|]
expr_stmt|;
name|type
operator|=
name|RX_PROD_PKT_BD_TYPE_RX_PROD_PKT
expr_stmt|;
block|}
else|else
block|{
name|rx_ring
operator|=
operator|&
name|softc
operator|->
name|ag_rings
index|[
name|rxqid
index|]
expr_stmt|;
name|type
operator|=
name|RX_PROD_AGG_BD_TYPE_RX_PROD_AGG
expr_stmt|;
block|}
name|rxbd
operator|=
operator|(
name|void
operator|*
operator|)
name|rx_ring
operator|->
name|vaddr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|rxbd
index|[
name|pidx
index|]
operator|.
name|flags_type
operator|=
name|htole16
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|rxbd
index|[
name|pidx
index|]
operator|.
name|len
operator|=
name|htole16
argument_list|(
name|len
argument_list|)
expr_stmt|;
comment|/* No need to byte-swap the opaque value */
name|rxbd
index|[
name|pidx
index|]
operator|.
name|opaque
operator|=
operator|(
operator|(
name|rxqid
operator|&
literal|0xff
operator|)
operator|<<
literal|24
operator|)
operator||
operator|(
name|flid
operator|<<
literal|16
operator|)
operator||
name|pidx
expr_stmt|;
name|rxbd
index|[
name|pidx
index|]
operator|.
name|addr
operator|=
name|htole64
argument_list|(
name|paddrs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|pidx
operator|==
name|rx_ring
operator|->
name|ring_size
condition|)
name|pidx
operator|=
literal|0
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|bnxt_isc_rxd_flush
parameter_list|(
name|void
modifier|*
name|sc
parameter_list|,
name|uint16_t
name|rxqid
parameter_list|,
name|uint8_t
name|flid
parameter_list|,
name|uint32_t
name|pidx
parameter_list|)
block|{
name|struct
name|bnxt_softc
modifier|*
name|softc
init|=
operator|(
expr|struct
name|bnxt_softc
operator|*
operator|)
name|sc
decl_stmt|;
name|struct
name|bnxt_ring
modifier|*
name|rx_ring
decl_stmt|;
if|if
condition|(
name|flid
operator|==
literal|0
condition|)
name|rx_ring
operator|=
operator|&
name|softc
operator|->
name|rx_rings
index|[
name|rxqid
index|]
expr_stmt|;
else|else
name|rx_ring
operator|=
operator|&
name|softc
operator|->
name|ag_rings
index|[
name|rxqid
index|]
expr_stmt|;
comment|/* 	 * We *must* update the completion ring before updating the RX ring 	 * or we will overrun the completion ring and the device will wedge for 	 * RX. 	 */
if|if
condition|(
name|softc
operator|->
name|rx_cp_rings
index|[
name|rxqid
index|]
operator|.
name|cons
operator|!=
name|UINT32_MAX
condition|)
name|BNXT_CP_IDX_DISABLE_DB
argument_list|(
operator|&
name|softc
operator|->
name|rx_cp_rings
index|[
name|rxqid
index|]
operator|.
name|ring
argument_list|,
name|softc
operator|->
name|rx_cp_rings
index|[
name|rxqid
index|]
operator|.
name|cons
argument_list|)
expr_stmt|;
comment|/* We're given the last filled RX buffer here, not the next empty one */
name|BNXT_RX_DB
argument_list|(
name|rx_ring
argument_list|,
name|RING_NEXT
argument_list|(
name|rx_ring
argument_list|,
name|pidx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* TODO: Cumulus+ doesn't need the double doorbell */
name|BNXT_RX_DB
argument_list|(
name|rx_ring
argument_list|,
name|RING_NEXT
argument_list|(
name|rx_ring
argument_list|,
name|pidx
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|bnxt_isc_rxd_available
parameter_list|(
name|void
modifier|*
name|sc
parameter_list|,
name|uint16_t
name|rxqid
parameter_list|,
name|uint32_t
name|idx
parameter_list|,
name|int
name|budget
parameter_list|)
block|{
name|struct
name|bnxt_softc
modifier|*
name|softc
init|=
operator|(
expr|struct
name|bnxt_softc
operator|*
operator|)
name|sc
decl_stmt|;
name|struct
name|bnxt_cp_ring
modifier|*
name|cpr
init|=
operator|&
name|softc
operator|->
name|rx_cp_rings
index|[
name|rxqid
index|]
decl_stmt|;
name|struct
name|rx_pkt_cmpl
modifier|*
name|rcp
decl_stmt|;
name|struct
name|rx_tpa_start_cmpl
modifier|*
name|rtpa
decl_stmt|;
name|struct
name|rx_tpa_end_cmpl
modifier|*
name|rtpae
decl_stmt|;
name|struct
name|cmpl_base
modifier|*
name|cmp
init|=
operator|(
expr|struct
name|cmpl_base
operator|*
operator|)
name|cpr
operator|->
name|ring
operator|.
name|vaddr
decl_stmt|;
name|int
name|avail
init|=
literal|0
decl_stmt|;
name|uint32_t
name|cons
init|=
name|cpr
operator|->
name|cons
decl_stmt|;
name|bool
name|v_bit
init|=
name|cpr
operator|->
name|v_bit
decl_stmt|;
name|uint8_t
name|ags
decl_stmt|;
name|int
name|i
decl_stmt|;
name|uint16_t
name|type
decl_stmt|;
name|uint8_t
name|agg_id
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|NEXT_CP_CONS_V
argument_list|(
operator|&
name|cpr
operator|->
name|ring
argument_list|,
name|cons
argument_list|,
name|v_bit
argument_list|)
expr_stmt|;
name|CMPL_PREFETCH_NEXT
argument_list|(
name|cpr
argument_list|,
name|cons
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CMP_VALID
argument_list|(
operator|&
name|cmp
index|[
name|cons
index|]
argument_list|,
name|v_bit
argument_list|)
condition|)
goto|goto
name|cmpl_invalid
goto|;
name|type
operator|=
name|le16toh
argument_list|(
name|cmp
index|[
name|cons
index|]
operator|.
name|type
argument_list|)
operator|&
name|CMPL_BASE_TYPE_MASK
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|CMPL_BASE_TYPE_RX_L2
case|:
name|rcp
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|cmp
index|[
name|cons
index|]
expr_stmt|;
name|ags
operator|=
operator|(
name|rcp
operator|->
name|agg_bufs_v1
operator|&
name|RX_PKT_CMPL_AGG_BUFS_MASK
operator|)
operator|>>
name|RX_PKT_CMPL_AGG_BUFS_SFT
expr_stmt|;
name|NEXT_CP_CONS_V
argument_list|(
operator|&
name|cpr
operator|->
name|ring
argument_list|,
name|cons
argument_list|,
name|v_bit
argument_list|)
expr_stmt|;
name|CMPL_PREFETCH_NEXT
argument_list|(
name|cpr
argument_list|,
name|cons
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CMP_VALID
argument_list|(
operator|&
name|cmp
index|[
name|cons
index|]
argument_list|,
name|v_bit
argument_list|)
condition|)
goto|goto
name|cmpl_invalid
goto|;
comment|/* Now account for all the AG completions */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ags
condition|;
name|i
operator|++
control|)
block|{
name|NEXT_CP_CONS_V
argument_list|(
operator|&
name|cpr
operator|->
name|ring
argument_list|,
name|cons
argument_list|,
name|v_bit
argument_list|)
expr_stmt|;
name|CMPL_PREFETCH_NEXT
argument_list|(
name|cpr
argument_list|,
name|cons
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CMP_VALID
argument_list|(
operator|&
name|cmp
index|[
name|cons
index|]
argument_list|,
name|v_bit
argument_list|)
condition|)
goto|goto
name|cmpl_invalid
goto|;
block|}
name|avail
operator|++
expr_stmt|;
break|break;
case|case
name|CMPL_BASE_TYPE_RX_TPA_END
case|:
name|rtpae
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|cmp
index|[
name|cons
index|]
expr_stmt|;
name|ags
operator|=
operator|(
name|rtpae
operator|->
name|agg_bufs_v1
operator|&
name|RX_TPA_END_CMPL_AGG_BUFS_MASK
operator|)
operator|>>
name|RX_TPA_END_CMPL_AGG_BUFS_SFT
expr_stmt|;
name|NEXT_CP_CONS_V
argument_list|(
operator|&
name|cpr
operator|->
name|ring
argument_list|,
name|cons
argument_list|,
name|v_bit
argument_list|)
expr_stmt|;
name|CMPL_PREFETCH_NEXT
argument_list|(
name|cpr
argument_list|,
name|cons
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CMP_VALID
argument_list|(
operator|&
name|cmp
index|[
name|cons
index|]
argument_list|,
name|v_bit
argument_list|)
condition|)
goto|goto
name|cmpl_invalid
goto|;
comment|/* Now account for all the AG completions */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ags
condition|;
name|i
operator|++
control|)
block|{
name|NEXT_CP_CONS_V
argument_list|(
operator|&
name|cpr
operator|->
name|ring
argument_list|,
name|cons
argument_list|,
name|v_bit
argument_list|)
expr_stmt|;
name|CMPL_PREFETCH_NEXT
argument_list|(
name|cpr
argument_list|,
name|cons
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CMP_VALID
argument_list|(
operator|&
name|cmp
index|[
name|cons
index|]
argument_list|,
name|v_bit
argument_list|)
condition|)
goto|goto
name|cmpl_invalid
goto|;
block|}
name|avail
operator|++
expr_stmt|;
break|break;
case|case
name|CMPL_BASE_TYPE_RX_TPA_START
case|:
name|rtpa
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|cmp
index|[
name|cons
index|]
expr_stmt|;
name|agg_id
operator|=
operator|(
name|rtpa
operator|->
name|agg_id
operator|&
name|RX_TPA_START_CMPL_AGG_ID_MASK
operator|)
operator|>>
name|RX_TPA_START_CMPL_AGG_ID_SFT
expr_stmt|;
name|softc
operator|->
name|tpa_start
index|[
name|agg_id
index|]
operator|.
name|low
operator|=
operator|*
name|rtpa
expr_stmt|;
name|NEXT_CP_CONS_V
argument_list|(
operator|&
name|cpr
operator|->
name|ring
argument_list|,
name|cons
argument_list|,
name|v_bit
argument_list|)
expr_stmt|;
name|CMPL_PREFETCH_NEXT
argument_list|(
name|cpr
argument_list|,
name|cons
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CMP_VALID
argument_list|(
operator|&
name|cmp
index|[
name|cons
index|]
argument_list|,
name|v_bit
argument_list|)
condition|)
goto|goto
name|cmpl_invalid
goto|;
name|softc
operator|->
name|tpa_start
index|[
name|agg_id
index|]
operator|.
name|high
operator|=
operator|(
operator|(
expr|struct
name|rx_tpa_start_cmpl_hi
operator|*
operator|)
name|cmp
operator|)
index|[
name|cons
index|]
expr_stmt|;
break|break;
case|case
name|CMPL_BASE_TYPE_RX_AGG
case|:
break|break;
default|default:
name|device_printf
argument_list|(
name|softc
operator|->
name|dev
argument_list|,
literal|"Unhandled completion type %d on RXQ %d\n"
argument_list|,
name|type
argument_list|,
name|rxqid
argument_list|)
expr_stmt|;
comment|/* Odd completion types use two completions */
if|if
condition|(
name|type
operator|&
literal|1
condition|)
block|{
name|NEXT_CP_CONS_V
argument_list|(
operator|&
name|cpr
operator|->
name|ring
argument_list|,
name|cons
argument_list|,
name|v_bit
argument_list|)
expr_stmt|;
name|CMPL_PREFETCH_NEXT
argument_list|(
name|cpr
argument_list|,
name|cons
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CMP_VALID
argument_list|(
operator|&
name|cmp
index|[
name|cons
index|]
argument_list|,
name|v_bit
argument_list|)
condition|)
goto|goto
name|cmpl_invalid
goto|;
block|}
break|break;
block|}
if|if
condition|(
name|avail
operator|>
name|budget
condition|)
break|break;
block|}
name|cmpl_invalid
label|:
return|return
name|avail
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bnxt_set_rsstype
parameter_list|(
name|if_rxd_info_t
name|ri
parameter_list|,
name|uint8_t
name|rss_hash_type
parameter_list|)
block|{
name|uint8_t
name|rss_profile_id
decl_stmt|;
name|rss_profile_id
operator|=
name|BNXT_GET_RSS_PROFILE_ID
argument_list|(
name|rss_hash_type
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|rss_profile_id
condition|)
block|{
case|case
name|BNXT_RSS_HASH_TYPE_TCPV4
case|:
name|ri
operator|->
name|iri_rsstype
operator|=
name|M_HASHTYPE_RSS_TCP_IPV4
expr_stmt|;
break|break;
case|case
name|BNXT_RSS_HASH_TYPE_UDPV4
case|:
name|ri
operator|->
name|iri_rsstype
operator|=
name|M_HASHTYPE_RSS_UDP_IPV4
expr_stmt|;
break|break;
case|case
name|BNXT_RSS_HASH_TYPE_IPV4
case|:
name|ri
operator|->
name|iri_rsstype
operator|=
name|M_HASHTYPE_RSS_IPV4
expr_stmt|;
break|break;
case|case
name|BNXT_RSS_HASH_TYPE_TCPV6
case|:
name|ri
operator|->
name|iri_rsstype
operator|=
name|M_HASHTYPE_RSS_TCP_IPV6
expr_stmt|;
break|break;
case|case
name|BNXT_RSS_HASH_TYPE_UDPV6
case|:
name|ri
operator|->
name|iri_rsstype
operator|=
name|M_HASHTYPE_RSS_UDP_IPV6
expr_stmt|;
break|break;
case|case
name|BNXT_RSS_HASH_TYPE_IPV6
case|:
name|ri
operator|->
name|iri_rsstype
operator|=
name|M_HASHTYPE_RSS_IPV6
expr_stmt|;
break|break;
default|default:
name|ri
operator|->
name|iri_rsstype
operator|=
name|M_HASHTYPE_OPAQUE
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|bnxt_pkt_get_l2
parameter_list|(
name|struct
name|bnxt_softc
modifier|*
name|softc
parameter_list|,
name|if_rxd_info_t
name|ri
parameter_list|,
name|struct
name|bnxt_cp_ring
modifier|*
name|cpr
parameter_list|,
name|uint16_t
name|flags_type
parameter_list|)
block|{
name|struct
name|rx_pkt_cmpl
modifier|*
name|rcp
decl_stmt|;
name|struct
name|rx_pkt_cmpl_hi
modifier|*
name|rcph
decl_stmt|;
name|struct
name|rx_abuf_cmpl
modifier|*
name|acp
decl_stmt|;
name|uint32_t
name|flags2
decl_stmt|;
name|uint32_t
name|errors
decl_stmt|;
name|uint8_t
name|ags
decl_stmt|;
name|int
name|i
decl_stmt|;
name|rcp
operator|=
operator|&
operator|(
operator|(
expr|struct
name|rx_pkt_cmpl
operator|*
operator|)
name|cpr
operator|->
name|ring
operator|.
name|vaddr
operator|)
index|[
name|cpr
operator|->
name|cons
index|]
expr_stmt|;
comment|/* Extract from the first 16-byte BD */
if|if
condition|(
name|flags_type
operator|&
name|RX_PKT_CMPL_FLAGS_RSS_VALID
condition|)
block|{
name|ri
operator|->
name|iri_flowid
operator|=
name|le32toh
argument_list|(
name|rcp
operator|->
name|rss_hash
argument_list|)
expr_stmt|;
name|bnxt_set_rsstype
argument_list|(
name|ri
argument_list|,
name|rcp
operator|->
name|rss_hash_type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ri
operator|->
name|iri_rsstype
operator|=
name|M_HASHTYPE_NONE
expr_stmt|;
block|}
name|ags
operator|=
operator|(
name|rcp
operator|->
name|agg_bufs_v1
operator|&
name|RX_PKT_CMPL_AGG_BUFS_MASK
operator|)
operator|>>
name|RX_PKT_CMPL_AGG_BUFS_SFT
expr_stmt|;
name|ri
operator|->
name|iri_nfrags
operator|=
name|ags
operator|+
literal|1
expr_stmt|;
comment|/* No need to byte-swap the opaque value */
name|ri
operator|->
name|iri_frags
index|[
literal|0
index|]
operator|.
name|irf_flid
operator|=
operator|(
name|rcp
operator|->
name|opaque
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
name|ri
operator|->
name|iri_frags
index|[
literal|0
index|]
operator|.
name|irf_idx
operator|=
name|rcp
operator|->
name|opaque
operator|&
literal|0xffff
expr_stmt|;
name|ri
operator|->
name|iri_frags
index|[
literal|0
index|]
operator|.
name|irf_len
operator|=
name|le16toh
argument_list|(
name|rcp
operator|->
name|len
argument_list|)
expr_stmt|;
name|ri
operator|->
name|iri_len
operator|=
name|le16toh
argument_list|(
name|rcp
operator|->
name|len
argument_list|)
expr_stmt|;
comment|/* Now the second 16-byte BD */
name|NEXT_CP_CONS_V
argument_list|(
operator|&
name|cpr
operator|->
name|ring
argument_list|,
name|cpr
operator|->
name|cons
argument_list|,
name|cpr
operator|->
name|v_bit
argument_list|)
expr_stmt|;
name|ri
operator|->
name|iri_cidx
operator|=
name|RING_NEXT
argument_list|(
operator|&
name|cpr
operator|->
name|ring
argument_list|,
name|ri
operator|->
name|iri_cidx
argument_list|)
expr_stmt|;
name|rcph
operator|=
operator|&
operator|(
operator|(
expr|struct
name|rx_pkt_cmpl_hi
operator|*
operator|)
name|cpr
operator|->
name|ring
operator|.
name|vaddr
operator|)
index|[
name|cpr
operator|->
name|cons
index|]
expr_stmt|;
name|flags2
operator|=
name|le32toh
argument_list|(
name|rcph
operator|->
name|flags2
argument_list|)
expr_stmt|;
name|errors
operator|=
name|le16toh
argument_list|(
name|rcph
operator|->
name|errors_v2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags2
operator|&
name|RX_PKT_CMPL_FLAGS2_META_FORMAT_MASK
operator|)
operator|==
name|RX_PKT_CMPL_FLAGS2_META_FORMAT_VLAN
condition|)
block|{
name|ri
operator|->
name|iri_flags
operator||=
name|M_VLANTAG
expr_stmt|;
comment|/* TODO: Should this be the entire 16-bits? */
name|ri
operator|->
name|iri_vtag
operator|=
name|le32toh
argument_list|(
name|rcph
operator|->
name|metadata
argument_list|)
operator|&
operator|(
name|RX_PKT_CMPL_METADATA_VID_MASK
operator||
name|RX_PKT_CMPL_METADATA_DE
operator||
name|RX_PKT_CMPL_METADATA_PRI_MASK
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|flags2
operator|&
name|RX_PKT_CMPL_FLAGS2_IP_CS_CALC
condition|)
block|{
name|ri
operator|->
name|iri_csum_flags
operator||=
name|CSUM_IP_CHECKED
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|errors
operator|&
name|RX_PKT_CMPL_ERRORS_IP_CS_ERROR
operator|)
condition|)
name|ri
operator|->
name|iri_csum_flags
operator||=
name|CSUM_IP_VALID
expr_stmt|;
block|}
if|if
condition|(
name|flags2
operator|&
name|RX_PKT_CMPL_FLAGS2_L4_CS_CALC
condition|)
block|{
name|ri
operator|->
name|iri_csum_flags
operator||=
name|CSUM_L4_CALC
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|errors
operator|&
name|RX_PKT_CMPL_ERRORS_L4_CS_ERROR
operator|)
condition|)
block|{
name|ri
operator|->
name|iri_csum_flags
operator||=
name|CSUM_L4_VALID
expr_stmt|;
name|ri
operator|->
name|iri_csum_data
operator|=
literal|0xffff
expr_stmt|;
block|}
block|}
comment|/* And finally the ag ring stuff. */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|ri
operator|->
name|iri_nfrags
condition|;
name|i
operator|++
control|)
block|{
name|NEXT_CP_CONS_V
argument_list|(
operator|&
name|cpr
operator|->
name|ring
argument_list|,
name|cpr
operator|->
name|cons
argument_list|,
name|cpr
operator|->
name|v_bit
argument_list|)
expr_stmt|;
name|ri
operator|->
name|iri_cidx
operator|=
name|RING_NEXT
argument_list|(
operator|&
name|cpr
operator|->
name|ring
argument_list|,
name|ri
operator|->
name|iri_cidx
argument_list|)
expr_stmt|;
name|acp
operator|=
operator|&
operator|(
operator|(
expr|struct
name|rx_abuf_cmpl
operator|*
operator|)
name|cpr
operator|->
name|ring
operator|.
name|vaddr
operator|)
index|[
name|cpr
operator|->
name|cons
index|]
expr_stmt|;
comment|/* No need to byte-swap the opaque value */
name|ri
operator|->
name|iri_frags
index|[
name|i
index|]
operator|.
name|irf_flid
operator|=
operator|(
name|acp
operator|->
name|opaque
operator|>>
literal|16
operator|&
literal|0xff
operator|)
expr_stmt|;
name|ri
operator|->
name|iri_frags
index|[
name|i
index|]
operator|.
name|irf_idx
operator|=
name|acp
operator|->
name|opaque
operator|&
literal|0xffff
expr_stmt|;
name|ri
operator|->
name|iri_frags
index|[
name|i
index|]
operator|.
name|irf_len
operator|=
name|le16toh
argument_list|(
name|acp
operator|->
name|len
argument_list|)
expr_stmt|;
name|ri
operator|->
name|iri_len
operator|+=
name|le16toh
argument_list|(
name|acp
operator|->
name|len
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bnxt_pkt_get_tpa
parameter_list|(
name|struct
name|bnxt_softc
modifier|*
name|softc
parameter_list|,
name|if_rxd_info_t
name|ri
parameter_list|,
name|struct
name|bnxt_cp_ring
modifier|*
name|cpr
parameter_list|,
name|uint16_t
name|flags_type
parameter_list|)
block|{
name|struct
name|rx_tpa_end_cmpl
modifier|*
name|agend
init|=
operator|&
operator|(
operator|(
expr|struct
name|rx_tpa_end_cmpl
operator|*
operator|)
name|cpr
operator|->
name|ring
operator|.
name|vaddr
operator|)
index|[
name|cpr
operator|->
name|cons
index|]
decl_stmt|;
name|struct
name|rx_tpa_end_cmpl_hi
modifier|*
name|agendh
decl_stmt|;
name|struct
name|rx_abuf_cmpl
modifier|*
name|acp
decl_stmt|;
name|struct
name|bnxt_full_tpa_start
modifier|*
name|tpas
decl_stmt|;
name|uint32_t
name|flags2
decl_stmt|;
name|uint8_t
name|ags
decl_stmt|;
name|uint8_t
name|agg_id
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Get the agg_id */
name|agg_id
operator|=
operator|(
name|agend
operator|->
name|agg_id
operator|&
name|RX_TPA_END_CMPL_AGG_ID_MASK
operator|)
operator|>>
name|RX_TPA_END_CMPL_AGG_ID_SFT
expr_stmt|;
name|tpas
operator|=
operator|&
name|softc
operator|->
name|tpa_start
index|[
name|agg_id
index|]
expr_stmt|;
comment|/* Extract from the first 16-byte BD */
if|if
condition|(
name|le16toh
argument_list|(
name|tpas
operator|->
name|low
operator|.
name|flags_type
argument_list|)
operator|&
name|RX_TPA_START_CMPL_FLAGS_RSS_VALID
condition|)
block|{
name|ri
operator|->
name|iri_flowid
operator|=
name|le32toh
argument_list|(
name|tpas
operator|->
name|low
operator|.
name|rss_hash
argument_list|)
expr_stmt|;
name|bnxt_set_rsstype
argument_list|(
name|ri
argument_list|,
name|tpas
operator|->
name|low
operator|.
name|rss_hash_type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ri
operator|->
name|iri_rsstype
operator|=
name|M_HASHTYPE_NONE
expr_stmt|;
block|}
name|ags
operator|=
operator|(
name|agend
operator|->
name|agg_bufs_v1
operator|&
name|RX_TPA_END_CMPL_AGG_BUFS_MASK
operator|)
operator|>>
name|RX_TPA_END_CMPL_AGG_BUFS_SFT
expr_stmt|;
name|ri
operator|->
name|iri_nfrags
operator|=
name|ags
operator|+
literal|1
expr_stmt|;
comment|/* No need to byte-swap the opaque value */
name|ri
operator|->
name|iri_frags
index|[
literal|0
index|]
operator|.
name|irf_flid
operator|=
operator|(
name|tpas
operator|->
name|low
operator|.
name|opaque
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
name|ri
operator|->
name|iri_frags
index|[
literal|0
index|]
operator|.
name|irf_idx
operator|=
name|tpas
operator|->
name|low
operator|.
name|opaque
operator|&
literal|0xffff
expr_stmt|;
name|ri
operator|->
name|iri_frags
index|[
literal|0
index|]
operator|.
name|irf_len
operator|=
name|le16toh
argument_list|(
name|tpas
operator|->
name|low
operator|.
name|len
argument_list|)
expr_stmt|;
name|ri
operator|->
name|iri_len
operator|=
name|le16toh
argument_list|(
name|tpas
operator|->
name|low
operator|.
name|len
argument_list|)
expr_stmt|;
comment|/* Now the second 16-byte BD */
name|NEXT_CP_CONS_V
argument_list|(
operator|&
name|cpr
operator|->
name|ring
argument_list|,
name|cpr
operator|->
name|cons
argument_list|,
name|cpr
operator|->
name|v_bit
argument_list|)
expr_stmt|;
name|ri
operator|->
name|iri_cidx
operator|=
name|RING_NEXT
argument_list|(
operator|&
name|cpr
operator|->
name|ring
argument_list|,
name|ri
operator|->
name|iri_cidx
argument_list|)
expr_stmt|;
name|agendh
operator|=
operator|&
operator|(
operator|(
expr|struct
name|rx_tpa_end_cmpl_hi
operator|*
operator|)
name|cpr
operator|->
name|ring
operator|.
name|vaddr
operator|)
index|[
name|cpr
operator|->
name|cons
index|]
expr_stmt|;
name|flags2
operator|=
name|le32toh
argument_list|(
name|tpas
operator|->
name|high
operator|.
name|flags2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags2
operator|&
name|RX_TPA_START_CMPL_FLAGS2_META_FORMAT_MASK
operator|)
operator|==
name|RX_TPA_START_CMPL_FLAGS2_META_FORMAT_VLAN
condition|)
block|{
name|ri
operator|->
name|iri_flags
operator||=
name|M_VLANTAG
expr_stmt|;
comment|/* TODO: Should this be the entire 16-bits? */
name|ri
operator|->
name|iri_vtag
operator|=
name|le32toh
argument_list|(
name|tpas
operator|->
name|high
operator|.
name|metadata
argument_list|)
operator|&
operator|(
name|RX_TPA_START_CMPL_METADATA_VID_MASK
operator||
name|RX_TPA_START_CMPL_METADATA_DE
operator||
name|RX_TPA_START_CMPL_METADATA_PRI_MASK
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|flags2
operator|&
name|RX_TPA_START_CMPL_FLAGS2_IP_CS_CALC
condition|)
block|{
name|ri
operator|->
name|iri_csum_flags
operator||=
name|CSUM_IP_CHECKED
expr_stmt|;
name|ri
operator|->
name|iri_csum_flags
operator||=
name|CSUM_IP_VALID
expr_stmt|;
block|}
if|if
condition|(
name|flags2
operator|&
name|RX_TPA_START_CMPL_FLAGS2_L4_CS_CALC
condition|)
block|{
name|ri
operator|->
name|iri_csum_flags
operator||=
name|CSUM_L4_CALC
expr_stmt|;
name|ri
operator|->
name|iri_csum_flags
operator||=
name|CSUM_L4_VALID
expr_stmt|;
name|ri
operator|->
name|iri_csum_data
operator|=
literal|0xffff
expr_stmt|;
block|}
comment|/* Now the ag ring stuff. */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|ri
operator|->
name|iri_nfrags
condition|;
name|i
operator|++
control|)
block|{
name|NEXT_CP_CONS_V
argument_list|(
operator|&
name|cpr
operator|->
name|ring
argument_list|,
name|cpr
operator|->
name|cons
argument_list|,
name|cpr
operator|->
name|v_bit
argument_list|)
expr_stmt|;
name|ri
operator|->
name|iri_cidx
operator|=
name|RING_NEXT
argument_list|(
operator|&
name|cpr
operator|->
name|ring
argument_list|,
name|ri
operator|->
name|iri_cidx
argument_list|)
expr_stmt|;
name|acp
operator|=
operator|&
operator|(
operator|(
expr|struct
name|rx_abuf_cmpl
operator|*
operator|)
name|cpr
operator|->
name|ring
operator|.
name|vaddr
operator|)
index|[
name|cpr
operator|->
name|cons
index|]
expr_stmt|;
comment|/* No need to byte-swap the opaque value */
name|ri
operator|->
name|iri_frags
index|[
name|i
index|]
operator|.
name|irf_flid
operator|=
operator|(
name|acp
operator|->
name|opaque
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
name|ri
operator|->
name|iri_frags
index|[
name|i
index|]
operator|.
name|irf_idx
operator|=
name|acp
operator|->
name|opaque
operator|&
literal|0xffff
expr_stmt|;
name|ri
operator|->
name|iri_frags
index|[
name|i
index|]
operator|.
name|irf_len
operator|=
name|le16toh
argument_list|(
name|acp
operator|->
name|len
argument_list|)
expr_stmt|;
name|ri
operator|->
name|iri_len
operator|+=
name|le16toh
argument_list|(
name|acp
operator|->
name|len
argument_list|)
expr_stmt|;
block|}
comment|/* And finally, the empty BD at the end... */
name|ri
operator|->
name|iri_nfrags
operator|++
expr_stmt|;
comment|/* No need to byte-swap the opaque value */
name|ri
operator|->
name|iri_frags
index|[
name|i
index|]
operator|.
name|irf_flid
operator|=
operator|(
name|agend
operator|->
name|opaque
operator|>>
literal|16
operator|)
operator|%
literal|0xff
expr_stmt|;
name|ri
operator|->
name|iri_frags
index|[
name|i
index|]
operator|.
name|irf_idx
operator|=
name|agend
operator|->
name|opaque
operator|&
literal|0xffff
expr_stmt|;
name|ri
operator|->
name|iri_frags
index|[
name|i
index|]
operator|.
name|irf_len
operator|=
name|le16toh
argument_list|(
name|agend
operator|->
name|len
argument_list|)
expr_stmt|;
name|ri
operator|->
name|iri_len
operator|+=
name|le16toh
argument_list|(
name|agend
operator|->
name|len
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* If we return anything but zero, iflib will assert... */
end_comment

begin_function
specifier|static
name|int
name|bnxt_isc_rxd_pkt_get
parameter_list|(
name|void
modifier|*
name|sc
parameter_list|,
name|if_rxd_info_t
name|ri
parameter_list|)
block|{
name|struct
name|bnxt_softc
modifier|*
name|softc
init|=
operator|(
expr|struct
name|bnxt_softc
operator|*
operator|)
name|sc
decl_stmt|;
name|struct
name|bnxt_cp_ring
modifier|*
name|cpr
init|=
operator|&
name|softc
operator|->
name|rx_cp_rings
index|[
name|ri
operator|->
name|iri_qsidx
index|]
decl_stmt|;
name|struct
name|cmpl_base
modifier|*
name|cmp
decl_stmt|;
name|uint16_t
name|flags_type
decl_stmt|;
name|uint16_t
name|type
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|NEXT_CP_CONS_V
argument_list|(
operator|&
name|cpr
operator|->
name|ring
argument_list|,
name|cpr
operator|->
name|cons
argument_list|,
name|cpr
operator|->
name|v_bit
argument_list|)
expr_stmt|;
name|ri
operator|->
name|iri_cidx
operator|=
name|RING_NEXT
argument_list|(
operator|&
name|cpr
operator|->
name|ring
argument_list|,
name|ri
operator|->
name|iri_cidx
argument_list|)
expr_stmt|;
name|CMPL_PREFETCH_NEXT
argument_list|(
name|cpr
argument_list|,
name|cpr
operator|->
name|cons
argument_list|)
expr_stmt|;
name|cmp
operator|=
operator|&
operator|(
operator|(
expr|struct
name|cmpl_base
operator|*
operator|)
name|cpr
operator|->
name|ring
operator|.
name|vaddr
operator|)
index|[
name|cpr
operator|->
name|cons
index|]
expr_stmt|;
name|flags_type
operator|=
name|le16toh
argument_list|(
name|cmp
operator|->
name|type
argument_list|)
expr_stmt|;
name|type
operator|=
name|flags_type
operator|&
name|CMPL_BASE_TYPE_MASK
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|CMPL_BASE_TYPE_RX_L2
case|:
return|return
name|bnxt_pkt_get_l2
argument_list|(
name|softc
argument_list|,
name|ri
argument_list|,
name|cpr
argument_list|,
name|flags_type
argument_list|)
return|;
case|case
name|CMPL_BASE_TYPE_RX_TPA_END
case|:
return|return
name|bnxt_pkt_get_tpa
argument_list|(
name|softc
argument_list|,
name|ri
argument_list|,
name|cpr
argument_list|,
name|flags_type
argument_list|)
return|;
case|case
name|CMPL_BASE_TYPE_RX_TPA_START
case|:
name|NEXT_CP_CONS_V
argument_list|(
operator|&
name|cpr
operator|->
name|ring
argument_list|,
name|cpr
operator|->
name|cons
argument_list|,
name|cpr
operator|->
name|v_bit
argument_list|)
expr_stmt|;
name|ri
operator|->
name|iri_cidx
operator|=
name|RING_NEXT
argument_list|(
operator|&
name|cpr
operator|->
name|ring
argument_list|,
name|ri
operator|->
name|iri_cidx
argument_list|)
expr_stmt|;
name|CMPL_PREFETCH_NEXT
argument_list|(
name|cpr
argument_list|,
name|cpr
operator|->
name|cons
argument_list|)
expr_stmt|;
break|break;
default|default:
name|device_printf
argument_list|(
name|softc
operator|->
name|dev
argument_list|,
literal|"Unhandled completion type %d on RXQ %d get\n"
argument_list|,
name|type
argument_list|,
name|ri
operator|->
name|iri_qsidx
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|&
literal|1
condition|)
block|{
name|NEXT_CP_CONS_V
argument_list|(
operator|&
name|cpr
operator|->
name|ring
argument_list|,
name|cpr
operator|->
name|cons
argument_list|,
name|cpr
operator|->
name|v_bit
argument_list|)
expr_stmt|;
name|ri
operator|->
name|iri_cidx
operator|=
name|RING_NEXT
argument_list|(
operator|&
name|cpr
operator|->
name|ring
argument_list|,
name|ri
operator|->
name|iri_cidx
argument_list|)
expr_stmt|;
name|CMPL_PREFETCH_NEXT
argument_list|(
name|cpr
argument_list|,
name|cpr
operator|->
name|cons
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bnxt_intr
parameter_list|(
name|void
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|bnxt_softc
modifier|*
name|softc
init|=
operator|(
expr|struct
name|bnxt_softc
operator|*
operator|)
name|sc
decl_stmt|;
name|device_printf
argument_list|(
name|softc
operator|->
name|dev
argument_list|,
literal|"STUB: %s @ %s:%d\n"
argument_list|,
name|__func__
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
return|return
name|ENOSYS
return|;
block|}
end_function

end_unit

