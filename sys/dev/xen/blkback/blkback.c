begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2006, Cisco Systems, Inc.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without   * modification, are permitted provided that the following conditions   * are met:  *  * 1. Redistributions of source code must retain the above copyright   *    notice, this list of conditions and the following disclaimer.   * 2. Redistributions in binary form must reproduce the above copyright   *    notice, this list of conditions and the following disclaimer in the   *    documentation and/or other materials provided with the distribution.   * 3. Neither the name of Cisco Systems, Inc. nor the names of its contributors   *    may be used to endorse or promote products derived from this software   *    without specific prior written permission.   *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"   * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE   * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE   * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR   * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF   * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS   * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN   * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)   * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE   * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<sys/namei.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/filedesc.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/disk.h>
end_include

begin_include
include|#
directive|include
file|<sys/bio.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<geom/geom.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<machine/xen-os.h>
end_include

begin_include
include|#
directive|include
file|<machine/hypervisor.h>
end_include

begin_include
include|#
directive|include
file|<machine/hypervisor-ifs.h>
end_include

begin_include
include|#
directive|include
file|<machine/xen_intr.h>
end_include

begin_include
include|#
directive|include
file|<machine/evtchn.h>
end_include

begin_include
include|#
directive|include
file|<machine/xenbus.h>
end_include

begin_include
include|#
directive|include
file|<machine/gnttab.h>
end_include

begin_include
include|#
directive|include
file|<machine/xen-public/memory.h>
end_include

begin_include
include|#
directive|include
file|<dev/xen/xenbus/xenbus_comms.h>
end_include

begin_if
if|#
directive|if
name|XEN_BLKBACK_DEBUG
end_if

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
define|\
value|printf("blkback (%s:%d): " fmt, __FUNCTION__, __LINE__, ##args)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
value|((void)0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|WPRINTF
parameter_list|(
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
define|\
value|printf("blkback (%s:%d): " fmt, __FUNCTION__, __LINE__, ##args)
end_define

begin_define
define|#
directive|define
name|BLKBACK_INVALID_HANDLE
value|(~0)
end_define

begin_struct
struct|struct
name|ring_ref
block|{
name|vm_offset_t
name|va
decl_stmt|;
name|grant_handle_t
name|handle
decl_stmt|;
name|uint64_t
name|bus_addr
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
struct|struct
name|blkback_info
block|{
comment|/* Schedule lists */
name|STAILQ_ENTRY
argument_list|(
argument|blkback_info
argument_list|)
name|next_req
expr_stmt|;
name|int
name|on_req_sched_list
decl_stmt|;
name|struct
name|xenbus_device
modifier|*
name|xdev
decl_stmt|;
name|XenbusState
name|frontend_state
decl_stmt|;
name|domid_t
name|domid
decl_stmt|;
name|int
name|state
decl_stmt|;
name|int
name|ring_connected
decl_stmt|;
name|struct
name|ring_ref
name|rr
decl_stmt|;
name|blkif_back_ring_t
name|ring
decl_stmt|;
name|evtchn_port_t
name|evtchn
decl_stmt|;
name|int
name|irq
decl_stmt|;
name|void
modifier|*
name|irq_cookie
decl_stmt|;
name|int
name|ref_cnt
decl_stmt|;
name|int
name|handle
decl_stmt|;
name|char
modifier|*
name|mode
decl_stmt|;
name|char
modifier|*
name|type
decl_stmt|;
name|char
modifier|*
name|dev_name
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vn
decl_stmt|;
name|struct
name|cdev
modifier|*
name|cdev
decl_stmt|;
name|struct
name|cdevsw
modifier|*
name|csw
decl_stmt|;
name|u_int
name|sector_size
decl_stmt|;
name|int
name|sector_size_shift
decl_stmt|;
name|off_t
name|media_size
decl_stmt|;
name|u_int
name|media_num_sectors
decl_stmt|;
name|int
name|major
decl_stmt|;
name|int
name|minor
decl_stmt|;
name|int
name|read_only
decl_stmt|;
name|struct
name|mtx
name|blk_ring_lock
decl_stmt|;
name|device_t
name|ndev
decl_stmt|;
comment|/* Stats */
name|int
name|st_rd_req
decl_stmt|;
name|int
name|st_wr_req
decl_stmt|;
name|int
name|st_oo_req
decl_stmt|;
name|int
name|st_err_req
decl_stmt|;
block|}
name|blkif_t
typedef|;
end_typedef

begin_comment
comment|/*  * These are rather arbitrary. They are fairly large because adjacent requests  * pulled from a communication ring are quite likely to end up being part of  * the same scatter/gather request at the disc.  *   * ** TRY INCREASING 'blkif_reqs' IF WRITE SPEEDS SEEM TOO LOW **  *   * This will increase the chances of being able to write whole tracks.  * 64 should be enough to keep us competitive with Linux.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|blkif_reqs
init|=
literal|64
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"xen.vbd.blkif_reqs"
argument_list|,
operator|&
name|blkif_reqs
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|mmap_pages
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Each outstanding request that we've passed to the lower device layers has a   * 'pending_req' allocated to it. Each buffer_head that completes decrements   * the pendcnt towards zero. When it hits zero, the specified domain has a   * response queued for it, with the saved 'id' passed back.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|pending_req
block|{
name|blkif_t
modifier|*
name|blkif
decl_stmt|;
name|uint64_t
name|id
decl_stmt|;
name|int
name|nr_pages
decl_stmt|;
name|int
name|pendcnt
decl_stmt|;
name|unsigned
name|short
name|operation
decl_stmt|;
name|int
name|status
decl_stmt|;
name|STAILQ_ENTRY
argument_list|(
argument|pending_req
argument_list|)
name|free_list
expr_stmt|;
block|}
name|pending_req_t
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|pending_req_t
modifier|*
name|pending_reqs
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|STAILQ_HEAD
argument_list|(
argument|pending_reqs_list
argument_list|,
argument|pending_req
argument_list|)
name|pending_free
operator|=
name|STAILQ_HEAD_INITIALIZER
argument_list|(
name|pending_free
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|pending_free_lock
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|STAILQ_HEAD
argument_list|(
argument|blkback_req_sched_list
argument_list|,
argument|blkback_info
argument_list|)
name|req_sched_list
operator|=
name|STAILQ_HEAD_INITIALIZER
argument_list|(
name|req_sched_list
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|req_sched_list_lock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|mmap_vstart
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
modifier|*
name|pending_vaddrs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|grant_handle_t
modifier|*
name|pending_grant_handles
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|task
name|blk_req_task
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Protos */
end_comment

begin_function_decl
specifier|static
name|void
name|disconnect_ring
parameter_list|(
name|blkif_t
modifier|*
name|blkif
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vbd_add_dev
parameter_list|(
name|struct
name|xenbus_device
modifier|*
name|xdev
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
specifier|inline
name|int
name|vaddr_pagenr
parameter_list|(
name|pending_req_t
modifier|*
name|req
parameter_list|,
name|int
name|seg
parameter_list|)
block|{
return|return
operator|(
name|req
operator|-
name|pending_reqs
operator|)
operator|*
name|BLKIF_MAX_SEGMENTS_PER_REQUEST
operator|+
name|seg
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|unsigned
name|long
name|vaddr
parameter_list|(
name|pending_req_t
modifier|*
name|req
parameter_list|,
name|int
name|seg
parameter_list|)
block|{
return|return
name|pending_vaddrs
index|[
name|vaddr_pagenr
argument_list|(
name|req
argument_list|,
name|seg
argument_list|)
index|]
return|;
block|}
end_function

begin_define
define|#
directive|define
name|pending_handle
parameter_list|(
name|_req
parameter_list|,
name|_seg
parameter_list|)
define|\
value|(pending_grant_handles[vaddr_pagenr(_req, _seg)])
end_define

begin_function
specifier|static
name|unsigned
name|long
name|alloc_empty_page_range
parameter_list|(
name|unsigned
name|long
name|nr_pages
parameter_list|)
block|{
name|void
modifier|*
name|pages
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|,
name|j
init|=
literal|0
decl_stmt|;
name|multicall_entry_t
name|mcl
index|[
literal|17
index|]
decl_stmt|;
name|unsigned
name|long
name|mfn_list
index|[
literal|16
index|]
decl_stmt|;
name|struct
name|xen_memory_reservation
name|reservation
init|=
block|{
operator|.
name|extent_start
operator|=
name|mfn_list
block|,
operator|.
name|nr_extents
operator|=
literal|0
block|,
operator|.
name|address_bits
operator|=
literal|0
block|,
operator|.
name|extent_order
operator|=
literal|0
block|,
operator|.
name|domid
operator|=
name|DOMID_SELF
block|}
decl_stmt|;
name|pages
operator|=
name|malloc
argument_list|(
name|nr_pages
operator|*
name|PAGE_SIZE
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|pages
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|memset
argument_list|(
name|mcl
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|mcl
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|nr_pages
condition|)
block|{
name|unsigned
name|long
name|va
init|=
operator|(
name|unsigned
name|long
operator|)
name|pages
operator|+
operator|(
name|i
operator|++
operator|*
name|PAGE_SIZE
operator|)
decl_stmt|;
name|mcl
index|[
name|j
index|]
operator|.
name|op
operator|=
name|__HYPERVISOR_update_va_mapping
expr_stmt|;
name|mcl
index|[
name|j
index|]
operator|.
name|args
index|[
literal|0
index|]
operator|=
name|va
expr_stmt|;
name|mfn_list
index|[
name|j
operator|++
index|]
operator|=
name|vtomach
argument_list|(
name|va
argument_list|)
operator|>>
name|PAGE_SHIFT
expr_stmt|;
name|xen_phys_machine
index|[
operator|(
name|vtophys
argument_list|(
name|va
argument_list|)
operator|>>
name|PAGE_SHIFT
operator|)
index|]
operator|=
name|INVALID_P2M_ENTRY
expr_stmt|;
if|if
condition|(
name|j
operator|==
literal|16
operator|||
name|i
operator|==
name|nr_pages
condition|)
block|{
name|mcl
index|[
name|j
operator|-
literal|1
index|]
operator|.
name|args
index|[
name|MULTI_UVMFLAGS_INDEX
index|]
operator|=
name|UVMF_TLB_FLUSH
operator||
name|UVMF_LOCAL
expr_stmt|;
name|reservation
operator|.
name|nr_extents
operator|=
name|j
expr_stmt|;
name|mcl
index|[
name|j
index|]
operator|.
name|op
operator|=
name|__HYPERVISOR_memory_op
expr_stmt|;
name|mcl
index|[
name|j
index|]
operator|.
name|args
index|[
literal|0
index|]
operator|=
name|XENMEM_decrease_reservation
expr_stmt|;
name|mcl
index|[
name|j
index|]
operator|.
name|args
index|[
literal|1
index|]
operator|=
operator|(
name|unsigned
name|long
operator|)
operator|&
name|reservation
expr_stmt|;
operator|(
name|void
operator|)
name|HYPERVISOR_multicall
argument_list|(
name|mcl
argument_list|,
name|j
operator|+
literal|1
argument_list|)
expr_stmt|;
name|mcl
index|[
name|j
operator|-
literal|1
index|]
operator|.
name|args
index|[
name|MULTI_UVMFLAGS_INDEX
index|]
operator|=
literal|0
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
operator|(
name|unsigned
name|long
operator|)
name|pages
return|;
block|}
end_function

begin_function
specifier|static
name|pending_req_t
modifier|*
name|alloc_req
parameter_list|(
name|void
parameter_list|)
block|{
name|pending_req_t
modifier|*
name|req
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|pending_free_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|req
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|pending_free
argument_list|)
operator|)
condition|)
block|{
name|STAILQ_REMOVE
argument_list|(
operator|&
name|pending_free
argument_list|,
name|req
argument_list|,
name|pending_req
argument_list|,
name|free_list
argument_list|)
expr_stmt|;
name|STAILQ_NEXT
argument_list|(
name|req
argument_list|,
name|free_list
argument_list|)
operator|=
name|NULL
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|pending_free_lock
argument_list|)
expr_stmt|;
return|return
name|req
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_req
parameter_list|(
name|pending_req_t
modifier|*
name|req
parameter_list|)
block|{
name|int
name|was_empty
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|pending_free_lock
argument_list|)
expr_stmt|;
name|was_empty
operator|=
name|STAILQ_EMPTY
argument_list|(
operator|&
name|pending_free
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|pending_free
argument_list|,
name|req
argument_list|,
name|free_list
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|pending_free_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|was_empty
condition|)
name|taskqueue_enqueue
argument_list|(
name|taskqueue_swi
argument_list|,
operator|&
name|blk_req_task
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fast_flush_area
parameter_list|(
name|pending_req_t
modifier|*
name|req
parameter_list|)
block|{
name|struct
name|gnttab_unmap_grant_ref
name|unmap
index|[
name|BLKIF_MAX_SEGMENTS_PER_REQUEST
index|]
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|invcount
init|=
literal|0
decl_stmt|;
name|grant_handle_t
name|handle
decl_stmt|;
name|int
name|ret
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|req
operator|->
name|nr_pages
condition|;
name|i
operator|++
control|)
block|{
name|handle
operator|=
name|pending_handle
argument_list|(
name|req
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|handle
operator|==
name|BLKBACK_INVALID_HANDLE
condition|)
continue|continue;
name|unmap
index|[
name|invcount
index|]
operator|.
name|host_addr
operator|=
name|vaddr
argument_list|(
name|req
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|unmap
index|[
name|invcount
index|]
operator|.
name|dev_bus_addr
operator|=
literal|0
expr_stmt|;
name|unmap
index|[
name|invcount
index|]
operator|.
name|handle
operator|=
name|handle
expr_stmt|;
name|pending_handle
argument_list|(
name|req
argument_list|,
name|i
argument_list|)
operator|=
name|BLKBACK_INVALID_HANDLE
expr_stmt|;
name|invcount
operator|++
expr_stmt|;
block|}
name|ret
operator|=
name|HYPERVISOR_grant_table_op
argument_list|(
name|GNTTABOP_unmap_grant_ref
argument_list|,
name|unmap
argument_list|,
name|invcount
argument_list|)
expr_stmt|;
name|PANIC_IF
argument_list|(
name|ret
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|blkif_get
parameter_list|(
name|blkif_t
modifier|*
name|blkif
parameter_list|)
block|{
name|atomic_add_int
argument_list|(
operator|&
name|blkif
operator|->
name|ref_cnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|blkif_put
parameter_list|(
name|blkif_t
modifier|*
name|blkif
parameter_list|)
block|{
if|if
condition|(
name|atomic_fetchadd_int
argument_list|(
operator|&
name|blkif
operator|->
name|ref_cnt
argument_list|,
operator|-
literal|1
argument_list|)
operator|==
literal|1
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"Removing %x\n"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|blkif
argument_list|)
expr_stmt|;
name|disconnect_ring
argument_list|(
name|blkif
argument_list|)
expr_stmt|;
if|if
condition|(
name|blkif
operator|->
name|mode
condition|)
name|free
argument_list|(
name|blkif
operator|->
name|mode
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|blkif
operator|->
name|type
condition|)
name|free
argument_list|(
name|blkif
operator|->
name|type
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|blkif
operator|->
name|dev_name
condition|)
name|free
argument_list|(
name|blkif
operator|->
name|dev_name
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|blkif
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|blkif_create
parameter_list|(
name|struct
name|xenbus_device
modifier|*
name|xdev
parameter_list|,
name|long
name|handle
parameter_list|,
name|char
modifier|*
name|mode
parameter_list|,
name|char
modifier|*
name|type
parameter_list|,
name|char
modifier|*
name|params
parameter_list|)
block|{
name|blkif_t
modifier|*
name|blkif
decl_stmt|;
name|blkif
operator|=
operator|(
name|blkif_t
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|blkif
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|blkif
condition|)
return|return
name|ENOMEM
return|;
name|DPRINTF
argument_list|(
literal|"Created %x\n"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|blkif
argument_list|)
expr_stmt|;
name|blkif
operator|->
name|ref_cnt
operator|=
literal|1
expr_stmt|;
name|blkif
operator|->
name|domid
operator|=
name|xdev
operator|->
name|otherend_id
expr_stmt|;
name|blkif
operator|->
name|handle
operator|=
name|handle
expr_stmt|;
name|blkif
operator|->
name|mode
operator|=
name|mode
expr_stmt|;
name|blkif
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|blkif
operator|->
name|dev_name
operator|=
name|params
expr_stmt|;
name|blkif
operator|->
name|xdev
operator|=
name|xdev
expr_stmt|;
name|xdev
operator|->
name|data
operator|=
name|blkif
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|blkif
operator|->
name|blk_ring_lock
argument_list|,
literal|"blk_ring_ock"
argument_list|,
literal|"blkback ring lock"
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|mode
argument_list|,
literal|"w"
argument_list|)
condition|)
name|blkif
operator|->
name|read_only
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|add_to_req_schedule_list_tail
parameter_list|(
name|blkif_t
modifier|*
name|blkif
parameter_list|)
block|{
if|if
condition|(
operator|!
name|blkif
operator|->
name|on_req_sched_list
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|req_sched_list_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|blkif
operator|->
name|on_req_sched_list
operator|&&
operator|(
name|blkif
operator|->
name|state
operator|==
name|XenbusStateConnected
operator|)
condition|)
block|{
name|blkif_get
argument_list|(
name|blkif
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|req_sched_list
argument_list|,
name|blkif
argument_list|,
name|next_req
argument_list|)
expr_stmt|;
name|blkif
operator|->
name|on_req_sched_list
operator|=
literal|1
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|taskqueue_swi
argument_list|,
operator|&
name|blk_req_task
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|req_sched_list_lock
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This routine does not call blkif_get(), does not schedule the blk_req_task to run,    and assumes that the state is connected */
end_comment

begin_function
specifier|static
name|void
name|add_to_req_schedule_list_tail2
parameter_list|(
name|blkif_t
modifier|*
name|blkif
parameter_list|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|req_sched_list_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|blkif
operator|->
name|on_req_sched_list
condition|)
block|{
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|req_sched_list
argument_list|,
name|blkif
argument_list|,
name|next_req
argument_list|)
expr_stmt|;
name|blkif
operator|->
name|on_req_sched_list
operator|=
literal|1
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|req_sched_list_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Removes blkif from front of list and does not call blkif_put() (caller must) */
end_comment

begin_function
specifier|static
name|blkif_t
modifier|*
name|remove_from_req_schedule_list
parameter_list|(
name|void
parameter_list|)
block|{
name|blkif_t
modifier|*
name|blkif
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|req_sched_list_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|blkif
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|req_sched_list
argument_list|)
operator|)
condition|)
block|{
name|STAILQ_REMOVE
argument_list|(
operator|&
name|req_sched_list
argument_list|,
name|blkif
argument_list|,
name|blkback_info
argument_list|,
name|next_req
argument_list|)
expr_stmt|;
name|STAILQ_NEXT
argument_list|(
name|blkif
argument_list|,
name|next_req
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|blkif
operator|->
name|on_req_sched_list
operator|=
literal|0
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|req_sched_list_lock
argument_list|)
expr_stmt|;
return|return
name|blkif
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|make_response
parameter_list|(
name|blkif_t
modifier|*
name|blkif
parameter_list|,
name|uint64_t
name|id
parameter_list|,
name|unsigned
name|short
name|op
parameter_list|,
name|int
name|st
parameter_list|)
block|{
name|blkif_response_t
modifier|*
name|resp
decl_stmt|;
name|blkif_back_ring_t
modifier|*
name|blk_ring
init|=
operator|&
name|blkif
operator|->
name|ring
decl_stmt|;
name|int
name|more_to_do
init|=
literal|0
decl_stmt|;
name|int
name|notify
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|blkif
operator|->
name|blk_ring_lock
argument_list|)
expr_stmt|;
comment|/* Place on the response ring for the relevant domain. */
name|resp
operator|=
name|RING_GET_RESPONSE
argument_list|(
name|blk_ring
argument_list|,
name|blk_ring
operator|->
name|rsp_prod_pvt
argument_list|)
expr_stmt|;
name|resp
operator|->
name|id
operator|=
name|id
expr_stmt|;
name|resp
operator|->
name|operation
operator|=
name|op
expr_stmt|;
name|resp
operator|->
name|status
operator|=
name|st
expr_stmt|;
name|blk_ring
operator|->
name|rsp_prod_pvt
operator|++
expr_stmt|;
name|RING_PUSH_RESPONSES_AND_CHECK_NOTIFY
argument_list|(
name|blk_ring
argument_list|,
name|notify
argument_list|)
expr_stmt|;
if|if
condition|(
name|blk_ring
operator|->
name|rsp_prod_pvt
operator|==
name|blk_ring
operator|->
name|req_cons
condition|)
block|{
comment|/* 		 * Tail check for pending requests. Allows frontend to avoid 		 * notifications if requests are already in flight (lower 		 * overheads and promotes batching). 		 */
name|RING_FINAL_CHECK_FOR_REQUESTS
argument_list|(
name|blk_ring
argument_list|,
name|more_to_do
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|RING_HAS_UNCONSUMED_REQUESTS
argument_list|(
name|blk_ring
argument_list|)
condition|)
name|more_to_do
operator|=
literal|1
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|blkif
operator|->
name|blk_ring_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|more_to_do
condition|)
name|add_to_req_schedule_list_tail
argument_list|(
name|blkif
argument_list|)
expr_stmt|;
if|if
condition|(
name|notify
condition|)
name|notify_remote_via_irq
argument_list|(
name|blkif
operator|->
name|irq
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|end_block_io_op
parameter_list|(
name|struct
name|bio
modifier|*
name|bio
parameter_list|)
block|{
name|pending_req_t
modifier|*
name|pending_req
init|=
name|bio
operator|->
name|bio_caller2
decl_stmt|;
if|if
condition|(
name|bio
operator|->
name|bio_error
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"BIO returned error %d for operation on device %s\n"
argument_list|,
name|bio
operator|->
name|bio_error
argument_list|,
name|pending_req
operator|->
name|blkif
operator|->
name|dev_name
argument_list|)
expr_stmt|;
name|pending_req
operator|->
name|status
operator|=
name|BLKIF_RSP_ERROR
expr_stmt|;
name|pending_req
operator|->
name|blkif
operator|->
name|st_err_req
operator|++
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|printf("done: bio=%x error=%x completed=%llu resid=%lu flags=%x\n", 		   (unsigned int)bio, bio->bio_error, bio->bio_completed, bio->bio_resid, bio->bio_flags);
endif|#
directive|endif
if|if
condition|(
name|atomic_fetchadd_int
argument_list|(
operator|&
name|pending_req
operator|->
name|pendcnt
argument_list|,
operator|-
literal|1
argument_list|)
operator|==
literal|1
condition|)
block|{
name|fast_flush_area
argument_list|(
name|pending_req
argument_list|)
expr_stmt|;
name|make_response
argument_list|(
name|pending_req
operator|->
name|blkif
argument_list|,
name|pending_req
operator|->
name|id
argument_list|,
name|pending_req
operator|->
name|operation
argument_list|,
name|pending_req
operator|->
name|status
argument_list|)
expr_stmt|;
name|blkif_put
argument_list|(
name|pending_req
operator|->
name|blkif
argument_list|)
expr_stmt|;
name|free_req
argument_list|(
name|pending_req
argument_list|)
expr_stmt|;
block|}
name|g_destroy_bio
argument_list|(
name|bio
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dispatch_rw_block_io
parameter_list|(
name|blkif_t
modifier|*
name|blkif
parameter_list|,
name|blkif_request_t
modifier|*
name|req
parameter_list|,
name|pending_req_t
modifier|*
name|pending_req
parameter_list|)
block|{
name|struct
name|gnttab_map_grant_ref
name|map
index|[
name|BLKIF_MAX_SEGMENTS_PER_REQUEST
index|]
decl_stmt|;
struct|struct
block|{
name|unsigned
name|long
name|buf
decl_stmt|;
name|unsigned
name|int
name|nsec
decl_stmt|;
block|}
name|seg
index|[
name|BLKIF_MAX_SEGMENTS_PER_REQUEST
index|]
struct|;
name|unsigned
name|int
name|nseg
init|=
name|req
operator|->
name|nr_segments
decl_stmt|,
name|nr_sects
init|=
literal|0
decl_stmt|;
name|struct
name|bio
modifier|*
name|biolist
index|[
name|BLKIF_MAX_SEGMENTS_PER_REQUEST
index|]
decl_stmt|;
name|int
name|operation
decl_stmt|,
name|ret
decl_stmt|,
name|i
decl_stmt|,
name|nbio
init|=
literal|0
decl_stmt|;
comment|/* Check that number of segments is sane. */
if|if
condition|(
name|unlikely
argument_list|(
name|nseg
operator|==
literal|0
argument_list|)
operator|||
name|unlikely
argument_list|(
name|nseg
operator|>
name|BLKIF_MAX_SEGMENTS_PER_REQUEST
argument_list|)
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"Bad number of segments in request (%d)\n"
argument_list|,
name|nseg
argument_list|)
expr_stmt|;
goto|goto
name|fail_response
goto|;
block|}
if|if
condition|(
name|req
operator|->
name|operation
operator|==
name|BLKIF_OP_WRITE
condition|)
block|{
if|if
condition|(
name|blkif
operator|->
name|read_only
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"Attempt to write to read only device %s\n"
argument_list|,
name|blkif
operator|->
name|dev_name
argument_list|)
expr_stmt|;
goto|goto
name|fail_response
goto|;
block|}
name|operation
operator|=
name|BIO_WRITE
expr_stmt|;
block|}
else|else
name|operation
operator|=
name|BIO_READ
expr_stmt|;
name|pending_req
operator|->
name|blkif
operator|=
name|blkif
expr_stmt|;
name|pending_req
operator|->
name|id
operator|=
name|req
operator|->
name|id
expr_stmt|;
name|pending_req
operator|->
name|operation
operator|=
name|req
operator|->
name|operation
expr_stmt|;
name|pending_req
operator|->
name|status
operator|=
name|BLKIF_RSP_OKAY
expr_stmt|;
name|pending_req
operator|->
name|nr_pages
operator|=
name|nseg
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nseg
condition|;
name|i
operator|++
control|)
block|{
name|seg
index|[
name|i
index|]
operator|.
name|nsec
operator|=
name|req
operator|->
name|seg
index|[
name|i
index|]
operator|.
name|last_sect
operator|-
name|req
operator|->
name|seg
index|[
name|i
index|]
operator|.
name|first_sect
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|req
operator|->
name|seg
index|[
name|i
index|]
operator|.
name|last_sect
operator|>=
operator|(
name|PAGE_SIZE
operator|>>
literal|9
operator|)
operator|)
operator|||
operator|(
name|seg
index|[
name|i
index|]
operator|.
name|nsec
operator|<=
literal|0
operator|)
condition|)
goto|goto
name|fail_response
goto|;
name|nr_sects
operator|+=
name|seg
index|[
name|i
index|]
operator|.
name|nsec
expr_stmt|;
name|map
index|[
name|i
index|]
operator|.
name|host_addr
operator|=
name|vaddr
argument_list|(
name|pending_req
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|map
index|[
name|i
index|]
operator|.
name|dom
operator|=
name|blkif
operator|->
name|domid
expr_stmt|;
name|map
index|[
name|i
index|]
operator|.
name|ref
operator|=
name|req
operator|->
name|seg
index|[
name|i
index|]
operator|.
name|gref
expr_stmt|;
name|map
index|[
name|i
index|]
operator|.
name|flags
operator|=
name|GNTMAP_host_map
expr_stmt|;
if|if
condition|(
name|operation
operator|==
name|BIO_WRITE
condition|)
name|map
index|[
name|i
index|]
operator|.
name|flags
operator||=
name|GNTMAP_readonly
expr_stmt|;
block|}
comment|/* Convert to the disk's sector size */
name|nr_sects
operator|=
operator|(
name|nr_sects
operator|<<
literal|9
operator|)
operator|>>
name|blkif
operator|->
name|sector_size_shift
expr_stmt|;
name|ret
operator|=
name|HYPERVISOR_grant_table_op
argument_list|(
name|GNTTABOP_map_grant_ref
argument_list|,
name|map
argument_list|,
name|nseg
argument_list|)
expr_stmt|;
name|PANIC_IF
argument_list|(
name|ret
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nseg
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|unlikely
argument_list|(
name|map
index|[
name|i
index|]
operator|.
name|status
operator|!=
literal|0
argument_list|)
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"invalid buffer -- could not remap it\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail_flush
goto|;
block|}
name|pending_handle
argument_list|(
name|pending_req
argument_list|,
name|i
argument_list|)
operator|=
name|map
index|[
name|i
index|]
operator|.
name|handle
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Can't do this in FreeBSD since vtophys() returns the pfn */
comment|/* of the remote domain who loaned us the machine page - DPT */
block|xen_phys_machine[(vtophys(vaddr(pending_req, i))>> PAGE_SHIFT)] = 			map[i]dev_bus_addr>> PAGE_SHIFT;
endif|#
directive|endif
name|seg
index|[
name|i
index|]
operator|.
name|buf
operator|=
name|map
index|[
name|i
index|]
operator|.
name|dev_bus_addr
operator||
operator|(
name|req
operator|->
name|seg
index|[
name|i
index|]
operator|.
name|first_sect
operator|<<
literal|9
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|req
operator|->
name|sector_number
operator|+
name|nr_sects
operator|>
name|blkif
operator|->
name|media_num_sectors
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"%s of [%llu,%llu] extends past end of device %s\n"
argument_list|,
name|operation
operator|==
name|BIO_READ
condition|?
literal|"read"
else|:
literal|"write"
argument_list|,
name|req
operator|->
name|sector_number
argument_list|,
name|req
operator|->
name|sector_number
operator|+
name|nr_sects
argument_list|,
name|blkif
operator|->
name|dev_name
argument_list|)
expr_stmt|;
goto|goto
name|fail_flush
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nseg
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|bio
modifier|*
name|bio
decl_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|seg
index|[
name|i
index|]
operator|.
name|nsec
operator|&
operator|(
operator|(
name|blkif
operator|->
name|sector_size
operator|>>
literal|9
operator|)
operator|-
literal|1
operator|)
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"Misaligned I/O request from domain %d"
argument_list|,
name|blkif
operator|->
name|domid
argument_list|)
expr_stmt|;
goto|goto
name|fail_put_bio
goto|;
block|}
name|bio
operator|=
name|biolist
index|[
name|nbio
operator|++
index|]
operator|=
name|g_new_bio
argument_list|()
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|bio
operator|==
name|NULL
argument_list|)
condition|)
goto|goto
name|fail_put_bio
goto|;
name|bio
operator|->
name|bio_cmd
operator|=
name|operation
expr_stmt|;
name|bio
operator|->
name|bio_offset
operator|=
name|req
operator|->
name|sector_number
operator|<<
name|blkif
operator|->
name|sector_size_shift
expr_stmt|;
name|bio
operator|->
name|bio_length
operator|=
name|seg
index|[
name|i
index|]
operator|.
name|nsec
operator|<<
literal|9
expr_stmt|;
name|bio
operator|->
name|bio_bcount
operator|=
name|bio
operator|->
name|bio_length
expr_stmt|;
name|bio
operator|->
name|bio_data
operator|=
call|(
name|caddr_t
call|)
argument_list|(
name|vaddr
argument_list|(
name|pending_req
argument_list|,
name|i
argument_list|)
operator||
operator|(
name|seg
index|[
name|i
index|]
operator|.
name|buf
operator|&
name|PAGE_MASK
operator|)
argument_list|)
expr_stmt|;
name|bio
operator|->
name|bio_done
operator|=
name|end_block_io_op
expr_stmt|;
name|bio
operator|->
name|bio_caller2
operator|=
name|pending_req
expr_stmt|;
name|bio
operator|->
name|bio_dev
operator|=
name|blkif
operator|->
name|cdev
expr_stmt|;
name|req
operator|->
name|sector_number
operator|+=
operator|(
name|seg
index|[
name|i
index|]
operator|.
name|nsec
operator|<<
literal|9
operator|)
operator|>>
name|blkif
operator|->
name|sector_size_shift
expr_stmt|;
if|#
directive|if
literal|0
block|printf("new: bio=%x cmd=%d sect=%llu nsect=%u iosize_max=%u @ %08lx\n", 			(unsigned int)bio, req->operation, req->sector_number, seg[i].nsec, 			blkif->cdev->si_iosize_max, seg[i].buf);
endif|#
directive|endif
block|}
name|pending_req
operator|->
name|pendcnt
operator|=
name|nbio
expr_stmt|;
name|blkif_get
argument_list|(
name|blkif
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nbio
condition|;
name|i
operator|++
control|)
call|(
modifier|*
name|blkif
operator|->
name|csw
operator|->
name|d_strategy
call|)
argument_list|(
name|biolist
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return;
name|fail_put_bio
label|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|nbio
operator|-
literal|1
operator|)
condition|;
name|i
operator|++
control|)
name|g_destroy_bio
argument_list|(
name|biolist
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|fail_flush
label|:
name|fast_flush_area
argument_list|(
name|pending_req
argument_list|)
expr_stmt|;
name|fail_response
label|:
name|make_response
argument_list|(
name|blkif
argument_list|,
name|req
operator|->
name|id
argument_list|,
name|req
operator|->
name|operation
argument_list|,
name|BLKIF_RSP_ERROR
argument_list|)
expr_stmt|;
name|free_req
argument_list|(
name|pending_req
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|blk_req_action
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|blkif_t
modifier|*
name|blkif
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|STAILQ_EMPTY
argument_list|(
operator|&
name|req_sched_list
argument_list|)
condition|)
block|{
name|blkif_back_ring_t
modifier|*
name|blk_ring
decl_stmt|;
name|RING_IDX
name|rc
decl_stmt|,
name|rp
decl_stmt|;
name|blkif
operator|=
name|remove_from_req_schedule_list
argument_list|()
expr_stmt|;
name|blk_ring
operator|=
operator|&
name|blkif
operator|->
name|ring
expr_stmt|;
name|rc
operator|=
name|blk_ring
operator|->
name|req_cons
expr_stmt|;
name|rp
operator|=
name|blk_ring
operator|->
name|sring
operator|->
name|req_prod
expr_stmt|;
name|rmb
argument_list|()
expr_stmt|;
comment|/* Ensure we see queued requests up to 'rp'. */
while|while
condition|(
operator|(
name|rc
operator|!=
name|rp
operator|)
operator|&&
operator|!
name|RING_REQUEST_CONS_OVERFLOW
argument_list|(
name|blk_ring
argument_list|,
name|rc
argument_list|)
condition|)
block|{
name|blkif_request_t
modifier|*
name|req
decl_stmt|;
name|pending_req_t
modifier|*
name|pending_req
decl_stmt|;
name|pending_req
operator|=
name|alloc_req
argument_list|()
expr_stmt|;
if|if
condition|(
name|pending_req
operator|==
name|NULL
condition|)
goto|goto
name|out_of_preqs
goto|;
name|req
operator|=
name|RING_GET_REQUEST
argument_list|(
name|blk_ring
argument_list|,
name|rc
argument_list|)
expr_stmt|;
name|blk_ring
operator|->
name|req_cons
operator|=
operator|++
name|rc
expr_stmt|;
comment|/* before make_response() */
switch|switch
condition|(
name|req
operator|->
name|operation
condition|)
block|{
case|case
name|BLKIF_OP_READ
case|:
name|blkif
operator|->
name|st_rd_req
operator|++
expr_stmt|;
name|dispatch_rw_block_io
argument_list|(
name|blkif
argument_list|,
name|req
argument_list|,
name|pending_req
argument_list|)
expr_stmt|;
break|break;
case|case
name|BLKIF_OP_WRITE
case|:
name|blkif
operator|->
name|st_wr_req
operator|++
expr_stmt|;
name|dispatch_rw_block_io
argument_list|(
name|blkif
argument_list|,
name|req
argument_list|,
name|pending_req
argument_list|)
expr_stmt|;
break|break;
default|default:
name|blkif
operator|->
name|st_err_req
operator|++
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"error: unknown block io operation [%d]\n"
argument_list|,
name|req
operator|->
name|operation
argument_list|)
expr_stmt|;
name|make_response
argument_list|(
name|blkif
argument_list|,
name|req
operator|->
name|id
argument_list|,
name|req
operator|->
name|operation
argument_list|,
name|BLKIF_RSP_ERROR
argument_list|)
expr_stmt|;
name|free_req
argument_list|(
name|pending_req
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|blkif_put
argument_list|(
name|blkif
argument_list|)
expr_stmt|;
block|}
return|return;
name|out_of_preqs
label|:
comment|/* We ran out of pending req structs */
comment|/* Just requeue interface and wait to be rescheduled to run when one is freed */
name|add_to_req_schedule_list_tail2
argument_list|(
name|blkif
argument_list|)
expr_stmt|;
name|blkif
operator|->
name|st_oo_req
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle interrupt from a frontend */
end_comment

begin_function
specifier|static
name|void
name|blkback_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|blkif_t
modifier|*
name|blkif
init|=
name|arg
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"%x\n"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|blkif
argument_list|)
expr_stmt|;
name|add_to_req_schedule_list_tail
argument_list|(
name|blkif
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Map grant ref for ring */
end_comment

begin_function
specifier|static
name|int
name|map_ring
parameter_list|(
name|grant_ref_t
name|ref
parameter_list|,
name|domid_t
name|dom
parameter_list|,
name|struct
name|ring_ref
modifier|*
name|ring
parameter_list|)
block|{
name|struct
name|gnttab_map_grant_ref
name|op
decl_stmt|;
name|ring
operator|->
name|va
operator|=
name|kmem_alloc_nofault
argument_list|(
name|kernel_map
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ring
operator|->
name|va
operator|==
literal|0
condition|)
return|return
name|ENOMEM
return|;
name|op
operator|.
name|host_addr
operator|=
name|ring
operator|->
name|va
expr_stmt|;
name|op
operator|.
name|flags
operator|=
name|GNTMAP_host_map
expr_stmt|;
name|op
operator|.
name|ref
operator|=
name|ref
expr_stmt|;
name|op
operator|.
name|dom
operator|=
name|dom
expr_stmt|;
name|HYPERVISOR_grant_table_op
argument_list|(
name|GNTTABOP_map_grant_ref
argument_list|,
operator|&
name|op
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|.
name|status
condition|)
block|{
name|WPRINTF
argument_list|(
literal|"grant table op err=%d\n"
argument_list|,
name|op
operator|.
name|status
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|kernel_map
argument_list|,
name|ring
operator|->
name|va
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|ring
operator|->
name|va
operator|=
literal|0
expr_stmt|;
return|return
name|EACCES
return|;
block|}
name|ring
operator|->
name|handle
operator|=
name|op
operator|.
name|handle
expr_stmt|;
name|ring
operator|->
name|bus_addr
operator|=
name|op
operator|.
name|dev_bus_addr
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Unmap grant ref for ring */
end_comment

begin_function
specifier|static
name|void
name|unmap_ring
parameter_list|(
name|struct
name|ring_ref
modifier|*
name|ring
parameter_list|)
block|{
name|struct
name|gnttab_unmap_grant_ref
name|op
decl_stmt|;
name|op
operator|.
name|host_addr
operator|=
name|ring
operator|->
name|va
expr_stmt|;
name|op
operator|.
name|dev_bus_addr
operator|=
name|ring
operator|->
name|bus_addr
expr_stmt|;
name|op
operator|.
name|handle
operator|=
name|ring
operator|->
name|handle
expr_stmt|;
name|HYPERVISOR_grant_table_op
argument_list|(
name|GNTTABOP_unmap_grant_ref
argument_list|,
operator|&
name|op
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|.
name|status
condition|)
name|WPRINTF
argument_list|(
literal|"grant table op err=%d\n"
argument_list|,
name|op
operator|.
name|status
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|kernel_map
argument_list|,
name|ring
operator|->
name|va
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|ring
operator|->
name|va
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|connect_ring
parameter_list|(
name|blkif_t
modifier|*
name|blkif
parameter_list|)
block|{
name|struct
name|xenbus_device
modifier|*
name|xdev
init|=
name|blkif
operator|->
name|xdev
decl_stmt|;
name|blkif_sring_t
modifier|*
name|ring
decl_stmt|;
name|unsigned
name|long
name|ring_ref
decl_stmt|;
name|evtchn_port_t
name|evtchn
decl_stmt|;
name|evtchn_op_t
name|op
init|=
block|{
operator|.
name|cmd
operator|=
name|EVTCHNOP_bind_interdomain
block|}
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
name|blkif
operator|->
name|ring_connected
condition|)
return|return
literal|0
return|;
comment|// Grab FE data and map his memory
name|err
operator|=
name|xenbus_gather
argument_list|(
name|NULL
argument_list|,
name|xdev
operator|->
name|otherend
argument_list|,
literal|"ring-ref"
argument_list|,
literal|"%lu"
argument_list|,
operator|&
name|ring_ref
argument_list|,
literal|"event-channel"
argument_list|,
literal|"%u"
argument_list|,
operator|&
name|evtchn
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|xenbus_dev_fatal
argument_list|(
name|xdev
argument_list|,
name|err
argument_list|,
literal|"reading %s/ring-ref and event-channel"
argument_list|,
name|xdev
operator|->
name|otherend
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
name|err
operator|=
name|map_ring
argument_list|(
name|ring_ref
argument_list|,
name|blkif
operator|->
name|domid
argument_list|,
operator|&
name|blkif
operator|->
name|rr
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|xenbus_dev_fatal
argument_list|(
name|xdev
argument_list|,
name|err
argument_list|,
literal|"mapping ring"
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
name|ring
operator|=
operator|(
name|blkif_sring_t
operator|*
operator|)
name|blkif
operator|->
name|rr
operator|.
name|va
expr_stmt|;
name|BACK_RING_INIT
argument_list|(
operator|&
name|blkif
operator|->
name|ring
argument_list|,
name|ring
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|op
operator|.
name|u
operator|.
name|bind_interdomain
operator|.
name|remote_dom
operator|=
name|blkif
operator|->
name|domid
expr_stmt|;
name|op
operator|.
name|u
operator|.
name|bind_interdomain
operator|.
name|remote_port
operator|=
name|evtchn
expr_stmt|;
name|err
operator|=
name|HYPERVISOR_event_channel_op
argument_list|(
operator|&
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|unmap_ring
argument_list|(
operator|&
name|blkif
operator|->
name|rr
argument_list|)
expr_stmt|;
name|xenbus_dev_fatal
argument_list|(
name|xdev
argument_list|,
name|err
argument_list|,
literal|"binding event channel"
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
name|blkif
operator|->
name|evtchn
operator|=
name|op
operator|.
name|u
operator|.
name|bind_interdomain
operator|.
name|local_port
expr_stmt|;
comment|/* bind evtchn to irq handler */
name|blkif
operator|->
name|irq
operator|=
name|bind_evtchn_to_irqhandler
argument_list|(
name|blkif
operator|->
name|evtchn
argument_list|,
literal|"blkback"
argument_list|,
name|blkback_intr
argument_list|,
name|blkif
argument_list|,
name|INTR_TYPE_NET
operator||
name|INTR_MPSAFE
argument_list|,
operator|&
name|blkif
operator|->
name|irq_cookie
argument_list|)
expr_stmt|;
name|blkif
operator|->
name|ring_connected
operator|=
literal|1
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"%x rings connected! evtchn=%d irq=%d\n"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|blkif
argument_list|,
name|blkif
operator|->
name|evtchn
argument_list|,
name|blkif
operator|->
name|irq
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|disconnect_ring
parameter_list|(
name|blkif_t
modifier|*
name|blkif
parameter_list|)
block|{
name|DPRINTF
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|blkif
operator|->
name|ring_connected
condition|)
block|{
name|unbind_from_irqhandler
argument_list|(
name|blkif
operator|->
name|irq
argument_list|,
name|blkif
operator|->
name|irq_cookie
argument_list|)
expr_stmt|;
name|blkif
operator|->
name|irq
operator|=
literal|0
expr_stmt|;
name|unmap_ring
argument_list|(
operator|&
name|blkif
operator|->
name|rr
argument_list|)
expr_stmt|;
name|blkif
operator|->
name|ring_connected
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|connect
parameter_list|(
name|blkif_t
modifier|*
name|blkif
parameter_list|)
block|{
name|struct
name|xenbus_transaction
modifier|*
name|xbt
decl_stmt|;
name|struct
name|xenbus_device
modifier|*
name|xdev
init|=
name|blkif
operator|->
name|xdev
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
operator|!
name|blkif
operator|->
name|ring_connected
operator|||
name|blkif
operator|->
name|vn
operator|==
name|NULL
operator|||
name|blkif
operator|->
name|state
operator|==
name|XenbusStateConnected
condition|)
return|return;
name|DPRINTF
argument_list|(
literal|"%s\n"
argument_list|,
name|xdev
operator|->
name|otherend
argument_list|)
expr_stmt|;
comment|/* Supply the information about the device the frontend needs */
name|again
label|:
name|xbt
operator|=
name|xenbus_transaction_start
argument_list|()
expr_stmt|;
if|if
condition|(
name|IS_ERR
argument_list|(
name|xbt
argument_list|)
condition|)
block|{
name|xenbus_dev_fatal
argument_list|(
name|xdev
argument_list|,
name|PTR_ERR
argument_list|(
name|xbt
argument_list|)
argument_list|,
literal|"Error writing configuration for backend "
literal|"(start transaction)"
argument_list|)
expr_stmt|;
return|return;
block|}
name|err
operator|=
name|xenbus_printf
argument_list|(
name|xbt
argument_list|,
name|xdev
operator|->
name|nodename
argument_list|,
literal|"sectors"
argument_list|,
literal|"%u"
argument_list|,
name|blkif
operator|->
name|media_num_sectors
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|xenbus_dev_fatal
argument_list|(
name|xdev
argument_list|,
name|err
argument_list|,
literal|"writing %s/sectors"
argument_list|,
name|xdev
operator|->
name|nodename
argument_list|)
expr_stmt|;
goto|goto
name|abort
goto|;
block|}
name|err
operator|=
name|xenbus_printf
argument_list|(
name|xbt
argument_list|,
name|xdev
operator|->
name|nodename
argument_list|,
literal|"info"
argument_list|,
literal|"%u"
argument_list|,
name|blkif
operator|->
name|read_only
condition|?
name|VDISK_READONLY
else|:
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|xenbus_dev_fatal
argument_list|(
name|xdev
argument_list|,
name|err
argument_list|,
literal|"writing %s/info"
argument_list|,
name|xdev
operator|->
name|nodename
argument_list|)
expr_stmt|;
goto|goto
name|abort
goto|;
block|}
name|err
operator|=
name|xenbus_printf
argument_list|(
name|xbt
argument_list|,
name|xdev
operator|->
name|nodename
argument_list|,
literal|"sector-size"
argument_list|,
literal|"%u"
argument_list|,
name|blkif
operator|->
name|sector_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|xenbus_dev_fatal
argument_list|(
name|xdev
argument_list|,
name|err
argument_list|,
literal|"writing %s/sector-size"
argument_list|,
name|xdev
operator|->
name|nodename
argument_list|)
expr_stmt|;
goto|goto
name|abort
goto|;
block|}
name|err
operator|=
name|xenbus_transaction_end
argument_list|(
name|xbt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
operator|-
name|EAGAIN
condition|)
goto|goto
name|again
goto|;
if|if
condition|(
name|err
condition|)
name|xenbus_dev_fatal
argument_list|(
name|xdev
argument_list|,
name|err
argument_list|,
literal|"ending transaction"
argument_list|)
expr_stmt|;
name|err
operator|=
name|xenbus_switch_state
argument_list|(
name|xdev
argument_list|,
name|NULL
argument_list|,
name|XenbusStateConnected
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|xenbus_dev_fatal
argument_list|(
name|xdev
argument_list|,
name|err
argument_list|,
literal|"switching to Connected state"
argument_list|,
name|xdev
operator|->
name|nodename
argument_list|)
expr_stmt|;
name|blkif
operator|->
name|state
operator|=
name|XenbusStateConnected
expr_stmt|;
return|return;
name|abort
label|:
name|xenbus_transaction_end
argument_list|(
name|xbt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|blkback_probe
parameter_list|(
name|struct
name|xenbus_device
modifier|*
name|xdev
parameter_list|,
specifier|const
name|struct
name|xenbus_device_id
modifier|*
name|id
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|mode
init|=
name|NULL
decl_stmt|,
modifier|*
name|type
init|=
name|NULL
decl_stmt|,
modifier|*
name|params
init|=
name|NULL
decl_stmt|;
name|long
name|handle
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"node=%s\n"
argument_list|,
name|xdev
operator|->
name|nodename
argument_list|)
expr_stmt|;
name|p
operator|=
name|strrchr
argument_list|(
name|xdev
operator|->
name|otherend
argument_list|,
literal|'/'
argument_list|)
operator|+
literal|1
expr_stmt|;
name|handle
operator|=
name|strtoul
argument_list|(
name|p
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mode
operator|=
name|xenbus_read
argument_list|(
name|NULL
argument_list|,
name|xdev
operator|->
name|nodename
argument_list|,
literal|"mode"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ERR
argument_list|(
name|mode
argument_list|)
condition|)
block|{
name|xenbus_dev_fatal
argument_list|(
name|xdev
argument_list|,
name|PTR_ERR
argument_list|(
name|mode
argument_list|)
argument_list|,
literal|"reading mode"
argument_list|)
expr_stmt|;
name|err
operator|=
name|PTR_ERR
argument_list|(
name|mode
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|type
operator|=
name|xenbus_read
argument_list|(
name|NULL
argument_list|,
name|xdev
operator|->
name|nodename
argument_list|,
literal|"type"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ERR
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|xenbus_dev_fatal
argument_list|(
name|xdev
argument_list|,
name|PTR_ERR
argument_list|(
name|type
argument_list|)
argument_list|,
literal|"reading type"
argument_list|)
expr_stmt|;
name|err
operator|=
name|PTR_ERR
argument_list|(
name|type
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|params
operator|=
name|xenbus_read
argument_list|(
name|NULL
argument_list|,
name|xdev
operator|->
name|nodename
argument_list|,
literal|"params"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ERR
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|xenbus_dev_fatal
argument_list|(
name|xdev
argument_list|,
name|PTR_ERR
argument_list|(
name|params
argument_list|)
argument_list|,
literal|"reading params"
argument_list|)
expr_stmt|;
name|err
operator|=
name|PTR_ERR
argument_list|(
name|params
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|err
operator|=
name|blkif_create
argument_list|(
name|xdev
argument_list|,
name|handle
argument_list|,
name|mode
argument_list|,
name|type
argument_list|,
name|params
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|xenbus_dev_fatal
argument_list|(
name|xdev
argument_list|,
name|err
argument_list|,
literal|"creating blkif"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|err
operator|=
name|vbd_add_dev
argument_list|(
name|xdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|blkif_put
argument_list|(
operator|(
name|blkif_t
operator|*
operator|)
name|xdev
operator|->
name|data
argument_list|)
expr_stmt|;
name|xenbus_dev_fatal
argument_list|(
name|xdev
argument_list|,
name|err
argument_list|,
literal|"adding vbd device"
argument_list|)
expr_stmt|;
block|}
return|return
name|err
return|;
name|error
label|:
if|if
condition|(
name|mode
condition|)
name|free
argument_list|(
name|mode
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
condition|)
name|free
argument_list|(
name|type
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|params
condition|)
name|free
argument_list|(
name|params
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|blkback_remove
parameter_list|(
name|struct
name|xenbus_device
modifier|*
name|xdev
parameter_list|)
block|{
name|blkif_t
modifier|*
name|blkif
init|=
name|xdev
operator|->
name|data
decl_stmt|;
name|device_t
name|ndev
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"node=%s\n"
argument_list|,
name|xdev
operator|->
name|nodename
argument_list|)
expr_stmt|;
name|blkif
operator|->
name|state
operator|=
name|XenbusStateClosing
expr_stmt|;
if|if
condition|(
operator|(
name|ndev
operator|=
name|blkif
operator|->
name|ndev
operator|)
condition|)
block|{
name|blkif
operator|->
name|ndev
operator|=
name|NULL
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|device_detach
argument_list|(
name|ndev
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
block|}
name|xdev
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
name|blkif
operator|->
name|xdev
operator|=
name|NULL
expr_stmt|;
name|blkif_put
argument_list|(
name|blkif
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|blkback_resume
parameter_list|(
name|struct
name|xenbus_device
modifier|*
name|xdev
parameter_list|)
block|{
name|DPRINTF
argument_list|(
literal|"node=%s\n"
argument_list|,
name|xdev
operator|->
name|nodename
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|frontend_changed
parameter_list|(
name|struct
name|xenbus_device
modifier|*
name|xdev
parameter_list|,
name|XenbusState
name|frontend_state
parameter_list|)
block|{
name|blkif_t
modifier|*
name|blkif
init|=
name|xdev
operator|->
name|data
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"state=%d\n"
argument_list|,
name|frontend_state
argument_list|)
expr_stmt|;
name|blkif
operator|->
name|frontend_state
operator|=
name|frontend_state
expr_stmt|;
switch|switch
condition|(
name|frontend_state
condition|)
block|{
case|case
name|XenbusStateInitialising
case|:
break|break;
case|case
name|XenbusStateInitialised
case|:
case|case
name|XenbusStateConnected
case|:
name|connect_ring
argument_list|(
name|blkif
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|blkif
argument_list|)
expr_stmt|;
break|break;
case|case
name|XenbusStateClosing
case|:
name|xenbus_switch_state
argument_list|(
name|xdev
argument_list|,
name|NULL
argument_list|,
name|XenbusStateClosing
argument_list|)
expr_stmt|;
break|break;
case|case
name|XenbusStateClosed
case|:
name|xenbus_remove_device
argument_list|(
name|xdev
argument_list|)
expr_stmt|;
break|break;
case|case
name|XenbusStateUnknown
case|:
case|case
name|XenbusStateInitWait
case|:
name|xenbus_dev_fatal
argument_list|(
name|xdev
argument_list|,
name|EINVAL
argument_list|,
literal|"saw state %d at frontend"
argument_list|,
name|frontend_state
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* ** Driver registration ** */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|xenbus_device_id
name|blkback_ids
index|[]
init|=
block|{
block|{
literal|"vbd"
block|}
block|,
block|{
literal|""
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|xenbus_driver
name|blkback
init|=
block|{
operator|.
name|name
operator|=
literal|"blkback"
block|,
operator|.
name|ids
operator|=
name|blkback_ids
block|,
operator|.
name|probe
operator|=
name|blkback_probe
block|,
operator|.
name|remove
operator|=
name|blkback_remove
block|,
operator|.
name|resume
operator|=
name|blkback_resume
block|,
operator|.
name|otherend_changed
operator|=
name|frontend_changed
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|blkback_init
parameter_list|(
name|void
modifier|*
name|unused
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|blk_req_task
argument_list|,
literal|0
argument_list|,
name|blk_req_action
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|req_sched_list_lock
argument_list|,
literal|"blk_req_sched_lock"
argument_list|,
literal|"blkback req sched lock"
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|pending_free_lock
argument_list|,
literal|"blk_pending_req_ock"
argument_list|,
literal|"blkback pending request lock"
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|mmap_pages
operator|=
name|blkif_reqs
operator|*
name|BLKIF_MAX_SEGMENTS_PER_REQUEST
expr_stmt|;
name|pending_reqs
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|pending_reqs
index|[
literal|0
index|]
argument_list|)
operator|*
name|blkif_reqs
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_ZERO
operator||
name|M_NOWAIT
argument_list|)
expr_stmt|;
name|pending_grant_handles
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|pending_grant_handles
index|[
literal|0
index|]
argument_list|)
operator|*
name|mmap_pages
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
name|pending_vaddrs
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|pending_vaddrs
index|[
literal|0
index|]
argument_list|)
operator|*
name|mmap_pages
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
name|mmap_vstart
operator|=
name|alloc_empty_page_range
argument_list|(
name|mmap_pages
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pending_reqs
operator|||
operator|!
name|pending_grant_handles
operator|||
operator|!
name|pending_vaddrs
operator|||
operator|!
name|mmap_vstart
condition|)
block|{
if|if
condition|(
name|pending_reqs
condition|)
name|free
argument_list|(
name|pending_reqs
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|pending_grant_handles
condition|)
name|free
argument_list|(
name|pending_grant_handles
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|pending_vaddrs
condition|)
name|free
argument_list|(
name|pending_vaddrs
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|WPRINTF
argument_list|(
literal|"out of memory\n"
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mmap_pages
condition|;
name|i
operator|++
control|)
block|{
name|pending_vaddrs
index|[
name|i
index|]
operator|=
name|mmap_vstart
operator|+
operator|(
name|i
operator|<<
name|PAGE_SHIFT
operator|)
expr_stmt|;
name|pending_grant_handles
index|[
name|i
index|]
operator|=
name|BLKBACK_INVALID_HANDLE
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|blkif_reqs
condition|;
name|i
operator|++
control|)
block|{
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|pending_free
argument_list|,
operator|&
name|pending_reqs
index|[
name|i
index|]
argument_list|,
name|free_list
argument_list|)
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
literal|"registering %s\n"
argument_list|,
name|blkback
operator|.
name|name
argument_list|)
expr_stmt|;
name|xenbus_register_backend
argument_list|(
operator|&
name|blkback
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|SYSINIT
argument_list|(
argument|xbbedev
argument_list|,
argument|SI_SUB_PSEUDO
argument_list|,
argument|SI_ORDER_ANY
argument_list|,
argument|blkback_init
argument_list|,
argument|NULL
argument_list|)
end_macro

begin_function
specifier|static
name|void
name|close_device
parameter_list|(
name|blkif_t
modifier|*
name|blkif
parameter_list|)
block|{
name|DPRINTF
argument_list|(
literal|"closing dev=%s\n"
argument_list|,
name|blkif
operator|->
name|dev_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|blkif
operator|->
name|vn
condition|)
block|{
name|int
name|flags
init|=
name|FREAD
decl_stmt|;
if|if
condition|(
operator|!
name|blkif
operator|->
name|read_only
condition|)
name|flags
operator||=
name|FWRITE
expr_stmt|;
if|if
condition|(
name|blkif
operator|->
name|csw
condition|)
block|{
name|dev_relthread
argument_list|(
name|blkif
operator|->
name|cdev
argument_list|)
expr_stmt|;
name|blkif
operator|->
name|csw
operator|=
name|NULL
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|vn_close
argument_list|(
name|blkif
operator|->
name|vn
argument_list|,
name|flags
argument_list|,
name|NOCRED
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
name|blkif
operator|->
name|vn
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|open_device
parameter_list|(
name|blkif_t
modifier|*
name|blkif
parameter_list|)
block|{
name|struct
name|nameidata
name|nd
decl_stmt|;
name|struct
name|vattr
name|vattr
decl_stmt|;
name|struct
name|cdev
modifier|*
name|dev
decl_stmt|;
name|struct
name|cdevsw
modifier|*
name|devsw
decl_stmt|;
name|int
name|flags
init|=
name|FREAD
decl_stmt|,
name|err
init|=
literal|0
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"opening dev=%s\n"
argument_list|,
name|blkif
operator|->
name|dev_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|blkif
operator|->
name|read_only
condition|)
name|flags
operator||=
name|FWRITE
expr_stmt|;
if|if
condition|(
operator|!
name|curthread
operator|->
name|td_proc
operator|->
name|p_fd
operator|->
name|fd_cdir
condition|)
block|{
name|curthread
operator|->
name|td_proc
operator|->
name|p_fd
operator|->
name|fd_cdir
operator|=
name|rootvnode
expr_stmt|;
name|VREF
argument_list|(
name|rootvnode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|curthread
operator|->
name|td_proc
operator|->
name|p_fd
operator|->
name|fd_rdir
condition|)
block|{
name|curthread
operator|->
name|td_proc
operator|->
name|p_fd
operator|->
name|fd_rdir
operator|=
name|rootvnode
expr_stmt|;
name|VREF
argument_list|(
name|rootvnode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|curthread
operator|->
name|td_proc
operator|->
name|p_fd
operator|->
name|fd_jdir
condition|)
block|{
name|curthread
operator|->
name|td_proc
operator|->
name|p_fd
operator|->
name|fd_jdir
operator|=
name|rootvnode
expr_stmt|;
name|VREF
argument_list|(
name|rootvnode
argument_list|)
expr_stmt|;
block|}
name|again
label|:
name|NDINIT
argument_list|(
operator|&
name|nd
argument_list|,
name|LOOKUP
argument_list|,
name|FOLLOW
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|blkif
operator|->
name|dev_name
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
name|err
operator|=
name|vn_open
argument_list|(
operator|&
name|nd
argument_list|,
operator|&
name|flags
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|blkif
operator|->
name|dev_name
index|[
literal|0
index|]
operator|!=
literal|'/'
condition|)
block|{
name|char
modifier|*
name|dev_path
init|=
literal|"/dev/"
decl_stmt|;
name|char
modifier|*
name|dev_name
decl_stmt|;
comment|/* Try adding device path at beginning of name */
name|dev_name
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|blkif
operator|->
name|dev_name
argument_list|)
operator|+
name|strlen
argument_list|(
name|dev_path
argument_list|)
operator|+
literal|1
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev_name
condition|)
block|{
name|sprintf
argument_list|(
name|dev_name
argument_list|,
literal|"%s%s"
argument_list|,
name|dev_path
argument_list|,
name|blkif
operator|->
name|dev_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|blkif
operator|->
name|dev_name
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|blkif
operator|->
name|dev_name
operator|=
name|dev_name
expr_stmt|;
goto|goto
name|again
goto|;
block|}
block|}
name|xenbus_dev_fatal
argument_list|(
name|blkif
operator|->
name|xdev
argument_list|,
name|err
argument_list|,
literal|"error opening device %s"
argument_list|,
name|blkif
operator|->
name|dev_name
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
name|NDFREE
argument_list|(
operator|&
name|nd
argument_list|,
name|NDF_ONLY_PNBUF
argument_list|)
expr_stmt|;
name|blkif
operator|->
name|vn
operator|=
name|nd
operator|.
name|ni_vp
expr_stmt|;
comment|/* We only support disks for now */
if|if
condition|(
operator|!
name|vn_isdisk
argument_list|(
name|blkif
operator|->
name|vn
argument_list|,
operator|&
name|err
argument_list|)
condition|)
block|{
name|xenbus_dev_fatal
argument_list|(
name|blkif
operator|->
name|xdev
argument_list|,
name|err
argument_list|,
literal|"device %s is not a disk"
argument_list|,
name|blkif
operator|->
name|dev_name
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|blkif
operator|->
name|vn
argument_list|,
literal|0
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|blkif
operator|->
name|cdev
operator|=
name|blkif
operator|->
name|vn
operator|->
name|v_rdev
expr_stmt|;
name|blkif
operator|->
name|csw
operator|=
name|dev_refthread
argument_list|(
name|blkif
operator|->
name|cdev
argument_list|)
expr_stmt|;
name|PANIC_IF
argument_list|(
name|blkif
operator|->
name|csw
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|err
operator|=
name|VOP_GETATTR
argument_list|(
name|blkif
operator|->
name|vn
argument_list|,
operator|&
name|vattr
argument_list|,
name|NOCRED
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|xenbus_dev_fatal
argument_list|(
name|blkif
operator|->
name|xdev
argument_list|,
name|err
argument_list|,
literal|"error getting vnode attributes for device %s"
argument_list|,
name|blkif
operator|->
name|dev_name
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|blkif
operator|->
name|vn
argument_list|,
literal|0
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|VOP_UNLOCK
argument_list|(
name|blkif
operator|->
name|vn
argument_list|,
literal|0
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
name|dev
operator|=
name|blkif
operator|->
name|vn
operator|->
name|v_rdev
expr_stmt|;
name|devsw
operator|=
name|dev
operator|->
name|si_devsw
expr_stmt|;
if|if
condition|(
operator|!
name|devsw
operator|->
name|d_ioctl
condition|)
block|{
name|err
operator|=
name|ENODEV
expr_stmt|;
name|xenbus_dev_fatal
argument_list|(
name|blkif
operator|->
name|xdev
argument_list|,
name|err
argument_list|,
literal|"no d_ioctl for device %s!"
argument_list|,
name|blkif
operator|->
name|dev_name
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|err
operator|=
call|(
modifier|*
name|devsw
operator|->
name|d_ioctl
call|)
argument_list|(
name|dev
argument_list|,
name|DIOCGSECTORSIZE
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|blkif
operator|->
name|sector_size
argument_list|,
name|FREAD
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|xenbus_dev_fatal
argument_list|(
name|blkif
operator|->
name|xdev
argument_list|,
name|err
argument_list|,
literal|"error calling ioctl DIOCGSECTORSIZE for device %s"
argument_list|,
name|blkif
operator|->
name|dev_name
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|blkif
operator|->
name|sector_size_shift
operator|=
name|fls
argument_list|(
name|blkif
operator|->
name|sector_size
argument_list|)
operator|-
literal|1
expr_stmt|;
name|err
operator|=
call|(
modifier|*
name|devsw
operator|->
name|d_ioctl
call|)
argument_list|(
name|dev
argument_list|,
name|DIOCGMEDIASIZE
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|blkif
operator|->
name|media_size
argument_list|,
name|FREAD
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|xenbus_dev_fatal
argument_list|(
name|blkif
operator|->
name|xdev
argument_list|,
name|err
argument_list|,
literal|"error calling ioctl DIOCGMEDIASIZE for device %s"
argument_list|,
name|blkif
operator|->
name|dev_name
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|blkif
operator|->
name|media_num_sectors
operator|=
name|blkif
operator|->
name|media_size
operator|>>
name|blkif
operator|->
name|sector_size_shift
expr_stmt|;
name|blkif
operator|->
name|major
operator|=
name|major
argument_list|(
name|vattr
operator|.
name|va_rdev
argument_list|)
expr_stmt|;
name|blkif
operator|->
name|minor
operator|=
name|minor
argument_list|(
name|vattr
operator|.
name|va_rdev
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"opened dev=%s major=%d minor=%d sector_size=%u media_size=%lld\n"
argument_list|,
name|blkif
operator|->
name|dev_name
argument_list|,
name|blkif
operator|->
name|major
argument_list|,
name|blkif
operator|->
name|minor
argument_list|,
name|blkif
operator|->
name|sector_size
argument_list|,
name|blkif
operator|->
name|media_size
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|error
label|:
name|close_device
argument_list|(
name|blkif
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vbd_add_dev
parameter_list|(
name|struct
name|xenbus_device
modifier|*
name|xdev
parameter_list|)
block|{
name|blkif_t
modifier|*
name|blkif
init|=
name|xdev
operator|->
name|data
decl_stmt|;
name|device_t
name|nexus
decl_stmt|,
name|ndev
decl_stmt|;
name|devclass_t
name|dc
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
comment|/* We will add a vbd device as a child of nexus0 (for now) */
if|if
condition|(
operator|!
operator|(
name|dc
operator|=
name|devclass_find
argument_list|(
literal|"nexus"
argument_list|)
operator|)
operator|||
operator|!
operator|(
name|nexus
operator|=
name|devclass_get_device
argument_list|(
name|dc
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
block|{
name|WPRINTF
argument_list|(
literal|"could not find nexus0!\n"
argument_list|)
expr_stmt|;
name|err
operator|=
name|ENOENT
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* Create a newbus device representing the vbd */
name|ndev
operator|=
name|BUS_ADD_CHILD
argument_list|(
name|nexus
argument_list|,
literal|0
argument_list|,
literal|"vbd"
argument_list|,
name|blkif
operator|->
name|handle
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ndev
condition|)
block|{
name|WPRINTF
argument_list|(
literal|"could not create newbus device vbd%d!\n"
argument_list|,
name|blkif
operator|->
name|handle
argument_list|)
expr_stmt|;
name|err
operator|=
name|EFAULT
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|blkif_get
argument_list|(
name|blkif
argument_list|)
expr_stmt|;
name|device_set_ivars
argument_list|(
name|ndev
argument_list|,
name|blkif
argument_list|)
expr_stmt|;
name|blkif
operator|->
name|ndev
operator|=
name|ndev
expr_stmt|;
name|device_probe_and_attach
argument_list|(
name|ndev
argument_list|)
expr_stmt|;
name|done
label|:
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_enum
enum|enum
block|{
name|VBD_SYSCTL_DOMID
block|,
name|VBD_SYSCTL_ST_RD_REQ
block|,
name|VBD_SYSCTL_ST_WR_REQ
block|,
name|VBD_SYSCTL_ST_OO_REQ
block|,
name|VBD_SYSCTL_ST_ERR_REQ
block|,
name|VBD_SYSCTL_RING
block|, }
enum|;
end_enum

begin_function
specifier|static
name|char
modifier|*
name|vbd_sysctl_ring_info
parameter_list|(
name|blkif_t
modifier|*
name|blkif
parameter_list|,
name|int
name|cmd
parameter_list|)
block|{
name|char
modifier|*
name|buf
init|=
name|malloc
argument_list|(
literal|256
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
decl_stmt|;
if|if
condition|(
name|buf
condition|)
block|{
if|if
condition|(
operator|!
name|blkif
operator|->
name|ring_connected
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"ring not connected\n"
argument_list|)
expr_stmt|;
else|else
block|{
name|blkif_back_ring_t
modifier|*
name|ring
init|=
operator|&
name|blkif
operator|->
name|ring
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"nr_ents=%x req_cons=%x"
literal|" req_prod=%x req_event=%x"
literal|" rsp_prod=%x rsp_event=%x"
argument_list|,
name|ring
operator|->
name|nr_ents
argument_list|,
name|ring
operator|->
name|req_cons
argument_list|,
name|ring
operator|->
name|sring
operator|->
name|req_prod
argument_list|,
name|ring
operator|->
name|sring
operator|->
name|req_event
argument_list|,
name|ring
operator|->
name|sring
operator|->
name|rsp_prod
argument_list|,
name|ring
operator|->
name|sring
operator|->
name|rsp_event
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|buf
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vbd_sysctl_handler
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|device_t
name|dev
init|=
operator|(
name|device_t
operator|)
name|arg1
decl_stmt|;
name|blkif_t
modifier|*
name|blkif
init|=
operator|(
name|blkif_t
operator|*
operator|)
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|value
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
name|int
name|err
decl_stmt|;
switch|switch
condition|(
name|arg2
condition|)
block|{
case|case
name|VBD_SYSCTL_DOMID
case|:
return|return
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
name|NULL
argument_list|,
name|blkif
operator|->
name|domid
argument_list|,
name|req
argument_list|)
return|;
case|case
name|VBD_SYSCTL_ST_RD_REQ
case|:
return|return
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
name|NULL
argument_list|,
name|blkif
operator|->
name|st_rd_req
argument_list|,
name|req
argument_list|)
return|;
case|case
name|VBD_SYSCTL_ST_WR_REQ
case|:
return|return
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
name|NULL
argument_list|,
name|blkif
operator|->
name|st_wr_req
argument_list|,
name|req
argument_list|)
return|;
case|case
name|VBD_SYSCTL_ST_OO_REQ
case|:
return|return
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
name|NULL
argument_list|,
name|blkif
operator|->
name|st_oo_req
argument_list|,
name|req
argument_list|)
return|;
case|case
name|VBD_SYSCTL_ST_ERR_REQ
case|:
return|return
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
name|NULL
argument_list|,
name|blkif
operator|->
name|st_err_req
argument_list|,
name|req
argument_list|)
return|;
case|case
name|VBD_SYSCTL_RING
case|:
name|value
operator|=
name|buf
operator|=
name|vbd_sysctl_ring_info
argument_list|(
name|blkif
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|err
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
name|value
argument_list|,
name|strlen
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|buf
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_comment
comment|/* Newbus vbd device driver probe */
end_comment

begin_function
specifier|static
name|int
name|vbd_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|DPRINTF
argument_list|(
literal|"vbd%d\n"
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Newbus vbd device driver attach */
end_comment

begin_function
specifier|static
name|int
name|vbd_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|blkif_t
modifier|*
name|blkif
init|=
operator|(
name|blkif_t
operator|*
operator|)
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"%s\n"
argument_list|,
name|blkif
operator|->
name|dev_name
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"domid"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RD
argument_list|,
name|dev
argument_list|,
name|VBD_SYSCTL_DOMID
argument_list|,
name|vbd_sysctl_handler
argument_list|,
literal|"I"
argument_list|,
literal|"domid of frontend"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rd_reqs"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RD
argument_list|,
name|dev
argument_list|,
name|VBD_SYSCTL_ST_RD_REQ
argument_list|,
name|vbd_sysctl_handler
argument_list|,
literal|"I"
argument_list|,
literal|"number of read reqs"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"wr_reqs"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RD
argument_list|,
name|dev
argument_list|,
name|VBD_SYSCTL_ST_WR_REQ
argument_list|,
name|vbd_sysctl_handler
argument_list|,
literal|"I"
argument_list|,
literal|"number of write reqs"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"oo_reqs"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RD
argument_list|,
name|dev
argument_list|,
name|VBD_SYSCTL_ST_OO_REQ
argument_list|,
name|vbd_sysctl_handler
argument_list|,
literal|"I"
argument_list|,
literal|"number of deferred reqs"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"err_reqs"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RD
argument_list|,
name|dev
argument_list|,
name|VBD_SYSCTL_ST_ERR_REQ
argument_list|,
name|vbd_sysctl_handler
argument_list|,
literal|"I"
argument_list|,
literal|"number of reqs that returned error"
argument_list|)
expr_stmt|;
if|#
directive|if
name|XEN_BLKBACK_DEBUG
name|SYSCTL_ADD_PROC
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"ring"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|dev
argument_list|,
name|VBD_SYSCTL_RING
argument_list|,
name|vbd_sysctl_handler
argument_list|,
literal|"A"
argument_list|,
literal|"req ring info"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|open_device
argument_list|(
name|blkif
argument_list|)
condition|)
name|connect
argument_list|(
name|blkif
argument_list|)
expr_stmt|;
return|return
name|bus_generic_attach
argument_list|(
name|dev
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Newbus vbd device driver detach */
end_comment

begin_function
specifier|static
name|int
name|vbd_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|blkif_t
modifier|*
name|blkif
init|=
operator|(
name|blkif_t
operator|*
operator|)
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"%s\n"
argument_list|,
name|blkif
operator|->
name|dev_name
argument_list|)
expr_stmt|;
name|close_device
argument_list|(
name|blkif
argument_list|)
expr_stmt|;
name|bus_generic_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|blkif_put
argument_list|(
name|blkif
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|vbd_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|vbd_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|vbd_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|vbd_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|bus_generic_shutdown
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|bus_generic_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|bus_generic_resume
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|vbd_devclass
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|vbd_driver
init|=
block|{
literal|"vbd"
block|,
name|vbd_methods
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|vbd
argument_list|,
name|nexus
argument_list|,
name|vbd_driver
argument_list|,
name|vbd_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Local variables:  * mode: C  * c-set-style: "BSD"  * c-basic-offset: 4  * tab-width: 4  * indent-tabs-mode: t  * End:  */
end_comment

end_unit

