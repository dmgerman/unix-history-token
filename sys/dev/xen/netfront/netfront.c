begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2004-2006 Kip Macy  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|700000
end_if

begin_include
include|#
directive|include
file|<netinet/tcp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp_lro.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_comment
comment|/* for DELAY */
end_comment

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<machine/frame.h>
end_include

begin_include
include|#
directive|include
file|<machine/vmparam.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<machine/intr_machdep.h>
end_include

begin_include
include|#
directive|include
file|<machine/xen/xen-os.h>
end_include

begin_include
include|#
directive|include
file|<machine/xen/xenfunc.h>
end_include

begin_include
include|#
directive|include
file|<machine/xen/xenvar.h>
end_include

begin_include
include|#
directive|include
file|<xen/hypervisor.h>
end_include

begin_include
include|#
directive|include
file|<xen/xen_intr.h>
end_include

begin_include
include|#
directive|include
file|<xen/evtchn.h>
end_include

begin_include
include|#
directive|include
file|<xen/gnttab.h>
end_include

begin_include
include|#
directive|include
file|<xen/interface/memory.h>
end_include

begin_include
include|#
directive|include
file|<xen/interface/io/netif.h>
end_include

begin_include
include|#
directive|include
file|<xen/xenbus/xenbusvar.h>
end_include

begin_include
include|#
directive|include
file|<dev/xen/netfront/mbufq.h>
end_include

begin_include
include|#
directive|include
file|"xenbus_if.h"
end_include

begin_define
define|#
directive|define
name|XN_CSUM_FEATURES
value|(CSUM_TCP | CSUM_UDP | CSUM_TSO)
end_define

begin_define
define|#
directive|define
name|NET_TX_RING_SIZE
value|__RING_SIZE((netif_tx_sring_t *)0, PAGE_SIZE)
end_define

begin_define
define|#
directive|define
name|NET_RX_RING_SIZE
value|__RING_SIZE((netif_rx_sring_t *)0, PAGE_SIZE)
end_define

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|700000
end_if

begin_comment
comment|/*  * Should the driver do LRO on the RX end  *  this can be toggled on the fly, but the  *  interface must be reset (down/up) for it  *  to take effect.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|xn_enable_lro
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.xn.enable_lro"
argument_list|,
operator|&
name|xn_enable_lro
argument_list|)
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|IFCAP_TSO4
value|0
end_define

begin_define
define|#
directive|define
name|CSUM_TSO
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|CONFIG_XEN
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|MODPARM_rx_copy
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|module_param_named
argument_list|(
name|rx_copy
argument_list|,
name|MODPARM_rx_copy
argument_list|,
name|bool
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_PARM_DESC
argument_list|(
name|rx_copy
argument_list|,
literal|"Copy packets from network card (rather than flip)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|MODPARM_rx_flip
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|module_param_named
argument_list|(
name|rx_flip
argument_list|,
name|MODPARM_rx_flip
argument_list|,
name|bool
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_PARM_DESC
argument_list|(
name|rx_flip
argument_list|,
literal|"Flip packets from network card (rather than copy)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
specifier|const
name|int
name|MODPARM_rx_copy
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|int
name|MODPARM_rx_flip
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * \brief The maximum allowed data fragments in a single transmit  *        request.  *  * This limit is imposed by the backend driver.  We assume here that  * we are dealing with a Linux driver domain and have set our limit  * to mirror the Linux MAX_SKB_FRAGS constant.  */
end_comment

begin_define
define|#
directive|define
name|MAX_TX_REQ_FRAGS
value|(65536 / PAGE_SIZE + 2)
end_define

begin_define
define|#
directive|define
name|RX_COPY_THRESHOLD
value|256
end_define

begin_define
define|#
directive|define
name|net_ratelimit
parameter_list|()
value|0
end_define

begin_struct_decl
struct_decl|struct
name|netfront_info
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|netfront_rx_info
struct_decl|;
end_struct_decl

begin_function_decl
specifier|static
name|void
name|xn_txeof
parameter_list|(
name|struct
name|netfront_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xn_rxeof
parameter_list|(
name|struct
name|netfront_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|network_alloc_rx_buffers
parameter_list|(
name|struct
name|netfront_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xn_tick_locked
parameter_list|(
name|struct
name|netfront_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xn_tick
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xn_intr
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|int
name|xn_count_frags
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xn_assemble_tx_request
parameter_list|(
name|struct
name|netfront_info
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m_head
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xn_start_locked
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xn_start
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xn_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|u_long
parameter_list|,
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xn_ifinit_locked
parameter_list|(
name|struct
name|netfront_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xn_ifinit
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xn_stop
parameter_list|(
name|struct
name|netfront_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|notyet
end_ifdef

begin_function_decl
specifier|static
name|void
name|xn_watchdog
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|show_device
parameter_list|(
name|struct
name|netfront_info
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|notyet
end_ifdef

begin_function_decl
specifier|static
name|void
name|netfront_closing
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|netif_free
parameter_list|(
name|struct
name|netfront_info
modifier|*
name|info
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|netfront_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|talk_to_backend
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|netfront_info
modifier|*
name|info
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|create_netdev
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|netif_disconnect_backend
parameter_list|(
name|struct
name|netfront_info
modifier|*
name|info
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|setup_device
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|netfront_info
modifier|*
name|info
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|end_access
parameter_list|(
name|int
name|ref
parameter_list|,
name|void
modifier|*
name|page
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xn_ifmedia_upd
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xn_ifmedia_sts
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|ifmediareq
modifier|*
name|ifmr
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Xenolinux helper functions */
end_comment

begin_function_decl
name|int
name|network_connect
parameter_list|(
name|struct
name|netfront_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xn_free_rx_ring
parameter_list|(
name|struct
name|netfront_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xn_free_tx_ring
parameter_list|(
name|struct
name|netfront_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xennet_get_responses
parameter_list|(
name|struct
name|netfront_info
modifier|*
name|np
parameter_list|,
name|struct
name|netfront_rx_info
modifier|*
name|rinfo
parameter_list|,
name|RING_IDX
name|rp
parameter_list|,
name|RING_IDX
modifier|*
name|cons
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|list
parameter_list|,
name|int
modifier|*
name|pages_flipped_p
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|virt_to_mfn
parameter_list|(
name|x
parameter_list|)
value|(vtomach(x)>> PAGE_SHIFT)
end_define

begin_define
define|#
directive|define
name|INVALID_P2M_ENTRY
value|(~0UL)
end_define

begin_comment
comment|/*  * Mbuf pointers. We need these to keep track of the virtual addresses  * of our mbuf chains since we can only convert from virtual to physical,  * not the other way around.  The size must track the free index arrays.  */
end_comment

begin_struct
struct|struct
name|xn_chain_data
block|{
name|struct
name|mbuf
modifier|*
name|xn_tx_chain
index|[
name|NET_TX_RING_SIZE
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|xn_tx_chain_cnt
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|xn_rx_chain
index|[
name|NET_RX_RING_SIZE
operator|+
literal|1
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|NUM_ELEMENTS
parameter_list|(
name|x
parameter_list|)
value|(sizeof(x)/sizeof(*x))
end_define

begin_struct
struct|struct
name|net_device_stats
block|{
name|u_long
name|rx_packets
decl_stmt|;
comment|/* total packets received	*/
name|u_long
name|tx_packets
decl_stmt|;
comment|/* total packets transmitted	*/
name|u_long
name|rx_bytes
decl_stmt|;
comment|/* total bytes received 	*/
name|u_long
name|tx_bytes
decl_stmt|;
comment|/* total bytes transmitted	*/
name|u_long
name|rx_errors
decl_stmt|;
comment|/* bad packets received		*/
name|u_long
name|tx_errors
decl_stmt|;
comment|/* packet transmit problems	*/
name|u_long
name|rx_dropped
decl_stmt|;
comment|/* no space in linux buffers	*/
name|u_long
name|tx_dropped
decl_stmt|;
comment|/* no space available in linux	*/
name|u_long
name|multicast
decl_stmt|;
comment|/* multicast packets received	*/
name|u_long
name|collisions
decl_stmt|;
comment|/* detailed rx_errors: */
name|u_long
name|rx_length_errors
decl_stmt|;
name|u_long
name|rx_over_errors
decl_stmt|;
comment|/* receiver ring buff overflow	*/
name|u_long
name|rx_crc_errors
decl_stmt|;
comment|/* recved pkt with crc error	*/
name|u_long
name|rx_frame_errors
decl_stmt|;
comment|/* recv'd frame alignment error */
name|u_long
name|rx_fifo_errors
decl_stmt|;
comment|/* recv'r fifo overrun		*/
name|u_long
name|rx_missed_errors
decl_stmt|;
comment|/* receiver missed packet	*/
comment|/* detailed tx_errors */
name|u_long
name|tx_aborted_errors
decl_stmt|;
name|u_long
name|tx_carrier_errors
decl_stmt|;
name|u_long
name|tx_fifo_errors
decl_stmt|;
name|u_long
name|tx_heartbeat_errors
decl_stmt|;
name|u_long
name|tx_window_errors
decl_stmt|;
comment|/* for cslip etc */
name|u_long
name|rx_compressed
decl_stmt|;
name|u_long
name|tx_compressed
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|netfront_info
block|{
name|struct
name|ifnet
modifier|*
name|xn_ifp
decl_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|700000
name|struct
name|lro_ctrl
name|xn_lro
decl_stmt|;
endif|#
directive|endif
name|struct
name|net_device_stats
name|stats
decl_stmt|;
name|u_int
name|tx_full
decl_stmt|;
name|netif_tx_front_ring_t
name|tx
decl_stmt|;
name|netif_rx_front_ring_t
name|rx
decl_stmt|;
name|struct
name|mtx
name|tx_lock
decl_stmt|;
name|struct
name|mtx
name|rx_lock
decl_stmt|;
name|struct
name|mtx
name|sc_lock
decl_stmt|;
name|u_int
name|handle
decl_stmt|;
name|u_int
name|irq
decl_stmt|;
name|u_int
name|copying_receiver
decl_stmt|;
name|u_int
name|carrier
decl_stmt|;
comment|/* Receive-ring batched refills. */
define|#
directive|define
name|RX_MIN_TARGET
value|32
define|#
directive|define
name|RX_MAX_TARGET
value|NET_RX_RING_SIZE
name|int
name|rx_min_target
decl_stmt|;
name|int
name|rx_max_target
decl_stmt|;
name|int
name|rx_target
decl_stmt|;
name|grant_ref_t
name|gref_tx_head
decl_stmt|;
name|grant_ref_t
name|grant_tx_ref
index|[
name|NET_TX_RING_SIZE
operator|+
literal|1
index|]
decl_stmt|;
name|grant_ref_t
name|gref_rx_head
decl_stmt|;
name|grant_ref_t
name|grant_rx_ref
index|[
name|NET_TX_RING_SIZE
operator|+
literal|1
index|]
decl_stmt|;
name|device_t
name|xbdev
decl_stmt|;
name|int
name|tx_ring_ref
decl_stmt|;
name|int
name|rx_ring_ref
decl_stmt|;
name|uint8_t
name|mac
index|[
name|ETHER_ADDR_LEN
index|]
decl_stmt|;
name|struct
name|xn_chain_data
name|xn_cdata
decl_stmt|;
comment|/* mbufs */
name|struct
name|mbuf_head
name|xn_rx_batch
decl_stmt|;
comment|/* head of the batch queue */
name|int
name|xn_if_flags
decl_stmt|;
name|struct
name|callout
name|xn_stat_ch
decl_stmt|;
name|u_long
name|rx_pfn_array
index|[
name|NET_RX_RING_SIZE
index|]
decl_stmt|;
name|multicall_entry_t
name|rx_mcl
index|[
name|NET_RX_RING_SIZE
operator|+
literal|1
index|]
decl_stmt|;
name|mmu_update_t
name|rx_mmu
index|[
name|NET_RX_RING_SIZE
index|]
decl_stmt|;
name|struct
name|ifmedia
name|sc_media
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|rx_mbufs
value|xn_cdata.xn_rx_chain
end_define

begin_define
define|#
directive|define
name|tx_mbufs
value|xn_cdata.xn_tx_chain
end_define

begin_define
define|#
directive|define
name|XN_LOCK_INIT
parameter_list|(
name|_sc
parameter_list|,
name|_name
parameter_list|)
define|\
value|mtx_init(&(_sc)->tx_lock, #_name"_tx", "network transmit lock", MTX_DEF); \         mtx_init(&(_sc)->rx_lock, #_name"_rx", "network receive lock", MTX_DEF);  \         mtx_init(&(_sc)->sc_lock, #_name"_sc", "netfront softc lock", MTX_DEF)
end_define

begin_define
define|#
directive|define
name|XN_RX_LOCK
parameter_list|(
name|_sc
parameter_list|)
value|mtx_lock(&(_sc)->rx_lock)
end_define

begin_define
define|#
directive|define
name|XN_RX_UNLOCK
parameter_list|(
name|_sc
parameter_list|)
value|mtx_unlock(&(_sc)->rx_lock)
end_define

begin_define
define|#
directive|define
name|XN_TX_LOCK
parameter_list|(
name|_sc
parameter_list|)
value|mtx_lock(&(_sc)->tx_lock)
end_define

begin_define
define|#
directive|define
name|XN_TX_UNLOCK
parameter_list|(
name|_sc
parameter_list|)
value|mtx_unlock(&(_sc)->tx_lock)
end_define

begin_define
define|#
directive|define
name|XN_LOCK
parameter_list|(
name|_sc
parameter_list|)
value|mtx_lock(&(_sc)->sc_lock);
end_define

begin_define
define|#
directive|define
name|XN_UNLOCK
parameter_list|(
name|_sc
parameter_list|)
value|mtx_unlock(&(_sc)->sc_lock);
end_define

begin_define
define|#
directive|define
name|XN_LOCK_ASSERT
parameter_list|(
name|_sc
parameter_list|)
value|mtx_assert(&(_sc)->sc_lock, MA_OWNED);
end_define

begin_define
define|#
directive|define
name|XN_RX_LOCK_ASSERT
parameter_list|(
name|_sc
parameter_list|)
value|mtx_assert(&(_sc)->rx_lock, MA_OWNED);
end_define

begin_define
define|#
directive|define
name|XN_TX_LOCK_ASSERT
parameter_list|(
name|_sc
parameter_list|)
value|mtx_assert(&(_sc)->tx_lock, MA_OWNED);
end_define

begin_define
define|#
directive|define
name|XN_LOCK_DESTROY
parameter_list|(
name|_sc
parameter_list|)
value|mtx_destroy(&(_sc)->rx_lock); \                                mtx_destroy(&(_sc)->tx_lock); \                                mtx_destroy(&(_sc)->sc_lock);
end_define

begin_struct
struct|struct
name|netfront_rx_info
block|{
name|struct
name|netif_rx_response
name|rx
decl_stmt|;
name|struct
name|netif_extra_info
name|extras
index|[
name|XEN_NETIF_EXTRA_TYPE_MAX
operator|-
literal|1
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|netfront_carrier_on
parameter_list|(
name|netif
parameter_list|)
value|((netif)->carrier = 1)
end_define

begin_define
define|#
directive|define
name|netfront_carrier_off
parameter_list|(
name|netif
parameter_list|)
value|((netif)->carrier = 0)
end_define

begin_define
define|#
directive|define
name|netfront_carrier_ok
parameter_list|(
name|netif
parameter_list|)
value|((netif)->carrier)
end_define

begin_comment
comment|/* Access macros for acquiring freeing slots in xn_free_{tx,rx}_idxs[]. */
end_comment

begin_comment
comment|/*  * Access macros for acquiring freeing slots in tx_skbs[].  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|add_id_to_freelist
parameter_list|(
name|struct
name|mbuf
modifier|*
modifier|*
name|list
parameter_list|,
name|uintptr_t
name|id
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|id
operator|!=
literal|0
argument_list|,
operator|(
literal|"%s: the head item (0) must always be free."
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|list
index|[
name|id
index|]
operator|=
name|list
index|[
literal|0
index|]
expr_stmt|;
name|list
index|[
literal|0
index|]
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
name|id
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|unsigned
name|short
name|get_id_from_freelist
parameter_list|(
name|struct
name|mbuf
modifier|*
modifier|*
name|list
parameter_list|)
block|{
name|uintptr_t
name|id
decl_stmt|;
name|id
operator|=
operator|(
name|uintptr_t
operator|)
name|list
index|[
literal|0
index|]
expr_stmt|;
name|KASSERT
argument_list|(
name|id
operator|!=
literal|0
argument_list|,
operator|(
literal|"%s: the head item (0) must always remain free."
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|list
index|[
literal|0
index|]
operator|=
name|list
index|[
name|id
index|]
expr_stmt|;
return|return
operator|(
name|id
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|xennet_rxidx
parameter_list|(
name|RING_IDX
name|idx
parameter_list|)
block|{
return|return
name|idx
operator|&
operator|(
name|NET_RX_RING_SIZE
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|struct
name|mbuf
modifier|*
name|xennet_get_rx_mbuf
parameter_list|(
name|struct
name|netfront_info
modifier|*
name|np
parameter_list|,
name|RING_IDX
name|ri
parameter_list|)
block|{
name|int
name|i
init|=
name|xennet_rxidx
argument_list|(
name|ri
argument_list|)
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|m
operator|=
name|np
operator|->
name|rx_mbufs
index|[
name|i
index|]
expr_stmt|;
name|np
operator|->
name|rx_mbufs
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|grant_ref_t
name|xennet_get_rx_ref
parameter_list|(
name|struct
name|netfront_info
modifier|*
name|np
parameter_list|,
name|RING_IDX
name|ri
parameter_list|)
block|{
name|int
name|i
init|=
name|xennet_rxidx
argument_list|(
name|ri
argument_list|)
decl_stmt|;
name|grant_ref_t
name|ref
init|=
name|np
operator|->
name|grant_rx_ref
index|[
name|i
index|]
decl_stmt|;
name|KASSERT
argument_list|(
name|ref
operator|!=
name|GRANT_REF_INVALID
argument_list|,
operator|(
literal|"Invalid grant reference!\n"
operator|)
argument_list|)
expr_stmt|;
name|np
operator|->
name|grant_rx_ref
index|[
name|i
index|]
operator|=
name|GRANT_REF_INVALID
expr_stmt|;
return|return
name|ref
return|;
block|}
end_function

begin_define
define|#
directive|define
name|IPRINTK
parameter_list|(
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
define|\
value|printf("[XEN] " fmt, ##args)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|INVARIANTS
end_ifdef

begin_define
define|#
directive|define
name|WPRINTK
parameter_list|(
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
define|\
value|printf("[XEN] " fmt, ##args)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|WPRINTK
parameter_list|(
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_define
define|#
directive|define
name|DPRINTK
parameter_list|(
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
define|\
value|printf("[XEN] %s: " fmt, __func__, ##args)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DPRINTK
parameter_list|(
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * Read the 'mac' node at the given device's node in the store, and parse that  * as colon-separated octets, placing result the given mac array.  mac must be  * a preallocated array of length ETH_ALEN (as declared in linux/if_ether.h).  * Return 0 on success, or errno on error.  */
end_comment

begin_function
specifier|static
name|int
name|xen_net_read_mac
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|uint8_t
name|mac
index|[]
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|e
decl_stmt|,
modifier|*
name|macstr
decl_stmt|;
name|error
operator|=
name|xs_read
argument_list|(
name|XST_NIL
argument_list|,
name|xenbus_get_node
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|"mac"
argument_list|,
name|NULL
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|macstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|s
operator|=
name|macstr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ETHER_ADDR_LEN
condition|;
name|i
operator|++
control|)
block|{
name|mac
index|[
name|i
index|]
operator|=
name|strtoul
argument_list|(
name|s
argument_list|,
operator|&
name|e
argument_list|,
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|e
operator|||
operator|(
name|e
index|[
literal|0
index|]
operator|!=
literal|':'
operator|&&
name|e
index|[
literal|0
index|]
operator|!=
literal|0
operator|)
condition|)
block|{
name|free
argument_list|(
name|macstr
argument_list|,
name|M_XENBUS
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
name|s
operator|=
operator|&
name|e
index|[
literal|1
index|]
expr_stmt|;
block|}
name|free
argument_list|(
name|macstr
argument_list|,
name|M_XENBUS
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Entry point to this code when a new device is created.  Allocate the basic  * structures and the ring buffers for communication with the backend, and  * inform the backend of the appropriate details for those.  Switch to  * Connected state.  */
end_comment

begin_function
specifier|static
name|int
name|netfront_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|xenbus_get_type
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|"vif"
argument_list|)
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Virtual Network Interface"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|netfront_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|err
operator|=
name|create_netdev
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|xenbus_dev_fatal
argument_list|(
name|dev
argument_list|,
name|err
argument_list|,
literal|"creating netdev"
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|700000
name|SYSCTL_ADD_INT
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"enable_lro"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|xn_enable_lro
argument_list|,
literal|0
argument_list|,
literal|"Large Receive Offload"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * We are reconnecting to the backend, due to a suspend/resume, or a backend  * driver restart.  We tear down our netif structure and recreate it, but  * leave the device-layer structures intact so that this is transparent to the  * rest of the kernel.  */
end_comment

begin_function
specifier|static
name|int
name|netfront_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|netfront_info
modifier|*
name|info
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|netif_disconnect_backend
argument_list|(
name|info
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Common code used when first setting up, and when resuming. */
end_comment

begin_function
specifier|static
name|int
name|talk_to_backend
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|netfront_info
modifier|*
name|info
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|message
decl_stmt|;
name|struct
name|xs_transaction
name|xst
decl_stmt|;
specifier|const
name|char
modifier|*
name|node
init|=
name|xenbus_get_node
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|err
decl_stmt|;
name|err
operator|=
name|xen_net_read_mac
argument_list|(
name|dev
argument_list|,
name|info
operator|->
name|mac
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|xenbus_dev_fatal
argument_list|(
name|dev
argument_list|,
name|err
argument_list|,
literal|"parsing %s/mac"
argument_list|,
name|node
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Create shared ring, alloc event channel. */
name|err
operator|=
name|setup_device
argument_list|(
name|dev
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
name|again
label|:
name|err
operator|=
name|xs_transaction_start
argument_list|(
operator|&
name|xst
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|xenbus_dev_fatal
argument_list|(
name|dev
argument_list|,
name|err
argument_list|,
literal|"starting transaction"
argument_list|)
expr_stmt|;
goto|goto
name|destroy_ring
goto|;
block|}
name|err
operator|=
name|xs_printf
argument_list|(
name|xst
argument_list|,
name|node
argument_list|,
literal|"tx-ring-ref"
argument_list|,
literal|"%u"
argument_list|,
name|info
operator|->
name|tx_ring_ref
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|message
operator|=
literal|"writing tx ring-ref"
expr_stmt|;
goto|goto
name|abort_transaction
goto|;
block|}
name|err
operator|=
name|xs_printf
argument_list|(
name|xst
argument_list|,
name|node
argument_list|,
literal|"rx-ring-ref"
argument_list|,
literal|"%u"
argument_list|,
name|info
operator|->
name|rx_ring_ref
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|message
operator|=
literal|"writing rx ring-ref"
expr_stmt|;
goto|goto
name|abort_transaction
goto|;
block|}
name|err
operator|=
name|xs_printf
argument_list|(
name|xst
argument_list|,
name|node
argument_list|,
literal|"event-channel"
argument_list|,
literal|"%u"
argument_list|,
name|irq_to_evtchn_port
argument_list|(
name|info
operator|->
name|irq
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|message
operator|=
literal|"writing event-channel"
expr_stmt|;
goto|goto
name|abort_transaction
goto|;
block|}
name|err
operator|=
name|xs_printf
argument_list|(
name|xst
argument_list|,
name|node
argument_list|,
literal|"request-rx-copy"
argument_list|,
literal|"%u"
argument_list|,
name|info
operator|->
name|copying_receiver
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|message
operator|=
literal|"writing request-rx-copy"
expr_stmt|;
goto|goto
name|abort_transaction
goto|;
block|}
name|err
operator|=
name|xs_printf
argument_list|(
name|xst
argument_list|,
name|node
argument_list|,
literal|"feature-rx-notify"
argument_list|,
literal|"%d"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|message
operator|=
literal|"writing feature-rx-notify"
expr_stmt|;
goto|goto
name|abort_transaction
goto|;
block|}
name|err
operator|=
name|xs_printf
argument_list|(
name|xst
argument_list|,
name|node
argument_list|,
literal|"feature-sg"
argument_list|,
literal|"%d"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|message
operator|=
literal|"writing feature-sg"
expr_stmt|;
goto|goto
name|abort_transaction
goto|;
block|}
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|700000
name|err
operator|=
name|xs_printf
argument_list|(
name|xst
argument_list|,
name|node
argument_list|,
literal|"feature-gso-tcpv4"
argument_list|,
literal|"%d"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|message
operator|=
literal|"writing feature-gso-tcpv4"
expr_stmt|;
goto|goto
name|abort_transaction
goto|;
block|}
endif|#
directive|endif
name|err
operator|=
name|xs_transaction_end
argument_list|(
name|xst
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|==
name|EAGAIN
condition|)
goto|goto
name|again
goto|;
name|xenbus_dev_fatal
argument_list|(
name|dev
argument_list|,
name|err
argument_list|,
literal|"completing transaction"
argument_list|)
expr_stmt|;
goto|goto
name|destroy_ring
goto|;
block|}
return|return
literal|0
return|;
name|abort_transaction
label|:
name|xs_transaction_end
argument_list|(
name|xst
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xenbus_dev_fatal
argument_list|(
name|dev
argument_list|,
name|err
argument_list|,
literal|"%s"
argument_list|,
name|message
argument_list|)
expr_stmt|;
name|destroy_ring
label|:
name|netif_free
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|setup_device
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|netfront_info
modifier|*
name|info
parameter_list|)
block|{
name|netif_tx_sring_t
modifier|*
name|txs
decl_stmt|;
name|netif_rx_sring_t
modifier|*
name|rxs
decl_stmt|;
name|int
name|error
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|ifp
operator|=
name|info
operator|->
name|xn_ifp
expr_stmt|;
name|info
operator|->
name|tx_ring_ref
operator|=
name|GRANT_REF_INVALID
expr_stmt|;
name|info
operator|->
name|rx_ring_ref
operator|=
name|GRANT_REF_INVALID
expr_stmt|;
name|info
operator|->
name|rx
operator|.
name|sring
operator|=
name|NULL
expr_stmt|;
name|info
operator|->
name|tx
operator|.
name|sring
operator|=
name|NULL
expr_stmt|;
name|info
operator|->
name|irq
operator|=
literal|0
expr_stmt|;
name|txs
operator|=
operator|(
name|netif_tx_sring_t
operator|*
operator|)
name|malloc
argument_list|(
name|PAGE_SIZE
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|txs
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
name|xenbus_dev_fatal
argument_list|(
name|dev
argument_list|,
name|error
argument_list|,
literal|"allocating tx ring page"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|SHARED_RING_INIT
argument_list|(
name|txs
argument_list|)
expr_stmt|;
name|FRONT_RING_INIT
argument_list|(
operator|&
name|info
operator|->
name|tx
argument_list|,
name|txs
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|error
operator|=
name|xenbus_grant_ring
argument_list|(
name|dev
argument_list|,
name|virt_to_mfn
argument_list|(
name|txs
argument_list|)
argument_list|,
operator|&
name|info
operator|->
name|tx_ring_ref
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|fail
goto|;
name|rxs
operator|=
operator|(
name|netif_rx_sring_t
operator|*
operator|)
name|malloc
argument_list|(
name|PAGE_SIZE
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rxs
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
name|xenbus_dev_fatal
argument_list|(
name|dev
argument_list|,
name|error
argument_list|,
literal|"allocating rx ring page"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|SHARED_RING_INIT
argument_list|(
name|rxs
argument_list|)
expr_stmt|;
name|FRONT_RING_INIT
argument_list|(
operator|&
name|info
operator|->
name|rx
argument_list|,
name|rxs
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|error
operator|=
name|xenbus_grant_ring
argument_list|(
name|dev
argument_list|,
name|virt_to_mfn
argument_list|(
name|rxs
argument_list|)
argument_list|,
operator|&
name|info
operator|->
name|rx_ring_ref
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|fail
goto|;
name|error
operator|=
name|bind_listening_port_to_irqhandler
argument_list|(
name|xenbus_get_otherend_id
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|"xn"
argument_list|,
name|xn_intr
argument_list|,
name|info
argument_list|,
name|INTR_TYPE_NET
operator||
name|INTR_MPSAFE
argument_list|,
operator|&
name|info
operator|->
name|irq
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|xenbus_dev_fatal
argument_list|(
name|dev
argument_list|,
name|error
argument_list|,
literal|"bind_evtchn_to_irqhandler failed"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|show_device
argument_list|(
name|info
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail
label|:
name|netif_free
argument_list|(
name|info
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * If this interface has an ipv4 address, send an arp for it. This  * helps to get the network going again after migrating hosts.  */
end_comment

begin_function
specifier|static
name|void
name|netfront_send_fake_arp
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|netfront_info
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|ifaddr
modifier|*
name|ifa
decl_stmt|;
name|ifp
operator|=
name|info
operator|->
name|xn_ifp
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ifa
argument_list|,
argument|&ifp->if_addrhead
argument_list|,
argument|ifa_link
argument_list|)
block|{
if|if
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
name|arp_ifinit
argument_list|(
name|ifp
argument_list|,
name|ifa
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/**  * Callback received when the backend's state changes.  */
end_comment

begin_function
specifier|static
name|int
name|netfront_backend_changed
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|XenbusState
name|newstate
parameter_list|)
block|{
name|struct
name|netfront_info
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|DPRINTK
argument_list|(
literal|"newstate=%d\n"
argument_list|,
name|newstate
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|newstate
condition|)
block|{
case|case
name|XenbusStateInitialising
case|:
case|case
name|XenbusStateInitialised
case|:
case|case
name|XenbusStateConnected
case|:
case|case
name|XenbusStateUnknown
case|:
case|case
name|XenbusStateClosed
case|:
case|case
name|XenbusStateReconfigured
case|:
case|case
name|XenbusStateReconfiguring
case|:
break|break;
case|case
name|XenbusStateInitWait
case|:
if|if
condition|(
name|xenbus_get_state
argument_list|(
name|dev
argument_list|)
operator|!=
name|XenbusStateInitialising
condition|)
break|break;
if|if
condition|(
name|network_connect
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
break|break;
name|xenbus_set_state
argument_list|(
name|dev
argument_list|,
name|XenbusStateConnected
argument_list|)
expr_stmt|;
name|netfront_send_fake_arp
argument_list|(
name|dev
argument_list|,
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|XenbusStateClosing
case|:
name|xenbus_set_state
argument_list|(
name|dev
argument_list|,
name|XenbusStateClosed
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xn_free_rx_ring
parameter_list|(
name|struct
name|netfront_info
modifier|*
name|sc
parameter_list|)
block|{
if|#
directive|if
literal|0
block|int i; 	 	for (i = 0; i< NET_RX_RING_SIZE; i++) { 		if (sc->xn_cdata.rx_mbufs[i] != NULL) { 			m_freem(sc->rx_mbufs[i]); 			sc->rx_mbufs[i] = NULL; 		} 	} 	 	sc->rx.rsp_cons = 0; 	sc->xn_rx_if->req_prod = 0; 	sc->xn_rx_if->event = sc->rx.rsp_cons ;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|xn_free_tx_ring
parameter_list|(
name|struct
name|netfront_info
modifier|*
name|sc
parameter_list|)
block|{
if|#
directive|if
literal|0
block|int i; 	 	for (i = 0; i< NET_TX_RING_SIZE; i++) { 		if (sc->tx_mbufs[i] != NULL) { 			m_freem(sc->tx_mbufs[i]); 			sc->xn_cdata.xn_tx_chain[i] = NULL; 		} 	} 	 	return;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/**  * \brief Verify that there is sufficient space in the Tx ring  *        buffer for a maximally sized request to be enqueued.  *  * A transmit request requires a transmit descriptor for each packet  * fragment, plus up to 2 entries for "options" (e.g. TSO).  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|xn_tx_slot_available
parameter_list|(
name|struct
name|netfront_info
modifier|*
name|np
parameter_list|)
block|{
return|return
operator|(
name|RING_FREE_REQUESTS
argument_list|(
operator|&
name|np
operator|->
name|tx
argument_list|)
operator|>
operator|(
name|MAX_TX_REQ_FRAGS
operator|+
literal|2
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|netif_release_tx_bufs
parameter_list|(
name|struct
name|netfront_info
modifier|*
name|np
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|NET_TX_RING_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|m
operator|=
name|np
operator|->
name|tx_mbufs
index|[
name|i
index|]
expr_stmt|;
comment|/* 		 * We assume that no kernel addresses are 		 * less than NET_TX_RING_SIZE.  Any entry 		 * in the table that is below this number 		 * must be an index from free-list tracking. 		 */
if|if
condition|(
operator|(
operator|(
name|uintptr_t
operator|)
name|m
operator|)
operator|<=
name|NET_TX_RING_SIZE
condition|)
continue|continue;
name|gnttab_grant_foreign_access_ref
argument_list|(
name|np
operator|->
name|grant_tx_ref
index|[
name|i
index|]
argument_list|,
name|xenbus_get_otherend_id
argument_list|(
name|np
operator|->
name|xbdev
argument_list|)
argument_list|,
name|virt_to_mfn
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|vm_offset_t
argument_list|)
argument_list|)
argument_list|,
name|GNTMAP_readonly
argument_list|)
expr_stmt|;
name|gnttab_release_grant_reference
argument_list|(
operator|&
name|np
operator|->
name|gref_tx_head
argument_list|,
name|np
operator|->
name|grant_tx_ref
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|np
operator|->
name|grant_tx_ref
index|[
name|i
index|]
operator|=
name|GRANT_REF_INVALID
expr_stmt|;
name|add_id_to_freelist
argument_list|(
name|np
operator|->
name|tx_mbufs
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|np
operator|->
name|xn_cdata
operator|.
name|xn_tx_chain_cnt
operator|--
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|xn_cdata
operator|.
name|xn_tx_chain_cnt
operator|<
literal|0
condition|)
block|{
name|panic
argument_list|(
literal|"netif_release_tx_bufs: tx_chain_cnt must be>= 0"
argument_list|)
expr_stmt|;
block|}
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|network_alloc_rx_buffers
parameter_list|(
name|struct
name|netfront_info
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|otherend_id
init|=
name|xenbus_get_otherend_id
argument_list|(
name|sc
operator|->
name|xbdev
argument_list|)
decl_stmt|;
name|unsigned
name|short
name|id
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m_new
decl_stmt|;
name|int
name|i
decl_stmt|,
name|batch_target
decl_stmt|,
name|notify
decl_stmt|;
name|RING_IDX
name|req_prod
decl_stmt|;
name|struct
name|xen_memory_reservation
name|reservation
decl_stmt|;
name|grant_ref_t
name|ref
decl_stmt|;
name|int
name|nr_flips
decl_stmt|;
name|netif_rx_request_t
modifier|*
name|req
decl_stmt|;
name|vm_offset_t
name|vaddr
decl_stmt|;
name|u_long
name|pfn
decl_stmt|;
name|req_prod
operator|=
name|sc
operator|->
name|rx
operator|.
name|req_prod_pvt
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|sc
operator|->
name|carrier
operator|==
literal|0
argument_list|)
condition|)
return|return;
comment|/* 	 * Allocate mbufs greedily, even though we batch updates to the 	 * receive ring. This creates a less bursty demand on the memory 	 * allocator, and so should reduce the chance of failed allocation 	 * requests both for ourself and for other kernel subsystems. 	 * 	 * Here we attempt to maintain rx_target buffers in flight, counting 	 * buffers that we have yet to process in the receive ring. 	 */
name|batch_target
operator|=
name|sc
operator|->
name|rx_target
operator|-
operator|(
name|req_prod
operator|-
name|sc
operator|->
name|rx
operator|.
name|rsp_cons
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|mbufq_len
argument_list|(
operator|&
name|sc
operator|->
name|xn_rx_batch
argument_list|)
init|;
name|i
operator|<
name|batch_target
condition|;
name|i
operator|++
control|)
block|{
name|MGETHDR
argument_list|(
name|m_new
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_new
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: MGETHDR failed\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|no_mbuf
goto|;
block|}
name|m_cljget
argument_list|(
name|m_new
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MJUMPAGESIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m_new
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: m_cljget failed\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m_new
argument_list|)
expr_stmt|;
name|no_mbuf
label|:
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
goto|goto
name|refill
goto|;
comment|/* 			 * XXX set timer 			 */
break|break;
block|}
name|m_new
operator|->
name|m_len
operator|=
name|m_new
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|MJUMPAGESIZE
expr_stmt|;
comment|/* queue the mbufs allocated */
name|mbufq_tail
argument_list|(
operator|&
name|sc
operator|->
name|xn_rx_batch
argument_list|,
name|m_new
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If we've allocated at least half of our target number of entries, 	 * submit them to the backend - we have enough to make the overhead 	 * of submission worthwhile.  Otherwise wait for more mbufs and 	 * request entries to become available. 	 */
if|if
condition|(
name|i
operator|<
operator|(
name|sc
operator|->
name|rx_target
operator|/
literal|2
operator|)
condition|)
block|{
if|if
condition|(
name|req_prod
operator|>
name|sc
operator|->
name|rx
operator|.
name|sring
operator|->
name|req_prod
condition|)
goto|goto
name|push
goto|;
return|return;
block|}
comment|/* 	 * Double floating fill target if we risked having the backend 	 * run out of empty buffers for receive traffic.  We define "running 	 * low" as having less than a fourth of our target buffers free 	 * at the time we refilled the queue.  	 */
if|if
condition|(
operator|(
name|req_prod
operator|-
name|sc
operator|->
name|rx
operator|.
name|sring
operator|->
name|rsp_prod
operator|)
operator|<
operator|(
name|sc
operator|->
name|rx_target
operator|/
literal|4
operator|)
condition|)
block|{
name|sc
operator|->
name|rx_target
operator|*=
literal|2
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|rx_target
operator|>
name|sc
operator|->
name|rx_max_target
condition|)
name|sc
operator|->
name|rx_target
operator|=
name|sc
operator|->
name|rx_max_target
expr_stmt|;
block|}
name|refill
label|:
for|for
control|(
name|nr_flips
operator|=
name|i
operator|=
literal|0
init|;
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|m_new
operator|=
name|mbufq_dequeue
argument_list|(
operator|&
name|sc
operator|->
name|xn_rx_batch
argument_list|)
operator|)
operator|==
name|NULL
condition|)
break|break;
name|m_new
operator|->
name|m_ext
operator|.
name|ext_arg1
operator|=
operator|(
name|vm_paddr_t
operator|*
operator|)
call|(
name|uintptr_t
call|)
argument_list|(
name|vtophys
argument_list|(
name|m_new
operator|->
name|m_ext
operator|.
name|ext_buf
argument_list|)
operator|>>
name|PAGE_SHIFT
argument_list|)
expr_stmt|;
name|id
operator|=
name|xennet_rxidx
argument_list|(
name|req_prod
operator|+
name|i
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|rx_mbufs
index|[
name|id
index|]
operator|==
name|NULL
argument_list|,
operator|(
literal|"non-NULL xm_rx_chain"
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rx_mbufs
index|[
name|id
index|]
operator|=
name|m_new
expr_stmt|;
name|ref
operator|=
name|gnttab_claim_grant_reference
argument_list|(
operator|&
name|sc
operator|->
name|gref_rx_head
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ref
operator|!=
name|GNTTAB_LIST_END
argument_list|,
operator|(
literal|"reserved grant references exhuasted"
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|grant_rx_ref
index|[
name|id
index|]
operator|=
name|ref
expr_stmt|;
name|vaddr
operator|=
name|mtod
argument_list|(
name|m_new
argument_list|,
name|vm_offset_t
argument_list|)
expr_stmt|;
name|pfn
operator|=
name|vtophys
argument_list|(
name|vaddr
argument_list|)
operator|>>
name|PAGE_SHIFT
expr_stmt|;
name|req
operator|=
name|RING_GET_REQUEST
argument_list|(
operator|&
name|sc
operator|->
name|rx
argument_list|,
name|req_prod
operator|+
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|copying_receiver
operator|==
literal|0
condition|)
block|{
name|gnttab_grant_foreign_transfer_ref
argument_list|(
name|ref
argument_list|,
name|otherend_id
argument_list|,
name|pfn
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rx_pfn_array
index|[
name|nr_flips
index|]
operator|=
name|PFNTOMFN
argument_list|(
name|pfn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xen_feature
argument_list|(
name|XENFEAT_auto_translated_physmap
argument_list|)
condition|)
block|{
comment|/* Remove this page before passing 				 * back to Xen. 				 */
name|set_phys_to_machine
argument_list|(
name|pfn
argument_list|,
name|INVALID_P2M_ENTRY
argument_list|)
expr_stmt|;
name|MULTI_update_va_mapping
argument_list|(
operator|&
name|sc
operator|->
name|rx_mcl
index|[
name|i
index|]
argument_list|,
name|vaddr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|nr_flips
operator|++
expr_stmt|;
block|}
else|else
block|{
name|gnttab_grant_foreign_access_ref
argument_list|(
name|ref
argument_list|,
name|otherend_id
argument_list|,
name|PFNTOMFN
argument_list|(
name|pfn
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|req
operator|->
name|id
operator|=
name|id
expr_stmt|;
name|req
operator|->
name|gref
operator|=
name|ref
expr_stmt|;
name|sc
operator|->
name|rx_pfn_array
index|[
name|i
index|]
operator|=
name|vtomach
argument_list|(
name|mtod
argument_list|(
name|m_new
argument_list|,
name|vm_offset_t
argument_list|)
argument_list|)
operator|>>
name|PAGE_SHIFT
expr_stmt|;
block|}
name|KASSERT
argument_list|(
name|i
argument_list|,
operator|(
literal|"no mbufs processed"
operator|)
argument_list|)
expr_stmt|;
comment|/* should have returned earlier */
name|KASSERT
argument_list|(
name|mbufq_len
argument_list|(
operator|&
name|sc
operator|->
name|xn_rx_batch
argument_list|)
operator|==
literal|0
argument_list|,
operator|(
literal|"not all mbufs processed"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * We may have allocated buffers which have entries outstanding 	 * in the page * update queue -- make sure we flush those first! 	 */
name|PT_UPDATES_FLUSH
argument_list|()
expr_stmt|;
if|if
condition|(
name|nr_flips
operator|!=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|notyet
comment|/* Tell the ballon driver what is going on. */
name|balloon_update_driver_allowance
argument_list|(
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|set_xen_guest_handle
argument_list|(
name|reservation
operator|.
name|extent_start
argument_list|,
name|sc
operator|->
name|rx_pfn_array
argument_list|)
expr_stmt|;
name|reservation
operator|.
name|nr_extents
operator|=
name|i
expr_stmt|;
name|reservation
operator|.
name|extent_order
operator|=
literal|0
expr_stmt|;
name|reservation
operator|.
name|address_bits
operator|=
literal|0
expr_stmt|;
name|reservation
operator|.
name|domid
operator|=
name|DOMID_SELF
expr_stmt|;
if|if
condition|(
operator|!
name|xen_feature
argument_list|(
name|XENFEAT_auto_translated_physmap
argument_list|)
condition|)
block|{
comment|/* After all PTEs have been zapped, flush the TLB. */
name|sc
operator|->
name|rx_mcl
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|args
index|[
name|MULTI_UVMFLAGS_INDEX
index|]
operator|=
name|UVMF_TLB_FLUSH
operator||
name|UVMF_ALL
expr_stmt|;
comment|/* Give away a batch of pages. */
name|sc
operator|->
name|rx_mcl
index|[
name|i
index|]
operator|.
name|op
operator|=
name|__HYPERVISOR_memory_op
expr_stmt|;
name|sc
operator|->
name|rx_mcl
index|[
name|i
index|]
operator|.
name|args
index|[
literal|0
index|]
operator|=
name|XENMEM_decrease_reservation
expr_stmt|;
name|sc
operator|->
name|rx_mcl
index|[
name|i
index|]
operator|.
name|args
index|[
literal|1
index|]
operator|=
operator|(
name|u_long
operator|)
operator|&
name|reservation
expr_stmt|;
comment|/* Zap PTEs and give away pages in one big multicall. */
operator|(
name|void
operator|)
name|HYPERVISOR_multicall
argument_list|(
name|sc
operator|->
name|rx_mcl
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Check return status of HYPERVISOR_dom_mem_op(). */
if|if
condition|(
name|unlikely
argument_list|(
name|sc
operator|->
name|rx_mcl
index|[
name|i
index|]
operator|.
name|result
operator|!=
name|i
argument_list|)
condition|)
name|panic
argument_list|(
literal|"Unable to reduce memory reservation\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|HYPERVISOR_memory_op
argument_list|(
name|XENMEM_decrease_reservation
argument_list|,
operator|&
name|reservation
argument_list|)
operator|!=
name|i
condition|)
name|panic
argument_list|(
literal|"Unable to reduce memory "
literal|"reservation\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|wmb
argument_list|()
expr_stmt|;
block|}
comment|/* Above is a suitable barrier to ensure backend will see requests. */
name|sc
operator|->
name|rx
operator|.
name|req_prod_pvt
operator|=
name|req_prod
operator|+
name|i
expr_stmt|;
name|push
label|:
name|RING_PUSH_REQUESTS_AND_CHECK_NOTIFY
argument_list|(
operator|&
name|sc
operator|->
name|rx
argument_list|,
name|notify
argument_list|)
expr_stmt|;
if|if
condition|(
name|notify
condition|)
name|notify_remote_via_irq
argument_list|(
name|sc
operator|->
name|irq
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xn_rxeof
parameter_list|(
name|struct
name|netfront_info
modifier|*
name|np
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|700000
name|struct
name|lro_ctrl
modifier|*
name|lro
init|=
operator|&
name|np
operator|->
name|xn_lro
decl_stmt|;
name|struct
name|lro_entry
modifier|*
name|queued
decl_stmt|;
endif|#
directive|endif
name|struct
name|netfront_rx_info
name|rinfo
decl_stmt|;
name|struct
name|netif_rx_response
modifier|*
name|rx
init|=
operator|&
name|rinfo
operator|.
name|rx
decl_stmt|;
name|struct
name|netif_extra_info
modifier|*
name|extras
init|=
name|rinfo
operator|.
name|extras
decl_stmt|;
name|RING_IDX
name|i
decl_stmt|,
name|rp
decl_stmt|;
name|multicall_entry_t
modifier|*
name|mcl
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|mbuf_head
name|rxq
decl_stmt|,
name|errq
decl_stmt|;
name|int
name|err
decl_stmt|,
name|pages_flipped
init|=
literal|0
decl_stmt|,
name|work_to_do
decl_stmt|;
do|do
block|{
name|XN_RX_LOCK_ASSERT
argument_list|(
name|np
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|netfront_carrier_ok
argument_list|(
name|np
argument_list|)
condition|)
return|return;
name|mbufq_init
argument_list|(
operator|&
name|errq
argument_list|)
expr_stmt|;
name|mbufq_init
argument_list|(
operator|&
name|rxq
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|np
operator|->
name|xn_ifp
expr_stmt|;
name|rp
operator|=
name|np
operator|->
name|rx
operator|.
name|sring
operator|->
name|rsp_prod
expr_stmt|;
name|rmb
argument_list|()
expr_stmt|;
comment|/* Ensure we see queued responses up to 'rp'. */
name|i
operator|=
name|np
operator|->
name|rx
operator|.
name|rsp_cons
expr_stmt|;
while|while
condition|(
operator|(
name|i
operator|!=
name|rp
operator|)
condition|)
block|{
name|memcpy
argument_list|(
name|rx
argument_list|,
name|RING_GET_RESPONSE
argument_list|(
operator|&
name|np
operator|->
name|rx
argument_list|,
name|i
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rx
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|extras
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|rinfo
operator|.
name|extras
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|=
name|NULL
expr_stmt|;
name|err
operator|=
name|xennet_get_responses
argument_list|(
name|np
argument_list|,
operator|&
name|rinfo
argument_list|,
name|rp
argument_list|,
operator|&
name|i
argument_list|,
operator|&
name|m
argument_list|,
operator|&
name|pages_flipped
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|err
argument_list|)
condition|)
block|{
if|if
condition|(
name|m
condition|)
name|mbufq_tail
argument_list|(
operator|&
name|errq
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|np
operator|->
name|stats
operator|.
name|rx_errors
operator|++
expr_stmt|;
continue|continue;
block|}
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
if|if
condition|(
name|rx
operator|->
name|flags
operator|&
name|NETRXF_data_validated
condition|)
block|{
comment|/* Tell the stack the checksums are okay */
comment|/* 				 * XXX this isn't necessarily the case - need to add 				 * check 				 */
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator||=
operator|(
name|CSUM_IP_CHECKED
operator||
name|CSUM_IP_VALID
operator||
name|CSUM_DATA_VALID
operator||
name|CSUM_PSEUDO_HDR
operator|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|=
literal|0xffff
expr_stmt|;
block|}
name|np
operator|->
name|stats
operator|.
name|rx_packets
operator|++
expr_stmt|;
name|np
operator|->
name|stats
operator|.
name|rx_bytes
operator|+=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|mbufq_tail
argument_list|(
operator|&
name|rxq
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|np
operator|->
name|rx
operator|.
name|rsp_cons
operator|=
name|i
expr_stmt|;
block|}
if|if
condition|(
name|pages_flipped
condition|)
block|{
comment|/* Some pages are no longer absent... */
ifdef|#
directive|ifdef
name|notyet
name|balloon_update_driver_allowance
argument_list|(
operator|-
name|pages_flipped
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Do all the remapping work, and M->P updates, in one big 			 * hypercall. 			 */
if|if
condition|(
operator|!
operator|!
name|xen_feature
argument_list|(
name|XENFEAT_auto_translated_physmap
argument_list|)
condition|)
block|{
name|mcl
operator|=
name|np
operator|->
name|rx_mcl
operator|+
name|pages_flipped
expr_stmt|;
name|mcl
operator|->
name|op
operator|=
name|__HYPERVISOR_mmu_update
expr_stmt|;
name|mcl
operator|->
name|args
index|[
literal|0
index|]
operator|=
operator|(
name|u_long
operator|)
name|np
operator|->
name|rx_mmu
expr_stmt|;
name|mcl
operator|->
name|args
index|[
literal|1
index|]
operator|=
name|pages_flipped
expr_stmt|;
name|mcl
operator|->
name|args
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|mcl
operator|->
name|args
index|[
literal|3
index|]
operator|=
name|DOMID_SELF
expr_stmt|;
operator|(
name|void
operator|)
name|HYPERVISOR_multicall
argument_list|(
name|np
operator|->
name|rx_mcl
argument_list|,
name|pages_flipped
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
while|while
condition|(
operator|(
name|m
operator|=
name|mbufq_dequeue
argument_list|(
operator|&
name|errq
argument_list|)
operator|)
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/*  		 * Process all the mbufs after the remapping is complete. 		 * Break the mbuf chain first though. 		 */
while|while
condition|(
operator|(
name|m
operator|=
name|mbufq_dequeue
argument_list|(
operator|&
name|rxq
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|ifp
operator|->
name|if_ipackets
operator|++
expr_stmt|;
comment|/* 			 * Do we really need to drop the rx lock? 			 */
name|XN_RX_UNLOCK
argument_list|(
name|np
argument_list|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|700000
comment|/* Use LRO if possible */
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_LRO
operator|)
operator|==
literal|0
operator|||
name|lro
operator|->
name|lro_cnt
operator|==
literal|0
operator|||
name|tcp_lro_rx
argument_list|(
name|lro
argument_list|,
name|m
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|/* 				 * If LRO fails, pass up to the stack 				 * directly. 				 */
call|(
modifier|*
name|ifp
operator|->
name|if_input
call|)
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
call|(
modifier|*
name|ifp
operator|->
name|if_input
call|)
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|XN_RX_LOCK
argument_list|(
name|np
argument_list|)
expr_stmt|;
block|}
name|np
operator|->
name|rx
operator|.
name|rsp_cons
operator|=
name|i
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|700000
comment|/* 		 * Flush any outstanding LRO work 		 */
while|while
condition|(
operator|!
name|SLIST_EMPTY
argument_list|(
operator|&
name|lro
operator|->
name|lro_active
argument_list|)
condition|)
block|{
name|queued
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|lro
operator|->
name|lro_active
argument_list|)
expr_stmt|;
name|SLIST_REMOVE_HEAD
argument_list|(
operator|&
name|lro
operator|->
name|lro_active
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|tcp_lro_flush
argument_list|(
name|lro
argument_list|,
name|queued
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|#
directive|if
literal|0
comment|/* If we get a callback with very few responses, reduce fill target. */
comment|/* NB. Note exponential increase, linear decrease. */
block|if (((np->rx.req_prod_pvt - np->rx.sring->rsp_prod)>  			((3*np->rx_target) / 4))&& (--np->rx_target< np->rx_min_target)) 			np->rx_target = np->rx_min_target;
endif|#
directive|endif
name|network_alloc_rx_buffers
argument_list|(
name|np
argument_list|)
expr_stmt|;
name|RING_FINAL_CHECK_FOR_RESPONSES
argument_list|(
operator|&
name|np
operator|->
name|rx
argument_list|,
name|work_to_do
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|work_to_do
condition|)
do|;
block|}
end_function

begin_function
specifier|static
name|void
name|xn_txeof
parameter_list|(
name|struct
name|netfront_info
modifier|*
name|np
parameter_list|)
block|{
name|RING_IDX
name|i
decl_stmt|,
name|prod
decl_stmt|;
name|unsigned
name|short
name|id
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|netif_tx_response_t
modifier|*
name|txr
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|XN_TX_LOCK_ASSERT
argument_list|(
name|np
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|netfront_carrier_ok
argument_list|(
name|np
argument_list|)
condition|)
return|return;
name|ifp
operator|=
name|np
operator|->
name|xn_ifp
expr_stmt|;
do|do
block|{
name|prod
operator|=
name|np
operator|->
name|tx
operator|.
name|sring
operator|->
name|rsp_prod
expr_stmt|;
name|rmb
argument_list|()
expr_stmt|;
comment|/* Ensure we see responses up to 'rp'. */
for|for
control|(
name|i
operator|=
name|np
operator|->
name|tx
operator|.
name|rsp_cons
init|;
name|i
operator|!=
name|prod
condition|;
name|i
operator|++
control|)
block|{
name|txr
operator|=
name|RING_GET_RESPONSE
argument_list|(
operator|&
name|np
operator|->
name|tx
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|txr
operator|->
name|status
operator|==
name|NETIF_RSP_NULL
condition|)
continue|continue;
if|if
condition|(
name|txr
operator|->
name|status
operator|!=
name|NETIF_RSP_OKAY
condition|)
block|{
name|printf
argument_list|(
literal|"%s: WARNING: response is %d!\n"
argument_list|,
name|__func__
argument_list|,
name|txr
operator|->
name|status
argument_list|)
expr_stmt|;
block|}
name|id
operator|=
name|txr
operator|->
name|id
expr_stmt|;
name|m
operator|=
name|np
operator|->
name|tx_mbufs
index|[
name|id
index|]
expr_stmt|;
name|KASSERT
argument_list|(
name|m
operator|!=
name|NULL
argument_list|,
operator|(
literal|"mbuf not found in xn_tx_chain"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|uintptr_t
operator|)
name|m
operator|>
name|NET_TX_RING_SIZE
argument_list|,
operator|(
literal|"mbuf already on the free list, but we're "
literal|"trying to free it again!"
operator|)
argument_list|)
expr_stmt|;
name|M_ASSERTVALID
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* 			 * Increment packet count if this is the last 			 * mbuf of the chain. 			 */
if|if
condition|(
operator|!
name|m
operator|->
name|m_next
condition|)
name|ifp
operator|->
name|if_opackets
operator|++
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|gnttab_query_foreign_access
argument_list|(
name|np
operator|->
name|grant_tx_ref
index|[
name|id
index|]
argument_list|)
operator|!=
literal|0
argument_list|)
condition|)
block|{
name|panic
argument_list|(
literal|"grant id %u still in use by the backend"
argument_list|,
name|id
argument_list|)
expr_stmt|;
block|}
name|gnttab_end_foreign_access_ref
argument_list|(
name|np
operator|->
name|grant_tx_ref
index|[
name|id
index|]
argument_list|)
expr_stmt|;
name|gnttab_release_grant_reference
argument_list|(
operator|&
name|np
operator|->
name|gref_tx_head
argument_list|,
name|np
operator|->
name|grant_tx_ref
index|[
name|id
index|]
argument_list|)
expr_stmt|;
name|np
operator|->
name|grant_tx_ref
index|[
name|id
index|]
operator|=
name|GRANT_REF_INVALID
expr_stmt|;
name|np
operator|->
name|tx_mbufs
index|[
name|id
index|]
operator|=
name|NULL
expr_stmt|;
name|add_id_to_freelist
argument_list|(
name|np
operator|->
name|tx_mbufs
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|np
operator|->
name|xn_cdata
operator|.
name|xn_tx_chain_cnt
operator|--
expr_stmt|;
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* Only mark the queue active if we've freed up at least one slot to try */
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
block|}
name|np
operator|->
name|tx
operator|.
name|rsp_cons
operator|=
name|prod
expr_stmt|;
comment|/* 		 * Set a new event, then check for race with update of 		 * tx_cons. Note that it is essential to schedule a 		 * callback, no matter how few buffers are pending. Even if 		 * there is space in the transmit ring, higher layers may 		 * be blocked because too much data is outstanding: in such 		 * cases notification from Xen is likely to be the only kick 		 * that we'll get. 		 */
name|np
operator|->
name|tx
operator|.
name|sring
operator|->
name|rsp_event
operator|=
name|prod
operator|+
operator|(
operator|(
name|np
operator|->
name|tx
operator|.
name|sring
operator|->
name|req_prod
operator|-
name|prod
operator|)
operator|>>
literal|1
operator|)
operator|+
literal|1
expr_stmt|;
name|mb
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|prod
operator|!=
name|np
operator|->
name|tx
operator|.
name|sring
operator|->
name|rsp_prod
condition|)
do|;
if|if
condition|(
name|np
operator|->
name|tx_full
operator|&&
operator|(
operator|(
name|np
operator|->
name|tx
operator|.
name|sring
operator|->
name|req_prod
operator|-
name|prod
operator|)
operator|<
name|NET_TX_RING_SIZE
operator|)
condition|)
block|{
name|np
operator|->
name|tx_full
operator|=
literal|0
expr_stmt|;
if|#
directive|if
literal|0
block|if (np->user_state == UST_OPEN) 			netif_wake_queue(dev);
endif|#
directive|endif
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|xn_intr
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
block|{
name|struct
name|netfront_info
modifier|*
name|np
init|=
name|xsc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|np
operator|->
name|xn_ifp
decl_stmt|;
if|#
directive|if
literal|0
block|if (!(np->rx.rsp_cons != np->rx.sring->rsp_prod&& 	    likely(netfront_carrier_ok(np))&& 	    ifp->if_drv_flags& IFF_DRV_RUNNING)) 		return;
endif|#
directive|endif
if|if
condition|(
name|RING_HAS_UNCONSUMED_RESPONSES
argument_list|(
operator|&
name|np
operator|->
name|tx
argument_list|)
condition|)
block|{
name|XN_TX_LOCK
argument_list|(
name|np
argument_list|)
expr_stmt|;
name|xn_txeof
argument_list|(
name|np
argument_list|)
expr_stmt|;
name|XN_TX_UNLOCK
argument_list|(
name|np
argument_list|)
expr_stmt|;
block|}
name|XN_RX_LOCK
argument_list|(
name|np
argument_list|)
expr_stmt|;
name|xn_rxeof
argument_list|(
name|np
argument_list|)
expr_stmt|;
name|XN_RX_UNLOCK
argument_list|(
name|np
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|&&
operator|!
name|IFQ_DRV_IS_EMPTY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
condition|)
name|xn_start
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xennet_move_rx_slot
parameter_list|(
name|struct
name|netfront_info
modifier|*
name|np
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|grant_ref_t
name|ref
parameter_list|)
block|{
name|int
name|new
init|=
name|xennet_rxidx
argument_list|(
name|np
operator|->
name|rx
operator|.
name|req_prod_pvt
argument_list|)
decl_stmt|;
name|KASSERT
argument_list|(
name|np
operator|->
name|rx_mbufs
index|[
name|new
index|]
operator|==
name|NULL
argument_list|,
operator|(
literal|"rx_mbufs != NULL"
operator|)
argument_list|)
expr_stmt|;
name|np
operator|->
name|rx_mbufs
index|[
name|new
index|]
operator|=
name|m
expr_stmt|;
name|np
operator|->
name|grant_rx_ref
index|[
name|new
index|]
operator|=
name|ref
expr_stmt|;
name|RING_GET_REQUEST
argument_list|(
operator|&
name|np
operator|->
name|rx
argument_list|,
name|np
operator|->
name|rx
operator|.
name|req_prod_pvt
argument_list|)
operator|->
name|id
operator|=
name|new
expr_stmt|;
name|RING_GET_REQUEST
argument_list|(
operator|&
name|np
operator|->
name|rx
argument_list|,
name|np
operator|->
name|rx
operator|.
name|req_prod_pvt
argument_list|)
operator|->
name|gref
operator|=
name|ref
expr_stmt|;
name|np
operator|->
name|rx
operator|.
name|req_prod_pvt
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|xennet_get_extras
parameter_list|(
name|struct
name|netfront_info
modifier|*
name|np
parameter_list|,
name|struct
name|netif_extra_info
modifier|*
name|extras
parameter_list|,
name|RING_IDX
name|rp
parameter_list|,
name|RING_IDX
modifier|*
name|cons
parameter_list|)
block|{
name|struct
name|netif_extra_info
modifier|*
name|extra
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
do|do
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|grant_ref_t
name|ref
decl_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
operator|*
name|cons
operator|+
literal|1
operator|==
name|rp
argument_list|)
condition|)
block|{
if|#
directive|if
literal|0
block|if (net_ratelimit()) 				WPRINTK("Missing extra info\n");
endif|#
directive|endif
name|err
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|extra
operator|=
operator|(
expr|struct
name|netif_extra_info
operator|*
operator|)
name|RING_GET_RESPONSE
argument_list|(
operator|&
name|np
operator|->
name|rx
argument_list|,
operator|++
operator|(
operator|*
name|cons
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
operator|!
name|extra
operator|->
name|type
operator|||
name|extra
operator|->
name|type
operator|>=
name|XEN_NETIF_EXTRA_TYPE_MAX
argument_list|)
condition|)
block|{
if|#
directive|if
literal|0
block|if (net_ratelimit()) 				WPRINTK("Invalid extra type: %d\n", 					extra->type);
endif|#
directive|endif
name|err
operator|=
name|EINVAL
expr_stmt|;
block|}
else|else
block|{
name|memcpy
argument_list|(
operator|&
name|extras
index|[
name|extra
operator|->
name|type
operator|-
literal|1
index|]
argument_list|,
name|extra
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|extra
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|m
operator|=
name|xennet_get_rx_mbuf
argument_list|(
name|np
argument_list|,
operator|*
name|cons
argument_list|)
expr_stmt|;
name|ref
operator|=
name|xennet_get_rx_ref
argument_list|(
name|np
argument_list|,
operator|*
name|cons
argument_list|)
expr_stmt|;
name|xennet_move_rx_slot
argument_list|(
name|np
argument_list|,
name|m
argument_list|,
name|ref
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|extra
operator|->
name|flags
operator|&
name|XEN_NETIF_EXTRA_FLAG_MORE
condition|)
do|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xennet_get_responses
parameter_list|(
name|struct
name|netfront_info
modifier|*
name|np
parameter_list|,
name|struct
name|netfront_rx_info
modifier|*
name|rinfo
parameter_list|,
name|RING_IDX
name|rp
parameter_list|,
name|RING_IDX
modifier|*
name|cons
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|list
parameter_list|,
name|int
modifier|*
name|pages_flipped_p
parameter_list|)
block|{
name|int
name|pages_flipped
init|=
operator|*
name|pages_flipped_p
decl_stmt|;
name|struct
name|mmu_update
modifier|*
name|mmu
decl_stmt|;
name|struct
name|multicall_entry
modifier|*
name|mcl
decl_stmt|;
name|struct
name|netif_rx_response
modifier|*
name|rx
init|=
operator|&
name|rinfo
operator|->
name|rx
decl_stmt|;
name|struct
name|netif_extra_info
modifier|*
name|extras
init|=
name|rinfo
operator|->
name|extras
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|m0
decl_stmt|,
modifier|*
name|m_prev
decl_stmt|;
name|grant_ref_t
name|ref
init|=
name|xennet_get_rx_ref
argument_list|(
name|np
argument_list|,
operator|*
name|cons
argument_list|)
decl_stmt|;
name|RING_IDX
name|ref_cons
init|=
operator|*
name|cons
decl_stmt|;
name|int
name|frags
init|=
literal|1
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|u_long
name|ret
decl_stmt|;
name|m0
operator|=
name|m
operator|=
name|m_prev
operator|=
name|xennet_get_rx_mbuf
argument_list|(
name|np
argument_list|,
operator|*
name|cons
argument_list|)
expr_stmt|;
if|if
condition|(
name|rx
operator|->
name|flags
operator|&
name|NETRXF_extra_info
condition|)
block|{
name|err
operator|=
name|xennet_get_extras
argument_list|(
name|np
argument_list|,
name|extras
argument_list|,
name|rp
argument_list|,
name|cons
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|m0
operator|!=
name|NULL
condition|)
block|{
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
literal|0
expr_stmt|;
name|m0
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
name|u_long
name|mfn
decl_stmt|;
if|#
directive|if
literal|0
block|DPRINTK("rx->status=%hd rx->offset=%hu frags=%u\n", 			rx->status, rx->offset, frags);
endif|#
directive|endif
if|if
condition|(
name|unlikely
argument_list|(
name|rx
operator|->
name|status
operator|<
literal|0
operator|||
name|rx
operator|->
name|offset
operator|+
name|rx
operator|->
name|status
operator|>
name|PAGE_SIZE
argument_list|)
condition|)
block|{
if|#
directive|if
literal|0
block|if (net_ratelimit()) 				WPRINTK("rx->offset: %x, size: %u\n", 					rx->offset, rx->status);
endif|#
directive|endif
name|xennet_move_rx_slot
argument_list|(
name|np
argument_list|,
name|m
argument_list|,
name|ref
argument_list|)
expr_stmt|;
if|if
condition|(
name|m0
operator|==
name|m
condition|)
name|m0
operator|=
name|NULL
expr_stmt|;
name|m
operator|=
name|NULL
expr_stmt|;
name|err
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|next_skip_queue
goto|;
block|}
comment|/* 		 * This definitely indicates a bug, either in this driver or in 		 * the backend driver. In future this should flag the bad 		 * situation to the system controller to reboot the backed. 		 */
if|if
condition|(
name|ref
operator|==
name|GRANT_REF_INVALID
condition|)
block|{
if|#
directive|if
literal|0
block|if (net_ratelimit()) 				WPRINTK("Bad rx response id %d.\n", rx->id);
endif|#
directive|endif
name|printf
argument_list|(
literal|"%s: Bad rx response id %d.\n"
argument_list|,
name|__func__
argument_list|,
name|rx
operator|->
name|id
argument_list|)
expr_stmt|;
name|err
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|next
goto|;
block|}
if|if
condition|(
operator|!
name|np
operator|->
name|copying_receiver
condition|)
block|{
comment|/* Memory pressure, insufficient buffer 			 * headroom, ... 			 */
if|if
condition|(
operator|!
operator|(
name|mfn
operator|=
name|gnttab_end_foreign_transfer_ref
argument_list|(
name|ref
argument_list|)
operator|)
condition|)
block|{
name|WPRINTK
argument_list|(
literal|"Unfulfilled rx req (id=%d, st=%d).\n"
argument_list|,
name|rx
operator|->
name|id
argument_list|,
name|rx
operator|->
name|status
argument_list|)
expr_stmt|;
name|xennet_move_rx_slot
argument_list|(
name|np
argument_list|,
name|m
argument_list|,
name|ref
argument_list|)
expr_stmt|;
name|err
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|next
goto|;
block|}
if|if
condition|(
operator|!
name|xen_feature
argument_list|(
name|XENFEAT_auto_translated_physmap
argument_list|)
condition|)
block|{
comment|/* Remap the page. */
name|void
modifier|*
name|vaddr
init|=
name|mtod
argument_list|(
name|m
argument_list|,
name|void
operator|*
argument_list|)
decl_stmt|;
name|uint32_t
name|pfn
decl_stmt|;
name|mcl
operator|=
name|np
operator|->
name|rx_mcl
operator|+
name|pages_flipped
expr_stmt|;
name|mmu
operator|=
name|np
operator|->
name|rx_mmu
operator|+
name|pages_flipped
expr_stmt|;
name|MULTI_update_va_mapping
argument_list|(
name|mcl
argument_list|,
operator|(
name|u_long
operator|)
name|vaddr
argument_list|,
operator|(
operator|(
operator|(
name|vm_paddr_t
operator|)
name|mfn
operator|)
operator|<<
name|PAGE_SHIFT
operator|)
operator||
name|PG_RW
operator||
name|PG_V
operator||
name|PG_M
operator||
name|PG_A
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pfn
operator|=
operator|(
name|uintptr_t
operator|)
name|m
operator|->
name|m_ext
operator|.
name|ext_arg1
expr_stmt|;
name|mmu
operator|->
name|ptr
operator|=
operator|(
operator|(
name|vm_paddr_t
operator|)
name|mfn
operator|<<
name|PAGE_SHIFT
operator|)
operator||
name|MMU_MACHPHYS_UPDATE
expr_stmt|;
name|mmu
operator|->
name|val
operator|=
name|pfn
expr_stmt|;
name|set_phys_to_machine
argument_list|(
name|pfn
argument_list|,
name|mfn
argument_list|)
expr_stmt|;
block|}
name|pages_flipped
operator|++
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|gnttab_end_foreign_access_ref
argument_list|(
name|ref
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ret
argument_list|,
operator|(
literal|"ret != 0"
operator|)
argument_list|)
expr_stmt|;
block|}
name|gnttab_release_grant_reference
argument_list|(
operator|&
name|np
operator|->
name|gref_rx_head
argument_list|,
name|ref
argument_list|)
expr_stmt|;
name|next
label|:
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
break|break;
name|m
operator|->
name|m_len
operator|=
name|rx
operator|->
name|status
expr_stmt|;
name|m
operator|->
name|m_data
operator|+=
name|rx
operator|->
name|offset
expr_stmt|;
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
name|rx
operator|->
name|status
expr_stmt|;
name|next_skip_queue
label|:
if|if
condition|(
operator|!
operator|(
name|rx
operator|->
name|flags
operator|&
name|NETRXF_more_data
operator|)
condition|)
break|break;
if|if
condition|(
operator|*
name|cons
operator|+
name|frags
operator|==
name|rp
condition|)
block|{
if|if
condition|(
name|net_ratelimit
argument_list|()
condition|)
name|WPRINTK
argument_list|(
literal|"Need more frags\n"
argument_list|)
expr_stmt|;
name|err
operator|=
name|ENOENT
expr_stmt|;
name|printf
argument_list|(
literal|"%s: cons %u frags %u rp %u, not enough frags\n"
argument_list|,
name|__func__
argument_list|,
operator|*
name|cons
argument_list|,
name|frags
argument_list|,
name|rp
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 		 * Note that m can be NULL, if rx->status< 0 or if 		 * rx->offset + rx->status> PAGE_SIZE above.   		 */
name|m_prev
operator|=
name|m
expr_stmt|;
name|rx
operator|=
name|RING_GET_RESPONSE
argument_list|(
operator|&
name|np
operator|->
name|rx
argument_list|,
operator|*
name|cons
operator|+
name|frags
argument_list|)
expr_stmt|;
name|m
operator|=
name|xennet_get_rx_mbuf
argument_list|(
name|np
argument_list|,
operator|*
name|cons
operator|+
name|frags
argument_list|)
expr_stmt|;
comment|/* 		 * m_prev == NULL can happen if rx->status< 0 or if 		 * rx->offset + * rx->status> PAGE_SIZE above.   		 */
if|if
condition|(
name|m_prev
operator|!=
name|NULL
condition|)
name|m_prev
operator|->
name|m_next
operator|=
name|m
expr_stmt|;
comment|/* 		 * m0 can be NULL if rx->status< 0 or if * rx->offset + 		 * rx->status> PAGE_SIZE above.   		 */
if|if
condition|(
name|m0
operator|==
name|NULL
condition|)
name|m0
operator|=
name|m
expr_stmt|;
name|m
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
name|ref
operator|=
name|xennet_get_rx_ref
argument_list|(
name|np
argument_list|,
operator|*
name|cons
operator|+
name|frags
argument_list|)
expr_stmt|;
name|ref_cons
operator|=
operator|*
name|cons
operator|+
name|frags
expr_stmt|;
name|frags
operator|++
expr_stmt|;
block|}
operator|*
name|list
operator|=
name|m0
expr_stmt|;
operator|*
name|cons
operator|+=
name|frags
expr_stmt|;
operator|*
name|pages_flipped_p
operator|=
name|pages_flipped
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xn_tick_locked
parameter_list|(
name|struct
name|netfront_info
modifier|*
name|sc
parameter_list|)
block|{
name|XN_RX_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|xn_stat_ch
argument_list|,
name|hz
argument_list|,
name|xn_tick
argument_list|,
name|sc
argument_list|)
expr_stmt|;
comment|/* XXX placeholder for printing debug information */
block|}
end_function

begin_function
specifier|static
name|void
name|xn_tick
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
block|{
name|struct
name|netfront_info
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|xsc
expr_stmt|;
name|XN_RX_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|xn_tick_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|XN_RX_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * \brief Count the number of fragments in an mbuf chain.  *  * Surprisingly, there isn't an M* macro for this.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|xn_count_frags
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|int
name|nfrags
decl_stmt|;
for|for
control|(
name|nfrags
operator|=
literal|0
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
name|nfrags
operator|++
expr_stmt|;
return|return
operator|(
name|nfrags
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Given an mbuf chain, make sure we have enough room and then push  * it onto the transmit ring.  */
end_comment

begin_function
specifier|static
name|int
name|xn_assemble_tx_request
parameter_list|(
name|struct
name|netfront_info
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m_head
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|u_int
name|nfrags
decl_stmt|;
name|netif_extra_info_t
modifier|*
name|extra
decl_stmt|;
name|int
name|otherend_id
decl_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|xn_ifp
expr_stmt|;
comment|/** 	 * Defragment the mbuf if necessary. 	 */
name|nfrags
operator|=
name|xn_count_frags
argument_list|(
name|m_head
argument_list|)
expr_stmt|;
comment|/* 	 * Check to see whether this request is longer than netback 	 * can handle, and try to defrag it. 	 */
comment|/** 	 * It is a bit lame, but the netback driver in Linux can't 	 * deal with nfrags> MAX_TX_REQ_FRAGS, which is a quirk of 	 * the Linux network stack. 	 */
if|if
condition|(
name|nfrags
operator|>
name|MAX_TX_REQ_FRAGS
condition|)
block|{
name|m
operator|=
name|m_defrag
argument_list|(
name|m_head
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
block|{
comment|/* 			 * Defrag failed, so free the mbuf and 			 * therefore drop the packet. 			 */
name|m_freem
argument_list|(
name|m_head
argument_list|)
expr_stmt|;
return|return
operator|(
name|EMSGSIZE
operator|)
return|;
block|}
name|m_head
operator|=
name|m
expr_stmt|;
block|}
comment|/* Determine how many fragments now exist */
name|nfrags
operator|=
name|xn_count_frags
argument_list|(
name|m_head
argument_list|)
expr_stmt|;
comment|/* 	 * Check to see whether the defragmented packet has too many 	 * segments for the Linux netback driver. 	 */
comment|/** 	 * The FreeBSD TCP stack, with TSO enabled, can produce a chain 	 * of mbufs longer than Linux can handle.  Make sure we don't 	 * pass a too-long chain over to the other side by dropping the 	 * packet.  It doesn't look like there is currently a way to 	 * tell the TCP stack to generate a shorter chain of packets. 	 */
if|if
condition|(
name|nfrags
operator|>
name|MAX_TX_REQ_FRAGS
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"%s: nfrags %d> MAX_TX_REQ_FRAGS %d, netback "
literal|"won't be able to handle it, dropping\n"
argument_list|,
name|__func__
argument_list|,
name|nfrags
argument_list|,
name|MAX_TX_REQ_FRAGS
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|m_freem
argument_list|(
name|m_head
argument_list|)
expr_stmt|;
return|return
operator|(
name|EMSGSIZE
operator|)
return|;
block|}
comment|/* 	 * This check should be redundant.  We've already verified that we 	 * have enough slots in the ring to handle a packet of maximum 	 * size, and that our packet is less than the maximum size.  Keep 	 * it in here as an assert for now just to make certain that 	 * xn_tx_chain_cnt is accurate. 	 */
name|KASSERT
argument_list|(
operator|(
name|sc
operator|->
name|xn_cdata
operator|.
name|xn_tx_chain_cnt
operator|+
name|nfrags
operator|)
operator|<=
name|NET_TX_RING_SIZE
argument_list|,
operator|(
literal|"%s: xn_tx_chain_cnt (%d) + nfrags (%d)> NET_TX_RING_SIZE "
literal|"(%d)!"
operator|,
name|__func__
operator|,
operator|(
name|int
operator|)
name|sc
operator|->
name|xn_cdata
operator|.
name|xn_tx_chain_cnt
operator|,
operator|(
name|int
operator|)
name|nfrags
operator|,
operator|(
name|int
operator|)
name|NET_TX_RING_SIZE
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Start packing the mbufs in this chain into 	 * the fragment pointers. Stop when we run out 	 * of fragments or hit the end of the mbuf chain. 	 */
name|m
operator|=
name|m_head
expr_stmt|;
name|extra
operator|=
name|NULL
expr_stmt|;
name|otherend_id
operator|=
name|xenbus_get_otherend_id
argument_list|(
name|sc
operator|->
name|xbdev
argument_list|)
expr_stmt|;
for|for
control|(
name|m
operator|=
name|m_head
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
block|{
name|netif_tx_request_t
modifier|*
name|tx
decl_stmt|;
name|uintptr_t
name|id
decl_stmt|;
name|grant_ref_t
name|ref
decl_stmt|;
name|u_long
name|mfn
decl_stmt|;
comment|/* XXX Wrong type? */
name|tx
operator|=
name|RING_GET_REQUEST
argument_list|(
operator|&
name|sc
operator|->
name|tx
argument_list|,
name|sc
operator|->
name|tx
operator|.
name|req_prod_pvt
argument_list|)
expr_stmt|;
name|id
operator|=
name|get_id_from_freelist
argument_list|(
name|sc
operator|->
name|tx_mbufs
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"xn_start_locked: was allocated the freelist head!\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|xn_cdata
operator|.
name|xn_tx_chain_cnt
operator|++
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|xn_cdata
operator|.
name|xn_tx_chain_cnt
operator|>
name|NET_TX_RING_SIZE
condition|)
name|panic
argument_list|(
literal|"xn_start_locked: tx_chain_cnt must be<= NET_TX_RING_SIZE\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tx_mbufs
index|[
name|id
index|]
operator|=
name|m
expr_stmt|;
name|tx
operator|->
name|id
operator|=
name|id
expr_stmt|;
name|ref
operator|=
name|gnttab_claim_grant_reference
argument_list|(
operator|&
name|sc
operator|->
name|gref_tx_head
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|short
operator|)
name|ref
operator|>=
literal|0
argument_list|,
operator|(
literal|"Negative ref"
operator|)
argument_list|)
expr_stmt|;
name|mfn
operator|=
name|virt_to_mfn
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|vm_offset_t
argument_list|)
argument_list|)
expr_stmt|;
name|gnttab_grant_foreign_access_ref
argument_list|(
name|ref
argument_list|,
name|otherend_id
argument_list|,
name|mfn
argument_list|,
name|GNTMAP_readonly
argument_list|)
expr_stmt|;
name|tx
operator|->
name|gref
operator|=
name|sc
operator|->
name|grant_tx_ref
index|[
name|id
index|]
operator|=
name|ref
expr_stmt|;
name|tx
operator|->
name|offset
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|vm_offset_t
argument_list|)
operator|&
operator|(
name|PAGE_SIZE
operator|-
literal|1
operator|)
expr_stmt|;
name|tx
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|m_head
condition|)
block|{
comment|/* 			 * The first fragment has the entire packet 			 * size, subsequent fragments have just the 			 * fragment size. The backend works out the 			 * true size of the first fragment by 			 * subtracting the sizes of the other 			 * fragments. 			 */
name|tx
operator|->
name|size
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
comment|/* 			 * The first fragment contains the checksum flags 			 * and is optionally followed by extra data for 			 * TSO etc. 			 */
comment|/** 			 * CSUM_TSO requires checksum offloading. 			 * Some versions of FreeBSD fail to 			 * set CSUM_TCP in the CSUM_TSO case, 			 * so we have to test for CSUM_TSO 			 * explicitly. 			 */
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
operator|(
name|CSUM_DELAY_DATA
operator||
name|CSUM_TSO
operator|)
condition|)
block|{
name|tx
operator|->
name|flags
operator||=
operator|(
name|NETTXF_csum_blank
operator||
name|NETTXF_data_validated
operator|)
expr_stmt|;
block|}
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|700000
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_TSO
condition|)
block|{
name|struct
name|netif_extra_info
modifier|*
name|gso
init|=
operator|(
expr|struct
name|netif_extra_info
operator|*
operator|)
name|RING_GET_REQUEST
argument_list|(
operator|&
name|sc
operator|->
name|tx
argument_list|,
operator|++
name|sc
operator|->
name|tx
operator|.
name|req_prod_pvt
argument_list|)
decl_stmt|;
name|tx
operator|->
name|flags
operator||=
name|NETTXF_extra_info
expr_stmt|;
name|gso
operator|->
name|u
operator|.
name|gso
operator|.
name|size
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|tso_segsz
expr_stmt|;
name|gso
operator|->
name|u
operator|.
name|gso
operator|.
name|type
operator|=
name|XEN_NETIF_GSO_TYPE_TCPV4
expr_stmt|;
name|gso
operator|->
name|u
operator|.
name|gso
operator|.
name|pad
operator|=
literal|0
expr_stmt|;
name|gso
operator|->
name|u
operator|.
name|gso
operator|.
name|features
operator|=
literal|0
expr_stmt|;
name|gso
operator|->
name|type
operator|=
name|XEN_NETIF_EXTRA_TYPE_GSO
expr_stmt|;
name|gso
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
block|}
else|else
block|{
name|tx
operator|->
name|size
operator|=
name|m
operator|->
name|m_len
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|->
name|m_next
condition|)
name|tx
operator|->
name|flags
operator||=
name|NETTXF_more_data
expr_stmt|;
name|sc
operator|->
name|tx
operator|.
name|req_prod_pvt
operator|++
expr_stmt|;
block|}
name|BPF_MTAP
argument_list|(
name|ifp
argument_list|,
name|m_head
argument_list|)
expr_stmt|;
name|sc
operator|->
name|stats
operator|.
name|tx_bytes
operator|+=
name|m_head
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|sc
operator|->
name|stats
operator|.
name|tx_packets
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xn_start_locked
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|netfront_info
modifier|*
name|sc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m_head
decl_stmt|;
name|int
name|notify
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
if|if
condition|(
operator|!
name|netfront_carrier_ok
argument_list|(
name|sc
argument_list|)
condition|)
return|return;
comment|/* 	 * While we have enough transmit slots available for at least one 	 * maximum-sized packet, pull mbufs off the queue and put them on 	 * the transmit ring. 	 */
while|while
condition|(
name|xn_tx_slot_available
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|IF_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m_head
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_head
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|xn_assemble_tx_request
argument_list|(
name|sc
argument_list|,
name|m_head
argument_list|)
operator|!=
literal|0
condition|)
break|break;
block|}
name|RING_PUSH_REQUESTS_AND_CHECK_NOTIFY
argument_list|(
operator|&
name|sc
operator|->
name|tx
argument_list|,
name|notify
argument_list|)
expr_stmt|;
if|if
condition|(
name|notify
condition|)
name|notify_remote_via_irq
argument_list|(
name|sc
operator|->
name|irq
argument_list|)
expr_stmt|;
if|if
condition|(
name|RING_FULL
argument_list|(
operator|&
name|sc
operator|->
name|tx
argument_list|)
condition|)
block|{
name|sc
operator|->
name|tx_full
operator|=
literal|1
expr_stmt|;
if|#
directive|if
literal|0
block|netif_stop_queue(dev);
endif|#
directive|endif
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|xn_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|netfront_info
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|XN_TX_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|xn_start_locked
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|XN_TX_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* equivalent of network_open() in Linux */
end_comment

begin_function
specifier|static
name|void
name|xn_ifinit_locked
parameter_list|(
name|struct
name|netfront_info
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|XN_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|xn_ifp
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
return|return;
name|xn_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|network_alloc_rx_buffers
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rx
operator|.
name|sring
operator|->
name|rsp_event
operator|=
name|sc
operator|->
name|rx
operator|.
name|rsp_cons
operator|+
literal|1
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_RUNNING
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
name|if_link_state_change
argument_list|(
name|ifp
argument_list|,
name|LINK_STATE_UP
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|xn_stat_ch
argument_list|,
name|hz
argument_list|,
name|xn_tick
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xn_ifinit
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
block|{
name|struct
name|netfront_info
modifier|*
name|sc
init|=
name|xsc
decl_stmt|;
name|XN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|xn_ifinit_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|XN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|xn_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|struct
name|netfront_info
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|ifaddr
modifier|*
name|ifa
init|=
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
name|data
decl_stmt|;
name|int
name|mask
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCSIFADDR
case|:
case|case
name|SIOCGIFADDR
case|:
name|XN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_UP
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
name|xn_ifinit_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|arp_ifinit
argument_list|(
name|ifp
argument_list|,
name|ifa
argument_list|)
expr_stmt|;
name|XN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|XN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SIOCSIFMTU
case|:
comment|/* XXX can we alter the MTU on a VN ?*/
ifdef|#
directive|ifdef
name|notyet
if|if
condition|(
name|ifr
operator|->
name|ifr_mtu
operator|>
name|XN_JUMBO_MTU
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
else|else
endif|#
directive|endif
block|{
name|ifp
operator|->
name|if_mtu
operator|=
name|ifr
operator|->
name|ifr_mtu
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_RUNNING
expr_stmt|;
name|xn_ifinit
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SIOCSIFFLAGS
case|:
name|XN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
comment|/* 			 * If only the state of the PROMISC flag changed, 			 * then just use the 'set promisc mode' command 			 * instead of reinitializing the entire NIC. Doing 			 * a full re-init means reloading the firmware and 			 * waiting for it to start up, which may take a 			 * second or two. 			 */
ifdef|#
directive|ifdef
name|notyet
comment|/* No promiscuous mode with Xen */
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|&&
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
operator|&&
operator|!
operator|(
name|sc
operator|->
name|xn_if_flags
operator|&
name|IFF_PROMISC
operator|)
condition|)
block|{
name|XN_SETBIT
argument_list|(
name|sc
argument_list|,
name|XN_RX_MODE
argument_list|,
name|XN_RXMODE_RX_PROMISC
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|&&
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
operator|)
operator|&&
name|sc
operator|->
name|xn_if_flags
operator|&
name|IFF_PROMISC
condition|)
block|{
name|XN_CLRBIT
argument_list|(
name|sc
argument_list|,
name|XN_RX_MODE
argument_list|,
name|XN_RXMODE_RX_PROMISC
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|xn_ifinit_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|xn_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
name|sc
operator|->
name|xn_if_flags
operator|=
name|ifp
operator|->
name|if_flags
expr_stmt|;
name|XN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SIOCSIFCAP
case|:
name|mask
operator|=
name|ifr
operator|->
name|ifr_reqcap
operator|^
name|ifp
operator|->
name|if_capenable
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IFCAP_TXCSUM
condition|)
block|{
if|if
condition|(
name|IFCAP_TXCSUM
operator|&
name|ifp
operator|->
name|if_capenable
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|&=
operator|~
operator|(
name|IFCAP_TXCSUM
operator||
name|IFCAP_TSO4
operator|)
expr_stmt|;
name|ifp
operator|->
name|if_hwassist
operator|&=
operator|~
operator|(
name|CSUM_TCP
operator||
name|CSUM_UDP
operator||
name|CSUM_IP
operator||
name|CSUM_TSO
operator|)
expr_stmt|;
block|}
else|else
block|{
name|ifp
operator|->
name|if_capenable
operator||=
name|IFCAP_TXCSUM
expr_stmt|;
name|ifp
operator|->
name|if_hwassist
operator||=
operator|(
name|CSUM_TCP
operator||
name|CSUM_UDP
operator||
name|CSUM_IP
operator|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mask
operator|&
name|IFCAP_RXCSUM
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_RXCSUM
expr_stmt|;
block|}
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|700000
if|if
condition|(
name|mask
operator|&
name|IFCAP_TSO4
condition|)
block|{
if|if
condition|(
name|IFCAP_TSO4
operator|&
name|ifp
operator|->
name|if_capenable
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|&=
operator|~
name|IFCAP_TSO4
expr_stmt|;
name|ifp
operator|->
name|if_hwassist
operator|&=
operator|~
name|CSUM_TSO
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IFCAP_TXCSUM
operator|&
name|ifp
operator|->
name|if_capenable
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator||=
name|IFCAP_TSO4
expr_stmt|;
name|ifp
operator|->
name|if_hwassist
operator||=
name|CSUM_TSO
expr_stmt|;
block|}
else|else
block|{
name|IPRINTK
argument_list|(
literal|"Xen requires tx checksum offload"
literal|" be enabled to use TSO\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mask
operator|&
name|IFCAP_LRO
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_LRO
expr_stmt|;
block|}
endif|#
directive|endif
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
ifdef|#
directive|ifdef
name|notyet
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|XN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|xn_setmulti
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|XN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* FALLTHROUGH */
case|case
name|SIOCSIFMEDIA
case|:
case|case
name|SIOCGIFMEDIA
case|:
name|error
operator|=
name|ifmedia_ioctl
argument_list|(
name|ifp
argument_list|,
name|ifr
argument_list|,
operator|&
name|sc
operator|->
name|sc_media
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xn_stop
parameter_list|(
name|struct
name|netfront_info
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|XN_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|xn_ifp
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|xn_stat_ch
argument_list|)
expr_stmt|;
name|xn_free_rx_ring
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|xn_free_tx_ring
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
operator|(
name|IFF_DRV_RUNNING
operator||
name|IFF_DRV_OACTIVE
operator|)
expr_stmt|;
name|if_link_state_change
argument_list|(
name|ifp
argument_list|,
name|LINK_STATE_DOWN
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* START of Xenolinux helper functions adapted to FreeBSD */
end_comment

begin_function
name|int
name|network_connect
parameter_list|(
name|struct
name|netfront_info
modifier|*
name|np
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|requeue_idx
decl_stmt|,
name|error
decl_stmt|;
name|grant_ref_t
name|ref
decl_stmt|;
name|netif_rx_request_t
modifier|*
name|req
decl_stmt|;
name|u_int
name|feature_rx_copy
decl_stmt|,
name|feature_rx_flip
decl_stmt|;
name|error
operator|=
name|xs_scanf
argument_list|(
name|XST_NIL
argument_list|,
name|xenbus_get_otherend_path
argument_list|(
name|np
operator|->
name|xbdev
argument_list|)
argument_list|,
literal|"feature-rx-copy"
argument_list|,
name|NULL
argument_list|,
literal|"%u"
argument_list|,
operator|&
name|feature_rx_copy
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|feature_rx_copy
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|xs_scanf
argument_list|(
name|XST_NIL
argument_list|,
name|xenbus_get_otherend_path
argument_list|(
name|np
operator|->
name|xbdev
argument_list|)
argument_list|,
literal|"feature-rx-flip"
argument_list|,
name|NULL
argument_list|,
literal|"%u"
argument_list|,
operator|&
name|feature_rx_flip
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|feature_rx_flip
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Copy packets on receive path if: 	 *  (a) This was requested by user, and the backend supports it; or 	 *  (b) Flipping was requested, but this is unsupported by the backend. 	 */
name|np
operator|->
name|copying_receiver
operator|=
operator|(
operator|(
name|MODPARM_rx_copy
operator|&&
name|feature_rx_copy
operator|)
operator|||
operator|(
name|MODPARM_rx_flip
operator|&&
operator|!
name|feature_rx_flip
operator|)
operator|)
expr_stmt|;
comment|/* Recovery procedure: */
name|error
operator|=
name|talk_to_backend
argument_list|(
name|np
operator|->
name|xbdev
argument_list|,
name|np
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Step 1: Reinitialise variables. */
name|netif_release_tx_bufs
argument_list|(
name|np
argument_list|)
expr_stmt|;
comment|/* Step 2: Rebuild the RX buffer freelist and the RX ring itself. */
for|for
control|(
name|requeue_idx
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NET_RX_RING_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|u_long
name|pfn
decl_stmt|;
if|if
condition|(
name|np
operator|->
name|rx_mbufs
index|[
name|i
index|]
operator|==
name|NULL
condition|)
continue|continue;
name|m
operator|=
name|np
operator|->
name|rx_mbufs
index|[
name|requeue_idx
index|]
operator|=
name|xennet_get_rx_mbuf
argument_list|(
name|np
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|ref
operator|=
name|np
operator|->
name|grant_rx_ref
index|[
name|requeue_idx
index|]
operator|=
name|xennet_get_rx_ref
argument_list|(
name|np
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|req
operator|=
name|RING_GET_REQUEST
argument_list|(
operator|&
name|np
operator|->
name|rx
argument_list|,
name|requeue_idx
argument_list|)
expr_stmt|;
name|pfn
operator|=
name|vtophys
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|vm_offset_t
argument_list|)
argument_list|)
operator|>>
name|PAGE_SHIFT
expr_stmt|;
if|if
condition|(
operator|!
name|np
operator|->
name|copying_receiver
condition|)
block|{
name|gnttab_grant_foreign_transfer_ref
argument_list|(
name|ref
argument_list|,
name|xenbus_get_otherend_id
argument_list|(
name|np
operator|->
name|xbdev
argument_list|)
argument_list|,
name|pfn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gnttab_grant_foreign_access_ref
argument_list|(
name|ref
argument_list|,
name|xenbus_get_otherend_id
argument_list|(
name|np
operator|->
name|xbdev
argument_list|)
argument_list|,
name|PFNTOMFN
argument_list|(
name|pfn
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|req
operator|->
name|gref
operator|=
name|ref
expr_stmt|;
name|req
operator|->
name|id
operator|=
name|requeue_idx
expr_stmt|;
name|requeue_idx
operator|++
expr_stmt|;
block|}
name|np
operator|->
name|rx
operator|.
name|req_prod_pvt
operator|=
name|requeue_idx
expr_stmt|;
comment|/* Step 3: All public and private state should now be sane.  Get 	 * ready to start sending and receiving packets and give the driver 	 * domain a kick because we've probably just requeued some 	 * packets. 	 */
name|netfront_carrier_on
argument_list|(
name|np
argument_list|)
expr_stmt|;
name|notify_remote_via_irq
argument_list|(
name|np
operator|->
name|irq
argument_list|)
expr_stmt|;
name|XN_TX_LOCK
argument_list|(
name|np
argument_list|)
expr_stmt|;
name|xn_txeof
argument_list|(
name|np
argument_list|)
expr_stmt|;
name|XN_TX_UNLOCK
argument_list|(
name|np
argument_list|)
expr_stmt|;
name|network_alloc_rx_buffers
argument_list|(
name|np
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|show_device
parameter_list|(
name|struct
name|netfront_info
modifier|*
name|sc
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|sc
condition|)
block|{
name|IPRINTK
argument_list|(
literal|"<vif handle=%u %s(%s) evtchn=%u irq=%u tx=%p rx=%p>\n"
argument_list|,
name|sc
operator|->
name|xn_ifno
argument_list|,
name|be_state_name
index|[
name|sc
operator|->
name|xn_backend_state
index|]
argument_list|,
name|sc
operator|->
name|xn_user_state
condition|?
literal|"open"
else|:
literal|"closed"
argument_list|,
name|sc
operator|->
name|xn_evtchn
argument_list|,
name|sc
operator|->
name|xn_irq
argument_list|,
name|sc
operator|->
name|xn_tx_if
argument_list|,
name|sc
operator|->
name|xn_rx_if
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|IPRINTK
argument_list|(
literal|"<vif NULL>\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/** Create a network device.  * @param handle device handle  */
end_comment

begin_function
name|int
name|create_netdev
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|netfront_info
modifier|*
name|np
decl_stmt|;
name|int
name|err
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|np
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|np
operator|->
name|xbdev
operator|=
name|dev
expr_stmt|;
name|XN_LOCK_INIT
argument_list|(
name|np
argument_list|,
name|xennetif
argument_list|)
expr_stmt|;
name|ifmedia_init
argument_list|(
operator|&
name|np
operator|->
name|sc_media
argument_list|,
literal|0
argument_list|,
name|xn_ifmedia_upd
argument_list|,
name|xn_ifmedia_sts
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|np
operator|->
name|sc_media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_MANUAL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
operator|&
name|np
operator|->
name|sc_media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_MANUAL
argument_list|)
expr_stmt|;
name|np
operator|->
name|rx_target
operator|=
name|RX_MIN_TARGET
expr_stmt|;
name|np
operator|->
name|rx_min_target
operator|=
name|RX_MIN_TARGET
expr_stmt|;
name|np
operator|->
name|rx_max_target
operator|=
name|RX_MAX_TARGET
expr_stmt|;
comment|/* Initialise {tx,rx}_skbs to be a free chain containing every entry. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|NET_TX_RING_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|np
operator|->
name|tx_mbufs
index|[
name|i
index|]
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|u_long
operator|)
name|i
operator|+
literal|1
operator|)
expr_stmt|;
name|np
operator|->
name|grant_tx_ref
index|[
name|i
index|]
operator|=
name|GRANT_REF_INVALID
expr_stmt|;
block|}
name|np
operator|->
name|tx_mbufs
index|[
name|NET_TX_RING_SIZE
index|]
operator|=
operator|(
name|void
operator|*
operator|)
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|NET_RX_RING_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|np
operator|->
name|rx_mbufs
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|np
operator|->
name|grant_rx_ref
index|[
name|i
index|]
operator|=
name|GRANT_REF_INVALID
expr_stmt|;
block|}
comment|/* A grant for every tx ring slot */
if|if
condition|(
name|gnttab_alloc_grant_references
argument_list|(
name|NET_TX_RING_SIZE
argument_list|,
operator|&
name|np
operator|->
name|gref_tx_head
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|IPRINTK
argument_list|(
literal|"#### netfront can't alloc tx grant refs\n"
argument_list|)
expr_stmt|;
name|err
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|exit
goto|;
block|}
comment|/* A grant for every rx ring slot */
if|if
condition|(
name|gnttab_alloc_grant_references
argument_list|(
name|RX_MAX_TARGET
argument_list|,
operator|&
name|np
operator|->
name|gref_rx_head
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|WPRINTK
argument_list|(
literal|"#### netfront can't alloc rx grant refs\n"
argument_list|)
expr_stmt|;
name|gnttab_free_grant_references
argument_list|(
name|np
operator|->
name|gref_tx_head
argument_list|)
expr_stmt|;
name|err
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|exit
goto|;
block|}
name|err
operator|=
name|xen_net_read_mac
argument_list|(
name|dev
argument_list|,
name|np
operator|->
name|mac
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|xenbus_dev_fatal
argument_list|(
name|dev
argument_list|,
name|err
argument_list|,
literal|"parsing %s/mac"
argument_list|,
name|xenbus_get_node
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Set up ifnet structure */
name|ifp
operator|=
name|np
operator|->
name|xn_ifp
operator|=
name|if_alloc
argument_list|(
name|IFT_ETHER
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_softc
operator|=
name|np
expr_stmt|;
name|if_initname
argument_list|(
name|ifp
argument_list|,
literal|"xn"
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|xn_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_output
operator|=
name|ether_output
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|xn_start
expr_stmt|;
ifdef|#
directive|ifdef
name|notyet
name|ifp
operator|->
name|if_watchdog
operator|=
name|xn_watchdog
expr_stmt|;
endif|#
directive|endif
name|ifp
operator|->
name|if_init
operator|=
name|xn_ifinit
expr_stmt|;
name|ifp
operator|->
name|if_mtu
operator|=
name|ETHERMTU
expr_stmt|;
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_maxlen
operator|=
name|NET_TX_RING_SIZE
operator|-
literal|1
expr_stmt|;
name|ifp
operator|->
name|if_hwassist
operator|=
name|XN_CSUM_FEATURES
expr_stmt|;
name|ifp
operator|->
name|if_capabilities
operator|=
name|IFCAP_HWCSUM
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|700000
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_TSO4
expr_stmt|;
if|if
condition|(
name|xn_enable_lro
condition|)
block|{
name|int
name|err
init|=
name|tcp_lro_init
argument_list|(
operator|&
name|np
operator|->
name|xn_lro
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"LRO initialization failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|exit
goto|;
block|}
name|np
operator|->
name|xn_lro
operator|.
name|ifp
operator|=
name|ifp
expr_stmt|;
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_LRO
expr_stmt|;
block|}
endif|#
directive|endif
name|ifp
operator|->
name|if_capenable
operator|=
name|ifp
operator|->
name|if_capabilities
expr_stmt|;
name|ether_ifattach
argument_list|(
name|ifp
argument_list|,
name|np
operator|->
name|mac
argument_list|)
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|np
operator|->
name|xn_stat_ch
argument_list|,
name|CALLOUT_MPSAFE
argument_list|)
expr_stmt|;
name|netfront_carrier_off
argument_list|(
name|np
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|exit
label|:
name|gnttab_free_grant_references
argument_list|(
name|np
operator|->
name|gref_tx_head
argument_list|)
expr_stmt|;
name|out
label|:
name|panic
argument_list|(
literal|"do something smart"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Handle the change of state of the backend to Closing.  We must delete our  * device-layer structures now, to ensure that writes are flushed through to  * the backend.  Once is this done, we can switch to Closed in  * acknowledgement.  */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_if
unit|static void netfront_closing(device_t dev) {
if|#
directive|if
literal|0
end_if

begin_endif
unit|struct netfront_info *info = dev->dev_driver_data;  	DPRINTK("netfront_closing: %s removed\n", dev->nodename);  	close_netdev(info);
endif|#
directive|endif
end_endif

begin_endif
unit|xenbus_switch_state(dev, XenbusStateClosed); }
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|netfront_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|netfront_info
modifier|*
name|info
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|DPRINTK
argument_list|(
literal|"%s\n"
argument_list|,
name|xenbus_get_node
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|netif_free
argument_list|(
name|info
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|netif_free
parameter_list|(
name|struct
name|netfront_info
modifier|*
name|info
parameter_list|)
block|{
name|netif_disconnect_backend
argument_list|(
name|info
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|close_netdev(info);
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|netif_disconnect_backend
parameter_list|(
name|struct
name|netfront_info
modifier|*
name|info
parameter_list|)
block|{
name|XN_RX_LOCK
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|XN_TX_LOCK
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|netfront_carrier_off
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|XN_TX_UNLOCK
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|XN_RX_UNLOCK
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|end_access
argument_list|(
name|info
operator|->
name|tx_ring_ref
argument_list|,
name|info
operator|->
name|tx
operator|.
name|sring
argument_list|)
expr_stmt|;
name|end_access
argument_list|(
name|info
operator|->
name|rx_ring_ref
argument_list|,
name|info
operator|->
name|rx
operator|.
name|sring
argument_list|)
expr_stmt|;
name|info
operator|->
name|tx_ring_ref
operator|=
name|GRANT_REF_INVALID
expr_stmt|;
name|info
operator|->
name|rx_ring_ref
operator|=
name|GRANT_REF_INVALID
expr_stmt|;
name|info
operator|->
name|tx
operator|.
name|sring
operator|=
name|NULL
expr_stmt|;
name|info
operator|->
name|rx
operator|.
name|sring
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|irq
condition|)
name|unbind_from_irqhandler
argument_list|(
name|info
operator|->
name|irq
argument_list|)
expr_stmt|;
name|info
operator|->
name|irq
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|end_access
parameter_list|(
name|int
name|ref
parameter_list|,
name|void
modifier|*
name|page
parameter_list|)
block|{
if|if
condition|(
name|ref
operator|!=
name|GRANT_REF_INVALID
condition|)
name|gnttab_end_foreign_access
argument_list|(
name|ref
argument_list|,
name|page
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|xn_ifmedia_upd
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xn_ifmedia_sts
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|ifmediareq
modifier|*
name|ifmr
parameter_list|)
block|{
name|ifmr
operator|->
name|ifm_status
operator|=
name|IFM_AVALID
operator||
name|IFM_ACTIVE
expr_stmt|;
name|ifmr
operator|->
name|ifm_active
operator|=
name|IFM_ETHER
operator||
name|IFM_MANUAL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** Driver registration ** */
end_comment

begin_decl_stmt
specifier|static
name|device_method_t
name|netfront_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|netfront_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|netfront_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|netfront_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|bus_generic_shutdown
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|bus_generic_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|netfront_resume
argument_list|)
block|,
comment|/* Xenbus interface */
name|DEVMETHOD
argument_list|(
name|xenbus_otherend_changed
argument_list|,
name|netfront_backend_changed
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|netfront_driver
init|=
block|{
literal|"xn"
block|,
name|netfront_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|netfront_info
argument_list|)
block|,                       }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|devclass_t
name|netfront_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|xe
argument_list|,
name|xenbusb_front
argument_list|,
name|netfront_driver
argument_list|,
name|netfront_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

