begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  * Copyright (c) 2004-2006 Kip Macy  * All rights reserved.  *  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_comment
comment|/* for DELAY */
end_comment

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<machine/frame.h>
end_include

begin_include
include|#
directive|include
file|<machine/vmparam.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<machine/intr_machdep.h>
end_include

begin_include
include|#
directive|include
file|<machine/xen/xen-os.h>
end_include

begin_include
include|#
directive|include
file|<machine/xen/hypervisor.h>
end_include

begin_include
include|#
directive|include
file|<machine/xen/xen_intr.h>
end_include

begin_include
include|#
directive|include
file|<machine/xen/evtchn.h>
end_include

begin_include
include|#
directive|include
file|<machine/xen/xenbus.h>
end_include

begin_include
include|#
directive|include
file|<xen/gnttab.h>
end_include

begin_include
include|#
directive|include
file|<xen/interface/memory.h>
end_include

begin_include
include|#
directive|include
file|<dev/xen/netfront/mbufq.h>
end_include

begin_include
include|#
directive|include
file|<machine/xen/features.h>
end_include

begin_include
include|#
directive|include
file|<xen/interface/io/netif.h>
end_include

begin_define
define|#
directive|define
name|GRANT_INVALID_REF
value|0
end_define

begin_define
define|#
directive|define
name|NET_TX_RING_SIZE
value|__RING_SIZE((netif_tx_sring_t *)0, PAGE_SIZE)
end_define

begin_define
define|#
directive|define
name|NET_RX_RING_SIZE
value|__RING_SIZE((netif_rx_sring_t *)0, PAGE_SIZE)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|CONFIG_XEN
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|MODPARM_rx_copy
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|module_param_named
argument_list|(
name|rx_copy
argument_list|,
name|MODPARM_rx_copy
argument_list|,
name|bool
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_PARM_DESC
argument_list|(
name|rx_copy
argument_list|,
literal|"Copy packets from network card (rather than flip)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|MODPARM_rx_flip
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|module_param_named
argument_list|(
name|rx_flip
argument_list|,
name|MODPARM_rx_flip
argument_list|,
name|bool
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_PARM_DESC
argument_list|(
name|rx_flip
argument_list|,
literal|"Flip packets from network card (rather than copy)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
specifier|const
name|int
name|MODPARM_rx_copy
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|int
name|MODPARM_rx_flip
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|RX_COPY_THRESHOLD
value|256
end_define

begin_define
define|#
directive|define
name|net_ratelimit
parameter_list|()
value|0
end_define

begin_struct_decl
struct_decl|struct
name|netfront_info
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|netfront_rx_info
struct_decl|;
end_struct_decl

begin_function_decl
specifier|static
name|void
name|xn_txeof
parameter_list|(
name|struct
name|netfront_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xn_rxeof
parameter_list|(
name|struct
name|netfront_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|network_alloc_rx_buffers
parameter_list|(
name|struct
name|netfront_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xn_tick_locked
parameter_list|(
name|struct
name|netfront_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xn_tick
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xn_intr
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xn_start_locked
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xn_start
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xn_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|u_long
parameter_list|,
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xn_ifinit_locked
parameter_list|(
name|struct
name|netfront_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xn_ifinit
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xn_stop
parameter_list|(
name|struct
name|netfront_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|notyet
end_ifdef

begin_function_decl
specifier|static
name|void
name|xn_watchdog
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|show_device
parameter_list|(
name|struct
name|netfront_info
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|notyet
end_ifdef

begin_function_decl
specifier|static
name|void
name|netfront_closing
parameter_list|(
name|struct
name|xenbus_device
modifier|*
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|netif_free
parameter_list|(
name|struct
name|netfront_info
modifier|*
name|info
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|netfront_remove
parameter_list|(
name|struct
name|xenbus_device
modifier|*
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|talk_to_backend
parameter_list|(
name|struct
name|xenbus_device
modifier|*
name|dev
parameter_list|,
name|struct
name|netfront_info
modifier|*
name|info
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|create_netdev
parameter_list|(
name|struct
name|xenbus_device
modifier|*
name|dev
parameter_list|,
name|struct
name|ifnet
modifier|*
modifier|*
name|ifp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|netif_disconnect_backend
parameter_list|(
name|struct
name|netfront_info
modifier|*
name|info
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|setup_device
parameter_list|(
name|struct
name|xenbus_device
modifier|*
name|dev
parameter_list|,
name|struct
name|netfront_info
modifier|*
name|info
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|end_access
parameter_list|(
name|int
name|ref
parameter_list|,
name|void
modifier|*
name|page
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Xenolinux helper functions */
end_comment

begin_function_decl
specifier|static
name|int
name|network_connect
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xn_free_rx_ring
parameter_list|(
name|struct
name|netfront_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xn_free_tx_ring
parameter_list|(
name|struct
name|netfront_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xennet_get_responses
parameter_list|(
name|struct
name|netfront_info
modifier|*
name|np
parameter_list|,
name|struct
name|netfront_rx_info
modifier|*
name|rinfo
parameter_list|,
name|RING_IDX
name|rp
parameter_list|,
name|struct
name|mbuf_head
modifier|*
name|list
parameter_list|,
name|int
modifier|*
name|pages_flipped_p
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|virt_to_mfn
parameter_list|(
name|x
parameter_list|)
value|(vtomach(x)>> PAGE_SHIFT)
end_define

begin_define
define|#
directive|define
name|INVALID_P2M_ENTRY
value|(~0UL)
end_define

begin_comment
comment|/*  * Mbuf pointers. We need these to keep track of the virtual addresses  * of our mbuf chains since we can only convert from virtual to physical,  * not the other way around.  The size must track the free index arrays.  */
end_comment

begin_struct
struct|struct
name|xn_chain_data
block|{
name|struct
name|mbuf
modifier|*
name|xn_tx_chain
index|[
name|NET_TX_RING_SIZE
operator|+
literal|1
index|]
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|xn_rx_chain
index|[
name|NET_RX_RING_SIZE
operator|+
literal|1
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|net_device_stats
block|{
name|u_long
name|rx_packets
decl_stmt|;
comment|/* total packets received	*/
name|u_long
name|tx_packets
decl_stmt|;
comment|/* total packets transmitted	*/
name|u_long
name|rx_bytes
decl_stmt|;
comment|/* total bytes received 	*/
name|u_long
name|tx_bytes
decl_stmt|;
comment|/* total bytes transmitted	*/
name|u_long
name|rx_errors
decl_stmt|;
comment|/* bad packets received		*/
name|u_long
name|tx_errors
decl_stmt|;
comment|/* packet transmit problems	*/
name|u_long
name|rx_dropped
decl_stmt|;
comment|/* no space in linux buffers	*/
name|u_long
name|tx_dropped
decl_stmt|;
comment|/* no space available in linux	*/
name|u_long
name|multicast
decl_stmt|;
comment|/* multicast packets received	*/
name|u_long
name|collisions
decl_stmt|;
comment|/* detailed rx_errors: */
name|u_long
name|rx_length_errors
decl_stmt|;
name|u_long
name|rx_over_errors
decl_stmt|;
comment|/* receiver ring buff overflow	*/
name|u_long
name|rx_crc_errors
decl_stmt|;
comment|/* recved pkt with crc error	*/
name|u_long
name|rx_frame_errors
decl_stmt|;
comment|/* recv'd frame alignment error */
name|u_long
name|rx_fifo_errors
decl_stmt|;
comment|/* recv'r fifo overrun		*/
name|u_long
name|rx_missed_errors
decl_stmt|;
comment|/* receiver missed packet	*/
comment|/* detailed tx_errors */
name|u_long
name|tx_aborted_errors
decl_stmt|;
name|u_long
name|tx_carrier_errors
decl_stmt|;
name|u_long
name|tx_fifo_errors
decl_stmt|;
name|u_long
name|tx_heartbeat_errors
decl_stmt|;
name|u_long
name|tx_window_errors
decl_stmt|;
comment|/* for cslip etc */
name|u_long
name|rx_compressed
decl_stmt|;
name|u_long
name|tx_compressed
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|netfront_info
block|{
name|struct
name|ifnet
modifier|*
name|xn_ifp
decl_stmt|;
name|struct
name|net_device_stats
name|stats
decl_stmt|;
name|u_int
name|tx_full
decl_stmt|;
name|netif_tx_front_ring_t
name|tx
decl_stmt|;
name|netif_rx_front_ring_t
name|rx
decl_stmt|;
name|struct
name|mtx
name|tx_lock
decl_stmt|;
name|struct
name|mtx
name|rx_lock
decl_stmt|;
name|struct
name|sx
name|sc_lock
decl_stmt|;
name|u_int
name|handle
decl_stmt|;
name|u_int
name|irq
decl_stmt|;
name|u_int
name|copying_receiver
decl_stmt|;
name|u_int
name|carrier
decl_stmt|;
comment|/* Receive-ring batched refills. */
define|#
directive|define
name|RX_MIN_TARGET
value|32
define|#
directive|define
name|RX_MAX_TARGET
value|NET_RX_RING_SIZE
name|int
name|rx_min_target
decl_stmt|,
name|rx_max_target
decl_stmt|,
name|rx_target
decl_stmt|;
comment|/* 	 * {tx,rx}_skbs store outstanding skbuffs. The first entry in each 	 * array is an index into a chain of free entries. 	 */
name|grant_ref_t
name|gref_tx_head
decl_stmt|;
name|grant_ref_t
name|grant_tx_ref
index|[
name|NET_TX_RING_SIZE
operator|+
literal|1
index|]
decl_stmt|;
name|grant_ref_t
name|gref_rx_head
decl_stmt|;
name|grant_ref_t
name|grant_rx_ref
index|[
name|NET_TX_RING_SIZE
operator|+
literal|1
index|]
decl_stmt|;
define|#
directive|define
name|TX_MAX_TARGET
value|min(NET_RX_RING_SIZE, 256)
name|struct
name|xenbus_device
modifier|*
name|xbdev
decl_stmt|;
name|int
name|tx_ring_ref
decl_stmt|;
name|int
name|rx_ring_ref
decl_stmt|;
name|uint8_t
name|mac
index|[
name|ETHER_ADDR_LEN
index|]
decl_stmt|;
name|struct
name|xn_chain_data
name|xn_cdata
decl_stmt|;
comment|/* mbufs */
name|struct
name|mbuf_head
name|xn_rx_batch
decl_stmt|;
comment|/* head of the batch queue */
name|int
name|xn_if_flags
decl_stmt|;
name|struct
name|callout
name|xn_stat_ch
decl_stmt|;
name|u_long
name|rx_pfn_array
index|[
name|NET_RX_RING_SIZE
index|]
decl_stmt|;
name|multicall_entry_t
name|rx_mcl
index|[
name|NET_RX_RING_SIZE
operator|+
literal|1
index|]
decl_stmt|;
name|mmu_update_t
name|rx_mmu
index|[
name|NET_RX_RING_SIZE
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|rx_mbufs
value|xn_cdata.xn_rx_chain
end_define

begin_define
define|#
directive|define
name|tx_mbufs
value|xn_cdata.xn_tx_chain
end_define

begin_define
define|#
directive|define
name|XN_LOCK_INIT
parameter_list|(
name|_sc
parameter_list|,
name|_name
parameter_list|)
define|\
value|mtx_init(&(_sc)->tx_lock, #_name"_tx", "network transmit lock", MTX_DEF); \         mtx_init(&(_sc)->rx_lock, #_name"_rx", "network receive lock", MTX_DEF);  \         sx_init(&(_sc)->sc_lock, #_name"_rx")
end_define

begin_define
define|#
directive|define
name|XN_RX_LOCK
parameter_list|(
name|_sc
parameter_list|)
value|mtx_lock(&(_sc)->rx_lock)
end_define

begin_define
define|#
directive|define
name|XN_RX_UNLOCK
parameter_list|(
name|_sc
parameter_list|)
value|mtx_unlock(&(_sc)->rx_lock)
end_define

begin_define
define|#
directive|define
name|XN_TX_LOCK
parameter_list|(
name|_sc
parameter_list|)
value|mtx_lock(&(_sc)->tx_lock)
end_define

begin_define
define|#
directive|define
name|XN_TX_UNLOCK
parameter_list|(
name|_sc
parameter_list|)
value|mtx_unlock(&(_sc)->tx_lock)
end_define

begin_define
define|#
directive|define
name|XN_LOCK
parameter_list|(
name|_sc
parameter_list|)
value|sx_xlock(&(_sc)->sc_lock);
end_define

begin_define
define|#
directive|define
name|XN_UNLOCK
parameter_list|(
name|_sc
parameter_list|)
value|sx_xunlock(&(_sc)->sc_lock);
end_define

begin_define
define|#
directive|define
name|XN_LOCK_ASSERT
parameter_list|(
name|_sc
parameter_list|)
value|sx_assert(&(_sc)->sc_lock, SX_LOCKED);
end_define

begin_define
define|#
directive|define
name|XN_RX_LOCK_ASSERT
parameter_list|(
name|_sc
parameter_list|)
value|mtx_assert(&(_sc)->rx_lock, MA_OWNED);
end_define

begin_define
define|#
directive|define
name|XN_TX_LOCK_ASSERT
parameter_list|(
name|_sc
parameter_list|)
value|mtx_assert(&(_sc)->tx_lock, MA_OWNED);
end_define

begin_define
define|#
directive|define
name|XN_LOCK_DESTROY
parameter_list|(
name|_sc
parameter_list|)
value|mtx_destroy(&(_sc)->rx_lock); \                                mtx_destroy(&(_sc)->tx_lock); \                                sx_destroy(&(_sc)->sc_lock);
end_define

begin_struct
struct|struct
name|netfront_rx_info
block|{
name|struct
name|netif_rx_response
name|rx
decl_stmt|;
name|struct
name|netif_extra_info
name|extras
index|[
name|XEN_NETIF_EXTRA_TYPE_MAX
operator|-
literal|1
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|netfront_carrier_on
parameter_list|(
name|netif
parameter_list|)
value|((netif)->carrier = 1)
end_define

begin_define
define|#
directive|define
name|netfront_carrier_off
parameter_list|(
name|netif
parameter_list|)
value|((netif)->carrier = 0)
end_define

begin_define
define|#
directive|define
name|netfront_carrier_ok
parameter_list|(
name|netif
parameter_list|)
value|((netif)->carrier)
end_define

begin_comment
comment|/* Access macros for acquiring freeing slots in xn_free_{tx,rx}_idxs[]. */
end_comment

begin_comment
comment|/*  * Access macros for acquiring freeing slots in tx_skbs[].  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|add_id_to_freelist
parameter_list|(
name|struct
name|mbuf
modifier|*
modifier|*
name|list
parameter_list|,
name|unsigned
name|short
name|id
parameter_list|)
block|{
name|list
index|[
name|id
index|]
operator|=
name|list
index|[
literal|0
index|]
expr_stmt|;
name|list
index|[
literal|0
index|]
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|u_long
operator|)
name|id
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|unsigned
name|short
name|get_id_from_freelist
parameter_list|(
name|struct
name|mbuf
modifier|*
modifier|*
name|list
parameter_list|)
block|{
name|u_int
name|id
init|=
operator|(
name|u_int
operator|)
operator|(
name|u_long
operator|)
name|list
index|[
literal|0
index|]
decl_stmt|;
name|list
index|[
literal|0
index|]
operator|=
name|list
index|[
name|id
index|]
expr_stmt|;
return|return
operator|(
name|id
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|xennet_rxidx
parameter_list|(
name|RING_IDX
name|idx
parameter_list|)
block|{
return|return
name|idx
operator|&
operator|(
name|NET_RX_RING_SIZE
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|struct
name|mbuf
modifier|*
name|xennet_get_rx_mbuf
parameter_list|(
name|struct
name|netfront_info
modifier|*
name|np
parameter_list|,
name|RING_IDX
name|ri
parameter_list|)
block|{
name|int
name|i
init|=
name|xennet_rxidx
argument_list|(
name|ri
argument_list|)
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|m
operator|=
name|np
operator|->
name|rx_mbufs
index|[
name|i
index|]
expr_stmt|;
name|np
operator|->
name|rx_mbufs
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|grant_ref_t
name|xennet_get_rx_ref
parameter_list|(
name|struct
name|netfront_info
modifier|*
name|np
parameter_list|,
name|RING_IDX
name|ri
parameter_list|)
block|{
name|int
name|i
init|=
name|xennet_rxidx
argument_list|(
name|ri
argument_list|)
decl_stmt|;
name|grant_ref_t
name|ref
init|=
name|np
operator|->
name|grant_rx_ref
index|[
name|i
index|]
decl_stmt|;
name|np
operator|->
name|grant_rx_ref
index|[
name|i
index|]
operator|=
name|GRANT_INVALID_REF
expr_stmt|;
return|return
name|ref
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|IPRINTK
parameter_list|(
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
define|\
value|printf("[XEN] " fmt, ##args)
end_define

begin_define
define|#
directive|define
name|WPRINTK
parameter_list|(
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
define|\
value|printf("[XEN] " fmt, ##args)
end_define

begin_define
define|#
directive|define
name|DPRINTK
parameter_list|(
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
define|\
value|printf("[XEN] " fmt, ##args)
end_define

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|mbuf
operator|*
name|makembuf
argument_list|(
argument|struct mbuf *buf
argument_list|)
block|{ 	struct
name|mbuf
operator|*
name|m
operator|=
name|NULL
block|;
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
block|;
if|if
condition|(
operator|!
name|m
condition|)
return|return
literal|0
return|;
name|M_MOVE_PKTHDR
argument_list|(
name|m
argument_list|,
name|buf
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|m_cljget
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MJUMPAGESIZE
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|buf
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|m
operator|->
name|m_len
operator|=
name|buf
operator|->
name|m_len
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|m_copydata
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|buf
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|m
operator|->
name|m_ext
operator|.
name|ext_arg1
operator|=
operator|(
name|caddr_t
operator|*
operator|)
call|(
name|uintptr_t
call|)
argument_list|(
name|vtophys
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|)
operator|>>
name|PAGE_SHIFT
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|m
return|;
end_return

begin_comment
unit|}
comment|/**  * Read the 'mac' node at the given device's node in the store, and parse that  * as colon-separated octets, placing result the given mac array.  mac must be  * a preallocated array of length ETH_ALEN (as declared in linux/if_ether.h).  * Return 0 on success, or errno on error.  */
end_comment

begin_function
unit|static
name|int
name|xen_net_read_mac
parameter_list|(
name|struct
name|xenbus_device
modifier|*
name|dev
parameter_list|,
name|uint8_t
name|mac
index|[]
parameter_list|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|e
decl_stmt|;
name|char
modifier|*
name|macstr
init|=
name|xenbus_read
argument_list|(
name|XBT_NIL
argument_list|,
name|dev
operator|->
name|nodename
argument_list|,
literal|"mac"
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|IS_ERR
argument_list|(
name|macstr
argument_list|)
condition|)
block|{
return|return
name|PTR_ERR
argument_list|(
name|macstr
argument_list|)
return|;
block|}
name|s
operator|=
name|macstr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ETHER_ADDR_LEN
condition|;
name|i
operator|++
control|)
block|{
name|mac
index|[
name|i
index|]
operator|=
name|strtoul
argument_list|(
name|s
argument_list|,
operator|&
name|e
argument_list|,
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|e
operator|||
operator|(
name|e
index|[
literal|0
index|]
operator|!=
literal|':'
operator|&&
name|e
index|[
literal|0
index|]
operator|!=
literal|0
operator|)
condition|)
block|{
name|free
argument_list|(
name|macstr
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
name|ENOENT
return|;
block|}
name|s
operator|=
operator|&
name|e
index|[
literal|1
index|]
expr_stmt|;
block|}
name|free
argument_list|(
name|macstr
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Entry point to this code when a new device is created.  Allocate the basic  * structures and the ring buffers for communication with the backend, and  * inform the backend of the appropriate details for those.  Switch to  * Connected state.  */
end_comment

begin_function
specifier|static
name|int
name|netfront_probe
parameter_list|(
name|struct
name|xenbus_device
modifier|*
name|dev
parameter_list|,
specifier|const
name|struct
name|xenbus_device_id
modifier|*
name|id
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|netfront_info
modifier|*
name|info
decl_stmt|;
name|printf
argument_list|(
literal|"netfront_probe() \n"
argument_list|)
expr_stmt|;
name|err
operator|=
name|create_netdev
argument_list|(
name|dev
argument_list|,
operator|&
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|xenbus_dev_fatal
argument_list|(
name|dev
argument_list|,
name|err
argument_list|,
literal|"creating netdev"
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
name|info
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|dev
operator|->
name|dev_driver_data
operator|=
name|info
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * We are reconnecting to the backend, due to a suspend/resume, or a backend  * driver restart.  We tear down our netif structure and recreate it, but  * leave the device-layer structures intact so that this is transparent to the  * rest of the kernel.  */
end_comment

begin_function
specifier|static
name|int
name|netfront_resume
parameter_list|(
name|struct
name|xenbus_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|netfront_info
modifier|*
name|info
init|=
name|dev
operator|->
name|dev_driver_data
decl_stmt|;
name|DPRINTK
argument_list|(
literal|"%s\n"
argument_list|,
name|dev
operator|->
name|nodename
argument_list|)
expr_stmt|;
name|netif_disconnect_backend
argument_list|(
name|info
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Common code used when first setting up, and when resuming. */
end_comment

begin_function
specifier|static
name|int
name|talk_to_backend
parameter_list|(
name|struct
name|xenbus_device
modifier|*
name|dev
parameter_list|,
name|struct
name|netfront_info
modifier|*
name|info
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|message
decl_stmt|;
name|struct
name|xenbus_transaction
name|xbt
decl_stmt|;
name|int
name|err
decl_stmt|;
name|err
operator|=
name|xen_net_read_mac
argument_list|(
name|dev
argument_list|,
name|info
operator|->
name|mac
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|xenbus_dev_fatal
argument_list|(
name|dev
argument_list|,
name|err
argument_list|,
literal|"parsing %s/mac"
argument_list|,
name|dev
operator|->
name|nodename
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Create shared ring, alloc event channel. */
name|err
operator|=
name|setup_device
argument_list|(
name|dev
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
name|again
label|:
name|err
operator|=
name|xenbus_transaction_start
argument_list|(
operator|&
name|xbt
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|xenbus_dev_fatal
argument_list|(
name|dev
argument_list|,
name|err
argument_list|,
literal|"starting transaction"
argument_list|)
expr_stmt|;
goto|goto
name|destroy_ring
goto|;
block|}
name|err
operator|=
name|xenbus_printf
argument_list|(
name|xbt
argument_list|,
name|dev
operator|->
name|nodename
argument_list|,
literal|"tx-ring-ref"
argument_list|,
literal|"%u"
argument_list|,
name|info
operator|->
name|tx_ring_ref
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|message
operator|=
literal|"writing tx ring-ref"
expr_stmt|;
goto|goto
name|abort_transaction
goto|;
block|}
name|err
operator|=
name|xenbus_printf
argument_list|(
name|xbt
argument_list|,
name|dev
operator|->
name|nodename
argument_list|,
literal|"rx-ring-ref"
argument_list|,
literal|"%u"
argument_list|,
name|info
operator|->
name|rx_ring_ref
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|message
operator|=
literal|"writing rx ring-ref"
expr_stmt|;
goto|goto
name|abort_transaction
goto|;
block|}
name|err
operator|=
name|xenbus_printf
argument_list|(
name|xbt
argument_list|,
name|dev
operator|->
name|nodename
argument_list|,
literal|"event-channel"
argument_list|,
literal|"%u"
argument_list|,
name|irq_to_evtchn_port
argument_list|(
name|info
operator|->
name|irq
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|message
operator|=
literal|"writing event-channel"
expr_stmt|;
goto|goto
name|abort_transaction
goto|;
block|}
name|err
operator|=
name|xenbus_printf
argument_list|(
name|xbt
argument_list|,
name|dev
operator|->
name|nodename
argument_list|,
literal|"request-rx-copy"
argument_list|,
literal|"%u"
argument_list|,
name|info
operator|->
name|copying_receiver
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|message
operator|=
literal|"writing request-rx-copy"
expr_stmt|;
goto|goto
name|abort_transaction
goto|;
block|}
name|err
operator|=
name|xenbus_printf
argument_list|(
name|xbt
argument_list|,
name|dev
operator|->
name|nodename
argument_list|,
literal|"feature-rx-notify"
argument_list|,
literal|"%d"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|message
operator|=
literal|"writing feature-rx-notify"
expr_stmt|;
goto|goto
name|abort_transaction
goto|;
block|}
name|err
operator|=
name|xenbus_printf
argument_list|(
name|xbt
argument_list|,
name|dev
operator|->
name|nodename
argument_list|,
literal|"feature-no-csum-offload"
argument_list|,
literal|"%d"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|message
operator|=
literal|"writing feature-no-csum-offload"
expr_stmt|;
goto|goto
name|abort_transaction
goto|;
block|}
name|err
operator|=
name|xenbus_printf
argument_list|(
name|xbt
argument_list|,
name|dev
operator|->
name|nodename
argument_list|,
literal|"feature-sg"
argument_list|,
literal|"%d"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|message
operator|=
literal|"writing feature-sg"
expr_stmt|;
goto|goto
name|abort_transaction
goto|;
block|}
ifdef|#
directive|ifdef
name|HAVE_TSO
name|err
operator|=
name|xenbus_printf
argument_list|(
name|xbt
argument_list|,
name|dev
operator|->
name|nodename
argument_list|,
literal|"feature-gso-tcpv4"
argument_list|,
literal|"%d"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|message
operator|=
literal|"writing feature-gso-tcpv4"
expr_stmt|;
goto|goto
name|abort_transaction
goto|;
block|}
endif|#
directive|endif
name|err
operator|=
name|xenbus_transaction_end
argument_list|(
name|xbt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|==
name|EAGAIN
condition|)
goto|goto
name|again
goto|;
name|xenbus_dev_fatal
argument_list|(
name|dev
argument_list|,
name|err
argument_list|,
literal|"completing transaction"
argument_list|)
expr_stmt|;
goto|goto
name|destroy_ring
goto|;
block|}
return|return
literal|0
return|;
name|abort_transaction
label|:
name|xenbus_transaction_end
argument_list|(
name|xbt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xenbus_dev_fatal
argument_list|(
name|dev
argument_list|,
name|err
argument_list|,
literal|"%s"
argument_list|,
name|message
argument_list|)
expr_stmt|;
name|destroy_ring
label|:
name|netif_free
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|setup_device
parameter_list|(
name|struct
name|xenbus_device
modifier|*
name|dev
parameter_list|,
name|struct
name|netfront_info
modifier|*
name|info
parameter_list|)
block|{
name|netif_tx_sring_t
modifier|*
name|txs
decl_stmt|;
name|netif_rx_sring_t
modifier|*
name|rxs
decl_stmt|;
name|int
name|err
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|ifp
operator|=
name|info
operator|->
name|xn_ifp
expr_stmt|;
name|info
operator|->
name|tx_ring_ref
operator|=
name|GRANT_INVALID_REF
expr_stmt|;
name|info
operator|->
name|rx_ring_ref
operator|=
name|GRANT_INVALID_REF
expr_stmt|;
name|info
operator|->
name|rx
operator|.
name|sring
operator|=
name|NULL
expr_stmt|;
name|info
operator|->
name|tx
operator|.
name|sring
operator|=
name|NULL
expr_stmt|;
name|info
operator|->
name|irq
operator|=
literal|0
expr_stmt|;
name|txs
operator|=
operator|(
name|netif_tx_sring_t
operator|*
operator|)
name|malloc
argument_list|(
name|PAGE_SIZE
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|txs
condition|)
block|{
name|err
operator|=
name|ENOMEM
expr_stmt|;
name|xenbus_dev_fatal
argument_list|(
name|dev
argument_list|,
name|err
argument_list|,
literal|"allocating tx ring page"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|SHARED_RING_INIT
argument_list|(
name|txs
argument_list|)
expr_stmt|;
name|FRONT_RING_INIT
argument_list|(
operator|&
name|info
operator|->
name|tx
argument_list|,
name|txs
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|err
operator|=
name|xenbus_grant_ring
argument_list|(
name|dev
argument_list|,
name|virt_to_mfn
argument_list|(
name|txs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|<
literal|0
condition|)
goto|goto
name|fail
goto|;
name|info
operator|->
name|tx_ring_ref
operator|=
name|err
expr_stmt|;
name|rxs
operator|=
operator|(
name|netif_rx_sring_t
operator|*
operator|)
name|malloc
argument_list|(
name|PAGE_SIZE
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rxs
condition|)
block|{
name|err
operator|=
name|ENOMEM
expr_stmt|;
name|xenbus_dev_fatal
argument_list|(
name|dev
argument_list|,
name|err
argument_list|,
literal|"allocating rx ring page"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|SHARED_RING_INIT
argument_list|(
name|rxs
argument_list|)
expr_stmt|;
name|FRONT_RING_INIT
argument_list|(
operator|&
name|info
operator|->
name|rx
argument_list|,
name|rxs
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|err
operator|=
name|xenbus_grant_ring
argument_list|(
name|dev
argument_list|,
name|virt_to_mfn
argument_list|(
name|rxs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|<
literal|0
condition|)
goto|goto
name|fail
goto|;
name|info
operator|->
name|rx_ring_ref
operator|=
name|err
expr_stmt|;
if|#
directive|if
literal|0
block|network_connect(ifp);
endif|#
directive|endif
name|err
operator|=
name|bind_listening_port_to_irqhandler
argument_list|(
name|dev
operator|->
name|otherend_id
argument_list|,
literal|"xn"
argument_list|,
name|xn_intr
argument_list|,
name|info
argument_list|,
name|INTR_TYPE_NET
operator||
name|INTR_MPSAFE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|<=
literal|0
condition|)
block|{
name|xenbus_dev_fatal
argument_list|(
name|dev
argument_list|,
name|err
argument_list|,
literal|"bind_evtchn_to_irqhandler failed"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|info
operator|->
name|irq
operator|=
name|err
expr_stmt|;
name|show_device
argument_list|(
name|info
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|fail
label|:
name|netif_free
argument_list|(
name|info
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_comment
comment|/**  * Callback received when the backend's state changes.  */
end_comment

begin_function
specifier|static
name|void
name|backend_changed
parameter_list|(
name|struct
name|xenbus_device
modifier|*
name|dev
parameter_list|,
name|XenbusState
name|backend_state
parameter_list|)
block|{
name|struct
name|netfront_info
modifier|*
name|sc
init|=
name|dev
operator|->
name|dev_driver_data
decl_stmt|;
name|DPRINTK
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|backend_state
condition|)
block|{
case|case
name|XenbusStateInitialising
case|:
case|case
name|XenbusStateInitialised
case|:
case|case
name|XenbusStateConnected
case|:
case|case
name|XenbusStateUnknown
case|:
case|case
name|XenbusStateClosed
case|:
break|break;
case|case
name|XenbusStateInitWait
case|:
if|if
condition|(
name|dev
operator|->
name|state
operator|!=
name|XenbusStateInitialising
condition|)
break|break;
if|if
condition|(
name|network_connect
argument_list|(
name|sc
operator|->
name|xn_ifp
argument_list|)
operator|!=
literal|0
condition|)
break|break;
name|xenbus_switch_state
argument_list|(
name|dev
argument_list|,
name|XenbusStateConnected
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|notyet
operator|(
name|void
operator|)
name|send_fake_arp
argument_list|(
name|netdev
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
break|break;
case|case
name|XenbusStateClosing
case|:
name|xenbus_frontend_closed
argument_list|(
name|dev
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|xn_free_rx_ring
parameter_list|(
name|struct
name|netfront_info
modifier|*
name|sc
parameter_list|)
block|{
if|#
directive|if
literal|0
block|int i; 	 	for (i = 0; i< NET_RX_RING_SIZE; i++) { 		if (sc->xn_cdata.xn_rx_chain[i] != NULL) { 			m_freem(sc->xn_cdata.xn_rx_chain[i]); 			sc->xn_cdata.xn_rx_chain[i] = NULL; 		} 	} 	 	sc->rx.rsp_cons = 0; 	sc->xn_rx_if->req_prod = 0; 	sc->xn_rx_if->event = sc->rx.rsp_cons ;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|xn_free_tx_ring
parameter_list|(
name|struct
name|netfront_info
modifier|*
name|sc
parameter_list|)
block|{
if|#
directive|if
literal|0
block|int i; 	 	for (i = 0; i< NET_TX_RING_SIZE; i++) { 		if (sc->xn_cdata.xn_tx_chain[i] != NULL) { 			m_freem(sc->xn_cdata.xn_tx_chain[i]); 			sc->xn_cdata.xn_tx_chain[i] = NULL; 		} 	} 	 	return;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|netfront_tx_slot_available
parameter_list|(
name|struct
name|netfront_info
modifier|*
name|np
parameter_list|)
block|{
return|return
operator|(
operator|(
name|np
operator|->
name|tx
operator|.
name|req_prod_pvt
operator|-
name|np
operator|->
name|tx
operator|.
name|rsp_cons
operator|)
operator|<
operator|(
name|TX_MAX_TARGET
operator|-
comment|/* MAX_SKB_FRAGS */
literal|24
operator|-
literal|2
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|netif_release_tx_bufs
parameter_list|(
name|struct
name|netfront_info
modifier|*
name|np
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|NET_TX_RING_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|m
operator|=
name|np
operator|->
name|xn_cdata
operator|.
name|xn_tx_chain
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|u_long
operator|)
name|m
operator|)
operator|<
name|KERNBASE
condition|)
continue|continue;
name|gnttab_grant_foreign_access_ref
argument_list|(
name|np
operator|->
name|grant_tx_ref
index|[
name|i
index|]
argument_list|,
name|np
operator|->
name|xbdev
operator|->
name|otherend_id
argument_list|,
name|virt_to_mfn
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|vm_offset_t
argument_list|)
argument_list|)
argument_list|,
name|GNTMAP_readonly
argument_list|)
expr_stmt|;
name|gnttab_release_grant_reference
argument_list|(
operator|&
name|np
operator|->
name|gref_tx_head
argument_list|,
name|np
operator|->
name|grant_tx_ref
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|np
operator|->
name|grant_tx_ref
index|[
name|i
index|]
operator|=
name|GRANT_INVALID_REF
expr_stmt|;
name|add_id_to_freelist
argument_list|(
name|np
operator|->
name|tx_mbufs
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|network_alloc_rx_buffers
parameter_list|(
name|struct
name|netfront_info
modifier|*
name|sc
parameter_list|)
block|{
name|unsigned
name|short
name|id
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m_new
decl_stmt|;
name|int
name|i
decl_stmt|,
name|batch_target
decl_stmt|,
name|notify
decl_stmt|;
name|RING_IDX
name|req_prod
decl_stmt|;
name|struct
name|xen_memory_reservation
name|reservation
decl_stmt|;
name|grant_ref_t
name|ref
decl_stmt|;
name|int
name|nr_flips
decl_stmt|;
name|netif_rx_request_t
modifier|*
name|req
decl_stmt|;
name|vm_offset_t
name|vaddr
decl_stmt|;
name|u_long
name|pfn
decl_stmt|;
name|req_prod
operator|=
name|sc
operator|->
name|rx
operator|.
name|req_prod_pvt
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|sc
operator|->
name|carrier
operator|==
literal|0
argument_list|)
condition|)
return|return;
comment|/* 	 * Allocate skbuffs greedily, even though we batch updates to the 	 * receive ring. This creates a less bursty demand on the memory 	 * allocator, so should reduce the chance of failed allocation 	 * requests both for ourself and for other kernel subsystems. 	 */
name|batch_target
operator|=
name|sc
operator|->
name|rx_target
operator|-
operator|(
name|req_prod
operator|-
name|sc
operator|->
name|rx
operator|.
name|rsp_cons
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|mbufq_len
argument_list|(
operator|&
name|sc
operator|->
name|xn_rx_batch
argument_list|)
init|;
name|i
operator|<
name|batch_target
condition|;
name|i
operator|++
control|)
block|{
name|MGETHDR
argument_list|(
name|m_new
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_new
operator|==
name|NULL
condition|)
goto|goto
name|no_mbuf
goto|;
name|m_cljget
argument_list|(
name|m_new
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MJUMPAGESIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m_new
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m_new
argument_list|)
expr_stmt|;
name|no_mbuf
label|:
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
goto|goto
name|refill
goto|;
comment|/* 			 * XXX set timer 			 */
break|break;
block|}
name|m_new
operator|->
name|m_len
operator|=
name|m_new
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|MJUMPAGESIZE
expr_stmt|;
comment|/* queue the mbufs allocated */
name|mbufq_tail
argument_list|(
operator|&
name|sc
operator|->
name|xn_rx_batch
argument_list|,
name|m_new
argument_list|)
expr_stmt|;
block|}
comment|/* Is the batch large enough to be worthwhile? */
if|if
condition|(
name|i
operator|<
operator|(
name|sc
operator|->
name|rx_target
operator|/
literal|2
operator|)
condition|)
block|{
if|if
condition|(
name|req_prod
operator|>
name|sc
operator|->
name|rx
operator|.
name|sring
operator|->
name|req_prod
condition|)
goto|goto
name|push
goto|;
return|return;
block|}
comment|/* Adjust floating fill target if we risked running out of buffers. */
if|if
condition|(
operator|(
operator|(
name|req_prod
operator|-
name|sc
operator|->
name|rx
operator|.
name|sring
operator|->
name|rsp_prod
operator|)
operator|<
operator|(
name|sc
operator|->
name|rx_target
operator|/
literal|4
operator|)
operator|)
operator|&&
operator|(
operator|(
name|sc
operator|->
name|rx_target
operator|*=
literal|2
operator|)
operator|>
name|sc
operator|->
name|rx_max_target
operator|)
condition|)
name|sc
operator|->
name|rx_target
operator|=
name|sc
operator|->
name|rx_max_target
expr_stmt|;
name|refill
label|:
for|for
control|(
name|nr_flips
operator|=
name|i
operator|=
literal|0
init|;
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|m_new
operator|=
name|mbufq_dequeue
argument_list|(
operator|&
name|sc
operator|->
name|xn_rx_batch
argument_list|)
operator|)
operator|==
name|NULL
condition|)
break|break;
name|m_new
operator|->
name|m_ext
operator|.
name|ext_arg1
operator|=
operator|(
name|vm_paddr_t
operator|*
operator|)
call|(
name|uintptr_t
call|)
argument_list|(
name|vtophys
argument_list|(
name|m_new
operator|->
name|m_ext
operator|.
name|ext_buf
argument_list|)
operator|>>
name|PAGE_SHIFT
argument_list|)
expr_stmt|;
name|id
operator|=
name|xennet_rxidx
argument_list|(
name|req_prod
operator|+
name|i
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|xn_cdata
operator|.
name|xn_rx_chain
index|[
name|id
index|]
operator|==
name|NULL
argument_list|,
operator|(
literal|"non-NULL xm_rx_chain"
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|xn_cdata
operator|.
name|xn_rx_chain
index|[
name|id
index|]
operator|=
name|m_new
expr_stmt|;
name|ref
operator|=
name|gnttab_claim_grant_reference
argument_list|(
operator|&
name|sc
operator|->
name|gref_rx_head
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|short
operator|)
name|ref
operator|>=
literal|0
argument_list|,
operator|(
literal|"negative ref"
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|grant_rx_ref
index|[
name|id
index|]
operator|=
name|ref
expr_stmt|;
name|vaddr
operator|=
name|mtod
argument_list|(
name|m_new
argument_list|,
name|vm_offset_t
argument_list|)
expr_stmt|;
name|pfn
operator|=
name|vtophys
argument_list|(
name|vaddr
argument_list|)
operator|>>
name|PAGE_SHIFT
expr_stmt|;
name|req
operator|=
name|RING_GET_REQUEST
argument_list|(
operator|&
name|sc
operator|->
name|rx
argument_list|,
name|req_prod
operator|+
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|copying_receiver
operator|==
literal|0
condition|)
block|{
name|gnttab_grant_foreign_transfer_ref
argument_list|(
name|ref
argument_list|,
name|sc
operator|->
name|xbdev
operator|->
name|otherend_id
argument_list|,
name|pfn
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rx_pfn_array
index|[
name|nr_flips
index|]
operator|=
name|PFNTOMFN
argument_list|(
name|pfn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xen_feature
argument_list|(
name|XENFEAT_auto_translated_physmap
argument_list|)
condition|)
block|{
comment|/* Remove this page before passing 				 * back to Xen. 				 */
name|set_phys_to_machine
argument_list|(
name|pfn
argument_list|,
name|INVALID_P2M_ENTRY
argument_list|)
expr_stmt|;
name|MULTI_update_va_mapping
argument_list|(
operator|&
name|sc
operator|->
name|rx_mcl
index|[
name|i
index|]
argument_list|,
name|vaddr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|nr_flips
operator|++
expr_stmt|;
block|}
else|else
block|{
name|gnttab_grant_foreign_access_ref
argument_list|(
name|ref
argument_list|,
name|sc
operator|->
name|xbdev
operator|->
name|otherend_id
argument_list|,
name|PFNTOMFN
argument_list|(
name|pfn
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|req
operator|->
name|id
operator|=
name|id
expr_stmt|;
name|req
operator|->
name|gref
operator|=
name|ref
expr_stmt|;
name|sc
operator|->
name|rx_pfn_array
index|[
name|i
index|]
operator|=
name|vtomach
argument_list|(
name|mtod
argument_list|(
name|m_new
argument_list|,
name|vm_offset_t
argument_list|)
argument_list|)
operator|>>
name|PAGE_SHIFT
expr_stmt|;
block|}
name|KASSERT
argument_list|(
name|i
argument_list|,
operator|(
literal|"no mbufs processed"
operator|)
argument_list|)
expr_stmt|;
comment|/* should have returned earlier */
name|KASSERT
argument_list|(
name|mbufq_len
argument_list|(
operator|&
name|sc
operator|->
name|xn_rx_batch
argument_list|)
operator|==
literal|0
argument_list|,
operator|(
literal|"not all mbufs processed"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * We may have allocated buffers which have entries outstanding 	 * in the page * update queue -- make sure we flush those first! 	 */
name|PT_UPDATES_FLUSH
argument_list|()
expr_stmt|;
if|if
condition|(
name|nr_flips
operator|!=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|notyet
comment|/* Tell the ballon driver what is going on. */
name|balloon_update_driver_allowance
argument_list|(
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|set_xen_guest_handle
argument_list|(
name|reservation
operator|.
name|extent_start
argument_list|,
name|sc
operator|->
name|rx_pfn_array
argument_list|)
expr_stmt|;
name|reservation
operator|.
name|nr_extents
operator|=
name|i
expr_stmt|;
name|reservation
operator|.
name|extent_order
operator|=
literal|0
expr_stmt|;
name|reservation
operator|.
name|address_bits
operator|=
literal|0
expr_stmt|;
name|reservation
operator|.
name|domid
operator|=
name|DOMID_SELF
expr_stmt|;
if|if
condition|(
operator|!
name|xen_feature
argument_list|(
name|XENFEAT_auto_translated_physmap
argument_list|)
condition|)
block|{
comment|/* After all PTEs have been zapped, flush the TLB. */
name|sc
operator|->
name|rx_mcl
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|args
index|[
name|MULTI_UVMFLAGS_INDEX
index|]
operator|=
name|UVMF_TLB_FLUSH
operator||
name|UVMF_ALL
expr_stmt|;
comment|/* Give away a batch of pages. */
name|sc
operator|->
name|rx_mcl
index|[
name|i
index|]
operator|.
name|op
operator|=
name|__HYPERVISOR_memory_op
expr_stmt|;
name|sc
operator|->
name|rx_mcl
index|[
name|i
index|]
operator|.
name|args
index|[
literal|0
index|]
operator|=
name|XENMEM_decrease_reservation
expr_stmt|;
name|sc
operator|->
name|rx_mcl
index|[
name|i
index|]
operator|.
name|args
index|[
literal|1
index|]
operator|=
operator|(
name|u_long
operator|)
operator|&
name|reservation
expr_stmt|;
comment|/* Zap PTEs and give away pages in one big multicall. */
operator|(
name|void
operator|)
name|HYPERVISOR_multicall
argument_list|(
name|sc
operator|->
name|rx_mcl
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Check return status of HYPERVISOR_dom_mem_op(). */
if|if
condition|(
name|unlikely
argument_list|(
name|sc
operator|->
name|rx_mcl
index|[
name|i
index|]
operator|.
name|result
operator|!=
name|i
argument_list|)
condition|)
name|panic
argument_list|(
literal|"Unable to reduce memory reservation\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|HYPERVISOR_memory_op
argument_list|(
name|XENMEM_decrease_reservation
argument_list|,
operator|&
name|reservation
argument_list|)
operator|!=
name|i
condition|)
name|panic
argument_list|(
literal|"Unable to reduce memory "
literal|"reservation\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|wmb
argument_list|()
expr_stmt|;
block|}
comment|/* Above is a suitable barrier to ensure backend will see requests. */
name|sc
operator|->
name|rx
operator|.
name|req_prod_pvt
operator|=
name|req_prod
operator|+
name|i
expr_stmt|;
name|push
label|:
name|RING_PUSH_REQUESTS_AND_CHECK_NOTIFY
argument_list|(
operator|&
name|sc
operator|->
name|rx
argument_list|,
name|notify
argument_list|)
expr_stmt|;
if|if
condition|(
name|notify
condition|)
name|notify_remote_via_irq
argument_list|(
name|sc
operator|->
name|irq
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xn_rxeof
parameter_list|(
name|struct
name|netfront_info
modifier|*
name|np
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|netfront_rx_info
name|rinfo
decl_stmt|;
name|struct
name|netif_rx_response
modifier|*
name|rx
init|=
operator|&
name|rinfo
operator|.
name|rx
decl_stmt|;
name|struct
name|netif_extra_info
modifier|*
name|extras
init|=
name|rinfo
operator|.
name|extras
decl_stmt|;
name|RING_IDX
name|i
decl_stmt|,
name|rp
decl_stmt|;
name|multicall_entry_t
modifier|*
name|mcl
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|mbuf_head
name|rxq
decl_stmt|,
name|errq
decl_stmt|,
name|tmpq
decl_stmt|;
name|int
name|err
decl_stmt|,
name|pages_flipped
init|=
literal|0
decl_stmt|;
name|XN_RX_LOCK_ASSERT
argument_list|(
name|np
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|netfront_carrier_ok
argument_list|(
name|np
argument_list|)
condition|)
return|return;
name|mbufq_init
argument_list|(
operator|&
name|tmpq
argument_list|)
expr_stmt|;
name|mbufq_init
argument_list|(
operator|&
name|errq
argument_list|)
expr_stmt|;
name|mbufq_init
argument_list|(
operator|&
name|rxq
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|np
operator|->
name|xn_ifp
expr_stmt|;
name|rp
operator|=
name|np
operator|->
name|rx
operator|.
name|sring
operator|->
name|rsp_prod
expr_stmt|;
name|rmb
argument_list|()
expr_stmt|;
comment|/* Ensure we see queued responses up to 'rp'. */
name|i
operator|=
name|np
operator|->
name|rx
operator|.
name|rsp_cons
expr_stmt|;
while|while
condition|(
operator|(
name|i
operator|!=
name|rp
operator|)
condition|)
block|{
name|memcpy
argument_list|(
name|rx
argument_list|,
name|RING_GET_RESPONSE
argument_list|(
operator|&
name|np
operator|->
name|rx
argument_list|,
name|i
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rx
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|extras
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|rinfo
operator|.
name|extras
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|xennet_get_responses
argument_list|(
name|np
argument_list|,
operator|&
name|rinfo
argument_list|,
name|rp
argument_list|,
operator|&
name|tmpq
argument_list|,
operator|&
name|pages_flipped
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|err
argument_list|)
condition|)
block|{
while|while
condition|(
operator|(
name|m
operator|=
name|mbufq_dequeue
argument_list|(
operator|&
name|tmpq
argument_list|)
operator|)
condition|)
name|mbufq_tail
argument_list|(
operator|&
name|errq
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|np
operator|->
name|stats
operator|.
name|rx_errors
operator|++
expr_stmt|;
name|i
operator|=
name|np
operator|->
name|rx
operator|.
name|rsp_cons
expr_stmt|;
continue|continue;
block|}
name|m
operator|=
name|mbufq_dequeue
argument_list|(
operator|&
name|tmpq
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_data
operator|+=
name|rx
operator|->
name|offset
expr_stmt|;
comment|/* (rx->addr& PAGE_MASK); */
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|rx
operator|->
name|status
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
if|if
condition|(
name|rx
operator|->
name|flags
operator|&
name|NETRXF_data_validated
condition|)
block|{
comment|/* Tell the stack the checksums are okay */
comment|/* 			 * XXX this isn't necessarily the case - need to add 			 * check 			 */
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator||=
operator|(
name|CSUM_IP_CHECKED
operator||
name|CSUM_IP_VALID
operator||
name|CSUM_DATA_VALID
operator||
name|CSUM_PSEUDO_HDR
operator|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|=
literal|0xffff
expr_stmt|;
block|}
name|np
operator|->
name|stats
operator|.
name|rx_packets
operator|++
expr_stmt|;
name|np
operator|->
name|stats
operator|.
name|rx_bytes
operator|+=
name|rx
operator|->
name|status
expr_stmt|;
name|mbufq_tail
argument_list|(
operator|&
name|rxq
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|np
operator|->
name|rx
operator|.
name|rsp_cons
operator|=
operator|++
name|i
expr_stmt|;
block|}
if|if
condition|(
name|pages_flipped
condition|)
block|{
comment|/* Some pages are no longer absent... */
ifdef|#
directive|ifdef
name|notyet
name|balloon_update_driver_allowance
argument_list|(
operator|-
name|pages_flipped
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Do all the remapping work, and M->P updates, in one big 		 * hypercall. 		 */
if|if
condition|(
operator|!
operator|!
name|xen_feature
argument_list|(
name|XENFEAT_auto_translated_physmap
argument_list|)
condition|)
block|{
name|mcl
operator|=
name|np
operator|->
name|rx_mcl
operator|+
name|pages_flipped
expr_stmt|;
name|mcl
operator|->
name|op
operator|=
name|__HYPERVISOR_mmu_update
expr_stmt|;
name|mcl
operator|->
name|args
index|[
literal|0
index|]
operator|=
operator|(
name|u_long
operator|)
name|np
operator|->
name|rx_mmu
expr_stmt|;
name|mcl
operator|->
name|args
index|[
literal|1
index|]
operator|=
name|pages_flipped
expr_stmt|;
name|mcl
operator|->
name|args
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|mcl
operator|->
name|args
index|[
literal|3
index|]
operator|=
name|DOMID_SELF
expr_stmt|;
operator|(
name|void
operator|)
name|HYPERVISOR_multicall
argument_list|(
name|np
operator|->
name|rx_mcl
argument_list|,
name|pages_flipped
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
while|while
condition|(
operator|(
name|m
operator|=
name|mbufq_dequeue
argument_list|(
operator|&
name|errq
argument_list|)
operator|)
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/*  	 * Process all the mbufs after the remapping is complete. 	 * Break the mbuf chain first though. 	 */
while|while
condition|(
operator|(
name|m
operator|=
name|mbufq_dequeue
argument_list|(
operator|&
name|rxq
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|ifp
operator|->
name|if_ipackets
operator|++
expr_stmt|;
comment|/* 		 * Do we really need to drop the rx lock? 		 */
name|XN_RX_UNLOCK
argument_list|(
name|np
argument_list|)
expr_stmt|;
comment|/* Pass it up. */
call|(
modifier|*
name|ifp
operator|->
name|if_input
call|)
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|XN_RX_LOCK
argument_list|(
name|np
argument_list|)
expr_stmt|;
block|}
name|np
operator|->
name|rx
operator|.
name|rsp_cons
operator|=
name|i
expr_stmt|;
if|#
directive|if
literal|0
comment|/* If we get a callback with very few responses, reduce fill target. */
comment|/* NB. Note exponential increase, linear decrease. */
block|if (((np->rx.req_prod_pvt - np->rx.sring->rsp_prod)>  	    ((3*np->rx_target) / 4))&& (--np->rx_target< np->rx_min_target)) 		np->rx_target = np->rx_min_target;
endif|#
directive|endif
name|network_alloc_rx_buffers
argument_list|(
name|np
argument_list|)
expr_stmt|;
name|np
operator|->
name|rx
operator|.
name|sring
operator|->
name|rsp_event
operator|=
name|i
operator|+
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xn_txeof
parameter_list|(
name|struct
name|netfront_info
modifier|*
name|np
parameter_list|)
block|{
name|RING_IDX
name|i
decl_stmt|,
name|prod
decl_stmt|;
name|unsigned
name|short
name|id
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|XN_TX_LOCK_ASSERT
argument_list|(
name|np
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|netfront_carrier_ok
argument_list|(
name|np
argument_list|)
condition|)
return|return;
name|ifp
operator|=
name|np
operator|->
name|xn_ifp
expr_stmt|;
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|prod
operator|=
name|np
operator|->
name|tx
operator|.
name|sring
operator|->
name|rsp_prod
expr_stmt|;
name|rmb
argument_list|()
expr_stmt|;
comment|/* Ensure we see responses up to 'rp'. */
for|for
control|(
name|i
operator|=
name|np
operator|->
name|tx
operator|.
name|rsp_cons
init|;
name|i
operator|!=
name|prod
condition|;
name|i
operator|++
control|)
block|{
name|id
operator|=
name|RING_GET_RESPONSE
argument_list|(
operator|&
name|np
operator|->
name|tx
argument_list|,
name|i
argument_list|)
operator|->
name|id
expr_stmt|;
name|m
operator|=
name|np
operator|->
name|xn_cdata
operator|.
name|xn_tx_chain
index|[
name|id
index|]
expr_stmt|;
name|ifp
operator|->
name|if_opackets
operator|++
expr_stmt|;
name|KASSERT
argument_list|(
name|m
operator|!=
name|NULL
argument_list|,
operator|(
literal|"mbuf not found in xn_tx_chain"
operator|)
argument_list|)
expr_stmt|;
name|M_ASSERTVALID
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|gnttab_query_foreign_access
argument_list|(
name|np
operator|->
name|grant_tx_ref
index|[
name|id
index|]
argument_list|)
operator|!=
literal|0
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"network_tx_buf_gc: warning "
literal|"-- grant still in use by backend "
literal|"domain.\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|gnttab_end_foreign_access_ref
argument_list|(
name|np
operator|->
name|grant_tx_ref
index|[
name|id
index|]
argument_list|,
name|GNTMAP_readonly
argument_list|)
expr_stmt|;
name|gnttab_release_grant_reference
argument_list|(
operator|&
name|np
operator|->
name|gref_tx_head
argument_list|,
name|np
operator|->
name|grant_tx_ref
index|[
name|id
index|]
argument_list|)
expr_stmt|;
name|np
operator|->
name|grant_tx_ref
index|[
name|id
index|]
operator|=
name|GRANT_INVALID_REF
expr_stmt|;
name|np
operator|->
name|xn_cdata
operator|.
name|xn_tx_chain
index|[
name|id
index|]
operator|=
name|NULL
expr_stmt|;
name|add_id_to_freelist
argument_list|(
name|np
operator|->
name|xn_cdata
operator|.
name|xn_tx_chain
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
name|np
operator|->
name|tx
operator|.
name|rsp_cons
operator|=
name|prod
expr_stmt|;
comment|/* 		 * Set a new event, then check for race with update of 		 * tx_cons. Note that it is essential to schedule a 		 * callback, no matter how few buffers are pending. Even if 		 * there is space in the transmit ring, higher layers may 		 * be blocked because too much data is outstanding: in such 		 * cases notification from Xen is likely to be the only kick 		 * that we'll get. 		 */
name|np
operator|->
name|tx
operator|.
name|sring
operator|->
name|rsp_event
operator|=
name|prod
operator|+
operator|(
operator|(
name|np
operator|->
name|tx
operator|.
name|sring
operator|->
name|req_prod
operator|-
name|prod
operator|)
operator|>>
literal|1
operator|)
operator|+
literal|1
expr_stmt|;
name|mb
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|prod
operator|!=
name|np
operator|->
name|tx
operator|.
name|sring
operator|->
name|rsp_prod
condition|)
do|;
name|out
label|:
if|if
condition|(
name|np
operator|->
name|tx_full
operator|&&
operator|(
operator|(
name|np
operator|->
name|tx
operator|.
name|sring
operator|->
name|req_prod
operator|-
name|prod
operator|)
operator|<
name|NET_TX_RING_SIZE
operator|)
condition|)
block|{
name|np
operator|->
name|tx_full
operator|=
literal|0
expr_stmt|;
if|#
directive|if
literal|0
block|if (np->user_state == UST_OPEN) 			netif_wake_queue(dev);
endif|#
directive|endif
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|xn_intr
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
block|{
name|struct
name|netfront_info
modifier|*
name|np
init|=
name|xsc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|np
operator|->
name|xn_ifp
decl_stmt|;
if|#
directive|if
literal|0
block|if (!(np->rx.rsp_cons != np->rx.sring->rsp_prod&& 	    likely(netfront_carrier_ok(np))&& 	    ifp->if_drv_flags& IFF_DRV_RUNNING)) 		return;
endif|#
directive|endif
if|if
condition|(
name|np
operator|->
name|tx
operator|.
name|rsp_cons
operator|!=
name|np
operator|->
name|tx
operator|.
name|sring
operator|->
name|rsp_prod
condition|)
block|{
name|XN_TX_LOCK
argument_list|(
name|np
argument_list|)
expr_stmt|;
name|xn_txeof
argument_list|(
name|np
argument_list|)
expr_stmt|;
name|XN_TX_UNLOCK
argument_list|(
name|np
argument_list|)
expr_stmt|;
block|}
name|XN_RX_LOCK
argument_list|(
name|np
argument_list|)
expr_stmt|;
name|xn_rxeof
argument_list|(
name|np
argument_list|)
expr_stmt|;
name|XN_RX_UNLOCK
argument_list|(
name|np
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|&&
operator|!
name|IFQ_DRV_IS_EMPTY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
condition|)
name|xn_start
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xennet_move_rx_slot
parameter_list|(
name|struct
name|netfront_info
modifier|*
name|np
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|grant_ref_t
name|ref
parameter_list|)
block|{
name|int
name|new
init|=
name|xennet_rxidx
argument_list|(
name|np
operator|->
name|rx
operator|.
name|req_prod_pvt
argument_list|)
decl_stmt|;
name|KASSERT
argument_list|(
name|np
operator|->
name|rx_mbufs
index|[
name|new
index|]
operator|==
name|NULL
argument_list|,
operator|(
literal|"rx_mbufs != NULL"
operator|)
argument_list|)
expr_stmt|;
name|np
operator|->
name|rx_mbufs
index|[
name|new
index|]
operator|=
name|m
expr_stmt|;
name|np
operator|->
name|grant_rx_ref
index|[
name|new
index|]
operator|=
name|ref
expr_stmt|;
name|RING_GET_REQUEST
argument_list|(
operator|&
name|np
operator|->
name|rx
argument_list|,
name|np
operator|->
name|rx
operator|.
name|req_prod_pvt
argument_list|)
operator|->
name|id
operator|=
name|new
expr_stmt|;
name|RING_GET_REQUEST
argument_list|(
operator|&
name|np
operator|->
name|rx
argument_list|,
name|np
operator|->
name|rx
operator|.
name|req_prod_pvt
argument_list|)
operator|->
name|gref
operator|=
name|ref
expr_stmt|;
name|np
operator|->
name|rx
operator|.
name|req_prod_pvt
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|xennet_get_extras
parameter_list|(
name|struct
name|netfront_info
modifier|*
name|np
parameter_list|,
name|struct
name|netif_extra_info
modifier|*
name|extras
parameter_list|,
name|RING_IDX
name|rp
parameter_list|)
block|{
name|struct
name|netif_extra_info
modifier|*
name|extra
decl_stmt|;
name|RING_IDX
name|cons
init|=
name|np
operator|->
name|rx
operator|.
name|rsp_cons
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
do|do
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|grant_ref_t
name|ref
decl_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|cons
operator|+
literal|1
operator|==
name|rp
argument_list|)
condition|)
block|{
if|#
directive|if
literal|0
block|if (net_ratelimit()) 				WPRINTK("Missing extra info\n");
endif|#
directive|endif
name|err
operator|=
operator|-
name|EINVAL
expr_stmt|;
break|break;
block|}
name|extra
operator|=
operator|(
expr|struct
name|netif_extra_info
operator|*
operator|)
name|RING_GET_RESPONSE
argument_list|(
operator|&
name|np
operator|->
name|rx
argument_list|,
operator|++
name|cons
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
operator|!
name|extra
operator|->
name|type
operator|||
name|extra
operator|->
name|type
operator|>=
name|XEN_NETIF_EXTRA_TYPE_MAX
argument_list|)
condition|)
block|{
if|#
directive|if
literal|0
block|if (net_ratelimit()) 				WPRINTK("Invalid extra type: %d\n", 					extra->type);
endif|#
directive|endif
name|err
operator|=
operator|-
name|EINVAL
expr_stmt|;
block|}
else|else
block|{
name|memcpy
argument_list|(
operator|&
name|extras
index|[
name|extra
operator|->
name|type
operator|-
literal|1
index|]
argument_list|,
name|extra
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|extra
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|m
operator|=
name|xennet_get_rx_mbuf
argument_list|(
name|np
argument_list|,
name|cons
argument_list|)
expr_stmt|;
name|ref
operator|=
name|xennet_get_rx_ref
argument_list|(
name|np
argument_list|,
name|cons
argument_list|)
expr_stmt|;
name|xennet_move_rx_slot
argument_list|(
name|np
argument_list|,
name|m
argument_list|,
name|ref
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|extra
operator|->
name|flags
operator|&
name|XEN_NETIF_EXTRA_FLAG_MORE
condition|)
do|;
name|np
operator|->
name|rx
operator|.
name|rsp_cons
operator|=
name|cons
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xennet_get_responses
parameter_list|(
name|struct
name|netfront_info
modifier|*
name|np
parameter_list|,
name|struct
name|netfront_rx_info
modifier|*
name|rinfo
parameter_list|,
name|RING_IDX
name|rp
parameter_list|,
name|struct
name|mbuf_head
modifier|*
name|list
parameter_list|,
name|int
modifier|*
name|pages_flipped_p
parameter_list|)
block|{
name|int
name|pages_flipped
init|=
operator|*
name|pages_flipped_p
decl_stmt|;
name|struct
name|mmu_update
modifier|*
name|mmu
decl_stmt|;
name|struct
name|multicall_entry
modifier|*
name|mcl
decl_stmt|;
name|struct
name|netif_rx_response
modifier|*
name|rx
init|=
operator|&
name|rinfo
operator|->
name|rx
decl_stmt|;
name|struct
name|netif_extra_info
modifier|*
name|extras
init|=
name|rinfo
operator|->
name|extras
decl_stmt|;
name|RING_IDX
name|cons
init|=
name|np
operator|->
name|rx
operator|.
name|rsp_cons
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
init|=
name|xennet_get_rx_mbuf
argument_list|(
name|np
argument_list|,
name|cons
argument_list|)
decl_stmt|;
name|grant_ref_t
name|ref
init|=
name|xennet_get_rx_ref
argument_list|(
name|np
argument_list|,
name|cons
argument_list|)
decl_stmt|;
name|int
name|max
init|=
literal|24
comment|/* MAX_SKB_FRAGS + (rx->status<= RX_COPY_THRESHOLD) */
decl_stmt|;
name|int
name|frags
init|=
literal|1
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|u_long
name|ret
decl_stmt|;
if|if
condition|(
name|rx
operator|->
name|flags
operator|&
name|NETRXF_extra_info
condition|)
block|{
name|err
operator|=
name|xennet_get_extras
argument_list|(
name|np
argument_list|,
name|extras
argument_list|,
name|rp
argument_list|)
expr_stmt|;
name|cons
operator|=
name|np
operator|->
name|rx
operator|.
name|rsp_cons
expr_stmt|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
name|u_long
name|mfn
decl_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|rx
operator|->
name|status
operator|<
literal|0
operator|||
name|rx
operator|->
name|offset
operator|+
name|rx
operator|->
name|status
operator|>
name|PAGE_SIZE
argument_list|)
condition|)
block|{
if|#
directive|if
literal|0
block|if (net_ratelimit()) 				WPRINTK("rx->offset: %x, size: %u\n", 					rx->offset, rx->status);
endif|#
directive|endif
name|xennet_move_rx_slot
argument_list|(
name|np
argument_list|,
name|m
argument_list|,
name|ref
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|next
goto|;
block|}
comment|/* 		 * This definitely indicates a bug, either in this driver or in 		 * the backend driver. In future this should flag the bad 		 * situation to the system controller to reboot the backed. 		 */
if|if
condition|(
name|ref
operator|==
name|GRANT_INVALID_REF
condition|)
block|{
if|#
directive|if
literal|0
block|if (net_ratelimit()) 				WPRINTK("Bad rx response id %d.\n", rx->id);
endif|#
directive|endif
name|err
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|next
goto|;
block|}
if|if
condition|(
operator|!
name|np
operator|->
name|copying_receiver
condition|)
block|{
comment|/* Memory pressure, insufficient buffer 			 * headroom, ... 			 */
if|if
condition|(
operator|!
operator|(
name|mfn
operator|=
name|gnttab_end_foreign_transfer_ref
argument_list|(
name|ref
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|net_ratelimit
argument_list|()
condition|)
name|WPRINTK
argument_list|(
literal|"Unfulfilled rx req "
literal|"(id=%d, st=%d).\n"
argument_list|,
name|rx
operator|->
name|id
argument_list|,
name|rx
operator|->
name|status
argument_list|)
expr_stmt|;
name|xennet_move_rx_slot
argument_list|(
name|np
argument_list|,
name|m
argument_list|,
name|ref
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|ENOMEM
expr_stmt|;
goto|goto
name|next
goto|;
block|}
if|if
condition|(
operator|!
name|xen_feature
argument_list|(
name|XENFEAT_auto_translated_physmap
argument_list|)
condition|)
block|{
comment|/* Remap the page. */
name|void
modifier|*
name|vaddr
init|=
name|mtod
argument_list|(
name|m
argument_list|,
name|void
operator|*
argument_list|)
decl_stmt|;
name|uint32_t
name|pfn
decl_stmt|;
name|mcl
operator|=
name|np
operator|->
name|rx_mcl
operator|+
name|pages_flipped
expr_stmt|;
name|mmu
operator|=
name|np
operator|->
name|rx_mmu
operator|+
name|pages_flipped
expr_stmt|;
name|MULTI_update_va_mapping
argument_list|(
name|mcl
argument_list|,
operator|(
name|u_long
operator|)
name|vaddr
argument_list|,
operator|(
operator|(
operator|(
name|vm_paddr_t
operator|)
name|mfn
operator|)
operator|<<
name|PAGE_SHIFT
operator|)
operator||
name|PG_RW
operator||
name|PG_V
operator||
name|PG_M
operator||
name|PG_A
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pfn
operator|=
operator|(
name|uint32_t
operator|)
name|m
operator|->
name|m_ext
operator|.
name|ext_arg1
expr_stmt|;
name|mmu
operator|->
name|ptr
operator|=
operator|(
operator|(
name|vm_paddr_t
operator|)
name|mfn
operator|<<
name|PAGE_SHIFT
operator|)
operator||
name|MMU_MACHPHYS_UPDATE
expr_stmt|;
name|mmu
operator|->
name|val
operator|=
name|pfn
expr_stmt|;
name|set_phys_to_machine
argument_list|(
name|pfn
argument_list|,
name|mfn
argument_list|)
expr_stmt|;
block|}
name|pages_flipped
operator|++
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|gnttab_end_foreign_access_ref
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ret
argument_list|,
operator|(
literal|"ret != 0"
operator|)
argument_list|)
expr_stmt|;
block|}
name|gnttab_release_grant_reference
argument_list|(
operator|&
name|np
operator|->
name|gref_rx_head
argument_list|,
name|ref
argument_list|)
expr_stmt|;
name|mbufq_tail
argument_list|(
name|list
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|next
label|:
if|if
condition|(
operator|!
operator|(
name|rx
operator|->
name|flags
operator|&
name|NETRXF_more_data
operator|)
condition|)
break|break;
if|if
condition|(
name|cons
operator|+
name|frags
operator|==
name|rp
condition|)
block|{
if|if
condition|(
name|net_ratelimit
argument_list|()
condition|)
name|WPRINTK
argument_list|(
literal|"Need more frags\n"
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|ENOENT
expr_stmt|;
break|break;
block|}
name|rx
operator|=
name|RING_GET_RESPONSE
argument_list|(
operator|&
name|np
operator|->
name|rx
argument_list|,
name|cons
operator|+
name|frags
argument_list|)
expr_stmt|;
name|m
operator|=
name|xennet_get_rx_mbuf
argument_list|(
name|np
argument_list|,
name|cons
operator|+
name|frags
argument_list|)
expr_stmt|;
name|ref
operator|=
name|xennet_get_rx_ref
argument_list|(
name|np
argument_list|,
name|cons
operator|+
name|frags
argument_list|)
expr_stmt|;
name|frags
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|unlikely
argument_list|(
name|frags
operator|>
name|max
argument_list|)
condition|)
block|{
if|if
condition|(
name|net_ratelimit
argument_list|()
condition|)
name|WPRINTK
argument_list|(
literal|"Too many frags\n"
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|E2BIG
expr_stmt|;
block|}
if|if
condition|(
name|unlikely
argument_list|(
name|err
argument_list|)
condition|)
name|np
operator|->
name|rx
operator|.
name|rsp_cons
operator|=
name|cons
operator|+
name|frags
expr_stmt|;
operator|*
name|pages_flipped_p
operator|=
name|pages_flipped
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xn_tick_locked
parameter_list|(
name|struct
name|netfront_info
modifier|*
name|sc
parameter_list|)
block|{
name|XN_RX_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|xn_stat_ch
argument_list|,
name|hz
argument_list|,
name|xn_tick
argument_list|,
name|sc
argument_list|)
expr_stmt|;
comment|/* XXX placeholder for printing debug information */
block|}
end_function

begin_function
specifier|static
name|void
name|xn_tick
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
block|{
name|struct
name|netfront_info
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|xsc
expr_stmt|;
name|XN_RX_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|xn_tick_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|XN_RX_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xn_start_locked
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|unsigned
name|short
name|id
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m_head
decl_stmt|,
modifier|*
name|new_m
decl_stmt|;
name|struct
name|netfront_info
modifier|*
name|sc
decl_stmt|;
name|netif_tx_request_t
modifier|*
name|tx
decl_stmt|;
name|RING_IDX
name|i
decl_stmt|;
name|grant_ref_t
name|ref
decl_stmt|;
name|u_long
name|mfn
decl_stmt|,
name|tx_bytes
decl_stmt|;
name|int
name|notify
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|tx_bytes
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|netfront_carrier_ok
argument_list|(
name|sc
argument_list|)
condition|)
return|return;
for|for
control|(
name|i
operator|=
name|sc
operator|->
name|tx
operator|.
name|req_prod_pvt
init|;
name|TRUE
condition|;
name|i
operator|++
control|)
block|{
name|IF_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m_head
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_head
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
operator|!
name|netfront_tx_slot_available
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|IF_PREPEND
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m_head
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_OACTIVE
expr_stmt|;
break|break;
block|}
name|id
operator|=
name|get_id_from_freelist
argument_list|(
name|sc
operator|->
name|xn_cdata
operator|.
name|xn_tx_chain
argument_list|)
expr_stmt|;
comment|/* 		 * Start packing the mbufs in this chain into 		 * the fragment pointers. Stop when we run out 		 * of fragments or hit the end of the mbuf chain. 		 */
name|new_m
operator|=
name|makembuf
argument_list|(
name|m_head
argument_list|)
expr_stmt|;
name|tx
operator|=
name|RING_GET_REQUEST
argument_list|(
operator|&
name|sc
operator|->
name|tx
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|tx
operator|->
name|id
operator|=
name|id
expr_stmt|;
name|ref
operator|=
name|gnttab_claim_grant_reference
argument_list|(
operator|&
name|sc
operator|->
name|gref_tx_head
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|short
operator|)
name|ref
operator|>=
literal|0
argument_list|,
operator|(
literal|"Negative ref"
operator|)
argument_list|)
expr_stmt|;
name|mfn
operator|=
name|virt_to_mfn
argument_list|(
name|mtod
argument_list|(
name|new_m
argument_list|,
name|vm_offset_t
argument_list|)
argument_list|)
expr_stmt|;
name|gnttab_grant_foreign_access_ref
argument_list|(
name|ref
argument_list|,
name|sc
operator|->
name|xbdev
operator|->
name|otherend_id
argument_list|,
name|mfn
argument_list|,
name|GNTMAP_readonly
argument_list|)
expr_stmt|;
name|tx
operator|->
name|gref
operator|=
name|sc
operator|->
name|grant_tx_ref
index|[
name|id
index|]
operator|=
name|ref
expr_stmt|;
name|tx
operator|->
name|size
operator|=
name|new_m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
if|#
directive|if
literal|0
block|tx->flags = (skb->ip_summed == CHECKSUM_HW) ? NETTXF_csum_blank : 0;
endif|#
directive|endif
name|tx
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|new_m
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
name|new_m
operator|->
name|m_nextpkt
operator|=
name|NULL
expr_stmt|;
name|m_freem
argument_list|(
name|m_head
argument_list|)
expr_stmt|;
name|sc
operator|->
name|xn_cdata
operator|.
name|xn_tx_chain
index|[
name|id
index|]
operator|=
name|new_m
expr_stmt|;
name|BPF_MTAP
argument_list|(
name|ifp
argument_list|,
name|new_m
argument_list|)
expr_stmt|;
name|sc
operator|->
name|stats
operator|.
name|tx_bytes
operator|+=
name|new_m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|sc
operator|->
name|stats
operator|.
name|tx_packets
operator|++
expr_stmt|;
block|}
name|sc
operator|->
name|tx
operator|.
name|req_prod_pvt
operator|=
name|i
expr_stmt|;
name|RING_PUSH_REQUESTS_AND_CHECK_NOTIFY
argument_list|(
operator|&
name|sc
operator|->
name|tx
argument_list|,
name|notify
argument_list|)
expr_stmt|;
if|if
condition|(
name|notify
condition|)
name|notify_remote_via_irq
argument_list|(
name|sc
operator|->
name|irq
argument_list|)
expr_stmt|;
name|xn_txeof
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|RING_FULL
argument_list|(
operator|&
name|sc
operator|->
name|tx
argument_list|)
condition|)
block|{
name|sc
operator|->
name|tx_full
operator|=
literal|1
expr_stmt|;
if|#
directive|if
literal|0
block|netif_stop_queue(dev);
endif|#
directive|endif
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|xn_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|netfront_info
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|XN_TX_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|xn_start_locked
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|XN_TX_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* equivalent of network_open() in Linux */
end_comment

begin_function
specifier|static
name|void
name|xn_ifinit_locked
parameter_list|(
name|struct
name|netfront_info
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|XN_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|xn_ifp
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
return|return;
name|xn_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|network_alloc_rx_buffers
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rx
operator|.
name|sring
operator|->
name|rsp_event
operator|=
name|sc
operator|->
name|rx
operator|.
name|rsp_cons
operator|+
literal|1
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_RUNNING
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|xn_stat_ch
argument_list|,
name|hz
argument_list|,
name|xn_tick
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xn_ifinit
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
block|{
name|struct
name|netfront_info
modifier|*
name|sc
init|=
name|xsc
decl_stmt|;
name|XN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|xn_ifinit_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|XN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|xn_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|struct
name|netfront_info
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|ifaddr
modifier|*
name|ifa
init|=
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
name|data
decl_stmt|;
name|int
name|mask
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCSIFADDR
case|:
case|case
name|SIOCGIFADDR
case|:
name|XN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_UP
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
name|xn_ifinit_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|arp_ifinit
argument_list|(
name|ifp
argument_list|,
name|ifa
argument_list|)
expr_stmt|;
block|}
else|else
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|XN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFMTU
case|:
comment|/* XXX can we alter the MTU on a VN ?*/
ifdef|#
directive|ifdef
name|notyet
if|if
condition|(
name|ifr
operator|->
name|ifr_mtu
operator|>
name|XN_JUMBO_MTU
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
else|else
endif|#
directive|endif
block|{
name|ifp
operator|->
name|if_mtu
operator|=
name|ifr
operator|->
name|ifr_mtu
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_RUNNING
expr_stmt|;
name|xn_ifinit
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SIOCSIFFLAGS
case|:
name|XN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
comment|/* 			 * If only the state of the PROMISC flag changed, 			 * then just use the 'set promisc mode' command 			 * instead of reinitializing the entire NIC. Doing 			 * a full re-init means reloading the firmware and 			 * waiting for it to start up, which may take a 			 * second or two. 			 */
ifdef|#
directive|ifdef
name|notyet
comment|/* No promiscuous mode with Xen */
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|&&
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
operator|&&
operator|!
operator|(
name|sc
operator|->
name|xn_if_flags
operator|&
name|IFF_PROMISC
operator|)
condition|)
block|{
name|XN_SETBIT
argument_list|(
name|sc
argument_list|,
name|XN_RX_MODE
argument_list|,
name|XN_RXMODE_RX_PROMISC
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|&&
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
operator|)
operator|&&
name|sc
operator|->
name|xn_if_flags
operator|&
name|IFF_PROMISC
condition|)
block|{
name|XN_CLRBIT
argument_list|(
name|sc
argument_list|,
name|XN_RX_MODE
argument_list|,
name|XN_RXMODE_RX_PROMISC
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|xn_ifinit_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|xn_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
name|sc
operator|->
name|xn_if_flags
operator|=
name|ifp
operator|->
name|if_flags
expr_stmt|;
name|XN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SIOCSIFCAP
case|:
name|mask
operator|=
name|ifr
operator|->
name|ifr_reqcap
operator|^
name|ifp
operator|->
name|if_capenable
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IFCAP_HWCSUM
condition|)
block|{
if|if
condition|(
name|IFCAP_HWCSUM
operator|&
name|ifp
operator|->
name|if_capenable
condition|)
name|ifp
operator|->
name|if_capenable
operator|&=
operator|~
name|IFCAP_HWCSUM
expr_stmt|;
else|else
name|ifp
operator|->
name|if_capenable
operator||=
name|IFCAP_HWCSUM
expr_stmt|;
block|}
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
ifdef|#
directive|ifdef
name|notyet
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|XN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|xn_setmulti
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|XN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* FALLTHROUGH */
case|case
name|SIOCSIFMEDIA
case|:
case|case
name|SIOCGIFMEDIA
case|:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xn_stop
parameter_list|(
name|struct
name|netfront_info
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|XN_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|xn_ifp
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|xn_stat_ch
argument_list|)
expr_stmt|;
name|xn_free_rx_ring
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|xn_free_tx_ring
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
operator|(
name|IFF_DRV_RUNNING
operator||
name|IFF_DRV_OACTIVE
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* START of Xenolinux helper functions adapted to FreeBSD */
end_comment

begin_function
specifier|static
name|int
name|network_connect
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|netfront_info
modifier|*
name|np
decl_stmt|;
name|int
name|i
decl_stmt|,
name|requeue_idx
decl_stmt|,
name|err
decl_stmt|;
name|grant_ref_t
name|ref
decl_stmt|;
name|netif_rx_request_t
modifier|*
name|req
decl_stmt|;
name|u_int
name|feature_rx_copy
decl_stmt|,
name|feature_rx_flip
decl_stmt|;
name|printf
argument_list|(
literal|"network_connect\n"
argument_list|)
expr_stmt|;
name|np
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|err
operator|=
name|xenbus_scanf
argument_list|(
name|XBT_NIL
argument_list|,
name|np
operator|->
name|xbdev
operator|->
name|otherend
argument_list|,
literal|"feature-rx-copy"
argument_list|,
literal|"%u"
argument_list|,
operator|&
name|feature_rx_copy
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|1
condition|)
name|feature_rx_copy
operator|=
literal|0
expr_stmt|;
name|err
operator|=
name|xenbus_scanf
argument_list|(
name|XBT_NIL
argument_list|,
name|np
operator|->
name|xbdev
operator|->
name|otherend
argument_list|,
literal|"feature-rx-flip"
argument_list|,
literal|"%u"
argument_list|,
operator|&
name|feature_rx_flip
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|1
condition|)
name|feature_rx_flip
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Copy packets on receive path if: 	 *  (a) This was requested by user, and the backend supports it; or 	 *  (b) Flipping was requested, but this is unsupported by the backend. 	 */
name|np
operator|->
name|copying_receiver
operator|=
operator|(
operator|(
name|MODPARM_rx_copy
operator|&&
name|feature_rx_copy
operator|)
operator|||
operator|(
name|MODPARM_rx_flip
operator|&&
operator|!
name|feature_rx_flip
operator|)
operator|)
expr_stmt|;
name|XN_LOCK
argument_list|(
name|np
argument_list|)
expr_stmt|;
comment|/* Recovery procedure: */
name|err
operator|=
name|talk_to_backend
argument_list|(
name|np
operator|->
name|xbdev
argument_list|,
name|np
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
comment|/* Step 1: Reinitialise variables. */
name|netif_release_tx_bufs
argument_list|(
name|np
argument_list|)
expr_stmt|;
comment|/* Step 2: Rebuild the RX buffer freelist and the RX ring itself. */
for|for
control|(
name|requeue_idx
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NET_RX_RING_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
if|if
condition|(
name|np
operator|->
name|rx_mbufs
index|[
name|i
index|]
operator|==
name|NULL
condition|)
continue|continue;
name|m
operator|=
name|np
operator|->
name|rx_mbufs
index|[
name|requeue_idx
index|]
operator|=
name|xennet_get_rx_mbuf
argument_list|(
name|np
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|ref
operator|=
name|np
operator|->
name|grant_rx_ref
index|[
name|requeue_idx
index|]
operator|=
name|xennet_get_rx_ref
argument_list|(
name|np
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|req
operator|=
name|RING_GET_REQUEST
argument_list|(
operator|&
name|np
operator|->
name|rx
argument_list|,
name|requeue_idx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|np
operator|->
name|copying_receiver
condition|)
block|{
name|gnttab_grant_foreign_transfer_ref
argument_list|(
name|ref
argument_list|,
name|np
operator|->
name|xbdev
operator|->
name|otherend_id
argument_list|,
name|vtophys
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|vm_offset_t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gnttab_grant_foreign_access_ref
argument_list|(
name|ref
argument_list|,
name|np
operator|->
name|xbdev
operator|->
name|otherend_id
argument_list|,
name|vtophys
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|vm_offset_t
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|req
operator|->
name|gref
operator|=
name|ref
expr_stmt|;
name|req
operator|->
name|id
operator|=
name|requeue_idx
expr_stmt|;
name|requeue_idx
operator|++
expr_stmt|;
block|}
name|np
operator|->
name|rx
operator|.
name|req_prod_pvt
operator|=
name|requeue_idx
expr_stmt|;
comment|/* Step 3: All public and private state should now be sane.  Get 	 * ready to start sending and receiving packets and give the driver 	 * domain a kick because we've probably just requeued some 	 * packets. 	 */
name|netfront_carrier_on
argument_list|(
name|np
argument_list|)
expr_stmt|;
name|notify_remote_via_irq
argument_list|(
name|np
operator|->
name|irq
argument_list|)
expr_stmt|;
name|XN_TX_LOCK
argument_list|(
name|np
argument_list|)
expr_stmt|;
name|xn_txeof
argument_list|(
name|np
argument_list|)
expr_stmt|;
name|XN_TX_UNLOCK
argument_list|(
name|np
argument_list|)
expr_stmt|;
name|network_alloc_rx_buffers
argument_list|(
name|np
argument_list|)
expr_stmt|;
name|XN_UNLOCK
argument_list|(
name|np
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|show_device
parameter_list|(
name|struct
name|netfront_info
modifier|*
name|sc
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|sc
condition|)
block|{
name|IPRINTK
argument_list|(
literal|"<vif handle=%u %s(%s) evtchn=%u irq=%u tx=%p rx=%p>\n"
argument_list|,
name|sc
operator|->
name|xn_ifno
argument_list|,
name|be_state_name
index|[
name|sc
operator|->
name|xn_backend_state
index|]
argument_list|,
name|sc
operator|->
name|xn_user_state
condition|?
literal|"open"
else|:
literal|"closed"
argument_list|,
name|sc
operator|->
name|xn_evtchn
argument_list|,
name|sc
operator|->
name|xn_irq
argument_list|,
name|sc
operator|->
name|xn_tx_if
argument_list|,
name|sc
operator|->
name|xn_rx_if
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|IPRINTK
argument_list|(
literal|"<vif NULL>\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|ifno
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/** Create a network device.  * @param handle device handle  */
end_comment

begin_function
specifier|static
name|int
name|create_netdev
parameter_list|(
name|struct
name|xenbus_device
modifier|*
name|dev
parameter_list|,
name|struct
name|ifnet
modifier|*
modifier|*
name|ifpp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|netfront_info
modifier|*
name|np
decl_stmt|;
name|int
name|err
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|np
operator|=
operator|(
expr|struct
name|netfront_info
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|netfront_info
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|memset
argument_list|(
name|np
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|netfront_info
argument_list|)
argument_list|)
expr_stmt|;
name|np
operator|->
name|xbdev
operator|=
name|dev
expr_stmt|;
name|XN_LOCK_INIT
argument_list|(
name|np
argument_list|,
name|xennetif
argument_list|)
expr_stmt|;
name|np
operator|->
name|rx_target
operator|=
name|RX_MIN_TARGET
expr_stmt|;
name|np
operator|->
name|rx_min_target
operator|=
name|RX_MIN_TARGET
expr_stmt|;
name|np
operator|->
name|rx_max_target
operator|=
name|RX_MAX_TARGET
expr_stmt|;
comment|/* Initialise {tx,rx}_skbs to be a free chain containing every entry. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|NET_TX_RING_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|np
operator|->
name|tx_mbufs
index|[
name|i
index|]
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|u_long
operator|)
name|i
operator|+
literal|1
operator|)
expr_stmt|;
name|np
operator|->
name|grant_tx_ref
index|[
name|i
index|]
operator|=
name|GRANT_INVALID_REF
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|NET_RX_RING_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|np
operator|->
name|rx_mbufs
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|np
operator|->
name|grant_rx_ref
index|[
name|i
index|]
operator|=
name|GRANT_INVALID_REF
expr_stmt|;
block|}
comment|/* A grant for every tx ring slot */
if|if
condition|(
name|gnttab_alloc_grant_references
argument_list|(
name|TX_MAX_TARGET
argument_list|,
operator|&
name|np
operator|->
name|gref_tx_head
argument_list|)
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"#### netfront can't alloc tx grant refs\n"
argument_list|)
expr_stmt|;
name|err
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|exit
goto|;
block|}
comment|/* A grant for every rx ring slot */
if|if
condition|(
name|gnttab_alloc_grant_references
argument_list|(
name|RX_MAX_TARGET
argument_list|,
operator|&
name|np
operator|->
name|gref_rx_head
argument_list|)
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"#### netfront can't alloc rx grant refs\n"
argument_list|)
expr_stmt|;
name|gnttab_free_grant_references
argument_list|(
name|np
operator|->
name|gref_tx_head
argument_list|)
expr_stmt|;
name|err
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|exit
goto|;
block|}
name|err
operator|=
name|xen_net_read_mac
argument_list|(
name|dev
argument_list|,
name|np
operator|->
name|mac
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|xenbus_dev_fatal
argument_list|(
name|dev
argument_list|,
name|err
argument_list|,
literal|"parsing %s/mac"
argument_list|,
name|dev
operator|->
name|nodename
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Set up ifnet structure */
operator|*
name|ifpp
operator|=
name|ifp
operator|=
name|np
operator|->
name|xn_ifp
operator|=
name|if_alloc
argument_list|(
name|IFT_ETHER
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_softc
operator|=
name|np
expr_stmt|;
name|if_initname
argument_list|(
name|ifp
argument_list|,
literal|"xn"
argument_list|,
name|ifno
operator|++
comment|/* ifno */
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|xn_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_output
operator|=
name|ether_output
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|xn_start
expr_stmt|;
ifdef|#
directive|ifdef
name|notyet
name|ifp
operator|->
name|if_watchdog
operator|=
name|xn_watchdog
expr_stmt|;
endif|#
directive|endif
name|ifp
operator|->
name|if_init
operator|=
name|xn_ifinit
expr_stmt|;
name|ifp
operator|->
name|if_mtu
operator|=
name|ETHERMTU
expr_stmt|;
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_maxlen
operator|=
name|NET_TX_RING_SIZE
operator|-
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|notyet
name|ifp
operator|->
name|if_hwassist
operator|=
name|XN_CSUM_FEATURES
expr_stmt|;
name|ifp
operator|->
name|if_capabilities
operator|=
name|IFCAP_HWCSUM
expr_stmt|;
name|ifp
operator|->
name|if_capenable
operator|=
name|ifp
operator|->
name|if_capabilities
expr_stmt|;
endif|#
directive|endif
name|ether_ifattach
argument_list|(
name|ifp
argument_list|,
name|np
operator|->
name|mac
argument_list|)
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|np
operator|->
name|xn_stat_ch
argument_list|,
name|CALLOUT_MPSAFE
argument_list|)
expr_stmt|;
name|netfront_carrier_off
argument_list|(
name|np
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|exit
label|:
name|gnttab_free_grant_references
argument_list|(
name|np
operator|->
name|gref_tx_head
argument_list|)
expr_stmt|;
name|out
label|:
name|panic
argument_list|(
literal|"do something smart"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Handle the change of state of the backend to Closing.  We must delete our  * device-layer structures now, to ensure that writes are flushed through to  * the backend.  Once is this done, we can switch to Closed in  * acknowledgement.  */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_if
unit|static void netfront_closing(struct xenbus_device *dev) {
if|#
directive|if
literal|0
end_if

begin_endif
unit|struct netfront_info *info = dev->dev_driver_data;  	DPRINTK("netfront_closing: %s removed\n", dev->nodename);  	close_netdev(info);
endif|#
directive|endif
end_endif

begin_endif
unit|xenbus_switch_state(dev, XenbusStateClosed); }
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|netfront_remove
parameter_list|(
name|struct
name|xenbus_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|netfront_info
modifier|*
name|info
init|=
name|dev
operator|->
name|dev_driver_data
decl_stmt|;
name|DPRINTK
argument_list|(
literal|"%s\n"
argument_list|,
name|dev
operator|->
name|nodename
argument_list|)
expr_stmt|;
name|netif_free
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|info
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|netif_free
parameter_list|(
name|struct
name|netfront_info
modifier|*
name|info
parameter_list|)
block|{
name|netif_disconnect_backend
argument_list|(
name|info
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|close_netdev(info);
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|netif_disconnect_backend
parameter_list|(
name|struct
name|netfront_info
modifier|*
name|info
parameter_list|)
block|{
name|xn_stop
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|end_access
argument_list|(
name|info
operator|->
name|tx_ring_ref
argument_list|,
name|info
operator|->
name|tx
operator|.
name|sring
argument_list|)
expr_stmt|;
name|end_access
argument_list|(
name|info
operator|->
name|rx_ring_ref
argument_list|,
name|info
operator|->
name|rx
operator|.
name|sring
argument_list|)
expr_stmt|;
name|info
operator|->
name|tx_ring_ref
operator|=
name|GRANT_INVALID_REF
expr_stmt|;
name|info
operator|->
name|rx_ring_ref
operator|=
name|GRANT_INVALID_REF
expr_stmt|;
name|info
operator|->
name|tx
operator|.
name|sring
operator|=
name|NULL
expr_stmt|;
name|info
operator|->
name|rx
operator|.
name|sring
operator|=
name|NULL
expr_stmt|;
if|#
directive|if
literal|0
block|if (info->irq) 		unbind_from_irqhandler(info->irq, info->netdev);
else|#
directive|else
name|panic
argument_list|(
literal|"FIX ME"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|info
operator|->
name|irq
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|end_access
parameter_list|(
name|int
name|ref
parameter_list|,
name|void
modifier|*
name|page
parameter_list|)
block|{
if|if
condition|(
name|ref
operator|!=
name|GRANT_INVALID_REF
condition|)
name|gnttab_end_foreign_access
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|,
name|page
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** Driver registration ** */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|xenbus_device_id
name|netfront_ids
index|[]
init|=
block|{
block|{
literal|"vif"
block|}
block|,
block|{
literal|""
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|xenbus_driver
name|netfront
init|=
block|{
operator|.
name|name
operator|=
literal|"vif"
block|,
operator|.
name|ids
operator|=
name|netfront_ids
block|,
operator|.
name|probe
operator|=
name|netfront_probe
block|,
operator|.
name|remove
operator|=
name|netfront_remove
block|,
operator|.
name|resume
operator|=
name|netfront_resume
block|,
operator|.
name|otherend_changed
operator|=
name|backend_changed
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|netif_init
parameter_list|(
name|void
modifier|*
name|unused
parameter_list|)
block|{
if|if
condition|(
operator|!
name|is_running_on_xen
argument_list|()
condition|)
return|return;
if|if
condition|(
name|is_initial_xendomain
argument_list|()
condition|)
return|return;
name|IPRINTK
argument_list|(
literal|"Initialising virtual ethernet driver.\n"
argument_list|)
expr_stmt|;
name|xenbus_register_frontend
argument_list|(
operator|&
name|netfront
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|xennetif
argument_list|,
name|SI_SUB_PSEUDO
argument_list|,
name|SI_ORDER_SECOND
argument_list|,
name|netif_init
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Local variables:  * mode: C  * c-set-style: "BSD"  * c-basic-offset: 8  * tab-width: 4  * indent-tabs-mode: t  * End:  */
end_comment

end_unit

