begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2004-2006 Kip Macy  * Copyright (c) 2015 Wei Liu<wei.liu2@citrix.com>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_inet6.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp_lro.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<xen/xen-os.h>
end_include

begin_include
include|#
directive|include
file|<xen/hypervisor.h>
end_include

begin_include
include|#
directive|include
file|<xen/xen_intr.h>
end_include

begin_include
include|#
directive|include
file|<xen/gnttab.h>
end_include

begin_include
include|#
directive|include
file|<xen/interface/memory.h>
end_include

begin_include
include|#
directive|include
file|<xen/interface/io/netif.h>
end_include

begin_include
include|#
directive|include
file|<xen/xenbus/xenbusvar.h>
end_include

begin_include
include|#
directive|include
file|"xenbus_if.h"
end_include

begin_comment
comment|/* Features supported by all backends.  TSO and LRO can be negotiated */
end_comment

begin_define
define|#
directive|define
name|XN_CSUM_FEATURES
value|(CSUM_TCP | CSUM_UDP)
end_define

begin_define
define|#
directive|define
name|NET_TX_RING_SIZE
value|__RING_SIZE((netif_tx_sring_t *)0, PAGE_SIZE)
end_define

begin_define
define|#
directive|define
name|NET_RX_RING_SIZE
value|__RING_SIZE((netif_rx_sring_t *)0, PAGE_SIZE)
end_define

begin_define
define|#
directive|define
name|NET_RX_SLOTS_MIN
value|(XEN_NETIF_NR_SLOTS_MIN + 1)
end_define

begin_comment
comment|/*  * Should the driver do LRO on the RX end  *  this can be toggled on the fly, but the  *  interface must be reset (down/up) for it  *  to take effect.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|xn_enable_lro
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.xn.enable_lro"
argument_list|,
operator|&
name|xn_enable_lro
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Number of pairs of queues.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|xn_num_queues
init|=
literal|4
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_ULONG
argument_list|(
literal|"hw.xn.num_queues"
argument_list|,
operator|&
name|xn_num_queues
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/**  * \brief The maximum allowed data fragments in a single transmit  *        request.  *  * This limit is imposed by the backend driver.  We assume here that  * we are dealing with a Linux driver domain and have set our limit  * to mirror the Linux MAX_SKB_FRAGS constant.  */
end_comment

begin_define
define|#
directive|define
name|MAX_TX_REQ_FRAGS
value|(65536 / PAGE_SIZE + 2)
end_define

begin_define
define|#
directive|define
name|RX_COPY_THRESHOLD
value|256
end_define

begin_define
define|#
directive|define
name|net_ratelimit
parameter_list|()
value|0
end_define

begin_struct_decl
struct_decl|struct
name|netfront_rxq
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|netfront_txq
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|netfront_info
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|netfront_rx_info
struct_decl|;
end_struct_decl

begin_function_decl
specifier|static
name|void
name|xn_txeof
parameter_list|(
name|struct
name|netfront_txq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xn_rxeof
parameter_list|(
name|struct
name|netfront_rxq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xn_alloc_rx_buffers
parameter_list|(
name|struct
name|netfront_rxq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xn_alloc_rx_buffers_callout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xn_release_rx_bufs
parameter_list|(
name|struct
name|netfront_rxq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xn_release_tx_bufs
parameter_list|(
name|struct
name|netfront_txq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xn_rxq_intr
parameter_list|(
name|struct
name|netfront_rxq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xn_txq_intr
parameter_list|(
name|struct
name|netfront_txq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xn_intr
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|int
name|xn_count_frags
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xn_assemble_tx_request
parameter_list|(
name|struct
name|netfront_txq
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xn_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|u_long
parameter_list|,
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xn_ifinit_locked
parameter_list|(
name|struct
name|netfront_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xn_ifinit
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xn_stop
parameter_list|(
name|struct
name|netfront_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xn_query_features
parameter_list|(
name|struct
name|netfront_info
modifier|*
name|np
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xn_configure_features
parameter_list|(
name|struct
name|netfront_info
modifier|*
name|np
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|netif_free
parameter_list|(
name|struct
name|netfront_info
modifier|*
name|info
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|netfront_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xn_txq_mq_start_locked
parameter_list|(
name|struct
name|netfront_txq
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xn_txq_mq_start
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|talk_to_backend
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|netfront_info
modifier|*
name|info
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|create_netdev
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|netif_disconnect_backend
parameter_list|(
name|struct
name|netfront_info
modifier|*
name|info
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|setup_device
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|netfront_info
modifier|*
name|info
parameter_list|,
name|unsigned
name|long
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xn_ifmedia_upd
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xn_ifmedia_sts
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|ifmediareq
modifier|*
name|ifmr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xn_connect
parameter_list|(
name|struct
name|netfront_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xn_kick_rings
parameter_list|(
name|struct
name|netfront_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xn_get_responses
parameter_list|(
name|struct
name|netfront_rxq
modifier|*
parameter_list|,
name|struct
name|netfront_rx_info
modifier|*
parameter_list|,
name|RING_IDX
parameter_list|,
name|RING_IDX
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|virt_to_mfn
parameter_list|(
name|x
parameter_list|)
value|(vtophys(x)>> PAGE_SHIFT)
end_define

begin_define
define|#
directive|define
name|INVALID_P2M_ENTRY
value|(~0UL)
end_define

begin_define
define|#
directive|define
name|XN_QUEUE_NAME_LEN
value|8
end_define

begin_comment
comment|/* xn{t,r}x_%u, allow for two digits */
end_comment

begin_struct
struct|struct
name|netfront_rxq
block|{
name|struct
name|netfront_info
modifier|*
name|info
decl_stmt|;
name|u_int
name|id
decl_stmt|;
name|char
name|name
index|[
name|XN_QUEUE_NAME_LEN
index|]
decl_stmt|;
name|struct
name|mtx
name|lock
decl_stmt|;
name|int
name|ring_ref
decl_stmt|;
name|netif_rx_front_ring_t
name|ring
decl_stmt|;
name|xen_intr_handle_t
name|xen_intr_handle
decl_stmt|;
name|grant_ref_t
name|gref_head
decl_stmt|;
name|grant_ref_t
name|grant_ref
index|[
name|NET_RX_RING_SIZE
operator|+
literal|1
index|]
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mbufs
index|[
name|NET_RX_RING_SIZE
operator|+
literal|1
index|]
decl_stmt|;
name|struct
name|lro_ctrl
name|lro
decl_stmt|;
name|struct
name|callout
name|rx_refill
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|netfront_txq
block|{
name|struct
name|netfront_info
modifier|*
name|info
decl_stmt|;
name|u_int
name|id
decl_stmt|;
name|char
name|name
index|[
name|XN_QUEUE_NAME_LEN
index|]
decl_stmt|;
name|struct
name|mtx
name|lock
decl_stmt|;
name|int
name|ring_ref
decl_stmt|;
name|netif_tx_front_ring_t
name|ring
decl_stmt|;
name|xen_intr_handle_t
name|xen_intr_handle
decl_stmt|;
name|grant_ref_t
name|gref_head
decl_stmt|;
name|grant_ref_t
name|grant_ref
index|[
name|NET_TX_RING_SIZE
operator|+
literal|1
index|]
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mbufs
index|[
name|NET_TX_RING_SIZE
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|mbufs_cnt
decl_stmt|;
name|struct
name|buf_ring
modifier|*
name|br
decl_stmt|;
name|struct
name|taskqueue
modifier|*
name|tq
decl_stmt|;
name|struct
name|task
name|defrtask
decl_stmt|;
name|bool
name|full
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|netfront_info
block|{
name|struct
name|ifnet
modifier|*
name|xn_ifp
decl_stmt|;
name|struct
name|mtx
name|sc_lock
decl_stmt|;
name|u_int
name|num_queues
decl_stmt|;
name|struct
name|netfront_rxq
modifier|*
name|rxq
decl_stmt|;
name|struct
name|netfront_txq
modifier|*
name|txq
decl_stmt|;
name|u_int
name|carrier
decl_stmt|;
name|u_int
name|maxfrags
decl_stmt|;
name|device_t
name|xbdev
decl_stmt|;
name|uint8_t
name|mac
index|[
name|ETHER_ADDR_LEN
index|]
decl_stmt|;
name|int
name|xn_if_flags
decl_stmt|;
name|struct
name|ifmedia
name|sc_media
decl_stmt|;
name|bool
name|xn_reset
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|netfront_rx_info
block|{
name|struct
name|netif_rx_response
name|rx
decl_stmt|;
name|struct
name|netif_extra_info
name|extras
index|[
name|XEN_NETIF_EXTRA_TYPE_MAX
operator|-
literal|1
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|XN_RX_LOCK
parameter_list|(
name|_q
parameter_list|)
value|mtx_lock(&(_q)->lock)
end_define

begin_define
define|#
directive|define
name|XN_RX_UNLOCK
parameter_list|(
name|_q
parameter_list|)
value|mtx_unlock(&(_q)->lock)
end_define

begin_define
define|#
directive|define
name|XN_TX_LOCK
parameter_list|(
name|_q
parameter_list|)
value|mtx_lock(&(_q)->lock)
end_define

begin_define
define|#
directive|define
name|XN_TX_TRYLOCK
parameter_list|(
name|_q
parameter_list|)
value|mtx_trylock(&(_q)->lock)
end_define

begin_define
define|#
directive|define
name|XN_TX_UNLOCK
parameter_list|(
name|_q
parameter_list|)
value|mtx_unlock(&(_q)->lock)
end_define

begin_define
define|#
directive|define
name|XN_LOCK
parameter_list|(
name|_sc
parameter_list|)
value|mtx_lock(&(_sc)->sc_lock);
end_define

begin_define
define|#
directive|define
name|XN_UNLOCK
parameter_list|(
name|_sc
parameter_list|)
value|mtx_unlock(&(_sc)->sc_lock);
end_define

begin_define
define|#
directive|define
name|XN_LOCK_ASSERT
parameter_list|(
name|_sc
parameter_list|)
value|mtx_assert(&(_sc)->sc_lock, MA_OWNED);
end_define

begin_define
define|#
directive|define
name|XN_RX_LOCK_ASSERT
parameter_list|(
name|_q
parameter_list|)
value|mtx_assert(&(_q)->lock, MA_OWNED);
end_define

begin_define
define|#
directive|define
name|XN_TX_LOCK_ASSERT
parameter_list|(
name|_q
parameter_list|)
value|mtx_assert(&(_q)->lock, MA_OWNED);
end_define

begin_define
define|#
directive|define
name|netfront_carrier_on
parameter_list|(
name|netif
parameter_list|)
value|((netif)->carrier = 1)
end_define

begin_define
define|#
directive|define
name|netfront_carrier_off
parameter_list|(
name|netif
parameter_list|)
value|((netif)->carrier = 0)
end_define

begin_define
define|#
directive|define
name|netfront_carrier_ok
parameter_list|(
name|netif
parameter_list|)
value|((netif)->carrier)
end_define

begin_comment
comment|/* Access macros for acquiring freeing slots in xn_free_{tx,rx}_idxs[]. */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|add_id_to_freelist
parameter_list|(
name|struct
name|mbuf
modifier|*
modifier|*
name|list
parameter_list|,
name|uintptr_t
name|id
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|id
operator|!=
literal|0
argument_list|,
operator|(
literal|"%s: the head item (0) must always be free."
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|list
index|[
name|id
index|]
operator|=
name|list
index|[
literal|0
index|]
expr_stmt|;
name|list
index|[
literal|0
index|]
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
name|id
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|unsigned
name|short
name|get_id_from_freelist
parameter_list|(
name|struct
name|mbuf
modifier|*
modifier|*
name|list
parameter_list|)
block|{
name|uintptr_t
name|id
decl_stmt|;
name|id
operator|=
operator|(
name|uintptr_t
operator|)
name|list
index|[
literal|0
index|]
expr_stmt|;
name|KASSERT
argument_list|(
name|id
operator|!=
literal|0
argument_list|,
operator|(
literal|"%s: the head item (0) must always remain free."
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|list
index|[
literal|0
index|]
operator|=
name|list
index|[
name|id
index|]
expr_stmt|;
return|return
operator|(
name|id
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|xn_rxidx
parameter_list|(
name|RING_IDX
name|idx
parameter_list|)
block|{
return|return
name|idx
operator|&
operator|(
name|NET_RX_RING_SIZE
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|struct
name|mbuf
modifier|*
name|xn_get_rx_mbuf
parameter_list|(
name|struct
name|netfront_rxq
modifier|*
name|rxq
parameter_list|,
name|RING_IDX
name|ri
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|i
operator|=
name|xn_rxidx
argument_list|(
name|ri
argument_list|)
expr_stmt|;
name|m
operator|=
name|rxq
operator|->
name|mbufs
index|[
name|i
index|]
expr_stmt|;
name|rxq
operator|->
name|mbufs
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|grant_ref_t
name|xn_get_rx_ref
parameter_list|(
name|struct
name|netfront_rxq
modifier|*
name|rxq
parameter_list|,
name|RING_IDX
name|ri
parameter_list|)
block|{
name|int
name|i
init|=
name|xn_rxidx
argument_list|(
name|ri
argument_list|)
decl_stmt|;
name|grant_ref_t
name|ref
init|=
name|rxq
operator|->
name|grant_ref
index|[
name|i
index|]
decl_stmt|;
name|KASSERT
argument_list|(
name|ref
operator|!=
name|GRANT_REF_INVALID
argument_list|,
operator|(
literal|"Invalid grant reference!\n"
operator|)
argument_list|)
expr_stmt|;
name|rxq
operator|->
name|grant_ref
index|[
name|i
index|]
operator|=
name|GRANT_REF_INVALID
expr_stmt|;
return|return
operator|(
name|ref
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|IPRINTK
parameter_list|(
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
define|\
value|printf("[XEN] " fmt, ##args)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|INVARIANTS
end_ifdef

begin_define
define|#
directive|define
name|WPRINTK
parameter_list|(
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
define|\
value|printf("[XEN] " fmt, ##args)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|WPRINTK
parameter_list|(
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_define
define|#
directive|define
name|DPRINTK
parameter_list|(
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
define|\
value|printf("[XEN] %s: " fmt, __func__, ##args)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DPRINTK
parameter_list|(
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * Read the 'mac' node at the given device's node in the store, and parse that  * as colon-separated octets, placing result the given mac array.  mac must be  * a preallocated array of length ETH_ALEN (as declared in linux/if_ether.h).  * Return 0 on success, or errno on error.  */
end_comment

begin_function
specifier|static
name|int
name|xen_net_read_mac
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|uint8_t
name|mac
index|[]
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|e
decl_stmt|,
modifier|*
name|macstr
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
name|path
operator|=
name|xenbus_get_node
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|error
operator|=
name|xs_read
argument_list|(
name|XST_NIL
argument_list|,
name|path
argument_list|,
literal|"mac"
argument_list|,
name|NULL
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|macstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENOENT
condition|)
block|{
comment|/* 		 * Deal with missing mac XenStore nodes on devices with 		 * HVM emulation (the 'ioemu' configuration attribute) 		 * enabled. 		 * 		 * The HVM emulator may execute in a stub device model 		 * domain which lacks the permission, only given to Dom0, 		 * to update the guest's XenStore tree.  For this reason, 		 * the HVM emulator doesn't even attempt to write the 		 * front-side mac node, even when operating in Dom0. 		 * However, there should always be a mac listed in the 		 * backend tree.  Fallback to this version if our query 		 * of the front side XenStore location doesn't find 		 * anything. 		 */
name|path
operator|=
name|xenbus_get_otherend_path
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|error
operator|=
name|xs_read
argument_list|(
name|XST_NIL
argument_list|,
name|path
argument_list|,
literal|"mac"
argument_list|,
name|NULL
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|macstr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|xenbus_dev_fatal
argument_list|(
name|dev
argument_list|,
name|error
argument_list|,
literal|"parsing %s/mac"
argument_list|,
name|path
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|s
operator|=
name|macstr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ETHER_ADDR_LEN
condition|;
name|i
operator|++
control|)
block|{
name|mac
index|[
name|i
index|]
operator|=
name|strtoul
argument_list|(
name|s
argument_list|,
operator|&
name|e
argument_list|,
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|e
operator|||
operator|(
name|e
index|[
literal|0
index|]
operator|!=
literal|':'
operator|&&
name|e
index|[
literal|0
index|]
operator|!=
literal|0
operator|)
condition|)
block|{
name|free
argument_list|(
name|macstr
argument_list|,
name|M_XENBUS
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
name|s
operator|=
operator|&
name|e
index|[
literal|1
index|]
expr_stmt|;
block|}
name|free
argument_list|(
name|macstr
argument_list|,
name|M_XENBUS
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Entry point to this code when a new device is created.  Allocate the basic  * structures and the ring buffers for communication with the backend, and  * inform the backend of the appropriate details for those.  Switch to  * Connected state.  */
end_comment

begin_function
specifier|static
name|int
name|netfront_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
if|if
condition|(
name|xen_hvm_domain
argument_list|()
operator|&&
name|xen_disable_pv_nics
operator|!=
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|xenbus_get_type
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|"vif"
argument_list|)
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Virtual Network Interface"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|netfront_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|err
operator|=
name|create_netdev
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|xenbus_dev_fatal
argument_list|(
name|dev
argument_list|,
name|err
argument_list|,
literal|"creating netdev"
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
name|SYSCTL_ADD_INT
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"enable_lro"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|xn_enable_lro
argument_list|,
literal|0
argument_list|,
literal|"Large Receive Offload"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"num_queues"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|xn_num_queues
argument_list|,
literal|"Number of pairs of queues"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|netfront_suspend
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|netfront_info
modifier|*
name|np
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|u_int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|np
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
name|XN_RX_LOCK
argument_list|(
operator|&
name|np
operator|->
name|rxq
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|XN_TX_LOCK
argument_list|(
operator|&
name|np
operator|->
name|txq
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|netfront_carrier_off
argument_list|(
name|np
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|np
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
name|XN_RX_UNLOCK
argument_list|(
operator|&
name|np
operator|->
name|rxq
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|XN_TX_UNLOCK
argument_list|(
operator|&
name|np
operator|->
name|txq
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * We are reconnecting to the backend, due to a suspend/resume, or a backend  * driver restart.  We tear down our netif structure and recreate it, but  * leave the device-layer structures intact so that this is transparent to the  * rest of the kernel.  */
end_comment

begin_function
specifier|static
name|int
name|netfront_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|netfront_info
modifier|*
name|info
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|u_int
name|i
decl_stmt|;
if|if
condition|(
name|xen_suspend_cancelled
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|info
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
name|XN_RX_LOCK
argument_list|(
operator|&
name|info
operator|->
name|rxq
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|XN_TX_LOCK
argument_list|(
operator|&
name|info
operator|->
name|txq
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|netfront_carrier_on
argument_list|(
name|info
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|info
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
name|XN_RX_UNLOCK
argument_list|(
operator|&
name|info
operator|->
name|rxq
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|XN_TX_UNLOCK
argument_list|(
operator|&
name|info
operator|->
name|txq
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|netif_disconnect_backend
argument_list|(
name|info
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|write_queue_xenstore_keys
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|netfront_rxq
modifier|*
name|rxq
parameter_list|,
name|struct
name|netfront_txq
modifier|*
name|txq
parameter_list|,
name|struct
name|xs_transaction
modifier|*
name|xst
parameter_list|,
name|bool
name|hierarchy
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
specifier|const
name|char
modifier|*
name|message
decl_stmt|;
specifier|const
name|char
modifier|*
name|node
init|=
name|xenbus_get_node
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|char
modifier|*
name|path
decl_stmt|;
name|size_t
name|path_size
decl_stmt|;
name|KASSERT
argument_list|(
name|rxq
operator|->
name|id
operator|==
name|txq
operator|->
name|id
argument_list|,
operator|(
literal|"Mismatch between RX and TX queue ids"
operator|)
argument_list|)
expr_stmt|;
comment|/* Split event channel support is not yet there. */
name|KASSERT
argument_list|(
name|rxq
operator|->
name|xen_intr_handle
operator|==
name|txq
operator|->
name|xen_intr_handle
argument_list|,
operator|(
literal|"Split event channels are not supported"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hierarchy
condition|)
block|{
name|path_size
operator|=
name|strlen
argument_list|(
name|node
argument_list|)
operator|+
literal|10
expr_stmt|;
name|path
operator|=
name|malloc
argument_list|(
name|path_size
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|path
argument_list|,
name|path_size
argument_list|,
literal|"%s/queue-%u"
argument_list|,
name|node
argument_list|,
name|rxq
operator|->
name|id
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|path_size
operator|=
name|strlen
argument_list|(
name|node
argument_list|)
operator|+
literal|1
expr_stmt|;
name|path
operator|=
name|malloc
argument_list|(
name|path_size
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|path
argument_list|,
name|path_size
argument_list|,
literal|"%s"
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
name|err
operator|=
name|xs_printf
argument_list|(
operator|*
name|xst
argument_list|,
name|path
argument_list|,
literal|"tx-ring-ref"
argument_list|,
literal|"%u"
argument_list|,
name|txq
operator|->
name|ring_ref
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|message
operator|=
literal|"writing tx ring-ref"
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|err
operator|=
name|xs_printf
argument_list|(
operator|*
name|xst
argument_list|,
name|path
argument_list|,
literal|"rx-ring-ref"
argument_list|,
literal|"%u"
argument_list|,
name|rxq
operator|->
name|ring_ref
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|message
operator|=
literal|"writing rx ring-ref"
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|err
operator|=
name|xs_printf
argument_list|(
operator|*
name|xst
argument_list|,
name|path
argument_list|,
literal|"event-channel"
argument_list|,
literal|"%u"
argument_list|,
name|xen_intr_port
argument_list|(
name|rxq
operator|->
name|xen_intr_handle
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|message
operator|=
literal|"writing event-channel"
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|free
argument_list|(
name|path
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|error
label|:
name|free
argument_list|(
name|path
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|xenbus_dev_fatal
argument_list|(
name|dev
argument_list|,
name|err
argument_list|,
literal|"%s"
argument_list|,
name|message
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Common code used when first setting up, and when resuming. */
end_comment

begin_function
specifier|static
name|int
name|talk_to_backend
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|netfront_info
modifier|*
name|info
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|message
decl_stmt|;
name|struct
name|xs_transaction
name|xst
decl_stmt|;
specifier|const
name|char
modifier|*
name|node
init|=
name|xenbus_get_node
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|err
decl_stmt|;
name|unsigned
name|long
name|num_queues
decl_stmt|,
name|max_queues
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|err
operator|=
name|xen_net_read_mac
argument_list|(
name|dev
argument_list|,
name|info
operator|->
name|mac
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|xenbus_dev_fatal
argument_list|(
name|dev
argument_list|,
name|err
argument_list|,
literal|"parsing %s/mac"
argument_list|,
name|node
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|err
operator|=
name|xs_scanf
argument_list|(
name|XST_NIL
argument_list|,
name|xenbus_get_otherend_path
argument_list|(
name|info
operator|->
name|xbdev
argument_list|)
argument_list|,
literal|"multi-queue-max-queues"
argument_list|,
name|NULL
argument_list|,
literal|"%lu"
argument_list|,
operator|&
name|max_queues
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
name|max_queues
operator|=
literal|1
expr_stmt|;
name|num_queues
operator|=
name|xn_num_queues
expr_stmt|;
if|if
condition|(
name|num_queues
operator|>
name|max_queues
condition|)
name|num_queues
operator|=
name|max_queues
expr_stmt|;
name|err
operator|=
name|setup_device
argument_list|(
name|dev
argument_list|,
name|info
argument_list|,
name|num_queues
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
name|again
label|:
name|err
operator|=
name|xs_transaction_start
argument_list|(
operator|&
name|xst
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|xenbus_dev_fatal
argument_list|(
name|dev
argument_list|,
name|err
argument_list|,
literal|"starting transaction"
argument_list|)
expr_stmt|;
goto|goto
name|free
goto|;
block|}
if|if
condition|(
name|info
operator|->
name|num_queues
operator|==
literal|1
condition|)
block|{
name|err
operator|=
name|write_queue_xenstore_keys
argument_list|(
name|dev
argument_list|,
operator|&
name|info
operator|->
name|rxq
index|[
literal|0
index|]
argument_list|,
operator|&
name|info
operator|->
name|txq
index|[
literal|0
index|]
argument_list|,
operator|&
name|xst
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
goto|goto
name|abort_transaction_no_def_error
goto|;
block|}
else|else
block|{
name|err
operator|=
name|xs_printf
argument_list|(
name|xst
argument_list|,
name|node
argument_list|,
literal|"multi-queue-num-queues"
argument_list|,
literal|"%u"
argument_list|,
name|info
operator|->
name|num_queues
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|message
operator|=
literal|"writing multi-queue-num-queues"
expr_stmt|;
goto|goto
name|abort_transaction
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|info
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
name|err
operator|=
name|write_queue_xenstore_keys
argument_list|(
name|dev
argument_list|,
operator|&
name|info
operator|->
name|rxq
index|[
name|i
index|]
argument_list|,
operator|&
name|info
operator|->
name|txq
index|[
name|i
index|]
argument_list|,
operator|&
name|xst
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
goto|goto
name|abort_transaction_no_def_error
goto|;
block|}
block|}
name|err
operator|=
name|xs_printf
argument_list|(
name|xst
argument_list|,
name|node
argument_list|,
literal|"request-rx-copy"
argument_list|,
literal|"%u"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|message
operator|=
literal|"writing request-rx-copy"
expr_stmt|;
goto|goto
name|abort_transaction
goto|;
block|}
name|err
operator|=
name|xs_printf
argument_list|(
name|xst
argument_list|,
name|node
argument_list|,
literal|"feature-rx-notify"
argument_list|,
literal|"%d"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|message
operator|=
literal|"writing feature-rx-notify"
expr_stmt|;
goto|goto
name|abort_transaction
goto|;
block|}
name|err
operator|=
name|xs_printf
argument_list|(
name|xst
argument_list|,
name|node
argument_list|,
literal|"feature-sg"
argument_list|,
literal|"%d"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|message
operator|=
literal|"writing feature-sg"
expr_stmt|;
goto|goto
name|abort_transaction
goto|;
block|}
if|if
condition|(
operator|(
name|info
operator|->
name|xn_ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_LRO
operator|)
operator|!=
literal|0
condition|)
block|{
name|err
operator|=
name|xs_printf
argument_list|(
name|xst
argument_list|,
name|node
argument_list|,
literal|"feature-gso-tcpv4"
argument_list|,
literal|"%d"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|message
operator|=
literal|"writing feature-gso-tcpv4"
expr_stmt|;
goto|goto
name|abort_transaction
goto|;
block|}
block|}
if|if
condition|(
operator|(
name|info
operator|->
name|xn_ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_RXCSUM
operator|)
operator|==
literal|0
condition|)
block|{
name|err
operator|=
name|xs_printf
argument_list|(
name|xst
argument_list|,
name|node
argument_list|,
literal|"feature-no-csum-offload"
argument_list|,
literal|"%d"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|message
operator|=
literal|"writing feature-no-csum-offload"
expr_stmt|;
goto|goto
name|abort_transaction
goto|;
block|}
block|}
name|err
operator|=
name|xs_transaction_end
argument_list|(
name|xst
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|err
operator|==
name|EAGAIN
condition|)
goto|goto
name|again
goto|;
name|xenbus_dev_fatal
argument_list|(
name|dev
argument_list|,
name|err
argument_list|,
literal|"completing transaction"
argument_list|)
expr_stmt|;
goto|goto
name|free
goto|;
block|}
return|return
literal|0
return|;
name|abort_transaction
label|:
name|xenbus_dev_fatal
argument_list|(
name|dev
argument_list|,
name|err
argument_list|,
literal|"%s"
argument_list|,
name|message
argument_list|)
expr_stmt|;
name|abort_transaction_no_def_error
label|:
name|xs_transaction_end
argument_list|(
name|xst
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|free
label|:
name|netif_free
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|out
label|:
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xn_rxq_intr
parameter_list|(
name|struct
name|netfront_rxq
modifier|*
name|rxq
parameter_list|)
block|{
name|XN_RX_LOCK
argument_list|(
name|rxq
argument_list|)
expr_stmt|;
name|xn_rxeof
argument_list|(
name|rxq
argument_list|)
expr_stmt|;
name|XN_RX_UNLOCK
argument_list|(
name|rxq
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xn_txq_start
parameter_list|(
name|struct
name|netfront_txq
modifier|*
name|txq
parameter_list|)
block|{
name|struct
name|netfront_info
modifier|*
name|np
init|=
name|txq
operator|->
name|info
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|np
operator|->
name|xn_ifp
decl_stmt|;
name|XN_TX_LOCK_ASSERT
argument_list|(
name|txq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|drbr_empty
argument_list|(
name|ifp
argument_list|,
name|txq
operator|->
name|br
argument_list|)
condition|)
name|xn_txq_mq_start_locked
argument_list|(
name|txq
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xn_txq_intr
parameter_list|(
name|struct
name|netfront_txq
modifier|*
name|txq
parameter_list|)
block|{
name|XN_TX_LOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
if|if
condition|(
name|RING_HAS_UNCONSUMED_RESPONSES
argument_list|(
operator|&
name|txq
operator|->
name|ring
argument_list|)
condition|)
name|xn_txeof
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|xn_txq_start
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|XN_TX_UNLOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xn_txq_tq_deferred
parameter_list|(
name|void
modifier|*
name|xtxq
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|netfront_txq
modifier|*
name|txq
init|=
name|xtxq
decl_stmt|;
name|XN_TX_LOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|xn_txq_start
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|XN_TX_UNLOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|disconnect_rxq
parameter_list|(
name|struct
name|netfront_rxq
modifier|*
name|rxq
parameter_list|)
block|{
name|xn_release_rx_bufs
argument_list|(
name|rxq
argument_list|)
expr_stmt|;
name|gnttab_free_grant_references
argument_list|(
name|rxq
operator|->
name|gref_head
argument_list|)
expr_stmt|;
name|gnttab_end_foreign_access
argument_list|(
name|rxq
operator|->
name|ring_ref
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * No split event channel support at the moment, handle will 	 * be unbound in tx. So no need to call xen_intr_unbind here, 	 * but we do want to reset the handler to 0. 	 */
name|rxq
operator|->
name|xen_intr_handle
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|destroy_rxq
parameter_list|(
name|struct
name|netfront_rxq
modifier|*
name|rxq
parameter_list|)
block|{
name|callout_drain
argument_list|(
operator|&
name|rxq
operator|->
name|rx_refill
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rxq
operator|->
name|ring
operator|.
name|sring
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|destroy_rxqs
parameter_list|(
name|struct
name|netfront_info
modifier|*
name|np
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|np
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
name|destroy_rxq
argument_list|(
operator|&
name|np
operator|->
name|rxq
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|np
operator|->
name|rxq
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|np
operator|->
name|rxq
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|setup_rxqs
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|netfront_info
modifier|*
name|info
parameter_list|,
name|unsigned
name|long
name|num_queues
parameter_list|)
block|{
name|int
name|q
decl_stmt|,
name|i
decl_stmt|;
name|int
name|error
decl_stmt|;
name|netif_rx_sring_t
modifier|*
name|rxs
decl_stmt|;
name|struct
name|netfront_rxq
modifier|*
name|rxq
decl_stmt|;
name|info
operator|->
name|rxq
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|netfront_rxq
argument_list|)
operator|*
name|num_queues
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
for|for
control|(
name|q
operator|=
literal|0
init|;
name|q
operator|<
name|num_queues
condition|;
name|q
operator|++
control|)
block|{
name|rxq
operator|=
operator|&
name|info
operator|->
name|rxq
index|[
name|q
index|]
expr_stmt|;
name|rxq
operator|->
name|id
operator|=
name|q
expr_stmt|;
name|rxq
operator|->
name|info
operator|=
name|info
expr_stmt|;
name|rxq
operator|->
name|ring_ref
operator|=
name|GRANT_REF_INVALID
expr_stmt|;
name|rxq
operator|->
name|ring
operator|.
name|sring
operator|=
name|NULL
expr_stmt|;
name|snprintf
argument_list|(
name|rxq
operator|->
name|name
argument_list|,
name|XN_QUEUE_NAME_LEN
argument_list|,
literal|"xnrx_%u"
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|rxq
operator|->
name|lock
argument_list|,
name|rxq
operator|->
name|name
argument_list|,
literal|"netfront receive lock"
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|NET_RX_RING_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|rxq
operator|->
name|mbufs
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|rxq
operator|->
name|grant_ref
index|[
name|i
index|]
operator|=
name|GRANT_REF_INVALID
expr_stmt|;
block|}
comment|/* Start resources allocation */
if|if
condition|(
name|gnttab_alloc_grant_references
argument_list|(
name|NET_RX_RING_SIZE
argument_list|,
operator|&
name|rxq
operator|->
name|gref_head
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"allocating rx gref"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|rxs
operator|=
operator|(
name|netif_rx_sring_t
operator|*
operator|)
name|malloc
argument_list|(
name|PAGE_SIZE
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|SHARED_RING_INIT
argument_list|(
name|rxs
argument_list|)
expr_stmt|;
name|FRONT_RING_INIT
argument_list|(
operator|&
name|rxq
operator|->
name|ring
argument_list|,
name|rxs
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|error
operator|=
name|xenbus_grant_ring
argument_list|(
name|dev
argument_list|,
name|virt_to_mfn
argument_list|(
name|rxs
argument_list|)
argument_list|,
operator|&
name|rxq
operator|->
name|ring_ref
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"granting rx ring page"
argument_list|)
expr_stmt|;
goto|goto
name|fail_grant_ring
goto|;
block|}
name|callout_init
argument_list|(
operator|&
name|rxq
operator|->
name|rx_refill
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|fail_grant_ring
label|:
name|gnttab_free_grant_references
argument_list|(
name|rxq
operator|->
name|gref_head
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rxq
operator|->
name|ring
operator|.
name|sring
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|fail
label|:
for|for
control|(
init|;
name|q
operator|>=
literal|0
condition|;
name|q
operator|--
control|)
block|{
name|disconnect_rxq
argument_list|(
operator|&
name|info
operator|->
name|rxq
index|[
name|q
index|]
argument_list|)
expr_stmt|;
name|destroy_rxq
argument_list|(
operator|&
name|info
operator|->
name|rxq
index|[
name|q
index|]
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|info
operator|->
name|rxq
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|disconnect_txq
parameter_list|(
name|struct
name|netfront_txq
modifier|*
name|txq
parameter_list|)
block|{
name|xn_release_tx_bufs
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|gnttab_free_grant_references
argument_list|(
name|txq
operator|->
name|gref_head
argument_list|)
expr_stmt|;
name|gnttab_end_foreign_access
argument_list|(
name|txq
operator|->
name|ring_ref
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|xen_intr_unbind
argument_list|(
operator|&
name|txq
operator|->
name|xen_intr_handle
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|destroy_txq
parameter_list|(
name|struct
name|netfront_txq
modifier|*
name|txq
parameter_list|)
block|{
name|free
argument_list|(
name|txq
operator|->
name|ring
operator|.
name|sring
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|buf_ring_free
argument_list|(
name|txq
operator|->
name|br
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|taskqueue_drain_all
argument_list|(
name|txq
operator|->
name|tq
argument_list|)
expr_stmt|;
name|taskqueue_free
argument_list|(
name|txq
operator|->
name|tq
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|destroy_txqs
parameter_list|(
name|struct
name|netfront_info
modifier|*
name|np
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|np
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
name|destroy_txq
argument_list|(
operator|&
name|np
operator|->
name|txq
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|np
operator|->
name|txq
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|np
operator|->
name|txq
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|setup_txqs
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|netfront_info
modifier|*
name|info
parameter_list|,
name|unsigned
name|long
name|num_queues
parameter_list|)
block|{
name|int
name|q
decl_stmt|,
name|i
decl_stmt|;
name|int
name|error
decl_stmt|;
name|netif_tx_sring_t
modifier|*
name|txs
decl_stmt|;
name|struct
name|netfront_txq
modifier|*
name|txq
decl_stmt|;
name|info
operator|->
name|txq
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|netfront_txq
argument_list|)
operator|*
name|num_queues
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
for|for
control|(
name|q
operator|=
literal|0
init|;
name|q
operator|<
name|num_queues
condition|;
name|q
operator|++
control|)
block|{
name|txq
operator|=
operator|&
name|info
operator|->
name|txq
index|[
name|q
index|]
expr_stmt|;
name|txq
operator|->
name|id
operator|=
name|q
expr_stmt|;
name|txq
operator|->
name|info
operator|=
name|info
expr_stmt|;
name|txq
operator|->
name|ring_ref
operator|=
name|GRANT_REF_INVALID
expr_stmt|;
name|txq
operator|->
name|ring
operator|.
name|sring
operator|=
name|NULL
expr_stmt|;
name|snprintf
argument_list|(
name|txq
operator|->
name|name
argument_list|,
name|XN_QUEUE_NAME_LEN
argument_list|,
literal|"xntx_%u"
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|txq
operator|->
name|lock
argument_list|,
name|txq
operator|->
name|name
argument_list|,
literal|"netfront transmit lock"
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|NET_TX_RING_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|txq
operator|->
name|mbufs
index|[
name|i
index|]
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|u_long
operator|)
name|i
operator|+
literal|1
operator|)
expr_stmt|;
name|txq
operator|->
name|grant_ref
index|[
name|i
index|]
operator|=
name|GRANT_REF_INVALID
expr_stmt|;
block|}
name|txq
operator|->
name|mbufs
index|[
name|NET_TX_RING_SIZE
index|]
operator|=
operator|(
name|void
operator|*
operator|)
literal|0
expr_stmt|;
comment|/* Start resources allocation. */
if|if
condition|(
name|gnttab_alloc_grant_references
argument_list|(
name|NET_TX_RING_SIZE
argument_list|,
operator|&
name|txq
operator|->
name|gref_head
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to allocate tx grant refs\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|txs
operator|=
operator|(
name|netif_tx_sring_t
operator|*
operator|)
name|malloc
argument_list|(
name|PAGE_SIZE
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|SHARED_RING_INIT
argument_list|(
name|txs
argument_list|)
expr_stmt|;
name|FRONT_RING_INIT
argument_list|(
operator|&
name|txq
operator|->
name|ring
argument_list|,
name|txs
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|error
operator|=
name|xenbus_grant_ring
argument_list|(
name|dev
argument_list|,
name|virt_to_mfn
argument_list|(
name|txs
argument_list|)
argument_list|,
operator|&
name|txq
operator|->
name|ring_ref
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to grant tx ring\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail_grant_ring
goto|;
block|}
name|txq
operator|->
name|br
operator|=
name|buf_ring_alloc
argument_list|(
name|NET_TX_RING_SIZE
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|,
operator|&
name|txq
operator|->
name|lock
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|txq
operator|->
name|defrtask
argument_list|,
literal|0
argument_list|,
name|xn_txq_tq_deferred
argument_list|,
name|txq
argument_list|)
expr_stmt|;
name|txq
operator|->
name|tq
operator|=
name|taskqueue_create
argument_list|(
name|txq
operator|->
name|name
argument_list|,
name|M_WAITOK
argument_list|,
name|taskqueue_thread_enqueue
argument_list|,
operator|&
name|txq
operator|->
name|tq
argument_list|)
expr_stmt|;
name|error
operator|=
name|taskqueue_start_threads
argument_list|(
operator|&
name|txq
operator|->
name|tq
argument_list|,
literal|1
argument_list|,
name|PI_NET
argument_list|,
literal|"%s txq %d"
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|,
name|txq
operator|->
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to start tx taskq %d\n"
argument_list|,
name|txq
operator|->
name|id
argument_list|)
expr_stmt|;
goto|goto
name|fail_start_thread
goto|;
block|}
name|error
operator|=
name|xen_intr_alloc_and_bind_local_port
argument_list|(
name|dev
argument_list|,
name|xenbus_get_otherend_id
argument_list|(
name|dev
argument_list|)
argument_list|,
comment|/* filter */
name|NULL
argument_list|,
name|xn_intr
argument_list|,
operator|&
name|info
operator|->
name|txq
index|[
name|q
index|]
argument_list|,
name|INTR_TYPE_NET
operator||
name|INTR_MPSAFE
operator||
name|INTR_ENTROPY
argument_list|,
operator|&
name|txq
operator|->
name|xen_intr_handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"xen_intr_alloc_and_bind_local_port failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail_bind_port
goto|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|fail_bind_port
label|:
name|taskqueue_drain_all
argument_list|(
name|txq
operator|->
name|tq
argument_list|)
expr_stmt|;
name|fail_start_thread
label|:
name|buf_ring_free
argument_list|(
name|txq
operator|->
name|br
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|taskqueue_free
argument_list|(
name|txq
operator|->
name|tq
argument_list|)
expr_stmt|;
name|gnttab_end_foreign_access
argument_list|(
name|txq
operator|->
name|ring_ref
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|fail_grant_ring
label|:
name|gnttab_free_grant_references
argument_list|(
name|txq
operator|->
name|gref_head
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|txq
operator|->
name|ring
operator|.
name|sring
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|fail
label|:
for|for
control|(
init|;
name|q
operator|>=
literal|0
condition|;
name|q
operator|--
control|)
block|{
name|disconnect_txq
argument_list|(
operator|&
name|info
operator|->
name|txq
index|[
name|q
index|]
argument_list|)
expr_stmt|;
name|destroy_txq
argument_list|(
operator|&
name|info
operator|->
name|txq
index|[
name|q
index|]
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|info
operator|->
name|txq
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|setup_device
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|netfront_info
modifier|*
name|info
parameter_list|,
name|unsigned
name|long
name|num_queues
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|int
name|q
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|txq
condition|)
name|destroy_txqs
argument_list|(
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|rxq
condition|)
name|destroy_rxqs
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|info
operator|->
name|num_queues
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|setup_rxqs
argument_list|(
name|dev
argument_list|,
name|info
argument_list|,
name|num_queues
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
name|error
operator|=
name|setup_txqs
argument_list|(
name|dev
argument_list|,
name|info
argument_list|,
name|num_queues
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
name|info
operator|->
name|num_queues
operator|=
name|num_queues
expr_stmt|;
comment|/* No split event channel at the moment. */
for|for
control|(
name|q
operator|=
literal|0
init|;
name|q
operator|<
name|num_queues
condition|;
name|q
operator|++
control|)
name|info
operator|->
name|rxq
index|[
name|q
index|]
operator|.
name|xen_intr_handle
operator|=
name|info
operator|->
name|txq
index|[
name|q
index|]
operator|.
name|xen_intr_handle
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|out
label|:
name|KASSERT
argument_list|(
name|error
operator|!=
literal|0
argument_list|,
operator|(
literal|"Error path taken without providing an error code"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_comment
comment|/**  * If this interface has an ipv4 address, send an arp for it. This  * helps to get the network going again after migrating hosts.  */
end_comment

begin_function
specifier|static
name|void
name|netfront_send_fake_arp
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|netfront_info
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|ifaddr
modifier|*
name|ifa
decl_stmt|;
name|ifp
operator|=
name|info
operator|->
name|xn_ifp
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ifa
argument_list|,
argument|&ifp->if_addrhead
argument_list|,
argument|ifa_link
argument_list|)
block|{
if|if
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
name|arp_ifinit
argument_list|(
name|ifp
argument_list|,
name|ifa
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * Callback received when the backend's state changes.  */
end_comment

begin_function
specifier|static
name|void
name|netfront_backend_changed
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|XenbusState
name|newstate
parameter_list|)
block|{
name|struct
name|netfront_info
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|DPRINTK
argument_list|(
literal|"newstate=%d\n"
argument_list|,
name|newstate
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|newstate
condition|)
block|{
case|case
name|XenbusStateInitialising
case|:
case|case
name|XenbusStateInitialised
case|:
case|case
name|XenbusStateUnknown
case|:
case|case
name|XenbusStateReconfigured
case|:
case|case
name|XenbusStateReconfiguring
case|:
break|break;
case|case
name|XenbusStateInitWait
case|:
if|if
condition|(
name|xenbus_get_state
argument_list|(
name|dev
argument_list|)
operator|!=
name|XenbusStateInitialising
condition|)
break|break;
if|if
condition|(
name|xn_connect
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
break|break;
comment|/* Switch to connected state before kicking the rings. */
name|xenbus_set_state
argument_list|(
name|sc
operator|->
name|xbdev
argument_list|,
name|XenbusStateConnected
argument_list|)
expr_stmt|;
name|xn_kick_rings
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|XenbusStateClosing
case|:
name|xenbus_set_state
argument_list|(
name|dev
argument_list|,
name|XenbusStateClosed
argument_list|)
expr_stmt|;
break|break;
case|case
name|XenbusStateClosed
case|:
if|if
condition|(
name|sc
operator|->
name|xn_reset
condition|)
block|{
name|netif_disconnect_backend
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|xenbus_set_state
argument_list|(
name|dev
argument_list|,
name|XenbusStateInitialising
argument_list|)
expr_stmt|;
name|sc
operator|->
name|xn_reset
operator|=
name|false
expr_stmt|;
block|}
break|break;
case|case
name|XenbusStateConnected
case|:
ifdef|#
directive|ifdef
name|INET
name|netfront_send_fake_arp
argument_list|(
name|dev
argument_list|,
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
block|}
end_function

begin_comment
comment|/**  * \brief Verify that there is sufficient space in the Tx ring  *        buffer for a maximally sized request to be enqueued.  *  * A transmit request requires a transmit descriptor for each packet  * fragment, plus up to 2 entries for "options" (e.g. TSO).  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|xn_tx_slot_available
parameter_list|(
name|struct
name|netfront_txq
modifier|*
name|txq
parameter_list|)
block|{
return|return
operator|(
name|RING_FREE_REQUESTS
argument_list|(
operator|&
name|txq
operator|->
name|ring
argument_list|)
operator|>
operator|(
name|MAX_TX_REQ_FRAGS
operator|+
literal|2
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xn_release_tx_bufs
parameter_list|(
name|struct
name|netfront_txq
modifier|*
name|txq
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|NET_TX_RING_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|m
operator|=
name|txq
operator|->
name|mbufs
index|[
name|i
index|]
expr_stmt|;
comment|/* 		 * We assume that no kernel addresses are 		 * less than NET_TX_RING_SIZE.  Any entry 		 * in the table that is below this number 		 * must be an index from free-list tracking. 		 */
if|if
condition|(
operator|(
operator|(
name|uintptr_t
operator|)
name|m
operator|)
operator|<=
name|NET_TX_RING_SIZE
condition|)
continue|continue;
name|gnttab_end_foreign_access_ref
argument_list|(
name|txq
operator|->
name|grant_ref
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|gnttab_release_grant_reference
argument_list|(
operator|&
name|txq
operator|->
name|gref_head
argument_list|,
name|txq
operator|->
name|grant_ref
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|txq
operator|->
name|grant_ref
index|[
name|i
index|]
operator|=
name|GRANT_REF_INVALID
expr_stmt|;
name|add_id_to_freelist
argument_list|(
name|txq
operator|->
name|mbufs
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|txq
operator|->
name|mbufs_cnt
operator|--
expr_stmt|;
if|if
condition|(
name|txq
operator|->
name|mbufs_cnt
operator|<
literal|0
condition|)
block|{
name|panic
argument_list|(
literal|"%s: tx_chain_cnt must be>= 0"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|xn_alloc_one_rx_buffer
parameter_list|(
name|struct
name|netfront_rxq
modifier|*
name|rxq
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|m
operator|=
name|m_getjcl
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|,
name|MJUMPAGESIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|m
operator|->
name|m_len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|MJUMPAGESIZE
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xn_alloc_rx_buffers
parameter_list|(
name|struct
name|netfront_rxq
modifier|*
name|rxq
parameter_list|)
block|{
name|RING_IDX
name|req_prod
decl_stmt|;
name|int
name|notify
decl_stmt|;
name|XN_RX_LOCK_ASSERT
argument_list|(
name|rxq
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|rxq
operator|->
name|info
operator|->
name|carrier
operator|==
literal|0
argument_list|)
condition|)
return|return;
for|for
control|(
name|req_prod
operator|=
name|rxq
operator|->
name|ring
operator|.
name|req_prod_pvt
init|;
name|req_prod
operator|-
name|rxq
operator|->
name|ring
operator|.
name|rsp_cons
operator|<
name|NET_RX_RING_SIZE
condition|;
name|req_prod
operator|++
control|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|unsigned
name|short
name|id
decl_stmt|;
name|grant_ref_t
name|ref
decl_stmt|;
name|struct
name|netif_rx_request
modifier|*
name|req
decl_stmt|;
name|unsigned
name|long
name|pfn
decl_stmt|;
name|m
operator|=
name|xn_alloc_one_rx_buffer
argument_list|(
name|rxq
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
break|break;
name|id
operator|=
name|xn_rxidx
argument_list|(
name|req_prod
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|rxq
operator|->
name|mbufs
index|[
name|id
index|]
operator|==
name|NULL
argument_list|,
operator|(
literal|"non-NULL xn_rx_chain"
operator|)
argument_list|)
expr_stmt|;
name|rxq
operator|->
name|mbufs
index|[
name|id
index|]
operator|=
name|m
expr_stmt|;
name|ref
operator|=
name|gnttab_claim_grant_reference
argument_list|(
operator|&
name|rxq
operator|->
name|gref_head
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ref
operator|!=
name|GNTTAB_LIST_END
argument_list|,
operator|(
literal|"reserved grant references exhuasted"
operator|)
argument_list|)
expr_stmt|;
name|rxq
operator|->
name|grant_ref
index|[
name|id
index|]
operator|=
name|ref
expr_stmt|;
name|pfn
operator|=
name|atop
argument_list|(
name|vtophys
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|vm_offset_t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|=
name|RING_GET_REQUEST
argument_list|(
operator|&
name|rxq
operator|->
name|ring
argument_list|,
name|req_prod
argument_list|)
expr_stmt|;
name|gnttab_grant_foreign_access_ref
argument_list|(
name|ref
argument_list|,
name|xenbus_get_otherend_id
argument_list|(
name|rxq
operator|->
name|info
operator|->
name|xbdev
argument_list|)
argument_list|,
name|pfn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|req
operator|->
name|id
operator|=
name|id
expr_stmt|;
name|req
operator|->
name|gref
operator|=
name|ref
expr_stmt|;
block|}
name|rxq
operator|->
name|ring
operator|.
name|req_prod_pvt
operator|=
name|req_prod
expr_stmt|;
comment|/* Not enough requests? Try again later. */
if|if
condition|(
name|req_prod
operator|-
name|rxq
operator|->
name|ring
operator|.
name|rsp_cons
operator|<
name|NET_RX_SLOTS_MIN
condition|)
block|{
name|callout_reset_curcpu
argument_list|(
operator|&
name|rxq
operator|->
name|rx_refill
argument_list|,
name|hz
operator|/
literal|10
argument_list|,
name|xn_alloc_rx_buffers_callout
argument_list|,
name|rxq
argument_list|)
expr_stmt|;
return|return;
block|}
name|wmb
argument_list|()
expr_stmt|;
comment|/* barrier so backend seens requests */
name|RING_PUSH_REQUESTS_AND_CHECK_NOTIFY
argument_list|(
operator|&
name|rxq
operator|->
name|ring
argument_list|,
name|notify
argument_list|)
expr_stmt|;
if|if
condition|(
name|notify
condition|)
name|xen_intr_signal
argument_list|(
name|rxq
operator|->
name|xen_intr_handle
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xn_alloc_rx_buffers_callout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|netfront_rxq
modifier|*
name|rxq
decl_stmt|;
name|rxq
operator|=
operator|(
expr|struct
name|netfront_rxq
operator|*
operator|)
name|arg
expr_stmt|;
name|XN_RX_LOCK
argument_list|(
name|rxq
argument_list|)
expr_stmt|;
name|xn_alloc_rx_buffers
argument_list|(
name|rxq
argument_list|)
expr_stmt|;
name|XN_RX_UNLOCK
argument_list|(
name|rxq
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xn_release_rx_bufs
parameter_list|(
name|struct
name|netfront_rxq
modifier|*
name|rxq
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|ref
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NET_RX_RING_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|m
operator|=
name|rxq
operator|->
name|mbufs
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
continue|continue;
name|ref
operator|=
name|rxq
operator|->
name|grant_ref
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|ref
operator|==
name|GRANT_REF_INVALID
condition|)
continue|continue;
name|gnttab_end_foreign_access_ref
argument_list|(
name|ref
argument_list|)
expr_stmt|;
name|gnttab_release_grant_reference
argument_list|(
operator|&
name|rxq
operator|->
name|gref_head
argument_list|,
name|ref
argument_list|)
expr_stmt|;
name|rxq
operator|->
name|mbufs
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|rxq
operator|->
name|grant_ref
index|[
name|i
index|]
operator|=
name|GRANT_REF_INVALID
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|xn_rxeof
parameter_list|(
name|struct
name|netfront_rxq
modifier|*
name|rxq
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|netfront_info
modifier|*
name|np
init|=
name|rxq
operator|->
name|info
decl_stmt|;
if|#
directive|if
operator|(
name|defined
argument_list|(
name|INET
argument_list|)
operator|||
name|defined
argument_list|(
name|INET6
argument_list|)
operator|)
name|struct
name|lro_ctrl
modifier|*
name|lro
init|=
operator|&
name|rxq
operator|->
name|lro
decl_stmt|;
endif|#
directive|endif
name|struct
name|netfront_rx_info
name|rinfo
decl_stmt|;
name|struct
name|netif_rx_response
modifier|*
name|rx
init|=
operator|&
name|rinfo
operator|.
name|rx
decl_stmt|;
name|struct
name|netif_extra_info
modifier|*
name|extras
init|=
name|rinfo
operator|.
name|extras
decl_stmt|;
name|RING_IDX
name|i
decl_stmt|,
name|rp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|mbufq
name|mbufq_rxq
decl_stmt|,
name|mbufq_errq
decl_stmt|;
name|int
name|err
decl_stmt|,
name|work_to_do
decl_stmt|;
name|XN_RX_LOCK_ASSERT
argument_list|(
name|rxq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|netfront_carrier_ok
argument_list|(
name|np
argument_list|)
condition|)
return|return;
comment|/* XXX: there should be some sane limit. */
name|mbufq_init
argument_list|(
operator|&
name|mbufq_errq
argument_list|,
name|INT_MAX
argument_list|)
expr_stmt|;
name|mbufq_init
argument_list|(
operator|&
name|mbufq_rxq
argument_list|,
name|INT_MAX
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|np
operator|->
name|xn_ifp
expr_stmt|;
do|do
block|{
name|rp
operator|=
name|rxq
operator|->
name|ring
operator|.
name|sring
operator|->
name|rsp_prod
expr_stmt|;
name|rmb
argument_list|()
expr_stmt|;
comment|/* Ensure we see queued responses up to 'rp'. */
name|i
operator|=
name|rxq
operator|->
name|ring
operator|.
name|rsp_cons
expr_stmt|;
while|while
condition|(
operator|(
name|i
operator|!=
name|rp
operator|)
condition|)
block|{
name|memcpy
argument_list|(
name|rx
argument_list|,
name|RING_GET_RESPONSE
argument_list|(
operator|&
name|rxq
operator|->
name|ring
argument_list|,
name|i
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rx
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|extras
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|rinfo
operator|.
name|extras
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|=
name|NULL
expr_stmt|;
name|err
operator|=
name|xn_get_responses
argument_list|(
name|rxq
argument_list|,
operator|&
name|rinfo
argument_list|,
name|rp
argument_list|,
operator|&
name|i
argument_list|,
operator|&
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|err
argument_list|)
condition|)
block|{
if|if
condition|(
name|m
condition|)
operator|(
name|void
operator|)
name|mbufq_enqueue
argument_list|(
operator|&
name|mbufq_errq
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_IQDROPS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
if|if
condition|(
name|rx
operator|->
name|flags
operator|&
name|NETRXF_data_validated
condition|)
block|{
comment|/* 				 * According to mbuf(9) the correct way to tell 				 * the stack that the checksum of an inbound 				 * packet is correct, without it actually being 				 * present (because the underlying interface 				 * doesn't provide it), is to set the 				 * CSUM_DATA_VALID and CSUM_PSEUDO_HDR flags, 				 * and the csum_data field to 0xffff. 				 */
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator||=
operator|(
name|CSUM_DATA_VALID
operator||
name|CSUM_PSEUDO_HDR
operator|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|=
literal|0xffff
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|rx
operator|->
name|flags
operator|&
name|NETRXF_extra_info
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|extras
index|[
name|XEN_NETIF_EXTRA_TYPE_GSO
operator|-
literal|1
index|]
operator|.
name|type
operator|==
name|XEN_NETIF_EXTRA_TYPE_GSO
operator|)
condition|)
block|{
name|m
operator|->
name|m_pkthdr
operator|.
name|tso_segsz
operator|=
name|extras
index|[
name|XEN_NETIF_EXTRA_TYPE_GSO
operator|-
literal|1
index|]
operator|.
name|u
operator|.
name|gso
operator|.
name|size
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator||=
name|CSUM_TSO
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|mbufq_enqueue
argument_list|(
operator|&
name|mbufq_rxq
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
name|rxq
operator|->
name|ring
operator|.
name|rsp_cons
operator|=
name|i
expr_stmt|;
name|xn_alloc_rx_buffers
argument_list|(
name|rxq
argument_list|)
expr_stmt|;
name|RING_FINAL_CHECK_FOR_RESPONSES
argument_list|(
operator|&
name|rxq
operator|->
name|ring
argument_list|,
name|work_to_do
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|work_to_do
condition|)
do|;
name|XN_RX_UNLOCK
argument_list|(
name|rxq
argument_list|)
expr_stmt|;
name|mbufq_drain
argument_list|(
operator|&
name|mbufq_errq
argument_list|)
expr_stmt|;
comment|/* 	 * Process all the mbufs after the remapping is complete. 	 * Break the mbuf chain first though. 	 */
while|while
condition|(
operator|(
name|m
operator|=
name|mbufq_dequeue
argument_list|(
operator|&
name|mbufq_rxq
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_IPACKETS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|defined
argument_list|(
name|INET
argument_list|)
operator|||
name|defined
argument_list|(
name|INET6
argument_list|)
operator|)
comment|/* Use LRO if possible */
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_LRO
operator|)
operator|==
literal|0
operator|||
name|lro
operator|->
name|lro_cnt
operator|==
literal|0
operator|||
name|tcp_lro_rx
argument_list|(
name|lro
argument_list|,
name|m
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|/* 			 * If LRO fails, pass up to the stack 			 * directly. 			 */
call|(
modifier|*
name|ifp
operator|->
name|if_input
call|)
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
call|(
modifier|*
name|ifp
operator|->
name|if_input
call|)
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|#
directive|if
operator|(
name|defined
argument_list|(
name|INET
argument_list|)
operator|||
name|defined
argument_list|(
name|INET6
argument_list|)
operator|)
comment|/* 	 * Flush any outstanding LRO work 	 */
name|tcp_lro_flush_all
argument_list|(
name|lro
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|XN_RX_LOCK
argument_list|(
name|rxq
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xn_txeof
parameter_list|(
name|struct
name|netfront_txq
modifier|*
name|txq
parameter_list|)
block|{
name|RING_IDX
name|i
decl_stmt|,
name|prod
decl_stmt|;
name|unsigned
name|short
name|id
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|netif_tx_response_t
modifier|*
name|txr
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|netfront_info
modifier|*
name|np
init|=
name|txq
operator|->
name|info
decl_stmt|;
name|XN_TX_LOCK_ASSERT
argument_list|(
name|txq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|netfront_carrier_ok
argument_list|(
name|np
argument_list|)
condition|)
return|return;
name|ifp
operator|=
name|np
operator|->
name|xn_ifp
expr_stmt|;
do|do
block|{
name|prod
operator|=
name|txq
operator|->
name|ring
operator|.
name|sring
operator|->
name|rsp_prod
expr_stmt|;
name|rmb
argument_list|()
expr_stmt|;
comment|/* Ensure we see responses up to 'rp'. */
for|for
control|(
name|i
operator|=
name|txq
operator|->
name|ring
operator|.
name|rsp_cons
init|;
name|i
operator|!=
name|prod
condition|;
name|i
operator|++
control|)
block|{
name|txr
operator|=
name|RING_GET_RESPONSE
argument_list|(
operator|&
name|txq
operator|->
name|ring
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|txr
operator|->
name|status
operator|==
name|NETIF_RSP_NULL
condition|)
continue|continue;
if|if
condition|(
name|txr
operator|->
name|status
operator|!=
name|NETIF_RSP_OKAY
condition|)
block|{
name|printf
argument_list|(
literal|"%s: WARNING: response is %d!\n"
argument_list|,
name|__func__
argument_list|,
name|txr
operator|->
name|status
argument_list|)
expr_stmt|;
block|}
name|id
operator|=
name|txr
operator|->
name|id
expr_stmt|;
name|m
operator|=
name|txq
operator|->
name|mbufs
index|[
name|id
index|]
expr_stmt|;
name|KASSERT
argument_list|(
name|m
operator|!=
name|NULL
argument_list|,
operator|(
literal|"mbuf not found in chain"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|uintptr_t
operator|)
name|m
operator|>
name|NET_TX_RING_SIZE
argument_list|,
operator|(
literal|"mbuf already on the free list, but we're "
literal|"trying to free it again!"
operator|)
argument_list|)
expr_stmt|;
name|M_ASSERTVALID
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|gnttab_query_foreign_access
argument_list|(
name|txq
operator|->
name|grant_ref
index|[
name|id
index|]
argument_list|)
operator|!=
literal|0
argument_list|)
condition|)
block|{
name|panic
argument_list|(
literal|"%s: grant id %u still in use by the "
literal|"backend"
argument_list|,
name|__func__
argument_list|,
name|id
argument_list|)
expr_stmt|;
block|}
name|gnttab_end_foreign_access_ref
argument_list|(
name|txq
operator|->
name|grant_ref
index|[
name|id
index|]
argument_list|)
expr_stmt|;
name|gnttab_release_grant_reference
argument_list|(
operator|&
name|txq
operator|->
name|gref_head
argument_list|,
name|txq
operator|->
name|grant_ref
index|[
name|id
index|]
argument_list|)
expr_stmt|;
name|txq
operator|->
name|grant_ref
index|[
name|id
index|]
operator|=
name|GRANT_REF_INVALID
expr_stmt|;
name|txq
operator|->
name|mbufs
index|[
name|id
index|]
operator|=
name|NULL
expr_stmt|;
name|add_id_to_freelist
argument_list|(
name|txq
operator|->
name|mbufs
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|txq
operator|->
name|mbufs_cnt
operator|--
expr_stmt|;
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* Only mark the txq active if we've freed up at least one slot to try */
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
block|}
name|txq
operator|->
name|ring
operator|.
name|rsp_cons
operator|=
name|prod
expr_stmt|;
comment|/* 		 * Set a new event, then check for race with update of 		 * tx_cons. Note that it is essential to schedule a 		 * callback, no matter how few buffers are pending. Even if 		 * there is space in the transmit ring, higher layers may 		 * be blocked because too much data is outstanding: in such 		 * cases notification from Xen is likely to be the only kick 		 * that we'll get. 		 */
name|txq
operator|->
name|ring
operator|.
name|sring
operator|->
name|rsp_event
operator|=
name|prod
operator|+
operator|(
operator|(
name|txq
operator|->
name|ring
operator|.
name|sring
operator|->
name|req_prod
operator|-
name|prod
operator|)
operator|>>
literal|1
operator|)
operator|+
literal|1
expr_stmt|;
name|mb
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|prod
operator|!=
name|txq
operator|->
name|ring
operator|.
name|sring
operator|->
name|rsp_prod
condition|)
do|;
if|if
condition|(
name|txq
operator|->
name|full
operator|&&
operator|(
operator|(
name|txq
operator|->
name|ring
operator|.
name|sring
operator|->
name|req_prod
operator|-
name|prod
operator|)
operator|<
name|NET_TX_RING_SIZE
operator|)
condition|)
block|{
name|txq
operator|->
name|full
operator|=
name|false
expr_stmt|;
name|xn_txq_start
argument_list|(
name|txq
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|xn_intr
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
block|{
name|struct
name|netfront_txq
modifier|*
name|txq
init|=
name|xsc
decl_stmt|;
name|struct
name|netfront_info
modifier|*
name|np
init|=
name|txq
operator|->
name|info
decl_stmt|;
name|struct
name|netfront_rxq
modifier|*
name|rxq
init|=
operator|&
name|np
operator|->
name|rxq
index|[
name|txq
operator|->
name|id
index|]
decl_stmt|;
comment|/* kick both tx and rx */
name|xn_rxq_intr
argument_list|(
name|rxq
argument_list|)
expr_stmt|;
name|xn_txq_intr
argument_list|(
name|txq
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xn_move_rx_slot
parameter_list|(
name|struct
name|netfront_rxq
modifier|*
name|rxq
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|grant_ref_t
name|ref
parameter_list|)
block|{
name|int
name|new
init|=
name|xn_rxidx
argument_list|(
name|rxq
operator|->
name|ring
operator|.
name|req_prod_pvt
argument_list|)
decl_stmt|;
name|KASSERT
argument_list|(
name|rxq
operator|->
name|mbufs
index|[
name|new
index|]
operator|==
name|NULL
argument_list|,
operator|(
literal|"mbufs != NULL"
operator|)
argument_list|)
expr_stmt|;
name|rxq
operator|->
name|mbufs
index|[
name|new
index|]
operator|=
name|m
expr_stmt|;
name|rxq
operator|->
name|grant_ref
index|[
name|new
index|]
operator|=
name|ref
expr_stmt|;
name|RING_GET_REQUEST
argument_list|(
operator|&
name|rxq
operator|->
name|ring
argument_list|,
name|rxq
operator|->
name|ring
operator|.
name|req_prod_pvt
argument_list|)
operator|->
name|id
operator|=
name|new
expr_stmt|;
name|RING_GET_REQUEST
argument_list|(
operator|&
name|rxq
operator|->
name|ring
argument_list|,
name|rxq
operator|->
name|ring
operator|.
name|req_prod_pvt
argument_list|)
operator|->
name|gref
operator|=
name|ref
expr_stmt|;
name|rxq
operator|->
name|ring
operator|.
name|req_prod_pvt
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|xn_get_extras
parameter_list|(
name|struct
name|netfront_rxq
modifier|*
name|rxq
parameter_list|,
name|struct
name|netif_extra_info
modifier|*
name|extras
parameter_list|,
name|RING_IDX
name|rp
parameter_list|,
name|RING_IDX
modifier|*
name|cons
parameter_list|)
block|{
name|struct
name|netif_extra_info
modifier|*
name|extra
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
do|do
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|grant_ref_t
name|ref
decl_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
operator|*
name|cons
operator|+
literal|1
operator|==
name|rp
argument_list|)
condition|)
block|{
name|err
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|extra
operator|=
operator|(
expr|struct
name|netif_extra_info
operator|*
operator|)
name|RING_GET_RESPONSE
argument_list|(
operator|&
name|rxq
operator|->
name|ring
argument_list|,
operator|++
operator|(
operator|*
name|cons
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
operator|!
name|extra
operator|->
name|type
operator|||
name|extra
operator|->
name|type
operator|>=
name|XEN_NETIF_EXTRA_TYPE_MAX
argument_list|)
condition|)
block|{
name|err
operator|=
name|EINVAL
expr_stmt|;
block|}
else|else
block|{
name|memcpy
argument_list|(
operator|&
name|extras
index|[
name|extra
operator|->
name|type
operator|-
literal|1
index|]
argument_list|,
name|extra
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|extra
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|m
operator|=
name|xn_get_rx_mbuf
argument_list|(
name|rxq
argument_list|,
operator|*
name|cons
argument_list|)
expr_stmt|;
name|ref
operator|=
name|xn_get_rx_ref
argument_list|(
name|rxq
argument_list|,
operator|*
name|cons
argument_list|)
expr_stmt|;
name|xn_move_rx_slot
argument_list|(
name|rxq
argument_list|,
name|m
argument_list|,
name|ref
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|extra
operator|->
name|flags
operator|&
name|XEN_NETIF_EXTRA_FLAG_MORE
condition|)
do|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xn_get_responses
parameter_list|(
name|struct
name|netfront_rxq
modifier|*
name|rxq
parameter_list|,
name|struct
name|netfront_rx_info
modifier|*
name|rinfo
parameter_list|,
name|RING_IDX
name|rp
parameter_list|,
name|RING_IDX
modifier|*
name|cons
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|list
parameter_list|)
block|{
name|struct
name|netif_rx_response
modifier|*
name|rx
init|=
operator|&
name|rinfo
operator|->
name|rx
decl_stmt|;
name|struct
name|netif_extra_info
modifier|*
name|extras
init|=
name|rinfo
operator|->
name|extras
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|m0
decl_stmt|,
modifier|*
name|m_prev
decl_stmt|;
name|grant_ref_t
name|ref
init|=
name|xn_get_rx_ref
argument_list|(
name|rxq
argument_list|,
operator|*
name|cons
argument_list|)
decl_stmt|;
name|RING_IDX
name|ref_cons
init|=
operator|*
name|cons
decl_stmt|;
name|int
name|frags
init|=
literal|1
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|u_long
name|ret
decl_stmt|;
name|m0
operator|=
name|m
operator|=
name|m_prev
operator|=
name|xn_get_rx_mbuf
argument_list|(
name|rxq
argument_list|,
operator|*
name|cons
argument_list|)
expr_stmt|;
if|if
condition|(
name|rx
operator|->
name|flags
operator|&
name|NETRXF_extra_info
condition|)
block|{
name|err
operator|=
name|xn_get_extras
argument_list|(
name|rxq
argument_list|,
name|extras
argument_list|,
name|rp
argument_list|,
name|cons
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|m0
operator|!=
name|NULL
condition|)
block|{
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
literal|0
expr_stmt|;
name|m0
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
if|#
directive|if
literal|0
block|DPRINTK("rx->status=%hd rx->offset=%hu frags=%u\n", 			rx->status, rx->offset, frags);
endif|#
directive|endif
if|if
condition|(
name|__predict_false
argument_list|(
name|rx
operator|->
name|status
operator|<
literal|0
operator|||
name|rx
operator|->
name|offset
operator|+
name|rx
operator|->
name|status
operator|>
name|PAGE_SIZE
argument_list|)
condition|)
block|{
name|xn_move_rx_slot
argument_list|(
name|rxq
argument_list|,
name|m
argument_list|,
name|ref
argument_list|)
expr_stmt|;
if|if
condition|(
name|m0
operator|==
name|m
condition|)
name|m0
operator|=
name|NULL
expr_stmt|;
name|m
operator|=
name|NULL
expr_stmt|;
name|err
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|next_skip_queue
goto|;
block|}
comment|/* 		 * This definitely indicates a bug, either in this driver or in 		 * the backend driver. In future this should flag the bad 		 * situation to the system controller to reboot the backed. 		 */
if|if
condition|(
name|ref
operator|==
name|GRANT_REF_INVALID
condition|)
block|{
name|printf
argument_list|(
literal|"%s: Bad rx response id %d.\n"
argument_list|,
name|__func__
argument_list|,
name|rx
operator|->
name|id
argument_list|)
expr_stmt|;
name|err
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|next
goto|;
block|}
name|ret
operator|=
name|gnttab_end_foreign_access_ref
argument_list|(
name|ref
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ret
argument_list|,
operator|(
literal|"Unable to end access to grant references"
operator|)
argument_list|)
expr_stmt|;
name|gnttab_release_grant_reference
argument_list|(
operator|&
name|rxq
operator|->
name|gref_head
argument_list|,
name|ref
argument_list|)
expr_stmt|;
name|next
label|:
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
break|break;
name|m
operator|->
name|m_len
operator|=
name|rx
operator|->
name|status
expr_stmt|;
name|m
operator|->
name|m_data
operator|+=
name|rx
operator|->
name|offset
expr_stmt|;
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
name|rx
operator|->
name|status
expr_stmt|;
name|next_skip_queue
label|:
if|if
condition|(
operator|!
operator|(
name|rx
operator|->
name|flags
operator|&
name|NETRXF_more_data
operator|)
condition|)
break|break;
if|if
condition|(
operator|*
name|cons
operator|+
name|frags
operator|==
name|rp
condition|)
block|{
if|if
condition|(
name|net_ratelimit
argument_list|()
condition|)
name|WPRINTK
argument_list|(
literal|"Need more frags\n"
argument_list|)
expr_stmt|;
name|err
operator|=
name|ENOENT
expr_stmt|;
name|printf
argument_list|(
literal|"%s: cons %u frags %u rp %u, not enough frags\n"
argument_list|,
name|__func__
argument_list|,
operator|*
name|cons
argument_list|,
name|frags
argument_list|,
name|rp
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 		 * Note that m can be NULL, if rx->status< 0 or if 		 * rx->offset + rx->status> PAGE_SIZE above. 		 */
name|m_prev
operator|=
name|m
expr_stmt|;
name|rx
operator|=
name|RING_GET_RESPONSE
argument_list|(
operator|&
name|rxq
operator|->
name|ring
argument_list|,
operator|*
name|cons
operator|+
name|frags
argument_list|)
expr_stmt|;
name|m
operator|=
name|xn_get_rx_mbuf
argument_list|(
name|rxq
argument_list|,
operator|*
name|cons
operator|+
name|frags
argument_list|)
expr_stmt|;
comment|/* 		 * m_prev == NULL can happen if rx->status< 0 or if 		 * rx->offset + * rx->status> PAGE_SIZE above. 		 */
if|if
condition|(
name|m_prev
operator|!=
name|NULL
condition|)
name|m_prev
operator|->
name|m_next
operator|=
name|m
expr_stmt|;
comment|/* 		 * m0 can be NULL if rx->status< 0 or if * rx->offset + 		 * rx->status> PAGE_SIZE above. 		 */
if|if
condition|(
name|m0
operator|==
name|NULL
condition|)
name|m0
operator|=
name|m
expr_stmt|;
name|m
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
name|ref
operator|=
name|xn_get_rx_ref
argument_list|(
name|rxq
argument_list|,
operator|*
name|cons
operator|+
name|frags
argument_list|)
expr_stmt|;
name|ref_cons
operator|=
operator|*
name|cons
operator|+
name|frags
expr_stmt|;
name|frags
operator|++
expr_stmt|;
block|}
operator|*
name|list
operator|=
name|m0
expr_stmt|;
operator|*
name|cons
operator|+=
name|frags
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * \brief Count the number of fragments in an mbuf chain.  *  * Surprisingly, there isn't an M* macro for this.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|xn_count_frags
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|int
name|nfrags
decl_stmt|;
for|for
control|(
name|nfrags
operator|=
literal|0
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
name|nfrags
operator|++
expr_stmt|;
return|return
operator|(
name|nfrags
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Given an mbuf chain, make sure we have enough room and then push  * it onto the transmit ring.  */
end_comment

begin_function
specifier|static
name|int
name|xn_assemble_tx_request
parameter_list|(
name|struct
name|netfront_txq
modifier|*
name|txq
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m_head
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|netfront_info
modifier|*
name|np
init|=
name|txq
operator|->
name|info
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|np
operator|->
name|xn_ifp
decl_stmt|;
name|u_int
name|nfrags
decl_stmt|;
name|int
name|otherend_id
decl_stmt|;
comment|/** 	 * Defragment the mbuf if necessary. 	 */
name|nfrags
operator|=
name|xn_count_frags
argument_list|(
name|m_head
argument_list|)
expr_stmt|;
comment|/* 	 * Check to see whether this request is longer than netback 	 * can handle, and try to defrag it. 	 */
comment|/** 	 * It is a bit lame, but the netback driver in Linux can't 	 * deal with nfrags> MAX_TX_REQ_FRAGS, which is a quirk of 	 * the Linux network stack. 	 */
if|if
condition|(
name|nfrags
operator|>
name|np
operator|->
name|maxfrags
condition|)
block|{
name|m
operator|=
name|m_defrag
argument_list|(
name|m_head
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
block|{
comment|/* 			 * Defrag failed, so free the mbuf and 			 * therefore drop the packet. 			 */
name|m_freem
argument_list|(
name|m_head
argument_list|)
expr_stmt|;
return|return
operator|(
name|EMSGSIZE
operator|)
return|;
block|}
name|m_head
operator|=
name|m
expr_stmt|;
block|}
comment|/* Determine how many fragments now exist */
name|nfrags
operator|=
name|xn_count_frags
argument_list|(
name|m_head
argument_list|)
expr_stmt|;
comment|/* 	 * Check to see whether the defragmented packet has too many 	 * segments for the Linux netback driver. 	 */
comment|/** 	 * The FreeBSD TCP stack, with TSO enabled, can produce a chain 	 * of mbufs longer than Linux can handle.  Make sure we don't 	 * pass a too-long chain over to the other side by dropping the 	 * packet.  It doesn't look like there is currently a way to 	 * tell the TCP stack to generate a shorter chain of packets. 	 */
if|if
condition|(
name|nfrags
operator|>
name|MAX_TX_REQ_FRAGS
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"%s: nfrags %d> MAX_TX_REQ_FRAGS %d, netback "
literal|"won't be able to handle it, dropping\n"
argument_list|,
name|__func__
argument_list|,
name|nfrags
argument_list|,
name|MAX_TX_REQ_FRAGS
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|m_freem
argument_list|(
name|m_head
argument_list|)
expr_stmt|;
return|return
operator|(
name|EMSGSIZE
operator|)
return|;
block|}
comment|/* 	 * This check should be redundant.  We've already verified that we 	 * have enough slots in the ring to handle a packet of maximum 	 * size, and that our packet is less than the maximum size.  Keep 	 * it in here as an assert for now just to make certain that 	 * chain_cnt is accurate. 	 */
name|KASSERT
argument_list|(
operator|(
name|txq
operator|->
name|mbufs_cnt
operator|+
name|nfrags
operator|)
operator|<=
name|NET_TX_RING_SIZE
argument_list|,
operator|(
literal|"%s: chain_cnt (%d) + nfrags (%d)> NET_TX_RING_SIZE "
literal|"(%d)!"
operator|,
name|__func__
operator|,
operator|(
name|int
operator|)
name|txq
operator|->
name|mbufs_cnt
operator|,
operator|(
name|int
operator|)
name|nfrags
operator|,
operator|(
name|int
operator|)
name|NET_TX_RING_SIZE
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Start packing the mbufs in this chain into 	 * the fragment pointers. Stop when we run out 	 * of fragments or hit the end of the mbuf chain. 	 */
name|m
operator|=
name|m_head
expr_stmt|;
name|otherend_id
operator|=
name|xenbus_get_otherend_id
argument_list|(
name|np
operator|->
name|xbdev
argument_list|)
expr_stmt|;
for|for
control|(
name|m
operator|=
name|m_head
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
block|{
name|netif_tx_request_t
modifier|*
name|tx
decl_stmt|;
name|uintptr_t
name|id
decl_stmt|;
name|grant_ref_t
name|ref
decl_stmt|;
name|u_long
name|mfn
decl_stmt|;
comment|/* XXX Wrong type? */
name|tx
operator|=
name|RING_GET_REQUEST
argument_list|(
operator|&
name|txq
operator|->
name|ring
argument_list|,
name|txq
operator|->
name|ring
operator|.
name|req_prod_pvt
argument_list|)
expr_stmt|;
name|id
operator|=
name|get_id_from_freelist
argument_list|(
name|txq
operator|->
name|mbufs
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"%s: was allocated the freelist head!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|txq
operator|->
name|mbufs_cnt
operator|++
expr_stmt|;
if|if
condition|(
name|txq
operator|->
name|mbufs_cnt
operator|>
name|NET_TX_RING_SIZE
condition|)
name|panic
argument_list|(
literal|"%s: tx_chain_cnt must be<= NET_TX_RING_SIZE\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|txq
operator|->
name|mbufs
index|[
name|id
index|]
operator|=
name|m
expr_stmt|;
name|tx
operator|->
name|id
operator|=
name|id
expr_stmt|;
name|ref
operator|=
name|gnttab_claim_grant_reference
argument_list|(
operator|&
name|txq
operator|->
name|gref_head
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|short
operator|)
name|ref
operator|>=
literal|0
argument_list|,
operator|(
literal|"Negative ref"
operator|)
argument_list|)
expr_stmt|;
name|mfn
operator|=
name|virt_to_mfn
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|vm_offset_t
argument_list|)
argument_list|)
expr_stmt|;
name|gnttab_grant_foreign_access_ref
argument_list|(
name|ref
argument_list|,
name|otherend_id
argument_list|,
name|mfn
argument_list|,
name|GNTMAP_readonly
argument_list|)
expr_stmt|;
name|tx
operator|->
name|gref
operator|=
name|txq
operator|->
name|grant_ref
index|[
name|id
index|]
operator|=
name|ref
expr_stmt|;
name|tx
operator|->
name|offset
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|vm_offset_t
argument_list|)
operator|&
operator|(
name|PAGE_SIZE
operator|-
literal|1
operator|)
expr_stmt|;
name|tx
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|m_head
condition|)
block|{
comment|/* 			 * The first fragment has the entire packet 			 * size, subsequent fragments have just the 			 * fragment size. The backend works out the 			 * true size of the first fragment by 			 * subtracting the sizes of the other 			 * fragments. 			 */
name|tx
operator|->
name|size
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
comment|/* 			 * The first fragment contains the checksum flags 			 * and is optionally followed by extra data for 			 * TSO etc. 			 */
comment|/** 			 * CSUM_TSO requires checksum offloading. 			 * Some versions of FreeBSD fail to 			 * set CSUM_TCP in the CSUM_TSO case, 			 * so we have to test for CSUM_TSO 			 * explicitly. 			 */
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
operator|(
name|CSUM_DELAY_DATA
operator||
name|CSUM_TSO
operator|)
condition|)
block|{
name|tx
operator|->
name|flags
operator||=
operator|(
name|NETTXF_csum_blank
operator||
name|NETTXF_data_validated
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_TSO
condition|)
block|{
name|struct
name|netif_extra_info
modifier|*
name|gso
init|=
operator|(
expr|struct
name|netif_extra_info
operator|*
operator|)
name|RING_GET_REQUEST
argument_list|(
operator|&
name|txq
operator|->
name|ring
argument_list|,
operator|++
name|txq
operator|->
name|ring
operator|.
name|req_prod_pvt
argument_list|)
decl_stmt|;
name|tx
operator|->
name|flags
operator||=
name|NETTXF_extra_info
expr_stmt|;
name|gso
operator|->
name|u
operator|.
name|gso
operator|.
name|size
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|tso_segsz
expr_stmt|;
name|gso
operator|->
name|u
operator|.
name|gso
operator|.
name|type
operator|=
name|XEN_NETIF_GSO_TYPE_TCPV4
expr_stmt|;
name|gso
operator|->
name|u
operator|.
name|gso
operator|.
name|pad
operator|=
literal|0
expr_stmt|;
name|gso
operator|->
name|u
operator|.
name|gso
operator|.
name|features
operator|=
literal|0
expr_stmt|;
name|gso
operator|->
name|type
operator|=
name|XEN_NETIF_EXTRA_TYPE_GSO
expr_stmt|;
name|gso
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|tx
operator|->
name|size
operator|=
name|m
operator|->
name|m_len
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|->
name|m_next
condition|)
name|tx
operator|->
name|flags
operator||=
name|NETTXF_more_data
expr_stmt|;
name|txq
operator|->
name|ring
operator|.
name|req_prod_pvt
operator|++
expr_stmt|;
block|}
name|BPF_MTAP
argument_list|(
name|ifp
argument_list|,
name|m_head
argument_list|)
expr_stmt|;
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_OPACKETS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_OBYTES
argument_list|,
name|m_head
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_head
operator|->
name|m_flags
operator|&
name|M_MCAST
condition|)
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_OMCASTS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xn_txeof
argument_list|(
name|txq
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* equivalent of network_open() in Linux */
end_comment

begin_function
specifier|static
name|void
name|xn_ifinit_locked
parameter_list|(
name|struct
name|netfront_info
modifier|*
name|np
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|netfront_rxq
modifier|*
name|rxq
decl_stmt|;
name|XN_LOCK_ASSERT
argument_list|(
name|np
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|np
operator|->
name|xn_ifp
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|||
operator|!
name|netfront_carrier_ok
argument_list|(
name|np
argument_list|)
condition|)
return|return;
name|xn_stop
argument_list|(
name|np
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|np
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
name|rxq
operator|=
operator|&
name|np
operator|->
name|rxq
index|[
name|i
index|]
expr_stmt|;
name|XN_RX_LOCK
argument_list|(
name|rxq
argument_list|)
expr_stmt|;
name|xn_alloc_rx_buffers
argument_list|(
name|rxq
argument_list|)
expr_stmt|;
name|rxq
operator|->
name|ring
operator|.
name|sring
operator|->
name|rsp_event
operator|=
name|rxq
operator|->
name|ring
operator|.
name|rsp_cons
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|RING_HAS_UNCONSUMED_RESPONSES
argument_list|(
operator|&
name|rxq
operator|->
name|ring
argument_list|)
condition|)
name|xn_rxeof
argument_list|(
name|rxq
argument_list|)
expr_stmt|;
name|XN_RX_UNLOCK
argument_list|(
name|rxq
argument_list|)
expr_stmt|;
block|}
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_RUNNING
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
name|if_link_state_change
argument_list|(
name|ifp
argument_list|,
name|LINK_STATE_UP
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xn_ifinit
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
block|{
name|struct
name|netfront_info
modifier|*
name|sc
init|=
name|xsc
decl_stmt|;
name|XN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|xn_ifinit_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|XN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|xn_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|struct
name|netfront_info
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
name|device_t
name|dev
decl_stmt|;
ifdef|#
directive|ifdef
name|INET
name|struct
name|ifaddr
modifier|*
name|ifa
init|=
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
name|data
decl_stmt|;
endif|#
directive|endif
name|int
name|mask
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|,
name|reinit
decl_stmt|;
name|dev
operator|=
name|sc
operator|->
name|xbdev
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCSIFADDR
case|:
ifdef|#
directive|ifdef
name|INET
name|XN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_UP
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
name|xn_ifinit_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|arp_ifinit
argument_list|(
name|ifp
argument_list|,
name|ifa
argument_list|)
expr_stmt|;
name|XN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|XN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INET
block|}
endif|#
directive|endif
break|break;
case|case
name|SIOCSIFMTU
case|:
name|ifp
operator|->
name|if_mtu
operator|=
name|ifr
operator|->
name|ifr_mtu
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_RUNNING
expr_stmt|;
name|xn_ifinit
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFFLAGS
case|:
name|XN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
comment|/* 			 * If only the state of the PROMISC flag changed, 			 * then just use the 'set promisc mode' command 			 * instead of reinitializing the entire NIC. Doing 			 * a full re-init means reloading the firmware and 			 * waiting for it to start up, which may take a 			 * second or two. 			 */
name|xn_ifinit_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|xn_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
name|sc
operator|->
name|xn_if_flags
operator|=
name|ifp
operator|->
name|if_flags
expr_stmt|;
name|XN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFCAP
case|:
name|mask
operator|=
name|ifr
operator|->
name|ifr_reqcap
operator|^
name|ifp
operator|->
name|if_capenable
expr_stmt|;
name|reinit
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IFCAP_TXCSUM
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_TXCSUM
expr_stmt|;
name|ifp
operator|->
name|if_hwassist
operator|^=
name|XN_CSUM_FEATURES
expr_stmt|;
block|}
if|if
condition|(
name|mask
operator|&
name|IFCAP_TSO4
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_TSO4
expr_stmt|;
name|ifp
operator|->
name|if_hwassist
operator|^=
name|CSUM_TSO
expr_stmt|;
block|}
if|if
condition|(
name|mask
operator|&
operator|(
name|IFCAP_RXCSUM
operator||
name|IFCAP_LRO
operator|)
condition|)
block|{
comment|/* These Rx features require us to renegotiate. */
name|reinit
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IFCAP_RXCSUM
condition|)
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_RXCSUM
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IFCAP_LRO
condition|)
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_LRO
expr_stmt|;
block|}
if|if
condition|(
name|reinit
operator|==
literal|0
condition|)
break|break;
comment|/* 		 * We must reset the interface so the backend picks up the 		 * new features. 		 */
name|device_printf
argument_list|(
name|sc
operator|->
name|xbdev
argument_list|,
literal|"performing interface reset due to feature change\n"
argument_list|)
expr_stmt|;
name|XN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|netfront_carrier_off
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|xn_reset
operator|=
name|true
expr_stmt|;
comment|/* 		 * NB: the pending packet queue is not flushed, since 		 * the interface should still support the old options. 		 */
name|XN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 		 * Delete the xenstore nodes that export features. 		 * 		 * NB: There's a xenbus state called 		 * "XenbusStateReconfiguring", which is what we should set 		 * here. Sadly none of the backends know how to handle it, 		 * and simply disconnect from the frontend, so we will just 		 * switch back to XenbusStateInitialising in order to force 		 * a reconnection. 		 */
name|xs_rm
argument_list|(
name|XST_NIL
argument_list|,
name|xenbus_get_node
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|"feature-gso-tcpv4"
argument_list|)
expr_stmt|;
name|xs_rm
argument_list|(
name|XST_NIL
argument_list|,
name|xenbus_get_node
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|"feature-no-csum-offload"
argument_list|)
expr_stmt|;
name|xenbus_set_state
argument_list|(
name|dev
argument_list|,
name|XenbusStateClosing
argument_list|)
expr_stmt|;
comment|/* 		 * Wait for the frontend to reconnect before returning 		 * from the ioctl. 30s should be more than enough for any 		 * sane backend to reconnect. 		 */
name|error
operator|=
name|tsleep
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
literal|"xn_rst"
argument_list|,
literal|30
operator|*
name|hz
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
break|break;
case|case
name|SIOCSIFMEDIA
case|:
case|case
name|SIOCGIFMEDIA
case|:
name|error
operator|=
name|ifmedia_ioctl
argument_list|(
name|ifp
argument_list|,
name|ifr
argument_list|,
operator|&
name|sc
operator|->
name|sc_media
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xn_stop
parameter_list|(
name|struct
name|netfront_info
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|XN_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|xn_ifp
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
operator|(
name|IFF_DRV_RUNNING
operator||
name|IFF_DRV_OACTIVE
operator|)
expr_stmt|;
name|if_link_state_change
argument_list|(
name|ifp
argument_list|,
name|LINK_STATE_DOWN
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xn_rebuild_rx_bufs
parameter_list|(
name|struct
name|netfront_rxq
modifier|*
name|rxq
parameter_list|)
block|{
name|int
name|requeue_idx
decl_stmt|,
name|i
decl_stmt|;
name|grant_ref_t
name|ref
decl_stmt|;
name|netif_rx_request_t
modifier|*
name|req
decl_stmt|;
for|for
control|(
name|requeue_idx
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NET_RX_RING_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|u_long
name|pfn
decl_stmt|;
if|if
condition|(
name|rxq
operator|->
name|mbufs
index|[
name|i
index|]
operator|==
name|NULL
condition|)
continue|continue;
name|m
operator|=
name|rxq
operator|->
name|mbufs
index|[
name|requeue_idx
index|]
operator|=
name|xn_get_rx_mbuf
argument_list|(
name|rxq
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|ref
operator|=
name|rxq
operator|->
name|grant_ref
index|[
name|requeue_idx
index|]
operator|=
name|xn_get_rx_ref
argument_list|(
name|rxq
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|req
operator|=
name|RING_GET_REQUEST
argument_list|(
operator|&
name|rxq
operator|->
name|ring
argument_list|,
name|requeue_idx
argument_list|)
expr_stmt|;
name|pfn
operator|=
name|vtophys
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|vm_offset_t
argument_list|)
argument_list|)
operator|>>
name|PAGE_SHIFT
expr_stmt|;
name|gnttab_grant_foreign_access_ref
argument_list|(
name|ref
argument_list|,
name|xenbus_get_otherend_id
argument_list|(
name|rxq
operator|->
name|info
operator|->
name|xbdev
argument_list|)
argument_list|,
name|pfn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|req
operator|->
name|gref
operator|=
name|ref
expr_stmt|;
name|req
operator|->
name|id
operator|=
name|requeue_idx
expr_stmt|;
name|requeue_idx
operator|++
expr_stmt|;
block|}
name|rxq
operator|->
name|ring
operator|.
name|req_prod_pvt
operator|=
name|requeue_idx
expr_stmt|;
block|}
end_function

begin_comment
comment|/* START of Xenolinux helper functions adapted to FreeBSD */
end_comment

begin_function
specifier|static
name|int
name|xn_connect
parameter_list|(
name|struct
name|netfront_info
modifier|*
name|np
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|error
decl_stmt|;
name|u_int
name|feature_rx_copy
decl_stmt|;
name|struct
name|netfront_rxq
modifier|*
name|rxq
decl_stmt|;
name|struct
name|netfront_txq
modifier|*
name|txq
decl_stmt|;
name|error
operator|=
name|xs_scanf
argument_list|(
name|XST_NIL
argument_list|,
name|xenbus_get_otherend_path
argument_list|(
name|np
operator|->
name|xbdev
argument_list|)
argument_list|,
literal|"feature-rx-copy"
argument_list|,
name|NULL
argument_list|,
literal|"%u"
argument_list|,
operator|&
name|feature_rx_copy
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|feature_rx_copy
operator|=
literal|0
expr_stmt|;
comment|/* We only support rx copy. */
if|if
condition|(
operator|!
name|feature_rx_copy
condition|)
return|return
operator|(
name|EPROTONOSUPPORT
operator|)
return|;
comment|/* Recovery procedure: */
name|error
operator|=
name|talk_to_backend
argument_list|(
name|np
operator|->
name|xbdev
argument_list|,
name|np
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Step 1: Reinitialise variables. */
name|xn_query_features
argument_list|(
name|np
argument_list|)
expr_stmt|;
name|xn_configure_features
argument_list|(
name|np
argument_list|)
expr_stmt|;
comment|/* Step 2: Release TX buffer */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|np
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
name|txq
operator|=
operator|&
name|np
operator|->
name|txq
index|[
name|i
index|]
expr_stmt|;
name|xn_release_tx_bufs
argument_list|(
name|txq
argument_list|)
expr_stmt|;
block|}
comment|/* Step 3: Rebuild the RX buffer freelist and the RX ring itself. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|np
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
name|rxq
operator|=
operator|&
name|np
operator|->
name|rxq
index|[
name|i
index|]
expr_stmt|;
name|xn_rebuild_rx_bufs
argument_list|(
name|rxq
argument_list|)
expr_stmt|;
block|}
comment|/* Step 4: All public and private state should now be sane.  Get 	 * ready to start sending and receiving packets and give the driver 	 * domain a kick because we've probably just requeued some 	 * packets. 	 */
name|netfront_carrier_on
argument_list|(
name|np
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|np
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xn_kick_rings
parameter_list|(
name|struct
name|netfront_info
modifier|*
name|np
parameter_list|)
block|{
name|struct
name|netfront_rxq
modifier|*
name|rxq
decl_stmt|;
name|struct
name|netfront_txq
modifier|*
name|txq
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|np
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
name|txq
operator|=
operator|&
name|np
operator|->
name|txq
index|[
name|i
index|]
expr_stmt|;
name|rxq
operator|=
operator|&
name|np
operator|->
name|rxq
index|[
name|i
index|]
expr_stmt|;
name|xen_intr_signal
argument_list|(
name|txq
operator|->
name|xen_intr_handle
argument_list|)
expr_stmt|;
name|XN_TX_LOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|xn_txeof
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|XN_TX_UNLOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|XN_RX_LOCK
argument_list|(
name|rxq
argument_list|)
expr_stmt|;
name|xn_alloc_rx_buffers
argument_list|(
name|rxq
argument_list|)
expr_stmt|;
name|XN_RX_UNLOCK
argument_list|(
name|rxq
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|xn_query_features
parameter_list|(
name|struct
name|netfront_info
modifier|*
name|np
parameter_list|)
block|{
name|int
name|val
decl_stmt|;
name|device_printf
argument_list|(
name|np
operator|->
name|xbdev
argument_list|,
literal|"backend features:"
argument_list|)
expr_stmt|;
if|if
condition|(
name|xs_scanf
argument_list|(
name|XST_NIL
argument_list|,
name|xenbus_get_otherend_path
argument_list|(
name|np
operator|->
name|xbdev
argument_list|)
argument_list|,
literal|"feature-sg"
argument_list|,
name|NULL
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|val
argument_list|)
operator|!=
literal|0
condition|)
name|val
operator|=
literal|0
expr_stmt|;
name|np
operator|->
name|maxfrags
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|val
condition|)
block|{
name|np
operator|->
name|maxfrags
operator|=
name|MAX_TX_REQ_FRAGS
expr_stmt|;
name|printf
argument_list|(
literal|" feature-sg"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|xs_scanf
argument_list|(
name|XST_NIL
argument_list|,
name|xenbus_get_otherend_path
argument_list|(
name|np
operator|->
name|xbdev
argument_list|)
argument_list|,
literal|"feature-gso-tcpv4"
argument_list|,
name|NULL
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|val
argument_list|)
operator|!=
literal|0
condition|)
name|val
operator|=
literal|0
expr_stmt|;
name|np
operator|->
name|xn_ifp
operator|->
name|if_capabilities
operator|&=
operator|~
operator|(
name|IFCAP_TSO4
operator||
name|IFCAP_LRO
operator|)
expr_stmt|;
if|if
condition|(
name|val
condition|)
block|{
name|np
operator|->
name|xn_ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_TSO4
operator||
name|IFCAP_LRO
expr_stmt|;
name|printf
argument_list|(
literal|" feature-gso-tcp4"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * HW CSUM offload is assumed to be available unless 	 * feature-no-csum-offload is set in xenstore. 	 */
if|if
condition|(
name|xs_scanf
argument_list|(
name|XST_NIL
argument_list|,
name|xenbus_get_otherend_path
argument_list|(
name|np
operator|->
name|xbdev
argument_list|)
argument_list|,
literal|"feature-no-csum-offload"
argument_list|,
name|NULL
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|val
argument_list|)
operator|!=
literal|0
condition|)
name|val
operator|=
literal|0
expr_stmt|;
name|np
operator|->
name|xn_ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_HWCSUM
expr_stmt|;
if|if
condition|(
name|val
condition|)
block|{
name|np
operator|->
name|xn_ifp
operator|->
name|if_capabilities
operator|&=
operator|~
operator|(
name|IFCAP_HWCSUM
operator|)
expr_stmt|;
name|printf
argument_list|(
literal|" feature-no-csum-offload"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|xn_configure_features
parameter_list|(
name|struct
name|netfront_info
modifier|*
name|np
parameter_list|)
block|{
name|int
name|err
decl_stmt|,
name|cap_enabled
decl_stmt|;
if|#
directive|if
operator|(
name|defined
argument_list|(
name|INET
argument_list|)
operator|||
name|defined
argument_list|(
name|INET6
argument_list|)
operator|)
name|int
name|i
decl_stmt|;
endif|#
directive|endif
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|ifp
operator|=
name|np
operator|->
name|xn_ifp
expr_stmt|;
name|err
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|ifp
operator|->
name|if_capabilities
operator|)
operator|==
name|ifp
operator|->
name|if_capenable
condition|)
block|{
comment|/* Current options are available, no need to do anything. */
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Try to preserve as many options as possible. */
name|cap_enabled
operator|=
name|ifp
operator|->
name|if_capenable
expr_stmt|;
name|ifp
operator|->
name|if_capenable
operator|=
name|ifp
operator|->
name|if_hwassist
operator|=
literal|0
expr_stmt|;
if|#
directive|if
operator|(
name|defined
argument_list|(
name|INET
argument_list|)
operator|||
name|defined
argument_list|(
name|INET6
argument_list|)
operator|)
if|if
condition|(
operator|(
name|cap_enabled
operator|&
name|IFCAP_LRO
operator|)
operator|!=
literal|0
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|np
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
name|tcp_lro_free
argument_list|(
operator|&
name|np
operator|->
name|rxq
index|[
name|i
index|]
operator|.
name|lro
argument_list|)
expr_stmt|;
if|if
condition|(
name|xn_enable_lro
operator|&&
operator|(
name|ifp
operator|->
name|if_capabilities
operator|&
name|cap_enabled
operator|&
name|IFCAP_LRO
operator|)
operator|!=
literal|0
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator||=
name|IFCAP_LRO
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|np
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
name|err
operator|=
name|tcp_lro_init
argument_list|(
operator|&
name|np
operator|->
name|rxq
index|[
name|i
index|]
operator|.
name|lro
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|np
operator|->
name|xbdev
argument_list|,
literal|"LRO initialization failed\n"
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_capenable
operator|&=
operator|~
name|IFCAP_LRO
expr_stmt|;
break|break;
block|}
name|np
operator|->
name|rxq
index|[
name|i
index|]
operator|.
name|lro
operator|.
name|ifp
operator|=
name|ifp
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_capabilities
operator|&
name|cap_enabled
operator|&
name|IFCAP_TSO4
operator|)
operator|!=
literal|0
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator||=
name|IFCAP_TSO4
expr_stmt|;
name|ifp
operator|->
name|if_hwassist
operator||=
name|CSUM_TSO
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_capabilities
operator|&
name|cap_enabled
operator|&
name|IFCAP_TXCSUM
operator|)
operator|!=
literal|0
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator||=
name|IFCAP_TXCSUM
expr_stmt|;
name|ifp
operator|->
name|if_hwassist
operator||=
name|XN_CSUM_FEATURES
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_capabilities
operator|&
name|cap_enabled
operator|&
name|IFCAP_RXCSUM
operator|)
operator|!=
literal|0
condition|)
name|ifp
operator|->
name|if_capenable
operator||=
name|IFCAP_RXCSUM
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xn_txq_mq_start_locked
parameter_list|(
name|struct
name|netfront_txq
modifier|*
name|txq
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|netfront_info
modifier|*
name|np
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|buf_ring
modifier|*
name|br
decl_stmt|;
name|int
name|error
decl_stmt|,
name|notify
decl_stmt|;
name|np
operator|=
name|txq
operator|->
name|info
expr_stmt|;
name|br
operator|=
name|txq
operator|->
name|br
expr_stmt|;
name|ifp
operator|=
name|np
operator|->
name|xn_ifp
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|XN_TX_LOCK_ASSERT
argument_list|(
name|txq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
operator|||
operator|!
name|netfront_carrier_ok
argument_list|(
name|np
argument_list|)
condition|)
block|{
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
name|error
operator|=
name|drbr_enqueue
argument_list|(
name|ifp
argument_list|,
name|br
argument_list|,
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|drbr_enqueue
argument_list|(
name|ifp
argument_list|,
name|br
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
while|while
condition|(
operator|(
name|m
operator|=
name|drbr_peek
argument_list|(
name|ifp
argument_list|,
name|br
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|xn_tx_slot_available
argument_list|(
name|txq
argument_list|)
condition|)
block|{
name|drbr_putback
argument_list|(
name|ifp
argument_list|,
name|br
argument_list|,
name|m
argument_list|)
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|xn_assemble_tx_request
argument_list|(
name|txq
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* xn_assemble_tx_request always consumes the mbuf*/
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|drbr_advance
argument_list|(
name|ifp
argument_list|,
name|br
argument_list|)
expr_stmt|;
break|break;
block|}
name|RING_PUSH_REQUESTS_AND_CHECK_NOTIFY
argument_list|(
operator|&
name|txq
operator|->
name|ring
argument_list|,
name|notify
argument_list|)
expr_stmt|;
if|if
condition|(
name|notify
condition|)
name|xen_intr_signal
argument_list|(
name|txq
operator|->
name|xen_intr_handle
argument_list|)
expr_stmt|;
name|drbr_advance
argument_list|(
name|ifp
argument_list|,
name|br
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|RING_FULL
argument_list|(
operator|&
name|txq
operator|->
name|ring
argument_list|)
condition|)
name|txq
operator|->
name|full
operator|=
name|true
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xn_txq_mq_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|netfront_info
modifier|*
name|np
decl_stmt|;
name|struct
name|netfront_txq
modifier|*
name|txq
decl_stmt|;
name|int
name|i
decl_stmt|,
name|npairs
decl_stmt|,
name|error
decl_stmt|;
name|np
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|npairs
operator|=
name|np
operator|->
name|num_queues
expr_stmt|;
if|if
condition|(
operator|!
name|netfront_carrier_ok
argument_list|(
name|np
argument_list|)
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
name|KASSERT
argument_list|(
name|npairs
operator|!=
literal|0
argument_list|,
operator|(
literal|"called with 0 available queues"
operator|)
argument_list|)
expr_stmt|;
comment|/* check if flowid is set */
if|if
condition|(
name|M_HASHTYPE_GET
argument_list|(
name|m
argument_list|)
operator|!=
name|M_HASHTYPE_NONE
condition|)
name|i
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|flowid
operator|%
name|npairs
expr_stmt|;
else|else
name|i
operator|=
name|curcpu
operator|%
name|npairs
expr_stmt|;
name|txq
operator|=
operator|&
name|np
operator|->
name|txq
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|XN_TX_TRYLOCK
argument_list|(
name|txq
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|xn_txq_mq_start_locked
argument_list|(
name|txq
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|XN_TX_UNLOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|drbr_enqueue
argument_list|(
name|ifp
argument_list|,
name|txq
operator|->
name|br
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|txq
operator|->
name|tq
argument_list|,
operator|&
name|txq
operator|->
name|defrtask
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xn_qflush
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|netfront_info
modifier|*
name|np
decl_stmt|;
name|struct
name|netfront_txq
modifier|*
name|txq
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|i
decl_stmt|;
name|np
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|np
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
name|txq
operator|=
operator|&
name|np
operator|->
name|txq
index|[
name|i
index|]
expr_stmt|;
name|XN_TX_LOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|m
operator|=
name|buf_ring_dequeue_sc
argument_list|(
name|txq
operator|->
name|br
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|XN_TX_UNLOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
block|}
name|if_qflush
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Create a network device.  * @param dev  Newbus device representing this virtual NIC.  */
end_comment

begin_function
name|int
name|create_netdev
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|netfront_info
modifier|*
name|np
decl_stmt|;
name|int
name|err
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|np
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|np
operator|->
name|xbdev
operator|=
name|dev
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|np
operator|->
name|sc_lock
argument_list|,
literal|"xnsc"
argument_list|,
literal|"netfront softc lock"
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|ifmedia_init
argument_list|(
operator|&
name|np
operator|->
name|sc_media
argument_list|,
literal|0
argument_list|,
name|xn_ifmedia_upd
argument_list|,
name|xn_ifmedia_sts
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|np
operator|->
name|sc_media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_MANUAL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
operator|&
name|np
operator|->
name|sc_media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_MANUAL
argument_list|)
expr_stmt|;
name|err
operator|=
name|xen_net_read_mac
argument_list|(
name|dev
argument_list|,
name|np
operator|->
name|mac
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
goto|goto
name|error
goto|;
comment|/* Set up ifnet structure */
name|ifp
operator|=
name|np
operator|->
name|xn_ifp
operator|=
name|if_alloc
argument_list|(
name|IFT_ETHER
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_softc
operator|=
name|np
expr_stmt|;
name|if_initname
argument_list|(
name|ifp
argument_list|,
literal|"xn"
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|xn_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_transmit
operator|=
name|xn_txq_mq_start
expr_stmt|;
name|ifp
operator|->
name|if_qflush
operator|=
name|xn_qflush
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|xn_ifinit
expr_stmt|;
name|ifp
operator|->
name|if_hwassist
operator|=
name|XN_CSUM_FEATURES
expr_stmt|;
comment|/* Enable all supported features at device creation. */
name|ifp
operator|->
name|if_capenable
operator|=
name|ifp
operator|->
name|if_capabilities
operator|=
name|IFCAP_HWCSUM
operator||
name|IFCAP_TSO4
operator||
name|IFCAP_LRO
expr_stmt|;
name|ifp
operator|->
name|if_hw_tsomax
operator|=
literal|65536
operator|-
operator|(
name|ETHER_HDR_LEN
operator|+
name|ETHER_VLAN_ENCAP_LEN
operator|)
expr_stmt|;
name|ifp
operator|->
name|if_hw_tsomaxsegcount
operator|=
name|MAX_TX_REQ_FRAGS
expr_stmt|;
name|ifp
operator|->
name|if_hw_tsomaxsegsize
operator|=
name|PAGE_SIZE
expr_stmt|;
name|ether_ifattach
argument_list|(
name|ifp
argument_list|,
name|np
operator|->
name|mac
argument_list|)
expr_stmt|;
name|netfront_carrier_off
argument_list|(
name|np
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|error
label|:
name|KASSERT
argument_list|(
name|err
operator|!=
literal|0
argument_list|,
operator|(
literal|"Error path with no error code specified"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|netfront_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|netfront_info
modifier|*
name|info
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|DPRINTK
argument_list|(
literal|"%s\n"
argument_list|,
name|xenbus_get_node
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|netif_free
argument_list|(
name|info
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|netif_free
parameter_list|(
name|struct
name|netfront_info
modifier|*
name|np
parameter_list|)
block|{
name|XN_LOCK
argument_list|(
name|np
argument_list|)
expr_stmt|;
name|xn_stop
argument_list|(
name|np
argument_list|)
expr_stmt|;
name|XN_UNLOCK
argument_list|(
name|np
argument_list|)
expr_stmt|;
name|netif_disconnect_backend
argument_list|(
name|np
argument_list|)
expr_stmt|;
name|ether_ifdetach
argument_list|(
name|np
operator|->
name|xn_ifp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|np
operator|->
name|rxq
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|np
operator|->
name|txq
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|if_free
argument_list|(
name|np
operator|->
name|xn_ifp
argument_list|)
expr_stmt|;
name|np
operator|->
name|xn_ifp
operator|=
name|NULL
expr_stmt|;
name|ifmedia_removeall
argument_list|(
operator|&
name|np
operator|->
name|sc_media
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|netif_disconnect_backend
parameter_list|(
name|struct
name|netfront_info
modifier|*
name|np
parameter_list|)
block|{
name|u_int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|np
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
name|XN_RX_LOCK
argument_list|(
operator|&
name|np
operator|->
name|rxq
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|XN_TX_LOCK
argument_list|(
operator|&
name|np
operator|->
name|txq
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|netfront_carrier_off
argument_list|(
name|np
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|np
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
name|XN_RX_UNLOCK
argument_list|(
operator|&
name|np
operator|->
name|rxq
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|XN_TX_UNLOCK
argument_list|(
operator|&
name|np
operator|->
name|txq
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|np
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
name|disconnect_rxq
argument_list|(
operator|&
name|np
operator|->
name|rxq
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|disconnect_txq
argument_list|(
operator|&
name|np
operator|->
name|txq
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|xn_ifmedia_upd
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xn_ifmedia_sts
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|ifmediareq
modifier|*
name|ifmr
parameter_list|)
block|{
name|ifmr
operator|->
name|ifm_status
operator|=
name|IFM_AVALID
operator||
name|IFM_ACTIVE
expr_stmt|;
name|ifmr
operator|->
name|ifm_active
operator|=
name|IFM_ETHER
operator||
name|IFM_MANUAL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** Driver registration ** */
end_comment

begin_decl_stmt
specifier|static
name|device_method_t
name|netfront_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|netfront_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|netfront_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|netfront_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|bus_generic_shutdown
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|netfront_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|netfront_resume
argument_list|)
block|,
comment|/* Xenbus interface */
name|DEVMETHOD
argument_list|(
name|xenbus_otherend_changed
argument_list|,
name|netfront_backend_changed
argument_list|)
block|,
name|DEVMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|netfront_driver
init|=
block|{
literal|"xn"
block|,
name|netfront_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|netfront_info
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|devclass_t
name|netfront_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|xe
argument_list|,
name|xenbusb_front
argument_list|,
name|netfront_driver
argument_list|,
name|netfront_devclass
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

