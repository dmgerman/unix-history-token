begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************************  * xenstore.c  *  * Low-level kernel interface to the XenStore.  *  * Copyright (C) 2005 Rusty Russell, IBM Corporation  * Copyright (C) 2009,2010 Spectra Logic Corporation  *  * This file may be distributed separately from the Linux kernel, or  * incorporated into other software packages, subject to the following license:  *  * Permission is hereby granted, free of charge, to any person obtaining a copy  * of this source file (the "Software"), to deal in the Software without  * restriction, including without limitation the rights to use, copy, modify,  * merge, publish, distribute, sublicense, and/or sell copies of the Software,  * and to permit persons to whom the Software is furnished to do so, subject to  * the following conditions:  *  * The above copyright notice and this permission notice shall be included in  * all copies or substantial portions of the Software.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE  * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING  * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS  * IN THE SOFTWARE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_include
include|#
directive|include
file|<sys/sbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<machine/stdarg.h>
end_include

begin_include
include|#
directive|include
file|<xen/xen-os.h>
end_include

begin_include
include|#
directive|include
file|<xen/hypervisor.h>
end_include

begin_include
include|#
directive|include
file|<xen/xen_intr.h>
end_include

begin_include
include|#
directive|include
file|<xen/interface/hvm/params.h>
end_include

begin_include
include|#
directive|include
file|<xen/hvm.h>
end_include

begin_include
include|#
directive|include
file|<xen/xenstore/xenstorevar.h>
end_include

begin_include
include|#
directive|include
file|<xen/xenstore/xenstore_internal.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_comment
comment|/**  * \file xenstore.c  * \brief XenStore interface  *  * The XenStore interface is a simple storage system that is a means of  * communicating state and configuration data between the Xen Domain 0  * and the various guest domains.  All configuration data other than  * a small amount of essential information required during the early  * boot process of launching a Xen aware guest, is managed using the  * XenStore.  *  * The XenStore is ASCII string based, and has a structure and semantics  * similar to a filesystem.  There are files and directories, the directories  * able to contain files or other directories.  The depth of the hierachy  * is only limited by the XenStore's maximum path length.  *  * The communication channel between the XenStore service and other  * domains is via two, guest specific, ring buffers in a shared memory  * area.  One ring buffer is used for communicating in each direction.  * The grant table references for this shared memory are given to the  * guest either via the xen_start_info structure for a fully para-  * virtualized guest, or via HVM hypercalls for a hardware virtualized  * guest.  *  * The XenStore communication relies on an event channel and thus  * interrupts.  For this reason, the attachment of the XenStore  * relies on an interrupt driven configuration hook to hold off  * boot processing until communication with the XenStore service  * can be established.  *  * Several Xen services depend on the XenStore, most notably the  * XenBus used to discover and manage Xen devices.  These services  * are implemented as NewBus child attachments to a bus exported  * by this XenStore driver.  */
end_comment

begin_function_decl
specifier|static
name|struct
name|xs_watch
modifier|*
name|find_watch
parameter_list|(
specifier|const
name|char
modifier|*
name|token
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_XENSTORE
argument_list|,
literal|"xenstore"
argument_list|,
literal|"XenStore data and results"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/**  * Pointer to shared memory communication structures allowing us  * to communicate with the XenStore service.  *  * When operating in full PV mode, this pointer is set early in kernel  * startup from within xen_machdep.c.  In HVM mode, we use hypercalls  * to get the guest frame number for the shared page and then map it  * into kva.  See xs_init() for details.  */
end_comment

begin_decl_stmt
name|struct
name|xenstore_domain_interface
modifier|*
name|xen_store
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*-------------------------- Private Data Structures ------------------------*/
end_comment

begin_comment
comment|/**  * Structure capturing messages received from the XenStore service.  */
end_comment

begin_struct
struct|struct
name|xs_stored_msg
block|{
name|TAILQ_ENTRY
argument_list|(
argument|xs_stored_msg
argument_list|)
name|list
expr_stmt|;
name|struct
name|xsd_sockmsg
name|hdr
decl_stmt|;
union|union
block|{
comment|/* Queued replies. */
struct|struct
block|{
name|char
modifier|*
name|body
decl_stmt|;
block|}
name|reply
struct|;
comment|/* Queued watch events. */
struct|struct
block|{
name|struct
name|xs_watch
modifier|*
name|handle
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|vec
decl_stmt|;
name|u_int
name|vec_size
decl_stmt|;
block|}
name|watch
struct|;
block|}
name|u
union|;
block|}
struct|;
end_struct

begin_expr_stmt
name|TAILQ_HEAD
argument_list|(
name|xs_stored_msg_list
argument_list|,
name|xs_stored_msg
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/**  * Container for all XenStore related state.  */
end_comment

begin_struct
struct|struct
name|xs_softc
block|{
comment|/** Newbus device for the XenStore. */
name|device_t
name|xs_dev
decl_stmt|;
comment|/** 	 * Lock serializing access to ring producer/consumer 	 * indexes.  Use of this lock guarantees that wakeups 	 * of blocking readers/writers are not missed due to 	 * races with the XenStore service. 	 */
name|struct
name|mtx
name|ring_lock
decl_stmt|;
comment|/* 	 * Mutex used to insure exclusive access to the outgoing 	 * communication ring.  We use a lock type that can be 	 * held while sleeping so that xs_write() can block waiting 	 * for space in the ring to free up, without allowing another 	 * writer to come in and corrupt a partial message write. 	 */
name|struct
name|sx
name|request_mutex
decl_stmt|;
comment|/** 	 * A list of replies to our requests. 	 * 	 * The reply list is filled by xs_rcv_thread().  It 	 * is consumed by the context that issued the request 	 * to which a reply is made.  The requester blocks in 	 * xs_read_reply(). 	 * 	 * /note Only one requesting context can be active at a time. 	 *       This is guaranteed by the request_mutex and insures 	 *	 that the requester sees replies matching the order 	 *	 of its requests. 	 */
name|struct
name|xs_stored_msg_list
name|reply_list
decl_stmt|;
comment|/** Lock protecting the reply list. */
name|struct
name|mtx
name|reply_lock
decl_stmt|;
comment|/** 	 * List of registered watches. 	 */
name|struct
name|xs_watch_list
name|registered_watches
decl_stmt|;
comment|/** Lock protecting the registered watches list. */
name|struct
name|mtx
name|registered_watches_lock
decl_stmt|;
comment|/** 	 * List of pending watch callback events. 	 */
name|struct
name|xs_stored_msg_list
name|watch_events
decl_stmt|;
comment|/** Lock protecting the watch calback list. */
name|struct
name|mtx
name|watch_events_lock
decl_stmt|;
comment|/** 	 * Sleepable lock used to prevent VM suspension while a 	 * xenstore transaction is outstanding. 	 * 	 * Each active transaction holds a shared lock on the 	 * suspend mutex.  Our suspend method blocks waiting 	 * to acquire an exclusive lock.  This guarantees that 	 * suspend processing will only proceed once all active 	 * transactions have been retired. 	 */
name|struct
name|sx
name|suspend_mutex
decl_stmt|;
comment|/** 	 * The processid of the xenwatch thread. 	 */
name|pid_t
name|xenwatch_pid
decl_stmt|;
comment|/** 	 * Sleepable mutex used to gate the execution of XenStore 	 * watch event callbacks. 	 * 	 * xenwatch_thread holds an exclusive lock on this mutex 	 * while delivering event callbacks, and xenstore_unregister_watch() 	 * uses an exclusive lock of this mutex to guarantee that no 	 * callbacks of the just unregistered watch are pending 	 * before returning to its caller. 	 */
name|struct
name|sx
name|xenwatch_mutex
decl_stmt|;
comment|/** 	 * The HVM guest pseudo-physical frame number.  This is Xen's mapping 	 * of the true machine frame number into our "physical address space". 	 */
name|unsigned
name|long
name|gpfn
decl_stmt|;
comment|/** 	 * The event channel for communicating with the 	 * XenStore service. 	 */
name|int
name|evtchn
decl_stmt|;
comment|/** Handle for XenStore interrupts. */
name|xen_intr_handle_t
name|xen_intr_handle
decl_stmt|;
comment|/** 	 * Interrupt driven config hook allowing us to defer 	 * attaching children until interrupts (and thus communication 	 * with the XenStore service) are available. 	 */
name|struct
name|intr_config_hook
name|xs_attachcb
decl_stmt|;
comment|/** 	 * Xenstore is a user-space process that usually runs in Dom0, 	 * so if this domain is booting as Dom0, xenstore wont we accessible, 	 * and we have to defer the initialization of xenstore related 	 * devices to later (when xenstore is started). 	 */
name|bool
name|initialized
decl_stmt|;
comment|/** 	 * Task to run when xenstore is initialized (Dom0 only), will 	 * take care of attaching xenstore related devices. 	 */
name|struct
name|task
name|xs_late_init
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*-------------------------------- Global Data ------------------------------*/
end_comment

begin_decl_stmt
specifier|static
name|struct
name|xs_softc
name|xs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*------------------------- Private Utility Functions -----------------------*/
end_comment

begin_comment
comment|/**  * Count and optionally record pointers to a number of NUL terminated  * strings in a buffer.  *  * \param strings  A pointer to a contiguous buffer of NUL terminated strings.  * \param dest	   An array to store pointers to each string found in strings.  * \param len	   The length of the buffer pointed to by strings.  *  * \return  A count of the number of strings found.  */
end_comment

begin_function
specifier|static
name|u_int
name|extract_strings
parameter_list|(
specifier|const
name|char
modifier|*
name|strings
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|dest
parameter_list|,
name|u_int
name|len
parameter_list|)
block|{
name|u_int
name|num
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|strings
operator|,
name|num
operator|=
literal|0
init|;
name|p
operator|<
name|strings
operator|+
name|len
condition|;
name|p
operator|+=
name|strlen
argument_list|(
name|p
argument_list|)
operator|+
literal|1
control|)
block|{
if|if
condition|(
name|dest
operator|!=
name|NULL
condition|)
operator|*
name|dest
operator|++
operator|=
name|p
expr_stmt|;
name|num
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|num
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Convert a contiguous buffer containing a series of NUL terminated  * strings into an array of pointers to strings.  *  * The returned pointer references the array of string pointers which  * is followed by the storage for the string data.  It is the client's  * responsibility to free this storage.  *  * The storage addressed by strings is free'd prior to split returning.  *  * \param strings  A pointer to a contiguous buffer of NUL terminated strings.  * \param len	   The length of the buffer pointed to by strings.  * \param num	   The number of strings found and returned in the strings  *                 array.  *  * \return  An array of pointers to the strings found in the input buffer.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
modifier|*
name|split
parameter_list|(
name|char
modifier|*
name|strings
parameter_list|,
name|u_int
name|len
parameter_list|,
name|u_int
modifier|*
name|num
parameter_list|)
block|{
specifier|const
name|char
modifier|*
modifier|*
name|ret
decl_stmt|;
comment|/* Protect against unterminated buffers. */
if|if
condition|(
name|len
operator|>
literal|0
condition|)
name|strings
index|[
name|len
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Count the strings. */
operator|*
name|num
operator|=
name|extract_strings
argument_list|(
name|strings
argument_list|,
comment|/*dest*/
name|NULL
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* Transfer to one big alloc for easy freeing by the caller. */
name|ret
operator|=
name|malloc
argument_list|(
operator|*
name|num
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|+
name|len
argument_list|,
name|M_XENSTORE
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|ret
index|[
operator|*
name|num
index|]
argument_list|,
name|strings
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|strings
argument_list|,
name|M_XENSTORE
argument_list|)
expr_stmt|;
comment|/* Extract pointers to newly allocated array. */
name|strings
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|ret
index|[
operator|*
name|num
index|]
expr_stmt|;
operator|(
name|void
operator|)
name|extract_strings
argument_list|(
name|strings
argument_list|,
comment|/*dest*/
name|ret
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------- Public Utility Functions -------------------------*/
end_comment

begin_comment
comment|/*------- API comments for these methods can be found in xenstorevar.h -------*/
end_comment

begin_function
name|struct
name|sbuf
modifier|*
name|xs_join
parameter_list|(
specifier|const
name|char
modifier|*
name|dir
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|sbuf
modifier|*
name|sb
decl_stmt|;
name|sb
operator|=
name|sbuf_new_auto
argument_list|()
expr_stmt|;
name|sbuf_cat
argument_list|(
name|sb
argument_list|,
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|sbuf_putc
argument_list|(
name|sb
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
name|sbuf_cat
argument_list|(
name|sb
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
name|sbuf_finish
argument_list|(
name|sb
argument_list|)
expr_stmt|;
return|return
operator|(
name|sb
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-------------------- Low Level Communication Management --------------------*/
end_comment

begin_comment
comment|/**  * Interrupt handler for the XenStore event channel.  *  * XenStore reads and writes block on "xen_store" for buffer  * space.  Wakeup any blocking operations when the XenStore  * service has modified the queues.  */
end_comment

begin_function
specifier|static
name|void
name|xs_intr
parameter_list|(
name|void
modifier|*
name|arg
name|__unused
comment|/*__attribute__((unused))*/
parameter_list|)
block|{
comment|/* If xenstore has not been initialized, initialize it now */
if|if
condition|(
operator|!
name|xs
operator|.
name|initialized
condition|)
block|{
name|xs
operator|.
name|initialized
operator|=
name|true
expr_stmt|;
comment|/* 		 * Since this task is probing and attaching devices we 		 * have to hold the Giant lock. 		 */
name|taskqueue_enqueue
argument_list|(
name|taskqueue_swi_giant
argument_list|,
operator|&
name|xs
operator|.
name|xs_late_init
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Hold ring lock across wakeup so that clients 	 * cannot miss a wakeup. 	 */
name|mtx_lock
argument_list|(
operator|&
name|xs
operator|.
name|ring_lock
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|xen_store
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|xs
operator|.
name|ring_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Verify that the indexes for a ring are valid.  *  * The difference between the producer and consumer cannot  * exceed the size of the ring.  *  * \param cons  The consumer index for the ring to test.  * \param prod  The producer index for the ring to test.  *  * \retval 1  If indexes are in range.  * \retval 0  If the indexes are out of range.  */
end_comment

begin_function
specifier|static
name|int
name|xs_check_indexes
parameter_list|(
name|XENSTORE_RING_IDX
name|cons
parameter_list|,
name|XENSTORE_RING_IDX
name|prod
parameter_list|)
block|{
return|return
operator|(
operator|(
name|prod
operator|-
name|cons
operator|)
operator|<=
name|XENSTORE_RING_SIZE
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Return a pointer to, and the length of, the contiguous  * free region available for output in a ring buffer.  *  * \param cons  The consumer index for the ring.  * \param prod  The producer index for the ring.  * \param buf   The base address of the ring's storage.  * \param len   The amount of contiguous storage available.  *  * \return  A pointer to the start location of the free region.  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|xs_get_output_chunk
parameter_list|(
name|XENSTORE_RING_IDX
name|cons
parameter_list|,
name|XENSTORE_RING_IDX
name|prod
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|uint32_t
modifier|*
name|len
parameter_list|)
block|{
operator|*
name|len
operator|=
name|XENSTORE_RING_SIZE
operator|-
name|MASK_XENSTORE_IDX
argument_list|(
name|prod
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|XENSTORE_RING_SIZE
operator|-
operator|(
name|prod
operator|-
name|cons
operator|)
operator|)
operator|<
operator|*
name|len
condition|)
operator|*
name|len
operator|=
name|XENSTORE_RING_SIZE
operator|-
operator|(
name|prod
operator|-
name|cons
operator|)
expr_stmt|;
return|return
operator|(
name|buf
operator|+
name|MASK_XENSTORE_IDX
argument_list|(
name|prod
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Return a pointer to, and the length of, the contiguous  * data available to read from a ring buffer.  *  * \param cons  The consumer index for the ring.  * \param prod  The producer index for the ring.  * \param buf   The base address of the ring's storage.  * \param len   The amount of contiguous data available to read.  *  * \return  A pointer to the start location of the available data.  */
end_comment

begin_function
specifier|static
specifier|const
name|void
modifier|*
name|xs_get_input_chunk
parameter_list|(
name|XENSTORE_RING_IDX
name|cons
parameter_list|,
name|XENSTORE_RING_IDX
name|prod
parameter_list|,
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|uint32_t
modifier|*
name|len
parameter_list|)
block|{
operator|*
name|len
operator|=
name|XENSTORE_RING_SIZE
operator|-
name|MASK_XENSTORE_IDX
argument_list|(
name|cons
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|prod
operator|-
name|cons
operator|)
operator|<
operator|*
name|len
condition|)
operator|*
name|len
operator|=
name|prod
operator|-
name|cons
expr_stmt|;
return|return
operator|(
name|buf
operator|+
name|MASK_XENSTORE_IDX
argument_list|(
name|cons
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Transmit data to the XenStore service.  *  * \param tdata  A pointer to the contiguous data to send.  * \param len    The amount of data to send.  *  * \return  On success 0, otherwise an errno value indicating the  *          cause of failure.  *  * \invariant  Called from thread context.  * \invariant  The buffer pointed to by tdata is at least len bytes  *             in length.  * \invariant  xs.request_mutex exclusively locked.  */
end_comment

begin_function
specifier|static
name|int
name|xs_write_store
parameter_list|(
specifier|const
name|void
modifier|*
name|tdata
parameter_list|,
name|unsigned
name|len
parameter_list|)
block|{
name|XENSTORE_RING_IDX
name|cons
decl_stmt|,
name|prod
decl_stmt|;
specifier|const
name|char
modifier|*
name|data
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|tdata
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sx_assert
argument_list|(
operator|&
name|xs
operator|.
name|request_mutex
argument_list|,
name|SX_XLOCKED
argument_list|)
expr_stmt|;
while|while
condition|(
name|len
operator|!=
literal|0
condition|)
block|{
name|void
modifier|*
name|dst
decl_stmt|;
name|u_int
name|avail
decl_stmt|;
comment|/* Hold lock so we can't miss wakeups should we block. */
name|mtx_lock
argument_list|(
operator|&
name|xs
operator|.
name|ring_lock
argument_list|)
expr_stmt|;
name|cons
operator|=
name|xen_store
operator|->
name|req_cons
expr_stmt|;
name|prod
operator|=
name|xen_store
operator|->
name|req_prod
expr_stmt|;
if|if
condition|(
operator|(
name|prod
operator|-
name|cons
operator|)
operator|==
name|XENSTORE_RING_SIZE
condition|)
block|{
comment|/* 			 * Output ring is full. Wait for a ring event. 			 * 			 * Note that the events from both queues 			 * are combined, so being woken does not 			 * guarantee that data exist in the read 			 * ring. 			 * 			 * To simplify error recovery and the retry, 			 * we specify PDROP so our lock is *not* held 			 * when msleep returns. 			 */
name|error
operator|=
name|msleep
argument_list|(
name|xen_store
argument_list|,
operator|&
name|xs
operator|.
name|ring_lock
argument_list|,
name|PCATCH
operator||
name|PDROP
argument_list|,
literal|"xbwrite"
argument_list|,
comment|/*timeout*/
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|&&
name|error
operator|!=
name|EWOULDBLOCK
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Try again. */
continue|continue;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|xs
operator|.
name|ring_lock
argument_list|)
expr_stmt|;
comment|/* Verify queue sanity. */
if|if
condition|(
operator|!
name|xs_check_indexes
argument_list|(
name|cons
argument_list|,
name|prod
argument_list|)
condition|)
block|{
name|xen_store
operator|->
name|req_cons
operator|=
name|xen_store
operator|->
name|req_prod
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|dst
operator|=
name|xs_get_output_chunk
argument_list|(
name|cons
argument_list|,
name|prod
argument_list|,
name|xen_store
operator|->
name|req
argument_list|,
operator|&
name|avail
argument_list|)
expr_stmt|;
if|if
condition|(
name|avail
operator|>
name|len
condition|)
name|avail
operator|=
name|len
expr_stmt|;
name|memcpy
argument_list|(
name|dst
argument_list|,
name|data
argument_list|,
name|avail
argument_list|)
expr_stmt|;
name|data
operator|+=
name|avail
expr_stmt|;
name|len
operator|-=
name|avail
expr_stmt|;
comment|/* 		 * The store to the producer index, which indicates 		 * to the other side that new data has arrived, must 		 * be visible only after our copy of the data into the 		 * ring has completed. 		 */
name|wmb
argument_list|()
expr_stmt|;
name|xen_store
operator|->
name|req_prod
operator|+=
name|avail
expr_stmt|;
comment|/* 		 * xen_intr_signal() implies mb(). The other side will see 		 * the change to req_prod at the time of the interrupt. 		 */
name|xen_intr_signal
argument_list|(
name|xs
operator|.
name|xen_intr_handle
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Receive data from the XenStore service.  *  * \param tdata  A pointer to the contiguous buffer to receive the data.  * \param len    The amount of data to receive.  *  * \return  On success 0, otherwise an errno value indicating the  *          cause of failure.  *  * \invariant  Called from thread context.  * \invariant  The buffer pointed to by tdata is at least len bytes  *             in length.  *  * \note xs_read does not perform any internal locking to guarantee  *       serial access to the incoming ring buffer.  However, there  *	 is only one context processing reads: xs_rcv_thread().  */
end_comment

begin_function
specifier|static
name|int
name|xs_read_store
parameter_list|(
name|void
modifier|*
name|tdata
parameter_list|,
name|unsigned
name|len
parameter_list|)
block|{
name|XENSTORE_RING_IDX
name|cons
decl_stmt|,
name|prod
decl_stmt|;
name|char
modifier|*
name|data
init|=
operator|(
name|char
operator|*
operator|)
name|tdata
decl_stmt|;
name|int
name|error
decl_stmt|;
while|while
condition|(
name|len
operator|!=
literal|0
condition|)
block|{
name|u_int
name|avail
decl_stmt|;
specifier|const
name|char
modifier|*
name|src
decl_stmt|;
comment|/* Hold lock so we can't miss wakeups should we block. */
name|mtx_lock
argument_list|(
operator|&
name|xs
operator|.
name|ring_lock
argument_list|)
expr_stmt|;
name|cons
operator|=
name|xen_store
operator|->
name|rsp_cons
expr_stmt|;
name|prod
operator|=
name|xen_store
operator|->
name|rsp_prod
expr_stmt|;
if|if
condition|(
name|cons
operator|==
name|prod
condition|)
block|{
comment|/* 			 * Nothing to read. Wait for a ring event. 			 * 			 * Note that the events from both queues 			 * are combined, so being woken does not 			 * guarantee that data exist in the read 			 * ring. 			 * 			 * To simplify error recovery and the retry, 			 * we specify PDROP so our lock is *not* held 			 * when msleep returns. 			 */
name|error
operator|=
name|msleep
argument_list|(
name|xen_store
argument_list|,
operator|&
name|xs
operator|.
name|ring_lock
argument_list|,
name|PCATCH
operator||
name|PDROP
argument_list|,
literal|"xbread"
argument_list|,
comment|/*timeout*/
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|&&
name|error
operator|!=
name|EWOULDBLOCK
condition|)
return|return
operator|(
name|error
operator|)
return|;
continue|continue;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|xs
operator|.
name|ring_lock
argument_list|)
expr_stmt|;
comment|/* Verify queue sanity. */
if|if
condition|(
operator|!
name|xs_check_indexes
argument_list|(
name|cons
argument_list|,
name|prod
argument_list|)
condition|)
block|{
name|xen_store
operator|->
name|rsp_cons
operator|=
name|xen_store
operator|->
name|rsp_prod
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|src
operator|=
name|xs_get_input_chunk
argument_list|(
name|cons
argument_list|,
name|prod
argument_list|,
name|xen_store
operator|->
name|rsp
argument_list|,
operator|&
name|avail
argument_list|)
expr_stmt|;
if|if
condition|(
name|avail
operator|>
name|len
condition|)
name|avail
operator|=
name|len
expr_stmt|;
comment|/* 		 * Insure the data we read is related to the indexes 		 * we read above. 		 */
name|rmb
argument_list|()
expr_stmt|;
name|memcpy
argument_list|(
name|data
argument_list|,
name|src
argument_list|,
name|avail
argument_list|)
expr_stmt|;
name|data
operator|+=
name|avail
expr_stmt|;
name|len
operator|-=
name|avail
expr_stmt|;
comment|/* 		 * Insure that the producer of this ring does not see 		 * the ring space as free until after we have copied it 		 * out. 		 */
name|mb
argument_list|()
expr_stmt|;
name|xen_store
operator|->
name|rsp_cons
operator|+=
name|avail
expr_stmt|;
comment|/* 		 * xen_intr_signal() implies mb(). The producer will see 		 * the updated consumer index when the event is delivered. 		 */
name|xen_intr_signal
argument_list|(
name|xs
operator|.
name|xen_intr_handle
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*----------------------- Received Message Processing ------------------------*/
end_comment

begin_comment
comment|/**  * Block reading the next message from the XenStore service and  * process the result.  *  * \param type  The returned type of the XenStore message received.  *  * \return  0 on success.  Otherwise an errno value indicating the  *          type of failure encountered.  */
end_comment

begin_function
specifier|static
name|int
name|xs_process_msg
parameter_list|(
name|enum
name|xsd_sockmsg_type
modifier|*
name|type
parameter_list|)
block|{
name|struct
name|xs_stored_msg
modifier|*
name|msg
decl_stmt|;
name|char
modifier|*
name|body
decl_stmt|;
name|int
name|error
decl_stmt|;
name|msg
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|msg
argument_list|)
argument_list|,
name|M_XENSTORE
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|error
operator|=
name|xs_read_store
argument_list|(
operator|&
name|msg
operator|->
name|hdr
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
operator|->
name|hdr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|free
argument_list|(
name|msg
argument_list|,
name|M_XENSTORE
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|body
operator|=
name|malloc
argument_list|(
name|msg
operator|->
name|hdr
operator|.
name|len
operator|+
literal|1
argument_list|,
name|M_XENSTORE
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|error
operator|=
name|xs_read_store
argument_list|(
name|body
argument_list|,
name|msg
operator|->
name|hdr
operator|.
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|free
argument_list|(
name|body
argument_list|,
name|M_XENSTORE
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|msg
argument_list|,
name|M_XENSTORE
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|body
index|[
name|msg
operator|->
name|hdr
operator|.
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|type
operator|=
name|msg
operator|->
name|hdr
operator|.
name|type
expr_stmt|;
if|if
condition|(
name|msg
operator|->
name|hdr
operator|.
name|type
operator|==
name|XS_WATCH_EVENT
condition|)
block|{
name|msg
operator|->
name|u
operator|.
name|watch
operator|.
name|vec
operator|=
name|split
argument_list|(
name|body
argument_list|,
name|msg
operator|->
name|hdr
operator|.
name|len
argument_list|,
operator|&
name|msg
operator|->
name|u
operator|.
name|watch
operator|.
name|vec_size
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|xs
operator|.
name|registered_watches_lock
argument_list|)
expr_stmt|;
name|msg
operator|->
name|u
operator|.
name|watch
operator|.
name|handle
operator|=
name|find_watch
argument_list|(
name|msg
operator|->
name|u
operator|.
name|watch
operator|.
name|vec
index|[
name|XS_WATCH_TOKEN
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|->
name|u
operator|.
name|watch
operator|.
name|handle
operator|!=
name|NULL
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|xs
operator|.
name|watch_events_lock
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|xs
operator|.
name|watch_events
argument_list|,
name|msg
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|xs
operator|.
name|watch_events
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|xs
operator|.
name|watch_events_lock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|free
argument_list|(
name|msg
operator|->
name|u
operator|.
name|watch
operator|.
name|vec
argument_list|,
name|M_XENSTORE
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|msg
argument_list|,
name|M_XENSTORE
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|xs
operator|.
name|registered_watches_lock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|msg
operator|->
name|u
operator|.
name|reply
operator|.
name|body
operator|=
name|body
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|xs
operator|.
name|reply_lock
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|xs
operator|.
name|reply_list
argument_list|,
name|msg
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|xs
operator|.
name|reply_list
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|xs
operator|.
name|reply_lock
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Thread body of the XenStore receive thread.  *  * This thread blocks waiting for data from the XenStore service  * and processes and received messages.  */
end_comment

begin_function
specifier|static
name|void
name|xs_rcv_thread
parameter_list|(
name|void
modifier|*
name|arg
name|__unused
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|enum
name|xsd_sockmsg_type
name|type
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|error
operator|=
name|xs_process_msg
argument_list|(
operator|&
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|printf
argument_list|(
literal|"XENSTORE error %d while reading message\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*---------------- XenStore Message Request/Reply Processing -----------------*/
end_comment

begin_comment
comment|/**  * Filter invoked before transmitting any message to the XenStore service.  *  * The role of the filter may expand, but currently serves to manage  * the interactions of messages with transaction state.  *  * \param request_msg_type  The message type for the request.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|xs_request_filter
parameter_list|(
name|uint32_t
name|request_msg_type
parameter_list|)
block|{
if|if
condition|(
name|request_msg_type
operator|==
name|XS_TRANSACTION_START
condition|)
name|sx_slock
argument_list|(
operator|&
name|xs
operator|.
name|suspend_mutex
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Filter invoked after transmitting any message to the XenStore service.  *  * The role of the filter may expand, but currently serves to manage  * the interactions of messages with transaction state.  *  * \param request_msg_type     The message type for the original request.  * \param reply_msg_type       The message type for any received reply.  * \param request_reply_error  The error status from the attempt to send  *                             the request or retrieve the reply.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|xs_reply_filter
parameter_list|(
name|uint32_t
name|request_msg_type
parameter_list|,
name|uint32_t
name|reply_msg_type
parameter_list|,
name|int
name|request_reply_error
parameter_list|)
block|{
comment|/* 	 * The count of transactions drops if we attempted 	 * to end a transaction (even if that attempt fails 	 * in error), we receive a transaction end acknowledgement, 	 * or if our attempt to begin a transaction fails. 	 */
if|if
condition|(
name|request_msg_type
operator|==
name|XS_TRANSACTION_END
operator|||
operator|(
name|request_reply_error
operator|==
literal|0
operator|&&
name|reply_msg_type
operator|==
name|XS_TRANSACTION_END
operator|)
operator|||
operator|(
name|request_msg_type
operator|==
name|XS_TRANSACTION_START
operator|&&
operator|(
name|request_reply_error
operator|!=
literal|0
operator|||
name|reply_msg_type
operator|==
name|XS_ERROR
operator|)
operator|)
condition|)
name|sx_sunlock
argument_list|(
operator|&
name|xs
operator|.
name|suspend_mutex
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|xsd_error_count
value|(sizeof(xsd_errors) / sizeof(xsd_errors[0]))
end_define

begin_comment
comment|/**  * Convert a XenStore error string into an errno number.  *  * \param errorstring  The error string to convert.  *  * \return  The errno best matching the input string.  *  * \note Unknown error strings are converted to EINVAL.  */
end_comment

begin_function
specifier|static
name|int
name|xs_get_error
parameter_list|(
specifier|const
name|char
modifier|*
name|errorstring
parameter_list|)
block|{
name|u_int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|xsd_error_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|errorstring
argument_list|,
name|xsd_errors
index|[
name|i
index|]
operator|.
name|errstring
argument_list|)
condition|)
return|return
operator|(
name|xsd_errors
index|[
name|i
index|]
operator|.
name|errnum
operator|)
return|;
block|}
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"XENSTORE xen store gave: unknown error %s"
argument_list|,
name|errorstring
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Block waiting for a reply to a message request.  *  * \param type	  The returned type of the reply.  * \param len	  The returned body length of the reply.  * \param result  The returned body of the reply.  *  * \return  0 on success.  Otherwise an errno indicating the  *          cause of failure.  */
end_comment

begin_function
specifier|static
name|int
name|xs_read_reply
parameter_list|(
name|enum
name|xsd_sockmsg_type
modifier|*
name|type
parameter_list|,
name|u_int
modifier|*
name|len
parameter_list|,
name|void
modifier|*
modifier|*
name|result
parameter_list|)
block|{
name|struct
name|xs_stored_msg
modifier|*
name|msg
decl_stmt|;
name|char
modifier|*
name|body
decl_stmt|;
name|int
name|error
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|xs
operator|.
name|reply_lock
argument_list|)
expr_stmt|;
while|while
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|xs
operator|.
name|reply_list
argument_list|)
condition|)
block|{
name|error
operator|=
name|mtx_sleep
argument_list|(
operator|&
name|xs
operator|.
name|reply_list
argument_list|,
operator|&
name|xs
operator|.
name|reply_lock
argument_list|,
name|PCATCH
argument_list|,
literal|"xswait"
argument_list|,
name|hz
operator|/
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|&&
name|error
operator|!=
name|EWOULDBLOCK
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|xs
operator|.
name|reply_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
name|msg
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|xs
operator|.
name|reply_list
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|xs
operator|.
name|reply_list
argument_list|,
name|msg
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|xs
operator|.
name|reply_lock
argument_list|)
expr_stmt|;
operator|*
name|type
operator|=
name|msg
operator|->
name|hdr
operator|.
name|type
expr_stmt|;
if|if
condition|(
name|len
condition|)
operator|*
name|len
operator|=
name|msg
operator|->
name|hdr
operator|.
name|len
expr_stmt|;
name|body
operator|=
name|msg
operator|->
name|u
operator|.
name|reply
operator|.
name|body
expr_stmt|;
name|free
argument_list|(
name|msg
argument_list|,
name|M_XENSTORE
argument_list|)
expr_stmt|;
operator|*
name|result
operator|=
name|body
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Pass-thru interface for XenStore access by userland processes  * via the XenStore device.  *  * Reply type and length data are returned by overwriting these  * fields in the passed in request message.  *  * \param msg	  A properly formatted message to transmit to  *		  the XenStore service.  * \param result  The returned body of the reply.  *  * \return  0 on success.  Otherwise an errno indicating the cause  *          of failure.  *  * \note The returned result is provided in malloced storage and thus  *       must be free'd by the caller with 'free(result, M_XENSTORE);  */
end_comment

begin_function
name|int
name|xs_dev_request_and_reply
parameter_list|(
name|struct
name|xsd_sockmsg
modifier|*
name|msg
parameter_list|,
name|void
modifier|*
modifier|*
name|result
parameter_list|)
block|{
name|uint32_t
name|request_type
decl_stmt|;
name|int
name|error
decl_stmt|;
name|request_type
operator|=
name|msg
operator|->
name|type
expr_stmt|;
name|xs_request_filter
argument_list|(
name|request_type
argument_list|)
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|xs
operator|.
name|request_mutex
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xs_write_store
argument_list|(
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|msg
argument_list|)
operator|+
name|msg
operator|->
name|len
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|error
operator|=
name|xs_read_reply
argument_list|(
operator|&
name|msg
operator|->
name|type
argument_list|,
operator|&
name|msg
operator|->
name|len
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|xs
operator|.
name|request_mutex
argument_list|)
expr_stmt|;
name|xs_reply_filter
argument_list|(
name|request_type
argument_list|,
name|msg
operator|->
name|type
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Send a message with an optionally muti-part body to the XenStore service.  *  * \param t              The transaction to use for this request.  * \param request_type   The type of message to send.  * \param iovec          Pointers to the body sections of the request.  * \param num_vecs       The number of body sections in the request.  * \param len            The returned length of the reply.  * \param result         The returned body of the reply.  *  * \return  0 on success.  Otherwise an errno indicating  *          the cause of failure.  *  * \note The returned result is provided in malloced storage and thus  *       must be free'd by the caller with 'free(*result, M_XENSTORE);  */
end_comment

begin_function
specifier|static
name|int
name|xs_talkv
parameter_list|(
name|struct
name|xs_transaction
name|t
parameter_list|,
name|enum
name|xsd_sockmsg_type
name|request_type
parameter_list|,
specifier|const
name|struct
name|iovec
modifier|*
name|iovec
parameter_list|,
name|u_int
name|num_vecs
parameter_list|,
name|u_int
modifier|*
name|len
parameter_list|,
name|void
modifier|*
modifier|*
name|result
parameter_list|)
block|{
name|struct
name|xsd_sockmsg
name|msg
decl_stmt|;
name|void
modifier|*
name|ret
init|=
name|NULL
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|int
name|error
decl_stmt|;
name|msg
operator|.
name|tx_id
operator|=
name|t
operator|.
name|id
expr_stmt|;
name|msg
operator|.
name|req_id
operator|=
literal|0
expr_stmt|;
name|msg
operator|.
name|type
operator|=
name|request_type
expr_stmt|;
name|msg
operator|.
name|len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_vecs
condition|;
name|i
operator|++
control|)
name|msg
operator|.
name|len
operator|+=
name|iovec
index|[
name|i
index|]
operator|.
name|iov_len
expr_stmt|;
name|xs_request_filter
argument_list|(
name|request_type
argument_list|)
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|xs
operator|.
name|request_mutex
argument_list|)
expr_stmt|;
name|error
operator|=
name|xs_write_store
argument_list|(
operator|&
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|printf
argument_list|(
literal|"xs_talkv failed %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|error_lock_held
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_vecs
condition|;
name|i
operator|++
control|)
block|{
name|error
operator|=
name|xs_write_store
argument_list|(
name|iovec
index|[
name|i
index|]
operator|.
name|iov_base
argument_list|,
name|iovec
index|[
name|i
index|]
operator|.
name|iov_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|printf
argument_list|(
literal|"xs_talkv failed %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|error_lock_held
goto|;
block|}
block|}
name|error
operator|=
name|xs_read_reply
argument_list|(
operator|&
name|msg
operator|.
name|type
argument_list|,
name|len
argument_list|,
operator|&
name|ret
argument_list|)
expr_stmt|;
name|error_lock_held
label|:
name|sx_xunlock
argument_list|(
operator|&
name|xs
operator|.
name|request_mutex
argument_list|)
expr_stmt|;
name|xs_reply_filter
argument_list|(
name|request_type
argument_list|,
name|msg
operator|.
name|type
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|msg
operator|.
name|type
operator|==
name|XS_ERROR
condition|)
block|{
name|error
operator|=
name|xs_get_error
argument_list|(
name|ret
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ret
argument_list|,
name|M_XENSTORE
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* Reply is either error or an echo of our request message type. */
name|KASSERT
argument_list|(
name|msg
operator|.
name|type
operator|==
name|request_type
argument_list|,
operator|(
literal|"bad xenstore message type"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
operator|*
name|result
operator|=
name|ret
expr_stmt|;
else|else
name|free
argument_list|(
name|ret
argument_list|,
name|M_XENSTORE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Wrapper for xs_talkv allowing easy transmission of a message with  * a single, contiguous, message body.  *  * \param t              The transaction to use for this request.  * \param request_type   The type of message to send.  * \param body           The body of the request.  * \param len            The returned length of the reply.  * \param result         The returned body of the reply.  *  * \return  0 on success.  Otherwise an errno indicating  *          the cause of failure.  *  * \note The returned result is provided in malloced storage and thus  *       must be free'd by the caller with 'free(*result, M_XENSTORE);  */
end_comment

begin_function
specifier|static
name|int
name|xs_single
parameter_list|(
name|struct
name|xs_transaction
name|t
parameter_list|,
name|enum
name|xsd_sockmsg_type
name|request_type
parameter_list|,
specifier|const
name|char
modifier|*
name|body
parameter_list|,
name|u_int
modifier|*
name|len
parameter_list|,
name|void
modifier|*
modifier|*
name|result
parameter_list|)
block|{
name|struct
name|iovec
name|iovec
decl_stmt|;
name|iovec
operator|.
name|iov_base
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|body
expr_stmt|;
name|iovec
operator|.
name|iov_len
operator|=
name|strlen
argument_list|(
name|body
argument_list|)
operator|+
literal|1
expr_stmt|;
return|return
operator|(
name|xs_talkv
argument_list|(
name|t
argument_list|,
name|request_type
argument_list|,
operator|&
name|iovec
argument_list|,
literal|1
argument_list|,
name|len
argument_list|,
name|result
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------- XenStore Watch Support ---------------------------*/
end_comment

begin_comment
comment|/**  * Transmit a watch request to the XenStore service.  *  * \param path    The path in the XenStore to watch.  * \param tocken  A unique identifier for this watch.  *  * \return  0 on success.  Otherwise an errno indicating the  *          cause of failure.  */
end_comment

begin_function
specifier|static
name|int
name|xs_watch
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|token
parameter_list|)
block|{
name|struct
name|iovec
name|iov
index|[
literal|2
index|]
decl_stmt|;
name|iov
index|[
literal|0
index|]
operator|.
name|iov_base
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|path
expr_stmt|;
name|iov
index|[
literal|0
index|]
operator|.
name|iov_len
operator|=
name|strlen
argument_list|(
name|path
argument_list|)
operator|+
literal|1
expr_stmt|;
name|iov
index|[
literal|1
index|]
operator|.
name|iov_base
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|token
expr_stmt|;
name|iov
index|[
literal|1
index|]
operator|.
name|iov_len
operator|=
name|strlen
argument_list|(
name|token
argument_list|)
operator|+
literal|1
expr_stmt|;
return|return
operator|(
name|xs_talkv
argument_list|(
name|XST_NIL
argument_list|,
name|XS_WATCH
argument_list|,
name|iov
argument_list|,
literal|2
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Transmit an uwatch request to the XenStore service.  *  * \param path    The path in the XenStore to watch.  * \param tocken  A unique identifier for this watch.  *  * \return  0 on success.  Otherwise an errno indicating the  *          cause of failure.  */
end_comment

begin_function
specifier|static
name|int
name|xs_unwatch
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|token
parameter_list|)
block|{
name|struct
name|iovec
name|iov
index|[
literal|2
index|]
decl_stmt|;
name|iov
index|[
literal|0
index|]
operator|.
name|iov_base
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|path
expr_stmt|;
name|iov
index|[
literal|0
index|]
operator|.
name|iov_len
operator|=
name|strlen
argument_list|(
name|path
argument_list|)
operator|+
literal|1
expr_stmt|;
name|iov
index|[
literal|1
index|]
operator|.
name|iov_base
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|token
expr_stmt|;
name|iov
index|[
literal|1
index|]
operator|.
name|iov_len
operator|=
name|strlen
argument_list|(
name|token
argument_list|)
operator|+
literal|1
expr_stmt|;
return|return
operator|(
name|xs_talkv
argument_list|(
name|XST_NIL
argument_list|,
name|XS_UNWATCH
argument_list|,
name|iov
argument_list|,
literal|2
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Convert from watch token (unique identifier) to the associated  * internal tracking structure for this watch.  *  * \param tocken  The unique identifier for the watch to find.  *  * \return  A pointer to the found watch structure or NULL.  */
end_comment

begin_function
specifier|static
name|struct
name|xs_watch
modifier|*
name|find_watch
parameter_list|(
specifier|const
name|char
modifier|*
name|token
parameter_list|)
block|{
name|struct
name|xs_watch
modifier|*
name|i
decl_stmt|,
modifier|*
name|cmp
decl_stmt|;
name|cmp
operator|=
operator|(
name|void
operator|*
operator|)
name|strtoul
argument_list|(
name|token
argument_list|,
name|NULL
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|i
argument_list|,
argument|&xs.registered_watches
argument_list|,
argument|list
argument_list|)
if|if
condition|(
name|i
operator|==
name|cmp
condition|)
return|return
operator|(
name|i
operator|)
return|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Thread body of the XenStore watch event dispatch thread.  */
end_comment

begin_function
specifier|static
name|void
name|xenwatch_thread
parameter_list|(
name|void
modifier|*
name|unused
parameter_list|)
block|{
name|struct
name|xs_stored_msg
modifier|*
name|msg
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|xs
operator|.
name|watch_events_lock
argument_list|)
expr_stmt|;
while|while
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|xs
operator|.
name|watch_events
argument_list|)
condition|)
name|mtx_sleep
argument_list|(
operator|&
name|xs
operator|.
name|watch_events
argument_list|,
operator|&
name|xs
operator|.
name|watch_events_lock
argument_list|,
name|PWAIT
operator||
name|PCATCH
argument_list|,
literal|"waitev"
argument_list|,
name|hz
operator|/
literal|10
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|xs
operator|.
name|watch_events_lock
argument_list|)
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|xs
operator|.
name|xenwatch_mutex
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|xs
operator|.
name|watch_events_lock
argument_list|)
expr_stmt|;
name|msg
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|xs
operator|.
name|watch_events
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
condition|)
name|TAILQ_REMOVE
argument_list|(
operator|&
name|xs
operator|.
name|watch_events
argument_list|,
name|msg
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|xs
operator|.
name|watch_events_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * XXX There are messages coming in with a NULL 			 * XXX callback.  This deserves further investigation; 			 * XXX the workaround here simply prevents the kernel 			 * XXX from panic'ing on startup. 			 */
if|if
condition|(
name|msg
operator|->
name|u
operator|.
name|watch
operator|.
name|handle
operator|->
name|callback
operator|!=
name|NULL
condition|)
name|msg
operator|->
name|u
operator|.
name|watch
operator|.
name|handle
operator|->
name|callback
argument_list|(
name|msg
operator|->
name|u
operator|.
name|watch
operator|.
name|handle
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|msg
operator|->
name|u
operator|.
name|watch
operator|.
name|vec
argument_list|,
name|msg
operator|->
name|u
operator|.
name|watch
operator|.
name|vec_size
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|msg
operator|->
name|u
operator|.
name|watch
operator|.
name|vec
argument_list|,
name|M_XENSTORE
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|msg
argument_list|,
name|M_XENSTORE
argument_list|)
expr_stmt|;
block|}
name|sx_xunlock
argument_list|(
operator|&
name|xs
operator|.
name|xenwatch_mutex
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*----------- XenStore Configuration, Initialization, and Control ------------*/
end_comment

begin_comment
comment|/**  * Setup communication channels with the XenStore service.  *  * \return  On success, 0. Otherwise an errno value indicating the  *          type of failure.  */
end_comment

begin_function
specifier|static
name|int
name|xs_init_comms
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
if|if
condition|(
name|xen_store
operator|->
name|rsp_prod
operator|!=
name|xen_store
operator|->
name|rsp_cons
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"XENSTORE response ring is not quiescent "
literal|"(%08x:%08x): fixing up\n"
argument_list|,
name|xen_store
operator|->
name|rsp_cons
argument_list|,
name|xen_store
operator|->
name|rsp_prod
argument_list|)
expr_stmt|;
name|xen_store
operator|->
name|rsp_cons
operator|=
name|xen_store
operator|->
name|rsp_prod
expr_stmt|;
block|}
name|xen_intr_unbind
argument_list|(
operator|&
name|xs
operator|.
name|xen_intr_handle
argument_list|)
expr_stmt|;
name|error
operator|=
name|xen_intr_bind_local_port
argument_list|(
name|xs
operator|.
name|xs_dev
argument_list|,
name|xs
operator|.
name|evtchn
argument_list|,
comment|/*filter*/
name|NULL
argument_list|,
name|xs_intr
argument_list|,
comment|/*arg*/
name|NULL
argument_list|,
name|INTR_TYPE_NET
operator||
name|INTR_MPSAFE
argument_list|,
operator|&
name|xs
operator|.
name|xen_intr_handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"XENSTORE request irq failed %i\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------ Private Device Attachment Functions  --------------------*/
end_comment

begin_function
specifier|static
name|void
name|xs_identify
parameter_list|(
name|driver_t
modifier|*
name|driver
parameter_list|,
name|device_t
name|parent
parameter_list|)
block|{
name|BUS_ADD_CHILD
argument_list|(
name|parent
argument_list|,
literal|0
argument_list|,
literal|"xenstore"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Probe for the existance of the XenStore.  *  * \param dev  */
end_comment

begin_function
specifier|static
name|int
name|xs_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
comment|/* 	 * We are either operating within a PV kernel or being probed 	 * as the child of the successfully attached xenpci device. 	 * Thus we are in a Xen environment and there will be a XenStore. 	 * Unconditionally return success. 	 */
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"XenStore"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xs_attach_deferred
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|xs_dev_init
argument_list|()
expr_stmt|;
name|bus_generic_probe
argument_list|(
name|xs
operator|.
name|xs_dev
argument_list|)
expr_stmt|;
name|bus_generic_attach
argument_list|(
name|xs
operator|.
name|xs_dev
argument_list|)
expr_stmt|;
name|config_intrhook_disestablish
argument_list|(
operator|&
name|xs
operator|.
name|xs_attachcb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xs_attach_late
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|KASSERT
argument_list|(
operator|(
name|pending
operator|==
literal|1
operator|)
argument_list|,
operator|(
literal|"xs late attach queued several times"
operator|)
argument_list|)
expr_stmt|;
name|bus_generic_probe
argument_list|(
name|xs
operator|.
name|xs_dev
argument_list|)
expr_stmt|;
name|bus_generic_attach
argument_list|(
name|xs
operator|.
name|xs_dev
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Attach to the XenStore.  *  * This routine also prepares for the probe/attach of drivers that rely  * on the XenStore.    */
end_comment

begin_function
specifier|static
name|int
name|xs_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
comment|/* Allow us to get device_t from softc and vice-versa. */
name|xs
operator|.
name|xs_dev
operator|=
name|dev
expr_stmt|;
name|device_set_softc
argument_list|(
name|dev
argument_list|,
operator|&
name|xs
argument_list|)
expr_stmt|;
comment|/* Initialize the interface to xenstore. */
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|xs
operator|.
name|initialized
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|xen_hvm_domain
argument_list|()
condition|)
block|{
name|xs
operator|.
name|evtchn
operator|=
name|hvm_get_parameter
argument_list|(
name|HVM_PARAM_STORE_EVTCHN
argument_list|)
expr_stmt|;
name|xs
operator|.
name|gpfn
operator|=
name|hvm_get_parameter
argument_list|(
name|HVM_PARAM_STORE_PFN
argument_list|)
expr_stmt|;
name|xen_store
operator|=
name|pmap_mapdev
argument_list|(
name|xs
operator|.
name|gpfn
operator|*
name|PAGE_SIZE
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|xs
operator|.
name|initialized
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|xen_pv_domain
argument_list|()
condition|)
block|{
if|if
condition|(
name|HYPERVISOR_start_info
operator|->
name|store_evtchn
operator|==
literal|0
condition|)
block|{
name|struct
name|evtchn_alloc_unbound
name|alloc_unbound
decl_stmt|;
comment|/* Allocate a local event channel for xenstore */
name|alloc_unbound
operator|.
name|dom
operator|=
name|DOMID_SELF
expr_stmt|;
name|alloc_unbound
operator|.
name|remote_dom
operator|=
name|DOMID_SELF
expr_stmt|;
name|error
operator|=
name|HYPERVISOR_event_channel_op
argument_list|(
name|EVTCHNOP_alloc_unbound
argument_list|,
operator|&
name|alloc_unbound
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"unable to alloc event channel for Dom0: %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|HYPERVISOR_start_info
operator|->
name|store_evtchn
operator|=
name|alloc_unbound
operator|.
name|port
expr_stmt|;
name|xs
operator|.
name|evtchn
operator|=
name|alloc_unbound
operator|.
name|port
expr_stmt|;
comment|/* Allocate memory for the xs shared ring */
name|xen_store
operator|=
name|malloc
argument_list|(
name|PAGE_SIZE
argument_list|,
name|M_XENSTORE
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|xs
operator|.
name|evtchn
operator|=
name|HYPERVISOR_start_info
operator|->
name|store_evtchn
expr_stmt|;
name|xs
operator|.
name|initialized
operator|=
name|true
expr_stmt|;
block|}
block|}
else|else
block|{
name|panic
argument_list|(
literal|"Unknown domain type, cannot initialize xenstore."
argument_list|)
expr_stmt|;
block|}
name|TAILQ_INIT
argument_list|(
operator|&
name|xs
operator|.
name|reply_list
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|xs
operator|.
name|watch_events
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|xs
operator|.
name|ring_lock
argument_list|,
literal|"ring lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|xs
operator|.
name|reply_lock
argument_list|,
literal|"reply lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|sx_init
argument_list|(
operator|&
name|xs
operator|.
name|xenwatch_mutex
argument_list|,
literal|"xenwatch"
argument_list|)
expr_stmt|;
name|sx_init
argument_list|(
operator|&
name|xs
operator|.
name|request_mutex
argument_list|,
literal|"xenstore request"
argument_list|)
expr_stmt|;
name|sx_init
argument_list|(
operator|&
name|xs
operator|.
name|suspend_mutex
argument_list|,
literal|"xenstore suspend"
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|xs
operator|.
name|registered_watches_lock
argument_list|,
literal|"watches"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|xs
operator|.
name|watch_events_lock
argument_list|,
literal|"watch events"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
comment|/* Initialize the shared memory rings to talk to xenstored */
name|error
operator|=
name|xs_init_comms
argument_list|()
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|kproc_create
argument_list|(
name|xenwatch_thread
argument_list|,
name|NULL
argument_list|,
operator|&
name|p
argument_list|,
name|RFHIGHPID
argument_list|,
literal|0
argument_list|,
literal|"xenwatch"
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|xs
operator|.
name|xenwatch_pid
operator|=
name|p
operator|->
name|p_pid
expr_stmt|;
name|error
operator|=
name|kproc_create
argument_list|(
name|xs_rcv_thread
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|RFHIGHPID
argument_list|,
literal|0
argument_list|,
literal|"xenstore_rcv"
argument_list|)
expr_stmt|;
name|xs
operator|.
name|xs_attachcb
operator|.
name|ich_func
operator|=
name|xs_attach_deferred
expr_stmt|;
name|xs
operator|.
name|xs_attachcb
operator|.
name|ich_arg
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|xs
operator|.
name|initialized
condition|)
block|{
name|config_intrhook_establish
argument_list|(
operator|&
name|xs
operator|.
name|xs_attachcb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TASK_INIT
argument_list|(
operator|&
name|xs
operator|.
name|xs_late_init
argument_list|,
literal|0
argument_list|,
name|xs_attach_late
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Prepare for suspension of this VM by halting XenStore access after  * all transactions and individual requests have completed.  */
end_comment

begin_function
specifier|static
name|int
name|xs_suspend
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
comment|/* Suspend child Xen devices. */
name|error
operator|=
name|bus_generic_suspend
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|sx_xlock
argument_list|(
operator|&
name|xs
operator|.
name|suspend_mutex
argument_list|)
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|xs
operator|.
name|request_mutex
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Resume XenStore operations after this VM is resumed.  */
end_comment

begin_function
specifier|static
name|int
name|xs_resume
parameter_list|(
name|device_t
name|dev
name|__unused
parameter_list|)
block|{
name|struct
name|xs_watch
modifier|*
name|watch
decl_stmt|;
name|char
name|token
index|[
sizeof|sizeof
argument_list|(
name|watch
argument_list|)
operator|*
literal|2
operator|+
literal|1
index|]
decl_stmt|;
name|xs_init_comms
argument_list|()
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|xs
operator|.
name|request_mutex
argument_list|)
expr_stmt|;
comment|/* 	 * No need for registered_watches_lock: the suspend_mutex 	 * is sufficient. 	 */
name|LIST_FOREACH
argument_list|(
argument|watch
argument_list|,
argument|&xs.registered_watches
argument_list|,
argument|list
argument_list|)
block|{
name|sprintf
argument_list|(
name|token
argument_list|,
literal|"%lX"
argument_list|,
operator|(
name|long
operator|)
name|watch
argument_list|)
expr_stmt|;
name|xs_watch
argument_list|(
name|watch
operator|->
name|node
argument_list|,
name|token
argument_list|)
expr_stmt|;
block|}
name|sx_xunlock
argument_list|(
operator|&
name|xs
operator|.
name|suspend_mutex
argument_list|)
expr_stmt|;
comment|/* Resume child Xen devices. */
name|bus_generic_resume
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-------------------- Private Device Attachment Data  -----------------------*/
end_comment

begin_decl_stmt
specifier|static
name|device_method_t
name|xenstore_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_identify
argument_list|,
name|xs_identify
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|xs_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|xs_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|bus_generic_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|bus_generic_shutdown
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|xs_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|xs_resume
argument_list|)
block|,
comment|/* Bus interface */
name|DEVMETHOD
argument_list|(
name|bus_add_child
argument_list|,
name|bus_generic_add_child
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_alloc_resource
argument_list|,
name|bus_generic_alloc_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_release_resource
argument_list|,
name|bus_generic_release_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_activate_resource
argument_list|,
name|bus_generic_activate_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_deactivate_resource
argument_list|,
name|bus_generic_deactivate_resource
argument_list|)
block|,
name|DEVMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DEFINE_CLASS_0
argument_list|(
name|xenstore
argument_list|,
name|xenstore_driver
argument_list|,
name|xenstore_methods
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|xenstore_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|xenstore
argument_list|,
name|xenpv
argument_list|,
name|xenstore_driver
argument_list|,
name|xenstore_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*------------------------------- Sysctl Data --------------------------------*/
end_comment

begin_comment
comment|/* XXX Shouldn't the node be somewhere else? */
end_comment

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_dev
argument_list|,
name|OID_AUTO
argument_list|,
name|xen
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"Xen"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_dev_xen
argument_list|,
name|OID_AUTO
argument_list|,
name|xsd_port
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|xs
operator|.
name|evtchn
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_ULONG
argument_list|(
name|_dev_xen
argument_list|,
name|OID_AUTO
argument_list|,
name|xsd_kva
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|(
name|u_long
operator|*
operator|)
operator|&
name|xen_store
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*-------------------------------- Public API --------------------------------*/
end_comment

begin_comment
comment|/*------- API comments for these methods can be found in xenstorevar.h -------*/
end_comment

begin_function
name|int
name|xs_directory
parameter_list|(
name|struct
name|xs_transaction
name|t
parameter_list|,
specifier|const
name|char
modifier|*
name|dir
parameter_list|,
specifier|const
name|char
modifier|*
name|node
parameter_list|,
name|u_int
modifier|*
name|num
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
modifier|*
name|result
parameter_list|)
block|{
name|struct
name|sbuf
modifier|*
name|path
decl_stmt|;
name|char
modifier|*
name|strings
decl_stmt|;
name|u_int
name|len
init|=
literal|0
decl_stmt|;
name|int
name|error
decl_stmt|;
name|path
operator|=
name|xs_join
argument_list|(
name|dir
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|error
operator|=
name|xs_single
argument_list|(
name|t
argument_list|,
name|XS_DIRECTORY
argument_list|,
name|sbuf_data
argument_list|(
name|path
argument_list|)
argument_list|,
operator|&
name|len
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|strings
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
operator|*
name|result
operator|=
name|split
argument_list|(
name|strings
argument_list|,
name|len
argument_list|,
name|num
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|xs_exists
parameter_list|(
name|struct
name|xs_transaction
name|t
parameter_list|,
specifier|const
name|char
modifier|*
name|dir
parameter_list|,
specifier|const
name|char
modifier|*
name|node
parameter_list|)
block|{
specifier|const
name|char
modifier|*
modifier|*
name|d
decl_stmt|;
name|int
name|error
decl_stmt|,
name|dir_n
decl_stmt|;
name|error
operator|=
name|xs_directory
argument_list|(
name|t
argument_list|,
name|dir
argument_list|,
name|node
argument_list|,
operator|&
name|dir_n
argument_list|,
operator|&
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|free
argument_list|(
name|d
argument_list|,
name|M_XENSTORE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|xs_read
parameter_list|(
name|struct
name|xs_transaction
name|t
parameter_list|,
specifier|const
name|char
modifier|*
name|dir
parameter_list|,
specifier|const
name|char
modifier|*
name|node
parameter_list|,
name|u_int
modifier|*
name|len
parameter_list|,
name|void
modifier|*
modifier|*
name|result
parameter_list|)
block|{
name|struct
name|sbuf
modifier|*
name|path
decl_stmt|;
name|void
modifier|*
name|ret
decl_stmt|;
name|int
name|error
decl_stmt|;
name|path
operator|=
name|xs_join
argument_list|(
name|dir
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|error
operator|=
name|xs_single
argument_list|(
name|t
argument_list|,
name|XS_READ
argument_list|,
name|sbuf_data
argument_list|(
name|path
argument_list|)
argument_list|,
name|len
argument_list|,
operator|&
name|ret
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
operator|*
name|result
operator|=
name|ret
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|xs_write
parameter_list|(
name|struct
name|xs_transaction
name|t
parameter_list|,
specifier|const
name|char
modifier|*
name|dir
parameter_list|,
specifier|const
name|char
modifier|*
name|node
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
name|struct
name|sbuf
modifier|*
name|path
decl_stmt|;
name|struct
name|iovec
name|iovec
index|[
literal|2
index|]
decl_stmt|;
name|int
name|error
decl_stmt|;
name|path
operator|=
name|xs_join
argument_list|(
name|dir
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|iovec
index|[
literal|0
index|]
operator|.
name|iov_base
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|sbuf_data
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|iovec
index|[
literal|0
index|]
operator|.
name|iov_len
operator|=
name|sbuf_len
argument_list|(
name|path
argument_list|)
operator|+
literal|1
expr_stmt|;
name|iovec
index|[
literal|1
index|]
operator|.
name|iov_base
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|string
expr_stmt|;
name|iovec
index|[
literal|1
index|]
operator|.
name|iov_len
operator|=
name|strlen
argument_list|(
name|string
argument_list|)
expr_stmt|;
name|error
operator|=
name|xs_talkv
argument_list|(
name|t
argument_list|,
name|XS_WRITE
argument_list|,
name|iovec
argument_list|,
literal|2
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|path
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|xs_mkdir
parameter_list|(
name|struct
name|xs_transaction
name|t
parameter_list|,
specifier|const
name|char
modifier|*
name|dir
parameter_list|,
specifier|const
name|char
modifier|*
name|node
parameter_list|)
block|{
name|struct
name|sbuf
modifier|*
name|path
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|path
operator|=
name|xs_join
argument_list|(
name|dir
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|ret
operator|=
name|xs_single
argument_list|(
name|t
argument_list|,
name|XS_MKDIR
argument_list|,
name|sbuf_data
argument_list|(
name|path
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|path
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|int
name|xs_rm
parameter_list|(
name|struct
name|xs_transaction
name|t
parameter_list|,
specifier|const
name|char
modifier|*
name|dir
parameter_list|,
specifier|const
name|char
modifier|*
name|node
parameter_list|)
block|{
name|struct
name|sbuf
modifier|*
name|path
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|path
operator|=
name|xs_join
argument_list|(
name|dir
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|ret
operator|=
name|xs_single
argument_list|(
name|t
argument_list|,
name|XS_RM
argument_list|,
name|sbuf_data
argument_list|(
name|path
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|path
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|int
name|xs_rm_tree
parameter_list|(
name|struct
name|xs_transaction
name|xbt
parameter_list|,
specifier|const
name|char
modifier|*
name|base
parameter_list|,
specifier|const
name|char
modifier|*
name|node
parameter_list|)
block|{
name|struct
name|xs_transaction
name|local_xbt
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|root_path_sbuf
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|cur_path_sbuf
decl_stmt|;
name|char
modifier|*
name|root_path
decl_stmt|;
name|char
modifier|*
name|cur_path
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|dir
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|empty
decl_stmt|;
name|retry
label|:
name|root_path_sbuf
operator|=
name|xs_join
argument_list|(
name|base
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|cur_path_sbuf
operator|=
name|xs_join
argument_list|(
name|base
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|root_path
operator|=
name|sbuf_data
argument_list|(
name|root_path_sbuf
argument_list|)
expr_stmt|;
name|cur_path
operator|=
name|sbuf_data
argument_list|(
name|cur_path_sbuf
argument_list|)
expr_stmt|;
name|dir
operator|=
name|NULL
expr_stmt|;
name|local_xbt
operator|.
name|id
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|xbt
operator|.
name|id
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|xs_transaction_start
argument_list|(
operator|&
name|local_xbt
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
name|xbt
operator|=
name|local_xbt
expr_stmt|;
block|}
name|empty
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|u_int
name|count
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|error
operator|=
name|xs_directory
argument_list|(
name|xbt
argument_list|,
name|cur_path
argument_list|,
literal|""
argument_list|,
operator|&
name|count
argument_list|,
operator|&
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|error
operator|=
name|xs_rm
argument_list|(
name|xbt
argument_list|,
name|cur_path
argument_list|,
name|dir
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENOTEMPTY
condition|)
block|{
name|struct
name|sbuf
modifier|*
name|push_dir
decl_stmt|;
comment|/* 				 * Descend to clear out this sub directory. 				 * We'll return to cur_dir once push_dir 				 * is empty. 				 */
name|push_dir
operator|=
name|xs_join
argument_list|(
name|cur_path
argument_list|,
name|dir
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|cur_path_sbuf
argument_list|)
expr_stmt|;
name|cur_path_sbuf
operator|=
name|push_dir
expr_stmt|;
name|cur_path
operator|=
name|sbuf_data
argument_list|(
name|cur_path_sbuf
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
goto|goto
name|out
goto|;
block|}
block|}
name|free
argument_list|(
name|dir
argument_list|,
name|M_XENSTORE
argument_list|)
expr_stmt|;
name|dir
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|count
condition|)
block|{
name|char
modifier|*
name|last_slash
decl_stmt|;
comment|/* Directory is empty.  It is now safe to remove. */
name|error
operator|=
name|xs_rm
argument_list|(
name|xbt
argument_list|,
name|cur_path
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|cur_path
argument_list|,
name|root_path
argument_list|)
condition|)
break|break;
comment|/* Return to processing the parent directory. */
name|last_slash
operator|=
name|strrchr
argument_list|(
name|cur_path
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|last_slash
operator|!=
name|NULL
argument_list|,
operator|(
literal|"xs_rm_tree: mangled path %s"
operator|,
name|cur_path
operator|)
argument_list|)
expr_stmt|;
operator|*
name|last_slash
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
name|out
label|:
name|sbuf_delete
argument_list|(
name|cur_path_sbuf
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|root_path_sbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|dir
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|dir
argument_list|,
name|M_XENSTORE
argument_list|)
expr_stmt|;
if|if
condition|(
name|local_xbt
operator|.
name|id
operator|!=
literal|0
condition|)
block|{
name|int
name|terror
decl_stmt|;
name|terror
operator|=
name|xs_transaction_end
argument_list|(
name|local_xbt
argument_list|,
comment|/*abort*/
name|error
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|xbt
operator|.
name|id
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|terror
operator|==
name|EAGAIN
operator|&&
name|error
operator|==
literal|0
condition|)
goto|goto
name|retry
goto|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|xs_transaction_start
parameter_list|(
name|struct
name|xs_transaction
modifier|*
name|t
parameter_list|)
block|{
name|char
modifier|*
name|id_str
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|xs_single
argument_list|(
name|XST_NIL
argument_list|,
name|XS_TRANSACTION_START
argument_list|,
literal|""
argument_list|,
name|NULL
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|id_str
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|t
operator|->
name|id
operator|=
name|strtoul
argument_list|(
name|id_str
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|id_str
argument_list|,
name|M_XENSTORE
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|xs_transaction_end
parameter_list|(
name|struct
name|xs_transaction
name|t
parameter_list|,
name|int
name|abort
parameter_list|)
block|{
name|char
name|abortstr
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|abort
condition|)
name|strcpy
argument_list|(
name|abortstr
argument_list|,
literal|"F"
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|abortstr
argument_list|,
literal|"T"
argument_list|)
expr_stmt|;
return|return
operator|(
name|xs_single
argument_list|(
name|t
argument_list|,
name|XS_TRANSACTION_END
argument_list|,
name|abortstr
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|xs_scanf
parameter_list|(
name|struct
name|xs_transaction
name|t
parameter_list|,
specifier|const
name|char
modifier|*
name|dir
parameter_list|,
specifier|const
name|char
modifier|*
name|node
parameter_list|,
name|int
modifier|*
name|scancountp
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|int
name|error
decl_stmt|,
name|ns
decl_stmt|;
name|char
modifier|*
name|val
decl_stmt|;
name|error
operator|=
name|xs_read
argument_list|(
name|t
argument_list|,
name|dir
argument_list|,
name|node
argument_list|,
name|NULL
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|ns
operator|=
name|vsscanf
argument_list|(
name|val
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|val
argument_list|,
name|M_XENSTORE
argument_list|)
expr_stmt|;
comment|/* Distinctive errno. */
if|if
condition|(
name|ns
operator|==
literal|0
condition|)
return|return
operator|(
name|ERANGE
operator|)
return|;
if|if
condition|(
name|scancountp
condition|)
operator|*
name|scancountp
operator|=
name|ns
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|xs_vprintf
parameter_list|(
name|struct
name|xs_transaction
name|t
parameter_list|,
specifier|const
name|char
modifier|*
name|dir
parameter_list|,
specifier|const
name|char
modifier|*
name|node
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
name|va_list
name|ap
parameter_list|)
block|{
name|struct
name|sbuf
modifier|*
name|sb
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sb
operator|=
name|sbuf_new_auto
argument_list|()
expr_stmt|;
name|sbuf_vprintf
argument_list|(
name|sb
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|sbuf_finish
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|error
operator|=
name|xs_write
argument_list|(
name|t
argument_list|,
name|dir
argument_list|,
name|node
argument_list|,
name|sbuf_data
argument_list|(
name|sb
argument_list|)
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|xs_printf
parameter_list|(
name|struct
name|xs_transaction
name|t
parameter_list|,
specifier|const
name|char
modifier|*
name|dir
parameter_list|,
specifier|const
name|char
modifier|*
name|node
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|int
name|error
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|error
operator|=
name|xs_vprintf
argument_list|(
name|t
argument_list|,
name|dir
argument_list|,
name|node
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|xs_gather
parameter_list|(
name|struct
name|xs_transaction
name|t
parameter_list|,
specifier|const
name|char
modifier|*
name|dir
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|error
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|error
operator|==
literal|0
operator|&&
operator|(
name|name
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|char
operator|*
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|fmt
init|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|char
operator|*
argument_list|)
decl_stmt|;
name|void
modifier|*
name|result
init|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|void
operator|*
argument_list|)
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|error
operator|=
name|xs_read
argument_list|(
name|t
argument_list|,
name|dir
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
if|if
condition|(
name|fmt
condition|)
block|{
if|if
condition|(
name|sscanf
argument_list|(
name|p
argument_list|,
name|fmt
argument_list|,
name|result
argument_list|)
operator|==
literal|0
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|,
name|M_XENSTORE
argument_list|)
expr_stmt|;
block|}
else|else
operator|*
operator|(
name|char
operator|*
operator|*
operator|)
name|result
operator|=
name|p
expr_stmt|;
block|}
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|xs_register_watch
parameter_list|(
name|struct
name|xs_watch
modifier|*
name|watch
parameter_list|)
block|{
comment|/* Pointer in ascii is the token. */
name|char
name|token
index|[
sizeof|sizeof
argument_list|(
name|watch
argument_list|)
operator|*
literal|2
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sprintf
argument_list|(
name|token
argument_list|,
literal|"%lX"
argument_list|,
operator|(
name|long
operator|)
name|watch
argument_list|)
expr_stmt|;
name|sx_slock
argument_list|(
operator|&
name|xs
operator|.
name|suspend_mutex
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|xs
operator|.
name|registered_watches_lock
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|find_watch
argument_list|(
name|token
argument_list|)
operator|==
name|NULL
argument_list|,
operator|(
literal|"watch already registered"
operator|)
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|xs
operator|.
name|registered_watches
argument_list|,
name|watch
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|xs
operator|.
name|registered_watches_lock
argument_list|)
expr_stmt|;
name|error
operator|=
name|xs_watch
argument_list|(
name|watch
operator|->
name|node
argument_list|,
name|token
argument_list|)
expr_stmt|;
comment|/* Ignore errors due to multiple registration. */
if|if
condition|(
name|error
operator|==
name|EEXIST
condition|)
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|xs
operator|.
name|registered_watches_lock
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|watch
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|xs
operator|.
name|registered_watches_lock
argument_list|)
expr_stmt|;
block|}
name|sx_sunlock
argument_list|(
operator|&
name|xs
operator|.
name|suspend_mutex
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|void
name|xs_unregister_watch
parameter_list|(
name|struct
name|xs_watch
modifier|*
name|watch
parameter_list|)
block|{
name|struct
name|xs_stored_msg
modifier|*
name|msg
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|char
name|token
index|[
sizeof|sizeof
argument_list|(
name|watch
argument_list|)
operator|*
literal|2
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sprintf
argument_list|(
name|token
argument_list|,
literal|"%lX"
argument_list|,
operator|(
name|long
operator|)
name|watch
argument_list|)
expr_stmt|;
name|sx_slock
argument_list|(
operator|&
name|xs
operator|.
name|suspend_mutex
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|xs
operator|.
name|registered_watches_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|find_watch
argument_list|(
name|token
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|xs
operator|.
name|registered_watches_lock
argument_list|)
expr_stmt|;
name|sx_sunlock
argument_list|(
operator|&
name|xs
operator|.
name|suspend_mutex
argument_list|)
expr_stmt|;
return|return;
block|}
name|LIST_REMOVE
argument_list|(
name|watch
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|xs
operator|.
name|registered_watches_lock
argument_list|)
expr_stmt|;
name|error
operator|=
name|xs_unwatch
argument_list|(
name|watch
operator|->
name|node
argument_list|,
name|token
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"XENSTORE Failed to release watch %s: %i\n"
argument_list|,
name|watch
operator|->
name|node
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|sx_sunlock
argument_list|(
operator|&
name|xs
operator|.
name|suspend_mutex
argument_list|)
expr_stmt|;
comment|/* Cancel pending watch events. */
name|mtx_lock
argument_list|(
operator|&
name|xs
operator|.
name|watch_events_lock
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|msg
argument_list|,
argument|&xs.watch_events
argument_list|,
argument|list
argument_list|,
argument|tmp
argument_list|)
block|{
if|if
condition|(
name|msg
operator|->
name|u
operator|.
name|watch
operator|.
name|handle
operator|!=
name|watch
condition|)
continue|continue;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|xs
operator|.
name|watch_events
argument_list|,
name|msg
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|msg
operator|->
name|u
operator|.
name|watch
operator|.
name|vec
argument_list|,
name|M_XENSTORE
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|msg
argument_list|,
name|M_XENSTORE
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|xs
operator|.
name|watch_events_lock
argument_list|)
expr_stmt|;
comment|/* Flush any currently-executing callback, unless we are it. :-) */
if|if
condition|(
name|curproc
operator|->
name|p_pid
operator|!=
name|xs
operator|.
name|xenwatch_pid
condition|)
block|{
name|sx_xlock
argument_list|(
operator|&
name|xs
operator|.
name|xenwatch_mutex
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|xs
operator|.
name|xenwatch_mutex
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

