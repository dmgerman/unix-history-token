begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2009-2011 Spectra Logic Corporation  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions, and the following disclaimer,  *    without modification.  * 2. Redistributions in binary form must reproduce at minimum a disclaimer  *    substantially similar to the "NO WARRANTY" disclaimer below  *    ("Disclaimer") and any redistribution must be conditioned upon  *    including a substantially similar Disclaimer requirement for further  *    binary redistribution.  *  * NO WARRANTY  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGES.  *  * Authors: Justin T. Gibbs     (Spectra Logic Corporation)  *          Alan Somers         (Spectra Logic Corporation)  *          John Suykerbuyk     (Spectra Logic Corporation)  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/**  * \file netback.c  *  * \brief Device driver supporting the vending of network access  * 	  from this FreeBSD domain to other domains.  */
end_comment

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_global.h"
end_include

begin_include
include|#
directive|include
file|"opt_sctp.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|700000
end_if

begin_include
include|#
directive|include
file|<netinet/tcp.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<netinet/ip_icmp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/udp.h>
end_include

begin_include
include|#
directive|include
file|<machine/in_cksum.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<machine/_inttypes.h>
end_include

begin_include
include|#
directive|include
file|<machine/xen/xen-os.h>
end_include

begin_include
include|#
directive|include
file|<machine/xen/xenvar.h>
end_include

begin_include
include|#
directive|include
file|<xen/evtchn.h>
end_include

begin_include
include|#
directive|include
file|<xen/xen_intr.h>
end_include

begin_include
include|#
directive|include
file|<xen/interface/io/netif.h>
end_include

begin_include
include|#
directive|include
file|<xen/xenbus/xenbusvar.h>
end_include

begin_comment
comment|/*--------------------------- Compile-time Tunables --------------------------*/
end_comment

begin_comment
comment|/*---------------------------------- Macros ----------------------------------*/
end_comment

begin_comment
comment|/**  * Custom malloc type for all driver allocations.  */
end_comment

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_XENNETBACK
argument_list|,
literal|"xnb"
argument_list|,
literal|"Xen Net Back Driver Data"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|XNB_SG
value|1
end_define

begin_comment
comment|/* netback driver supports feature-sg */
end_comment

begin_define
define|#
directive|define
name|XNB_GSO_TCPV4
value|1
end_define

begin_comment
comment|/* netback driver supports feature-gso-tcpv4 */
end_comment

begin_define
define|#
directive|define
name|XNB_RX_COPY
value|1
end_define

begin_comment
comment|/* netback driver supports feature-rx-copy */
end_comment

begin_define
define|#
directive|define
name|XNB_RX_FLIP
value|0
end_define

begin_comment
comment|/* netback driver does not support feature-rx-flip */
end_comment

begin_undef
undef|#
directive|undef
name|XNB_DEBUG
end_undef

begin_define
define|#
directive|define
name|XNB_DEBUG
end_define

begin_comment
comment|/* hardcode on during development */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|XNB_DEBUG
end_ifdef

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
define|\
value|printf("xnb(%s:%d): " fmt, __FUNCTION__, __LINE__, ##args)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
value|do {} while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Default length for stack-allocated grant tables */
end_comment

begin_define
define|#
directive|define
name|GNTTAB_LEN
value|(64)
end_define

begin_comment
comment|/* Features supported by all backends.  TSO and LRO can be negotiated */
end_comment

begin_define
define|#
directive|define
name|XNB_CSUM_FEATURES
value|(CSUM_TCP | CSUM_UDP)
end_define

begin_define
define|#
directive|define
name|NET_TX_RING_SIZE
value|__RING_SIZE((netif_tx_sring_t *)0, PAGE_SIZE)
end_define

begin_define
define|#
directive|define
name|NET_RX_RING_SIZE
value|__RING_SIZE((netif_rx_sring_t *)0, PAGE_SIZE)
end_define

begin_comment
comment|/**  * Two argument version of the standard macro.  Second argument is a tentative  * value of req_cons  */
end_comment

begin_define
define|#
directive|define
name|RING_HAS_UNCONSUMED_REQUESTS_2
parameter_list|(
name|_r
parameter_list|,
name|cons
parameter_list|)
value|({                     \ 	unsigned int req = (_r)->sring->req_prod - cons;          	\ 	unsigned int rsp = RING_SIZE(_r) -                              \ 	(cons - (_r)->rsp_prod_pvt);                          		\ 	req< rsp ? req : rsp;                                          \ })
end_define

begin_define
define|#
directive|define
name|virt_to_mfn
parameter_list|(
name|x
parameter_list|)
value|(vtomach(x)>> PAGE_SHIFT)
end_define

begin_define
define|#
directive|define
name|virt_to_offset
parameter_list|(
name|x
parameter_list|)
value|((x)& (PAGE_SIZE - 1))
end_define

begin_comment
comment|/**  * Predefined array type of grant table copy descriptors.  Used to pass around  * statically allocated memory structures.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|gnttab_copy
name|gnttab_copy_table
index|[
name|GNTTAB_LEN
index|]
typedef|;
end_typedef

begin_comment
comment|/*--------------------------- Forward Declarations ---------------------------*/
end_comment

begin_struct_decl
struct_decl|struct
name|xnb_softc
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|xnb_pkt
struct_decl|;
end_struct_decl

begin_function_decl
specifier|static
name|void
name|xnb_attach_failed
parameter_list|(
name|struct
name|xnb_softc
modifier|*
name|xnb
parameter_list|,
name|int
name|err
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
function_decl|__printflike
parameter_list|(
function_decl|3
operator|,
function_decl|4
end_function_decl

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_function_decl
specifier|static
name|int
name|xnb_shutdown
parameter_list|(
name|struct
name|xnb_softc
modifier|*
name|xnb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|create_netdev
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xnb_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xen_net_read_mac
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|uint8_t
name|mac
index|[]
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xnb_ifmedia_upd
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xnb_ifmedia_sts
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|ifmediareq
modifier|*
name|ifmr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xnb_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xnb_send
parameter_list|(
name|netif_rx_back_ring_t
modifier|*
name|rxb
parameter_list|,
name|domid_t
name|otherend
parameter_list|,
specifier|const
name|struct
name|mbuf
modifier|*
name|mbufc
parameter_list|,
name|gnttab_copy_table
name|gnttab
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xnb_recv
parameter_list|(
name|netif_tx_back_ring_t
modifier|*
name|txb
parameter_list|,
name|domid_t
name|otherend
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|mbufc
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifnet
parameter_list|,
name|gnttab_copy_table
name|gnttab
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xnb_ring2pkt
parameter_list|(
name|struct
name|xnb_pkt
modifier|*
name|pkt
parameter_list|,
specifier|const
name|netif_tx_back_ring_t
modifier|*
name|tx_ring
parameter_list|,
name|RING_IDX
name|start
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xnb_txpkt2rsp
parameter_list|(
specifier|const
name|struct
name|xnb_pkt
modifier|*
name|pkt
parameter_list|,
name|netif_tx_back_ring_t
modifier|*
name|ring
parameter_list|,
name|int
name|error
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|mbuf
modifier|*
name|xnb_pkt2mbufc
parameter_list|(
specifier|const
name|struct
name|xnb_pkt
modifier|*
name|pkt
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xnb_txpkt2gnttab
parameter_list|(
specifier|const
name|struct
name|xnb_pkt
modifier|*
name|pkt
parameter_list|,
specifier|const
name|struct
name|mbuf
modifier|*
name|mbufc
parameter_list|,
name|gnttab_copy_table
name|gnttab
parameter_list|,
specifier|const
name|netif_tx_back_ring_t
modifier|*
name|txb
parameter_list|,
name|domid_t
name|otherend_id
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xnb_update_mbufc
parameter_list|(
name|struct
name|mbuf
modifier|*
name|mbufc
parameter_list|,
specifier|const
name|gnttab_copy_table
name|gnttab
parameter_list|,
name|int
name|n_entries
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xnb_mbufc2pkt
parameter_list|(
specifier|const
name|struct
name|mbuf
modifier|*
name|mbufc
parameter_list|,
name|struct
name|xnb_pkt
modifier|*
name|pkt
parameter_list|,
name|RING_IDX
name|start
parameter_list|,
name|int
name|space
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xnb_rxpkt2gnttab
parameter_list|(
specifier|const
name|struct
name|xnb_pkt
modifier|*
name|pkt
parameter_list|,
specifier|const
name|struct
name|mbuf
modifier|*
name|mbufc
parameter_list|,
name|gnttab_copy_table
name|gnttab
parameter_list|,
specifier|const
name|netif_rx_back_ring_t
modifier|*
name|rxb
parameter_list|,
name|domid_t
name|otherend_id
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xnb_rxpkt2rsp
parameter_list|(
specifier|const
name|struct
name|xnb_pkt
modifier|*
name|pkt
parameter_list|,
specifier|const
name|gnttab_copy_table
name|gnttab
parameter_list|,
name|int
name|n_entries
parameter_list|,
name|netif_rx_back_ring_t
modifier|*
name|ring
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xnb_add_mbuf_cksum
parameter_list|(
name|struct
name|mbuf
modifier|*
name|mbufc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xnb_stop
parameter_list|(
name|struct
name|xnb_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xnb_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|u_long
parameter_list|,
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xnb_start_locked
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xnb_start
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xnb_ifinit_locked
parameter_list|(
name|struct
name|xnb_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xnb_ifinit
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|XNB_DEBUG
end_ifdef

begin_function_decl
specifier|static
name|int
name|xnb_unit_test_main
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xnb_dump_rings
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*------------------------------ Data Structures -----------------------------*/
end_comment

begin_comment
comment|/**  * Representation of a xennet packet.  Simplified version of a packet as  * stored in the Xen tx ring.  Applicable to both RX and TX packets  */
end_comment

begin_struct
struct|struct
name|xnb_pkt
block|{
comment|/** 	 * Array index of the first data-bearing (eg, not extra info) entry 	 * for this packet 	 */
name|RING_IDX
name|car
decl_stmt|;
comment|/** 	 * Array index of the second data-bearing entry for this packet. 	 * Invalid if the packet has only one data-bearing entry.  If the 	 * packet has more than two data-bearing entries, then the second 	 * through the last will be sequential modulo the ring size 	 */
name|RING_IDX
name|cdr
decl_stmt|;
comment|/** 	 * Optional extra info.  Only valid if flags contains 	 * NETTXF_extra_info.  Note that extra.type will always be 	 * XEN_NETIF_EXTRA_TYPE_GSO.  Currently, no known netfront or netback 	 * driver will ever set XEN_NETIF_EXTRA_TYPE_MCAST_* 	 */
name|netif_extra_info_t
name|extra
decl_stmt|;
comment|/** Size of entire packet in bytes.       */
name|uint16_t
name|size
decl_stmt|;
comment|/** The size of the first entry's data in bytes */
name|uint16_t
name|car_size
decl_stmt|;
comment|/** 	 * Either NETTXF_ or NETRXF_ flags.  Note that the flag values are 	 * not the same for TX and RX packets 	 */
name|uint16_t
name|flags
decl_stmt|;
comment|/** 	 * The number of valid data-bearing entries (either netif_tx_request's 	 * or netif_rx_response's) in the packet.  If this is 0, it means the 	 * entire packet is invalid. 	 */
name|uint16_t
name|list_len
decl_stmt|;
comment|/** There was an error processing the packet */
name|uint8_t
name|error
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/** xnb_pkt method: initialize it */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|xnb_pkt_initialize
parameter_list|(
name|struct
name|xnb_pkt
modifier|*
name|pxnb
parameter_list|)
block|{
name|bzero
argument_list|(
name|pxnb
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pxnb
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** xnb_pkt method: mark the packet as valid */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|xnb_pkt_validate
parameter_list|(
name|struct
name|xnb_pkt
modifier|*
name|pxnb
parameter_list|)
block|{
name|pxnb
operator|->
name|error
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/** xnb_pkt method: mark the packet as invalid */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|xnb_pkt_invalidate
parameter_list|(
name|struct
name|xnb_pkt
modifier|*
name|pxnb
parameter_list|)
block|{
name|pxnb
operator|->
name|error
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/** xnb_pkt method: Check whether the packet is valid */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|xnb_pkt_is_valid
parameter_list|(
specifier|const
name|struct
name|xnb_pkt
modifier|*
name|pxnb
parameter_list|)
block|{
return|return
operator|(
operator|!
name|pxnb
operator|->
name|error
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|XNB_DEBUG
end_ifdef

begin_comment
comment|/** xnb_pkt method: print the packet's contents in human-readable format*/
end_comment

begin_function
specifier|static
name|void
name|__unused
name|xnb_dump_pkt
parameter_list|(
specifier|const
name|struct
name|xnb_pkt
modifier|*
name|pkt
parameter_list|)
block|{
if|if
condition|(
name|pkt
operator|==
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"Was passed a null pointer.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|DPRINTF
argument_list|(
literal|"pkt address= %p\n"
argument_list|,
name|pkt
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"pkt->size=%d\n"
argument_list|,
name|pkt
operator|->
name|size
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"pkt->car_size=%d\n"
argument_list|,
name|pkt
operator|->
name|car_size
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"pkt->flags=0x%04x\n"
argument_list|,
name|pkt
operator|->
name|flags
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"pkt->list_len=%d\n"
argument_list|,
name|pkt
operator|->
name|list_len
argument_list|)
expr_stmt|;
comment|/* DPRINTF("pkt->extra");	TODO */
name|DPRINTF
argument_list|(
literal|"pkt->car=%d\n"
argument_list|,
name|pkt
operator|->
name|car
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"pkt->cdr=%d\n"
argument_list|,
name|pkt
operator|->
name|cdr
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"pkt->error=%d\n"
argument_list|,
name|pkt
operator|->
name|error
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* XNB_DEBUG */
end_comment

begin_function
specifier|static
name|void
name|xnb_dump_txreq
parameter_list|(
name|RING_IDX
name|idx
parameter_list|,
specifier|const
name|struct
name|netif_tx_request
modifier|*
name|txreq
parameter_list|)
block|{
if|if
condition|(
name|txreq
operator|!=
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"netif_tx_request index =%u\n"
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"netif_tx_request.gref  =%u\n"
argument_list|,
name|txreq
operator|->
name|gref
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"netif_tx_request.offset=%hu\n"
argument_list|,
name|txreq
operator|->
name|offset
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"netif_tx_request.flags =%hu\n"
argument_list|,
name|txreq
operator|->
name|flags
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"netif_tx_request.id    =%hu\n"
argument_list|,
name|txreq
operator|->
name|id
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"netif_tx_request.size  =%hu\n"
argument_list|,
name|txreq
operator|->
name|size
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * \brief Configuration data for a shared memory request ring  *        used to communicate with the front-end client of this  *        this driver.  */
end_comment

begin_struct
struct|struct
name|xnb_ring_config
block|{
comment|/** 	 * Runtime structures for ring access.  Unfortunately, TX and RX rings 	 * use different data structures, and that cannot be changed since it 	 * is part of the interdomain protocol. 	 */
union|union
block|{
name|netif_rx_back_ring_t
name|rx_ring
decl_stmt|;
name|netif_tx_back_ring_t
name|tx_ring
decl_stmt|;
block|}
name|back_ring
union|;
comment|/** 	 * The device bus address returned by the hypervisor when 	 * mapping the ring and required to unmap it when a connection 	 * is torn down. 	 */
name|uint64_t
name|bus_addr
decl_stmt|;
comment|/** The pseudo-physical address where ring memory is mapped.*/
name|uint64_t
name|gnt_addr
decl_stmt|;
comment|/** KVA address where ring memory is mapped. */
name|vm_offset_t
name|va
decl_stmt|;
comment|/** 	 * Grant table handles, one per-ring page, returned by the 	 * hyperpervisor upon mapping of the ring and required to 	 * unmap it when a connection is torn down. 	 */
name|grant_handle_t
name|handle
decl_stmt|;
comment|/** The number of ring pages mapped for the current connection. */
name|unsigned
name|ring_pages
decl_stmt|;
comment|/** 	 * The grant references, one per-ring page, supplied by the 	 * front-end, allowing us to reference the ring pages in the 	 * front-end's domain and to map these pages into our own domain. 	 */
name|grant_ref_t
name|ring_ref
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/**  * Per-instance connection state flags.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
comment|/** Communication with the front-end has been established. */
name|XNBF_RING_CONNECTED
init|=
literal|0x01
block|,
comment|/** 	 * Front-end requests exist in the ring and are waiting for 	 * xnb_xen_req objects to free up. 	 */
name|XNBF_RESOURCE_SHORTAGE
init|=
literal|0x02
block|,
comment|/** Connection teardown has started. */
name|XNBF_SHUTDOWN
init|=
literal|0x04
block|,
comment|/** A thread is already performing shutdown processing. */
name|XNBF_IN_SHUTDOWN
init|=
literal|0x08
block|}
name|xnb_flag_t
typedef|;
end_typedef

begin_comment
comment|/**  * Types of rings.  Used for array indices and to identify a ring's control  * data structure type  */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|XNB_RING_TYPE_TX
init|=
literal|0
block|,
comment|/* ID of TX rings, used for array indices */
name|XNB_RING_TYPE_RX
init|=
literal|1
block|,
comment|/* ID of RX rings, used for array indices */
name|XNB_NUM_RING_TYPES
block|}
name|xnb_ring_type_t
typedef|;
end_typedef

begin_comment
comment|/**  * Per-instance configuration data.  */
end_comment

begin_struct
struct|struct
name|xnb_softc
block|{
comment|/** NewBus device corresponding to this instance. */
name|device_t
name|dev
decl_stmt|;
comment|/* Media related fields */
comment|/** Generic network media state */
name|struct
name|ifmedia
name|sc_media
decl_stmt|;
comment|/** Media carrier info */
name|struct
name|ifnet
modifier|*
name|xnb_ifp
decl_stmt|;
comment|/** Our own private carrier state */
name|unsigned
name|carrier
decl_stmt|;
comment|/** Device MAC Address */
name|uint8_t
name|mac
index|[
name|ETHER_ADDR_LEN
index|]
decl_stmt|;
comment|/* Xen related fields */
comment|/** 	 * \brief The netif protocol abi in effect. 	 * 	 * There are situations where the back and front ends can 	 * have a different, native abi (e.g. intel x86_64 and 	 * 32bit x86 domains on the same machine).  The back-end 	 * always accomodates the front-end's native abi.  That 	 * value is pulled from the XenStore and recorded here. 	 */
name|int
name|abi
decl_stmt|;
comment|/** 	 * Name of the bridge to which this VIF is connected, if any 	 * This field is dynamically allocated by xenbus and must be free()ed 	 * when no longer needed 	 */
name|char
modifier|*
name|bridge
decl_stmt|;
comment|/** The interrupt driven even channel used to signal ring events. */
name|evtchn_port_t
name|evtchn
decl_stmt|;
comment|/** Xen device handle.*/
name|long
name|handle
decl_stmt|;
comment|/** IRQ mapping for the communication ring event channel. */
name|int
name|irq
decl_stmt|;
comment|/** 	 * \brief Cached value of the front-end's domain id. 	 * 	 * This value is used at once for each mapped page in 	 * a transaction.  We cache it to avoid incuring the 	 * cost of an ivar access every time this is needed. 	 */
name|domid_t
name|otherend_id
decl_stmt|;
comment|/** 	 * Undocumented frontend feature.  Has something to do with 	 * scatter/gather IO 	 */
name|uint8_t
name|can_sg
decl_stmt|;
comment|/** Undocumented frontend feature */
name|uint8_t
name|gso
decl_stmt|;
comment|/** Undocumented frontend feature */
name|uint8_t
name|gso_prefix
decl_stmt|;
comment|/** Can checksum TCP/UDP over IPv4 */
name|uint8_t
name|ip_csum
decl_stmt|;
comment|/* Implementation related fields */
comment|/** 	 * Preallocated grant table copy descriptor for RX operations. 	 * Access must be protected by rx_lock 	 */
name|gnttab_copy_table
name|rx_gnttab
decl_stmt|;
comment|/** 	 * Preallocated grant table copy descriptor for TX operations. 	 * Access must be protected by tx_lock 	 */
name|gnttab_copy_table
name|tx_gnttab
decl_stmt|;
ifdef|#
directive|ifdef
name|XENHVM
comment|/** 	 * Resource representing allocated physical address space 	 * associated with our per-instance kva region. 	 */
name|struct
name|resource
modifier|*
name|pseudo_phys_res
decl_stmt|;
comment|/** Resource id for allocated physical address space. */
name|int
name|pseudo_phys_res_id
decl_stmt|;
endif|#
directive|endif
comment|/** Ring mapping and interrupt configuration data. */
name|struct
name|xnb_ring_config
name|ring_configs
index|[
name|XNB_NUM_RING_TYPES
index|]
decl_stmt|;
comment|/** 	 * Global pool of kva used for mapping remote domain ring 	 * and I/O transaction data. 	 */
name|vm_offset_t
name|kva
decl_stmt|;
comment|/** Psuedo-physical address corresponding to kva. */
name|uint64_t
name|gnt_base_addr
decl_stmt|;
comment|/** Various configuration and state bit flags. */
name|xnb_flag_t
name|flags
decl_stmt|;
comment|/** Mutex protecting per-instance data in the receive path. */
name|struct
name|mtx
name|rx_lock
decl_stmt|;
comment|/** Mutex protecting per-instance data in the softc structure. */
name|struct
name|mtx
name|sc_lock
decl_stmt|;
comment|/** Mutex protecting per-instance data in the transmit path. */
name|struct
name|mtx
name|tx_lock
decl_stmt|;
comment|/** The size of the global kva pool. */
name|int
name|kva_size
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*---------------------------- Debugging functions ---------------------------*/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|XNB_DEBUG
end_ifdef

begin_function
specifier|static
name|void
name|__unused
name|xnb_dump_gnttab_copy
parameter_list|(
specifier|const
name|struct
name|gnttab_copy
modifier|*
name|entry
parameter_list|)
block|{
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"NULL grant table pointer\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|entry
operator|->
name|flags
operator|&
name|GNTCOPY_dest_gref
condition|)
name|printf
argument_list|(
literal|"gnttab dest ref=\t%u\n"
argument_list|,
name|entry
operator|->
name|dest
operator|.
name|u
operator|.
name|ref
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"gnttab dest gmfn=\t%lu\n"
argument_list|,
name|entry
operator|->
name|dest
operator|.
name|u
operator|.
name|gmfn
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"gnttab dest offset=\t%hu\n"
argument_list|,
name|entry
operator|->
name|dest
operator|.
name|offset
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"gnttab dest domid=\t%hu\n"
argument_list|,
name|entry
operator|->
name|dest
operator|.
name|domid
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|flags
operator|&
name|GNTCOPY_source_gref
condition|)
name|printf
argument_list|(
literal|"gnttab source ref=\t%u\n"
argument_list|,
name|entry
operator|->
name|source
operator|.
name|u
operator|.
name|ref
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"gnttab source gmfn=\t%lu\n"
argument_list|,
name|entry
operator|->
name|source
operator|.
name|u
operator|.
name|gmfn
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"gnttab source offset=\t%hu\n"
argument_list|,
name|entry
operator|->
name|source
operator|.
name|offset
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"gnttab source domid=\t%hu\n"
argument_list|,
name|entry
operator|->
name|source
operator|.
name|domid
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"gnttab len=\t%hu\n"
argument_list|,
name|entry
operator|->
name|len
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"gnttab flags=\t%hu\n"
argument_list|,
name|entry
operator|->
name|flags
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"gnttab status=\t%hd\n"
argument_list|,
name|entry
operator|->
name|status
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|xnb_dump_rings
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
specifier|static
name|char
name|results
index|[
literal|720
index|]
decl_stmt|;
name|struct
name|xnb_softc
specifier|const
modifier|*
name|xnb
init|=
operator|(
expr|struct
name|xnb_softc
operator|*
operator|)
name|arg1
decl_stmt|;
name|netif_rx_back_ring_t
specifier|const
modifier|*
name|rxb
init|=
operator|&
name|xnb
operator|->
name|ring_configs
index|[
name|XNB_RING_TYPE_RX
index|]
operator|.
name|back_ring
operator|.
name|rx_ring
decl_stmt|;
name|netif_tx_back_ring_t
specifier|const
modifier|*
name|txb
init|=
operator|&
name|xnb
operator|->
name|ring_configs
index|[
name|XNB_RING_TYPE_TX
index|]
operator|.
name|back_ring
operator|.
name|tx_ring
decl_stmt|;
comment|/* empty the result strings */
name|results
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|txb
operator|||
operator|!
name|txb
operator|->
name|sring
operator|||
operator|!
name|rxb
operator|||
operator|!
name|rxb
operator|->
name|sring
condition|)
return|return
operator|(
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
name|results
argument_list|,
name|strnlen
argument_list|(
name|results
argument_list|,
literal|720
argument_list|)
argument_list|)
operator|)
return|;
name|snprintf
argument_list|(
name|results
argument_list|,
literal|720
argument_list|,
literal|"\n\t%35s %18s\n"
comment|/* TX, RX */
literal|"\t%16s %18d %18d\n"
comment|/* req_cons */
literal|"\t%16s %18d %18d\n"
comment|/* nr_ents */
literal|"\t%16s %18d %18d\n"
comment|/* rsp_prod_pvt */
literal|"\t%16s %18p %18p\n"
comment|/* sring */
literal|"\t%16s %18d %18d\n"
comment|/* req_prod */
literal|"\t%16s %18d %18d\n"
comment|/* req_event */
literal|"\t%16s %18d %18d\n"
comment|/* rsp_prod */
literal|"\t%16s %18d %18d\n"
argument_list|,
comment|/* rsp_event */
literal|"TX"
argument_list|,
literal|"RX"
argument_list|,
literal|"req_cons"
argument_list|,
name|txb
operator|->
name|req_cons
argument_list|,
name|rxb
operator|->
name|req_cons
argument_list|,
literal|"nr_ents"
argument_list|,
name|txb
operator|->
name|nr_ents
argument_list|,
name|rxb
operator|->
name|nr_ents
argument_list|,
literal|"rsp_prod_pvt"
argument_list|,
name|txb
operator|->
name|rsp_prod_pvt
argument_list|,
name|rxb
operator|->
name|rsp_prod_pvt
argument_list|,
literal|"sring"
argument_list|,
name|txb
operator|->
name|sring
argument_list|,
name|rxb
operator|->
name|sring
argument_list|,
literal|"sring->req_prod"
argument_list|,
name|txb
operator|->
name|sring
operator|->
name|req_prod
argument_list|,
name|rxb
operator|->
name|sring
operator|->
name|req_prod
argument_list|,
literal|"sring->req_event"
argument_list|,
name|txb
operator|->
name|sring
operator|->
name|req_event
argument_list|,
name|rxb
operator|->
name|sring
operator|->
name|req_event
argument_list|,
literal|"sring->rsp_prod"
argument_list|,
name|txb
operator|->
name|sring
operator|->
name|rsp_prod
argument_list|,
name|rxb
operator|->
name|sring
operator|->
name|rsp_prod
argument_list|,
literal|"sring->rsp_event"
argument_list|,
name|txb
operator|->
name|sring
operator|->
name|rsp_event
argument_list|,
name|rxb
operator|->
name|sring
operator|->
name|rsp_event
argument_list|)
expr_stmt|;
return|return
operator|(
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
name|results
argument_list|,
name|strnlen
argument_list|(
name|results
argument_list|,
literal|720
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|__unused
name|xnb_dump_mbuf
parameter_list|(
specifier|const
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
name|uint8_t
modifier|*
name|d
decl_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return;
name|printf
argument_list|(
literal|"xnb_dump_mbuf:\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_PKTHDR
condition|)
block|{
name|printf
argument_list|(
literal|"    flowid=%10d, csum_flags=%#8x, csum_data=%#8x, "
literal|"tso_segsz=%5hd\n"
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|flowid
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_data
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|tso_segsz
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    rcvif=%16p,  header=%18p, len=%19d\n"
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|header
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"    m_next=%16p, m_nextpk=%16p, m_data=%16p\n"
argument_list|,
name|m
operator|->
name|m_next
argument_list|,
name|m
operator|->
name|m_nextpkt
argument_list|,
name|m
operator|->
name|m_data
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    m_len=%17d, m_flags=%#15x, m_type=%18hd\n"
argument_list|,
name|m
operator|->
name|m_len
argument_list|,
name|m
operator|->
name|m_flags
argument_list|,
name|m
operator|->
name|m_type
argument_list|)
expr_stmt|;
name|len
operator|=
name|m
operator|->
name|m_len
expr_stmt|;
name|d
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|uint8_t
operator|*
argument_list|)
expr_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"                "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
literal|16
operator|)
operator|&&
operator|(
name|len
operator|>
literal|0
operator|)
condition|;
name|i
operator|++
operator|,
name|len
operator|--
control|)
block|{
name|printf
argument_list|(
literal|"%02hhx "
argument_list|,
operator|*
operator|(
name|d
operator|++
operator|)
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* XNB_DEBUG */
end_comment

begin_comment
comment|/*------------------------ Inter-Domain Communication ------------------------*/
end_comment

begin_comment
comment|/**  * Free dynamically allocated KVA or pseudo-physical address allocations.  *  * \param xnb  Per-instance xnb configuration structure.  */
end_comment

begin_function
specifier|static
name|void
name|xnb_free_communication_mem
parameter_list|(
name|struct
name|xnb_softc
modifier|*
name|xnb
parameter_list|)
block|{
if|if
condition|(
name|xnb
operator|->
name|kva
operator|!=
literal|0
condition|)
block|{
ifndef|#
directive|ifndef
name|XENHVM
name|kmem_free
argument_list|(
name|kernel_map
argument_list|,
name|xnb
operator|->
name|kva
argument_list|,
name|xnb
operator|->
name|kva_size
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|xnb
operator|->
name|pseudo_phys_res
operator|!=
name|NULL
condition|)
block|{
name|bus_release_resource
argument_list|(
name|xnb
operator|->
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|xnb
operator|->
name|pseudo_phys_res_id
argument_list|,
name|xnb
operator|->
name|pseudo_phys_res
argument_list|)
expr_stmt|;
name|xnb
operator|->
name|pseudo_phys_res
operator|=
name|NULL
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* XENHVM */
block|}
name|xnb
operator|->
name|kva
operator|=
literal|0
expr_stmt|;
name|xnb
operator|->
name|gnt_base_addr
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Cleanup all inter-domain communication mechanisms.  *  * \param xnb  Per-instance xnb configuration structure.  */
end_comment

begin_function
specifier|static
name|int
name|xnb_disconnect
parameter_list|(
name|struct
name|xnb_softc
modifier|*
name|xnb
parameter_list|)
block|{
name|struct
name|gnttab_unmap_grant_ref
name|gnts
index|[
name|XNB_NUM_RING_TYPES
index|]
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|xnb
operator|->
name|irq
operator|!=
literal|0
condition|)
block|{
name|unbind_from_irqhandler
argument_list|(
name|xnb
operator|->
name|irq
argument_list|)
expr_stmt|;
name|xnb
operator|->
name|irq
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * We may still have another thread currently processing requests.  We 	 * must acquire the rx and tx locks to make sure those threads are done, 	 * but we can release those locks as soon as we acquire them, because no 	 * more interrupts will be arriving. 	 */
name|mtx_lock
argument_list|(
operator|&
name|xnb
operator|->
name|tx_lock
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|xnb
operator|->
name|tx_lock
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|xnb
operator|->
name|rx_lock
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|xnb
operator|->
name|rx_lock
argument_list|)
expr_stmt|;
comment|/* Free malloc'd softc member variables */
if|if
condition|(
name|xnb
operator|->
name|bridge
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|xnb
operator|->
name|bridge
argument_list|,
name|M_XENSTORE
argument_list|)
expr_stmt|;
comment|/* All request processing has stopped, so unmap the rings */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XNB_NUM_RING_TYPES
condition|;
name|i
operator|++
control|)
block|{
name|gnts
index|[
name|i
index|]
operator|.
name|host_addr
operator|=
name|xnb
operator|->
name|ring_configs
index|[
name|i
index|]
operator|.
name|gnt_addr
expr_stmt|;
name|gnts
index|[
name|i
index|]
operator|.
name|dev_bus_addr
operator|=
name|xnb
operator|->
name|ring_configs
index|[
name|i
index|]
operator|.
name|bus_addr
expr_stmt|;
name|gnts
index|[
name|i
index|]
operator|.
name|handle
operator|=
name|xnb
operator|->
name|ring_configs
index|[
name|i
index|]
operator|.
name|handle
expr_stmt|;
block|}
name|error
operator|=
name|HYPERVISOR_grant_table_op
argument_list|(
name|GNTTABOP_unmap_grant_ref
argument_list|,
name|gnts
argument_list|,
name|XNB_NUM_RING_TYPES
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|,
operator|(
literal|"Grant table unmap op failed (%d)"
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
name|xnb_free_communication_mem
argument_list|(
name|xnb
argument_list|)
expr_stmt|;
comment|/* 	 * Zero the ring config structs because the pointers, handles, and 	 * grant refs contained therein are no longer valid. 	 */
name|bzero
argument_list|(
operator|&
name|xnb
operator|->
name|ring_configs
index|[
name|XNB_RING_TYPE_TX
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|xnb_ring_config
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|xnb
operator|->
name|ring_configs
index|[
name|XNB_RING_TYPE_RX
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|xnb_ring_config
argument_list|)
argument_list|)
expr_stmt|;
name|xnb
operator|->
name|flags
operator|&=
operator|~
name|XNBF_RING_CONNECTED
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Map a single shared memory ring into domain local address space and  * initialize its control structure  *  * \param xnb	Per-instance xnb configuration structure  * \param ring_type	Array index of this ring in the xnb's array of rings  * \return 	An errno  */
end_comment

begin_function
specifier|static
name|int
name|xnb_connect_ring
parameter_list|(
name|struct
name|xnb_softc
modifier|*
name|xnb
parameter_list|,
name|xnb_ring_type_t
name|ring_type
parameter_list|)
block|{
name|struct
name|gnttab_map_grant_ref
name|gnt
decl_stmt|;
name|struct
name|xnb_ring_config
modifier|*
name|ring
init|=
operator|&
name|xnb
operator|->
name|ring_configs
index|[
name|ring_type
index|]
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* TX ring type = 0, RX =1 */
name|ring
operator|->
name|va
operator|=
name|xnb
operator|->
name|kva
operator|+
name|ring_type
operator|*
name|PAGE_SIZE
expr_stmt|;
name|ring
operator|->
name|gnt_addr
operator|=
name|xnb
operator|->
name|gnt_base_addr
operator|+
name|ring_type
operator|*
name|PAGE_SIZE
expr_stmt|;
name|gnt
operator|.
name|host_addr
operator|=
name|ring
operator|->
name|gnt_addr
expr_stmt|;
name|gnt
operator|.
name|flags
operator|=
name|GNTMAP_host_map
expr_stmt|;
name|gnt
operator|.
name|ref
operator|=
name|ring
operator|->
name|ring_ref
expr_stmt|;
name|gnt
operator|.
name|dom
operator|=
name|xnb
operator|->
name|otherend_id
expr_stmt|;
name|error
operator|=
name|HYPERVISOR_grant_table_op
argument_list|(
name|GNTTABOP_map_grant_ref
argument_list|,
operator|&
name|gnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"netback: Ring page grant table op failed (%d)"
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|gnt
operator|.
name|status
operator|!=
literal|0
condition|)
block|{
name|ring
operator|->
name|va
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|EACCES
expr_stmt|;
name|xenbus_dev_fatal
argument_list|(
name|xnb
operator|->
name|dev
argument_list|,
name|error
argument_list|,
literal|"Ring shared page mapping failed. "
literal|"Status %d."
argument_list|,
name|gnt
operator|.
name|status
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ring
operator|->
name|handle
operator|=
name|gnt
operator|.
name|handle
expr_stmt|;
name|ring
operator|->
name|bus_addr
operator|=
name|gnt
operator|.
name|dev_bus_addr
expr_stmt|;
if|if
condition|(
name|ring_type
operator|==
name|XNB_RING_TYPE_TX
condition|)
block|{
name|BACK_RING_INIT
argument_list|(
operator|&
name|ring
operator|->
name|back_ring
operator|.
name|tx_ring
argument_list|,
operator|(
name|netif_tx_sring_t
operator|*
operator|)
name|ring
operator|->
name|va
argument_list|,
name|ring
operator|->
name|ring_pages
operator|*
name|PAGE_SIZE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ring_type
operator|==
name|XNB_RING_TYPE_RX
condition|)
block|{
name|BACK_RING_INIT
argument_list|(
operator|&
name|ring
operator|->
name|back_ring
operator|.
name|rx_ring
argument_list|,
operator|(
name|netif_rx_sring_t
operator|*
operator|)
name|ring
operator|->
name|va
argument_list|,
name|ring
operator|->
name|ring_pages
operator|*
name|PAGE_SIZE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|xenbus_dev_fatal
argument_list|(
name|xnb
operator|->
name|dev
argument_list|,
name|error
argument_list|,
literal|"Unknown ring type %d"
argument_list|,
name|ring_type
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/**  * Setup the shared memory rings and bind an interrupt to the event channel  * used to notify us of ring changes.  *  * \param xnb  Per-instance xnb configuration structure.  */
end_comment

begin_function
specifier|static
name|int
name|xnb_connect_comms
parameter_list|(
name|struct
name|xnb_softc
modifier|*
name|xnb
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|xnb_ring_type_t
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|xnb
operator|->
name|flags
operator|&
name|XNBF_RING_CONNECTED
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Kva for our rings are at the tail of the region of kva allocated 	 * by xnb_alloc_communication_mem(). 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XNB_NUM_RING_TYPES
condition|;
name|i
operator|++
control|)
block|{
name|error
operator|=
name|xnb_connect_ring
argument_list|(
name|xnb
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
name|error
return|;
block|}
name|xnb
operator|->
name|flags
operator||=
name|XNBF_RING_CONNECTED
expr_stmt|;
name|error
operator|=
name|bind_interdomain_evtchn_to_irqhandler
argument_list|(
name|xnb
operator|->
name|otherend_id
argument_list|,
name|xnb
operator|->
name|evtchn
argument_list|,
name|device_get_nameunit
argument_list|(
name|xnb
operator|->
name|dev
argument_list|)
argument_list|,
name|xnb_intr
argument_list|,
comment|/*arg*/
name|xnb
argument_list|,
name|INTR_TYPE_BIO
operator||
name|INTR_MPSAFE
argument_list|,
operator|&
name|xnb
operator|->
name|irq
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|xnb_disconnect
argument_list|(
name|xnb
argument_list|)
expr_stmt|;
name|xenbus_dev_fatal
argument_list|(
name|xnb
operator|->
name|dev
argument_list|,
name|error
argument_list|,
literal|"binding event channel"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|DPRINTF
argument_list|(
literal|"rings connected!\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Size KVA and pseudo-physical address allocations based on negotiated  * values for the size and number of I/O requests, and the size of our  * communication ring.  *  * \param xnb  Per-instance xnb configuration structure.  *  * These address spaces are used to dynamically map pages in the  * front-end's domain into our own.  */
end_comment

begin_function
specifier|static
name|int
name|xnb_alloc_communication_mem
parameter_list|(
name|struct
name|xnb_softc
modifier|*
name|xnb
parameter_list|)
block|{
name|xnb_ring_type_t
name|i
decl_stmt|;
name|xnb
operator|->
name|kva_size
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XNB_NUM_RING_TYPES
condition|;
name|i
operator|++
control|)
block|{
name|xnb
operator|->
name|kva_size
operator|+=
name|xnb
operator|->
name|ring_configs
index|[
name|i
index|]
operator|.
name|ring_pages
operator|*
name|PAGE_SIZE
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|XENHVM
name|xnb
operator|->
name|kva
operator|=
name|kmem_alloc_nofault
argument_list|(
name|kernel_map
argument_list|,
name|xnb
operator|->
name|kva_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|xnb
operator|->
name|kva
operator|==
literal|0
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|xnb
operator|->
name|gnt_base_addr
operator|=
name|xnb
operator|->
name|kva
expr_stmt|;
else|#
directive|else
comment|/* defined XENHVM */
comment|/* 	 * Reserve a range of pseudo physical memory that we can map 	 * into kva.  These pages will only be backed by machine 	 * pages ("real memory") during the lifetime of front-end requests 	 * via grant table operations.  We will map the netif tx and rx rings 	 * into this space. 	 */
name|xnb
operator|->
name|pseudo_phys_res_id
operator|=
literal|0
expr_stmt|;
name|xnb
operator|->
name|pseudo_phys_res
operator|=
name|bus_alloc_resource
argument_list|(
name|xnb
operator|->
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|xnb
operator|->
name|pseudo_phys_res_id
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
name|xnb
operator|->
name|kva_size
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|xnb
operator|->
name|pseudo_phys_res
operator|==
name|NULL
condition|)
block|{
name|xnb
operator|->
name|kva
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|xnb
operator|->
name|kva
operator|=
operator|(
name|vm_offset_t
operator|)
name|rman_get_virtual
argument_list|(
name|xnb
operator|->
name|pseudo_phys_res
argument_list|)
expr_stmt|;
name|xnb
operator|->
name|gnt_base_addr
operator|=
name|rman_get_start
argument_list|(
name|xnb
operator|->
name|pseudo_phys_res
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !defined XENHVM */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Collect information from the XenStore related to our device and its frontend  *  * \param xnb  Per-instance xnb configuration structure.  */
end_comment

begin_function
specifier|static
name|int
name|xnb_collect_xenstore_info
parameter_list|(
name|struct
name|xnb_softc
modifier|*
name|xnb
parameter_list|)
block|{
comment|/** 	 * \todo Linux collects the following info.  We should collect most 	 * of this, too: 	 * "feature-rx-notify" 	 */
specifier|const
name|char
modifier|*
name|otherend_path
decl_stmt|;
specifier|const
name|char
modifier|*
name|our_path
decl_stmt|;
name|int
name|err
decl_stmt|;
name|unsigned
name|int
name|rx_copy
decl_stmt|,
name|bridge_len
decl_stmt|;
name|uint8_t
name|no_csum_offload
decl_stmt|;
name|otherend_path
operator|=
name|xenbus_get_otherend_path
argument_list|(
name|xnb
operator|->
name|dev
argument_list|)
expr_stmt|;
name|our_path
operator|=
name|xenbus_get_node
argument_list|(
name|xnb
operator|->
name|dev
argument_list|)
expr_stmt|;
comment|/* Collect the critical communication parameters */
name|err
operator|=
name|xs_gather
argument_list|(
name|XST_NIL
argument_list|,
name|otherend_path
argument_list|,
literal|"tx-ring-ref"
argument_list|,
literal|"%l"
name|PRIu32
argument_list|,
operator|&
name|xnb
operator|->
name|ring_configs
index|[
name|XNB_RING_TYPE_TX
index|]
operator|.
name|ring_ref
argument_list|,
literal|"rx-ring-ref"
argument_list|,
literal|"%l"
name|PRIu32
argument_list|,
operator|&
name|xnb
operator|->
name|ring_configs
index|[
name|XNB_RING_TYPE_RX
index|]
operator|.
name|ring_ref
argument_list|,
literal|"event-channel"
argument_list|,
literal|"%"
name|PRIu32
argument_list|,
operator|&
name|xnb
operator|->
name|evtchn
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|xenbus_dev_fatal
argument_list|(
name|xnb
operator|->
name|dev
argument_list|,
name|err
argument_list|,
literal|"Unable to retrieve ring information from "
literal|"frontend %s.  Unable to connect."
argument_list|,
name|otherend_path
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
comment|/* Collect the handle from xenstore */
name|err
operator|=
name|xs_scanf
argument_list|(
name|XST_NIL
argument_list|,
name|our_path
argument_list|,
literal|"handle"
argument_list|,
name|NULL
argument_list|,
literal|"%li"
argument_list|,
operator|&
name|xnb
operator|->
name|handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|xenbus_dev_fatal
argument_list|(
name|xnb
operator|->
name|dev
argument_list|,
name|err
argument_list|,
literal|"Error reading handle from frontend %s.  "
literal|"Unable to connect."
argument_list|,
name|otherend_path
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Collect the bridgename, if any.  We do not need bridge_len; we just 	 * throw it away 	 */
name|err
operator|=
name|xs_read
argument_list|(
name|XST_NIL
argument_list|,
name|our_path
argument_list|,
literal|"bridge"
argument_list|,
operator|&
name|bridge_len
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|xnb
operator|->
name|bridge
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
name|xnb
operator|->
name|bridge
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Does the frontend request that we use rx copy?  If not, return an 	 * error because this driver only supports rx copy. 	 */
name|err
operator|=
name|xs_scanf
argument_list|(
name|XST_NIL
argument_list|,
name|otherend_path
argument_list|,
literal|"request-rx-copy"
argument_list|,
name|NULL
argument_list|,
literal|"%"
name|PRIu32
argument_list|,
operator|&
name|rx_copy
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|ENOENT
condition|)
block|{
name|err
operator|=
literal|0
expr_stmt|;
name|rx_copy
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|err
operator|<
literal|0
condition|)
block|{
name|xenbus_dev_fatal
argument_list|(
name|xnb
operator|->
name|dev
argument_list|,
name|err
argument_list|,
literal|"reading %s/request-rx-copy"
argument_list|,
name|otherend_path
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
comment|/** 	 * \todo: figure out the exact meaning of this feature, and when 	 * the frontend will set it to true.  It should be set to true 	 * at some point 	 */
comment|/*        if (!rx_copy)*/
comment|/*          return EOPNOTSUPP;*/
comment|/** \todo Collect the rx notify feature */
comment|/*  Collect the feature-sg. */
if|if
condition|(
name|xs_scanf
argument_list|(
name|XST_NIL
argument_list|,
name|otherend_path
argument_list|,
literal|"feature-sg"
argument_list|,
name|NULL
argument_list|,
literal|"%hhu"
argument_list|,
operator|&
name|xnb
operator|->
name|can_sg
argument_list|)
operator|<
literal|0
condition|)
name|xnb
operator|->
name|can_sg
operator|=
literal|0
expr_stmt|;
comment|/* Collect remaining frontend features */
if|if
condition|(
name|xs_scanf
argument_list|(
name|XST_NIL
argument_list|,
name|otherend_path
argument_list|,
literal|"feature-gso-tcpv4"
argument_list|,
name|NULL
argument_list|,
literal|"%hhu"
argument_list|,
operator|&
name|xnb
operator|->
name|gso
argument_list|)
operator|<
literal|0
condition|)
name|xnb
operator|->
name|gso
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|xs_scanf
argument_list|(
name|XST_NIL
argument_list|,
name|otherend_path
argument_list|,
literal|"feature-gso-tcpv4-prefix"
argument_list|,
name|NULL
argument_list|,
literal|"%hhu"
argument_list|,
operator|&
name|xnb
operator|->
name|gso_prefix
argument_list|)
operator|<
literal|0
condition|)
name|xnb
operator|->
name|gso_prefix
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|xs_scanf
argument_list|(
name|XST_NIL
argument_list|,
name|otherend_path
argument_list|,
literal|"feature-no-csum-offload"
argument_list|,
name|NULL
argument_list|,
literal|"%hhu"
argument_list|,
operator|&
name|no_csum_offload
argument_list|)
operator|<
literal|0
condition|)
name|no_csum_offload
operator|=
literal|0
expr_stmt|;
name|xnb
operator|->
name|ip_csum
operator|=
operator|(
name|no_csum_offload
operator|==
literal|0
operator|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Supply information about the physical device to the frontend  * via XenBus.  *  * \param xnb  Per-instance xnb configuration structure.  */
end_comment

begin_function
specifier|static
name|int
name|xnb_publish_backend_info
parameter_list|(
name|struct
name|xnb_softc
modifier|*
name|xnb
parameter_list|)
block|{
name|struct
name|xs_transaction
name|xst
decl_stmt|;
specifier|const
name|char
modifier|*
name|our_path
decl_stmt|;
name|int
name|error
decl_stmt|;
name|our_path
operator|=
name|xenbus_get_node
argument_list|(
name|xnb
operator|->
name|dev
argument_list|)
expr_stmt|;
do|do
block|{
name|error
operator|=
name|xs_transaction_start
argument_list|(
operator|&
name|xst
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|xenbus_dev_fatal
argument_list|(
name|xnb
operator|->
name|dev
argument_list|,
name|error
argument_list|,
literal|"Error publishing backend info "
literal|"(start transaction)"
argument_list|)
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|xs_printf
argument_list|(
name|xst
argument_list|,
name|our_path
argument_list|,
literal|"feature-sg"
argument_list|,
literal|"%d"
argument_list|,
name|XNB_SG
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
name|error
operator|=
name|xs_printf
argument_list|(
name|xst
argument_list|,
name|our_path
argument_list|,
literal|"feature-gso-tcpv4"
argument_list|,
literal|"%d"
argument_list|,
name|XNB_GSO_TCPV4
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
name|error
operator|=
name|xs_printf
argument_list|(
name|xst
argument_list|,
name|our_path
argument_list|,
literal|"feature-rx-copy"
argument_list|,
literal|"%d"
argument_list|,
name|XNB_RX_COPY
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
name|error
operator|=
name|xs_printf
argument_list|(
name|xst
argument_list|,
name|our_path
argument_list|,
literal|"feature-rx-flip"
argument_list|,
literal|"%d"
argument_list|,
name|XNB_RX_FLIP
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
name|error
operator|=
name|xs_transaction_end
argument_list|(
name|xst
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|&&
name|error
operator|!=
name|EAGAIN
condition|)
block|{
name|xenbus_dev_fatal
argument_list|(
name|xnb
operator|->
name|dev
argument_list|,
name|error
argument_list|,
literal|"ending transaction"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
name|error
operator|==
name|EAGAIN
condition|)
do|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Connect to our netfront peer now that it has completed publishing  * its configuration into the XenStore.  *  * \param xnb  Per-instance xnb configuration structure.  */
end_comment

begin_function
specifier|static
name|void
name|xnb_connect
parameter_list|(
name|struct
name|xnb_softc
modifier|*
name|xnb
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
if|if
condition|(
name|xenbus_get_state
argument_list|(
name|xnb
operator|->
name|dev
argument_list|)
operator|==
name|XenbusStateConnected
condition|)
return|return;
if|if
condition|(
name|xnb_collect_xenstore_info
argument_list|(
name|xnb
argument_list|)
operator|!=
literal|0
condition|)
return|return;
name|xnb
operator|->
name|flags
operator|&=
operator|~
name|XNBF_SHUTDOWN
expr_stmt|;
comment|/* Read front end configuration. */
comment|/* Allocate resources whose size depends on front-end configuration. */
name|error
operator|=
name|xnb_alloc_communication_mem
argument_list|(
name|xnb
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|xenbus_dev_fatal
argument_list|(
name|xnb
operator|->
name|dev
argument_list|,
name|error
argument_list|,
literal|"Unable to allocate communication memory"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Connect communication channel. 	 */
name|error
operator|=
name|xnb_connect_comms
argument_list|(
name|xnb
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
comment|/* Specific errors are reported by xnb_connect_comms(). */
return|return;
block|}
name|xnb
operator|->
name|carrier
operator|=
literal|1
expr_stmt|;
comment|/* Ready for I/O. */
name|xenbus_set_state
argument_list|(
name|xnb
operator|->
name|dev
argument_list|,
name|XenbusStateConnected
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-------------------------- Device Teardown Support -------------------------*/
end_comment

begin_comment
comment|/**  * Perform device shutdown functions.  *  * \param xnb  Per-instance xnb configuration structure.  *  * Mark this instance as shutting down, wait for any active requests  * to drain, disconnect from the front-end, and notify any waiters (e.g.  * a thread invoking our detach method) that detach can now proceed.  */
end_comment

begin_function
specifier|static
name|int
name|xnb_shutdown
parameter_list|(
name|struct
name|xnb_softc
modifier|*
name|xnb
parameter_list|)
block|{
comment|/* 	 * Due to the need to drop our mutex during some 	 * xenbus operations, it is possible for two threads 	 * to attempt to close out shutdown processing at 	 * the same time.  Tell the caller that hits this 	 * race to try back later. 	 */
if|if
condition|(
operator|(
name|xnb
operator|->
name|flags
operator|&
name|XNBF_IN_SHUTDOWN
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EAGAIN
operator|)
return|;
name|xnb
operator|->
name|flags
operator||=
name|XNBF_SHUTDOWN
expr_stmt|;
name|xnb
operator|->
name|flags
operator||=
name|XNBF_IN_SHUTDOWN
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|xnb
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
comment|/* Free the network interface */
name|xnb
operator|->
name|carrier
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|xnb
operator|->
name|xnb_ifp
operator|!=
name|NULL
condition|)
block|{
name|ether_ifdetach
argument_list|(
name|xnb
operator|->
name|xnb_ifp
argument_list|)
expr_stmt|;
name|if_free
argument_list|(
name|xnb
operator|->
name|xnb_ifp
argument_list|)
expr_stmt|;
name|xnb
operator|->
name|xnb_ifp
operator|=
name|NULL
expr_stmt|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|xnb
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
name|xnb_disconnect
argument_list|(
name|xnb
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|xnb
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|xenbus_get_state
argument_list|(
name|xnb
operator|->
name|dev
argument_list|)
operator|<
name|XenbusStateClosing
condition|)
name|xenbus_set_state
argument_list|(
name|xnb
operator|->
name|dev
argument_list|,
name|XenbusStateClosing
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|xnb
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
name|xnb
operator|->
name|flags
operator|&=
operator|~
name|XNBF_IN_SHUTDOWN
expr_stmt|;
comment|/* Indicate to xnb_detach() that is it safe to proceed. */
name|wakeup
argument_list|(
name|xnb
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Report an attach time error to the console and Xen, and cleanup  * this instance by forcing immediate detach processing.  *  * \param xnb  Per-instance xnb configuration structure.  * \param err  Errno describing the error.  * \param fmt  Printf style format and arguments  */
end_comment

begin_function
specifier|static
name|void
name|xnb_attach_failed
parameter_list|(
name|struct
name|xnb_softc
modifier|*
name|xnb
parameter_list|,
name|int
name|err
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|va_list
name|ap_hotplug
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|va_copy
argument_list|(
name|ap_hotplug
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|xs_vprintf
argument_list|(
name|XST_NIL
argument_list|,
name|xenbus_get_node
argument_list|(
name|xnb
operator|->
name|dev
argument_list|)
argument_list|,
literal|"hotplug-error"
argument_list|,
name|fmt
argument_list|,
name|ap_hotplug
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap_hotplug
argument_list|)
expr_stmt|;
name|xs_printf
argument_list|(
name|XST_NIL
argument_list|,
name|xenbus_get_node
argument_list|(
name|xnb
operator|->
name|dev
argument_list|)
argument_list|,
literal|"hotplug-status"
argument_list|,
literal|"error"
argument_list|)
expr_stmt|;
name|xenbus_dev_vfatal
argument_list|(
name|xnb
operator|->
name|dev
argument_list|,
name|err
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|xs_printf
argument_list|(
name|XST_NIL
argument_list|,
name|xenbus_get_node
argument_list|(
name|xnb
operator|->
name|dev
argument_list|)
argument_list|,
literal|"online"
argument_list|,
literal|"0"
argument_list|)
expr_stmt|;
name|xnb_detach
argument_list|(
name|xnb
operator|->
name|dev
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------- NewBus Entrypoints ----------------------------*/
end_comment

begin_comment
comment|/**  * Inspect a XenBus device and claim it if is of the appropriate type.  *  * \param dev  NewBus device object representing a candidate XenBus device.  *  * \return  0 for success, errno codes for failure.  */
end_comment

begin_function
specifier|static
name|int
name|xnb_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|xenbus_get_type
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|"vif"
argument_list|)
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"Claiming device %d, %s\n"
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|,
name|devclass_get_name
argument_list|(
name|device_get_devclass
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Backend Virtual Network Device"
argument_list|)
expr_stmt|;
name|device_quiet
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Setup sysctl variables to control various Network Back parameters.  *  * \param xnb  Xen Net Back softc.  *  */
end_comment

begin_function
specifier|static
name|void
name|xnb_setup_sysctl
parameter_list|(
name|struct
name|xnb_softc
modifier|*
name|xnb
parameter_list|)
block|{
name|struct
name|sysctl_ctx_list
modifier|*
name|sysctl_ctx
init|=
name|NULL
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|sysctl_tree
init|=
name|NULL
decl_stmt|;
name|sysctl_ctx
operator|=
name|device_get_sysctl_ctx
argument_list|(
name|xnb
operator|->
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|sysctl_ctx
operator|==
name|NULL
condition|)
return|return;
name|sysctl_tree
operator|=
name|device_get_sysctl_tree
argument_list|(
name|xnb
operator|->
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|sysctl_tree
operator|==
name|NULL
condition|)
return|return;
ifdef|#
directive|ifdef
name|XNB_DEBUG
name|SYSCTL_ADD_PROC
argument_list|(
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"unit_test_results"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|xnb
argument_list|,
literal|0
argument_list|,
name|xnb_unit_test_main
argument_list|,
literal|"A"
argument_list|,
literal|"Results of builtin unit tests"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"dump_rings"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|xnb
argument_list|,
literal|0
argument_list|,
name|xnb_dump_rings
argument_list|,
literal|"A"
argument_list|,
literal|"Xennet Back Rings"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* XNB_DEBUG */
block|}
end_function

begin_comment
comment|/**  * Create a network device.  * @param handle device handle  */
end_comment

begin_function
name|int
name|create_netdev
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|xnb_softc
modifier|*
name|xnb
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|xnb
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|xnb
operator|->
name|sc_lock
argument_list|,
literal|"xnb_softc"
argument_list|,
literal|"xen netback softc lock"
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|xnb
operator|->
name|tx_lock
argument_list|,
literal|"xnb_tx"
argument_list|,
literal|"xen netback tx lock"
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|xnb
operator|->
name|rx_lock
argument_list|,
literal|"xnb_rx"
argument_list|,
literal|"xen netback rx lock"
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|xnb
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|ifmedia_init
argument_list|(
operator|&
name|xnb
operator|->
name|sc_media
argument_list|,
literal|0
argument_list|,
name|xnb_ifmedia_upd
argument_list|,
name|xnb_ifmedia_sts
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|xnb
operator|->
name|sc_media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_MANUAL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
operator|&
name|xnb
operator|->
name|sc_media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_MANUAL
argument_list|)
expr_stmt|;
name|err
operator|=
name|xen_net_read_mac
argument_list|(
name|dev
argument_list|,
name|xnb
operator|->
name|mac
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
comment|/* Set up ifnet structure */
name|ifp
operator|=
name|xnb
operator|->
name|xnb_ifp
operator|=
name|if_alloc
argument_list|(
name|IFT_ETHER
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_softc
operator|=
name|xnb
expr_stmt|;
name|if_initname
argument_list|(
name|ifp
argument_list|,
literal|"xnb"
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|xnb_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_output
operator|=
name|ether_output
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|xnb_start
expr_stmt|;
ifdef|#
directive|ifdef
name|notyet
name|ifp
operator|->
name|if_watchdog
operator|=
name|xnb_watchdog
expr_stmt|;
endif|#
directive|endif
name|ifp
operator|->
name|if_init
operator|=
name|xnb_ifinit
expr_stmt|;
name|ifp
operator|->
name|if_mtu
operator|=
name|ETHERMTU
expr_stmt|;
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_maxlen
operator|=
name|NET_RX_RING_SIZE
operator|-
literal|1
expr_stmt|;
name|ifp
operator|->
name|if_hwassist
operator|=
name|XNB_CSUM_FEATURES
expr_stmt|;
name|ifp
operator|->
name|if_capabilities
operator|=
name|IFCAP_HWCSUM
expr_stmt|;
name|ifp
operator|->
name|if_capenable
operator|=
name|IFCAP_HWCSUM
expr_stmt|;
name|ether_ifattach
argument_list|(
name|ifp
argument_list|,
name|xnb
operator|->
name|mac
argument_list|)
expr_stmt|;
name|xnb
operator|->
name|carrier
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|err
return|;
block|}
end_function

begin_comment
comment|/**  * Attach to a XenBus device that has been claimed by our probe routine.  *  * \param dev  NewBus device object representing this Xen Net Back instance.  *  * \return  0 for success, errno codes for failure.  */
end_comment

begin_function
specifier|static
name|int
name|xnb_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|xnb_softc
modifier|*
name|xnb
decl_stmt|;
name|int
name|error
decl_stmt|;
name|xnb_ring_type_t
name|i
decl_stmt|;
name|error
operator|=
name|create_netdev
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|xenbus_dev_fatal
argument_list|(
name|dev
argument_list|,
name|error
argument_list|,
literal|"creating netdev"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|DPRINTF
argument_list|(
literal|"Attaching to %s\n"
argument_list|,
name|xenbus_get_node
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Basic initialization. 	 * After this block it is safe to call xnb_detach() 	 * to clean up any allocated data for this instance. 	 */
name|xnb
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|xnb
operator|->
name|otherend_id
operator|=
name|xenbus_get_otherend_id
argument_list|(
name|dev
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XNB_NUM_RING_TYPES
condition|;
name|i
operator|++
control|)
block|{
name|xnb
operator|->
name|ring_configs
index|[
name|i
index|]
operator|.
name|ring_pages
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 	 * Setup sysctl variables. 	 */
name|xnb_setup_sysctl
argument_list|(
name|xnb
argument_list|)
expr_stmt|;
comment|/* Update hot-plug status to satisfy xend. */
name|error
operator|=
name|xs_printf
argument_list|(
name|XST_NIL
argument_list|,
name|xenbus_get_node
argument_list|(
name|xnb
operator|->
name|dev
argument_list|)
argument_list|,
literal|"hotplug-status"
argument_list|,
literal|"connected"
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|xnb_attach_failed
argument_list|(
name|xnb
argument_list|,
name|error
argument_list|,
literal|"writing %s/hotplug-status"
argument_list|,
name|xenbus_get_node
argument_list|(
name|xnb
operator|->
name|dev
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|xnb_publish_backend_info
argument_list|(
name|xnb
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * If we can't publish our data, we cannot participate 		 * in this connection, and waiting for a front-end state 		 * change will not help the situation. 		 */
name|xnb_attach_failed
argument_list|(
name|xnb
argument_list|,
name|error
argument_list|,
literal|"Publishing backend status for %s"
argument_list|,
name|xenbus_get_node
argument_list|(
name|xnb
operator|->
name|dev
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* Tell the front end that we are ready to connect. */
name|xenbus_set_state
argument_list|(
name|dev
argument_list|,
name|XenbusStateInitWait
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Detach from a net back device instance.  *  * \param dev  NewBus device object representing this Xen Net Back instance.  *  * \return  0 for success, errno codes for failure.  *  * \note A net back device may be detached at any time in its life-cycle,  *       including part way through the attach process.  For this reason,  *       initialization order and the intialization state checks in this  *       routine must be carefully coupled so that attach time failures  *       are gracefully handled.  */
end_comment

begin_function
specifier|static
name|int
name|xnb_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|xnb_softc
modifier|*
name|xnb
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|xnb
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|xnb
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
while|while
condition|(
name|xnb_shutdown
argument_list|(
name|xnb
argument_list|)
operator|==
name|EAGAIN
condition|)
block|{
name|msleep
argument_list|(
name|xnb
argument_list|,
operator|&
name|xnb
operator|->
name|sc_lock
argument_list|,
comment|/*wakeup prio unchanged*/
literal|0
argument_list|,
literal|"xnb_shutdown"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|xnb
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|xnb
operator|->
name|tx_lock
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|xnb
operator|->
name|rx_lock
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|xnb
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Prepare this net back device for suspension of this VM.  *  * \param dev  NewBus device object representing this Xen net Back instance.  *  * \return  0 for success, errno codes for failure.  */
end_comment

begin_function
specifier|static
name|int
name|xnb_suspend
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Perform any processing required to recover from a suspended state.  *  * \param dev  NewBus device object representing this Xen Net Back instance.  *  * \return  0 for success, errno codes for failure.  */
end_comment

begin_function
specifier|static
name|int
name|xnb_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Handle state changes expressed via the XenStore by our front-end peer.  *  * \param dev             NewBus device object representing this Xen  *                        Net Back instance.  * \param frontend_state  The new state of the front-end.  *  * \return  0 for success, errno codes for failure.  */
end_comment

begin_function
specifier|static
name|void
name|xnb_frontend_changed
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|XenbusState
name|frontend_state
parameter_list|)
block|{
name|struct
name|xnb_softc
modifier|*
name|xnb
decl_stmt|;
name|xnb
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"frontend_state=%s, xnb_state=%s\n"
argument_list|,
name|xenbus_strstate
argument_list|(
name|frontend_state
argument_list|)
argument_list|,
name|xenbus_strstate
argument_list|(
name|xenbus_get_state
argument_list|(
name|xnb
operator|->
name|dev
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|frontend_state
condition|)
block|{
case|case
name|XenbusStateInitialising
case|:
break|break;
case|case
name|XenbusStateInitialised
case|:
case|case
name|XenbusStateConnected
case|:
name|xnb_connect
argument_list|(
name|xnb
argument_list|)
expr_stmt|;
break|break;
case|case
name|XenbusStateClosing
case|:
case|case
name|XenbusStateClosed
case|:
name|mtx_lock
argument_list|(
operator|&
name|xnb
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
name|xnb_shutdown
argument_list|(
name|xnb
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|xnb
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|frontend_state
operator|==
name|XenbusStateClosed
condition|)
name|xenbus_set_state
argument_list|(
name|xnb
operator|->
name|dev
argument_list|,
name|XenbusStateClosed
argument_list|)
expr_stmt|;
break|break;
default|default:
name|xenbus_dev_fatal
argument_list|(
name|xnb
operator|->
name|dev
argument_list|,
name|EINVAL
argument_list|,
literal|"saw state %d at frontend"
argument_list|,
name|frontend_state
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*---------------------------- Request Processing ----------------------------*/
end_comment

begin_comment
comment|/**  * Interrupt handler bound to the shared ring's event channel.  * Entry point for the xennet transmit path in netback  * Transfers packets from the Xen ring to the host's generic networking stack  *  * \param arg  Callback argument registerd during event channel  *             binding - the xnb_softc for this instance.  */
end_comment

begin_function
specifier|static
name|void
name|xnb_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|xnb_softc
modifier|*
name|xnb
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|netif_tx_back_ring_t
modifier|*
name|txb
decl_stmt|;
name|RING_IDX
name|req_prod_local
decl_stmt|;
name|xnb
operator|=
operator|(
expr|struct
name|xnb_softc
operator|*
operator|)
name|arg
expr_stmt|;
name|ifp
operator|=
name|xnb
operator|->
name|xnb_ifp
expr_stmt|;
name|txb
operator|=
operator|&
name|xnb
operator|->
name|ring_configs
index|[
name|XNB_RING_TYPE_TX
index|]
operator|.
name|back_ring
operator|.
name|tx_ring
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|xnb
operator|->
name|tx_lock
argument_list|)
expr_stmt|;
do|do
block|{
name|int
name|notify
decl_stmt|;
name|req_prod_local
operator|=
name|txb
operator|->
name|sring
operator|->
name|req_prod
expr_stmt|;
name|xen_rmb
argument_list|()
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|struct
name|mbuf
modifier|*
name|mbufc
decl_stmt|;
name|int
name|err
decl_stmt|;
name|err
operator|=
name|xnb_recv
argument_list|(
name|txb
argument_list|,
name|xnb
operator|->
name|otherend_id
argument_list|,
operator|&
name|mbufc
argument_list|,
name|ifp
argument_list|,
name|xnb
operator|->
name|tx_gnttab
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|||
operator|(
name|mbufc
operator|==
name|NULL
operator|)
condition|)
break|break;
comment|/* Send the packet to the generic network stack */
call|(
modifier|*
name|xnb
operator|->
name|xnb_ifp
operator|->
name|if_input
call|)
argument_list|(
name|xnb
operator|->
name|xnb_ifp
argument_list|,
name|mbufc
argument_list|)
expr_stmt|;
block|}
name|RING_PUSH_RESPONSES_AND_CHECK_NOTIFY
argument_list|(
name|txb
argument_list|,
name|notify
argument_list|)
expr_stmt|;
if|if
condition|(
name|notify
operator|!=
literal|0
condition|)
name|notify_remote_via_irq
argument_list|(
name|xnb
operator|->
name|irq
argument_list|)
expr_stmt|;
name|txb
operator|->
name|sring
operator|->
name|req_event
operator|=
name|txb
operator|->
name|req_cons
operator|+
literal|1
expr_stmt|;
name|xen_mb
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|txb
operator|->
name|sring
operator|->
name|req_prod
operator|!=
name|req_prod_local
condition|)
do|;
name|mtx_unlock
argument_list|(
operator|&
name|xnb
operator|->
name|tx_lock
argument_list|)
expr_stmt|;
name|xnb_start
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Build a struct xnb_pkt based on netif_tx_request's from a netif tx ring.  * Will read exactly 0 or 1 packets from the ring; never a partial packet.  * \param[out]	pkt	The returned packet.  If there is an error building  * 			the packet, pkt.list_len will be set to 0.  * \param[in]	tx_ring	Pointer to the Ring that is the input to this function  * \param[in]	start	The ring index of the first potential request  * \return		The number of requests consumed to build this packet  */
end_comment

begin_function
specifier|static
name|int
name|xnb_ring2pkt
parameter_list|(
name|struct
name|xnb_pkt
modifier|*
name|pkt
parameter_list|,
specifier|const
name|netif_tx_back_ring_t
modifier|*
name|tx_ring
parameter_list|,
name|RING_IDX
name|start
parameter_list|)
block|{
comment|/* 	 * Outline: 	 * 1) Initialize pkt 	 * 2) Read the first request of the packet 	 * 3) Read the extras 	 * 4) Set cdr 	 * 5) Loop on the remainder of the packet 	 * 6) Finalize pkt (stuff like car_size and list_len) 	 */
name|int
name|idx
init|=
name|start
decl_stmt|;
name|int
name|discard
init|=
literal|0
decl_stmt|;
comment|/* whether to discard the packet */
name|int
name|more_data
init|=
literal|0
decl_stmt|;
comment|/* there are more request past the last one */
name|uint16_t
name|cdr_size
init|=
literal|0
decl_stmt|;
comment|/* accumulated size of requests 2 through n */
name|xnb_pkt_initialize
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
comment|/* Read the first request */
if|if
condition|(
name|RING_HAS_UNCONSUMED_REQUESTS_2
argument_list|(
name|tx_ring
argument_list|,
name|idx
argument_list|)
condition|)
block|{
name|netif_tx_request_t
modifier|*
name|tx
init|=
name|RING_GET_REQUEST
argument_list|(
name|tx_ring
argument_list|,
name|idx
argument_list|)
decl_stmt|;
name|pkt
operator|->
name|size
operator|=
name|tx
operator|->
name|size
expr_stmt|;
name|pkt
operator|->
name|flags
operator|=
name|tx
operator|->
name|flags
operator|&
operator|~
name|NETTXF_more_data
expr_stmt|;
name|more_data
operator|=
name|tx
operator|->
name|flags
operator|&
name|NETTXF_more_data
expr_stmt|;
name|pkt
operator|->
name|list_len
operator|++
expr_stmt|;
name|pkt
operator|->
name|car
operator|=
name|idx
expr_stmt|;
name|idx
operator|++
expr_stmt|;
block|}
comment|/* Read the extra info */
if|if
condition|(
operator|(
name|pkt
operator|->
name|flags
operator|&
name|NETTXF_extra_info
operator|)
operator|&&
name|RING_HAS_UNCONSUMED_REQUESTS_2
argument_list|(
name|tx_ring
argument_list|,
name|idx
argument_list|)
condition|)
block|{
name|netif_extra_info_t
modifier|*
name|ext
init|=
operator|(
name|netif_extra_info_t
operator|*
operator|)
name|RING_GET_REQUEST
argument_list|(
name|tx_ring
argument_list|,
name|idx
argument_list|)
decl_stmt|;
name|pkt
operator|->
name|extra
operator|.
name|type
operator|=
name|ext
operator|->
name|type
expr_stmt|;
switch|switch
condition|(
name|pkt
operator|->
name|extra
operator|.
name|type
condition|)
block|{
case|case
name|XEN_NETIF_EXTRA_TYPE_GSO
case|:
name|pkt
operator|->
name|extra
operator|.
name|u
operator|.
name|gso
operator|=
name|ext
operator|->
name|u
operator|.
name|gso
expr_stmt|;
break|break;
default|default:
comment|/* 				 * The reference Linux netfront driver will 				 * never set any other extra.type.  So we don't 				 * know what to do with it.  Let's print an 				 * error, then consume and discard the packet 				 */
name|printf
argument_list|(
literal|"xnb(%s:%d): Unknown extra info type %d."
literal|"  Discarding packet\n"
argument_list|,
name|__func__
argument_list|,
name|__LINE__
argument_list|,
name|pkt
operator|->
name|extra
operator|.
name|type
argument_list|)
expr_stmt|;
name|xnb_dump_txreq
argument_list|(
name|start
argument_list|,
name|RING_GET_REQUEST
argument_list|(
name|tx_ring
argument_list|,
name|start
argument_list|)
argument_list|)
expr_stmt|;
name|xnb_dump_txreq
argument_list|(
name|idx
argument_list|,
name|RING_GET_REQUEST
argument_list|(
name|tx_ring
argument_list|,
name|idx
argument_list|)
argument_list|)
expr_stmt|;
name|discard
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|pkt
operator|->
name|extra
operator|.
name|flags
operator|=
name|ext
operator|->
name|flags
expr_stmt|;
if|if
condition|(
name|ext
operator|->
name|flags
operator|&
name|XEN_NETIF_EXTRA_FLAG_MORE
condition|)
block|{
comment|/* 			 * The reference linux netfront driver never sets this 			 * flag (nor does any other known netfront).  So we 			 * will discard the packet. 			 */
name|printf
argument_list|(
literal|"xnb(%s:%d): Request sets "
literal|"XEN_NETIF_EXTRA_FLAG_MORE, but we can't handle "
literal|"that\n"
argument_list|,
name|__func__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|xnb_dump_txreq
argument_list|(
name|start
argument_list|,
name|RING_GET_REQUEST
argument_list|(
name|tx_ring
argument_list|,
name|start
argument_list|)
argument_list|)
expr_stmt|;
name|xnb_dump_txreq
argument_list|(
name|idx
argument_list|,
name|RING_GET_REQUEST
argument_list|(
name|tx_ring
argument_list|,
name|idx
argument_list|)
argument_list|)
expr_stmt|;
name|discard
operator|=
literal|1
expr_stmt|;
block|}
name|idx
operator|++
expr_stmt|;
block|}
comment|/* Set cdr.  If there is not more data, cdr is invalid */
name|pkt
operator|->
name|cdr
operator|=
name|idx
expr_stmt|;
comment|/* Loop on remainder of packet */
while|while
condition|(
name|more_data
operator|&&
name|RING_HAS_UNCONSUMED_REQUESTS_2
argument_list|(
name|tx_ring
argument_list|,
name|idx
argument_list|)
condition|)
block|{
name|netif_tx_request_t
modifier|*
name|tx
init|=
name|RING_GET_REQUEST
argument_list|(
name|tx_ring
argument_list|,
name|idx
argument_list|)
decl_stmt|;
name|pkt
operator|->
name|list_len
operator|++
expr_stmt|;
name|cdr_size
operator|+=
name|tx
operator|->
name|size
expr_stmt|;
if|if
condition|(
name|tx
operator|->
name|flags
operator|&
operator|~
name|NETTXF_more_data
condition|)
block|{
comment|/* There should be no other flags set at this point */
name|printf
argument_list|(
literal|"xnb(%s:%d): Request sets unknown flags %d "
literal|"after the 1st request in the packet.\n"
argument_list|,
name|__func__
argument_list|,
name|__LINE__
argument_list|,
name|tx
operator|->
name|flags
argument_list|)
expr_stmt|;
name|xnb_dump_txreq
argument_list|(
name|start
argument_list|,
name|RING_GET_REQUEST
argument_list|(
name|tx_ring
argument_list|,
name|start
argument_list|)
argument_list|)
expr_stmt|;
name|xnb_dump_txreq
argument_list|(
name|idx
argument_list|,
name|RING_GET_REQUEST
argument_list|(
name|tx_ring
argument_list|,
name|idx
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|more_data
operator|=
name|tx
operator|->
name|flags
operator|&
name|NETTXF_more_data
expr_stmt|;
name|idx
operator|++
expr_stmt|;
block|}
comment|/* Finalize packet */
if|if
condition|(
name|more_data
operator|!=
literal|0
condition|)
block|{
comment|/* The ring ran out of requests before finishing the packet */
name|xnb_pkt_invalidate
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
name|idx
operator|=
name|start
expr_stmt|;
comment|/* tell caller that we consumed no requests */
block|}
else|else
block|{
comment|/* Calculate car_size */
name|pkt
operator|->
name|car_size
operator|=
name|pkt
operator|->
name|size
operator|-
name|cdr_size
expr_stmt|;
block|}
if|if
condition|(
name|discard
operator|!=
literal|0
condition|)
block|{
name|xnb_pkt_invalidate
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
block|}
return|return
name|idx
operator|-
name|start
return|;
block|}
end_function

begin_comment
comment|/**  * Respond to all the requests that constituted pkt.  Builds the responses and  * writes them to the ring, but doesn't push them to the shared ring.  * \param[in] pkt	the packet that needs a response  * \param[in] error	true if there was an error handling the packet, such  * 			as in the hypervisor copy op or mbuf allocation  * \param[out] ring	Responses go here  */
end_comment

begin_function
specifier|static
name|void
name|xnb_txpkt2rsp
parameter_list|(
specifier|const
name|struct
name|xnb_pkt
modifier|*
name|pkt
parameter_list|,
name|netif_tx_back_ring_t
modifier|*
name|ring
parameter_list|,
name|int
name|error
parameter_list|)
block|{
comment|/* 	 * Outline: 	 * 1) Respond to the first request 	 * 2) Respond to the extra info reques 	 * Loop through every remaining request in the packet, generating 	 * responses that copy those requests' ids and sets the status 	 * appropriately. 	 */
name|netif_tx_request_t
modifier|*
name|tx
decl_stmt|;
name|netif_tx_response_t
modifier|*
name|rsp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|uint16_t
name|status
decl_stmt|;
name|status
operator|=
operator|(
name|xnb_pkt_is_valid
argument_list|(
name|pkt
argument_list|)
operator|==
literal|0
operator|)
operator|||
name|error
condition|?
name|NETIF_RSP_ERROR
else|:
name|NETIF_RSP_OKAY
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|pkt
operator|->
name|list_len
operator|==
literal|0
operator|)
operator|||
operator|(
name|ring
operator|->
name|rsp_prod_pvt
operator|==
name|pkt
operator|->
name|car
operator|)
argument_list|,
operator|(
literal|"Cannot respond to ring requests out of order"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pkt
operator|->
name|list_len
operator|>=
literal|1
condition|)
block|{
name|uint16_t
name|id
decl_stmt|;
name|tx
operator|=
name|RING_GET_REQUEST
argument_list|(
name|ring
argument_list|,
name|ring
operator|->
name|rsp_prod_pvt
argument_list|)
expr_stmt|;
name|id
operator|=
name|tx
operator|->
name|id
expr_stmt|;
name|rsp
operator|=
name|RING_GET_RESPONSE
argument_list|(
name|ring
argument_list|,
name|ring
operator|->
name|rsp_prod_pvt
argument_list|)
expr_stmt|;
name|rsp
operator|->
name|id
operator|=
name|id
expr_stmt|;
name|rsp
operator|->
name|status
operator|=
name|status
expr_stmt|;
name|ring
operator|->
name|rsp_prod_pvt
operator|++
expr_stmt|;
if|if
condition|(
name|pkt
operator|->
name|flags
operator|&
name|NETRXF_extra_info
condition|)
block|{
name|rsp
operator|=
name|RING_GET_RESPONSE
argument_list|(
name|ring
argument_list|,
name|ring
operator|->
name|rsp_prod_pvt
argument_list|)
expr_stmt|;
name|rsp
operator|->
name|status
operator|=
name|NETIF_RSP_NULL
expr_stmt|;
name|ring
operator|->
name|rsp_prod_pvt
operator|++
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pkt
operator|->
name|list_len
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|uint16_t
name|id
decl_stmt|;
name|tx
operator|=
name|RING_GET_REQUEST
argument_list|(
name|ring
argument_list|,
name|ring
operator|->
name|rsp_prod_pvt
argument_list|)
expr_stmt|;
name|id
operator|=
name|tx
operator|->
name|id
expr_stmt|;
name|rsp
operator|=
name|RING_GET_RESPONSE
argument_list|(
name|ring
argument_list|,
name|ring
operator|->
name|rsp_prod_pvt
argument_list|)
expr_stmt|;
name|rsp
operator|->
name|id
operator|=
name|id
expr_stmt|;
name|rsp
operator|->
name|status
operator|=
name|status
expr_stmt|;
name|ring
operator|->
name|rsp_prod_pvt
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * Create an mbuf chain to represent a packet.  Initializes all of the headers  * in the mbuf chain, but does not copy the data.  The returned chain must be  * free()'d when no longer needed  * \param[in]	pkt	A packet to model the mbuf chain after  * \return	A newly allocated mbuf chain, possibly with clusters attached.  * 		NULL on failure  */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|xnb_pkt2mbufc
parameter_list|(
specifier|const
name|struct
name|xnb_pkt
modifier|*
name|pkt
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
comment|/** 	 * \todo consider using a memory pool for mbufs instead of 	 * reallocating them for every packet 	 */
comment|/** \todo handle extra data */
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|m
operator|=
name|m_getm
argument_list|(
name|NULL
argument_list|,
name|pkt
operator|->
name|size
argument_list|,
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
if|if
condition|(
name|pkt
operator|->
name|flags
operator|&
name|NETTXF_data_validated
condition|)
block|{
comment|/* 			 * We lie to the host OS and always tell it that the 			 * checksums are ok, because the packet is unlikely to 			 * get corrupted going across domains. 			 */
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|=
operator|(
name|CSUM_IP_CHECKED
operator||
name|CSUM_IP_VALID
operator||
name|CSUM_DATA_VALID
operator||
name|CSUM_PSEUDO_HDR
operator|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|=
literal|0xffff
expr_stmt|;
block|}
block|}
return|return
name|m
return|;
block|}
end_function

begin_comment
comment|/**  * Build a gnttab_copy table that can be used to copy data from a pkt  * to an mbufc.  Does not actually perform the copy.  Always uses gref's on  * the packet side.  * \param[in]	pkt	pkt's associated requests form the src for  * 			the copy operation  * \param[in]	mbufc	mbufc's storage forms the dest for the copy operation  * \param[out]  gnttab	Storage for the returned grant table  * \param[in]	txb	Pointer to the backend ring structure  * \param[in]	otherend_id	The domain ID of the other end of the copy  * \return 		The number of gnttab entries filled  */
end_comment

begin_function
specifier|static
name|int
name|xnb_txpkt2gnttab
parameter_list|(
specifier|const
name|struct
name|xnb_pkt
modifier|*
name|pkt
parameter_list|,
specifier|const
name|struct
name|mbuf
modifier|*
name|mbufc
parameter_list|,
name|gnttab_copy_table
name|gnttab
parameter_list|,
specifier|const
name|netif_tx_back_ring_t
modifier|*
name|txb
parameter_list|,
name|domid_t
name|otherend_id
parameter_list|)
block|{
specifier|const
name|struct
name|mbuf
modifier|*
name|mbuf
init|=
name|mbufc
decl_stmt|;
comment|/* current mbuf within the chain */
name|int
name|gnt_idx
init|=
literal|0
decl_stmt|;
comment|/* index into grant table */
name|RING_IDX
name|r_idx
init|=
name|pkt
operator|->
name|car
decl_stmt|;
comment|/* index into tx ring buffer */
name|int
name|r_ofs
init|=
literal|0
decl_stmt|;
comment|/* offset of next data within tx request's data area */
name|int
name|m_ofs
init|=
literal|0
decl_stmt|;
comment|/* offset of next data within mbuf's data area */
comment|/* size in bytes that still needs to be represented in the table */
name|uint16_t
name|size_remaining
init|=
name|pkt
operator|->
name|size
decl_stmt|;
while|while
condition|(
name|size_remaining
operator|>
literal|0
condition|)
block|{
specifier|const
name|netif_tx_request_t
modifier|*
name|txq
init|=
name|RING_GET_REQUEST
argument_list|(
name|txb
argument_list|,
name|r_idx
argument_list|)
decl_stmt|;
specifier|const
name|size_t
name|mbuf_space
init|=
name|M_TRAILINGSPACE
argument_list|(
name|mbuf
argument_list|)
operator|-
name|m_ofs
decl_stmt|;
specifier|const
name|size_t
name|req_size
init|=
name|r_idx
operator|==
name|pkt
operator|->
name|car
condition|?
name|pkt
operator|->
name|car_size
else|:
name|txq
operator|->
name|size
decl_stmt|;
specifier|const
name|size_t
name|pkt_space
init|=
name|req_size
operator|-
name|r_ofs
decl_stmt|;
comment|/* 		 * space is the largest amount of data that can be copied in the 		 * grant table's next entry 		 */
specifier|const
name|size_t
name|space
init|=
name|MIN
argument_list|(
name|pkt_space
argument_list|,
name|mbuf_space
argument_list|)
decl_stmt|;
comment|/* TODO: handle this error condition without panicking */
name|KASSERT
argument_list|(
name|gnt_idx
operator|<
name|GNTTAB_LEN
argument_list|,
operator|(
literal|"Grant table is too short"
operator|)
argument_list|)
expr_stmt|;
name|gnttab
index|[
name|gnt_idx
index|]
operator|.
name|source
operator|.
name|u
operator|.
name|ref
operator|=
name|txq
operator|->
name|gref
expr_stmt|;
name|gnttab
index|[
name|gnt_idx
index|]
operator|.
name|source
operator|.
name|domid
operator|=
name|otherend_id
expr_stmt|;
name|gnttab
index|[
name|gnt_idx
index|]
operator|.
name|source
operator|.
name|offset
operator|=
name|txq
operator|->
name|offset
operator|+
name|r_ofs
expr_stmt|;
name|gnttab
index|[
name|gnt_idx
index|]
operator|.
name|dest
operator|.
name|u
operator|.
name|gmfn
operator|=
name|virt_to_mfn
argument_list|(
name|mtod
argument_list|(
name|mbuf
argument_list|,
name|vm_offset_t
argument_list|)
operator|+
name|m_ofs
argument_list|)
expr_stmt|;
name|gnttab
index|[
name|gnt_idx
index|]
operator|.
name|dest
operator|.
name|offset
operator|=
name|virt_to_offset
argument_list|(
name|mtod
argument_list|(
name|mbuf
argument_list|,
name|vm_offset_t
argument_list|)
operator|+
name|m_ofs
argument_list|)
expr_stmt|;
name|gnttab
index|[
name|gnt_idx
index|]
operator|.
name|dest
operator|.
name|domid
operator|=
name|DOMID_SELF
expr_stmt|;
name|gnttab
index|[
name|gnt_idx
index|]
operator|.
name|len
operator|=
name|space
expr_stmt|;
name|gnttab
index|[
name|gnt_idx
index|]
operator|.
name|flags
operator|=
name|GNTCOPY_source_gref
expr_stmt|;
name|gnt_idx
operator|++
expr_stmt|;
name|r_ofs
operator|+=
name|space
expr_stmt|;
name|m_ofs
operator|+=
name|space
expr_stmt|;
name|size_remaining
operator|-=
name|space
expr_stmt|;
if|if
condition|(
name|req_size
operator|-
name|r_ofs
operator|<=
literal|0
condition|)
block|{
comment|/* Must move to the next tx request */
name|r_ofs
operator|=
literal|0
expr_stmt|;
name|r_idx
operator|=
operator|(
name|r_idx
operator|==
name|pkt
operator|->
name|car
operator|)
condition|?
name|pkt
operator|->
name|cdr
else|:
name|r_idx
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|M_TRAILINGSPACE
argument_list|(
name|mbuf
argument_list|)
operator|-
name|m_ofs
operator|<=
literal|0
condition|)
block|{
comment|/* Must move to the next mbuf */
name|m_ofs
operator|=
literal|0
expr_stmt|;
name|mbuf
operator|=
name|mbuf
operator|->
name|m_next
expr_stmt|;
block|}
block|}
return|return
name|gnt_idx
return|;
block|}
end_function

begin_comment
comment|/**  * Check the status of the grant copy operations, and update mbufs various  * non-data fields to reflect the data present.  * \param[in,out] mbufc	mbuf chain to update.  The chain must be valid and of  * 			the correct length, and data should already be present  * \param[in] gnttab	A grant table for a just completed copy op  * \param[in] n_entries The number of valid entries in the grant table  */
end_comment

begin_function
specifier|static
name|void
name|xnb_update_mbufc
parameter_list|(
name|struct
name|mbuf
modifier|*
name|mbufc
parameter_list|,
specifier|const
name|gnttab_copy_table
name|gnttab
parameter_list|,
name|int
name|n_entries
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|mbuf
init|=
name|mbufc
decl_stmt|;
name|int
name|i
decl_stmt|;
name|size_t
name|total_size
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_entries
condition|;
name|i
operator|++
control|)
block|{
name|KASSERT
argument_list|(
name|gnttab
index|[
name|i
index|]
operator|.
name|status
operator|==
name|GNTST_okay
argument_list|,
operator|(
literal|"Some gnttab_copy entry had error status %hd\n"
operator|,
name|gnttab
index|[
name|i
index|]
operator|.
name|status
operator|)
argument_list|)
expr_stmt|;
name|mbuf
operator|->
name|m_len
operator|+=
name|gnttab
index|[
name|i
index|]
operator|.
name|len
expr_stmt|;
name|total_size
operator|+=
name|gnttab
index|[
name|i
index|]
operator|.
name|len
expr_stmt|;
if|if
condition|(
name|M_TRAILINGSPACE
argument_list|(
name|mbuf
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|mbuf
operator|=
name|mbuf
operator|->
name|m_next
expr_stmt|;
block|}
block|}
name|mbufc
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|total_size
expr_stmt|;
name|xnb_add_mbuf_cksum
argument_list|(
name|mbufc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Dequeue at most one packet from the shared ring  * \param[in,out] txb	Netif tx ring.  A packet will be removed from it, and  * 			its private indices will be updated.  But the indices  * 			will not be pushed to the shared ring.  * \param[in] ifnet	Interface to which the packet will be sent  * \param[in] otherend	Domain ID of the other end of the ring  * \param[out] mbufc	The assembled mbuf chain, ready to send to the generic  * 			networking stack  * \param[in,out] gnttab Pointer to enough memory for a grant table.  We make  * 			this a function parameter so that we will take less  * 			stack space.  * \return		An error code  */
end_comment

begin_function
specifier|static
name|int
name|xnb_recv
parameter_list|(
name|netif_tx_back_ring_t
modifier|*
name|txb
parameter_list|,
name|domid_t
name|otherend
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|mbufc
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifnet
parameter_list|,
name|gnttab_copy_table
name|gnttab
parameter_list|)
block|{
name|struct
name|xnb_pkt
name|pkt
decl_stmt|;
comment|/* number of tx requests consumed to build the last packet */
name|int
name|num_consumed
decl_stmt|;
name|int
name|nr_ents
decl_stmt|;
operator|*
name|mbufc
operator|=
name|NULL
expr_stmt|;
name|num_consumed
operator|=
name|xnb_ring2pkt
argument_list|(
operator|&
name|pkt
argument_list|,
name|txb
argument_list|,
name|txb
operator|->
name|req_cons
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_consumed
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Nothing to receive */
comment|/* update statistics indepdent of errors */
name|ifnet
operator|->
name|if_ipackets
operator|++
expr_stmt|;
comment|/* 	 * if we got here, then 1 or more requests was consumed, but the packet 	 * is not necessarily valid. 	 */
if|if
condition|(
name|xnb_pkt_is_valid
argument_list|(
operator|&
name|pkt
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* got a garbage packet, respond and drop it */
name|xnb_txpkt2rsp
argument_list|(
operator|&
name|pkt
argument_list|,
name|txb
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|txb
operator|->
name|req_cons
operator|+=
name|num_consumed
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"xnb_intr: garbage packet, num_consumed=%d\n"
argument_list|,
name|num_consumed
argument_list|)
expr_stmt|;
name|ifnet
operator|->
name|if_ierrors
operator|++
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
operator|*
name|mbufc
operator|=
name|xnb_pkt2mbufc
argument_list|(
operator|&
name|pkt
argument_list|,
name|ifnet
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|mbufc
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * Couldn't allocate mbufs.  Respond and drop the packet.  Do 		 * not consume the requests 		 */
name|xnb_txpkt2rsp
argument_list|(
operator|&
name|pkt
argument_list|,
name|txb
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"xnb_intr: Couldn't allocate mbufs, num_consumed=%d\n"
argument_list|,
name|num_consumed
argument_list|)
expr_stmt|;
name|ifnet
operator|->
name|if_iqdrops
operator|++
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|nr_ents
operator|=
name|xnb_txpkt2gnttab
argument_list|(
operator|&
name|pkt
argument_list|,
operator|*
name|mbufc
argument_list|,
name|gnttab
argument_list|,
name|txb
argument_list|,
name|otherend
argument_list|)
expr_stmt|;
if|if
condition|(
name|nr_ents
operator|>
literal|0
condition|)
block|{
name|int
name|__unused
name|hv_ret
init|=
name|HYPERVISOR_grant_table_op
argument_list|(
name|GNTTABOP_copy
argument_list|,
name|gnttab
argument_list|,
name|nr_ents
argument_list|)
decl_stmt|;
name|KASSERT
argument_list|(
name|hv_ret
operator|==
literal|0
argument_list|,
operator|(
literal|"HYPERVISOR_grant_table_op returned %d\n"
operator|,
name|hv_ret
operator|)
argument_list|)
expr_stmt|;
name|xnb_update_mbufc
argument_list|(
operator|*
name|mbufc
argument_list|,
name|gnttab
argument_list|,
name|nr_ents
argument_list|)
expr_stmt|;
block|}
name|xnb_txpkt2rsp
argument_list|(
operator|&
name|pkt
argument_list|,
name|txb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|txb
operator|->
name|req_cons
operator|+=
name|num_consumed
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Create an xnb_pkt based on the contents of an mbuf chain.  * \param[in] mbufc	mbuf chain to transform into a packet  * \param[out] pkt	Storage for the newly generated xnb_pkt  * \param[in] start	The ring index of the first available slot in the rx  * 			ring  * \param[in] space	The number of free slots in the rx ring  * \retval 0		Success  * \retval EINVAL	mbufc was corrupt or not convertible into a pkt  * \retval EAGAIN	There was not enough space in the ring to queue the  * 			packet  */
end_comment

begin_function
specifier|static
name|int
name|xnb_mbufc2pkt
parameter_list|(
specifier|const
name|struct
name|mbuf
modifier|*
name|mbufc
parameter_list|,
name|struct
name|xnb_pkt
modifier|*
name|pkt
parameter_list|,
name|RING_IDX
name|start
parameter_list|,
name|int
name|space
parameter_list|)
block|{
name|int
name|retval
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|mbufc
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|(
name|mbufc
operator|->
name|m_flags
operator|&
name|M_PKTHDR
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|mbufc
operator|->
name|m_pkthdr
operator|.
name|len
operator|==
literal|0
operator|)
condition|)
block|{
name|xnb_pkt_invalidate
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
name|retval
operator|=
name|EINVAL
expr_stmt|;
block|}
else|else
block|{
name|int
name|slots_required
decl_stmt|;
name|xnb_pkt_validate
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
name|pkt
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|pkt
operator|->
name|size
operator|=
name|mbufc
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|pkt
operator|->
name|car
operator|=
name|start
expr_stmt|;
name|pkt
operator|->
name|car_size
operator|=
name|mbufc
operator|->
name|m_len
expr_stmt|;
if|if
condition|(
name|mbufc
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_TSO
condition|)
block|{
name|pkt
operator|->
name|flags
operator||=
name|NETRXF_extra_info
expr_stmt|;
name|pkt
operator|->
name|extra
operator|.
name|u
operator|.
name|gso
operator|.
name|size
operator|=
name|mbufc
operator|->
name|m_pkthdr
operator|.
name|tso_segsz
expr_stmt|;
name|pkt
operator|->
name|extra
operator|.
name|u
operator|.
name|gso
operator|.
name|type
operator|=
name|XEN_NETIF_GSO_TYPE_TCPV4
expr_stmt|;
name|pkt
operator|->
name|extra
operator|.
name|u
operator|.
name|gso
operator|.
name|pad
operator|=
literal|0
expr_stmt|;
name|pkt
operator|->
name|extra
operator|.
name|u
operator|.
name|gso
operator|.
name|features
operator|=
literal|0
expr_stmt|;
name|pkt
operator|->
name|extra
operator|.
name|type
operator|=
name|XEN_NETIF_EXTRA_TYPE_GSO
expr_stmt|;
name|pkt
operator|->
name|extra
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|pkt
operator|->
name|cdr
operator|=
name|start
operator|+
literal|2
expr_stmt|;
block|}
else|else
block|{
name|pkt
operator|->
name|cdr
operator|=
name|start
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|mbufc
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
operator|(
name|CSUM_TSO
operator||
name|CSUM_DELAY_DATA
operator|)
condition|)
block|{
name|pkt
operator|->
name|flags
operator||=
operator|(
name|NETRXF_csum_blank
operator||
name|NETRXF_data_validated
operator|)
expr_stmt|;
block|}
comment|/* 		 * Each ring response can have up to PAGE_SIZE of data. 		 * Assume that we can defragment the mbuf chain efficiently 		 * into responses so that each response but the last uses all 		 * PAGE_SIZE bytes. 		 */
name|pkt
operator|->
name|list_len
operator|=
operator|(
name|pkt
operator|->
name|size
operator|+
name|PAGE_SIZE
operator|-
literal|1
operator|)
operator|/
name|PAGE_SIZE
expr_stmt|;
if|if
condition|(
name|pkt
operator|->
name|list_len
operator|>
literal|1
condition|)
block|{
name|pkt
operator|->
name|flags
operator||=
name|NETRXF_more_data
expr_stmt|;
block|}
name|slots_required
operator|=
name|pkt
operator|->
name|list_len
operator|+
operator|(
name|pkt
operator|->
name|flags
operator|&
name|NETRXF_extra_info
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|slots_required
operator|>
name|space
condition|)
block|{
name|xnb_pkt_invalidate
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
name|retval
operator|=
name|EAGAIN
expr_stmt|;
block|}
block|}
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/**  * Build a gnttab_copy table that can be used to copy data from an mbuf chain  * to the frontend's shared buffers.  Does not actually perform the copy.  * Always uses gref's on the other end's side.  * \param[in]	pkt	pkt's associated responses form the dest for the copy  * 			operatoin  * \param[in]	mbufc	The source for the copy operation  * \param[out]	gnttab	Storage for the returned grant table  * \param[in]	rxb	Pointer to the backend ring structure  * \param[in]	otherend_id	The domain ID of the other end of the copy  * \return 		The number of gnttab entries filled  */
end_comment

begin_function
specifier|static
name|int
name|xnb_rxpkt2gnttab
parameter_list|(
specifier|const
name|struct
name|xnb_pkt
modifier|*
name|pkt
parameter_list|,
specifier|const
name|struct
name|mbuf
modifier|*
name|mbufc
parameter_list|,
name|gnttab_copy_table
name|gnttab
parameter_list|,
specifier|const
name|netif_rx_back_ring_t
modifier|*
name|rxb
parameter_list|,
name|domid_t
name|otherend_id
parameter_list|)
block|{
specifier|const
name|struct
name|mbuf
modifier|*
name|mbuf
init|=
name|mbufc
decl_stmt|;
comment|/* current mbuf within the chain */
name|int
name|gnt_idx
init|=
literal|0
decl_stmt|;
comment|/* index into grant table */
name|RING_IDX
name|r_idx
init|=
name|pkt
operator|->
name|car
decl_stmt|;
comment|/* index into rx ring buffer */
name|int
name|r_ofs
init|=
literal|0
decl_stmt|;
comment|/* offset of next data within rx request's data area */
name|int
name|m_ofs
init|=
literal|0
decl_stmt|;
comment|/* offset of next data within mbuf's data area */
comment|/* size in bytes that still needs to be represented in the table */
name|uint16_t
name|size_remaining
decl_stmt|;
name|size_remaining
operator|=
operator|(
name|xnb_pkt_is_valid
argument_list|(
name|pkt
argument_list|)
operator|!=
literal|0
operator|)
condition|?
name|pkt
operator|->
name|size
else|:
literal|0
expr_stmt|;
while|while
condition|(
name|size_remaining
operator|>
literal|0
condition|)
block|{
specifier|const
name|netif_rx_request_t
modifier|*
name|rxq
init|=
name|RING_GET_REQUEST
argument_list|(
name|rxb
argument_list|,
name|r_idx
argument_list|)
decl_stmt|;
specifier|const
name|size_t
name|mbuf_space
init|=
name|mbuf
operator|->
name|m_len
operator|-
name|m_ofs
decl_stmt|;
comment|/* Xen shared pages have an implied size of PAGE_SIZE */
specifier|const
name|size_t
name|req_size
init|=
name|PAGE_SIZE
decl_stmt|;
specifier|const
name|size_t
name|pkt_space
init|=
name|req_size
operator|-
name|r_ofs
decl_stmt|;
comment|/* 		 * space is the largest amount of data that can be copied in the 		 * grant table's next entry 		 */
specifier|const
name|size_t
name|space
init|=
name|MIN
argument_list|(
name|pkt_space
argument_list|,
name|mbuf_space
argument_list|)
decl_stmt|;
comment|/* TODO: handle this error condition without panicing */
name|KASSERT
argument_list|(
name|gnt_idx
operator|<
name|GNTTAB_LEN
argument_list|,
operator|(
literal|"Grant table is too short"
operator|)
argument_list|)
expr_stmt|;
name|gnttab
index|[
name|gnt_idx
index|]
operator|.
name|dest
operator|.
name|u
operator|.
name|ref
operator|=
name|rxq
operator|->
name|gref
expr_stmt|;
name|gnttab
index|[
name|gnt_idx
index|]
operator|.
name|dest
operator|.
name|domid
operator|=
name|otherend_id
expr_stmt|;
name|gnttab
index|[
name|gnt_idx
index|]
operator|.
name|dest
operator|.
name|offset
operator|=
name|r_ofs
expr_stmt|;
name|gnttab
index|[
name|gnt_idx
index|]
operator|.
name|source
operator|.
name|u
operator|.
name|gmfn
operator|=
name|virt_to_mfn
argument_list|(
name|mtod
argument_list|(
name|mbuf
argument_list|,
name|vm_offset_t
argument_list|)
operator|+
name|m_ofs
argument_list|)
expr_stmt|;
name|gnttab
index|[
name|gnt_idx
index|]
operator|.
name|source
operator|.
name|offset
operator|=
name|virt_to_offset
argument_list|(
name|mtod
argument_list|(
name|mbuf
argument_list|,
name|vm_offset_t
argument_list|)
operator|+
name|m_ofs
argument_list|)
expr_stmt|;
name|gnttab
index|[
name|gnt_idx
index|]
operator|.
name|source
operator|.
name|domid
operator|=
name|DOMID_SELF
expr_stmt|;
name|gnttab
index|[
name|gnt_idx
index|]
operator|.
name|len
operator|=
name|space
expr_stmt|;
name|gnttab
index|[
name|gnt_idx
index|]
operator|.
name|flags
operator|=
name|GNTCOPY_dest_gref
expr_stmt|;
name|gnt_idx
operator|++
expr_stmt|;
name|r_ofs
operator|+=
name|space
expr_stmt|;
name|m_ofs
operator|+=
name|space
expr_stmt|;
name|size_remaining
operator|-=
name|space
expr_stmt|;
if|if
condition|(
name|req_size
operator|-
name|r_ofs
operator|<=
literal|0
condition|)
block|{
comment|/* Must move to the next rx request */
name|r_ofs
operator|=
literal|0
expr_stmt|;
name|r_idx
operator|=
operator|(
name|r_idx
operator|==
name|pkt
operator|->
name|car
operator|)
condition|?
name|pkt
operator|->
name|cdr
else|:
name|r_idx
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|mbuf
operator|->
name|m_len
operator|-
name|m_ofs
operator|<=
literal|0
condition|)
block|{
comment|/* Must move to the next mbuf */
name|m_ofs
operator|=
literal|0
expr_stmt|;
name|mbuf
operator|=
name|mbuf
operator|->
name|m_next
expr_stmt|;
block|}
block|}
return|return
name|gnt_idx
return|;
block|}
end_function

begin_comment
comment|/**  * Generates responses for all the requests that constituted pkt.  Builds  * responses and writes them to the ring, but doesn't push the shared ring  * indices.  * \param[in] pkt	the packet that needs a response  * \param[in] gnttab	The grant copy table corresponding to this packet.  * 			Used to determine how many rsp->netif_rx_response_t's to  * 			generate.  * \param[in] n_entries	Number of relevant entries in the grant table  * \param[out] ring	Responses go here  * \return		The number of RX requests that were consumed to generate  * 			the responses  */
end_comment

begin_function
specifier|static
name|int
name|xnb_rxpkt2rsp
parameter_list|(
specifier|const
name|struct
name|xnb_pkt
modifier|*
name|pkt
parameter_list|,
specifier|const
name|gnttab_copy_table
name|gnttab
parameter_list|,
name|int
name|n_entries
parameter_list|,
name|netif_rx_back_ring_t
modifier|*
name|ring
parameter_list|)
block|{
comment|/* 	 * This code makes the following assumptions: 	 *	* All entries in gnttab set GNTCOPY_dest_gref 	 *	* The entries in gnttab are grouped by their grefs: any two 	 *	   entries with the same gref must be adjacent 	 */
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|gnt_idx
decl_stmt|,
name|i
decl_stmt|;
name|int
name|n_responses
init|=
literal|0
decl_stmt|;
name|grant_ref_t
name|last_gref
init|=
name|GRANT_REF_INVALID
decl_stmt|;
name|RING_IDX
name|r_idx
decl_stmt|;
name|KASSERT
argument_list|(
name|gnttab
operator|!=
name|NULL
argument_list|,
operator|(
literal|"Received a null granttable copy"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * In the event of an error, we only need to send one response to the 	 * netfront.  In that case, we musn't write any data to the responses 	 * after the one we send.  So we must loop all the way through gnttab 	 * looking for errors before we generate any responses 	 * 	 * Since we're looping through the grant table anyway, we'll count the 	 * number of different gref's in it, which will tell us how many 	 * responses to generate 	 */
for|for
control|(
name|gnt_idx
operator|=
literal|0
init|;
name|gnt_idx
operator|<
name|n_entries
condition|;
name|gnt_idx
operator|++
control|)
block|{
name|int16_t
name|status
init|=
name|gnttab
index|[
name|gnt_idx
index|]
operator|.
name|status
decl_stmt|;
if|if
condition|(
name|status
operator|!=
name|GNTST_okay
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"Got error %d for hypervisor gnttab_copy status\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|gnttab
index|[
name|gnt_idx
index|]
operator|.
name|dest
operator|.
name|u
operator|.
name|ref
operator|!=
name|last_gref
condition|)
block|{
name|n_responses
operator|++
expr_stmt|;
name|last_gref
operator|=
name|gnttab
index|[
name|gnt_idx
index|]
operator|.
name|dest
operator|.
name|u
operator|.
name|ref
expr_stmt|;
block|}
block|}
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|uint16_t
name|id
decl_stmt|;
name|netif_rx_response_t
modifier|*
name|rsp
decl_stmt|;
name|id
operator|=
name|RING_GET_REQUEST
argument_list|(
name|ring
argument_list|,
name|ring
operator|->
name|rsp_prod_pvt
argument_list|)
operator|->
name|id
expr_stmt|;
name|rsp
operator|=
name|RING_GET_RESPONSE
argument_list|(
name|ring
argument_list|,
name|ring
operator|->
name|rsp_prod_pvt
argument_list|)
expr_stmt|;
name|rsp
operator|->
name|id
operator|=
name|id
expr_stmt|;
name|rsp
operator|->
name|status
operator|=
name|NETIF_RSP_ERROR
expr_stmt|;
name|n_responses
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|gnt_idx
operator|=
literal|0
expr_stmt|;
specifier|const
name|int
name|has_extra
init|=
name|pkt
operator|->
name|flags
operator|&
name|NETRXF_extra_info
decl_stmt|;
if|if
condition|(
name|has_extra
operator|!=
literal|0
condition|)
name|n_responses
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_responses
condition|;
name|i
operator|++
control|)
block|{
name|netif_rx_request_t
name|rxq
decl_stmt|;
name|netif_rx_response_t
modifier|*
name|rsp
decl_stmt|;
name|r_idx
operator|=
name|ring
operator|->
name|rsp_prod_pvt
operator|+
name|i
expr_stmt|;
comment|/* 			 * We copy the structure of rxq instead of making a 			 * pointer because it shares the same memory as rsp. 			 */
name|rxq
operator|=
operator|*
operator|(
name|RING_GET_REQUEST
argument_list|(
name|ring
argument_list|,
name|r_idx
argument_list|)
operator|)
expr_stmt|;
name|rsp
operator|=
name|RING_GET_RESPONSE
argument_list|(
name|ring
argument_list|,
name|r_idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_extra
operator|&&
operator|(
name|i
operator|==
literal|1
operator|)
condition|)
block|{
name|netif_extra_info_t
modifier|*
name|ext
init|=
operator|(
name|netif_extra_info_t
operator|*
operator|)
name|rsp
decl_stmt|;
name|ext
operator|->
name|type
operator|=
name|XEN_NETIF_EXTRA_TYPE_GSO
expr_stmt|;
name|ext
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|ext
operator|->
name|u
operator|.
name|gso
operator|.
name|size
operator|=
name|pkt
operator|->
name|extra
operator|.
name|u
operator|.
name|gso
operator|.
name|size
expr_stmt|;
name|ext
operator|->
name|u
operator|.
name|gso
operator|.
name|type
operator|=
name|XEN_NETIF_GSO_TYPE_TCPV4
expr_stmt|;
name|ext
operator|->
name|u
operator|.
name|gso
operator|.
name|pad
operator|=
literal|0
expr_stmt|;
name|ext
operator|->
name|u
operator|.
name|gso
operator|.
name|features
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|rsp
operator|->
name|id
operator|=
name|rxq
operator|.
name|id
expr_stmt|;
name|rsp
operator|->
name|status
operator|=
name|GNTST_okay
expr_stmt|;
name|rsp
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
name|rsp
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|pkt
operator|->
name|list_len
operator|-
literal|1
condition|)
name|rsp
operator|->
name|flags
operator||=
name|NETRXF_more_data
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|==
literal|0
operator|)
operator|&&
name|has_extra
condition|)
name|rsp
operator|->
name|flags
operator||=
name|NETRXF_extra_info
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|==
literal|0
operator|)
operator|&&
operator|(
name|pkt
operator|->
name|flags
operator|&
name|NETRXF_data_validated
operator|)
condition|)
block|{
name|rsp
operator|->
name|flags
operator||=
name|NETRXF_data_validated
expr_stmt|;
name|rsp
operator|->
name|flags
operator||=
name|NETRXF_csum_blank
expr_stmt|;
block|}
name|rsp
operator|->
name|status
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|gnttab
index|[
name|gnt_idx
index|]
operator|.
name|dest
operator|.
name|u
operator|.
name|ref
operator|==
name|rxq
operator|.
name|gref
condition|;
name|gnt_idx
operator|++
control|)
block|{
name|rsp
operator|->
name|status
operator|+=
name|gnttab
index|[
name|gnt_idx
index|]
operator|.
name|len
expr_stmt|;
block|}
block|}
block|}
block|}
name|ring
operator|->
name|req_cons
operator|+=
name|n_responses
expr_stmt|;
name|ring
operator|->
name|rsp_prod_pvt
operator|+=
name|n_responses
expr_stmt|;
return|return
name|n_responses
return|;
block|}
end_function

begin_comment
comment|/**  * Add IP, TCP, and/or UDP checksums to every mbuf in a chain.  The first mbuf  * in the chain must start with a struct ether_header.  *  * XXX This function will perform incorrectly on UDP packets that are split up  * into multiple ethernet frames.  */
end_comment

begin_function
specifier|static
name|void
name|xnb_add_mbuf_cksum
parameter_list|(
name|struct
name|mbuf
modifier|*
name|mbufc
parameter_list|)
block|{
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|struct
name|ip
modifier|*
name|iph
decl_stmt|;
name|uint16_t
name|ether_type
decl_stmt|;
name|eh
operator|=
name|mtod
argument_list|(
name|mbufc
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
name|ether_type
operator|=
name|ntohs
argument_list|(
name|eh
operator|->
name|ether_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|ether_type
operator|!=
name|ETHERTYPE_IP
condition|)
block|{
comment|/* Nothing to calculate */
return|return;
block|}
name|iph
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
operator|(
name|eh
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|mbufc
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_IP_VALID
condition|)
block|{
name|iph
operator|->
name|ip_sum
operator|=
literal|0
expr_stmt|;
name|iph
operator|->
name|ip_sum
operator|=
name|in_cksum_hdr
argument_list|(
name|iph
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|iph
operator|->
name|ip_p
condition|)
block|{
case|case
name|IPPROTO_TCP
case|:
if|if
condition|(
name|mbufc
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_IP_VALID
condition|)
block|{
name|size_t
name|tcplen
init|=
name|ntohs
argument_list|(
name|iph
operator|->
name|ip_len
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
decl_stmt|;
name|struct
name|tcphdr
modifier|*
name|th
init|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
operator|(
name|iph
operator|+
literal|1
operator|)
decl_stmt|;
name|th
operator|->
name|th_sum
operator|=
name|in_pseudo
argument_list|(
name|iph
operator|->
name|ip_src
operator|.
name|s_addr
argument_list|,
name|iph
operator|->
name|ip_dst
operator|.
name|s_addr
argument_list|,
name|htons
argument_list|(
name|IPPROTO_TCP
operator|+
name|tcplen
argument_list|)
argument_list|)
expr_stmt|;
name|th
operator|->
name|th_sum
operator|=
name|in_cksum_skip
argument_list|(
name|mbufc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
operator|+
name|ntohs
argument_list|(
name|iph
operator|->
name|ip_len
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
operator|+
operator|(
name|iph
operator|->
name|ip_hl
operator|<<
literal|2
operator|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|IPPROTO_UDP
case|:
if|if
condition|(
name|mbufc
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_IP_VALID
condition|)
block|{
name|size_t
name|udplen
init|=
name|ntohs
argument_list|(
name|iph
operator|->
name|ip_len
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
decl_stmt|;
name|struct
name|udphdr
modifier|*
name|uh
init|=
operator|(
expr|struct
name|udphdr
operator|*
operator|)
operator|(
name|iph
operator|+
literal|1
operator|)
decl_stmt|;
name|uh
operator|->
name|uh_sum
operator|=
name|in_pseudo
argument_list|(
name|iph
operator|->
name|ip_src
operator|.
name|s_addr
argument_list|,
name|iph
operator|->
name|ip_dst
operator|.
name|s_addr
argument_list|,
name|htons
argument_list|(
name|IPPROTO_UDP
operator|+
name|udplen
argument_list|)
argument_list|)
expr_stmt|;
name|uh
operator|->
name|uh_sum
operator|=
name|in_cksum_skip
argument_list|(
name|mbufc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
operator|+
name|ntohs
argument_list|(
name|iph
operator|->
name|ip_len
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
operator|+
operator|(
name|iph
operator|->
name|ip_hl
operator|<<
literal|2
operator|)
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|xnb_stop
parameter_list|(
name|struct
name|xnb_softc
modifier|*
name|xnb
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|xnb
operator|->
name|sc_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|xnb
operator|->
name|xnb_ifp
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
operator|(
name|IFF_DRV_RUNNING
operator||
name|IFF_DRV_OACTIVE
operator|)
expr_stmt|;
name|if_link_state_change
argument_list|(
name|ifp
argument_list|,
name|LINK_STATE_DOWN
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|xnb_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|struct
name|xnb_softc
modifier|*
name|xnb
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
ifdef|#
directive|ifdef
name|INET
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|ifaddr
modifier|*
name|ifa
init|=
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
name|data
decl_stmt|;
endif|#
directive|endif
name|int
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCSIFFLAGS
case|:
name|mtx_lock
argument_list|(
operator|&
name|xnb
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
name|xnb_ifinit_locked
argument_list|(
name|xnb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|xnb_stop
argument_list|(
name|xnb
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 			 * Note: netfront sets a variable named xn_if_flags 			 * here, but that variable is never read 			 */
name|mtx_unlock
argument_list|(
operator|&
name|xnb
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFADDR
case|:
case|case
name|SIOCGIFADDR
case|:
ifdef|#
directive|ifdef
name|INET
name|mtx_lock
argument_list|(
operator|&
name|xnb
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_UP
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
block|{
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
operator|(
name|IFF_DRV_RUNNING
operator||
name|IFF_DRV_OACTIVE
operator|)
expr_stmt|;
name|if_link_state_change
argument_list|(
name|ifp
argument_list|,
name|LINK_STATE_DOWN
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_RUNNING
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
name|if_link_state_change
argument_list|(
name|ifp
argument_list|,
name|LINK_STATE_UP
argument_list|)
expr_stmt|;
block|}
name|arp_ifinit
argument_list|(
name|ifp
argument_list|,
name|ifa
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|xnb
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mtx_unlock
argument_list|(
operator|&
name|xnb
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INET
block|}
endif|#
directive|endif
break|break;
case|case
name|SIOCSIFCAP
case|:
name|mtx_lock
argument_list|(
operator|&
name|xnb
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifr
operator|->
name|ifr_reqcap
operator|&
name|IFCAP_TXCSUM
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator||=
name|IFCAP_TXCSUM
expr_stmt|;
name|ifp
operator|->
name|if_hwassist
operator||=
name|XNB_CSUM_FEATURES
expr_stmt|;
block|}
else|else
block|{
name|ifp
operator|->
name|if_capenable
operator|&=
operator|~
operator|(
name|IFCAP_TXCSUM
operator|)
expr_stmt|;
name|ifp
operator|->
name|if_hwassist
operator|&=
operator|~
operator|(
name|XNB_CSUM_FEATURES
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ifr
operator|->
name|ifr_reqcap
operator|&
name|IFCAP_RXCSUM
operator|)
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator||=
name|IFCAP_RXCSUM
expr_stmt|;
block|}
else|else
block|{
name|ifp
operator|->
name|if_capenable
operator|&=
operator|~
operator|(
name|IFCAP_RXCSUM
operator|)
expr_stmt|;
block|}
comment|/* 			 * TODO enable TSO4 and LRO once we no longer need 			 * to calculate checksums in software 			 */
if|#
directive|if
literal|0
block|if (ifr->if_reqcap |= IFCAP_TSO4) { 				if (IFCAP_TXCSUM& ifp->if_capenable) { 					printf("xnb: Xen netif requires that " 						"TXCSUM be enabled in order " 						"to use TSO4\n"); 					error = EINVAL; 				} else { 					ifp->if_capenable |= IFCAP_TSO4; 					ifp->if_hwassist |= CSUM_TSO; 				} 			} else { 				ifp->if_capenable&= ~(IFCAP_TSO4); 				ifp->if_hwassist&= ~(CSUM_TSO); 			} 			if (ifr->ifreqcap |= IFCAP_LRO) { 				ifp->if_capenable |= IFCAP_LRO; 			} else { 				ifp->if_capenable&= ~(IFCAP_LRO); 			}
endif|#
directive|endif
name|mtx_unlock
argument_list|(
operator|&
name|xnb
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFMTU
case|:
name|ifp
operator|->
name|if_mtu
operator|=
name|ifr
operator|->
name|ifr_mtu
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_RUNNING
expr_stmt|;
name|xnb_ifinit
argument_list|(
name|xnb
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
case|case
name|SIOCSIFMEDIA
case|:
case|case
name|SIOCGIFMEDIA
case|:
name|error
operator|=
name|ifmedia_ioctl
argument_list|(
name|ifp
argument_list|,
name|ifr
argument_list|,
operator|&
name|xnb
operator|->
name|sc_media
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xnb_start_locked
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|netif_rx_back_ring_t
modifier|*
name|rxb
decl_stmt|;
name|struct
name|xnb_softc
modifier|*
name|xnb
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mbufc
decl_stmt|;
name|RING_IDX
name|req_prod_local
decl_stmt|;
name|xnb
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|rxb
operator|=
operator|&
name|xnb
operator|->
name|ring_configs
index|[
name|XNB_RING_TYPE_RX
index|]
operator|.
name|back_ring
operator|.
name|rx_ring
expr_stmt|;
if|if
condition|(
operator|!
name|xnb
operator|->
name|carrier
condition|)
return|return;
do|do
block|{
name|int
name|out_of_space
init|=
literal|0
decl_stmt|;
name|int
name|notify
decl_stmt|;
name|req_prod_local
operator|=
name|rxb
operator|->
name|sring
operator|->
name|req_prod
expr_stmt|;
name|xen_rmb
argument_list|()
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|error
decl_stmt|;
name|IF_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|mbufc
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbufc
operator|==
name|NULL
condition|)
break|break;
name|error
operator|=
name|xnb_send
argument_list|(
name|rxb
argument_list|,
name|xnb
operator|->
name|otherend_id
argument_list|,
name|mbufc
argument_list|,
name|xnb
operator|->
name|rx_gnttab
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|error
condition|)
block|{
case|case
name|EAGAIN
case|:
comment|/* 					 * Insufficient space in the ring. 					 * Requeue pkt and send when space is 					 * available. 					 */
name|IF_PREPEND
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|mbufc
argument_list|)
expr_stmt|;
comment|/* 					 * Perhaps the frontend missed an IRQ 					 * and went to sleep.  Notify it to wake 					 * it up. 					 */
name|out_of_space
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|EINVAL
case|:
comment|/* OS gave a corrupt packet.  Drop it.*/
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
comment|/* FALLTHROUGH */
default|default:
comment|/* Send succeeded, or packet had error. 					 * Free the packet */
name|ifp
operator|->
name|if_opackets
operator|++
expr_stmt|;
if|if
condition|(
name|mbufc
condition|)
name|m_freem
argument_list|(
name|mbufc
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|out_of_space
operator|!=
literal|0
condition|)
break|break;
block|}
name|RING_PUSH_RESPONSES_AND_CHECK_NOTIFY
argument_list|(
name|rxb
argument_list|,
name|notify
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|notify
operator|!=
literal|0
operator|)
operator|||
operator|(
name|out_of_space
operator|!=
literal|0
operator|)
condition|)
name|notify_remote_via_irq
argument_list|(
name|xnb
operator|->
name|irq
argument_list|)
expr_stmt|;
name|rxb
operator|->
name|sring
operator|->
name|req_event
operator|=
name|req_prod_local
operator|+
literal|1
expr_stmt|;
name|xen_mb
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|rxb
operator|->
name|sring
operator|->
name|req_prod
operator|!=
name|req_prod_local
condition|)
do|;
block|}
end_function

begin_comment
comment|/**  * Sends one packet to the ring.  Blocks until the packet is on the ring  * \param[in]	mbufc	Contains one packet to send.  Caller must free  * \param[in,out] rxb	The packet will be pushed onto this ring, but the  * 			otherend will not be notified.  * \param[in]	otherend The domain ID of the other end of the connection  * \retval	EAGAIN	The ring did not have enough space for the packet.  * 			The ring has not been modified  * \param[in,out] gnttab Pointer to enough memory for a grant table.  We make  * 			this a function parameter so that we will take less  * 			stack space.  * \retval EINVAL	mbufc was corrupt or not convertible into a pkt  */
end_comment

begin_function
specifier|static
name|int
name|xnb_send
parameter_list|(
name|netif_rx_back_ring_t
modifier|*
name|ring
parameter_list|,
name|domid_t
name|otherend
parameter_list|,
specifier|const
name|struct
name|mbuf
modifier|*
name|mbufc
parameter_list|,
name|gnttab_copy_table
name|gnttab
parameter_list|)
block|{
name|struct
name|xnb_pkt
name|pkt
decl_stmt|;
name|int
name|error
decl_stmt|,
name|n_entries
decl_stmt|,
name|n_reqs
decl_stmt|;
name|RING_IDX
name|space
decl_stmt|;
name|space
operator|=
name|ring
operator|->
name|sring
operator|->
name|req_prod
operator|-
name|ring
operator|->
name|req_cons
expr_stmt|;
name|error
operator|=
name|xnb_mbufc2pkt
argument_list|(
name|mbufc
argument_list|,
operator|&
name|pkt
argument_list|,
name|ring
operator|->
name|rsp_prod_pvt
argument_list|,
name|space
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
name|error
return|;
name|n_entries
operator|=
name|xnb_rxpkt2gnttab
argument_list|(
operator|&
name|pkt
argument_list|,
name|mbufc
argument_list|,
name|gnttab
argument_list|,
name|ring
argument_list|,
name|otherend
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_entries
operator|!=
literal|0
condition|)
block|{
name|int
name|__unused
name|hv_ret
init|=
name|HYPERVISOR_grant_table_op
argument_list|(
name|GNTTABOP_copy
argument_list|,
name|gnttab
argument_list|,
name|n_entries
argument_list|)
decl_stmt|;
name|KASSERT
argument_list|(
name|hv_ret
operator|==
literal|0
argument_list|,
operator|(
literal|"HYPERVISOR_grant_table_op returned %d\n"
operator|,
name|hv_ret
operator|)
argument_list|)
expr_stmt|;
block|}
name|n_reqs
operator|=
name|xnb_rxpkt2rsp
argument_list|(
operator|&
name|pkt
argument_list|,
name|gnttab
argument_list|,
name|n_entries
argument_list|,
name|ring
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xnb_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|xnb_softc
modifier|*
name|xnb
decl_stmt|;
name|xnb
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|xnb
operator|->
name|rx_lock
argument_list|)
expr_stmt|;
name|xnb_start_locked
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|xnb
operator|->
name|rx_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* equivalent of network_open() in Linux */
end_comment

begin_function
specifier|static
name|void
name|xnb_ifinit_locked
parameter_list|(
name|struct
name|xnb_softc
modifier|*
name|xnb
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|ifp
operator|=
name|xnb
operator|->
name|xnb_ifp
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|xnb
operator|->
name|sc_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
return|return;
name|xnb_stop
argument_list|(
name|xnb
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_RUNNING
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
name|if_link_state_change
argument_list|(
name|ifp
argument_list|,
name|LINK_STATE_UP
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xnb_ifinit
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
block|{
name|struct
name|xnb_softc
modifier|*
name|xnb
init|=
name|xsc
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|xnb
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
name|xnb_ifinit_locked
argument_list|(
name|xnb
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|xnb
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Read the 'mac' node at the given device's node in the store, and parse that  * as colon-separated octets, placing result the given mac array.  mac must be  * a preallocated array of length ETHER_ADDR_LEN ETH_ALEN (as declared in  * net/ethernet.h).  * Return 0 on success, or errno on error.  */
end_comment

begin_function
specifier|static
name|int
name|xen_net_read_mac
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|uint8_t
name|mac
index|[]
parameter_list|)
block|{
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|e
decl_stmt|,
modifier|*
name|macstr
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|path
operator|=
name|xenbus_get_node
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|error
operator|=
name|xs_read
argument_list|(
name|XST_NIL
argument_list|,
name|path
argument_list|,
literal|"mac"
argument_list|,
name|NULL
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|macstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|xenbus_dev_fatal
argument_list|(
name|dev
argument_list|,
name|error
argument_list|,
literal|"parsing %s/mac"
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|s
operator|=
name|macstr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ETHER_ADDR_LEN
condition|;
name|i
operator|++
control|)
block|{
name|mac
index|[
name|i
index|]
operator|=
name|strtoul
argument_list|(
name|s
argument_list|,
operator|&
name|e
argument_list|,
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|e
operator|||
operator|(
name|e
index|[
literal|0
index|]
operator|!=
literal|':'
operator|&&
name|e
index|[
literal|0
index|]
operator|!=
literal|0
operator|)
condition|)
block|{
name|error
operator|=
name|ENOENT
expr_stmt|;
break|break;
block|}
name|s
operator|=
operator|&
name|e
index|[
literal|1
index|]
expr_stmt|;
block|}
name|free
argument_list|(
name|macstr
argument_list|,
name|M_XENBUS
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/**  * Callback used by the generic networking code to tell us when our carrier  * state has changed.  Since we don't have a physical carrier, we don't care  */
end_comment

begin_function
specifier|static
name|int
name|xnb_ifmedia_upd
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Callback used by the generic networking code to ask us what our carrier  * state is.  Since we don't have a physical carrier, this is very simple  */
end_comment

begin_function
specifier|static
name|void
name|xnb_ifmedia_sts
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|ifmediareq
modifier|*
name|ifmr
parameter_list|)
block|{
name|ifmr
operator|->
name|ifm_status
operator|=
name|IFM_AVALID
operator||
name|IFM_ACTIVE
expr_stmt|;
name|ifmr
operator|->
name|ifm_active
operator|=
name|IFM_ETHER
operator||
name|IFM_MANUAL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------- NewBus Registration ---------------------------*/
end_comment

begin_decl_stmt
specifier|static
name|device_method_t
name|xnb_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|xnb_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|xnb_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|xnb_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|bus_generic_shutdown
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|xnb_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|xnb_resume
argument_list|)
block|,
comment|/* Xenbus interface */
name|DEVMETHOD
argument_list|(
name|xenbus_otherend_changed
argument_list|,
name|xnb_frontend_changed
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|xnb_driver
init|=
block|{
literal|"xnb"
block|,
name|xnb_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|xnb_softc
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|devclass_t
name|xnb_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|xnb
argument_list|,
name|xenbusb_back
argument_list|,
name|xnb_driver
argument_list|,
name|xnb_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*-------------------------- Unit Tests -------------------------------------*/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|XNB_DEBUG
end_ifdef

begin_include
include|#
directive|include
file|"netback_unit_tests.c"
end_include

begin_endif
endif|#
directive|endif
end_endif

end_unit

