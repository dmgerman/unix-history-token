begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2009 Adrian Chadd  * Copyright (c) 2012 Spectra Logic Corporation  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  */
end_comment

begin_comment
comment|/**  * \file dev/xen/timer/timer.c  * \brief A timer driver for the Xen hypervisor's PV clock.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/timetc.h>
end_include

begin_include
include|#
directive|include
file|<sys/timeet.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/clock.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<xen/xen-os.h>
end_include

begin_include
include|#
directive|include
file|<xen/features.h>
end_include

begin_include
include|#
directive|include
file|<xen/xen_intr.h>
end_include

begin_include
include|#
directive|include
file|<xen/hypervisor.h>
end_include

begin_include
include|#
directive|include
file|<xen/interface/io/xenbus.h>
end_include

begin_include
include|#
directive|include
file|<xen/interface/vcpu.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpufunc.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<machine/_inttypes.h>
end_include

begin_include
include|#
directive|include
file|<machine/smp.h>
end_include

begin_include
include|#
directive|include
file|<dev/xen/timer/timer.h>
end_include

begin_include
include|#
directive|include
file|"clock_if.h"
end_include

begin_decl_stmt
specifier|static
name|devclass_t
name|xentimer_devclass
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NSEC_IN_SEC
value|1000000000ULL
end_define

begin_define
define|#
directive|define
name|NSEC_IN_USEC
value|1000ULL
end_define

begin_comment
comment|/* 18446744073 = int(2^64 / NSEC_IN_SC) = 1 ns in 64-bit fractions */
end_comment

begin_define
define|#
directive|define
name|FRAC_IN_NSEC
value|18446744073LL
end_define

begin_comment
comment|/* Xen timers may fire up to 100us off */
end_comment

begin_define
define|#
directive|define
name|XENTIMER_MIN_PERIOD_IN_NSEC
value|100*NSEC_IN_USEC
end_define

begin_define
define|#
directive|define
name|XENCLOCK_RESOLUTION
value|10000000
end_define

begin_define
define|#
directive|define
name|ETIME
value|62
end_define

begin_comment
comment|/* Xen "bad time" error */
end_comment

begin_define
define|#
directive|define
name|XENTIMER_QUALITY
value|950
end_define

begin_struct
struct|struct
name|xentimer_pcpu_data
block|{
name|uint64_t
name|timer
decl_stmt|;
name|uint64_t
name|last_processed
decl_stmt|;
name|void
modifier|*
name|irq_handle
decl_stmt|;
block|}
struct|;
end_struct

begin_expr_stmt
name|DPCPU_DEFINE
argument_list|(
expr|struct
name|xentimer_pcpu_data
argument_list|,
name|xentimer_pcpu
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DPCPU_DECLARE
argument_list|(
expr|struct
name|vcpu_info
operator|*
argument_list|,
name|vcpu_info
argument_list|)
expr_stmt|;
end_expr_stmt

begin_struct
struct|struct
name|xentimer_softc
block|{
name|device_t
name|dev
decl_stmt|;
name|struct
name|timecounter
name|tc
decl_stmt|;
name|struct
name|eventtimer
name|et
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Last time; this guarantees a monotonically increasing clock. */
end_comment

begin_decl_stmt
specifier|volatile
name|uint64_t
name|xen_timer_last_time
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|xentimer_identify
parameter_list|(
name|driver_t
modifier|*
name|driver
parameter_list|,
name|device_t
name|parent
parameter_list|)
block|{
if|if
condition|(
operator|!
name|xen_domain
argument_list|()
condition|)
return|return;
comment|/* Handle all Xen PV timers in one device instance. */
if|if
condition|(
name|devclass_get_device
argument_list|(
name|xentimer_devclass
argument_list|,
literal|0
argument_list|)
condition|)
return|return;
name|BUS_ADD_CHILD
argument_list|(
name|parent
argument_list|,
literal|0
argument_list|,
literal|"xen_et"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|xentimer_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|KASSERT
argument_list|(
operator|(
name|xen_domain
argument_list|()
operator|)
argument_list|,
operator|(
literal|"Trying to use Xen timer on bare metal"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * In order to attach, this driver requires the following: 	 * - Vector callback support by the hypervisor, in order to deliver 	 *   timer interrupts to the correct CPU for CPUs other than 0. 	 * - Access to the hypervisor shared info page, in order to look up 	 *   each VCPU's timer information and the Xen wallclock time. 	 * - The hypervisor must say its PV clock is "safe" to use. 	 * - The hypervisor must support VCPUOP hypercalls. 	 * - The maximum number of CPUs supported by FreeBSD must not exceed 	 *   the number of VCPUs supported by the hypervisor. 	 */
define|#
directive|define
name|XTREQUIRES
parameter_list|(
name|condition
parameter_list|,
name|reason
modifier|...
parameter_list|)
define|\
value|if (!(condition)) {			\ 		device_printf(dev, ## reason);	\ 		device_detach(dev);		\ 		return (ENXIO);			\ 	}
if|if
condition|(
name|xen_hvm_domain
argument_list|()
condition|)
block|{
name|XTREQUIRES
argument_list|(
name|xen_vector_callback_enabled
argument_list|,
literal|"vector callbacks unavailable\n"
argument_list|)
expr_stmt|;
name|XTREQUIRES
argument_list|(
name|xen_feature
argument_list|(
name|XENFEAT_hvm_safe_pvclock
argument_list|)
argument_list|,
literal|"HVM safe pvclock unavailable\n"
argument_list|)
expr_stmt|;
block|}
name|XTREQUIRES
argument_list|(
name|HYPERVISOR_shared_info
operator|!=
name|NULL
argument_list|,
literal|"shared info page unavailable\n"
argument_list|)
expr_stmt|;
name|XTREQUIRES
argument_list|(
name|HYPERVISOR_vcpu_op
argument_list|(
name|VCPUOP_stop_periodic_timer
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
argument_list|,
literal|"VCPUOPs interface unavailable\n"
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|XTREQUIRES
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Xen PV Clock"
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_NOWILDCARD
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Scale a 64-bit delta by scaling and multiplying by a 32-bit fraction,  * yielding a 64-bit result.  */
end_comment

begin_function
specifier|static
specifier|inline
name|uint64_t
name|scale_delta
parameter_list|(
name|uint64_t
name|delta
parameter_list|,
name|uint32_t
name|mul_frac
parameter_list|,
name|int
name|shift
parameter_list|)
block|{
name|uint64_t
name|product
decl_stmt|;
if|if
condition|(
name|shift
operator|<
literal|0
condition|)
name|delta
operator|>>=
operator|-
name|shift
expr_stmt|;
else|else
name|delta
operator|<<=
name|shift
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__i386__
argument_list|)
block|{
name|uint32_t
name|tmp1
decl_stmt|,
name|tmp2
decl_stmt|;
comment|/** 		 * For i386, the formula looks like: 		 * 		 *   lower = (mul_frac * (delta& UINT_MAX))>> 32 		 *   upper = mul_frac * (delta>> 32) 		 *   product = lower + upper 		 */
asm|__asm__ ( 			"mul  %5       ; " 			"mov  %4,%%eax ; " 			"mov  %%edx,%4 ; " 			"mul  %5       ; " 			"xor  %5,%5    ; " 			"add  %4,%%eax ; " 			"adc  %5,%%edx ; " 			: "=A" (product), "=r" (tmp1), "=r" (tmp2) 			: "a" ((uint32_t)delta), "1" ((uint32_t)(delta>> 32)), 			  "2" (mul_frac) );
block|}
elif|#
directive|elif
name|defined
argument_list|(
name|__amd64__
argument_list|)
block|{
name|unsigned
name|long
name|tmp
decl_stmt|;
asm|__asm__ ( 			"mulq %[mul_frac] ; shrd $32, %[hi], %[lo]" 			: [lo]"=a" (product), [hi]"=d" (tmp) 			: "0" (delta), [mul_frac]"rm"((uint64_t)mul_frac));
block|}
else|#
directive|else
error|#
directive|error
literal|"xentimer: unsupported architecture"
endif|#
directive|endif
return|return
operator|(
name|product
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint64_t
name|get_nsec_offset
parameter_list|(
name|struct
name|vcpu_time_info
modifier|*
name|tinfo
parameter_list|)
block|{
return|return
operator|(
name|scale_delta
argument_list|(
name|rdtsc
argument_list|()
operator|-
name|tinfo
operator|->
name|tsc_timestamp
argument_list|,
name|tinfo
operator|->
name|tsc_to_system_mul
argument_list|,
name|tinfo
operator|->
name|tsc_shift
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read the current hypervisor system uptime value from Xen.  * See<xen/interface/xen.h> for a description of how this works.  */
end_comment

begin_function
specifier|static
name|uint32_t
name|xen_fetch_vcpu_tinfo
parameter_list|(
name|struct
name|vcpu_time_info
modifier|*
name|dst
parameter_list|,
name|struct
name|vcpu_time_info
modifier|*
name|src
parameter_list|)
block|{
do|do
block|{
name|dst
operator|->
name|version
operator|=
name|src
operator|->
name|version
expr_stmt|;
name|rmb
argument_list|()
expr_stmt|;
name|dst
operator|->
name|tsc_timestamp
operator|=
name|src
operator|->
name|tsc_timestamp
expr_stmt|;
name|dst
operator|->
name|system_time
operator|=
name|src
operator|->
name|system_time
expr_stmt|;
name|dst
operator|->
name|tsc_to_system_mul
operator|=
name|src
operator|->
name|tsc_to_system_mul
expr_stmt|;
name|dst
operator|->
name|tsc_shift
operator|=
name|src
operator|->
name|tsc_shift
expr_stmt|;
name|rmb
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|src
operator|->
name|version
operator|&
literal|1
operator|)
operator||
operator|(
name|dst
operator|->
name|version
operator|^
name|src
operator|->
name|version
operator|)
condition|)
do|;
return|return
operator|(
name|dst
operator|->
name|version
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * \brief Get the current time, in nanoseconds, since the hypervisor booted.  *  * \param vcpu		vcpu_info structure to fetch the time from.  *  * \note This function returns the current CPU's idea of this value, unless  *       it happens to be less than another CPU's previously determined value.  */
end_comment

begin_function
specifier|static
name|uint64_t
name|xen_fetch_vcpu_time
parameter_list|(
name|struct
name|vcpu_info
modifier|*
name|vcpu
parameter_list|)
block|{
name|struct
name|vcpu_time_info
name|dst
decl_stmt|;
name|struct
name|vcpu_time_info
modifier|*
name|src
decl_stmt|;
name|uint32_t
name|pre_version
decl_stmt|;
name|uint64_t
name|now
decl_stmt|;
specifier|volatile
name|uint64_t
name|last
decl_stmt|;
name|src
operator|=
operator|&
name|vcpu
operator|->
name|time
expr_stmt|;
do|do
block|{
name|pre_version
operator|=
name|xen_fetch_vcpu_tinfo
argument_list|(
operator|&
name|dst
argument_list|,
name|src
argument_list|)
expr_stmt|;
name|barrier
argument_list|()
expr_stmt|;
name|now
operator|=
name|dst
operator|.
name|system_time
operator|+
name|get_nsec_offset
argument_list|(
operator|&
name|dst
argument_list|)
expr_stmt|;
name|barrier
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|pre_version
operator|!=
name|src
operator|->
name|version
condition|)
do|;
comment|/* 	 * Enforce a monotonically increasing clock time across all 	 * VCPUs.  If our time is too old, use the last time and return. 	 * Otherwise, try to update the last time. 	 */
do|do
block|{
name|last
operator|=
name|xen_timer_last_time
expr_stmt|;
if|if
condition|(
name|last
operator|>
name|now
condition|)
block|{
name|now
operator|=
name|last
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
operator|!
name|atomic_cmpset_64
argument_list|(
operator|&
name|xen_timer_last_time
argument_list|,
name|last
argument_list|,
name|now
argument_list|)
condition|)
do|;
return|return
operator|(
name|now
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|xentimer_get_timecount
parameter_list|(
name|struct
name|timecounter
modifier|*
name|tc
parameter_list|)
block|{
name|uint64_t
name|vcpu_time
decl_stmt|;
comment|/* 	 * We don't disable preemption here because the worst that can 	 * happen is reading the vcpu_info area of a different CPU than 	 * the one we are currently running on, but that would also 	 * return a valid tc (and we avoid the overhead of 	 * critical_{enter/exit} calls). 	 */
name|vcpu_time
operator|=
name|xen_fetch_vcpu_time
argument_list|(
name|DPCPU_GET
argument_list|(
name|vcpu_info
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|vcpu_time
operator|&
name|UINT32_MAX
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * \brief Fetch the hypervisor boot time, known as the "Xen wallclock".  *  * \param ts		Timespec to store the current stable value.  * \param version	Pointer to store the corresponding wallclock version.  *  * \note This value is updated when Domain-0 shifts its clock to follow  *       clock drift, e.g. as detected by NTP.  */
end_comment

begin_function
specifier|static
name|void
name|xen_fetch_wallclock
parameter_list|(
name|struct
name|timespec
modifier|*
name|ts
parameter_list|)
block|{
name|shared_info_t
modifier|*
name|src
init|=
name|HYPERVISOR_shared_info
decl_stmt|;
name|uint32_t
name|version
init|=
literal|0
decl_stmt|;
do|do
block|{
name|version
operator|=
name|src
operator|->
name|wc_version
expr_stmt|;
name|rmb
argument_list|()
expr_stmt|;
name|ts
operator|->
name|tv_sec
operator|=
name|src
operator|->
name|wc_sec
expr_stmt|;
name|ts
operator|->
name|tv_nsec
operator|=
name|src
operator|->
name|wc_nsec
expr_stmt|;
name|rmb
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|src
operator|->
name|wc_version
operator|&
literal|1
operator|)
operator||
operator|(
name|version
operator|^
name|src
operator|->
name|wc_version
operator|)
condition|)
do|;
block|}
end_function

begin_function
specifier|static
name|void
name|xen_fetch_uptime
parameter_list|(
name|struct
name|timespec
modifier|*
name|ts
parameter_list|)
block|{
name|uint64_t
name|uptime
decl_stmt|;
name|uptime
operator|=
name|xen_fetch_vcpu_time
argument_list|(
name|DPCPU_GET
argument_list|(
name|vcpu_info
argument_list|)
argument_list|)
expr_stmt|;
name|ts
operator|->
name|tv_sec
operator|=
name|uptime
operator|/
name|NSEC_IN_SEC
expr_stmt|;
name|ts
operator|->
name|tv_nsec
operator|=
name|uptime
operator|%
name|NSEC_IN_SEC
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|xentimer_settime
parameter_list|(
name|device_t
name|dev
name|__unused
parameter_list|,
name|struct
name|timespec
modifier|*
name|ts
parameter_list|)
block|{
comment|/* 	 * Don't return EINVAL here; just silently fail if the domain isn't 	 * privileged enough to set the TOD. 	 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * \brief Return current time according to the Xen Hypervisor wallclock.  *  * \param dev	Xentimer device.  * \param ts	Pointer to store the wallclock time.  *  * \note  The Xen time structures document the hypervisor start time and the  *        uptime-since-hypervisor-start (in nsec.) They need to be combined  *        in order to calculate a TOD clock.  */
end_comment

begin_function
specifier|static
name|int
name|xentimer_gettime
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|timespec
modifier|*
name|ts
parameter_list|)
block|{
name|struct
name|timespec
name|u_ts
decl_stmt|;
name|timespecclear
argument_list|(
name|ts
argument_list|)
expr_stmt|;
name|xen_fetch_wallclock
argument_list|(
name|ts
argument_list|)
expr_stmt|;
name|xen_fetch_uptime
argument_list|(
operator|&
name|u_ts
argument_list|)
expr_stmt|;
name|timespecadd
argument_list|(
name|ts
argument_list|,
operator|&
name|u_ts
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * \brief Handle a timer interrupt for the Xen PV timer driver.  *  * \param arg	Xen timer driver softc that is expecting the interrupt.  */
end_comment

begin_function
specifier|static
name|int
name|xentimer_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|xentimer_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|xentimer_softc
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|xentimer_pcpu_data
modifier|*
name|pcpu
init|=
name|DPCPU_PTR
argument_list|(
name|xentimer_pcpu
argument_list|)
decl_stmt|;
name|pcpu
operator|->
name|last_processed
operator|=
name|xen_fetch_vcpu_time
argument_list|(
name|DPCPU_GET
argument_list|(
name|vcpu_info
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcpu
operator|->
name|timer
operator|!=
literal|0
operator|&&
name|sc
operator|->
name|et
operator|.
name|et_active
condition|)
name|sc
operator|->
name|et
operator|.
name|et_event_cb
argument_list|(
operator|&
name|sc
operator|->
name|et
argument_list|,
name|sc
operator|->
name|et
operator|.
name|et_arg
argument_list|)
expr_stmt|;
return|return
operator|(
name|FILTER_HANDLED
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xentimer_vcpu_start_timer
parameter_list|(
name|int
name|vcpu
parameter_list|,
name|uint64_t
name|next_time
parameter_list|)
block|{
name|struct
name|vcpu_set_singleshot_timer
name|single
decl_stmt|;
name|single
operator|.
name|timeout_abs_ns
operator|=
name|next_time
expr_stmt|;
name|single
operator|.
name|flags
operator|=
name|VCPU_SSHOTTMR_future
expr_stmt|;
return|return
operator|(
name|HYPERVISOR_vcpu_op
argument_list|(
name|VCPUOP_set_singleshot_timer
argument_list|,
name|vcpu
argument_list|,
operator|&
name|single
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xentimer_vcpu_stop_timer
parameter_list|(
name|int
name|vcpu
parameter_list|)
block|{
return|return
operator|(
name|HYPERVISOR_vcpu_op
argument_list|(
name|VCPUOP_stop_singleshot_timer
argument_list|,
name|vcpu
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * \brief Set the next oneshot time for the current CPU.  *  * \param et	Xen timer driver event timer to schedule on.  * \param first	Delta to the next time to schedule the interrupt for.  * \param period Not used.  *  * \note See eventtimers(9) for more information.  * \note   *  * \returns 0  */
end_comment

begin_function
specifier|static
name|int
name|xentimer_et_start
parameter_list|(
name|struct
name|eventtimer
modifier|*
name|et
parameter_list|,
name|sbintime_t
name|first
parameter_list|,
name|sbintime_t
name|period
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|,
name|i
init|=
literal|0
decl_stmt|;
name|struct
name|xentimer_softc
modifier|*
name|sc
init|=
name|et
operator|->
name|et_priv
decl_stmt|;
name|int
name|cpu
init|=
name|PCPU_GET
argument_list|(
name|vcpu_id
argument_list|)
decl_stmt|;
name|struct
name|xentimer_pcpu_data
modifier|*
name|pcpu
init|=
name|DPCPU_PTR
argument_list|(
name|xentimer_pcpu
argument_list|)
decl_stmt|;
name|struct
name|vcpu_info
modifier|*
name|vcpu
init|=
name|DPCPU_GET
argument_list|(
name|vcpu_info
argument_list|)
decl_stmt|;
name|uint64_t
name|first_in_ns
decl_stmt|,
name|next_time
decl_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|struct
name|thread
modifier|*
name|td
init|=
name|curthread
decl_stmt|;
endif|#
directive|endif
name|KASSERT
argument_list|(
name|td
operator|->
name|td_critnest
operator|!=
literal|0
argument_list|,
operator|(
literal|"xentimer_et_start called without preemption disabled"
operator|)
argument_list|)
expr_stmt|;
comment|/* See sbttots() for this formula. */
name|first_in_ns
operator|=
operator|(
operator|(
operator|(
name|first
operator|>>
literal|32
operator|)
operator|*
name|NSEC_IN_SEC
operator|)
operator|+
operator|(
operator|(
operator|(
name|uint64_t
operator|)
name|NSEC_IN_SEC
operator|*
operator|(
name|uint32_t
operator|)
name|first
operator|)
operator|>>
literal|32
operator|)
operator|)
expr_stmt|;
comment|/* 	 * Retry any timer scheduling failures, where the hypervisor 	 * returns -ETIME.  Sometimes even a 100us timer period isn't large 	 * enough, but larger period instances are relatively uncommon. 	 * 	 * XXX Remove the panics once et_start() and its consumers are 	 *     equipped to deal with start failures. 	 */
do|do
block|{
if|if
condition|(
operator|++
name|i
operator|==
literal|60
condition|)
name|panic
argument_list|(
literal|"can't schedule timer"
argument_list|)
expr_stmt|;
name|next_time
operator|=
name|xen_fetch_vcpu_time
argument_list|(
name|vcpu
argument_list|)
operator|+
name|first_in_ns
expr_stmt|;
name|error
operator|=
name|xentimer_vcpu_start_timer
argument_list|(
name|cpu
argument_list|,
name|next_time
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|error
operator|==
operator|-
name|ETIME
condition|)
do|;
if|if
condition|(
name|error
condition|)
name|panic
argument_list|(
literal|"%s: Error %d setting singleshot timer to %"
name|PRIu64
literal|"\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
name|error
argument_list|,
name|next_time
argument_list|)
expr_stmt|;
name|pcpu
operator|->
name|timer
operator|=
name|next_time
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * \brief Cancel the event timer's currently running timer, if any.  */
end_comment

begin_function
specifier|static
name|int
name|xentimer_et_stop
parameter_list|(
name|struct
name|eventtimer
modifier|*
name|et
parameter_list|)
block|{
name|int
name|cpu
init|=
name|PCPU_GET
argument_list|(
name|vcpu_id
argument_list|)
decl_stmt|;
name|struct
name|xentimer_pcpu_data
modifier|*
name|pcpu
init|=
name|DPCPU_PTR
argument_list|(
name|xentimer_pcpu
argument_list|)
decl_stmt|;
name|pcpu
operator|->
name|timer
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|xentimer_vcpu_stop_timer
argument_list|(
name|cpu
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * \brief Attach a Xen PV timer driver instance.  *   * \param dev	Bus device object to attach.  *  * \note  * \returns EINVAL   */
end_comment

begin_function
specifier|static
name|int
name|xentimer_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|xentimer_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
name|sc
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
comment|/* Bind an event channel to a VIRQ on each VCPU. */
name|CPU_FOREACH
argument_list|(
argument|i
argument_list|)
block|{
name|struct
name|xentimer_pcpu_data
modifier|*
name|pcpu
decl_stmt|;
name|pcpu
operator|=
name|DPCPU_ID_PTR
argument_list|(
name|i
argument_list|,
name|xentimer_pcpu
argument_list|)
expr_stmt|;
name|error
operator|=
name|HYPERVISOR_vcpu_op
argument_list|(
name|VCPUOP_stop_periodic_timer
argument_list|,
name|i
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Error disabling Xen periodic timer "
literal|"on CPU %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
name|xen_intr_bind_virq
argument_list|(
name|dev
argument_list|,
name|VIRQ_TIMER
argument_list|,
name|i
argument_list|,
name|xentimer_intr
argument_list|,
name|NULL
argument_list|,
name|sc
argument_list|,
name|INTR_TYPE_CLK
argument_list|,
operator|&
name|pcpu
operator|->
name|irq_handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Error %d binding VIRQ_TIMER "
literal|"to VCPU %d\n"
argument_list|,
name|error
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|xen_intr_describe
argument_list|(
name|pcpu
operator|->
name|irq_handle
argument_list|,
literal|"c%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* Register the event timer. */
name|sc
operator|->
name|et
operator|.
name|et_name
operator|=
literal|"XENTIMER"
expr_stmt|;
name|sc
operator|->
name|et
operator|.
name|et_quality
operator|=
name|XENTIMER_QUALITY
expr_stmt|;
name|sc
operator|->
name|et
operator|.
name|et_flags
operator|=
name|ET_FLAGS_ONESHOT
operator||
name|ET_FLAGS_PERCPU
expr_stmt|;
name|sc
operator|->
name|et
operator|.
name|et_frequency
operator|=
name|NSEC_IN_SEC
expr_stmt|;
comment|/* See tstosbt() for this formula */
name|sc
operator|->
name|et
operator|.
name|et_min_period
operator|=
operator|(
name|XENTIMER_MIN_PERIOD_IN_NSEC
operator|*
operator|(
operator|(
operator|(
name|uint64_t
operator|)
literal|1
operator|<<
literal|63
operator|)
operator|/
literal|500000000
operator|)
operator|>>
literal|32
operator|)
expr_stmt|;
name|sc
operator|->
name|et
operator|.
name|et_max_period
operator|=
operator|(
operator|(
name|sbintime_t
operator|)
literal|4
operator|<<
literal|32
operator|)
expr_stmt|;
name|sc
operator|->
name|et
operator|.
name|et_start
operator|=
name|xentimer_et_start
expr_stmt|;
name|sc
operator|->
name|et
operator|.
name|et_stop
operator|=
name|xentimer_et_stop
expr_stmt|;
name|sc
operator|->
name|et
operator|.
name|et_priv
operator|=
name|sc
expr_stmt|;
name|et_register
argument_list|(
operator|&
name|sc
operator|->
name|et
argument_list|)
expr_stmt|;
comment|/* Register the timecounter. */
name|sc
operator|->
name|tc
operator|.
name|tc_name
operator|=
literal|"XENTIMER"
expr_stmt|;
name|sc
operator|->
name|tc
operator|.
name|tc_quality
operator|=
name|XENTIMER_QUALITY
expr_stmt|;
name|sc
operator|->
name|tc
operator|.
name|tc_flags
operator|=
name|TC_FLAGS_SUSPEND_SAFE
expr_stmt|;
comment|/* 	 * The underlying resolution is in nanoseconds, since the timer info 	 * scales TSC frequencies using a fraction that represents time in 	 * terms of nanoseconds. 	 */
name|sc
operator|->
name|tc
operator|.
name|tc_frequency
operator|=
name|NSEC_IN_SEC
expr_stmt|;
name|sc
operator|->
name|tc
operator|.
name|tc_counter_mask
operator|=
operator|~
literal|0u
expr_stmt|;
name|sc
operator|->
name|tc
operator|.
name|tc_get_timecount
operator|=
name|xentimer_get_timecount
expr_stmt|;
name|sc
operator|->
name|tc
operator|.
name|tc_priv
operator|=
name|sc
expr_stmt|;
name|tc_init
argument_list|(
operator|&
name|sc
operator|->
name|tc
argument_list|)
expr_stmt|;
comment|/* Register the Hypervisor wall clock */
name|clock_register
argument_list|(
name|dev
argument_list|,
name|XENCLOCK_RESOLUTION
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xentimer_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
comment|/* Implement Xen PV clock teardown - XXX see hpet_detach ? */
comment|/* If possible: 	 * 1. need to deregister timecounter 	 * 2. need to deregister event timer 	 * 3. need to deregister virtual IRQ event channels 	 */
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xentimer_percpu_resume
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|device_t
name|dev
init|=
operator|(
name|device_t
operator|)
name|arg
decl_stmt|;
name|struct
name|xentimer_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|xentimer_et_start
argument_list|(
operator|&
name|sc
operator|->
name|et
argument_list|,
name|sc
operator|->
name|et
operator|.
name|et_min_period
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|xentimer_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Disable the periodic timer */
name|CPU_FOREACH
argument_list|(
argument|i
argument_list|)
block|{
name|error
operator|=
name|HYPERVISOR_vcpu_op
argument_list|(
name|VCPUOP_stop_periodic_timer
argument_list|,
name|i
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Error disabling Xen periodic timer on CPU %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
comment|/* Reset the last uptime value */
name|xen_timer_last_time
operator|=
literal|0
expr_stmt|;
comment|/* Reset the RTC clock */
name|inittodr
argument_list|(
name|time_second
argument_list|)
expr_stmt|;
comment|/* Kick the timers on all CPUs */
name|smp_rendezvous
argument_list|(
name|NULL
argument_list|,
name|xentimer_percpu_resume
argument_list|,
name|NULL
argument_list|,
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"resumed operation after suspension\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xentimer_suspend
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Xen early clock init  */
end_comment

begin_function
name|void
name|xen_clock_init
parameter_list|(
name|void
parameter_list|)
block|{ }
end_function

begin_comment
comment|/*  * Xen PV DELAY function  *  * When running on PVH mode we don't have an emulated i8524, so  * make use of the Xen time info in order to code a simple DELAY  * function that can be used during early boot.  */
end_comment

begin_function
name|void
name|xen_delay
parameter_list|(
name|int
name|n
parameter_list|)
block|{
name|struct
name|vcpu_info
modifier|*
name|vcpu
init|=
operator|&
name|HYPERVISOR_shared_info
operator|->
name|vcpu_info
index|[
literal|0
index|]
decl_stmt|;
name|uint64_t
name|end_ns
decl_stmt|;
name|uint64_t
name|current
decl_stmt|;
name|end_ns
operator|=
name|xen_fetch_vcpu_time
argument_list|(
name|vcpu
argument_list|)
expr_stmt|;
name|end_ns
operator|+=
name|n
operator|*
name|NSEC_IN_USEC
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|current
operator|=
name|xen_fetch_vcpu_time
argument_list|(
name|vcpu
argument_list|)
expr_stmt|;
if|if
condition|(
name|current
operator|>=
name|end_ns
condition|)
break|break;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|xentimer_methods
index|[]
init|=
block|{
name|DEVMETHOD
argument_list|(
name|device_identify
argument_list|,
name|xentimer_identify
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|xentimer_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|xentimer_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|xentimer_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|xentimer_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|xentimer_resume
argument_list|)
block|,
comment|/* clock interface */
name|DEVMETHOD
argument_list|(
name|clock_gettime
argument_list|,
name|xentimer_gettime
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|clock_settime
argument_list|,
name|xentimer_settime
argument_list|)
block|,
name|DEVMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|xentimer_driver
init|=
block|{
literal|"xen_et"
block|,
name|xentimer_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|xentimer_softc
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|xentimer
argument_list|,
name|xenpv
argument_list|,
name|xentimer_driver
argument_list|,
name|xentimer_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|xentimer
argument_list|,
name|xenpv
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

