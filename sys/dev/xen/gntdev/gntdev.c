begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2016 Akshay Jaggi<jaggi@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * gntdev.c  *   * Interface to /dev/xen/gntdev.  *   */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/rwlock.h>
end_include

begin_include
include|#
directive|include
file|<sys/selinfo.h>
end_include

begin_include
include|#
directive|include
file|<sys/poll.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioccom.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/tree.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/bitset.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_object.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_pager.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<xen/xen-os.h>
end_include

begin_include
include|#
directive|include
file|<xen/hypervisor.h>
end_include

begin_include
include|#
directive|include
file|<xen/error.h>
end_include

begin_include
include|#
directive|include
file|<xen/xen_intr.h>
end_include

begin_include
include|#
directive|include
file|<xen/gnttab.h>
end_include

begin_include
include|#
directive|include
file|<xen/gntdev.h>
end_include

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_GNTDEV
argument_list|,
literal|"gntdev"
argument_list|,
literal|"Xen grant-table user-space device"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|MAX_OFFSET_COUNT
value|((0xffffffffffffffffull>> PAGE_SHIFT) + 1)
end_define

begin_decl_stmt
specifier|static
name|d_open_t
name|gntdev_open
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|gntdev_ioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_mmap_single_t
name|gntdev_mmap_single
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|gntdev_devsw
init|=
block|{
operator|.
name|d_version
operator|=
name|D_VERSION
block|,
operator|.
name|d_open
operator|=
name|gntdev_open
block|,
operator|.
name|d_ioctl
operator|=
name|gntdev_ioctl
block|,
operator|.
name|d_mmap_single
operator|=
name|gntdev_mmap_single
block|,
operator|.
name|d_name
operator|=
literal|"gntdev"
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_t
name|gntdev_dev
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_struct_decl
struct_decl|struct
name|gntdev_gref
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|gntdev_gmap
struct_decl|;
end_struct_decl

begin_expr_stmt
name|STAILQ_HEAD
argument_list|(
name|gref_list_head
argument_list|,
name|gntdev_gref
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|STAILQ_HEAD
argument_list|(
name|gmap_list_head
argument_list|,
name|gntdev_gmap
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|RB_HEAD
argument_list|(
name|gref_tree_head
argument_list|,
name|gntdev_gref
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|RB_HEAD
argument_list|(
name|gmap_tree_head
argument_list|,
name|gntdev_gmap
argument_list|)
expr_stmt|;
end_expr_stmt

begin_struct
struct|struct
name|file_offset_struct
block|{
name|RB_ENTRY
argument_list|(
argument|file_offset_struct
argument_list|)
name|next
expr_stmt|;
name|uint64_t
name|file_offset
decl_stmt|;
name|uint64_t
name|count
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|offset_cmp
parameter_list|(
name|struct
name|file_offset_struct
modifier|*
name|f1
parameter_list|,
name|struct
name|file_offset_struct
modifier|*
name|f2
parameter_list|)
block|{
return|return
operator|(
name|f1
operator|->
name|file_offset
operator|-
name|f2
operator|->
name|file_offset
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|RB_HEAD
argument_list|(
name|file_offset_head
argument_list|,
name|file_offset_struct
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|RB_GENERATE_STATIC
argument_list|(
name|file_offset_head
argument_list|,
name|file_offset_struct
argument_list|,
name|next
argument_list|,
name|offset_cmp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_struct
struct|struct
name|per_user_data
block|{
name|struct
name|mtx
name|user_data_lock
decl_stmt|;
name|struct
name|gref_tree_head
name|gref_tree
decl_stmt|;
name|struct
name|gmap_tree_head
name|gmap_tree
decl_stmt|;
name|struct
name|file_offset_head
name|file_offset
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Get offset into the file which will be used while mmapping the  * appropriate pages by the userspace program.  */
end_comment

begin_function
specifier|static
name|int
name|get_file_offset
parameter_list|(
name|struct
name|per_user_data
modifier|*
name|priv_user
parameter_list|,
name|uint32_t
name|count
parameter_list|,
name|uint64_t
modifier|*
name|file_offset
parameter_list|)
block|{
name|struct
name|file_offset_struct
modifier|*
name|offset
decl_stmt|,
modifier|*
name|offset_tmp
decl_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|mtx_lock
argument_list|(
operator|&
name|priv_user
operator|->
name|user_data_lock
argument_list|)
expr_stmt|;
name|RB_FOREACH_SAFE
argument_list|(
argument|offset
argument_list|,
argument|file_offset_head
argument_list|,
argument|&priv_user->file_offset
argument_list|,
argument|offset_tmp
argument_list|)
block|{
if|if
condition|(
name|offset
operator|->
name|count
operator|>=
name|count
condition|)
block|{
name|offset
operator|->
name|count
operator|-=
name|count
expr_stmt|;
operator|*
name|file_offset
operator|=
name|offset
operator|->
name|file_offset
operator|+
name|offset
operator|->
name|count
operator|*
name|PAGE_SIZE
expr_stmt|;
if|if
condition|(
name|offset
operator|->
name|count
operator|==
literal|0
condition|)
block|{
name|RB_REMOVE
argument_list|(
name|file_offset_head
argument_list|,
operator|&
name|priv_user
operator|->
name|file_offset
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|offset
argument_list|,
name|M_GNTDEV
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|priv_user
operator|->
name|user_data_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|priv_user
operator|->
name|user_data_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOSPC
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|put_file_offset
parameter_list|(
name|struct
name|per_user_data
modifier|*
name|priv_user
parameter_list|,
name|uint32_t
name|count
parameter_list|,
name|uint64_t
name|file_offset
parameter_list|)
block|{
name|struct
name|file_offset_struct
modifier|*
name|offset
decl_stmt|,
modifier|*
name|offset_nxt
decl_stmt|,
modifier|*
name|offset_prv
decl_stmt|;
name|offset
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|offset
argument_list|)
argument_list|,
name|M_GNTDEV
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|offset
operator|->
name|file_offset
operator|=
name|file_offset
expr_stmt|;
name|offset
operator|->
name|count
operator|=
name|count
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|priv_user
operator|->
name|user_data_lock
argument_list|)
expr_stmt|;
name|RB_INSERT
argument_list|(
name|file_offset_head
argument_list|,
operator|&
name|priv_user
operator|->
name|file_offset
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|offset_nxt
operator|=
name|RB_NEXT
argument_list|(
name|file_offset_head
argument_list|,
operator|&
name|priv_user
operator|->
name|file_offset
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|offset_prv
operator|=
name|RB_PREV
argument_list|(
name|file_offset_head
argument_list|,
operator|&
name|priv_user
operator|->
name|file_offset
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset_nxt
operator|!=
name|NULL
operator|&&
name|offset_nxt
operator|->
name|file_offset
operator|==
name|offset
operator|->
name|file_offset
operator|+
name|offset
operator|->
name|count
operator|*
name|PAGE_SIZE
condition|)
block|{
name|offset
operator|->
name|count
operator|+=
name|offset_nxt
operator|->
name|count
expr_stmt|;
name|RB_REMOVE
argument_list|(
name|file_offset_head
argument_list|,
operator|&
name|priv_user
operator|->
name|file_offset
argument_list|,
name|offset_nxt
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|offset_nxt
argument_list|,
name|M_GNTDEV
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|offset_prv
operator|!=
name|NULL
operator|&&
name|offset
operator|->
name|file_offset
operator|==
name|offset_prv
operator|->
name|file_offset
operator|+
name|offset_prv
operator|->
name|count
operator|*
name|PAGE_SIZE
condition|)
block|{
name|offset_prv
operator|->
name|count
operator|+=
name|offset
operator|->
name|count
expr_stmt|;
name|RB_REMOVE
argument_list|(
name|file_offset_head
argument_list|,
operator|&
name|priv_user
operator|->
name|file_offset
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|offset
argument_list|,
name|M_GNTDEV
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|priv_user
operator|->
name|user_data_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function_decl
specifier|static
name|int
name|gntdev_gmap_pg_ctor
parameter_list|(
name|void
modifier|*
name|handle
parameter_list|,
name|vm_ooffset_t
name|size
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|,
name|vm_ooffset_t
name|foff
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|u_short
modifier|*
name|color
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gntdev_gmap_pg_dtor
parameter_list|(
name|void
modifier|*
name|handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|gntdev_gmap_pg_fault
parameter_list|(
name|vm_object_t
name|object
parameter_list|,
name|vm_ooffset_t
name|offset
parameter_list|,
name|int
name|prot
parameter_list|,
name|vm_page_t
modifier|*
name|mres
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|cdev_pager_ops
name|gntdev_gmap_pg_ops
init|=
block|{
operator|.
name|cdev_pg_fault
operator|=
name|gntdev_gmap_pg_fault
block|,
operator|.
name|cdev_pg_ctor
operator|=
name|gntdev_gmap_pg_ctor
block|,
operator|.
name|cdev_pg_dtor
operator|=
name|gntdev_gmap_pg_dtor
block|, }
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|cleanup_data_struct
block|{
name|struct
name|mtx
name|to_kill_grefs_mtx
decl_stmt|;
name|struct
name|mtx
name|to_kill_gmaps_mtx
decl_stmt|;
name|struct
name|gref_list_head
name|to_kill_grefs
decl_stmt|;
name|struct
name|gmap_list_head
name|to_kill_gmaps
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|cleanup_data_struct
name|cleanup_data
init|=
block|{
operator|.
name|to_kill_grefs
operator|=
name|STAILQ_HEAD_INITIALIZER
argument_list|(
name|cleanup_data
operator|.
name|to_kill_grefs
argument_list|)
block|,
operator|.
name|to_kill_gmaps
operator|=
name|STAILQ_HEAD_INITIALIZER
argument_list|(
name|cleanup_data
operator|.
name|to_kill_gmaps
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MTX_SYSINIT
argument_list|(
name|to_kill_grefs_mtx
argument_list|,
operator|&
name|cleanup_data
operator|.
name|to_kill_grefs_mtx
argument_list|,
literal|"gntdev to_kill_grefs mutex"
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MTX_SYSINIT
argument_list|(
name|to_kill_gmaps_mtx
argument_list|,
operator|&
name|cleanup_data
operator|.
name|to_kill_gmaps_mtx
argument_list|,
literal|"gntdev to_kill_gmaps mutex"
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|void
name|cleanup_function
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|__unused
name|int
name|pending
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|task
name|cleanup_task
init|=
name|TASK_INITIALIZER
argument_list|(
literal|0
argument_list|,
name|cleanup_function
argument_list|,
operator|&
name|cleanup_data
argument_list|)
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|notify_data
block|{
name|uint64_t
name|index
decl_stmt|;
name|uint32_t
name|action
decl_stmt|;
name|uint32_t
name|event_channel_port
decl_stmt|;
name|xen_intr_handle_t
name|notify_evtchn_handle
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|void
name|notify
parameter_list|(
name|struct
name|notify_data
modifier|*
name|notify
parameter_list|,
name|vm_page_t
name|page
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*-------------------- Grant Allocation Methods  -----------------------------*/
end_comment

begin_struct
struct|struct
name|gntdev_gref
block|{
union|union
name|gref_next_union
block|{
name|STAILQ_ENTRY
argument_list|(
argument|gntdev_gref
argument_list|)
name|list
expr_stmt|;
name|RB_ENTRY
argument_list|(
argument|gntdev_gref
argument_list|)
name|tree
expr_stmt|;
block|}
name|gref_next
union|;
name|uint64_t
name|file_index
decl_stmt|;
name|grant_ref_t
name|gref_id
decl_stmt|;
name|vm_page_t
name|page
decl_stmt|;
name|struct
name|notify_data
modifier|*
name|notify
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|gref_cmp
parameter_list|(
name|struct
name|gntdev_gref
modifier|*
name|g1
parameter_list|,
name|struct
name|gntdev_gref
modifier|*
name|g2
parameter_list|)
block|{
return|return
operator|(
name|g1
operator|->
name|file_index
operator|-
name|g2
operator|->
name|file_index
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|RB_GENERATE_STATIC
argument_list|(
name|gref_tree_head
argument_list|,
name|gntdev_gref
argument_list|,
name|gref_next
operator|.
name|tree
argument_list|,
name|gref_cmp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Traverse over the device-list of to-be-deleted grants allocated, and  * if all accesses, both local mmaps and foreign maps, to them have ended,  * destroy them.  */
end_comment

begin_function
specifier|static
name|void
name|gref_list_dtor
parameter_list|(
name|struct
name|cleanup_data_struct
modifier|*
name|cleanup_data
parameter_list|)
block|{
name|struct
name|gref_list_head
name|tmp_grefs
decl_stmt|;
name|struct
name|gntdev_gref
modifier|*
name|gref
decl_stmt|,
modifier|*
name|gref_tmp
decl_stmt|,
modifier|*
name|gref_previous
decl_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|tmp_grefs
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|cleanup_data
operator|->
name|to_kill_grefs_mtx
argument_list|)
expr_stmt|;
name|STAILQ_SWAP
argument_list|(
operator|&
name|cleanup_data
operator|->
name|to_kill_grefs
argument_list|,
operator|&
name|tmp_grefs
argument_list|,
name|gntdev_gref
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|cleanup_data
operator|->
name|to_kill_grefs_mtx
argument_list|)
expr_stmt|;
name|gref_previous
operator|=
name|NULL
expr_stmt|;
name|STAILQ_FOREACH_SAFE
argument_list|(
argument|gref
argument_list|,
argument|&tmp_grefs
argument_list|,
argument|gref_next.list
argument_list|,
argument|gref_tmp
argument_list|)
block|{
if|if
condition|(
name|gref
operator|->
name|page
operator|&&
name|gref
operator|->
name|page
operator|->
name|object
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|gref
operator|->
name|notify
condition|)
block|{
name|notify
argument_list|(
name|gref
operator|->
name|notify
argument_list|,
name|gref
operator|->
name|page
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gref
operator|->
name|gref_id
operator|!=
name|GRANT_REF_INVALID
condition|)
block|{
if|if
condition|(
name|gnttab_query_foreign_access
argument_list|(
name|gref
operator|->
name|gref_id
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|gnttab_end_foreign_access_ref
argument_list|(
name|gref
operator|->
name|gref_id
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
name|gnttab_free_grant_reference
argument_list|(
name|gref
operator|->
name|gref_id
argument_list|)
expr_stmt|;
block|}
name|vm_page_unwire
argument_list|(
name|gref
operator|->
name|page
argument_list|,
name|PQ_NONE
argument_list|)
expr_stmt|;
name|vm_page_free
argument_list|(
name|gref
operator|->
name|page
argument_list|)
expr_stmt|;
name|gref
operator|->
name|page
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|gref
operator|->
name|page
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|gref_previous
operator|==
name|NULL
condition|)
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|tmp_grefs
argument_list|,
name|gref_next
operator|.
name|list
argument_list|)
expr_stmt|;
else|else
name|STAILQ_REMOVE_AFTER
argument_list|(
operator|&
name|tmp_grefs
argument_list|,
name|gref_previous
argument_list|,
name|gref_next
operator|.
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
name|gref
operator|->
name|notify
condition|)
name|free
argument_list|(
name|gref
operator|->
name|notify
argument_list|,
name|M_GNTDEV
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|gref
argument_list|,
name|M_GNTDEV
argument_list|)
expr_stmt|;
block|}
else|else
name|gref_previous
operator|=
name|gref
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|STAILQ_EMPTY
argument_list|(
operator|&
name|tmp_grefs
argument_list|)
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|cleanup_data
operator|->
name|to_kill_grefs_mtx
argument_list|)
expr_stmt|;
name|STAILQ_CONCAT
argument_list|(
operator|&
name|cleanup_data
operator|->
name|to_kill_grefs
argument_list|,
operator|&
name|tmp_grefs
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|cleanup_data
operator|->
name|to_kill_grefs_mtx
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Find count number of contiguous allocated grants for a given userspace  * program by file-offset (index).  */
end_comment

begin_function
specifier|static
name|struct
name|gntdev_gref
modifier|*
name|gntdev_find_grefs
parameter_list|(
name|struct
name|per_user_data
modifier|*
name|priv_user
parameter_list|,
name|uint64_t
name|index
parameter_list|,
name|uint32_t
name|count
parameter_list|)
block|{
name|struct
name|gntdev_gref
name|find_gref
decl_stmt|,
modifier|*
name|gref
decl_stmt|,
modifier|*
name|gref_start
init|=
name|NULL
decl_stmt|;
name|find_gref
operator|.
name|file_index
operator|=
name|index
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|priv_user
operator|->
name|user_data_lock
argument_list|)
expr_stmt|;
name|gref_start
operator|=
name|RB_FIND
argument_list|(
name|gref_tree_head
argument_list|,
operator|&
name|priv_user
operator|->
name|gref_tree
argument_list|,
operator|&
name|find_gref
argument_list|)
expr_stmt|;
for|for
control|(
name|gref
operator|=
name|gref_start
init|;
name|gref
operator|!=
name|NULL
operator|&&
name|count
operator|>
literal|0
condition|;
name|gref
operator|=
name|RB_NEXT
argument_list|(
name|gref_tree_head
argument_list|,
operator|&
name|priv_user
operator|->
name|gref_tree
argument_list|,
name|gref
argument_list|)
control|)
block|{
if|if
condition|(
name|index
operator|!=
name|gref
operator|->
name|file_index
condition|)
break|break;
name|index
operator|+=
name|PAGE_SIZE
expr_stmt|;
name|count
operator|--
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|priv_user
operator|->
name|user_data_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
name|gref_start
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * IOCTL_GNTDEV_ALLOC_GREF  * Allocate required number of wired pages for the request, grant foreign  * access to the physical frames for these pages, and add details about  * this allocation to the per user private data, so that these pages can  * be mmapped by the userspace program.  */
end_comment

begin_function
specifier|static
name|int
name|gntdev_alloc_gref
parameter_list|(
name|struct
name|ioctl_gntdev_alloc_gref
modifier|*
name|arg
parameter_list|)
block|{
name|uint32_t
name|i
decl_stmt|;
name|int
name|error
decl_stmt|,
name|readonly
decl_stmt|;
name|uint64_t
name|file_offset
decl_stmt|;
name|struct
name|gntdev_gref
modifier|*
name|grefs
decl_stmt|;
name|struct
name|per_user_data
modifier|*
name|priv_user
decl_stmt|;
name|readonly
operator|=
operator|!
operator|(
name|arg
operator|->
name|flags
operator|&
name|GNTDEV_ALLOC_FLAG_WRITABLE
operator|)
expr_stmt|;
name|error
operator|=
name|devfs_get_cdevpriv
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|priv_user
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* Cleanup grefs and free pages. */
name|taskqueue_enqueue
argument_list|(
name|taskqueue_thread
argument_list|,
operator|&
name|cleanup_task
argument_list|)
expr_stmt|;
comment|/* Get file offset for this request. */
name|error
operator|=
name|get_file_offset
argument_list|(
name|priv_user
argument_list|,
name|arg
operator|->
name|count
argument_list|,
operator|&
name|file_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Allocate grefs. */
name|grefs
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|grefs
argument_list|)
operator|*
name|arg
operator|->
name|count
argument_list|,
name|M_GNTDEV
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|arg
operator|->
name|count
condition|;
name|i
operator|++
control|)
block|{
name|grefs
index|[
name|i
index|]
operator|.
name|file_index
operator|=
name|file_offset
operator|+
name|i
operator|*
name|PAGE_SIZE
expr_stmt|;
name|grefs
index|[
name|i
index|]
operator|.
name|gref_id
operator|=
name|GRANT_REF_INVALID
expr_stmt|;
name|grefs
index|[
name|i
index|]
operator|.
name|notify
operator|=
name|NULL
expr_stmt|;
name|grefs
index|[
name|i
index|]
operator|.
name|page
operator|=
name|vm_page_alloc
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|VM_ALLOC_NORMAL
operator||
name|VM_ALLOC_NOOBJ
operator||
name|VM_ALLOC_WIRED
operator||
name|VM_ALLOC_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|grefs
index|[
name|i
index|]
operator|.
name|page
operator|==
name|NULL
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Page allocation failed."
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|grefs
index|[
name|i
index|]
operator|.
name|page
operator|->
name|flags
operator|&
name|PG_ZERO
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Zero the allocated page, as we don't want to  			 * leak our memory to other domains. 			 */
name|pmap_zero_page
argument_list|(
name|grefs
index|[
name|i
index|]
operator|.
name|page
argument_list|)
expr_stmt|;
block|}
name|grefs
index|[
name|i
index|]
operator|.
name|page
operator|->
name|valid
operator|=
name|VM_PAGE_BITS_ALL
expr_stmt|;
name|error
operator|=
name|gnttab_grant_foreign_access
argument_list|(
name|arg
operator|->
name|domid
argument_list|,
operator|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|grefs
index|[
name|i
index|]
operator|.
name|page
argument_list|)
operator|>>
name|PAGE_SHIFT
operator|)
argument_list|,
name|readonly
argument_list|,
operator|&
name|grefs
index|[
name|i
index|]
operator|.
name|gref_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Grant Table Hypercall failed."
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * If target domain maps the gref (by guessing the gref-id), 		 * then we can't clean it up yet and we have to leave the  		 * page in place so as to not leak our memory to that domain. 		 * Add it to a global list to be cleaned up later. 		 */
name|mtx_lock
argument_list|(
operator|&
name|cleanup_data
operator|.
name|to_kill_grefs_mtx
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|arg
operator|->
name|count
condition|;
name|i
operator|++
control|)
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|cleanup_data
operator|.
name|to_kill_grefs
argument_list|,
operator|&
name|grefs
index|[
name|i
index|]
argument_list|,
name|gref_next
operator|.
name|list
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|cleanup_data
operator|.
name|to_kill_grefs_mtx
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|taskqueue_thread
argument_list|,
operator|&
name|cleanup_task
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* Copy the output values. */
name|arg
operator|->
name|index
operator|=
name|file_offset
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|arg
operator|->
name|count
condition|;
name|i
operator|++
control|)
name|arg
operator|->
name|gref_ids
index|[
name|i
index|]
operator|=
name|grefs
index|[
name|i
index|]
operator|.
name|gref_id
expr_stmt|;
comment|/* Modify the per user private data. */
name|mtx_lock
argument_list|(
operator|&
name|priv_user
operator|->
name|user_data_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|arg
operator|->
name|count
condition|;
name|i
operator|++
control|)
name|RB_INSERT
argument_list|(
name|gref_tree_head
argument_list|,
operator|&
name|priv_user
operator|->
name|gref_tree
argument_list|,
operator|&
name|grefs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|priv_user
operator|->
name|user_data_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * IOCTL_GNTDEV_DEALLOC_GREF  * Remove grant allocation information from the per user private data, so  * that it can't be mmapped anymore by the userspace program, and add it  * to the to-be-deleted grants global device-list.  */
end_comment

begin_function
specifier|static
name|int
name|gntdev_dealloc_gref
parameter_list|(
name|struct
name|ioctl_gntdev_dealloc_gref
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|uint32_t
name|count
decl_stmt|;
name|struct
name|gntdev_gref
modifier|*
name|gref
decl_stmt|,
modifier|*
name|gref_tmp
decl_stmt|;
name|struct
name|per_user_data
modifier|*
name|priv_user
decl_stmt|;
name|error
operator|=
name|devfs_get_cdevpriv
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|priv_user
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|gref
operator|=
name|gntdev_find_grefs
argument_list|(
name|priv_user
argument_list|,
name|arg
operator|->
name|index
argument_list|,
name|arg
operator|->
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|gref
operator|==
name|NULL
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Can't find requested grant-refs."
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Remove the grefs from user private data. */
name|count
operator|=
name|arg
operator|->
name|count
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|priv_user
operator|->
name|user_data_lock
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|cleanup_data
operator|.
name|to_kill_grefs_mtx
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|gref
operator|!=
name|NULL
operator|&&
name|count
operator|>
literal|0
condition|;
name|gref
operator|=
name|gref_tmp
control|)
block|{
name|gref_tmp
operator|=
name|RB_NEXT
argument_list|(
name|gref_tree_head
argument_list|,
operator|&
name|priv_user
operator|->
name|gref_tree
argument_list|,
name|gref
argument_list|)
expr_stmt|;
name|RB_REMOVE
argument_list|(
name|gref_tree_head
argument_list|,
operator|&
name|priv_user
operator|->
name|gref_tree
argument_list|,
name|gref
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|cleanup_data
operator|.
name|to_kill_grefs
argument_list|,
name|gref
argument_list|,
name|gref_next
operator|.
name|list
argument_list|)
expr_stmt|;
name|count
operator|--
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|cleanup_data
operator|.
name|to_kill_grefs_mtx
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|priv_user
operator|->
name|user_data_lock
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|taskqueue_thread
argument_list|,
operator|&
name|cleanup_task
argument_list|)
expr_stmt|;
name|put_file_offset
argument_list|(
name|priv_user
argument_list|,
name|arg
operator|->
name|count
argument_list|,
name|arg
operator|->
name|index
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-------------------- Grant Mapping Methods  --------------------------------*/
end_comment

begin_struct
struct|struct
name|gntdev_gmap_map
block|{
name|vm_object_t
name|mem
decl_stmt|;
name|struct
name|resource
modifier|*
name|pseudo_phys_res
decl_stmt|;
name|int
name|pseudo_phys_res_id
decl_stmt|;
name|vm_paddr_t
name|phys_base_addr
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|gntdev_gmap
block|{
union|union
name|gmap_next_union
block|{
name|STAILQ_ENTRY
argument_list|(
argument|gntdev_gmap
argument_list|)
name|list
expr_stmt|;
name|RB_ENTRY
argument_list|(
argument|gntdev_gmap
argument_list|)
name|tree
expr_stmt|;
block|}
name|gmap_next
union|;
name|uint64_t
name|file_index
decl_stmt|;
name|uint32_t
name|count
decl_stmt|;
name|struct
name|gnttab_map_grant_ref
modifier|*
name|grant_map_ops
decl_stmt|;
name|struct
name|gntdev_gmap_map
modifier|*
name|map
decl_stmt|;
name|struct
name|notify_data
modifier|*
name|notify
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|gmap_cmp
parameter_list|(
name|struct
name|gntdev_gmap
modifier|*
name|g1
parameter_list|,
name|struct
name|gntdev_gmap
modifier|*
name|g2
parameter_list|)
block|{
return|return
operator|(
name|g1
operator|->
name|file_index
operator|-
name|g2
operator|->
name|file_index
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|RB_GENERATE_STATIC
argument_list|(
name|gmap_tree_head
argument_list|,
name|gntdev_gmap
argument_list|,
name|gmap_next
operator|.
name|tree
argument_list|,
name|gmap_cmp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Traverse over the device-list of to-be-deleted grant mappings, and if  * the region is no longer mmapped by anyone, free the memory used to  * store information about the mapping.  */
end_comment

begin_function
specifier|static
name|void
name|gmap_list_dtor
parameter_list|(
name|struct
name|cleanup_data_struct
modifier|*
name|cleanup_data
parameter_list|)
block|{
name|struct
name|gmap_list_head
name|tmp_gmaps
decl_stmt|;
name|struct
name|gntdev_gmap
modifier|*
name|gmap
decl_stmt|,
modifier|*
name|gmap_tmp
decl_stmt|,
modifier|*
name|gmap_previous
decl_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|tmp_gmaps
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|cleanup_data
operator|->
name|to_kill_gmaps_mtx
argument_list|)
expr_stmt|;
name|STAILQ_SWAP
argument_list|(
operator|&
name|cleanup_data
operator|->
name|to_kill_gmaps
argument_list|,
operator|&
name|tmp_gmaps
argument_list|,
name|gntdev_gmap
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|cleanup_data
operator|->
name|to_kill_gmaps_mtx
argument_list|)
expr_stmt|;
name|gmap_previous
operator|=
name|NULL
expr_stmt|;
name|STAILQ_FOREACH_SAFE
argument_list|(
argument|gmap
argument_list|,
argument|&tmp_gmaps
argument_list|,
argument|gmap_next.list
argument_list|,
argument|gmap_tmp
argument_list|)
block|{
if|if
condition|(
name|gmap
operator|->
name|map
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|gmap_previous
operator|==
name|NULL
condition|)
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|tmp_gmaps
argument_list|,
name|gmap_next
operator|.
name|list
argument_list|)
expr_stmt|;
else|else
name|STAILQ_REMOVE_AFTER
argument_list|(
operator|&
name|tmp_gmaps
argument_list|,
name|gmap_previous
argument_list|,
name|gmap_next
operator|.
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
name|gmap
operator|->
name|notify
condition|)
name|free
argument_list|(
name|gmap
operator|->
name|notify
argument_list|,
name|M_GNTDEV
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|gmap
operator|->
name|grant_map_ops
argument_list|,
name|M_GNTDEV
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|gmap
argument_list|,
name|M_GNTDEV
argument_list|)
expr_stmt|;
block|}
else|else
name|gmap_previous
operator|=
name|gmap
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|STAILQ_EMPTY
argument_list|(
operator|&
name|tmp_gmaps
argument_list|)
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|cleanup_data
operator|->
name|to_kill_gmaps_mtx
argument_list|)
expr_stmt|;
name|STAILQ_CONCAT
argument_list|(
operator|&
name|cleanup_data
operator|->
name|to_kill_gmaps
argument_list|,
operator|&
name|tmp_gmaps
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|cleanup_data
operator|->
name|to_kill_gmaps_mtx
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Find mapped grants for a given userspace program, by file-offset (index)  * and count, as supplied during the map-ioctl.  */
end_comment

begin_function
specifier|static
name|struct
name|gntdev_gmap
modifier|*
name|gntdev_find_gmap
parameter_list|(
name|struct
name|per_user_data
modifier|*
name|priv_user
parameter_list|,
name|uint64_t
name|index
parameter_list|,
name|uint32_t
name|count
parameter_list|)
block|{
name|struct
name|gntdev_gmap
name|find_gmap
decl_stmt|,
modifier|*
name|gmap
decl_stmt|;
name|find_gmap
operator|.
name|file_index
operator|=
name|index
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|priv_user
operator|->
name|user_data_lock
argument_list|)
expr_stmt|;
name|gmap
operator|=
name|RB_FIND
argument_list|(
name|gmap_tree_head
argument_list|,
operator|&
name|priv_user
operator|->
name|gmap_tree
argument_list|,
operator|&
name|find_gmap
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|priv_user
operator|->
name|user_data_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|gmap
operator|!=
name|NULL
operator|&&
name|gmap
operator|->
name|count
operator|==
name|count
condition|)
return|return
operator|(
name|gmap
operator|)
return|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Remove the pages from the mgtdevice pager, call the unmap hypercall,  * free the xenmem resource. This function is called during the  * destruction of the mgtdevice pager, which happens when all mmaps to  * it have been removed, and the unmap-ioctl has been performed.  */
end_comment

begin_function
specifier|static
name|int
name|notify_unmap_cleanup
parameter_list|(
name|struct
name|gntdev_gmap
modifier|*
name|gmap
parameter_list|)
block|{
name|uint32_t
name|i
decl_stmt|;
name|int
name|error
decl_stmt|,
name|count
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
name|struct
name|gnttab_unmap_grant_ref
modifier|*
name|unmap_ops
decl_stmt|;
name|unmap_ops
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|gnttab_unmap_grant_ref
argument_list|)
operator|*
name|gmap
operator|->
name|count
argument_list|,
name|M_GNTDEV
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
comment|/* Enumerate freeable maps. */
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|gmap
operator|->
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|gmap
operator|->
name|grant_map_ops
index|[
name|i
index|]
operator|.
name|handle
operator|!=
operator|-
literal|1
condition|)
block|{
name|unmap_ops
index|[
name|count
index|]
operator|.
name|handle
operator|=
name|gmap
operator|->
name|grant_map_ops
index|[
name|i
index|]
operator|.
name|handle
expr_stmt|;
name|unmap_ops
index|[
name|count
index|]
operator|.
name|host_addr
operator|=
name|gmap
operator|->
name|grant_map_ops
index|[
name|i
index|]
operator|.
name|host_addr
expr_stmt|;
name|unmap_ops
index|[
name|count
index|]
operator|.
name|dev_bus_addr
operator|=
literal|0
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
block|}
comment|/* Perform notification. */
if|if
condition|(
name|count
operator|>
literal|0
operator|&&
name|gmap
operator|->
name|notify
condition|)
block|{
name|vm_page_t
name|page
decl_stmt|;
name|uint64_t
name|page_offset
decl_stmt|;
name|page_offset
operator|=
name|gmap
operator|->
name|notify
operator|->
name|index
operator|-
name|gmap
operator|->
name|file_index
expr_stmt|;
name|page
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|gmap
operator|->
name|map
operator|->
name|phys_base_addr
operator|+
name|page_offset
argument_list|)
expr_stmt|;
name|notify
argument_list|(
name|gmap
operator|->
name|notify
argument_list|,
name|page
argument_list|)
expr_stmt|;
block|}
comment|/* Free the pages. */
name|VM_OBJECT_WLOCK
argument_list|(
name|gmap
operator|->
name|map
operator|->
name|mem
argument_list|)
expr_stmt|;
name|retry
label|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|gmap
operator|->
name|count
condition|;
name|i
operator|++
control|)
block|{
name|m
operator|=
name|vm_page_lookup
argument_list|(
name|gmap
operator|->
name|map
operator|->
name|mem
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|vm_page_sleep_if_busy
argument_list|(
name|m
argument_list|,
literal|"pcmdum"
argument_list|)
condition|)
goto|goto
name|retry
goto|;
name|cdev_pager_free_page
argument_list|(
name|gmap
operator|->
name|map
operator|->
name|mem
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
name|VM_OBJECT_WUNLOCK
argument_list|(
name|gmap
operator|->
name|map
operator|->
name|mem
argument_list|)
expr_stmt|;
comment|/* Perform unmap hypercall. */
name|error
operator|=
name|HYPERVISOR_grant_table_op
argument_list|(
name|GNTTABOP_unmap_grant_ref
argument_list|,
name|unmap_ops
argument_list|,
name|count
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|gmap
operator|->
name|count
condition|;
name|i
operator|++
control|)
block|{
name|gmap
operator|->
name|grant_map_ops
index|[
name|i
index|]
operator|.
name|handle
operator|=
operator|-
literal|1
expr_stmt|;
name|gmap
operator|->
name|grant_map_ops
index|[
name|i
index|]
operator|.
name|host_addr
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|gmap
operator|->
name|map
condition|)
block|{
name|error
operator|=
name|xenmem_free
argument_list|(
name|gntdev_dev
argument_list|,
name|gmap
operator|->
name|map
operator|->
name|pseudo_phys_res_id
argument_list|,
name|gmap
operator|->
name|map
operator|->
name|pseudo_phys_res
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|,
operator|(
literal|"Unable to release memory resource: %d"
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|gmap
operator|->
name|map
argument_list|,
name|M_GNTDEV
argument_list|)
expr_stmt|;
name|gmap
operator|->
name|map
operator|=
name|NULL
expr_stmt|;
block|}
name|free
argument_list|(
name|unmap_ops
argument_list|,
name|M_GNTDEV
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * IOCTL_GNTDEV_MAP_GRANT_REF  * Populate structures for mapping the grant reference in the per user  * private data. Actual resource allocation and map hypercall is performed  * during the mmap.  */
end_comment

begin_function
specifier|static
name|int
name|gntdev_map_grant_ref
parameter_list|(
name|struct
name|ioctl_gntdev_map_grant_ref
modifier|*
name|arg
parameter_list|)
block|{
name|uint32_t
name|i
decl_stmt|;
name|int
name|error
decl_stmt|;
name|struct
name|gntdev_gmap
modifier|*
name|gmap
decl_stmt|;
name|struct
name|per_user_data
modifier|*
name|priv_user
decl_stmt|;
name|error
operator|=
name|devfs_get_cdevpriv
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|priv_user
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|gmap
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|gmap
argument_list|)
argument_list|,
name|M_GNTDEV
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|gmap
operator|->
name|count
operator|=
name|arg
operator|->
name|count
expr_stmt|;
name|gmap
operator|->
name|grant_map_ops
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|gnttab_map_grant_ref
argument_list|)
operator|*
name|arg
operator|->
name|count
argument_list|,
name|M_GNTDEV
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|error
operator|=
name|get_file_offset
argument_list|(
name|priv_user
argument_list|,
name|arg
operator|->
name|count
argument_list|,
operator|&
name|gmap
operator|->
name|file_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|arg
operator|->
name|count
condition|;
name|i
operator|++
control|)
block|{
name|gmap
operator|->
name|grant_map_ops
index|[
name|i
index|]
operator|.
name|dom
operator|=
name|arg
operator|->
name|refs
index|[
name|i
index|]
operator|.
name|domid
expr_stmt|;
name|gmap
operator|->
name|grant_map_ops
index|[
name|i
index|]
operator|.
name|ref
operator|=
name|arg
operator|->
name|refs
index|[
name|i
index|]
operator|.
name|ref
expr_stmt|;
name|gmap
operator|->
name|grant_map_ops
index|[
name|i
index|]
operator|.
name|handle
operator|=
operator|-
literal|1
expr_stmt|;
name|gmap
operator|->
name|grant_map_ops
index|[
name|i
index|]
operator|.
name|flags
operator|=
name|GNTMAP_host_map
expr_stmt|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|priv_user
operator|->
name|user_data_lock
argument_list|)
expr_stmt|;
name|RB_INSERT
argument_list|(
name|gmap_tree_head
argument_list|,
operator|&
name|priv_user
operator|->
name|gmap_tree
argument_list|,
name|gmap
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|priv_user
operator|->
name|user_data_lock
argument_list|)
expr_stmt|;
name|arg
operator|->
name|index
operator|=
name|gmap
operator|->
name|file_index
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * IOCTL_GNTDEV_UNMAP_GRANT_REF  * Remove the map information from the per user private data and add it  * to the global device-list of mappings to be deleted. A reference to  * the mgtdevice pager is also decreased, the reason for which is  * explained in mmap_gmap().  */
end_comment

begin_function
specifier|static
name|int
name|gntdev_unmap_grant_ref
parameter_list|(
name|struct
name|ioctl_gntdev_unmap_grant_ref
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|gntdev_gmap
modifier|*
name|gmap
decl_stmt|;
name|struct
name|per_user_data
modifier|*
name|priv_user
decl_stmt|;
name|error
operator|=
name|devfs_get_cdevpriv
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|priv_user
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|gmap
operator|=
name|gntdev_find_gmap
argument_list|(
name|priv_user
argument_list|,
name|arg
operator|->
name|index
argument_list|,
name|arg
operator|->
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|gmap
operator|==
name|NULL
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Can't find requested grant-map."
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|priv_user
operator|->
name|user_data_lock
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|cleanup_data
operator|.
name|to_kill_gmaps_mtx
argument_list|)
expr_stmt|;
name|RB_REMOVE
argument_list|(
name|gmap_tree_head
argument_list|,
operator|&
name|priv_user
operator|->
name|gmap_tree
argument_list|,
name|gmap
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|cleanup_data
operator|.
name|to_kill_gmaps
argument_list|,
name|gmap
argument_list|,
name|gmap_next
operator|.
name|list
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|cleanup_data
operator|.
name|to_kill_gmaps_mtx
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|priv_user
operator|->
name|user_data_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|gmap
operator|->
name|map
condition|)
name|vm_object_deallocate
argument_list|(
name|gmap
operator|->
name|map
operator|->
name|mem
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|taskqueue_thread
argument_list|,
operator|&
name|cleanup_task
argument_list|)
expr_stmt|;
name|put_file_offset
argument_list|(
name|priv_user
argument_list|,
name|arg
operator|->
name|count
argument_list|,
name|arg
operator|->
name|index
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * IOCTL_GNTDEV_GET_OFFSET_FOR_VADDR  * Get file-offset and count for a given mapping, from the virtual address  * where the mapping is mmapped.  * Please note, this only works for grants mapped by this domain, and not  * grants allocated. Count doesn't make much sense in reference to grants  * allocated. Also, because this function is present in the linux gntdev  * device, but not in the linux gntalloc one, most userspace code only use  * it for mapped grants.  */
end_comment

begin_function
specifier|static
name|int
name|gntdev_get_offset_for_vaddr
parameter_list|(
name|struct
name|ioctl_gntdev_get_offset_for_vaddr
modifier|*
name|arg
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|vm_map_t
name|map
decl_stmt|;
name|vm_map_entry_t
name|entry
decl_stmt|;
name|vm_object_t
name|mem
decl_stmt|;
name|vm_pindex_t
name|pindex
decl_stmt|;
name|vm_prot_t
name|prot
decl_stmt|;
name|boolean_t
name|wired
decl_stmt|;
name|struct
name|gntdev_gmap
modifier|*
name|gmap
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|map
operator|=
operator|&
name|td
operator|->
name|td_proc
operator|->
name|p_vmspace
operator|->
name|vm_map
expr_stmt|;
name|error
operator|=
name|vm_map_lookup
argument_list|(
operator|&
name|map
argument_list|,
name|arg
operator|->
name|vaddr
argument_list|,
name|VM_PROT_NONE
argument_list|,
operator|&
name|entry
argument_list|,
operator|&
name|mem
argument_list|,
operator|&
name|pindex
argument_list|,
operator|&
name|prot
argument_list|,
operator|&
name|wired
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|KERN_SUCCESS
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
operator|(
name|mem
operator|->
name|type
operator|!=
name|OBJT_MGTDEVICE
operator|)
operator|||
operator|(
name|mem
operator|->
name|un_pager
operator|.
name|devp
operator|.
name|ops
operator|!=
operator|&
name|gntdev_gmap_pg_ops
operator|)
condition|)
block|{
name|rc
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|gmap
operator|=
name|mem
operator|->
name|handle
expr_stmt|;
if|if
condition|(
name|gmap
operator|==
name|NULL
operator|||
operator|(
name|entry
operator|->
name|end
operator|-
name|entry
operator|->
name|start
operator|)
operator|!=
operator|(
name|gmap
operator|->
name|count
operator|*
name|PAGE_SIZE
operator|)
condition|)
block|{
name|rc
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|arg
operator|->
name|count
operator|=
name|gmap
operator|->
name|count
expr_stmt|;
name|arg
operator|->
name|offset
operator|=
name|gmap
operator|->
name|file_index
expr_stmt|;
name|rc
operator|=
literal|0
expr_stmt|;
name|out
label|:
name|vm_map_lookup_done
argument_list|(
name|map
argument_list|,
name|entry
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-------------------- Grant Mapping Pager  ----------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|gntdev_gmap_pg_ctor
parameter_list|(
name|void
modifier|*
name|handle
parameter_list|,
name|vm_ooffset_t
name|size
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|,
name|vm_ooffset_t
name|foff
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|u_short
modifier|*
name|color
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|gntdev_gmap_pg_dtor
parameter_list|(
name|void
modifier|*
name|handle
parameter_list|)
block|{
name|notify_unmap_cleanup
argument_list|(
operator|(
expr|struct
name|gntdev_gmap
operator|*
operator|)
name|handle
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|gntdev_gmap_pg_fault
parameter_list|(
name|vm_object_t
name|object
parameter_list|,
name|vm_ooffset_t
name|offset
parameter_list|,
name|int
name|prot
parameter_list|,
name|vm_page_t
modifier|*
name|mres
parameter_list|)
block|{
name|struct
name|gntdev_gmap
modifier|*
name|gmap
init|=
name|object
operator|->
name|handle
decl_stmt|;
name|vm_pindex_t
name|pidx
decl_stmt|,
name|ridx
decl_stmt|;
name|vm_page_t
name|page
decl_stmt|,
name|oldm
decl_stmt|;
name|vm_ooffset_t
name|relative_offset
decl_stmt|;
if|if
condition|(
name|gmap
operator|->
name|map
operator|==
name|NULL
condition|)
return|return
operator|(
name|VM_PAGER_FAIL
operator|)
return|;
name|relative_offset
operator|=
name|offset
operator|-
name|gmap
operator|->
name|file_index
expr_stmt|;
name|pidx
operator|=
name|UOFF_TO_IDX
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|ridx
operator|=
name|UOFF_TO_IDX
argument_list|(
name|relative_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|ridx
operator|>=
name|gmap
operator|->
name|count
operator|||
name|gmap
operator|->
name|grant_map_ops
index|[
name|ridx
index|]
operator|.
name|status
operator|!=
name|GNTST_okay
condition|)
return|return
operator|(
name|VM_PAGER_FAIL
operator|)
return|;
name|page
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|gmap
operator|->
name|map
operator|->
name|phys_base_addr
operator|+
name|relative_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|page
operator|==
name|NULL
condition|)
return|return
operator|(
name|VM_PAGER_FAIL
operator|)
return|;
name|KASSERT
argument_list|(
operator|(
name|page
operator|->
name|flags
operator|&
name|PG_FICTITIOUS
operator|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"not fictitious %p"
operator|,
name|page
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|page
operator|->
name|wire_count
operator|==
literal|1
argument_list|,
operator|(
literal|"wire_count not 1 %p"
operator|,
name|page
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|vm_page_busied
argument_list|(
name|page
argument_list|)
operator|==
literal|0
argument_list|,
operator|(
literal|"page %p is busy"
operator|,
name|page
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|mres
operator|!=
name|NULL
condition|)
block|{
name|oldm
operator|=
operator|*
name|mres
expr_stmt|;
name|vm_page_lock
argument_list|(
name|oldm
argument_list|)
expr_stmt|;
name|vm_page_free
argument_list|(
name|oldm
argument_list|)
expr_stmt|;
name|vm_page_unlock
argument_list|(
name|oldm
argument_list|)
expr_stmt|;
operator|*
name|mres
operator|=
name|NULL
expr_stmt|;
block|}
name|vm_page_insert
argument_list|(
name|page
argument_list|,
name|object
argument_list|,
name|pidx
argument_list|)
expr_stmt|;
name|page
operator|->
name|valid
operator|=
name|VM_PAGE_BITS_ALL
expr_stmt|;
name|vm_page_xbusy
argument_list|(
name|page
argument_list|)
expr_stmt|;
operator|*
name|mres
operator|=
name|page
expr_stmt|;
return|return
operator|(
name|VM_PAGER_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------ Grant Table Methods  ------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|notify
parameter_list|(
name|struct
name|notify_data
modifier|*
name|notify
parameter_list|,
name|vm_page_t
name|page
parameter_list|)
block|{
if|if
condition|(
name|notify
operator|->
name|action
operator|&
name|UNMAP_NOTIFY_CLEAR_BYTE
condition|)
block|{
name|uint8_t
modifier|*
name|mem
decl_stmt|;
name|uint64_t
name|offset
decl_stmt|;
name|offset
operator|=
name|notify
operator|->
name|index
operator|&
name|PAGE_MASK
expr_stmt|;
name|mem
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|pmap_quick_enter_page
argument_list|(
name|page
argument_list|)
expr_stmt|;
name|mem
index|[
name|offset
index|]
operator|=
literal|0
expr_stmt|;
name|pmap_quick_remove_page
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|mem
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|notify
operator|->
name|action
operator|&
name|UNMAP_NOTIFY_SEND_EVENT
condition|)
block|{
name|xen_intr_signal
argument_list|(
name|notify
operator|->
name|notify_evtchn_handle
argument_list|)
expr_stmt|;
name|xen_intr_unbind
argument_list|(
operator|&
name|notify
operator|->
name|notify_evtchn_handle
argument_list|)
expr_stmt|;
block|}
name|notify
operator|->
name|action
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Helper to copy new arguments from the notify ioctl into  * the existing notify data.  */
end_comment

begin_function
specifier|static
name|int
name|copy_notify_helper
parameter_list|(
name|struct
name|notify_data
modifier|*
name|destination
parameter_list|,
name|struct
name|ioctl_gntdev_unmap_notify
modifier|*
name|source
parameter_list|)
block|{
name|xen_intr_handle_t
name|handlep
init|=
name|NULL
decl_stmt|;
comment|/* 	 * "Get" before "Put"ting previous reference, as we might be 	 * holding the last reference to the event channel port. 	 */
if|if
condition|(
name|source
operator|->
name|action
operator|&
name|UNMAP_NOTIFY_SEND_EVENT
condition|)
if|if
condition|(
name|xen_intr_get_evtchn_from_port
argument_list|(
name|source
operator|->
name|event_channel_port
argument_list|,
operator|&
name|handlep
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|destination
operator|->
name|action
operator|&
name|UNMAP_NOTIFY_SEND_EVENT
condition|)
name|xen_intr_unbind
argument_list|(
operator|&
name|destination
operator|->
name|notify_evtchn_handle
argument_list|)
expr_stmt|;
name|destination
operator|->
name|action
operator|=
name|source
operator|->
name|action
expr_stmt|;
name|destination
operator|->
name|event_channel_port
operator|=
name|source
operator|->
name|event_channel_port
expr_stmt|;
name|destination
operator|->
name|index
operator|=
name|source
operator|->
name|index
expr_stmt|;
name|destination
operator|->
name|notify_evtchn_handle
operator|=
name|handlep
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * IOCTL_GNTDEV_SET_UNMAP_NOTIFY  * Set unmap notification inside the appropriate grant. It sends a  * notification when the grant is completely munmapped by this domain  * and ready for destruction.  */
end_comment

begin_function
specifier|static
name|int
name|gntdev_set_unmap_notify
parameter_list|(
name|struct
name|ioctl_gntdev_unmap_notify
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|uint64_t
name|index
decl_stmt|;
name|struct
name|per_user_data
modifier|*
name|priv_user
decl_stmt|;
name|struct
name|gntdev_gref
modifier|*
name|gref
init|=
name|NULL
decl_stmt|;
name|struct
name|gntdev_gmap
modifier|*
name|gmap
decl_stmt|;
name|error
operator|=
name|devfs_get_cdevpriv
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|priv_user
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|arg
operator|->
name|action
operator|&
operator|~
operator|(
name|UNMAP_NOTIFY_CLEAR_BYTE
operator||
name|UNMAP_NOTIFY_SEND_EVENT
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|index
operator|=
name|arg
operator|->
name|index
operator|&
operator|~
name|PAGE_MASK
expr_stmt|;
name|gref
operator|=
name|gntdev_find_grefs
argument_list|(
name|priv_user
argument_list|,
name|index
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|gref
condition|)
block|{
if|if
condition|(
name|gref
operator|->
name|notify
operator|==
name|NULL
condition|)
name|gref
operator|->
name|notify
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|arg
argument_list|)
argument_list|,
name|M_GNTDEV
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
return|return
operator|(
name|copy_notify_helper
argument_list|(
name|gref
operator|->
name|notify
argument_list|,
name|arg
argument_list|)
operator|)
return|;
block|}
name|error
operator|=
name|EINVAL
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|priv_user
operator|->
name|user_data_lock
argument_list|)
expr_stmt|;
name|RB_FOREACH
argument_list|(
argument|gmap
argument_list|,
argument|gmap_tree_head
argument_list|,
argument|&priv_user->gmap_tree
argument_list|)
block|{
if|if
condition|(
name|arg
operator|->
name|index
operator|>=
name|gmap
operator|->
name|file_index
operator|&&
name|arg
operator|->
name|index
operator|<
name|gmap
operator|->
name|file_index
operator|+
name|gmap
operator|->
name|count
operator|*
name|PAGE_SIZE
condition|)
block|{
if|if
condition|(
name|gmap
operator|->
name|notify
operator|==
name|NULL
condition|)
name|gmap
operator|->
name|notify
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|arg
argument_list|)
argument_list|,
name|M_GNTDEV
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|error
operator|=
name|copy_notify_helper
argument_list|(
name|gmap
operator|->
name|notify
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|priv_user
operator|->
name|user_data_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------ Gntdev Char Device Methods  -----------------------------*/
end_comment

begin_function
specifier|static
name|void
name|cleanup_function
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|__unused
name|int
name|pending
parameter_list|)
block|{
name|gref_list_dtor
argument_list|(
operator|(
expr|struct
name|cleanup_data_struct
operator|*
operator|)
name|arg
argument_list|)
expr_stmt|;
name|gmap_list_dtor
argument_list|(
operator|(
expr|struct
name|cleanup_data_struct
operator|*
operator|)
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|per_user_data_dtor
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|gntdev_gref
modifier|*
name|gref
decl_stmt|,
modifier|*
name|gref_tmp
decl_stmt|;
name|struct
name|gntdev_gmap
modifier|*
name|gmap
decl_stmt|,
modifier|*
name|gmap_tmp
decl_stmt|;
name|struct
name|file_offset_struct
modifier|*
name|offset
decl_stmt|,
modifier|*
name|offset_tmp
decl_stmt|;
name|struct
name|per_user_data
modifier|*
name|priv_user
decl_stmt|;
name|priv_user
operator|=
operator|(
expr|struct
name|per_user_data
operator|*
operator|)
name|arg
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|priv_user
operator|->
name|user_data_lock
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|cleanup_data
operator|.
name|to_kill_grefs_mtx
argument_list|)
expr_stmt|;
name|RB_FOREACH_SAFE
argument_list|(
argument|gref
argument_list|,
argument|gref_tree_head
argument_list|,
argument|&priv_user->gref_tree
argument_list|,
argument|gref_tmp
argument_list|)
block|{
name|RB_REMOVE
argument_list|(
name|gref_tree_head
argument_list|,
operator|&
name|priv_user
operator|->
name|gref_tree
argument_list|,
name|gref
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|cleanup_data
operator|.
name|to_kill_grefs
argument_list|,
name|gref
argument_list|,
name|gref_next
operator|.
name|list
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|cleanup_data
operator|.
name|to_kill_grefs_mtx
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|cleanup_data
operator|.
name|to_kill_gmaps_mtx
argument_list|)
expr_stmt|;
name|RB_FOREACH_SAFE
argument_list|(
argument|gmap
argument_list|,
argument|gmap_tree_head
argument_list|,
argument|&priv_user->gmap_tree
argument_list|,
argument|gmap_tmp
argument_list|)
block|{
name|RB_REMOVE
argument_list|(
name|gmap_tree_head
argument_list|,
operator|&
name|priv_user
operator|->
name|gmap_tree
argument_list|,
name|gmap
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|cleanup_data
operator|.
name|to_kill_gmaps
argument_list|,
name|gmap
argument_list|,
name|gmap_next
operator|.
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
name|gmap
operator|->
name|map
condition|)
name|vm_object_deallocate
argument_list|(
name|gmap
operator|->
name|map
operator|->
name|mem
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|cleanup_data
operator|.
name|to_kill_gmaps_mtx
argument_list|)
expr_stmt|;
name|RB_FOREACH_SAFE
argument_list|(
argument|offset
argument_list|,
argument|file_offset_head
argument_list|,
argument|&priv_user->file_offset
argument_list|,
argument|offset_tmp
argument_list|)
block|{
name|RB_REMOVE
argument_list|(
name|file_offset_head
argument_list|,
operator|&
name|priv_user
operator|->
name|file_offset
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|offset
argument_list|,
name|M_GNTDEV
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|priv_user
operator|->
name|user_data_lock
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|taskqueue_thread
argument_list|,
operator|&
name|cleanup_task
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|priv_user
operator|->
name|user_data_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|priv_user
argument_list|,
name|M_GNTDEV
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|gntdev_open
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|otyp
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|per_user_data
modifier|*
name|priv_user
decl_stmt|;
name|struct
name|file_offset_struct
modifier|*
name|offset
decl_stmt|;
name|priv_user
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|priv_user
argument_list|)
argument_list|,
name|M_GNTDEV
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|RB_INIT
argument_list|(
operator|&
name|priv_user
operator|->
name|gref_tree
argument_list|)
expr_stmt|;
name|RB_INIT
argument_list|(
operator|&
name|priv_user
operator|->
name|gmap_tree
argument_list|)
expr_stmt|;
name|RB_INIT
argument_list|(
operator|&
name|priv_user
operator|->
name|file_offset
argument_list|)
expr_stmt|;
name|offset
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|offset
argument_list|)
argument_list|,
name|M_GNTDEV
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|offset
operator|->
name|file_offset
operator|=
literal|0
expr_stmt|;
name|offset
operator|->
name|count
operator|=
name|MAX_OFFSET_COUNT
expr_stmt|;
name|RB_INSERT
argument_list|(
name|file_offset_head
argument_list|,
operator|&
name|priv_user
operator|->
name|file_offset
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|priv_user
operator|->
name|user_data_lock
argument_list|,
literal|"per user data mutex"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|error
operator|=
name|devfs_set_cdevpriv
argument_list|(
name|priv_user
argument_list|,
name|per_user_data_dtor
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|per_user_data_dtor
argument_list|(
name|priv_user
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|gntdev_ioctl
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|int
name|fflag
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|IOCTL_GNTDEV_SET_UNMAP_NOTIFY
case|:
name|error
operator|=
name|gntdev_set_unmap_notify
argument_list|(
operator|(
expr|struct
name|ioctl_gntdev_unmap_notify
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|IOCTL_GNTDEV_ALLOC_GREF
case|:
name|error
operator|=
name|gntdev_alloc_gref
argument_list|(
operator|(
expr|struct
name|ioctl_gntdev_alloc_gref
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|IOCTL_GNTDEV_DEALLOC_GREF
case|:
name|error
operator|=
name|gntdev_dealloc_gref
argument_list|(
operator|(
expr|struct
name|ioctl_gntdev_dealloc_gref
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|IOCTL_GNTDEV_MAP_GRANT_REF
case|:
name|error
operator|=
name|gntdev_map_grant_ref
argument_list|(
operator|(
expr|struct
name|ioctl_gntdev_map_grant_ref
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|IOCTL_GNTDEV_UNMAP_GRANT_REF
case|:
name|error
operator|=
name|gntdev_unmap_grant_ref
argument_list|(
operator|(
expr|struct
name|ioctl_gntdev_unmap_grant_ref
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|IOCTL_GNTDEV_GET_OFFSET_FOR_VADDR
case|:
name|error
operator|=
name|gntdev_get_offset_for_vaddr
argument_list|(
operator|(
expr|struct
name|ioctl_gntdev_get_offset_for_vaddr
operator|*
operator|)
name|data
argument_list|,
name|td
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|ENOSYS
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * MMAP an allocated grant into user memory.  * Please note, that the grants must not already be mmapped, otherwise  * this function will fail.  */
end_comment

begin_function
specifier|static
name|int
name|mmap_gref
parameter_list|(
name|struct
name|per_user_data
modifier|*
name|priv_user
parameter_list|,
name|struct
name|gntdev_gref
modifier|*
name|gref_start
parameter_list|,
name|uint32_t
name|count
parameter_list|,
name|vm_size_t
name|size
parameter_list|,
name|struct
name|vm_object
modifier|*
modifier|*
name|object
parameter_list|)
block|{
name|vm_object_t
name|mem_obj
decl_stmt|;
name|struct
name|gntdev_gref
modifier|*
name|gref
decl_stmt|;
name|mem_obj
operator|=
name|vm_object_allocate
argument_list|(
name|OBJT_PHYS
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|mem_obj
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|mtx_lock
argument_list|(
operator|&
name|priv_user
operator|->
name|user_data_lock
argument_list|)
expr_stmt|;
name|VM_OBJECT_WLOCK
argument_list|(
name|mem_obj
argument_list|)
expr_stmt|;
for|for
control|(
name|gref
operator|=
name|gref_start
init|;
name|gref
operator|!=
name|NULL
operator|&&
name|count
operator|>
literal|0
condition|;
name|gref
operator|=
name|RB_NEXT
argument_list|(
name|gref_tree_head
argument_list|,
operator|&
name|priv_user
operator|->
name|gref_tree
argument_list|,
name|gref
argument_list|)
control|)
block|{
if|if
condition|(
name|gref
operator|->
name|page
operator|->
name|object
condition|)
break|break;
name|vm_page_insert
argument_list|(
name|gref
operator|->
name|page
argument_list|,
name|mem_obj
argument_list|,
name|UOFF_TO_IDX
argument_list|(
name|gref
operator|->
name|file_index
argument_list|)
argument_list|)
expr_stmt|;
name|count
operator|--
expr_stmt|;
block|}
name|VM_OBJECT_WUNLOCK
argument_list|(
name|mem_obj
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|priv_user
operator|->
name|user_data_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
condition|)
block|{
name|vm_object_deallocate
argument_list|(
name|mem_obj
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
operator|*
name|object
operator|=
name|mem_obj
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * MMAP a mapped grant into user memory.  */
end_comment

begin_function
specifier|static
name|int
name|mmap_gmap
parameter_list|(
name|struct
name|per_user_data
modifier|*
name|priv_user
parameter_list|,
name|struct
name|gntdev_gmap
modifier|*
name|gmap_start
parameter_list|,
name|vm_ooffset_t
modifier|*
name|offset
parameter_list|,
name|vm_size_t
name|size
parameter_list|,
name|struct
name|vm_object
modifier|*
modifier|*
name|object
parameter_list|,
name|int
name|nprot
parameter_list|)
block|{
name|uint32_t
name|i
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* 	 * The grant map hypercall might already be done. 	 * If that is the case, increase a reference to the 	 * vm object and return the already allocated object. 	 */
if|if
condition|(
name|gmap_start
operator|->
name|map
condition|)
block|{
name|vm_object_reference
argument_list|(
name|gmap_start
operator|->
name|map
operator|->
name|mem
argument_list|)
expr_stmt|;
operator|*
name|object
operator|=
name|gmap_start
operator|->
name|map
operator|->
name|mem
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|gmap_start
operator|->
name|map
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
operator|(
name|gmap_start
operator|->
name|map
operator|)
argument_list|)
argument_list|,
name|M_GNTDEV
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
comment|/* Allocate the xen pseudo physical memory resource. */
name|gmap_start
operator|->
name|map
operator|->
name|pseudo_phys_res_id
operator|=
literal|0
expr_stmt|;
name|gmap_start
operator|->
name|map
operator|->
name|pseudo_phys_res
operator|=
name|xenmem_alloc
argument_list|(
name|gntdev_dev
argument_list|,
operator|&
name|gmap_start
operator|->
name|map
operator|->
name|pseudo_phys_res_id
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|gmap_start
operator|->
name|map
operator|->
name|pseudo_phys_res
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|gmap_start
operator|->
name|map
argument_list|,
name|M_GNTDEV
argument_list|)
expr_stmt|;
name|gmap_start
operator|->
name|map
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|gmap_start
operator|->
name|map
operator|->
name|phys_base_addr
operator|=
name|rman_get_start
argument_list|(
name|gmap_start
operator|->
name|map
operator|->
name|pseudo_phys_res
argument_list|)
expr_stmt|;
comment|/* Allocate the mgtdevice pager. */
name|gmap_start
operator|->
name|map
operator|->
name|mem
operator|=
name|cdev_pager_allocate
argument_list|(
name|gmap_start
argument_list|,
name|OBJT_MGTDEVICE
argument_list|,
operator|&
name|gntdev_gmap_pg_ops
argument_list|,
name|size
argument_list|,
name|nprot
argument_list|,
operator|*
name|offset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|gmap_start
operator|->
name|map
operator|->
name|mem
operator|==
name|NULL
condition|)
block|{
name|xenmem_free
argument_list|(
name|gntdev_dev
argument_list|,
name|gmap_start
operator|->
name|map
operator|->
name|pseudo_phys_res_id
argument_list|,
name|gmap_start
operator|->
name|map
operator|->
name|pseudo_phys_res
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|gmap_start
operator|->
name|map
argument_list|,
name|M_GNTDEV
argument_list|)
expr_stmt|;
name|gmap_start
operator|->
name|map
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|gmap_start
operator|->
name|count
condition|;
name|i
operator|++
control|)
block|{
name|gmap_start
operator|->
name|grant_map_ops
index|[
name|i
index|]
operator|.
name|host_addr
operator|=
name|gmap_start
operator|->
name|map
operator|->
name|phys_base_addr
operator|+
name|i
operator|*
name|PAGE_SIZE
expr_stmt|;
if|if
condition|(
operator|(
name|nprot
operator|&
name|PROT_WRITE
operator|)
operator|==
literal|0
condition|)
name|gmap_start
operator|->
name|grant_map_ops
index|[
name|i
index|]
operator|.
name|flags
operator||=
name|GNTMAP_readonly
expr_stmt|;
block|}
comment|/* Make the MAP hypercall. */
name|error
operator|=
name|HYPERVISOR_grant_table_op
argument_list|(
name|GNTTABOP_map_grant_ref
argument_list|,
name|gmap_start
operator|->
name|grant_map_ops
argument_list|,
name|gmap_start
operator|->
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Deallocate pager. 		 * Pager deallocation will automatically take care of 		 * xenmem deallocation, etc. 		 */
name|vm_object_deallocate
argument_list|(
name|gmap_start
operator|->
name|map
operator|->
name|mem
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Retry EAGAIN maps. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|gmap_start
operator|->
name|count
condition|;
name|i
operator|++
control|)
block|{
name|int
name|delay
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|delay
operator|<
literal|256
operator|&&
name|gmap_start
operator|->
name|grant_map_ops
index|[
name|i
index|]
operator|.
name|status
operator|==
name|GNTST_eagain
condition|)
block|{
name|HYPERVISOR_grant_table_op
argument_list|(
name|GNTTABOP_map_grant_ref
argument_list|,
operator|&
name|gmap_start
operator|->
name|grant_map_ops
index|[
name|i
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pause
argument_list|(
operator|(
literal|"gntmap"
operator|)
argument_list|,
name|delay
operator|*
name|SBT_1MS
argument_list|)
expr_stmt|;
name|delay
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|gmap_start
operator|->
name|grant_map_ops
index|[
name|i
index|]
operator|.
name|status
operator|==
name|GNTST_eagain
condition|)
name|gmap_start
operator|->
name|grant_map_ops
index|[
name|i
index|]
operator|.
name|status
operator|=
name|GNTST_bad_page
expr_stmt|;
if|if
condition|(
name|gmap_start
operator|->
name|grant_map_ops
index|[
name|i
index|]
operator|.
name|status
operator|!=
name|GNTST_okay
condition|)
block|{
comment|/* 			 * Deallocate pager. 			 * Pager deallocation will automatically take care of 			 * xenmem deallocation, notification, unmap hypercall, 			 * etc. 			 */
name|vm_object_deallocate
argument_list|(
name|gmap_start
operator|->
name|map
operator|->
name|mem
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
comment|/* 	 * Add a reference to the vm object. We do not want 	 * the vm object to be deleted when all the mmaps are 	 * unmapped, because it may be re-mmapped. Instead, 	 * we want the object to be deleted, when along with 	 * munmaps, we have also processed the unmap-ioctl. 	 */
name|vm_object_reference
argument_list|(
name|gmap_start
operator|->
name|map
operator|->
name|mem
argument_list|)
expr_stmt|;
operator|*
name|object
operator|=
name|gmap_start
operator|->
name|map
operator|->
name|mem
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|gntdev_mmap_single
parameter_list|(
name|struct
name|cdev
modifier|*
name|cdev
parameter_list|,
name|vm_ooffset_t
modifier|*
name|offset
parameter_list|,
name|vm_size_t
name|size
parameter_list|,
name|struct
name|vm_object
modifier|*
modifier|*
name|object
parameter_list|,
name|int
name|nprot
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|uint32_t
name|count
decl_stmt|;
name|struct
name|gntdev_gref
modifier|*
name|gref_start
decl_stmt|;
name|struct
name|gntdev_gmap
modifier|*
name|gmap_start
decl_stmt|;
name|struct
name|per_user_data
modifier|*
name|priv_user
decl_stmt|;
name|error
operator|=
name|devfs_get_cdevpriv
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|priv_user
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|count
operator|=
name|UOFF_TO_IDX
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|gref_start
operator|=
name|gntdev_find_grefs
argument_list|(
name|priv_user
argument_list|,
operator|*
name|offset
argument_list|,
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|gref_start
condition|)
block|{
name|error
operator|=
name|mmap_gref
argument_list|(
name|priv_user
argument_list|,
name|gref_start
argument_list|,
name|count
argument_list|,
name|size
argument_list|,
name|object
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|gmap_start
operator|=
name|gntdev_find_gmap
argument_list|(
name|priv_user
argument_list|,
operator|*
name|offset
argument_list|,
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|gmap_start
condition|)
block|{
name|error
operator|=
name|mmap_gmap
argument_list|(
name|priv_user
argument_list|,
name|gmap_start
argument_list|,
name|offset
argument_list|,
name|size
argument_list|,
name|object
argument_list|,
name|nprot
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------ Private Device Attachment Functions  --------------------*/
end_comment

begin_function
specifier|static
name|void
name|gntdev_identify
parameter_list|(
name|driver_t
modifier|*
name|driver
parameter_list|,
name|device_t
name|parent
parameter_list|)
block|{
name|KASSERT
argument_list|(
operator|(
name|xen_domain
argument_list|()
operator|)
argument_list|,
operator|(
literal|"Trying to attach gntdev device on non Xen domain"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|BUS_ADD_CHILD
argument_list|(
name|parent
argument_list|,
literal|0
argument_list|,
literal|"gntdev"
argument_list|,
literal|0
argument_list|)
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"unable to attach gntdev user-space device"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|gntdev_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|gntdev_dev
operator|=
name|dev
expr_stmt|;
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Xen grant-table user-space device"
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_NOWILDCARD
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|gntdev_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|make_dev_credf
argument_list|(
name|MAKEDEV_ETERNAL
argument_list|,
operator|&
name|gntdev_devsw
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0600
argument_list|,
literal|"xen/gntdev"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-------------------- Private Device Attachment Data  -----------------------*/
end_comment

begin_decl_stmt
specifier|static
name|device_method_t
name|gntdev_methods
index|[]
init|=
block|{
name|DEVMETHOD
argument_list|(
name|device_identify
argument_list|,
name|gntdev_identify
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|gntdev_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|gntdev_attach
argument_list|)
block|,
name|DEVMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|gntdev_driver
init|=
block|{
literal|"gntdev"
block|,
name|gntdev_methods
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|devclass_t
name|gntdev_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|gntdev
argument_list|,
name|xenpv
argument_list|,
name|gntdev_driver
argument_list|,
name|gntdev_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|gntdev
argument_list|,
name|xenpv
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

