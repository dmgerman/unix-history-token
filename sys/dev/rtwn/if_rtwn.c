begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$OpenBSD: if_urtwn.c,v 1.16 2011/02/10 17:26:40 jakemsr Exp $	*/
end_comment

begin_comment
comment|/*-  * Copyright (c) 2010 Damien Bergamini<damien.bergamini@free.fr>  * Copyright (c) 2014 Kevin Lo<kevlo@FreeBSD.org>  * Copyright (c) 2015-2016 Andriy Voskoboinyk<avos@FreeBSD.org>  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Driver for Realtek RTL8188CE-VAU/RTL8188CUS/RTL8188EU/RTL8188RU/RTL8192CU/RTL8812AU/RTL8821AU.  */
end_comment

begin_include
include|#
directive|include
file|"opt_wlan.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/linker.h>
end_include

begin_include
include|#
directive|include
file|<sys/firmware.h>
end_include

begin_include
include|#
directive|include
file|<sys/kdb.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_var.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_regdomain.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_radiotap.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_ratectl.h>
end_include

begin_include
include|#
directive|include
file|<dev/rtwn/if_rtwnreg.h>
end_include

begin_include
include|#
directive|include
file|<dev/rtwn/if_rtwnvar.h>
end_include

begin_include
include|#
directive|include
file|<dev/rtwn/if_rtwn_beacon.h>
end_include

begin_include
include|#
directive|include
file|<dev/rtwn/if_rtwn_calib.h>
end_include

begin_include
include|#
directive|include
file|<dev/rtwn/if_rtwn_cam.h>
end_include

begin_include
include|#
directive|include
file|<dev/rtwn/if_rtwn_debug.h>
end_include

begin_include
include|#
directive|include
file|<dev/rtwn/if_rtwn_efuse.h>
end_include

begin_include
include|#
directive|include
file|<dev/rtwn/if_rtwn_fw.h>
end_include

begin_include
include|#
directive|include
file|<dev/rtwn/if_rtwn_ridx.h>
end_include

begin_include
include|#
directive|include
file|<dev/rtwn/if_rtwn_rx.h>
end_include

begin_include
include|#
directive|include
file|<dev/rtwn/if_rtwn_task.h>
end_include

begin_include
include|#
directive|include
file|<dev/rtwn/if_rtwn_tx.h>
end_include

begin_include
include|#
directive|include
file|<dev/rtwn/rtl8192c/r92c_reg.h>
end_include

begin_function_decl
specifier|static
name|void
name|rtwn_radiotap_attach
parameter_list|(
name|struct
name|rtwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rtwn_vap_decrement_counters
parameter_list|(
name|struct
name|rtwn_softc
modifier|*
parameter_list|,
name|enum
name|ieee80211_opmode
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rtwn_set_ic_opmode
parameter_list|(
name|struct
name|rtwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|ieee80211vap
modifier|*
name|rtwn_vap_create
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|,
specifier|const
name|char
index|[
name|IFNAMSIZ
index|]
parameter_list|,
name|int
parameter_list|,
name|enum
name|ieee80211_opmode
parameter_list|,
name|int
parameter_list|,
specifier|const
name|uint8_t
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|,
specifier|const
name|uint8_t
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rtwn_vap_delete
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rtwn_read_chipid
parameter_list|(
name|struct
name|rtwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rtwn_ioctl_reset
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
parameter_list|,
name|u_long
parameter_list|)
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|RTWN_WITHOUT_UCODE
end_ifndef

begin_function_decl
specifier|static
name|void
name|rtwn_set_media_status
parameter_list|(
name|struct
name|rtwn_softc
modifier|*
parameter_list|,
name|union
name|sec_param
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rtwn_tx_fwpkt_check
parameter_list|(
name|struct
name|rtwn_softc
modifier|*
parameter_list|,
name|struct
name|ieee80211vap
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rtwn_construct_nulldata
parameter_list|(
name|struct
name|rtwn_softc
modifier|*
parameter_list|,
name|struct
name|ieee80211vap
modifier|*
parameter_list|,
name|uint8_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rtwn_push_nulldata
parameter_list|(
name|struct
name|rtwn_softc
modifier|*
parameter_list|,
name|struct
name|ieee80211vap
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rtwn_pwrmode_init
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rtwn_set_pwrmode_cb
parameter_list|(
name|struct
name|rtwn_softc
modifier|*
parameter_list|,
name|union
name|sec_param
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|rtwn_tsf_sync_adhoc
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rtwn_tsf_sync_adhoc_task
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rtwn_tsf_sync_enable
parameter_list|(
name|struct
name|rtwn_softc
modifier|*
parameter_list|,
name|struct
name|ieee80211vap
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rtwn_set_ack_preamble
parameter_list|(
name|struct
name|rtwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rtwn_set_mode
parameter_list|(
name|struct
name|rtwn_softc
modifier|*
parameter_list|,
name|uint8_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rtwn_monitor_newstate
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
parameter_list|,
name|enum
name|ieee80211_state
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rtwn_newstate
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
parameter_list|,
name|enum
name|ieee80211_state
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rtwn_calc_basicrates
parameter_list|(
name|struct
name|rtwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rtwn_run
parameter_list|(
name|struct
name|rtwn_softc
modifier|*
parameter_list|,
name|struct
name|ieee80211vap
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|D4054
end_ifndef

begin_function_decl
specifier|static
name|void
name|rtwn_watchdog
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|rtwn_parent
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rtwn_llt_write
parameter_list|(
name|struct
name|rtwn_softc
modifier|*
parameter_list|,
name|uint32_t
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rtwn_llt_init
parameter_list|(
name|struct
name|rtwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rtwn_dma_init
parameter_list|(
name|struct
name|rtwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rtwn_mac_init
parameter_list|(
name|struct
name|rtwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rtwn_mrr_init
parameter_list|(
name|struct
name|rtwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rtwn_scan_start
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rtwn_scan_curchan
parameter_list|(
name|struct
name|ieee80211_scan_state
modifier|*
parameter_list|,
name|unsigned
name|long
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rtwn_scan_end
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rtwn_getradiocaps
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|,
name|struct
name|ieee80211_channel
type|[]
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rtwn_update_chw
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rtwn_set_channel
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rtwn_wme_update
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rtwn_update_slot
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rtwn_update_slot_cb
parameter_list|(
name|struct
name|rtwn_softc
modifier|*
parameter_list|,
name|union
name|sec_param
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rtwn_update_aifs
parameter_list|(
name|struct
name|rtwn_softc
modifier|*
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rtwn_update_promisc
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rtwn_update_mcast
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rtwn_set_bssid
parameter_list|(
name|struct
name|rtwn_softc
modifier|*
parameter_list|,
specifier|const
name|uint8_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rtwn_set_macaddr
parameter_list|(
name|struct
name|rtwn_softc
modifier|*
parameter_list|,
specifier|const
name|uint8_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|ieee80211_node
modifier|*
name|rtwn_node_alloc
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
parameter_list|,
specifier|const
name|uint8_t
name|mac
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rtwn_newassoc
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rtwn_node_free
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rtwn_init_beacon_reg
parameter_list|(
name|struct
name|rtwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rtwn_init
parameter_list|(
name|struct
name|rtwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rtwn_stop
parameter_list|(
name|struct
name|rtwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_RTWN_PRIV
argument_list|,
literal|"rtwn_priv"
argument_list|,
literal|"rtwn driver private state"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
specifier|const
name|uint8_t
name|rtwn_chan_2ghz
index|[]
init|=
block|{
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|,
literal|13
block|,
literal|14
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|uint16_t
name|wme2reg
index|[]
init|=
block|{
name|R92C_EDCA_BE_PARAM
block|,
name|R92C_EDCA_BK_PARAM
block|,
name|R92C_EDCA_VI_PARAM
block|,
name|R92C_EDCA_VO_PARAM
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|rtwn_attach
parameter_list|(
name|struct
name|rtwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|->
name|cur_bcnq_id
operator|=
name|RTWN_VAP_ID_INVALID
expr_stmt|;
name|RTWN_NT_LOCK_INIT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|rtwn_cmdq_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|D4054
name|callout_init_mtx
argument_list|(
operator|&
name|sc
operator|->
name|sc_watchdog_to
argument_list|,
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|callout_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_calib_to
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_pwrmode_init
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mbufq_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_snd
argument_list|,
name|ifqmaxlen
argument_list|)
expr_stmt|;
name|RTWN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
name|rtwn_read_chipid
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|RTWN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"unsupported test chip\n"
argument_list|)
expr_stmt|;
goto|goto
name|detach
goto|;
block|}
name|error
operator|=
name|rtwn_read_rom
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: cannot read rom, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|detach
goto|;
block|}
if|if
condition|(
name|sc
operator|->
name|macid_limit
operator|>
name|RTWN_MACID_LIMIT
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"macid limit will be reduced from %d to %d\n"
argument_list|,
name|sc
operator|->
name|macid_limit
argument_list|,
name|RTWN_MACID_LIMIT
argument_list|)
expr_stmt|;
name|sc
operator|->
name|macid_limit
operator|=
name|RTWN_MACID_LIMIT
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|cam_entry_limit
operator|>
name|RTWN_CAM_ENTRY_LIMIT
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"cam entry limit will be reduced from %d to %d\n"
argument_list|,
name|sc
operator|->
name|cam_entry_limit
argument_list|,
name|RTWN_CAM_ENTRY_LIMIT
argument_list|)
expr_stmt|;
name|sc
operator|->
name|cam_entry_limit
operator|=
name|RTWN_CAM_ENTRY_LIMIT
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|txdesc_len
operator|>
name|RTWN_TX_DESC_SIZE
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"adjust size for Tx descriptor (current %d, needed %d)\n"
argument_list|,
name|RTWN_TX_DESC_SIZE
argument_list|,
name|sc
operator|->
name|txdesc_len
argument_list|)
expr_stmt|;
goto|goto
name|detach
goto|;
block|}
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"MAC/BB %s, RF 6052 %dT%dR\n"
argument_list|,
name|sc
operator|->
name|name
argument_list|,
name|sc
operator|->
name|ntxchains
argument_list|,
name|sc
operator|->
name|nrxchains
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_softc
operator|=
name|sc
expr_stmt|;
name|ic
operator|->
name|ic_phytype
operator|=
name|IEEE80211_T_OFDM
expr_stmt|;
comment|/* not only, but not used */
name|ic
operator|->
name|ic_opmode
operator|=
name|IEEE80211_M_STA
expr_stmt|;
comment|/* default to BSS mode */
comment|/* set device capabilities */
name|ic
operator|->
name|ic_caps
operator|=
name|IEEE80211_C_STA
comment|/* station mode */
operator||
name|IEEE80211_C_MONITOR
comment|/* monitor mode */
operator||
name|IEEE80211_C_IBSS
comment|/* adhoc mode */
operator||
name|IEEE80211_C_HOSTAP
comment|/* hostap mode */
if|#
directive|if
literal|0
comment|/* TODO: HRPWM register setup */
ifndef|#
directive|ifndef
name|RTWN_WITHOUT_UCODE
expr|| IEEE80211_C_PMGT
comment|/* Station-side power mgmt */
endif|#
directive|endif
endif|#
directive|endif
operator||
name|IEEE80211_C_SHPREAMBLE
comment|/* short preamble supported */
operator||
name|IEEE80211_C_SHSLOT
comment|/* short slot time supported */
if|#
directive|if
literal|0
expr|| IEEE80211_C_BGSCAN
comment|/* capable of bg scanning */
endif|#
directive|endif
operator||
name|IEEE80211_C_WPA
comment|/* 802.11i */
operator||
name|IEEE80211_C_WME
comment|/* 802.11e */
operator||
name|IEEE80211_C_SWAMSDUTX
comment|/* Do software A-MSDU TX */
operator||
name|IEEE80211_C_FF
comment|/* Atheros fast-frames */
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_hwcrypto
operator|!=
name|RTWN_CRYPTO_SW
condition|)
block|{
name|ic
operator|->
name|ic_cryptocaps
operator|=
name|IEEE80211_CRYPTO_WEP
operator||
name|IEEE80211_CRYPTO_TKIP
operator||
name|IEEE80211_CRYPTO_AES_CCM
expr_stmt|;
block|}
name|ic
operator|->
name|ic_htcaps
operator|=
name|IEEE80211_HTCAP_SHORTGI20
comment|/* short GI in 20MHz */
operator||
name|IEEE80211_HTCAP_MAXAMSDU_3839
comment|/* max A-MSDU length */
operator||
name|IEEE80211_HTCAP_SMPS_OFF
comment|/* SM PS mode disabled */
comment|/* s/w capabilities */
operator||
name|IEEE80211_HTC_HT
comment|/* HT operation */
operator||
name|IEEE80211_HTC_AMPDU
comment|/* A-MPDU tx */
operator||
name|IEEE80211_HTC_AMSDU
comment|/* A-MSDU tx */
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_ht40
condition|)
block|{
name|ic
operator|->
name|ic_htcaps
operator||=
name|IEEE80211_HTCAP_CHWIDTH40
comment|/* 40 MHz channel width */
operator||
name|IEEE80211_HTCAP_SHORTGI40
comment|/* short GI in 40MHz */
expr_stmt|;
block|}
name|ic
operator|->
name|ic_txstream
operator|=
name|sc
operator|->
name|ntxchains
expr_stmt|;
name|ic
operator|->
name|ic_rxstream
operator|=
name|sc
operator|->
name|nrxchains
expr_stmt|;
comment|/* Enable TX watchdog */
ifdef|#
directive|ifdef
name|D4054
name|ic
operator|->
name|ic_flags_ext
operator||=
name|IEEE80211_FEXT_WATCHDOG
expr_stmt|;
endif|#
directive|endif
comment|/* Adjust capabilities. */
name|rtwn_adj_devcaps
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|rtwn_getradiocaps
argument_list|(
name|ic
argument_list|,
name|IEEE80211_CHAN_MAX
argument_list|,
operator|&
name|ic
operator|->
name|ic_nchans
argument_list|,
name|ic
operator|->
name|ic_channels
argument_list|)
expr_stmt|;
comment|/* XXX TODO: setup regdomain if R92C_CHANNEL_PLAN_BY_HW bit is set. */
name|ieee80211_ifattach
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_raw_xmit
operator|=
name|rtwn_raw_xmit
expr_stmt|;
name|ic
operator|->
name|ic_scan_start
operator|=
name|rtwn_scan_start
expr_stmt|;
name|sc
operator|->
name|sc_scan_curchan
operator|=
name|ic
operator|->
name|ic_scan_curchan
expr_stmt|;
name|ic
operator|->
name|ic_scan_curchan
operator|=
name|rtwn_scan_curchan
expr_stmt|;
name|ic
operator|->
name|ic_scan_end
operator|=
name|rtwn_scan_end
expr_stmt|;
name|ic
operator|->
name|ic_getradiocaps
operator|=
name|rtwn_getradiocaps
expr_stmt|;
name|ic
operator|->
name|ic_update_chw
operator|=
name|rtwn_update_chw
expr_stmt|;
name|ic
operator|->
name|ic_set_channel
operator|=
name|rtwn_set_channel
expr_stmt|;
name|ic
operator|->
name|ic_transmit
operator|=
name|rtwn_transmit
expr_stmt|;
name|ic
operator|->
name|ic_parent
operator|=
name|rtwn_parent
expr_stmt|;
name|ic
operator|->
name|ic_vap_create
operator|=
name|rtwn_vap_create
expr_stmt|;
name|ic
operator|->
name|ic_vap_delete
operator|=
name|rtwn_vap_delete
expr_stmt|;
name|ic
operator|->
name|ic_wme
operator|.
name|wme_update
operator|=
name|rtwn_wme_update
expr_stmt|;
name|ic
operator|->
name|ic_updateslot
operator|=
name|rtwn_update_slot
expr_stmt|;
name|ic
operator|->
name|ic_update_promisc
operator|=
name|rtwn_update_promisc
expr_stmt|;
name|ic
operator|->
name|ic_update_mcast
operator|=
name|rtwn_update_mcast
expr_stmt|;
name|ic
operator|->
name|ic_node_alloc
operator|=
name|rtwn_node_alloc
expr_stmt|;
name|ic
operator|->
name|ic_newassoc
operator|=
name|rtwn_newassoc
expr_stmt|;
name|sc
operator|->
name|sc_node_free
operator|=
name|ic
operator|->
name|ic_node_free
expr_stmt|;
name|ic
operator|->
name|ic_node_free
operator|=
name|rtwn_node_free
expr_stmt|;
name|rtwn_postattach
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|rtwn_radiotap_attach
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|ieee80211_announce
argument_list|(
name|ic
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|detach
label|:
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* failure */
block|}
end_function

begin_function
specifier|static
name|void
name|rtwn_radiotap_attach
parameter_list|(
name|struct
name|rtwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|rtwn_rx_radiotap_header
modifier|*
name|rxtap
init|=
operator|&
name|sc
operator|->
name|sc_rxtap
decl_stmt|;
name|struct
name|rtwn_tx_radiotap_header
modifier|*
name|txtap
init|=
operator|&
name|sc
operator|->
name|sc_txtap
decl_stmt|;
name|ieee80211_radiotap_attach
argument_list|(
operator|&
name|sc
operator|->
name|sc_ic
argument_list|,
operator|&
name|txtap
operator|->
name|wt_ihdr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|txtap
argument_list|)
argument_list|,
name|RTWN_TX_RADIOTAP_PRESENT
argument_list|,
operator|&
name|rxtap
operator|->
name|wr_ihdr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rxtap
argument_list|)
argument_list|,
name|RTWN_RX_RADIOTAP_PRESENT
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|rtwn_sysctlattach
parameter_list|(
name|struct
name|rtwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|sysctl_ctx_list
modifier|*
name|ctx
init|=
name|device_get_sysctl_ctx
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|tree
init|=
name|device_get_sysctl_tree
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
decl_stmt|;
if|#
directive|if
literal|1
name|sc
operator|->
name|sc_ht40
operator|=
literal|0
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"ht40"
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|sc
operator|->
name|sc_ht40
argument_list|,
name|sc
operator|->
name|sc_ht40
argument_list|,
literal|"Enable 40 MHz mode support"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|RTWN_DEBUG
name|SYSCTL_ADD_U32
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"debug"
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|sc
operator|->
name|sc_debug
argument_list|,
name|sc
operator|->
name|sc_debug
argument_list|,
literal|"Control debugging printfs"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sc
operator|->
name|sc_hwcrypto
operator|=
name|RTWN_CRYPTO_PAIR
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"hwcrypto"
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|sc
operator|->
name|sc_hwcrypto
argument_list|,
name|sc
operator|->
name|sc_hwcrypto
argument_list|,
literal|"Enable h/w crypto: "
literal|"0 - disable, 1 - pairwise keys, 2 - all keys"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_hwcrypto
operator|>=
name|RTWN_CRYPTO_MAX
condition|)
name|sc
operator|->
name|sc_hwcrypto
operator|=
name|RTWN_CRYPTO_FULL
expr_stmt|;
name|sc
operator|->
name|sc_ratectl_sysctl
operator|=
name|RTWN_RATECTL_NET80211
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"ratectl"
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|sc
operator|->
name|sc_ratectl_sysctl
argument_list|,
name|sc
operator|->
name|sc_ratectl_sysctl
argument_list|,
literal|"Select rate control mechanism: "
literal|"0 - disabled, 1 - via net80211, 2 - via firmware"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_ratectl_sysctl
operator|>=
name|RTWN_RATECTL_MAX
condition|)
name|sc
operator|->
name|sc_ratectl_sysctl
operator|=
name|RTWN_RATECTL_FW
expr_stmt|;
name|sc
operator|->
name|sc_ratectl
operator|=
name|sc
operator|->
name|sc_ratectl_sysctl
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"ratectl_selected"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|sc_ratectl
argument_list|,
name|sc
operator|->
name|sc_ratectl
argument_list|,
literal|"Currently selected rate control mechanism (by the driver)"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|rtwn_detach
parameter_list|(
name|struct
name|rtwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_softc
operator|==
name|sc
condition|)
block|{
comment|/* Stop command queue. */
name|RTWN_CMDQ_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_detached
operator|=
literal|1
expr_stmt|;
name|RTWN_CMDQ_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ieee80211_draintask
argument_list|(
name|ic
argument_list|,
operator|&
name|sc
operator|->
name|cmdq_task
argument_list|)
expr_stmt|;
name|ieee80211_ifdetach
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
name|rtwn_cmdq_destroy
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|RTWN_NT_LOCK_INITIALIZED
argument_list|(
name|sc
argument_list|)
condition|)
name|RTWN_NT_LOCK_DESTROY
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|rtwn_suspend
parameter_list|(
name|struct
name|rtwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|ieee80211_suspend_all
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|rtwn_resume
parameter_list|(
name|struct
name|rtwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|ieee80211_resume_all
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|rtwn_vap_decrement_counters
parameter_list|(
name|struct
name|rtwn_softc
modifier|*
name|sc
parameter_list|,
name|enum
name|ieee80211_opmode
name|opmode
parameter_list|,
name|int
name|id
parameter_list|)
block|{
name|RTWN_ASSERT_LOCKED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|!=
name|RTWN_VAP_ID_INVALID
condition|)
block|{
name|KASSERT
argument_list|(
name|id
operator|==
literal|0
operator|||
name|id
operator|==
literal|1
argument_list|,
operator|(
literal|"wrong vap id %d!\n"
operator|,
name|id
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|vaps
index|[
name|id
index|]
operator|!=
name|NULL
argument_list|,
operator|(
literal|"vap pointer is NULL\n"
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|vaps
index|[
name|id
index|]
operator|=
name|NULL
expr_stmt|;
block|}
switch|switch
condition|(
name|opmode
condition|)
block|{
case|case
name|IEEE80211_M_HOSTAP
case|:
name|sc
operator|->
name|ap_vaps
operator|--
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|IEEE80211_M_IBSS
case|:
name|sc
operator|->
name|bcn_vaps
operator|--
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|IEEE80211_M_STA
case|:
name|sc
operator|->
name|nvaps
operator|--
expr_stmt|;
break|break;
case|case
name|IEEE80211_M_MONITOR
case|:
name|sc
operator|->
name|mon_vaps
operator|--
expr_stmt|;
break|break;
default|default:
name|KASSERT
argument_list|(
literal|0
argument_list|,
operator|(
literal|"wrong opmode %d\n"
operator|,
name|opmode
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|KASSERT
argument_list|(
name|sc
operator|->
name|vaps_running
operator|>=
literal|0
operator|&&
name|sc
operator|->
name|monvaps_running
operator|>=
literal|0
argument_list|,
operator|(
literal|"number of running vaps is negative (vaps %d, monvaps %d)\n"
operator|,
name|sc
operator|->
name|vaps_running
operator|,
name|sc
operator|->
name|monvaps_running
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|vaps_running
operator|-
name|sc
operator|->
name|monvaps_running
operator|<=
name|RTWN_PORT_COUNT
argument_list|,
operator|(
literal|"number of running vaps is too big (vaps %d, monvaps %d)\n"
operator|,
name|sc
operator|->
name|vaps_running
operator|,
name|sc
operator|->
name|monvaps_running
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|nvaps
operator|>=
literal|0
operator|&&
name|sc
operator|->
name|nvaps
operator|<=
name|RTWN_PORT_COUNT
argument_list|,
operator|(
literal|"wrong value %d for nvaps\n"
operator|,
name|sc
operator|->
name|nvaps
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|mon_vaps
operator|>=
literal|0
argument_list|,
operator|(
literal|"mon_vaps is negative (%d)\n"
operator|,
name|sc
operator|->
name|mon_vaps
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|bcn_vaps
operator|>=
literal|0
operator|&&
operator|(
operator|(
name|RTWN_CHIP_HAS_BCNQ1
argument_list|(
name|sc
argument_list|)
operator|&&
name|sc
operator|->
name|bcn_vaps
operator|<=
name|RTWN_PORT_COUNT
operator|)
operator|||
name|sc
operator|->
name|bcn_vaps
operator|<=
literal|1
operator|)
argument_list|,
operator|(
literal|"bcn_vaps value %d is wrong\n"
operator|,
name|sc
operator|->
name|bcn_vaps
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|ap_vaps
operator|>=
literal|0
operator|&&
operator|(
operator|(
name|RTWN_CHIP_HAS_BCNQ1
argument_list|(
name|sc
argument_list|)
operator|&&
name|sc
operator|->
name|ap_vaps
operator|<=
name|RTWN_PORT_COUNT
operator|)
operator|||
name|sc
operator|->
name|ap_vaps
operator|<=
literal|1
operator|)
argument_list|,
operator|(
literal|"ap_vaps value %d is wrong\n"
operator|,
name|sc
operator|->
name|ap_vaps
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|rtwn_set_ic_opmode
parameter_list|(
name|struct
name|rtwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|RTWN_ASSERT_LOCKED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* for ieee80211_reset_erp() */
if|if
condition|(
name|sc
operator|->
name|bcn_vaps
operator|-
name|sc
operator|->
name|ap_vaps
operator|>
literal|0
condition|)
name|ic
operator|->
name|ic_opmode
operator|=
name|IEEE80211_M_IBSS
expr_stmt|;
elseif|else
if|if
condition|(
name|sc
operator|->
name|ap_vaps
operator|>
literal|0
condition|)
name|ic
operator|->
name|ic_opmode
operator|=
name|IEEE80211_M_HOSTAP
expr_stmt|;
elseif|else
if|if
condition|(
name|sc
operator|->
name|nvaps
operator|>
literal|0
condition|)
name|ic
operator|->
name|ic_opmode
operator|=
name|IEEE80211_M_STA
expr_stmt|;
else|else
name|ic
operator|->
name|ic_opmode
operator|=
name|IEEE80211_M_MONITOR
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|ieee80211vap
modifier|*
name|rtwn_vap_create
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
specifier|const
name|char
name|name
index|[
name|IFNAMSIZ
index|]
parameter_list|,
name|int
name|unit
parameter_list|,
name|enum
name|ieee80211_opmode
name|opmode
parameter_list|,
name|int
name|flags
parameter_list|,
specifier|const
name|uint8_t
name|bssid
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|,
specifier|const
name|uint8_t
name|mac
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
block|{
name|struct
name|rtwn_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_softc
decl_stmt|;
name|struct
name|rtwn_vap
modifier|*
name|uvp
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
decl_stmt|;
name|int
name|id
init|=
name|RTWN_VAP_ID_INVALID
decl_stmt|;
name|RTWN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|nvaps
operator|<=
name|RTWN_PORT_COUNT
argument_list|,
operator|(
literal|"nvaps overflow (%d> %d)\n"
operator|,
name|sc
operator|->
name|nvaps
operator|,
name|RTWN_PORT_COUNT
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|ap_vaps
operator|<=
name|RTWN_PORT_COUNT
argument_list|,
operator|(
literal|"ap_vaps overflow (%d> %d)\n"
operator|,
name|sc
operator|->
name|ap_vaps
operator|,
name|RTWN_PORT_COUNT
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|bcn_vaps
operator|<=
name|RTWN_PORT_COUNT
argument_list|,
operator|(
literal|"bcn_vaps overflow (%d> %d)\n"
operator|,
name|sc
operator|->
name|bcn_vaps
operator|,
name|RTWN_PORT_COUNT
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|opmode
operator|!=
name|IEEE80211_M_MONITOR
condition|)
block|{
switch|switch
condition|(
name|sc
operator|->
name|nvaps
condition|)
block|{
case|case
literal|0
case|:
name|id
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|1
case|:
if|if
condition|(
name|sc
operator|->
name|vaps
index|[
literal|1
index|]
operator|==
name|NULL
condition|)
name|id
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|sc
operator|->
name|vaps
index|[
literal|0
index|]
operator|==
name|NULL
condition|)
name|id
operator|=
literal|0
expr_stmt|;
name|KASSERT
argument_list|(
name|id
operator|!=
name|RTWN_VAP_ID_INVALID
argument_list|,
operator|(
literal|"no free ports left\n"
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
default|default:
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|opmode
operator|==
name|IEEE80211_M_IBSS
operator|||
name|opmode
operator|==
name|IEEE80211_M_HOSTAP
condition|)
block|{
if|if
condition|(
operator|(
name|sc
operator|->
name|bcn_vaps
operator|==
literal|1
operator|&&
operator|!
name|RTWN_CHIP_HAS_BCNQ1
argument_list|(
name|sc
argument_list|)
operator|)
operator|||
name|sc
operator|->
name|bcn_vaps
operator|==
name|RTWN_PORT_COUNT
condition|)
goto|goto
name|fail
goto|;
block|}
block|}
switch|switch
condition|(
name|opmode
condition|)
block|{
case|case
name|IEEE80211_M_HOSTAP
case|:
name|sc
operator|->
name|ap_vaps
operator|++
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|IEEE80211_M_IBSS
case|:
name|sc
operator|->
name|bcn_vaps
operator|++
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|IEEE80211_M_STA
case|:
name|sc
operator|->
name|nvaps
operator|++
expr_stmt|;
break|break;
case|case
name|IEEE80211_M_MONITOR
case|:
name|sc
operator|->
name|mon_vaps
operator|++
expr_stmt|;
break|break;
default|default:
name|KASSERT
argument_list|(
literal|0
argument_list|,
operator|(
literal|"unknown opmode %d\n"
operator|,
name|opmode
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|RTWN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|uvp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|rtwn_vap
argument_list|)
argument_list|,
name|M_80211_VAP
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|uvp
operator|->
name|id
operator|=
name|id
expr_stmt|;
if|if
condition|(
name|id
operator|!=
name|RTWN_VAP_ID_INVALID
condition|)
block|{
name|RTWN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|vaps
index|[
name|id
index|]
operator|=
name|uvp
expr_stmt|;
name|RTWN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|vap
operator|=
operator|&
name|uvp
operator|->
name|vap
expr_stmt|;
comment|/* enable s/w bmiss handling for sta mode */
if|if
condition|(
name|ieee80211_vap_setup
argument_list|(
name|ic
argument_list|,
name|vap
argument_list|,
name|name
argument_list|,
name|unit
argument_list|,
name|opmode
argument_list|,
name|flags
operator||
name|IEEE80211_CLONE_NOBEACONS
argument_list|,
name|bssid
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* out of memory */
name|free
argument_list|(
name|uvp
argument_list|,
name|M_80211_VAP
argument_list|)
expr_stmt|;
name|RTWN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|rtwn_vap_decrement_counters
argument_list|(
name|sc
argument_list|,
name|opmode
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|RTWN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|rtwn_beacon_init
argument_list|(
name|sc
argument_list|,
operator|&
name|uvp
operator|->
name|bcn_desc
operator|.
name|txd
index|[
literal|0
index|]
argument_list|,
name|uvp
operator|->
name|id
argument_list|)
expr_stmt|;
name|rtwn_vap_preattach
argument_list|(
name|sc
argument_list|,
name|vap
argument_list|)
expr_stmt|;
comment|/* override state transition machine */
name|uvp
operator|->
name|newstate
operator|=
name|vap
operator|->
name|iv_newstate
expr_stmt|;
if|if
condition|(
name|opmode
operator|==
name|IEEE80211_M_MONITOR
condition|)
name|vap
operator|->
name|iv_newstate
operator|=
name|rtwn_monitor_newstate
expr_stmt|;
else|else
name|vap
operator|->
name|iv_newstate
operator|=
name|rtwn_newstate
expr_stmt|;
name|vap
operator|->
name|iv_update_beacon
operator|=
name|rtwn_update_beacon
expr_stmt|;
name|vap
operator|->
name|iv_reset
operator|=
name|rtwn_ioctl_reset
expr_stmt|;
name|vap
operator|->
name|iv_key_alloc
operator|=
name|rtwn_key_alloc
expr_stmt|;
name|vap
operator|->
name|iv_key_set
operator|=
name|rtwn_key_set
expr_stmt|;
name|vap
operator|->
name|iv_key_delete
operator|=
name|rtwn_key_delete
expr_stmt|;
name|vap
operator|->
name|iv_max_aid
operator|=
name|sc
operator|->
name|macid_limit
expr_stmt|;
comment|/* 802.11n parameters */
name|vap
operator|->
name|iv_ampdu_density
operator|=
name|IEEE80211_HTCAP_MPDUDENSITY_16
expr_stmt|;
name|vap
operator|->
name|iv_ampdu_rxmax
operator|=
name|IEEE80211_HTCAP_MAXRXAMPDU_64K
expr_stmt|;
name|TIMEOUT_TASK_INIT
argument_list|(
name|taskqueue_thread
argument_list|,
operator|&
name|uvp
operator|->
name|tx_beacon_csa
argument_list|,
literal|0
argument_list|,
name|rtwn_tx_beacon_csa
argument_list|,
name|vap
argument_list|)
expr_stmt|;
if|if
condition|(
name|opmode
operator|==
name|IEEE80211_M_IBSS
condition|)
block|{
name|uvp
operator|->
name|recv_mgmt
operator|=
name|vap
operator|->
name|iv_recv_mgmt
expr_stmt|;
name|vap
operator|->
name|iv_recv_mgmt
operator|=
name|rtwn_adhoc_recv_mgmt
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|uvp
operator|->
name|tsf_sync_adhoc_task
argument_list|,
literal|0
argument_list|,
name|rtwn_tsf_sync_adhoc_task
argument_list|,
name|vap
argument_list|)
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|uvp
operator|->
name|tsf_sync_adhoc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * NB: driver can select net80211 RA even when user requests 	 * another mechanism. 	 */
name|ieee80211_ratectl_init
argument_list|(
name|vap
argument_list|)
expr_stmt|;
comment|/* complete setup */
name|ieee80211_vap_attach
argument_list|(
name|vap
argument_list|,
name|ieee80211_media_change
argument_list|,
name|ieee80211_media_status
argument_list|,
name|mac
argument_list|)
expr_stmt|;
name|RTWN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|rtwn_set_ic_opmode
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|RTWN_RUNNING
condition|)
block|{
if|if
condition|(
name|uvp
operator|->
name|id
operator|!=
name|RTWN_VAP_ID_INVALID
condition|)
name|rtwn_set_macaddr
argument_list|(
name|sc
argument_list|,
name|vap
operator|->
name|iv_myaddr
argument_list|,
name|uvp
operator|->
name|id
argument_list|)
expr_stmt|;
name|rtwn_rxfilter_update
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|RTWN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|vap
operator|)
return|;
name|fail
label|:
name|RTWN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|rtwn_vap_delete
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|struct
name|rtwn_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_softc
decl_stmt|;
name|struct
name|rtwn_vap
modifier|*
name|uvp
init|=
name|RTWN_VAP
argument_list|(
name|vap
argument_list|)
decl_stmt|;
comment|/* Put vap into INIT state + stop device if needed. */
name|ieee80211_stop
argument_list|(
name|vap
argument_list|)
expr_stmt|;
name|ieee80211_draintask
argument_list|(
name|ic
argument_list|,
operator|&
name|vap
operator|->
name|iv_nstate_task
argument_list|)
expr_stmt|;
name|ieee80211_draintask
argument_list|(
name|ic
argument_list|,
operator|&
name|ic
operator|->
name|ic_parent_task
argument_list|)
expr_stmt|;
name|RTWN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Cancel any unfinished Tx. */
name|rtwn_reset_lists
argument_list|(
name|sc
argument_list|,
name|vap
argument_list|)
expr_stmt|;
if|if
condition|(
name|uvp
operator|->
name|bcn_mbuf
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|uvp
operator|->
name|bcn_mbuf
argument_list|)
expr_stmt|;
name|rtwn_vap_decrement_counters
argument_list|(
name|sc
argument_list|,
name|vap
operator|->
name|iv_opmode
argument_list|,
name|uvp
operator|->
name|id
argument_list|)
expr_stmt|;
name|rtwn_set_ic_opmode
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|RTWN_RUNNING
condition|)
name|rtwn_rxfilter_update
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|RTWN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_IBSS
condition|)
block|{
name|ieee80211_draintask
argument_list|(
name|ic
argument_list|,
operator|&
name|uvp
operator|->
name|tsf_sync_adhoc_task
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|uvp
operator|->
name|tsf_sync_adhoc
argument_list|)
expr_stmt|;
block|}
name|ieee80211_ratectl_deinit
argument_list|(
name|vap
argument_list|)
expr_stmt|;
name|ieee80211_vap_detach
argument_list|(
name|vap
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|uvp
argument_list|,
name|M_80211_VAP
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|rtwn_read_chipid
parameter_list|(
name|struct
name|rtwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|reg
decl_stmt|;
name|reg
operator|=
name|rtwn_read_4
argument_list|(
name|sc
argument_list|,
name|R92C_SYS_CFG
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|&
name|R92C_SYS_CFG_TRP_VAUX_EN
condition|)
comment|/* test chip */
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
name|rtwn_read_chipid_vendor
argument_list|(
name|sc
argument_list|,
name|reg
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|rtwn_ioctl_reset
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
name|u_long
name|cmd
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
ifndef|#
directive|ifndef
name|RTWN_WITHOUT_UCODE
case|case
name|IEEE80211_IOC_POWERSAVE
case|:
case|case
name|IEEE80211_IOC_POWERSAVESLEEP
case|:
block|{
name|struct
name|rtwn_softc
modifier|*
name|sc
init|=
name|vap
operator|->
name|iv_ic
operator|->
name|ic_softc
decl_stmt|;
name|struct
name|rtwn_vap
modifier|*
name|uvp
init|=
name|RTWN_VAP
argument_list|(
name|vap
argument_list|)
decl_stmt|;
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_STA
operator|&&
name|uvp
operator|->
name|id
operator|==
literal|0
condition|)
block|{
name|RTWN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|RTWN_RUNNING
condition|)
name|error
operator|=
name|rtwn_set_pwrmode
argument_list|(
name|sc
argument_list|,
name|vap
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
literal|0
expr_stmt|;
name|RTWN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|error
operator|=
name|ENETRESET
expr_stmt|;
block|}
else|else
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
case|case
name|IEEE80211_IOC_SHORTGI
case|:
case|case
name|IEEE80211_IOC_RTSTHRESHOLD
case|:
case|case
name|IEEE80211_IOC_PROTMODE
case|:
case|case
name|IEEE80211_IOC_HTPROTMODE
case|:
name|error
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|ENETRESET
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|RTWN_WITHOUT_UCODE
end_ifndef

begin_function
specifier|static
name|void
name|rtwn_set_media_status
parameter_list|(
name|struct
name|rtwn_softc
modifier|*
name|sc
parameter_list|,
name|union
name|sec_param
modifier|*
name|data
parameter_list|)
block|{
name|sc
operator|->
name|sc_set_media_status
argument_list|(
name|sc
argument_list|,
name|data
operator|->
name|macid
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|rtwn_tx_fwpkt_check
parameter_list|(
name|struct
name|rtwn_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
name|int
name|ntries
decl_stmt|,
name|error
decl_stmt|;
for|for
control|(
name|ntries
operator|=
literal|0
init|;
name|ntries
operator|<
literal|5
condition|;
name|ntries
operator|++
control|)
block|{
name|error
operator|=
name|rtwn_push_nulldata
argument_list|(
name|sc
argument_list|,
name|vap
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|ntries
operator|==
literal|5
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: cannot push f/w frames into chip, error %d!\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|rtwn_construct_nulldata
parameter_list|(
name|struct
name|rtwn_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
name|uint8_t
modifier|*
name|ptr
parameter_list|,
name|int
name|qos
parameter_list|)
block|{
name|struct
name|rtwn_vap
modifier|*
name|uvp
init|=
name|RTWN_VAP
argument_list|(
name|vap
argument_list|)
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|struct
name|rtwn_tx_desc_common
modifier|*
name|txd
decl_stmt|;
name|struct
name|ieee80211_frame
modifier|*
name|wh
decl_stmt|;
name|int
name|pktlen
decl_stmt|;
comment|/* XXX obtain from net80211 */
name|wh
operator|=
operator|(
expr|struct
name|ieee80211_frame
operator|*
operator|)
operator|(
name|ptr
operator|+
name|sc
operator|->
name|txdesc_len
operator|)
expr_stmt|;
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|=
name|IEEE80211_FC0_VERSION_0
operator||
name|IEEE80211_FC0_TYPE_DATA
expr_stmt|;
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator|=
name|IEEE80211_FC1_DIR_TODS
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|,
name|vap
operator|->
name|iv_bss
operator|->
name|ni_bssid
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr2
argument_list|,
name|vap
operator|->
name|iv_myaddr
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr3
argument_list|,
name|vap
operator|->
name|iv_bss
operator|->
name|ni_macaddr
argument_list|)
expr_stmt|;
name|txd
operator|=
operator|(
expr|struct
name|rtwn_tx_desc_common
operator|*
operator|)
name|ptr
expr_stmt|;
name|txd
operator|->
name|offset
operator|=
name|sc
operator|->
name|txdesc_len
expr_stmt|;
name|pktlen
operator|=
name|sc
operator|->
name|txdesc_len
expr_stmt|;
if|if
condition|(
name|qos
condition|)
block|{
name|struct
name|ieee80211_qosframe
modifier|*
name|qwh
decl_stmt|;
specifier|const
name|int
name|tid
init|=
name|WME_AC_TO_TID
argument_list|(
name|WME_AC_BE
argument_list|)
decl_stmt|;
name|qwh
operator|=
operator|(
expr|struct
name|ieee80211_qosframe
operator|*
operator|)
name|wh
expr_stmt|;
name|qwh
operator|->
name|i_fc
index|[
literal|0
index|]
operator||=
name|IEEE80211_FC0_SUBTYPE_QOS_NULL
expr_stmt|;
name|qwh
operator|->
name|i_qos
index|[
literal|0
index|]
operator|=
name|tid
operator|&
name|IEEE80211_QOS_TID
expr_stmt|;
name|txd
operator|->
name|pktlen
operator|=
name|htole16
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_qosframe
argument_list|)
argument_list|)
expr_stmt|;
name|pktlen
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_qosframe
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator||=
name|IEEE80211_FC0_SUBTYPE_NODATA
expr_stmt|;
name|txd
operator|->
name|pktlen
operator|=
name|htole16
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_frame
argument_list|)
argument_list|)
expr_stmt|;
name|pktlen
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_frame
argument_list|)
expr_stmt|;
block|}
name|rtwn_fill_tx_desc_null
argument_list|(
name|sc
argument_list|,
name|ptr
argument_list|,
name|ic
operator|->
name|ic_curmode
operator|==
name|IEEE80211_MODE_11B
argument_list|,
name|qos
argument_list|,
name|uvp
operator|->
name|id
argument_list|)
expr_stmt|;
return|return
operator|(
name|pktlen
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|rtwn_push_nulldata
parameter_list|(
name|struct
name|rtwn_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
name|struct
name|rtwn_vap
modifier|*
name|uvp
init|=
name|RTWN_VAP
argument_list|(
name|vap
argument_list|)
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|struct
name|ieee80211_channel
modifier|*
name|c
init|=
name|ic
operator|->
name|ic_curchan
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|uint8_t
modifier|*
name|ptr
decl_stmt|;
name|int
name|required_size
decl_stmt|,
name|bcn_size
decl_stmt|,
name|null_size
decl_stmt|,
name|null_data
decl_stmt|,
name|error
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|RTWN_FW_LOADED
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* requires firmware */
name|KASSERT
argument_list|(
name|sc
operator|->
name|page_size
operator|>
literal|0
argument_list|,
operator|(
literal|"page size was not set!\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* Leave some space for beacon (multi-vap) */
name|bcn_size
operator|=
name|roundup
argument_list|(
name|RTWN_BCN_MAX_SIZE
argument_list|,
name|sc
operator|->
name|page_size
argument_list|)
expr_stmt|;
comment|/* 1 page for Null Data + 1 page for Qos Null Data frames. */
name|required_size
operator|=
name|bcn_size
operator|+
name|sc
operator|->
name|page_size
operator|*
literal|2
expr_stmt|;
name|m
operator|=
name|m_get2
argument_list|(
name|required_size
argument_list|,
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
comment|/* Setup beacon descriptor. */
name|rtwn_beacon_set_rate
argument_list|(
name|sc
argument_list|,
operator|&
name|uvp
operator|->
name|bcn_desc
operator|.
name|txd
index|[
literal|0
index|]
argument_list|,
name|IEEE80211_IS_CHAN_5GHZ
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|uint8_t
operator|*
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|ptr
argument_list|,
literal|0
argument_list|,
name|required_size
operator|-
name|sc
operator|->
name|txdesc_len
argument_list|)
expr_stmt|;
comment|/* Construct Null Data frame. */
name|ptr
operator|+=
name|bcn_size
operator|-
name|sc
operator|->
name|txdesc_len
expr_stmt|;
name|null_size
operator|=
name|rtwn_construct_nulldata
argument_list|(
name|sc
argument_list|,
name|vap
argument_list|,
name|ptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|null_size
operator|<
name|sc
operator|->
name|page_size
argument_list|,
operator|(
literal|"recalculate size for Null Data frame\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* Construct Qos Null Data frame. */
name|ptr
operator|+=
name|roundup
argument_list|(
name|null_size
argument_list|,
name|sc
operator|->
name|page_size
argument_list|)
expr_stmt|;
name|null_size
operator|=
name|rtwn_construct_nulldata
argument_list|(
name|sc
argument_list|,
name|vap
argument_list|,
name|ptr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|null_size
operator|<
name|sc
operator|->
name|page_size
argument_list|,
operator|(
literal|"recalculate size for Qos Null Data frame\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* Do not try to detect a beacon here. */
name|rtwn_setbits_1_shift
argument_list|(
name|sc
argument_list|,
name|R92C_CR
argument_list|,
literal|0
argument_list|,
name|R92C_CR_ENSWBCN
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|rtwn_setbits_1_shift
argument_list|(
name|sc
argument_list|,
name|R92C_FWHW_TXQ_CTRL
argument_list|,
name|R92C_FWHW_TXQ_CTRL_REAL_BEACON
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|uvp
operator|->
name|bcn_mbuf
operator|!=
name|NULL
condition|)
block|{
name|rtwn_beacon_unload
argument_list|(
name|sc
argument_list|,
name|uvp
operator|->
name|id
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|uvp
operator|->
name|bcn_mbuf
argument_list|)
expr_stmt|;
block|}
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|required_size
operator|-
name|sc
operator|->
name|txdesc_len
expr_stmt|;
name|uvp
operator|->
name|bcn_mbuf
operator|=
name|m
expr_stmt|;
name|error
operator|=
name|rtwn_tx_beacon_check
argument_list|(
name|sc
argument_list|,
name|uvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|RTWN_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RTWN_DEBUG_BEACON
argument_list|,
literal|"%s: frame was not recognized!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Setup addresses in firmware. */
name|null_data
operator|=
name|howmany
argument_list|(
name|bcn_size
argument_list|,
name|sc
operator|->
name|page_size
argument_list|)
expr_stmt|;
name|error
operator|=
name|rtwn_set_rsvd_page
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|null_data
argument_list|,
name|null_data
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: CMD_RSVD_PAGE was not sent, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|fail
label|:
comment|/* Re-enable beacon detection. */
name|rtwn_setbits_1_shift
argument_list|(
name|sc
argument_list|,
name|R92C_FWHW_TXQ_CTRL
argument_list|,
literal|0
argument_list|,
name|R92C_FWHW_TXQ_CTRL_REAL_BEACON
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|rtwn_setbits_1_shift
argument_list|(
name|sc
argument_list|,
name|R92C_CR
argument_list|,
name|R92C_CR_ENSWBCN
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Restore beacon (if present). */
if|if
condition|(
name|sc
operator|->
name|bcn_vaps
operator|>
literal|0
operator|&&
name|sc
operator|->
name|vaps
index|[
operator|!
name|uvp
operator|->
name|id
index|]
operator|!=
name|NULL
condition|)
block|{
name|struct
name|rtwn_vap
modifier|*
name|uvp2
init|=
name|sc
operator|->
name|vaps
index|[
operator|!
name|uvp
operator|->
name|id
index|]
decl_stmt|;
if|if
condition|(
name|uvp2
operator|->
name|curr_mode
operator|!=
name|R92C_MSR_NOLINK
condition|)
name|error
operator|=
name|rtwn_tx_beacon_check
argument_list|(
name|sc
argument_list|,
name|uvp2
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|rtwn_pwrmode_init
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|rtwn_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|rtwn_cmd_sleepable
argument_list|(
name|sc
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|rtwn_set_pwrmode_cb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|rtwn_set_pwrmode_cb
parameter_list|(
name|struct
name|rtwn_softc
modifier|*
name|sc
parameter_list|,
name|union
name|sec_param
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
operator|&
name|sc
operator|->
name|vaps
index|[
literal|0
index|]
operator|->
name|vap
decl_stmt|;
if|if
condition|(
name|vap
operator|!=
name|NULL
condition|)
name|rtwn_set_pwrmode
argument_list|(
name|sc
argument_list|,
name|vap
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|rtwn_tsf_sync_adhoc
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|arg
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|struct
name|rtwn_vap
modifier|*
name|uvp
init|=
name|RTWN_VAP
argument_list|(
name|vap
argument_list|)
decl_stmt|;
if|if
condition|(
name|uvp
operator|->
name|curr_mode
operator|!=
name|R92C_MSR_NOLINK
condition|)
block|{
comment|/* Do it in process context. */
name|ieee80211_runtask
argument_list|(
name|ic
argument_list|,
operator|&
name|uvp
operator|->
name|tsf_sync_adhoc_task
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Workaround for TSF synchronization:  * when BSSID filter in IBSS mode is not set  * (and TSF synchronization is enabled), then any beacon may update it.  * This routine synchronizes it when BSSID matching is enabled (IBSS merge  * is not possible during this period).  *  * NOTE: there is no race with rtwn_newstate(), since it uses the same  * taskqueue.  */
end_comment

begin_function
specifier|static
name|void
name|rtwn_tsf_sync_adhoc_task
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|arg
decl_stmt|;
name|struct
name|rtwn_vap
modifier|*
name|uvp
init|=
name|RTWN_VAP
argument_list|(
name|vap
argument_list|)
decl_stmt|;
name|struct
name|rtwn_softc
modifier|*
name|sc
init|=
name|vap
operator|->
name|iv_ic
operator|->
name|ic_softc
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|RTWN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ni
operator|=
name|ieee80211_ref_node
argument_list|(
name|vap
operator|->
name|iv_bss
argument_list|)
expr_stmt|;
comment|/* Accept beacons with the same BSSID. */
name|rtwn_set_rx_bssid_all
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Deny RCR updates. */
name|sc
operator|->
name|sc_flags
operator||=
name|RTWN_RCR_LOCKED
expr_stmt|;
comment|/* Enable synchronization. */
name|rtwn_setbits_1
argument_list|(
name|sc
argument_list|,
name|R92C_BCN_CTRL
argument_list|(
name|uvp
operator|->
name|id
argument_list|)
argument_list|,
name|R92C_BCN_CTRL_DIS_TSF_UDT0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Synchronize. */
name|rtwn_delay
argument_list|(
name|sc
argument_list|,
name|ni
operator|->
name|ni_intval
operator|*
literal|5
operator|*
literal|1000
argument_list|)
expr_stmt|;
comment|/* Disable synchronization. */
name|rtwn_setbits_1
argument_list|(
name|sc
argument_list|,
name|R92C_BCN_CTRL
argument_list|(
name|uvp
operator|->
name|id
argument_list|)
argument_list|,
literal|0
argument_list|,
name|R92C_BCN_CTRL_DIS_TSF_UDT0
argument_list|)
expr_stmt|;
comment|/* Accept all beacons. */
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|RTWN_RCR_LOCKED
expr_stmt|;
name|rtwn_set_rx_bssid_all
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Schedule next TSF synchronization. */
name|callout_reset
argument_list|(
operator|&
name|uvp
operator|->
name|tsf_sync_adhoc
argument_list|,
literal|60
operator|*
name|hz
argument_list|,
name|rtwn_tsf_sync_adhoc
argument_list|,
name|vap
argument_list|)
expr_stmt|;
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
name|RTWN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|rtwn_tsf_sync_enable
parameter_list|(
name|struct
name|rtwn_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|struct
name|rtwn_vap
modifier|*
name|uvp
init|=
name|RTWN_VAP
argument_list|(
name|vap
argument_list|)
decl_stmt|;
comment|/* Reset TSF. */
name|rtwn_write_1
argument_list|(
name|sc
argument_list|,
name|R92C_DUAL_TSF_RST
argument_list|,
name|R92C_DUAL_TSF_RESET
argument_list|(
name|uvp
operator|->
name|id
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|vap
operator|->
name|iv_opmode
condition|)
block|{
case|case
name|IEEE80211_M_STA
case|:
comment|/* Enable TSF synchronization. */
name|rtwn_setbits_1
argument_list|(
name|sc
argument_list|,
name|R92C_BCN_CTRL
argument_list|(
name|uvp
operator|->
name|id
argument_list|)
argument_list|,
name|R92C_BCN_CTRL_DIS_TSF_UDT0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_M_IBSS
case|:
name|ieee80211_runtask
argument_list|(
name|ic
argument_list|,
operator|&
name|uvp
operator|->
name|tsf_sync_adhoc_task
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|IEEE80211_M_HOSTAP
case|:
comment|/* Enable beaconing. */
name|rtwn_beacon_enable
argument_list|(
name|sc
argument_list|,
name|uvp
operator|->
name|id
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
default|default:
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"undefined opmode %d\n"
argument_list|,
name|vap
operator|->
name|iv_opmode
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|rtwn_set_ack_preamble
parameter_list|(
name|struct
name|rtwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|uint32_t
name|reg
decl_stmt|;
name|reg
operator|=
name|rtwn_read_4
argument_list|(
name|sc
argument_list|,
name|R92C_WMAC_TRXPTCL_CTL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_SHPREAMBLE
condition|)
name|reg
operator||=
name|R92C_WMAC_TRXPTCL_SHPRE
expr_stmt|;
else|else
name|reg
operator|&=
operator|~
name|R92C_WMAC_TRXPTCL_SHPRE
expr_stmt|;
name|rtwn_write_4
argument_list|(
name|sc
argument_list|,
name|R92C_WMAC_TRXPTCL_CTL
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|rtwn_set_mode
parameter_list|(
name|struct
name|rtwn_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|mode
parameter_list|,
name|int
name|id
parameter_list|)
block|{
name|rtwn_setbits_1
argument_list|(
name|sc
argument_list|,
name|R92C_MSR
argument_list|,
name|R92C_MSR_MASK
operator|<<
name|id
operator|*
literal|2
argument_list|,
name|mode
operator|<<
name|id
operator|*
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|vaps
index|[
name|id
index|]
operator|!=
name|NULL
condition|)
name|sc
operator|->
name|vaps
index|[
name|id
index|]
operator|->
name|curr_mode
operator|=
name|mode
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|rtwn_monitor_newstate
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
name|enum
name|ieee80211_state
name|nstate
parameter_list|,
name|int
name|arg
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|struct
name|rtwn_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_softc
decl_stmt|;
name|struct
name|rtwn_vap
modifier|*
name|uvp
init|=
name|RTWN_VAP
argument_list|(
name|vap
argument_list|)
decl_stmt|;
name|RTWN_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RTWN_DEBUG_STATE
argument_list|,
literal|"%s -> %s\n"
argument_list|,
name|ieee80211_state_name
index|[
name|vap
operator|->
name|iv_state
index|]
argument_list|,
name|ieee80211_state_name
index|[
name|nstate
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|iv_state
operator|!=
name|nstate
condition|)
block|{
name|IEEE80211_UNLOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|RTWN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|nstate
condition|)
block|{
case|case
name|IEEE80211_S_INIT
case|:
name|sc
operator|->
name|vaps_running
operator|--
expr_stmt|;
name|sc
operator|->
name|monvaps_running
operator|--
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|vaps_running
operator|==
literal|0
condition|)
block|{
comment|/* Turn link LED off. */
name|rtwn_set_led
argument_list|(
name|sc
argument_list|,
name|RTWN_LED_LINK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|IEEE80211_S_RUN
case|:
name|sc
operator|->
name|vaps_running
operator|++
expr_stmt|;
name|sc
operator|->
name|monvaps_running
operator|++
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|vaps_running
operator|==
literal|1
condition|)
block|{
comment|/* Turn link LED on. */
name|rtwn_set_led
argument_list|(
name|sc
argument_list|,
name|RTWN_LED_LINK
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
comment|/* NOTREACHED */
break|break;
block|}
name|RTWN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|IEEE80211_LOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|uvp
operator|->
name|newstate
argument_list|(
name|vap
argument_list|,
name|nstate
argument_list|,
name|arg
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|rtwn_newstate
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
name|enum
name|ieee80211_state
name|nstate
parameter_list|,
name|int
name|arg
parameter_list|)
block|{
name|struct
name|rtwn_vap
modifier|*
name|uvp
init|=
name|RTWN_VAP
argument_list|(
name|vap
argument_list|)
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|struct
name|rtwn_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_softc
decl_stmt|;
name|enum
name|ieee80211_state
name|ostate
decl_stmt|;
name|int
name|error
decl_stmt|,
name|early_newstate
decl_stmt|;
name|ostate
operator|=
name|vap
operator|->
name|iv_state
expr_stmt|;
name|RTWN_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RTWN_DEBUG_STATE
argument_list|,
literal|"%s -> %s\n"
argument_list|,
name|ieee80211_state_name
index|[
name|ostate
index|]
argument_list|,
name|ieee80211_state_name
index|[
name|nstate
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|iv_bss
operator|->
name|ni_chan
operator|==
name|IEEE80211_CHAN_ANYC
operator|&&
name|ostate
operator|==
name|IEEE80211_S_INIT
operator|&&
name|nstate
operator|==
name|IEEE80211_S_RUN
condition|)
block|{
comment|/* need to call iv_newstate() firstly */
name|error
operator|=
name|uvp
operator|->
name|newstate
argument_list|(
name|vap
argument_list|,
name|nstate
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|early_newstate
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|early_newstate
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ostate
operator|==
name|IEEE80211_S_CSA
condition|)
block|{
name|taskqueue_cancel_timeout
argument_list|(
name|taskqueue_thread
argument_list|,
operator|&
name|uvp
operator|->
name|tx_beacon_csa
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 		 * In multi-vap case second counter may not be cleared 		 * properly. 		 */
name|vap
operator|->
name|iv_csa_count
operator|=
literal|0
expr_stmt|;
block|}
name|IEEE80211_UNLOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|RTWN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ostate
operator|==
name|IEEE80211_S_CSA
condition|)
block|{
comment|/* Unblock all queues (multi-vap case). */
name|rtwn_write_1
argument_list|(
name|sc
argument_list|,
name|R92C_TXPAUSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ostate
operator|==
name|IEEE80211_S_RUN
operator|&&
name|nstate
operator|!=
name|IEEE80211_S_CSA
operator|)
operator|||
name|ostate
operator|==
name|IEEE80211_S_CSA
condition|)
block|{
name|sc
operator|->
name|vaps_running
operator|--
expr_stmt|;
comment|/* Set media status to 'No Link'. */
name|rtwn_set_mode
argument_list|(
name|sc
argument_list|,
name|R92C_MSR_NOLINK
argument_list|,
name|uvp
operator|->
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_IBSS
condition|)
block|{
comment|/* Stop periodical TSF synchronization. */
name|callout_stop
argument_list|(
operator|&
name|uvp
operator|->
name|tsf_sync_adhoc
argument_list|)
expr_stmt|;
block|}
comment|/* Disable TSF synchronization / beaconing. */
name|rtwn_beacon_enable
argument_list|(
name|sc
argument_list|,
name|uvp
operator|->
name|id
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rtwn_setbits_1
argument_list|(
name|sc
argument_list|,
name|R92C_BCN_CTRL
argument_list|(
name|uvp
operator|->
name|id
argument_list|)
argument_list|,
literal|0
argument_list|,
name|R92C_BCN_CTRL_DIS_TSF_UDT0
argument_list|)
expr_stmt|;
comment|/* NB: monitor mode vaps are using port 0. */
if|if
condition|(
name|uvp
operator|->
name|id
operator|!=
literal|0
operator|||
name|sc
operator|->
name|monvaps_running
operator|==
literal|0
condition|)
block|{
comment|/* Reset TSF. */
name|rtwn_write_1
argument_list|(
name|sc
argument_list|,
name|R92C_DUAL_TSF_RST
argument_list|,
name|R92C_DUAL_TSF_RESET
argument_list|(
name|uvp
operator|->
name|id
argument_list|)
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|RTWN_WITHOUT_UCODE
if|if
condition|(
operator|(
name|ic
operator|->
name|ic_caps
operator|&
name|IEEE80211_C_PMGT
operator|)
operator|!=
literal|0
operator|&&
name|uvp
operator|->
name|id
operator|==
literal|0
condition|)
block|{
comment|/* Disable power management. */
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|sc_pwrmode_init
argument_list|)
expr_stmt|;
name|rtwn_set_pwrmode
argument_list|(
name|sc
argument_list|,
name|vap
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|sc
operator|->
name|vaps_running
operator|-
name|sc
operator|->
name|monvaps_running
operator|>
literal|0
condition|)
block|{
comment|/* Recalculate basic rates bitmap. */
name|rtwn_calc_basicrates
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|vaps_running
operator|==
name|sc
operator|->
name|monvaps_running
condition|)
block|{
comment|/* Stop calibration. */
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|sc_calib_to
argument_list|)
expr_stmt|;
comment|/* Stop Rx of data frames. */
name|rtwn_write_2
argument_list|(
name|sc
argument_list|,
name|R92C_RXFLTMAP2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Reset EDCA parameters. */
name|rtwn_write_4
argument_list|(
name|sc
argument_list|,
name|R92C_EDCA_VO_PARAM
argument_list|,
literal|0x002f3217
argument_list|)
expr_stmt|;
name|rtwn_write_4
argument_list|(
name|sc
argument_list|,
name|R92C_EDCA_VI_PARAM
argument_list|,
literal|0x005e4317
argument_list|)
expr_stmt|;
name|rtwn_write_4
argument_list|(
name|sc
argument_list|,
name|R92C_EDCA_BE_PARAM
argument_list|,
literal|0x00105320
argument_list|)
expr_stmt|;
name|rtwn_write_4
argument_list|(
name|sc
argument_list|,
name|R92C_EDCA_BK_PARAM
argument_list|,
literal|0x0000a444
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|vaps_running
operator|==
literal|0
condition|)
block|{
comment|/* Turn link LED off. */
name|rtwn_set_led
argument_list|(
name|sc
argument_list|,
name|RTWN_LED_LINK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|error
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|nstate
condition|)
block|{
case|case
name|IEEE80211_S_SCAN
case|:
comment|/* Pause AC Tx queues. */
if|if
condition|(
name|sc
operator|->
name|vaps_running
operator|==
literal|0
condition|)
name|rtwn_setbits_1
argument_list|(
name|sc
argument_list|,
name|R92C_TXPAUSE
argument_list|,
literal|0
argument_list|,
name|R92C_TX_QUEUE_AC
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_S_RUN
case|:
name|error
operator|=
name|rtwn_run
argument_list|(
name|sc
argument_list|,
name|vap
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not move to RUN state\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
break|break;
block|}
name|sc
operator|->
name|vaps_running
operator|++
expr_stmt|;
break|break;
case|case
name|IEEE80211_S_CSA
case|:
comment|/* Block all Tx queues (except beacon queue). */
name|rtwn_setbits_1
argument_list|(
name|sc
argument_list|,
name|R92C_TXPAUSE
argument_list|,
literal|0
argument_list|,
name|R92C_TX_QUEUE_AC
operator||
name|R92C_TX_QUEUE_MGT
operator||
name|R92C_TX_QUEUE_HIGH
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|RTWN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|IEEE80211_LOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
operator|(
name|early_newstate
condition|?
literal|0
else|:
name|uvp
operator|->
name|newstate
argument_list|(
name|vap
argument_list|,
name|nstate
argument_list|,
name|arg
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|rtwn_calc_basicrates
parameter_list|(
name|struct
name|rtwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|uint32_t
name|basicrates
decl_stmt|;
name|int
name|i
decl_stmt|;
name|RTWN_ASSERT_LOCKED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_SCAN
condition|)
return|return;
comment|/* will be done by rtwn_scan_end(). */
name|basicrates
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nitems
argument_list|(
name|sc
operator|->
name|vaps
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|rtwn_vap
modifier|*
name|rvp
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|uint32_t
name|rates
decl_stmt|;
name|rvp
operator|=
name|sc
operator|->
name|vaps
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|rvp
operator|==
name|NULL
operator|||
name|rvp
operator|->
name|curr_mode
operator|==
name|R92C_MSR_NOLINK
condition|)
continue|continue;
name|vap
operator|=
operator|&
name|rvp
operator|->
name|vap
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|iv_bss
operator|==
name|NULL
condition|)
continue|continue;
name|ni
operator|=
name|ieee80211_ref_node
argument_list|(
name|vap
operator|->
name|iv_bss
argument_list|)
expr_stmt|;
name|rtwn_get_rates
argument_list|(
name|sc
argument_list|,
operator|&
name|ni
operator|->
name|ni_rates
argument_list|,
name|NULL
argument_list|,
operator|&
name|rates
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|basicrates
operator||=
name|rates
expr_stmt|;
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|basicrates
operator|==
literal|0
condition|)
return|return;
comment|/* XXX initial RTS rate? */
name|rtwn_set_basicrates
argument_list|(
name|sc
argument_list|,
name|basicrates
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|rtwn_run
parameter_list|(
name|struct
name|rtwn_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|struct
name|rtwn_vap
modifier|*
name|uvp
init|=
name|RTWN_VAP
argument_list|(
name|vap
argument_list|)
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|uint8_t
name|mode
decl_stmt|;
name|int
name|error
decl_stmt|;
name|RTWN_ASSERT_LOCKED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|ni
operator|=
name|ieee80211_ref_node
argument_list|(
name|vap
operator|->
name|iv_bss
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_bsschan
operator|==
name|IEEE80211_CHAN_ANYC
operator|||
name|ni
operator|->
name|ni_chan
operator|==
name|IEEE80211_CHAN_ANYC
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
switch|switch
condition|(
name|vap
operator|->
name|iv_opmode
condition|)
block|{
case|case
name|IEEE80211_M_STA
case|:
name|mode
operator|=
name|R92C_MSR_INFRA
expr_stmt|;
break|break;
case|case
name|IEEE80211_M_IBSS
case|:
name|mode
operator|=
name|R92C_MSR_ADHOC
expr_stmt|;
break|break;
case|case
name|IEEE80211_M_HOSTAP
case|:
name|mode
operator|=
name|R92C_MSR_AP
expr_stmt|;
break|break;
default|default:
name|KASSERT
argument_list|(
literal|0
argument_list|,
operator|(
literal|"undefined opmode %d\n"
operator|,
name|vap
operator|->
name|iv_opmode
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Set media status to 'Associated'. */
name|rtwn_set_mode
argument_list|(
name|sc
argument_list|,
name|mode
argument_list|,
name|uvp
operator|->
name|id
argument_list|)
expr_stmt|;
comment|/* Set AssocID. */
comment|/* XXX multi-vap? */
name|rtwn_write_2
argument_list|(
name|sc
argument_list|,
name|R92C_BCN_PSR_RPT
argument_list|,
literal|0xc000
operator||
name|IEEE80211_NODE_AID
argument_list|(
name|ni
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set BSSID. */
name|rtwn_set_bssid
argument_list|(
name|sc
argument_list|,
name|ni
operator|->
name|ni_bssid
argument_list|,
name|uvp
operator|->
name|id
argument_list|)
expr_stmt|;
comment|/* Set beacon interval. */
name|rtwn_write_2
argument_list|(
name|sc
argument_list|,
name|R92C_BCN_INTERVAL
argument_list|(
name|uvp
operator|->
name|id
argument_list|)
argument_list|,
name|ni
operator|->
name|ni_intval
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|vaps_running
operator|==
name|sc
operator|->
name|monvaps_running
condition|)
block|{
comment|/* Enable Rx of data frames. */
name|rtwn_write_2
argument_list|(
name|sc
argument_list|,
name|R92C_RXFLTMAP2
argument_list|,
literal|0xffff
argument_list|)
expr_stmt|;
comment|/* Flush all AC queues. */
name|rtwn_write_1
argument_list|(
name|sc
argument_list|,
name|R92C_TXPAUSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|RTWN_WITHOUT_UCODE
comment|/* Upload (QoS) Null Data frame to firmware. */
comment|/* Note: do this for port 0 only. */
if|if
condition|(
operator|(
name|ic
operator|->
name|ic_caps
operator|&
name|IEEE80211_C_PMGT
operator|)
operator|!=
literal|0
operator|&&
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_STA
operator|&&
name|uvp
operator|->
name|id
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|rtwn_tx_fwpkt_check
argument_list|(
name|sc
argument_list|,
name|vap
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
comment|/* Setup power management. */
comment|/* 		 * NB: it will be enabled immediately - delay it, 		 * so 4-Way handshake will not be interrupted. 		 */
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sc_pwrmode_init
argument_list|,
literal|5
operator|*
name|hz
argument_list|,
name|rtwn_pwrmode_init
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Enable TSF synchronization. */
name|rtwn_tsf_sync_enable
argument_list|(
name|sc
argument_list|,
name|vap
argument_list|)
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_HOSTAP
operator|||
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_IBSS
condition|)
block|{
name|error
operator|=
name|rtwn_setup_beacon
argument_list|(
name|sc
argument_list|,
name|ni
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"unable to push beacon into the chip, "
literal|"error %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
comment|/* Set ACK preamble type. */
name|rtwn_set_ack_preamble
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Set basic rates mask. */
name|rtwn_calc_basicrates
argument_list|(
name|sc
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RTWN_TODO
name|rtwn_write_1
argument_list|(
name|sc
argument_list|,
name|R92C_SIFS_CCK
operator|+
literal|1
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|rtwn_write_1
argument_list|(
name|sc
argument_list|,
name|R92C_SIFS_OFDM
operator|+
literal|1
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|rtwn_write_1
argument_list|(
name|sc
argument_list|,
name|R92C_SPEC_SIFS
operator|+
literal|1
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|rtwn_write_1
argument_list|(
name|sc
argument_list|,
name|R92C_MAC_SPEC_SIFS
operator|+
literal|1
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|rtwn_write_1
argument_list|(
name|sc
argument_list|,
name|R92C_R2T_SIFS
operator|+
literal|1
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|rtwn_write_1
argument_list|(
name|sc
argument_list|,
name|R92C_T2T_SIFS
operator|+
literal|1
argument_list|,
literal|10
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sc
operator|->
name|vaps_running
operator|==
name|sc
operator|->
name|monvaps_running
condition|)
block|{
comment|/* Reset temperature calibration state machine. */
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|RTWN_TEMP_MEASURED
expr_stmt|;
name|sc
operator|->
name|thcal_temp
operator|=
name|sc
operator|->
name|thermal_meter
expr_stmt|;
comment|/* Start periodic calibration. */
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sc_calib_to
argument_list|,
literal|2
operator|*
name|hz
argument_list|,
name|rtwn_calib_to
argument_list|,
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|vaps_running
operator|==
literal|0
condition|)
block|{
comment|/* Turn link LED on. */
name|rtwn_set_led
argument_list|(
name|sc
argument_list|,
name|RTWN_LED_LINK
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|fail
label|:
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|D4054
end_ifndef

begin_function
specifier|static
name|void
name|rtwn_watchdog
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|rtwn_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|RTWN_ASSERT_LOCKED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|sc_flags
operator|&
name|RTWN_RUNNING
argument_list|,
operator|(
literal|"not running"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_tx_timer
operator|!=
literal|0
operator|&&
operator|--
name|sc
operator|->
name|sc_tx_timer
operator|==
literal|0
condition|)
block|{
name|ic_printf
argument_list|(
name|ic
argument_list|,
literal|"device timeout\n"
argument_list|)
expr_stmt|;
name|ieee80211_restart_all
argument_list|(
name|ic
argument_list|)
expr_stmt|;
return|return;
block|}
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sc_watchdog_to
argument_list|,
name|hz
argument_list|,
name|rtwn_watchdog
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|rtwn_parent
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|struct
name|rtwn_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_softc
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
decl_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_nrunning
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|rtwn_init
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|IEEE80211_LOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|vap
argument_list|,
argument|&ic->ic_vaps
argument_list|,
argument|iv_next
argument_list|)
name|ieee80211_stop_locked
argument_list|(
name|vap
argument_list|)
expr_stmt|;
name|IEEE80211_UNLOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
else|else
name|ieee80211_start_all
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
else|else
name|rtwn_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|rtwn_llt_write
parameter_list|(
name|struct
name|rtwn_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|addr
parameter_list|,
name|uint32_t
name|data
parameter_list|)
block|{
name|int
name|ntries
decl_stmt|,
name|error
decl_stmt|;
name|error
operator|=
name|rtwn_write_4
argument_list|(
name|sc
argument_list|,
name|R92C_LLT_INIT
argument_list|,
name|SM
argument_list|(
name|R92C_LLT_INIT_OP
argument_list|,
name|R92C_LLT_INIT_OP_WRITE
argument_list|)
operator||
name|SM
argument_list|(
name|R92C_LLT_INIT_ADDR
argument_list|,
name|addr
argument_list|)
operator||
name|SM
argument_list|(
name|R92C_LLT_INIT_DATA
argument_list|,
name|data
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Wait for write operation to complete. */
for|for
control|(
name|ntries
operator|=
literal|0
init|;
name|ntries
operator|<
literal|20
condition|;
name|ntries
operator|++
control|)
block|{
if|if
condition|(
name|MS
argument_list|(
name|rtwn_read_4
argument_list|(
name|sc
argument_list|,
name|R92C_LLT_INIT
argument_list|)
argument_list|,
name|R92C_LLT_INIT_OP
argument_list|)
operator|==
name|R92C_LLT_INIT_OP_NO_ACTIVE
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|rtwn_delay
argument_list|(
name|sc
argument_list|,
literal|10
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ETIMEDOUT
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|rtwn_llt_init
parameter_list|(
name|struct
name|rtwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|error
decl_stmt|;
comment|/* Reserve pages [0; page_count]. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|page_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|rtwn_llt_write
argument_list|(
name|sc
argument_list|,
name|i
argument_list|,
name|i
operator|+
literal|1
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* NB: 0xff indicates end-of-list. */
if|if
condition|(
operator|(
name|error
operator|=
name|rtwn_llt_write
argument_list|(
name|sc
argument_list|,
name|i
argument_list|,
literal|0xff
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 	 * Use pages [page_count + 1; pktbuf_count - 1] 	 * as ring buffer. 	 */
for|for
control|(
operator|++
name|i
init|;
name|i
operator|<
name|sc
operator|->
name|pktbuf_count
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|rtwn_llt_write
argument_list|(
name|sc
argument_list|,
name|i
argument_list|,
name|i
operator|+
literal|1
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* Make the last page point to the beginning of the ring buffer. */
name|error
operator|=
name|rtwn_llt_write
argument_list|(
name|sc
argument_list|,
name|i
argument_list|,
name|sc
operator|->
name|page_count
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|rtwn_dma_init
parameter_list|(
name|struct
name|rtwn_softc
modifier|*
name|sc
parameter_list|)
block|{
define|#
directive|define
name|RTWN_CHK
parameter_list|(
name|res
parameter_list|)
value|do {	\ 	if (res != 0)		\ 		return (EIO);	\ } while(0)
name|uint16_t
name|reg
decl_stmt|;
name|uint8_t
name|tx_boundary
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Initialize LLT table. */
name|error
operator|=
name|rtwn_llt_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Set the number of pages for each queue. */
name|RTWN_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RTWN_DEBUG_RESET
argument_list|,
literal|"%s: pages per queue: high %d, normal %d, low %d, public %d\n"
argument_list|,
name|__func__
argument_list|,
name|sc
operator|->
name|nhqpages
argument_list|,
name|sc
operator|->
name|nnqpages
argument_list|,
name|sc
operator|->
name|nlqpages
argument_list|,
name|sc
operator|->
name|npubqpages
argument_list|)
expr_stmt|;
name|RTWN_CHK
argument_list|(
name|rtwn_write_1
argument_list|(
name|sc
argument_list|,
name|R92C_RQPN_NPQ
argument_list|,
name|sc
operator|->
name|nnqpages
argument_list|)
argument_list|)
expr_stmt|;
name|RTWN_CHK
argument_list|(
name|rtwn_write_4
argument_list|(
name|sc
argument_list|,
name|R92C_RQPN
argument_list|,
comment|/* Set number of pages for public queue. */
name|SM
argument_list|(
name|R92C_RQPN_PUBQ
argument_list|,
name|sc
operator|->
name|npubqpages
argument_list|)
operator||
comment|/* Set number of pages for high priority queue. */
name|SM
argument_list|(
name|R92C_RQPN_HPQ
argument_list|,
name|sc
operator|->
name|nhqpages
argument_list|)
operator||
comment|/* Set number of pages for low priority queue. */
name|SM
argument_list|(
name|R92C_RQPN_LPQ
argument_list|,
name|sc
operator|->
name|nlqpages
argument_list|)
operator||
comment|/* Load values. */
name|R92C_RQPN_LD
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Initialize TX buffer boundary. */
name|KASSERT
argument_list|(
name|sc
operator|->
name|page_count
operator|<
literal|255
operator|&&
name|sc
operator|->
name|page_count
operator|>
literal|0
argument_list|,
operator|(
literal|"page_count is %d\n"
operator|,
name|sc
operator|->
name|page_count
operator|)
argument_list|)
expr_stmt|;
name|tx_boundary
operator|=
name|sc
operator|->
name|page_count
operator|+
literal|1
expr_stmt|;
name|RTWN_CHK
argument_list|(
name|rtwn_write_1
argument_list|(
name|sc
argument_list|,
name|R92C_TXPKTBUF_BCNQ_BDNY
argument_list|,
name|tx_boundary
argument_list|)
argument_list|)
expr_stmt|;
name|RTWN_CHK
argument_list|(
name|rtwn_write_1
argument_list|(
name|sc
argument_list|,
name|R92C_TXPKTBUF_MGQ_BDNY
argument_list|,
name|tx_boundary
argument_list|)
argument_list|)
expr_stmt|;
name|RTWN_CHK
argument_list|(
name|rtwn_write_1
argument_list|(
name|sc
argument_list|,
name|R92C_TXPKTBUF_WMAC_LBK_BF_HD
argument_list|,
name|tx_boundary
argument_list|)
argument_list|)
expr_stmt|;
name|RTWN_CHK
argument_list|(
name|rtwn_write_1
argument_list|(
name|sc
argument_list|,
name|R92C_TRXFF_BNDY
argument_list|,
name|tx_boundary
argument_list|)
argument_list|)
expr_stmt|;
name|RTWN_CHK
argument_list|(
name|rtwn_write_1
argument_list|(
name|sc
argument_list|,
name|R92C_TDECTRL
operator|+
literal|1
argument_list|,
name|tx_boundary
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|rtwn_init_bcnq1_boundary
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Set queue to USB pipe mapping. */
comment|/* Note: PCIe devices are using some magic number here. */
name|reg
operator|=
name|rtwn_get_qmap
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|RTWN_CHK
argument_list|(
name|rtwn_setbits_2
argument_list|(
name|sc
argument_list|,
name|R92C_TRXDMA_CTRL
argument_list|,
name|R92C_TRXDMA_CTRL_QMAP_M
argument_list|,
name|reg
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Configure Tx/Rx DMA (PCIe). */
name|rtwn_set_desc_addr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Set Tx/Rx transfer page boundary. */
name|RTWN_CHK
argument_list|(
name|rtwn_write_2
argument_list|(
name|sc
argument_list|,
name|R92C_TRXFF_BNDY
operator|+
literal|2
argument_list|,
name|sc
operator|->
name|rx_dma_size
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set Tx/Rx transfer page size. */
name|rtwn_set_page_size
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|rtwn_mac_init
parameter_list|(
name|struct
name|rtwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|error
decl_stmt|;
comment|/* Write MAC initialization values. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|mac_size
condition|;
name|i
operator|++
control|)
block|{
name|error
operator|=
name|rtwn_write_1
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mac_prog
index|[
name|i
index|]
operator|.
name|reg
argument_list|,
name|sc
operator|->
name|mac_prog
index|[
name|i
index|]
operator|.
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|rtwn_mrr_init
parameter_list|(
name|struct
name|rtwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* Drop rate index by 1 per retry. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|R92C_DARFRC_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|rtwn_write_1
argument_list|(
name|sc
argument_list|,
name|R92C_DARFRC
operator|+
name|i
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|rtwn_write_1
argument_list|(
name|sc
argument_list|,
name|R92C_RARFRC
operator|+
name|i
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|rtwn_scan_start
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|struct
name|rtwn_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_softc
decl_stmt|;
name|RTWN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Pause beaconing. */
name|rtwn_setbits_1
argument_list|(
name|sc
argument_list|,
name|R92C_TXPAUSE
argument_list|,
literal|0
argument_list|,
name|R92C_TX_QUEUE_BCN
argument_list|)
expr_stmt|;
comment|/* Receive beacons / probe responses from any BSSID. */
if|if
condition|(
name|sc
operator|->
name|bcn_vaps
operator|==
literal|0
condition|)
name|rtwn_set_rx_bssid_all
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|RTWN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|rtwn_scan_curchan
parameter_list|(
name|struct
name|ieee80211_scan_state
modifier|*
name|ss
parameter_list|,
name|unsigned
name|long
name|maxdwell
parameter_list|)
block|{
name|struct
name|rtwn_softc
modifier|*
name|sc
init|=
name|ss
operator|->
name|ss_ic
operator|->
name|ic_softc
decl_stmt|;
comment|/* Make link LED blink during scan. */
name|RTWN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|rtwn_set_led
argument_list|(
name|sc
argument_list|,
name|RTWN_LED_LINK
argument_list|,
operator|!
name|sc
operator|->
name|ledlink
argument_list|)
expr_stmt|;
name|RTWN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_scan_curchan
argument_list|(
name|ss
argument_list|,
name|maxdwell
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|rtwn_scan_end
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|struct
name|rtwn_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_softc
decl_stmt|;
name|RTWN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Restore limitations. */
if|if
condition|(
name|ic
operator|->
name|ic_promisc
operator|==
literal|0
operator|&&
name|sc
operator|->
name|bcn_vaps
operator|==
literal|0
condition|)
name|rtwn_set_rx_bssid_all
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Restore LED state. */
name|rtwn_set_led
argument_list|(
name|sc
argument_list|,
name|RTWN_LED_LINK
argument_list|,
operator|(
name|sc
operator|->
name|vaps_running
operator|!=
literal|0
operator|)
argument_list|)
expr_stmt|;
comment|/* Restore basic rates mask. */
name|rtwn_calc_basicrates
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Resume beaconing. */
name|rtwn_setbits_1
argument_list|(
name|sc
argument_list|,
name|R92C_TXPAUSE
argument_list|,
name|R92C_TX_QUEUE_BCN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|RTWN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|rtwn_getradiocaps
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|int
name|maxchans
parameter_list|,
name|int
modifier|*
name|nchans
parameter_list|,
name|struct
name|ieee80211_channel
name|chans
index|[]
parameter_list|)
block|{
name|struct
name|rtwn_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_softc
decl_stmt|;
name|uint8_t
name|bands
index|[
name|IEEE80211_MODE_BYTES
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|memset
argument_list|(
name|bands
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|bands
argument_list|)
argument_list|)
expr_stmt|;
name|setbit
argument_list|(
name|bands
argument_list|,
name|IEEE80211_MODE_11B
argument_list|)
expr_stmt|;
name|setbit
argument_list|(
name|bands
argument_list|,
name|IEEE80211_MODE_11G
argument_list|)
expr_stmt|;
name|setbit
argument_list|(
name|bands
argument_list|,
name|IEEE80211_MODE_11NG
argument_list|)
expr_stmt|;
name|ieee80211_add_channel_list_2ghz
argument_list|(
name|chans
argument_list|,
name|maxchans
argument_list|,
name|nchans
argument_list|,
name|rtwn_chan_2ghz
argument_list|,
name|nitems
argument_list|(
name|rtwn_chan_2ghz
argument_list|)
argument_list|,
name|bands
argument_list|,
operator|!
operator|!
operator|(
name|ic
operator|->
name|ic_htcaps
operator|&
name|IEEE80211_HTCAP_CHWIDTH40
operator|)
argument_list|)
expr_stmt|;
comment|/* XXX workaround add_channel_list() limitations */
name|setbit
argument_list|(
name|bands
argument_list|,
name|IEEE80211_MODE_11A
argument_list|)
expr_stmt|;
name|setbit
argument_list|(
name|bands
argument_list|,
name|IEEE80211_MODE_11NA
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nitems
argument_list|(
name|sc
operator|->
name|chan_num_5ghz
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|chan_num_5ghz
index|[
name|i
index|]
operator|==
literal|0
condition|)
continue|continue;
name|ieee80211_add_channel_list_5ghz
argument_list|(
name|chans
argument_list|,
name|maxchans
argument_list|,
name|nchans
argument_list|,
name|sc
operator|->
name|chan_list_5ghz
index|[
name|i
index|]
argument_list|,
name|sc
operator|->
name|chan_num_5ghz
index|[
name|i
index|]
argument_list|,
name|bands
argument_list|,
operator|!
operator|!
operator|(
name|ic
operator|->
name|ic_htcaps
operator|&
name|IEEE80211_HTCAP_CHWIDTH40
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|rtwn_update_chw
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
name|void
name|rtwn_set_channel
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|struct
name|rtwn_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_softc
decl_stmt|;
name|struct
name|ieee80211_channel
modifier|*
name|c
init|=
name|ic
operator|->
name|ic_curchan
decl_stmt|;
name|RTWN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|rtwn_set_chan
argument_list|(
name|sc
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_rxtap
operator|.
name|wr_chan_freq
operator|=
name|htole16
argument_list|(
name|c
operator|->
name|ic_freq
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_rxtap
operator|.
name|wr_chan_flags
operator|=
name|htole16
argument_list|(
name|c
operator|->
name|ic_flags
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_txtap
operator|.
name|wt_chan_freq
operator|=
name|htole16
argument_list|(
name|c
operator|->
name|ic_freq
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_txtap
operator|.
name|wt_chan_flags
operator|=
name|htole16
argument_list|(
name|c
operator|->
name|ic_flags
argument_list|)
expr_stmt|;
name|RTWN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|rtwn_wme_update
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|struct
name|ieee80211_channel
modifier|*
name|c
init|=
name|ic
operator|->
name|ic_curchan
decl_stmt|;
name|struct
name|rtwn_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_softc
decl_stmt|;
name|struct
name|wmeParams
modifier|*
name|wmep
init|=
name|sc
operator|->
name|cap_wmeParams
decl_stmt|;
name|uint8_t
name|aifs
decl_stmt|,
name|acm
decl_stmt|,
name|slottime
decl_stmt|;
name|int
name|ac
decl_stmt|;
comment|/* Prevent possible races. */
name|IEEE80211_LOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
comment|/* XXX */
name|RTWN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|wmep
argument_list|,
name|ic
operator|->
name|ic_wme
operator|.
name|wme_chanParams
operator|.
name|cap_wmeParams
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|cap_wmeParams
argument_list|)
argument_list|)
expr_stmt|;
name|RTWN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|IEEE80211_UNLOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|acm
operator|=
literal|0
expr_stmt|;
name|slottime
operator|=
name|IEEE80211_GET_SLOTTIME
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|RTWN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
name|ac
operator|=
name|WME_AC_BE
init|;
name|ac
operator|<
name|WME_NUM_AC
condition|;
name|ac
operator|++
control|)
block|{
comment|/* AIFS[AC] = AIFSN[AC] * aSlotTime + aSIFSTime. */
name|aifs
operator|=
name|wmep
index|[
name|ac
index|]
operator|.
name|wmep_aifsn
operator|*
name|slottime
operator|+
operator|(
name|IEEE80211_IS_CHAN_5GHZ
argument_list|(
name|c
argument_list|)
condition|?
name|IEEE80211_DUR_OFDM_SIFS
else|:
name|IEEE80211_DUR_SIFS
operator|)
expr_stmt|;
name|rtwn_write_4
argument_list|(
name|sc
argument_list|,
name|wme2reg
index|[
name|ac
index|]
argument_list|,
name|SM
argument_list|(
name|R92C_EDCA_PARAM_TXOP
argument_list|,
name|wmep
index|[
name|ac
index|]
operator|.
name|wmep_txopLimit
argument_list|)
operator||
name|SM
argument_list|(
name|R92C_EDCA_PARAM_ECWMIN
argument_list|,
name|wmep
index|[
name|ac
index|]
operator|.
name|wmep_logcwmin
argument_list|)
operator||
name|SM
argument_list|(
name|R92C_EDCA_PARAM_ECWMAX
argument_list|,
name|wmep
index|[
name|ac
index|]
operator|.
name|wmep_logcwmax
argument_list|)
operator||
name|SM
argument_list|(
name|R92C_EDCA_PARAM_AIFS
argument_list|,
name|aifs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ac
operator|!=
name|WME_AC_BE
condition|)
name|acm
operator||=
name|wmep
index|[
name|ac
index|]
operator|.
name|wmep_acm
operator|<<
name|ac
expr_stmt|;
block|}
if|if
condition|(
name|acm
operator|!=
literal|0
condition|)
name|acm
operator||=
name|R92C_ACMHWCTRL_EN
expr_stmt|;
name|rtwn_setbits_1
argument_list|(
name|sc
argument_list|,
name|R92C_ACMHWCTRL
argument_list|,
name|R92C_ACMHWCTRL_ACM_MASK
argument_list|,
name|acm
argument_list|)
expr_stmt|;
name|RTWN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|rtwn_update_slot
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|rtwn_cmd_sleepable
argument_list|(
name|ic
operator|->
name|ic_softc
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|rtwn_update_slot_cb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|rtwn_update_slot_cb
parameter_list|(
name|struct
name|rtwn_softc
modifier|*
name|sc
parameter_list|,
name|union
name|sec_param
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|uint8_t
name|slottime
decl_stmt|;
name|slottime
operator|=
name|IEEE80211_GET_SLOTTIME
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|RTWN_DPRINTF
argument_list|(
name|sc
argument_list|,
name|RTWN_DEBUG_STATE
argument_list|,
literal|"%s: setting slot time to %uus\n"
argument_list|,
name|__func__
argument_list|,
name|slottime
argument_list|)
expr_stmt|;
name|rtwn_write_1
argument_list|(
name|sc
argument_list|,
name|R92C_SLOT
argument_list|,
name|slottime
argument_list|)
expr_stmt|;
name|rtwn_update_aifs
argument_list|(
name|sc
argument_list|,
name|slottime
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|rtwn_update_aifs
parameter_list|(
name|struct
name|rtwn_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|slottime
parameter_list|)
block|{
name|struct
name|ieee80211_channel
modifier|*
name|c
init|=
name|sc
operator|->
name|sc_ic
operator|.
name|ic_curchan
decl_stmt|;
specifier|const
name|struct
name|wmeParams
modifier|*
name|wmep
init|=
name|sc
operator|->
name|cap_wmeParams
decl_stmt|;
name|uint8_t
name|aifs
decl_stmt|,
name|ac
decl_stmt|;
for|for
control|(
name|ac
operator|=
name|WME_AC_BE
init|;
name|ac
operator|<
name|WME_NUM_AC
condition|;
name|ac
operator|++
control|)
block|{
comment|/* AIFS[AC] = AIFSN[AC] * aSlotTime + aSIFSTime. */
name|aifs
operator|=
name|wmep
index|[
name|ac
index|]
operator|.
name|wmep_aifsn
operator|*
name|slottime
operator|+
operator|(
name|IEEE80211_IS_CHAN_5GHZ
argument_list|(
name|c
argument_list|)
condition|?
name|IEEE80211_DUR_OFDM_SIFS
else|:
name|IEEE80211_DUR_SIFS
operator|)
expr_stmt|;
name|rtwn_write_1
argument_list|(
name|sc
argument_list|,
name|wme2reg
index|[
name|ac
index|]
argument_list|,
name|aifs
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|rtwn_update_promisc
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|struct
name|rtwn_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_softc
decl_stmt|;
name|RTWN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|RTWN_RUNNING
condition|)
name|rtwn_set_promisc
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|RTWN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|rtwn_update_mcast
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|struct
name|rtwn_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_softc
decl_stmt|;
name|RTWN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|RTWN_RUNNING
condition|)
name|rtwn_set_multi
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|RTWN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|rtwn_set_bssid
parameter_list|(
name|struct
name|rtwn_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|bssid
parameter_list|,
name|int
name|id
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
name|rtwn_write_4
argument_list|(
name|sc
argument_list|,
name|R92C_BSSID
argument_list|(
name|id
argument_list|)
argument_list|,
name|le32dec
argument_list|(
operator|&
name|bssid
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|rtwn_write_2
argument_list|(
name|sc
argument_list|,
name|R92C_BSSID
argument_list|(
name|id
argument_list|)
operator|+
literal|4
argument_list|,
name|le16dec
argument_list|(
operator|&
name|bssid
index|[
literal|4
index|]
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|rtwn_set_macaddr
parameter_list|(
name|struct
name|rtwn_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|addr
parameter_list|,
name|int
name|id
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
name|rtwn_write_4
argument_list|(
name|sc
argument_list|,
name|R92C_MACID
argument_list|(
name|id
argument_list|)
argument_list|,
name|le32dec
argument_list|(
operator|&
name|addr
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|rtwn_write_2
argument_list|(
name|sc
argument_list|,
name|R92C_MACID
argument_list|(
name|id
argument_list|)
operator|+
literal|4
argument_list|,
name|le16dec
argument_list|(
operator|&
name|addr
index|[
literal|4
index|]
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|ieee80211_node
modifier|*
name|rtwn_node_alloc
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
specifier|const
name|uint8_t
name|mac
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
block|{
name|struct
name|rtwn_node
modifier|*
name|un
decl_stmt|;
name|un
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|rtwn_node
argument_list|)
argument_list|,
name|M_80211_NODE
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|un
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|un
operator|->
name|id
operator|=
name|RTWN_MACID_UNDEFINED
expr_stmt|;
name|un
operator|->
name|avg_pwdb
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|&
name|un
operator|->
name|ni
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|rtwn_newassoc
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|int
name|isnew
parameter_list|)
block|{
name|struct
name|rtwn_softc
modifier|*
name|sc
init|=
name|ni
operator|->
name|ni_ic
operator|->
name|ic_softc
decl_stmt|;
name|struct
name|rtwn_node
modifier|*
name|un
init|=
name|RTWN_NODE
argument_list|(
name|ni
argument_list|)
decl_stmt|;
name|int
name|id
decl_stmt|;
if|if
condition|(
operator|!
name|isnew
condition|)
return|return;
name|RTWN_NT_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
name|id
operator|=
literal|0
init|;
name|id
operator|<=
name|sc
operator|->
name|macid_limit
condition|;
name|id
operator|++
control|)
block|{
if|if
condition|(
name|id
operator|!=
name|RTWN_MACID_BC
operator|&&
name|sc
operator|->
name|node_list
index|[
name|id
index|]
operator|==
name|NULL
condition|)
block|{
name|un
operator|->
name|id
operator|=
name|id
expr_stmt|;
name|sc
operator|->
name|node_list
index|[
name|id
index|]
operator|=
name|ni
expr_stmt|;
break|break;
block|}
block|}
name|RTWN_NT_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|>
name|sc
operator|->
name|macid_limit
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: node table is full\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return;
block|}
ifndef|#
directive|ifndef
name|RTWN_WITHOUT_UCODE
comment|/* Notify firmware. */
name|id
operator||=
name|RTWN_MACID_VALID
expr_stmt|;
name|rtwn_cmd_sleepable
argument_list|(
name|sc
argument_list|,
operator|&
name|id
argument_list|,
sizeof|sizeof
argument_list|(
name|id
argument_list|)
argument_list|,
name|rtwn_set_media_status
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|rtwn_node_free
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|struct
name|rtwn_softc
modifier|*
name|sc
init|=
name|ni
operator|->
name|ni_ic
operator|->
name|ic_softc
decl_stmt|;
name|struct
name|rtwn_node
modifier|*
name|un
init|=
name|RTWN_NODE
argument_list|(
name|ni
argument_list|)
decl_stmt|;
name|RTWN_NT_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|un
operator|->
name|id
operator|!=
name|RTWN_MACID_UNDEFINED
condition|)
block|{
name|sc
operator|->
name|node_list
index|[
name|un
operator|->
name|id
index|]
operator|=
name|NULL
expr_stmt|;
ifndef|#
directive|ifndef
name|RTWN_WITHOUT_UCODE
name|rtwn_cmd_sleepable
argument_list|(
name|sc
argument_list|,
operator|&
name|un
operator|->
name|id
argument_list|,
sizeof|sizeof
argument_list|(
name|un
operator|->
name|id
argument_list|)
argument_list|,
name|rtwn_set_media_status
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|RTWN_NT_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_node_free
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|rtwn_init_beacon_reg
parameter_list|(
name|struct
name|rtwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|rtwn_write_1
argument_list|(
name|sc
argument_list|,
name|R92C_BCN_CTRL
argument_list|(
literal|0
argument_list|)
argument_list|,
name|R92C_BCN_CTRL_DIS_TSF_UDT0
argument_list|)
expr_stmt|;
name|rtwn_write_1
argument_list|(
name|sc
argument_list|,
name|R92C_BCN_CTRL
argument_list|(
literal|1
argument_list|)
argument_list|,
name|R92C_BCN_CTRL_DIS_TSF_UDT0
argument_list|)
expr_stmt|;
name|rtwn_write_2
argument_list|(
name|sc
argument_list|,
name|R92C_TBTT_PROHIBIT
argument_list|,
literal|0x6404
argument_list|)
expr_stmt|;
name|rtwn_write_1
argument_list|(
name|sc
argument_list|,
name|R92C_DRVERLYINT
argument_list|,
literal|0x05
argument_list|)
expr_stmt|;
name|rtwn_write_1
argument_list|(
name|sc
argument_list|,
name|R92C_BCNDMATIM
argument_list|,
literal|0x02
argument_list|)
expr_stmt|;
name|rtwn_write_2
argument_list|(
name|sc
argument_list|,
name|R92C_BCNTCFG
argument_list|,
literal|0x660f
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|rtwn_init
parameter_list|(
name|struct
name|rtwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|;
name|RTWN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|RTWN_RUNNING
condition|)
block|{
name|RTWN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|sc
operator|->
name|sc_flags
operator||=
name|RTWN_STARTED
expr_stmt|;
comment|/* Power on adapter. */
name|error
operator|=
name|rtwn_power_on
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
ifndef|#
directive|ifndef
name|RTWN_WITHOUT_UCODE
comment|/* Load 8051 microcode. */
name|error
operator|=
name|rtwn_load_firmware
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|sc
operator|->
name|sc_flags
operator||=
name|RTWN_FW_LOADED
expr_stmt|;
comment|/* Init firmware commands ring. */
name|sc
operator|->
name|fwcur
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* Initialize MAC block. */
name|error
operator|=
name|rtwn_mac_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: error while initializing MAC block\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Initialize DMA. */
name|error
operator|=
name|rtwn_dma_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
comment|/* Drop incorrect TX (USB). */
name|rtwn_drop_incorrect_tx
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Set info size in Rx descriptors (in 64-bit words). */
name|rtwn_write_1
argument_list|(
name|sc
argument_list|,
name|R92C_RX_DRVINFO_SZ
argument_list|,
name|R92C_RX_DRVINFO_SZ_DEF
argument_list|)
expr_stmt|;
comment|/* Init interrupts. */
name|rtwn_init_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nitems
argument_list|(
name|sc
operator|->
name|vaps
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|rtwn_vap
modifier|*
name|uvp
init|=
name|sc
operator|->
name|vaps
index|[
name|i
index|]
decl_stmt|;
comment|/* Set initial network type. */
name|rtwn_set_mode
argument_list|(
name|sc
argument_list|,
name|R92C_MSR_NOLINK
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|uvp
operator|==
name|NULL
condition|)
continue|continue;
comment|/* Set MAC address. */
name|error
operator|=
name|rtwn_set_macaddr
argument_list|(
name|sc
argument_list|,
name|uvp
operator|->
name|vap
operator|.
name|iv_myaddr
argument_list|,
name|uvp
operator|->
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
block|}
comment|/* Initialize Rx filter. */
name|rtwn_rxfilter_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Set short/long retry limits. */
name|rtwn_write_2
argument_list|(
name|sc
argument_list|,
name|R92C_RL
argument_list|,
name|SM
argument_list|(
name|R92C_RL_SRL
argument_list|,
literal|0x30
argument_list|)
operator||
name|SM
argument_list|(
name|R92C_RL_LRL
argument_list|,
literal|0x30
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Initialize EDCA parameters. */
name|rtwn_init_edca
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|rtwn_setbits_1
argument_list|(
name|sc
argument_list|,
name|R92C_FWHW_TXQ_CTRL
argument_list|,
literal|0
argument_list|,
name|R92C_FWHW_TXQ_CTRL_AMPDU_RTY_NEW
argument_list|)
expr_stmt|;
comment|/* Set ACK timeout. */
name|rtwn_write_1
argument_list|(
name|sc
argument_list|,
name|R92C_ACKTO
argument_list|,
name|sc
operator|->
name|ackto
argument_list|)
expr_stmt|;
comment|/* Setup aggregation. */
comment|/* Tx aggregation. */
name|rtwn_init_tx_agg
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|rtwn_init_rx_agg
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Initialize beacon parameters. */
name|rtwn_init_beacon_reg
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Init A-MPDU parameters. */
name|rtwn_init_ampdu
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Init MACTXEN / MACRXEN after setting RxFF boundary. */
name|rtwn_setbits_1
argument_list|(
name|sc
argument_list|,
name|R92C_CR
argument_list|,
literal|0
argument_list|,
name|R92C_CR_MACTXEN
operator||
name|R92C_CR_MACRXEN
argument_list|)
expr_stmt|;
comment|/* Initialize BB/RF blocks. */
name|rtwn_init_bb
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|rtwn_init_rf
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Initialize wireless band. */
name|rtwn_set_chan
argument_list|(
name|sc
argument_list|,
name|ic
operator|->
name|ic_curchan
argument_list|)
expr_stmt|;
comment|/* Clear per-station keys table. */
name|rtwn_init_cam
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Enable decryption / encryption. */
name|rtwn_init_seccfg
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Install static keys (if any). */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nitems
argument_list|(
name|sc
operator|->
name|vaps
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|vaps
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|rtwn_init_static_keys
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|vaps
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
block|}
block|}
comment|/* Initialize antenna selection. */
name|rtwn_init_antsel
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Enable hardware sequence numbering. */
name|rtwn_write_1
argument_list|(
name|sc
argument_list|,
name|R92C_HWSEQ_CTRL
argument_list|,
name|R92C_TX_QUEUE_ALL
argument_list|)
expr_stmt|;
comment|/* Disable BAR. */
name|rtwn_write_4
argument_list|(
name|sc
argument_list|,
name|R92C_BAR_MODE_CTRL
argument_list|,
literal|0x0201ffff
argument_list|)
expr_stmt|;
comment|/* NAV limit. */
name|rtwn_write_1
argument_list|(
name|sc
argument_list|,
name|R92C_NAV_UPPER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Initialize GPIO setting. */
name|rtwn_setbits_1
argument_list|(
name|sc
argument_list|,
name|R92C_GPIO_MUXCFG
argument_list|,
name|R92C_GPIO_MUXCFG_ENBT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Initialize MRR. */
name|rtwn_mrr_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Device-specific post initialization. */
name|rtwn_post_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|rtwn_start_xfers
argument_list|(
name|sc
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|D4054
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sc_watchdog_to
argument_list|,
name|hz
argument_list|,
name|rtwn_watchdog
argument_list|,
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sc
operator|->
name|sc_flags
operator||=
name|RTWN_RUNNING
expr_stmt|;
name|fail
label|:
name|RTWN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|rtwn_stop
parameter_list|(
name|struct
name|rtwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|RTWN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|RTWN_STARTED
operator|)
condition|)
block|{
name|RTWN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
ifndef|#
directive|ifndef
name|D4054
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|sc_watchdog_to
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_tx_timer
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
operator|(
name|RTWN_STARTED
operator||
name|RTWN_RUNNING
operator||
name|RTWN_FW_LOADED
operator|)
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|RTWN_TEMP_MEASURED
expr_stmt|;
name|sc
operator|->
name|fwver
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|thcal_temp
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|cur_bcnq_id
operator|=
name|RTWN_VAP_ID_INVALID
expr_stmt|;
ifdef|#
directive|ifdef
name|D4054
name|ieee80211_tx_watchdog_stop
argument_list|(
operator|&
name|sc
operator|->
name|sc_ic
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|rtwn_abort_xfers
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|rtwn_drain_mbufq
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|rtwn_power_off
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|rtwn_reset_lists
argument_list|(
name|sc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|RTWN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|rtwn
argument_list|,
literal|2
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|rtwn
argument_list|,
name|wlan
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|RTWN_WITHOUT_UCODE
end_ifndef

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|rtwn
argument_list|,
name|firmware
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

end_unit

