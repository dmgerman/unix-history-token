begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************************  Copyright (c) 2006, Myricom Inc. All rights reserved.  Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:   1. Redistributions of source code must retain the above copyright notice,     this list of conditions and the following disclaimer.   2. Redistributions in binary form must reproduce the above copyright     notice, this list of conditions and the following disclaimer in the     documentation and/or other materials provided with the distribution.   3. Neither the name of the Myricom Inc, nor the names of its     contributors may be used to endorse or promote products derived from     this software without specific prior written permission.  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  ***************************************************************************/
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/linker.h>
end_include

begin_include
include|#
directive|include
file|<sys/firmware.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kdb.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/memrange.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/if_vlan_var.h>
end_include

begin_include
include|#
directive|include
file|<net/zlib.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_comment
comment|/* for pmap_mapdev() */
end_comment

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<dev/mxge/mxge_mcp.h>
end_include

begin_include
include|#
directive|include
file|<dev/mxge/mcp_gen_header.h>
end_include

begin_include
include|#
directive|include
file|<dev/mxge/if_mxge_var.h>
end_include

begin_comment
comment|/* tunable params */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mxge_nvidia_ecrc_enable
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mxge_force_firmware
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mxge_max_intr_slots
init|=
literal|1024
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mxge_intr_coal_delay
init|=
literal|30
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mxge_deassert_wait
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mxge_flow_control
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mxge_verbose
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|mxge_fw_unaligned
init|=
literal|"mxge_ethp_z8e"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|mxge_fw_aligned
init|=
literal|"mxge_eth_z8e"
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|mxge_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mxge_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mxge_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mxge_shutdown
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mxge_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|device_method_t
name|mxge_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|mxge_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|mxge_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|mxge_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|mxge_shutdown
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|mxge_driver
init|=
block|{
literal|"mxge"
block|,
name|mxge_methods
block|,
sizeof|sizeof
argument_list|(
name|mxge_softc_t
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|mxge_devclass
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Declare ourselves to be a child of the PCI bus.*/
end_comment

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|mxge
argument_list|,
name|pci
argument_list|,
name|mxge_driver
argument_list|,
name|mxge_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|mxge
argument_list|,
name|firmware
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|mxge_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
if|if
condition|(
operator|(
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
operator|==
name|MXGE_PCI_VENDOR_MYRICOM
operator|)
operator|&&
operator|(
name|pci_get_device
argument_list|(
name|dev
argument_list|)
operator|==
name|MXGE_PCI_DEVICE_Z8E
operator|)
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Myri10G-PCIE-8A"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|ENXIO
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mxge_enable_wc
parameter_list|(
name|mxge_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|mem_range_desc
name|mrdesc
decl_stmt|;
name|vm_paddr_t
name|pa
decl_stmt|;
name|vm_offset_t
name|len
decl_stmt|;
name|int
name|err
decl_stmt|,
name|action
decl_stmt|;
name|pa
operator|=
name|rman_get_start
argument_list|(
name|sc
operator|->
name|mem_res
argument_list|)
expr_stmt|;
name|len
operator|=
name|rman_get_size
argument_list|(
name|sc
operator|->
name|mem_res
argument_list|)
expr_stmt|;
name|mrdesc
operator|.
name|mr_base
operator|=
name|pa
expr_stmt|;
name|mrdesc
operator|.
name|mr_len
operator|=
name|len
expr_stmt|;
name|mrdesc
operator|.
name|mr_flags
operator|=
name|MDF_WRITECOMBINE
expr_stmt|;
name|action
operator|=
name|MEMRANGE_SET_UPDATE
expr_stmt|;
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|mrdesc
operator|.
name|mr_owner
argument_list|,
literal|"mxge"
argument_list|)
expr_stmt|;
name|err
operator|=
name|mem_range_attr_set
argument_list|(
operator|&
name|mrdesc
argument_list|,
operator|&
name|action
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"w/c failed for pa 0x%lx, len 0x%lx, err = %d\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|pa
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|len
argument_list|,
name|err
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|wc
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* callback to get our DMA address */
end_comment

begin_function
specifier|static
name|void
name|mxge_dmamap_callback
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nsegs
parameter_list|,
name|int
name|error
parameter_list|)
block|{
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
operator|*
operator|(
name|bus_addr_t
operator|*
operator|)
name|arg
operator|=
name|segs
operator|->
name|ds_addr
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|mxge_dma_alloc
parameter_list|(
name|mxge_softc_t
modifier|*
name|sc
parameter_list|,
name|mxge_dma_t
modifier|*
name|dma
parameter_list|,
name|size_t
name|bytes
parameter_list|,
name|bus_size_t
name|alignment
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|device_t
name|dev
init|=
name|sc
operator|->
name|dev
decl_stmt|;
comment|/* allocate DMAable memory tags */
name|err
operator|=
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|parent_dmat
argument_list|,
comment|/* parent */
name|alignment
argument_list|,
comment|/* alignment */
literal|4096
argument_list|,
comment|/* boundary */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* low */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* high */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter */
name|bytes
argument_list|,
comment|/* maxsize */
literal|1
argument_list|,
comment|/* num segs */
literal|4096
argument_list|,
comment|/* maxsegsize */
name|BUS_DMA_COHERENT
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* lock */
operator|&
name|dma
operator|->
name|dmat
argument_list|)
expr_stmt|;
comment|/* tag */
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"couldn't alloc tag (err = %d)\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
comment|/* allocate DMAable memory& map */
name|err
operator|=
name|bus_dmamem_alloc
argument_list|(
name|dma
operator|->
name|dmat
argument_list|,
operator|&
name|dma
operator|->
name|addr
argument_list|,
operator|(
name|BUS_DMA_WAITOK
operator||
name|BUS_DMA_COHERENT
operator||
name|BUS_DMA_ZERO
operator|)
argument_list|,
operator|&
name|dma
operator|->
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"couldn't alloc mem (err = %d)\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
goto|goto
name|abort_with_dmat
goto|;
block|}
comment|/* load the memory */
name|err
operator|=
name|bus_dmamap_load
argument_list|(
name|dma
operator|->
name|dmat
argument_list|,
name|dma
operator|->
name|map
argument_list|,
name|dma
operator|->
name|addr
argument_list|,
name|bytes
argument_list|,
name|mxge_dmamap_callback
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|dma
operator|->
name|bus_addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"couldn't load map (err = %d)\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
goto|goto
name|abort_with_mem
goto|;
block|}
return|return
literal|0
return|;
name|abort_with_mem
label|:
name|bus_dmamem_free
argument_list|(
name|dma
operator|->
name|dmat
argument_list|,
name|dma
operator|->
name|addr
argument_list|,
name|dma
operator|->
name|map
argument_list|)
expr_stmt|;
name|abort_with_dmat
label|:
operator|(
name|void
operator|)
name|bus_dma_tag_destroy
argument_list|(
name|dma
operator|->
name|dmat
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mxge_dma_free
parameter_list|(
name|mxge_dma_t
modifier|*
name|dma
parameter_list|)
block|{
name|bus_dmamap_unload
argument_list|(
name|dma
operator|->
name|dmat
argument_list|,
name|dma
operator|->
name|map
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|dma
operator|->
name|dmat
argument_list|,
name|dma
operator|->
name|addr
argument_list|,
name|dma
operator|->
name|map
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|bus_dma_tag_destroy
argument_list|(
name|dma
operator|->
name|dmat
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * The eeprom strings on the lanaiX have the format  * SN=x\0  * MAC=x:x:x:x:x:x\0  * PC=text\0  */
end_comment

begin_function
specifier|static
name|int
name|mxge_parse_strings
parameter_list|(
name|mxge_softc_t
modifier|*
name|sc
parameter_list|)
block|{
define|#
directive|define
name|MXGE_NEXT_STRING
parameter_list|(
name|p
parameter_list|)
value|while(ptr< limit&& *ptr++)
name|char
modifier|*
name|ptr
decl_stmt|,
modifier|*
name|limit
decl_stmt|;
name|int
name|i
decl_stmt|,
name|found_mac
decl_stmt|;
name|ptr
operator|=
name|sc
operator|->
name|eeprom_strings
expr_stmt|;
name|limit
operator|=
name|sc
operator|->
name|eeprom_strings
operator|+
name|MXGE_EEPROM_STRINGS_SIZE
expr_stmt|;
name|found_mac
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|ptr
operator|<
name|limit
operator|&&
operator|*
name|ptr
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|memcmp
argument_list|(
name|ptr
argument_list|,
literal|"MAC="
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ptr
operator|+=
literal|1
expr_stmt|;
name|sc
operator|->
name|mac_addr_string
operator|=
name|ptr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
block|{
name|ptr
operator|+=
literal|3
expr_stmt|;
if|if
condition|(
operator|(
name|ptr
operator|+
literal|2
operator|)
operator|>
name|limit
condition|)
goto|goto
name|abort
goto|;
name|sc
operator|->
name|mac_addr
index|[
name|i
index|]
operator|=
name|strtoul
argument_list|(
name|ptr
argument_list|,
name|NULL
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|found_mac
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|memcmp
argument_list|(
name|ptr
argument_list|,
literal|"PC="
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ptr
operator|+=
literal|3
expr_stmt|;
name|strncpy
argument_list|(
name|sc
operator|->
name|product_code_string
argument_list|,
name|ptr
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|product_code_string
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|memcmp
argument_list|(
name|ptr
argument_list|,
literal|"SN="
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ptr
operator|+=
literal|3
expr_stmt|;
name|strncpy
argument_list|(
name|sc
operator|->
name|serial_number_string
argument_list|,
name|ptr
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|serial_number_string
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|MXGE_NEXT_STRING
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|found_mac
condition|)
return|return
literal|0
return|;
name|abort
label|:
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to parse eeprom_strings\n"
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
end_function

begin_if
if|#
directive|if
operator|#
name|cpu
argument_list|(
name|i386
argument_list|)
operator|||
name|defined
name|__i386
operator|||
name|defined
name|i386
operator|||
name|defined
name|__i386__
operator|||
operator|#
name|cpu
argument_list|(
name|x86_64
argument_list|)
operator|||
name|defined
name|__x86_64__
end_if

begin_function
specifier|static
name|int
name|mxge_enable_nvidia_ecrc
parameter_list|(
name|mxge_softc_t
modifier|*
name|sc
parameter_list|,
name|device_t
name|pdev
parameter_list|)
block|{
name|uint32_t
name|val
decl_stmt|;
name|unsigned
name|long
name|off
decl_stmt|;
name|char
modifier|*
name|va
decl_stmt|,
modifier|*
name|cfgptr
decl_stmt|;
name|uint16_t
name|vendor_id
decl_stmt|,
name|device_id
decl_stmt|;
name|uintptr_t
name|bus
decl_stmt|,
name|slot
decl_stmt|,
name|func
decl_stmt|,
name|ivend
decl_stmt|,
name|idev
decl_stmt|;
name|uint32_t
modifier|*
name|ptr32
decl_stmt|;
comment|/* XXXX 	   Test below is commented because it is believed that doing 	   config read/write beyond 0xff will access the config space 	   for the next larger function.  Uncomment this and remove  	   the hacky pmap_mapdev() way of accessing config space when 	   FreeBSD grows support for extended pcie config space access 	*/
if|#
directive|if
literal|0
comment|/* See if we can, by some miracle, access the extended 	   config space */
block|val = pci_read_config(pdev, 0x178, 4); 	if (val != 0xffffffff) { 		val |= 0x40; 		pci_write_config(pdev, 0x178, val, 4); 		return 0; 	}
endif|#
directive|endif
comment|/* Rather than using normal pci config space writes, we must 	 * map the Nvidia config space ourselves.  This is because on 	 * opteron/nvidia class machine the 0xe000000 mapping is 	 * handled by the nvidia chipset, that means the internal PCI 	 * device (the on-chip northbridge), or the amd-8131 bridge 	 * and things behind them are not visible by this method. 	 */
name|BUS_READ_IVAR
argument_list|(
name|device_get_parent
argument_list|(
name|pdev
argument_list|)
argument_list|,
name|pdev
argument_list|,
name|PCI_IVAR_BUS
argument_list|,
operator|&
name|bus
argument_list|)
expr_stmt|;
name|BUS_READ_IVAR
argument_list|(
name|device_get_parent
argument_list|(
name|pdev
argument_list|)
argument_list|,
name|pdev
argument_list|,
name|PCI_IVAR_SLOT
argument_list|,
operator|&
name|slot
argument_list|)
expr_stmt|;
name|BUS_READ_IVAR
argument_list|(
name|device_get_parent
argument_list|(
name|pdev
argument_list|)
argument_list|,
name|pdev
argument_list|,
name|PCI_IVAR_FUNCTION
argument_list|,
operator|&
name|func
argument_list|)
expr_stmt|;
name|BUS_READ_IVAR
argument_list|(
name|device_get_parent
argument_list|(
name|pdev
argument_list|)
argument_list|,
name|pdev
argument_list|,
name|PCI_IVAR_VENDOR
argument_list|,
operator|&
name|ivend
argument_list|)
expr_stmt|;
name|BUS_READ_IVAR
argument_list|(
name|device_get_parent
argument_list|(
name|pdev
argument_list|)
argument_list|,
name|pdev
argument_list|,
name|PCI_IVAR_DEVICE
argument_list|,
operator|&
name|idev
argument_list|)
expr_stmt|;
name|off
operator|=
literal|0xe0000000UL
operator|+
literal|0x00100000UL
operator|*
operator|(
name|unsigned
name|long
operator|)
name|bus
operator|+
literal|0x00001000UL
operator|*
call|(
name|unsigned
name|long
call|)
argument_list|(
name|func
operator|+
literal|8
operator|*
name|slot
argument_list|)
expr_stmt|;
comment|/* map it into the kernel */
name|va
operator|=
name|pmap_mapdev
argument_list|(
name|trunc_page
argument_list|(
operator|(
name|vm_paddr_t
operator|)
name|off
argument_list|)
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|va
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"pmap_kenter_temporary didn't\n"
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
block|}
comment|/* get a pointer to the config space mapped into the kernel */
name|cfgptr
operator|=
name|va
operator|+
operator|(
name|off
operator|&
name|PAGE_MASK
operator|)
expr_stmt|;
comment|/* make sure that we can really access it */
name|vendor_id
operator|=
operator|*
operator|(
name|uint16_t
operator|*
operator|)
operator|(
name|cfgptr
operator|+
name|PCIR_VENDOR
operator|)
expr_stmt|;
name|device_id
operator|=
operator|*
operator|(
name|uint16_t
operator|*
operator|)
operator|(
name|cfgptr
operator|+
name|PCIR_DEVICE
operator|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|vendor_id
operator|==
name|ivend
operator|&&
name|device_id
operator|==
name|idev
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"mapping failed: 0x%x:0x%x\n"
argument_list|,
name|vendor_id
argument_list|,
name|device_id
argument_list|)
expr_stmt|;
name|pmap_unmapdev
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|va
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
block|}
name|ptr32
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|cfgptr
operator|+
literal|0x178
operator|)
expr_stmt|;
name|val
operator|=
operator|*
name|ptr32
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|0xffffffff
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"extended mapping failed\n"
argument_list|)
expr_stmt|;
name|pmap_unmapdev
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|va
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
block|}
operator|*
name|ptr32
operator|=
name|val
operator||
literal|0x40
expr_stmt|;
name|pmap_unmapdev
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|va
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|mxge_verbose
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Enabled ECRC on upstream Nvidia bridge "
literal|"at %d:%d:%d\n"
argument_list|,
operator|(
name|int
operator|)
name|bus
argument_list|,
operator|(
name|int
operator|)
name|slot
argument_list|,
operator|(
name|int
operator|)
name|func
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
specifier|static
name|int
name|mxge_enable_nvidia_ecrc
parameter_list|(
name|mxge_softc_t
modifier|*
name|sc
parameter_list|,
name|device_t
name|pdev
parameter_list|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Nforce 4 chipset on non-x86/amd64!?!?!\n"
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * The Lanai Z8E PCI-E interface achieves higher Read-DMA throughput  * when the PCI-E Completion packets are aligned on an 8-byte  * boundary.  Some PCI-E chip sets always align Completion packets; on  * the ones that do not, the alignment can be enforced by enabling  * ECRC generation (if supported).  *  * When PCI-E Completion packets are not aligned, it is actually more  * efficient to limit Read-DMA transactions to 2KB, rather than 4KB.  *  * If the driver can neither enable ECRC nor verify that it has  * already been enabled, then it must use a firmware image which works  * around unaligned completion packets (ethp_z8e.dat), and it should  * also ensure that it never gives the device a Read-DMA which is  * larger than 2KB by setting the tx.boundary to 2KB.  If ECRC is  * enabled, then the driver should use the aligned (eth_z8e.dat)  * firmware image, and set tx.boundary to 4KB.  */
end_comment

begin_function
specifier|static
name|void
name|mxge_select_firmware
parameter_list|(
name|mxge_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|err
decl_stmt|,
name|aligned
init|=
literal|0
decl_stmt|;
name|device_t
name|pdev
decl_stmt|;
name|uint16_t
name|pvend
decl_stmt|,
name|pdid
decl_stmt|;
if|if
condition|(
name|mxge_force_firmware
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|mxge_force_firmware
operator|==
literal|1
condition|)
name|aligned
operator|=
literal|1
expr_stmt|;
else|else
name|aligned
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mxge_verbose
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Assuming %s completions (forced)\n"
argument_list|,
name|aligned
condition|?
literal|"aligned"
else|:
literal|"unaligned"
argument_list|)
expr_stmt|;
goto|goto
name|abort
goto|;
block|}
comment|/* if the PCIe link width is 4 or less, we can use the aligned 	   firmware and skip any checks */
if|if
condition|(
name|sc
operator|->
name|link_width
operator|!=
literal|0
operator|&&
name|sc
operator|->
name|link_width
operator|<=
literal|4
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"PCIe x%d Link, expect reduced performance\n"
argument_list|,
name|sc
operator|->
name|link_width
argument_list|)
expr_stmt|;
name|aligned
operator|=
literal|1
expr_stmt|;
goto|goto
name|abort
goto|;
block|}
name|pdev
operator|=
name|device_get_parent
argument_list|(
name|device_get_parent
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pdev
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"could not find parent?\n"
argument_list|)
expr_stmt|;
goto|goto
name|abort
goto|;
block|}
name|pvend
operator|=
name|pci_read_config
argument_list|(
name|pdev
argument_list|,
name|PCIR_VENDOR
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|pdid
operator|=
name|pci_read_config
argument_list|(
name|pdev
argument_list|,
name|PCIR_DEVICE
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* see if we can enable ECRC's on an upstream 	   Nvidia bridge */
if|if
condition|(
name|mxge_nvidia_ecrc_enable
operator|&&
operator|(
name|pvend
operator|==
literal|0x10de
operator|&&
name|pdid
operator|==
literal|0x005d
operator|)
condition|)
block|{
name|err
operator|=
name|mxge_enable_nvidia_ecrc
argument_list|(
name|sc
argument_list|,
name|pdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
name|aligned
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|mxge_verbose
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Assuming aligned completions"
literal|" (ECRC)\n"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* see if the upstream bridge is known to 	   provided aligned completions */
if|if
condition|(
comment|/* HT2000 */
operator|(
name|pvend
operator|==
literal|0x1166
operator|&&
name|pdid
operator|==
literal|0x0132
operator|)
operator|||
comment|/* PLX */
operator|(
name|pvend
operator|==
literal|0x10b5
operator|&&
name|pdid
operator|==
literal|0x8532
operator|)
operator|||
comment|/* Intel */
operator|(
name|pvend
operator|==
literal|0x8086
operator|&&
comment|/* E5000 NorthBridge*/
operator|(
operator|(
name|pdid
operator|>=
literal|0x25f7
operator|&&
name|pdid
operator|<=
literal|0x25fa
operator|)
operator|||
comment|/* E5000 SouthBridge*/
operator|(
name|pdid
operator|>=
literal|0x3510
operator|&&
name|pdid
operator|<=
literal|0x351b
operator|)
operator|)
operator|)
condition|)
block|{
name|aligned
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|mxge_verbose
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Assuming aligned completions "
literal|"(0x%x:0x%x)\n"
argument_list|,
name|pvend
argument_list|,
name|pdid
argument_list|)
expr_stmt|;
block|}
name|abort
label|:
if|if
condition|(
name|aligned
condition|)
block|{
name|sc
operator|->
name|fw_name
operator|=
name|mxge_fw_aligned
expr_stmt|;
name|sc
operator|->
name|tx
operator|.
name|boundary
operator|=
literal|4096
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|fw_name
operator|=
name|mxge_fw_unaligned
expr_stmt|;
name|sc
operator|->
name|tx
operator|.
name|boundary
operator|=
literal|2048
expr_stmt|;
block|}
block|}
end_function

begin_union
union|union
name|qualhack
block|{
specifier|const
name|char
modifier|*
name|ro_char
decl_stmt|;
name|char
modifier|*
name|rw_char
decl_stmt|;
block|}
union|;
end_union

begin_function
specifier|static
name|int
name|mxge_validate_firmware
parameter_list|(
name|mxge_softc_t
modifier|*
name|sc
parameter_list|,
specifier|const
name|mcp_gen_header_t
modifier|*
name|hdr
parameter_list|)
block|{
name|int
name|major
decl_stmt|,
name|minor
decl_stmt|;
if|if
condition|(
name|be32toh
argument_list|(
name|hdr
operator|->
name|mcp_type
argument_list|)
operator|!=
name|MCP_TYPE_ETH
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Bad firmware type: 0x%x\n"
argument_list|,
name|be32toh
argument_list|(
name|hdr
operator|->
name|mcp_type
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
block|}
comment|/* save firmware version for sysctl */
name|strncpy
argument_list|(
name|sc
operator|->
name|fw_version
argument_list|,
name|hdr
operator|->
name|version
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|fw_version
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mxge_verbose
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"firmware id: %s\n"
argument_list|,
name|hdr
operator|->
name|version
argument_list|)
expr_stmt|;
name|sscanf
argument_list|(
name|sc
operator|->
name|fw_version
argument_list|,
literal|"%d.%d"
argument_list|,
operator|&
name|major
argument_list|,
operator|&
name|minor
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|major
operator|==
name|MXGEFW_VERSION_MAJOR
operator|&&
name|minor
operator|==
name|MXGEFW_VERSION_MINOR
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Found firmware version %s\n"
argument_list|,
name|sc
operator|->
name|fw_version
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Driver needs %d.%d\n"
argument_list|,
name|MXGEFW_VERSION_MAJOR
argument_list|,
name|MXGEFW_VERSION_MINOR
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mxge_load_firmware_helper
parameter_list|(
name|mxge_softc_t
modifier|*
name|sc
parameter_list|,
name|uint32_t
modifier|*
name|limit
parameter_list|)
block|{
name|struct
name|firmware
modifier|*
name|fw
decl_stmt|;
specifier|const
name|mcp_gen_header_t
modifier|*
name|hdr
decl_stmt|;
name|unsigned
name|hdr_offset
decl_stmt|;
specifier|const
name|char
modifier|*
name|fw_data
decl_stmt|;
name|union
name|qualhack
name|hack
decl_stmt|;
name|int
name|status
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|char
name|dummy
decl_stmt|;
name|fw
operator|=
name|firmware_get
argument_list|(
name|sc
operator|->
name|fw_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|fw
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Could not find firmware image %s\n"
argument_list|,
name|sc
operator|->
name|fw_name
argument_list|)
expr_stmt|;
return|return
name|ENOENT
return|;
block|}
if|if
condition|(
name|fw
operator|->
name|datasize
operator|>
operator|*
name|limit
operator|||
name|fw
operator|->
name|datasize
operator|<
name|MCP_HEADER_PTR_OFFSET
operator|+
literal|4
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Firmware image %s too large (%d/%d)\n"
argument_list|,
name|sc
operator|->
name|fw_name
argument_list|,
operator|(
name|int
operator|)
name|fw
operator|->
name|datasize
argument_list|,
operator|(
name|int
operator|)
operator|*
name|limit
argument_list|)
expr_stmt|;
name|status
operator|=
name|ENOSPC
expr_stmt|;
goto|goto
name|abort_with_fw
goto|;
block|}
operator|*
name|limit
operator|=
name|fw
operator|->
name|datasize
expr_stmt|;
comment|/* check id */
name|fw_data
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|fw
operator|->
name|data
expr_stmt|;
name|hdr_offset
operator|=
name|htobe32
argument_list|(
operator|*
operator|(
specifier|const
name|uint32_t
operator|*
operator|)
operator|(
name|fw_data
operator|+
name|MCP_HEADER_PTR_OFFSET
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|hdr_offset
operator|&
literal|3
operator|)
operator|||
name|hdr_offset
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
operator|>
name|fw
operator|->
name|datasize
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Bad firmware file"
argument_list|)
expr_stmt|;
name|status
operator|=
name|EIO
expr_stmt|;
goto|goto
name|abort_with_fw
goto|;
block|}
name|hdr
operator|=
operator|(
specifier|const
name|void
operator|*
operator|)
operator|(
name|fw_data
operator|+
name|hdr_offset
operator|)
expr_stmt|;
name|status
operator|=
name|mxge_validate_firmware
argument_list|(
name|sc
argument_list|,
name|hdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
goto|goto
name|abort_with_fw
goto|;
name|hack
operator|.
name|ro_char
operator|=
name|fw_data
expr_stmt|;
comment|/* Copy the inflated firmware to NIC SRAM. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|*
name|limit
condition|;
name|i
operator|+=
literal|256
control|)
block|{
name|mxge_pio_copy
argument_list|(
name|sc
operator|->
name|sram
operator|+
name|MXGE_FW_OFFSET
operator|+
name|i
argument_list|,
name|hack
operator|.
name|rw_char
operator|+
name|i
argument_list|,
name|min
argument_list|(
literal|256U
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
operator|*
name|limit
operator|-
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|mb
argument_list|()
expr_stmt|;
name|dummy
operator|=
operator|*
name|sc
operator|->
name|sram
expr_stmt|;
name|mb
argument_list|()
expr_stmt|;
block|}
name|status
operator|=
literal|0
expr_stmt|;
name|abort_with_fw
label|:
name|firmware_put
argument_list|(
name|fw
argument_list|,
name|FIRMWARE_UNLOAD
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/*  * Enable or disable periodic RDMAs from the host to make certain  * chipsets resend dropped PCIe messages  */
end_comment

begin_function
specifier|static
name|void
name|mxge_dummy_rdma
parameter_list|(
name|mxge_softc_t
modifier|*
name|sc
parameter_list|,
name|int
name|enable
parameter_list|)
block|{
name|char
name|buf_bytes
index|[
literal|72
index|]
decl_stmt|;
specifier|volatile
name|uint32_t
modifier|*
name|confirm
decl_stmt|;
specifier|volatile
name|char
modifier|*
name|submit
decl_stmt|;
name|uint32_t
modifier|*
name|buf
decl_stmt|,
name|dma_low
decl_stmt|,
name|dma_high
decl_stmt|;
name|int
name|i
decl_stmt|;
name|buf
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
call|(
name|unsigned
name|long
call|)
argument_list|(
name|buf_bytes
operator|+
literal|7
argument_list|)
operator|&
operator|~
literal|7UL
operator|)
expr_stmt|;
comment|/* clear confirmation addr */
name|confirm
operator|=
operator|(
specifier|volatile
name|uint32_t
operator|*
operator|)
name|sc
operator|->
name|cmd
expr_stmt|;
operator|*
name|confirm
operator|=
literal|0
expr_stmt|;
name|mb
argument_list|()
expr_stmt|;
comment|/* send an rdma command to the PCIe engine, and wait for the 	   response in the confirmation address.  The firmware should 	   write a -1 there to indicate it is alive and well 	*/
name|dma_low
operator|=
name|MXGE_LOWPART_TO_U32
argument_list|(
name|sc
operator|->
name|cmd_dma
operator|.
name|bus_addr
argument_list|)
expr_stmt|;
name|dma_high
operator|=
name|MXGE_HIGHPART_TO_U32
argument_list|(
name|sc
operator|->
name|cmd_dma
operator|.
name|bus_addr
argument_list|)
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
name|htobe32
argument_list|(
name|dma_high
argument_list|)
expr_stmt|;
comment|/* confirm addr MSW */
name|buf
index|[
literal|1
index|]
operator|=
name|htobe32
argument_list|(
name|dma_low
argument_list|)
expr_stmt|;
comment|/* confirm addr LSW */
name|buf
index|[
literal|2
index|]
operator|=
name|htobe32
argument_list|(
literal|0xffffffff
argument_list|)
expr_stmt|;
comment|/* confirm data */
name|dma_low
operator|=
name|MXGE_LOWPART_TO_U32
argument_list|(
name|sc
operator|->
name|zeropad_dma
operator|.
name|bus_addr
argument_list|)
expr_stmt|;
name|dma_high
operator|=
name|MXGE_HIGHPART_TO_U32
argument_list|(
name|sc
operator|->
name|zeropad_dma
operator|.
name|bus_addr
argument_list|)
expr_stmt|;
name|buf
index|[
literal|3
index|]
operator|=
name|htobe32
argument_list|(
name|dma_high
argument_list|)
expr_stmt|;
comment|/* dummy addr MSW */
name|buf
index|[
literal|4
index|]
operator|=
name|htobe32
argument_list|(
name|dma_low
argument_list|)
expr_stmt|;
comment|/* dummy addr LSW */
name|buf
index|[
literal|5
index|]
operator|=
name|htobe32
argument_list|(
name|enable
argument_list|)
expr_stmt|;
comment|/* enable? */
name|submit
operator|=
operator|(
specifier|volatile
name|char
operator|*
operator|)
operator|(
name|sc
operator|->
name|sram
operator|+
name|MXGEFW_BOOT_DUMMY_RDMA
operator|)
expr_stmt|;
name|mxge_pio_copy
argument_list|(
name|submit
argument_list|,
name|buf
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|mb
argument_list|()
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|mb
argument_list|()
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|confirm
operator|!=
literal|0xffffffff
operator|&&
name|i
operator|<
literal|20
condition|)
block|{
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|confirm
operator|!=
literal|0xffffffff
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"dummy rdma %s failed (%p = 0x%x)"
argument_list|,
operator|(
name|enable
condition|?
literal|"enable"
else|:
literal|"disable"
operator|)
argument_list|,
name|confirm
argument_list|,
operator|*
name|confirm
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|mxge_send_cmd
parameter_list|(
name|mxge_softc_t
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|cmd
parameter_list|,
name|mxge_cmd_t
modifier|*
name|data
parameter_list|)
block|{
name|mcp_cmd_t
modifier|*
name|buf
decl_stmt|;
name|char
name|buf_bytes
index|[
sizeof|sizeof
argument_list|(
operator|*
name|buf
argument_list|)
operator|+
literal|8
index|]
decl_stmt|;
specifier|volatile
name|mcp_cmd_response_t
modifier|*
name|response
init|=
name|sc
operator|->
name|cmd
decl_stmt|;
specifier|volatile
name|char
modifier|*
name|cmd_addr
init|=
name|sc
operator|->
name|sram
operator|+
name|MXGEFW_ETH_CMD
decl_stmt|;
name|uint32_t
name|dma_low
decl_stmt|,
name|dma_high
decl_stmt|;
name|int
name|sleep_total
init|=
literal|0
decl_stmt|;
comment|/* ensure buf is aligned to 8 bytes */
name|buf
operator|=
operator|(
name|mcp_cmd_t
operator|*
operator|)
operator|(
call|(
name|unsigned
name|long
call|)
argument_list|(
name|buf_bytes
operator|+
literal|7
argument_list|)
operator|&
operator|~
literal|7UL
operator|)
expr_stmt|;
name|buf
operator|->
name|data0
operator|=
name|htobe32
argument_list|(
name|data
operator|->
name|data0
argument_list|)
expr_stmt|;
name|buf
operator|->
name|data1
operator|=
name|htobe32
argument_list|(
name|data
operator|->
name|data1
argument_list|)
expr_stmt|;
name|buf
operator|->
name|data2
operator|=
name|htobe32
argument_list|(
name|data
operator|->
name|data2
argument_list|)
expr_stmt|;
name|buf
operator|->
name|cmd
operator|=
name|htobe32
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|dma_low
operator|=
name|MXGE_LOWPART_TO_U32
argument_list|(
name|sc
operator|->
name|cmd_dma
operator|.
name|bus_addr
argument_list|)
expr_stmt|;
name|dma_high
operator|=
name|MXGE_HIGHPART_TO_U32
argument_list|(
name|sc
operator|->
name|cmd_dma
operator|.
name|bus_addr
argument_list|)
expr_stmt|;
name|buf
operator|->
name|response_addr
operator|.
name|low
operator|=
name|htobe32
argument_list|(
name|dma_low
argument_list|)
expr_stmt|;
name|buf
operator|->
name|response_addr
operator|.
name|high
operator|=
name|htobe32
argument_list|(
name|dma_high
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|cmd_lock
argument_list|)
expr_stmt|;
name|response
operator|->
name|result
operator|=
literal|0xffffffff
expr_stmt|;
name|mb
argument_list|()
expr_stmt|;
name|mxge_pio_copy
argument_list|(
operator|(
specifier|volatile
name|void
operator|*
operator|)
name|cmd_addr
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|buf
argument_list|)
argument_list|)
expr_stmt|;
comment|/* wait up to 20ms */
for|for
control|(
name|sleep_total
operator|=
literal|0
init|;
name|sleep_total
operator|<
literal|20
condition|;
name|sleep_total
operator|++
control|)
block|{
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|cmd_dma
operator|.
name|dmat
argument_list|,
name|sc
operator|->
name|cmd_dma
operator|.
name|map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|mb
argument_list|()
expr_stmt|;
if|if
condition|(
name|response
operator|->
name|result
operator|!=
literal|0xffffffff
condition|)
block|{
if|if
condition|(
name|response
operator|->
name|result
operator|==
literal|0
condition|)
block|{
name|data
operator|->
name|data0
operator|=
name|be32toh
argument_list|(
name|response
operator|->
name|data
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|cmd_lock
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"mxge: command %d "
literal|"failed, result = %d\n"
argument_list|,
name|cmd
argument_list|,
name|be32toh
argument_list|(
name|response
operator|->
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|cmd_lock
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
block|}
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|cmd_lock
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"mxge: command %d timed out"
literal|"result = %d\n"
argument_list|,
name|cmd
argument_list|,
name|be32toh
argument_list|(
name|response
operator|->
name|result
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|EAGAIN
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mxge_adopt_running_firmware
parameter_list|(
name|mxge_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|mcp_gen_header
modifier|*
name|hdr
decl_stmt|;
specifier|const
name|size_t
name|bytes
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|mcp_gen_header
argument_list|)
decl_stmt|;
name|size_t
name|hdr_offset
decl_stmt|;
name|int
name|status
decl_stmt|;
comment|/* find running firmware header */
name|hdr_offset
operator|=
name|htobe32
argument_list|(
operator|*
operator|(
specifier|volatile
name|uint32_t
operator|*
operator|)
operator|(
name|sc
operator|->
name|sram
operator|+
name|MCP_HEADER_PTR_OFFSET
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|hdr_offset
operator|&
literal|3
operator|)
operator|||
name|hdr_offset
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
operator|>
name|sc
operator|->
name|sram_size
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Running firmware has bad header offset (%d)\n"
argument_list|,
operator|(
name|int
operator|)
name|hdr_offset
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
block|}
comment|/* copy header of running firmware from SRAM to host memory to 	 * validate firmware */
name|hdr
operator|=
name|malloc
argument_list|(
name|bytes
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdr
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"could not malloc firmware hdr\n"
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|bus_space_read_region_1
argument_list|(
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|mem_res
argument_list|)
argument_list|,
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|mem_res
argument_list|)
argument_list|,
name|hdr_offset
argument_list|,
operator|(
name|char
operator|*
operator|)
name|hdr
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
name|status
operator|=
name|mxge_validate_firmware
argument_list|(
name|sc
argument_list|,
name|hdr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|hdr
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mxge_load_firmware
parameter_list|(
name|mxge_softc_t
modifier|*
name|sc
parameter_list|)
block|{
specifier|volatile
name|uint32_t
modifier|*
name|confirm
decl_stmt|;
specifier|volatile
name|char
modifier|*
name|submit
decl_stmt|;
name|char
name|buf_bytes
index|[
literal|72
index|]
decl_stmt|;
name|uint32_t
modifier|*
name|buf
decl_stmt|,
name|size
decl_stmt|,
name|dma_low
decl_stmt|,
name|dma_high
decl_stmt|;
name|int
name|status
decl_stmt|,
name|i
decl_stmt|;
name|buf
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
call|(
name|unsigned
name|long
call|)
argument_list|(
name|buf_bytes
operator|+
literal|7
argument_list|)
operator|&
operator|~
literal|7UL
operator|)
expr_stmt|;
name|size
operator|=
name|sc
operator|->
name|sram_size
expr_stmt|;
name|status
operator|=
name|mxge_load_firmware_helper
argument_list|(
name|sc
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
comment|/* Try to use the currently running firmware, if 		   it is new enough */
name|status
operator|=
name|mxge_adopt_running_firmware
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to adopt running firmware\n"
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Successfully adopted running firmware\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tx
operator|.
name|boundary
operator|==
literal|4096
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Using firmware currently running on NIC"
literal|".  For optimal\n"
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"performance consider loading optimized "
literal|"firmware\n"
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|fw_name
operator|=
name|mxge_fw_unaligned
expr_stmt|;
name|sc
operator|->
name|tx
operator|.
name|boundary
operator|=
literal|2048
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* clear confirmation addr */
name|confirm
operator|=
operator|(
specifier|volatile
name|uint32_t
operator|*
operator|)
name|sc
operator|->
name|cmd
expr_stmt|;
operator|*
name|confirm
operator|=
literal|0
expr_stmt|;
name|mb
argument_list|()
expr_stmt|;
comment|/* send a reload command to the bootstrap MCP, and wait for the 	   response in the confirmation address.  The firmware should 	   write a -1 there to indicate it is alive and well 	*/
name|dma_low
operator|=
name|MXGE_LOWPART_TO_U32
argument_list|(
name|sc
operator|->
name|cmd_dma
operator|.
name|bus_addr
argument_list|)
expr_stmt|;
name|dma_high
operator|=
name|MXGE_HIGHPART_TO_U32
argument_list|(
name|sc
operator|->
name|cmd_dma
operator|.
name|bus_addr
argument_list|)
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
name|htobe32
argument_list|(
name|dma_high
argument_list|)
expr_stmt|;
comment|/* confirm addr MSW */
name|buf
index|[
literal|1
index|]
operator|=
name|htobe32
argument_list|(
name|dma_low
argument_list|)
expr_stmt|;
comment|/* confirm addr LSW */
name|buf
index|[
literal|2
index|]
operator|=
name|htobe32
argument_list|(
literal|0xffffffff
argument_list|)
expr_stmt|;
comment|/* confirm data */
comment|/* FIX: All newest firmware should un-protect the bottom of 	   the sram before handoff. However, the very first interfaces 	   do not. Therefore the handoff copy must skip the first 8 bytes 	*/
comment|/* where the code starts*/
name|buf
index|[
literal|3
index|]
operator|=
name|htobe32
argument_list|(
name|MXGE_FW_OFFSET
operator|+
literal|8
argument_list|)
expr_stmt|;
name|buf
index|[
literal|4
index|]
operator|=
name|htobe32
argument_list|(
name|size
operator|-
literal|8
argument_list|)
expr_stmt|;
comment|/* length of code */
name|buf
index|[
literal|5
index|]
operator|=
name|htobe32
argument_list|(
literal|8
argument_list|)
expr_stmt|;
comment|/* where to copy to */
name|buf
index|[
literal|6
index|]
operator|=
name|htobe32
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* where to jump to */
name|submit
operator|=
operator|(
specifier|volatile
name|char
operator|*
operator|)
operator|(
name|sc
operator|->
name|sram
operator|+
name|MXGEFW_BOOT_HANDOFF
operator|)
expr_stmt|;
name|mxge_pio_copy
argument_list|(
name|submit
argument_list|,
name|buf
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|mb
argument_list|()
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|mb
argument_list|()
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|confirm
operator|!=
literal|0xffffffff
operator|&&
name|i
operator|<
literal|20
condition|)
block|{
name|DELAY
argument_list|(
literal|1000
operator|*
literal|10
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|cmd_dma
operator|.
name|dmat
argument_list|,
name|sc
operator|->
name|cmd_dma
operator|.
name|map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|confirm
operator|!=
literal|0xffffffff
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"handoff failed (%p = 0x%x)"
argument_list|,
name|confirm
argument_list|,
operator|*
name|confirm
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mxge_update_mac_address
parameter_list|(
name|mxge_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|mxge_cmd_t
name|cmd
decl_stmt|;
name|uint8_t
modifier|*
name|addr
init|=
name|sc
operator|->
name|mac_addr
decl_stmt|;
name|int
name|status
decl_stmt|;
name|cmd
operator|.
name|data0
operator|=
operator|(
operator|(
name|addr
index|[
literal|0
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|addr
index|[
literal|1
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|addr
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|3
index|]
operator|)
expr_stmt|;
name|cmd
operator|.
name|data1
operator|=
operator|(
operator|(
name|addr
index|[
literal|4
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|addr
index|[
literal|5
index|]
operator|)
operator|)
expr_stmt|;
name|status
operator|=
name|mxge_send_cmd
argument_list|(
name|sc
argument_list|,
name|MXGEFW_SET_MAC_ADDRESS
argument_list|,
operator|&
name|cmd
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mxge_change_pause
parameter_list|(
name|mxge_softc_t
modifier|*
name|sc
parameter_list|,
name|int
name|pause
parameter_list|)
block|{
name|mxge_cmd_t
name|cmd
decl_stmt|;
name|int
name|status
decl_stmt|;
if|if
condition|(
name|pause
condition|)
name|status
operator|=
name|mxge_send_cmd
argument_list|(
name|sc
argument_list|,
name|MXGEFW_ENABLE_FLOW_CONTROL
argument_list|,
operator|&
name|cmd
argument_list|)
expr_stmt|;
else|else
name|status
operator|=
name|mxge_send_cmd
argument_list|(
name|sc
argument_list|,
name|MXGEFW_DISABLE_FLOW_CONTROL
argument_list|,
operator|&
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Failed to set flow control mode\n"
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
name|sc
operator|->
name|pause
operator|=
name|pause
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mxge_change_promisc
parameter_list|(
name|mxge_softc_t
modifier|*
name|sc
parameter_list|,
name|int
name|promisc
parameter_list|)
block|{
name|mxge_cmd_t
name|cmd
decl_stmt|;
name|int
name|status
decl_stmt|;
if|if
condition|(
name|promisc
condition|)
name|status
operator|=
name|mxge_send_cmd
argument_list|(
name|sc
argument_list|,
name|MXGEFW_ENABLE_PROMISC
argument_list|,
operator|&
name|cmd
argument_list|)
expr_stmt|;
else|else
name|status
operator|=
name|mxge_send_cmd
argument_list|(
name|sc
argument_list|,
name|MXGEFW_DISABLE_PROMISC
argument_list|,
operator|&
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Failed to set promisc mode\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|mxge_set_multicast_list
parameter_list|(
name|mxge_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|mxge_cmd_t
name|cmd
decl_stmt|;
name|struct
name|ifmultiaddr
modifier|*
name|ifma
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|ifp
decl_stmt|;
name|int
name|err
decl_stmt|;
comment|/* This firmware is known to not support multicast */
if|if
condition|(
operator|!
name|sc
operator|->
name|fw_multicast_support
condition|)
return|return;
comment|/* Disable multicast filtering while we play with the lists*/
name|err
operator|=
name|mxge_send_cmd
argument_list|(
name|sc
argument_list|,
name|MXGEFW_ENABLE_ALLMULTI
argument_list|,
operator|&
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Failed MXGEFW_ENABLE_ALLMULTI,"
literal|" error status: %d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_ALLMULTI
condition|)
comment|/* request to disable multicast filtering, so quit here */
return|return;
comment|/* Flush all the filters */
name|err
operator|=
name|mxge_send_cmd
argument_list|(
name|sc
argument_list|,
name|MXGEFW_LEAVE_ALL_MULTICAST_GROUPS
argument_list|,
operator|&
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Failed MXGEFW_LEAVE_ALL_MULTICAST_GROUPS"
literal|", error status: %d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Walk the multicast list, and add each address */
name|IF_ADDR_LOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ifma
argument_list|,
argument|&ifp->if_multiaddrs
argument_list|,
argument|ifma_link
argument_list|)
block|{
if|if
condition|(
name|ifma
operator|->
name|ifma_addr
operator|->
name|sa_family
operator|!=
name|AF_LINK
condition|)
continue|continue;
name|bcopy
argument_list|(
name|LLADDR
argument_list|(
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifma
operator|->
name|ifma_addr
argument_list|)
argument_list|,
operator|&
name|cmd
operator|.
name|data0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|LLADDR
argument_list|(
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifma
operator|->
name|ifma_addr
argument_list|)
operator|+
literal|4
argument_list|,
operator|&
name|cmd
operator|.
name|data1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|data0
operator|=
name|htonl
argument_list|(
name|cmd
operator|.
name|data0
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|data1
operator|=
name|htonl
argument_list|(
name|cmd
operator|.
name|data1
argument_list|)
expr_stmt|;
name|err
operator|=
name|mxge_send_cmd
argument_list|(
name|sc
argument_list|,
name|MXGEFW_JOIN_MULTICAST_GROUP
argument_list|,
operator|&
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Failed "
literal|"MXGEFW_JOIN_MULTICAST_GROUP, error status:"
literal|"%d\t"
argument_list|,
name|err
argument_list|)
expr_stmt|;
comment|/* abort, leaving multicast filtering off */
name|IF_ADDR_UNLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|IF_ADDR_UNLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* Enable multicast filtering */
name|err
operator|=
name|mxge_send_cmd
argument_list|(
name|sc
argument_list|,
name|MXGEFW_DISABLE_ALLMULTI
argument_list|,
operator|&
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Failed MXGEFW_DISABLE_ALLMULTI"
literal|", error status: %d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|mxge_reset
parameter_list|(
name|mxge_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|mxge_cmd_t
name|cmd
decl_stmt|;
name|mxge_dma_t
name|dmabench_dma
decl_stmt|;
name|size_t
name|bytes
decl_stmt|;
name|int
name|status
decl_stmt|;
comment|/* try to send a reset command to the card to see if it 	   is alive */
name|memset
argument_list|(
operator|&
name|cmd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|mxge_send_cmd
argument_list|(
name|sc
argument_list|,
name|MXGEFW_CMD_RESET
argument_list|,
operator|&
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed reset\n"
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
name|mxge_dummy_rdma
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Now exchange information about interrupts  */
name|bytes
operator|=
name|mxge_max_intr_slots
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|sc
operator|->
name|rx_done
operator|.
name|entry
argument_list|)
expr_stmt|;
block|\
name|memset
argument_list|(
name|sc
operator|->
name|rx_done
operator|.
name|entry
argument_list|,
literal|0
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|data0
operator|=
operator|(
name|uint32_t
operator|)
name|bytes
expr_stmt|;
name|status
operator|=
name|mxge_send_cmd
argument_list|(
name|sc
argument_list|,
name|MXGEFW_CMD_SET_INTRQ_SIZE
argument_list|,
operator|&
name|cmd
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|data0
operator|=
name|MXGE_LOWPART_TO_U32
argument_list|(
name|sc
operator|->
name|rx_done
operator|.
name|dma
operator|.
name|bus_addr
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|data1
operator|=
name|MXGE_HIGHPART_TO_U32
argument_list|(
name|sc
operator|->
name|rx_done
operator|.
name|dma
operator|.
name|bus_addr
argument_list|)
expr_stmt|;
name|status
operator||=
name|mxge_send_cmd
argument_list|(
name|sc
argument_list|,
name|MXGEFW_CMD_SET_INTRQ_DMA
argument_list|,
operator|&
name|cmd
argument_list|)
expr_stmt|;
name|status
operator||=
name|mxge_send_cmd
argument_list|(
name|sc
argument_list|,
name|MXGEFW_CMD_GET_INTR_COAL_DELAY_OFFSET
argument_list|,
operator|&
name|cmd
argument_list|)
expr_stmt|;
name|sc
operator|->
name|intr_coal_delay_ptr
operator|=
operator|(
specifier|volatile
name|uint32_t
operator|*
operator|)
operator|(
name|sc
operator|->
name|sram
operator|+
name|cmd
operator|.
name|data0
operator|)
expr_stmt|;
name|status
operator||=
name|mxge_send_cmd
argument_list|(
name|sc
argument_list|,
name|MXGEFW_CMD_GET_IRQ_ACK_OFFSET
argument_list|,
operator|&
name|cmd
argument_list|)
expr_stmt|;
name|sc
operator|->
name|irq_claim
operator|=
operator|(
specifier|volatile
name|uint32_t
operator|*
operator|)
operator|(
name|sc
operator|->
name|sram
operator|+
name|cmd
operator|.
name|data0
operator|)
expr_stmt|;
name|status
operator||=
name|mxge_send_cmd
argument_list|(
name|sc
argument_list|,
name|MXGEFW_CMD_GET_IRQ_DEASSERT_OFFSET
argument_list|,
operator|&
name|cmd
argument_list|)
expr_stmt|;
name|sc
operator|->
name|irq_deassert
operator|=
operator|(
specifier|volatile
name|uint32_t
operator|*
operator|)
operator|(
name|sc
operator|->
name|sram
operator|+
name|cmd
operator|.
name|data0
operator|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed set interrupt parameters\n"
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
operator|*
name|sc
operator|->
name|intr_coal_delay_ptr
operator|=
name|htobe32
argument_list|(
name|sc
operator|->
name|intr_coal_delay
argument_list|)
expr_stmt|;
comment|/* run a DMA benchmark */
name|sc
operator|->
name|read_dma
operator|=
name|sc
operator|->
name|write_dma
operator|=
name|sc
operator|->
name|read_write_dma
operator|=
literal|0
expr_stmt|;
name|status
operator|=
name|mxge_dma_alloc
argument_list|(
name|sc
argument_list|,
operator|&
name|dmabench_dma
argument_list|,
literal|4096
argument_list|,
literal|4096
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
goto|goto
name|dmabench_fail
goto|;
comment|/* Read DMA */
name|cmd
operator|.
name|data0
operator|=
name|MXGE_LOWPART_TO_U32
argument_list|(
name|dmabench_dma
operator|.
name|bus_addr
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|data1
operator|=
name|MXGE_HIGHPART_TO_U32
argument_list|(
name|dmabench_dma
operator|.
name|bus_addr
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|data2
operator|=
name|sc
operator|->
name|tx
operator|.
name|boundary
operator|*
literal|0x10000
expr_stmt|;
name|status
operator|=
name|mxge_send_cmd
argument_list|(
name|sc
argument_list|,
name|MXGEFW_DMA_TEST
argument_list|,
operator|&
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"read dma benchmark failed\n"
argument_list|)
expr_stmt|;
else|else
name|sc
operator|->
name|read_dma
operator|=
operator|(
operator|(
name|cmd
operator|.
name|data0
operator|>>
literal|16
operator|)
operator|*
name|sc
operator|->
name|tx
operator|.
name|boundary
operator|*
literal|2
operator|)
operator|/
operator|(
name|cmd
operator|.
name|data0
operator|&
literal|0xffff
operator|)
expr_stmt|;
comment|/* Write DMA */
name|cmd
operator|.
name|data0
operator|=
name|MXGE_LOWPART_TO_U32
argument_list|(
name|dmabench_dma
operator|.
name|bus_addr
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|data1
operator|=
name|MXGE_HIGHPART_TO_U32
argument_list|(
name|dmabench_dma
operator|.
name|bus_addr
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|data2
operator|=
name|sc
operator|->
name|tx
operator|.
name|boundary
operator|*
literal|0x1
expr_stmt|;
name|status
operator|=
name|mxge_send_cmd
argument_list|(
name|sc
argument_list|,
name|MXGEFW_DMA_TEST
argument_list|,
operator|&
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"write dma benchmark failed\n"
argument_list|)
expr_stmt|;
else|else
name|sc
operator|->
name|write_dma
operator|=
operator|(
operator|(
name|cmd
operator|.
name|data0
operator|>>
literal|16
operator|)
operator|*
name|sc
operator|->
name|tx
operator|.
name|boundary
operator|*
literal|2
operator|)
operator|/
operator|(
name|cmd
operator|.
name|data0
operator|&
literal|0xffff
operator|)
expr_stmt|;
comment|/* Read/Write DMA */
name|cmd
operator|.
name|data0
operator|=
name|MXGE_LOWPART_TO_U32
argument_list|(
name|dmabench_dma
operator|.
name|bus_addr
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|data1
operator|=
name|MXGE_HIGHPART_TO_U32
argument_list|(
name|dmabench_dma
operator|.
name|bus_addr
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|data2
operator|=
name|sc
operator|->
name|tx
operator|.
name|boundary
operator|*
literal|0x10001
expr_stmt|;
name|status
operator|=
name|mxge_send_cmd
argument_list|(
name|sc
argument_list|,
name|MXGEFW_DMA_TEST
argument_list|,
operator|&
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"read/write dma benchmark failed\n"
argument_list|)
expr_stmt|;
else|else
name|sc
operator|->
name|read_write_dma
operator|=
operator|(
operator|(
name|cmd
operator|.
name|data0
operator|>>
literal|16
operator|)
operator|*
name|sc
operator|->
name|tx
operator|.
name|boundary
operator|*
literal|2
operator|*
literal|2
operator|)
operator|/
operator|(
name|cmd
operator|.
name|data0
operator|&
literal|0xffff
operator|)
expr_stmt|;
name|mxge_dma_free
argument_list|(
operator|&
name|dmabench_dma
argument_list|)
expr_stmt|;
name|dmabench_fail
label|:
comment|/* reset mcp/driver shared state back to 0 */
name|bzero
argument_list|(
name|sc
operator|->
name|rx_done
operator|.
name|entry
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rx_done
operator|.
name|idx
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|rx_done
operator|.
name|cnt
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|tx
operator|.
name|req
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|tx
operator|.
name|done
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|tx
operator|.
name|pkt_done
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|tx
operator|.
name|wake
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|tx
operator|.
name|stall
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|rx_big
operator|.
name|cnt
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|rx_small
operator|.
name|cnt
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|rdma_tags_available
operator|=
literal|15
expr_stmt|;
name|status
operator|=
name|mxge_update_mac_address
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mxge_change_promisc
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mxge_change_pause
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|pause
argument_list|)
expr_stmt|;
name|mxge_set_multicast_list
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mxge_change_intr_coal
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|mxge_softc_t
modifier|*
name|sc
decl_stmt|;
name|unsigned
name|int
name|intr_coal_delay
decl_stmt|;
name|int
name|err
decl_stmt|;
name|sc
operator|=
name|arg1
expr_stmt|;
name|intr_coal_delay
operator|=
name|sc
operator|->
name|intr_coal_delay
expr_stmt|;
name|err
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|intr_coal_delay
argument_list|,
name|arg2
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
return|return
name|err
return|;
block|}
if|if
condition|(
name|intr_coal_delay
operator|==
name|sc
operator|->
name|intr_coal_delay
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|intr_coal_delay
operator|==
literal|0
operator|||
name|intr_coal_delay
operator|>
literal|1000
operator|*
literal|1000
condition|)
return|return
name|EINVAL
return|;
name|sx_xlock
argument_list|(
operator|&
name|sc
operator|->
name|driver_lock
argument_list|)
expr_stmt|;
operator|*
name|sc
operator|->
name|intr_coal_delay_ptr
operator|=
name|htobe32
argument_list|(
name|intr_coal_delay
argument_list|)
expr_stmt|;
name|sc
operator|->
name|intr_coal_delay
operator|=
name|intr_coal_delay
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|sc
operator|->
name|driver_lock
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mxge_change_flow_control
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|mxge_softc_t
modifier|*
name|sc
decl_stmt|;
name|unsigned
name|int
name|enabled
decl_stmt|;
name|int
name|err
decl_stmt|;
name|sc
operator|=
name|arg1
expr_stmt|;
name|enabled
operator|=
name|sc
operator|->
name|pause
expr_stmt|;
name|err
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|enabled
argument_list|,
name|arg2
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
return|return
name|err
return|;
block|}
if|if
condition|(
name|enabled
operator|==
name|sc
operator|->
name|pause
condition|)
return|return
literal|0
return|;
name|sx_xlock
argument_list|(
operator|&
name|sc
operator|->
name|driver_lock
argument_list|)
expr_stmt|;
name|err
operator|=
name|mxge_change_pause
argument_list|(
name|sc
argument_list|,
name|enabled
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|sc
operator|->
name|driver_lock
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mxge_handle_be32
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
if|if
condition|(
name|arg1
operator|==
name|NULL
condition|)
return|return
name|EFAULT
return|;
name|arg2
operator|=
name|be32toh
argument_list|(
operator|*
operator|(
name|int
operator|*
operator|)
name|arg1
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|NULL
expr_stmt|;
name|err
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|req
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mxge_add_sysctls
parameter_list|(
name|mxge_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|sysctl_ctx_list
modifier|*
name|ctx
decl_stmt|;
name|struct
name|sysctl_oid_list
modifier|*
name|children
decl_stmt|;
name|mcp_irq_data_t
modifier|*
name|fw
decl_stmt|;
name|ctx
operator|=
name|device_get_sysctl_ctx
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
expr_stmt|;
name|children
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|fw
operator|=
name|sc
operator|->
name|fw_stats
expr_stmt|;
comment|/* random information */
name|SYSCTL_ADD_STRING
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"firmware_version"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|fw_version
argument_list|,
literal|0
argument_list|,
literal|"firmware version"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_STRING
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"serial_number"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|serial_number_string
argument_list|,
literal|0
argument_list|,
literal|"serial number"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_STRING
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"product_code"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|product_code_string
argument_list|,
literal|0
argument_list|,
literal|"product_code"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"pcie_link_width"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|link_width
argument_list|,
literal|0
argument_list|,
literal|"tx_boundary"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_boundary"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|tx
operator|.
name|boundary
argument_list|,
literal|0
argument_list|,
literal|"tx_boundary"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"write_combine"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|wc
argument_list|,
literal|0
argument_list|,
literal|"write combining PIO?"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"read_dma_MBs"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|read_dma
argument_list|,
literal|0
argument_list|,
literal|"DMA Read speed in MB/s"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"write_dma_MBs"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|write_dma
argument_list|,
literal|0
argument_list|,
literal|"DMA Write speed in MB/s"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"read_write_dma_MBs"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|read_write_dma
argument_list|,
literal|0
argument_list|,
literal|"DMA concurrent Read/Write speed in MB/s"
argument_list|)
expr_stmt|;
comment|/* performance related tunables */
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"intr_coal_delay"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|mxge_change_intr_coal
argument_list|,
literal|"I"
argument_list|,
literal|"interrupt coalescing delay in usecs"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"flow_control_enabled"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|mxge_change_flow_control
argument_list|,
literal|"I"
argument_list|,
literal|"interrupt coalescing delay in usecs"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"deassert_wait"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|mxge_deassert_wait
argument_list|,
literal|0
argument_list|,
literal|"Wait for IRQ line to go low in ihandler"
argument_list|)
expr_stmt|;
comment|/* stats block from firmware is in network byte order.   	   Need to swap it */
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"link_up"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RD
argument_list|,
operator|&
name|fw
operator|->
name|link_up
argument_list|,
literal|0
argument_list|,
name|mxge_handle_be32
argument_list|,
literal|"I"
argument_list|,
literal|"link up"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rdma_tags_available"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RD
argument_list|,
operator|&
name|fw
operator|->
name|rdma_tags_available
argument_list|,
literal|0
argument_list|,
name|mxge_handle_be32
argument_list|,
literal|"I"
argument_list|,
literal|"rdma_tags_available"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"dropped_link_overflow"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RD
argument_list|,
operator|&
name|fw
operator|->
name|dropped_link_overflow
argument_list|,
literal|0
argument_list|,
name|mxge_handle_be32
argument_list|,
literal|"I"
argument_list|,
literal|"dropped_link_overflow"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"dropped_link_error_or_filtered"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RD
argument_list|,
operator|&
name|fw
operator|->
name|dropped_link_error_or_filtered
argument_list|,
literal|0
argument_list|,
name|mxge_handle_be32
argument_list|,
literal|"I"
argument_list|,
literal|"dropped_link_error_or_filtered"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"dropped_multicast_filtered"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RD
argument_list|,
operator|&
name|fw
operator|->
name|dropped_multicast_filtered
argument_list|,
literal|0
argument_list|,
name|mxge_handle_be32
argument_list|,
literal|"I"
argument_list|,
literal|"dropped_multicast_filtered"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"dropped_runt"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RD
argument_list|,
operator|&
name|fw
operator|->
name|dropped_runt
argument_list|,
literal|0
argument_list|,
name|mxge_handle_be32
argument_list|,
literal|"I"
argument_list|,
literal|"dropped_runt"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"dropped_overrun"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RD
argument_list|,
operator|&
name|fw
operator|->
name|dropped_overrun
argument_list|,
literal|0
argument_list|,
name|mxge_handle_be32
argument_list|,
literal|"I"
argument_list|,
literal|"dropped_overrun"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"dropped_no_small_buffer"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RD
argument_list|,
operator|&
name|fw
operator|->
name|dropped_no_small_buffer
argument_list|,
literal|0
argument_list|,
name|mxge_handle_be32
argument_list|,
literal|"I"
argument_list|,
literal|"dropped_no_small_buffer"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"dropped_no_big_buffer"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RD
argument_list|,
operator|&
name|fw
operator|->
name|dropped_no_big_buffer
argument_list|,
literal|0
argument_list|,
name|mxge_handle_be32
argument_list|,
literal|"I"
argument_list|,
literal|"dropped_no_big_buffer"
argument_list|)
expr_stmt|;
comment|/* host counters exported for debugging */
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_small_cnt"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|rx_small
operator|.
name|cnt
argument_list|,
literal|0
argument_list|,
literal|"rx_small_cnt"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_big_cnt"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|rx_big
operator|.
name|cnt
argument_list|,
literal|0
argument_list|,
literal|"rx_small_cnt"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_req"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|tx
operator|.
name|req
argument_list|,
literal|0
argument_list|,
literal|"tx_req"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_done"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|tx
operator|.
name|done
argument_list|,
literal|0
argument_list|,
literal|"tx_done"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_pkt_done"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|tx
operator|.
name|pkt_done
argument_list|,
literal|0
argument_list|,
literal|"tx_done"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_stall"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|tx
operator|.
name|stall
argument_list|,
literal|0
argument_list|,
literal|"tx_stall"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_wake"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|tx
operator|.
name|wake
argument_list|,
literal|0
argument_list|,
literal|"tx_wake"
argument_list|)
expr_stmt|;
comment|/* verbose printing? */
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"verbose"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|mxge_verbose
argument_list|,
literal|0
argument_list|,
literal|"verbose printing"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* copy an array of mcp_kreq_ether_send_t's to the mcp.  Copy     backwards one at a time and handle ring wraps */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|mxge_submit_req_backwards
parameter_list|(
name|mxge_tx_buf_t
modifier|*
name|tx
parameter_list|,
name|mcp_kreq_ether_send_t
modifier|*
name|src
parameter_list|,
name|int
name|cnt
parameter_list|)
block|{
name|int
name|idx
decl_stmt|,
name|starting_slot
decl_stmt|;
name|starting_slot
operator|=
name|tx
operator|->
name|req
expr_stmt|;
while|while
condition|(
name|cnt
operator|>
literal|1
condition|)
block|{
name|cnt
operator|--
expr_stmt|;
name|idx
operator|=
operator|(
name|starting_slot
operator|+
name|cnt
operator|)
operator|&
name|tx
operator|->
name|mask
expr_stmt|;
name|mxge_pio_copy
argument_list|(
operator|&
name|tx
operator|->
name|lanai
index|[
name|idx
index|]
argument_list|,
operator|&
name|src
index|[
name|cnt
index|]
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|src
argument_list|)
argument_list|)
expr_stmt|;
name|mb
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * copy an array of mcp_kreq_ether_send_t's to the mcp.  Copy  * at most 32 bytes at a time, so as to avoid involving the software  * pio handler in the nic.   We re-write the first segment's flags  * to mark them valid only after writing the entire chain   */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|mxge_submit_req
parameter_list|(
name|mxge_tx_buf_t
modifier|*
name|tx
parameter_list|,
name|mcp_kreq_ether_send_t
modifier|*
name|src
parameter_list|,
name|int
name|cnt
parameter_list|)
block|{
name|int
name|idx
decl_stmt|,
name|i
decl_stmt|;
name|uint32_t
modifier|*
name|src_ints
decl_stmt|;
specifier|volatile
name|uint32_t
modifier|*
name|dst_ints
decl_stmt|;
name|mcp_kreq_ether_send_t
modifier|*
name|srcp
decl_stmt|;
specifier|volatile
name|mcp_kreq_ether_send_t
modifier|*
name|dstp
decl_stmt|,
modifier|*
name|dst
decl_stmt|;
name|uint8_t
name|last_flags
decl_stmt|;
name|idx
operator|=
name|tx
operator|->
name|req
operator|&
name|tx
operator|->
name|mask
expr_stmt|;
name|last_flags
operator|=
name|src
operator|->
name|flags
expr_stmt|;
name|src
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|mb
argument_list|()
expr_stmt|;
name|dst
operator|=
name|dstp
operator|=
operator|&
name|tx
operator|->
name|lanai
index|[
name|idx
index|]
expr_stmt|;
name|srcp
operator|=
name|src
expr_stmt|;
if|if
condition|(
operator|(
name|idx
operator|+
name|cnt
operator|)
operator|<
name|tx
operator|->
name|mask
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|cnt
operator|-
literal|1
operator|)
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|mxge_pio_copy
argument_list|(
name|dstp
argument_list|,
name|srcp
argument_list|,
literal|2
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|src
argument_list|)
argument_list|)
expr_stmt|;
name|mb
argument_list|()
expr_stmt|;
comment|/* force write every 32 bytes */
name|srcp
operator|+=
literal|2
expr_stmt|;
name|dstp
operator|+=
literal|2
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* submit all but the first request, and ensure                     that it is submitted below */
name|mxge_submit_req_backwards
argument_list|(
name|tx
argument_list|,
name|src
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<
name|cnt
condition|)
block|{
comment|/* submit the first request */
name|mxge_pio_copy
argument_list|(
name|dstp
argument_list|,
name|srcp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|src
argument_list|)
argument_list|)
expr_stmt|;
name|mb
argument_list|()
expr_stmt|;
comment|/* barrier before setting valid flag */
block|}
comment|/* re-write the last 32-bits with the valid flags */
name|src
operator|->
name|flags
operator|=
name|last_flags
expr_stmt|;
name|src_ints
operator|=
operator|(
name|uint32_t
operator|*
operator|)
name|src
expr_stmt|;
name|src_ints
operator|+=
literal|3
expr_stmt|;
name|dst_ints
operator|=
operator|(
specifier|volatile
name|uint32_t
operator|*
operator|)
name|dst
expr_stmt|;
name|dst_ints
operator|+=
literal|3
expr_stmt|;
operator|*
name|dst_ints
operator|=
operator|*
name|src_ints
expr_stmt|;
name|tx
operator|->
name|req
operator|+=
name|cnt
expr_stmt|;
name|mb
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|mxge_submit_req_wc
parameter_list|(
name|mxge_tx_buf_t
modifier|*
name|tx
parameter_list|,
name|mcp_kreq_ether_send_t
modifier|*
name|src
parameter_list|,
name|int
name|cnt
parameter_list|)
block|{
name|tx
operator|->
name|req
operator|+=
name|cnt
expr_stmt|;
name|mb
argument_list|()
expr_stmt|;
while|while
condition|(
name|cnt
operator|>=
literal|4
condition|)
block|{
name|mxge_pio_copy
argument_list|(
operator|(
specifier|volatile
name|char
operator|*
operator|)
name|tx
operator|->
name|wc_fifo
argument_list|,
name|src
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|mb
argument_list|()
expr_stmt|;
name|src
operator|+=
literal|4
expr_stmt|;
name|cnt
operator|-=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|cnt
operator|>
literal|0
condition|)
block|{
comment|/* pad it to 64 bytes.  The src is 64 bytes bigger than it 	       needs to be so that we don't overrun it */
name|mxge_pio_copy
argument_list|(
name|tx
operator|->
name|wc_fifo
operator|+
name|MXGEFW_ETH_SEND_OFFSET
argument_list|(
name|cnt
argument_list|)
argument_list|,
name|src
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|mb
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|mxge_encap_tso
parameter_list|(
name|mxge_softc_t
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|busdma_seg_cnt
parameter_list|)
block|{
name|mxge_tx_buf_t
modifier|*
name|tx
decl_stmt|;
name|mcp_kreq_ether_send_t
modifier|*
name|req
decl_stmt|;
name|bus_dma_segment_t
modifier|*
name|seg
decl_stmt|;
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|struct
name|tcphdr
modifier|*
name|tcp
decl_stmt|;
name|uint32_t
name|low
decl_stmt|,
name|high_swapped
decl_stmt|;
name|int
name|len
decl_stmt|,
name|seglen
decl_stmt|,
name|cum_len
decl_stmt|,
name|cum_len_next
decl_stmt|;
name|int
name|next_is_first
decl_stmt|,
name|chop
decl_stmt|,
name|cnt
decl_stmt|,
name|rdma_count
decl_stmt|,
name|small
decl_stmt|;
name|uint16_t
name|pseudo_hdr_offset
decl_stmt|,
name|cksum_offset
decl_stmt|,
name|mss
decl_stmt|;
name|uint8_t
name|flags
decl_stmt|,
name|flags_next
decl_stmt|;
specifier|static
name|int
name|once
decl_stmt|;
name|mss
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|tso_segsz
expr_stmt|;
comment|/* negative cum_len signifies to the 	 * send loop that we are still in the 	 * header portion of the TSO packet. 	 */
comment|/* ensure we have the ethernet, IP and TCP 	   header together in the first mbuf, copy 	   it to a scratch buffer if not */
if|if
condition|(
name|__predict_false
argument_list|(
name|m
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|eh
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|ip
argument_list|)
argument_list|)
condition|)
block|{
name|m_copydata
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|eh
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|ip
argument_list|)
argument_list|,
name|sc
operator|->
name|scratch
argument_list|)
expr_stmt|;
name|eh
operator|=
operator|(
expr|struct
name|ether_header
operator|*
operator|)
name|sc
operator|->
name|scratch
expr_stmt|;
block|}
else|else
block|{
name|eh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
block|}
name|ip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
operator|(
name|eh
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|m
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|eh
argument_list|)
operator|+
operator|(
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
operator|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|tcp
argument_list|)
argument_list|)
condition|)
block|{
name|m_copydata
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|eh
argument_list|)
operator|+
operator|(
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
operator|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|tcp
argument_list|)
argument_list|,
name|sc
operator|->
name|scratch
argument_list|)
expr_stmt|;
name|eh
operator|=
operator|(
expr|struct
name|ether_header
operator|*
operator|)
name|sc
operator|->
name|scratch
expr_stmt|;
name|ip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
operator|(
name|eh
operator|+
literal|1
operator|)
expr_stmt|;
block|}
name|tcp
operator|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|ip
operator|+
operator|(
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
operator|)
operator|)
expr_stmt|;
name|cum_len
operator|=
operator|-
operator|(
sizeof|sizeof
argument_list|(
operator|*
name|eh
argument_list|)
operator|+
operator|(
operator|(
name|ip
operator|->
name|ip_hl
operator|+
name|tcp
operator|->
name|th_off
operator|)
operator|<<
literal|2
operator|)
operator|)
expr_stmt|;
comment|/* TSO implies checksum offload on this hardware */
name|cksum_offset
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|eh
argument_list|)
operator|+
operator|(
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
operator|)
expr_stmt|;
name|flags
operator|=
name|MXGEFW_FLAGS_TSO_HDR
operator||
name|MXGEFW_FLAGS_FIRST
expr_stmt|;
comment|/* for TSO, pseudo_hdr_offset holds mss. 	 * The firmware figures out where to put 	 * the checksum by parsing the header. */
name|pseudo_hdr_offset
operator|=
name|htobe16
argument_list|(
name|mss
argument_list|)
expr_stmt|;
name|tx
operator|=
operator|&
name|sc
operator|->
name|tx
expr_stmt|;
name|req
operator|=
name|tx
operator|->
name|req_list
expr_stmt|;
name|seg
operator|=
name|tx
operator|->
name|seg_list
expr_stmt|;
name|cnt
operator|=
literal|0
expr_stmt|;
name|rdma_count
operator|=
literal|0
expr_stmt|;
comment|/* "rdma_count" is the number of RDMAs belonging to the 	 * current packet BEFORE the current send request. For 	 * non-TSO packets, this is equal to "count". 	 * For TSO packets, rdma_count needs to be reset 	 * to 0 after a segment cut. 	 * 	 * The rdma_count field of the send request is 	 * the number of RDMAs of the packet starting at 	 * that request. For TSO send requests with one ore more cuts 	 * in the middle, this is the number of RDMAs starting 	 * after the last cut in the request. All previous 	 * segments before the last cut implicitly have 1 RDMA. 	 * 	 * Since the number of RDMAs is not known beforehand, 	 * it must be filled-in retroactively - after each 	 * segmentation cut or at the end of the entire packet. 	 */
while|while
condition|(
name|busdma_seg_cnt
condition|)
block|{
comment|/* Break the busdma segment up into pieces*/
name|low
operator|=
name|MXGE_LOWPART_TO_U32
argument_list|(
name|seg
operator|->
name|ds_addr
argument_list|)
expr_stmt|;
name|high_swapped
operator|=
name|htobe32
argument_list|(
name|MXGE_HIGHPART_TO_U32
argument_list|(
name|seg
operator|->
name|ds_addr
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|seglen
operator|=
name|seg
operator|->
name|ds_len
expr_stmt|;
while|while
condition|(
name|len
condition|)
block|{
name|flags_next
operator|=
name|flags
operator|&
operator|~
name|MXGEFW_FLAGS_FIRST
expr_stmt|;
name|cum_len_next
operator|=
name|cum_len
operator|+
name|seglen
expr_stmt|;
operator|(
name|req
operator|-
name|rdma_count
operator|)
operator|->
name|rdma_count
operator|=
name|rdma_count
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|__predict_true
argument_list|(
name|cum_len
operator|>=
literal|0
argument_list|)
condition|)
block|{
comment|/* payload */
name|chop
operator|=
operator|(
name|cum_len_next
operator|>
name|mss
operator|)
expr_stmt|;
name|cum_len_next
operator|=
name|cum_len_next
operator|%
name|mss
expr_stmt|;
name|next_is_first
operator|=
operator|(
name|cum_len_next
operator|==
literal|0
operator|)
expr_stmt|;
name|flags
operator||=
name|chop
operator|*
name|MXGEFW_FLAGS_TSO_CHOP
expr_stmt|;
name|flags_next
operator||=
name|next_is_first
operator|*
name|MXGEFW_FLAGS_FIRST
expr_stmt|;
name|rdma_count
operator||=
operator|-
operator|(
name|chop
operator||
name|next_is_first
operator|)
expr_stmt|;
name|rdma_count
operator|+=
name|chop
operator|&
operator|!
name|next_is_first
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cum_len_next
operator|>=
literal|0
condition|)
block|{
comment|/* header ends */
name|rdma_count
operator|=
operator|-
literal|1
expr_stmt|;
name|cum_len_next
operator|=
literal|0
expr_stmt|;
name|seglen
operator|=
operator|-
name|cum_len
expr_stmt|;
name|small
operator|=
operator|(
name|mss
operator|<=
name|MXGEFW_SEND_SMALL_SIZE
operator|)
expr_stmt|;
name|flags_next
operator|=
name|MXGEFW_FLAGS_TSO_PLD
operator||
name|MXGEFW_FLAGS_FIRST
operator||
operator|(
name|small
operator|*
name|MXGEFW_FLAGS_SMALL
operator|)
expr_stmt|;
block|}
name|req
operator|->
name|addr_high
operator|=
name|high_swapped
expr_stmt|;
name|req
operator|->
name|addr_low
operator|=
name|htobe32
argument_list|(
name|low
argument_list|)
expr_stmt|;
name|req
operator|->
name|pseudo_hdr_offset
operator|=
name|pseudo_hdr_offset
expr_stmt|;
name|req
operator|->
name|pad
operator|=
literal|0
expr_stmt|;
name|req
operator|->
name|rdma_count
operator|=
literal|1
expr_stmt|;
name|req
operator|->
name|length
operator|=
name|htobe16
argument_list|(
name|seglen
argument_list|)
expr_stmt|;
name|req
operator|->
name|cksum_offset
operator|=
name|cksum_offset
expr_stmt|;
name|req
operator|->
name|flags
operator|=
name|flags
operator||
operator|(
operator|(
name|cum_len
operator|&
literal|1
operator|)
operator|*
name|MXGEFW_FLAGS_ALIGN_ODD
operator|)
expr_stmt|;
name|low
operator|+=
name|seglen
expr_stmt|;
name|len
operator|-=
name|seglen
expr_stmt|;
name|cum_len
operator|=
name|cum_len_next
expr_stmt|;
name|flags
operator|=
name|flags_next
expr_stmt|;
name|req
operator|++
expr_stmt|;
name|cnt
operator|++
expr_stmt|;
name|rdma_count
operator|++
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|cksum_offset
operator|>
name|seglen
argument_list|)
condition|)
name|cksum_offset
operator|-=
name|seglen
expr_stmt|;
else|else
name|cksum_offset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|cnt
operator|>
name|MXGE_MAX_SEND_DESC
argument_list|)
condition|)
goto|goto
name|drop
goto|;
block|}
name|busdma_seg_cnt
operator|--
expr_stmt|;
name|seg
operator|++
expr_stmt|;
block|}
operator|(
name|req
operator|-
name|rdma_count
operator|)
operator|->
name|rdma_count
operator|=
name|rdma_count
expr_stmt|;
do|do
block|{
name|req
operator|--
expr_stmt|;
name|req
operator|->
name|flags
operator||=
name|MXGEFW_FLAGS_TSO_LAST
expr_stmt|;
block|}
do|while
condition|(
operator|!
operator|(
name|req
operator|->
name|flags
operator|&
operator|(
name|MXGEFW_FLAGS_TSO_CHOP
operator||
name|MXGEFW_FLAGS_FIRST
operator|)
operator|)
condition|)
do|;
name|tx
operator|->
name|info
index|[
operator|(
operator|(
name|cnt
operator|-
literal|1
operator|)
operator|+
name|tx
operator|->
name|req
operator|)
operator|&
name|tx
operator|->
name|mask
index|]
operator|.
name|flag
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|tx
operator|->
name|wc_fifo
operator|==
name|NULL
condition|)
name|mxge_submit_req
argument_list|(
name|tx
argument_list|,
name|tx
operator|->
name|req_list
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
else|else
name|mxge_submit_req_wc
argument_list|(
name|tx
argument_list|,
name|tx
operator|->
name|req_list
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
return|return;
name|drop
label|:
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|once
condition|)
block|{
name|printf
argument_list|(
literal|"MXGE_MAX_SEND_DESC exceeded via TSO!\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"mss = %d, %ld!\n"
argument_list|,
name|mss
argument_list|,
operator|(
name|long
operator|)
name|seg
operator|-
operator|(
name|long
operator|)
name|tx
operator|->
name|seg_list
argument_list|)
expr_stmt|;
name|once
operator|=
literal|1
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|mxge_encap
parameter_list|(
name|mxge_softc_t
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|mcp_kreq_ether_send_t
modifier|*
name|req
decl_stmt|;
name|bus_dma_segment_t
modifier|*
name|seg
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m_tmp
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|mxge_tx_buf_t
modifier|*
name|tx
decl_stmt|;
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|int
name|cnt
decl_stmt|,
name|cum_len
decl_stmt|,
name|err
decl_stmt|,
name|i
decl_stmt|,
name|idx
decl_stmt|,
name|odd_flag
decl_stmt|;
name|uint16_t
name|pseudo_hdr_offset
decl_stmt|;
name|uint8_t
name|flags
decl_stmt|,
name|cksum_offset
decl_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|ifp
expr_stmt|;
name|tx
operator|=
operator|&
name|sc
operator|->
name|tx
expr_stmt|;
comment|/* (try to) map the frame for DMA */
name|idx
operator|=
name|tx
operator|->
name|req
operator|&
name|tx
operator|->
name|mask
expr_stmt|;
name|err
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|tx
operator|->
name|dmat
argument_list|,
name|tx
operator|->
name|info
index|[
name|idx
index|]
operator|.
name|map
argument_list|,
name|m
argument_list|,
name|tx
operator|->
name|seg_list
argument_list|,
operator|&
name|cnt
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|EFBIG
condition|)
block|{
comment|/* Too many segments in the chain.  Try 		   to defrag */
name|m_tmp
operator|=
name|m_defrag
argument_list|(
name|m
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_tmp
operator|==
name|NULL
condition|)
block|{
goto|goto
name|drop
goto|;
block|}
name|m
operator|=
name|m_tmp
expr_stmt|;
name|err
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|tx
operator|->
name|dmat
argument_list|,
name|tx
operator|->
name|info
index|[
name|idx
index|]
operator|.
name|map
argument_list|,
name|m
argument_list|,
name|tx
operator|->
name|seg_list
argument_list|,
operator|&
name|cnt
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"bus_dmamap_load_mbuf_sg returned %d"
literal|" packet len = %d\n"
argument_list|,
name|err
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
goto|goto
name|drop
goto|;
block|}
name|bus_dmamap_sync
argument_list|(
name|tx
operator|->
name|dmat
argument_list|,
name|tx
operator|->
name|info
index|[
name|idx
index|]
operator|.
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|tx
operator|->
name|info
index|[
name|idx
index|]
operator|.
name|m
operator|=
name|m
expr_stmt|;
comment|/* TSO is different enough, we handle it in another routine */
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
operator|(
name|CSUM_TSO
operator|)
condition|)
block|{
name|mxge_encap_tso
argument_list|(
name|sc
argument_list|,
name|m
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
return|return;
block|}
name|req
operator|=
name|tx
operator|->
name|req_list
expr_stmt|;
name|cksum_offset
operator|=
literal|0
expr_stmt|;
name|pseudo_hdr_offset
operator|=
literal|0
expr_stmt|;
name|flags
operator|=
name|MXGEFW_FLAGS_NO_TSO
expr_stmt|;
comment|/* checksum offloading? */
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
operator|(
name|CSUM_DELAY_DATA
operator|)
condition|)
block|{
comment|/* ensure ip header is in first mbuf, copy 		   it to a scratch buffer if not */
if|if
condition|(
name|__predict_false
argument_list|(
name|m
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|eh
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|ip
argument_list|)
argument_list|)
condition|)
block|{
name|m_copydata
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|eh
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|ip
argument_list|)
argument_list|,
name|sc
operator|->
name|scratch
argument_list|)
expr_stmt|;
name|eh
operator|=
operator|(
expr|struct
name|ether_header
operator|*
operator|)
name|sc
operator|->
name|scratch
expr_stmt|;
block|}
else|else
block|{
name|eh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
block|}
name|ip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
operator|(
name|eh
operator|+
literal|1
operator|)
expr_stmt|;
name|cksum_offset
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|eh
argument_list|)
operator|+
operator|(
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
operator|)
expr_stmt|;
name|pseudo_hdr_offset
operator|=
name|cksum_offset
operator|+
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_data
expr_stmt|;
name|pseudo_hdr_offset
operator|=
name|htobe16
argument_list|(
name|pseudo_hdr_offset
argument_list|)
expr_stmt|;
name|req
operator|->
name|cksum_offset
operator|=
name|cksum_offset
expr_stmt|;
name|flags
operator||=
name|MXGEFW_FLAGS_CKSUM
expr_stmt|;
name|odd_flag
operator|=
name|MXGEFW_FLAGS_ALIGN_ODD
expr_stmt|;
block|}
else|else
block|{
name|odd_flag
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|<
name|MXGEFW_SEND_SMALL_SIZE
condition|)
name|flags
operator||=
name|MXGEFW_FLAGS_SMALL
expr_stmt|;
comment|/* convert segments into a request list */
name|cum_len
operator|=
literal|0
expr_stmt|;
name|seg
operator|=
name|tx
operator|->
name|seg_list
expr_stmt|;
name|req
operator|->
name|flags
operator|=
name|MXGEFW_FLAGS_FIRST
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cnt
condition|;
name|i
operator|++
control|)
block|{
name|req
operator|->
name|addr_low
operator|=
name|htobe32
argument_list|(
name|MXGE_LOWPART_TO_U32
argument_list|(
name|seg
operator|->
name|ds_addr
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|->
name|addr_high
operator|=
name|htobe32
argument_list|(
name|MXGE_HIGHPART_TO_U32
argument_list|(
name|seg
operator|->
name|ds_addr
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|->
name|length
operator|=
name|htobe16
argument_list|(
name|seg
operator|->
name|ds_len
argument_list|)
expr_stmt|;
name|req
operator|->
name|cksum_offset
operator|=
name|cksum_offset
expr_stmt|;
if|if
condition|(
name|cksum_offset
operator|>
name|seg
operator|->
name|ds_len
condition|)
name|cksum_offset
operator|-=
name|seg
operator|->
name|ds_len
expr_stmt|;
else|else
name|cksum_offset
operator|=
literal|0
expr_stmt|;
name|req
operator|->
name|pseudo_hdr_offset
operator|=
name|pseudo_hdr_offset
expr_stmt|;
name|req
operator|->
name|pad
operator|=
literal|0
expr_stmt|;
comment|/* complete solid 16-byte block */
name|req
operator|->
name|rdma_count
operator|=
literal|1
expr_stmt|;
name|req
operator|->
name|flags
operator||=
name|flags
operator||
operator|(
operator|(
name|cum_len
operator|&
literal|1
operator|)
operator|*
name|odd_flag
operator|)
expr_stmt|;
name|cum_len
operator|+=
name|seg
operator|->
name|ds_len
expr_stmt|;
name|seg
operator|++
expr_stmt|;
name|req
operator|++
expr_stmt|;
name|req
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
block|}
name|req
operator|--
expr_stmt|;
comment|/* pad runts to 60 bytes */
if|if
condition|(
name|cum_len
operator|<
literal|60
condition|)
block|{
name|req
operator|++
expr_stmt|;
name|req
operator|->
name|addr_low
operator|=
name|htobe32
argument_list|(
name|MXGE_LOWPART_TO_U32
argument_list|(
name|sc
operator|->
name|zeropad_dma
operator|.
name|bus_addr
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|->
name|addr_high
operator|=
name|htobe32
argument_list|(
name|MXGE_HIGHPART_TO_U32
argument_list|(
name|sc
operator|->
name|zeropad_dma
operator|.
name|bus_addr
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|->
name|length
operator|=
name|htobe16
argument_list|(
literal|60
operator|-
name|cum_len
argument_list|)
expr_stmt|;
name|req
operator|->
name|cksum_offset
operator|=
literal|0
expr_stmt|;
name|req
operator|->
name|pseudo_hdr_offset
operator|=
name|pseudo_hdr_offset
expr_stmt|;
name|req
operator|->
name|pad
operator|=
literal|0
expr_stmt|;
comment|/* complete solid 16-byte block */
name|req
operator|->
name|rdma_count
operator|=
literal|1
expr_stmt|;
name|req
operator|->
name|flags
operator||=
name|flags
operator||
operator|(
operator|(
name|cum_len
operator|&
literal|1
operator|)
operator|*
name|odd_flag
operator|)
expr_stmt|;
name|cnt
operator|++
expr_stmt|;
block|}
name|tx
operator|->
name|req_list
index|[
literal|0
index|]
operator|.
name|rdma_count
operator|=
name|cnt
expr_stmt|;
if|#
directive|if
literal|0
comment|/* print what the firmware will see */
block|for (i = 0; i< cnt; i++) { 		printf("%d: addr: 0x%x 0x%x len:%d pso%d," 		    "cso:%d, flags:0x%x, rdma:%d\n", 		    i, (int)ntohl(tx->req_list[i].addr_high), 		    (int)ntohl(tx->req_list[i].addr_low), 		    (int)ntohs(tx->req_list[i].length), 		    (int)ntohs(tx->req_list[i].pseudo_hdr_offset), 		    tx->req_list[i].cksum_offset, tx->req_list[i].flags, 		    tx->req_list[i].rdma_count); 	} 	printf("--------------\n");
endif|#
directive|endif
name|tx
operator|->
name|info
index|[
operator|(
operator|(
name|cnt
operator|-
literal|1
operator|)
operator|+
name|tx
operator|->
name|req
operator|)
operator|&
name|tx
operator|->
name|mask
index|]
operator|.
name|flag
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|tx
operator|->
name|wc_fifo
operator|==
name|NULL
condition|)
name|mxge_submit_req
argument_list|(
name|tx
argument_list|,
name|tx
operator|->
name|req_list
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
else|else
name|mxge_submit_req_wc
argument_list|(
name|tx
argument_list|,
name|tx
operator|->
name|req_list
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
return|return;
name|drop
label|:
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|mxge_start_locked
parameter_list|(
name|mxge_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|ifp
expr_stmt|;
while|while
condition|(
operator|(
name|sc
operator|->
name|tx
operator|.
name|mask
operator|-
operator|(
name|sc
operator|->
name|tx
operator|.
name|req
operator|-
name|sc
operator|->
name|tx
operator|.
name|done
operator|)
operator|)
operator|>
name|MXGE_MAX_SEND_DESC
condition|)
block|{
name|IFQ_DRV_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
comment|/* let BPF see it */
name|BPF_MTAP
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* give it to the nic */
name|mxge_encap
argument_list|(
name|sc
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
comment|/* ran out of transmit slots */
if|if
condition|(
operator|(
name|sc
operator|->
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_OACTIVE
operator|)
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_OACTIVE
expr_stmt|;
name|sc
operator|->
name|tx
operator|.
name|stall
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|mxge_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|mxge_softc_t
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|tx_lock
argument_list|)
expr_stmt|;
name|mxge_start_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|tx_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * copy an array of mcp_kreq_ether_recv_t's to the mcp.  Copy  * at most 32 bytes at a time, so as to avoid involving the software  * pio handler in the nic.   We re-write the first segment's low  * DMA address to mark it valid only after we write the entire chunk  * in a burst  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|mxge_submit_8rx
parameter_list|(
specifier|volatile
name|mcp_kreq_ether_recv_t
modifier|*
name|dst
parameter_list|,
name|mcp_kreq_ether_recv_t
modifier|*
name|src
parameter_list|)
block|{
name|uint32_t
name|low
decl_stmt|;
name|low
operator|=
name|src
operator|->
name|addr_low
expr_stmt|;
name|src
operator|->
name|addr_low
operator|=
literal|0xffffffff
expr_stmt|;
name|mxge_pio_copy
argument_list|(
name|dst
argument_list|,
name|src
argument_list|,
literal|4
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|src
argument_list|)
argument_list|)
expr_stmt|;
name|mb
argument_list|()
expr_stmt|;
name|mxge_pio_copy
argument_list|(
name|dst
operator|+
literal|4
argument_list|,
name|src
operator|+
literal|4
argument_list|,
literal|4
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|src
argument_list|)
argument_list|)
expr_stmt|;
name|mb
argument_list|()
expr_stmt|;
name|dst
operator|->
name|addr_low
operator|=
name|low
expr_stmt|;
name|mb
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|mxge_get_buf_small
parameter_list|(
name|mxge_softc_t
modifier|*
name|sc
parameter_list|,
name|bus_dmamap_t
name|map
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
name|bus_dma_segment_t
name|seg
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|mxge_rx_buf_t
modifier|*
name|rx
init|=
operator|&
name|sc
operator|->
name|rx_small
decl_stmt|;
name|int
name|cnt
decl_stmt|,
name|err
decl_stmt|;
name|m
operator|=
name|m_gethdr
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|rx
operator|->
name|alloc_fail
operator|++
expr_stmt|;
name|err
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|m
operator|->
name|m_len
operator|=
name|MHLEN
expr_stmt|;
name|err
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|rx
operator|->
name|dmat
argument_list|,
name|map
argument_list|,
name|m
argument_list|,
operator|&
name|seg
argument_list|,
operator|&
name|cnt
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|rx
operator|->
name|info
index|[
name|idx
index|]
operator|.
name|m
operator|=
name|m
expr_stmt|;
name|rx
operator|->
name|shadow
index|[
name|idx
index|]
operator|.
name|addr_low
operator|=
name|htobe32
argument_list|(
name|MXGE_LOWPART_TO_U32
argument_list|(
name|seg
operator|.
name|ds_addr
argument_list|)
argument_list|)
expr_stmt|;
name|rx
operator|->
name|shadow
index|[
name|idx
index|]
operator|.
name|addr_high
operator|=
name|htobe32
argument_list|(
name|MXGE_HIGHPART_TO_U32
argument_list|(
name|seg
operator|.
name|ds_addr
argument_list|)
argument_list|)
expr_stmt|;
name|done
label|:
if|if
condition|(
operator|(
name|idx
operator|&
literal|7
operator|)
operator|==
literal|7
condition|)
block|{
if|if
condition|(
name|rx
operator|->
name|wc_fifo
operator|==
name|NULL
condition|)
name|mxge_submit_8rx
argument_list|(
operator|&
name|rx
operator|->
name|lanai
index|[
name|idx
operator|-
literal|7
index|]
argument_list|,
operator|&
name|rx
operator|->
name|shadow
index|[
name|idx
operator|-
literal|7
index|]
argument_list|)
expr_stmt|;
else|else
block|{
name|mb
argument_list|()
expr_stmt|;
name|mxge_pio_copy
argument_list|(
name|rx
operator|->
name|wc_fifo
argument_list|,
operator|&
name|rx
operator|->
name|shadow
index|[
name|idx
operator|-
literal|7
index|]
argument_list|,
literal|64
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mxge_get_buf_big
parameter_list|(
name|mxge_softc_t
modifier|*
name|sc
parameter_list|,
name|bus_dmamap_t
name|map
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
name|bus_dma_segment_t
name|seg
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|mxge_rx_buf_t
modifier|*
name|rx
init|=
operator|&
name|sc
operator|->
name|rx_big
decl_stmt|;
name|int
name|cnt
decl_stmt|,
name|err
decl_stmt|;
name|m
operator|=
name|m_getjcl
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|,
name|sc
operator|->
name|big_bytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|rx
operator|->
name|alloc_fail
operator|++
expr_stmt|;
name|err
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|m
operator|->
name|m_len
operator|=
name|sc
operator|->
name|big_bytes
expr_stmt|;
name|err
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|rx
operator|->
name|dmat
argument_list|,
name|map
argument_list|,
name|m
argument_list|,
operator|&
name|seg
argument_list|,
operator|&
name|cnt
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|rx
operator|->
name|info
index|[
name|idx
index|]
operator|.
name|m
operator|=
name|m
expr_stmt|;
name|rx
operator|->
name|shadow
index|[
name|idx
index|]
operator|.
name|addr_low
operator|=
name|htobe32
argument_list|(
name|MXGE_LOWPART_TO_U32
argument_list|(
name|seg
operator|.
name|ds_addr
argument_list|)
argument_list|)
expr_stmt|;
name|rx
operator|->
name|shadow
index|[
name|idx
index|]
operator|.
name|addr_high
operator|=
name|htobe32
argument_list|(
name|MXGE_HIGHPART_TO_U32
argument_list|(
name|seg
operator|.
name|ds_addr
argument_list|)
argument_list|)
expr_stmt|;
name|done
label|:
if|if
condition|(
operator|(
name|idx
operator|&
literal|7
operator|)
operator|==
literal|7
condition|)
block|{
if|if
condition|(
name|rx
operator|->
name|wc_fifo
operator|==
name|NULL
condition|)
name|mxge_submit_8rx
argument_list|(
operator|&
name|rx
operator|->
name|lanai
index|[
name|idx
operator|-
literal|7
index|]
argument_list|,
operator|&
name|rx
operator|->
name|shadow
index|[
name|idx
operator|-
literal|7
index|]
argument_list|)
expr_stmt|;
else|else
block|{
name|mb
argument_list|()
expr_stmt|;
name|mxge_pio_copy
argument_list|(
name|rx
operator|->
name|wc_fifo
argument_list|,
operator|&
name|rx
operator|->
name|shadow
index|[
name|idx
operator|-
literal|7
index|]
argument_list|,
literal|64
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|mxge_rx_csum
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|csum
parameter_list|)
block|{
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|eh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_true
argument_list|(
name|eh
operator|->
name|ether_type
operator|==
name|htons
argument_list|(
name|ETHERTYPE_IP
argument_list|)
argument_list|)
condition|)
block|{
name|ip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
operator|(
name|eh
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|__predict_true
argument_list|(
name|ip
operator|->
name|ip_p
operator|==
name|IPPROTO_TCP
operator|||
name|ip
operator|->
name|ip_p
operator|==
name|IPPROTO_UDP
argument_list|)
condition|)
block|{
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|=
name|csum
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|=
name|CSUM_DATA_VALID
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|mxge_rx_done_big
parameter_list|(
name|mxge_softc_t
modifier|*
name|sc
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|csum
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
init|=
literal|0
decl_stmt|;
comment|/* -Wunitialized */
name|struct
name|mbuf
modifier|*
name|m_prev
init|=
literal|0
decl_stmt|;
comment|/* -Wunitialized */
name|struct
name|mbuf
modifier|*
name|m_head
init|=
literal|0
decl_stmt|;
name|bus_dmamap_t
name|old_map
decl_stmt|;
name|mxge_rx_buf_t
modifier|*
name|rx
decl_stmt|;
name|int
name|idx
decl_stmt|;
name|rx
operator|=
operator|&
name|sc
operator|->
name|rx_big
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|ifp
expr_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|idx
operator|=
name|rx
operator|->
name|cnt
operator|&
name|rx
operator|->
name|mask
expr_stmt|;
name|rx
operator|->
name|cnt
operator|++
expr_stmt|;
comment|/* save a pointer to the received mbuf */
name|m
operator|=
name|rx
operator|->
name|info
index|[
name|idx
index|]
operator|.
name|m
expr_stmt|;
comment|/* try to replace the received mbuf */
if|if
condition|(
name|mxge_get_buf_big
argument_list|(
name|sc
argument_list|,
name|rx
operator|->
name|extra_map
argument_list|,
name|idx
argument_list|)
condition|)
block|{
goto|goto
name|drop
goto|;
block|}
comment|/* unmap the received buffer */
name|old_map
operator|=
name|rx
operator|->
name|info
index|[
name|idx
index|]
operator|.
name|map
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|rx
operator|->
name|dmat
argument_list|,
name|old_map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|rx
operator|->
name|dmat
argument_list|,
name|old_map
argument_list|)
expr_stmt|;
comment|/* swap the bus_dmamap_t's */
name|rx
operator|->
name|info
index|[
name|idx
index|]
operator|.
name|map
operator|=
name|rx
operator|->
name|extra_map
expr_stmt|;
name|rx
operator|->
name|extra_map
operator|=
name|old_map
expr_stmt|;
comment|/* chain multiple segments together */
if|if
condition|(
operator|!
name|m_head
condition|)
block|{
name|m_head
operator|=
name|m
expr_stmt|;
comment|/* mcp implicitly skips 1st bytes so that 			 * packet is properly aligned */
name|m
operator|->
name|m_data
operator|+=
name|MXGEFW_PAD
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|len
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|sc
operator|->
name|big_bytes
operator|-
name|MXGEFW_PAD
expr_stmt|;
block|}
else|else
block|{
name|m
operator|->
name|m_len
operator|=
name|sc
operator|->
name|big_bytes
expr_stmt|;
name|m
operator|->
name|m_flags
operator|&=
operator|~
name|M_PKTHDR
expr_stmt|;
name|m_prev
operator|->
name|m_next
operator|=
name|m
expr_stmt|;
block|}
name|len
operator|-=
name|m
operator|->
name|m_len
expr_stmt|;
name|m_prev
operator|=
name|m
expr_stmt|;
block|}
comment|/* trim trailing garbage from the last mbuf in the chain.  If 	 * there is any garbage, len will be negative */
name|m
operator|->
name|m_len
operator|+=
name|len
expr_stmt|;
comment|/* if the checksum is valid, mark it in the mbuf header */
if|if
condition|(
name|sc
operator|->
name|csum_flag
condition|)
name|mxge_rx_csum
argument_list|(
name|m_head
argument_list|,
name|csum
argument_list|)
expr_stmt|;
comment|/* pass the frame up the stack */
name|m_head
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
name|ifp
operator|->
name|if_ipackets
operator|++
expr_stmt|;
call|(
modifier|*
name|ifp
operator|->
name|if_input
call|)
argument_list|(
name|ifp
argument_list|,
name|m_head
argument_list|)
expr_stmt|;
return|return;
name|drop
label|:
comment|/* drop the frame -- the old mbuf(s) are re-cycled by running 	   every slot through the allocator */
if|if
condition|(
name|m_head
condition|)
block|{
name|len
operator|-=
name|sc
operator|->
name|big_bytes
expr_stmt|;
name|m_freem
argument_list|(
name|m_head
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|len
operator|-=
operator|(
name|sc
operator|->
name|big_bytes
operator|+
name|MXGEFW_PAD
operator|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|int
operator|)
name|len
operator|>
literal|0
condition|)
block|{
name|idx
operator|=
name|rx
operator|->
name|cnt
operator|&
name|rx
operator|->
name|mask
expr_stmt|;
name|rx
operator|->
name|cnt
operator|++
expr_stmt|;
name|m
operator|=
name|rx
operator|->
name|info
index|[
name|idx
index|]
operator|.
name|m
expr_stmt|;
if|if
condition|(
literal|0
operator|==
operator|(
name|mxge_get_buf_big
argument_list|(
name|sc
argument_list|,
name|rx
operator|->
name|extra_map
argument_list|,
name|idx
argument_list|)
operator|)
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* unmap the received buffer */
name|old_map
operator|=
name|rx
operator|->
name|info
index|[
name|idx
index|]
operator|.
name|map
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|rx
operator|->
name|dmat
argument_list|,
name|old_map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|rx
operator|->
name|dmat
argument_list|,
name|old_map
argument_list|)
expr_stmt|;
comment|/* swap the bus_dmamap_t's */
name|rx
operator|->
name|info
index|[
name|idx
index|]
operator|.
name|map
operator|=
name|rx
operator|->
name|extra_map
expr_stmt|;
name|rx
operator|->
name|extra_map
operator|=
name|old_map
expr_stmt|;
block|}
name|len
operator|-=
name|sc
operator|->
name|big_bytes
expr_stmt|;
block|}
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|mxge_rx_done_small
parameter_list|(
name|mxge_softc_t
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|len
parameter_list|,
name|uint32_t
name|csum
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|mxge_rx_buf_t
modifier|*
name|rx
decl_stmt|;
name|bus_dmamap_t
name|old_map
decl_stmt|;
name|int
name|idx
decl_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|ifp
expr_stmt|;
name|rx
operator|=
operator|&
name|sc
operator|->
name|rx_small
expr_stmt|;
name|idx
operator|=
name|rx
operator|->
name|cnt
operator|&
name|rx
operator|->
name|mask
expr_stmt|;
name|rx
operator|->
name|cnt
operator|++
expr_stmt|;
comment|/* save a pointer to the received mbuf */
name|m
operator|=
name|rx
operator|->
name|info
index|[
name|idx
index|]
operator|.
name|m
expr_stmt|;
comment|/* try to replace the received mbuf */
if|if
condition|(
name|mxge_get_buf_small
argument_list|(
name|sc
argument_list|,
name|rx
operator|->
name|extra_map
argument_list|,
name|idx
argument_list|)
condition|)
block|{
comment|/* drop the frame -- the old mbuf is re-cycled */
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
return|return;
block|}
comment|/* unmap the received buffer */
name|old_map
operator|=
name|rx
operator|->
name|info
index|[
name|idx
index|]
operator|.
name|map
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|rx
operator|->
name|dmat
argument_list|,
name|old_map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|rx
operator|->
name|dmat
argument_list|,
name|old_map
argument_list|)
expr_stmt|;
comment|/* swap the bus_dmamap_t's */
name|rx
operator|->
name|info
index|[
name|idx
index|]
operator|.
name|map
operator|=
name|rx
operator|->
name|extra_map
expr_stmt|;
name|rx
operator|->
name|extra_map
operator|=
name|old_map
expr_stmt|;
comment|/* mcp implicitly skips 1st 2 bytes so that packet is properly 	 * aligned */
name|m
operator|->
name|m_data
operator|+=
name|MXGEFW_PAD
expr_stmt|;
comment|/* if the checksum is valid, mark it in the mbuf header */
if|if
condition|(
name|sc
operator|->
name|csum_flag
condition|)
name|mxge_rx_csum
argument_list|(
name|m
argument_list|,
name|csum
argument_list|)
expr_stmt|;
comment|/* pass the frame up the stack */
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|len
expr_stmt|;
name|ifp
operator|->
name|if_ipackets
operator|++
expr_stmt|;
call|(
modifier|*
name|ifp
operator|->
name|if_input
call|)
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|mxge_clean_rx_done
parameter_list|(
name|mxge_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|mxge_rx_done_t
modifier|*
name|rx_done
init|=
operator|&
name|sc
operator|->
name|rx_done
decl_stmt|;
name|int
name|limit
init|=
literal|0
decl_stmt|;
name|uint16_t
name|length
decl_stmt|;
name|uint16_t
name|checksum
decl_stmt|;
while|while
condition|(
name|rx_done
operator|->
name|entry
index|[
name|rx_done
operator|->
name|idx
index|]
operator|.
name|length
operator|!=
literal|0
condition|)
block|{
name|length
operator|=
name|ntohs
argument_list|(
name|rx_done
operator|->
name|entry
index|[
name|rx_done
operator|->
name|idx
index|]
operator|.
name|length
argument_list|)
expr_stmt|;
name|rx_done
operator|->
name|entry
index|[
name|rx_done
operator|->
name|idx
index|]
operator|.
name|length
operator|=
literal|0
expr_stmt|;
name|checksum
operator|=
name|ntohs
argument_list|(
name|rx_done
operator|->
name|entry
index|[
name|rx_done
operator|->
name|idx
index|]
operator|.
name|checksum
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|<=
operator|(
name|MHLEN
operator|-
name|MXGEFW_PAD
operator|)
condition|)
name|mxge_rx_done_small
argument_list|(
name|sc
argument_list|,
name|length
argument_list|,
name|checksum
argument_list|)
expr_stmt|;
else|else
name|mxge_rx_done_big
argument_list|(
name|sc
argument_list|,
name|length
argument_list|,
name|checksum
argument_list|)
expr_stmt|;
name|rx_done
operator|->
name|cnt
operator|++
expr_stmt|;
name|rx_done
operator|->
name|idx
operator|=
name|rx_done
operator|->
name|cnt
operator|&
operator|(
name|mxge_max_intr_slots
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* limit potential for livelock */
if|if
condition|(
name|__predict_false
argument_list|(
operator|++
name|limit
operator|>
literal|2
operator|*
name|mxge_max_intr_slots
argument_list|)
condition|)
break|break;
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|mxge_tx_done
parameter_list|(
name|mxge_softc_t
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|mcp_idx
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|mxge_tx_buf_t
modifier|*
name|tx
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|bus_dmamap_t
name|map
decl_stmt|;
name|int
name|idx
decl_stmt|,
name|limit
decl_stmt|;
name|limit
operator|=
literal|0
expr_stmt|;
name|tx
operator|=
operator|&
name|sc
operator|->
name|tx
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|ifp
expr_stmt|;
while|while
condition|(
name|tx
operator|->
name|pkt_done
operator|!=
name|mcp_idx
condition|)
block|{
name|idx
operator|=
name|tx
operator|->
name|done
operator|&
name|tx
operator|->
name|mask
expr_stmt|;
name|tx
operator|->
name|done
operator|++
expr_stmt|;
name|m
operator|=
name|tx
operator|->
name|info
index|[
name|idx
index|]
operator|.
name|m
expr_stmt|;
comment|/* mbuf and DMA map only attached to the first 		   segment per-mbuf */
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
name|ifp
operator|->
name|if_opackets
operator|++
expr_stmt|;
name|tx
operator|->
name|info
index|[
name|idx
index|]
operator|.
name|m
operator|=
name|NULL
expr_stmt|;
name|map
operator|=
name|tx
operator|->
name|info
index|[
name|idx
index|]
operator|.
name|map
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|tx
operator|->
name|dmat
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tx
operator|->
name|info
index|[
name|idx
index|]
operator|.
name|flag
condition|)
block|{
name|tx
operator|->
name|info
index|[
name|idx
index|]
operator|.
name|flag
operator|=
literal|0
expr_stmt|;
name|tx
operator|->
name|pkt_done
operator|++
expr_stmt|;
block|}
comment|/* limit potential for livelock by only handling 		   2 full tx rings per call */
if|if
condition|(
name|__predict_false
argument_list|(
operator|++
name|limit
operator|>
literal|2
operator|*
name|tx
operator|->
name|mask
argument_list|)
condition|)
break|break;
block|}
comment|/* If we have space, clear IFF_OACTIVE to tell the stack that            its OK to send packets */
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_OACTIVE
operator|&&
name|tx
operator|->
name|req
operator|-
name|tx
operator|->
name|done
operator|<
operator|(
name|tx
operator|->
name|mask
operator|+
literal|1
operator|)
operator|/
literal|4
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|tx_lock
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
name|sc
operator|->
name|tx
operator|.
name|wake
operator|++
expr_stmt|;
name|mxge_start_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|tx_lock
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|mxge_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|mxge_softc_t
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|mcp_irq_data_t
modifier|*
name|stats
init|=
name|sc
operator|->
name|fw_stats
decl_stmt|;
name|mxge_tx_buf_t
modifier|*
name|tx
init|=
operator|&
name|sc
operator|->
name|tx
decl_stmt|;
name|mxge_rx_done_t
modifier|*
name|rx_done
init|=
operator|&
name|sc
operator|->
name|rx_done
decl_stmt|;
name|uint32_t
name|send_done_count
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
comment|/* make sure the DMA has finished */
if|if
condition|(
operator|!
name|stats
operator|->
name|valid
condition|)
block|{
return|return;
block|}
name|valid
operator|=
name|stats
operator|->
name|valid
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|msi_enabled
condition|)
block|{
comment|/* lower legacy IRQ  */
operator|*
name|sc
operator|->
name|irq_deassert
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|mxge_deassert_wait
condition|)
comment|/* don't wait for conf. that irq is low */
name|stats
operator|->
name|valid
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|stats
operator|->
name|valid
operator|=
literal|0
expr_stmt|;
block|}
comment|/* loop while waiting for legacy irq deassertion */
do|do
block|{
comment|/* check for transmit completes and receives */
name|send_done_count
operator|=
name|be32toh
argument_list|(
name|stats
operator|->
name|send_done_count
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|send_done_count
operator|!=
name|tx
operator|->
name|pkt_done
operator|)
operator|||
operator|(
name|rx_done
operator|->
name|entry
index|[
name|rx_done
operator|->
name|idx
index|]
operator|.
name|length
operator|!=
literal|0
operator|)
condition|)
block|{
name|mxge_tx_done
argument_list|(
name|sc
argument_list|,
operator|(
name|int
operator|)
name|send_done_count
argument_list|)
expr_stmt|;
name|mxge_clean_rx_done
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|send_done_count
operator|=
name|be32toh
argument_list|(
name|stats
operator|->
name|send_done_count
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|*
operator|(
operator|(
specifier|volatile
name|uint8_t
operator|*
operator|)
operator|&
name|stats
operator|->
name|valid
operator|)
condition|)
do|;
if|if
condition|(
name|__predict_false
argument_list|(
name|stats
operator|->
name|stats_updated
argument_list|)
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|link_state
operator|!=
name|stats
operator|->
name|link_up
condition|)
block|{
name|sc
operator|->
name|link_state
operator|=
name|stats
operator|->
name|link_up
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|link_state
condition|)
block|{
name|if_link_state_change
argument_list|(
name|sc
operator|->
name|ifp
argument_list|,
name|LINK_STATE_UP
argument_list|)
expr_stmt|;
if|if
condition|(
name|mxge_verbose
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"link up\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|if_link_state_change
argument_list|(
name|sc
operator|->
name|ifp
argument_list|,
name|LINK_STATE_DOWN
argument_list|)
expr_stmt|;
if|if
condition|(
name|mxge_verbose
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"link down\n"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sc
operator|->
name|rdma_tags_available
operator|!=
name|be32toh
argument_list|(
name|sc
operator|->
name|fw_stats
operator|->
name|rdma_tags_available
argument_list|)
condition|)
block|{
name|sc
operator|->
name|rdma_tags_available
operator|=
name|be32toh
argument_list|(
name|sc
operator|->
name|fw_stats
operator|->
name|rdma_tags_available
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"RDMA timed out! %d tags "
literal|"left\n"
argument_list|,
name|sc
operator|->
name|rdma_tags_available
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|down_cnt
operator|+=
name|stats
operator|->
name|link_down
expr_stmt|;
block|}
comment|/* check to see if we have rx token to pass back */
if|if
condition|(
name|valid
operator|&
literal|0x1
condition|)
operator|*
name|sc
operator|->
name|irq_claim
operator|=
name|be32toh
argument_list|(
literal|3
argument_list|)
expr_stmt|;
operator|*
operator|(
name|sc
operator|->
name|irq_claim
operator|+
literal|1
operator|)
operator|=
name|be32toh
argument_list|(
literal|3
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mxge_watchdog
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|printf
argument_list|(
literal|"%s called\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mxge_init
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
name|void
name|mxge_free_mbufs
parameter_list|(
name|mxge_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|sc
operator|->
name|rx_big
operator|.
name|mask
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|rx_big
operator|.
name|info
index|[
name|i
index|]
operator|.
name|m
operator|==
name|NULL
condition|)
continue|continue;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|rx_big
operator|.
name|dmat
argument_list|,
name|sc
operator|->
name|rx_big
operator|.
name|info
index|[
name|i
index|]
operator|.
name|map
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|sc
operator|->
name|rx_big
operator|.
name|info
index|[
name|i
index|]
operator|.
name|m
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rx_big
operator|.
name|info
index|[
name|i
index|]
operator|.
name|m
operator|=
name|NULL
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|sc
operator|->
name|rx_big
operator|.
name|mask
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|rx_big
operator|.
name|info
index|[
name|i
index|]
operator|.
name|m
operator|==
name|NULL
condition|)
continue|continue;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|rx_big
operator|.
name|dmat
argument_list|,
name|sc
operator|->
name|rx_big
operator|.
name|info
index|[
name|i
index|]
operator|.
name|map
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|sc
operator|->
name|rx_big
operator|.
name|info
index|[
name|i
index|]
operator|.
name|m
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rx_big
operator|.
name|info
index|[
name|i
index|]
operator|.
name|m
operator|=
name|NULL
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|sc
operator|->
name|tx
operator|.
name|mask
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|tx
operator|.
name|info
index|[
name|i
index|]
operator|.
name|m
operator|==
name|NULL
condition|)
continue|continue;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|tx
operator|.
name|dmat
argument_list|,
name|sc
operator|->
name|tx
operator|.
name|info
index|[
name|i
index|]
operator|.
name|map
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|sc
operator|->
name|tx
operator|.
name|info
index|[
name|i
index|]
operator|.
name|m
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tx
operator|.
name|info
index|[
name|i
index|]
operator|.
name|m
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|mxge_free_rings
parameter_list|(
name|mxge_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|tx
operator|.
name|req_bytes
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|sc
operator|->
name|tx
operator|.
name|req_bytes
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tx
operator|.
name|seg_list
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|sc
operator|->
name|tx
operator|.
name|seg_list
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|rx_small
operator|.
name|shadow
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|sc
operator|->
name|rx_small
operator|.
name|shadow
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|rx_big
operator|.
name|shadow
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|sc
operator|->
name|rx_big
operator|.
name|shadow
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tx
operator|.
name|info
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|sc
operator|->
name|tx
operator|.
name|mask
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|tx
operator|.
name|info
index|[
name|i
index|]
operator|.
name|map
operator|!=
name|NULL
condition|)
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|tx
operator|.
name|dmat
argument_list|,
name|sc
operator|->
name|tx
operator|.
name|info
index|[
name|i
index|]
operator|.
name|map
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|sc
operator|->
name|tx
operator|.
name|info
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|rx_small
operator|.
name|info
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|sc
operator|->
name|rx_small
operator|.
name|mask
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|rx_small
operator|.
name|info
index|[
name|i
index|]
operator|.
name|map
operator|!=
name|NULL
condition|)
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|rx_small
operator|.
name|dmat
argument_list|,
name|sc
operator|->
name|rx_small
operator|.
name|info
index|[
name|i
index|]
operator|.
name|map
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|sc
operator|->
name|rx_small
operator|.
name|info
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|rx_big
operator|.
name|info
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|sc
operator|->
name|rx_big
operator|.
name|mask
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|rx_big
operator|.
name|info
index|[
name|i
index|]
operator|.
name|map
operator|!=
name|NULL
condition|)
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|rx_big
operator|.
name|dmat
argument_list|,
name|sc
operator|->
name|rx_big
operator|.
name|info
index|[
name|i
index|]
operator|.
name|map
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|sc
operator|->
name|rx_big
operator|.
name|info
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|rx_big
operator|.
name|extra_map
operator|!=
name|NULL
condition|)
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|rx_big
operator|.
name|dmat
argument_list|,
name|sc
operator|->
name|rx_big
operator|.
name|extra_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|rx_small
operator|.
name|extra_map
operator|!=
name|NULL
condition|)
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|rx_small
operator|.
name|dmat
argument_list|,
name|sc
operator|->
name|rx_small
operator|.
name|extra_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tx
operator|.
name|dmat
operator|!=
name|NULL
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|tx
operator|.
name|dmat
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|rx_small
operator|.
name|dmat
operator|!=
name|NULL
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|rx_small
operator|.
name|dmat
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|rx_big
operator|.
name|dmat
operator|!=
name|NULL
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|rx_big
operator|.
name|dmat
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|mxge_alloc_rings
parameter_list|(
name|mxge_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|mxge_cmd_t
name|cmd
decl_stmt|;
name|int
name|tx_ring_size
decl_stmt|,
name|rx_ring_size
decl_stmt|;
name|int
name|tx_ring_entries
decl_stmt|,
name|rx_ring_entries
decl_stmt|;
name|int
name|i
decl_stmt|,
name|err
decl_stmt|;
name|unsigned
name|long
name|bytes
decl_stmt|;
comment|/* get ring sizes */
name|err
operator|=
name|mxge_send_cmd
argument_list|(
name|sc
argument_list|,
name|MXGEFW_CMD_GET_SEND_RING_SIZE
argument_list|,
operator|&
name|cmd
argument_list|)
expr_stmt|;
name|tx_ring_size
operator|=
name|cmd
operator|.
name|data0
expr_stmt|;
name|err
operator||=
name|mxge_send_cmd
argument_list|(
name|sc
argument_list|,
name|MXGEFW_CMD_GET_RX_RING_SIZE
argument_list|,
operator|&
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Cannot determine ring sizes\n"
argument_list|)
expr_stmt|;
goto|goto
name|abort_with_nothing
goto|;
block|}
name|rx_ring_size
operator|=
name|cmd
operator|.
name|data0
expr_stmt|;
name|tx_ring_entries
operator|=
name|tx_ring_size
operator|/
sizeof|sizeof
argument_list|(
name|mcp_kreq_ether_send_t
argument_list|)
expr_stmt|;
name|rx_ring_entries
operator|=
name|rx_ring_size
operator|/
sizeof|sizeof
argument_list|(
name|mcp_dma_addr_t
argument_list|)
expr_stmt|;
name|IFQ_SET_MAXLEN
argument_list|(
operator|&
name|sc
operator|->
name|ifp
operator|->
name|if_snd
argument_list|,
name|tx_ring_entries
operator|-
literal|1
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_drv_maxlen
operator|=
name|sc
operator|->
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_maxlen
expr_stmt|;
name|IFQ_SET_READY
argument_list|(
operator|&
name|sc
operator|->
name|ifp
operator|->
name|if_snd
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tx
operator|.
name|mask
operator|=
name|tx_ring_entries
operator|-
literal|1
expr_stmt|;
name|sc
operator|->
name|rx_small
operator|.
name|mask
operator|=
name|sc
operator|->
name|rx_big
operator|.
name|mask
operator|=
name|rx_ring_entries
operator|-
literal|1
expr_stmt|;
name|err
operator|=
name|ENOMEM
expr_stmt|;
comment|/* allocate the tx request copy block */
name|bytes
operator|=
literal|8
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|sc
operator|->
name|tx
operator|.
name|req_list
argument_list|)
operator|*
operator|(
name|MXGE_MAX_SEND_DESC
operator|+
literal|4
operator|)
expr_stmt|;
name|sc
operator|->
name|tx
operator|.
name|req_bytes
operator|=
name|malloc
argument_list|(
name|bytes
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tx
operator|.
name|req_bytes
operator|==
name|NULL
condition|)
goto|goto
name|abort_with_nothing
goto|;
comment|/* ensure req_list entries are aligned to 8 bytes */
name|sc
operator|->
name|tx
operator|.
name|req_list
operator|=
operator|(
name|mcp_kreq_ether_send_t
operator|*
operator|)
operator|(
call|(
name|unsigned
name|long
call|)
argument_list|(
name|sc
operator|->
name|tx
operator|.
name|req_bytes
operator|+
literal|7
argument_list|)
operator|&
operator|~
literal|7UL
operator|)
expr_stmt|;
comment|/* allocate the tx busdma segment list */
name|bytes
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|sc
operator|->
name|tx
operator|.
name|seg_list
argument_list|)
operator|*
name|MXGE_MAX_SEND_DESC
expr_stmt|;
name|sc
operator|->
name|tx
operator|.
name|seg_list
operator|=
operator|(
name|bus_dma_segment_t
operator|*
operator|)
name|malloc
argument_list|(
name|bytes
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tx
operator|.
name|seg_list
operator|==
name|NULL
condition|)
goto|goto
name|abort_with_alloc
goto|;
comment|/* allocate the rx shadow rings */
name|bytes
operator|=
name|rx_ring_entries
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|sc
operator|->
name|rx_small
operator|.
name|shadow
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rx_small
operator|.
name|shadow
operator|=
name|malloc
argument_list|(
name|bytes
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|rx_small
operator|.
name|shadow
operator|==
name|NULL
condition|)
goto|goto
name|abort_with_alloc
goto|;
name|bytes
operator|=
name|rx_ring_entries
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|sc
operator|->
name|rx_big
operator|.
name|shadow
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rx_big
operator|.
name|shadow
operator|=
name|malloc
argument_list|(
name|bytes
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|rx_big
operator|.
name|shadow
operator|==
name|NULL
condition|)
goto|goto
name|abort_with_alloc
goto|;
comment|/* allocate the host info rings */
name|bytes
operator|=
name|tx_ring_entries
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|sc
operator|->
name|tx
operator|.
name|info
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tx
operator|.
name|info
operator|=
name|malloc
argument_list|(
name|bytes
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tx
operator|.
name|info
operator|==
name|NULL
condition|)
goto|goto
name|abort_with_alloc
goto|;
name|bytes
operator|=
name|rx_ring_entries
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|sc
operator|->
name|rx_small
operator|.
name|info
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rx_small
operator|.
name|info
operator|=
name|malloc
argument_list|(
name|bytes
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|rx_small
operator|.
name|info
operator|==
name|NULL
condition|)
goto|goto
name|abort_with_alloc
goto|;
name|bytes
operator|=
name|rx_ring_entries
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|sc
operator|->
name|rx_big
operator|.
name|info
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rx_big
operator|.
name|info
operator|=
name|malloc
argument_list|(
name|bytes
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|rx_big
operator|.
name|info
operator|==
name|NULL
condition|)
goto|goto
name|abort_with_alloc
goto|;
comment|/* allocate the busdma resources */
name|err
operator|=
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|parent_dmat
argument_list|,
comment|/* parent */
literal|1
argument_list|,
comment|/* alignment */
name|sc
operator|->
name|tx
operator|.
name|boundary
argument_list|,
comment|/* boundary */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* low */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* high */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter */
literal|65536
operator|+
literal|256
argument_list|,
comment|/* maxsize */
name|MXGE_MAX_SEND_DESC
operator|/
literal|2
argument_list|,
comment|/* num segs */
name|sc
operator|->
name|tx
operator|.
name|boundary
argument_list|,
comment|/* maxsegsize */
name|BUS_DMA_ALLOCNOW
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* lock */
operator|&
name|sc
operator|->
name|tx
operator|.
name|dmat
argument_list|)
expr_stmt|;
comment|/* tag */
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Err %d allocating tx dmat\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
goto|goto
name|abort_with_alloc
goto|;
block|}
name|err
operator|=
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|parent_dmat
argument_list|,
comment|/* parent */
literal|1
argument_list|,
comment|/* alignment */
literal|4096
argument_list|,
comment|/* boundary */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* low */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* high */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter */
name|MHLEN
argument_list|,
comment|/* maxsize */
literal|1
argument_list|,
comment|/* num segs */
name|MHLEN
argument_list|,
comment|/* maxsegsize */
name|BUS_DMA_ALLOCNOW
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* lock */
operator|&
name|sc
operator|->
name|rx_small
operator|.
name|dmat
argument_list|)
expr_stmt|;
comment|/* tag */
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Err %d allocating rx_small dmat\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
goto|goto
name|abort_with_alloc
goto|;
block|}
name|err
operator|=
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|parent_dmat
argument_list|,
comment|/* parent */
literal|1
argument_list|,
comment|/* alignment */
literal|4096
argument_list|,
comment|/* boundary */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* low */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* high */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter */
literal|4096
argument_list|,
comment|/* maxsize */
literal|1
argument_list|,
comment|/* num segs */
literal|4096
argument_list|,
comment|/* maxsegsize */
name|BUS_DMA_ALLOCNOW
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* lock */
operator|&
name|sc
operator|->
name|rx_big
operator|.
name|dmat
argument_list|)
expr_stmt|;
comment|/* tag */
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Err %d allocating rx_big dmat\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
goto|goto
name|abort_with_alloc
goto|;
block|}
comment|/* now use these tags to setup dmamaps for each slot 	   in each ring */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|sc
operator|->
name|tx
operator|.
name|mask
condition|;
name|i
operator|++
control|)
block|{
name|err
operator|=
name|bus_dmamap_create
argument_list|(
name|sc
operator|->
name|tx
operator|.
name|dmat
argument_list|,
literal|0
argument_list|,
operator|&
name|sc
operator|->
name|tx
operator|.
name|info
index|[
name|i
index|]
operator|.
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Err %d  tx dmamap\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
goto|goto
name|abort_with_alloc
goto|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|sc
operator|->
name|rx_small
operator|.
name|mask
condition|;
name|i
operator|++
control|)
block|{
name|err
operator|=
name|bus_dmamap_create
argument_list|(
name|sc
operator|->
name|rx_small
operator|.
name|dmat
argument_list|,
literal|0
argument_list|,
operator|&
name|sc
operator|->
name|rx_small
operator|.
name|info
index|[
name|i
index|]
operator|.
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Err %d  rx_small dmamap\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
goto|goto
name|abort_with_alloc
goto|;
block|}
block|}
name|err
operator|=
name|bus_dmamap_create
argument_list|(
name|sc
operator|->
name|rx_small
operator|.
name|dmat
argument_list|,
literal|0
argument_list|,
operator|&
name|sc
operator|->
name|rx_small
operator|.
name|extra_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Err %d extra rx_small dmamap\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
goto|goto
name|abort_with_alloc
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|sc
operator|->
name|rx_big
operator|.
name|mask
condition|;
name|i
operator|++
control|)
block|{
name|err
operator|=
name|bus_dmamap_create
argument_list|(
name|sc
operator|->
name|rx_big
operator|.
name|dmat
argument_list|,
literal|0
argument_list|,
operator|&
name|sc
operator|->
name|rx_big
operator|.
name|info
index|[
name|i
index|]
operator|.
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Err %d  rx_big dmamap\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
goto|goto
name|abort_with_alloc
goto|;
block|}
block|}
name|err
operator|=
name|bus_dmamap_create
argument_list|(
name|sc
operator|->
name|rx_big
operator|.
name|dmat
argument_list|,
literal|0
argument_list|,
operator|&
name|sc
operator|->
name|rx_big
operator|.
name|extra_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Err %d extra rx_big dmamap\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
goto|goto
name|abort_with_alloc
goto|;
block|}
return|return
literal|0
return|;
name|abort_with_alloc
label|:
name|mxge_free_rings
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|abort_with_nothing
label|:
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mxge_open
parameter_list|(
name|mxge_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|mxge_cmd_t
name|cmd
decl_stmt|;
name|int
name|i
decl_stmt|,
name|err
decl_stmt|;
name|bus_dmamap_t
name|map
decl_stmt|;
name|bus_addr_t
name|bus
decl_stmt|;
comment|/* Copy the MAC address in case it was overridden */
name|bcopy
argument_list|(
name|IF_LLADDR
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
argument_list|,
name|sc
operator|->
name|mac_addr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|err
operator|=
name|mxge_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to reset\n"
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
block|}
if|if
condition|(
name|MCLBYTES
operator|>=
name|sc
operator|->
name|ifp
operator|->
name|if_mtu
operator|+
name|ETHER_HDR_LEN
operator|+
name|MXGEFW_PAD
condition|)
name|sc
operator|->
name|big_bytes
operator|=
name|MCLBYTES
expr_stmt|;
else|else
name|sc
operator|->
name|big_bytes
operator|=
name|MJUMPAGESIZE
expr_stmt|;
name|err
operator|=
name|mxge_alloc_rings
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to allocate rings\n"
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
name|err
operator|=
name|bus_setup_intr
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|sc
operator|->
name|irq_res
argument_list|,
name|INTR_TYPE_NET
operator||
name|INTR_MPSAFE
argument_list|,
name|mxge_intr
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|ih
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
goto|goto
name|abort_with_rings
goto|;
block|}
comment|/* get the lanai pointers to the send and receive rings */
name|err
operator|=
name|mxge_send_cmd
argument_list|(
name|sc
argument_list|,
name|MXGEFW_CMD_GET_SEND_OFFSET
argument_list|,
operator|&
name|cmd
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tx
operator|.
name|lanai
operator|=
operator|(
specifier|volatile
name|mcp_kreq_ether_send_t
operator|*
operator|)
operator|(
name|sc
operator|->
name|sram
operator|+
name|cmd
operator|.
name|data0
operator|)
expr_stmt|;
name|err
operator||=
name|mxge_send_cmd
argument_list|(
name|sc
argument_list|,
name|MXGEFW_CMD_GET_SMALL_RX_OFFSET
argument_list|,
operator|&
name|cmd
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rx_small
operator|.
name|lanai
operator|=
operator|(
specifier|volatile
name|mcp_kreq_ether_recv_t
operator|*
operator|)
operator|(
name|sc
operator|->
name|sram
operator|+
name|cmd
operator|.
name|data0
operator|)
expr_stmt|;
name|err
operator||=
name|mxge_send_cmd
argument_list|(
name|sc
argument_list|,
name|MXGEFW_CMD_GET_BIG_RX_OFFSET
argument_list|,
operator|&
name|cmd
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rx_big
operator|.
name|lanai
operator|=
operator|(
specifier|volatile
name|mcp_kreq_ether_recv_t
operator|*
operator|)
operator|(
name|sc
operator|->
name|sram
operator|+
name|cmd
operator|.
name|data0
operator|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to get ring sizes or locations\n"
argument_list|)
expr_stmt|;
name|err
operator|=
name|EIO
expr_stmt|;
goto|goto
name|abort_with_irq
goto|;
block|}
if|if
condition|(
name|sc
operator|->
name|wc
condition|)
block|{
name|sc
operator|->
name|tx
operator|.
name|wc_fifo
operator|=
name|sc
operator|->
name|sram
operator|+
name|MXGEFW_ETH_SEND_4
expr_stmt|;
name|sc
operator|->
name|rx_small
operator|.
name|wc_fifo
operator|=
name|sc
operator|->
name|sram
operator|+
name|MXGEFW_ETH_RECV_SMALL
expr_stmt|;
name|sc
operator|->
name|rx_big
operator|.
name|wc_fifo
operator|=
name|sc
operator|->
name|sram
operator|+
name|MXGEFW_ETH_RECV_BIG
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|tx
operator|.
name|wc_fifo
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|rx_small
operator|.
name|wc_fifo
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|rx_big
operator|.
name|wc_fifo
operator|=
literal|0
expr_stmt|;
block|}
comment|/* stock receive rings */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|sc
operator|->
name|rx_small
operator|.
name|mask
condition|;
name|i
operator|++
control|)
block|{
name|map
operator|=
name|sc
operator|->
name|rx_small
operator|.
name|info
index|[
name|i
index|]
operator|.
name|map
expr_stmt|;
name|err
operator|=
name|mxge_get_buf_small
argument_list|(
name|sc
argument_list|,
name|map
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"alloced %d/%d smalls\n"
argument_list|,
name|i
argument_list|,
name|sc
operator|->
name|rx_small
operator|.
name|mask
operator|+
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|abort
goto|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|sc
operator|->
name|rx_big
operator|.
name|mask
condition|;
name|i
operator|++
control|)
block|{
name|map
operator|=
name|sc
operator|->
name|rx_big
operator|.
name|info
index|[
name|i
index|]
operator|.
name|map
expr_stmt|;
name|err
operator|=
name|mxge_get_buf_big
argument_list|(
name|sc
argument_list|,
name|map
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"alloced %d/%d bigs\n"
argument_list|,
name|i
argument_list|,
name|sc
operator|->
name|rx_big
operator|.
name|mask
operator|+
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|abort
goto|;
block|}
block|}
comment|/* Give the firmware the mtu and the big and small buffer 	   sizes.  The firmware wants the big buf size to be a power 	   of two. Luckily, FreeBSD's clusters are powers of two */
name|cmd
operator|.
name|data0
operator|=
name|sc
operator|->
name|ifp
operator|->
name|if_mtu
operator|+
name|ETHER_HDR_LEN
expr_stmt|;
name|err
operator|=
name|mxge_send_cmd
argument_list|(
name|sc
argument_list|,
name|MXGEFW_CMD_SET_MTU
argument_list|,
operator|&
name|cmd
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|data0
operator|=
name|MHLEN
operator|-
name|MXGEFW_PAD
expr_stmt|;
name|err
operator||=
name|mxge_send_cmd
argument_list|(
name|sc
argument_list|,
name|MXGEFW_CMD_SET_SMALL_BUFFER_SIZE
argument_list|,
operator|&
name|cmd
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|data0
operator|=
name|sc
operator|->
name|big_bytes
expr_stmt|;
name|err
operator||=
name|mxge_send_cmd
argument_list|(
name|sc
argument_list|,
name|MXGEFW_CMD_SET_BIG_BUFFER_SIZE
argument_list|,
operator|&
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to setup params\n"
argument_list|)
expr_stmt|;
goto|goto
name|abort
goto|;
block|}
comment|/* Now give him the pointer to the stats block */
name|cmd
operator|.
name|data0
operator|=
name|MXGE_LOWPART_TO_U32
argument_list|(
name|sc
operator|->
name|fw_stats_dma
operator|.
name|bus_addr
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|data1
operator|=
name|MXGE_HIGHPART_TO_U32
argument_list|(
name|sc
operator|->
name|fw_stats_dma
operator|.
name|bus_addr
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|data2
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|mcp_irq_data
argument_list|)
expr_stmt|;
name|err
operator|=
name|mxge_send_cmd
argument_list|(
name|sc
argument_list|,
name|MXGEFW_CMD_SET_STATS_DMA_V2
argument_list|,
operator|&
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|bus
operator|=
name|sc
operator|->
name|fw_stats_dma
operator|.
name|bus_addr
expr_stmt|;
name|bus
operator|+=
name|offsetof
argument_list|(
expr|struct
name|mcp_irq_data
argument_list|,
name|send_done_count
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|data0
operator|=
name|MXGE_LOWPART_TO_U32
argument_list|(
name|bus
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|data1
operator|=
name|MXGE_HIGHPART_TO_U32
argument_list|(
name|bus
argument_list|)
expr_stmt|;
name|err
operator|=
name|mxge_send_cmd
argument_list|(
name|sc
argument_list|,
name|MXGEFW_CMD_SET_STATS_DMA_OBSOLETE
argument_list|,
operator|&
name|cmd
argument_list|)
expr_stmt|;
comment|/* Firmware cannot support multicast without STATS_DMA_V2 */
name|sc
operator|->
name|fw_multicast_support
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|fw_multicast_support
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to setup params\n"
argument_list|)
expr_stmt|;
goto|goto
name|abort
goto|;
block|}
comment|/* Finally, start the firmware running */
name|err
operator|=
name|mxge_send_cmd
argument_list|(
name|sc
argument_list|,
name|MXGEFW_CMD_ETHERNET_UP
argument_list|,
operator|&
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Couldn't bring up link\n"
argument_list|)
expr_stmt|;
goto|goto
name|abort
goto|;
block|}
name|sc
operator|->
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_RUNNING
expr_stmt|;
name|sc
operator|->
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
return|return
literal|0
return|;
name|abort
label|:
name|mxge_free_mbufs
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|abort_with_irq
label|:
name|bus_teardown_intr
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|sc
operator|->
name|irq_res
argument_list|,
name|sc
operator|->
name|ih
argument_list|)
expr_stmt|;
name|abort_with_rings
label|:
name|mxge_free_rings
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mxge_close
parameter_list|(
name|mxge_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|mxge_cmd_t
name|cmd
decl_stmt|;
name|int
name|err
decl_stmt|,
name|old_down_cnt
decl_stmt|;
name|sc
operator|->
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_RUNNING
expr_stmt|;
name|old_down_cnt
operator|=
name|sc
operator|->
name|down_cnt
expr_stmt|;
name|mb
argument_list|()
expr_stmt|;
name|err
operator|=
name|mxge_send_cmd
argument_list|(
name|sc
argument_list|,
name|MXGEFW_CMD_ETHERNET_DOWN
argument_list|,
operator|&
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Couldn't bring down link\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|old_down_cnt
operator|==
name|sc
operator|->
name|down_cnt
condition|)
block|{
comment|/* wait for down irq */
operator|(
name|void
operator|)
name|tsleep
argument_list|(
operator|&
name|sc
operator|->
name|down_cnt
argument_list|,
name|PWAIT
argument_list|,
literal|"down mxge"
argument_list|,
name|hz
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|old_down_cnt
operator|==
name|sc
operator|->
name|down_cnt
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"never got down irq\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|ih
operator|!=
name|NULL
condition|)
name|bus_teardown_intr
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|sc
operator|->
name|irq_res
argument_list|,
name|sc
operator|->
name|ih
argument_list|)
expr_stmt|;
name|mxge_free_mbufs
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mxge_free_rings
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mxge_media_change
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
return|return
name|EINVAL
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mxge_change_mtu
parameter_list|(
name|mxge_softc_t
modifier|*
name|sc
parameter_list|,
name|int
name|mtu
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|ifp
decl_stmt|;
name|int
name|real_mtu
decl_stmt|,
name|old_mtu
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|real_mtu
operator|=
name|mtu
operator|+
name|ETHER_HDR_LEN
expr_stmt|;
if|if
condition|(
operator|(
name|real_mtu
operator|>
name|MXGE_MAX_ETHER_MTU
operator|)
operator|||
name|real_mtu
operator|<
literal|60
condition|)
return|return
name|EINVAL
return|;
name|sx_xlock
argument_list|(
operator|&
name|sc
operator|->
name|driver_lock
argument_list|)
expr_stmt|;
name|old_mtu
operator|=
name|ifp
operator|->
name|if_mtu
expr_stmt|;
name|ifp
operator|->
name|if_mtu
operator|=
name|mtu
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|mxge_close
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|err
operator|=
name|mxge_open
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|ifp
operator|->
name|if_mtu
operator|=
name|old_mtu
expr_stmt|;
name|mxge_close
argument_list|(
name|sc
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|mxge_open
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
name|sx_xunlock
argument_list|(
operator|&
name|sc
operator|->
name|driver_lock
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mxge_media_status
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|ifmediareq
modifier|*
name|ifmr
parameter_list|)
block|{
name|mxge_softc_t
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return;
name|ifmr
operator|->
name|ifm_status
operator|=
name|IFM_AVALID
expr_stmt|;
name|ifmr
operator|->
name|ifm_status
operator||=
name|sc
operator|->
name|fw_stats
operator|->
name|link_up
condition|?
name|IFM_ACTIVE
else|:
literal|0
expr_stmt|;
name|ifmr
operator|->
name|ifm_active
operator|=
name|IFM_AUTO
operator||
name|IFM_ETHER
expr_stmt|;
name|ifmr
operator|->
name|ifm_active
operator||=
name|sc
operator|->
name|fw_stats
operator|->
name|link_up
condition|?
name|IFM_FDX
else|:
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|mxge_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|command
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|mxge_softc_t
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
name|int
name|err
decl_stmt|,
name|mask
decl_stmt|;
name|err
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|command
condition|)
block|{
case|case
name|SIOCSIFADDR
case|:
case|case
name|SIOCGIFADDR
case|:
name|err
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|command
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFMTU
case|:
name|err
operator|=
name|mxge_change_mtu
argument_list|(
name|sc
argument_list|,
name|ifr
operator|->
name|ifr_mtu
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFFLAGS
case|:
name|sx_xlock
argument_list|(
operator|&
name|sc
operator|->
name|driver_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
name|err
operator|=
name|mxge_open
argument_list|(
name|sc
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* take care of promis can allmulti 				   flag chages */
name|mxge_change_promisc
argument_list|(
name|sc
argument_list|,
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
argument_list|)
expr_stmt|;
name|mxge_set_multicast_list
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
name|mxge_close
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|sx_xunlock
argument_list|(
operator|&
name|sc
operator|->
name|driver_lock
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
name|sx_xlock
argument_list|(
operator|&
name|sc
operator|->
name|driver_lock
argument_list|)
expr_stmt|;
name|mxge_set_multicast_list
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|sc
operator|->
name|driver_lock
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFCAP
case|:
name|sx_xlock
argument_list|(
operator|&
name|sc
operator|->
name|driver_lock
argument_list|)
expr_stmt|;
name|mask
operator|=
name|ifr
operator|->
name|ifr_reqcap
operator|^
name|ifp
operator|->
name|if_capenable
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IFCAP_TXCSUM
condition|)
block|{
if|if
condition|(
name|IFCAP_TXCSUM
operator|&
name|ifp
operator|->
name|if_capenable
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|&=
operator|~
operator|(
name|IFCAP_TXCSUM
operator||
name|IFCAP_TSO4
operator|)
expr_stmt|;
name|ifp
operator|->
name|if_hwassist
operator|&=
operator|~
operator|(
name|CSUM_TCP
operator||
name|CSUM_UDP
operator||
name|CSUM_TSO
operator|)
expr_stmt|;
block|}
else|else
block|{
name|ifp
operator|->
name|if_capenable
operator||=
name|IFCAP_TXCSUM
expr_stmt|;
name|ifp
operator|->
name|if_hwassist
operator||=
operator|(
name|CSUM_TCP
operator||
name|CSUM_UDP
operator|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|mask
operator|&
name|IFCAP_RXCSUM
condition|)
block|{
if|if
condition|(
name|IFCAP_RXCSUM
operator|&
name|ifp
operator|->
name|if_capenable
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|&=
operator|~
name|IFCAP_RXCSUM
expr_stmt|;
name|sc
operator|->
name|csum_flag
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|ifp
operator|->
name|if_capenable
operator||=
name|IFCAP_RXCSUM
expr_stmt|;
name|sc
operator|->
name|csum_flag
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mask
operator|&
name|IFCAP_TSO4
condition|)
block|{
if|if
condition|(
name|IFCAP_TSO4
operator|&
name|ifp
operator|->
name|if_capenable
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|&=
operator|~
name|IFCAP_TSO4
expr_stmt|;
name|ifp
operator|->
name|if_hwassist
operator|&=
operator|~
name|CSUM_TSO
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IFCAP_TXCSUM
operator|&
name|ifp
operator|->
name|if_capenable
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator||=
name|IFCAP_TSO4
expr_stmt|;
name|ifp
operator|->
name|if_hwassist
operator||=
name|CSUM_TSO
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"mxge requires tx checksum offload"
literal|" be enabled to use TSO\n"
argument_list|)
expr_stmt|;
name|err
operator|=
name|EINVAL
expr_stmt|;
block|}
block|}
name|sx_xunlock
argument_list|(
operator|&
name|sc
operator|->
name|driver_lock
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCGIFMEDIA
case|:
name|err
operator|=
name|ifmedia_ioctl
argument_list|(
name|ifp
argument_list|,
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
argument_list|,
operator|&
name|sc
operator|->
name|media
argument_list|,
name|command
argument_list|)
expr_stmt|;
break|break;
default|default:
name|err
operator|=
name|ENOTTY
expr_stmt|;
block|}
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mxge_fetch_tunables
parameter_list|(
name|mxge_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|TUNABLE_INT_FETCH
argument_list|(
literal|"hw.mxge.flow_control_enabled"
argument_list|,
operator|&
name|mxge_flow_control
argument_list|)
expr_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
literal|"hw.mxge.intr_coal_delay"
argument_list|,
operator|&
name|mxge_intr_coal_delay
argument_list|)
expr_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
literal|"hw.mxge.nvidia_ecrc_enable"
argument_list|,
operator|&
name|mxge_nvidia_ecrc_enable
argument_list|)
expr_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
literal|"hw.mxge.force_firmware"
argument_list|,
operator|&
name|mxge_force_firmware
argument_list|)
expr_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
literal|"hw.mxge.deassert_wait"
argument_list|,
operator|&
name|mxge_deassert_wait
argument_list|)
expr_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
literal|"hw.mxge.verbose"
argument_list|,
operator|&
name|mxge_verbose
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|mxge_verbose
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|mxge_intr_coal_delay
operator|<
literal|0
operator|||
name|mxge_intr_coal_delay
operator|>
literal|10
operator|*
literal|1000
condition|)
name|mxge_intr_coal_delay
operator|=
literal|30
expr_stmt|;
name|sc
operator|->
name|pause
operator|=
name|mxge_flow_control
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|mxge_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|mxge_softc_t
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|size_t
name|bytes
decl_stmt|;
name|int
name|count
decl_stmt|,
name|rid
decl_stmt|,
name|err
decl_stmt|,
name|reg
decl_stmt|;
name|uint16_t
name|cmd
decl_stmt|,
name|pectl
decl_stmt|,
name|lnk
decl_stmt|;
name|sc
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|mxge_fetch_tunables
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|err
operator|=
name|bus_dma_tag_create
argument_list|(
name|NULL
argument_list|,
comment|/* parent */
literal|1
argument_list|,
comment|/* alignment */
literal|4096
argument_list|,
comment|/* boundary */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* low */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* high */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter */
literal|65536
operator|+
literal|256
argument_list|,
comment|/* maxsize */
name|MXGE_MAX_SEND_DESC
argument_list|,
comment|/* num segs */
literal|4096
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* lock */
operator|&
name|sc
operator|->
name|parent_dmat
argument_list|)
expr_stmt|;
comment|/* tag */
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Err %d allocating parent dmat\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
goto|goto
name|abort_with_nothing
goto|;
block|}
name|ifp
operator|=
name|sc
operator|->
name|ifp
operator|=
name|if_alloc
argument_list|(
name|IFT_ETHER
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"can not if_alloc()\n"
argument_list|)
expr_stmt|;
name|err
operator|=
name|ENOSPC
expr_stmt|;
goto|goto
name|abort_with_parent_dmat
goto|;
block|}
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|cmd_lock
argument_list|,
name|NULL
argument_list|,
name|MTX_NETWORK_LOCK
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|tx_lock
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|,
name|MTX_NETWORK_LOCK
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|sx_init
argument_list|(
operator|&
name|sc
operator|->
name|driver_lock
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
comment|/* find the PCIe link width and set max read request to 4KB*/
if|if
condition|(
name|pci_find_extcap
argument_list|(
name|dev
argument_list|,
name|PCIY_EXPRESS
argument_list|,
operator|&
name|reg
argument_list|)
operator|==
literal|0
condition|)
block|{
name|lnk
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|reg
operator|+
literal|0x12
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|sc
operator|->
name|link_width
operator|=
operator|(
name|lnk
operator|>>
literal|4
operator|)
operator|&
literal|0x3f
expr_stmt|;
name|pectl
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|reg
operator|+
literal|0x8
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|pectl
operator|=
operator|(
name|pectl
operator|&
operator|~
literal|0x7000
operator|)
operator||
operator|(
literal|5
operator|<<
literal|12
operator|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|reg
operator|+
literal|0x8
argument_list|,
name|pectl
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
comment|/* Enable DMA and Memory space access */
name|pci_enable_busmaster
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|cmd
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|cmd
operator||=
name|PCIM_CMD_MEMEN
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
name|cmd
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Map the board into the kernel */
name|rid
operator|=
name|PCIR_BARS
expr_stmt|;
name|sc
operator|->
name|mem_res
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
literal|1
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mem_res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not map memory\n"
argument_list|)
expr_stmt|;
name|err
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|abort_with_lock
goto|;
block|}
name|sc
operator|->
name|sram
operator|=
name|rman_get_virtual
argument_list|(
name|sc
operator|->
name|mem_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sram_size
operator|=
literal|2
operator|*
literal|1024
operator|*
literal|1024
operator|-
operator|(
literal|2
operator|*
operator|(
literal|48
operator|*
literal|1024
operator|)
operator|+
operator|(
literal|32
operator|*
literal|1024
operator|)
operator|)
operator|-
literal|0x100
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sram_size
operator|>
name|rman_get_size
argument_list|(
name|sc
operator|->
name|mem_res
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"impossible memory region size %ld\n"
argument_list|,
name|rman_get_size
argument_list|(
name|sc
operator|->
name|mem_res
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|abort_with_mem_res
goto|;
block|}
comment|/* make NULL terminated copy of the EEPROM strings section of 	   lanai SRAM */
name|bzero
argument_list|(
name|sc
operator|->
name|eeprom_strings
argument_list|,
name|MXGE_EEPROM_STRINGS_SIZE
argument_list|)
expr_stmt|;
name|bus_space_read_region_1
argument_list|(
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|mem_res
argument_list|)
argument_list|,
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|mem_res
argument_list|)
argument_list|,
name|sc
operator|->
name|sram_size
operator|-
name|MXGE_EEPROM_STRINGS_SIZE
argument_list|,
name|sc
operator|->
name|eeprom_strings
argument_list|,
name|MXGE_EEPROM_STRINGS_SIZE
operator|-
literal|2
argument_list|)
expr_stmt|;
name|err
operator|=
name|mxge_parse_strings
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
goto|goto
name|abort_with_mem_res
goto|;
comment|/* Enable write combining for efficient use of PCIe bus */
name|mxge_enable_wc
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Allocate the out of band dma memory */
name|err
operator|=
name|mxge_dma_alloc
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|cmd_dma
argument_list|,
sizeof|sizeof
argument_list|(
name|mxge_cmd_t
argument_list|)
argument_list|,
literal|64
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
goto|goto
name|abort_with_mem_res
goto|;
name|sc
operator|->
name|cmd
operator|=
operator|(
name|mcp_cmd_response_t
operator|*
operator|)
name|sc
operator|->
name|cmd_dma
operator|.
name|addr
expr_stmt|;
name|err
operator|=
name|mxge_dma_alloc
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|zeropad_dma
argument_list|,
literal|64
argument_list|,
literal|64
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
goto|goto
name|abort_with_cmd_dma
goto|;
name|err
operator|=
name|mxge_dma_alloc
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|fw_stats_dma
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sc
operator|->
name|fw_stats
argument_list|)
argument_list|,
literal|64
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
goto|goto
name|abort_with_zeropad_dma
goto|;
name|sc
operator|->
name|fw_stats
operator|=
operator|(
name|mcp_irq_data_t
operator|*
operator|)
name|sc
operator|->
name|fw_stats_dma
operator|.
name|addr
expr_stmt|;
comment|/* allocate interrupt queues */
name|bytes
operator|=
name|mxge_max_intr_slots
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|sc
operator|->
name|rx_done
operator|.
name|entry
argument_list|)
expr_stmt|;
name|err
operator|=
name|mxge_dma_alloc
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|rx_done
operator|.
name|dma
argument_list|,
name|bytes
argument_list|,
literal|4096
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
goto|goto
name|abort_with_fw_stats
goto|;
name|sc
operator|->
name|rx_done
operator|.
name|entry
operator|=
name|sc
operator|->
name|rx_done
operator|.
name|dma
operator|.
name|addr
expr_stmt|;
name|bzero
argument_list|(
name|sc
operator|->
name|rx_done
operator|.
name|entry
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
comment|/* Add our ithread  */
name|count
operator|=
name|pci_msi_count
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|1
operator|&&
name|pci_alloc_msi
argument_list|(
name|dev
argument_list|,
operator|&
name|count
argument_list|)
operator|==
literal|0
condition|)
block|{
name|rid
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|msi_enabled
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|rid
operator|=
literal|0
expr_stmt|;
block|}
name|sc
operator|->
name|irq_res
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
literal|1
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|irq_res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not alloc interrupt\n"
argument_list|)
expr_stmt|;
goto|goto
name|abort_with_rx_done
goto|;
block|}
if|if
condition|(
name|mxge_verbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"using %s irq %ld\n"
argument_list|,
name|sc
operator|->
name|msi_enabled
condition|?
literal|"MSI"
else|:
literal|"INTx"
argument_list|,
name|rman_get_start
argument_list|(
name|sc
operator|->
name|irq_res
argument_list|)
argument_list|)
expr_stmt|;
comment|/* load the firmware */
name|mxge_select_firmware
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|err
operator|=
name|mxge_load_firmware
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
goto|goto
name|abort_with_irq_res
goto|;
name|sc
operator|->
name|intr_coal_delay
operator|=
name|mxge_intr_coal_delay
expr_stmt|;
name|err
operator|=
name|mxge_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
goto|goto
name|abort_with_irq_res
goto|;
comment|/* hook into the network stack */
name|if_initname
argument_list|(
name|ifp
argument_list|,
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_baudrate
operator|=
literal|100000000
expr_stmt|;
name|ifp
operator|->
name|if_capabilities
operator|=
name|IFCAP_RXCSUM
operator||
name|IFCAP_TXCSUM
operator||
name|IFCAP_TSO4
operator||
name|IFCAP_JUMBO_MTU
expr_stmt|;
name|ifp
operator|->
name|if_hwassist
operator|=
name|CSUM_TCP
operator||
name|CSUM_UDP
operator||
name|CSUM_TSO
expr_stmt|;
name|ifp
operator|->
name|if_capenable
operator|=
name|ifp
operator|->
name|if_capabilities
expr_stmt|;
name|sc
operator|->
name|csum_flag
operator|=
literal|1
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|mxge_init
expr_stmt|;
name|ifp
operator|->
name|if_softc
operator|=
name|sc
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|mxge_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|mxge_start
expr_stmt|;
name|ifp
operator|->
name|if_watchdog
operator|=
name|mxge_watchdog
expr_stmt|;
name|ether_ifattach
argument_list|(
name|ifp
argument_list|,
name|sc
operator|->
name|mac_addr
argument_list|)
expr_stmt|;
comment|/* ether_ifattach sets mtu to 1500 */
name|ifp
operator|->
name|if_mtu
operator|=
name|MXGE_MAX_ETHER_MTU
operator|-
name|ETHER_HDR_LEN
expr_stmt|;
comment|/* Initialise the ifmedia structure */
name|ifmedia_init
argument_list|(
operator|&
name|sc
operator|->
name|media
argument_list|,
literal|0
argument_list|,
name|mxge_media_change
argument_list|,
name|mxge_media_status
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|sc
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_AUTO
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mxge_add_sysctls
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|abort_with_irq_res
label|:
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|sc
operator|->
name|msi_enabled
condition|?
literal|1
else|:
literal|0
argument_list|,
name|sc
operator|->
name|irq_res
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|msi_enabled
condition|)
name|pci_release_msi
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|abort_with_rx_done
label|:
name|sc
operator|->
name|rx_done
operator|.
name|entry
operator|=
name|NULL
expr_stmt|;
name|mxge_dma_free
argument_list|(
operator|&
name|sc
operator|->
name|rx_done
operator|.
name|dma
argument_list|)
expr_stmt|;
name|abort_with_fw_stats
label|:
name|mxge_dma_free
argument_list|(
operator|&
name|sc
operator|->
name|fw_stats_dma
argument_list|)
expr_stmt|;
name|abort_with_zeropad_dma
label|:
name|mxge_dma_free
argument_list|(
operator|&
name|sc
operator|->
name|zeropad_dma
argument_list|)
expr_stmt|;
name|abort_with_cmd_dma
label|:
name|mxge_dma_free
argument_list|(
operator|&
name|sc
operator|->
name|cmd_dma
argument_list|)
expr_stmt|;
name|abort_with_mem_res
label|:
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|PCIR_BARS
argument_list|,
name|sc
operator|->
name|mem_res
argument_list|)
expr_stmt|;
name|abort_with_lock
label|:
name|pci_disable_busmaster
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|cmd_lock
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|tx_lock
argument_list|)
expr_stmt|;
name|sx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|driver_lock
argument_list|)
expr_stmt|;
name|if_free
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|abort_with_parent_dmat
label|:
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|parent_dmat
argument_list|)
expr_stmt|;
name|abort_with_nothing
label|:
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mxge_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|mxge_softc_t
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|sc
operator|->
name|driver_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
name|mxge_close
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|sc
operator|->
name|driver_lock
argument_list|)
expr_stmt|;
name|ether_ifdetach
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
expr_stmt|;
name|mxge_dummy_rdma
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|sc
operator|->
name|msi_enabled
condition|?
literal|1
else|:
literal|0
argument_list|,
name|sc
operator|->
name|irq_res
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|msi_enabled
condition|)
name|pci_release_msi
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rx_done
operator|.
name|entry
operator|=
name|NULL
expr_stmt|;
name|mxge_dma_free
argument_list|(
operator|&
name|sc
operator|->
name|rx_done
operator|.
name|dma
argument_list|)
expr_stmt|;
name|mxge_dma_free
argument_list|(
operator|&
name|sc
operator|->
name|fw_stats_dma
argument_list|)
expr_stmt|;
name|mxge_dma_free
argument_list|(
operator|&
name|sc
operator|->
name|zeropad_dma
argument_list|)
expr_stmt|;
name|mxge_dma_free
argument_list|(
operator|&
name|sc
operator|->
name|cmd_dma
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|PCIR_BARS
argument_list|,
name|sc
operator|->
name|mem_res
argument_list|)
expr_stmt|;
name|pci_disable_busmaster
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|cmd_lock
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|tx_lock
argument_list|)
expr_stmt|;
name|sx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|driver_lock
argument_list|)
expr_stmt|;
name|if_free
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|parent_dmat
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mxge_shutdown
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*   This file uses Myri10GE driver indentation.    Local Variables:   c-file-style:"linux"   tab-width:8   End: */
end_comment

end_unit

